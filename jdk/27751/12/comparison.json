{"files":[{"patch":"@@ -28,1 +28,0 @@\n-test\/benchmarks\/**\/target\n","filename":".gitignore","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -453,1 +453,1 @@\n-performance. Defaults to 4.<\/p>\n+performance. Defaults to 1.<\/p>\n","filename":"doc\/testing.html","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -390,1 +390,1 @@\n-adjust this factor to compensate for less performance. Defaults to 4.\n+adjust this factor to compensate for less performance. Defaults to 1.\n","filename":"doc\/testing.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -949,2 +949,2 @@\n-  # Please reach consensus before changing this.\n-  JTREG_AUTO_TIMEOUT_FACTOR := 4\n+  # Please reach consensus before changing this. It was not easy changing it to a `1`.\n+  JTREG_AUTO_TIMEOUT_FACTOR := 1\n","filename":"make\/RunTests.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-LINUX_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk25\/bd75d5f9689641da8e1daabeccb5528b\/36\/GPL\/openjdk-25_linux-x64_bin.tar.gz\n-LINUX_X64_BOOT_JDK_SHA256=59cdcaf255add4721de38eb411d4ecfe779356b61fb671aee63c7dec78054c2b\n+LINUX_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk24\/1f9ff9062db4449d8ca828c504ffae90\/36\/GPL\/openjdk-24_linux-x64_bin.tar.gz\n+LINUX_X64_BOOT_JDK_SHA256=88b090fa80c6c1d084ec9a755233967458788e2c0777ae2e172230c5c692d7ef\n@@ -36,2 +36,2 @@\n-ALPINE_LINUX_X64_BOOT_JDK_URL=https:\/\/github.com\/adoptium\/temurin25-binaries\/releases\/download\/jdk-25%2B36\/OpenJDK25U-jdk_x64_alpine-linux_hotspot_25_36.tar.gz\n-ALPINE_LINUX_X64_BOOT_JDK_SHA256=637e47474d411ed86134f413af7d5fef4180ddb0bf556347b7e74a88cf8904c8\n+ALPINE_LINUX_X64_BOOT_JDK_URL=https:\/\/github.com\/adoptium\/temurin24-binaries\/releases\/download\/jdk-24%2B36\/OpenJDK24U-jdk_x64_alpine-linux_hotspot_24_36.tar.gz\n+ALPINE_LINUX_X64_BOOT_JDK_SHA256=a642608f0da78344ee6812fb1490b8bc1d7ad5a18064c70994d6f330568c51cb\n@@ -40,2 +40,2 @@\n-MACOS_AARCH64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk25\/bd75d5f9689641da8e1daabeccb5528b\/36\/GPL\/openjdk-25_macos-aarch64_bin.tar.gz\n-MACOS_AARCH64_BOOT_JDK_SHA256=2006337bf326fdfdf6117081751ba38c1c8706d63419ecac7ff102ff7c776876\n+MACOS_AARCH64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk24\/1f9ff9062db4449d8ca828c504ffae90\/36\/GPL\/openjdk-24_macos-aarch64_bin.tar.gz\n+MACOS_AARCH64_BOOT_JDK_SHA256=f7133238a12714a62c5ad2bd4da6741130be1a82512065da9ca23dee26b2d3d3\n@@ -44,2 +44,2 @@\n-MACOS_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk25\/bd75d5f9689641da8e1daabeccb5528b\/36\/GPL\/openjdk-25_macos-x64_bin.tar.gz\n-MACOS_X64_BOOT_JDK_SHA256=47482ad9888991ecac9b2bcc131e2b53ff78aff275104cef85f66252308e8a09\n+MACOS_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk24\/1f9ff9062db4449d8ca828c504ffae90\/36\/GPL\/openjdk-24_macos-x64_bin.tar.gz\n+MACOS_X64_BOOT_JDK_SHA256=6bbfb1d01741cbe55ab90299cb91464b695de9a3ace85c15131aa2f50292f321\n@@ -48,2 +48,2 @@\n-WINDOWS_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk25\/bd75d5f9689641da8e1daabeccb5528b\/36\/GPL\/openjdk-25_windows-x64_bin.zip\n-WINDOWS_X64_BOOT_JDK_SHA256=85bcc178461e2cb3c549ab9ca9dfa73afd54c09a175d6510d0884071867137d3\n+WINDOWS_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk24\/1f9ff9062db4449d8ca828c504ffae90\/36\/GPL\/openjdk-24_windows-x64_bin.zip\n+WINDOWS_X64_BOOT_JDK_SHA256=11d1d9f6ac272d5361c8a0bef01894364081c7fb1a6914c2ad2fc312ae83d63b\n","filename":"make\/conf\/github-actions.conf","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -390,2 +390,2 @@\n-    common.boot_jdk_version = \"25\";\n-    common.boot_jdk_build_number = \"37\";\n+    common.boot_jdk_version = \"24\";\n+    common.boot_jdk_build_number = \"36\";\n","filename":"make\/conf\/jib-profiles.js","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"25 26\"\n+DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"24 25 26\"\n","filename":"make\/conf\/version-numbers.conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1269,2 +1269,2 @@\n-    _ANY_REG32_mask.assignFrom(_ALL_REG32_mask);\n-    _ANY_REG32_mask.remove(OptoReg::as_OptoReg(r31_sp->as_VMReg()));\n+    _ANY_REG32_mask = _ALL_REG32_mask;\n+    _ANY_REG32_mask.Remove(OptoReg::as_OptoReg(r31_sp->as_VMReg()));\n@@ -1272,1 +1272,1 @@\n-    _ANY_REG_mask.assignFrom(_ALL_REG_mask);\n+    _ANY_REG_mask = _ALL_REG_mask;\n@@ -1274,1 +1274,1 @@\n-    _PTR_REG_mask.assignFrom(_ALL_REG_mask);\n+    _PTR_REG_mask = _ALL_REG_mask;\n@@ -1276,2 +1276,2 @@\n-    _NO_SPECIAL_REG32_mask.assignFrom(_ALL_REG32_mask);\n-    _NO_SPECIAL_REG32_mask.subtract(_NON_ALLOCATABLE_REG32_mask);\n+    _NO_SPECIAL_REG32_mask = _ALL_REG32_mask;\n+    _NO_SPECIAL_REG32_mask.SUBTRACT(_NON_ALLOCATABLE_REG32_mask);\n@@ -1279,2 +1279,2 @@\n-    _NO_SPECIAL_REG_mask.assignFrom(_ALL_REG_mask);\n-    _NO_SPECIAL_REG_mask.subtract(_NON_ALLOCATABLE_REG_mask);\n+    _NO_SPECIAL_REG_mask = _ALL_REG_mask;\n+    _NO_SPECIAL_REG_mask.SUBTRACT(_NON_ALLOCATABLE_REG_mask);\n@@ -1282,2 +1282,2 @@\n-    _NO_SPECIAL_PTR_REG_mask.assignFrom(_ALL_REG_mask);\n-    _NO_SPECIAL_PTR_REG_mask.subtract(_NON_ALLOCATABLE_REG_mask);\n+    _NO_SPECIAL_PTR_REG_mask = _ALL_REG_mask;\n+    _NO_SPECIAL_PTR_REG_mask.SUBTRACT(_NON_ALLOCATABLE_REG_mask);\n@@ -1288,3 +1288,3 @@\n-      _NO_SPECIAL_REG32_mask.remove(OptoReg::as_OptoReg(r27->as_VMReg()));\n-      _NO_SPECIAL_REG_mask.remove(OptoReg::as_OptoReg(r27->as_VMReg()));\n-      _NO_SPECIAL_PTR_REG_mask.remove(OptoReg::as_OptoReg(r27->as_VMReg()));\n+      _NO_SPECIAL_REG32_mask.Remove(OptoReg::as_OptoReg(r27->as_VMReg()));\n+      _NO_SPECIAL_REG_mask.Remove(OptoReg::as_OptoReg(r27->as_VMReg()));\n+      _NO_SPECIAL_PTR_REG_mask.Remove(OptoReg::as_OptoReg(r27->as_VMReg()));\n@@ -1295,3 +1295,3 @@\n-      _NO_SPECIAL_REG32_mask.remove(OptoReg::as_OptoReg(r29->as_VMReg()));\n-      _NO_SPECIAL_REG_mask.remove(OptoReg::as_OptoReg(r29->as_VMReg()));\n-      _NO_SPECIAL_PTR_REG_mask.remove(OptoReg::as_OptoReg(r29->as_VMReg()));\n+      _NO_SPECIAL_REG32_mask.Remove(OptoReg::as_OptoReg(r29->as_VMReg()));\n+      _NO_SPECIAL_REG_mask.Remove(OptoReg::as_OptoReg(r29->as_VMReg()));\n+      _NO_SPECIAL_PTR_REG_mask.Remove(OptoReg::as_OptoReg(r29->as_VMReg()));\n@@ -1300,2 +1300,2 @@\n-    _NO_SPECIAL_NO_RFP_PTR_REG_mask.assignFrom(_NO_SPECIAL_PTR_REG_mask);\n-    _NO_SPECIAL_NO_RFP_PTR_REG_mask.remove(OptoReg::as_OptoReg(r29->as_VMReg()));\n+    _NO_SPECIAL_NO_RFP_PTR_REG_mask = _NO_SPECIAL_PTR_REG_mask;\n+    _NO_SPECIAL_NO_RFP_PTR_REG_mask.Remove(OptoReg::as_OptoReg(r29->as_VMReg()));\n@@ -1737,1 +1737,1 @@\n-const RegMask& MachConstantBaseNode::_out_RegMask = RegMask::EMPTY;\n+const RegMask& MachConstantBaseNode::_out_RegMask = RegMask::Empty;\n@@ -2523,1 +2523,1 @@\n-  \/\/ (_NO_SPECIAL_REG32_mask.size() minus 1) forces CallNode to become\n+  \/\/ (_NO_SPECIAL_REG32_mask.Size() minus 1) forces CallNode to become\n@@ -2526,1 +2526,1 @@\n-  uint default_int_pressure_threshold = _NO_SPECIAL_REG32_mask.size() - 1;\n+  uint default_int_pressure_threshold = _NO_SPECIAL_REG32_mask.Size() - 1;\n@@ -2541,1 +2541,1 @@\n-  return (FLOATPRESSURE == -1) ? _FLOAT_REG_mask.size() : FLOATPRESSURE;\n+  return (FLOATPRESSURE == -1) ? _FLOAT_REG_mask.Size() : FLOATPRESSURE;\n@@ -2548,1 +2548,1 @@\n-const RegMask& Matcher::divI_proj_mask() {\n+RegMask Matcher::divI_proj_mask() {\n@@ -2550,1 +2550,1 @@\n-  return RegMask::EMPTY;\n+  return RegMask();\n@@ -2554,1 +2554,1 @@\n-const RegMask& Matcher::modI_proj_mask() {\n+RegMask Matcher::modI_proj_mask() {\n@@ -2556,1 +2556,1 @@\n-  return RegMask::EMPTY;\n+  return RegMask();\n@@ -2560,1 +2560,1 @@\n-const RegMask& Matcher::divL_proj_mask() {\n+RegMask Matcher::divL_proj_mask() {\n@@ -2562,1 +2562,1 @@\n-  return RegMask::EMPTY;\n+  return RegMask();\n@@ -2566,1 +2566,1 @@\n-const RegMask& Matcher::modL_proj_mask() {\n+RegMask Matcher::modL_proj_mask() {\n@@ -2568,1 +2568,1 @@\n-  return RegMask::EMPTY;\n+  return RegMask();\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":30,"deletions":30,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -7084,1 +7084,1 @@\n-                    vReg tmp3, pReg ptmp, pRegGov pgtmp) %{\n+                    vReg tmp3, vReg tmp4, pReg ptmp, pRegGov pgtmp) %{\n@@ -7086,1 +7086,1 @@\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP ptmp, TEMP pgtmp);\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP ptmp, TEMP pgtmp);\n@@ -7088,1 +7088,1 @@\n-  format %{ \"vcompressB $dst, $src, $pg\\t# KILL $tmp1, $tmp2, $tmp3, $ptmp, $pgtmp\" %}\n+  format %{ \"vcompressB $dst, $src, $pg\\t# KILL $tmp1, $tmp2, $tmp3, tmp4, $ptmp, $pgtmp\" %}\n@@ -7090,1 +7090,0 @@\n-    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n@@ -7092,2 +7091,3 @@\n-                         $tmp1$$FloatRegister, $tmp2$$FloatRegister, $tmp3$$FloatRegister,\n-                         $ptmp$$PRegister, $pgtmp$$PRegister, length_in_bytes);\n+                         $tmp1$$FloatRegister,$tmp2$$FloatRegister,\n+                         $tmp3$$FloatRegister,$tmp4$$FloatRegister,\n+                         $ptmp$$PRegister, $pgtmp$$PRegister);\n@@ -7098,1 +7098,2 @@\n-instruct vcompressS(vReg dst, vReg src, pReg pg, vReg tmp1, vReg tmp2, pRegGov pgtmp) %{\n+instruct vcompressS(vReg dst, vReg src, pReg pg,\n+                    vReg tmp1, vReg tmp2, pRegGov pgtmp) %{\n@@ -7104,2 +7105,0 @@\n-    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n-    __ sve_dup($tmp1$$FloatRegister, __ H, 0);\n@@ -7107,2 +7106,1 @@\n-                          $tmp1$$FloatRegister, $tmp2$$FloatRegister, $pgtmp$$PRegister,\n-                          length_in_bytes);\n+                          $tmp1$$FloatRegister,$tmp2$$FloatRegister, $pgtmp$$PRegister);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -5072,1 +5072,1 @@\n-                    vReg tmp3, pReg ptmp, pRegGov pgtmp) %{\n+                    vReg tmp3, vReg tmp4, pReg ptmp, pRegGov pgtmp) %{\n@@ -5074,1 +5074,1 @@\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP ptmp, TEMP pgtmp);\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP ptmp, TEMP pgtmp);\n@@ -5076,1 +5076,1 @@\n-  format %{ \"vcompressB $dst, $src, $pg\\t# KILL $tmp1, $tmp2, $tmp3, $ptmp, $pgtmp\" %}\n+  format %{ \"vcompressB $dst, $src, $pg\\t# KILL $tmp1, $tmp2, $tmp3, tmp4, $ptmp, $pgtmp\" %}\n@@ -5078,1 +5078,0 @@\n-    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n@@ -5080,2 +5079,3 @@\n-                         $tmp1$$FloatRegister, $tmp2$$FloatRegister, $tmp3$$FloatRegister,\n-                         $ptmp$$PRegister, $pgtmp$$PRegister, length_in_bytes);\n+                         $tmp1$$FloatRegister,$tmp2$$FloatRegister,\n+                         $tmp3$$FloatRegister,$tmp4$$FloatRegister,\n+                         $ptmp$$PRegister, $pgtmp$$PRegister);\n@@ -5086,1 +5086,2 @@\n-instruct vcompressS(vReg dst, vReg src, pReg pg, vReg tmp1, vReg tmp2, pRegGov pgtmp) %{\n+instruct vcompressS(vReg dst, vReg src, pReg pg,\n+                    vReg tmp1, vReg tmp2, pRegGov pgtmp) %{\n@@ -5092,2 +5093,0 @@\n-    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n-    __ sve_dup($tmp1$$FloatRegister, __ H, 0);\n@@ -5095,2 +5094,1 @@\n-                          $tmp1$$FloatRegister, $tmp2$$FloatRegister, $pgtmp$$PRegister,\n-                          length_in_bytes);\n+                          $tmp1$$FloatRegister,$tmp2$$FloatRegister, $pgtmp$$PRegister);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -3489,1 +3489,0 @@\n-  INSN(sve_splice,0b00000101, 0b101100100); \/\/ splice two vectors under predicate control, destructive\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2206,1 +2206,1 @@\n-\/\/ Preserves: mask, vzr\n+\/\/ Preserves: src, mask\n@@ -2208,2 +2208,2 @@\n-                                           FloatRegister vzr, FloatRegister vtmp,\n-                                           PRegister pgtmp, unsigned vector_length_in_bytes) {\n+                                           FloatRegister vtmp1, FloatRegister vtmp2,\n+                                           PRegister pgtmp) {\n@@ -2211,3 +2211,1 @@\n-  \/\/ When called by sve_compress_byte, src and vtmp may be the same register.\n-  assert_different_registers(dst, src, vzr);\n-  assert_different_registers(dst, vtmp, vzr);\n+  assert_different_registers(dst, src, vtmp1, vtmp2);\n@@ -2215,4 +2213,5 @@\n-  \/\/ high <-- low\n-  \/\/ Example input:   src   = hh gg ff ee dd cc bb aa, one character is 8 bits.\n-  \/\/                  mask  = 01 00 00 01 01 00 01 01, one character is 1 bit.\n-  \/\/ Expected result: dst   = 00 00 00 hh ee dd bb aa\n+\n+  \/\/ Example input:   src   = 8888 7777 6666 5555 4444 3333 2222 1111\n+  \/\/                  mask  = 0001 0000 0000 0001 0001 0000 0001 0001\n+  \/\/ Expected result: dst   = 0000 0000 0000 8888 5555 4444 2222 1111\n+  sve_dup(vtmp2, H, 0);\n@@ -2221,1 +2220,1 @@\n-  \/\/ dst   =  00dd  00cc  00bb  00aa\n+  \/\/ dst = 00004444 00003333 00002222 00001111\n@@ -2223,1 +2222,1 @@\n-  \/\/ pgtmp =  0001  0000  0001  0001\n+  \/\/ pgtmp = 00000001 00000000 00000001 00000001\n@@ -2227,1 +2226,1 @@\n-  \/\/ dst   =  0000  00dd  00bb  00aa\n+  \/\/ dst = 00000000 00004444 00002222 00001111\n@@ -2230,9 +2229,2 @@\n-  \/\/ dst   = 00 00 00 00 00 dd bb aa\n-  sve_uzp1(dst, H, dst, vzr);\n-\n-  \/\/ Return if the vector length is no more than MaxVectorSize\/2, since the\n-  \/\/ highest half is invalid.\n-  if (vector_length_in_bytes <= (MaxVectorSize >> 1)) {\n-    return;\n-  }\n-\n+  \/\/ dst = 0000 0000 0000 0000 0000 4444 2222 1111\n+  sve_uzp1(dst, H, dst, vtmp2);\n@@ -2244,1 +2236,1 @@\n-  \/\/ pgtmp =  0001  0000  0000  0001\n+  \/\/ pgtmp = 00000001 00000000 00000000 00000001\n@@ -2246,14 +2238,20 @@\n-  \/\/ vtmp  =  00hh  00gg  00ff  00ee\n-  sve_uunpkhi(vtmp, S, src);\n-  \/\/ vtmp  =  0000  0000  00hh  00ee\n-  sve_compact(vtmp, S, vtmp, pgtmp);\n-  \/\/ vtmp  = 00 00 00 00 00 00 hh ee\n-  sve_uzp1(vtmp, H, vtmp, vzr);\n-\n-  \/\/ pgtmp = 00 00 00 00 00 01 01 01\n-  sve_whilelt(pgtmp, H, zr, rscratch1);\n-  \/\/ Compressed low:  dst  = 00 00 00 00 00 dd bb aa\n-  \/\/ Compressed high: vtmp = 00 00 00 00 00 00 hh ee\n-  \/\/ Combine the compressed low with the compressed high:\n-  \/\/                  dst  = 00 00 00 hh ee dd bb aa\n-  sve_splice(dst, H, pgtmp, vtmp);\n+  \/\/ vtmp1 = 00008888 00007777 00006666 00005555\n+  sve_uunpkhi(vtmp1, S, src);\n+  \/\/ vtmp1 = 00000000 00000000 00008888 00005555\n+  sve_compact(vtmp1, S, vtmp1, pgtmp);\n+  \/\/ vtmp1 = 0000 0000 0000 0000 0000 0000 8888 5555\n+  sve_uzp1(vtmp1, H, vtmp1, vtmp2);\n+\n+  \/\/ Compressed low:   dst   = 0000 0000 0000 0000 0000 4444 2222 1111\n+  \/\/ Compressed high:  vtmp1 = 0000 0000 0000 0000 0000 0000 8888  5555\n+  \/\/ Left shift(cross lane) compressed high with TRUE_CNT lanes,\n+  \/\/ TRUE_CNT is the number of active elements in the compressed low.\n+  neg(rscratch1, rscratch1);\n+  \/\/ vtmp2 = {4 3 2 1 0 -1 -2 -3}\n+  sve_index(vtmp2, H, rscratch1, 1);\n+  \/\/ vtmp1 = 0000 0000 0000 8888 5555 0000 0000 0000\n+  sve_tbl(vtmp1, H, vtmp1, vtmp2);\n+\n+  \/\/ Combine the compressed high(after shifted) with the compressed low.\n+  \/\/ dst = 0000 0000 0000 8888 5555 4444 2222 1111\n+  sve_orr(dst, dst, vtmp1);\n@@ -2265,2 +2263,3 @@\n-                                          FloatRegister vtmp1, FloatRegister vtmp2, FloatRegister vtmp3,\n-                                          PRegister ptmp, PRegister pgtmp, unsigned vector_length_in_bytes) {\n+                                          FloatRegister vtmp1, FloatRegister vtmp2,\n+                                          FloatRegister vtmp3, FloatRegister vtmp4,\n+                                          PRegister ptmp, PRegister pgtmp) {\n@@ -2268,1 +2267,1 @@\n-  assert_different_registers(dst, src, vtmp1, vtmp2, vtmp3);\n+  assert_different_registers(dst, src, vtmp1, vtmp2, vtmp3, vtmp4);\n@@ -2270,6 +2269,3 @@\n-  \/\/ high <-- low\n-  \/\/ Example input:   src   = q p n m l k j i h g f e d c b a, one character is 8 bits.\n-  \/\/                  mask  = 0 1 0 0 0 0 0 1 0 1 0 0 0 1 0 1, one character is 1 bit.\n-  \/\/ Expected result: dst   = 0 0 0 0 0 0 0 0 0 0 0 p i g c a\n-  FloatRegister vzr = vtmp3;\n-  sve_dup(vzr, B, 0);\n+  \/\/ Example input:   src   = 88 77 66 55 44 33 22 11\n+  \/\/                  mask  = 01 00 00 01 01 00 01 01\n+  \/\/ Expected result: dst   = 00 00 00 88 55 44 22 11\n@@ -2277,0 +2273,1 @@\n+  sve_dup(vtmp4, B, 0);\n@@ -2278,1 +2275,1 @@\n-  \/\/ vtmp1 =  0h  0g  0f  0e  0d  0c  0b  0a\n+  \/\/ vtmp1 = 0044 0033 0022 0011\n@@ -2280,1 +2277,1 @@\n-  \/\/ ptmp  =  00  01  00  00  00  01  00  01\n+  \/\/ ptmp = 0001 0000 0001 0001\n@@ -2282,14 +2279,0 @@\n-  \/\/ Pack the active elements in size of type SHORT to the right,\n-  \/\/ and fill the remainings with zero.\n-  \/\/ dst   =  00  00  00  00  00  0g  0c  0a\n-  unsigned extended_size = vector_length_in_bytes << 1;\n-  sve_compress_short(dst, vtmp1, ptmp, vzr, vtmp2, pgtmp, extended_size > MaxVectorSize ? MaxVectorSize : extended_size);\n-  \/\/ Narrow the result back to type BYTE.\n-  \/\/ dst   = 0 0 0 0 0 0 0 0 0 0 0 0 0 g c a\n-  sve_uzp1(dst, B, dst, vzr);\n-\n-  \/\/ Return if the vector length is no more than MaxVectorSize\/2, since the\n-  \/\/ highest half is invalid.\n-  if (vector_length_in_bytes <= (MaxVectorSize >> 1)) {\n-    return;\n-  }\n@@ -2299,0 +2282,7 @@\n+  \/\/ Pack the active elements in size of type SHORT to the right,\n+  \/\/ and fill the remainings with zero.\n+  \/\/ dst = 0000 0044 0022 0011\n+  sve_compress_short(dst, vtmp1, ptmp, vtmp2, vtmp3, pgtmp);\n+  \/\/ Narrow the result back to type BYTE.\n+  \/\/ dst = 00 00 00 00 00 44 22 11\n+  sve_uzp1(dst, B, dst, vtmp4);\n@@ -2301,1 +2291,1 @@\n-  \/\/ ptmp  =  00  01  00  00  00  00  00  01\n+  \/\/ ptmp = 0001 0000 0000 0001\n@@ -2303,1 +2293,1 @@\n-  \/\/ vtmp2 =  0q  0p  0n  0m  0l  0k  0j  0i\n+  \/\/ vtmp1 = 0088 0077 0066 0055\n@@ -2305,12 +2295,19 @@\n-  \/\/ vtmp1 =  00  00  00  00  00  00  0p  0i\n-  sve_compress_short(vtmp1, vtmp2, ptmp, vzr, vtmp2, pgtmp, extended_size - MaxVectorSize);\n-  \/\/ vtmp1 = 0 0 0 0 0 0 0 0 0 0 0 0 0 0 p i\n-  sve_uzp1(vtmp1, B, vtmp1, vzr);\n-\n-  \/\/ ptmp  = 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1\n-  sve_whilelt(ptmp, B, zr, rscratch2);\n-  \/\/ Compressed low:  dst   = 0 0 0 0 0 0 0 0 0 0 0 0 0 g c a\n-  \/\/ Compressed high: vtmp1 = 0 0 0 0 0 0 0 0 0 0 0 0 0 0 p i\n-  \/\/ Combine the compressed low with the compressed high:\n-  \/\/                  dst   = 0 0 0 0 0 0 0 0 0 0 0 p i g c a\n-  sve_splice(dst, B, ptmp, vtmp1);\n+  \/\/ vtmp1 = 0000 0000 0088 0055\n+  sve_compress_short(vtmp1, vtmp2, ptmp, vtmp3, vtmp4, pgtmp);\n+\n+  sve_dup(vtmp4, B, 0);\n+  \/\/ vtmp1 = 00 00 00 00 00 00 88 55\n+  sve_uzp1(vtmp1, B, vtmp1, vtmp4);\n+\n+  \/\/ Compressed low:   dst   = 00 00 00 00 00 44 22 11\n+  \/\/ Compressed high:  vtmp1 = 00 00 00 00 00 00 88 55\n+  \/\/ Left shift(cross lane) compressed high with TRUE_CNT lanes,\n+  \/\/ TRUE_CNT is the number of active elements in the compressed low.\n+  neg(rscratch2, rscratch2);\n+  \/\/ vtmp2 = {4 3 2 1 0 -1 -2 -3}\n+  sve_index(vtmp2, B, rscratch2, 1);\n+  \/\/ vtmp1 = 00 00 00 88 55 00 00 00\n+  sve_tbl(vtmp1, B, vtmp1, vtmp2);\n+  \/\/ Combine the compressed high(after shifted) with the compressed low.\n+  \/\/ dst = 00 00 00 88 55 44 22 11\n+  sve_orr(dst, dst, vtmp1);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":73,"deletions":76,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -176,2 +176,3 @@\n-                         FloatRegister vtmp1, FloatRegister vtmp2, FloatRegister vtmp3,\n-                         PRegister ptmp, PRegister pgtmp, unsigned vector_length_in_bytes);\n+                         FloatRegister vtmp1, FloatRegister vtmp2,\n+                         FloatRegister vtmp3, FloatRegister vtmp4,\n+                         PRegister ptmp, PRegister pgtmp);\n@@ -180,2 +181,2 @@\n-                          FloatRegister vzr, FloatRegister vtmp,\n-                          PRegister pgtmp, unsigned vector_length_in_bytes);\n+                          FloatRegister vtmp1, FloatRegister vtmp2,\n+                          PRegister pgtmp);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1707,11 +1707,0 @@\n-\n-#ifdef ASSERT\n-void InterpreterMacroAssembler::verify_field_offset(Register reg) {\n-  \/\/ Verify the field offset is not in the header, implicitly checks for 0\n-  Label L;\n-  subs(zr, reg, oopDesc::base_offset_in_bytes());\n-  br(Assembler::GE, L);\n-  stop(\"bad field offset\");\n-  bind(L);\n-}\n-#endif\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -322,2 +322,0 @@\n-\n-  void verify_field_offset(Register reg) NOT_DEBUG_RETURN;\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -151,0 +151,3 @@\n+class RelocActions {\n+protected:\n+  typedef int (*reloc_insn)(address insn_addr, address &target);\n@@ -152,3 +155,6 @@\n-static uint32_t insn_at(address insn_addr, int n) {\n-  return ((uint32_t*)insn_addr)[n];\n-}\n+  virtual reloc_insn adrpMem() = 0;\n+  virtual reloc_insn adrpAdd() = 0;\n+  virtual reloc_insn adrpMovk() = 0;\n+\n+  const address _insn_addr;\n+  const uint32_t _insn;\n@@ -156,2 +162,6 @@\n-template<typename T>\n-class RelocActions : public AllStatic {\n+  static uint32_t insn_at(address insn_addr, int n) {\n+    return ((uint32_t*)insn_addr)[n];\n+  }\n+  uint32_t insn_at(int n) const {\n+    return insn_at(_insn_addr, n);\n+  }\n@@ -161,1 +171,14 @@\n-  static int ALWAYSINLINE run(address insn_addr, address &target) {\n+  RelocActions(address insn_addr) : _insn_addr(insn_addr), _insn(insn_at(insn_addr, 0)) {}\n+  RelocActions(address insn_addr, uint32_t insn)\n+    :  _insn_addr(insn_addr), _insn(insn) {}\n+\n+  virtual int unconditionalBranch(address insn_addr, address &target) = 0;\n+  virtual int conditionalBranch(address insn_addr, address &target) = 0;\n+  virtual int testAndBranch(address insn_addr, address &target) = 0;\n+  virtual int loadStore(address insn_addr, address &target) = 0;\n+  virtual int adr(address insn_addr, address &target) = 0;\n+  virtual int adrp(address insn_addr, address &target, reloc_insn inner) = 0;\n+  virtual int immediate(address insn_addr, address &target) = 0;\n+  virtual void verify(address insn_addr, address &target) = 0;\n+\n+  int ALWAYSINLINE run(address insn_addr, address &target) {\n@@ -163,1 +186,0 @@\n-    uint32_t insn = insn_at(insn_addr, 0);\n@@ -165,1 +187,1 @@\n-    uint32_t dispatch = Instruction_aarch64::extract(insn, 30, 25);\n+    uint32_t dispatch = Instruction_aarch64::extract(_insn, 30, 25);\n@@ -169,1 +191,1 @@\n-        instructions = T::unconditionalBranch(insn_addr, target);\n+        instructions = unconditionalBranch(insn_addr, target);\n@@ -174,2 +196,2 @@\n-        instructions = T::conditionalBranch(insn_addr, target);\n-        break;\n+        instructions = conditionalBranch(insn_addr, target);\n+          break;\n@@ -178,1 +200,1 @@\n-        instructions = T::testAndBranch(insn_addr, target);\n+        instructions = testAndBranch(insn_addr, target);\n@@ -190,1 +212,1 @@\n-        if ((Instruction_aarch64::extract(insn, 29, 24) & 0b111011) == 0b011000) {\n+        if ((Instruction_aarch64::extract(_insn, 29, 24) & 0b111011) == 0b011000) {\n@@ -192,1 +214,1 @@\n-          instructions = T::loadStore(insn_addr, target);\n+          instructions = loadStore(insn_addr, target);\n@@ -205,2 +227,2 @@\n-        assert(Instruction_aarch64::extract(insn, 28, 24) == 0b10000, \"must be\");\n-        int shift = Instruction_aarch64::extract(insn, 31, 31);\n+        assert(Instruction_aarch64::extract(_insn, 28, 24) == 0b10000, \"must be\");\n+        int shift = Instruction_aarch64::extract(_insn, 31, 31);\n@@ -208,1 +230,1 @@\n-          uint32_t insn2 = insn_at(insn_addr, 1);\n+          uint32_t insn2 = insn_at(1);\n@@ -210,1 +232,1 @@\n-              Instruction_aarch64::extract(insn, 4, 0) ==\n+              Instruction_aarch64::extract(_insn, 4, 0) ==\n@@ -212,1 +234,1 @@\n-            instructions = T::adrp(insn_addr, target, T::adrpMem);\n+            instructions = adrp(insn_addr, target, adrpMem());\n@@ -214,1 +236,1 @@\n-                     Instruction_aarch64::extract(insn, 4, 0) ==\n+                     Instruction_aarch64::extract(_insn, 4, 0) ==\n@@ -216,1 +238,1 @@\n-            instructions = T::adrp(insn_addr, target, T::adrpAdd);\n+            instructions = adrp(insn_addr, target, adrpAdd());\n@@ -218,1 +240,1 @@\n-                     Instruction_aarch64::extract(insn, 4, 0) ==\n+                     Instruction_aarch64::extract(_insn, 4, 0) ==\n@@ -220,1 +242,1 @@\n-            instructions = T::adrp(insn_addr, target, T::adrpMovk);\n+            instructions = adrp(insn_addr, target, adrpMovk());\n@@ -225,1 +247,1 @@\n-          instructions = T::adr(insn_addr, target);\n+          instructions = adr(insn_addr, target);\n@@ -233,1 +255,1 @@\n-        instructions = T::immediate(insn_addr, target);\n+        instructions = immediate(insn_addr, target);\n@@ -241,1 +263,1 @@\n-    T::verify(insn_addr, target);\n+    verify(insn_addr, target);\n@@ -246,1 +268,5 @@\n-class Patcher : public AllStatic {\n+class Patcher : public RelocActions {\n+  virtual reloc_insn adrpMem() { return &Patcher::adrpMem_impl; }\n+  virtual reloc_insn adrpAdd() { return &Patcher::adrpAdd_impl; }\n+  virtual reloc_insn adrpMovk() { return &Patcher::adrpMovk_impl; }\n+\n@@ -248,1 +274,3 @@\n-  static int unconditionalBranch(address insn_addr, address &target) {\n+  Patcher(address insn_addr) : RelocActions(insn_addr) {}\n+\n+  virtual int unconditionalBranch(address insn_addr, address &target) {\n@@ -253,1 +281,1 @@\n-  static int conditionalBranch(address insn_addr, address &target) {\n+  virtual int conditionalBranch(address insn_addr, address &target) {\n@@ -258,1 +286,1 @@\n-  static int testAndBranch(address insn_addr, address &target) {\n+  virtual int testAndBranch(address insn_addr, address &target) {\n@@ -263,1 +291,1 @@\n-  static int loadStore(address insn_addr, address &target) {\n+  virtual int loadStore(address insn_addr, address &target) {\n@@ -268,1 +296,1 @@\n-  static int adr(address insn_addr, address &target) {\n+  virtual int adr(address insn_addr, address &target) {\n@@ -270,1 +298,1 @@\n-    assert(Instruction_aarch64::extract(insn_at(insn_addr, 0), 28, 24) == 0b10000, \"must be\");\n+    assert(Instruction_aarch64::extract(_insn, 28, 24) == 0b10000, \"must be\");\n@@ -280,2 +308,1 @@\n-  template<typename U>\n-  static int adrp(address insn_addr, address &target, U inner) {\n+  virtual int adrp(address insn_addr, address &target, reloc_insn inner) {\n@@ -284,1 +311,1 @@\n-    assert(Instruction_aarch64::extract(insn_at(insn_addr, 0), 28, 24) == 0b10000, \"must be\");\n+    assert(Instruction_aarch64::extract(_insn, 28, 24) == 0b10000, \"must be\");\n@@ -291,1 +318,1 @@\n-    instructions = inner(insn_addr, adjusted_target);\n+    instructions = (*inner)(insn_addr, adjusted_target);\n@@ -301,1 +328,1 @@\n-  static int adrpMem(address insn_addr, address &target) {\n+  static int adrpMem_impl(address insn_addr, address &target) {\n@@ -310,1 +337,1 @@\n-  static int adrpAdd(address insn_addr, address &target) {\n+  static int adrpAdd_impl(address insn_addr, address &target) {\n@@ -316,1 +343,1 @@\n-  static int adrpMovk(address insn_addr, address &target) {\n+  static int adrpMovk_impl(address insn_addr, address &target) {\n@@ -323,2 +350,2 @@\n-  static int immediate(address insn_addr, address &target) {\n-    assert(Instruction_aarch64::extract(insn_at(insn_addr, 0), 31, 21) == 0b11010010100, \"must be\");\n+  virtual int immediate(address insn_addr, address &target) {\n+    assert(Instruction_aarch64::extract(_insn, 31, 21) == 0b11010010100, \"must be\");\n@@ -334,1 +361,1 @@\n-  static void verify(address insn_addr, address &target) {\n+  virtual void verify(address insn_addr, address &target) {\n@@ -368,1 +395,5 @@\n-class AArch64Decoder : public AllStatic {\n+class AArch64Decoder : public RelocActions {\n+  virtual reloc_insn adrpMem() { return &AArch64Decoder::adrpMem_impl; }\n+  virtual reloc_insn adrpAdd() { return &AArch64Decoder::adrpAdd_impl; }\n+  virtual reloc_insn adrpMovk() { return &AArch64Decoder::adrpMovk_impl; }\n+\n@@ -370,0 +401,1 @@\n+  AArch64Decoder(address insn_addr, uint32_t insn) : RelocActions(insn_addr, insn) {}\n@@ -371,2 +403,2 @@\n-  static int loadStore(address insn_addr, address &target) {\n-    intptr_t offset = Instruction_aarch64::sextract(insn_at(insn_addr, 0), 23, 5);\n+  virtual int loadStore(address insn_addr, address &target) {\n+    intptr_t offset = Instruction_aarch64::sextract(_insn, 23, 5);\n@@ -376,2 +408,2 @@\n-  static int unconditionalBranch(address insn_addr, address &target) {\n-    intptr_t offset = Instruction_aarch64::sextract(insn_at(insn_addr, 0), 25, 0);\n+  virtual int unconditionalBranch(address insn_addr, address &target) {\n+    intptr_t offset = Instruction_aarch64::sextract(_insn, 25, 0);\n@@ -381,2 +413,2 @@\n-  static int conditionalBranch(address insn_addr, address &target) {\n-    intptr_t offset = Instruction_aarch64::sextract(insn_at(insn_addr, 0), 23, 5);\n+  virtual int conditionalBranch(address insn_addr, address &target) {\n+    intptr_t offset = Instruction_aarch64::sextract(_insn, 23, 5);\n@@ -386,2 +418,2 @@\n-  static int testAndBranch(address insn_addr, address &target) {\n-    intptr_t offset = Instruction_aarch64::sextract(insn_at(insn_addr, 0), 18, 5);\n+  virtual int testAndBranch(address insn_addr, address &target) {\n+    intptr_t offset = Instruction_aarch64::sextract(_insn, 18, 5);\n@@ -391,1 +423,1 @@\n-  static int adr(address insn_addr, address &target) {\n+  virtual int adr(address insn_addr, address &target) {\n@@ -393,3 +425,2 @@\n-    uint32_t insn = insn_at(insn_addr, 0);\n-    intptr_t offset = Instruction_aarch64::extract(insn, 30, 29);\n-    offset |= Instruction_aarch64::sextract(insn, 23, 5) << 2;\n+    intptr_t offset = Instruction_aarch64::extract(_insn, 30, 29);\n+    offset |= Instruction_aarch64::sextract(_insn, 23, 5) << 2;\n@@ -399,6 +430,4 @@\n-  template<typename U>\n-  static int adrp(address insn_addr, address &target, U inner) {\n-    uint32_t insn = insn_at(insn_addr, 0);\n-    assert(Instruction_aarch64::extract(insn, 28, 24) == 0b10000, \"must be\");\n-    intptr_t offset = Instruction_aarch64::extract(insn, 30, 29);\n-    offset |= Instruction_aarch64::sextract(insn, 23, 5) << 2;\n+  virtual int adrp(address insn_addr, address &target, reloc_insn inner) {\n+    assert(Instruction_aarch64::extract(_insn, 28, 24) == 0b10000, \"must be\");\n+    intptr_t offset = Instruction_aarch64::extract(_insn, 30, 29);\n+    offset |= Instruction_aarch64::sextract(_insn, 23, 5) << 2;\n@@ -409,1 +438,1 @@\n-    uint32_t insn2 = insn_at(insn_addr, 1);\n+    uint32_t insn2 = insn_at(1);\n@@ -412,1 +441,1 @@\n-    inner(insn_addr, target);\n+    (*inner)(insn_addr, target);\n@@ -415,1 +444,1 @@\n-  static int adrpMem(address insn_addr, address &target) {\n+  static int adrpMem_impl(address insn_addr, address &target) {\n@@ -424,1 +453,1 @@\n-  static int adrpAdd(address insn_addr, address &target) {\n+  static int adrpAdd_impl(address insn_addr, address &target) {\n@@ -431,1 +460,1 @@\n-  static int adrpMovk(address insn_addr, address &target) {\n+  static int adrpMovk_impl(address insn_addr, address &target) {\n@@ -450,1 +479,1 @@\n-  static int immediate(address insn_addr, address &target) {\n+  virtual int immediate(address insn_addr, address &target) {\n@@ -452,1 +481,1 @@\n-    assert(Instruction_aarch64::extract(insns[0], 31, 21) == 0b11010010100, \"must be\");\n+    assert(Instruction_aarch64::extract(_insn, 31, 21) == 0b11010010100, \"must be\");\n@@ -456,3 +485,3 @@\n-    target = address(uint64_t(Instruction_aarch64::extract(insns[0], 20, 5))\n-                  + (uint64_t(Instruction_aarch64::extract(insns[1], 20, 5)) << 16)\n-                  + (uint64_t(Instruction_aarch64::extract(insns[2], 20, 5)) << 32));\n+    target = address(uint64_t(Instruction_aarch64::extract(_insn, 20, 5))\n+                 + (uint64_t(Instruction_aarch64::extract(insns[1], 20, 5)) << 16)\n+                 + (uint64_t(Instruction_aarch64::extract(insns[2], 20, 5)) << 32));\n@@ -463,1 +492,1 @@\n-  static void verify(address insn_addr, address &target) {\n+  virtual void verify(address insn_addr, address &target) {\n@@ -467,1 +496,2 @@\n-address MacroAssembler::target_addr_for_insn(address insn_addr) {\n+address MacroAssembler::target_addr_for_insn(address insn_addr, uint32_t insn) {\n+  AArch64Decoder decoder(insn_addr, insn);\n@@ -469,1 +499,1 @@\n-  RelocActions<AArch64Decoder>::run(insn_addr, target);\n+  decoder.run(insn_addr, target);\n@@ -476,1 +506,2 @@\n-  return RelocActions<Patcher>::run(insn_addr, target);\n+  Patcher patcher(insn_addr);\n+  return patcher.run(insn_addr, target);\n@@ -518,2 +549,2 @@\n-address MacroAssembler::target_addr_for_insn_or_null(address insn_addr) {\n-  if (NativeInstruction::is_ldrw_to_zr(insn_addr)) {\n+address MacroAssembler::target_addr_for_insn_or_null(address insn_addr, unsigned insn) {\n+  if (NativeInstruction::is_ldrw_to_zr(address(&insn))) {\n@@ -522,1 +553,1 @@\n-  return MacroAssembler::target_addr_for_insn(insn_addr);\n+  return MacroAssembler::target_addr_for_insn(insn_addr, insn);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":110,"deletions":79,"binary":false,"changes":189,"status":"modified"},{"patch":"@@ -679,2 +679,10 @@\n-  static address target_addr_for_insn(address insn_addr);\n-  static address target_addr_for_insn_or_null(address insn_addr);\n+  static address target_addr_for_insn(address insn_addr, unsigned insn);\n+  static address target_addr_for_insn_or_null(address insn_addr, unsigned insn);\n+  static address target_addr_for_insn(address insn_addr) {\n+    unsigned insn = *(unsigned*)insn_addr;\n+    return target_addr_for_insn(insn_addr, insn);\n+  }\n+  static address target_addr_for_insn_or_null(address insn_addr) {\n+    unsigned insn = *(unsigned*)insn_addr;\n+    return target_addr_for_insn_or_null(insn_addr, insn);\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -171,1 +171,0 @@\n-  assert_different_registers(bc_reg, temp_reg);\n@@ -235,6 +234,3 @@\n-  \/\/ Patch bytecode with release store to coordinate with ResolvedFieldEntry loads\n-  \/\/ in fast bytecode codelets. load_field_entry has a memory barrier that gains\n-  \/\/ the needed ordering, together with control dependency on entering the fast codelet\n-  \/\/ itself.\n-  __ lea(temp_reg, at_bcp(0));\n-  __ stlrb(bc_reg, temp_reg);\n+\n+  \/\/ patch bytecode\n+  __ strb(bc_reg, at_bcp(0));\n@@ -3101,1 +3097,0 @@\n-  __ verify_field_offset(r1);\n@@ -3191,2 +3186,0 @@\n-  __ verify_field_offset(r1);\n-\n@@ -3259,1 +3252,0 @@\n-\n@@ -3261,1 +3253,0 @@\n-  __ verify_field_offset(r1);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1134,1 +1134,1 @@\n-const RegMask& Matcher::divI_proj_mask() {\n+RegMask Matcher::divI_proj_mask() {\n@@ -1136,1 +1136,1 @@\n-  return RegMask::EMPTY;\n+  return RegMask();\n@@ -1140,1 +1140,1 @@\n-const RegMask& Matcher::modI_proj_mask() {\n+RegMask Matcher::modI_proj_mask() {\n@@ -1142,1 +1142,1 @@\n-  return RegMask::EMPTY;\n+  return RegMask();\n@@ -1146,1 +1146,1 @@\n-const RegMask& Matcher::divL_proj_mask() {\n+RegMask Matcher::divL_proj_mask() {\n@@ -1148,1 +1148,1 @@\n-  return RegMask::EMPTY;\n+  return RegMask();\n@@ -1152,1 +1152,1 @@\n-const RegMask& Matcher::modL_proj_mask() {\n+RegMask Matcher::modL_proj_mask() {\n@@ -1154,1 +1154,1 @@\n-  return RegMask::EMPTY;\n+  return RegMask();\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -136,7 +136,2 @@\n-  void load_field_or_method_entry(bool is_method, Register cache, Register index, int bcp_offset, bool for_fast_bytecode);\n-  void load_field_entry(Register cache, Register index, int bcp_offset = 1, bool for_fast_bytecode = false) {\n-    load_field_or_method_entry(false, cache, index, bcp_offset, for_fast_bytecode);\n-  }\n-  void load_method_entry(Register cache, Register index, int bcp_offset = 1, bool for_fast_bytecode = false) {\n-    load_field_or_method_entry(true, cache, index, bcp_offset, for_fast_bytecode);\n-  }\n+  void load_field_entry(Register cache, Register index, int bcp_offset = 1);\n+  void load_method_entry(Register cache, Register index, int bcp_offset = 1);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc.hpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -471,5 +471,1 @@\n-void InterpreterMacroAssembler::load_field_or_method_entry(bool is_method, Register cache, Register index, int bcp_offset, bool for_fast_bytecode) {\n-  const int entry_size     = is_method ? sizeof(ResolvedMethodEntry) : sizeof(ResolvedFieldEntry),\n-            base_offset    = is_method ? Array<ResolvedMethodEntry>::base_offset_in_bytes() : Array<ResolvedFieldEntry>::base_offset_in_bytes(),\n-            entries_offset = is_method ? in_bytes(ConstantPoolCache::method_entries_offset()) : in_bytes(ConstantPoolCache::field_entries_offset());\n-\n+void InterpreterMacroAssembler::load_field_entry(Register cache, Register index, int bcp_offset) {\n@@ -479,1 +475,1 @@\n-  if (is_power_of_2(entry_size)) {\n+  if (is_power_of_2(sizeof(ResolvedFieldEntry))) {\n@@ -481,1 +477,1 @@\n-    sldi(index, index, log2i_exact(entry_size));\n+    sldi(index, index, log2i_exact(sizeof(ResolvedFieldEntry)));\n@@ -484,1 +480,1 @@\n-    mulli(index, index, entry_size);\n+    mulli(index, index, sizeof(ResolvedFieldEntry));\n@@ -487,2 +483,2 @@\n-  ld_ptr(cache, entries_offset, R27_constPoolCache);\n-  addi(cache, cache, base_offset);\n+  ld_ptr(cache, in_bytes(ConstantPoolCache::field_entries_offset()), R27_constPoolCache);\n+  addi(cache, cache, Array<ResolvedFieldEntry>::base_offset_in_bytes());\n@@ -490,0 +486,1 @@\n+}\n@@ -491,7 +488,10 @@\n-  if (for_fast_bytecode) {\n-    \/\/ Prevent speculative loading from ResolvedFieldEntry\/ResolvedMethodEntry as it can miss the info written by another thread.\n-    \/\/ TemplateTable::patch_bytecode uses release-store.\n-    \/\/ We reached here via control dependency (Bytecode dispatch has used the rewritten Bytecode).\n-    \/\/ So, we can use control-isync based ordering.\n-    isync();\n-  }\n+void InterpreterMacroAssembler::load_method_entry(Register cache, Register index, int bcp_offset) {\n+  \/\/ Get index out of bytecode pointer\n+  get_cache_index_at_bcp(index, bcp_offset, sizeof(u2));\n+  \/\/ Scale the index to be the entry index * sizeof(ResolvedMethodEntry)\n+  mulli(index, index, sizeof(ResolvedMethodEntry));\n+\n+  \/\/ Get address of field entries array\n+  ld_ptr(cache, ConstantPoolCache::method_entries_offset(), R27_constPoolCache);\n+  addi(cache, cache, Array<ResolvedMethodEntry>::base_offset_in_bytes());\n+  add(cache, cache, index); \/\/ method_entries + base_offset + scaled index\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2453,1 +2453,1 @@\n-const RegMask& Matcher::divI_proj_mask() {\n+RegMask Matcher::divI_proj_mask() {\n@@ -2455,1 +2455,1 @@\n-  return RegMask::EMPTY;\n+  return RegMask();\n@@ -2459,1 +2459,1 @@\n-const RegMask& Matcher::modI_proj_mask() {\n+RegMask Matcher::modI_proj_mask() {\n@@ -2461,1 +2461,1 @@\n-  return RegMask::EMPTY;\n+  return RegMask();\n@@ -2465,1 +2465,1 @@\n-const RegMask& Matcher::divL_proj_mask() {\n+RegMask Matcher::divL_proj_mask() {\n@@ -2467,1 +2467,1 @@\n-  return RegMask::EMPTY;\n+  return RegMask();\n@@ -2471,1 +2471,1 @@\n-const RegMask& Matcher::modL_proj_mask() {\n+RegMask Matcher::modL_proj_mask() {\n@@ -2473,1 +2473,1 @@\n-  return RegMask::EMPTY;\n+  return RegMask();\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -151,3 +151,1 @@\n-  \/\/ Patch bytecode with release store to coordinate with ResolvedFieldEntry\n-  \/\/ and ResolvedMethodEntry loads in fast bytecode codelets.\n-  __ release();\n+  \/\/ Patch bytecode.\n@@ -317,1 +315,0 @@\n-  \/\/ Only rewritten during link time. So, no need for memory barriers for accessing resolved info.\n@@ -3120,1 +3117,1 @@\n-  __ load_field_entry(Rcache, Rscratch, 1, \/* for_fast_bytecode *\/ true);\n+  __ load_field_entry(Rcache, Rscratch);\n@@ -3201,1 +3198,1 @@\n-  __ load_field_entry(Rcache, Rscratch, 1, \/* for_fast_bytecode *\/ true);\n+  __ load_field_entry(Rcache, Rscratch);\n@@ -3340,1 +3337,1 @@\n-  __ load_field_entry(Rcache, Rscratch, 2, \/* for_fast_bytecode *\/ true);\n+  __ load_field_entry(Rcache, Rscratch, 2);\n@@ -3501,1 +3498,1 @@\n-  __ load_method_entry(Rcache, R11_scratch1, 1, \/* for_fast_bytecode *\/ true);\n+  __ load_method_entry(Rcache, R11_scratch1);\n","filename":"src\/hotspot\/cpu\/ppc\/templateTable_ppc_64.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -102,4 +102,0 @@\n-  if (FLAG_IS_DEFAULT(UsePopCountInstruction)) {\n-    FLAG_SET_ERGO(UsePopCountInstruction, true);\n-  }\n-\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1844,9 +1844,0 @@\n-void InterpreterMacroAssembler::verify_field_offset(Register reg) {\n-  \/\/ Verify the field offset is not in the header, implicitly checks for 0\n-  Label L;\n-  mv(t0, oopDesc::base_offset_in_bytes());\n-  bge(reg, t0, L);\n-  stop(\"bad field offset\");\n-  bind(L);\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -303,1 +303,1 @@\n-  void verify_field_offset(Register reg) NOT_DEBUG_RETURN;\n+#ifdef ASSERT\n@@ -305,2 +305,3 @@\n-                           const char* msg, bool stop_by_hit = true) NOT_DEBUG_RETURN;\n-  void verify_frame_setup() NOT_DEBUG_RETURN;\n+                           const char* msg, bool stop_by_hit = true);\n+  void verify_frame_setup();\n+#endif\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1095,2 +1095,2 @@\n-  _ANY_REG32_mask.assignFrom(_ALL_REG32_mask);\n-  _ANY_REG32_mask.remove(OptoReg::as_OptoReg(x0->as_VMReg()));\n+  _ANY_REG32_mask = _ALL_REG32_mask;\n+  _ANY_REG32_mask.Remove(OptoReg::as_OptoReg(x0->as_VMReg()));\n@@ -1098,2 +1098,2 @@\n-  _ANY_REG_mask.assignFrom(_ALL_REG_mask);\n-  _ANY_REG_mask.subtract(_ZR_REG_mask);\n+  _ANY_REG_mask = _ALL_REG_mask;\n+  _ANY_REG_mask.SUBTRACT(_ZR_REG_mask);\n@@ -1101,2 +1101,2 @@\n-  _PTR_REG_mask.assignFrom(_ALL_REG_mask);\n-  _PTR_REG_mask.subtract(_ZR_REG_mask);\n+  _PTR_REG_mask = _ALL_REG_mask;\n+  _PTR_REG_mask.SUBTRACT(_ZR_REG_mask);\n@@ -1104,2 +1104,2 @@\n-  _NO_SPECIAL_REG32_mask.assignFrom(_ALL_REG32_mask);\n-  _NO_SPECIAL_REG32_mask.subtract(_NON_ALLOCATABLE_REG32_mask);\n+  _NO_SPECIAL_REG32_mask = _ALL_REG32_mask;\n+  _NO_SPECIAL_REG32_mask.SUBTRACT(_NON_ALLOCATABLE_REG32_mask);\n@@ -1107,2 +1107,2 @@\n-  _NO_SPECIAL_REG_mask.assignFrom(_ALL_REG_mask);\n-  _NO_SPECIAL_REG_mask.subtract(_NON_ALLOCATABLE_REG_mask);\n+  _NO_SPECIAL_REG_mask = _ALL_REG_mask;\n+  _NO_SPECIAL_REG_mask.SUBTRACT(_NON_ALLOCATABLE_REG_mask);\n@@ -1110,2 +1110,2 @@\n-  _NO_SPECIAL_PTR_REG_mask.assignFrom(_ALL_REG_mask);\n-  _NO_SPECIAL_PTR_REG_mask.subtract(_NON_ALLOCATABLE_REG_mask);\n+  _NO_SPECIAL_PTR_REG_mask = _ALL_REG_mask;\n+  _NO_SPECIAL_PTR_REG_mask.SUBTRACT(_NON_ALLOCATABLE_REG_mask);\n@@ -1115,3 +1115,3 @@\n-    _NO_SPECIAL_REG32_mask.remove(OptoReg::as_OptoReg(x27->as_VMReg()));\n-    _NO_SPECIAL_REG_mask.remove(OptoReg::as_OptoReg(x27->as_VMReg()));\n-    _NO_SPECIAL_PTR_REG_mask.remove(OptoReg::as_OptoReg(x27->as_VMReg()));\n+    _NO_SPECIAL_REG32_mask.Remove(OptoReg::as_OptoReg(x27->as_VMReg()));\n+    _NO_SPECIAL_REG_mask.Remove(OptoReg::as_OptoReg(x27->as_VMReg()));\n+    _NO_SPECIAL_PTR_REG_mask.Remove(OptoReg::as_OptoReg(x27->as_VMReg()));\n@@ -1122,3 +1122,3 @@\n-    _NO_SPECIAL_REG32_mask.remove(OptoReg::as_OptoReg(x8->as_VMReg()));\n-    _NO_SPECIAL_REG_mask.remove(OptoReg::as_OptoReg(x8->as_VMReg()));\n-    _NO_SPECIAL_PTR_REG_mask.remove(OptoReg::as_OptoReg(x8->as_VMReg()));\n+    _NO_SPECIAL_REG32_mask.Remove(OptoReg::as_OptoReg(x8->as_VMReg()));\n+    _NO_SPECIAL_REG_mask.Remove(OptoReg::as_OptoReg(x8->as_VMReg()));\n+    _NO_SPECIAL_PTR_REG_mask.Remove(OptoReg::as_OptoReg(x8->as_VMReg()));\n@@ -1127,2 +1127,2 @@\n-  _NO_SPECIAL_NO_FP_PTR_REG_mask.assignFrom(_NO_SPECIAL_PTR_REG_mask);\n-  _NO_SPECIAL_NO_FP_PTR_REG_mask.remove(OptoReg::as_OptoReg(x8->as_VMReg()));\n+  _NO_SPECIAL_NO_FP_PTR_REG_mask = _NO_SPECIAL_PTR_REG_mask;\n+  _NO_SPECIAL_NO_FP_PTR_REG_mask.Remove(OptoReg::as_OptoReg(x8->as_VMReg()));\n@@ -1329,1 +1329,1 @@\n-const RegMask& MachConstantBaseNode::_out_RegMask = RegMask::EMPTY;\n+const RegMask& MachConstantBaseNode::_out_RegMask = RegMask::Empty;\n@@ -2107,1 +2107,1 @@\n-  \/\/ (_NO_SPECIAL_REG32_mask.size() minus 1) forces CallNode to become\n+  \/\/ (_NO_SPECIAL_REG32_mask.Size() minus 1) forces CallNode to become\n@@ -2110,1 +2110,1 @@\n-  uint default_int_pressure_threshold = _NO_SPECIAL_REG32_mask.size() - 1;\n+  uint default_int_pressure_threshold = _NO_SPECIAL_REG32_mask.Size() - 1;\n@@ -2125,1 +2125,1 @@\n-  return (FLOATPRESSURE == -1) ? _FLOAT_REG_mask.size() : FLOATPRESSURE;\n+  return (FLOATPRESSURE == -1) ? _FLOAT_REG_mask.Size() : FLOATPRESSURE;\n@@ -2132,1 +2132,1 @@\n-const RegMask& Matcher::divI_proj_mask() {\n+RegMask Matcher::divI_proj_mask() {\n@@ -2134,1 +2134,1 @@\n-  return RegMask::EMPTY;\n+  return RegMask();\n@@ -2138,1 +2138,1 @@\n-const RegMask& Matcher::modI_proj_mask() {\n+RegMask Matcher::modI_proj_mask() {\n@@ -2140,1 +2140,1 @@\n-  return RegMask::EMPTY;\n+  return RegMask();\n@@ -2144,1 +2144,1 @@\n-const RegMask& Matcher::divL_proj_mask() {\n+RegMask Matcher::divL_proj_mask() {\n@@ -2146,1 +2146,1 @@\n-  return RegMask::EMPTY;\n+  return RegMask();\n@@ -2150,1 +2150,1 @@\n-const RegMask& Matcher::modL_proj_mask() {\n+RegMask Matcher::modL_proj_mask() {\n@@ -2152,1 +2152,1 @@\n-  return RegMask::EMPTY;\n+  return RegMask();\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":32,"deletions":32,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -1076,0 +1076,1 @@\n+#ifdef ASSERT\n@@ -1077,0 +1078,1 @@\n+#endif\n@@ -1542,0 +1544,1 @@\n+#ifdef ASSERT\n@@ -1543,0 +1546,1 @@\n+#endif\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -136,1 +136,0 @@\n-  assert_different_registers(bc_reg, temp_reg);\n@@ -200,5 +199,1 @@\n-  \/\/ Patch bytecode with release store to coordinate with ResolvedFieldEntry loads\n-  \/\/ in fast bytecode codelets. load_field_entry has a memory barrier that gains\n-  \/\/ the needed ordering, together with control dependency on entering the fast codelet\n-  \/\/ itself.\n-  __ membar(MacroAssembler::LoadStore | MacroAssembler::StoreStore);\n+  \/\/ patch bytecode\n@@ -3036,1 +3031,0 @@\n-  __ verify_field_offset(x11);\n@@ -3124,2 +3118,0 @@\n-  __ verify_field_offset(x11);\n-\n@@ -3181,1 +3173,0 @@\n-\n@@ -3183,1 +3174,0 @@\n-  __ verify_field_offset(x11);\n","filename":"src\/hotspot\/cpu\/riscv\/templateTable_riscv.cpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -106,0 +106,11 @@\n+  \/\/ Enable vendor specific features\n+\n+  if (mvendorid.enabled()) {\n+    \/\/ Rivos\n+    if (mvendorid.value() == RIVOS) {\n+      if (FLAG_IS_DEFAULT(UseConservativeFence)) {\n+        FLAG_SET_DEFAULT(UseConservativeFence, false);\n+      }\n+    }\n+  }\n+\n@@ -191,1 +202,1 @@\n-  if (UseZicboz && zicboz_block_size.value() > 0) {\n+  if (UseZicboz && zicboz_block_size.enabled() && zicboz_block_size.value() > 0) {\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-\n+    int64_t           _value;\n@@ -58,1 +58,8 @@\n-      _pretty(pretty), _feature_string(fstring), _linux_feature_bit(nth_bit(linux_bit_num)) {\n+      _pretty(pretty), _feature_string(fstring), _linux_feature_bit(nth_bit(linux_bit_num)),\n+      _value(-1) {\n+    }\n+    virtual void enable_feature(int64_t value = 0) {\n+      _value = value;\n+    }\n+    virtual void disable_feature() {\n+      _value = -1;\n@@ -60,2 +67,0 @@\n-    virtual void enable_feature(int64_t value = 0) = 0;\n-    virtual void disable_feature() = 0;\n@@ -65,0 +70,1 @@\n+    int64_t value()              { return _value; }\n@@ -67,1 +73,29 @@\n-    virtual void log_enabled() = 0;\n+\n+   protected:\n+    bool deps_all_enabled(RVFeatureValue* dep0, ...) {\n+      assert(dep0 != nullptr, \"must not\");\n+\n+      va_list va;\n+      va_start(va, dep0);\n+      RVFeatureValue* next = dep0;\n+      bool enabled = true;\n+      while (next != nullptr && enabled) {\n+        enabled = next->enabled();\n+        next = va_arg(va, RVFeatureValue*);\n+      }\n+      va_end(va);\n+      return enabled;\n+    }\n+\n+    void deps_string(stringStream& ss, RVFeatureValue* dep0, ...) {\n+      assert(dep0 != nullptr, \"must not\");\n+      ss.print(\"%s (%s)\", dep0->pretty(), dep0->enabled() ? \"enabled\" : \"disabled\");\n+\n+      va_list va;\n+      va_start(va, dep0);\n+      RVFeatureValue* next = nullptr;\n+      while ((next = va_arg(va, RVFeatureValue*)) != nullptr) {\n+        ss.print(\", %s (%s)\", next->pretty(), next->enabled() ? \"enabled\" : \"disabled\");\n+      }\n+      va_end(va);\n+    }\n@@ -86,1 +120,0 @@\n-      DEBUG_ONLY(verify_deps(dep0, ##__VA_ARGS__));                                                         \\\n@@ -88,1 +121,1 @@\n-        if (deps_all_enabled(dep0, ##__VA_ARGS__)) {                                                        \\\n+        if (this->deps_all_enabled(dep0, ##__VA_ARGS__)) {                                                  \\\n@@ -119,1 +152,0 @@\n-\n@@ -125,4 +157,0 @@\n-    int cpu_feature_index() {\n-      \/\/ Can be used to check, for example, v is declared before Zvfh in RV_EXT_FEATURE_FLAGS.\n-      return _cpu_feature_index;\n-    }\n@@ -133,0 +161,1 @@\n+      RVFeatureValue::enable_feature(value);\n@@ -136,0 +165,1 @@\n+      RVFeatureValue::disable_feature();\n@@ -138,52 +168,0 @@\n-    void log_enabled();\n-\n-   protected:\n-    bool deps_all_enabled(RVExtFeatureValue* dep0, ...) {\n-      assert(dep0 != nullptr, \"must not\");\n-\n-      va_list va;\n-      va_start(va, dep0);\n-      RVExtFeatureValue* next = dep0;\n-      bool enabled = true;\n-      while (next != nullptr && enabled) {\n-        enabled = next->enabled();\n-        next = va_arg(va, RVExtFeatureValue*);\n-      }\n-      va_end(va);\n-      return enabled;\n-    }\n-\n-    void deps_string(stringStream& ss, RVExtFeatureValue* dep0, ...) {\n-      assert(dep0 != nullptr, \"must not\");\n-      ss.print(\"%s (%s)\", dep0->pretty(), dep0->enabled() ? \"enabled\" : \"disabled\");\n-\n-      va_list va;\n-      va_start(va, dep0);\n-      RVExtFeatureValue* next = nullptr;\n-      while ((next = va_arg(va, RVExtFeatureValue*)) != nullptr) {\n-        ss.print(\", %s (%s)\", next->pretty(), next->enabled() ? \"enabled\" : \"disabled\");\n-      }\n-      va_end(va);\n-    }\n-\n-#ifdef ASSERT\n-    void verify_deps(RVExtFeatureValue* dep0, ...) {\n-      assert(dep0 != nullptr, \"must not\");\n-      assert(cpu_feature_index() >= 0, \"must\");\n-\n-      va_list va;\n-      va_start(va, dep0);\n-      RVExtFeatureValue* next = dep0;\n-      while (next != nullptr) {\n-        assert(next->cpu_feature_index() >= 0, \"must\");\n-        \/\/ We only need to check depenency relationship for extension flags.\n-        \/\/ The dependant ones must be declared before this, for example, v must be declared\n-        \/\/ before Zvfh in RV_EXT_FEATURE_FLAGS. The reason is in setup_cpu_available_features\n-        \/\/ we need to make sure v is `update_flag`ed before Zvfh, so Zvfh is `update_flag`ed\n-        \/\/ based on v.\n-        assert(cpu_feature_index() > next->cpu_feature_index(), \"Invalid\");\n-        next = va_arg(va, RVExtFeatureValue*);\n-      }\n-      va_end(va);\n-    }\n-#endif \/\/ ASSERT\n@@ -193,3 +171,1 @@\n-    static const int64_t DEFAULT_VALUE = -1;\n-    int64_t _value;\n-\n+    bool _enabled;\n@@ -199,1 +175,1 @@\n-      _value(DEFAULT_VALUE) {\n+      _enabled(false) {\n@@ -201,4 +177,8 @@\n-    bool enabled() { return _value != DEFAULT_VALUE; }\n-    void enable_feature(int64_t value) {\n-      assert(value != DEFAULT_VALUE, \"Sanity\");\n-      _value = value;\n+    bool enabled()               { return _enabled; }\n+    void enable_feature(int64_t value = 0) {\n+      RVFeatureValue::enable_feature(value);\n+      _enabled = true;\n+    }\n+    void disable_feature() {\n+      RVFeatureValue::disable_feature();\n+      _enabled = false;\n@@ -206,3 +186,0 @@\n-    void disable_feature() { _value = DEFAULT_VALUE; }\n-    int64_t value() { return _value; }\n-    void log_enabled();\n@@ -308,2 +285,0 @@\n-  \/* Manufactory JEDEC id encoded, ISA vol 2 3.1.2.. *\/                                        \\\n-  decl(mvendorid         ,  RV_NO_FLAG_BIT,  false,  NO_UPDATE_DEFAULT)                        \\\n@@ -316,0 +291,2 @@\n+  \/* Manufactory JEDEC id encoded, ISA vol 2 3.1.2.. *\/                                        \\\n+  decl(mvendorid         ,  RV_NO_FLAG_BIT,  false,  NO_UPDATE_DEFAULT)                        \\\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":54,"deletions":77,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -359,1 +359,1 @@\n-    __ z_csg($res$$Register, $newval$$Register, 0, $mem_ptr$$reg);\n+    __ z_csg($oldval$$Register, $newval$$Register, 0, $mem_ptr$$reg);\n","filename":"src\/hotspot\/cpu\/s390\/gc\/g1\/g1_s390.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,3 +38,0 @@\n-    \/\/ No hardware barriers are necessary. All members are volatile and the profiler\n-    \/\/ is run from a signal handler and only observers the thread its running on.\n-\n@@ -42,1 +39,1 @@\n-\n+    OrderAccess::release();\n@@ -44,0 +41,2 @@\n+    \/\/ Fence?\n+    OrderAccess::fence();\n@@ -50,0 +49,2 @@\n+\n+    OrderAccess::release();\n@@ -54,3 +55,1 @@\n-    \/\/ No hardware barriers are necessary. All members are volatile and the profiler\n-    \/\/ is run from a signal handler and only observers the thread its running on.\n-\n+    \/\/ In order to make sure the transition state is valid for \"this\"\n@@ -58,0 +57,4 @@\n+    \/\/ Hack Alert: Temporary bugfix for 4717480\/4721647\n+    \/\/ To act like previous version (pd_cache_state) don't null _last_Java_sp\n+    \/\/ unless the value is changing.\n+    \/\/\n@@ -59,0 +62,1 @@\n+      OrderAccess::release();\n@@ -60,0 +64,1 @@\n+      OrderAccess::fence();\n@@ -64,0 +69,1 @@\n+    OrderAccess::release();\n@@ -77,1 +83,1 @@\n-  void set_last_Java_sp(intptr_t* sp) { _last_Java_sp = sp; }\n+  void set_last_Java_sp(intptr_t* sp) { OrderAccess::release(); _last_Java_sp = sp; }\n","filename":"src\/hotspot\/cpu\/s390\/javaFrameAnchor_s390.hpp","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1964,1 +1964,1 @@\n-const RegMask& Matcher::divI_proj_mask() {\n+RegMask Matcher::divI_proj_mask() {\n@@ -1969,1 +1969,1 @@\n-const RegMask& Matcher::modI_proj_mask() {\n+RegMask Matcher::modI_proj_mask() {\n@@ -1974,1 +1974,1 @@\n-const RegMask& Matcher::divL_proj_mask() {\n+RegMask Matcher::divL_proj_mask() {\n@@ -1979,1 +1979,1 @@\n-const RegMask& Matcher::modL_proj_mask() {\n+RegMask Matcher::modL_proj_mask() {\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -474,9 +474,9 @@\n-  caller_saved.insert(OptoReg::as_OptoReg(rax->as_VMReg()));\n-  caller_saved.insert(OptoReg::as_OptoReg(rcx->as_VMReg()));\n-  caller_saved.insert(OptoReg::as_OptoReg(rdx->as_VMReg()));\n-  caller_saved.insert(OptoReg::as_OptoReg(rsi->as_VMReg()));\n-  caller_saved.insert(OptoReg::as_OptoReg(rdi->as_VMReg()));\n-  caller_saved.insert(OptoReg::as_OptoReg(r8->as_VMReg()));\n-  caller_saved.insert(OptoReg::as_OptoReg(r9->as_VMReg()));\n-  caller_saved.insert(OptoReg::as_OptoReg(r10->as_VMReg()));\n-  caller_saved.insert(OptoReg::as_OptoReg(r11->as_VMReg()));\n+  caller_saved.Insert(OptoReg::as_OptoReg(rax->as_VMReg()));\n+  caller_saved.Insert(OptoReg::as_OptoReg(rcx->as_VMReg()));\n+  caller_saved.Insert(OptoReg::as_OptoReg(rdx->as_VMReg()));\n+  caller_saved.Insert(OptoReg::as_OptoReg(rsi->as_VMReg()));\n+  caller_saved.Insert(OptoReg::as_OptoReg(rdi->as_VMReg()));\n+  caller_saved.Insert(OptoReg::as_OptoReg(r8->as_VMReg()));\n+  caller_saved.Insert(OptoReg::as_OptoReg(r9->as_VMReg()));\n+  caller_saved.Insert(OptoReg::as_OptoReg(r10->as_VMReg()));\n+  caller_saved.Insert(OptoReg::as_OptoReg(r11->as_VMReg()));\n@@ -485,16 +485,16 @@\n-    caller_saved.insert(OptoReg::as_OptoReg(r16->as_VMReg()));\n-    caller_saved.insert(OptoReg::as_OptoReg(r17->as_VMReg()));\n-    caller_saved.insert(OptoReg::as_OptoReg(r18->as_VMReg()));\n-    caller_saved.insert(OptoReg::as_OptoReg(r19->as_VMReg()));\n-    caller_saved.insert(OptoReg::as_OptoReg(r20->as_VMReg()));\n-    caller_saved.insert(OptoReg::as_OptoReg(r21->as_VMReg()));\n-    caller_saved.insert(OptoReg::as_OptoReg(r22->as_VMReg()));\n-    caller_saved.insert(OptoReg::as_OptoReg(r23->as_VMReg()));\n-    caller_saved.insert(OptoReg::as_OptoReg(r24->as_VMReg()));\n-    caller_saved.insert(OptoReg::as_OptoReg(r25->as_VMReg()));\n-    caller_saved.insert(OptoReg::as_OptoReg(r26->as_VMReg()));\n-    caller_saved.insert(OptoReg::as_OptoReg(r27->as_VMReg()));\n-    caller_saved.insert(OptoReg::as_OptoReg(r28->as_VMReg()));\n-    caller_saved.insert(OptoReg::as_OptoReg(r29->as_VMReg()));\n-    caller_saved.insert(OptoReg::as_OptoReg(r30->as_VMReg()));\n-    caller_saved.insert(OptoReg::as_OptoReg(r31->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r16->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r17->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r18->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r19->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r20->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r21->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r22->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r23->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r24->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r25->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r26->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r27->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r28->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r29->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r30->as_VMReg()));\n+    caller_saved.Insert(OptoReg::as_OptoReg(r31->as_VMReg()));\n@@ -514,1 +514,1 @@\n-      if (caller_saved.member(opto_reg)) {\n+      if (caller_saved.Member(opto_reg)) {\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.cpp","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -500,1 +500,1 @@\n-  _ANY_REG_mask.assignFrom(_ALL_REG_mask);\n+  _ANY_REG_mask = _ALL_REG_mask;\n@@ -503,2 +503,2 @@\n-    _ANY_REG_mask.remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n-    _ANY_REG_mask.remove(OptoReg::as_OptoReg(rbp->as_VMReg()->next()));\n+    _ANY_REG_mask.Remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n+    _ANY_REG_mask.Remove(OptoReg::as_OptoReg(rbp->as_VMReg()->next()));\n@@ -507,2 +507,2 @@\n-    _ANY_REG_mask.remove(OptoReg::as_OptoReg(r12->as_VMReg()));\n-    _ANY_REG_mask.remove(OptoReg::as_OptoReg(r12->as_VMReg()->next()));\n+    _ANY_REG_mask.Remove(OptoReg::as_OptoReg(r12->as_VMReg()));\n+    _ANY_REG_mask.Remove(OptoReg::as_OptoReg(r12->as_VMReg()->next()));\n@@ -511,5 +511,5 @@\n-  _PTR_REG_mask.assignFrom(_ANY_REG_mask);\n-  _PTR_REG_mask.remove(OptoReg::as_OptoReg(rsp->as_VMReg()));\n-  _PTR_REG_mask.remove(OptoReg::as_OptoReg(rsp->as_VMReg()->next()));\n-  _PTR_REG_mask.remove(OptoReg::as_OptoReg(r15->as_VMReg()));\n-  _PTR_REG_mask.remove(OptoReg::as_OptoReg(r15->as_VMReg()->next()));\n+  _PTR_REG_mask = _ANY_REG_mask;\n+  _PTR_REG_mask.Remove(OptoReg::as_OptoReg(rsp->as_VMReg()));\n+  _PTR_REG_mask.Remove(OptoReg::as_OptoReg(rsp->as_VMReg()->next()));\n+  _PTR_REG_mask.Remove(OptoReg::as_OptoReg(r15->as_VMReg()));\n+  _PTR_REG_mask.Remove(OptoReg::as_OptoReg(r15->as_VMReg()->next()));\n@@ -518,2 +518,2 @@\n-      _PTR_REG_mask.remove(OptoReg::as_OptoReg(egprs[i]->as_VMReg()));\n-      _PTR_REG_mask.remove(OptoReg::as_OptoReg(egprs[i]->as_VMReg()->next()));\n+      _PTR_REG_mask.Remove(OptoReg::as_OptoReg(egprs[i]->as_VMReg()));\n+      _PTR_REG_mask.Remove(OptoReg::as_OptoReg(egprs[i]->as_VMReg()->next()));\n@@ -523,2 +523,2 @@\n-  _STACK_OR_PTR_REG_mask.assignFrom(_PTR_REG_mask);\n-  _STACK_OR_PTR_REG_mask.or_with(STACK_OR_STACK_SLOTS_mask());\n+  _STACK_OR_PTR_REG_mask = _PTR_REG_mask;\n+  _STACK_OR_PTR_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());\n@@ -526,3 +526,3 @@\n-  _PTR_REG_NO_RBP_mask.assignFrom(_PTR_REG_mask);\n-  _PTR_REG_NO_RBP_mask.remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n-  _PTR_REG_NO_RBP_mask.remove(OptoReg::as_OptoReg(rbp->as_VMReg()->next()));\n+  _PTR_REG_NO_RBP_mask = _PTR_REG_mask;\n+  _PTR_REG_NO_RBP_mask.Remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n+  _PTR_REG_NO_RBP_mask.Remove(OptoReg::as_OptoReg(rbp->as_VMReg()->next()));\n@@ -530,3 +530,3 @@\n-  _PTR_NO_RAX_REG_mask.assignFrom(_PTR_REG_mask);\n-  _PTR_NO_RAX_REG_mask.remove(OptoReg::as_OptoReg(rax->as_VMReg()));\n-  _PTR_NO_RAX_REG_mask.remove(OptoReg::as_OptoReg(rax->as_VMReg()->next()));\n+  _PTR_NO_RAX_REG_mask = _PTR_REG_mask;\n+  _PTR_NO_RAX_REG_mask.Remove(OptoReg::as_OptoReg(rax->as_VMReg()));\n+  _PTR_NO_RAX_REG_mask.Remove(OptoReg::as_OptoReg(rax->as_VMReg()->next()));\n@@ -534,3 +534,3 @@\n-  _PTR_NO_RAX_RBX_REG_mask.assignFrom(_PTR_NO_RAX_REG_mask);\n-  _PTR_NO_RAX_RBX_REG_mask.remove(OptoReg::as_OptoReg(rbx->as_VMReg()));\n-  _PTR_NO_RAX_RBX_REG_mask.remove(OptoReg::as_OptoReg(rbx->as_VMReg()->next()));\n+  _PTR_NO_RAX_RBX_REG_mask = _PTR_NO_RAX_REG_mask;\n+  _PTR_NO_RAX_RBX_REG_mask.Remove(OptoReg::as_OptoReg(rbx->as_VMReg()));\n+  _PTR_NO_RAX_RBX_REG_mask.Remove(OptoReg::as_OptoReg(rbx->as_VMReg()->next()));\n@@ -539,3 +539,3 @@\n-  _LONG_REG_mask.assignFrom(_PTR_REG_mask);\n-  _STACK_OR_LONG_REG_mask.assignFrom(_LONG_REG_mask);\n-  _STACK_OR_LONG_REG_mask.or_with(STACK_OR_STACK_SLOTS_mask());\n+  _LONG_REG_mask = _PTR_REG_mask;\n+  _STACK_OR_LONG_REG_mask = _LONG_REG_mask;\n+  _STACK_OR_LONG_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());\n@@ -543,5 +543,5 @@\n-  _LONG_NO_RAX_RDX_REG_mask.assignFrom(_LONG_REG_mask);\n-  _LONG_NO_RAX_RDX_REG_mask.remove(OptoReg::as_OptoReg(rax->as_VMReg()));\n-  _LONG_NO_RAX_RDX_REG_mask.remove(OptoReg::as_OptoReg(rax->as_VMReg()->next()));\n-  _LONG_NO_RAX_RDX_REG_mask.remove(OptoReg::as_OptoReg(rdx->as_VMReg()));\n-  _LONG_NO_RAX_RDX_REG_mask.remove(OptoReg::as_OptoReg(rdx->as_VMReg()->next()));\n+  _LONG_NO_RAX_RDX_REG_mask = _LONG_REG_mask;\n+  _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax->as_VMReg()));\n+  _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax->as_VMReg()->next()));\n+  _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx->as_VMReg()));\n+  _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx->as_VMReg()->next()));\n@@ -549,3 +549,3 @@\n-  _LONG_NO_RCX_REG_mask.assignFrom(_LONG_REG_mask);\n-  _LONG_NO_RCX_REG_mask.remove(OptoReg::as_OptoReg(rcx->as_VMReg()));\n-  _LONG_NO_RCX_REG_mask.remove(OptoReg::as_OptoReg(rcx->as_VMReg()->next()));\n+  _LONG_NO_RCX_REG_mask = _LONG_REG_mask;\n+  _LONG_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx->as_VMReg()));\n+  _LONG_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx->as_VMReg()->next()));\n@@ -553,5 +553,5 @@\n-  _LONG_NO_RBP_R13_REG_mask.assignFrom(_LONG_REG_mask);\n-  _LONG_NO_RBP_R13_REG_mask.remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n-  _LONG_NO_RBP_R13_REG_mask.remove(OptoReg::as_OptoReg(rbp->as_VMReg()->next()));\n-  _LONG_NO_RBP_R13_REG_mask.remove(OptoReg::as_OptoReg(r13->as_VMReg()));\n-  _LONG_NO_RBP_R13_REG_mask.remove(OptoReg::as_OptoReg(r13->as_VMReg()->next()));\n+  _LONG_NO_RBP_R13_REG_mask = _LONG_REG_mask;\n+  _LONG_NO_RBP_R13_REG_mask.Remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n+  _LONG_NO_RBP_R13_REG_mask.Remove(OptoReg::as_OptoReg(rbp->as_VMReg()->next()));\n+  _LONG_NO_RBP_R13_REG_mask.Remove(OptoReg::as_OptoReg(r13->as_VMReg()));\n+  _LONG_NO_RBP_R13_REG_mask.Remove(OptoReg::as_OptoReg(r13->as_VMReg()->next()));\n@@ -559,1 +559,1 @@\n-  _INT_REG_mask.assignFrom(_ALL_INT_REG_mask);\n+  _INT_REG_mask = _ALL_INT_REG_mask;\n@@ -562,1 +562,1 @@\n-      _INT_REG_mask.remove(OptoReg::as_OptoReg(egprs[i]->as_VMReg()));\n+      _INT_REG_mask.Remove(OptoReg::as_OptoReg(egprs[i]->as_VMReg()));\n@@ -567,1 +567,1 @@\n-    _INT_REG_mask.remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n+    _INT_REG_mask.Remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n@@ -570,1 +570,1 @@\n-    _INT_REG_mask.remove(OptoReg::as_OptoReg(r12->as_VMReg()));\n+    _INT_REG_mask.Remove(OptoReg::as_OptoReg(r12->as_VMReg()));\n@@ -573,2 +573,2 @@\n-  _STACK_OR_INT_REG_mask.assignFrom(_INT_REG_mask);\n-  _STACK_OR_INT_REG_mask.or_with(STACK_OR_STACK_SLOTS_mask());\n+  _STACK_OR_INT_REG_mask = _INT_REG_mask;\n+  _STACK_OR_INT_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());\n@@ -576,3 +576,3 @@\n-  _INT_NO_RAX_RDX_REG_mask.assignFrom(_INT_REG_mask);\n-  _INT_NO_RAX_RDX_REG_mask.remove(OptoReg::as_OptoReg(rax->as_VMReg()));\n-  _INT_NO_RAX_RDX_REG_mask.remove(OptoReg::as_OptoReg(rdx->as_VMReg()));\n+  _INT_NO_RAX_RDX_REG_mask = _INT_REG_mask;\n+  _INT_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax->as_VMReg()));\n+  _INT_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx->as_VMReg()));\n@@ -580,2 +580,2 @@\n-  _INT_NO_RCX_REG_mask.assignFrom(_INT_REG_mask);\n-  _INT_NO_RCX_REG_mask.remove(OptoReg::as_OptoReg(rcx->as_VMReg()));\n+  _INT_NO_RCX_REG_mask = _INT_REG_mask;\n+  _INT_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx->as_VMReg()));\n@@ -583,3 +583,3 @@\n-  _INT_NO_RBP_R13_REG_mask.assignFrom(_INT_REG_mask);\n-  _INT_NO_RBP_R13_REG_mask.remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n-  _INT_NO_RBP_R13_REG_mask.remove(OptoReg::as_OptoReg(r13->as_VMReg()));\n+  _INT_NO_RBP_R13_REG_mask = _INT_REG_mask;\n+  _INT_NO_RBP_R13_REG_mask.Remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n+  _INT_NO_RBP_R13_REG_mask.Remove(OptoReg::as_OptoReg(r13->as_VMReg()));\n@@ -589,1 +589,1 @@\n-  _FLOAT_REG_mask.assignFrom(VM_Version::supports_evex() ? _FLOAT_REG_EVEX_mask : _FLOAT_REG_LEGACY_mask);\n+  _FLOAT_REG_mask = VM_Version::supports_evex() ? _FLOAT_REG_EVEX_mask : _FLOAT_REG_LEGACY_mask;\n@@ -759,1 +759,1 @@\n-const RegMask& MachConstantBaseNode::_out_RegMask = RegMask::EMPTY;\n+const RegMask& MachConstantBaseNode::_out_RegMask = RegMask::Empty;\n@@ -1661,1 +1661,1 @@\n-  return (INTPRESSURE == -1) ? _INT_REG_mask.size() : INTPRESSURE;\n+  return (INTPRESSURE == -1) ? _INT_REG_mask.Size() : INTPRESSURE;\n@@ -1669,1 +1669,1 @@\n-  uint default_float_pressure_threshold = _FLOAT_REG_mask.size() - dec_count;\n+  uint default_float_pressure_threshold = _FLOAT_REG_mask.Size() - dec_count;\n@@ -1681,1 +1681,1 @@\n-const RegMask& Matcher::divI_proj_mask() {\n+RegMask Matcher::divI_proj_mask() {\n@@ -1686,1 +1686,1 @@\n-const RegMask& Matcher::modI_proj_mask() {\n+RegMask Matcher::modI_proj_mask() {\n@@ -1691,1 +1691,1 @@\n-const RegMask& Matcher::divL_proj_mask() {\n+RegMask Matcher::divL_proj_mask() {\n@@ -1696,1 +1696,1 @@\n-const RegMask& Matcher::modL_proj_mask() {\n+RegMask Matcher::modL_proj_mask() {\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":61,"deletions":61,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -49,4 +49,0 @@\n-\n-int ZNUMA::numa_id_to_node(uint32_t numa_id) {\n-  ShouldNotCallThis();\n-}\n","filename":"src\/hotspot\/os\/bsd\/gc\/z\/zNUMA_bsd.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,3 +35,0 @@\n-static uint* z_numa_id_to_node = nullptr;\n-static uint32_t* z_node_to_numa_id = nullptr;\n-\n@@ -41,20 +38,0 @@\n-  size_t configured_nodes = 0;\n-\n-  if (UseNUMA) {\n-    const size_t max_nodes = os::Linux::numa_num_configured_nodes();\n-    z_numa_id_to_node = NEW_C_HEAP_ARRAY(uint, max_nodes, mtGC);\n-    configured_nodes = os::numa_get_leaf_groups(z_numa_id_to_node, 0);\n-\n-    z_node_to_numa_id = NEW_C_HEAP_ARRAY(uint32_t, max_nodes, mtGC);\n-\n-    \/\/ Fill the array with invalid NUMA ids\n-    for (uint32_t i = 0; i < max_nodes; i++) {\n-      z_node_to_numa_id[i] = (uint32_t)-1;\n-    }\n-\n-    \/\/ Fill the reverse mappings\n-    for (uint32_t i = 0; i < configured_nodes; i++) {\n-      z_node_to_numa_id[z_numa_id_to_node[i]] = i;\n-    }\n-  }\n-\n@@ -63,1 +40,1 @@\n-      ? configured_nodes\n+      ? os::Linux::numa_max_node() + 1\n@@ -80,1 +57,1 @@\n-  return z_node_to_numa_id[os::Linux::get_node_by_cpu(ZCPU::id())];\n+  return os::Linux::get_node_by_cpu(ZCPU::id());\n@@ -89,1 +66,1 @@\n-  int node = -1;\n+  uint32_t id = (uint32_t)-1;\n@@ -91,1 +68,1 @@\n-  if (ZSyscall::get_mempolicy(&node, nullptr, 0, (void*)addr, MPOL_F_NODE | MPOL_F_ADDR) == -1) {\n+  if (ZSyscall::get_mempolicy((int*)&id, nullptr, 0, (void*)addr, MPOL_F_NODE | MPOL_F_ADDR) == -1) {\n@@ -96,8 +73,1 @@\n-  DEBUG_ONLY(const int max_nodes = os::Linux::numa_num_configured_nodes();)\n-  assert(node < max_nodes, \"NUMA node is out of bounds node=%d, max=%d\", node, max_nodes);\n-\n-  return z_node_to_numa_id[node];\n-}\n-\n-int ZNUMA::numa_id_to_node(uint32_t numa_id) {\n-  assert(numa_id < _count, \"NUMA id out of range 0 <= %ud <= %ud\", numa_id, _count);\n+  assert(id < _count, \"Invalid NUMA id\");\n@@ -105,1 +75,1 @@\n-  return (int)z_numa_id_to_node[numa_id];\n+  return id;\n","filename":"src\/hotspot\/os\/linux\/gc\/z\/zNUMA_linux.cpp","additions":6,"deletions":36,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -632,1 +632,1 @@\n-  os::Linux::numa_set_preferred(ZNUMA::numa_id_to_node(numa_id));\n+  os::Linux::numa_set_preferred((int)numa_id);\n","filename":"src\/hotspot\/os\/linux\/gc\/z\/zPhysicalMemoryBacking_linux.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"logging\/logStream.hpp\"\n@@ -75,1 +74,3 @@\n-    log_debug(perf)(\"could not commit PerfData memory\");\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"Could not commit PerfData memory\\n\");\n+    }\n@@ -299,2 +300,1 @@\n-    if (log_is_enabled(Debug, perf)) {\n-      LogStreamHandle(Debug, perf) log;\n+    if (PrintMiscellaneous && Verbose) {\n@@ -302,1 +302,1 @@\n-        log.print_cr(\"directory %s is a symlink and is not secure\", dirname);\n+        warning(\"directory %s is a symlink and is not secure\\n\", dirname);\n@@ -304,1 +304,1 @@\n-        log.print_cr(\"could not open directory %s: %s\", dirname, os::strerror(errno));\n+        warning(\"could not open directory %s: %s\\n\", dirname, os::strerror(errno));\n@@ -374,1 +374,3 @@\n-    log_debug(perf)(\"could not change to directory %s\", dirname);\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"could not change to directory %s\", dirname);\n+    }\n@@ -412,1 +414,3 @@\n-    log_debug(perf)(\"fstat failed on %s: %s\", filename, os::strerror(errno));\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"fstat failed on %s: %s\\n\", filename, os::strerror(errno));\n+    }\n@@ -417,1 +421,3 @@\n-    log_debug(perf)(\"file %s has multiple links\", filename);\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"file %s has multiple links\\n\", filename);\n+    }\n@@ -444,2 +450,1 @@\n-    if (log_is_enabled(Debug, perf)) {\n-      LogStreamHandle(Debug, perf) log;\n+    if (PrintMiscellaneous && Verbose) {\n@@ -447,1 +452,2 @@\n-        log.print_cr(\"Could not retrieve passwd entry: %s\", os::strerror(result));\n+        warning(\"Could not retrieve passwd entry: %s\\n\",\n+                os::strerror(result));\n@@ -460,1 +466,2 @@\n-        log.print_cr(\"Could not retrieve passwd entry: %s\", os::strerror(errno));\n+        warning(\"Could not retrieve passwd entry: %s\\n\",\n+                os::strerror(errno));\n@@ -463,2 +470,3 @@\n-        log.print_cr(\"Could not determine user name: %s\",\n-                     p->pw_name == nullptr ? \"pw_name = null\" : \"pw_name zero length\");\n+        warning(\"Could not determine user name: %s\\n\",\n+                p->pw_name == nullptr ? \"pw_name = null\" :\n+                                     \"pw_name zero length\");\n@@ -675,1 +683,1 @@\n-  if (log_is_enabled(Debug, perf) && result == OS_ERR) {\n+  if (PrintMiscellaneous && Verbose && result == OS_ERR) {\n@@ -677,2 +685,2 @@\n-      log_debug(perf)(\"could not unlink shared memory backing store file %s : %s\",\n-                      path, os::strerror(errno));\n+      warning(\"Could not unlink shared memory backing\"\n+              \" store file %s : %s\\n\", path, os::strerror(errno));\n@@ -814,0 +822,1 @@\n+      \/\/\n@@ -816,1 +825,3 @@\n-        log_debug(perf)(\"%s directory is insecure\", dirname);\n+        if (PrintMiscellaneous && Verbose) {\n+          warning(\"%s directory is insecure\\n\", dirname);\n+        }\n@@ -823,1 +834,5 @@\n-      log_debug(perf)(\"could not create directory %s: %s\", dirname, os::strerror(errno));\n+      \/\/\n+      if (PrintMiscellaneous && Verbose) {\n+        warning(\"could not create directory %s: %s\\n\",\n+                dirname, os::strerror(errno));\n+      }\n@@ -860,2 +875,1 @@\n-    if (log_is_enabled(Debug, perf)) {\n-      LogStreamHandle(Debug, perf) log;\n+    if (PrintMiscellaneous && Verbose) {\n@@ -863,1 +877,1 @@\n-        log.print_cr(\"file %s is a symlink and is not secure\", filename);\n+        warning(\"file %s is a symlink and is not secure\\n\", filename);\n@@ -865,1 +879,1 @@\n-        log.print_cr(\"could not create file %s: %s\", filename, os::strerror(errno));\n+        warning(\"could not create file %s: %s\\n\", filename, os::strerror(errno));\n@@ -913,1 +927,3 @@\n-    log_debug(perf)(\"could not truncate shared memory file: %s\", os::strerror(errno));\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"could not truncate shared memory file: %s\\n\", os::strerror(errno));\n+    }\n@@ -920,1 +936,3 @@\n-    log_debug(perf)(\"could not set shared memory file size: %s\", os::strerror(errno));\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"could not set shared memory file size: %s\\n\", os::strerror(errno));\n+    }\n@@ -1042,1 +1060,3 @@\n-    log_debug(perf)(\"mmap failed - %s\", os::strerror(errno));\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"mmap failed -  %s\\n\", os::strerror(errno));\n+    }\n@@ -1118,1 +1138,3 @@\n-    log_debug(perf)(\"fstat failed: %s\", os::strerror(errno));\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"fstat failed: %s\\n\", os::strerror(errno));\n+    }\n@@ -1193,1 +1215,3 @@\n-    log_debug(perf)(\"mmap failed: %s\", os::strerror(errno));\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"mmap failed: %s\\n\", os::strerror(errno));\n+    }\n@@ -1223,0 +1247,1 @@\n+\n@@ -1225,1 +1250,4 @@\n-      log_debug(perf)(\"Reverting to non-shared PerfMemory region.\");\n+      \/\/\n+      if (PrintMiscellaneous && Verbose) {\n+        warning(\"Reverting to non-shared PerfMemory region.\\n\");\n+      }\n","filename":"src\/hotspot\/os\/posix\/perfMemory_posix.cpp","additions":58,"deletions":30,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-#include \"utilities\/deferredStatic.hpp\"\n@@ -171,1 +170,1 @@\n-static DeferredStatic<OSXSemaphore> sr_semaphore;\n+  static OSXSemaphore sr_semaphore;\n@@ -173,1 +172,1 @@\n-static DeferredStatic<PosixSemaphore> sr_semaphore;\n+  static PosixSemaphore sr_semaphore;\n@@ -181,1 +180,1 @@\n-static DeferredStatic<Semaphore> sig_semaphore;\n+static Semaphore* sig_semaphore = nullptr;\n@@ -355,2 +354,1 @@\n-  int sem_count = 0;\n-  sig_semaphore.initialize(sem_count);\n+  sig_semaphore = new Semaphore();\n@@ -360,3 +358,1 @@\n-  \/\/ Signal thread is not created with ReduceSignalUsage and jdk_misc_signal_init\n-  \/\/ initialization isn't called.\n-  if (!ReduceSignalUsage) {\n+  if (sig_semaphore != nullptr) {\n@@ -365,0 +361,4 @@\n+  } else {\n+    \/\/ Signal thread is not created with ReduceSignalUsage and jdk_misc_signal_init\n+    \/\/ initialization isn't called.\n+    assert(ReduceSignalUsage, \"signal semaphore should be created\");\n@@ -1699,1 +1699,1 @@\n-      sr_semaphore->signal();\n+      sr_semaphore.signal();\n@@ -1708,1 +1708,1 @@\n-          sr_semaphore->signal();\n+          sr_semaphore.signal();\n@@ -1734,3 +1734,0 @@\n-  int sem_count = 0;\n-  sr_semaphore.initialize(sem_count);\n-\n@@ -1784,1 +1781,1 @@\n-  assert(!sr_semaphore->trywait(), \"semaphore has invalid state\");\n+  assert(!sr_semaphore.trywait(), \"semaphore has invalid state\");\n@@ -1799,1 +1796,1 @@\n-    if (sr_semaphore->timedwait(2)) {\n+    if (sr_semaphore.timedwait(2)) {\n@@ -1808,1 +1805,1 @@\n-        sr_semaphore->wait();\n+        sr_semaphore.wait();\n@@ -1823,1 +1820,1 @@\n-  assert(!sr_semaphore->trywait(), \"invalid semaphore state\");\n+  assert(!sr_semaphore.trywait(), \"invalid semaphore state\");\n@@ -1833,1 +1830,1 @@\n-      if (sr_semaphore->timedwait(2)) {\n+      if (sr_semaphore.timedwait(2)) {\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":16,"deletions":19,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -49,4 +49,0 @@\n-\n-int ZNUMA::numa_id_to_node(uint32_t numa_id) {\n-  ShouldNotCallThis();\n-}\n","filename":"src\/hotspot\/os\/windows\/gc\/z\/zNUMA_windows.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -6262,103 +6262,0 @@\n-\n-\/*\n- * Windows\/x64 does not use stack frames the way expected by Java:\n- * [1] in most cases, there is no frame pointer. All locals are addressed via RSP\n- * [2] in rare cases, when alloca() is used, a frame pointer is used, but this may\n- *     not be RBP.\n- * See http:\/\/msdn.microsoft.com\/en-us\/library\/ew5tede7.aspx\n- *\n- * So it's not possible to print the native stack using the\n- *     while (...) {...  fr = os::get_sender_for_C_frame(&fr); }\n- * loop in vmError.cpp. We need to roll our own loop.\n- * This approach works for Windows AArch64 as well.\n- *\/\n-bool os::win32::platform_print_native_stack(outputStream* st, const void* context,\n-                                            char* buf, int buf_size, address& lastpc)\n-{\n-  CONTEXT ctx;\n-  if (context != nullptr) {\n-    memcpy(&ctx, context, sizeof(ctx));\n-  } else {\n-    RtlCaptureContext(&ctx);\n-  }\n-\n-  st->print_cr(\"Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)\");\n-\n-  DWORD machine_type;\n-  STACKFRAME stk;\n-  memset(&stk, 0, sizeof(stk));\n-  stk.AddrStack.Mode      = AddrModeFlat;\n-  stk.AddrFrame.Mode      = AddrModeFlat;\n-  stk.AddrPC.Mode         = AddrModeFlat;\n-\n-#if defined(_M_AMD64)\n-  stk.AddrStack.Offset    = ctx.Rsp;\n-  stk.AddrFrame.Offset    = ctx.Rbp;\n-  stk.AddrPC.Offset       = ctx.Rip;\n-  machine_type            = IMAGE_FILE_MACHINE_AMD64;\n-#elif defined(_M_ARM64)\n-  stk.AddrStack.Offset    = ctx.Sp;\n-  stk.AddrFrame.Offset    = ctx.Fp;\n-  stk.AddrPC.Offset       = ctx.Pc;\n-  machine_type            = IMAGE_FILE_MACHINE_ARM64;\n-#else\n-  #error unknown architecture\n-#endif\n-\n-  \/\/ Ensure we consider dynamically loaded DLLs\n-  SymbolEngine::refreshModuleList();\n-\n-  int count = 0;\n-  address lastpc_internal = 0;\n-  while (count++ < StackPrintLimit) {\n-    intptr_t* sp = (intptr_t*)stk.AddrStack.Offset;\n-    intptr_t* fp = (intptr_t*)stk.AddrFrame.Offset; \/\/ NOT necessarily the same as ctx.Rbp!\n-    address pc = (address)stk.AddrPC.Offset;\n-\n-    if (pc != nullptr) {\n-      if (count == 2 && lastpc_internal == pc) {\n-        \/\/ Skip it -- StackWalk64() may return the same PC\n-        \/\/ (but different SP) on the first try.\n-      } else {\n-        \/\/ Don't try to create a frame(sp, fp, pc) -- on WinX64, stk.AddrFrame\n-        \/\/ may not contain what Java expects, and may cause the frame() constructor\n-        \/\/ to crash. Let's just print out the symbolic address.\n-        frame::print_C_frame(st, buf, buf_size, pc);\n-        \/\/ print source file and line, if available\n-        char buf[128];\n-        int line_no;\n-        if (SymbolEngine::get_source_info(pc, buf, sizeof(buf), &line_no)) {\n-          st->print(\"  (%s:%d)\", buf, line_no);\n-        } else {\n-          st->print(\"  (no source info available)\");\n-        }\n-        st->cr();\n-      }\n-      lastpc_internal = pc;\n-    }\n-\n-    PVOID p = WindowsDbgHelp::symFunctionTableAccess64(GetCurrentProcess(), stk.AddrPC.Offset);\n-    if (p == nullptr) {\n-      \/\/ StackWalk64() can't handle this PC. Calling StackWalk64 again may cause crash.\n-      lastpc = lastpc_internal;\n-      break;\n-    }\n-\n-    BOOL result = WindowsDbgHelp::stackWalk64(\n-        machine_type,              \/\/ __in      DWORD MachineType,\n-        GetCurrentProcess(),       \/\/ __in      HANDLE hProcess,\n-        GetCurrentThread(),        \/\/ __in      HANDLE hThread,\n-        &stk,                      \/\/ __inout   LP STACKFRAME64 StackFrame,\n-        &ctx);                     \/\/ __inout   PVOID ContextRecord,\n-\n-    if (!result) {\n-      break;\n-    }\n-  }\n-  if (count > StackPrintLimit) {\n-    st->print_cr(\"...<more frames>...\");\n-  }\n-  st->cr();\n-\n-  return true;\n-}\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":0,"deletions":103,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"logging\/logStream.hpp\"\n@@ -45,1 +44,5 @@\n-#include <securitybaseapi.h>\n+\n+typedef BOOL (WINAPI *SetSecurityDescriptorControlFnPtr)(\n+   IN PSECURITY_DESCRIPTOR pSecurityDescriptor,\n+   IN SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest,\n+   IN SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet);\n@@ -62,1 +65,3 @@\n-    log_debug(perf)(\"could not commit PerfData memory\");\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"Could not commit PerfData memory\\n\");\n+    }\n@@ -88,1 +93,1 @@\n-  assert(destfile[0] != '\\0', \"invalid PerfData file path\");\n+  assert(destfile[0] != '\\0', \"invalid Perfdata file path\");\n@@ -94,2 +99,4 @@\n-    log_debug(perf)(\"could not create PerfData save file: %s: %s\",\n-                    destfile, os::strerror(errno));\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"Could not create Perfdata save file: %s: %s\\n\",\n+              destfile, os::strerror(errno));\n+    }\n@@ -101,2 +108,4 @@\n-        log_debug(perf)(\"could not write PerfData save file: %s: %s\",\n-                        destfile, os::strerror(errno));\n+        if (PrintMiscellaneous && Verbose) {\n+          warning(\"Could not write Perfdata save file: %s: %s\\n\",\n+                  destfile, os::strerror(errno));\n+        }\n@@ -111,2 +120,4 @@\n-    if (result == OS_ERR) {\n-      log_debug(perf)(\"could not close %s: %s\", destfile, os::strerror(errno));\n+    if (PrintMiscellaneous && Verbose) {\n+      if (result == OS_ERR) {\n+        warning(\"Could not close %s: %s\\n\", destfile, os::strerror(errno));\n+      }\n@@ -212,2 +223,4 @@\n-      log_debug(perf)(\"could not get attributes for file %s: lasterror = %d\",\n-                      path, lasterror);\n+      if (PrintMiscellaneous && Verbose) {\n+        warning(\"could not get attributes for file %s: \"\n+                \" lasterror = %d\\n\", path, lasterror);\n+      }\n@@ -224,1 +237,3 @@\n-    log_debug(perf)(\"%s is a reparse point\", path);\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"%s is a reparse point\\n\", path);\n+    }\n@@ -241,2 +256,4 @@\n-    log_debug(perf)(\"%s is not a directory, file attributes : \"\n-                    INTPTR_FORMAT, path, fa);\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"%s is not a directory, file attributes = \"\n+              INTPTR_FORMAT \"\\n\", path, fa);\n+    }\n@@ -478,3 +495,5 @@\n-    if (errno != ENOENT) {\n-      log_debug(perf)(\"could not unlink shared memory backing store file %s : %s\",\n-                      path, os::strerror(errno));\n+    if (PrintMiscellaneous && Verbose) {\n+      if (errno != ENOENT) {\n+        warning(\"Could not unlink shared memory backing\"\n+                \" store file %s : %s\\n\", path, os::strerror(errno));\n+      }\n@@ -499,3 +518,5 @@\n-    DWORD lastError = GetLastError();\n-    if (lastError != ERROR_INVALID_PARAMETER) {\n-      log_debug(perf)(\"OpenProcess failed: %d\", lastError);\n+    if (PrintMiscellaneous && Verbose) {\n+      DWORD lastError = GetLastError();\n+      if (lastError != ERROR_INVALID_PARAMETER) {\n+        warning(\"OpenProcess failed: %d\\n\", GetLastError());\n+      }\n@@ -508,1 +529,3 @@\n-    log_debug(perf)(\"GetExitCodeProcess failed: %d\", GetLastError());\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"GetExitCodeProcess failed: %d\\n\", GetLastError());\n+    }\n@@ -525,1 +548,3 @@\n-    log_debug(perf)(\"bypassing file system criteria checks for %s\", path);\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"bypassing file system criteria checks for %s\\n\", path);\n+    }\n@@ -531,1 +556,3 @@\n-    log_debug(perf)(\"expected device specifier in path: %s\", path);\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"expected device specifier in path: %s\\n\", path);\n+    }\n@@ -552,2 +579,5 @@\n-    log_debug(perf)(\"could not get device information for %s: path = %s: lasterror = %d\",\n-                    root_path, path, GetLastError());\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"could not get device information for %s: \"\n+              \" path = %s: lasterror = %d\\n\",\n+              root_path, path, GetLastError());\n+    }\n@@ -559,2 +589,4 @@\n-    log_debug(perf)(\"file system type %s on device %s does not support ACLs\",\n-                    fs_type, root_path);\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"file system type %s on device %s does not support\"\n+              \" ACLs\\n\", fs_type, root_path);\n+    }\n@@ -566,2 +598,4 @@\n-    log_debug(perf)(\"file system type %s on device %s is compressed\",\n-                    fs_type, root_path);\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"file system type %s on device %s is compressed\\n\",\n+              fs_type, root_path);\n+    }\n@@ -673,1 +707,3 @@\n-    log_debug(perf)(\"CreateFileMapping failed, lasterror = %d\", GetLastError());\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"CreateFileMapping failed, lasterror = %d\\n\", GetLastError());\n+    }\n@@ -684,1 +720,3 @@\n-    log_debug(perf)(\"file mapping already exists, lasterror = %d\", GetLastError());\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"file mapping already exists, lasterror = %d\\n\", GetLastError());\n+    }\n@@ -748,1 +786,3 @@\n-    log_debug(perf)(\"OpenProcessToken failure: lasterror = %d\", GetLastError());\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"OpenProcessToken failure: lasterror = %d \\n\", GetLastError());\n+    }\n@@ -758,2 +798,4 @@\n-      log_debug(perf)(\"GetTokenInformation failure: lasterror = %d, rsize = %d\",\n-                      lasterror, rsize);\n+      if (PrintMiscellaneous && Verbose) {\n+        warning(\"GetTokenInformation failure: lasterror = %d,\"\n+                \" rsize = %d\\n\", lasterror, rsize);\n+      }\n@@ -769,2 +811,4 @@\n-    log_debug(perf)(\"GetTokenInformation failure: lasterror = %d, rsize = %d\",\n-                    GetLastError(), rsize);\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"GetTokenInformation failure: lasterror = %d,\"\n+              \" rsize = %d\\n\", GetLastError(), rsize);\n+    }\n@@ -780,2 +824,4 @@\n-    log_debug(perf)(\"GetTokenInformation failure: lasterror = %d, rsize = %d\",\n-                    GetLastError(), rsize);\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"GetTokenInformation failure: lasterror = %d,\"\n+              \" rsize = %d\\n\", GetLastError(), rsize);\n+    }\n@@ -823,2 +869,4 @@\n-    log_debug(perf)(\"GetSecurityDescriptor failure: lasterror = %d\",\n-                    GetLastError());\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"GetSecurityDescriptor failure: lasterror = %d \\n\",\n+              GetLastError());\n+    }\n@@ -841,2 +889,4 @@\n-      log_debug(perf)(\"GetAclInformation failure: lasterror = %d\", GetLastError());\n-      return false;\n+      if (PrintMiscellaneous && Verbose) {\n+        warning(\"GetAclInformation failure: lasterror = %d \\n\", GetLastError());\n+        return false;\n+      }\n@@ -867,1 +917,3 @@\n-    log_debug(perf)(\"InitializeAcl failure: lasterror = %d\", GetLastError());\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"InitializeAcl failure: lasterror = %d \\n\", GetLastError());\n+    }\n@@ -878,1 +930,3 @@\n-        log_debug(perf)(\"InitializeAcl failure: lasterror = %d\", GetLastError());\n+        if (PrintMiscellaneous && Verbose) {\n+          warning(\"InitializeAcl failure: lasterror = %d \\n\", GetLastError());\n+        }\n@@ -903,1 +957,3 @@\n-          log_debug(perf)(\"AddAce failure: lasterror = %d\", GetLastError());\n+          if (PrintMiscellaneous && Verbose) {\n+            warning(\"AddAce failure: lasterror = %d \\n\", GetLastError());\n+          }\n@@ -916,2 +972,4 @@\n-      log_debug(perf)(\"AddAccessAllowedAce failure: lasterror = %d\",\n-                      GetLastError());\n+      if (PrintMiscellaneous && Verbose) {\n+        warning(\"AddAccessAllowedAce failure: lasterror = %d \\n\",\n+                GetLastError());\n+      }\n@@ -930,1 +988,3 @@\n-        log_debug(perf)(\"InitializeAcl failure: lasterror = %d\", GetLastError());\n+        if (PrintMiscellaneous && Verbose) {\n+          warning(\"InitializeAcl failure: lasterror = %d \\n\", GetLastError());\n+        }\n@@ -936,1 +996,3 @@\n-        log_debug(perf)(\"AddAce failure: lasterror = %d\", GetLastError());\n+        if (PrintMiscellaneous && Verbose) {\n+          warning(\"AddAce failure: lasterror = %d \\n\", GetLastError());\n+        }\n@@ -946,1 +1008,4 @@\n-    log_debug(perf)(\"SetSecurityDescriptorDacl failure: lasterror = %d\", GetLastError());\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"SetSecurityDescriptorDacl failure:\"\n+              \" lasterror = %d \\n\", GetLastError());\n+    }\n@@ -951,6 +1016,19 @@\n-  \/\/ We do not want to further propagate inherited DACLs, so making them\n-  \/\/ protected prevents that.\n-  if (!SetSecurityDescriptorControl(pSD, SE_DACL_PROTECTED, SE_DACL_PROTECTED)) {\n-    log_debug(perf)(\"SetSecurityDescriptorControl failure: lasterror = %d\", GetLastError());\n-    FREE_C_HEAP_ARRAY(char, newACL);\n-    return false;\n+  \/\/ if running on windows 2000 or later, set the automatic inheritance\n+  \/\/ control flags.\n+  SetSecurityDescriptorControlFnPtr _SetSecurityDescriptorControl;\n+  _SetSecurityDescriptorControl = (SetSecurityDescriptorControlFnPtr)\n+       GetProcAddress(GetModuleHandle(TEXT(\"advapi32.dll\")),\n+                      \"SetSecurityDescriptorControl\");\n+\n+  if (_SetSecurityDescriptorControl != nullptr) {\n+    \/\/ We do not want to further propagate inherited DACLs, so making them\n+    \/\/ protected prevents that.\n+    if (!_SetSecurityDescriptorControl(pSD, SE_DACL_PROTECTED,\n+                                            SE_DACL_PROTECTED)) {\n+      if (PrintMiscellaneous && Verbose) {\n+        warning(\"SetSecurityDescriptorControl failure:\"\n+                \" lasterror = %d \\n\", GetLastError());\n+      }\n+      FREE_C_HEAP_ARRAY(char, newACL);\n+      return false;\n+    }\n@@ -958,5 +1036,5 @@\n-\n-  \/\/ Note, the security descriptor maintains a reference to the newACL, not\n-  \/\/ a copy of it. Therefore, the newACL is not freed here. It is freed when\n-  \/\/ the security descriptor containing its reference is freed.\n-  return true;\n+   \/\/ Note, the security descriptor maintains a reference to the newACL, not\n+   \/\/ a copy of it. Therefore, the newACL is not freed here. It is freed when\n+   \/\/ the security descriptor containing its reference is freed.\n+   \/\/\n+   return true;\n@@ -982,1 +1060,4 @@\n-    log_debug(perf)(\"InitializeSecurityDescriptor failure: lasterror = %d\", GetLastError());\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"InitializeSecurityDescriptor failure: \"\n+              \"lasterror = %d \\n\", GetLastError());\n+    }\n@@ -1035,1 +1116,5 @@\n-    log_debug(perf)(\"AllocateAndInitializeSid failure: lasterror = %d\", GetLastError());\n+\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"AllocateAndInitializeSid failure: \"\n+              \"lasterror = %d \\n\", GetLastError());\n+    }\n@@ -1049,1 +1134,5 @@\n-    log_debug(perf)(\"AllocateAndInitializeSid failure: lasterror = %d\", GetLastError());\n+\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"AllocateAndInitializeSid failure: \"\n+              \"lasterror = %d \\n\", GetLastError());\n+    }\n@@ -1150,1 +1239,3 @@\n-        log_debug(perf)(\"%s directory is insecure\", dirname);\n+        if (PrintMiscellaneous && Verbose) {\n+          warning(\"%s directory is insecure\\n\", dirname);\n+        }\n@@ -1161,2 +1252,5 @@\n-        lasterror = GetLastError();\n-        log_debug(perf)(\"SetFileSecurity failed for %s directory. lasterror = %d\", dirname, lasterror);\n+        if (PrintMiscellaneous && Verbose) {\n+          lasterror = GetLastError();\n+          warning(\"SetFileSecurity failed for %s directory.  lasterror %d \\n\",\n+                                                        dirname, lasterror);\n+        }\n@@ -1165,1 +1259,3 @@\n-      log_debug(perf)(\"CreateDirectory failed: %d\", GetLastError());\n+      if (PrintMiscellaneous && Verbose) {\n+        warning(\"CreateDirectory failed: %d\\n\", GetLastError());\n+      }\n@@ -1232,1 +1328,3 @@\n-    log_debug(perf)(\"could not create file %s: %d\", filename, lasterror);\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"could not create file %s: %d\\n\", filename, lasterror);\n+    }\n@@ -1258,2 +1356,4 @@\n-      log_debug(perf)(\"could not get status information from file %s: %s\",\n-                      filename, os::strerror(errno));\n+      if (PrintMiscellaneous && Verbose) {\n+        warning(\"Could not get status information from file %s: %s\\n\",\n+            filename, os::strerror(errno));\n+      }\n@@ -1272,1 +1372,3 @@\n-      log_debug(perf)(\"could not flush file %s: %d\", filename, lasterror);\n+      if (PrintMiscellaneous && Verbose) {\n+        warning(\"could not flush file %s: %d\\n\", filename, lasterror);\n+      }\n@@ -1303,2 +1405,4 @@\n-    log_debug(perf)(\"OpenFileMapping failed for shared memory object %s:\"\n-                    \" lasterror = %d\", objectname, lasterror);\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"OpenFileMapping failed for shared memory object %s:\"\n+              \" lasterror = %d\\n\", objectname, lasterror);\n+    }\n@@ -1384,1 +1488,3 @@\n-    log_debug(perf)(\"MapViewOfFile failed, lasterror = %d\", GetLastError());\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"MapViewOfFile failed, lasterror = %d\\n\", GetLastError());\n+    }\n@@ -1448,1 +1554,3 @@\n-    log_debug(perf)(\"stat %s failed: %s\", filename, os::strerror(errno));\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"stat %s failed: %s\\n\", filename, os::strerror(errno));\n+    }\n@@ -1454,2 +1562,6 @@\n-    log_debug(perf)(\"unexpected file size: size = %zu\", statbuf.st_size);\n-    THROW_MSG_0(vmSymbols::java_io_IOException(), \"Invalid PerfMemory size\");\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"unexpected file size: size = %zu\\n\",\n+              statbuf.st_size);\n+    }\n+    THROW_MSG_0(vmSymbols::java_io_IOException(),\n+                \"Invalid PerfMemory size\");\n@@ -1528,1 +1640,3 @@\n-    log_debug(perf)(\"MapViewOfFile failed, lasterror = %d\", GetLastError());\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"MapViewOfFile failed, lasterror = %d\\n\", GetLastError());\n+    }\n@@ -1597,1 +1711,3 @@\n-      log_debug(perf)(\"Reverting to non-shared PerfMemory region.\");\n+      if (PrintMiscellaneous && Verbose) {\n+        warning(\"Reverting to non-shared PerfMemory region.\\n\");\n+      }\n","filename":"src\/hotspot\/os\/windows\/perfMemory_windows.cpp","additions":197,"deletions":81,"binary":false,"changes":278,"status":"modified"},{"patch":"@@ -170,2 +170,9 @@\n-  \/\/ ====== extensions ======\n-  \/\/\n+  if (is_valid(RISCV_HWPROBE_KEY_MVENDORID)) {\n+    VM_Version::mvendorid.enable_feature(query[RISCV_HWPROBE_KEY_MVENDORID].value);\n+  }\n+  if (is_valid(RISCV_HWPROBE_KEY_MARCHID)) {\n+    VM_Version::marchid.enable_feature(query[RISCV_HWPROBE_KEY_MARCHID].value);\n+  }\n+  if (is_valid(RISCV_HWPROBE_KEY_MIMPID)) {\n+    VM_Version::mimpid.enable_feature(query[RISCV_HWPROBE_KEY_MIMPID].value);\n+  }\n@@ -173,1 +180,0 @@\n-    VM_Version::ext_a.enable_feature();\n@@ -176,3 +182,1 @@\n-  }\n-  if (is_set(RISCV_HWPROBE_KEY_IMA_EXT_0, RISCV_HWPROBE_IMA_C)) {\n-    VM_Version::ext_c.enable_feature();\n+    VM_Version::ext_a.enable_feature();\n@@ -181,1 +185,0 @@\n-    VM_Version::ext_d.enable_feature();\n@@ -183,0 +186,4 @@\n+    VM_Version::ext_d.enable_feature();\n+  }\n+  if (is_set(RISCV_HWPROBE_KEY_IMA_EXT_0, RISCV_HWPROBE_IMA_C)) {\n+    VM_Version::ext_c.enable_feature();\n@@ -198,6 +205,0 @@\n-\n-#ifndef PRODUCT\n-  if (is_set(RISCV_HWPROBE_KEY_IMA_EXT_0, RISCV_HWPROBE_EXT_ZACAS)) {\n-    VM_Version::ext_Zacas.enable_feature();\n-  }\n-#endif\n@@ -210,5 +211,0 @@\n-#ifndef PRODUCT\n-  if (is_set(RISCV_HWPROBE_KEY_IMA_EXT_0, RISCV_HWPROBE_EXT_ZBKB)) {\n-    VM_Version::ext_Zbkb.enable_feature();\n-  }\n-#endif\n@@ -219,2 +215,5 @@\n-  if (is_set(RISCV_HWPROBE_KEY_IMA_EXT_0, RISCV_HWPROBE_EXT_ZFA)) {\n-    VM_Version::ext_Zfa.enable_feature();\n+  if (is_set(RISCV_HWPROBE_KEY_IMA_EXT_0, RISCV_HWPROBE_EXT_ZICBOZ)) {\n+    VM_Version::ext_Zicboz.enable_feature();\n+  }\n+  if (is_set(RISCV_HWPROBE_KEY_IMA_EXT_0, RISCV_HWPROBE_EXT_ZBKB)) {\n+    VM_Version::ext_Zbkb.enable_feature();\n@@ -230,12 +229,0 @@\n-  if (is_set(RISCV_HWPROBE_KEY_IMA_EXT_0, RISCV_HWPROBE_EXT_ZICBOZ)) {\n-    VM_Version::ext_Zicboz.enable_feature();\n-  }\n-  \/\/ Currently tests shows that cmove using Zicond instructions will bring\n-  \/\/ performance regression, but to get a test coverage all the time, will\n-  \/\/ still prefer to enabling it in debug version.\n-  if (is_set(RISCV_HWPROBE_KEY_IMA_EXT_0, RISCV_HWPROBE_EXT_ZICOND)) {\n-    VM_Version::ext_Zicond.enable_feature();\n-  }\n-  if (is_set(RISCV_HWPROBE_KEY_IMA_EXT_0, RISCV_HWPROBE_EXT_ZTSO)) {\n-    VM_Version::ext_Ztso.enable_feature();\n-  }\n@@ -245,0 +232,2 @@\n+#endif\n+#ifndef PRODUCT\n@@ -249,3 +238,0 @@\n-  if (is_set(RISCV_HWPROBE_KEY_IMA_EXT_0, RISCV_HWPROBE_EXT_ZVFH)) {\n-    VM_Version::ext_Zvfh.enable_feature();\n-  }\n@@ -260,5 +246,2 @@\n-\n-  \/\/ ====== non-extensions ======\n-  \/\/\n-  if (is_valid(RISCV_HWPROBE_KEY_MARCHID)) {\n-    VM_Version::marchid.enable_feature(query[RISCV_HWPROBE_KEY_MARCHID].value);\n+  if (is_set(RISCV_HWPROBE_KEY_IMA_EXT_0, RISCV_HWPROBE_EXT_ZVFH)) {\n+    VM_Version::ext_Zvfh.enable_feature();\n@@ -266,2 +249,3 @@\n-  if (is_valid(RISCV_HWPROBE_KEY_MIMPID)) {\n-    VM_Version::mimpid.enable_feature(query[RISCV_HWPROBE_KEY_MIMPID].value);\n+#ifndef PRODUCT\n+  if (is_set(RISCV_HWPROBE_KEY_IMA_EXT_0, RISCV_HWPROBE_EXT_ZFA)) {\n+    VM_Version::ext_Zfa.enable_feature();\n@@ -269,2 +253,15 @@\n-  if (is_valid(RISCV_HWPROBE_KEY_MVENDORID)) {\n-    VM_Version::mvendorid.enable_feature(query[RISCV_HWPROBE_KEY_MVENDORID].value);\n+#endif\n+#ifndef PRODUCT\n+  if (is_set(RISCV_HWPROBE_KEY_IMA_EXT_0, RISCV_HWPROBE_EXT_ZTSO)) {\n+    VM_Version::ext_Ztso.enable_feature();\n+  }\n+#endif\n+#ifndef PRODUCT\n+  if (is_set(RISCV_HWPROBE_KEY_IMA_EXT_0, RISCV_HWPROBE_EXT_ZACAS)) {\n+    VM_Version::ext_Zacas.enable_feature();\n+  }\n+  \/\/ Currently tests shows that cmove using Zicond instructions will bring\n+  \/\/ performance regression, but to get a test coverage all the time, will\n+  \/\/ still prefer to enabling it in debug version.\n+  if (is_set(RISCV_HWPROBE_KEY_IMA_EXT_0, RISCV_HWPROBE_EXT_ZICOND)) {\n+    VM_Version::ext_Zicond.enable_feature();\n@@ -272,0 +269,1 @@\n+#endif\n@@ -282,0 +280,1 @@\n+\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/riscv_hwprobe.cpp","additions":43,"deletions":44,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -106,8 +106,0 @@\n-void VM_Version::RVExtFeatureValue::log_enabled() {\n-  log_debug(os, cpu)(\"Enabled RV64 feature \\\"%s\\\"\", pretty());\n-}\n-\n-void VM_Version::RVNonExtFeatureValue::log_enabled() {\n-  log_debug(os, cpu)(\"Enabled RV64 feature \\\"%s\\\" (%ld)\", pretty(), value());\n-}\n-\n@@ -155,2 +147,3 @@\n-      _feature_list[i]->log_enabled();\n-\n+      log_debug(os, cpu)(\"Enabled RV64 feature \\\"%s\\\" (%ld)\",\n+             _feature_list[i]->pretty(),\n+             _feature_list[i]->value());\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/vm_version_linux_riscv.cpp","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"os_windows.hpp\"\n@@ -36,6 +35,0 @@\n-#define HAVE_PLATFORM_PRINT_NATIVE_STACK 1\n-inline bool os::platform_print_native_stack(outputStream* st, const void* context,\n-                                            char *buf, int buf_size, address& lastpc) {\n-  return os::win32::platform_print_native_stack(st, context, buf, buf_size, lastpc);\n-}\n-\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/os_windows_aarch64.inline.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -200,0 +200,92 @@\n+#ifdef HAVE_PLATFORM_PRINT_NATIVE_STACK\n+\/*\n+ * Windows\/x64 does not use stack frames the way expected by Java:\n+ * [1] in most cases, there is no frame pointer. All locals are addressed via RSP\n+ * [2] in rare cases, when alloca() is used, a frame pointer is used, but this may\n+ *     not be RBP.\n+ * See http:\/\/msdn.microsoft.com\/en-us\/library\/ew5tede7.aspx\n+ *\n+ * So it's not possible to print the native stack using the\n+ *     while (...) {...  fr = os::get_sender_for_C_frame(&fr); }\n+ * loop in vmError.cpp. We need to roll our own loop.\n+ *\/\n+bool os::win32::platform_print_native_stack(outputStream* st, const void* context,\n+                                            char *buf, int buf_size, address& lastpc)\n+{\n+  CONTEXT ctx;\n+  if (context != nullptr) {\n+    memcpy(&ctx, context, sizeof(ctx));\n+  } else {\n+    RtlCaptureContext(&ctx);\n+  }\n+\n+  st->print_cr(\"Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)\");\n+\n+  STACKFRAME stk;\n+  memset(&stk, 0, sizeof(stk));\n+  stk.AddrStack.Offset    = ctx.Rsp;\n+  stk.AddrStack.Mode      = AddrModeFlat;\n+  stk.AddrFrame.Offset    = ctx.Rbp;\n+  stk.AddrFrame.Mode      = AddrModeFlat;\n+  stk.AddrPC.Offset       = ctx.Rip;\n+  stk.AddrPC.Mode         = AddrModeFlat;\n+\n+  \/\/ Ensure we consider dynamically loaded dll's\n+  SymbolEngine::refreshModuleList();\n+\n+  int count = 0;\n+  address lastpc_internal = 0;\n+  while (count++ < StackPrintLimit) {\n+    intptr_t* sp = (intptr_t*)stk.AddrStack.Offset;\n+    intptr_t* fp = (intptr_t*)stk.AddrFrame.Offset; \/\/ NOT necessarily the same as ctx.Rbp!\n+    address pc = (address)stk.AddrPC.Offset;\n+\n+    if (pc != nullptr) {\n+      if (count == 2 && lastpc_internal == pc) {\n+        \/\/ Skip it -- StackWalk64() may return the same PC\n+        \/\/ (but different SP) on the first try.\n+      } else {\n+        \/\/ Don't try to create a frame(sp, fp, pc) -- on WinX64, stk.AddrFrame\n+        \/\/ may not contain what Java expects, and may cause the frame() constructor\n+        \/\/ to crash. Let's just print out the symbolic address.\n+        frame::print_C_frame(st, buf, buf_size, pc);\n+        \/\/ print source file and line, if available\n+        char buf[128];\n+        int line_no;\n+        if (SymbolEngine::get_source_info(pc, buf, sizeof(buf), &line_no)) {\n+          st->print(\"  (%s:%d)\", buf, line_no);\n+        } else {\n+          st->print(\"  (no source info available)\");\n+        }\n+        st->cr();\n+      }\n+      lastpc_internal = pc;\n+    }\n+\n+    PVOID p = WindowsDbgHelp::symFunctionTableAccess64(GetCurrentProcess(), stk.AddrPC.Offset);\n+    if (!p) {\n+      \/\/ StackWalk64() can't handle this PC. Calling StackWalk64 again may cause crash.\n+      lastpc = lastpc_internal;\n+      break;\n+    }\n+\n+    BOOL result = WindowsDbgHelp::stackWalk64(\n+        IMAGE_FILE_MACHINE_AMD64,  \/\/ __in      DWORD MachineType,\n+        GetCurrentProcess(),       \/\/ __in      HANDLE hProcess,\n+        GetCurrentThread(),        \/\/ __in      HANDLE hThread,\n+        &stk,                      \/\/ __inout   LP STACKFRAME64 StackFrame,\n+        &ctx);                     \/\/ __inout   PVOID ContextRecord,\n+\n+    if (!result) {\n+      break;\n+    }\n+  }\n+  if (count > StackPrintLimit) {\n+    st->print_cr(\"...<more frames>...\");\n+  }\n+  st->cr();\n+\n+  return true;\n+}\n+#endif \/\/ HAVE_PLATFORM_PRINT_NATIVE_STACK\n+\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/os_windows_x86.cpp","additions":92,"deletions":0,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -902,3 +902,1 @@\n-  if (reg_class_name == nullptr) {\n-    return \"RegMask::EMPTY\";\n-  }\n+  if( reg_class_name == nullptr ) return \"RegMask::Empty\";\n@@ -907,1 +905,1 @@\n-    return \"RegMask::EMPTY\";\n+    return \"RegMask::Empty\";\n@@ -925,1 +923,1 @@\n-  const char* reg_mask = \"RegMask::EMPTY\";\n+  const char *reg_mask = \"RegMask::Empty\";\n@@ -944,1 +942,1 @@\n-  const char* regMask = \"RegMask::EMPTY\";\n+  const char *regMask      = \"RegMask::Empty\";\n@@ -973,1 +971,1 @@\n-  \/\/ Instructions producing 'Universe' use RegMask::EMPTY\n+  \/\/ Instructions producing 'Universe' use RegMask::Empty\n@@ -975,1 +973,1 @@\n-    return \"RegMask::EMPTY\";\n+    return \"RegMask::Empty\";\n","filename":"src\/hotspot\/share\/adlc\/archDesc.cpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2425,1 +2425,1 @@\n-  const char* reg_class = nullptr; \/\/ \"RegMask::EMPTY\";\n+  const char *reg_class = nullptr; \/\/ \"RegMask::Empty\";\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2840,1 +2840,1 @@\n-        fprintf(fp, \"  return &RegMask::EMPTY;\\n\");\n+        fprintf(fp,\"  return &RegMask::Empty;\\n\");\n","filename":"src\/hotspot\/share\/adlc\/output_c.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -228,18 +228,0 @@\n-      \/\/ no-fast bytecode\n-      case Bytecodes::_nofast_getfield:\n-      \/\/ fast bytecodes\n-      case Bytecodes::_fast_agetfield:\n-      case Bytecodes::_fast_bgetfield:\n-      case Bytecodes::_fast_cgetfield:\n-      case Bytecodes::_fast_dgetfield:\n-      case Bytecodes::_fast_fgetfield:\n-      case Bytecodes::_fast_igetfield:\n-      case Bytecodes::_fast_lgetfield:\n-      case Bytecodes::_fast_sgetfield:\n-        raw_bc = Bytecodes::_getfield;\n-        maybe_resolve_fmi_ref(ik, m, raw_bc, bcs.get_index_u2(), preresolve_list, THREAD);\n-        if (HAS_PENDING_EXCEPTION) {\n-          CLEAR_PENDING_EXCEPTION; \/\/ just ignore\n-        }\n-        break;\n-\n@@ -247,13 +229,0 @@\n-      \/\/ no-fast bytecode\n-      case Bytecodes::_nofast_putfield:\n-      \/\/ fast bytecodes\n-      case Bytecodes::_fast_aputfield:\n-      case Bytecodes::_fast_bputfield:\n-      case Bytecodes::_fast_zputfield:\n-      case Bytecodes::_fast_cputfield:\n-      case Bytecodes::_fast_dputfield:\n-      case Bytecodes::_fast_fputfield:\n-      case Bytecodes::_fast_iputfield:\n-      case Bytecodes::_fast_lputfield:\n-      case Bytecodes::_fast_sputfield:\n-        raw_bc = Bytecodes::_putfield;\n","filename":"src\/hotspot\/share\/cds\/aotConstantPoolResolver.cpp","additions":0,"deletions":31,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -45,2 +45,0 @@\n-#include \"runtime\/serviceThread.hpp\"\n-#include \"utilities\/growableArray.hpp\"\n@@ -58,2 +56,0 @@\n-\/\/\n-\/\/ Note: we can't link the classes yet because SharedRuntime is not yet ready to generate adapters.\n@@ -119,38 +115,0 @@\n-\/\/ Some cached heap objects may hold references to methods in aot-linked\n-\/\/ classes (via MemberName). We need to make sure all classes are\n-\/\/ linked before executing any bytecode.\n-void AOTLinkedClassBulkLoader::link_classes(JavaThread* current) {\n-  link_classes_impl(current);\n-  if (current->has_pending_exception()) {\n-    exit_on_exception(current);\n-  }\n-}\n-\n-void AOTLinkedClassBulkLoader::link_classes_impl(TRAPS) {\n-  precond(CDSConfig::is_using_aot_linked_classes());\n-\n-  AOTLinkedClassTable* table = AOTLinkedClassTable::get();\n-\n-  link_classes_in_table(table->boot1(), CHECK);\n-  link_classes_in_table(table->boot2(), CHECK);\n-  link_classes_in_table(table->platform(), CHECK);\n-  link_classes_in_table(table->app(), CHECK);\n-}\n-\n-void AOTLinkedClassBulkLoader::link_classes_in_table(Array<InstanceKlass*>* classes, TRAPS) {\n-  if (classes != nullptr) {\n-    for (int i = 0; i < classes->length(); i++) {\n-      \/\/ NOTE: CDSConfig::is_preserving_verification_constraints() is required\n-      \/\/ when storing ik in the AOT cache. This means we don't have to verify\n-      \/\/ ik at all.\n-      \/\/\n-      \/\/ Without is_preserving_verification_constraints(), ik->link_class() may cause\n-      \/\/ class loading, which may result in invocation of ClassLoader::loadClass() calls,\n-      \/\/ which CANNOT happen because we are not ready to execute any Java byecodes yet\n-      \/\/ at this point.\n-      InstanceKlass* ik = classes->at(i);\n-      ik->link_class(CHECK);\n-    }\n-  }\n-}\n-\n@@ -218,2 +176,4 @@\n-void AOTLinkedClassBulkLoader::init_javabase_classes(JavaThread* current) {\n-  init_classes_for_loader(Handle(), AOTLinkedClassTable::get()->boot1(), current);\n+\/\/ Link all java.base classes in the AOTLinkedClassTable. Of those classes,\n+\/\/ move the ones that have been AOT-initialized to the \"initialized\" state.\n+void AOTLinkedClassBulkLoader::link_or_init_javabase_classes(JavaThread* current) {\n+  link_or_init_classes_for_loader(Handle(), AOTLinkedClassTable::get()->boot1(), current);\n@@ -225,2 +185,4 @@\n-void AOTLinkedClassBulkLoader::init_non_javabase_classes(JavaThread* current) {\n-  init_non_javabase_classes_impl(current);\n+\/\/ Do the same thing as link_or_init_javabase_classes(), but for the classes that are not\n+\/\/ in the java.base module.\n+void AOTLinkedClassBulkLoader::link_or_init_non_javabase_classes(JavaThread* current) {\n+  link_or_init_non_javabase_classes_impl(current);\n@@ -232,1 +194,1 @@\n-void AOTLinkedClassBulkLoader::init_non_javabase_classes_impl(TRAPS) {\n+void AOTLinkedClassBulkLoader::link_or_init_non_javabase_classes_impl(TRAPS) {\n@@ -249,3 +211,3 @@\n-  init_classes_for_loader(Handle(), table->boot2(), CHECK);\n-  init_classes_for_loader(h_platform_loader, table->platform(), CHECK);\n-  init_classes_for_loader(h_system_loader, table->app(), CHECK);\n+  link_or_init_classes_for_loader(Handle(), table->boot2(), CHECK);\n+  link_or_init_classes_for_loader(h_platform_loader, table->platform(), CHECK);\n+  link_or_init_classes_for_loader(h_system_loader, table->app(), CHECK);\n@@ -283,1 +245,0 @@\n-    oop message = java_lang_Throwable::message(current->pending_exception());\n@@ -285,1 +246,1 @@\n-                   message == nullptr ? \"(no message)\" : java_lang_String::as_utf8_string(message));\n+                   java_lang_String::as_utf8_string(java_lang_Throwable::message(current->pending_exception())));\n@@ -331,1 +292,1 @@\n-void AOTLinkedClassBulkLoader::init_classes_for_loader(Handle class_loader, Array<InstanceKlass*>* classes, TRAPS) {\n+void AOTLinkedClassBulkLoader::link_or_init_classes_for_loader(Handle class_loader, Array<InstanceKlass*>* classes, TRAPS) {\n@@ -335,1 +296,6 @@\n-      assert(ik->class_loader_data() != nullptr, \"must be\");\n+      if (ik->class_loader_data() == nullptr) {\n+        \/\/ This class is not yet loaded. We will initialize it in a later phase.\n+        \/\/ For example, we have loaded only AOTLinkedClassCategory::BOOT1 classes\n+        \/\/ but k is part of AOTLinkedClassCategory::BOOT2.\n+        continue;\n+      }\n@@ -338,0 +304,5 @@\n+      } else {\n+        \/\/ Some cached heap objects may hold references to methods in aot-linked\n+        \/\/ classes (via MemberName). We need to make sure all classes are\n+        \/\/ linked to allow such MemberNames to be invoked.\n+        ik->link_class(CHECK);\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassBulkLoader.cpp","additions":25,"deletions":54,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -55,5 +55,4 @@\n-  static void initiate_loading(JavaThread* current, const char* category, Handle initiating_loader, Array<InstanceKlass*>* classes);\n-  static void link_classes_impl(TRAPS);\n-  static void link_classes_in_table(Array<InstanceKlass*>* classes, TRAPS);\n-  static void init_non_javabase_classes_impl(TRAPS);\n-  static void init_classes_for_loader(Handle class_loader, Array<InstanceKlass*>* classes, TRAPS);\n+  static void initiate_loading(JavaThread* current, const char* category, Handle initiating_loader,\n+                               Array<InstanceKlass*>* classes);\n+  static void link_or_init_non_javabase_classes_impl(TRAPS);\n+  static void link_or_init_classes_for_loader(Handle class_loader, Array<InstanceKlass*>* classes, TRAPS);\n@@ -71,4 +70,3 @@\n-  static void preload_classes(JavaThread* current) NOT_CDS_RETURN;\n-  static void link_classes(JavaThread* current) NOT_CDS_RETURN;\n-  static void init_javabase_classes(JavaThread* current) NOT_CDS_RETURN;\n-  static void init_non_javabase_classes(JavaThread* current) NOT_CDS_RETURN;\n+  static void preload_classes(JavaThread* current);\n+  static void link_or_init_javabase_classes(JavaThread* current) NOT_CDS_RETURN;\n+  static void link_or_init_non_javabase_classes(JavaThread* current) NOT_CDS_RETURN;\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassBulkLoader.hpp","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -138,8 +138,6 @@\n-    if (AOTMetaspace::in_aot_cache(ref->obj())) {\n-      info._src_addr = ref->obj();\n-      info._buffered_addr = ref->obj();\n-      info._requested_addr = ref->obj();\n-      info._bytes = ref->size() * BytesPerWord;\n-      info._type = ref->msotype();\n-      _objs.append(info);\n-    }\n+    info._src_addr = ref->obj();\n+    info._buffered_addr = ref->obj();\n+    info._requested_addr = ref->obj();\n+    info._bytes = ref->size() * BytesPerWord;\n+    info._type = ref->msotype();\n+    _objs.append(info);\n","filename":"src\/hotspot\/share\/cds\/aotMapLogger.cpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -946,2 +946,0 @@\n-  } else if (is_dumping_classic_static_archive()) {\n-    return is_dumping_aot_linked_classes();\n@@ -949,0 +947,1 @@\n+    \/\/ For simplicity, we don't support this optimization with the old CDS workflow.\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -130,8 +130,0 @@\n-      LogStreamHandle(Trace, aot, resolve) log;\n-      if (log.is_enabled()) {\n-        log.print(\"ConstantPool entries for %s to be pre-resolved:\", k->external_name());\n-        for (int i = 0; i < cp_indices.length(); i++) {\n-          log.print(\" %d\", cp_indices.at(i));\n-        }\n-        log.print(\"\\n\");\n-      }\n","filename":"src\/hotspot\/share\/cds\/finalImageRecipes.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  if (CDSConfig::is_preserving_verification_constraints()) {\n+  if (CDSConfig::is_preserving_verification_constraints() && CDSConfig::is_dumping_final_static_archive()) {\n","filename":"src\/hotspot\/share\/cds\/runTimeClassInfo.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -135,1 +135,1 @@\n-    StackMapFrame* frame, int bci, int offset, TRAPS) const {\n+    StackMapFrame* frame, int32_t target, TRAPS) const {\n@@ -137,8 +137,0 @@\n-  \/\/ Jump targets must be within the method and the method size is limited. See JVMS 4.11\n-  int min_offset = -1 * max_method_code_size;\n-  if (offset < min_offset || offset > max_method_code_size) {\n-    frame->verifier()->verify_error(ErrorContext::bad_stackmap(bci, frame),\n-        \"Illegal target of jump or branch (bci %d + offset %d)\", bci, offset);\n-    return;\n-  }\n-  int target = bci + offset;\n","filename":"src\/hotspot\/share\/classfile\/stackMapTable.cpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-  void check_jump_target(StackMapFrame* frame, int bci, int offset, TRAPS) const;\n+  void check_jump_target(StackMapFrame* frame, int32_t target, TRAPS) const;\n","filename":"src\/hotspot\/share\/classfile\/stackMapTable.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -858,22 +858,0 @@\n-void SystemDictionaryShared::link_all_exclusion_check_candidates(InstanceKlass* ik) {\n-  bool need_to_link = false;\n-  {\n-    MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);\n-    ExclusionCheckCandidates candidates(ik);\n-\n-    candidates.iterate_all([&] (InstanceKlass* k, DumpTimeClassInfo* info) {\n-      if (!k->is_linked()) {\n-        need_to_link = true;\n-      }\n-    });\n-  }\n-  if (need_to_link) {\n-    JavaThread* THREAD = JavaThread::current();\n-    if (log_is_enabled(Info, aot, link)) {\n-      ResourceMark rm(THREAD);\n-      log_info(aot, link)(\"Link all loaded classes for %s\", ik->external_name());\n-    }\n-    AOTMetaspace::link_all_loaded_classes(THREAD);\n-  }\n-}\n-\n@@ -903,6 +881,9 @@\n-      {\n-        \/\/ fast path\n-        MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);\n-        DumpTimeClassInfo* p = get_info_locked(ik);\n-        if (p->has_checked_exclusion()) {\n-          return p->is_excluded();\n+      if (!ik->is_linked()) {\n+        \/\/ should_be_excluded_impl() below doesn't link unlinked classes. We come\n+        \/\/ here only when we are trying to aot-link constant pool entries, so\n+        \/\/ we'd better link the class.\n+        JavaThread* THREAD = JavaThread::current();\n+        ik->link_class(THREAD);\n+        if (HAS_PENDING_EXCEPTION) {\n+          CLEAR_PENDING_EXCEPTION;\n+          return true; \/\/ linking failed -- let's exclude it\n@@ -910,1 +891,0 @@\n-      }\n@@ -912,1 +892,4 @@\n-      link_all_exclusion_check_candidates(ik);\n+        \/\/ Also link any classes that were loaded for the verification of ik or its supertypes.\n+        \/\/ Otherwise we might miss the verification constraints of those classes.\n+        AOTMetaspace::link_all_loaded_classes(THREAD);\n+      }\n@@ -916,0 +899,3 @@\n+      if (p->is_excluded()) {\n+        return true;\n+      }\n@@ -929,1 +915,1 @@\n-      \/\/ Don't take DumpTimeTable_lock as we are in safepoint.\n+      \/\/ Can't take the lock as we are in safepoint.\n@@ -1437,4 +1423,0 @@\n-\n-  get_archive(is_static_archive)->_unregistered_dictionary.iterate([&] (const RunTimeClassInfo* record) {\n-      classes->append(record->klass());\n-    });\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":17,"deletions":35,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -178,1 +178,0 @@\n-  static void link_all_exclusion_check_candidates(InstanceKlass* ik);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -784,0 +784,1 @@\n+      int target;\n@@ -1608,0 +1609,1 @@\n+          target = bcs.dest();\n@@ -1609,1 +1611,1 @@\n-            &current_frame, bcs.bci(), bcs.get_offset_s2(), CHECK_VERIFY(this));\n+            &current_frame, target, CHECK_VERIFY(this));\n@@ -1620,0 +1622,1 @@\n+          target = bcs.dest();\n@@ -1621,1 +1624,1 @@\n-            (&current_frame, bcs.bci(), bcs.get_offset_s2(), CHECK_VERIFY(this));\n+            (&current_frame, target, CHECK_VERIFY(this));\n@@ -1624,0 +1627,1 @@\n+          target = bcs.dest();\n@@ -1625,1 +1629,1 @@\n-            &current_frame, bcs.bci(), bcs.get_offset_s2(), CHECK_VERIFY(this));\n+            &current_frame, target, CHECK_VERIFY(this));\n@@ -1628,0 +1632,1 @@\n+          target = bcs.dest_w();\n@@ -1629,1 +1634,1 @@\n-            &current_frame, bcs.bci(), bcs.get_offset_s4(), CHECK_VERIFY(this));\n+            &current_frame, target, CHECK_VERIFY(this));\n@@ -2278,1 +2283,2 @@\n-  stackmap_table->check_jump_target(current_frame, bci, default_offset, CHECK_VERIFY(this));\n+  int target = bci + default_offset;\n+  stackmap_table->check_jump_target(current_frame, target, CHECK_VERIFY(this));\n@@ -2283,1 +2289,1 @@\n-    int offset = (jint)Bytes::get_Java_u4(aligned_bcp+(3+i*delta)*jintSize);\n+    target = bci + (jint)Bytes::get_Java_u4(aligned_bcp+(3+i*delta)*jintSize);\n@@ -2285,1 +2291,1 @@\n-      current_frame, bci, offset, CHECK_VERIFY(this));\n+      current_frame, target, CHECK_VERIFY(this));\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -470,2 +470,2 @@\n-  \/* support for com.sun.crypto.provider.AES_Crypt and some of its callers *\/                                            \\\n-  do_class(com_sun_crypto_provider_aescrypt,      \"com\/sun\/crypto\/provider\/AES_Crypt\")                                   \\\n+  \/* support for com.sun.crypto.provider.AESCrypt and some of its callers *\/                                            \\\n+  do_class(com_sun_crypto_provider_aescrypt,      \"com\/sun\/crypto\/provider\/AESCrypt\")                                   \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -913,1 +913,0 @@\n-      nm->print_code_snippet(st, addr);\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"cds\/cdsConfig.hpp\"\n@@ -1151,1 +1150,1 @@\n-    + ImmutableDataReferencesCounterSize;\n+    + align_up(ImmutableDataReferencesCounterSize, oopSize);\n@@ -1326,1 +1325,0 @@\n-    _immutable_data_reference_counter_offset = 0;\n@@ -1425,0 +1423,9 @@\n+  \/\/ Increment number of references to immutable data to share it between nmethods\n+  _immutable_data_size          = nm._immutable_data_size;\n+  if (_immutable_data_size > 0) {\n+    _immutable_data             = nm._immutable_data;\n+    set_immutable_data_references_counter(get_immutable_data_references_counter() + 1);\n+  } else {\n+    _immutable_data             = blob_end();\n+  }\n+\n@@ -1440,1 +1447,0 @@\n-  _immutable_data_size          = nm._immutable_data_size;\n@@ -1459,9 +1465,0 @@\n-  _immutable_data_reference_counter_offset = nm._immutable_data_reference_counter_offset;\n-\n-  \/\/ Increment number of references to immutable data to share it between nmethods\n-  if (_immutable_data_size > 0) {\n-    _immutable_data             = nm._immutable_data;\n-    set_immutable_data_references_counter(get_immutable_data_references_counter() + 1);\n-  } else {\n-    _immutable_data             = blob_end();\n-  }\n@@ -1757,2 +1754,1 @@\n-    _immutable_data_reference_counter_offset = _speculations_offset + align_up(speculations_len, oopSize);\n-    DEBUG_ONLY( int immutable_data_end_offset = _immutable_data_reference_counter_offset + ImmutableDataReferencesCounterSize; )\n+    DEBUG_ONLY( int immutable_data_end_offset = _speculations_offset + align_up(speculations_len, oopSize) + align_up(ImmutableDataReferencesCounterSize, oopSize); )\n@@ -1760,2 +1756,1 @@\n-    _immutable_data_reference_counter_offset =  _scopes_data_offset + align_up(debug_info->data_size(), oopSize);\n-    DEBUG_ONLY( int immutable_data_end_offset = _immutable_data_reference_counter_offset + ImmutableDataReferencesCounterSize; )\n+    DEBUG_ONLY( int immutable_data_end_offset = _scopes_data_offset + align_up(debug_info->data_size(), oopSize) + align_up(ImmutableDataReferencesCounterSize, oopSize); )\n@@ -2508,27 +2503,0 @@\n-#if INCLUDE_CDS\n-static GrowableArrayCHeap<nmethod*, mtClassShared>* _delayed_compiled_method_load_events = nullptr;\n-\n-void nmethod::add_delayed_compiled_method_load_event(nmethod* nm) {\n-  precond(CDSConfig::is_using_aot_linked_classes());\n-  precond(!ServiceThread::has_started());\n-\n-  \/\/ We are still in single threaded stage of VM bootstrap. No need to lock.\n-  if (_delayed_compiled_method_load_events == nullptr) {\n-    _delayed_compiled_method_load_events = new GrowableArrayCHeap<nmethod*, mtClassShared>();\n-  }\n-  _delayed_compiled_method_load_events->append(nm);\n-}\n-\n-void nmethod::post_delayed_compiled_method_load_events() {\n-  precond(ServiceThread::has_started());\n-  if (_delayed_compiled_method_load_events != nullptr) {\n-    for (int i = 0; i < _delayed_compiled_method_load_events->length(); i++) {\n-      nmethod* nm = _delayed_compiled_method_load_events->at(i);\n-      nm->post_compiled_method_load_event();\n-    }\n-    delete _delayed_compiled_method_load_events;\n-    _delayed_compiled_method_load_events = nullptr;\n-  }\n-}\n-#endif\n-\n@@ -2540,10 +2508,0 @@\n-#if INCLUDE_CDS\n-  if (!ServiceThread::has_started()) {\n-    \/\/ With AOT-linked classes, we could compile wrappers for native methods before the\n-    \/\/ ServiceThread has been started, so we must delay the events to be posted later.\n-    assert(state == nullptr, \"must be\");\n-    add_delayed_compiled_method_load_event(this);\n-    return;\n-  }\n-#endif\n-\n@@ -4311,40 +4269,0 @@\n-void nmethod::print_code_snippet(outputStream* st, address addr) const {\n-  if (entry_point() <= addr && addr < code_end()) {\n-    \/\/ Pointing into the nmethod's code. Try to disassemble some instructions around addr.\n-    \/\/ Determine conservative start and end points.\n-    address start;\n-    if (frame_complete_offset() != CodeOffsets::frame_never_safe &&\n-        addr >= code_begin() + frame_complete_offset()) {\n-      start = code_begin() + frame_complete_offset();\n-    } else {\n-      start = (addr < verified_entry_point()) ? entry_point() : verified_entry_point();\n-    }\n-    address start_for_hex_dump = start; \/\/ We can choose a different starting point for hex dump, below.\n-    address end = code_end();\n-\n-    \/\/ Try using relocations to find closer instruction start and end points.\n-    \/\/ (Some platforms have variable length instructions and can only\n-    \/\/ disassemble correctly at instruction start addresses.)\n-    RelocIterator iter((nmethod*)this, start);\n-    while (iter.next() && iter.addr() < addr) { \/\/ find relocation before addr\n-      \/\/ Note: There's a relocation which doesn't point to an instruction start:\n-      \/\/ ZBarrierRelocationFormatStoreGoodAfterMov with ZGC on x86_64\n-      \/\/ We could detect and skip it, but hex dump is still usable when\n-      \/\/ disassembler produces garbage in such a very rare case.\n-      start = iter.addr();\n-      \/\/ We want at least 64 Bytes ahead in hex dump.\n-      if (iter.addr() <= (addr - 64)) start_for_hex_dump = iter.addr();\n-    }\n-    if (iter.has_current()) {\n-      if (iter.addr() == addr) iter.next(); \/\/ find relocation after addr\n-      if (iter.has_current()) end = iter.addr();\n-    }\n-\n-    \/\/ Always print hex. Disassembler may still have problems when hitting an incorrect instruction start.\n-    os::print_hex_dump(st, start_for_hex_dump, end, 1, \/* print_ascii=*\/false);\n-    if (!Disassembler::is_abstract()) {\n-      Disassembler::decode(start, end, st);\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":12,"deletions":94,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -253,1 +253,0 @@\n-  int      _immutable_data_reference_counter_offset;\n@@ -650,1 +649,1 @@\n-  address speculations_end      () const { return           _immutable_data + _immutable_data_reference_counter_offset ; }\n+  address speculations_end      () const { return           immutable_data_end() - ImmutableDataReferencesCounterSize ; }\n@@ -652,1 +651,1 @@\n-  address scopes_data_end       () const { return           _immutable_data + _immutable_data_reference_counter_offset ; }\n+  address scopes_data_end       () const { return           immutable_data_end() - ImmutableDataReferencesCounterSize ; }\n@@ -654,1 +653,2 @@\n-  address immutable_data_references_counter_begin () const { return _immutable_data + _immutable_data_reference_counter_offset ; }\n+\n+  address immutable_data_references_counter_begin () const { return immutable_data_end() - ImmutableDataReferencesCounterSize ; }\n@@ -968,2 +968,0 @@\n-  static void add_delayed_compiled_method_load_event(nmethod* nm) NOT_CDS_RETURN;\n-\n@@ -1004,3 +1002,0 @@\n-  \/\/ AOT cache support\n-  static void post_delayed_compiled_method_load_events() NOT_CDS_RETURN;\n-\n@@ -1011,1 +1006,0 @@\n-  void print_code_snippet(outputStream* st, address addr) const;\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -218,0 +218,5 @@\n+  if (FLAG_IS_DEFAULT(MaxRAM)) {\n+    \/\/ Do not use FLAG_SET_ERGO to update MaxRAM, as this will impact\n+    \/\/ heap setting done based on available phys_mem (see Arguments::set_heap_size).\n+    FLAG_SET_DEFAULT(MaxRAM, 1ULL*G);\n+  }\n@@ -551,1 +556,1 @@\n-bool CompilerConfig::should_set_client_emulation_mode_flags() {\n+void CompilerConfig::ergo_initialize() {\n@@ -553,1 +558,1 @@\n-  return false;\n+  return;\n@@ -559,1 +564,1 @@\n-        return true;\n+        set_client_emulation_mode_flags();\n@@ -562,1 +567,1 @@\n-      return true;\n+      set_client_emulation_mode_flags();\n@@ -566,15 +571,0 @@\n-  return false;\n-}\n-\n-void CompilerConfig::ergo_initialize() {\n-#if !COMPILER1_OR_COMPILER2\n-  return;\n-#endif\n-\n-  \/\/ This property is also checked when selecting the heap size. Since client\n-  \/\/ emulation mode influences Java heap memory usage, part of the logic must\n-  \/\/ occur before choosing the heap size.\n-  if (should_set_client_emulation_mode_flags()) {\n-    set_client_emulation_mode_flags();\n-  }\n-\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.cpp","additions":9,"deletions":19,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -154,2 +154,0 @@\n-  static bool should_set_client_emulation_mode_flags();\n-\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -620,8 +620,2 @@\n-  tty->print_cr(\"The <method pattern> has the format '<class>.<method><descriptor>'.\");\n-  tty->cr();\n-  tty->print_cr(\"For example, the <method pattern>\");\n-  tty->cr();\n-  tty->print_cr(\"  package\/Class.method(Lpackage\/Parameter;)Lpackage\/Return;\");\n-  tty->cr();\n-  tty->print_cr(\"matches the <method> 'method' in <class> 'package\/Class' with <descriptor>\");\n-  tty->print_cr(\"'(Lpackage\/Parameter;)Lpackage\/Return;'\");\n+    tty->print_cr(\"Method patterns has the format:\");\n+  tty->print_cr(\"  package\/Class.method()\");\n@@ -630,0 +624,1 @@\n+  tty->print_cr(\"  package.Class::method()\");\n@@ -631,25 +626,2 @@\n-  tty->print_cr(\"  package.Class::method(Lpackage.Parameter;)Lpackage.Return;\");\n-  tty->cr();\n-  tty->print_cr(\"A whitespace or comma can optionally separate the <descriptor> from the\");\n-  tty->print_cr(\"<method>:\");\n-  tty->cr();\n-  tty->print_cr(\"  package\/Class.method (Lpackage\/Parameter;)Lpackage\/Return;\");\n-  tty->print_cr(\"  package\/Class.method,(Lpackage\/Parameter;)Lpackage\/Return;\");\n-  tty->cr();\n-  tty->print_cr(\"The <class> and <method> accept leading and trailing '*' wildcards\");\n-  tty->print_cr(\"matching:\");\n-  tty->cr();\n-  tty->print_cr(\"  *ackage\/Clas*.*etho*(Lpackage\/Parameter;)Lpackage\/Return;\");\n-  tty->cr();\n-  tty->print_cr(\"The <descriptor> does not support explicit wildcards and\");\n-  tty->print_cr(\"always has an implicit trailing wildcard. Therefore,\");\n-  tty->cr();\n-  tty->print_cr(\"  package\/Class.method(Lpackage\/Parameter;)Lpackage\/Return;\");\n-  tty->cr();\n-  tty->print_cr(\"matches a subset of\");\n-  tty->cr();\n-  tty->print_cr(\"  package\/Class.method(Lpackage\/Parameter;)\");\n-  tty->cr();\n-  tty->print_cr(\"which matches a subset of\");\n-  tty->cr();\n-  tty->print_cr(\"  package\/Class.method\");\n+  tty->print_cr(\"The signature can be separated by an optional whitespace or comma:\");\n+  tty->print_cr(\"  package\/Class.method ()\");\n@@ -657,1 +629,3 @@\n-  tty->print_cr(\"which matches all possible descriptors.\");\n+  tty->print_cr(\"The class and method identifier can be used together with leading or\");\n+  tty->print_cr(\"trailing *'s for wildcard matching:\");\n+  tty->print_cr(\"  *ackage\/Clas*.*etho*()\");\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":8,"deletions":34,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-  _space->initialize(committed_region, \/* clear_space = *\/ true);\n+  _space->initialize(committed_region, \/* clear_space = *\/ true, \/* mangle_space = *\/ true);\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-void G1BarrierSet::write_region(MemRegion mr) {\n+void G1BarrierSet::write_region(JavaThread* thread, MemRegion mr) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,0 +87,4 @@\n+  virtual bool card_mark_must_follow_store() const {\n+    return true;\n+  }\n+\n@@ -102,1 +106,2 @@\n-  virtual void write_region(MemRegion mr);\n+  inline void write_region(MemRegion mr);\n+  void write_region(JavaThread* thread, MemRegion mr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSet.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -71,0 +71,4 @@\n+inline void G1BarrierSet::write_region(MemRegion mr) {\n+  write_region(JavaThread::current(), mr);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSet.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -406,6 +406,1 @@\n-  \/\/ Do not allow a GC because we are allocating a new TLAB to avoid an issue\n-  \/\/ with UseGCOverheadLimit: although this GC would return null if the overhead\n-  \/\/ limit would be exceeded, but it would likely free at least some space.\n-  \/\/ So the subsequent outside-TLAB allocation could be successful anyway and\n-  \/\/ the indication that the overhead limit had been exceeded swallowed.\n-  return attempt_allocation(min_size, requested_size, actual_size, false \/* allow_gc *\/);\n+  return attempt_allocation(min_size, requested_size, actual_size);\n@@ -414,1 +409,2 @@\n-HeapWord* G1CollectedHeap::mem_allocate(size_t word_size) {\n+HeapWord*\n+G1CollectedHeap::mem_allocate(size_t word_size) {\n@@ -421,1 +417,1 @@\n-  return attempt_allocation(word_size, word_size, &dummy, true \/* allow_gc *\/);\n+  return attempt_allocation(word_size, word_size, &dummy);\n@@ -424,1 +420,1 @@\n-HeapWord* G1CollectedHeap::attempt_allocation_slow(uint node_index, size_t word_size, bool allow_gc) {\n+HeapWord* G1CollectedHeap::attempt_allocation_slow(uint node_index, size_t word_size) {\n@@ -451,2 +447,0 @@\n-      } else if (!allow_gc) {\n-        return nullptr;\n@@ -621,2 +615,1 @@\n-                                                     size_t* actual_word_size,\n-                                                     bool allow_gc) {\n+                                                     size_t* actual_word_size) {\n@@ -634,1 +627,1 @@\n-    result = attempt_allocation_slow(node_index, desired_word_size, allow_gc);\n+    result = attempt_allocation_slow(node_index, desired_word_size);\n@@ -1401,0 +1394,1 @@\n+  bs->initialize();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":8,"deletions":14,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -442,3 +442,7 @@\n-  \/\/   this fails, (only) mem_allocate() will attempt to do an evacuation\n-  \/\/   pause and retry the allocation. Allocate_new_tlab() will return null,\n-  \/\/   deferring to the following mem_allocate().\n+  \/\/   this fails, they will attempt to do an evacuation pause and\n+  \/\/   retry the allocation.\n+  \/\/\n+  \/\/ * If all allocation attempts fail, even after trying to schedule\n+  \/\/   an evacuation pause, allocate_new_tlab() will return null,\n+  \/\/   whereas mem_allocate() will attempt a heap expansion and\/or\n+  \/\/   schedule a Full GC.\n@@ -449,1 +453,1 @@\n-  \/\/   will satisfy them in a special path.\n+  \/\/   will satisfy them with a special path.\n@@ -462,2 +466,2 @@\n-                                      size_t* actual_word_size,\n-                                      bool allow_gc);\n+                                      size_t* actual_word_size);\n+\n@@ -466,3 +470,2 @@\n-  \/\/ pause if allow_gc is set. This should only be used for non-humongous\n-  \/\/ allocations.\n-  HeapWord* attempt_allocation_slow(uint node_index, size_t word_size, bool allow_gc);\n+  \/\/ pause. This should only be used for non-humongous allocations.\n+  HeapWord* attempt_allocation_slow(uint node_index, size_t word_size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-MutableNUMASpace::MutableNUMASpace(size_t page_size) : MutableSpace(page_size) {\n+MutableNUMASpace::MutableNUMASpace(size_t alignment) : MutableSpace(alignment), _must_use_large_pages(false) {\n@@ -42,0 +42,1 @@\n+  _page_size = os::vm_page_size();\n@@ -45,0 +46,9 @@\n+#ifdef LINUX\n+  \/\/ Changing the page size can lead to freeing of memory. When using large pages\n+  \/\/ and the memory has been both reserved and committed, Linux does not support\n+  \/\/ freeing parts of it.\n+    if (UseLargePages && !os::can_commit_large_page_memory()) {\n+      _must_use_large_pages = true;\n+    }\n+#endif \/\/ LINUX\n+\n@@ -53,1 +63,1 @@\n-    lgrp_spaces()->append(new LGRPSpace(lgrp_ids[i], page_size));\n+    lgrp_spaces()->append(new LGRPSpace(lgrp_ids[i], alignment));\n@@ -121,4 +131,1 @@\n-  if (lgrp_spaces_index == -1) {\n-    \/\/ Running on a CPU with no memory; pick another CPU based on %.\n-    lgrp_spaces_index = lgrp_id % lgrp_spaces()->length();\n-  }\n+  assert(lgrp_spaces_index != -1, \"must have created spaces for all lgrp_ids\");\n@@ -142,5 +149,15 @@\n-  assert(is_aligned(mr.start(), page_size()), \"precondition\");\n-  assert(is_aligned(mr.end(), page_size()), \"precondition\");\n-\n-  if (mr.is_empty()) {\n-    return;\n+  HeapWord *start = align_up(mr.start(), page_size());\n+  HeapWord *end = align_down(mr.end(), page_size());\n+  if (end > start) {\n+    MemRegion aligned_region(start, end);\n+    assert((intptr_t)aligned_region.start()     % page_size() == 0 &&\n+           (intptr_t)aligned_region.byte_size() % page_size() == 0, \"Bad alignment\");\n+    assert(region().contains(aligned_region), \"Sanity\");\n+    \/\/ First we tell the OS which page size we want in the given range. The underlying\n+    \/\/ large page can be broken down if we require small pages.\n+    const size_t os_align = UseLargePages ? page_size() : os::vm_page_size();\n+    os::realign_memory((char*)aligned_region.start(), aligned_region.byte_size(), os_align);\n+    \/\/ Then we uncommit the pages in the range.\n+    os::disclaim_memory((char*)aligned_region.start(), aligned_region.byte_size());\n+    \/\/ And make them local\/first-touch biased.\n+    os::numa_make_local((char*)aligned_region.start(), aligned_region.byte_size(), checked_cast<int>(lgrp_id));\n@@ -148,7 +165,0 @@\n-  \/\/ First we tell the OS which page size we want in the given range. The underlying\n-  \/\/ large page can be broken down if we require small pages.\n-  os::realign_memory((char*) mr.start(), mr.byte_size(), page_size());\n-  \/\/ Then we uncommit the pages in the range.\n-  os::disclaim_memory((char*) mr.start(), mr.byte_size());\n-  \/\/ And make them local\/first-touch biased.\n-  os::numa_make_local((char*)mr.start(), mr.byte_size(), checked_cast<int>(lgrp_id));\n@@ -203,2 +213,1 @@\n-  \/\/ The number of pages may not be evenly divided.\n-  return align_down(capacity_in_bytes() \/ lgrp_spaces()->length(), page_size());\n+  return base_space_size() \/ lgrp_spaces()->length() * page_size();\n@@ -211,1 +220,1 @@\n-  size_t pages_available = capacity_in_bytes() \/ page_size();\n+  size_t pages_available = base_space_size();\n@@ -257,5 +266,0 @@\n-  assert(is_aligned(new_region.start(), page_size()), \"precondition\");\n-  assert(is_aligned(new_region.end(), page_size()), \"precondition\");\n-  assert(is_aligned(intersection.start(), page_size()), \"precondition\");\n-  assert(is_aligned(intersection.end(), page_size()), \"precondition\");\n-\n@@ -264,0 +268,12 @@\n+    \/\/ Try to coalesce small pages into a large one.\n+    if (UseLargePages && page_size() >= alignment()) {\n+      HeapWord* p = align_up(intersection.start(), alignment());\n+      if (new_region.contains(p)\n+          && pointer_delta(p, new_region.start(), sizeof(char)) >= alignment()) {\n+        if (intersection.contains(p)) {\n+          intersection = MemRegion(p, intersection.end());\n+        } else {\n+          intersection = MemRegion(p, p);\n+        }\n+      }\n+    }\n@@ -271,0 +287,12 @@\n+    \/\/ Try to coalesce small pages into a large one.\n+    if (UseLargePages && page_size() >= alignment()) {\n+      HeapWord* p = align_down(intersection.end(), alignment());\n+      if (new_region.contains(p)\n+          && pointer_delta(new_region.end(), p, sizeof(char)) >= alignment()) {\n+        if (intersection.contains(p)) {\n+          intersection = MemRegion(intersection.start(), p);\n+        } else {\n+          intersection = MemRegion(p, p);\n+        }\n+      }\n+    }\n@@ -284,2 +312,0 @@\n-  assert(is_aligned(mr.start(), page_size()), \"precondition\");\n-  assert(is_aligned(mr.end(), page_size()), \"precondition\");\n@@ -293,8 +319,18 @@\n-  size_t num_pages = mr.byte_size() \/ page_size();\n-\n-  if (num_pages < (size_t)lgrp_spaces()->length()) {\n-    log_warning(gc)(\"Degraded NUMA config: #os-pages (%zu) < #CPU (%d); space-size: %zu, page-size: %zu\",\n-      num_pages, lgrp_spaces()->length(), mr.byte_size(), page_size());\n-\n-    \/\/ Keep only the first few CPUs.\n-    lgrp_spaces()->trunc_to((int)num_pages);\n+  \/\/ Compute chunk sizes\n+  size_t prev_page_size = page_size();\n+  set_page_size(alignment());\n+  HeapWord* rounded_bottom = align_up(bottom(), page_size());\n+  HeapWord* rounded_end = align_down(end(), page_size());\n+  size_t base_space_size_pages = pointer_delta(rounded_end, rounded_bottom, sizeof(char)) \/ page_size();\n+\n+  \/\/ Try small pages if the chunk size is too small\n+  if (base_space_size_pages \/ lgrp_spaces()->length() == 0\n+      && page_size() > os::vm_page_size()) {\n+    \/\/ Changing the page size below can lead to freeing of memory. So we fail initialization.\n+    if (_must_use_large_pages) {\n+      vm_exit_during_initialization(\"Failed initializing NUMA with large pages. Too small heap size\");\n+    }\n+    set_page_size(os::vm_page_size());\n+    rounded_bottom = align_up(bottom(), page_size());\n+    rounded_end = align_down(end(), page_size());\n+    base_space_size_pages = pointer_delta(rounded_end, rounded_bottom, sizeof(char)) \/ page_size();\n@@ -302,0 +338,2 @@\n+  guarantee(base_space_size_pages \/ lgrp_spaces()->length() > 0, \"Space too small\");\n+  set_base_space_size(base_space_size_pages);\n@@ -306,1 +344,1 @@\n-    new_region = mr;\n+    new_region = MemRegion(rounded_bottom, rounded_end);\n@@ -308,1 +346,4 @@\n-    if (intersection.is_empty()) {\n+    if (intersection.start() == nullptr ||\n+        intersection.end() == nullptr   ||\n+        prev_page_size > page_size()) { \/\/ If the page size got smaller we have to change\n+                                        \/\/ the page size preference for the whole space.\n@@ -355,1 +396,1 @@\n-        new_region = MemRegion(bottom(), chunk_byte_size >> LogHeapWordSize);\n+        new_region = MemRegion(bottom(), rounded_bottom + (chunk_byte_size >> LogHeapWordSize));\n@@ -359,8 +400,9 @@\n-    } else if (i < lgrp_spaces()->length() - 1) { \/\/ Middle chunks\n-      MutableSpace* ps = lgrp_spaces()->at(i - 1)->space();\n-      new_region = MemRegion(ps->end(),\n-                             chunk_byte_size >> LogHeapWordSize);\n-    } else { \/\/ Top chunk\n-      MutableSpace* ps = lgrp_spaces()->at(i - 1)->space();\n-      new_region = MemRegion(ps->end(), end());\n-    }\n+    } else\n+      if (i < lgrp_spaces()->length() - 1) { \/\/ Middle chunks\n+        MutableSpace *ps = lgrp_spaces()->at(i - 1)->space();\n+        new_region = MemRegion(ps->end(),\n+                               ps->end() + (chunk_byte_size >> LogHeapWordSize));\n+      } else { \/\/ Top chunk\n+        MutableSpace *ps = lgrp_spaces()->at(i - 1)->space();\n+        new_region = MemRegion(ps->end(), end());\n+      }\n@@ -393,0 +435,2 @@\n+\n+    set_adaptation_cycles(samples_count());\n@@ -394,1 +438,0 @@\n-  set_adaptation_cycles(samples_count());\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.cpp","additions":91,"deletions":48,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -83,2 +83,2 @@\n-    LGRPSpace(uint l, size_t page_size) : _lgrp_id(l), _allocation_failed(false) {\n-      _space = new MutableSpace(page_size);\n+    LGRPSpace(uint l, size_t alignment) : _lgrp_id(l), _allocation_failed(false) {\n+      _space = new MutableSpace(alignment);\n@@ -120,0 +120,1 @@\n+  size_t _page_size;\n@@ -122,0 +123,5 @@\n+  bool _must_use_large_pages;\n+\n+  void set_page_size(size_t psz)                     { _page_size = psz;          }\n+  size_t page_size() const                           { return _page_size;         }\n+\n@@ -128,0 +134,4 @@\n+  size_t _base_space_size;\n+  void set_base_space_size(size_t v)                 { _base_space_size = v;      }\n+  size_t base_space_size() const                     { return _base_space_size;   }\n+\n@@ -147,1 +157,1 @@\n-  MutableNUMASpace(size_t page_size);\n+  MutableNUMASpace(size_t alignment);\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.hpp","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-MutableSpace::MutableSpace(size_t page_size) :\n+MutableSpace::MutableSpace(size_t alignment) :\n@@ -39,1 +39,1 @@\n-  _page_size(page_size),\n+  _alignment(alignment),\n@@ -42,9 +42,5 @@\n-  _end(nullptr) {}\n-\n-void MutableSpace::numa_setup_pages(MemRegion mr, bool clear_space) {\n-  assert(is_aligned(mr.start(), page_size()), \"precondition\");\n-  assert(is_aligned(mr.end(), page_size()), \"precondition\");\n-\n-  if (mr.is_empty()) {\n-    return;\n-  }\n+  _end(nullptr)\n+{\n+  assert(MutableSpace::alignment() % os::vm_page_size() == 0,\n+         \"Space should be aligned\");\n+}\n@@ -52,3 +48,12 @@\n-  if (clear_space) {\n-    \/\/ Prefer page reallocation to migration.\n-    os::disclaim_memory((char*) mr.start(), mr.byte_size());\n+void MutableSpace::numa_setup_pages(MemRegion mr, size_t page_size, bool clear_space) {\n+  if (!mr.is_empty()) {\n+    HeapWord *start = align_up(mr.start(), page_size);\n+    HeapWord *end =   align_down(mr.end(), page_size);\n+    if (end > start) {\n+      size_t size = pointer_delta(end, start, sizeof(char));\n+      if (clear_space) {\n+        \/\/ Prefer page reallocation to migration.\n+        os::disclaim_memory((char*)start, size);\n+      }\n+      os::numa_make_global((char*)start, size);\n+    }\n@@ -56,1 +61,0 @@\n-  os::numa_make_global((char*) mr.start(), mr.byte_size());\n@@ -104,0 +108,2 @@\n+    size_t page_size = alignment();\n+\n@@ -105,2 +111,2 @@\n-      numa_setup_pages(head, clear_space);\n-      numa_setup_pages(tail, clear_space);\n+      numa_setup_pages(head, page_size, clear_space);\n+      numa_setup_pages(tail, page_size, clear_space);\n@@ -110,0 +116,1 @@\n+      size_t pretouch_page_size = UseLargePages ? page_size : os::vm_page_size();\n@@ -111,1 +118,1 @@\n-                             page_size(), pretouch_workers);\n+                             pretouch_page_size, pretouch_workers);\n@@ -114,1 +121,1 @@\n-                             page_size(), pretouch_workers);\n+                             pretouch_page_size, pretouch_workers);\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableSpace.cpp","additions":26,"deletions":19,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-  size_t _page_size;\n+  size_t _alignment;\n@@ -59,1 +59,1 @@\n-  void numa_setup_pages(MemRegion mr, bool clear_space);\n+  void numa_setup_pages(MemRegion mr, size_t page_size, bool clear_space);\n@@ -64,4 +64,1 @@\n-protected:\n-  size_t page_size() const                 { return _page_size;         }\n-\n-public:\n+ public:\n@@ -83,0 +80,2 @@\n+  size_t alignment()                       { return _alignment; }\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableSpace.hpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -50,4 +50,1 @@\n-  ReservedSpace backing_store = MemoryReserver::reserve(bytes_to_reserve,\n-                                                        os::vm_allocation_granularity(),\n-                                                        os::vm_page_size(),\n-                                                        mtGC);\n+  ReservedSpace backing_store = MemoryReserver::reserve(bytes_to_reserve, mtGC);\n","filename":"src\/hotspot\/share\/gc\/parallel\/objectStartArray.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -106,0 +106,5 @@\n+\/\/ The alignment used for spaces in young gen and old gen\n+static size_t default_space_alignment() {\n+  return 64 * K * HeapWordSize;\n+}\n+\n@@ -109,1 +114,1 @@\n-  SpaceAlignment = ParallelScavengeHeap::default_space_alignment();\n+  SpaceAlignment = default_space_alignment();\n@@ -121,6 +126,0 @@\n-  if (!UseLargePages) {\n-    ParallelScavengeHeap::set_desired_page_size(os::vm_page_size());\n-    return;\n-  }\n-\n-  \/\/ If using large-page, need to update SpaceAlignment so that spaces are page-size aligned.\n@@ -129,6 +128,0 @@\n-  ParallelScavengeHeap::set_desired_page_size(page_sz);\n-\n-  if (page_sz == os::vm_page_size()) {\n-    log_warning(gc, heap)(\"MinHeapSize (%zu) must be large enough for 4 * page-size; Disabling UseLargePages for heap\", MinHeapSize);\n-    return;\n-  }\n@@ -136,2 +129,3 @@\n-  \/\/ Space is largepage-aligned.\n-  size_t new_alignment = page_sz;\n+  \/\/ Can a page size be something else than a power of two?\n+  assert(is_power_of_2((intptr_t)page_sz), \"must be a power of 2\");\n+  size_t new_alignment = align_up(page_sz, SpaceAlignment);\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelArguments.cpp","additions":9,"deletions":15,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -64,1 +64,0 @@\n-size_t ParallelScavengeHeap::_desired_page_size = 0;\n@@ -69,7 +68,1 @@\n-  assert(_desired_page_size != 0, \"Should be initialized\");\n-  ReservedHeapSpace heap_rs = Universe::reserve_heap(reserved_heap_size, HeapAlignment, _desired_page_size);\n-  \/\/ Adjust SpaceAlignment based on actually used large page size.\n-  if (UseLargePages) {\n-    SpaceAlignment = MAX2(heap_rs.page_size(), default_space_alignment());\n-  }\n-  assert(is_aligned(SpaceAlignment, heap_rs.page_size()), \"inv\");\n+  ReservedHeapSpace heap_rs = Universe::reserve_heap(reserved_heap_size, HeapAlignment);\n@@ -89,0 +82,1 @@\n+  barrier_set->initialize();\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -79,3 +79,0 @@\n-  \/\/ At startup, calculate the desired OS page-size based on heap size and large-page flags.\n-  static size_t _desired_page_size;\n-\n@@ -134,12 +131,0 @@\n-  \/\/ The alignment used for spaces in young gen and old gen\n-  constexpr static size_t default_space_alignment() {\n-    constexpr size_t alignment = 64 * K * HeapWordSize;\n-    static_assert(is_power_of_2(alignment), \"inv\");\n-    return alignment;\n-  }\n-\n-  static void set_desired_page_size(size_t page_size) {\n-    assert(is_power_of_2(page_size), \"precondition\");\n-    _desired_page_size = page_size;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -123,0 +123,1 @@\n+  inline void push(PartialArrayState* stat);\n@@ -191,0 +192,1 @@\n+  inline void push(oop obj);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,0 +59,8 @@\n+inline void ParCompactionManager::push(oop obj) {\n+  marking_stack()->push(ScannerTask(obj));\n+}\n+\n+inline void ParCompactionManager::push(PartialArrayState* stat) {\n+  marking_stack()->push(ScannerTask(stat));\n+}\n+\n@@ -73,14 +81,17 @@\n-  if (CompressedOops::is_null(heap_oop)) {\n-    return;\n-  }\n-\n-  oop obj = CompressedOops::decode_not_null(heap_oop);\n-  if (!mark_bitmap()->mark_obj(obj)) {\n-    \/\/ Marked by another worker.\n-    return;\n-  }\n-\n-  if (StringDedup::is_enabled() &&\n-      java_lang_String::is_instance(obj) &&\n-      psStringDedup::is_candidate_from_mark(obj)) {\n-    _string_dedup_requests.add(obj);\n+  if (!CompressedOops::is_null(heap_oop)) {\n+    oop obj = CompressedOops::decode_not_null(heap_oop);\n+    assert(ParallelScavengeHeap::heap()->is_in(obj), \"should be in heap\");\n+\n+    if (mark_bitmap()->mark_obj(obj)) {\n+      if (StringDedup::is_enabled() &&\n+          java_lang_String::is_instance(obj) &&\n+          psStringDedup::is_candidate_from_mark(obj)) {\n+        _string_dedup_requests.add(obj);\n+      }\n+\n+      ContinuationGCSupport::transform_stack_chunk(obj);\n+\n+      assert(_marking_stats_cache != nullptr, \"inv\");\n+      _marking_stats_cache->push(obj, obj->size());\n+      push(obj);\n+    }\n@@ -88,5 +99,0 @@\n-\n-  ContinuationGCSupport::transform_stack_chunk(obj);\n-\n-  _marking_stats_cache->push(obj, obj->size());\n-  marking_stack()->push(ScannerTask(obj));\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.inline.hpp","additions":25,"deletions":19,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-  _object_space = new MutableSpace(virtual_space()->page_size());\n+  _object_space = new MutableSpace(virtual_space()->alignment());\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-  _alignment(alignment),\n-  _page_size(rs.page_size()) {\n+  _alignment(alignment)\n+{\n@@ -91,2 +91,1 @@\n-  assert(is_aligned(_page_size, os::vm_page_size()), \"bad alignment\");\n-  assert(is_aligned(_alignment, _page_size), \"inv\");\n+  assert(is_aligned(_alignment, os::vm_page_size()), \"bad alignment\");\n","filename":"src\/hotspot\/share\/gc\/parallel\/psVirtualspace.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -44,3 +44,0 @@\n-  \/\/ OS page size used. If using Transparent Huge Pages, it's the desired large page-size.\n-  const size_t _page_size;\n-\n@@ -74,1 +71,0 @@\n-  size_t page_size()          const { return _page_size; }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psVirtualspace.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-    _eden_space = new MutableNUMASpace(virtual_space()->page_size());\n+    _eden_space = new MutableNUMASpace(virtual_space()->alignment());\n@@ -88,1 +88,1 @@\n-    _eden_space = new MutableSpace(virtual_space()->page_size());\n+    _eden_space = new MutableSpace(virtual_space()->alignment());\n@@ -90,2 +90,2 @@\n-  _from_space = new MutableSpace(virtual_space()->page_size());\n-  _to_space   = new MutableSpace(virtual_space()->page_size());\n+  _from_space = new MutableSpace(virtual_space()->alignment());\n+  _to_space   = new MutableSpace(virtual_space()->alignment());\n","filename":"src\/hotspot\/share\/gc\/parallel\/psYoungGen.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-  nonstatic_field(PSVirtualSpace,              _page_size,                                    const size_t)                          \\\n","filename":"src\/hotspot\/share\/gc\/parallel\/vmStructs_parallelgc.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -228,0 +228,6 @@\n+  MemRegion cmr((HeapWord*)_virtual_space.low(),\n+                (HeapWord*)_virtual_space.high());\n+  SerialHeap* gch = SerialHeap::heap();\n+\n+  gch->rem_set()->resize_covered_region(cmr);\n+\n@@ -232,2 +238,0 @@\n-  init_spaces();\n-\n@@ -255,0 +259,1 @@\n+  compute_space_boundaries(0, SpaceDecorator::Clear, SpaceDecorator::Mangle);\n@@ -266,8 +271,9 @@\n-void DefNewGeneration::init_spaces() {\n-  \/\/ Using layout: from, to, eden, so only from can be non-empty.\n-  assert(eden()->is_empty(), \"precondition\");\n-  assert(to()->is_empty(), \"precondition\");\n-\n-  if (!from()->is_empty()) {\n-    assert((char*) from()->bottom() == _virtual_space.low(), \"inv\");\n-  }\n+void DefNewGeneration::compute_space_boundaries(uintx minimum_eden_size,\n+                                                bool clear_space,\n+                                                bool mangle_space) {\n+  \/\/ If the spaces are being cleared (only done at heap initialization\n+  \/\/ currently), the survivor spaces need not be empty.\n+  \/\/ Otherwise, no care is taken for used areas in the survivor spaces\n+  \/\/ so check.\n+  assert(clear_space || (to()->is_empty() && from()->is_empty()),\n+    \"Initialization of the survivor spaces assumes these are empty\");\n@@ -276,5 +282,11 @@\n-  size_t size = _virtual_space.committed_size();\n-  size_t survivor_size = compute_survivor_size(size, SpaceAlignment);\n-  assert(survivor_size >= from()->used(), \"inv\");\n-  assert(size > 2 * survivor_size, \"inv\");\n-  size_t eden_size = size - (2 * survivor_size);\n+  uintx size = _virtual_space.committed_size();\n+  uintx survivor_size = compute_survivor_size(size, SpaceAlignment);\n+  uintx eden_size = size - (2*survivor_size);\n+  if (eden_size > max_eden_size()) {\n+    \/\/ Need to reduce eden_size to satisfy the max constraint. The delta needs\n+    \/\/ to be 2*SpaceAlignment aligned so that both survivors are properly\n+    \/\/ aligned.\n+    uintx eden_delta = align_up(eden_size - max_eden_size(), 2*SpaceAlignment);\n+    eden_size     -= eden_delta;\n+    survivor_size += eden_delta\/2;\n+  }\n@@ -283,5 +295,11 @@\n-  \/\/ layout: from, to, eden\n-  char* from_start = _virtual_space.low();\n-  char* to_start = from_start + survivor_size;\n-  char* eden_start = to_start + survivor_size;\n-  char* eden_end = eden_start + eden_size;\n+  if (eden_size < minimum_eden_size) {\n+    \/\/ May happen due to 64Kb rounding, if so adjust eden size back up\n+    minimum_eden_size = align_up(minimum_eden_size, SpaceAlignment);\n+    uintx maximum_survivor_size = (size - minimum_eden_size) \/ 2;\n+    uintx unaligned_survivor_size =\n+      align_down(maximum_survivor_size, SpaceAlignment);\n+    survivor_size = MAX2(unaligned_survivor_size, SpaceAlignment);\n+    eden_size = size - (2*survivor_size);\n+    assert(eden_size > 0 && survivor_size <= eden_size, \"just checking\");\n+    assert(eden_size >= minimum_eden_size, \"just checking\");\n+  }\n@@ -289,1 +307,7 @@\n-  assert(eden_end == _virtual_space.high(), \"just checking\");\n+  char *eden_start = _virtual_space.low();\n+  char *from_start = eden_start + eden_size;\n+  char *to_start   = from_start + survivor_size;\n+  char *to_end     = to_start   + survivor_size;\n+\n+  assert(to_end == _virtual_space.high(), \"just checking\");\n+  assert(is_aligned(eden_start, SpaceAlignment), \"checking alignment\");\n@@ -292,2 +316,0 @@\n-  assert(is_aligned(eden_start, SpaceAlignment), \"checking alignment\");\n-  assert(is_aligned(eden_end, SpaceAlignment), \"checking alignment\");\n@@ -295,0 +317,1 @@\n+  MemRegion edenMR((HeapWord*)eden_start, (HeapWord*)from_start);\n@@ -296,7 +319,1 @@\n-  MemRegion toMR  ((HeapWord*)to_start, (HeapWord*)eden_start);\n-  MemRegion edenMR((HeapWord*)eden_start, (HeapWord*)eden_end);\n-\n-  \/\/ Reset the spaces for their new regions.\n-  from()->initialize(fromMR, from()->is_empty());\n-  to()->initialize(toMR, true);\n-  eden()->initialize(edenMR, true);\n+  MemRegion toMR  ((HeapWord*)to_start, (HeapWord*)to_end);\n@@ -304,2 +321,4 @@\n-  post_resize();\n-}\n+  \/\/ A minimum eden size implies that there is a part of eden that\n+  \/\/ is being used and that affects the initialization of any\n+  \/\/ newly formed eden.\n+  bool live_in_eden = minimum_eden_size > 0;\n@@ -307,4 +326,13 @@\n-void DefNewGeneration::post_resize() {\n-  MemRegion cmr((HeapWord*)_virtual_space.low(),\n-                (HeapWord*)_virtual_space.high());\n-  SerialHeap::heap()->rem_set()->resize_covered_region(cmr);\n+  \/\/ Reset the spaces for their new regions.\n+  eden()->initialize(edenMR,\n+                     clear_space && !live_in_eden,\n+                     SpaceDecorator::Mangle);\n+  \/\/ If clear_space and live_in_eden, we will not have cleared any\n+  \/\/ portion of eden above its top. This can cause newly\n+  \/\/ expanded space not to be mangled if using ZapUnusedHeapArea.\n+  \/\/ We explicitly do such mangling here.\n+  if (ZapUnusedHeapArea && clear_space && live_in_eden && mangle_space) {\n+    eden()->mangle_unused_area();\n+  }\n+  from()->initialize(fromMR, clear_space, mangle_space);\n+  to()->initialize(toMR, clear_space, mangle_space);\n@@ -326,3 +354,1 @@\n-  assert(bytes != 0, \"precondition\");\n-  assert(is_aligned(bytes, SpaceAlignment), \"precondition\");\n-\n+  HeapWord* prev_high = (HeapWord*) _virtual_space.high();\n@@ -330,2 +356,7 @@\n-  if (!success) {\n-    log_info(gc)(\"Failed to expand young-gen by %zu bytes\", bytes);\n+  if (success && ZapUnusedHeapArea) {\n+    \/\/ Mangle newly committed space immediately because it\n+    \/\/ can be done here more simply that after the new\n+    \/\/ spaces have been computed.\n+    HeapWord* new_high = (HeapWord*) _virtual_space.high();\n+    MemRegion mangle_region(prev_high, new_high);\n+    SpaceMangler::mangle_region(mangle_region);\n@@ -337,11 +368,0 @@\n-void DefNewGeneration::expand_eden_by(size_t delta_bytes) {\n-  if (!expand(delta_bytes)) {\n-    return;\n-  }\n-\n-  MemRegion eden_mr{eden()->bottom(), (HeapWord*)_virtual_space.high()};\n-  eden()->initialize(eden_mr, eden()->is_empty());\n-\n-  post_resize();\n-}\n-\n@@ -380,2 +400,12 @@\n-size_t DefNewGeneration::calculate_desired_young_gen_bytes() const {\n-  size_t old_size = SerialHeap::heap()->old_gen()->capacity();\n+void DefNewGeneration::compute_new_size() {\n+  \/\/ This is called after a GC that includes the old generation, so from-space\n+  \/\/ will normally be empty.\n+  \/\/ Note that we check both spaces, since if scavenge failed they revert roles.\n+  \/\/ If not we bail out (otherwise we would have to relocate the objects).\n+  if (!from()->is_empty() || !to()->is_empty()) {\n+    return;\n+  }\n+\n+  SerialHeap* gch = SerialHeap::heap();\n+\n+  size_t old_size = gch->old_gen()->capacity();\n@@ -402,32 +432,8 @@\n-  if (!from()->is_empty()) {\n-    \/\/ Mininum constraint to hold all live objs inside from-space.\n-    size_t min_survivor_size = align_up(from()->used(), alignment);\n-\n-    \/\/ SurvivorRatio := eden_size \/ survivor_size\n-    \/\/ young-gen-size = eden_size                     + 2 * survivor_size\n-    \/\/                = SurvivorRatio * survivor_size + 2 * survivor_size\n-    \/\/                = (SurvivorRatio + 2) * survivor_size\n-    size_t min_young_gen_size = min_survivor_size * (SurvivorRatio + 2);\n-\n-    desired_new_size = MAX2(min_young_gen_size, desired_new_size);\n-  }\n-  assert(is_aligned(desired_new_size, alignment), \"postcondition\");\n-\n-  return desired_new_size;\n-}\n-\n-void DefNewGeneration::resize_inner() {\n-  assert(eden()->is_empty(), \"precondition\");\n-  assert(to()->is_empty(), \"precondition\");\n-\n-  size_t current_young_gen_size_bytes = _virtual_space.committed_size();\n-  size_t desired_young_gen_size_bytes = calculate_desired_young_gen_bytes();\n-  if (current_young_gen_size_bytes == desired_young_gen_size_bytes) {\n-    return;\n-  }\n-\n-  \/\/ Commit\/uncommit\n-  if (desired_young_gen_size_bytes > current_young_gen_size_bytes) {\n-    size_t delta_bytes = desired_young_gen_size_bytes - current_young_gen_size_bytes;\n-    if (!expand(delta_bytes)) {\n-      return;\n+  assert(desired_new_size <= max_new_size, \"just checking\");\n+\n+  bool changed = false;\n+  if (desired_new_size > new_size_before) {\n+    size_t change = desired_new_size - new_size_before;\n+    assert(change % alignment == 0, \"just checking\");\n+    if (expand(change)) {\n+       changed = true;\n@@ -435,43 +441,31 @@\n-  } else {\n-    size_t delta_bytes = current_young_gen_size_bytes - desired_young_gen_size_bytes;\n-    _virtual_space.shrink_by(delta_bytes);\n-  }\n-\n-  assert(desired_young_gen_size_bytes == _virtual_space.committed_size(), \"inv\");\n-\n-  init_spaces();\n-\n-  log_debug(gc, ergo, heap)(\"New generation size %zuK->%zuK [eden=%zuK,survivor=%zuK]\",\n-    current_young_gen_size_bytes\/K, _virtual_space.committed_size()\/K,\n-    eden()->capacity()\/K, from()->capacity()\/K);\n-}\n-\n-void DefNewGeneration::resize_after_young_gc() {\n-  \/\/ Called only after successful young-gc.\n-  assert(eden()->is_empty(), \"precondition\");\n-  assert(to()->is_empty(), \"precondition\");\n-\n-  if ((char*)to()->bottom() == _virtual_space.low()) {\n-    \/\/ layout: to, from, eden; can't resize.\n-    return;\n-  }\n-\n-  assert((char*)from()->bottom() == _virtual_space.low(), \"inv\");\n-  resize_inner();\n-}\n-\n-void DefNewGeneration::resize_after_full_gc() {\n-  if (eden()->is_empty() && from()->is_empty() && to()->is_empty()) {\n-    resize_inner();\n-    return;\n-  }\n-\n-  \/\/ Usually the young-gen is empty after full-gc.\n-  \/\/ This is the extreme case; expand young-gen to its max size.\n-  if (_virtual_space.uncommitted_size() == 0) {\n-    \/\/ Already at its max size.\n-    return;\n-  }\n-\n-  \/\/ Keep from\/to and expand eden.\n-  expand_eden_by(_virtual_space.uncommitted_size());\n+    \/\/ If the heap failed to expand to the desired size,\n+    \/\/ \"changed\" will be false.  If the expansion failed\n+    \/\/ (and at this point it was expected to succeed),\n+    \/\/ ignore the failure (leaving \"changed\" as false).\n+  }\n+  if (desired_new_size < new_size_before && eden()->is_empty()) {\n+    \/\/ bail out of shrinking if objects in eden\n+    size_t change = new_size_before - desired_new_size;\n+    assert(change % alignment == 0, \"just checking\");\n+    _virtual_space.shrink_by(change);\n+    changed = true;\n+  }\n+  if (changed) {\n+    \/\/ The spaces have already been mangled at this point but\n+    \/\/ may not have been cleared (set top = bottom) and should be.\n+    \/\/ Mangling was done when the heap was being expanded.\n+    compute_space_boundaries(eden()->used(),\n+                             SpaceDecorator::Clear,\n+                             SpaceDecorator::DontMangle);\n+    MemRegion cmr((HeapWord*)_virtual_space.low(),\n+                  (HeapWord*)_virtual_space.high());\n+    gch->rem_set()->resize_covered_region(cmr);\n+\n+    log_debug(gc, ergo, heap)(\n+        \"New generation size %zuK->%zuK [eden=%zuK,survivor=%zuK]\",\n+        new_size_before\/K, _virtual_space.committed_size()\/K,\n+        eden()->capacity()\/K, from()->capacity()\/K);\n+    log_trace(gc, ergo, heap)(\n+        \"  [allowed %zuK extra for %d threads]\",\n+          thread_increase_size\/K, threads_count);\n+      }\n@@ -492,0 +486,1 @@\n+\n@@ -497,0 +492,1 @@\n+\n@@ -504,2 +500,1 @@\n-  const size_t min_survivor_bytes = SpaceAlignment;\n-  return reserved_bytes - min_survivor_bytes;\n+  return reserved_bytes - compute_survivor_size(reserved_bytes, SpaceAlignment);\n@@ -597,0 +592,1 @@\n+  to()->clear(SpaceDecorator::Mangle);\n@@ -846,12 +842,7 @@\n-HeapWord* DefNewGeneration::expand_and_allocate(size_t word_size) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"precondition\");\n-  assert(Thread::current()->is_VM_thread(), \"precondition\");\n-\n-  size_t eden_free_bytes = eden()->free();\n-  size_t requested_bytes = word_size * HeapWordSize;\n-  if (eden_free_bytes < requested_bytes) {\n-    size_t expand_bytes = requested_bytes - eden_free_bytes;\n-    expand_eden_by(align_up(expand_bytes, SpaceAlignment));\n-  }\n-\n-  HeapWord* result = eden()->allocate(word_size);\n+HeapWord* DefNewGeneration::allocate(size_t word_size) {\n+  \/\/ This is the slow-path allocation for the DefNewGeneration.\n+  \/\/ Most allocations are fast-path in compiled code.\n+  \/\/ We try to allocate from the eden.  If that works, we are happy.\n+  \/\/ Note that since DefNewGeneration supports lock-free allocation, we\n+  \/\/ have to use it here, as well.\n+  HeapWord* result = eden()->par_allocate(word_size);\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":134,"deletions":143,"binary":false,"changes":277,"status":"modified"},{"patch":"@@ -134,7 +134,0 @@\n-  size_t calculate_desired_young_gen_bytes() const;\n-\n-  void expand_eden_by(size_t delta_bytes);\n-\n-  void resize_inner();\n-  void post_resize();\n-\n@@ -193,0 +186,2 @@\n+  \/\/ Allocate requested size or return null; single-threaded and lock-free versions.\n+  HeapWord* allocate(size_t word_size);\n@@ -194,1 +189,0 @@\n-  HeapWord* expand_and_allocate(size_t word_size);\n@@ -205,2 +199,2 @@\n-  void resize_after_young_gc();\n-  void resize_after_full_gc();\n+  \/\/ GC support\n+  void compute_new_size();\n@@ -229,3 +223,7 @@\n- private:\n-  \/\/ Initialize eden\/from\/to spaces.\n-  void init_spaces();\n+ protected:\n+  \/\/ If clear_space is true, clear the survivor spaces.  Eden is\n+  \/\/ cleared if the minimum size of eden is 0.  If mangle_space\n+  \/\/ is true, also mangle the space in debug mode.\n+  void compute_space_boundaries(uintx minimum_eden_size,\n+                                bool clear_space,\n+                                bool mangle_space);\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.hpp","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -185,0 +185,1 @@\n+  bs->initialize();\n@@ -271,1 +272,1 @@\n-  HeapWord* result = _young_gen->expand_and_allocate(size);\n+  HeapWord* result = _young_gen->allocate(size);\n@@ -273,1 +274,1 @@\n-  if (result == nullptr && !is_tlab) {\n+  if (result == nullptr) {\n@@ -390,1 +391,0 @@\n-    _young_gen->resize_after_young_gc();\n@@ -397,0 +397,2 @@\n+  _young_gen->compute_new_size();\n+\n@@ -582,1 +584,1 @@\n-  _young_gen->resize_after_full_gc();\n+  _young_gen->compute_new_size();\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,4 +58,4 @@\n-\/\/ +--------+--------+-----------------+--------+---------------+-------------------+\n-\/\/ |  from  |   to   |       eden      |        |      old      |                   |\n-\/\/ |  (to)  | (from) |                 |        |               |                   |\n-\/\/ +--------+--------+-----------------+--------+---------------+-------------------+\n+\/\/ +-----------------+--------+--------+--------+---------------+-------------------+\n+\/\/ |       eden      |  from  |   to   |        |      old      |                   |\n+\/\/ |                 |  (to)  | (from) |        |               |                   |\n+\/\/ +-----------------+--------+--------+--------+---------------+-------------------+\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -317,1 +317,1 @@\n-  _the_space->initialize(MemRegion(bottom, end), SpaceDecorator::Clear);\n+  _the_space->initialize(MemRegion(bottom, end), SpaceDecorator::Clear, SpaceDecorator::Mangle);\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-  _preserve.insert(OptoReg::as_OptoReg(vm_reg));\n+  _preserve.Insert(OptoReg::as_OptoReg(vm_reg));\n@@ -127,1 +127,1 @@\n-    _preserve.remove(OptoReg::as_OptoReg(vm_reg));\n+    _preserve.Remove(OptoReg::as_OptoReg(vm_reg));\n@@ -1174,1 +1174,1 @@\n-      new_live.or_with(live[succ_id]);\n+      new_live.OR(live[succ_id]);\n@@ -1185,1 +1185,1 @@\n-          regs->or_with(new_live);\n+          regs->OR(new_live);\n@@ -1193,1 +1193,1 @@\n-        new_live.remove(first);\n+        new_live.Remove(first);\n@@ -1196,1 +1196,1 @@\n-        new_live.remove(second);\n+        new_live.Remove(second);\n@@ -1205,1 +1205,1 @@\n-          new_live.insert(first);\n+          new_live.Insert(first);\n@@ -1208,1 +1208,1 @@\n-          new_live.insert(second);\n+          new_live.Insert(second);\n@@ -1216,1 +1216,1 @@\n-          regs->or_with(new_live);\n+          regs->OR(new_live);\n@@ -1222,2 +1222,2 @@\n-    new_live.subtract(old_live);\n-    if (!new_live.is_empty()) {\n+    new_live.SUBTRACT(old_live);\n+    if (!new_live.is_Empty()) {\n@@ -1225,1 +1225,1 @@\n-      old_live.or_with(new_live);\n+      old_live.OR(new_live);\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+  _defer_initial_card_mark(false),\n@@ -68,0 +69,1 @@\n+  _defer_initial_card_mark(false),\n@@ -71,0 +73,4 @@\n+void CardTableBarrierSet::initialize() {\n+  initialize_deferred_card_mark_barriers();\n+}\n+\n@@ -105,1 +111,3 @@\n-\/\/     that this barrier need only be applied to a non-young write.\n+\/\/     that this barrier need only be applied to a non-young write,\n+\/\/     but, because of the presence of concurrent refinement,\n+\/\/     must strictly follow the oop-store.\n@@ -115,0 +123,2 @@\n+  \/\/ If a previous card-mark was deferred, flush it now.\n+  flush_deferred_card_mark_barrier(thread);\n@@ -117,0 +127,3 @@\n+    \/\/ The deferred_card_mark region should be empty\n+    \/\/ following the flush above.\n+    assert(thread->deferred_card_mark().is_empty(), \"Error\");\n@@ -120,2 +133,7 @@\n-    \/\/ Do the card mark\n-    write_region(mr);\n+    if (_defer_initial_card_mark) {\n+      \/\/ Defer the card mark\n+      thread->set_deferred_card_mark(mr);\n+    } else {\n+      \/\/ Do the card mark\n+      write_region(mr);\n+    }\n@@ -125,0 +143,49 @@\n+\n+void CardTableBarrierSet::initialize_deferred_card_mark_barriers() {\n+  \/\/ Used for ReduceInitialCardMarks (when COMPILER2 or JVMCI is used);\n+  \/\/ otherwise remains unused.\n+#if COMPILER2_OR_JVMCI\n+  _defer_initial_card_mark = CompilerConfig::is_c2_or_jvmci_compiler_enabled() && ReduceInitialCardMarks\n+                             && (DeferInitialCardMark || card_mark_must_follow_store());\n+#else\n+  assert(_defer_initial_card_mark == false, \"Who would set it?\");\n+#endif\n+}\n+\n+void CardTableBarrierSet::flush_deferred_card_mark_barrier(JavaThread* thread) {\n+#if COMPILER2_OR_JVMCI\n+  MemRegion deferred = thread->deferred_card_mark();\n+  if (!deferred.is_empty()) {\n+    assert(_defer_initial_card_mark, \"Otherwise should be empty\");\n+    {\n+      \/\/ Verify that the storage points to a parsable object in heap\n+      DEBUG_ONLY(oop old_obj = cast_to_oop(deferred.start());)\n+      assert(!_card_table->is_in_young(old_obj),\n+             \"Else should have been filtered in on_slowpath_allocation_exit()\");\n+      assert(oopDesc::is_oop(old_obj), \"Not an oop\");\n+      assert(deferred.word_size() == old_obj->size(),\n+             \"Mismatch: multiple objects?\");\n+    }\n+    write_region(thread, deferred);\n+    \/\/ \"Clear\" the deferred_card_mark field\n+    thread->set_deferred_card_mark(MemRegion());\n+  }\n+  assert(thread->deferred_card_mark().is_empty(), \"invariant\");\n+#else\n+  assert(!_defer_initial_card_mark, \"Should be false\");\n+  assert(thread->deferred_card_mark().is_empty(), \"Should be empty\");\n+#endif\n+}\n+\n+void CardTableBarrierSet::on_thread_detach(Thread* thread) {\n+  \/\/ The deferred store barriers must all have been flushed to the\n+  \/\/ card-table (or other remembered set structure) before GC starts\n+  \/\/ processing the card-table (or other remembered set).\n+  if (thread->is_Java_thread()) { \/\/ Only relevant for Java threads.\n+    flush_deferred_card_mark_barrier(JavaThread::cast(thread));\n+  }\n+}\n+\n+bool CardTableBarrierSet::card_mark_must_follow_store() const {\n+  return false;\n+}\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableBarrierSet.cpp","additions":70,"deletions":3,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -50,0 +50,3 @@\n+  \/\/ Used in support of ReduceInitialCardMarks; only consulted if COMPILER2\n+  \/\/ or INCLUDE_JVMCI is being used\n+  bool       _defer_initial_card_mark;\n@@ -64,0 +67,7 @@\n+  void initialize();\n+\n+  void write_region(JavaThread* thread, MemRegion mr) {\n+    write_region(mr);\n+  }\n+\n+ public:\n@@ -73,0 +83,19 @@\n+  \/\/ ReduceInitialCardMarks\n+  void initialize_deferred_card_mark_barriers();\n+\n+  \/\/ If the CollectedHeap was asked to defer a store barrier above,\n+  \/\/ this informs it to flush such a deferred store barrier to the\n+  \/\/ remembered set.\n+  void flush_deferred_card_mark_barrier(JavaThread* thread);\n+\n+  \/\/ If a compiler is eliding store barriers for TLAB-allocated objects,\n+  \/\/ we will be informed of a slow-path allocation by a call\n+  \/\/ to on_slowpath_allocation_exit() below. Such a call precedes the\n+  \/\/ initialization of the object itself, and no post-store-barriers will\n+  \/\/ be issued. Some heap types require that the barrier strictly follows\n+  \/\/ the initializing stores. (This is currently implemented by deferring the\n+  \/\/ barrier until the next slow-path allocation or gc-related safepoint.)\n+  \/\/ This interface answers whether a particular barrier type needs the card\n+  \/\/ mark to be thus strictly sequenced after the stores.\n+  virtual bool card_mark_must_follow_store() const;\n+\n@@ -74,0 +103,3 @@\n+  virtual void on_thread_detach(Thread* thread);\n+\n+  virtual void make_parsable(JavaThread* thread) { flush_deferred_card_mark_barrier(thread); }\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableBarrierSet.hpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -626,2 +626,0 @@\n-\n-  ResourceMark rm;\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -421,0 +421,4 @@\n+  product(bool, DeferInitialCardMark, false, DIAGNOSTIC,                    \\\n+          \"When +ReduceInitialCardMarks, explicitly defer any that \"        \\\n+          \"may arise from new_pre_store_barrier\")                           \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,0 +56,2 @@\n+  \/\/ Causes all refs in \"mr\" to be assumed to be modified by the given JavaThread.\n+  virtual void write_region(JavaThread* thread, MemRegion mr) = 0;\n","filename":"src\/hotspot\/share\/gc\/shared\/modRefBarrierSet.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,2 @@\n-                                 bool clear_space) {\n+                                 bool clear_space,\n+                                 bool mangle_space) {\n@@ -55,4 +56,1 @@\n-    clear(SpaceDecorator::DontMangle);\n-  }\n-  if (ZapUnusedHeapArea) {\n-    mangle_unused_area();\n+    clear(mangle_space);\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-  void initialize(MemRegion mr, bool clear_space);\n+  void initialize(MemRegion mr, bool clear_space, bool mangle_space);\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -91,0 +91,1 @@\n+  nonstatic_field(CardTableBarrierSet,         _defer_initial_card_mark,                      bool)                                  \\\n","filename":"src\/hotspot\/share\/gc\/shared\/vmStructs_gc.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,6 +35,0 @@\n-\/**\n- * ShenanoahAllocationRate maintains a truncated history of recently sampled allocation rates for the purpose of providing\n- * informed estimates of current and future allocation rates based on weighted averages and standard deviations of the\n- * truncated history.  More recently sampled allocations are weighted more heavily than older samples when computing\n- * averages and standard deviations.\n- *\/\n@@ -44,2 +38,0 @@\n-\n-  \/\/ Reset the _last_sample_value to zero, _last_sample_time to current time.\n@@ -48,7 +40,0 @@\n-  \/\/ Force an allocation rate sample to be taken, even if the time since last sample is not greater than\n-  \/\/ 1s\/ShenandoahAdaptiveSampleFrequencyHz, except when current_time - _last_sample_time < MinSampleTime (2 ms).\n-  \/\/ The sampled allocation rate is computed from (allocated - _last_sample_value) \/ (current_time - _last_sample_time).\n-  \/\/ Return the newly computed rate if the sample is taken, zero if it is not an appropriate time to add a sample.\n-  \/\/ In the case that a new sample is not taken, overwrite unaccounted_bytes_allocated with bytes allocated since\n-  \/\/ the previous sample was taken (allocated - _last_sample_value).  Otherwise, overwrite unaccounted_bytes_allocated\n-  \/\/ with 0.\n@@ -56,4 +41,0 @@\n-\n-  \/\/ Add an allocation rate sample if the time since last sample is greater than 1s\/ShenandoahAdaptiveSampleFrequencyHz.\n-  \/\/ The sampled allocation rate is computed from (allocated - _last_sample_value) \/ (current_time - _last_sample_time).\n-  \/\/ Return the newly computed rate if the sample is taken, zero if it is not an appropriate time to add a sample.\n@@ -62,3 +43,0 @@\n-  \/\/ Return an estimate of the upper bound on allocation rate, with the upper bound computed as the weighted average\n-  \/\/ of recently sampled instantaneous allocation rates added to sds times the standard deviation computed for the\n-  \/\/ sequence of recently sampled average allocation rates.\n@@ -66,3 +44,0 @@\n-\n-  \/\/ Test whether rate significantly diverges from the computed average allocation rate.  If so, return true.\n-  \/\/ Otherwise, return false.  Significant divergence is recognized if (rate - _rate.avg()) \/ _rate.sd() > threshold.\n@@ -73,2 +48,0 @@\n-  \/\/ Return the instantaneous rate calculated from (allocated - _last_sample_value) \/ (time - _last_sample_time).\n-  \/\/ Return Sentinel value 0.0 if (time - _last_sample_time) == 0 or if (allocated <= _last_sample_value).\n@@ -77,1 +50,0 @@\n-  \/\/ Time at which previous allocation rate sample was collected.\n@@ -79,2 +51,0 @@\n-\n-  \/\/ Bytes allocated as of the time at which previous allocation rate sample was collected.\n@@ -82,2 +52,0 @@\n-\n-  \/\/ The desired interval of time between consecutive samples of the allocation rate.\n@@ -85,2 +53,0 @@\n-\n-  \/\/ Holds a sequence of the most recently sampled instantaneous allocation rates\n@@ -88,3 +54,0 @@\n-\n-  \/\/ Holds a sequence of the most recently computed weighted average of allocation rates, with each weighted average\n-  \/\/ computed immediately after an instantaneous rate was sampled\n@@ -194,2 +157,0 @@\n-  \/\/ Sample the allocation rate at GC trigger time if possible.  Return the number of allocated bytes that were\n-  \/\/ not accounted for in the sample.  This must be called before resetting bytes allocated since gc start.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp","additions":0,"deletions":39,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n-      bool bm_live = _generation->complete_marking_context()->is_marked(cast_to_oop(region->bottom()));\n+      bool bm_live = heap->active_generation()->complete_marking_context()->is_marked(cast_to_oop(region->bottom()));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahGenerationalHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -76,2 +76,0 @@\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-\n@@ -79,1 +77,2 @@\n-  assert(!heap->mode()->is_generational(), \"Wrong heuristic for heap mode\");\n+\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n@@ -124,1 +123,1 @@\n-      bool bm_live = heap->global_generation()->complete_marking_context()->is_marked(cast_to_oop(region->bottom()));\n+      bool bm_live = heap->gc_generation()->complete_marking_context()->is_marked(cast_to_oop(region->bottom()));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -428,10 +428,0 @@\n-void ShenandoahAsserts::assert_mark_complete(HeapWord* obj, const char* file, int line) {\n-  const ShenandoahHeap* heap = ShenandoahHeap::heap();\n-  const ShenandoahHeapRegion* region = heap->heap_region_containing(obj);\n-  const ShenandoahGeneration* generation = heap->generation_for(region->affiliation());\n-  if (!generation->is_mark_complete()) {\n-    ShenandoahMessageBuffer msg(\"Marking should be complete for object \" PTR_FORMAT \" in the %s generation\", p2i(obj), generation->name());\n-    report_vm_error(file, line, msg.buffer());\n-  }\n-}\n-\n@@ -555,0 +545,17 @@\n+void ShenandoahAsserts::assert_generations_reconciled(const char* file, int line) {\n+  if (!ShenandoahSafepoint::is_at_shenandoah_safepoint()) {\n+    \/\/ Only shenandoah safepoint operations participate in the active\/gc generation scheme\n+    return;\n+  }\n+\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  ShenandoahGeneration* ggen = heap->gc_generation();\n+  ShenandoahGeneration* agen = heap->active_generation();\n+  if (agen == ggen) {\n+    return;\n+  }\n+\n+  ShenandoahMessageBuffer msg(\"Active(%s) & GC(%s) Generations aren't reconciled\", agen->name(), ggen->name());\n+  report_vm_error(file, line, msg.buffer());\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.cpp","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -68,3 +68,0 @@\n-\n-  \/\/ Assert that marking is complete for the generation where this obj resides\n-  static void assert_mark_complete(HeapWord* obj, const char* file, int line);\n@@ -82,0 +79,1 @@\n+  static void assert_generations_reconciled(const char* file, int line);\n@@ -138,3 +136,0 @@\n-#define shenandoah_assert_mark_complete(obj) \\\n-                    ShenandoahAsserts::assert_mark_complete(obj, __FILE__, __LINE__)\n-\n@@ -192,0 +187,4 @@\n+\/\/ Some limited sanity checking of the _gc_generation and _active_generation fields of ShenandoahHeap\n+#define shenandoah_assert_generations_reconciled()                                                             \\\n+                    ShenandoahAsserts::assert_generations_reconciled(__FILE__, __LINE__)\n+\n@@ -221,2 +220,0 @@\n-#define shenandoah_assert_mark_complete(obj)\n-\n@@ -247,0 +244,1 @@\n+#define shenandoah_assert_generations_reconciled()\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.hpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -92,13 +92,2 @@\n-  if (ReduceInitialCardMarks && ShenandoahCardBarrier && !ShenandoahHeap::heap()->is_in_young(new_obj)) {\n-    log_debug(gc)(\"Newly allocated object (\" PTR_FORMAT \") is not in the young generation\", p2i(new_obj));\n-    \/\/ This can happen when an object is newly allocated, but we come to a safepoint before returning\n-    \/\/ the object. If the safepoint runs a degenerated cycle that is upgraded to a full GC, this object\n-    \/\/ will have survived two GC cycles. If the tenuring age is very low (1), this object may be promoted.\n-    \/\/ In this case, we have an allocated object, but it has received no stores yet. If card marking barriers\n-    \/\/ have been elided, we could end up with an object in old holding pointers to young that won't be in\n-    \/\/ the remembered set. The solution here is conservative, but this problem should be rare, and it will\n-    \/\/ correct itself on subsequent cycles when the remembered set is updated.\n-    ShenandoahGenerationalHeap::heap()->old_generation()->card_scan()->mark_range_as_dirty(\n-      cast_from_oop<HeapWord*>(new_obj), new_obj->size()\n-    );\n-  }\n+  assert(!ReduceInitialCardMarks || !ShenandoahCardBarrier || ShenandoahGenerationalHeap::heap()->is_in_young(new_obj),\n+         \"Allocating new object outside of young generation: \" INTPTR_FORMAT, p2i(new_obj));\n@@ -106,0 +95,1 @@\n+  assert(thread->deferred_card_mark().is_empty(), \"We don't use this\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.cpp","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -94,1 +94,0 @@\n-  ShenandoahGC(generation),\n@@ -96,0 +95,1 @@\n+  _generation(generation),\n@@ -579,1 +579,1 @@\n-  ShenandoahGenerationalHeap::heap()->promote_regions_in_place(_generation, true);\n+  ShenandoahGenerationalHeap::heap()->promote_regions_in_place(true);\n@@ -709,1 +709,1 @@\n-    heap->verifier()->verify_before_concmark(_generation);\n+    heap->verifier()->verify_before_concmark();\n@@ -766,1 +766,1 @@\n-    heap->verifier()->verify_roots_no_forwarded(_generation);\n+    heap->verifier()->verify_roots_no_forwarded();\n@@ -794,1 +794,1 @@\n-        heap->verifier()->verify_before_evacuation(_generation);\n+        heap->verifier()->verify_before_evacuation();\n@@ -809,1 +809,1 @@\n-          heap->verifier()->verify_after_concmark_with_promotions(_generation);\n+          heap->verifier()->verify_after_concmark_with_promotions();\n@@ -811,1 +811,1 @@\n-          heap->verifier()->verify_after_concmark(_generation);\n+          heap->verifier()->verify_after_concmark();\n@@ -880,1 +880,0 @@\n-  ShenandoahGeneration* const _generation;\n@@ -886,1 +885,1 @@\n-  explicit ShenandoahEvacUpdateCleanupOopStorageRootsClosure(ShenandoahGeneration* generation);\n+  ShenandoahEvacUpdateCleanupOopStorageRootsClosure();\n@@ -891,1 +890,1 @@\n-ShenandoahEvacUpdateCleanupOopStorageRootsClosure::ShenandoahEvacUpdateCleanupOopStorageRootsClosure(ShenandoahGeneration* generation) :\n+ShenandoahEvacUpdateCleanupOopStorageRootsClosure::ShenandoahEvacUpdateCleanupOopStorageRootsClosure() :\n@@ -893,1 +892,0 @@\n-  _generation(generation),\n@@ -903,1 +901,2 @@\n-      if (_generation->contains(obj)) {\n+      shenandoah_assert_generations_reconciled();\n+      if (_heap->is_in_active_generation(obj)) {\n@@ -946,1 +945,0 @@\n-  ShenandoahGeneration*                      _generation;\n@@ -950,1 +948,1 @@\n-  ShenandoahConcurrentWeakRootsEvacUpdateTask(ShenandoahGeneration* generation, ShenandoahPhaseTimings::Phase phase) :\n+  ShenandoahConcurrentWeakRootsEvacUpdateTask(ShenandoahPhaseTimings::Phase phase) :\n@@ -955,1 +953,0 @@\n-    _generation(generation),\n@@ -963,1 +960,1 @@\n-  void work(uint worker_id) override {\n+  void work(uint worker_id) {\n@@ -970,1 +967,1 @@\n-      ShenandoahEvacUpdateCleanupOopStorageRootsClosure cl(_generation);\n+      ShenandoahEvacUpdateCleanupOopStorageRootsClosure cl;\n@@ -1005,1 +1002,1 @@\n-    ShenandoahConcurrentWeakRootsEvacUpdateTask task(_generation, ShenandoahPhaseTimings::conc_weak_roots_work);\n+    ShenandoahConcurrentWeakRootsEvacUpdateTask task(ShenandoahPhaseTimings::conc_weak_roots_work);\n@@ -1111,1 +1108,1 @@\n-  ShenandoahHeap::heap()->evacuate_collection_set(_generation, true \/*concurrent*\/);\n+  ShenandoahHeap::heap()->evacuate_collection_set(true \/*concurrent*\/);\n@@ -1115,0 +1112,1 @@\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n@@ -1116,1 +1114,0 @@\n-    ShenandoahHeap* const heap = ShenandoahHeap::heap();\n@@ -1118,1 +1115,1 @@\n-    heap->verifier()->verify_before_update_refs(_generation);\n+    heap->verifier()->verify_before_update_refs();\n@@ -1123,1 +1120,1 @@\n-  ShenandoahHeap::heap()->update_heap_references(_generation, true \/*concurrent*\/);\n+  ShenandoahHeap::heap()->update_heap_references(true \/*concurrent*\/);\n@@ -1169,1 +1166,1 @@\n-    heap->verifier()->verify_roots_in_to_space(_generation);\n+    heap->verifier()->verify_roots_in_to_space();\n@@ -1204,1 +1201,1 @@\n-    heap->verifier()->verify_after_update_refs(_generation);\n+    heap->verifier()->verify_after_update_refs();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":21,"deletions":24,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+  ShenandoahGeneration* const _generation;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+    ShenandoahHeap* heap = ShenandoahHeap::heap();\n@@ -62,0 +63,6 @@\n+    \/\/ Do not use active_generation() : we must use the gc_generation() set by\n+    \/\/ ShenandoahGCScope on the ControllerThread's stack; no safepoint may\n+    \/\/ intervene to update active_generation, so we can't\n+    \/\/ shenandoah_assert_generations_reconciled() here.\n+    ShenandoahReferenceProcessor* rp = heap->gc_generation()->ref_processor();\n+    assert(rp != nullptr, \"need reference processor\");\n@@ -63,1 +70,1 @@\n-    _cm->mark_loop(worker_id, _terminator, GENERATION, true \/*cancellable*\/,\n+    _cm->mark_loop(worker_id, _terminator, rp, GENERATION, true \/*cancellable*\/,\n@@ -102,0 +109,3 @@\n+    ShenandoahReferenceProcessor* rp = heap->gc_generation()->ref_processor();\n+    shenandoah_assert_generations_reconciled();\n+\n@@ -115,1 +125,1 @@\n-    _cm->mark_loop(worker_id, _terminator, GENERATION, false \/*not cancellable*\/,\n+    _cm->mark_loop(worker_id, _terminator, rp, GENERATION, false \/*not cancellable*\/,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-  ShenandoahGC(generation),\n+  ShenandoahGC(),\n@@ -51,0 +51,1 @@\n+  _generation(generation),\n@@ -262,1 +263,1 @@\n-        ShenandoahGenerationalHeap::heap()->promote_regions_in_place(_generation, false \/* concurrent*\/);\n+        ShenandoahGenerationalHeap::heap()->promote_regions_in_place(false \/* concurrent*\/);\n@@ -302,1 +303,1 @@\n-    heap->verifier()->verify_after_degenerated(_generation);\n+    heap->verifier()->verify_after_degenerated();\n@@ -339,1 +340,1 @@\n-    heap->verifier()->verify_roots_no_forwarded(_generation);\n+    heap->verifier()->verify_roots_no_forwarded();\n@@ -343,1 +344,1 @@\n-  heap->parallel_cleaning(_generation, false \/*full gc*\/);\n+  heap->parallel_cleaning(false \/*full gc*\/);\n@@ -360,1 +361,1 @@\n-      heap->verifier()->verify_before_evacuation(_generation);\n+      heap->verifier()->verify_before_evacuation();\n@@ -368,1 +369,1 @@\n-        heap->verifier()->verify_after_concmark_with_promotions(_generation);\n+        heap->verifier()->verify_after_concmark_with_promotions();\n@@ -370,1 +371,1 @@\n-        heap->verifier()->verify_after_concmark(_generation);\n+        heap->verifier()->verify_after_concmark();\n@@ -390,1 +391,1 @@\n-  ShenandoahHeap::heap()->evacuate_collection_set(_generation, false \/* concurrent*\/);\n+  ShenandoahHeap::heap()->evacuate_collection_set(false \/* concurrent*\/);\n@@ -404,1 +405,1 @@\n-  heap->update_heap_references(_generation, false \/*concurrent*\/);\n+  heap->update_heap_references(false \/*concurrent*\/);\n@@ -418,1 +419,1 @@\n-    heap->verifier()->verify_after_update_refs(_generation);\n+    heap->verifier()->verify_after_update_refs();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+  ShenandoahGeneration* _generation;\n@@ -41,1 +42,1 @@\n-  bool collect(GCCause::Cause cause) override;\n+  bool collect(GCCause::Cause cause);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -71,1 +71,0 @@\n-  ShenandoahGC(ShenandoahHeap::heap()->global_generation()),\n@@ -128,1 +127,1 @@\n-  _generation->heuristics()->record_success_full();\n+  heap->global_generation()->heuristics()->record_success_full();\n@@ -145,1 +144,1 @@\n-    heap->verifier()->verify_before_fullgc(_generation);\n+    heap->verifier()->verify_before_fullgc();\n@@ -198,1 +197,1 @@\n-    ShenandoahReferenceProcessor* rp = _generation->ref_processor();\n+    ShenandoahReferenceProcessor* rp = heap->global_generation()->ref_processor();\n@@ -277,1 +276,1 @@\n-    heap->verifier()->verify_after_fullgc(_generation);\n+    heap->verifier()->verify_after_fullgc();\n@@ -296,1 +295,1 @@\n-  _generation->reset_mark_bitmap<true, true>();\n+  heap->global_generation()->reset_mark_bitmap<true, true>();\n@@ -298,1 +297,1 @@\n-  assert(!_generation->is_mark_complete(), \"sanity\");\n+  assert(!heap->global_generation()->is_mark_complete(), \"sanity\");\n@@ -300,1 +299,1 @@\n-  heap->set_unload_classes(_generation->heuristics()->can_unload_classes());\n+  heap->set_unload_classes(heap->global_generation()->heuristics()->can_unload_classes());\n@@ -302,1 +301,1 @@\n-  ShenandoahReferenceProcessor* rp = _generation->ref_processor();\n+  ShenandoahReferenceProcessor* rp = heap->global_generation()->ref_processor();\n@@ -306,1 +305,1 @@\n-  ShenandoahSTWMark mark(_generation, true \/*full_gc*\/);\n+  ShenandoahSTWMark mark(heap->global_generation(), true \/*full_gc*\/);\n@@ -308,1 +307,1 @@\n-  heap->parallel_cleaning(_generation, true \/* full_gc *\/);\n+  heap->parallel_cleaning(true \/* full_gc *\/);\n@@ -354,2 +353,1 @@\n-  void do_object(oop p) override {\n-    shenandoah_assert_mark_complete(cast_from_oop<HeapWord*>(p));\n+  void do_object(oop p) {\n@@ -357,3 +355,2 @@\n-    assert(_heap->global_generation()->is_mark_complete(), \"marking must be finished\");\n-    assert(_heap->marking_context()->is_marked(p), \"must be marked\");\n-    assert(!_heap->marking_context()->allocated_after_mark_start(p), \"must be truly marked\");\n+    assert(_heap->gc_generation()->complete_marking_context()->is_marked(p), \"must be marked\");\n+    assert(!_heap->gc_generation()->complete_marking_context()->allocated_after_mark_start(p), \"must be truly marked\");\n@@ -529,0 +526,3 @@\n+private:\n+  ShenandoahHeap* const _heap;\n+\n@@ -530,1 +530,2 @@\n-  void heap_region_do(ShenandoahHeapRegion* r) override {\n+  ShenandoahEnsureHeapActiveClosure() : _heap(ShenandoahHeap::heap()) {}\n+  void heap_region_do(ShenandoahHeapRegion* r) {\n@@ -762,0 +763,1 @@\n+  ShenandoahHeap* const _heap;\n@@ -779,1 +781,2 @@\n-    _ctx(ShenandoahHeap::heap()->global_generation()->complete_marking_context()) {}\n+    _heap(ShenandoahHeap::heap()),\n+    _ctx(ShenandoahHeap::heap()->gc_generation()->complete_marking_context()) {}\n@@ -789,0 +792,1 @@\n+  ShenandoahHeap* const _heap;\n@@ -792,3 +796,5 @@\n-  void do_object(oop p) override {\n-    assert(ShenandoahHeap::heap()->global_generation()->is_mark_complete(), \"marking must be complete\");\n-    assert(ShenandoahHeap::heap()->marking_context()->is_marked(p), \"must be marked\");\n+  ShenandoahAdjustPointersObjectClosure() :\n+    _heap(ShenandoahHeap::heap()) {\n+  }\n+  void do_object(oop p) {\n+    assert(_heap->gc_generation()->complete_marking_context()->is_marked(p), \"must be marked\");\n@@ -810,1 +816,1 @@\n-  void work(uint worker_id) override {\n+  void work(uint worker_id) {\n@@ -836,1 +842,1 @@\n-  void work(uint worker_id) override {\n+  void work(uint worker_id) {\n@@ -870,1 +876,2 @@\n-  uint const _worker_id;\n+  ShenandoahHeap* const _heap;\n+  uint            const _worker_id;\n@@ -873,2 +880,2 @@\n-  explicit ShenandoahCompactObjectsClosure(uint worker_id) :\n-    _worker_id(worker_id) {}\n+  ShenandoahCompactObjectsClosure(uint worker_id) :\n+    _heap(ShenandoahHeap::heap()), _worker_id(worker_id) {}\n@@ -876,3 +883,2 @@\n-  void do_object(oop p) override {\n-    assert(ShenandoahHeap::heap()->global_generation()->is_mark_complete(), \"marking must be finished\");\n-    assert(ShenandoahHeap::heap()->marking_context()->is_marked(p), \"must be marked\");\n+  void do_object(oop p) {\n+    assert(_heap->gc_generation()->complete_marking_context()->is_marked(p), \"must be marked\");\n@@ -905,1 +911,1 @@\n-  void work(uint worker_id) override {\n+  void work(uint worker_id) {\n@@ -942,1 +948,1 @@\n-  void heap_region_do(ShenandoahHeapRegion* r) override {\n+  void heap_region_do(ShenandoahHeapRegion* r) {\n@@ -951,1 +957,1 @@\n-      _heap->marking_context()->reset_top_at_mark_start(r);\n+      _heap->gc_generation()->complete_marking_context()->reset_top_at_mark_start(r);\n@@ -1076,1 +1082,1 @@\n-\/\/ cannot be iterated over using oop->size()). The only way to safely iterate over those is using\n+\/\/ cannot be iterated over using oop->size(). The only way to safely iterate over those is using\n@@ -1088,1 +1094,1 @@\n-  void work(uint worker_id) override {\n+  void work(uint worker_id) {\n@@ -1092,2 +1098,1 @@\n-    ShenandoahMarkingContext* const ctx = heap->marking_context();\n-    assert(heap->global_generation()->is_mark_complete(), \"Marking must be complete\");\n+    ShenandoahMarkingContext* const ctx = heap->gc_generation()->complete_marking_context();\n@@ -1161,1 +1166,1 @@\n-    _generation->set_mark_incomplete();\n+    heap->global_generation()->set_mark_incomplete();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":42,"deletions":37,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-  bool collect(GCCause::Cause cause) override;\n+  bool collect(GCCause::Cause cause);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,2 +47,0 @@\n-class ShenandoahGeneration;\n-\n@@ -62,2 +60,0 @@\n-  explicit ShenandoahGC(ShenandoahGeneration* generation) : _generation(generation) {}\n-\n@@ -68,1 +64,0 @@\n-  ShenandoahGeneration* generation() const { return _generation; }\n@@ -71,2 +66,0 @@\n-\n-  ShenandoahGeneration* _generation;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGC.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -145,5 +145,0 @@\n-\n-  \/\/ Reset the bytes allocated within this generation since the start of GC.  The argument initial_bytes_allocated\n-  \/\/ is normally zero.  In the case that some memory was allocated following the last allocation rate sample that\n-  \/\/ precedes the start of GC, the number of bytes allocated is supplied as the initial value of bytes_allocated_since_gc_start.\n-  \/\/ We will behave as if these bytes were allocated after the start of GC.\n@@ -206,1 +201,1 @@\n-  bool is_mark_complete() const { return _is_marking_complete.is_set(); }\n+  bool is_mark_complete() { return _is_marking_complete.is_set(); }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-                                                                           ShenandoahGeneration* generation,\n@@ -58,1 +57,0 @@\n-  _generation(generation),\n@@ -174,1 +172,1 @@\n-  assert(!_generation->is_old(), \"Sanity check\");\n+  assert(!_heap->gc_generation()->is_old(), \"Sanity check\");\n@@ -180,0 +178,1 @@\n+    shenandoah_assert_generations_reconciled();\n@@ -263,1 +262,2 @@\n-  assert(_generation->is_mark_complete(), \"sanity\");\n+  assert(_heap->gc_generation()->is_mark_complete(), \"sanity\");\n+  shenandoah_assert_generations_reconciled();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalEvacuationTask.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-  ShenandoahGeneration* const _generation;\n@@ -46,1 +45,0 @@\n-                                       ShenandoahGeneration* generation,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalEvacuationTask.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,2 @@\n-  heap->set_active_generation(heap->global_generation());\n+  heap->set_gc_generation(heap->global_generation());\n+  heap->set_active_generation();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalFullGC.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -181,1 +181,1 @@\n-void ShenandoahGenerationalHeap::evacuate_collection_set(ShenandoahGeneration* generation, bool concurrent) {\n+void ShenandoahGenerationalHeap::evacuate_collection_set(bool concurrent) {\n@@ -183,1 +183,1 @@\n-  ShenandoahGenerationalEvacuationTask task(this, generation, &regions, concurrent, false \/* only promote regions *\/);\n+  ShenandoahGenerationalEvacuationTask task(this, &regions, concurrent, false \/* only promote regions *\/);\n@@ -187,1 +187,1 @@\n-void ShenandoahGenerationalHeap::promote_regions_in_place(ShenandoahGeneration* generation, bool concurrent) {\n+void ShenandoahGenerationalHeap::promote_regions_in_place(bool concurrent) {\n@@ -189,1 +189,1 @@\n-  ShenandoahGenerationalEvacuationTask task(this, generation, &regions, concurrent, true \/* only promote regions *\/);\n+  ShenandoahGenerationalEvacuationTask task(this, &regions, concurrent, true \/* only promote regions *\/);\n@@ -760,2 +760,0 @@\n-  \/\/ For update refs, _generation will be young or global. Mixed collections use the young generation.\n-  ShenandoahGeneration* _generation;\n@@ -767,3 +765,2 @@\n-  ShenandoahGenerationalUpdateHeapRefsTask(ShenandoahGeneration* generation,\n-                                           ShenandoahRegionIterator* regions,\n-                                           ShenandoahRegionChunkIterator* work_chunks) :\n+  explicit ShenandoahGenerationalUpdateHeapRefsTask(ShenandoahRegionIterator* regions,\n+                                                    ShenandoahRegionChunkIterator* work_chunks) :\n@@ -771,1 +768,0 @@\n-          _generation(generation),\n@@ -776,1 +772,1 @@\n-    const bool old_bitmap_stable = _heap->old_generation()->is_mark_complete();\n+    bool old_bitmap_stable = _heap->old_generation()->is_mark_complete();\n@@ -780,1 +776,1 @@\n-  void work(uint worker_id) override {\n+  void work(uint worker_id) {\n@@ -810,2 +806,4 @@\n-    \/\/ We update references for global, mixed, and young collections.\n-    assert(_generation->is_mark_complete(), \"Expected complete marking\");\n+    \/\/ We update references for global, old, and young collections.\n+    ShenandoahGeneration* const gc_generation = _heap->gc_generation();\n+    shenandoah_assert_generations_reconciled();\n+    assert(gc_generation->is_mark_complete(), \"Expected complete marking\");\n@@ -823,1 +821,1 @@\n-          if (_generation->is_global()) {\n+          if (gc_generation->is_global()) {\n@@ -852,1 +850,1 @@\n-    if (_generation->is_young()) {\n+    if (!gc_generation->is_global()) {\n@@ -966,1 +964,1 @@\n-void ShenandoahGenerationalHeap::update_heap_references(ShenandoahGeneration* generation, bool concurrent) {\n+void ShenandoahGenerationalHeap::update_heap_references(bool concurrent) {\n@@ -971,1 +969,1 @@\n-    ShenandoahGenerationalUpdateHeapRefsTask<true> task(generation, &_update_refs_iterator, &work_list);\n+    ShenandoahGenerationalUpdateHeapRefsTask<true> task(&_update_refs_iterator, &work_list);\n@@ -974,1 +972,1 @@\n-    ShenandoahGenerationalUpdateHeapRefsTask<false> task(generation, &_update_refs_iterator, &work_list);\n+    ShenandoahGenerationalUpdateHeapRefsTask<false> task(&_update_refs_iterator, &work_list);\n@@ -1049,1 +1047,1 @@\n-  ShenandoahUpdateRegionAges ages(marking_context());\n+  ShenandoahUpdateRegionAges ages(active_generation()->complete_marking_context());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":18,"deletions":20,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -91,5 +91,2 @@\n-\n-  \/\/ In the generational mode, we will use these two functions for young, mixed, and global collections.\n-  \/\/ For young and mixed, the generation argument will be the young generation, otherwise it will be the global generation.\n-  void evacuate_collection_set(ShenandoahGeneration* generation, bool concurrent) override;\n-  void promote_regions_in_place(ShenandoahGeneration* generation, bool concurrent);\n+  void evacuate_collection_set(bool concurrent) override;\n+  void promote_regions_in_place(bool concurrent);\n@@ -105,3 +102,1 @@\n-  \/\/ In the generational mode, we will use this function for young, mixed, and global collections.\n-  \/\/ For young and mixed, the generation argument will be the young generation, otherwise it will be the global generation.\n-  void update_heap_references(ShenandoahGeneration* generation, bool concurrent) override;\n+  void update_heap_references(bool concurrent) override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.hpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -532,0 +532,1 @@\n+  _gc_generation(nullptr),\n@@ -1259,2 +1260,1 @@\n-void ShenandoahHeap::evacuate_collection_set(ShenandoahGeneration* generation, bool concurrent) {\n-  assert(generation->is_global(), \"Only global generation expected here\");\n+void ShenandoahHeap::evacuate_collection_set(bool concurrent) {\n@@ -1579,2 +1579,2 @@\n-  \/\/ concurrent cycle in the prologue of the heap inspect\/dump operation (see VM_HeapDumper::doit_prologue).\n-  \/\/ This is how other concurrent collectors in the JVM handle this scenario as well.\n+  \/\/ concurrent cycle in the prologue of the heap inspect\/dump operation. This is how\n+  \/\/ other concurrent collectors in the JVM handle this scenario as well.\n@@ -1590,4 +1590,1 @@\n-  \/\/ This method is only called by `CollectedHeap::collect_as_vm_thread`, which we have\n-  \/\/ overridden to do nothing. See the comment there for an explanation of how heap inspections\n-  \/\/ work for Shenandoah.\n-  ShouldNotReachHere();\n+  \/\/assert(false, \"Shouldn't need to do full collections\");\n@@ -1662,0 +1659,5 @@\n+void ShenandoahHeap::set_gc_generation(ShenandoahGeneration* generation) {\n+  shenandoah_assert_control_or_vm_thread_at_safepoint();\n+  _gc_generation = generation;\n+}\n+\n@@ -1663,1 +1665,1 @@\n-void ShenandoahHeap::set_active_generation(ShenandoahGeneration* generation) {\n+void ShenandoahHeap::set_active_generation() {\n@@ -1666,1 +1668,2 @@\n-  _active_generation = generation;\n+  assert(_gc_generation != nullptr, \"Will set _active_generation to nullptr\");\n+  _active_generation = _gc_generation;\n@@ -1675,0 +1678,1 @@\n+  assert(_gc_generation == nullptr, \"Over-writing _gc_generation\");\n@@ -1677,0 +1681,1 @@\n+  set_gc_generation(generation);\n@@ -1683,0 +1688,1 @@\n+  assert(_gc_generation != nullptr, \"_gc_generation wasn't set\");\n@@ -1691,0 +1697,1 @@\n+  set_gc_generation(nullptr);\n@@ -1697,1 +1704,1 @@\n-      verifier()->verify_generic(active_generation(), vo);\n+      verifier()->verify_generic(vo);\n@@ -2057,1 +2064,1 @@\n-void ShenandoahHeap::stw_weak_refs(ShenandoahGeneration* generation, bool full_gc) {\n+void ShenandoahHeap::stw_weak_refs(bool full_gc) {\n@@ -2063,1 +2070,2 @@\n-  generation->ref_processor()->process_references(phase, workers(), false \/* concurrent *\/);\n+  shenandoah_assert_generations_reconciled();\n+  gc_generation()->ref_processor()->process_references(phase, workers(), false \/* concurrent *\/);\n@@ -2304,1 +2312,1 @@\n-void ShenandoahHeap::parallel_cleaning(ShenandoahGeneration* generation, bool full_gc) {\n+void ShenandoahHeap::parallel_cleaning(bool full_gc) {\n@@ -2310,1 +2318,1 @@\n-  stw_weak_refs(generation, full_gc);\n+  stw_weak_refs(full_gc);\n@@ -2418,2 +2426,5 @@\n-    assert((r->is_pinned() && r->pin_count() > 0) || (!r->is_pinned() && r->pin_count() == 0),\n-           \"Region %zu pinning status is inconsistent\", i);\n+    shenandoah_assert_generations_reconciled();\n+    if (gc_generation()->contains(r)) {\n+      assert((r->is_pinned() && r->pin_count() > 0) || (!r->is_pinned() && r->pin_count() == 0),\n+             \"Region %zu pinning status is inconsistent\", i);\n+    }\n@@ -2522,2 +2533,1 @@\n-void ShenandoahHeap::update_heap_references(ShenandoahGeneration* generation, bool concurrent) {\n-  assert(generation->is_global(), \"Should only get global generation here\");\n+void ShenandoahHeap::update_heap_references(bool concurrent) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":29,"deletions":19,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -148,0 +148,5 @@\n+  \/\/ Indicates the generation whose collection is in\n+  \/\/ progress. Mutator threads aren't allowed to read\n+  \/\/ this field.\n+  ShenandoahGeneration* _gc_generation;\n+\n@@ -149,2 +154,2 @@\n-  \/\/ at each STW pause (safepoint) to the value given to the VM operation.\n-  \/\/ This allows the value to be always consistently\n+  \/\/ at each STW pause (safepoint) to the value seen in\n+  \/\/ _gc_generation. This allows the value to be always consistently\n@@ -152,0 +157,2 @@\n+  \/\/ In that sense, it's a stable snapshot of _gc_generation that is\n+  \/\/ updated at each STW pause associated with a ShenandoahVMOp.\n@@ -163,0 +170,7 @@\n+  ShenandoahGeneration* gc_generation() const {\n+    \/\/ We don't want this field read by a mutator thread\n+    assert(!Thread::current()->is_Java_thread(), \"Not allowed\");\n+    \/\/ value of _gc_generation field, see above\n+    return _gc_generation;\n+  }\n+\n@@ -168,2 +182,7 @@\n-  \/\/ Update the _active_generation field: can only be called at a safepoint by the VMThread.\n-  void set_active_generation(ShenandoahGeneration* generation);\n+  \/\/ Set the _gc_generation field\n+  void set_gc_generation(ShenandoahGeneration* generation);\n+\n+  \/\/ Copy the value in the _gc_generation field into\n+  \/\/ the _active_generation field: can only be called at\n+  \/\/ a safepoint by the VMThread.\n+  void set_active_generation();\n@@ -466,1 +485,1 @@\n-  virtual void evacuate_collection_set(ShenandoahGeneration* generation, bool concurrent);\n+  virtual void evacuate_collection_set(bool concurrent);\n@@ -481,1 +500,1 @@\n-  virtual void update_heap_references(ShenandoahGeneration* generation, bool concurrent);\n+  virtual void update_heap_references(bool concurrent);\n@@ -589,1 +608,1 @@\n-  void parallel_cleaning(ShenandoahGeneration* generation, bool full_gc);\n+  void parallel_cleaning(bool full_gc);\n@@ -594,1 +613,1 @@\n-  void stw_weak_refs(ShenandoahGeneration* generation, bool full_gc);\n+  void stw_weak_refs(bool full_gc);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":27,"deletions":8,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -318,3 +318,3 @@\n-  const ShenandoahHeap* heap = ShenandoahHeap::heap();\n-  assert(heap->generation_for(affiliation())->is_mark_complete(), \"Marking should be complete here.\");\n-  heap->marking_context()->reset_top_bitmap(this);\n+  assert(ShenandoahHeap::heap()->gc_generation()->is_mark_complete(), \"Marking should be complete here.\");\n+  shenandoah_assert_generations_reconciled();\n+  ShenandoahHeap::heap()->marking_context()->reset_top_bitmap(this);\n@@ -464,3 +464,3 @@\n-  \/\/ Expect marking to be completed for the old generation before we fill in unmarked objects\n-  assert(heap->old_generation()->is_mark_complete(), \"sanity\");\n-  assert(is_old(), \"Only need to coalesce and fill old regions\");\n+  \/\/ Expect marking to be completed before these threads invoke this service.\n+  assert(heap->gc_generation()->is_mark_complete(), \"sanity\");\n+  shenandoah_assert_generations_reconciled();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-void ShenandoahMark::mark_loop_prework(uint w, TaskTerminator *t, StringDedup::Requests* const req, bool update_refs) {\n+void ShenandoahMark::mark_loop_prework(uint w, TaskTerminator *t, ShenandoahReferenceProcessor *rp, StringDedup::Requests* const req, bool update_refs) {\n@@ -61,1 +61,1 @@\n-  ShenandoahReferenceProcessor *rp = _generation->ref_processor();\n+\n@@ -81,2 +81,2 @@\n-void ShenandoahMark::mark_loop(uint worker_id, TaskTerminator* terminator,\n-                               ShenandoahGenerationType generation_type, StringDedup::Requests* const req) {\n+void ShenandoahMark::mark_loop(uint worker_id, TaskTerminator* terminator, ShenandoahReferenceProcessor *rp,\n+                               ShenandoahGenerationType generation, StringDedup::Requests* const req) {\n@@ -84,1 +84,1 @@\n-  switch (generation_type) {\n+  switch (generation) {\n@@ -86,1 +86,1 @@\n-      mark_loop_prework<YOUNG, CANCELLABLE, STRING_DEDUP>(worker_id, terminator, req, update_refs);\n+      mark_loop_prework<YOUNG, CANCELLABLE, STRING_DEDUP>(worker_id, terminator, rp, req, update_refs);\n@@ -90,1 +90,1 @@\n-      mark_loop_prework<OLD, CANCELLABLE, STRING_DEDUP>(worker_id, terminator, req, false);\n+      mark_loop_prework<OLD, CANCELLABLE, STRING_DEDUP>(worker_id, terminator, rp, req, false);\n@@ -93,1 +93,1 @@\n-      mark_loop_prework<GLOBAL, CANCELLABLE, STRING_DEDUP>(worker_id, terminator, req, update_refs);\n+      mark_loop_prework<GLOBAL, CANCELLABLE, STRING_DEDUP>(worker_id, terminator, rp, req, update_refs);\n@@ -96,1 +96,1 @@\n-      mark_loop_prework<NON_GEN, CANCELLABLE, STRING_DEDUP>(worker_id, terminator, req, update_refs);\n+      mark_loop_prework<NON_GEN, CANCELLABLE, STRING_DEDUP>(worker_id, terminator, rp, req, update_refs);\n@@ -104,2 +104,2 @@\n-void ShenandoahMark::mark_loop(uint worker_id, TaskTerminator* terminator, ShenandoahGenerationType generation_type,\n-                               bool cancellable, StringDedupMode dedup_mode, StringDedup::Requests* const req) {\n+void ShenandoahMark::mark_loop(uint worker_id, TaskTerminator* terminator, ShenandoahReferenceProcessor *rp,\n+                               ShenandoahGenerationType generation, bool cancellable, StringDedupMode dedup_mode, StringDedup::Requests* const req) {\n@@ -109,1 +109,1 @@\n-        mark_loop<true, NO_DEDUP>(worker_id, terminator, generation_type, req);\n+        mark_loop<true, NO_DEDUP>(worker_id, terminator, rp, generation, req);\n@@ -112,1 +112,1 @@\n-        mark_loop<true, ENQUEUE_DEDUP>(worker_id, terminator, generation_type, req);\n+        mark_loop<true, ENQUEUE_DEDUP>(worker_id, terminator, rp, generation, req);\n@@ -115,1 +115,1 @@\n-        mark_loop<true, ALWAYS_DEDUP>(worker_id, terminator, generation_type, req);\n+        mark_loop<true, ALWAYS_DEDUP>(worker_id, terminator, rp, generation, req);\n@@ -121,1 +121,1 @@\n-        mark_loop<false, NO_DEDUP>(worker_id, terminator, generation_type, req);\n+        mark_loop<false, NO_DEDUP>(worker_id, terminator, rp, generation, req);\n@@ -124,1 +124,1 @@\n-        mark_loop<false, ENQUEUE_DEDUP>(worker_id, terminator, generation_type, req);\n+        mark_loop<false, ENQUEUE_DEDUP>(worker_id, terminator, rp, generation, req);\n@@ -127,1 +127,1 @@\n-        mark_loop<false, ALWAYS_DEDUP>(worker_id, terminator, generation_type, req);\n+        mark_loop<false, ALWAYS_DEDUP>(worker_id, terminator, rp, generation, req);\n@@ -142,2 +142,6 @@\n-  assert(_generation->type() == GENERATION, \"Sanity: %d != %d\", _generation->type(), GENERATION);\n-  _generation->ref_processor()->set_mark_closure(worker_id, cl);\n+  \/\/ Do not use active_generation() : we must use the gc_generation() set by\n+  \/\/ ShenandoahGCScope on the ControllerThread's stack; no safepoint may\n+  \/\/ intervene to update active_generation, so we can't\n+  \/\/ shenandoah_assert_generations_reconciled() here.\n+  assert(heap->gc_generation()->type() == GENERATION, \"Sanity: %d != %d\", heap->gc_generation()->type(), GENERATION);\n+  heap->gc_generation()->ref_processor()->set_mark_closure(worker_id, cl);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.cpp","additions":23,"deletions":19,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+class ShenandoahReferenceProcessor;\n@@ -74,1 +75,1 @@\n-  ShenandoahGeneration* generation() const { return _generation; };\n+  inline ShenandoahGeneration* generation() { return _generation; };\n@@ -95,1 +96,1 @@\n-  void mark_loop_prework(uint worker_id, TaskTerminator *terminator, StringDedup::Requests* const req, bool update_refs);\n+  void mark_loop_prework(uint worker_id, TaskTerminator *terminator, ShenandoahReferenceProcessor *rp, StringDedup::Requests* const req, bool update_refs);\n@@ -111,2 +112,2 @@\n-  void mark_loop(uint worker_id, TaskTerminator* terminator, ShenandoahGenerationType generation_type,\n-                StringDedup::Requests* const req);\n+  void mark_loop(uint worker_id, TaskTerminator* terminator, ShenandoahReferenceProcessor *rp,\n+                 ShenandoahGenerationType generation, StringDedup::Requests* const req);\n@@ -114,2 +115,2 @@\n-  void mark_loop(uint worker_id, TaskTerminator* terminator, ShenandoahGenerationType generation_type,\n-                 bool cancellable, StringDedupMode dedup_mode, StringDedup::Requests* const req);\n+  void mark_loop(uint worker_id, TaskTerminator* terminator, ShenandoahReferenceProcessor *rp,\n+                 ShenandoahGenerationType generation, bool cancellable, StringDedupMode dedup_mode, StringDedup::Requests* const req);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.hpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -77,2 +77,2 @@\n-  log_debug(gc, mark)(\"SMC:initialize_top_at_mark_start for Region %zu, TAMS: \" PTR_FORMAT \", TopOfBitMap: \" PTR_FORMAT,\n-                      r->index(), p2i(bottom), p2i(r->end()));\n+  log_debug(gc)(\"SMC:initialize_top_at_mark_start for Region %zu, TAMS: \" PTR_FORMAT \", TopOfBitMap: \" PTR_FORMAT,\n+                r->index(), p2i(bottom), p2i(r->end()));\n@@ -89,2 +89,2 @@\n-  log_debug(gc, mark)(\"SMC:clear_bitmap for %s Region %zu, top_bitmap: \" PTR_FORMAT,\n-                      r->affiliation_name(), r->index(), p2i(top_bitmap));\n+  log_debug(gc)(\"SMC:clear_bitmap for %s Region %zu, top_bitmap: \" PTR_FORMAT,\n+                r->affiliation_name(), r->index(), p2i(top_bitmap));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -107,2 +107,2 @@\n-  log_debug(gc, mark)(\"Capturing TAMS for %s Region %zu, was: \" PTR_FORMAT \", now: \" PTR_FORMAT,\n-                      r->affiliation_name(), idx, p2i(old_tams), p2i(new_tams));\n+  log_debug(gc)(\"Capturing TAMS for %s Region %zu, was: \" PTR_FORMAT \", now: \" PTR_FORMAT,\n+                r->affiliation_name(), idx, p2i(old_tams), p2i(new_tams));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-    heap->verifier()->verify_roots_no_forwarded(_old_generation);\n+    heap->verifier()->verify_roots_no_forwarded();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGC.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -332,1 +332,0 @@\n-  shenandoah_assert_mark_complete(raw_referent);\n@@ -334,1 +333,2 @@\n-  \/\/ Check if the referent is still alive, in which case we should drop the reference.\n+  \/\/ Check if the referent is still alive, in which case we should\n+  \/\/ drop the reference.\n@@ -336,1 +336,1 @@\n-    return heap->marking_context()->is_marked(raw_referent);\n+    return heap->active_generation()->complete_marking_context()->is_marked(raw_referent);\n@@ -338,1 +338,1 @@\n-    return heap->marking_context()->is_marked_strong(raw_referent);\n+    return heap->active_generation()->complete_marking_context()->is_marked_strong(raw_referent);\n@@ -345,8 +345,0 @@\n-#ifdef ASSERT\n-    auto referent = reference_referent_raw<T>(reference);\n-    auto heap = ShenandoahHeap::heap();\n-    shenandoah_assert_mark_complete(referent);\n-    assert(reference_next<T>(reference) == nullptr, \"Already inactive\");\n-    assert(heap->marking_context()->is_marked(referent), \"only make inactive final refs with alive referents\");\n-#endif\n-\n@@ -357,0 +349,2 @@\n+    assert(reference_next<T>(reference) == nullptr, \"Already inactive\");\n+    assert(ShenandoahHeap::heap()->active_generation()->complete_marking_context()->is_marked(reference_referent_raw<T>(reference)), \"only make inactive final refs with alive referents\");\n@@ -446,6 +440,2 @@\n-  if (raw_referent != nullptr) {\n-    ShenandoahHeap* heap = ShenandoahHeap::heap();\n-    ShenandoahHeapRegion* region  = heap->heap_region_containing(raw_referent);\n-    ShenandoahMarkingContext* ctx = heap->generation_for(region->affiliation())->complete_marking_context();\n-    assert(ctx->is_marked(raw_referent), \"only drop references with alive referents\");\n-  }\n+  assert(raw_referent == nullptr || ShenandoahHeap::heap()->active_generation()->complete_marking_context()->is_marked(raw_referent),\n+         \"only drop references with alive referents\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.cpp","additions":8,"deletions":18,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-    SuspendibleThreadSetJoiner joiner;\n@@ -99,1 +98,0 @@\n-    SuspendibleThreadSetJoiner joiner;\n@@ -127,1 +125,0 @@\n-  SuspendibleThreadSetLeaver leaver;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRegulatorThread.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -61,3 +61,3 @@\n-  _phase(phase),\n-  _is_par(is_par),\n-  _threads_claim_token_scope() {}\n+  _phase(phase), _is_par(is_par) {\n+  Threads::change_thread_claim_token();\n+}\n@@ -77,0 +77,4 @@\n+ShenandoahThreadRoots::~ShenandoahThreadRoots() {\n+  Threads::assert_all_threads_claimed();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-#include \"runtime\/threads.hpp\"\n@@ -91,2 +90,1 @@\n-  const bool                    _is_par;\n-  ThreadsClaimTokenScope        _threads_claim_token_scope;\n+  const bool _is_par;\n@@ -95,0 +93,1 @@\n+  ~ShenandoahThreadRoots();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-void ShenandoahRootVerifier::roots_do(OopIterateClosure* oops, ShenandoahGeneration* generation) {\n+void ShenandoahRootVerifier::roots_do(OopIterateClosure* oops) {\n@@ -78,1 +78,2 @@\n-  if (generation->is_young()) {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  if (heap->mode()->is_generational() && heap->active_generation()->is_young()) {\n@@ -80,1 +81,0 @@\n-    shenandoah_assert_generational();\n@@ -90,1 +90,1 @@\n-void ShenandoahRootVerifier::strong_roots_do(OopIterateClosure* oops, ShenandoahGeneration* generation) {\n+void ShenandoahRootVerifier::strong_roots_do(OopIterateClosure* oops) {\n@@ -101,2 +101,2 @@\n-  if (generation->is_young()) {\n-    shenandoah_assert_generational();\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  if (heap->mode()->is_generational() && heap->active_generation()->is_young()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootVerifier.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -46,4 +46,2 @@\n-  \/\/ The generation parameter here may be young or global. If it is young,\n-  \/\/ then the roots will include the remembered set.\n-  static void roots_do(OopIterateClosure* cl, ShenandoahGeneration* generation);\n-  static void strong_roots_do(OopIterateClosure* cl, ShenandoahGeneration* generation);\n+  static void roots_do(OopIterateClosure* cl);\n+  static void strong_roots_do(OopIterateClosure* cl);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootVerifier.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+  assert(ShenandoahHeap::heap()->gc_generation() == _generation, \"Marking unexpected generation\");\n@@ -81,0 +82,1 @@\n+  shenandoah_assert_generations_reconciled();\n@@ -86,1 +88,1 @@\n-    heap->verifier()->verify_roots_no_forwarded(_generation);\n+    heap->verifier()->verify_roots_no_forwarded();\n@@ -120,0 +122,1 @@\n+  assert(ShenandoahHeap::heap()->gc_generation() == _generation, \"Marking unexpected generation\");\n@@ -148,0 +151,1 @@\n+  assert(ShenandoahHeap::heap()->gc_generation() == _generation, \"Marking unexpected generation\");\n@@ -150,0 +154,2 @@\n+  ShenandoahReferenceProcessor* rp = _generation->ref_processor();\n+  shenandoah_assert_generations_reconciled();\n@@ -152,1 +158,2 @@\n-  mark_loop(worker_id, &_terminator, _generation->type(), false \/* not cancellable *\/,\n+  mark_loop(worker_id, &_terminator, rp,\n+            _generation->type(), false \/* not cancellable *\/,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSTWMark.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -686,3 +686,3 @@\n-    log_debug(gc, remset)(\"ShenandoahScanRememberedTask::do_work(%u), processing slice of region \"\n-                          \"%zu at offset %zu, size: %zu\",\n-                          worker_id, region->index(), assignment._chunk_offset, assignment._chunk_size);\n+    log_debug(gc)(\"ShenandoahScanRememberedTask::do_work(%u), processing slice of region \"\n+                  \"%zu at offset %zu, size: %zu\",\n+                  worker_id, region->index(), assignment._chunk_offset, assignment._chunk_size);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -346,3 +346,3 @@\n-  log_debug(gc, remset)(\"Remembered set scan processing Region %zu, from \" PTR_FORMAT \" to \" PTR_FORMAT \", using %s table\",\n-                        region->index(), p2i(start_of_range), p2i(end_of_range),\n-                        use_write_table? \"read\/write (updating)\": \"read (marking)\");\n+  log_debug(gc)(\"Remembered set scan processing Region %zu, from \" PTR_FORMAT \" to \" PTR_FORMAT \", using %s table\",\n+                region->index(), p2i(start_of_range), p2i(end_of_range),\n+                use_write_table? \"read\/write (updating)\": \"read (marking)\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -53,2 +53,4 @@\n-  log_debug(gc, heap)(\"%s: active_generation is %s\", prefix,\n-                      agen == nullptr ? \"nullptr\" : shenandoah_generation_name(agen->type()));\n+  ShenandoahGeneration* ggen = ShenandoahHeap::heap()->gc_generation();\n+  log_debug(gc, heap)(\"%s: active_generation is %s, gc_generation is %s\", prefix,\n+                      agen == nullptr ? \"nullptr\" : shenandoah_generation_name(agen->type()),\n+                      ggen == nullptr ? \"nullptr\" : shenandoah_generation_name(ggen->type()));\n@@ -60,1 +62,1 @@\n-    ShenandoahHeap::heap()->set_active_generation(_generation);\n+    ShenandoahHeap::heap()->set_active_generation();\n@@ -78,4 +80,0 @@\n-VM_ShenandoahInitMark::VM_ShenandoahInitMark(ShenandoahConcurrentGC* gc)\n-  : VM_ShenandoahOperation(gc->generation()), _gc(gc) {\n-}\n-\n@@ -88,4 +86,0 @@\n-VM_ShenandoahFinalMarkStartEvac::VM_ShenandoahFinalMarkStartEvac(ShenandoahConcurrentGC* gc)\n-  : VM_ShenandoahOperation(gc->generation()), _gc(gc) {\n-}\n-\n@@ -98,4 +92,0 @@\n-VM_ShenandoahFullGC::VM_ShenandoahFullGC(GCCause::Cause gc_cause, ShenandoahFullGC* full_gc)\n-  : VM_ShenandoahReferenceOperation(full_gc->generation()), _gc_cause(gc_cause), _full_gc(full_gc) {\n-}\n-\n@@ -108,4 +98,0 @@\n-VM_ShenandoahDegeneratedGC::VM_ShenandoahDegeneratedGC(ShenandoahDegenGC* gc)\n-  : VM_ShenandoahReferenceOperation(gc->generation()), _gc(gc) {\n-}\n-\n@@ -118,4 +104,0 @@\n-VM_ShenandoahInitUpdateRefs::VM_ShenandoahInitUpdateRefs(ShenandoahConcurrentGC* gc)\n-  : VM_ShenandoahOperation(gc->generation()), _gc(gc) {\n-}\n-\n@@ -128,4 +110,0 @@\n-VM_ShenandoahFinalUpdateRefs::VM_ShenandoahFinalUpdateRefs(ShenandoahConcurrentGC* gc)\n-  : VM_ShenandoahOperation(gc->generation()), _gc(gc) {\n-}\n-\n@@ -138,4 +116,0 @@\n-VM_ShenandoahFinalRoots::VM_ShenandoahFinalRoots(ShenandoahConcurrentGC* gc)\n-  : VM_ShenandoahOperation(gc->generation()), _gc(gc) {\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVMOperations.cpp","additions":5,"deletions":31,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-  ShenandoahGeneration* _generation;\n@@ -53,5 +52,1 @@\n-  explicit VM_ShenandoahOperation(ShenandoahGeneration* generation)\n-  : _gc_id(GCId::current())\n-  , _generation(generation) {\n-  }\n-\n+  VM_ShenandoahOperation() : _gc_id(GCId::current()) {};\n@@ -69,2 +64,1 @@\n-  explicit VM_ShenandoahReferenceOperation(ShenandoahGeneration* generation)\n-    : VM_ShenandoahOperation(generation) {};\n+  VM_ShenandoahReferenceOperation() : VM_ShenandoahOperation() {};\n@@ -76,0 +70,1 @@\n+private:\n@@ -78,4 +73,6 @@\n-  explicit VM_ShenandoahInitMark(ShenandoahConcurrentGC* gc);\n-  VM_Operation::VMOp_Type type() const override { return VMOp_ShenandoahInitMark; }\n-  const char* name()             const override { return \"Shenandoah Init Marking\"; }\n-  void doit() override;\n+  VM_ShenandoahInitMark(ShenandoahConcurrentGC* gc) :\n+    VM_ShenandoahOperation(),\n+    _gc(gc) {};\n+  VM_Operation::VMOp_Type type() const { return VMOp_ShenandoahInitMark; }\n+  const char* name()             const { return \"Shenandoah Init Marking\"; }\n+  virtual void doit();\n@@ -85,0 +82,1 @@\n+private:\n@@ -87,4 +85,6 @@\n-  explicit VM_ShenandoahFinalMarkStartEvac(ShenandoahConcurrentGC* gc);\n-  VM_Operation::VMOp_Type type() const override { return VMOp_ShenandoahFinalMarkStartEvac; }\n-  const char* name()             const override { return \"Shenandoah Final Mark and Start Evacuation\"; }\n-  void doit() override;\n+  VM_ShenandoahFinalMarkStartEvac(ShenandoahConcurrentGC* gc) :\n+    VM_ShenandoahOperation(),\n+    _gc(gc) {};\n+  VM_Operation::VMOp_Type type() const { return VMOp_ShenandoahFinalMarkStartEvac; }\n+  const char* name()             const { return \"Shenandoah Final Mark and Start Evacuation\"; }\n+  virtual  void doit();\n@@ -94,0 +94,1 @@\n+private:\n@@ -96,4 +97,7 @@\n-  explicit VM_ShenandoahDegeneratedGC(ShenandoahDegenGC* gc);\n-  VM_Operation::VMOp_Type type() const override { return VMOp_ShenandoahDegeneratedGC; }\n-  const char* name()             const override { return \"Shenandoah Degenerated GC\"; }\n-  void doit() override;\n+  VM_ShenandoahDegeneratedGC(ShenandoahDegenGC* gc) :\n+    VM_ShenandoahReferenceOperation(),\n+    _gc(gc) {};\n+\n+  VM_Operation::VMOp_Type type() const { return VMOp_ShenandoahDegeneratedGC; }\n+  const char* name()             const { return \"Shenandoah Degenerated GC\"; }\n+  virtual  void doit();\n@@ -103,0 +107,1 @@\n+private:\n@@ -106,4 +111,7 @@\n-  explicit VM_ShenandoahFullGC(GCCause::Cause gc_cause, ShenandoahFullGC* full_gc);\n-  VM_Operation::VMOp_Type type() const override { return VMOp_ShenandoahFullGC; }\n-  const char* name()             const override { return \"Shenandoah Full GC\"; }\n-  void doit() override;\n+  VM_ShenandoahFullGC(GCCause::Cause gc_cause, ShenandoahFullGC* full_gc) :\n+    VM_ShenandoahReferenceOperation(),\n+    _gc_cause(gc_cause),\n+    _full_gc(full_gc) {};\n+  VM_Operation::VMOp_Type type() const { return VMOp_ShenandoahFullGC; }\n+  const char* name()             const { return \"Shenandoah Full GC\"; }\n+  virtual void doit();\n@@ -115,4 +123,6 @@\n-  explicit VM_ShenandoahInitUpdateRefs(ShenandoahConcurrentGC* gc);\n-  VM_Operation::VMOp_Type type() const override { return VMOp_ShenandoahInitUpdateRefs; }\n-  const char* name()             const override { return \"Shenandoah Init Update References\"; }\n-  void doit() override;\n+  VM_ShenandoahInitUpdateRefs(ShenandoahConcurrentGC* gc) :\n+    VM_ShenandoahOperation(),\n+    _gc(gc) {};\n+  VM_Operation::VMOp_Type type() const { return VMOp_ShenandoahInitUpdateRefs; }\n+  const char* name()             const { return \"Shenandoah Init Update References\"; }\n+  virtual void doit();\n@@ -124,4 +134,6 @@\n-  explicit VM_ShenandoahFinalUpdateRefs(ShenandoahConcurrentGC* gc);\n-  VM_Operation::VMOp_Type type() const override { return VMOp_ShenandoahFinalUpdateRefs; }\n-  const char* name()             const override { return \"Shenandoah Final Update References\"; }\n-  void doit() override;\n+  VM_ShenandoahFinalUpdateRefs(ShenandoahConcurrentGC* gc) :\n+    VM_ShenandoahOperation(),\n+    _gc(gc) {};\n+  VM_Operation::VMOp_Type type() const { return VMOp_ShenandoahFinalUpdateRefs; }\n+  const char* name()             const { return \"Shenandoah Final Update References\"; }\n+  virtual void doit();\n@@ -133,4 +145,6 @@\n-  explicit VM_ShenandoahFinalRoots(ShenandoahConcurrentGC* gc);\n-  VM_Operation::VMOp_Type type() const override { return VMOp_ShenandoahFinalRoots; }\n-  const char* name()             const override { return \"Shenandoah Final Roots\"; }\n-  void doit() override;\n+  VM_ShenandoahFinalRoots(ShenandoahConcurrentGC* gc) :\n+    VM_ShenandoahOperation(),\n+    _gc(gc) {};\n+  VM_Operation::VMOp_Type type() const { return VMOp_ShenandoahFinalRoots; }\n+  const char* name()             const { return \"Shenandoah Final Roots\"; }\n+  virtual void doit();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVMOperations.hpp","additions":50,"deletions":36,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -73,2 +73,1 @@\n-  ShenandoahVerifyOopClosure(ShenandoahGeneration* generation, ShenandoahVerifierStack* stack,\n-                             MarkBitMap* map, ShenandoahLivenessData* ld,\n+  ShenandoahVerifyOopClosure(ShenandoahVerifierStack* stack, MarkBitMap* map, ShenandoahLivenessData* ld,\n@@ -84,1 +83,1 @@\n-    _generation(generation) {\n+    _generation(nullptr) {\n@@ -96,0 +95,6 @@\n+\n+    if (_heap->mode()->is_generational()) {\n+      _generation = _heap->gc_generation();\n+      assert(_generation != nullptr, \"Expected active generation in this mode\");\n+      shenandoah_assert_generations_reconciled();\n+    }\n@@ -129,1 +134,5 @@\n-  bool in_generation(oop obj) const {\n+  bool in_generation(oop obj) {\n+    if (_generation == nullptr) {\n+      return true;\n+    }\n+\n@@ -191,1 +200,1 @@\n-                (obj_reg->is_old() && _generation->is_young()),\n+                (obj_reg->is_old() && _heap->gc_generation()->is_young()),\n@@ -193,0 +202,1 @@\n+          shenandoah_assert_generations_reconciled();\n@@ -269,1 +279,1 @@\n-        check(ShenandoahAsserts::_safe_all, obj, _generation->complete_marking_context()->is_marked(obj),\n+        check(ShenandoahAsserts::_safe_all, obj, _heap->gc_generation()->complete_marking_context()->is_marked(obj),\n@@ -274,1 +284,1 @@\n-        check(ShenandoahAsserts::_safe_all, obj, _generation->complete_marking_context()->is_marked(obj),\n+        check(ShenandoahAsserts::_safe_all, obj, _heap->gc_generation()->complete_marking_context()->is_marked(obj),\n@@ -564,1 +574,0 @@\n-  ShenandoahGeneration* _generation;\n@@ -567,2 +576,1 @@\n-  ShenandoahVerifierReachableTask(ShenandoahGeneration* generation,\n-                                  MarkBitMap* bitmap,\n+  ShenandoahVerifierReachableTask(MarkBitMap* bitmap,\n@@ -578,2 +586,1 @@\n-    _processed(0),\n-    _generation(generation) {};\n+    _processed(0) {};\n@@ -595,1 +602,1 @@\n-        ShenandoahVerifyOopClosure cl(_generation, &stack, _bitmap, _ld,\n+        ShenandoahVerifyOopClosure cl(&stack, _bitmap, _ld,\n@@ -599,1 +606,1 @@\n-          ShenandoahRootVerifier::strong_roots_do(&cl, _generation);\n+          ShenandoahRootVerifier::strong_roots_do(&cl);\n@@ -601,1 +608,1 @@\n-          ShenandoahRootVerifier::roots_do(&cl, _generation);\n+          ShenandoahRootVerifier::roots_do(&cl);\n@@ -608,1 +615,1 @@\n-      ShenandoahVerifyOopClosure cl(_generation, &stack, _bitmap, _ld,\n+      ShenandoahVerifyOopClosure cl(&stack, _bitmap, _ld,\n@@ -644,2 +651,1 @@\n-  ShenandoahVerifierMarkedRegionTask(ShenandoahGeneration* generation,\n-                                     MarkBitMap* bitmap,\n+  ShenandoahVerifierMarkedRegionTask(MarkBitMap* bitmap,\n@@ -657,1 +663,7 @@\n-          _generation(generation) {}\n+          _generation(nullptr) {\n+    if (_heap->mode()->is_generational()) {\n+      _generation = _heap->gc_generation();\n+      assert(_generation != nullptr, \"Expected active generation in this mode.\");\n+      shenandoah_assert_generations_reconciled();\n+    }\n+  };\n@@ -670,1 +682,1 @@\n-    ShenandoahVerifyOopClosure cl(_generation, &stack, _bitmap, _ld,\n+    ShenandoahVerifyOopClosure cl(&stack, _bitmap, _ld,\n@@ -693,2 +705,2 @@\n-  bool in_generation(ShenandoahHeapRegion* r) const {\n-    return _generation->contains(r);\n+  bool in_generation(ShenandoahHeapRegion* r) {\n+    return _generation == nullptr || _generation->contains(r);\n@@ -700,1 +712,1 @@\n-    if (_generation->complete_marking_context()->is_marked(cast_to_oop(obj))) {\n+    if (_heap->gc_generation()->complete_marking_context()->is_marked(cast_to_oop(obj))) {\n@@ -708,1 +720,1 @@\n-    ShenandoahMarkingContext* ctx = _generation->complete_marking_context();\n+    ShenandoahMarkingContext* ctx = _heap->gc_generation()->complete_marking_context();\n@@ -785,2 +797,1 @@\n-void ShenandoahVerifier::verify_at_safepoint(ShenandoahGeneration* generation,\n-                                             const char* label,\n+void ShenandoahVerifier::verify_at_safepoint(const char* label,\n@@ -888,0 +899,1 @@\n+  ShenandoahGeneration* generation;\n@@ -889,0 +901,8 @@\n+    generation = _heap->gc_generation();\n+    guarantee(generation != nullptr, \"Need to know which generation to verify.\");\n+    shenandoah_assert_generations_reconciled();\n+  } else {\n+    generation = nullptr;\n+  }\n+\n+  if (generation != nullptr) {\n@@ -935,1 +955,5 @@\n-    generation->heap_region_iterate(&cl);\n+    if (generation != nullptr) {\n+      generation->heap_region_iterate(&cl);\n+    } else {\n+      _heap->heap_region_iterate(&cl);\n+    }\n@@ -959,1 +983,1 @@\n-    ShenandoahVerifierReachableTask task(generation, _verification_bit_map, ld, label, options);\n+    ShenandoahVerifierReachableTask task(_verification_bit_map, ld, label, options);\n@@ -978,2 +1002,2 @@\n-    guarantee(generation->is_mark_complete(), \"Marking context should be complete\");\n-    ShenandoahVerifierMarkedRegionTask task(generation, _verification_bit_map, ld, label, options);\n+    guarantee(_heap->gc_generation()->is_mark_complete(), \"Marking context should be complete\");\n+    ShenandoahVerifierMarkedRegionTask task(_verification_bit_map, ld, label, options);\n@@ -994,1 +1018,1 @@\n-      if (!generation->contains(r)) {\n+      if (generation != nullptr && !generation->contains(r)) {\n@@ -1021,0 +1045,2 @@\n+\n+\n@@ -1027,1 +1053,1 @@\n-void ShenandoahVerifier::verify_generic(ShenandoahGeneration* generation, VerifyOption vo) {\n+void ShenandoahVerifier::verify_generic(VerifyOption vo) {\n@@ -1029,1 +1055,0 @@\n-          generation,\n@@ -1042,1 +1067,1 @@\n-void ShenandoahVerifier::verify_before_concmark(ShenandoahGeneration* generation) {\n+void ShenandoahVerifier::verify_before_concmark() {\n@@ -1050,1 +1075,0 @@\n-          generation,\n@@ -1064,1 +1088,1 @@\n-void ShenandoahVerifier::verify_after_concmark(ShenandoahGeneration* generation) {\n+void ShenandoahVerifier::verify_after_concmark() {\n@@ -1066,1 +1090,0 @@\n-          generation,\n@@ -1079,1 +1102,1 @@\n-void ShenandoahVerifier::verify_after_concmark_with_promotions(ShenandoahGeneration* generation) {\n+void ShenandoahVerifier::verify_after_concmark_with_promotions() {\n@@ -1081,1 +1104,0 @@\n-          generation,\n@@ -1095,1 +1117,1 @@\n-void ShenandoahVerifier::verify_before_evacuation(ShenandoahGeneration* generation) {\n+void ShenandoahVerifier::verify_before_evacuation() {\n@@ -1097,1 +1119,0 @@\n-          generation,\n@@ -1111,1 +1132,1 @@\n-void ShenandoahVerifier::verify_before_update_refs(ShenandoahGeneration* generation) {\n+void ShenandoahVerifier::verify_before_update_refs() {\n@@ -1118,1 +1139,0 @@\n-          generation,\n@@ -1132,1 +1152,1 @@\n-void ShenandoahVerifier::verify_after_update_refs(ShenandoahGeneration* generation) {\n+void ShenandoahVerifier::verify_after_update_refs() {\n@@ -1134,1 +1154,0 @@\n-          generation,\n@@ -1147,1 +1166,1 @@\n-void ShenandoahVerifier::verify_after_degenerated(ShenandoahGeneration* generation) {\n+void ShenandoahVerifier::verify_after_degenerated() {\n@@ -1149,1 +1168,0 @@\n-          generation,\n@@ -1162,1 +1180,1 @@\n-void ShenandoahVerifier::verify_before_fullgc(ShenandoahGeneration* generation) {\n+void ShenandoahVerifier::verify_before_fullgc() {\n@@ -1164,1 +1182,0 @@\n-          generation,\n@@ -1177,1 +1194,1 @@\n-void ShenandoahVerifier::verify_after_fullgc(ShenandoahGeneration* generation) {\n+void ShenandoahVerifier::verify_after_fullgc() {\n@@ -1179,1 +1196,0 @@\n-          generation,\n@@ -1244,1 +1260,1 @@\n-void ShenandoahVerifier::verify_roots_in_to_space(ShenandoahGeneration* generation) {\n+void ShenandoahVerifier::verify_roots_in_to_space() {\n@@ -1246,1 +1262,1 @@\n-  ShenandoahRootVerifier::roots_do(&cl, generation);\n+  ShenandoahRootVerifier::roots_do(&cl);\n@@ -1249,1 +1265,1 @@\n-void ShenandoahVerifier::verify_roots_no_forwarded(ShenandoahGeneration* generation) {\n+void ShenandoahVerifier::verify_roots_no_forwarded() {\n@@ -1251,1 +1267,1 @@\n-  ShenandoahRootVerifier::roots_do(&cl, generation);\n+  ShenandoahRootVerifier::roots_do(&cl);\n@@ -1287,0 +1303,1 @@\n+  shenandoah_assert_generations_reconciled();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":72,"deletions":55,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -199,2 +199,1 @@\n-  void verify_at_safepoint(ShenandoahGeneration* generation,\n-                           const char* label,\n+  void verify_at_safepoint(const char* label,\n@@ -214,10 +213,10 @@\n-  void verify_before_concmark(ShenandoahGeneration* generation);\n-  void verify_after_concmark(ShenandoahGeneration* generation);\n-  void verify_after_concmark_with_promotions(ShenandoahGeneration* generation);\n-  void verify_before_evacuation(ShenandoahGeneration* generation);\n-  void verify_before_update_refs(ShenandoahGeneration* generation);\n-  void verify_after_update_refs(ShenandoahGeneration* generation);\n-  void verify_before_fullgc(ShenandoahGeneration* generation);\n-  void verify_after_fullgc(ShenandoahGeneration* generation);\n-  void verify_after_degenerated(ShenandoahGeneration* generation);\n-  void verify_generic(ShenandoahGeneration* generation, VerifyOption option);\n+  void verify_before_concmark();\n+  void verify_after_concmark();\n+  void verify_after_concmark_with_promotions();\n+  void verify_before_evacuation();\n+  void verify_before_update_refs();\n+  void verify_after_update_refs();\n+  void verify_before_fullgc();\n+  void verify_after_fullgc();\n+  void verify_after_degenerated();\n+  void verify_generic(VerifyOption option);\n@@ -226,2 +225,2 @@\n-  void verify_roots_in_to_space(ShenandoahGeneration* generation);\n-  void verify_roots_no_forwarded(ShenandoahGeneration* generation);\n+  void verify_roots_in_to_space();\n+  void verify_roots_no_forwarded();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.hpp","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -56,2 +56,0 @@\n-\n-  static int numa_id_to_node(uint32_t numa_id);\n","filename":"src\/hotspot\/share\/gc\/z\/zNUMA.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-  if (!commit(vmem, 0) || !uncommit(vmem)) {\n+  if (!commit(vmem, (uint32_t)-1) || !uncommit(vmem)) {\n@@ -296,1 +296,1 @@\n-    os::numa_make_local((char*)addr, size, ZNUMA::numa_id_to_node(numa_id));\n+    os::numa_make_local((char*)addr, size, (int)numa_id);\n","filename":"src\/hotspot\/share\/gc\/z\/zPhysicalMemoryManager.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -261,2 +261,1 @@\n-        bool is_resolved = cpool->resolved_indy_entry_at(method_index)->is_resolved();\n-        return !is_resolved;\n+        return cpool->resolved_indy_entry_at(method_index)->is_resolved();\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -103,17 +103,2 @@\n-  int get_offset_s2() const { return bytecode().get_offset_s2(raw_code()); }\n-  int get_offset_s4() const { return bytecode().get_offset_s4(raw_code()); }\n-\n-  \/\/ These methods are not safe to use before or during verification as they may\n-  \/\/ have large offsets and cause overflows\n-  int dest() const {\n-    int min_offset = -1 * max_method_code_size;\n-    int offset = bytecode().get_offset_s2(raw_code());\n-    guarantee(offset >= min_offset && offset <= max_method_code_size, \"must be\");\n-    return bci() + offset;\n-  }\n-  int dest_w() const {\n-    int min_offset = -1 * max_method_code_size;\n-    int offset = bytecode().get_offset_s4(raw_code());\n-    guarantee(offset >= min_offset && offset <= max_method_code_size, \"must be\");\n-    return bci() + offset;\n-  }\n+  int             dest() const                   { return bci() + bytecode().get_offset_s2(raw_code()); }\n+  int             dest_w() const                 { return bci() + bytecode().get_offset_s4(raw_code()); }\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeStream.hpp","additions":2,"deletions":17,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -85,1 +85,8 @@\n-  _data[_head++] = request;\n+  u4 elementIndex;\n+  do {\n+    elementIndex = AtomicAccess::load_acquire(&_head);\n+    if (elementIndex >= _capacity) {\n+      return false;\n+    }\n+  } while (AtomicAccess::cmpxchg(&_head, elementIndex, elementIndex + 1) != elementIndex);\n+  _data[elementIndex] = request;\n@@ -97,1 +104,1 @@\n-  return _head;\n+  return AtomicAccess::load_acquire(&_head);\n@@ -101,1 +108,1 @@\n-  _head = size;\n+  AtomicAccess::release_store(&_head, size);\n@@ -105,1 +112,1 @@\n-  return _capacity;\n+  return AtomicAccess::load_acquire(&_capacity);\n@@ -109,1 +116,1 @@\n-  if (capacity == _capacity) {\n+  if (capacity == AtomicAccess::load(&_capacity)) {\n@@ -122,1 +129,1 @@\n-  _capacity = capacity;\n+  AtomicAccess::release_store(&_capacity, capacity);\n@@ -126,1 +133,1 @@\n-  return _head == 0;\n+  return AtomicAccess::load_acquire(&_head) == 0;\n@@ -130,1 +137,1 @@\n-  return _lost_samples;\n+  return AtomicAccess::load(&_lost_samples);\n@@ -139,1 +146,1 @@\n-  _lost_samples_due_to_queue_full++;\n+  AtomicAccess::inc(&_lost_samples_due_to_queue_full);\n@@ -147,3 +154,1 @@\n-  u4 lost = _lost_samples_due_to_queue_full;\n-  _lost_samples_due_to_queue_full = 0;\n-  return lost;\n+  return AtomicAccess::xchg(&_lost_samples_due_to_queue_full, (u4)0);\n@@ -157,1 +162,1 @@\n-  _head = 0;\n+  AtomicAccess::release_store(&_head, (u4)0);\n@@ -165,2 +170,3 @@\n-  if (_capacity < CPU_TIME_QUEUE_MAX_CAPACITY) {\n-    float ratio = (float)lost_samples_due_to_queue_full \/ (float)_capacity;\n+  u4 capacity = AtomicAccess::load(&_capacity);\n+  if (capacity < CPU_TIME_QUEUE_MAX_CAPACITY) {\n+    float ratio = (float)lost_samples_due_to_queue_full \/ (float)capacity;\n@@ -178,1 +184,1 @@\n-      u4 new_capacity = MIN2(CPU_TIME_QUEUE_MAX_CAPACITY, _capacity * factor);\n+      u4 new_capacity = MIN2(CPU_TIME_QUEUE_MAX_CAPACITY, capacity * factor);\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.cpp","additions":22,"deletions":16,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -46,7 +46,0 @@\n-\/\/ The lock in question is the tri-state CPU time JFR lock in JfrThreadLocal\n-\/\/ This allows us to skip most of the atomic accesses and memory barriers,\n-\/\/ holding a lock acts as a memory barrier\n-\/\/ Only the _lost_samples property is atomic, as it can be accessed even after\n-\/\/ acquiring the lock failed.\n-\/\/ Important to note is that the queue is also only accessed under lock in signal\n-\/\/ handlers.\n@@ -55,0 +48,4 @@\n+  \/\/ the default queue capacity, scaled if the sampling period is smaller than 10ms\n+  \/\/ when the thread is started\n+  static const u4 CPU_TIME_QUEUE_CAPACITY = 500;\n+\n@@ -56,1 +53,1 @@\n-  u4 _capacity;\n+  volatile u4 _capacity;\n@@ -58,1 +55,1 @@\n-  u4 _head;\n+  volatile u4 _head;\n@@ -60,1 +57,0 @@\n-  \/\/ the only property accessible without a lock\n@@ -62,2 +58,1 @@\n-\n-  u4 _lost_samples_due_to_queue_full;\n+  volatile u4 _lost_samples_due_to_queue_full;\n@@ -90,1 +85,0 @@\n-  \/\/ the only method callable without holding a lock\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.hpp","additions":7,"deletions":13,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -461,1 +461,0 @@\n-  assert(!thread->is_Java_thread() || JavaThread::cast(thread)->thread_state() == _thread_in_vm, \"invariant\");\n@@ -523,1 +522,1 @@\n-  JavaThread* _jt;\n+  JavaThread* const _jt;\n@@ -527,1 +526,1 @@\n-  JavaThreadInVMAndNative(Thread* t) : _jt(nullptr),\n+  JavaThreadInVMAndNative(Thread* t) : _jt(t->is_Java_thread() ? JavaThread::cast(t) : nullptr),\n@@ -529,2 +528,1 @@\n-    if (t != nullptr && t->is_Java_thread()) {\n-      _jt = JavaThread::cast(t);\n+    if (_jt != nullptr) {\n@@ -540,1 +538,0 @@\n-      assert(_jt != nullptr, \"invariant\");\n@@ -580,1 +577,0 @@\n-      JavaThreadInVMAndNative jtivm(thread);\n@@ -582,0 +578,1 @@\n+        JavaThreadInVMAndNative jtivm(thread);\n@@ -585,2 +582,0 @@\n-      \/\/ Transition to a safe safepoint state for the infinite sleep. A nop for non-java threads.\n-      jtivm.transition_to_native();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/repository\/jfrEmergencyDump.cpp","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-  LOG_TAG(asan) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-static DeferredStatic<PlatformMutex> GlobalChunkPoolMutex;\n+static PlatformMutex* GlobalChunkPoolMutex = nullptr;\n@@ -45,1 +45,1 @@\n-  GlobalChunkPoolMutex.initialize();\n+  GlobalChunkPoolMutex = new PlatformMutex();\n@@ -48,8 +48,3 @@\n-ChunkPoolLocker::ChunkPoolLocker(LockStrategy ls) {\n-  if (ls == LockStrategy::Lock) {\n-    GlobalChunkPoolMutex->lock();\n-    _locked = true;\n-  } else {\n-    assert(ls == LockStrategy::Try, \"must be\");\n-    _locked = GlobalChunkPoolMutex->try_lock();\n-  }\n+ChunkPoolLocker::ChunkPoolLocker() {\n+  assert(GlobalChunkPoolMutex != nullptr, \"must be initialized\");\n+  GlobalChunkPoolMutex->lock();\n@@ -59,3 +54,1 @@\n-  if (_locked) {\n-    GlobalChunkPoolMutex->unlock();\n-  }\n+  GlobalChunkPoolMutex->unlock();\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":6,"deletions":13,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-  bool _locked;\n@@ -43,3 +42,1 @@\n-  enum class LockStrategy { Lock, Try };\n-\n-  ChunkPoolLocker(LockStrategy ls = LockStrategy::Lock);\n+  ChunkPoolLocker();\n","filename":"src\/hotspot\/share\/memory\/arena.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -958,1 +958,1 @@\n-ReservedHeapSpace Universe::reserve_heap(size_t heap_size, size_t alignment, size_t desired_page_size) {\n+ReservedHeapSpace Universe::reserve_heap(size_t heap_size, size_t alignment) {\n@@ -969,7 +969,3 @@\n-  size_t page_size;\n-  if (desired_page_size == 0) {\n-    if (UseLargePages) {\n-      page_size = os::large_page_size();\n-    } else {\n-      page_size = os::vm_page_size();\n-    }\n+  size_t page_size = os::vm_page_size();\n+  if (UseLargePages && is_aligned(alignment, os::large_page_size())) {\n+    page_size = os::large_page_size();\n@@ -979,3 +975,1 @@\n-    assert(UseParallelGC , \"only Parallel\");\n-    \/\/ Use caller provided value.\n-    page_size = desired_page_size;\n+    assert(!UseLargePages || UseParallelGC , \"Wrong alignment to use large pages\");\n@@ -983,1 +977,1 @@\n-  assert(is_aligned(heap_size, page_size), \"inv\");\n+\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -318,1 +318,1 @@\n-  static ReservedHeapSpace reserve_heap(size_t heap_size, size_t alignment, size_t desired_page_size = 0);\n+  static ReservedHeapSpace reserve_heap(size_t heap_size, size_t alignment);\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"nmt\/memTracker.hpp\"\n@@ -40,1 +39,1 @@\n-void MallocHeader::print_block_on_error(outputStream* st, address bad_address, address block_address) const {\n+void MallocHeader::print_block_on_error(outputStream* st, address bad_address) const {\n@@ -52,12 +51,0 @@\n-  if (MemTracker::tracking_level() == NMT_TrackingLevel::NMT_detail) {\n-    MallocHeader* mh = (MallocHeader*)block_address;\n-    NativeCallStack stack;\n-    if (MallocSiteTable::access_stack(stack, *mh)) {\n-      st->print_cr(\"allocated from:\");\n-      stack.print_on(st);\n-    } else {\n-      st->print_cr(\"allocation-site cannot be shown since the marker is also corrupted.\");\n-    }\n-    st->print_cr(\"\");\n-  }\n-\n","filename":"src\/hotspot\/share\/nmt\/mallocHeader.cpp","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-  void print_block_on_error(outputStream* st, address bad_address, address block_address) const;\n+  void print_block_on_error(outputStream* st, address bad_address) const;\n","filename":"src\/hotspot\/share\/nmt\/mallocHeader.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-    header_pointer->print_block_on_error(tty, corruption != nullptr ? corruption : (address)header_pointer, (address)header_pointer);\n+    header_pointer->print_block_on_error(tty, corruption != nullptr ? corruption : (address)header_pointer);\n","filename":"src\/hotspot\/share\/nmt\/mallocHeader.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -166,3 +166,1 @@\n-  if (bucket_idx >= table_size) {\n-    return nullptr;\n-  }\n+  assert(bucket_idx < table_size, \"Invalid bucket index\");\n@@ -174,3 +172,1 @@\n-  if (head == nullptr) {\n-    return nullptr;\n-  }\n+  assert(head != nullptr, \"Invalid position index\");\n","filename":"src\/hotspot\/share\/nmt\/mallocSiteTable.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -68,5 +68,1 @@\n-  ChunkPoolLocker::LockStrategy ls = ChunkPoolLocker::LockStrategy::Lock;\n-  if (VMError::is_error_reported() && VMError::is_error_reported_in_current_thread()) {\n-    ls = ChunkPoolLocker::LockStrategy::Try;\n-  }\n-  ChunkPoolLocker cpl(ls);\n+  ChunkPoolLocker lock;\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"utilities\/vmError.hpp\"\n@@ -62,5 +61,1 @@\n-    ChunkPoolLocker::LockStrategy ls = ChunkPoolLocker::LockStrategy::Lock;\n-    if (VMError::is_error_reported() && VMError::is_error_reported_in_current_thread()) {\n-      ls = ChunkPoolLocker::LockStrategy::Try;\n-    }\n-    ChunkPoolLocker cpl(ls);\n+    ChunkPoolLocker lock;\n","filename":"src\/hotspot\/share\/nmt\/nmtUsage.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -541,0 +541,1 @@\n+  Klass* k = resolved_klass_at(cp_index);\n@@ -542,1 +543,0 @@\n-  Klass* k = nullptr;\n@@ -544,1 +544,5 @@\n-  if (CDSConfig::is_dumping_preimage_static_archive()) {\n+  if (k == nullptr) {\n+    \/\/ We'd come here if the referenced class has been excluded via\n+    \/\/ SystemDictionaryShared::is_excluded_class(). As a result, ArchiveBuilder\n+    \/\/ has cleared the resolved_klasses()->at(...) pointer to null. Thus, we\n+    \/\/ need to revert the tag to JVM_CONSTANT_UnresolvedClass.\n@@ -547,11 +551,2 @@\n-    k = resolved_klass_at(cp_index);\n-    if (k == nullptr) {\n-      \/\/ We'd come here if the referenced class has been excluded via\n-      \/\/ SystemDictionaryShared::is_excluded_class(). As a result, ArchiveBuilder\n-      \/\/ has cleared the resolved_klasses()->at(...) pointer to null. Thus, we\n-      \/\/ need to revert the tag to JVM_CONSTANT_UnresolvedClass.\n-      can_archive = false;\n-    } else {\n-      ConstantPool* src_cp = ArchiveBuilder::current()->get_source_addr(this);\n-      can_archive = AOTConstantPoolResolver::is_resolution_deterministic(src_cp, cp_index);\n-    }\n+    ConstantPool* src_cp = ArchiveBuilder::current()->get_source_addr(this);\n+    can_archive = AOTConstantPoolResolver::is_resolution_deterministic(src_cp, cp_index);\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -433,2 +433,1 @@\n-    if (resolved && !CDSConfig::is_dumping_preimage_static_archive()\n-        && AOTConstantPoolResolver::is_resolution_deterministic(src_cp, cp_index)) {\n+    if (resolved && AOTConstantPoolResolver::is_resolution_deterministic(src_cp, cp_index)) {\n@@ -440,12 +439,14 @@\n-    LogStreamHandle(Trace, aot, resolve) log;\n-    if (log.is_enabled()) {\n-      ResourceMark rm;\n-      int klass_cp_index = cp->uncached_klass_ref_index_at(cp_index);\n-      Symbol* klass_name = cp->klass_name_at(klass_cp_index);\n-      Symbol* name = cp->uncached_name_ref_at(cp_index);\n-      Symbol* signature = cp->uncached_signature_ref_at(cp_index);\n-      log.print(\"%s field  CP entry [%3d]: %s => %s.%s:%s\",\n-                (archived ? \"archived\" : \"reverted\"),\n-                cp_index,\n-                cp->pool_holder()->name()->as_C_string(),\n-                klass_name->as_C_string(), name->as_C_string(), signature->as_C_string());\n+    if (resolved) {\n+      LogStreamHandle(Trace, aot, resolve) log;\n+      if (log.is_enabled()) {\n+        ResourceMark rm;\n+        int klass_cp_index = cp->uncached_klass_ref_index_at(cp_index);\n+        Symbol* klass_name = cp->klass_name_at(klass_cp_index);\n+        Symbol* name = cp->uncached_name_ref_at(cp_index);\n+        Symbol* signature = cp->uncached_signature_ref_at(cp_index);\n+        log.print(\"%s field  CP entry [%3d]: %s => %s.%s:%s\",\n+                  (archived ? \"archived\" : \"reverted\"),\n+                  cp_index,\n+                  cp->pool_holder()->name()->as_C_string(),\n+                  klass_name->as_C_string(), name->as_C_string(), signature->as_C_string());\n+      }\n@@ -472,2 +473,1 @@\n-    if (resolved && !CDSConfig::is_dumping_preimage_static_archive()\n-        && can_archive_resolved_method(src_cp, rme)) {\n+    if (resolved && can_archive_resolved_method(src_cp, rme)) {\n@@ -479,18 +479,20 @@\n-    LogStreamHandle(Trace, aot, resolve) log;\n-    if (log.is_enabled()) {\n-      ResourceMark rm;\n-      int klass_cp_index = cp->uncached_klass_ref_index_at(cp_index);\n-      Symbol* klass_name = cp->klass_name_at(klass_cp_index);\n-      Symbol* name = cp->uncached_name_ref_at(cp_index);\n-      Symbol* signature = cp->uncached_signature_ref_at(cp_index);\n-      log.print(\"%s%s method CP entry [%3d]: %s %s.%s:%s\",\n-                (archived ? \"archived\" : \"reverted\"),\n-                (rme->is_resolved(Bytecodes::_invokeinterface) ? \" interface\" : \"\"),\n-                cp_index,\n-                cp->pool_holder()->name()->as_C_string(),\n-                klass_name->as_C_string(), name->as_C_string(), signature->as_C_string());\n-      if (archived) {\n-        Klass* resolved_klass = cp->resolved_klass_at(klass_cp_index);\n-        log.print(\" => %s%s\",\n-                  resolved_klass->name()->as_C_string(),\n-                  (rme->is_resolved(Bytecodes::_invokestatic) ? \" *** static\" : \"\"));\n+    if (resolved) {\n+      LogStreamHandle(Trace, aot, resolve) log;\n+      if (log.is_enabled()) {\n+        ResourceMark rm;\n+        int klass_cp_index = cp->uncached_klass_ref_index_at(cp_index);\n+        Symbol* klass_name = cp->klass_name_at(klass_cp_index);\n+        Symbol* name = cp->uncached_name_ref_at(cp_index);\n+        Symbol* signature = cp->uncached_signature_ref_at(cp_index);\n+        log.print(\"%s%s method CP entry [%3d]: %s %s.%s:%s\",\n+                  (archived ? \"archived\" : \"reverted\"),\n+                  (rme->is_resolved(Bytecodes::_invokeinterface) ? \" interface\" : \"\"),\n+                  cp_index,\n+                  cp->pool_holder()->name()->as_C_string(),\n+                  klass_name->as_C_string(), name->as_C_string(), signature->as_C_string());\n+        if (archived) {\n+          Klass* resolved_klass = cp->resolved_klass_at(klass_cp_index);\n+          log.print(\" => %s%s\",\n+                    resolved_klass->name()->as_C_string(),\n+                    (rme->is_resolved(Bytecodes::_invokestatic) ? \" *** static\" : \"\"));\n+        }\n@@ -511,2 +513,1 @@\n-    if (resolved && !CDSConfig::is_dumping_preimage_static_archive()\n-        && AOTConstantPoolResolver::is_resolution_deterministic(src_cp, cp_index)) {\n+    if (resolved && AOTConstantPoolResolver::is_resolution_deterministic(src_cp, cp_index)) {\n@@ -518,13 +519,16 @@\n-    LogStreamHandle(Trace, aot, resolve) log;\n-    if (log.is_enabled()) {\n-      ResourceMark rm;\n-      int bsm = cp->bootstrap_method_ref_index_at(cp_index);\n-      int bsm_ref = cp->method_handle_index_at(bsm);\n-      Symbol* bsm_name = cp->uncached_name_ref_at(bsm_ref);\n-      Symbol* bsm_signature = cp->uncached_signature_ref_at(bsm_ref);\n-      Symbol* bsm_klass = cp->klass_name_at(cp->uncached_klass_ref_index_at(bsm_ref));\n-      log.print(\"%s indy   CP entry [%3d]: %s (%d)\",\n-                (archived ? \"archived\" : \"reverted\"),\n-                cp_index, cp->pool_holder()->name()->as_C_string(), i);\n-      log.print(\" %s %s.%s:%s\", (archived ? \"=>\" : \"  \"), bsm_klass->as_C_string(),\n-                bsm_name->as_C_string(), bsm_signature->as_C_string());\n+    if (resolved) {\n+      LogStreamHandle(Trace, aot, resolve) log;\n+      if (log.is_enabled()) {\n+        ResourceMark rm;\n+        int bsm = cp->bootstrap_method_ref_index_at(cp_index);\n+        int bsm_ref = cp->method_handle_index_at(bsm);\n+        Symbol* bsm_name = cp->uncached_name_ref_at(bsm_ref);\n+        Symbol* bsm_signature = cp->uncached_signature_ref_at(bsm_ref);\n+        Symbol* bsm_klass = cp->klass_name_at(cp->uncached_klass_ref_index_at(bsm_ref));\n+        log.print(\"%s indy   CP entry [%3d]: %s (%d)\",\n+                  (archived ? \"archived\" : \"reverted\"),\n+                  cp_index, cp->pool_holder()->name()->as_C_string(), i);\n+        log.print(\" %s %s.%s:%s\", (archived ? \"=>\" : \"  \"), bsm_klass->as_C_string(),\n+                  bsm_name->as_C_string(), bsm_signature->as_C_string());\n+      }\n+      ArchiveBuilder::alloc_stats()->record_indy_cp_entry(archived, resolved && !archived);\n@@ -532,1 +536,0 @@\n-    ArchiveBuilder::alloc_stats()->record_indy_cp_entry(archived, resolved && !archived);\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":53,"deletions":50,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-  return RegMask::EMPTY;\n+  return RegMask::Empty;\n@@ -85,1 +85,1 @@\n-    return new MachProjNode(this,proj->_con,RegMask::EMPTY,MachProjNode::unmatched_proj);\n+    return new MachProjNode(this,proj->_con,RegMask::Empty,MachProjNode::unmatched_proj);\n@@ -780,1 +780,1 @@\n-    return new MachProjNode(this,proj->_con,RegMask::EMPTY,MachProjNode::unmatched_proj);\n+    return new MachProjNode(this,proj->_con,RegMask::Empty,MachProjNode::unmatched_proj);\n@@ -785,1 +785,1 @@\n-    return new MachProjNode(this,proj->_con, RegMask::EMPTY, (uint)OptoReg::Bad);\n+    return new MachProjNode(this,proj->_con, RegMask::Empty, (uint)OptoReg::Bad);\n@@ -801,1 +801,1 @@\n-            rm.insert(r);\n+            rm.Insert(r);\n@@ -808,1 +808,1 @@\n-      rm.insert(regs.second());\n+      rm.Insert( regs.second() );\n@@ -1495,3 +1495,1 @@\n-  if (idx < TypeFunc::Parms) {\n-    return RegMask::EMPTY;\n-  }\n+  if( idx < TypeFunc::Parms ) return RegMask::Empty;\n@@ -1502,1 +1500,1 @@\n-  return RegMask::EMPTY;\n+  return RegMask::Empty;\n@@ -1613,1 +1611,1 @@\n-  return RegMask::EMPTY;\n+  return RegMask::Empty;\n@@ -1664,1 +1662,1 @@\n-  return RegMask::EMPTY;\n+  return RegMask::Empty;\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1017,1 +1017,1 @@\n-  return RegMask::EMPTY;\n+  return RegMask::Empty;\n@@ -2862,1 +2862,1 @@\n-  return i ? out_RegMask() : RegMask::EMPTY;\n+  return i ? out_RegMask() : RegMask::Empty;\n@@ -2868,3 +2868,1 @@\n-  if (ideal_reg == 0) {\n-    return RegMask::EMPTY;\n-  }\n+  if( ideal_reg == 0 ) return RegMask::Empty;\n@@ -2897,1 +2895,1 @@\n-  return RegMask::EMPTY;\n+  return RegMask::Empty;\n@@ -2902,1 +2900,1 @@\n-  return RegMask::EMPTY;\n+  return RegMask::Empty;\n@@ -2907,1 +2905,1 @@\n-  return RegMask::EMPTY;\n+  return RegMask::Empty;\n@@ -2912,1 +2910,1 @@\n-  return RegMask::EMPTY;\n+  return RegMask::Empty;\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -744,1 +744,1 @@\n-    return RegMask::ALL;\n+    return RegMask::All;\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,3 +52,1 @@\n-    else {\n-      tty->print(\", #!!!_%d_vs_%d \", _mask_size, _mask.size());\n-    }\n+    else tty->print(\", #!!!_%d_vs_%d \",_mask_size,_mask.Size());\n@@ -56,1 +54,1 @@\n-    tty->print(\", #?(%d) \", _mask.size());\n+    tty->print(\", #?(%d) \",_mask.Size());\n@@ -746,1 +744,1 @@\n-          lrg.remove(hi);               \/\/ Yank from mask\n+          lrg.Remove(hi);       \/\/ Yank from mask\n@@ -778,1 +776,1 @@\n-      _lrg_map.map(n->_idx, !rm.is_empty() ? lr_counter++ : 0);\n+      _lrg_map.map(n->_idx, !rm.is_Empty() ? lr_counter++ : 0);\n@@ -799,1 +797,1 @@\n-      _lrg_map.map(n->_idx, !rm.is_empty() ? n->_idx : 0);\n+      _lrg_map.map(n->_idx, !rm.is_Empty() ? n->_idx : 0);\n@@ -884,1 +882,1 @@\n-        lrg.and_with(rm);\n+        lrg.AND( rm );\n@@ -940,1 +938,1 @@\n-          lrg.set_num_regs(rm.size());\n+          lrg.set_num_regs(rm.Size());\n@@ -1131,1 +1129,1 @@\n-          lrg.and_with(rm);\n+          lrg.AND( rm );\n@@ -1169,1 +1167,1 @@\n-          lrg.clear();\n+          lrg.Clear();\n@@ -1410,1 +1408,1 @@\n-  if (lrg.mask().can_represent(reg) && lrg.mask().member(reg)) {\n+  if (lrg.mask().can_represent(reg) && lrg.mask().Member(reg)) {\n@@ -1464,1 +1462,1 @@\n-          mask.remove(assigned - num_regs + 1);      \/\/ Unmask the lowest reg\n+          mask.Remove(assigned - num_regs + 1); \/\/ Unmask the lowest reg\n@@ -1515,1 +1513,1 @@\n-      tempmask.and_with(lrgs(copy_lrg).mask());\n+      tempmask.AND(lrgs(copy_lrg).mask());\n@@ -1538,1 +1536,1 @@\n-    lrg.remove(reg);\n+    lrg.Remove(reg);\n@@ -1540,1 +1538,1 @@\n-    lrg.insert(reg);\n+    lrg.Insert(reg);\n@@ -1550,2 +1548,2 @@\n-  assert(C->in_preserve_stack_slots() == 0 || lrg.mask().is_offset() || lrg._is_bound || lrg.mask().is_bound1() || !lrg.mask().member(OptoReg::Name(_matcher._old_SP - 1)), \"must not allocate stack0 (inside preserve area)\");\n-  assert(C->out_preserve_stack_slots() == 0 || lrg.mask().is_offset() || lrg._is_bound || lrg.mask().is_bound1() || !lrg.mask().member(OptoReg::Name(_matcher._old_SP + 0)), \"must not allocate stack0 (inside preserve area)\");\n+  assert(C->in_preserve_stack_slots() == 0 || lrg.mask().is_offset() || lrg._is_bound || lrg.mask().is_bound1() || !lrg.mask().Member(OptoReg::Name(_matcher._old_SP - 1)), \"must not allocate stack0 (inside preserve area)\");\n+  assert(C->out_preserve_stack_slots() == 0 || lrg.mask().is_offset() || lrg._is_bound || lrg.mask().is_bound1() || !lrg.mask().Member(OptoReg::Name(_matcher._old_SP + 0)), \"must not allocate stack0 (inside preserve area)\");\n@@ -1627,1 +1625,1 @@\n-          uint size = lrg->mask().size();\n+          uint size = lrg->mask().Size();\n@@ -1631,1 +1629,1 @@\n-          lrg->subtract_inner(nlrg.mask());\n+          lrg->SUBTRACT_inner(nlrg.mask());\n@@ -1633,1 +1631,1 @@\n-          if (trace_spilling() && lrg->mask().size() != size) {\n+          if (trace_spilling() && lrg->mask().Size() != size) {\n@@ -1640,1 +1638,1 @@\n-            trace_mask.subtract(lrg->mask());\n+            trace_mask.SUBTRACT(lrg->mask());\n@@ -1706,2 +1704,2 @@\n-        lrg->clear();     \/\/ Clear the mask\n-        lrg->insert(reg); \/\/ Set regmask to match selected reg\n+        lrg->Clear();           \/\/ Clear the mask\n+        lrg->Insert(reg);       \/\/ Set regmask to match selected reg\n@@ -1714,1 +1712,1 @@\n-          lrg->insert(OptoReg::add(reg, -i));\n+          lrg->Insert(OptoReg::add(reg,-i));\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":23,"deletions":25,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-  uint _mask_size;              \/\/ cache of _mask.size();\n+  uint _mask_size;              \/\/ cache of _mask.Size();\n@@ -108,1 +108,1 @@\n-  int compute_mask_size() const { return _mask.is_infinite_stack() ? INFINITE_STACK_SIZE : _mask.size(); }\n+  int compute_mask_size() const { return _mask.is_infinite_stack() ? INFINITE_STACK_SIZE : _mask.Size(); }\n@@ -110,1 +110,1 @@\n-    assert((size == (int)INFINITE_STACK_SIZE) || (size == (int)_mask.size()), \"\");\n+    assert((size == (int)INFINITE_STACK_SIZE) || (size == (int)_mask.Size()), \"\");\n@@ -131,1 +131,1 @@\n-  void set_mask(const RegMask& rm) { _mask.assignFrom(rm); DEBUG_ONLY(_msize_valid = 0;) }\n+  void set_mask( const RegMask &rm ) { _mask = rm; DEBUG_ONLY(_msize_valid=0;)}\n@@ -133,5 +133,5 @@\n-  void and_with( const RegMask &rm ) { _mask.and_with(rm); DEBUG_ONLY(_msize_valid=0;)}\n-  void subtract( const RegMask &rm ) { _mask.subtract(rm); DEBUG_ONLY(_msize_valid=0;)}\n-  void subtract_inner(const RegMask& rm) { _mask.subtract_inner(rm); DEBUG_ONLY(_msize_valid = 0;) }\n-  void clear()   { _mask.clear()  ; DEBUG_ONLY(_msize_valid=1); _mask_size = 0; }\n-  void set_all() { _mask.set_all(); DEBUG_ONLY(_msize_valid = 1); _mask_size = _mask.rm_size_in_bits(); }\n+  void AND( const RegMask &rm ) { _mask.AND(rm); DEBUG_ONLY(_msize_valid=0;)}\n+  void SUBTRACT( const RegMask &rm ) { _mask.SUBTRACT(rm); DEBUG_ONLY(_msize_valid=0;)}\n+  void SUBTRACT_inner(const RegMask& rm) { _mask.SUBTRACT_inner(rm); DEBUG_ONLY(_msize_valid = 0;) }\n+  void Clear()   { _mask.Clear()  ; DEBUG_ONLY(_msize_valid=1); _mask_size = 0; }\n+  void Set_All() { _mask.Set_All(); DEBUG_ONLY(_msize_valid = 1); _mask_size = _mask.rm_size_in_bits(); }\n@@ -140,2 +140,2 @@\n-  void insert( OptoReg::Name reg ) { _mask.insert(reg);  DEBUG_ONLY(_msize_valid=0;) }\n-  void remove( OptoReg::Name reg ) { _mask.remove(reg);  DEBUG_ONLY(_msize_valid=0;) }\n+  void Insert( OptoReg::Name reg ) { _mask.Insert(reg);  DEBUG_ONLY(_msize_valid=0;) }\n+  void Remove( OptoReg::Name reg ) { _mask.Remove(reg);  DEBUG_ONLY(_msize_valid=0;) }\n@@ -627,1 +627,1 @@\n-        uint new_pressure = current_pressure() + fatproj_mask.size();\n+        uint new_pressure = current_pressure() + fatproj_mask.Size();\n","filename":"src\/hotspot\/share\/opto\/chaitin.hpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-      lrg1->and_with(lrg2->mask());\n+      lrg1->AND(lrg2->mask());\n@@ -506,2 +506,2 @@\n-  lrgs(lr2).clear();           \/\/ Force empty mask for LRG 2\n-  \/\/ lrgs(lr2)._size = 0;      \/\/ Live-range 2 goes dead\n+  lrgs(lr2).Clear();        \/\/ Force empty mask for LRG 2\n+  \/\/lrgs(lr2)._size = 0;      \/\/ Live-range 2 goes dead\n@@ -573,1 +573,1 @@\n-        rm.subtract(lrgs(lidx).mask());\n+        rm.SUBTRACT( lrgs(lidx).mask() );\n@@ -575,1 +575,1 @@\n-        rm_size = rm.size();\n+        rm_size = rm.Size();\n@@ -698,1 +698,1 @@\n-  mask.and_with(lrgs(lr2).mask());\n+  mask.AND(lrgs(lr2).mask());\n@@ -700,1 +700,1 @@\n-  uint rm_size = mask.size();\n+  uint rm_size = mask.Size();\n","filename":"src\/hotspot\/share\/opto\/coalesce.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -46,2 +46,2 @@\n-  virtual const RegMask& out_RegMask() const { return RegMask::EMPTY; }\n-  virtual const RegMask& in_RegMask(uint) const { return RegMask::EMPTY; }\n+  virtual const RegMask &out_RegMask() const { return RegMask::Empty; }\n+  virtual const RegMask &in_RegMask(uint) const { return RegMask::Empty; }\n","filename":"src\/hotspot\/share\/opto\/connode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1671,1 +1671,1 @@\n-    rm.assignFrom(match->divI_proj_mask());\n+    rm = match->divI_proj_mask();\n@@ -1674,1 +1674,1 @@\n-    rm.assignFrom(match->modI_proj_mask());\n+    rm = match->modI_proj_mask();\n@@ -1686,1 +1686,1 @@\n-    rm.assignFrom(match->divL_proj_mask());\n+    rm = match->divL_proj_mask();\n@@ -1689,1 +1689,1 @@\n-    rm.assignFrom(match->modL_proj_mask());\n+    rm = match->modL_proj_mask();\n@@ -1724,1 +1724,1 @@\n-    rm.assignFrom(match->divI_proj_mask());\n+    rm = match->divI_proj_mask();\n@@ -1727,1 +1727,1 @@\n-    rm.assignFrom(match->modI_proj_mask());\n+    rm = match->modI_proj_mask();\n@@ -1739,1 +1739,1 @@\n-    rm.assignFrom(match->divL_proj_mask());\n+    rm = match->divL_proj_mask();\n@@ -1742,1 +1742,1 @@\n-    rm.assignFrom(match->modL_proj_mask());\n+    rm = match->modL_proj_mask();\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1299,0 +1299,2 @@\n+    } else if (use->is_SafePoint()) {\n+      \/\/ processed later\n@@ -1300,1 +1302,0 @@\n-      \/\/ Safepoints to be processed later; other users aren't expected here\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1452,1 +1452,1 @@\n-  if (mach != nullptr && mach->out_RegMask().is_bound1() && !mach->out_RegMask().is_empty()) {\n+  if (mach != nullptr && mach->out_RegMask().is_bound1() && !mach->out_RegMask().is_Empty())\n@@ -1454,1 +1454,0 @@\n-  }\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    _lrgs[i].set_all();\n+    _lrgs[i].Set_All();\n@@ -658,1 +658,1 @@\n-  mask_tmp.and_with(*Matcher::idealreg2regmask[op_regtype]);\n+  mask_tmp.AND(*Matcher::idealreg2regmask[op_regtype]);\n@@ -732,1 +732,1 @@\n-    old.assignFrom(interfering_lrg.mask());\n+    old = interfering_lrg.mask();\n@@ -741,1 +741,1 @@\n-      r2mask.assignFrom(mask);\n+      r2mask = mask;\n@@ -745,1 +745,1 @@\n-      interfering_lrg.subtract(r2mask);\n+      interfering_lrg.SUBTRACT(r2mask);\n@@ -749,1 +749,1 @@\n-      interfering_lrg.subtract(mask);\n+      interfering_lrg.SUBTRACT(mask);\n@@ -754,2 +754,2 @@\n-      if (interfering_lrg.mask().member(r_reg)) {\n-        interfering_lrg.remove(r_reg);\n+      if (interfering_lrg.mask().Member(r_reg)) {\n+        interfering_lrg.Remove(r_reg);\n@@ -936,1 +936,1 @@\n-        if (lrg.is_bound() && !n->rematerialize() && !lrg.mask().is_empty()) {\n+        if (lrg.is_bound() && !n->rematerialize() && !lrg.mask().is_Empty()) {\n","filename":"src\/hotspot\/share\/opto\/ifg.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-  return RegMask::EMPTY;\n+  return RegMask::Empty;\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -858,1 +858,1 @@\n-    if (!regs.member(r)) { \/\/ Not already defined by the call\n+    if( !regs.Member(r) ) {     \/\/ Not already defined by the call\n@@ -863,1 +863,1 @@\n-        proj->_rout.insert(r);\n+        proj->_rout.Insert(r);\n@@ -887,1 +887,1 @@\n-    regs.or_with(n->out_RegMask());\n+    regs.OR(n->out_RegMask());\n@@ -910,1 +910,1 @@\n-  regs.insert(_matcher.c_frame_pointer());\n+  regs.Insert(_matcher.c_frame_pointer());\n@@ -915,1 +915,1 @@\n-  MachProjNode* proj = new MachProjNode(mcall, r_cnt + 1, RegMask::EMPTY, MachProjNode::fat_proj);\n+  MachProjNode *proj = new MachProjNode( mcall, r_cnt+1, RegMask::Empty, MachProjNode::fat_proj );\n@@ -1167,2 +1167,2 @@\n-      regs.insert(_matcher.c_frame_pointer());\n-      regs.or_with(n->out_RegMask());\n+      regs.Insert(_matcher.c_frame_pointer());\n+      regs.OR(n->out_RegMask());\n@@ -1170,1 +1170,1 @@\n-      MachProjNode* proj = new MachProjNode(n, 1, RegMask::EMPTY, MachProjNode::fat_proj);\n+      MachProjNode *proj = new MachProjNode( n, 1, RegMask::Empty, MachProjNode::fat_proj );\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -7276,1 +7276,1 @@\n-  ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AES_Crypt\"));\n+  ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n@@ -7362,1 +7362,1 @@\n-  ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AES_Crypt\"));\n+  ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n@@ -7432,1 +7432,1 @@\n-  ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AES_Crypt\"));\n+  ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n@@ -7472,1 +7472,1 @@\n-  assert (objSessionK != nullptr, \"wrong version of com.sun.crypto.provider.AES_Crypt\");\n+  assert (objSessionK != nullptr, \"wrong version of com.sun.crypto.provider.AESCrypt\");\n@@ -7480,1 +7480,1 @@\n-  assert (objAESCryptKey != nullptr, \"wrong version of com.sun.crypto.provider.AES_Crypt\");\n+  assert (objAESCryptKey != nullptr, \"wrong version of com.sun.crypto.provider.AESCrypt\");\n@@ -7515,1 +7515,1 @@\n-  ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AES_Crypt\"));\n+  ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n@@ -7578,1 +7578,1 @@\n-  ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AES_Crypt\"));\n+  ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n@@ -7638,1 +7638,1 @@\n-  ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AES_Crypt\"));\n+  ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n@@ -8611,1 +8611,1 @@\n-  ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AES_Crypt\"));\n+  ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n@@ -8665,1 +8665,1 @@\n-  ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AES_Crypt\"));\n+  ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -525,3 +525,1 @@\n-  \/\/ The lazy_replace ensures that any get_ctrl that used to have multiversion_slow_proj\n-  \/\/ as their control are forwarded to the new region node as their control.\n-  lazy_replace(multiversion_slow_proj, region);\n+  _igvn.replace_node(multiversion_slow_proj, region);\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -5179,1 +5179,1 @@\n-      if (!lpt->is_innermost()) continue;\n+      if (!head->is_BaseCountedLoop() || !lpt->is_innermost()) continue;\n@@ -5182,5 +5182,7 @@\n-      if (head->is_CountedLoop() && head->as_CountedLoop()->is_unroll_only()) {\n-        continue;\n-      } else {\n-        AutoNodeBudget node_budget(this);\n-        lpt->reassociate_invariants(this);\n+      if (head->is_CountedLoop()) {\n+        if (head->as_CountedLoop()->is_unroll_only()) {\n+          continue;\n+        } else {\n+          AutoNodeBudget node_budget(this);\n+          lpt->reassociate_invariants(this);\n+        }\n@@ -5192,1 +5194,0 @@\n-          head->is_BaseCountedLoop() &&\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -528,1 +528,1 @@\n-    if (!rm.is_empty() && rm.is_bound(ideal_reg())) {\n+    if (!rm.is_Empty() && rm.is_bound(ideal_reg())) {\n@@ -622,5 +622,2 @@\n-  if (idx == 0) {\n-    return RegMask::EMPTY;\n-  } else {\n-    return in(1)->as_Mach()->out_RegMask();\n-  }\n+  if( idx == 0 ) return RegMask::Empty;\n+  else return in(1)->as_Mach()->out_RegMask();\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -740,1 +740,1 @@\n-  virtual const RegMask& out_RegMask() const { return RegMask::EMPTY; }\n+  virtual const RegMask &out_RegMask() const { return RegMask::Empty; }\n@@ -772,1 +772,1 @@\n-  virtual const RegMask& in_RegMask(uint) const { return RegMask::EMPTY; }\n+  virtual const RegMask &in_RegMask(uint) const { return RegMask::Empty; }\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -179,1 +179,1 @@\n-  assert(_return_addr_mask.is_empty(),\n+  assert(_return_addr_mask.is_Empty(),\n@@ -181,1 +181,1 @@\n-  _return_addr_mask.insert(return_addr());\n+  _return_addr_mask.Insert(return_addr());\n@@ -184,1 +184,1 @@\n-  _return_addr_mask.insert(OptoReg::add(return_addr(), 1));\n+  _return_addr_mask.Insert(OptoReg::add(return_addr(),1));\n@@ -198,1 +198,1 @@\n-    _return_value_mask.assignFrom(RegMask(regs.first()));\n+    _return_value_mask = RegMask(regs.first());\n@@ -200,1 +200,1 @@\n-      _return_value_mask.insert(regs.second());\n+      _return_value_mask.Insert(regs.second());\n@@ -264,1 +264,1 @@\n-    _calling_convention_mask[i].clear();\n+    _calling_convention_mask[i].Clear();\n@@ -276,1 +276,1 @@\n-      _calling_convention_mask[i].insert(reg1);\n+      _calling_convention_mask[i].Insert(reg1);\n@@ -280,1 +280,1 @@\n-      _calling_convention_mask[i].insert(reg2);\n+      _calling_convention_mask[i].Insert(reg2);\n@@ -425,5 +425,5 @@\n-  rms[TypeFunc::Control  ].assignFrom(RegMask::EMPTY);\n-  rms[TypeFunc::I_O      ].assignFrom(RegMask::EMPTY);\n-  rms[TypeFunc::Memory   ].assignFrom(RegMask::EMPTY);\n-  rms[TypeFunc::ReturnAdr].assignFrom(ret_adr);\n-  rms[TypeFunc::FramePtr ].assignFrom(fp);\n+  rms[TypeFunc::Control  ] = RegMask::Empty;\n+  rms[TypeFunc::I_O      ] = RegMask::Empty;\n+  rms[TypeFunc::Memory   ] = RegMask::Empty;\n+  rms[TypeFunc::ReturnAdr] = ret_adr;\n+  rms[TypeFunc::FramePtr ] = fp;\n@@ -474,1 +474,1 @@\n-  C->FIRST_STACK_mask().clear();\n+  C->FIRST_STACK_mask().Clear();\n@@ -479,1 +479,1 @@\n-    C->FIRST_STACK_mask().insert(i);\n+    C->FIRST_STACK_mask().Insert(i);\n@@ -482,1 +482,1 @@\n-  C->FIRST_STACK_mask().set_all_from(_out_arg_limit);\n+  C->FIRST_STACK_mask().Set_All_From(_out_arg_limit);\n@@ -491,1 +491,1 @@\n-  idealreg2spillmask[Op_RegP]->assignFrom(*idealreg2regmask[Op_RegP]);\n+  *idealreg2spillmask[Op_RegP] = *idealreg2regmask[Op_RegP];\n@@ -493,3 +493,3 @@\n-  idealreg2spillmask[Op_RegN]->assignFrom(*idealreg2regmask[Op_RegN]);\n-  idealreg2spillmask[Op_RegN]->or_with(C->FIRST_STACK_mask());\n-  idealreg2spillmask[Op_RegP]->or_with(aligned_stack_mask);\n+  *idealreg2spillmask[Op_RegN] = *idealreg2regmask[Op_RegN];\n+   idealreg2spillmask[Op_RegN]->OR(C->FIRST_STACK_mask());\n+   idealreg2spillmask[Op_RegP]->OR(aligned_stack_mask);\n@@ -497,1 +497,1 @@\n-   idealreg2spillmask[Op_RegP]->or_with(C->FIRST_STACK_mask());\n+   idealreg2spillmask[Op_RegP]->OR(C->FIRST_STACK_mask());\n@@ -499,8 +499,8 @@\n-  idealreg2spillmask[Op_RegI]->assignFrom(*idealreg2regmask[Op_RegI]);\n-  idealreg2spillmask[Op_RegI]->or_with(C->FIRST_STACK_mask());\n-  idealreg2spillmask[Op_RegL]->assignFrom(*idealreg2regmask[Op_RegL]);\n-  idealreg2spillmask[Op_RegL]->or_with(aligned_stack_mask);\n-  idealreg2spillmask[Op_RegF]->assignFrom(*idealreg2regmask[Op_RegF]);\n-  idealreg2spillmask[Op_RegF]->or_with(C->FIRST_STACK_mask());\n-  idealreg2spillmask[Op_RegD]->assignFrom(*idealreg2regmask[Op_RegD]);\n-  idealreg2spillmask[Op_RegD]->or_with(aligned_stack_mask);\n+  *idealreg2spillmask[Op_RegI] = *idealreg2regmask[Op_RegI];\n+   idealreg2spillmask[Op_RegI]->OR(C->FIRST_STACK_mask());\n+  *idealreg2spillmask[Op_RegL] = *idealreg2regmask[Op_RegL];\n+   idealreg2spillmask[Op_RegL]->OR(aligned_stack_mask);\n+  *idealreg2spillmask[Op_RegF] = *idealreg2regmask[Op_RegF];\n+   idealreg2spillmask[Op_RegF]->OR(C->FIRST_STACK_mask());\n+  *idealreg2spillmask[Op_RegD] = *idealreg2regmask[Op_RegD];\n+   idealreg2spillmask[Op_RegD]->OR(aligned_stack_mask);\n@@ -509,2 +509,2 @@\n-    idealreg2spillmask[Op_RegVectMask]->assignFrom(*idealreg2regmask[Op_RegVectMask]);\n-    idealreg2spillmask[Op_RegVectMask]->or_with(aligned_stack_mask);\n+    *idealreg2spillmask[Op_RegVectMask] = *idealreg2regmask[Op_RegVectMask];\n+     idealreg2spillmask[Op_RegVectMask]->OR(aligned_stack_mask);\n@@ -512,1 +512,1 @@\n-    idealreg2spillmask[Op_RegVectMask]->assignFrom(RegMask::EMPTY);\n+    *idealreg2spillmask[Op_RegVectMask] = RegMask::Empty;\n@@ -516,2 +516,2 @@\n-    idealreg2spillmask[Op_VecS]->assignFrom(*idealreg2regmask[Op_VecS]);\n-    idealreg2spillmask[Op_VecS]->or_with(C->FIRST_STACK_mask());\n+    *idealreg2spillmask[Op_VecS] = *idealreg2regmask[Op_VecS];\n+     idealreg2spillmask[Op_VecS]->OR(C->FIRST_STACK_mask());\n@@ -519,1 +519,1 @@\n-    idealreg2spillmask[Op_VecS]->assignFrom(RegMask::EMPTY);\n+    *idealreg2spillmask[Op_VecS] = RegMask::Empty;\n@@ -525,2 +525,2 @@\n-    idealreg2spillmask[Op_VecD]->assignFrom(*idealreg2regmask[Op_VecD]);\n-    idealreg2spillmask[Op_VecD]->or_with(aligned_stack_mask);\n+    *idealreg2spillmask[Op_VecD] = *idealreg2regmask[Op_VecD];\n+     idealreg2spillmask[Op_VecD]->OR(aligned_stack_mask);\n@@ -528,1 +528,1 @@\n-    idealreg2spillmask[Op_VecD]->assignFrom(RegMask::EMPTY);\n+    *idealreg2spillmask[Op_VecD] = RegMask::Empty;\n@@ -541,1 +541,1 @@\n-      aligned_stack_mask.remove(in);\n+      aligned_stack_mask.Remove(in);\n@@ -544,4 +544,4 @@\n-    aligned_stack_mask.clear_to_sets(RegMask::SlotsPerVecX);\n-    assert(aligned_stack_mask.is_infinite_stack(), \"should be infinite stack\");\n-    idealreg2spillmask[Op_VecX]->assignFrom(*idealreg2regmask[Op_VecX]);\n-    idealreg2spillmask[Op_VecX]->or_with(aligned_stack_mask);\n+     aligned_stack_mask.clear_to_sets(RegMask::SlotsPerVecX);\n+     assert(aligned_stack_mask.is_infinite_stack(), \"should be infinite stack\");\n+    *idealreg2spillmask[Op_VecX] = *idealreg2regmask[Op_VecX];\n+     idealreg2spillmask[Op_VecX]->OR(aligned_stack_mask);\n@@ -549,1 +549,1 @@\n-    idealreg2spillmask[Op_VecX]->assignFrom(RegMask::EMPTY);\n+    *idealreg2spillmask[Op_VecX] = RegMask::Empty;\n@@ -556,1 +556,1 @@\n-      aligned_stack_mask.remove(in);\n+      aligned_stack_mask.Remove(in);\n@@ -559,4 +559,4 @@\n-    aligned_stack_mask.clear_to_sets(RegMask::SlotsPerVecY);\n-    assert(aligned_stack_mask.is_infinite_stack(), \"should be infinite stack\");\n-    idealreg2spillmask[Op_VecY]->assignFrom(*idealreg2regmask[Op_VecY]);\n-    idealreg2spillmask[Op_VecY]->or_with(aligned_stack_mask);\n+     aligned_stack_mask.clear_to_sets(RegMask::SlotsPerVecY);\n+     assert(aligned_stack_mask.is_infinite_stack(), \"should be infinite stack\");\n+    *idealreg2spillmask[Op_VecY] = *idealreg2regmask[Op_VecY];\n+     idealreg2spillmask[Op_VecY]->OR(aligned_stack_mask);\n@@ -564,1 +564,1 @@\n-    idealreg2spillmask[Op_VecY]->assignFrom(RegMask::EMPTY);\n+    *idealreg2spillmask[Op_VecY] = RegMask::Empty;\n@@ -571,1 +571,1 @@\n-      aligned_stack_mask.remove(in);\n+      aligned_stack_mask.Remove(in);\n@@ -574,4 +574,4 @@\n-    aligned_stack_mask.clear_to_sets(RegMask::SlotsPerVecZ);\n-    assert(aligned_stack_mask.is_infinite_stack(), \"should be infinite stack\");\n-    idealreg2spillmask[Op_VecZ]->assignFrom(*idealreg2regmask[Op_VecZ]);\n-    idealreg2spillmask[Op_VecZ]->or_with(aligned_stack_mask);\n+     aligned_stack_mask.clear_to_sets(RegMask::SlotsPerVecZ);\n+     assert(aligned_stack_mask.is_infinite_stack(), \"should be infinite stack\");\n+    *idealreg2spillmask[Op_VecZ] = *idealreg2regmask[Op_VecZ];\n+     idealreg2spillmask[Op_VecZ]->OR(aligned_stack_mask);\n@@ -579,1 +579,1 @@\n-    idealreg2spillmask[Op_VecZ]->assignFrom(RegMask::EMPTY);\n+    *idealreg2spillmask[Op_VecZ] = RegMask::Empty;\n@@ -589,1 +589,1 @@\n-        scalable_stack_mask.remove(in);\n+        scalable_stack_mask.Remove(in);\n@@ -596,2 +596,2 @@\n-      idealreg2spillmask[Op_RegVectMask]->assignFrom(*idealreg2regmask[Op_RegVectMask]);\n-      idealreg2spillmask[Op_RegVectMask]->or_with(scalable_stack_mask);\n+      *idealreg2spillmask[Op_RegVectMask] = *idealreg2regmask[Op_RegVectMask];\n+      idealreg2spillmask[Op_RegVectMask]->OR(scalable_stack_mask);\n@@ -603,1 +603,1 @@\n-      scalable_stack_mask.remove(in);\n+      scalable_stack_mask.Remove(in);\n@@ -608,4 +608,4 @@\n-    scalable_stack_mask.clear_to_sets(RegMask::SlotsPerVecA);\n-    assert(scalable_stack_mask.is_infinite_stack(), \"should be infinite stack\");\n-    idealreg2spillmask[Op_VecA]->assignFrom(*idealreg2regmask[Op_VecA]);\n-    idealreg2spillmask[Op_VecA]->or_with(scalable_stack_mask);\n+     scalable_stack_mask.clear_to_sets(RegMask::SlotsPerVecA);\n+     assert(scalable_stack_mask.is_infinite_stack(), \"should be infinite stack\");\n+    *idealreg2spillmask[Op_VecA] = *idealreg2regmask[Op_VecA];\n+     idealreg2spillmask[Op_VecA]->OR(scalable_stack_mask);\n@@ -613,1 +613,1 @@\n-    idealreg2spillmask[Op_VecA]->assignFrom(RegMask::EMPTY);\n+    *idealreg2spillmask[Op_VecA] = RegMask::Empty;\n@@ -621,2 +621,2 @@\n-    idealreg2spillmask[Op_RegI]->or_with(*idealreg2regmask[Op_RegF]);\n-    idealreg2spillmask[Op_RegF]->or_with(*idealreg2regmask[Op_RegI]);\n+    idealreg2spillmask[Op_RegI]->OR(*idealreg2regmask[Op_RegF]);\n+    idealreg2spillmask[Op_RegF]->OR(*idealreg2regmask[Op_RegI]);\n@@ -624,4 +624,4 @@\n-    idealreg2spillmask[Op_RegN]->or_with(*idealreg2regmask[Op_RegF]);\n-    idealreg2spillmask[Op_RegL]->or_with(*idealreg2regmask[Op_RegD]);\n-    idealreg2spillmask[Op_RegD]->or_with(*idealreg2regmask[Op_RegL]);\n-    idealreg2spillmask[Op_RegP]->or_with(*idealreg2regmask[Op_RegD]);\n+    idealreg2spillmask[Op_RegN]->OR(*idealreg2regmask[Op_RegF]);\n+    idealreg2spillmask[Op_RegL]->OR(*idealreg2regmask[Op_RegD]);\n+    idealreg2spillmask[Op_RegD]->OR(*idealreg2regmask[Op_RegL]);\n+    idealreg2spillmask[Op_RegP]->OR(*idealreg2regmask[Op_RegD]);\n@@ -629,1 +629,1 @@\n-    idealreg2spillmask[Op_RegP]->or_with(*idealreg2regmask[Op_RegF]);\n+    idealreg2spillmask[Op_RegP]->OR(*idealreg2regmask[Op_RegF]);\n@@ -633,2 +633,2 @@\n-    idealreg2spillmask[Op_RegL]->or_with(*idealreg2regmask[Op_RegD]);\n-    idealreg2spillmask[Op_RegD]->or_with(*idealreg2regmask[Op_RegL]);\n+    idealreg2spillmask[Op_RegL]->OR(*idealreg2regmask[Op_RegD]);\n+    idealreg2spillmask[Op_RegD]->OR(*idealreg2regmask[Op_RegL]);\n@@ -642,14 +642,14 @@\n-  idealreg2debugmask[Op_RegN]->assignFrom(*idealreg2spillmask[Op_RegN]);\n-  idealreg2debugmask[Op_RegI]->assignFrom(*idealreg2spillmask[Op_RegI]);\n-  idealreg2debugmask[Op_RegL]->assignFrom(*idealreg2spillmask[Op_RegL]);\n-  idealreg2debugmask[Op_RegF]->assignFrom(*idealreg2spillmask[Op_RegF]);\n-  idealreg2debugmask[Op_RegD]->assignFrom(*idealreg2spillmask[Op_RegD]);\n-  idealreg2debugmask[Op_RegP]->assignFrom(*idealreg2spillmask[Op_RegP]);\n-  idealreg2debugmask[Op_RegVectMask]->assignFrom(*idealreg2spillmask[Op_RegVectMask]);\n-\n-  idealreg2debugmask[Op_VecA]->assignFrom(*idealreg2spillmask[Op_VecA]);\n-  idealreg2debugmask[Op_VecS]->assignFrom(*idealreg2spillmask[Op_VecS]);\n-  idealreg2debugmask[Op_VecD]->assignFrom(*idealreg2spillmask[Op_VecD]);\n-  idealreg2debugmask[Op_VecX]->assignFrom(*idealreg2spillmask[Op_VecX]);\n-  idealreg2debugmask[Op_VecY]->assignFrom(*idealreg2spillmask[Op_VecY]);\n-  idealreg2debugmask[Op_VecZ]->assignFrom(*idealreg2spillmask[Op_VecZ]);\n+  *idealreg2debugmask  [Op_RegN] = *idealreg2spillmask[Op_RegN];\n+  *idealreg2debugmask  [Op_RegI] = *idealreg2spillmask[Op_RegI];\n+  *idealreg2debugmask  [Op_RegL] = *idealreg2spillmask[Op_RegL];\n+  *idealreg2debugmask  [Op_RegF] = *idealreg2spillmask[Op_RegF];\n+  *idealreg2debugmask  [Op_RegD] = *idealreg2spillmask[Op_RegD];\n+  *idealreg2debugmask  [Op_RegP] = *idealreg2spillmask[Op_RegP];\n+  *idealreg2debugmask  [Op_RegVectMask] = *idealreg2spillmask[Op_RegVectMask];\n+\n+  *idealreg2debugmask  [Op_VecA] = *idealreg2spillmask[Op_VecA];\n+  *idealreg2debugmask  [Op_VecS] = *idealreg2spillmask[Op_VecS];\n+  *idealreg2debugmask  [Op_VecD] = *idealreg2spillmask[Op_VecD];\n+  *idealreg2debugmask  [Op_VecX] = *idealreg2spillmask[Op_VecX];\n+  *idealreg2debugmask  [Op_VecY] = *idealreg2spillmask[Op_VecY];\n+  *idealreg2debugmask  [Op_VecZ] = *idealreg2spillmask[Op_VecZ];\n@@ -662,14 +662,14 @@\n-  idealreg2debugmask[Op_RegN]->subtract(*caller_save_mask);\n-  idealreg2debugmask[Op_RegI]->subtract(*caller_save_mask);\n-  idealreg2debugmask[Op_RegL]->subtract(*caller_save_mask);\n-  idealreg2debugmask[Op_RegF]->subtract(*caller_save_mask);\n-  idealreg2debugmask[Op_RegD]->subtract(*caller_save_mask);\n-  idealreg2debugmask[Op_RegP]->subtract(*caller_save_mask);\n-  idealreg2debugmask[Op_RegVectMask]->subtract(*caller_save_mask);\n-\n-  idealreg2debugmask[Op_VecA]->subtract(*caller_save_mask);\n-  idealreg2debugmask[Op_VecS]->subtract(*caller_save_mask);\n-  idealreg2debugmask[Op_VecD]->subtract(*caller_save_mask);\n-  idealreg2debugmask[Op_VecX]->subtract(*caller_save_mask);\n-  idealreg2debugmask[Op_VecY]->subtract(*caller_save_mask);\n-  idealreg2debugmask[Op_VecZ]->subtract(*caller_save_mask);\n+  idealreg2debugmask[Op_RegN]->SUBTRACT(*caller_save_mask);\n+  idealreg2debugmask[Op_RegI]->SUBTRACT(*caller_save_mask);\n+  idealreg2debugmask[Op_RegL]->SUBTRACT(*caller_save_mask);\n+  idealreg2debugmask[Op_RegF]->SUBTRACT(*caller_save_mask);\n+  idealreg2debugmask[Op_RegD]->SUBTRACT(*caller_save_mask);\n+  idealreg2debugmask[Op_RegP]->SUBTRACT(*caller_save_mask);\n+  idealreg2debugmask[Op_RegVectMask]->SUBTRACT(*caller_save_mask);\n+\n+  idealreg2debugmask[Op_VecA]->SUBTRACT(*caller_save_mask);\n+  idealreg2debugmask[Op_VecS]->SUBTRACT(*caller_save_mask);\n+  idealreg2debugmask[Op_VecD]->SUBTRACT(*caller_save_mask);\n+  idealreg2debugmask[Op_VecX]->SUBTRACT(*caller_save_mask);\n+  idealreg2debugmask[Op_VecY]->SUBTRACT(*caller_save_mask);\n+  idealreg2debugmask[Op_VecZ]->SUBTRACT(*caller_save_mask);\n@@ -705,3 +705,2 @@\n-  if (ret_edge_cnt > TypeFunc::Parms) {\n-    ret_rms[TypeFunc::Parms + 0].assignFrom(_return_value_mask);\n-  }\n+  if (ret_edge_cnt > TypeFunc::Parms)\n+    ret_rms[TypeFunc::Parms+0] = _return_value_mask;\n@@ -719,1 +718,1 @@\n-    reth_rms[TypeFunc::Parms].assignFrom(mreg2regmask[reg]);\n+    reth_rms[TypeFunc::Parms] = mreg2regmask[reg];\n@@ -722,1 +721,1 @@\n-    reth_rms[TypeFunc::Parms].insert(OptoReg::add(OptoReg::Name(reg), 1));\n+    reth_rms[TypeFunc::Parms].Insert(OptoReg::add(OptoReg::Name(reg), 1));\n@@ -741,2 +740,2 @@\n-      tail_call_rms[TypeFunc::Parms + 0].assignFrom(m->MachNode::in_RegMask(TypeFunc::Parms + 0));\n-      tail_call_rms[TypeFunc::Parms + 1].assignFrom(m->MachNode::in_RegMask(TypeFunc::Parms + 1));\n+      tail_call_rms[TypeFunc::Parms+0] = m->MachNode::in_RegMask(TypeFunc::Parms+0);\n+      tail_call_rms[TypeFunc::Parms+1] = m->MachNode::in_RegMask(TypeFunc::Parms+1);\n@@ -754,2 +753,2 @@\n-      tail_jump_rms[TypeFunc::Parms + 0].assignFrom(m->MachNode::in_RegMask(TypeFunc::Parms + 0));\n-      tail_jump_rms[TypeFunc::Parms + 1].assignFrom(m->MachNode::in_RegMask(TypeFunc::Parms + 1));\n+      tail_jump_rms[TypeFunc::Parms+0] = m->MachNode::in_RegMask(TypeFunc::Parms+0);\n+      tail_jump_rms[TypeFunc::Parms+1] = m->MachNode::in_RegMask(TypeFunc::Parms+1);\n@@ -788,5 +787,5 @@\n-      ret_rms      [      ret_edge_cnt].assignFrom(mreg2regmask[i]);\n-      reth_rms     [     reth_edge_cnt].assignFrom(mreg2regmask[i]);\n-      tail_call_rms[tail_call_edge_cnt].assignFrom(mreg2regmask[i]);\n-      tail_jump_rms[tail_jump_edge_cnt].assignFrom(mreg2regmask[i]);\n-      forw_exc_rms [ forw_exc_edge_cnt].assignFrom(mreg2regmask[i]);\n+      ret_rms      [      ret_edge_cnt] = mreg2regmask[i];\n+      reth_rms     [     reth_edge_cnt] = mreg2regmask[i];\n+      tail_call_rms[tail_call_edge_cnt] = mreg2regmask[i];\n+      tail_jump_rms[tail_jump_edge_cnt] = mreg2regmask[i];\n+      forw_exc_rms [ forw_exc_edge_cnt] = mreg2regmask[i];\n@@ -795,1 +794,1 @@\n-      halt_rms     [     halt_edge_cnt].assignFrom(*idealreg2spillmask[_register_save_type[i]]);\n+      halt_rms     [     halt_edge_cnt] = *idealreg2spillmask[_register_save_type[i]];\n@@ -806,6 +805,6 @@\n-        ret_rms      [      ret_edge_cnt].insert(OptoReg::Name(i+1));\n-        reth_rms     [     reth_edge_cnt].insert(OptoReg::Name(i+1));\n-        tail_call_rms[tail_call_edge_cnt].insert(OptoReg::Name(i+1));\n-        tail_jump_rms[tail_jump_edge_cnt].insert(OptoReg::Name(i+1));\n-        forw_exc_rms [ forw_exc_edge_cnt].insert(OptoReg::Name(i+1));\n-        halt_rms     [     halt_edge_cnt].insert(OptoReg::Name(i+1));\n+        ret_rms      [      ret_edge_cnt].Insert(OptoReg::Name(i+1));\n+        reth_rms     [     reth_edge_cnt].Insert(OptoReg::Name(i+1));\n+        tail_call_rms[tail_call_edge_cnt].Insert(OptoReg::Name(i+1));\n+        tail_jump_rms[tail_jump_edge_cnt].Insert(OptoReg::Name(i+1));\n+        forw_exc_rms [ forw_exc_edge_cnt].Insert(OptoReg::Name(i+1));\n+        halt_rms     [     halt_edge_cnt].Insert(OptoReg::Name(i+1));\n@@ -819,6 +818,6 @@\n-        ret_rms      [      ret_edge_cnt].assignFrom(RegMask::EMPTY);\n-        reth_rms     [     reth_edge_cnt].assignFrom(RegMask::EMPTY);\n-        tail_call_rms[tail_call_edge_cnt].assignFrom(RegMask::EMPTY);\n-        tail_jump_rms[tail_jump_edge_cnt].assignFrom(RegMask::EMPTY);\n-        forw_exc_rms [ forw_exc_edge_cnt].assignFrom(RegMask::EMPTY);\n-        halt_rms     [     halt_edge_cnt].assignFrom(RegMask::EMPTY);\n+        ret_rms      [      ret_edge_cnt] = RegMask::Empty;\n+        reth_rms     [     reth_edge_cnt] = RegMask::Empty;\n+        tail_call_rms[tail_call_edge_cnt] = RegMask::Empty;\n+        tail_jump_rms[tail_jump_edge_cnt] = RegMask::Empty;\n+        forw_exc_rms [ forw_exc_edge_cnt] = RegMask::Empty;\n+        halt_rms     [     halt_edge_cnt] = RegMask::Empty;\n@@ -834,6 +833,6 @@\n-        ret_rms      [      ret_edge_cnt].insert(OptoReg::Name(i+1));\n-        reth_rms     [     reth_edge_cnt].insert(OptoReg::Name(i+1));\n-        tail_call_rms[tail_call_edge_cnt].insert(OptoReg::Name(i+1));\n-        tail_jump_rms[tail_jump_edge_cnt].insert(OptoReg::Name(i+1));\n-        forw_exc_rms [ forw_exc_edge_cnt].insert(OptoReg::Name(i+1));\n-        halt_rms     [     halt_edge_cnt].insert(OptoReg::Name(i+1));\n+        ret_rms      [      ret_edge_cnt].Insert(OptoReg::Name(i+1));\n+        reth_rms     [     reth_edge_cnt].Insert(OptoReg::Name(i+1));\n+        tail_call_rms[tail_call_edge_cnt].Insert(OptoReg::Name(i+1));\n+        tail_jump_rms[tail_jump_edge_cnt].Insert(OptoReg::Name(i+1));\n+        forw_exc_rms [ forw_exc_edge_cnt].Insert(OptoReg::Name(i+1));\n+        halt_rms     [     halt_edge_cnt].Insert(OptoReg::Name(i+1));\n@@ -847,6 +846,6 @@\n-        ret_rms      [      ret_edge_cnt].assignFrom(RegMask::EMPTY);\n-        reth_rms     [     reth_edge_cnt].assignFrom(RegMask::EMPTY);\n-        tail_call_rms[tail_call_edge_cnt].assignFrom(RegMask::EMPTY);\n-        tail_jump_rms[tail_jump_edge_cnt].assignFrom(RegMask::EMPTY);\n-        forw_exc_rms [ forw_exc_edge_cnt].assignFrom(RegMask::EMPTY);\n-        halt_rms     [     halt_edge_cnt].assignFrom(RegMask::EMPTY);\n+        ret_rms      [      ret_edge_cnt] = RegMask::Empty;\n+        reth_rms     [     reth_edge_cnt] = RegMask::Empty;\n+        tail_call_rms[tail_call_edge_cnt] = RegMask::Empty;\n+        tail_jump_rms[tail_jump_edge_cnt] = RegMask::Empty;\n+        forw_exc_rms [ forw_exc_edge_cnt] = RegMask::Empty;\n+        halt_rms     [     halt_edge_cnt] = RegMask::Empty;\n@@ -879,1 +878,1 @@\n-  c_frame_ptr_mask.assignFrom(RegMask(c_frame_pointer()));\n+  c_frame_ptr_mask = RegMask(c_frame_pointer());\n@@ -882,1 +881,1 @@\n-  c_frame_ptr_mask.insert(OptoReg::add(c_frame_pointer(), 1));\n+  c_frame_ptr_mask.Insert(OptoReg::add(c_frame_pointer(),1));\n@@ -886,1 +885,1 @@\n-  STACK_ONLY_mask.clear();\n+  STACK_ONLY_mask.Clear();\n@@ -888,1 +887,1 @@\n-  STACK_ONLY_mask.set_all_from(OptoReg::stack2reg(0));\n+  STACK_ONLY_mask.Set_All_From(OptoReg::stack2reg(0));\n@@ -895,1 +894,1 @@\n-    mreg2regmask[i].insert(i);\n+    mreg2regmask[i].Insert(i);\n@@ -900,1 +899,1 @@\n-      caller_save_regmask.insert(i);\n+      caller_save_regmask.Insert(i);\n@@ -906,1 +905,1 @@\n-      caller_save_regmask_exclude_soe.insert(i);\n+      caller_save_regmask_exclude_soe.Insert(i);\n@@ -1244,2 +1243,2 @@\n-  msfpt->_in_rms[TypeFunc::ReturnAdr].assignFrom(_return_addr_mask);\n-  msfpt->_in_rms[TypeFunc::FramePtr ].assignFrom(c_frame_ptr_mask);\n+  msfpt->_in_rms[TypeFunc::ReturnAdr] = _return_addr_mask;\n+  msfpt->_in_rms[TypeFunc::FramePtr ] = c_frame_ptr_mask;\n@@ -1319,1 +1318,1 @@\n-          rm->insert(r);\n+          rm->Insert(r);\n@@ -1325,1 +1324,1 @@\n-        rm->insert(reg1);\n+        rm->Insert( reg1 );\n@@ -1329,1 +1328,1 @@\n-        rm->insert(reg2);\n+        rm->Insert( reg2 );\n@@ -1346,1 +1345,1 @@\n-    MachProjNode* proj = new MachProjNode(mcall, r_cnt + 10000, RegMask::EMPTY, MachProjNode::fat_proj);\n+    MachProjNode *proj = new MachProjNode( mcall, r_cnt+10000, RegMask::Empty, MachProjNode::fat_proj );\n@@ -1348,1 +1347,1 @@\n-      proj->_rout.insert(OptoReg::Name(i));\n+      proj->_rout.Insert(OptoReg::Name(i));\n@@ -1350,1 +1349,1 @@\n-    if (!proj->_rout.is_empty()) {\n+    if (!proj->_rout.is_Empty()) {\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":155,"deletions":156,"binary":false,"changes":311,"status":"modified"},{"patch":"@@ -411,1 +411,1 @@\n-  static const RegMask& divI_proj_mask();\n+  static RegMask divI_proj_mask();\n@@ -413,1 +413,1 @@\n-  static const RegMask& modI_proj_mask();\n+  static RegMask modI_proj_mask();\n@@ -416,1 +416,1 @@\n-  static const RegMask& divL_proj_mask();\n+  static RegMask divL_proj_mask();\n@@ -418,1 +418,1 @@\n-  static const RegMask& modL_proj_mask();\n+  static RegMask modL_proj_mask();\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4328,1 +4328,1 @@\n-    return new MachProjNode(this, proj->_con, RegMask::EMPTY, MachProjNode::unmatched_proj);\n+    return new MachProjNode(this,proj->_con,RegMask::Empty,MachProjNode::unmatched_proj);\n@@ -4575,1 +4575,1 @@\n-  return RegMask::EMPTY;\n+  return RegMask::Empty;\n@@ -5787,1 +5787,1 @@\n-  return RegMask::EMPTY;\n+  return RegMask::Empty;\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-    if (!scaleI.is_zero() && !scaleL.is_zero()) {\n+    if (!scaleI.is_zero() && !scaleL.is_NaN()) {\n","filename":"src\/hotspot\/share\/opto\/mempointer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -966,1 +966,1 @@\n-static bool mask_shift_amount(PhaseGVN* phase, const Node* shift_node, uint nBits, int& real_shift, uint& masked_shift) {\n+static bool mask_shift_amount(PhaseGVN* phase, const Node* shift_node, uint nBits, int& real_shift, int& masked_shift) {\n@@ -975,1 +975,1 @@\n-static bool mask_shift_amount(PhaseGVN* phase, const Node* shift_node, uint nBits, uint& masked_shift) {\n+static bool mask_shift_amount(PhaseGVN* phase, const Node* shift_node, uint nBits, int& masked_shift) {\n@@ -982,1 +982,1 @@\n-static uint mask_and_replace_shift_amount(PhaseGVN* phase, Node* shift_node, uint nBits) {\n+static int mask_and_replace_shift_amount(PhaseGVN* phase, Node* shift_node, uint nBits) {\n@@ -984,1 +984,1 @@\n-  uint masked_shift;\n+  int masked_shift;\n@@ -991,1 +991,1 @@\n-    if (real_shift != (int)masked_shift) {\n+    if (real_shift != masked_shift) {\n@@ -1016,1 +1016,1 @@\n-static Node* collapse_nested_shift_left(PhaseGVN* phase, const Node* outer_shift, uint con_outer, BasicType bt) {\n+static Node* collapse_nested_shift_left(PhaseGVN* phase, const Node* outer_shift, int con_outer, BasicType bt) {\n@@ -1023,2 +1023,2 @@\n-  uint nbits = bits_per_java_integer(bt);\n-  uint con_inner;\n+  int nbits = static_cast<int>(bits_per_java_integer(bt));\n+  int con_inner;\n@@ -1049,1 +1049,6 @@\n-  return IdentityIL(phase, T_INT);\n+  int count = 0;\n+  if (const_shift_count(phase, this, &count) && (count & (BitsPerJavaInteger - 1)) == 0) {\n+    \/\/ Shift by a multiple of 32 does nothing\n+    return in(1);\n+  }\n+  return this;\n@@ -1052,2 +1057,8 @@\n-Node* LShiftNode::IdealIL(PhaseGVN* phase, bool can_reshape, BasicType bt) {\n-  uint con = mask_and_replace_shift_amount(phase, this, bits_per_java_integer(bt));\n+\/\/------------------------------Ideal------------------------------------------\n+\/\/ If the right input is a constant, and the left input is an add of a\n+\/\/ constant, flatten the tree: (X+con1)<<con0 ==> X<<con0 + con1<<con0\n+\/\/\n+\/\/ Also collapse nested left-shifts with constant rhs:\n+\/\/ (X << con1) << con2 ==> X << (con1 + con2)\n+Node *LShiftINode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+  int con = mask_and_replace_shift_amount(phase, this, BitsPerJavaInteger);\n@@ -1058,3 +1069,2 @@\n-  \/\/ If the right input is a constant, and the left input is an add of a\n-  \/\/ constant, flatten the tree: (X+con1)<<con0 ==> X<<con0 + con1<<con0\n-  Node* add1 = in(1);\n+  \/\/ Left input is an add?\n+  Node *add1 = in(1);\n@@ -1062,2 +1072,2 @@\n-  if (add1_op == Op_Add(bt)) {    \/\/ Left input is an add?\n-    assert(add1 != add1->in(1), \"dead loop in LShiftINode::Ideal\");\n+  if( add1_op == Op_AddI ) {    \/\/ Left input is an add?\n+    assert( add1 != add1->in(1), \"dead loop in LShiftINode::Ideal\" );\n@@ -1067,1 +1077,1 @@\n-    if (bt != T_INT || con < 16) {\n+    if( con < 16 ) {\n@@ -1069,1 +1079,1 @@\n-      if (con != (bits_per_java_integer(bt) - 1) && add1->in(1) == add1->in(2)) {\n+      if (add1->in(1) == add1->in(2)) {\n@@ -1071,1 +1081,1 @@\n-        \/\/ In general, this optimization cannot be applied for c0 == 31 (for LShiftI) since\n+        \/\/ In general, this optimization cannot be applied for c0 == 31 since\n@@ -1073,6 +1083,1 @@\n-        \/\/ or c0 != 63 (for LShiftL) because:\n-        \/\/ (x + x) << 63 = 2x << 63, while\n-        \/\/ (x + x) << 63 --transform--> x << 64 = x << 0 = x (!= 2x << 63, for example for x = 1)\n-        \/\/ According to the Java spec, chapter 15.19, we only consider the six lowest-order bits of the right-hand operand\n-        \/\/ (i.e. \"right-hand operand\" & 0b111111). Therefore, x << 64 is the same as x << 0 (64 = 0b10000000 & 0b0111111 = 0).\n-        return LShiftNode::make(add1->in(1), phase->intcon(con + 1), bt);\n+        return new LShiftINode(add1->in(1), phase->intcon(con + 1));\n@@ -1082,2 +1087,2 @@\n-      const TypeInteger* t12 = phase->type(add1->in(2))->isa_integer(bt);\n-      if (t12 != nullptr && t12->is_con()) { \/\/ Left input is an add of a con?\n+      const TypeInt *t12 = phase->type(add1->in(2))->isa_int();\n+      if( t12 && t12->is_con() ){ \/\/ Left input is an add of a con?\n@@ -1085,1 +1090,1 @@\n-        Node* lsh = phase->transform(LShiftNode::make(add1->in(1), in(2), bt));\n+        Node *lsh = phase->transform( new LShiftINode( add1->in(1), in(2) ) );\n@@ -1087,1 +1092,1 @@\n-        return AddNode::make(lsh, phase->integercon(java_shift_left(t12->get_con_as_long(bt), con, bt), bt), bt);\n+        return new AddINode( lsh, phase->intcon(t12->get_con() << con));\n@@ -1093,1 +1098,1 @@\n-  if (add1_op == Op_RShift(bt) || add1_op == Op_URShift(bt)) {\n+  if (add1_op == Op_RShiftI || add1_op == Op_URShiftI) {\n@@ -1098,1 +1103,1 @@\n-    if (add1Con > 0 && con == (uint)add1Con) {\n+    if (add1Con > 0 && con == add1Con) {\n@@ -1100,1 +1105,1 @@\n-      return  MulNode::make_and(add1->in(1), phase->integercon(java_negate(java_shift_left(1, con, bt), bt), bt), bt);\n+      return new AndINode(add1->in(1), phase->intcon(java_negate(jint(1 << con))));\n@@ -1103,1 +1108,1 @@\n-      if (add1Con > 0 && (uint)add1Con < bits_per_java_integer(bt)) {\n+      if (add1Con > 0 && add1Con < BitsPerJavaInteger) {\n@@ -1107,1 +1112,1 @@\n-          if (con > (uint)add1Con) {\n+          if (con > add1Con) {\n@@ -1109,2 +1114,2 @@\n-            Node* lshift = phase->transform(LShiftNode::make(add1->in(1), phase->intcon(con - add1Con), bt));\n-            return MulNode::make_and(lshift, phase->integercon(java_negate(java_shift_left(1, con, bt), bt), bt), bt);\n+            Node* lshift = phase->transform(new LShiftINode(add1->in(1), phase->intcon(con - add1Con)));\n+            return new AndINode(lshift, phase->intcon(java_negate(jint(1 << con))));\n@@ -1112,1 +1117,1 @@\n-            assert(con < (uint)add1Con, \"must be (%d < %d)\", con, add1Con);\n+            assert(con < add1Con, \"must be (%d < %d)\", con, add1Con);\n@@ -1117,2 +1122,2 @@\n-            if (add1_op == Op_RShift(bt)) {\n-              rshift = phase->transform(RShiftNode::make(add1->in(1), phase->intcon(add1Con - con), bt));\n+            if (add1_op == Op_RShiftI) {\n+              rshift = phase->transform(new RShiftINode(add1->in(1), phase->intcon(add1Con - con)));\n@@ -1120,1 +1125,1 @@\n-              rshift = phase->transform(URShiftNode::make(add1->in(1), phase->intcon(add1Con - con), bt));\n+              rshift = phase->transform(new URShiftINode(add1->in(1), phase->intcon(add1Con - con)));\n@@ -1123,1 +1128,1 @@\n-            return MulNode::make_and(rshift, phase->integercon(java_negate(java_shift_left(1,  con, bt)), bt), bt);\n+            return new AndINode(rshift, phase->intcon(java_negate(jint(1 << con))));\n@@ -1133,2 +1138,2 @@\n-  if (add1_op == Op_And(bt)) {\n-    Node* add2 = add1->in(1);\n+  if (add1_op == Op_AndI) {\n+    Node *add2 = add1->in(1);\n@@ -1136,1 +1141,1 @@\n-    if (add2_op == Op_RShift(bt) || add2_op == Op_URShift(bt)) {\n+    if (add2_op == Op_RShiftI || add2_op == Op_URShiftI) {\n@@ -1140,2 +1145,2 @@\n-        Node* y_sh = phase->transform(LShiftNode::make(add1->in(2), phase->intcon(con), bt));\n-        return MulNode::make_and(add2->in(1), y_sh, bt);\n+        Node* y_sh = phase->transform(new LShiftINode(add1->in(2), phase->intcon(con)));\n+        return new AndINode(add2->in(1), y_sh);\n@@ -1146,1 +1151,1 @@\n-      if (add2Con > 0 && (uint)add2Con < bits_per_java_integer(bt)) {\n+      if (add2Con > 0 && add2Con < BitsPerJavaInteger) {\n@@ -1151,1 +1156,1 @@\n-          Node* x_sh = phase->transform(LShiftNode::make(add2, phase->intcon(con), bt));\n+          Node* x_sh = phase->transform(new LShiftINode(add2, phase->intcon(con)));\n@@ -1153,1 +1158,1 @@\n-          Node* y_sh = phase->transform(LShiftNode::make(add1->in(2), phase->intcon(con), bt));\n+          Node* y_sh = phase->transform(new LShiftINode(add1->in(2), phase->intcon(con)));\n@@ -1155,1 +1160,1 @@\n-          return MulNode::make_and(x_sh, y_sh, bt);\n+          return new AndINode(x_sh, y_sh);\n@@ -1165,6 +1170,4 @@\n-  const jlong bits_mask = max_unsigned_integer(bt) >> con;\n-  assert(bt != T_INT || bits_mask == right_n_bits(bits_per_java_integer(bt)-con), \"inconsistent\");\n-  if (add1_op == Op_And(bt) &&\n-      phase->type(add1->in(2)) == TypeInteger::make(bits_mask, bt)) {\n-    return LShiftNode::make(add1->in(1), in(2), bt);\n-  }\n+  const jint bits_mask = right_n_bits(BitsPerJavaInteger-con);\n+  if( add1_op == Op_AndI &&\n+      phase->type(add1->in(2)) == TypeInt::make( bits_mask ) )\n+    return new LShiftINode( add1->in(1), in(2) );\n@@ -1172,1 +1175,1 @@\n-  \/\/ Collapse nested left-shifts with constant rhs:\n+  \/\/ Performs:\n@@ -1174,1 +1177,1 @@\n-  Node* doubleShift = collapse_nested_shift_left(phase, this, con, bt);\n+  Node* doubleShift = collapse_nested_shift_left(phase, this, con, T_INT);\n@@ -1182,8 +1185,5 @@\n-\/\/------------------------------Ideal------------------------------------------\n-Node* LShiftINode::Ideal(PhaseGVN *phase, bool can_reshape) {\n-  return IdealIL(phase, can_reshape, T_INT);\n-}\n-\n-const Type* LShiftNode::ValueIL(PhaseGVN* phase, BasicType bt) const {\n-  const Type* t1 = phase->type(in(1));\n-  const Type* t2 = phase->type(in(2));\n+\/\/------------------------------Value------------------------------------------\n+\/\/ A LShiftINode shifts its input2 left by input1 amount.\n+const Type* LShiftINode::Value(PhaseGVN* phase) const {\n+  const Type *t1 = phase->type( in(1) );\n+  const Type *t2 = phase->type( in(2) );\n@@ -1191,6 +1191,2 @@\n-  if (t1 == Type::TOP) {\n-    return Type::TOP;\n-  }\n-  if (t2 == Type::TOP) {\n-    return Type::TOP;\n-  }\n+  if( t1 == Type::TOP ) return Type::TOP;\n+  if( t2 == Type::TOP ) return Type::TOP;\n@@ -1199,3 +1195,1 @@\n-  if (t1 == TypeInteger::zero(bt)) {\n-    return TypeInteger::zero(bt);\n-  }\n+  if( t1 == TypeInt::ZERO ) return TypeInt::ZERO;\n@@ -1203,3 +1197,1 @@\n-  if (t2 == TypeInt::ZERO) {\n-    return t1;\n-  }\n+  if( t2 == TypeInt::ZERO ) return t1;\n@@ -1208,4 +1200,3 @@\n-  if ((t1 == TypeInteger::bottom(bt)) || (t2 == TypeInt::INT) ||\n-      (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM)) {\n-    return TypeInteger::bottom(bt);\n-  }\n+  if( (t1 == TypeInt::INT) || (t2 == TypeInt::INT) ||\n+      (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )\n+    return TypeInt::INT;\n@@ -1213,2 +1204,2 @@\n-  const TypeInteger* r1 = t1->is_integer(bt); \/\/ Handy access\n-  const TypeInt* r2 = t2->is_int(); \/\/ Handy access\n+  const TypeInt *r1 = t1->is_int(); \/\/ Handy access\n+  const TypeInt *r2 = t2->is_int(); \/\/ Handy access\n@@ -1216,3 +1207,2 @@\n-  if (!r2->is_con()) {\n-    return TypeInteger::bottom(bt);\n-  }\n+  if (!r2->is_con())\n+    return TypeInt::INT;\n@@ -1221,5 +1211,3 @@\n-  shift &= bits_per_java_integer(bt) - 1;  \/\/ semantics of Java shifts\n-  \/\/ Shift by a multiple of 32\/64 does nothing:\n-  if (shift == 0) {\n-    return t1;\n-  }\n+  shift &= BitsPerJavaInteger-1;  \/\/ semantics of Java shifts\n+  \/\/ Shift by a multiple of 32 does nothing:\n+  if (shift == 0)  return t1;\n@@ -1230,10 +1218,3 @@\n-    jlong lo = r1->lo_as_long(), hi = r1->hi_as_long();\n-#ifdef ASSERT\n-    if (bt == T_INT) {\n-      jint lo_int = r1->is_int()->_lo, hi_int = r1->is_int()->_hi;\n-      assert((java_shift_right(java_shift_left(lo, shift, bt),  shift, bt) == lo) == (((lo_int << shift) >> shift) == lo_int), \"inconsistent\");\n-      assert((java_shift_right(java_shift_left(hi, shift, bt),  shift, bt) == hi) == (((hi_int << shift) >> shift) == hi_int), \"inconsistent\");\n-    }\n-#endif\n-    if (java_shift_right(java_shift_left(lo, shift, bt),  shift, bt) == lo &&\n-        java_shift_right(java_shift_left(hi, shift, bt), shift, bt) == hi) {\n+    jint lo = r1->_lo, hi = r1->_hi;\n+    if (((lo << shift) >> shift) == lo &&\n+        ((hi << shift) >> shift) == hi) {\n@@ -1241,3 +1222,3 @@\n-      return TypeInteger::make(java_shift_left(lo, shift, bt),\n-                               java_shift_left(hi,  shift, bt),\n-                               MAX2(r1->_widen, r2->_widen), bt);\n+      return TypeInt::make((jint)lo << (jint)shift,\n+                           (jint)hi << (jint)shift,\n+                           MAX2(r1->_widen,r2->_widen));\n@@ -1245,1 +1226,1 @@\n-    return TypeInteger::bottom(bt);\n+    return TypeInt::INT;\n@@ -1248,6 +1229,1 @@\n-  return TypeInteger::make(java_shift_left(r1->get_con_as_long(bt), shift, bt), bt);\n-}\n-\n-\/\/------------------------------Value------------------------------------------\n-const Type* LShiftINode::Value(PhaseGVN* phase) const {\n-  return ValueIL(phase, T_INT);\n+  return TypeInt::make( (jint)r1->get_con() << (jint)shift );\n@@ -1256,1 +1232,3 @@\n-Node* LShiftNode::IdentityIL(PhaseGVN* phase, BasicType bt) {\n+\/\/=============================================================================\n+\/\/------------------------------Identity---------------------------------------\n+Node* LShiftLNode::Identity(PhaseGVN* phase) {\n@@ -1258,2 +1236,2 @@\n-  if (const_shift_count(phase, this, &count) && (count & (bits_per_java_integer(bt) - 1)) == 0) {\n-    \/\/ Shift by a multiple of 32\/64 does nothing\n+  if (const_shift_count(phase, this, &count) && (count & (BitsPerJavaLong - 1)) == 0) {\n+    \/\/ Shift by a multiple of 64 does nothing\n@@ -1265,6 +1243,0 @@\n-\/\/=============================================================================\n-\/\/------------------------------Identity---------------------------------------\n-Node* LShiftLNode::Identity(PhaseGVN* phase) {\n-  return IdentityIL(phase, T_LONG);\n-}\n-\n@@ -1272,2 +1244,125 @@\n-Node* LShiftLNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n-  return IdealIL(phase, can_reshape, T_LONG);\n+\/\/ If the right input is a constant, and the left input is an add of a\n+\/\/ constant, flatten the tree: (X+con1)<<con0 ==> X<<con0 + con1<<con0\n+\/\/\n+\/\/ Also collapse nested left-shifts with constant rhs:\n+\/\/ (X << con1) << con2 ==> X << (con1 + con2)\n+Node *LShiftLNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+  int con = mask_and_replace_shift_amount(phase, this, BitsPerJavaLong);\n+  if (con == 0) {\n+    return nullptr;\n+  }\n+\n+  \/\/ Left input is an add?\n+  Node *add1 = in(1);\n+  int add1_op = add1->Opcode();\n+  if( add1_op == Op_AddL ) {    \/\/ Left input is an add?\n+    \/\/ Avoid dead data cycles from dead loops\n+    assert( add1 != add1->in(1), \"dead loop in LShiftLNode::Ideal\" );\n+\n+    \/\/ Left input is an add of the same number?\n+    if (con != (BitsPerJavaLong - 1) && add1->in(1) == add1->in(2)) {\n+      \/\/ Convert \"(x + x) << c0\" into \"x << (c0 + 1)\"\n+      \/\/ Can only be applied if c0 != 63 because:\n+      \/\/ (x + x) << 63 = 2x << 63, while\n+      \/\/ (x + x) << 63 --transform--> x << 64 = x << 0 = x (!= 2x << 63, for example for x = 1)\n+      \/\/ According to the Java spec, chapter 15.19, we only consider the six lowest-order bits of the right-hand operand\n+      \/\/ (i.e. \"right-hand operand\" & 0b111111). Therefore, x << 64 is the same as x << 0 (64 = 0b10000000 & 0b0111111 = 0).\n+      return new LShiftLNode(add1->in(1), phase->intcon(con + 1));\n+    }\n+\n+    \/\/ Left input is an add of a constant?\n+    const TypeLong *t12 = phase->type(add1->in(2))->isa_long();\n+    if( t12 && t12->is_con() ){ \/\/ Left input is an add of a con?\n+      \/\/ Compute X << con0\n+      Node *lsh = phase->transform( new LShiftLNode( add1->in(1), in(2) ) );\n+      \/\/ Compute X<<con0 + (con1<<con0)\n+      return new AddLNode( lsh, phase->longcon(t12->get_con() << con));\n+    }\n+  }\n+\n+  \/\/ Check for \"(x >> C1) << C2\"\n+  if (add1_op == Op_RShiftL || add1_op == Op_URShiftL) {\n+    int add1Con = 0;\n+    const_shift_count(phase, add1, &add1Con);\n+\n+    \/\/ Special case C1 == C2, which just masks off low bits\n+    if (add1Con > 0 && con == add1Con) {\n+      \/\/ Convert to \"(x & -(1 << C2))\"\n+      return new AndLNode(add1->in(1), phase->longcon(java_negate(jlong(CONST64(1) << con))));\n+    } else {\n+      \/\/ Wait until the right shift has been sharpened to the correct count\n+      if (add1Con > 0 && add1Con < BitsPerJavaLong) {\n+        \/\/ As loop parsing can produce LShiftI nodes, we should wait until the graph is fully formed\n+        \/\/ to apply optimizations, otherwise we can inadvertently stop vectorization opportunities.\n+        if (phase->is_IterGVN()) {\n+          if (con > add1Con) {\n+            \/\/ Creates \"(x << (C2 - C1)) & -(1 << C2)\"\n+            Node* lshift = phase->transform(new LShiftLNode(add1->in(1), phase->intcon(con - add1Con)));\n+            return new AndLNode(lshift, phase->longcon(java_negate(jlong(CONST64(1) << con))));\n+          } else {\n+            assert(con < add1Con, \"must be (%d < %d)\", con, add1Con);\n+            \/\/ Creates \"(x >> (C1 - C2)) & -(1 << C2)\"\n+\n+            \/\/ Handle logical and arithmetic shifts\n+            Node* rshift;\n+            if (add1_op == Op_RShiftL) {\n+              rshift = phase->transform(new RShiftLNode(add1->in(1), phase->intcon(add1Con - con)));\n+            } else {\n+              rshift = phase->transform(new URShiftLNode(add1->in(1), phase->intcon(add1Con - con)));\n+            }\n+\n+            return new AndLNode(rshift, phase->longcon(java_negate(jlong(CONST64(1) << con))));\n+          }\n+        } else {\n+          phase->record_for_igvn(this);\n+        }\n+      }\n+    }\n+  }\n+\n+  \/\/ Check for \"((x >> C1) & Y) << C2\"\n+  if (add1_op == Op_AndL) {\n+    Node* add2 = add1->in(1);\n+    int add2_op = add2->Opcode();\n+    if (add2_op == Op_RShiftL || add2_op == Op_URShiftL) {\n+      \/\/ Special case C1 == C2, which just masks off low bits\n+      if (add2->in(2) == in(2)) {\n+        \/\/ Convert to \"(x & (Y << C2))\"\n+        Node* y_sh = phase->transform(new LShiftLNode(add1->in(2), phase->intcon(con)));\n+        return new AndLNode(add2->in(1), y_sh);\n+      }\n+\n+      int add2Con = 0;\n+      const_shift_count(phase, add2, &add2Con);\n+      if (add2Con > 0 && add2Con < BitsPerJavaLong) {\n+        if (phase->is_IterGVN()) {\n+          \/\/ Convert to \"((x >> C1) << C2) & (Y << C2)\"\n+\n+          \/\/ Make \"(x >> C1) << C2\", which will get folded away by the rule above\n+          Node* x_sh = phase->transform(new LShiftLNode(add2, phase->intcon(con)));\n+          \/\/ Make \"Y << C2\", which will simplify when Y is a constant\n+          Node* y_sh = phase->transform(new LShiftLNode(add1->in(2), phase->intcon(con)));\n+\n+          return new AndLNode(x_sh, y_sh);\n+        } else {\n+          phase->record_for_igvn(this);\n+        }\n+      }\n+    }\n+  }\n+\n+  \/\/ Check for ((x & ((CONST64(1)<<(64-c0))-1)) << c0) which ANDs off high bits\n+  \/\/ before shifting them away.\n+  const jlong bits_mask = jlong(max_julong >> con);\n+  if( add1_op == Op_AndL &&\n+      phase->type(add1->in(2)) == TypeLong::make( bits_mask ) )\n+    return new LShiftLNode( add1->in(1), in(2) );\n+\n+  \/\/ Performs:\n+  \/\/ (X << con1) << con2 ==> X << (con1 + con2)\n+  Node* doubleShift = collapse_nested_shift_left(phase, this, con, T_LONG);\n+  if (doubleShift != nullptr) {\n+    return doubleShift;\n+  }\n+\n+  return nullptr;\n@@ -1277,0 +1372,1 @@\n+\/\/ A LShiftLNode shifts its input2 left by input1 amount.\n@@ -1278,1 +1374,42 @@\n-  return ValueIL(phase, T_LONG);\n+  const Type *t1 = phase->type( in(1) );\n+  const Type *t2 = phase->type( in(2) );\n+  \/\/ Either input is TOP ==> the result is TOP\n+  if( t1 == Type::TOP ) return Type::TOP;\n+  if( t2 == Type::TOP ) return Type::TOP;\n+\n+  \/\/ Left input is ZERO ==> the result is ZERO.\n+  if( t1 == TypeLong::ZERO ) return TypeLong::ZERO;\n+  \/\/ Shift by zero does nothing\n+  if( t2 == TypeInt::ZERO ) return t1;\n+\n+  \/\/ Either input is BOTTOM ==> the result is BOTTOM\n+  if( (t1 == TypeLong::LONG) || (t2 == TypeInt::INT) ||\n+      (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )\n+    return TypeLong::LONG;\n+\n+  const TypeLong *r1 = t1->is_long(); \/\/ Handy access\n+  const TypeInt  *r2 = t2->is_int();  \/\/ Handy access\n+\n+  if (!r2->is_con())\n+    return TypeLong::LONG;\n+\n+  uint shift = r2->get_con();\n+  shift &= BitsPerJavaLong - 1;  \/\/ semantics of Java shifts\n+  \/\/ Shift by a multiple of 64 does nothing:\n+  if (shift == 0)  return t1;\n+\n+  \/\/ If the shift is a constant, shift the bounds of the type,\n+  \/\/ unless this could lead to an overflow.\n+  if (!r1->is_con()) {\n+    jlong lo = r1->_lo, hi = r1->_hi;\n+    if (((lo << shift) >> shift) == lo &&\n+        ((hi << shift) >> shift) == hi) {\n+      \/\/ No overflow.  The range shifts up cleanly.\n+      return TypeLong::make((jlong)lo << (jint)shift,\n+                            (jlong)hi << (jint)shift,\n+                            MAX2(r1->_widen,r2->_widen));\n+    }\n+    return TypeLong::LONG;\n+  }\n+\n+  return TypeLong::make( (jlong)r1->get_con() << (jint)shift );\n@@ -1515,12 +1652,0 @@\n-URShiftNode* URShiftNode::make(Node* in1, Node* in2, BasicType bt) {\n-  switch (bt) {\n-    case T_INT:\n-      return new URShiftINode(in1, in2);\n-    case T_LONG:\n-      return new URShiftLNode(in1, in2);\n-    default:\n-      fatal(\"Not implemented for %s\", type2name(bt));\n-  }\n-  return nullptr;\n-}\n-\n@@ -1562,1 +1687,1 @@\n-Node* URShiftINode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+Node *URShiftINode::Ideal(PhaseGVN *phase, bool can_reshape) {\n@@ -1726,1 +1851,1 @@\n-Node* URShiftLNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+Node *URShiftLNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":263,"deletions":138,"binary":false,"changes":401,"status":"modified"},{"patch":"@@ -263,1 +263,1 @@\n-  LShiftNode(Node* in1, Node* in2) : Node(nullptr,in1,in2) {\n+  LShiftNode(Node *in1, Node *in2) : Node(nullptr,in1,in2) {\n@@ -267,4 +267,0 @@\n-  const Type* ValueIL(PhaseGVN* phase, BasicType bt) const;\n-  Node* IdentityIL(PhaseGVN* phase, BasicType bt);\n-  Node* IdealIL(PhaseGVN* phase, bool can_reshape, BasicType bt);\n-\n@@ -278,1 +274,1 @@\n-  LShiftINode(Node* in1, Node* in2) : LShiftNode(in1,in2) {}\n+  LShiftINode(Node *in1, Node *in2) : LShiftNode(in1,in2) {}\n@@ -281,1 +277,1 @@\n-  virtual Node* Ideal(PhaseGVN *phase, bool can_reshape);\n+  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n@@ -283,1 +279,1 @@\n-  const Type* bottom_type() const { return TypeInt::INT; }\n+  const Type *bottom_type() const { return TypeInt::INT; }\n@@ -294,1 +290,1 @@\n-  virtual Node* Ideal(PhaseGVN *phase, bool can_reshape);\n+  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n@@ -296,1 +292,1 @@\n-  const Type* bottom_type() const { return TypeLong::LONG; }\n+  const Type *bottom_type() const { return TypeLong::LONG; }\n@@ -365,6 +361,0 @@\n-class URShiftNode : public Node {\n-public:\n-  URShiftNode(Node* in1, Node* in2) : Node(nullptr, in1, in2) {}\n-  static URShiftNode* make(Node* in1, Node* in2, BasicType bt);\n-};\n-\n@@ -373,1 +363,1 @@\n-class URShiftBNode : public URShiftNode {\n+class URShiftBNode : public Node {\n@@ -375,1 +365,1 @@\n-  URShiftBNode(Node* in1, Node* in2) : URShiftNode(in1,in2) {\n+  URShiftBNode( Node *in1, Node *in2 ) : Node(nullptr,in1,in2) {\n@@ -383,1 +373,1 @@\n-class URShiftSNode : public URShiftNode {\n+class URShiftSNode : public Node {\n@@ -385,1 +375,1 @@\n-  URShiftSNode(Node* in1, Node* in2) : URShiftNode(in1,in2) {\n+  URShiftSNode( Node *in1, Node *in2 ) : Node(nullptr,in1,in2) {\n@@ -393,1 +383,1 @@\n-class URShiftINode : public URShiftNode {\n+class URShiftINode : public Node {\n@@ -395,1 +385,1 @@\n-  URShiftINode(Node* in1, Node* in2) : URShiftNode(in1,in2) {}\n+  URShiftINode( Node *in1, Node *in2 ) : Node(nullptr,in1,in2) {}\n@@ -398,1 +388,1 @@\n-  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n@@ -400,1 +390,1 @@\n-  const Type* bottom_type() const { return TypeInt::INT; }\n+  const Type *bottom_type() const { return TypeInt::INT; }\n@@ -406,1 +396,1 @@\n-class URShiftLNode : public URShiftNode {\n+class URShiftLNode : public Node {\n@@ -408,1 +398,1 @@\n-  URShiftLNode(Node* in1, Node* in2) : URShiftNode(in1,in2) {}\n+  URShiftLNode( Node *in1, Node *in2 ) : Node(nullptr,in1,in2) {}\n@@ -411,1 +401,1 @@\n-  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n@@ -413,1 +403,1 @@\n-  const Type* bottom_type() const { return TypeLong::LONG; }\n+  const Type *bottom_type() const { return TypeLong::LONG; }\n","filename":"src\/hotspot\/share\/opto\/mulnode.hpp","additions":18,"deletions":28,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-  return RegMask::EMPTY;\n+  return RegMask::Empty;\n@@ -188,1 +188,1 @@\n-  return RegMask::EMPTY;\n+  return RegMask::Empty;\n","filename":"src\/hotspot\/share\/opto\/multnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2803,1 +2803,1 @@\n-  return RegMask::EMPTY;\n+  return RegMask::Empty;\n@@ -2808,1 +2808,1 @@\n-  return RegMask::EMPTY;\n+  return RegMask::Empty;\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2089,1 +2089,0 @@\n-Op_IL(RShift)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -176,1 +176,1 @@\n-  bool can_use = use_mask.member(def_reg);\n+  bool can_use = use_mask.Member(def_reg);\n@@ -681,1 +681,1 @@\n-              bool is_adjacent = lrgs(useidx).mask().member(ureg_lo);\n+              bool is_adjacent = lrgs(useidx).mask().Member(ureg_lo);\n@@ -765,1 +765,1 @@\n-        bool is_adjacent = lrgs(lidx).mask().member(nreg_lo);\n+        bool is_adjacent = lrgs(lidx).mask().Member(nreg_lo);\n@@ -770,2 +770,2 @@\n-          RegMask tmp(lrgs(lidx).mask());\n-          tmp.remove(nreg);\n+          RegMask tmp = lrgs(lidx).mask();\n+          tmp.Remove(nreg);\n","filename":"src\/hotspot\/share\/opto\/postaloc.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -479,1 +479,1 @@\n-    if (!n->out_RegMask().is_empty()) {\n+    if (!n->out_RegMask().is_Empty()) {\n@@ -1041,1 +1041,1 @@\n-                (int)umask.size() <= lrgs(useidx).num_regs() &&\n+                (int)umask.Size() <= lrgs(useidx).num_regs() &&\n@@ -1131,1 +1131,1 @@\n-                  tmp_rm.subtract(Matcher::STACK_ONLY_mask);\n+                  tmp_rm.SUBTRACT(Matcher::STACK_ONLY_mask);\n","filename":"src\/hotspot\/share\/opto\/reg_split.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-const RegMask RegMask::EMPTY;\n+const RegMask RegMask::Empty;\n@@ -52,1 +52,1 @@\n-const RegMask RegMask::ALL(\n+const RegMask RegMask::All(\n@@ -129,1 +129,1 @@\n-  return size() == 2 && !is_aligned_pairs();\n+  return Size() == 2 && !is_aligned_pairs();\n@@ -230,1 +230,1 @@\n-    if (!member(reg - i)) {\n+    if (!Member(reg - i)) {\n","filename":"src\/hotspot\/share\/opto\/regmask.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -302,0 +302,33 @@\n+  \/\/ Make us a copy of src\n+  void copy(const RegMask& src) {\n+    assert(_offset == src._offset, \"offset mismatch\");\n+    _hwm = src._hwm;\n+    _lwm = src._lwm;\n+\n+    \/\/ Copy base mask\n+    memcpy(_rm_word, src._rm_word, sizeof(uintptr_t) * RM_SIZE_IN_WORDS);\n+    _infinite_stack = src._infinite_stack;\n+\n+    \/\/ Copy extension\n+    if (src._rm_word_ext != nullptr) {\n+      assert(src._rm_size_in_words > RM_SIZE_IN_WORDS, \"sanity\");\n+      assert(_original_ext_address == &_rm_word_ext, \"clone sanity check\");\n+      grow(src._rm_size_in_words, false);\n+      memcpy(_rm_word_ext, src._rm_word_ext,\n+             sizeof(uintptr_t) * (src._rm_size_in_words - RM_SIZE_IN_WORDS));\n+    }\n+\n+    \/\/ If the source is smaller than us, we need to set the gap according to\n+    \/\/ the sources infinite_stack flag.\n+    if (src._rm_size_in_words < _rm_size_in_words) {\n+      int value = 0;\n+      if (src.is_infinite_stack()) {\n+        value = 0xFF;\n+        _hwm = rm_word_max_index();\n+      }\n+      set_range(src._rm_size_in_words, value, _rm_size_in_words - src._rm_size_in_words);\n+    }\n+\n+    assert(valid_watermarks(), \"post-condition\");\n+  }\n+\n@@ -419,1 +452,1 @@\n-    insert(reg);\n+    Insert(reg);\n@@ -423,18 +456,3 @@\n-  \/\/ Make us represent the same set of registers as src.\n-  void assignFrom(const RegMask& src) {\n-    assert(_offset == src._offset, \"offset mismatch\");\n-    _hwm = src._hwm;\n-    _lwm = src._lwm;\n-\n-    \/\/ Copy base mask\n-    memcpy(_rm_word, src._rm_word, sizeof(uintptr_t) * RM_SIZE_IN_WORDS);\n-    _infinite_stack = src._infinite_stack;\n-\n-    \/\/ Copy extension\n-    if (src._rm_word_ext != nullptr) {\n-      assert(src._rm_size_in_words > RM_SIZE_IN_WORDS, \"sanity\");\n-      assert(_original_ext_address == &_rm_word_ext, \"clone sanity check\");\n-      grow(src._rm_size_in_words, false);\n-      memcpy(_rm_word_ext, src._rm_word_ext,\n-             sizeof(uintptr_t) * (src._rm_size_in_words - RM_SIZE_IN_WORDS));\n-    }\n+  \/\/ ----------------------------------------\n+  \/\/ Deep copying constructors and assignment\n+  \/\/ ----------------------------------------\n@@ -442,17 +460,0 @@\n-    \/\/ If the source is smaller than us, we need to set the gap according to\n-    \/\/ the sources infinite_stack flag.\n-    if (src._rm_size_in_words < _rm_size_in_words) {\n-      int value = 0;\n-      if (src.is_infinite_stack()) {\n-        value = 0xFF;\n-        _hwm = rm_word_max_index();\n-      }\n-      set_range(src._rm_size_in_words, value, _rm_size_in_words - src._rm_size_in_words);\n-    }\n-\n-    assert(valid_watermarks(), \"post-condition\");\n-  }\n-\n-  \/\/ Construct from other register mask (deep copy) and register an arena\n-  \/\/ for potential register mask extension. Passing nullptr as arena disables\n-  \/\/ extension.\n@@ -461,1 +462,1 @@\n-    assignFrom(rm);\n+    copy(rm);\n@@ -464,2 +465,1 @@\n-  \/\/ Copy constructor (deep copy). By default does not allow extension.\n-  explicit RegMask(const RegMask& rm) : RegMask(rm, nullptr) {}\n+  RegMask(const RegMask& rm) : RegMask(rm, nullptr) {}\n@@ -467,2 +467,4 @@\n-  \/\/ Disallow copy assignment (use assignFrom instead)\n-  RegMask& operator=(const RegMask&) = delete;\n+  RegMask& operator=(const RegMask& rm) {\n+    copy(rm);\n+    return *this;\n+  }\n@@ -474,1 +476,1 @@\n-  bool member(OptoReg::Name reg) const {\n+  bool Member(OptoReg::Name reg) const {\n@@ -487,1 +489,1 @@\n-  bool is_empty() const {\n+  bool is_Empty() const {\n@@ -643,1 +645,1 @@\n-  void clear() {\n+  void Clear() {\n@@ -652,1 +654,1 @@\n-  void set_all() {\n+  void Set_All() {\n@@ -654,1 +656,1 @@\n-    set_all_from_offset();\n+    Set_All_From_Offset();\n@@ -658,1 +660,1 @@\n-  void set_all_from_offset() {\n+  void Set_All_From_Offset() {\n@@ -667,1 +669,1 @@\n-  void set_all_from(OptoReg::Name reg) {\n+  void Set_All_From(OptoReg::Name reg) {\n@@ -690,1 +692,1 @@\n-  void insert(OptoReg::Name reg) {\n+  void Insert(OptoReg::Name reg) {\n@@ -707,1 +709,1 @@\n-  void remove(OptoReg::Name reg) {\n+  void Remove(OptoReg::Name reg) {\n@@ -715,2 +717,2 @@\n-  \/\/ Or 'rm' into 'this'\n-  void or_with(const RegMask& rm) {\n+  \/\/ OR 'rm' into 'this'\n+  void OR(const RegMask &rm) {\n@@ -737,2 +739,2 @@\n-  \/\/ And 'rm' into 'this'\n-  void and_with(const RegMask& rm) {\n+  \/\/ AND 'rm' into 'this'\n+  void AND(const RegMask &rm) {\n@@ -769,1 +771,1 @@\n-  void subtract(const RegMask& rm) {\n+  void SUBTRACT(const RegMask &rm) {\n@@ -792,1 +794,1 @@\n-  void subtract_inner(const RegMask& rm) {\n+  void SUBTRACT_inner(const RegMask& rm) {\n@@ -822,1 +824,1 @@\n-    set_all_from_offset();\n+    Set_All_From_Offset();\n@@ -827,1 +829,1 @@\n-  uint size() const {\n+  uint Size() const {\n@@ -896,2 +898,2 @@\n-  static const RegMask EMPTY; \/\/ Common empty mask\n-  static const RegMask ALL;   \/\/ Common all mask\n+  static const RegMask Empty;   \/\/ Common empty mask\n+  static const RegMask All;     \/\/ Common all mask\n","filename":"src\/hotspot\/share\/opto\/regmask.hpp","additions":62,"deletions":60,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-  return RegMask::EMPTY;\n+  return RegMask::Empty;\n","filename":"src\/hotspot\/share\/opto\/rootnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2503,2 +2503,0 @@\n-  case Op_ReverseBytesS:\n-  case Op_ReverseBytesUS:\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -199,5 +199,0 @@\n-  if (JvmtiEnvBase::get_phase() != JVMTI_PHASE_LIVE) {\n-    st->print_cr(\"Dynamic agent loading is only permitted in the live phase\");\n-    return;\n-  }\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgentList.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -882,0 +882,1 @@\n+  bool                 _has_been_modified;\n@@ -898,0 +899,1 @@\n+    _has_been_modified = false;\n@@ -936,0 +938,2 @@\n+  bool has_been_modified() { return _has_been_modified; }\n+\n@@ -982,0 +986,1 @@\n+      _has_been_modified = true;\n@@ -1056,1 +1061,1 @@\n-void JvmtiExport::post_class_file_load_hook(Symbol* h_name,\n+bool JvmtiExport::post_class_file_load_hook(Symbol* h_name,\n@@ -1063,1 +1068,1 @@\n-    return;\n+    return false;\n@@ -1067,1 +1072,1 @@\n-    return;\n+    return false;\n@@ -1075,0 +1080,1 @@\n+  return poster.has_been_modified();\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -380,1 +380,2 @@\n-  static void post_class_file_load_hook(Symbol* h_name, Handle class_loader,\n+  \/\/ Return true if the class was modified by the hook.\n+  static bool post_class_file_load_hook(Symbol* h_name, Handle class_loader,\n@@ -383,1 +384,1 @@\n-                                        JvmtiCachedClassFileData **cache_ptr) NOT_JVMTI_RETURN;\n+                                        JvmtiCachedClassFileData **cache_ptr) NOT_JVMTI_RETURN_(false);\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -551,1 +551,0 @@\n-  { \"ShenandoahPacing\",             JDK_Version::jdk(25), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n@@ -1524,6 +1523,0 @@\n-  if (CompilerConfig::should_set_client_emulation_mode_flags() &&\n-      FLAG_IS_DEFAULT(MaxRAM)) {\n-    \/\/ Reduce the maximum available memory if client emulation mode is enabled.\n-    FLAG_SET_DEFAULT(MaxRAM, 1ULL*G);\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-  friend class VMStructs;\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1807,1 +1807,2 @@\n-address Deoptimization::deoptimize_for_missing_exception_handler(nmethod* nm, bool make_not_entrant) {\n+#if INCLUDE_JVMCI\n+address Deoptimization::deoptimize_for_missing_exception_handler(nmethod* nm) {\n@@ -1809,3 +1810,1 @@\n-  if (make_not_entrant) {\n-    nm->make_not_entrant(nmethod::InvalidationReason::MISSING_EXCEPTION_HANDLER);\n-  }\n+  nm->make_not_entrant(nmethod::InvalidationReason::MISSING_EXCEPTION_HANDLER);\n@@ -1825,9 +1824,0 @@\n-\n-  Deoptimization::deoptimize(thread, caller_frame, Deoptimization::Reason_not_compiled_exception_handler);\n-\n-  if (!nm->is_compiled_by_jvmci()) {\n-    return SharedRuntime::deopt_blob()->unpack_with_exception_in_tls();\n-  }\n-\n-#if INCLUDE_JVMCI\n-  \/\/ JVMCI support\n@@ -1849,0 +1839,1 @@\n+  Deoptimization::deoptimize(thread, caller_frame, Deoptimization::Reason_not_compiled_exception_handler);\n@@ -1854,1 +1845,0 @@\n-#endif\n@@ -1858,0 +1848,1 @@\n+#endif\n@@ -2760,1 +2751,0 @@\n-  \"not_compiled_exception_handler\",\n@@ -2764,0 +2754,1 @@\n+  \"not_compiled_exception_handler\",\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":6,"deletions":15,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -120,1 +120,0 @@\n-    Reason_not_compiled_exception_handler, \/\/ missing compiled exception handler\n@@ -125,0 +124,1 @@\n+    Reason_not_compiled_exception_handler,\n@@ -187,1 +187,0 @@\n-  static address deoptimize_for_missing_exception_handler(nmethod* nm, bool make_not_entrant);\n@@ -189,0 +188,1 @@\n+  static address deoptimize_for_missing_exception_handler(nmethod* nm);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -505,1 +505,1 @@\n-          range(0, 18)                                                      \\\n+          range(0, 17)                                                      \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -538,0 +538,1 @@\n+  assert(deferred_card_mark().is_empty(), \"Default MemRegion ctor\");\n@@ -1361,0 +1362,3 @@\n+  \/\/ Verify that the deferred card marks have been flushed.\n+  assert(deferred_card_mark().is_empty(), \"Should be empty during GC\");\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -152,0 +152,5 @@\n+  \/\/ See ReduceInitialCardMarks: this holds the precise space interval of\n+  \/\/ the most recent slow path allocation for which compiled code has\n+  \/\/ elided card-marks for performance along the fast-path.\n+  MemRegion     _deferred_card_mark;\n+\n@@ -774,0 +779,3 @@\n+  MemRegion deferred_card_mark() const           { return _deferred_card_mark; }\n+  void set_deferred_card_mark(MemRegion mr)      { _deferred_card_mark = mr;   }\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1866,1 +1866,1 @@\n-  \/\/   while (!timeout && !interrupted && node.TState == TS_WAIT) park()\n+  \/\/   while (!timeout && !interrupted && _notified == 0) park()\n@@ -1869,1 +1869,1 @@\n-  bool was_notified = false;\n+  int WasNotified = 0;\n@@ -1885,1 +1885,1 @@\n-      } else if (node.TState == ObjectWaiter::TS_WAIT) {\n+      } else if (!node._notified) {\n@@ -1913,0 +1913,1 @@\n+        assert(!node._notified, \"invariant\");\n@@ -1925,1 +1926,1 @@\n-    was_notified = node.TState == ObjectWaiter::TS_ENTER;\n+    WasNotified = node._notified;\n@@ -1938,1 +1939,1 @@\n-      if (was_notified && has_successor(current)) {\n+      if (node._notified && has_successor(current)) {\n@@ -2005,1 +2006,1 @@\n-  if (!was_notified) {\n+  if (!WasNotified) {\n@@ -2028,0 +2029,1 @@\n+    guarantee(!iterator->_notified, \"invariant\");\n@@ -2049,0 +2051,1 @@\n+    iterator->_notified = true;\n@@ -2210,0 +2213,1 @@\n+      assert(!node->_notified, \"invariant\");\n@@ -2515,0 +2519,1 @@\n+  _notified = false;\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+  volatile bool _notified;\n@@ -69,0 +70,1 @@\n+  bool notified()           const { return _notified; }\n@@ -70,1 +72,1 @@\n-  bool at_monitorenter()    const { return !_is_wait || TState != TS_WAIT; }\n+  bool at_monitorenter()    const { return !_is_wait || _at_reenter || _notified; }\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -117,1 +117,3 @@\n-    log_debug(perf)(\"could not create PerfData Memory region, reverting to malloc\");\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"Could not create PerfData Memory region, reverting to malloc\");\n+    }\n@@ -251,1 +253,4 @@\n-      log_debug(perf)(\"invalid performance data file path name specified, fall back to a default name\");\n+      if (PrintMiscellaneous && Verbose) {\n+        warning(\"Invalid performance data file path name specified, \"\\\n+                \"fall back to a default name\");\n+      }\n","filename":"src\/hotspot\/share\/runtime\/perfMemory.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-JavaThread* ServiceThread::_instance = nullptr;\n+DEBUG_ONLY(JavaThread* ServiceThread::_instance = nullptr;)\n@@ -65,1 +65,1 @@\n-  _instance = thread;\n+  DEBUG_ONLY(_instance = thread;)\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-  static JavaThread* _instance;\n+  DEBUG_ONLY(static JavaThread* _instance;)\n@@ -47,1 +47,0 @@\n-  static bool has_started() { return  _instance != nullptr; }\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -794,2 +794,1 @@\n-      bool make_not_entrant = true;\n-      return Deoptimization::deoptimize_for_missing_exception_handler(nm, make_not_entrant);\n+      return Deoptimization::deoptimize_for_missing_exception_handler(nm);\n@@ -851,9 +850,0 @@\n-\n-  \/\/ If the compiler did not anticipate a recursive exception, resulting in an exception\n-  \/\/ thrown from the catch bci, then the compiled exception handler might be missing.\n-  \/\/ This is rare.  Just deoptimize and let the interpreter handle it.\n-  if (t == nullptr && recursive_exception_occurred) {\n-    bool make_not_entrant = false;\n-    return Deoptimization::deoptimize_for_missing_exception_handler(nm, make_not_entrant);\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -387,0 +387,4 @@\n+  static bool handle_ic_miss_helper_internal(Handle receiver, nmethod* caller_nm, const frame& caller_frame,\n+                                             methodHandle callee_method, Bytecodes::Code bc, CallInfo& call_info,\n+                                             bool& needs_ic_stub_refill, TRAPS);\n+\n@@ -548,0 +552,1 @@\n+  static bool should_fixup_call_destination(address destination, address entry_point, address caller_pc, Method* moop, CodeBlob* cb);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -100,1 +100,0 @@\n-#include \"sanitizers\/address.hpp\"\n@@ -347,5 +346,0 @@\n-  \/\/ This is before the execution of the very first Java bytecode.\n-  if (CDSConfig::is_using_aot_linked_classes()) {\n-    AOTLinkedClassBulkLoader::link_classes(THREAD);\n-  }\n-\n@@ -706,4 +700,0 @@\n-#ifdef ADDRESS_SANITIZER\n-  Asan::initialize();\n-#endif\n-\n@@ -755,4 +745,0 @@\n-  if (CDSConfig::is_using_aot_linked_classes()) {\n-    nmethod::post_delayed_compiled_method_load_events();\n-  }\n-\n@@ -791,1 +777,1 @@\n-    AOTLinkedClassBulkLoader::init_javabase_classes(THREAD);\n+    AOTLinkedClassBulkLoader::link_or_init_javabase_classes(THREAD);\n@@ -810,1 +796,1 @@\n-    AOTLinkedClassBulkLoader::init_non_javabase_classes(THREAD);\n+    AOTLinkedClassBulkLoader::link_or_init_non_javabase_classes(THREAD);\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -619,1 +619,0 @@\n-  nonstatic_field(JavaThread,                  _cont_entry,                                   ContinuationEntry*)                    \\\n@@ -800,2 +799,1 @@\n-  volatile_nonstatic_field(Mutex,              _owner,                                        Thread*)                               \\\n-  static_field(ContinuationEntry,              _return_pc,                                    address)\n+  volatile_nonstatic_field(Mutex,              _owner,                                        Thread*)\n@@ -1275,1 +1273,0 @@\n-  declare_toplevel_type(ContinuationEntry)                                \\\n@@ -1584,1 +1581,0 @@\n-  declare_constant(Deoptimization::Reason_not_compiled_exception_handler) \\\n@@ -1586,0 +1582,1 @@\n+  NOT_ZERO(JVMCI_ONLY(declare_constant(Deoptimization::Reason_not_compiled_exception_handler))) \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,120 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifdef ADDRESS_SANITIZER\n-\n-#include \"logging\/log.hpp\"\n-#include \"sanitizers\/address.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/vmError.hpp\"\n-\n-#include <dlfcn.h>\n-#include <stdio.h>\n-\n-typedef void (*callback_setter_t) (void (*callback)(const char *));\n-static callback_setter_t g_callback_setter = nullptr;\n-static const char* g_report = nullptr;\n-\n-extern \"C\" void asan_error_callback(const char* report_text) {\n-  \/\/ Please keep things very short and simple here and use as little\n-  \/\/ as possible of any hotspot infrastructure. However shaky the JVM,\n-  \/\/ we should always at least get the ASAN report on stderr.\n-\n-  \/\/ Note: this is threadsafe since ASAN synchronizes error reports\n-  g_report = report_text;\n-\n-  \/\/ First, print off the bare error to stderr\n-  fprintf(stderr, \"JVM caught ASAN Error\\n\");\n-  fprintf(stderr, \"%s\\n\", report_text);\n-\n-  \/\/ Then, let normal JVM error handling run its due course.\n-  fatal(\"ASAN Error\");\n-}\n-\n-void Asan::initialize() {\n-\n-  \/\/ For documentation of __asan_set_error_report_callback() see asan_interface.h .\n-  g_callback_setter = (callback_setter_t) dlsym(RTLD_DEFAULT, \"__asan_set_error_report_callback\");\n-  if (g_callback_setter == nullptr) {\n-    log_info(asan)(\"*** Failed to install JVM callback for ASAN. ASAN errors will not generate hs-err files. ***\");\n-    return;\n-  }\n-\n-  g_callback_setter(asan_error_callback);\n-  log_info(asan)(\"JVM callback for ASAN errors successfully installed\");\n-\n-  \/\/ Controlling core dump behavior:\n-  \/\/\n-  \/\/ In hotspot, CreateCoredumpOnCrash decides whether to create a core dump (on Posix, whether to\n-  \/\/ end the process with abort(3) or exit(3)).\n-  \/\/\n-  \/\/ Core generation in the default ASAN reporter is controlled by two options:\n-  \/\/ - \"abort_on_error=0\" (default) - end with exit(3), \"abort_on_error=1\" end with abort(3)\n-  \/\/ - \"disable_coredump=1\" (default) disables cores by imposing a near-zero core soft limit.\n-  \/\/ By default both options are set to prevent cores. That default makes sense since ASAN cores\n-  \/\/ can get very large (due to the shadow map) and very numerous (ASAN is typically ran for\n-  \/\/ large-scale integration tests, not targeted micro-tests).\n-  \/\/\n-  \/\/ In hotspot ASAN builds, we replace the default ASAN reporter. The soft limit imposed by\n-  \/\/ \"disable_coredump=1\" is still in effect. But \"abort_on_error\" is not honored. Since we'd\n-  \/\/ like to exhibit exactly the same behavior as the standard ASAN error reporter, we disable\n-  \/\/ core files if ASAN would inhibit them (we just switch off CreateCoredumpOnCrash).\n-  \/\/\n-  \/\/ Thus:\n-  \/\/     abort_on_error      disable_coredump       core file?\n-  \/\/         0                   0                  No  (enforced by ergo-setting CreateCoredumpOnCrash=0)\n-  \/\/ (*)     0                   1                  No  (enforced by ASAN-imposed soft limit)\n-  \/\/         1                   0                  Yes, unless -XX:-CreateCoredumpOnCrash set on command line\n-  \/\/         1                   1                  No  (enforced by ASAN-imposed soft limit)\n-  \/\/ (*) is the default if no ASAN options are specified.\n-\n-  const char* const asan_options = getenv(\"ASAN_OPTIONS\");\n-  const bool asan_inhibits_cores = (asan_options == nullptr) ||\n-                                   (::strstr(asan_options, \"abort_on_error=1\") == nullptr) ||\n-                                   (::strstr(asan_options, \"disable_coredump=0\") == nullptr);\n-  if (asan_inhibits_cores) {\n-    if (CreateCoredumpOnCrash) {\n-      log_info(asan)(\"CreateCoredumpOnCrash overruled by%s asan options. Core generation disabled.\",\n-                        asan_options != nullptr ? \"\" : \" default setting for\");\n-      log_info(asan)(\"Use 'ASAN_OPTIONS=abort_on_error=1:disable_coredump=0:unmap_shadow_on_exit=1' \"\n-                     \"to enable core generation.\");\n-    }\n-    FLAG_SET_ERGO(CreateCoredumpOnCrash, false);\n-  }\n-}\n-\n-bool Asan::had_error() {\n-  return g_report != nullptr;\n-}\n-\n-void Asan::report(outputStream* st) {\n-  if (had_error()) {\n-    \/\/ Use raw print here to avoid truncation.\n-    st->print_raw(g_report);\n-    st->cr();\n-    st->cr();\n-  }\n-}\n-\n-#endif \/\/ ADDRESS_SANITIZER\n","filename":"src\/hotspot\/share\/sanitizers\/address.cpp","additions":0,"deletions":120,"binary":false,"changes":120,"status":"deleted"},{"patch":"@@ -29,2 +29,0 @@\n-#include \"memory\/allStatic.hpp\"\n-\n@@ -79,10 +77,0 @@\n-class outputStream;\n-\n-#ifdef ADDRESS_SANITIZER\n-struct Asan : public AllStatic {\n-  static void initialize();\n-  static bool had_error();\n-  static void report(outputStream* st);\n-};\n-#endif\n-\n","filename":"src\/hotspot\/share\/sanitizers\/address.hpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -359,3 +359,1 @@\n-    return \"Print all platform threads, and mounted virtual threads, \"\n-           \"with stack traces. The Thread.dump_to_file command will \"\n-           \"print all threads to a file.\";\n+    return \"Print all threads with stacktraces.\";\n@@ -773,2 +771,1 @@\n-    return \"Dump all threads, with stack traces, \"\n-           \"to a file in plain text or JSON format.\";\n+    return \"Dump threads, with stack traces, to a file in plain text or JSON format.\";\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"utilities\/checkedCast.hpp\"\n@@ -1257,8 +1256,0 @@\n-inline jlong java_negate(jlong v, BasicType bt) {\n-  if (bt == T_INT) {\n-    return java_negate(checked_cast<jint>(v));\n-  }\n-  assert(bt == T_LONG, \"int or long only\");\n-  return java_negate(v);\n-}\n-\n@@ -1271,1 +1262,1 @@\n-    return FUNC(checked_cast<jint>(lhs), rhs);         \\\n+    return FUNC((jint) lhs, rhs);                      \\\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-#include \"sanitizers\/address.hpp\"\n@@ -914,10 +913,1 @@\n-#ifdef ADDRESS_SANITIZER\n-  STEP_IF(\"printing ASAN error information\", _verbose && Asan::had_error())\n-    st->cr();\n-    st->print_cr(\"------------------  A S A N ----------------\");\n-    st->cr();\n-    Asan::report(st);\n-    st->cr();\n-#endif \/\/ ADDRESS_SANITIZER\n-\n-    STEP_IF(\"printing thread\", _verbose)\n+  STEP_IF(\"printing thread\", _verbose)\n@@ -2199,8 +2189,0 @@\n-    case 18: {\n-      \/\/ Trigger an error that should cause ASAN to report a double free or use-after-free.\n-      \/\/ Please note that this is not 100% bullet-proof since it assumes that this block\n-      \/\/ is not immediately repurposed by some other thread after free.\n-      void* const p = os::malloc(4096, mtTest);\n-      os::free(p);\n-      os::free(p);\n-    }\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":1,"deletions":19,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n- * @see AES_Crypt\n+ * @see AESCrypt\n@@ -177,1 +177,1 @@\n-        core = new CipherCore(new AES_Crypt(), AESConstants.AES_BLOCK_SIZE);\n+        core = new CipherCore(new AESCrypt(), AESConstants.AES_BLOCK_SIZE);\n@@ -507,1 +507,1 @@\n-        if (!AES_Crypt.isKeySizeValid(encoded.length)) {\n+        if (!AESCrypt.isKeySizeValid(encoded.length)) {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AESCipher.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,1437 @@\n+\/*\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* $Id: Rijndael.java,v 1.6 2000\/02\/10 01:31:41 gelderen Exp $\n+ *\n+ * Copyright (C) 1995-2000 The Cryptix Foundation Limited.\n+ * All rights reserved.\n+ *\n+ * Use, modification, copying and distribution of this softwareas is subject\n+ * the terms and conditions of the Cryptix General Licence. You should have\n+ * received a copy of the Cryptix General Licence along with this library;\n+ * if not, you can download a copy from http:\/\/www.cryptix.org\/ .\n+ *\/\n+\n+package com.sun.crypto.provider;\n+\n+import java.security.InvalidKeyException;\n+import java.security.MessageDigest;\n+import java.util.Arrays;\n+\n+import jdk.internal.vm.annotation.IntrinsicCandidate;\n+\n+\/**\n+ * Rijndael --pronounced Reindaal-- is a symmetric cipher with a 128-bit\n+ * block size and variable key-size (128-, 192- and 256-bit).\n+ * <p>\n+ * Rijndael was designed by <a href=\"mailto:rijmen@esat.kuleuven.ac.be\">Vincent\n+ * Rijmen<\/a> and <a href=\"mailto:Joan.Daemen@village.uunet.be\">Joan Daemen<\/a>.\n+ *\/\n+final class AESCrypt extends SymmetricCipher implements AESConstants {\n+    \/\/\n+    \/\/ Pre-computed tables, which are copied or derived from FIPS 197.\n+    \/\/\n+\n+    \/\/ the pre-computed substitution table (S-box), 256 bytes\n+    private static final byte[] S = {\n+            (byte)0x63, (byte)0x7C, (byte)0x77, (byte)0x7B,\n+            (byte)0xF2, (byte)0x6B, (byte)0x6F, (byte)0xC5,\n+            (byte)0x30, (byte)0x01, (byte)0x67, (byte)0x2B,\n+            (byte)0xFE, (byte)0xD7, (byte)0xAB, (byte)0x76,\n+            (byte)0xCA, (byte)0x82, (byte)0xC9, (byte)0x7D,\n+            (byte)0xFA, (byte)0x59, (byte)0x47, (byte)0xF0,\n+            (byte)0xAD, (byte)0xD4, (byte)0xA2, (byte)0xAF,\n+            (byte)0x9C, (byte)0xA4, (byte)0x72, (byte)0xC0,\n+            (byte)0xB7, (byte)0xFD, (byte)0x93, (byte)0x26,\n+            (byte)0x36, (byte)0x3F, (byte)0xF7, (byte)0xCC,\n+            (byte)0x34, (byte)0xA5, (byte)0xE5, (byte)0xF1,\n+            (byte)0x71, (byte)0xD8, (byte)0x31, (byte)0x15,\n+            (byte)0x04, (byte)0xC7, (byte)0x23, (byte)0xC3,\n+            (byte)0x18, (byte)0x96, (byte)0x05, (byte)0x9A,\n+            (byte)0x07, (byte)0x12, (byte)0x80, (byte)0xE2,\n+            (byte)0xEB, (byte)0x27, (byte)0xB2, (byte)0x75,\n+            (byte)0x09, (byte)0x83, (byte)0x2C, (byte)0x1A,\n+            (byte)0x1B, (byte)0x6E, (byte)0x5A, (byte)0xA0,\n+            (byte)0x52, (byte)0x3B, (byte)0xD6, (byte)0xB3,\n+            (byte)0x29, (byte)0xE3, (byte)0x2F, (byte)0x84,\n+            (byte)0x53, (byte)0xD1, (byte)0x00, (byte)0xED,\n+            (byte)0x20, (byte)0xFC, (byte)0xB1, (byte)0x5B,\n+            (byte)0x6A, (byte)0xCB, (byte)0xBE, (byte)0x39,\n+            (byte)0x4A, (byte)0x4C, (byte)0x58, (byte)0xCF,\n+            (byte)0xD0, (byte)0xEF, (byte)0xAA, (byte)0xFB,\n+            (byte)0x43, (byte)0x4D, (byte)0x33, (byte)0x85,\n+            (byte)0x45, (byte)0xF9, (byte)0x02, (byte)0x7F,\n+            (byte)0x50, (byte)0x3C, (byte)0x9F, (byte)0xA8,\n+            (byte)0x51, (byte)0xA3, (byte)0x40, (byte)0x8F,\n+            (byte)0x92, (byte)0x9D, (byte)0x38, (byte)0xF5,\n+            (byte)0xBC, (byte)0xB6, (byte)0xDA, (byte)0x21,\n+            (byte)0x10, (byte)0xFF, (byte)0xF3, (byte)0xD2,\n+            (byte)0xCD, (byte)0x0C, (byte)0x13, (byte)0xEC,\n+            (byte)0x5F, (byte)0x97, (byte)0x44, (byte)0x17,\n+            (byte)0xC4, (byte)0xA7, (byte)0x7E, (byte)0x3D,\n+            (byte)0x64, (byte)0x5D, (byte)0x19, (byte)0x73,\n+            (byte)0x60, (byte)0x81, (byte)0x4F, (byte)0xDC,\n+            (byte)0x22, (byte)0x2A, (byte)0x90, (byte)0x88,\n+            (byte)0x46, (byte)0xEE, (byte)0xB8, (byte)0x14,\n+            (byte)0xDE, (byte)0x5E, (byte)0x0B, (byte)0xDB,\n+            (byte)0xE0, (byte)0x32, (byte)0x3A, (byte)0x0A,\n+            (byte)0x49, (byte)0x06, (byte)0x24, (byte)0x5C,\n+            (byte)0xC2, (byte)0xD3, (byte)0xAC, (byte)0x62,\n+            (byte)0x91, (byte)0x95, (byte)0xE4, (byte)0x79,\n+            (byte)0xE7, (byte)0xC8, (byte)0x37, (byte)0x6D,\n+            (byte)0x8D, (byte)0xD5, (byte)0x4E, (byte)0xA9,\n+            (byte)0x6C, (byte)0x56, (byte)0xF4, (byte)0xEA,\n+            (byte)0x65, (byte)0x7A, (byte)0xAE, (byte)0x08,\n+            (byte)0xBA, (byte)0x78, (byte)0x25, (byte)0x2E,\n+            (byte)0x1C, (byte)0xA6, (byte)0xB4, (byte)0xC6,\n+            (byte)0xE8, (byte)0xDD, (byte)0x74, (byte)0x1F,\n+            (byte)0x4B, (byte)0xBD, (byte)0x8B, (byte)0x8A,\n+            (byte)0x70, (byte)0x3E, (byte)0xB5, (byte)0x66,\n+            (byte)0x48, (byte)0x03, (byte)0xF6, (byte)0x0E,\n+            (byte)0x61, (byte)0x35, (byte)0x57, (byte)0xB9,\n+            (byte)0x86, (byte)0xC1, (byte)0x1D, (byte)0x9E,\n+            (byte)0xE1, (byte)0xF8, (byte)0x98, (byte)0x11,\n+            (byte)0x69, (byte)0xD9, (byte)0x8E, (byte)0x94,\n+            (byte)0x9B, (byte)0x1E, (byte)0x87, (byte)0xE9,\n+            (byte)0xCE, (byte)0x55, (byte)0x28, (byte)0xDF,\n+            (byte)0x8C, (byte)0xA1, (byte)0x89, (byte)0x0D,\n+            (byte)0xBF, (byte)0xE6, (byte)0x42, (byte)0x68,\n+            (byte)0x41, (byte)0x99, (byte)0x2D, (byte)0x0F,\n+            (byte)0xB0, (byte)0x54, (byte)0xBB, (byte)0x16,\n+    };\n+\n+    \/\/ the pre-computed substitution table (inverse S-box), 256 bytes\n+    private static final byte[] Si = {\n+            (byte)0x52, (byte)0x09, (byte)0x6A, (byte)0xD5,\n+            (byte)0x30, (byte)0x36, (byte)0xA5, (byte)0x38,\n+            (byte)0xBF, (byte)0x40, (byte)0xA3, (byte)0x9E,\n+            (byte)0x81, (byte)0xF3, (byte)0xD7, (byte)0xFB,\n+            (byte)0x7C, (byte)0xE3, (byte)0x39, (byte)0x82,\n+            (byte)0x9B, (byte)0x2F, (byte)0xFF, (byte)0x87,\n+            (byte)0x34, (byte)0x8E, (byte)0x43, (byte)0x44,\n+            (byte)0xC4, (byte)0xDE, (byte)0xE9, (byte)0xCB,\n+            (byte)0x54, (byte)0x7B, (byte)0x94, (byte)0x32,\n+            (byte)0xA6, (byte)0xC2, (byte)0x23, (byte)0x3D,\n+            (byte)0xEE, (byte)0x4C, (byte)0x95, (byte)0x0B,\n+            (byte)0x42, (byte)0xFA, (byte)0xC3, (byte)0x4E,\n+            (byte)0x08, (byte)0x2E, (byte)0xA1, (byte)0x66,\n+            (byte)0x28, (byte)0xD9, (byte)0x24, (byte)0xB2,\n+            (byte)0x76, (byte)0x5B, (byte)0xA2, (byte)0x49,\n+            (byte)0x6D, (byte)0x8B, (byte)0xD1, (byte)0x25,\n+            (byte)0x72, (byte)0xF8, (byte)0xF6, (byte)0x64,\n+            (byte)0x86, (byte)0x68, (byte)0x98, (byte)0x16,\n+            (byte)0xD4, (byte)0xA4, (byte)0x5C, (byte)0xCC,\n+            (byte)0x5D, (byte)0x65, (byte)0xB6, (byte)0x92,\n+            (byte)0x6C, (byte)0x70, (byte)0x48, (byte)0x50,\n+            (byte)0xFD, (byte)0xED, (byte)0xB9, (byte)0xDA,\n+            (byte)0x5E, (byte)0x15, (byte)0x46, (byte)0x57,\n+            (byte)0xA7, (byte)0x8D, (byte)0x9D, (byte)0x84,\n+            (byte)0x90, (byte)0xD8, (byte)0xAB, (byte)0x00,\n+            (byte)0x8C, (byte)0xBC, (byte)0xD3, (byte)0x0A,\n+            (byte)0xF7, (byte)0xE4, (byte)0x58, (byte)0x05,\n+            (byte)0xB8, (byte)0xB3, (byte)0x45, (byte)0x06,\n+            (byte)0xD0, (byte)0x2C, (byte)0x1E, (byte)0x8F,\n+            (byte)0xCA, (byte)0x3F, (byte)0x0F, (byte)0x02,\n+            (byte)0xC1, (byte)0xAF, (byte)0xBD, (byte)0x03,\n+            (byte)0x01, (byte)0x13, (byte)0x8A, (byte)0x6B,\n+            (byte)0x3A, (byte)0x91, (byte)0x11, (byte)0x41,\n+            (byte)0x4F, (byte)0x67, (byte)0xDC, (byte)0xEA,\n+            (byte)0x97, (byte)0xF2, (byte)0xCF, (byte)0xCE,\n+            (byte)0xF0, (byte)0xB4, (byte)0xE6, (byte)0x73,\n+            (byte)0x96, (byte)0xAC, (byte)0x74, (byte)0x22,\n+            (byte)0xE7, (byte)0xAD, (byte)0x35, (byte)0x85,\n+            (byte)0xE2, (byte)0xF9, (byte)0x37, (byte)0xE8,\n+            (byte)0x1C, (byte)0x75, (byte)0xDF, (byte)0x6E,\n+            (byte)0x47, (byte)0xF1, (byte)0x1A, (byte)0x71,\n+            (byte)0x1D, (byte)0x29, (byte)0xC5, (byte)0x89,\n+            (byte)0x6F, (byte)0xB7, (byte)0x62, (byte)0x0E,\n+            (byte)0xAA, (byte)0x18, (byte)0xBE, (byte)0x1B,\n+            (byte)0xFC, (byte)0x56, (byte)0x3E, (byte)0x4B,\n+            (byte)0xC6, (byte)0xD2, (byte)0x79, (byte)0x20,\n+            (byte)0x9A, (byte)0xDB, (byte)0xC0, (byte)0xFE,\n+            (byte)0x78, (byte)0xCD, (byte)0x5A, (byte)0xF4,\n+            (byte)0x1F, (byte)0xDD, (byte)0xA8, (byte)0x33,\n+            (byte)0x88, (byte)0x07, (byte)0xC7, (byte)0x31,\n+            (byte)0xB1, (byte)0x12, (byte)0x10, (byte)0x59,\n+            (byte)0x27, (byte)0x80, (byte)0xEC, (byte)0x5F,\n+            (byte)0x60, (byte)0x51, (byte)0x7F, (byte)0xA9,\n+            (byte)0x19, (byte)0xB5, (byte)0x4A, (byte)0x0D,\n+            (byte)0x2D, (byte)0xE5, (byte)0x7A, (byte)0x9F,\n+            (byte)0x93, (byte)0xC9, (byte)0x9C, (byte)0xEF,\n+            (byte)0xA0, (byte)0xE0, (byte)0x3B, (byte)0x4D,\n+            (byte)0xAE, (byte)0x2A, (byte)0xF5, (byte)0xB0,\n+            (byte)0xC8, (byte)0xEB, (byte)0xBB, (byte)0x3C,\n+            (byte)0x83, (byte)0x53, (byte)0x99, (byte)0x61,\n+            (byte)0x17, (byte)0x2B, (byte)0x04, (byte)0x7E,\n+            (byte)0xBA, (byte)0x77, (byte)0xD6, (byte)0x26,\n+            (byte)0xE1, (byte)0x69, (byte)0x14, (byte)0x63,\n+            (byte)0x55, (byte)0x21, (byte)0x0C, (byte)0x7D,\n+    };\n+\n+    \/\/ pre-computed tables (T-box)\n+    private static final int[] T1 = {\n+            0xC66363A5, 0xF87C7C84, 0xEE777799, 0xF67B7B8D,\n+            0xFFF2F20D, 0xD66B6BBD, 0xDE6F6FB1, 0x91C5C554,\n+            0x60303050, 0x02010103, 0xCE6767A9, 0x562B2B7D,\n+            0xE7FEFE19, 0xB5D7D762, 0x4DABABE6, 0xEC76769A,\n+            0x8FCACA45, 0x1F82829D, 0x89C9C940, 0xFA7D7D87,\n+            0xEFFAFA15, 0xB25959EB, 0x8E4747C9, 0xFBF0F00B,\n+            0x41ADADEC, 0xB3D4D467, 0x5FA2A2FD, 0x45AFAFEA,\n+            0x239C9CBF, 0x53A4A4F7, 0xE4727296, 0x9BC0C05B,\n+            0x75B7B7C2, 0xE1FDFD1C, 0x3D9393AE, 0x4C26266A,\n+            0x6C36365A, 0x7E3F3F41, 0xF5F7F702, 0x83CCCC4F,\n+            0x6834345C, 0x51A5A5F4, 0xD1E5E534, 0xF9F1F108,\n+            0xE2717193, 0xABD8D873, 0x62313153, 0x2A15153F,\n+            0x0804040C, 0x95C7C752, 0x46232365, 0x9DC3C35E,\n+            0x30181828, 0x379696A1, 0x0A05050F, 0x2F9A9AB5,\n+            0x0E070709, 0x24121236, 0x1B80809B, 0xDFE2E23D,\n+            0xCDEBEB26, 0x4E272769, 0x7FB2B2CD, 0xEA75759F,\n+            0x1209091B, 0x1D83839E, 0x582C2C74, 0x341A1A2E,\n+            0x361B1B2D, 0xDC6E6EB2, 0xB45A5AEE, 0x5BA0A0FB,\n+            0xA45252F6, 0x763B3B4D, 0xB7D6D661, 0x7DB3B3CE,\n+            0x5229297B, 0xDDE3E33E, 0x5E2F2F71, 0x13848497,\n+            0xA65353F5, 0xB9D1D168, 0x00000000, 0xC1EDED2C,\n+            0x40202060, 0xE3FCFC1F, 0x79B1B1C8, 0xB65B5BED,\n+            0xD46A6ABE, 0x8DCBCB46, 0x67BEBED9, 0x7239394B,\n+            0x944A4ADE, 0x984C4CD4, 0xB05858E8, 0x85CFCF4A,\n+            0xBBD0D06B, 0xC5EFEF2A, 0x4FAAAAE5, 0xEDFBFB16,\n+            0x864343C5, 0x9A4D4DD7, 0x66333355, 0x11858594,\n+            0x8A4545CF, 0xE9F9F910, 0x04020206, 0xFE7F7F81,\n+            0xA05050F0, 0x783C3C44, 0x259F9FBA, 0x4BA8A8E3,\n+            0xA25151F3, 0x5DA3A3FE, 0x804040C0, 0x058F8F8A,\n+            0x3F9292AD, 0x219D9DBC, 0x70383848, 0xF1F5F504,\n+            0x63BCBCDF, 0x77B6B6C1, 0xAFDADA75, 0x42212163,\n+            0x20101030, 0xE5FFFF1A, 0xFDF3F30E, 0xBFD2D26D,\n+            0x81CDCD4C, 0x180C0C14, 0x26131335, 0xC3ECEC2F,\n+            0xBE5F5FE1, 0x359797A2, 0x884444CC, 0x2E171739,\n+            0x93C4C457, 0x55A7A7F2, 0xFC7E7E82, 0x7A3D3D47,\n+            0xC86464AC, 0xBA5D5DE7, 0x3219192B, 0xE6737395,\n+            0xC06060A0, 0x19818198, 0x9E4F4FD1, 0xA3DCDC7F,\n+            0x44222266, 0x542A2A7E, 0x3B9090AB, 0x0B888883,\n+            0x8C4646CA, 0xC7EEEE29, 0x6BB8B8D3, 0x2814143C,\n+            0xA7DEDE79, 0xBC5E5EE2, 0x160B0B1D, 0xADDBDB76,\n+            0xDBE0E03B, 0x64323256, 0x743A3A4E, 0x140A0A1E,\n+            0x924949DB, 0x0C06060A, 0x4824246C, 0xB85C5CE4,\n+            0x9FC2C25D, 0xBDD3D36E, 0x43ACACEF, 0xC46262A6,\n+            0x399191A8, 0x319595A4, 0xD3E4E437, 0xF279798B,\n+            0xD5E7E732, 0x8BC8C843, 0x6E373759, 0xDA6D6DB7,\n+            0x018D8D8C, 0xB1D5D564, 0x9C4E4ED2, 0x49A9A9E0,\n+            0xD86C6CB4, 0xAC5656FA, 0xF3F4F407, 0xCFEAEA25,\n+            0xCA6565AF, 0xF47A7A8E, 0x47AEAEE9, 0x10080818,\n+            0x6FBABAD5, 0xF0787888, 0x4A25256F, 0x5C2E2E72,\n+            0x381C1C24, 0x57A6A6F1, 0x73B4B4C7, 0x97C6C651,\n+            0xCBE8E823, 0xA1DDDD7C, 0xE874749C, 0x3E1F1F21,\n+            0x964B4BDD, 0x61BDBDDC, 0x0D8B8B86, 0x0F8A8A85,\n+            0xE0707090, 0x7C3E3E42, 0x71B5B5C4, 0xCC6666AA,\n+            0x904848D8, 0x06030305, 0xF7F6F601, 0x1C0E0E12,\n+            0xC26161A3, 0x6A35355F, 0xAE5757F9, 0x69B9B9D0,\n+            0x17868691, 0x99C1C158, 0x3A1D1D27, 0x279E9EB9,\n+            0xD9E1E138, 0xEBF8F813, 0x2B9898B3, 0x22111133,\n+            0xD26969BB, 0xA9D9D970, 0x078E8E89, 0x339494A7,\n+            0x2D9B9BB6, 0x3C1E1E22, 0x15878792, 0xC9E9E920,\n+            0x87CECE49, 0xAA5555FF, 0x50282878, 0xA5DFDF7A,\n+            0x038C8C8F, 0x59A1A1F8, 0x09898980, 0x1A0D0D17,\n+            0x65BFBFDA, 0xD7E6E631, 0x844242C6, 0xD06868B8,\n+            0x824141C3, 0x299999B0, 0x5A2D2D77, 0x1E0F0F11,\n+            0x7BB0B0CB, 0xA85454FC, 0x6DBBBBD6, 0x2C16163A,\n+    };\n+\n+    private static final int[] T2 = {\n+            0xA5C66363, 0x84F87C7C, 0x99EE7777, 0x8DF67B7B,\n+            0x0DFFF2F2, 0xBDD66B6B, 0xB1DE6F6F, 0x5491C5C5,\n+            0x50603030, 0x03020101, 0xA9CE6767, 0x7D562B2B,\n+            0x19E7FEFE, 0x62B5D7D7, 0xE64DABAB, 0x9AEC7676,\n+            0x458FCACA, 0x9D1F8282, 0x4089C9C9, 0x87FA7D7D,\n+            0x15EFFAFA, 0xEBB25959, 0xC98E4747, 0x0BFBF0F0,\n+            0xEC41ADAD, 0x67B3D4D4, 0xFD5FA2A2, 0xEA45AFAF,\n+            0xBF239C9C, 0xF753A4A4, 0x96E47272, 0x5B9BC0C0,\n+            0xC275B7B7, 0x1CE1FDFD, 0xAE3D9393, 0x6A4C2626,\n+            0x5A6C3636, 0x417E3F3F, 0x02F5F7F7, 0x4F83CCCC,\n+            0x5C683434, 0xF451A5A5, 0x34D1E5E5, 0x08F9F1F1,\n+            0x93E27171, 0x73ABD8D8, 0x53623131, 0x3F2A1515,\n+            0x0C080404, 0x5295C7C7, 0x65462323, 0x5E9DC3C3,\n+            0x28301818, 0xA1379696, 0x0F0A0505, 0xB52F9A9A,\n+            0x090E0707, 0x36241212, 0x9B1B8080, 0x3DDFE2E2,\n+            0x26CDEBEB, 0x694E2727, 0xCD7FB2B2, 0x9FEA7575,\n+            0x1B120909, 0x9E1D8383, 0x74582C2C, 0x2E341A1A,\n+            0x2D361B1B, 0xB2DC6E6E, 0xEEB45A5A, 0xFB5BA0A0,\n+            0xF6A45252, 0x4D763B3B, 0x61B7D6D6, 0xCE7DB3B3,\n+            0x7B522929, 0x3EDDE3E3, 0x715E2F2F, 0x97138484,\n+            0xF5A65353, 0x68B9D1D1, 0x00000000, 0x2CC1EDED,\n+            0x60402020, 0x1FE3FCFC, 0xC879B1B1, 0xEDB65B5B,\n+            0xBED46A6A, 0x468DCBCB, 0xD967BEBE, 0x4B723939,\n+            0xDE944A4A, 0xD4984C4C, 0xE8B05858, 0x4A85CFCF,\n+            0x6BBBD0D0, 0x2AC5EFEF, 0xE54FAAAA, 0x16EDFBFB,\n+            0xC5864343, 0xD79A4D4D, 0x55663333, 0x94118585,\n+            0xCF8A4545, 0x10E9F9F9, 0x06040202, 0x81FE7F7F,\n+            0xF0A05050, 0x44783C3C, 0xBA259F9F, 0xE34BA8A8,\n+            0xF3A25151, 0xFE5DA3A3, 0xC0804040, 0x8A058F8F,\n+            0xAD3F9292, 0xBC219D9D, 0x48703838, 0x04F1F5F5,\n+            0xDF63BCBC, 0xC177B6B6, 0x75AFDADA, 0x63422121,\n+            0x30201010, 0x1AE5FFFF, 0x0EFDF3F3, 0x6DBFD2D2,\n+            0x4C81CDCD, 0x14180C0C, 0x35261313, 0x2FC3ECEC,\n+            0xE1BE5F5F, 0xA2359797, 0xCC884444, 0x392E1717,\n+            0x5793C4C4, 0xF255A7A7, 0x82FC7E7E, 0x477A3D3D,\n+            0xACC86464, 0xE7BA5D5D, 0x2B321919, 0x95E67373,\n+            0xA0C06060, 0x98198181, 0xD19E4F4F, 0x7FA3DCDC,\n+            0x66442222, 0x7E542A2A, 0xAB3B9090, 0x830B8888,\n+            0xCA8C4646, 0x29C7EEEE, 0xD36BB8B8, 0x3C281414,\n+            0x79A7DEDE, 0xE2BC5E5E, 0x1D160B0B, 0x76ADDBDB,\n+            0x3BDBE0E0, 0x56643232, 0x4E743A3A, 0x1E140A0A,\n+            0xDB924949, 0x0A0C0606, 0x6C482424, 0xE4B85C5C,\n+            0x5D9FC2C2, 0x6EBDD3D3, 0xEF43ACAC, 0xA6C46262,\n+            0xA8399191, 0xA4319595, 0x37D3E4E4, 0x8BF27979,\n+            0x32D5E7E7, 0x438BC8C8, 0x596E3737, 0xB7DA6D6D,\n+            0x8C018D8D, 0x64B1D5D5, 0xD29C4E4E, 0xE049A9A9,\n+            0xB4D86C6C, 0xFAAC5656, 0x07F3F4F4, 0x25CFEAEA,\n+            0xAFCA6565, 0x8EF47A7A, 0xE947AEAE, 0x18100808,\n+            0xD56FBABA, 0x88F07878, 0x6F4A2525, 0x725C2E2E,\n+            0x24381C1C, 0xF157A6A6, 0xC773B4B4, 0x5197C6C6,\n+            0x23CBE8E8, 0x7CA1DDDD, 0x9CE87474, 0x213E1F1F,\n+            0xDD964B4B, 0xDC61BDBD, 0x860D8B8B, 0x850F8A8A,\n+            0x90E07070, 0x427C3E3E, 0xC471B5B5, 0xAACC6666,\n+            0xD8904848, 0x05060303, 0x01F7F6F6, 0x121C0E0E,\n+            0xA3C26161, 0x5F6A3535, 0xF9AE5757, 0xD069B9B9,\n+            0x91178686, 0x5899C1C1, 0x273A1D1D, 0xB9279E9E,\n+            0x38D9E1E1, 0x13EBF8F8, 0xB32B9898, 0x33221111,\n+            0xBBD26969, 0x70A9D9D9, 0x89078E8E, 0xA7339494,\n+            0xB62D9B9B, 0x223C1E1E, 0x92158787, 0x20C9E9E9,\n+            0x4987CECE, 0xFFAA5555, 0x78502828, 0x7AA5DFDF,\n+            0x8F038C8C, 0xF859A1A1, 0x80098989, 0x171A0D0D,\n+            0xDA65BFBF, 0x31D7E6E6, 0xC6844242, 0xB8D06868,\n+            0xC3824141, 0xB0299999, 0x775A2D2D, 0x111E0F0F,\n+            0xCB7BB0B0, 0xFCA85454, 0xD66DBBBB, 0x3A2C1616,\n+    };\n+\n+    private static final int[] T3 = {\n+            0x63A5C663, 0x7C84F87C, 0x7799EE77, 0x7B8DF67B,\n+            0xF20DFFF2, 0x6BBDD66B, 0x6FB1DE6F, 0xC55491C5,\n+            0x30506030, 0x01030201, 0x67A9CE67, 0x2B7D562B,\n+            0xFE19E7FE, 0xD762B5D7, 0xABE64DAB, 0x769AEC76,\n+            0xCA458FCA, 0x829D1F82, 0xC94089C9, 0x7D87FA7D,\n+            0xFA15EFFA, 0x59EBB259, 0x47C98E47, 0xF00BFBF0,\n+            0xADEC41AD, 0xD467B3D4, 0xA2FD5FA2, 0xAFEA45AF,\n+            0x9CBF239C, 0xA4F753A4, 0x7296E472, 0xC05B9BC0,\n+            0xB7C275B7, 0xFD1CE1FD, 0x93AE3D93, 0x266A4C26,\n+            0x365A6C36, 0x3F417E3F, 0xF702F5F7, 0xCC4F83CC,\n+            0x345C6834, 0xA5F451A5, 0xE534D1E5, 0xF108F9F1,\n+            0x7193E271, 0xD873ABD8, 0x31536231, 0x153F2A15,\n+            0x040C0804, 0xC75295C7, 0x23654623, 0xC35E9DC3,\n+            0x18283018, 0x96A13796, 0x050F0A05, 0x9AB52F9A,\n+            0x07090E07, 0x12362412, 0x809B1B80, 0xE23DDFE2,\n+            0xEB26CDEB, 0x27694E27, 0xB2CD7FB2, 0x759FEA75,\n+            0x091B1209, 0x839E1D83, 0x2C74582C, 0x1A2E341A,\n+            0x1B2D361B, 0x6EB2DC6E, 0x5AEEB45A, 0xA0FB5BA0,\n+            0x52F6A452, 0x3B4D763B, 0xD661B7D6, 0xB3CE7DB3,\n+            0x297B5229, 0xE33EDDE3, 0x2F715E2F, 0x84971384,\n+            0x53F5A653, 0xD168B9D1, 0x00000000, 0xED2CC1ED,\n+            0x20604020, 0xFC1FE3FC, 0xB1C879B1, 0x5BEDB65B,\n+            0x6ABED46A, 0xCB468DCB, 0xBED967BE, 0x394B7239,\n+            0x4ADE944A, 0x4CD4984C, 0x58E8B058, 0xCF4A85CF,\n+            0xD06BBBD0, 0xEF2AC5EF, 0xAAE54FAA, 0xFB16EDFB,\n+            0x43C58643, 0x4DD79A4D, 0x33556633, 0x85941185,\n+            0x45CF8A45, 0xF910E9F9, 0x02060402, 0x7F81FE7F,\n+            0x50F0A050, 0x3C44783C, 0x9FBA259F, 0xA8E34BA8,\n+            0x51F3A251, 0xA3FE5DA3, 0x40C08040, 0x8F8A058F,\n+            0x92AD3F92, 0x9DBC219D, 0x38487038, 0xF504F1F5,\n+            0xBCDF63BC, 0xB6C177B6, 0xDA75AFDA, 0x21634221,\n+            0x10302010, 0xFF1AE5FF, 0xF30EFDF3, 0xD26DBFD2,\n+            0xCD4C81CD, 0x0C14180C, 0x13352613, 0xEC2FC3EC,\n+            0x5FE1BE5F, 0x97A23597, 0x44CC8844, 0x17392E17,\n+            0xC45793C4, 0xA7F255A7, 0x7E82FC7E, 0x3D477A3D,\n+            0x64ACC864, 0x5DE7BA5D, 0x192B3219, 0x7395E673,\n+            0x60A0C060, 0x81981981, 0x4FD19E4F, 0xDC7FA3DC,\n+            0x22664422, 0x2A7E542A, 0x90AB3B90, 0x88830B88,\n+            0x46CA8C46, 0xEE29C7EE, 0xB8D36BB8, 0x143C2814,\n+            0xDE79A7DE, 0x5EE2BC5E, 0x0B1D160B, 0xDB76ADDB,\n+            0xE03BDBE0, 0x32566432, 0x3A4E743A, 0x0A1E140A,\n+            0x49DB9249, 0x060A0C06, 0x246C4824, 0x5CE4B85C,\n+            0xC25D9FC2, 0xD36EBDD3, 0xACEF43AC, 0x62A6C462,\n+            0x91A83991, 0x95A43195, 0xE437D3E4, 0x798BF279,\n+            0xE732D5E7, 0xC8438BC8, 0x37596E37, 0x6DB7DA6D,\n+            0x8D8C018D, 0xD564B1D5, 0x4ED29C4E, 0xA9E049A9,\n+            0x6CB4D86C, 0x56FAAC56, 0xF407F3F4, 0xEA25CFEA,\n+            0x65AFCA65, 0x7A8EF47A, 0xAEE947AE, 0x08181008,\n+            0xBAD56FBA, 0x7888F078, 0x256F4A25, 0x2E725C2E,\n+            0x1C24381C, 0xA6F157A6, 0xB4C773B4, 0xC65197C6,\n+            0xE823CBE8, 0xDD7CA1DD, 0x749CE874, 0x1F213E1F,\n+            0x4BDD964B, 0xBDDC61BD, 0x8B860D8B, 0x8A850F8A,\n+            0x7090E070, 0x3E427C3E, 0xB5C471B5, 0x66AACC66,\n+            0x48D89048, 0x03050603, 0xF601F7F6, 0x0E121C0E,\n+            0x61A3C261, 0x355F6A35, 0x57F9AE57, 0xB9D069B9,\n+            0x86911786, 0xC15899C1, 0x1D273A1D, 0x9EB9279E,\n+            0xE138D9E1, 0xF813EBF8, 0x98B32B98, 0x11332211,\n+            0x69BBD269, 0xD970A9D9, 0x8E89078E, 0x94A73394,\n+            0x9BB62D9B, 0x1E223C1E, 0x87921587, 0xE920C9E9,\n+            0xCE4987CE, 0x55FFAA55, 0x28785028, 0xDF7AA5DF,\n+            0x8C8F038C, 0xA1F859A1, 0x89800989, 0x0D171A0D,\n+            0xBFDA65BF, 0xE631D7E6, 0x42C68442, 0x68B8D068,\n+            0x41C38241, 0x99B02999, 0x2D775A2D, 0x0F111E0F,\n+            0xB0CB7BB0, 0x54FCA854, 0xBBD66DBB, 0x163A2C16,\n+    };\n+\n+    private static final int[] T4 = {\n+            0x6363A5C6, 0x7C7C84F8, 0x777799EE, 0x7B7B8DF6,\n+            0xF2F20DFF, 0x6B6BBDD6, 0x6F6FB1DE, 0xC5C55491,\n+            0x30305060, 0x01010302, 0x6767A9CE, 0x2B2B7D56,\n+            0xFEFE19E7, 0xD7D762B5, 0xABABE64D, 0x76769AEC,\n+            0xCACA458F, 0x82829D1F, 0xC9C94089, 0x7D7D87FA,\n+            0xFAFA15EF, 0x5959EBB2, 0x4747C98E, 0xF0F00BFB,\n+            0xADADEC41, 0xD4D467B3, 0xA2A2FD5F, 0xAFAFEA45,\n+            0x9C9CBF23, 0xA4A4F753, 0x727296E4, 0xC0C05B9B,\n+            0xB7B7C275, 0xFDFD1CE1, 0x9393AE3D, 0x26266A4C,\n+            0x36365A6C, 0x3F3F417E, 0xF7F702F5, 0xCCCC4F83,\n+            0x34345C68, 0xA5A5F451, 0xE5E534D1, 0xF1F108F9,\n+            0x717193E2, 0xD8D873AB, 0x31315362, 0x15153F2A,\n+            0x04040C08, 0xC7C75295, 0x23236546, 0xC3C35E9D,\n+            0x18182830, 0x9696A137, 0x05050F0A, 0x9A9AB52F,\n+            0x0707090E, 0x12123624, 0x80809B1B, 0xE2E23DDF,\n+            0xEBEB26CD, 0x2727694E, 0xB2B2CD7F, 0x75759FEA,\n+            0x09091B12, 0x83839E1D, 0x2C2C7458, 0x1A1A2E34,\n+            0x1B1B2D36, 0x6E6EB2DC, 0x5A5AEEB4, 0xA0A0FB5B,\n+            0x5252F6A4, 0x3B3B4D76, 0xD6D661B7, 0xB3B3CE7D,\n+            0x29297B52, 0xE3E33EDD, 0x2F2F715E, 0x84849713,\n+            0x5353F5A6, 0xD1D168B9, 0x00000000, 0xEDED2CC1,\n+            0x20206040, 0xFCFC1FE3, 0xB1B1C879, 0x5B5BEDB6,\n+            0x6A6ABED4, 0xCBCB468D, 0xBEBED967, 0x39394B72,\n+            0x4A4ADE94, 0x4C4CD498, 0x5858E8B0, 0xCFCF4A85,\n+            0xD0D06BBB, 0xEFEF2AC5, 0xAAAAE54F, 0xFBFB16ED,\n+            0x4343C586, 0x4D4DD79A, 0x33335566, 0x85859411,\n+            0x4545CF8A, 0xF9F910E9, 0x02020604, 0x7F7F81FE,\n+            0x5050F0A0, 0x3C3C4478, 0x9F9FBA25, 0xA8A8E34B,\n+            0x5151F3A2, 0xA3A3FE5D, 0x4040C080, 0x8F8F8A05,\n+            0x9292AD3F, 0x9D9DBC21, 0x38384870, 0xF5F504F1,\n+            0xBCBCDF63, 0xB6B6C177, 0xDADA75AF, 0x21216342,\n+            0x10103020, 0xFFFF1AE5, 0xF3F30EFD, 0xD2D26DBF,\n+            0xCDCD4C81, 0x0C0C1418, 0x13133526, 0xECEC2FC3,\n+            0x5F5FE1BE, 0x9797A235, 0x4444CC88, 0x1717392E,\n+            0xC4C45793, 0xA7A7F255, 0x7E7E82FC, 0x3D3D477A,\n+            0x6464ACC8, 0x5D5DE7BA, 0x19192B32, 0x737395E6,\n+            0x6060A0C0, 0x81819819, 0x4F4FD19E, 0xDCDC7FA3,\n+            0x22226644, 0x2A2A7E54, 0x9090AB3B, 0x8888830B,\n+            0x4646CA8C, 0xEEEE29C7, 0xB8B8D36B, 0x14143C28,\n+            0xDEDE79A7, 0x5E5EE2BC, 0x0B0B1D16, 0xDBDB76AD,\n+            0xE0E03BDB, 0x32325664, 0x3A3A4E74, 0x0A0A1E14,\n+            0x4949DB92, 0x06060A0C, 0x24246C48, 0x5C5CE4B8,\n+            0xC2C25D9F, 0xD3D36EBD, 0xACACEF43, 0x6262A6C4,\n+            0x9191A839, 0x9595A431, 0xE4E437D3, 0x79798BF2,\n+            0xE7E732D5, 0xC8C8438B, 0x3737596E, 0x6D6DB7DA,\n+            0x8D8D8C01, 0xD5D564B1, 0x4E4ED29C, 0xA9A9E049,\n+            0x6C6CB4D8, 0x5656FAAC, 0xF4F407F3, 0xEAEA25CF,\n+            0x6565AFCA, 0x7A7A8EF4, 0xAEAEE947, 0x08081810,\n+            0xBABAD56F, 0x787888F0, 0x25256F4A, 0x2E2E725C,\n+            0x1C1C2438, 0xA6A6F157, 0xB4B4C773, 0xC6C65197,\n+            0xE8E823CB, 0xDDDD7CA1, 0x74749CE8, 0x1F1F213E,\n+            0x4B4BDD96, 0xBDBDDC61, 0x8B8B860D, 0x8A8A850F,\n+            0x707090E0, 0x3E3E427C, 0xB5B5C471, 0x6666AACC,\n+            0x4848D890, 0x03030506, 0xF6F601F7, 0x0E0E121C,\n+            0x6161A3C2, 0x35355F6A, 0x5757F9AE, 0xB9B9D069,\n+            0x86869117, 0xC1C15899, 0x1D1D273A, 0x9E9EB927,\n+            0xE1E138D9, 0xF8F813EB, 0x9898B32B, 0x11113322,\n+            0x6969BBD2, 0xD9D970A9, 0x8E8E8907, 0x9494A733,\n+            0x9B9BB62D, 0x1E1E223C, 0x87879215, 0xE9E920C9,\n+            0xCECE4987, 0x5555FFAA, 0x28287850, 0xDFDF7AA5,\n+            0x8C8C8F03, 0xA1A1F859, 0x89898009, 0x0D0D171A,\n+            0xBFBFDA65, 0xE6E631D7, 0x4242C684, 0x6868B8D0,\n+            0x4141C382, 0x9999B029, 0x2D2D775A, 0x0F0F111E,\n+            0xB0B0CB7B, 0x5454FCA8, 0xBBBBD66D, 0x16163A2C,\n+    };\n+\n+\n+    \/\/ pre-computed inverse tables (inverse T-box)\n+    private static final int[] T5 = {\n+            0x51F4A750, 0x7E416553, 0x1A17A4C3, 0x3A275E96,\n+            0x3BAB6BCB, 0x1F9D45F1, 0xACFA58AB, 0x4BE30393,\n+            0x2030FA55, 0xAD766DF6, 0x88CC7691, 0xF5024C25,\n+            0x4FE5D7FC, 0xC52ACBD7, 0x26354480, 0xB562A38F,\n+            0xDEB15A49, 0x25BA1B67, 0x45EA0E98, 0x5DFEC0E1,\n+            0xC32F7502, 0x814CF012, 0x8D4697A3, 0x6BD3F9C6,\n+            0x038F5FE7, 0x15929C95, 0xBF6D7AEB, 0x955259DA,\n+            0xD4BE832D, 0x587421D3, 0x49E06929, 0x8EC9C844,\n+            0x75C2896A, 0xF48E7978, 0x99583E6B, 0x27B971DD,\n+            0xBEE14FB6, 0xF088AD17, 0xC920AC66, 0x7DCE3AB4,\n+            0x63DF4A18, 0xE51A3182, 0x97513360, 0x62537F45,\n+            0xB16477E0, 0xBB6BAE84, 0xFE81A01C, 0xF9082B94,\n+            0x70486858, 0x8F45FD19, 0x94DE6C87, 0x527BF8B7,\n+            0xAB73D323, 0x724B02E2, 0xE31F8F57, 0x6655AB2A,\n+            0xB2EB2807, 0x2FB5C203, 0x86C57B9A, 0xD33708A5,\n+            0x302887F2, 0x23BFA5B2, 0x02036ABA, 0xED16825C,\n+            0x8ACF1C2B, 0xA779B492, 0xF307F2F0, 0x4E69E2A1,\n+            0x65DAF4CD, 0x0605BED5, 0xD134621F, 0xC4A6FE8A,\n+            0x342E539D, 0xA2F355A0, 0x058AE132, 0xA4F6EB75,\n+            0x0B83EC39, 0x4060EFAA, 0x5E719F06, 0xBD6E1051,\n+            0x3E218AF9, 0x96DD063D, 0xDD3E05AE, 0x4DE6BD46,\n+            0x91548DB5, 0x71C45D05, 0x0406D46F, 0x605015FF,\n+            0x1998FB24, 0xD6BDE997, 0x894043CC, 0x67D99E77,\n+            0xB0E842BD, 0x07898B88, 0xE7195B38, 0x79C8EEDB,\n+            0xA17C0A47, 0x7C420FE9, 0xF8841EC9, 0x00000000,\n+            0x09808683, 0x322BED48, 0x1E1170AC, 0x6C5A724E,\n+            0xFD0EFFFB, 0x0F853856, 0x3DAED51E, 0x362D3927,\n+            0x0A0FD964, 0x685CA621, 0x9B5B54D1, 0x24362E3A,\n+            0x0C0A67B1, 0x9357E70F, 0xB4EE96D2, 0x1B9B919E,\n+            0x80C0C54F, 0x61DC20A2, 0x5A774B69, 0x1C121A16,\n+            0xE293BA0A, 0xC0A02AE5, 0x3C22E043, 0x121B171D,\n+            0x0E090D0B, 0xF28BC7AD, 0x2DB6A8B9, 0x141EA9C8,\n+            0x57F11985, 0xAF75074C, 0xEE99DDBB, 0xA37F60FD,\n+            0xF701269F, 0x5C72F5BC, 0x44663BC5, 0x5BFB7E34,\n+            0x8B432976, 0xCB23C6DC, 0xB6EDFC68, 0xB8E4F163,\n+            0xD731DCCA, 0x42638510, 0x13972240, 0x84C61120,\n+            0x854A247D, 0xD2BB3DF8, 0xAEF93211, 0xC729A16D,\n+            0x1D9E2F4B, 0xDCB230F3, 0x0D8652EC, 0x77C1E3D0,\n+            0x2BB3166C, 0xA970B999, 0x119448FA, 0x47E96422,\n+            0xA8FC8CC4, 0xA0F03F1A, 0x567D2CD8, 0x223390EF,\n+            0x87494EC7, 0xD938D1C1, 0x8CCAA2FE, 0x98D40B36,\n+            0xA6F581CF, 0xA57ADE28, 0xDAB78E26, 0x3FADBFA4,\n+            0x2C3A9DE4, 0x5078920D, 0x6A5FCC9B, 0x547E4662,\n+            0xF68D13C2, 0x90D8B8E8, 0x2E39F75E, 0x82C3AFF5,\n+            0x9F5D80BE, 0x69D0937C, 0x6FD52DA9, 0xCF2512B3,\n+            0xC8AC993B, 0x10187DA7, 0xE89C636E, 0xDB3BBB7B,\n+            0xCD267809, 0x6E5918F4, 0xEC9AB701, 0x834F9AA8,\n+            0xE6956E65, 0xAAFFE67E, 0x21BCCF08, 0xEF15E8E6,\n+            0xBAE79BD9, 0x4A6F36CE, 0xEA9F09D4, 0x29B07CD6,\n+            0x31A4B2AF, 0x2A3F2331, 0xC6A59430, 0x35A266C0,\n+            0x744EBC37, 0xFC82CAA6, 0xE090D0B0, 0x33A7D815,\n+            0xF104984A, 0x41ECDAF7, 0x7FCD500E, 0x1791F62F,\n+            0x764DD68D, 0x43EFB04D, 0xCCAA4D54, 0xE49604DF,\n+            0x9ED1B5E3, 0x4C6A881B, 0xC12C1FB8, 0x4665517F,\n+            0x9D5EEA04, 0x018C355D, 0xFA877473, 0xFB0B412E,\n+            0xB3671D5A, 0x92DBD252, 0xE9105633, 0x6DD64713,\n+            0x9AD7618C, 0x37A10C7A, 0x59F8148E, 0xEB133C89,\n+            0xCEA927EE, 0xB761C935, 0xE11CE5ED, 0x7A47B13C,\n+            0x9CD2DF59, 0x55F2733F, 0x1814CE79, 0x73C737BF,\n+            0x53F7CDEA, 0x5FFDAA5B, 0xDF3D6F14, 0x7844DB86,\n+            0xCAAFF381, 0xB968C43E, 0x3824342C, 0xC2A3405F,\n+            0x161DC372, 0xBCE2250C, 0x283C498B, 0xFF0D9541,\n+            0x39A80171, 0x080CB3DE, 0xD8B4E49C, 0x6456C190,\n+            0x7BCB8461, 0xD532B670, 0x486C5C74, 0xD0B85742,\n+    };\n+\n+    private static final int[] T6 = {\n+            0x5051F4A7, 0x537E4165, 0xC31A17A4, 0x963A275E,\n+            0xCB3BAB6B, 0xF11F9D45, 0xABACFA58, 0x934BE303,\n+            0x552030FA, 0xF6AD766D, 0x9188CC76, 0x25F5024C,\n+            0xFC4FE5D7, 0xD7C52ACB, 0x80263544, 0x8FB562A3,\n+            0x49DEB15A, 0x6725BA1B, 0x9845EA0E, 0xE15DFEC0,\n+            0x02C32F75, 0x12814CF0, 0xA38D4697, 0xC66BD3F9,\n+            0xE7038F5F, 0x9515929C, 0xEBBF6D7A, 0xDA955259,\n+            0x2DD4BE83, 0xD3587421, 0x2949E069, 0x448EC9C8,\n+            0x6A75C289, 0x78F48E79, 0x6B99583E, 0xDD27B971,\n+            0xB6BEE14F, 0x17F088AD, 0x66C920AC, 0xB47DCE3A,\n+            0x1863DF4A, 0x82E51A31, 0x60975133, 0x4562537F,\n+            0xE0B16477, 0x84BB6BAE, 0x1CFE81A0, 0x94F9082B,\n+            0x58704868, 0x198F45FD, 0x8794DE6C, 0xB7527BF8,\n+            0x23AB73D3, 0xE2724B02, 0x57E31F8F, 0x2A6655AB,\n+            0x07B2EB28, 0x032FB5C2, 0x9A86C57B, 0xA5D33708,\n+            0xF2302887, 0xB223BFA5, 0xBA02036A, 0x5CED1682,\n+            0x2B8ACF1C, 0x92A779B4, 0xF0F307F2, 0xA14E69E2,\n+            0xCD65DAF4, 0xD50605BE, 0x1FD13462, 0x8AC4A6FE,\n+            0x9D342E53, 0xA0A2F355, 0x32058AE1, 0x75A4F6EB,\n+            0x390B83EC, 0xAA4060EF, 0x065E719F, 0x51BD6E10,\n+            0xF93E218A, 0x3D96DD06, 0xAEDD3E05, 0x464DE6BD,\n+            0xB591548D, 0x0571C45D, 0x6F0406D4, 0xFF605015,\n+            0x241998FB, 0x97D6BDE9, 0xCC894043, 0x7767D99E,\n+            0xBDB0E842, 0x8807898B, 0x38E7195B, 0xDB79C8EE,\n+            0x47A17C0A, 0xE97C420F, 0xC9F8841E, 0x00000000,\n+            0x83098086, 0x48322BED, 0xAC1E1170, 0x4E6C5A72,\n+            0xFBFD0EFF, 0x560F8538, 0x1E3DAED5, 0x27362D39,\n+            0x640A0FD9, 0x21685CA6, 0xD19B5B54, 0x3A24362E,\n+            0xB10C0A67, 0x0F9357E7, 0xD2B4EE96, 0x9E1B9B91,\n+            0x4F80C0C5, 0xA261DC20, 0x695A774B, 0x161C121A,\n+            0x0AE293BA, 0xE5C0A02A, 0x433C22E0, 0x1D121B17,\n+            0x0B0E090D, 0xADF28BC7, 0xB92DB6A8, 0xC8141EA9,\n+            0x8557F119, 0x4CAF7507, 0xBBEE99DD, 0xFDA37F60,\n+            0x9FF70126, 0xBC5C72F5, 0xC544663B, 0x345BFB7E,\n+            0x768B4329, 0xDCCB23C6, 0x68B6EDFC, 0x63B8E4F1,\n+            0xCAD731DC, 0x10426385, 0x40139722, 0x2084C611,\n+            0x7D854A24, 0xF8D2BB3D, 0x11AEF932, 0x6DC729A1,\n+            0x4B1D9E2F, 0xF3DCB230, 0xEC0D8652, 0xD077C1E3,\n+            0x6C2BB316, 0x99A970B9, 0xFA119448, 0x2247E964,\n+            0xC4A8FC8C, 0x1AA0F03F, 0xD8567D2C, 0xEF223390,\n+            0xC787494E, 0xC1D938D1, 0xFE8CCAA2, 0x3698D40B,\n+            0xCFA6F581, 0x28A57ADE, 0x26DAB78E, 0xA43FADBF,\n+            0xE42C3A9D, 0x0D507892, 0x9B6A5FCC, 0x62547E46,\n+            0xC2F68D13, 0xE890D8B8, 0x5E2E39F7, 0xF582C3AF,\n+            0xBE9F5D80, 0x7C69D093, 0xA96FD52D, 0xB3CF2512,\n+            0x3BC8AC99, 0xA710187D, 0x6EE89C63, 0x7BDB3BBB,\n+            0x09CD2678, 0xF46E5918, 0x01EC9AB7, 0xA8834F9A,\n+            0x65E6956E, 0x7EAAFFE6, 0x0821BCCF, 0xE6EF15E8,\n+            0xD9BAE79B, 0xCE4A6F36, 0xD4EA9F09, 0xD629B07C,\n+            0xAF31A4B2, 0x312A3F23, 0x30C6A594, 0xC035A266,\n+            0x37744EBC, 0xA6FC82CA, 0xB0E090D0, 0x1533A7D8,\n+            0x4AF10498, 0xF741ECDA, 0x0E7FCD50, 0x2F1791F6,\n+            0x8D764DD6, 0x4D43EFB0, 0x54CCAA4D, 0xDFE49604,\n+            0xE39ED1B5, 0x1B4C6A88, 0xB8C12C1F, 0x7F466551,\n+            0x049D5EEA, 0x5D018C35, 0x73FA8774, 0x2EFB0B41,\n+            0x5AB3671D, 0x5292DBD2, 0x33E91056, 0x136DD647,\n+            0x8C9AD761, 0x7A37A10C, 0x8E59F814, 0x89EB133C,\n+            0xEECEA927, 0x35B761C9, 0xEDE11CE5, 0x3C7A47B1,\n+            0x599CD2DF, 0x3F55F273, 0x791814CE, 0xBF73C737,\n+            0xEA53F7CD, 0x5B5FFDAA, 0x14DF3D6F, 0x867844DB,\n+            0x81CAAFF3, 0x3EB968C4, 0x2C382434, 0x5FC2A340,\n+            0x72161DC3, 0x0CBCE225, 0x8B283C49, 0x41FF0D95,\n+            0x7139A801, 0xDE080CB3, 0x9CD8B4E4, 0x906456C1,\n+            0x617BCB84, 0x70D532B6, 0x74486C5C, 0x42D0B857,\n+    };\n+\n+    private static final int[] T7 = {\n+            0xA75051F4, 0x65537E41, 0xA4C31A17, 0x5E963A27,\n+            0x6BCB3BAB, 0x45F11F9D, 0x58ABACFA, 0x03934BE3,\n+            0xFA552030, 0x6DF6AD76, 0x769188CC, 0x4C25F502,\n+            0xD7FC4FE5, 0xCBD7C52A, 0x44802635, 0xA38FB562,\n+            0x5A49DEB1, 0x1B6725BA, 0x0E9845EA, 0xC0E15DFE,\n+            0x7502C32F, 0xF012814C, 0x97A38D46, 0xF9C66BD3,\n+            0x5FE7038F, 0x9C951592, 0x7AEBBF6D, 0x59DA9552,\n+            0x832DD4BE, 0x21D35874, 0x692949E0, 0xC8448EC9,\n+            0x896A75C2, 0x7978F48E, 0x3E6B9958, 0x71DD27B9,\n+            0x4FB6BEE1, 0xAD17F088, 0xAC66C920, 0x3AB47DCE,\n+            0x4A1863DF, 0x3182E51A, 0x33609751, 0x7F456253,\n+            0x77E0B164, 0xAE84BB6B, 0xA01CFE81, 0x2B94F908,\n+            0x68587048, 0xFD198F45, 0x6C8794DE, 0xF8B7527B,\n+            0xD323AB73, 0x02E2724B, 0x8F57E31F, 0xAB2A6655,\n+            0x2807B2EB, 0xC2032FB5, 0x7B9A86C5, 0x08A5D337,\n+            0x87F23028, 0xA5B223BF, 0x6ABA0203, 0x825CED16,\n+            0x1C2B8ACF, 0xB492A779, 0xF2F0F307, 0xE2A14E69,\n+            0xF4CD65DA, 0xBED50605, 0x621FD134, 0xFE8AC4A6,\n+            0x539D342E, 0x55A0A2F3, 0xE132058A, 0xEB75A4F6,\n+            0xEC390B83, 0xEFAA4060, 0x9F065E71, 0x1051BD6E,\n+            0x8AF93E21, 0x063D96DD, 0x05AEDD3E, 0xBD464DE6,\n+            0x8DB59154, 0x5D0571C4, 0xD46F0406, 0x15FF6050,\n+            0xFB241998, 0xE997D6BD, 0x43CC8940, 0x9E7767D9,\n+            0x42BDB0E8, 0x8B880789, 0x5B38E719, 0xEEDB79C8,\n+            0x0A47A17C, 0x0FE97C42, 0x1EC9F884, 0x00000000,\n+            0x86830980, 0xED48322B, 0x70AC1E11, 0x724E6C5A,\n+            0xFFFBFD0E, 0x38560F85, 0xD51E3DAE, 0x3927362D,\n+            0xD9640A0F, 0xA621685C, 0x54D19B5B, 0x2E3A2436,\n+            0x67B10C0A, 0xE70F9357, 0x96D2B4EE, 0x919E1B9B,\n+            0xC54F80C0, 0x20A261DC, 0x4B695A77, 0x1A161C12,\n+            0xBA0AE293, 0x2AE5C0A0, 0xE0433C22, 0x171D121B,\n+            0x0D0B0E09, 0xC7ADF28B, 0xA8B92DB6, 0xA9C8141E,\n+            0x198557F1, 0x074CAF75, 0xDDBBEE99, 0x60FDA37F,\n+            0x269FF701, 0xF5BC5C72, 0x3BC54466, 0x7E345BFB,\n+            0x29768B43, 0xC6DCCB23, 0xFC68B6ED, 0xF163B8E4,\n+            0xDCCAD731, 0x85104263, 0x22401397, 0x112084C6,\n+            0x247D854A, 0x3DF8D2BB, 0x3211AEF9, 0xA16DC729,\n+            0x2F4B1D9E, 0x30F3DCB2, 0x52EC0D86, 0xE3D077C1,\n+            0x166C2BB3, 0xB999A970, 0x48FA1194, 0x642247E9,\n+            0x8CC4A8FC, 0x3F1AA0F0, 0x2CD8567D, 0x90EF2233,\n+            0x4EC78749, 0xD1C1D938, 0xA2FE8CCA, 0x0B3698D4,\n+            0x81CFA6F5, 0xDE28A57A, 0x8E26DAB7, 0xBFA43FAD,\n+            0x9DE42C3A, 0x920D5078, 0xCC9B6A5F, 0x4662547E,\n+            0x13C2F68D, 0xB8E890D8, 0xF75E2E39, 0xAFF582C3,\n+            0x80BE9F5D, 0x937C69D0, 0x2DA96FD5, 0x12B3CF25,\n+            0x993BC8AC, 0x7DA71018, 0x636EE89C, 0xBB7BDB3B,\n+            0x7809CD26, 0x18F46E59, 0xB701EC9A, 0x9AA8834F,\n+            0x6E65E695, 0xE67EAAFF, 0xCF0821BC, 0xE8E6EF15,\n+            0x9BD9BAE7, 0x36CE4A6F, 0x09D4EA9F, 0x7CD629B0,\n+            0xB2AF31A4, 0x23312A3F, 0x9430C6A5, 0x66C035A2,\n+            0xBC37744E, 0xCAA6FC82, 0xD0B0E090, 0xD81533A7,\n+            0x984AF104, 0xDAF741EC, 0x500E7FCD, 0xF62F1791,\n+            0xD68D764D, 0xB04D43EF, 0x4D54CCAA, 0x04DFE496,\n+            0xB5E39ED1, 0x881B4C6A, 0x1FB8C12C, 0x517F4665,\n+            0xEA049D5E, 0x355D018C, 0x7473FA87, 0x412EFB0B,\n+            0x1D5AB367, 0xD25292DB, 0x5633E910, 0x47136DD6,\n+            0x618C9AD7, 0x0C7A37A1, 0x148E59F8, 0x3C89EB13,\n+            0x27EECEA9, 0xC935B761, 0xE5EDE11C, 0xB13C7A47,\n+            0xDF599CD2, 0x733F55F2, 0xCE791814, 0x37BF73C7,\n+            0xCDEA53F7, 0xAA5B5FFD, 0x6F14DF3D, 0xDB867844,\n+            0xF381CAAF, 0xC43EB968, 0x342C3824, 0x405FC2A3,\n+            0xC372161D, 0x250CBCE2, 0x498B283C, 0x9541FF0D,\n+            0x017139A8, 0xB3DE080C, 0xE49CD8B4, 0xC1906456,\n+            0x84617BCB, 0xB670D532, 0x5C74486C, 0x5742D0B8,\n+    };\n+\n+    private static final int[] T8 = {\n+            0xF4A75051, 0x4165537E, 0x17A4C31A, 0x275E963A,\n+            0xAB6BCB3B, 0x9D45F11F, 0xFA58ABAC, 0xE303934B,\n+            0x30FA5520, 0x766DF6AD, 0xCC769188, 0x024C25F5,\n+            0xE5D7FC4F, 0x2ACBD7C5, 0x35448026, 0x62A38FB5,\n+            0xB15A49DE, 0xBA1B6725, 0xEA0E9845, 0xFEC0E15D,\n+            0x2F7502C3, 0x4CF01281, 0x4697A38D, 0xD3F9C66B,\n+            0x8F5FE703, 0x929C9515, 0x6D7AEBBF, 0x5259DA95,\n+            0xBE832DD4, 0x7421D358, 0xE0692949, 0xC9C8448E,\n+            0xC2896A75, 0x8E7978F4, 0x583E6B99, 0xB971DD27,\n+            0xE14FB6BE, 0x88AD17F0, 0x20AC66C9, 0xCE3AB47D,\n+            0xDF4A1863, 0x1A3182E5, 0x51336097, 0x537F4562,\n+            0x6477E0B1, 0x6BAE84BB, 0x81A01CFE, 0x082B94F9,\n+            0x48685870, 0x45FD198F, 0xDE6C8794, 0x7BF8B752,\n+            0x73D323AB, 0x4B02E272, 0x1F8F57E3, 0x55AB2A66,\n+            0xEB2807B2, 0xB5C2032F, 0xC57B9A86, 0x3708A5D3,\n+            0x2887F230, 0xBFA5B223, 0x036ABA02, 0x16825CED,\n+            0xCF1C2B8A, 0x79B492A7, 0x07F2F0F3, 0x69E2A14E,\n+            0xDAF4CD65, 0x05BED506, 0x34621FD1, 0xA6FE8AC4,\n+            0x2E539D34, 0xF355A0A2, 0x8AE13205, 0xF6EB75A4,\n+            0x83EC390B, 0x60EFAA40, 0x719F065E, 0x6E1051BD,\n+            0x218AF93E, 0xDD063D96, 0x3E05AEDD, 0xE6BD464D,\n+            0x548DB591, 0xC45D0571, 0x06D46F04, 0x5015FF60,\n+            0x98FB2419, 0xBDE997D6, 0x4043CC89, 0xD99E7767,\n+            0xE842BDB0, 0x898B8807, 0x195B38E7, 0xC8EEDB79,\n+            0x7C0A47A1, 0x420FE97C, 0x841EC9F8, 0x00000000,\n+            0x80868309, 0x2BED4832, 0x1170AC1E, 0x5A724E6C,\n+            0x0EFFFBFD, 0x8538560F, 0xAED51E3D, 0x2D392736,\n+            0x0FD9640A, 0x5CA62168, 0x5B54D19B, 0x362E3A24,\n+            0x0A67B10C, 0x57E70F93, 0xEE96D2B4, 0x9B919E1B,\n+            0xC0C54F80, 0xDC20A261, 0x774B695A, 0x121A161C,\n+            0x93BA0AE2, 0xA02AE5C0, 0x22E0433C, 0x1B171D12,\n+            0x090D0B0E, 0x8BC7ADF2, 0xB6A8B92D, 0x1EA9C814,\n+            0xF1198557, 0x75074CAF, 0x99DDBBEE, 0x7F60FDA3,\n+            0x01269FF7, 0x72F5BC5C, 0x663BC544, 0xFB7E345B,\n+            0x4329768B, 0x23C6DCCB, 0xEDFC68B6, 0xE4F163B8,\n+            0x31DCCAD7, 0x63851042, 0x97224013, 0xC6112084,\n+            0x4A247D85, 0xBB3DF8D2, 0xF93211AE, 0x29A16DC7,\n+            0x9E2F4B1D, 0xB230F3DC, 0x8652EC0D, 0xC1E3D077,\n+            0xB3166C2B, 0x70B999A9, 0x9448FA11, 0xE9642247,\n+            0xFC8CC4A8, 0xF03F1AA0, 0x7D2CD856, 0x3390EF22,\n+            0x494EC787, 0x38D1C1D9, 0xCAA2FE8C, 0xD40B3698,\n+            0xF581CFA6, 0x7ADE28A5, 0xB78E26DA, 0xADBFA43F,\n+            0x3A9DE42C, 0x78920D50, 0x5FCC9B6A, 0x7E466254,\n+            0x8D13C2F6, 0xD8B8E890, 0x39F75E2E, 0xC3AFF582,\n+            0x5D80BE9F, 0xD0937C69, 0xD52DA96F, 0x2512B3CF,\n+            0xAC993BC8, 0x187DA710, 0x9C636EE8, 0x3BBB7BDB,\n+            0x267809CD, 0x5918F46E, 0x9AB701EC, 0x4F9AA883,\n+            0x956E65E6, 0xFFE67EAA, 0xBCCF0821, 0x15E8E6EF,\n+            0xE79BD9BA, 0x6F36CE4A, 0x9F09D4EA, 0xB07CD629,\n+            0xA4B2AF31, 0x3F23312A, 0xA59430C6, 0xA266C035,\n+            0x4EBC3774, 0x82CAA6FC, 0x90D0B0E0, 0xA7D81533,\n+            0x04984AF1, 0xECDAF741, 0xCD500E7F, 0x91F62F17,\n+            0x4DD68D76, 0xEFB04D43, 0xAA4D54CC, 0x9604DFE4,\n+            0xD1B5E39E, 0x6A881B4C, 0x2C1FB8C1, 0x65517F46,\n+            0x5EEA049D, 0x8C355D01, 0x877473FA, 0x0B412EFB,\n+            0x671D5AB3, 0xDBD25292, 0x105633E9, 0xD647136D,\n+            0xD7618C9A, 0xA10C7A37, 0xF8148E59, 0x133C89EB,\n+            0xA927EECE, 0x61C935B7, 0x1CE5EDE1, 0x47B13C7A,\n+            0xD2DF599C, 0xF2733F55, 0x14CE7918, 0xC737BF73,\n+            0xF7CDEA53, 0xFDAA5B5F, 0x3D6F14DF, 0x44DB8678,\n+            0xAFF381CA, 0x68C43EB9, 0x24342C38, 0xA3405FC2,\n+            0x1DC37216, 0xE2250CBC, 0x3C498B28, 0x0D9541FF,\n+            0xA8017139, 0x0CB3DE08, 0xB4E49CD8, 0x56C19064,\n+            0xCB84617B, 0x32B670D5, 0x6C5C7448, 0xB85742D0,\n+    };\n+\n+    private static final int[] U1 = {\n+            0x00000000, 0x0E090D0B, 0x1C121A16, 0x121B171D,\n+            0x3824342C, 0x362D3927, 0x24362E3A, 0x2A3F2331,\n+            0x70486858, 0x7E416553, 0x6C5A724E, 0x62537F45,\n+            0x486C5C74, 0x4665517F, 0x547E4662, 0x5A774B69,\n+            0xE090D0B0, 0xEE99DDBB, 0xFC82CAA6, 0xF28BC7AD,\n+            0xD8B4E49C, 0xD6BDE997, 0xC4A6FE8A, 0xCAAFF381,\n+            0x90D8B8E8, 0x9ED1B5E3, 0x8CCAA2FE, 0x82C3AFF5,\n+            0xA8FC8CC4, 0xA6F581CF, 0xB4EE96D2, 0xBAE79BD9,\n+            0xDB3BBB7B, 0xD532B670, 0xC729A16D, 0xC920AC66,\n+            0xE31F8F57, 0xED16825C, 0xFF0D9541, 0xF104984A,\n+            0xAB73D323, 0xA57ADE28, 0xB761C935, 0xB968C43E,\n+            0x9357E70F, 0x9D5EEA04, 0x8F45FD19, 0x814CF012,\n+            0x3BAB6BCB, 0x35A266C0, 0x27B971DD, 0x29B07CD6,\n+            0x038F5FE7, 0x0D8652EC, 0x1F9D45F1, 0x119448FA,\n+            0x4BE30393, 0x45EA0E98, 0x57F11985, 0x59F8148E,\n+            0x73C737BF, 0x7DCE3AB4, 0x6FD52DA9, 0x61DC20A2,\n+            0xAD766DF6, 0xA37F60FD, 0xB16477E0, 0xBF6D7AEB,\n+            0x955259DA, 0x9B5B54D1, 0x894043CC, 0x87494EC7,\n+            0xDD3E05AE, 0xD33708A5, 0xC12C1FB8, 0xCF2512B3,\n+            0xE51A3182, 0xEB133C89, 0xF9082B94, 0xF701269F,\n+            0x4DE6BD46, 0x43EFB04D, 0x51F4A750, 0x5FFDAA5B,\n+            0x75C2896A, 0x7BCB8461, 0x69D0937C, 0x67D99E77,\n+            0x3DAED51E, 0x33A7D815, 0x21BCCF08, 0x2FB5C203,\n+            0x058AE132, 0x0B83EC39, 0x1998FB24, 0x1791F62F,\n+            0x764DD68D, 0x7844DB86, 0x6A5FCC9B, 0x6456C190,\n+            0x4E69E2A1, 0x4060EFAA, 0x527BF8B7, 0x5C72F5BC,\n+            0x0605BED5, 0x080CB3DE, 0x1A17A4C3, 0x141EA9C8,\n+            0x3E218AF9, 0x302887F2, 0x223390EF, 0x2C3A9DE4,\n+            0x96DD063D, 0x98D40B36, 0x8ACF1C2B, 0x84C61120,\n+            0xAEF93211, 0xA0F03F1A, 0xB2EB2807, 0xBCE2250C,\n+            0xE6956E65, 0xE89C636E, 0xFA877473, 0xF48E7978,\n+            0xDEB15A49, 0xD0B85742, 0xC2A3405F, 0xCCAA4D54,\n+            0x41ECDAF7, 0x4FE5D7FC, 0x5DFEC0E1, 0x53F7CDEA,\n+            0x79C8EEDB, 0x77C1E3D0, 0x65DAF4CD, 0x6BD3F9C6,\n+            0x31A4B2AF, 0x3FADBFA4, 0x2DB6A8B9, 0x23BFA5B2,\n+            0x09808683, 0x07898B88, 0x15929C95, 0x1B9B919E,\n+            0xA17C0A47, 0xAF75074C, 0xBD6E1051, 0xB3671D5A,\n+            0x99583E6B, 0x97513360, 0x854A247D, 0x8B432976,\n+            0xD134621F, 0xDF3D6F14, 0xCD267809, 0xC32F7502,\n+            0xE9105633, 0xE7195B38, 0xF5024C25, 0xFB0B412E,\n+            0x9AD7618C, 0x94DE6C87, 0x86C57B9A, 0x88CC7691,\n+            0xA2F355A0, 0xACFA58AB, 0xBEE14FB6, 0xB0E842BD,\n+            0xEA9F09D4, 0xE49604DF, 0xF68D13C2, 0xF8841EC9,\n+            0xD2BB3DF8, 0xDCB230F3, 0xCEA927EE, 0xC0A02AE5,\n+            0x7A47B13C, 0x744EBC37, 0x6655AB2A, 0x685CA621,\n+            0x42638510, 0x4C6A881B, 0x5E719F06, 0x5078920D,\n+            0x0A0FD964, 0x0406D46F, 0x161DC372, 0x1814CE79,\n+            0x322BED48, 0x3C22E043, 0x2E39F75E, 0x2030FA55,\n+            0xEC9AB701, 0xE293BA0A, 0xF088AD17, 0xFE81A01C,\n+            0xD4BE832D, 0xDAB78E26, 0xC8AC993B, 0xC6A59430,\n+            0x9CD2DF59, 0x92DBD252, 0x80C0C54F, 0x8EC9C844,\n+            0xA4F6EB75, 0xAAFFE67E, 0xB8E4F163, 0xB6EDFC68,\n+            0x0C0A67B1, 0x02036ABA, 0x10187DA7, 0x1E1170AC,\n+            0x342E539D, 0x3A275E96, 0x283C498B, 0x26354480,\n+            0x7C420FE9, 0x724B02E2, 0x605015FF, 0x6E5918F4,\n+            0x44663BC5, 0x4A6F36CE, 0x587421D3, 0x567D2CD8,\n+            0x37A10C7A, 0x39A80171, 0x2BB3166C, 0x25BA1B67,\n+            0x0F853856, 0x018C355D, 0x13972240, 0x1D9E2F4B,\n+            0x47E96422, 0x49E06929, 0x5BFB7E34, 0x55F2733F,\n+            0x7FCD500E, 0x71C45D05, 0x63DF4A18, 0x6DD64713,\n+            0xD731DCCA, 0xD938D1C1, 0xCB23C6DC, 0xC52ACBD7,\n+            0xEF15E8E6, 0xE11CE5ED, 0xF307F2F0, 0xFD0EFFFB,\n+            0xA779B492, 0xA970B999, 0xBB6BAE84, 0xB562A38F,\n+            0x9F5D80BE, 0x91548DB5, 0x834F9AA8, 0x8D4697A3,\n+    };\n+\n+    private static final int[] U2 = {\n+            0x00000000, 0x0B0E090D, 0x161C121A, 0x1D121B17,\n+            0x2C382434, 0x27362D39, 0x3A24362E, 0x312A3F23,\n+            0x58704868, 0x537E4165, 0x4E6C5A72, 0x4562537F,\n+            0x74486C5C, 0x7F466551, 0x62547E46, 0x695A774B,\n+            0xB0E090D0, 0xBBEE99DD, 0xA6FC82CA, 0xADF28BC7,\n+            0x9CD8B4E4, 0x97D6BDE9, 0x8AC4A6FE, 0x81CAAFF3,\n+            0xE890D8B8, 0xE39ED1B5, 0xFE8CCAA2, 0xF582C3AF,\n+            0xC4A8FC8C, 0xCFA6F581, 0xD2B4EE96, 0xD9BAE79B,\n+            0x7BDB3BBB, 0x70D532B6, 0x6DC729A1, 0x66C920AC,\n+            0x57E31F8F, 0x5CED1682, 0x41FF0D95, 0x4AF10498,\n+            0x23AB73D3, 0x28A57ADE, 0x35B761C9, 0x3EB968C4,\n+            0x0F9357E7, 0x049D5EEA, 0x198F45FD, 0x12814CF0,\n+            0xCB3BAB6B, 0xC035A266, 0xDD27B971, 0xD629B07C,\n+            0xE7038F5F, 0xEC0D8652, 0xF11F9D45, 0xFA119448,\n+            0x934BE303, 0x9845EA0E, 0x8557F119, 0x8E59F814,\n+            0xBF73C737, 0xB47DCE3A, 0xA96FD52D, 0xA261DC20,\n+            0xF6AD766D, 0xFDA37F60, 0xE0B16477, 0xEBBF6D7A,\n+            0xDA955259, 0xD19B5B54, 0xCC894043, 0xC787494E,\n+            0xAEDD3E05, 0xA5D33708, 0xB8C12C1F, 0xB3CF2512,\n+            0x82E51A31, 0x89EB133C, 0x94F9082B, 0x9FF70126,\n+            0x464DE6BD, 0x4D43EFB0, 0x5051F4A7, 0x5B5FFDAA,\n+            0x6A75C289, 0x617BCB84, 0x7C69D093, 0x7767D99E,\n+            0x1E3DAED5, 0x1533A7D8, 0x0821BCCF, 0x032FB5C2,\n+            0x32058AE1, 0x390B83EC, 0x241998FB, 0x2F1791F6,\n+            0x8D764DD6, 0x867844DB, 0x9B6A5FCC, 0x906456C1,\n+            0xA14E69E2, 0xAA4060EF, 0xB7527BF8, 0xBC5C72F5,\n+            0xD50605BE, 0xDE080CB3, 0xC31A17A4, 0xC8141EA9,\n+            0xF93E218A, 0xF2302887, 0xEF223390, 0xE42C3A9D,\n+            0x3D96DD06, 0x3698D40B, 0x2B8ACF1C, 0x2084C611,\n+            0x11AEF932, 0x1AA0F03F, 0x07B2EB28, 0x0CBCE225,\n+            0x65E6956E, 0x6EE89C63, 0x73FA8774, 0x78F48E79,\n+            0x49DEB15A, 0x42D0B857, 0x5FC2A340, 0x54CCAA4D,\n+            0xF741ECDA, 0xFC4FE5D7, 0xE15DFEC0, 0xEA53F7CD,\n+            0xDB79C8EE, 0xD077C1E3, 0xCD65DAF4, 0xC66BD3F9,\n+            0xAF31A4B2, 0xA43FADBF, 0xB92DB6A8, 0xB223BFA5,\n+            0x83098086, 0x8807898B, 0x9515929C, 0x9E1B9B91,\n+            0x47A17C0A, 0x4CAF7507, 0x51BD6E10, 0x5AB3671D,\n+            0x6B99583E, 0x60975133, 0x7D854A24, 0x768B4329,\n+            0x1FD13462, 0x14DF3D6F, 0x09CD2678, 0x02C32F75,\n+            0x33E91056, 0x38E7195B, 0x25F5024C, 0x2EFB0B41,\n+            0x8C9AD761, 0x8794DE6C, 0x9A86C57B, 0x9188CC76,\n+            0xA0A2F355, 0xABACFA58, 0xB6BEE14F, 0xBDB0E842,\n+            0xD4EA9F09, 0xDFE49604, 0xC2F68D13, 0xC9F8841E,\n+            0xF8D2BB3D, 0xF3DCB230, 0xEECEA927, 0xE5C0A02A,\n+            0x3C7A47B1, 0x37744EBC, 0x2A6655AB, 0x21685CA6,\n+            0x10426385, 0x1B4C6A88, 0x065E719F, 0x0D507892,\n+            0x640A0FD9, 0x6F0406D4, 0x72161DC3, 0x791814CE,\n+            0x48322BED, 0x433C22E0, 0x5E2E39F7, 0x552030FA,\n+            0x01EC9AB7, 0x0AE293BA, 0x17F088AD, 0x1CFE81A0,\n+            0x2DD4BE83, 0x26DAB78E, 0x3BC8AC99, 0x30C6A594,\n+            0x599CD2DF, 0x5292DBD2, 0x4F80C0C5, 0x448EC9C8,\n+            0x75A4F6EB, 0x7EAAFFE6, 0x63B8E4F1, 0x68B6EDFC,\n+            0xB10C0A67, 0xBA02036A, 0xA710187D, 0xAC1E1170,\n+            0x9D342E53, 0x963A275E, 0x8B283C49, 0x80263544,\n+            0xE97C420F, 0xE2724B02, 0xFF605015, 0xF46E5918,\n+            0xC544663B, 0xCE4A6F36, 0xD3587421, 0xD8567D2C,\n+            0x7A37A10C, 0x7139A801, 0x6C2BB316, 0x6725BA1B,\n+            0x560F8538, 0x5D018C35, 0x40139722, 0x4B1D9E2F,\n+            0x2247E964, 0x2949E069, 0x345BFB7E, 0x3F55F273,\n+            0x0E7FCD50, 0x0571C45D, 0x1863DF4A, 0x136DD647,\n+            0xCAD731DC, 0xC1D938D1, 0xDCCB23C6, 0xD7C52ACB,\n+            0xE6EF15E8, 0xEDE11CE5, 0xF0F307F2, 0xFBFD0EFF,\n+            0x92A779B4, 0x99A970B9, 0x84BB6BAE, 0x8FB562A3,\n+            0xBE9F5D80, 0xB591548D, 0xA8834F9A, 0xA38D4697,\n+    };\n+\n+    private static final int[] U3 = {\n+            0x00000000, 0x0D0B0E09, 0x1A161C12, 0x171D121B,\n+            0x342C3824, 0x3927362D, 0x2E3A2436, 0x23312A3F,\n+            0x68587048, 0x65537E41, 0x724E6C5A, 0x7F456253,\n+            0x5C74486C, 0x517F4665, 0x4662547E, 0x4B695A77,\n+            0xD0B0E090, 0xDDBBEE99, 0xCAA6FC82, 0xC7ADF28B,\n+            0xE49CD8B4, 0xE997D6BD, 0xFE8AC4A6, 0xF381CAAF,\n+            0xB8E890D8, 0xB5E39ED1, 0xA2FE8CCA, 0xAFF582C3,\n+            0x8CC4A8FC, 0x81CFA6F5, 0x96D2B4EE, 0x9BD9BAE7,\n+            0xBB7BDB3B, 0xB670D532, 0xA16DC729, 0xAC66C920,\n+            0x8F57E31F, 0x825CED16, 0x9541FF0D, 0x984AF104,\n+            0xD323AB73, 0xDE28A57A, 0xC935B761, 0xC43EB968,\n+            0xE70F9357, 0xEA049D5E, 0xFD198F45, 0xF012814C,\n+            0x6BCB3BAB, 0x66C035A2, 0x71DD27B9, 0x7CD629B0,\n+            0x5FE7038F, 0x52EC0D86, 0x45F11F9D, 0x48FA1194,\n+            0x03934BE3, 0x0E9845EA, 0x198557F1, 0x148E59F8,\n+            0x37BF73C7, 0x3AB47DCE, 0x2DA96FD5, 0x20A261DC,\n+            0x6DF6AD76, 0x60FDA37F, 0x77E0B164, 0x7AEBBF6D,\n+            0x59DA9552, 0x54D19B5B, 0x43CC8940, 0x4EC78749,\n+            0x05AEDD3E, 0x08A5D337, 0x1FB8C12C, 0x12B3CF25,\n+            0x3182E51A, 0x3C89EB13, 0x2B94F908, 0x269FF701,\n+            0xBD464DE6, 0xB04D43EF, 0xA75051F4, 0xAA5B5FFD,\n+            0x896A75C2, 0x84617BCB, 0x937C69D0, 0x9E7767D9,\n+            0xD51E3DAE, 0xD81533A7, 0xCF0821BC, 0xC2032FB5,\n+            0xE132058A, 0xEC390B83, 0xFB241998, 0xF62F1791,\n+            0xD68D764D, 0xDB867844, 0xCC9B6A5F, 0xC1906456,\n+            0xE2A14E69, 0xEFAA4060, 0xF8B7527B, 0xF5BC5C72,\n+            0xBED50605, 0xB3DE080C, 0xA4C31A17, 0xA9C8141E,\n+            0x8AF93E21, 0x87F23028, 0x90EF2233, 0x9DE42C3A,\n+            0x063D96DD, 0x0B3698D4, 0x1C2B8ACF, 0x112084C6,\n+            0x3211AEF9, 0x3F1AA0F0, 0x2807B2EB, 0x250CBCE2,\n+            0x6E65E695, 0x636EE89C, 0x7473FA87, 0x7978F48E,\n+            0x5A49DEB1, 0x5742D0B8, 0x405FC2A3, 0x4D54CCAA,\n+            0xDAF741EC, 0xD7FC4FE5, 0xC0E15DFE, 0xCDEA53F7,\n+            0xEEDB79C8, 0xE3D077C1, 0xF4CD65DA, 0xF9C66BD3,\n+            0xB2AF31A4, 0xBFA43FAD, 0xA8B92DB6, 0xA5B223BF,\n+            0x86830980, 0x8B880789, 0x9C951592, 0x919E1B9B,\n+            0x0A47A17C, 0x074CAF75, 0x1051BD6E, 0x1D5AB367,\n+            0x3E6B9958, 0x33609751, 0x247D854A, 0x29768B43,\n+            0x621FD134, 0x6F14DF3D, 0x7809CD26, 0x7502C32F,\n+            0x5633E910, 0x5B38E719, 0x4C25F502, 0x412EFB0B,\n+            0x618C9AD7, 0x6C8794DE, 0x7B9A86C5, 0x769188CC,\n+            0x55A0A2F3, 0x58ABACFA, 0x4FB6BEE1, 0x42BDB0E8,\n+            0x09D4EA9F, 0x04DFE496, 0x13C2F68D, 0x1EC9F884,\n+            0x3DF8D2BB, 0x30F3DCB2, 0x27EECEA9, 0x2AE5C0A0,\n+            0xB13C7A47, 0xBC37744E, 0xAB2A6655, 0xA621685C,\n+            0x85104263, 0x881B4C6A, 0x9F065E71, 0x920D5078,\n+            0xD9640A0F, 0xD46F0406, 0xC372161D, 0xCE791814,\n+            0xED48322B, 0xE0433C22, 0xF75E2E39, 0xFA552030,\n+            0xB701EC9A, 0xBA0AE293, 0xAD17F088, 0xA01CFE81,\n+            0x832DD4BE, 0x8E26DAB7, 0x993BC8AC, 0x9430C6A5,\n+            0xDF599CD2, 0xD25292DB, 0xC54F80C0, 0xC8448EC9,\n+            0xEB75A4F6, 0xE67EAAFF, 0xF163B8E4, 0xFC68B6ED,\n+            0x67B10C0A, 0x6ABA0203, 0x7DA71018, 0x70AC1E11,\n+            0x539D342E, 0x5E963A27, 0x498B283C, 0x44802635,\n+            0x0FE97C42, 0x02E2724B, 0x15FF6050, 0x18F46E59,\n+            0x3BC54466, 0x36CE4A6F, 0x21D35874, 0x2CD8567D,\n+            0x0C7A37A1, 0x017139A8, 0x166C2BB3, 0x1B6725BA,\n+            0x38560F85, 0x355D018C, 0x22401397, 0x2F4B1D9E,\n+            0x642247E9, 0x692949E0, 0x7E345BFB, 0x733F55F2,\n+            0x500E7FCD, 0x5D0571C4, 0x4A1863DF, 0x47136DD6,\n+            0xDCCAD731, 0xD1C1D938, 0xC6DCCB23, 0xCBD7C52A,\n+            0xE8E6EF15, 0xE5EDE11C, 0xF2F0F307, 0xFFFBFD0E,\n+            0xB492A779, 0xB999A970, 0xAE84BB6B, 0xA38FB562,\n+            0x80BE9F5D, 0x8DB59154, 0x9AA8834F, 0x97A38D46,\n+    };\n+\n+    private static final int[] U4 = {\n+            0x00000000, 0x090D0B0E, 0x121A161C, 0x1B171D12,\n+            0x24342C38, 0x2D392736, 0x362E3A24, 0x3F23312A,\n+            0x48685870, 0x4165537E, 0x5A724E6C, 0x537F4562,\n+            0x6C5C7448, 0x65517F46, 0x7E466254, 0x774B695A,\n+            0x90D0B0E0, 0x99DDBBEE, 0x82CAA6FC, 0x8BC7ADF2,\n+            0xB4E49CD8, 0xBDE997D6, 0xA6FE8AC4, 0xAFF381CA,\n+            0xD8B8E890, 0xD1B5E39E, 0xCAA2FE8C, 0xC3AFF582,\n+            0xFC8CC4A8, 0xF581CFA6, 0xEE96D2B4, 0xE79BD9BA,\n+            0x3BBB7BDB, 0x32B670D5, 0x29A16DC7, 0x20AC66C9,\n+            0x1F8F57E3, 0x16825CED, 0x0D9541FF, 0x04984AF1,\n+            0x73D323AB, 0x7ADE28A5, 0x61C935B7, 0x68C43EB9,\n+            0x57E70F93, 0x5EEA049D, 0x45FD198F, 0x4CF01281,\n+            0xAB6BCB3B, 0xA266C035, 0xB971DD27, 0xB07CD629,\n+            0x8F5FE703, 0x8652EC0D, 0x9D45F11F, 0x9448FA11,\n+            0xE303934B, 0xEA0E9845, 0xF1198557, 0xF8148E59,\n+            0xC737BF73, 0xCE3AB47D, 0xD52DA96F, 0xDC20A261,\n+            0x766DF6AD, 0x7F60FDA3, 0x6477E0B1, 0x6D7AEBBF,\n+            0x5259DA95, 0x5B54D19B, 0x4043CC89, 0x494EC787,\n+            0x3E05AEDD, 0x3708A5D3, 0x2C1FB8C1, 0x2512B3CF,\n+            0x1A3182E5, 0x133C89EB, 0x082B94F9, 0x01269FF7,\n+            0xE6BD464D, 0xEFB04D43, 0xF4A75051, 0xFDAA5B5F,\n+            0xC2896A75, 0xCB84617B, 0xD0937C69, 0xD99E7767,\n+            0xAED51E3D, 0xA7D81533, 0xBCCF0821, 0xB5C2032F,\n+            0x8AE13205, 0x83EC390B, 0x98FB2419, 0x91F62F17,\n+            0x4DD68D76, 0x44DB8678, 0x5FCC9B6A, 0x56C19064,\n+            0x69E2A14E, 0x60EFAA40, 0x7BF8B752, 0x72F5BC5C,\n+            0x05BED506, 0x0CB3DE08, 0x17A4C31A, 0x1EA9C814,\n+            0x218AF93E, 0x2887F230, 0x3390EF22, 0x3A9DE42C,\n+            0xDD063D96, 0xD40B3698, 0xCF1C2B8A, 0xC6112084,\n+            0xF93211AE, 0xF03F1AA0, 0xEB2807B2, 0xE2250CBC,\n+            0x956E65E6, 0x9C636EE8, 0x877473FA, 0x8E7978F4,\n+            0xB15A49DE, 0xB85742D0, 0xA3405FC2, 0xAA4D54CC,\n+            0xECDAF741, 0xE5D7FC4F, 0xFEC0E15D, 0xF7CDEA53,\n+            0xC8EEDB79, 0xC1E3D077, 0xDAF4CD65, 0xD3F9C66B,\n+            0xA4B2AF31, 0xADBFA43F, 0xB6A8B92D, 0xBFA5B223,\n+            0x80868309, 0x898B8807, 0x929C9515, 0x9B919E1B,\n+            0x7C0A47A1, 0x75074CAF, 0x6E1051BD, 0x671D5AB3,\n+            0x583E6B99, 0x51336097, 0x4A247D85, 0x4329768B,\n+            0x34621FD1, 0x3D6F14DF, 0x267809CD, 0x2F7502C3,\n+            0x105633E9, 0x195B38E7, 0x024C25F5, 0x0B412EFB,\n+            0xD7618C9A, 0xDE6C8794, 0xC57B9A86, 0xCC769188,\n+            0xF355A0A2, 0xFA58ABAC, 0xE14FB6BE, 0xE842BDB0,\n+            0x9F09D4EA, 0x9604DFE4, 0x8D13C2F6, 0x841EC9F8,\n+            0xBB3DF8D2, 0xB230F3DC, 0xA927EECE, 0xA02AE5C0,\n+            0x47B13C7A, 0x4EBC3774, 0x55AB2A66, 0x5CA62168,\n+            0x63851042, 0x6A881B4C, 0x719F065E, 0x78920D50,\n+            0x0FD9640A, 0x06D46F04, 0x1DC37216, 0x14CE7918,\n+            0x2BED4832, 0x22E0433C, 0x39F75E2E, 0x30FA5520,\n+            0x9AB701EC, 0x93BA0AE2, 0x88AD17F0, 0x81A01CFE,\n+            0xBE832DD4, 0xB78E26DA, 0xAC993BC8, 0xA59430C6,\n+            0xD2DF599C, 0xDBD25292, 0xC0C54F80, 0xC9C8448E,\n+            0xF6EB75A4, 0xFFE67EAA, 0xE4F163B8, 0xEDFC68B6,\n+            0x0A67B10C, 0x036ABA02, 0x187DA710, 0x1170AC1E,\n+            0x2E539D34, 0x275E963A, 0x3C498B28, 0x35448026,\n+            0x420FE97C, 0x4B02E272, 0x5015FF60, 0x5918F46E,\n+            0x663BC544, 0x6F36CE4A, 0x7421D358, 0x7D2CD856,\n+            0xA10C7A37, 0xA8017139, 0xB3166C2B, 0xBA1B6725,\n+            0x8538560F, 0x8C355D01, 0x97224013, 0x9E2F4B1D,\n+            0xE9642247, 0xE0692949, 0xFB7E345B, 0xF2733F55,\n+            0xCD500E7F, 0xC45D0571, 0xDF4A1863, 0xD647136D,\n+            0x31DCCAD7, 0x38D1C1D9, 0x23C6DCCB, 0x2ACBD7C5,\n+            0x15E8E6EF, 0x1CE5EDE1, 0x07F2F0F3, 0x0EFFFBFD,\n+            0x79B492A7, 0x70B999A9, 0x6BAE84BB, 0x62A38FB5,\n+            0x5D80BE9F, 0x548DB591, 0x4F9AA883, 0x4697A38D,\n+    };\n+\n+    private static final int[] rcon = {\n+            0x00000001, 0x00000002, 0x00000004, 0x00000008,\n+            0x00000010, 0x00000020, 0x00000040, 0x00000080,\n+            0x0000001B, 0x00000036, 0x0000006C, 0x000000D8,\n+            0x000000AB, 0x0000004D, 0x0000009A, 0x0000002F,\n+            0x0000005E, 0x000000BC, 0x00000063, 0x000000C6,\n+            0x00000097, 0x00000035, 0x0000006A, 0x000000D4,\n+            0x000000B3, 0x0000007D, 0x000000FA, 0x000000EF,\n+            0x000000C5, 0x00000091,\n+    };\n+\n+    private boolean ROUNDS_12 = false;\n+    private boolean ROUNDS_14 = false;\n+\n+    \/** Session and Sub keys *\/\n+    private int[][] sessionK = null;\n+    private int[] K = null;\n+\n+    \/** Cipher encryption\/decryption key *\/\n+    \/\/ skip re-generating Session and Sub keys if the cipher key is\n+    \/\/ the same\n+    private byte[] lastKey = null;\n+\n+    \/** ROUNDS * 4 *\/\n+    private int limit = 0;\n+\n+    AESCrypt() {\n+        \/\/ empty\n+    }\n+\n+    \/**\n+     * Returns this cipher's block size.\n+     *\n+     * @return this cipher's block size\n+     *\/\n+    int getBlockSize() {\n+        return AES_BLOCK_SIZE;\n+    }\n+\n+    void init(boolean decrypting, String algorithm, byte[] key)\n+            throws InvalidKeyException {\n+        if (!algorithm.equalsIgnoreCase(\"AES\")\n+                    && !algorithm.equalsIgnoreCase(\"Rijndael\")) {\n+            throw new InvalidKeyException\n+                (\"Wrong algorithm: AES or Rijndael required\");\n+        }\n+\n+        if (key == null) {      \/\/ Unlikely, but just double check it.\n+            throw new InvalidKeyException(\"Empty key\");\n+        }\n+\n+        if (!MessageDigest.isEqual(key, lastKey)) {\n+            \/\/ re-generate session key 'sessionK' when cipher key changes\n+            makeSessionKey(key);\n+            if (lastKey != null) {\n+                Arrays.fill(lastKey, (byte)0);\n+            }\n+            lastKey = key.clone();  \/\/ save cipher key\n+        }\n+\n+        \/\/ set sub key to the corresponding session Key\n+        this.K = sessionK[(decrypting? 1:0)];\n+    }\n+\n+    \/\/ check if the specified length (in bytes) is a valid keysize for AES\n+    static boolean isKeySizeValid(int len) {\n+        for (int aesKeysize : AES_KEYSIZES) {\n+            if (len == aesKeysize) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Encrypt exactly one block of plaintext.\n+     *\/\n+    void encryptBlock(byte[] in, int inOffset,\n+                      byte[] out, int outOffset) {\n+        \/\/ Array bound checks are done in caller code, i.e.\n+        \/\/ FeedbackCipher.encrypt\/decrypt(...) to improve performance.\n+        implEncryptBlock(in, inOffset, out, outOffset);\n+    }\n+\n+    \/\/ Encryption operation. Possibly replaced with a compiler intrinsic.\n+    @IntrinsicCandidate\n+    private void implEncryptBlock(byte[] in, int inOffset,\n+                                  byte[] out, int outOffset)\n+    {\n+        int keyOffset = 0;\n+        int t0   = ((in[inOffset++]       ) << 24 |\n+                    (in[inOffset++] & 0xFF) << 16 |\n+                    (in[inOffset++] & 0xFF) <<  8 |\n+                    (in[inOffset++] & 0xFF)        ) ^ K[keyOffset++];\n+        int t1   = ((in[inOffset++]       ) << 24 |\n+                    (in[inOffset++] & 0xFF) << 16 |\n+                    (in[inOffset++] & 0xFF) <<  8 |\n+                    (in[inOffset++] & 0xFF)        ) ^ K[keyOffset++];\n+        int t2   = ((in[inOffset++]       ) << 24 |\n+                    (in[inOffset++] & 0xFF) << 16 |\n+                    (in[inOffset++] & 0xFF) <<  8 |\n+                    (in[inOffset++] & 0xFF)        ) ^ K[keyOffset++];\n+        int t3   = ((in[inOffset++]       ) << 24 |\n+                    (in[inOffset++] & 0xFF) << 16 |\n+                    (in[inOffset++] & 0xFF) <<  8 |\n+                    (in[inOffset]   & 0xFF)        ) ^ K[keyOffset++];\n+\n+        \/\/ apply round transforms\n+        while( keyOffset < limit )\n+        {\n+            int a0, a1, a2;\n+            a0 = T1[(t0 >>> 24)       ] ^\n+                 T2[(t1 >>> 16) & 0xFF] ^\n+                 T3[(t2 >>>  8) & 0xFF] ^\n+                 T4[(t3       ) & 0xFF] ^ K[keyOffset++];\n+            a1 = T1[(t1 >>> 24)       ] ^\n+                 T2[(t2 >>> 16) & 0xFF] ^\n+                 T3[(t3 >>>  8) & 0xFF] ^\n+                 T4[(t0       ) & 0xFF] ^ K[keyOffset++];\n+            a2 = T1[(t2 >>> 24)       ] ^\n+                 T2[(t3 >>> 16) & 0xFF] ^\n+                 T3[(t0 >>>  8) & 0xFF] ^\n+                 T4[(t1       ) & 0xFF] ^ K[keyOffset++];\n+            t3 = T1[(t3 >>> 24)       ] ^\n+                 T2[(t0 >>> 16) & 0xFF] ^\n+                 T3[(t1 >>>  8) & 0xFF] ^\n+                 T4[(t2       ) & 0xFF] ^ K[keyOffset++];\n+            t0 = a0; t1 = a1; t2 = a2;\n+        }\n+\n+        \/\/ last round is special\n+        int tt = K[keyOffset++];\n+        out[outOffset++] = (byte)(S[(t0 >>> 24)       ] ^ (tt >>> 24));\n+        out[outOffset++] = (byte)(S[(t1 >>> 16) & 0xFF] ^ (tt >>> 16));\n+        out[outOffset++] = (byte)(S[(t2 >>>  8) & 0xFF] ^ (tt >>>  8));\n+        out[outOffset++] = (byte)(S[(t3       ) & 0xFF] ^ (tt       ));\n+        tt = K[keyOffset++];\n+        out[outOffset++] = (byte)(S[(t1 >>> 24)       ] ^ (tt >>> 24));\n+        out[outOffset++] = (byte)(S[(t2 >>> 16) & 0xFF] ^ (tt >>> 16));\n+        out[outOffset++] = (byte)(S[(t3 >>>  8) & 0xFF] ^ (tt >>>  8));\n+        out[outOffset++] = (byte)(S[(t0       ) & 0xFF] ^ (tt       ));\n+        tt = K[keyOffset++];\n+        out[outOffset++] = (byte)(S[(t2 >>> 24)       ] ^ (tt >>> 24));\n+        out[outOffset++] = (byte)(S[(t3 >>> 16) & 0xFF] ^ (tt >>> 16));\n+        out[outOffset++] = (byte)(S[(t0 >>>  8) & 0xFF] ^ (tt >>>  8));\n+        out[outOffset++] = (byte)(S[(t1       ) & 0xFF] ^ (tt       ));\n+        tt = K[keyOffset];\n+        out[outOffset++] = (byte)(S[(t3 >>> 24)       ] ^ (tt >>> 24));\n+        out[outOffset++] = (byte)(S[(t0 >>> 16) & 0xFF] ^ (tt >>> 16));\n+        out[outOffset++] = (byte)(S[(t1 >>>  8) & 0xFF] ^ (tt >>>  8));\n+        out[outOffset  ] = (byte)(S[(t2       ) & 0xFF] ^ (tt       ));\n+    }\n+\n+    \/**\n+     * Decrypt exactly one block of plaintext.\n+     *\/\n+    void decryptBlock(byte[] in, int inOffset,\n+                      byte[] out, int outOffset) {\n+        \/\/ Array bound checks are done in caller code, i.e.\n+        \/\/ FeedbackCipher.encrypt\/decrypt(...) to improve performance.\n+        implDecryptBlock(in, inOffset, out, outOffset);\n+    }\n+\n+    \/\/ Decrypt operation. Possibly replaced with a compiler intrinsic.\n+    @IntrinsicCandidate\n+    private void implDecryptBlock(byte[] in, int inOffset,\n+                                  byte[] out, int outOffset)\n+    {\n+        int keyOffset = 4;\n+        int t0 = ((in[inOffset++]       ) << 24 |\n+                  (in[inOffset++] & 0xFF) << 16 |\n+                  (in[inOffset++] & 0xFF) <<  8 |\n+                  (in[inOffset++] & 0xFF)        ) ^ K[keyOffset++];\n+        int t1 = ((in[inOffset++]       ) << 24 |\n+                  (in[inOffset++] & 0xFF) << 16 |\n+                  (in[inOffset++] & 0xFF) <<  8 |\n+                  (in[inOffset++] & 0xFF)        ) ^ K[keyOffset++];\n+        int t2 = ((in[inOffset++]       ) << 24 |\n+                  (in[inOffset++] & 0xFF) << 16 |\n+                  (in[inOffset++] & 0xFF) <<  8 |\n+                  (in[inOffset++] & 0xFF)        ) ^ K[keyOffset++];\n+        int t3 = ((in[inOffset++]       ) << 24 |\n+                  (in[inOffset++] & 0xFF) << 16 |\n+                  (in[inOffset++] & 0xFF) <<  8 |\n+                  (in[inOffset  ] & 0xFF)        ) ^ K[keyOffset++];\n+\n+        int a0, a1, a2;\n+        if(ROUNDS_12)\n+        {\n+            a0 = T5[(t0>>>24)     ] ^ T6[(t3>>>16)&0xFF] ^\n+                 T7[(t2>>> 8)&0xFF] ^ T8[(t1     )&0xFF] ^ K[keyOffset++];\n+            a1 = T5[(t1>>>24)     ] ^ T6[(t0>>>16)&0xFF] ^\n+                 T7[(t3>>> 8)&0xFF] ^ T8[(t2     )&0xFF] ^ K[keyOffset++];\n+            a2 = T5[(t2>>>24)     ] ^ T6[(t1>>>16)&0xFF] ^\n+                 T7[(t0>>> 8)&0xFF] ^ T8[(t3     )&0xFF] ^ K[keyOffset++];\n+            t3 = T5[(t3>>>24)     ] ^ T6[(t2>>>16)&0xFF] ^\n+                 T7[(t1>>> 8)&0xFF] ^ T8[(t0     )&0xFF] ^ K[keyOffset++];\n+            t0 = T5[(a0>>>24)     ] ^ T6[(t3>>>16)&0xFF] ^\n+                 T7[(a2>>> 8)&0xFF] ^ T8[(a1     )&0xFF] ^ K[keyOffset++];\n+            t1 = T5[(a1>>>24)     ] ^ T6[(a0>>>16)&0xFF] ^\n+                 T7[(t3>>> 8)&0xFF] ^ T8[(a2     )&0xFF] ^ K[keyOffset++];\n+            t2 = T5[(a2>>>24)     ] ^ T6[(a1>>>16)&0xFF] ^\n+                 T7[(a0>>> 8)&0xFF] ^ T8[(t3     )&0xFF] ^ K[keyOffset++];\n+            t3 = T5[(t3>>>24)     ] ^ T6[(a2>>>16)&0xFF] ^\n+                 T7[(a1>>> 8)&0xFF] ^ T8[(a0     )&0xFF] ^ K[keyOffset++];\n+\n+            if(ROUNDS_14)\n+            {\n+                a0 = T5[(t0>>>24)     ] ^ T6[(t3>>>16)&0xFF] ^\n+                     T7[(t2>>> 8)&0xFF] ^ T8[(t1     )&0xFF] ^ K[keyOffset++];\n+                a1 = T5[(t1>>>24)     ] ^ T6[(t0>>>16)&0xFF] ^\n+                     T7[(t3>>> 8)&0xFF] ^ T8[(t2     )&0xFF] ^ K[keyOffset++];\n+                a2 = T5[(t2>>>24)     ] ^ T6[(t1>>>16)&0xFF] ^\n+                     T7[(t0>>> 8)&0xFF] ^ T8[(t3     )&0xFF] ^ K[keyOffset++];\n+                t3 = T5[(t3>>>24)     ] ^ T6[(t2>>>16)&0xFF] ^\n+                     T7[(t1>>> 8)&0xFF] ^ T8[(t0     )&0xFF] ^ K[keyOffset++];\n+                t0 = T5[(a0>>>24)     ] ^ T6[(t3>>>16)&0xFF] ^\n+                     T7[(a2>>> 8)&0xFF] ^ T8[(a1     )&0xFF] ^ K[keyOffset++];\n+                t1 = T5[(a1>>>24)     ] ^ T6[(a0>>>16)&0xFF] ^\n+                     T7[(t3>>> 8)&0xFF] ^ T8[(a2     )&0xFF] ^ K[keyOffset++];\n+                t2 = T5[(a2>>>24)     ] ^ T6[(a1>>>16)&0xFF] ^\n+                     T7[(a0>>> 8)&0xFF] ^ T8[(t3     )&0xFF] ^ K[keyOffset++];\n+                t3 = T5[(t3>>>24)     ] ^ T6[(a2>>>16)&0xFF] ^\n+                     T7[(a1>>> 8)&0xFF] ^ T8[(a0     )&0xFF] ^ K[keyOffset++];\n+            }\n+        }\n+        a0 = T5[(t0>>>24)     ] ^ T6[(t3>>>16)&0xFF] ^\n+             T7[(t2>>> 8)&0xFF] ^ T8[(t1     )&0xFF] ^ K[keyOffset++];\n+        a1 = T5[(t1>>>24)     ] ^ T6[(t0>>>16)&0xFF] ^\n+             T7[(t3>>> 8)&0xFF] ^ T8[(t2     )&0xFF] ^ K[keyOffset++];\n+        a2 = T5[(t2>>>24)     ] ^ T6[(t1>>>16)&0xFF] ^\n+             T7[(t0>>> 8)&0xFF] ^ T8[(t3     )&0xFF] ^ K[keyOffset++];\n+        t3 = T5[(t3>>>24)     ] ^ T6[(t2>>>16)&0xFF] ^\n+             T7[(t1>>> 8)&0xFF] ^ T8[(t0     )&0xFF] ^ K[keyOffset++];\n+        t0 = T5[(a0>>>24)     ] ^ T6[(t3>>>16)&0xFF] ^\n+             T7[(a2>>> 8)&0xFF] ^ T8[(a1     )&0xFF] ^ K[keyOffset++];\n+        t1 = T5[(a1>>>24)     ] ^ T6[(a0>>>16)&0xFF] ^\n+             T7[(t3>>> 8)&0xFF] ^ T8[(a2     )&0xFF] ^ K[keyOffset++];\n+        t2 = T5[(a2>>>24)     ] ^ T6[(a1>>>16)&0xFF] ^\n+             T7[(a0>>> 8)&0xFF] ^ T8[(t3     )&0xFF] ^ K[keyOffset++];\n+        t3 = T5[(t3>>>24)     ] ^ T6[(a2>>>16)&0xFF] ^\n+             T7[(a1>>> 8)&0xFF] ^ T8[(a0     )&0xFF] ^ K[keyOffset++];\n+        a0 = T5[(t0>>>24)     ] ^ T6[(t3>>>16)&0xFF] ^\n+             T7[(t2>>> 8)&0xFF] ^ T8[(t1     )&0xFF] ^ K[keyOffset++];\n+        a1 = T5[(t1>>>24)     ] ^ T6[(t0>>>16)&0xFF] ^\n+             T7[(t3>>> 8)&0xFF] ^ T8[(t2     )&0xFF] ^ K[keyOffset++];\n+        a2 = T5[(t2>>>24)     ] ^ T6[(t1>>>16)&0xFF] ^\n+             T7[(t0>>> 8)&0xFF] ^ T8[(t3     )&0xFF] ^ K[keyOffset++];\n+        t3 = T5[(t3>>>24)     ] ^ T6[(t2>>>16)&0xFF] ^\n+             T7[(t1>>> 8)&0xFF] ^ T8[(t0     )&0xFF] ^ K[keyOffset++];\n+        t0 = T5[(a0>>>24)     ] ^ T6[(t3>>>16)&0xFF] ^\n+             T7[(a2>>> 8)&0xFF] ^ T8[(a1     )&0xFF] ^ K[keyOffset++];\n+        t1 = T5[(a1>>>24)     ] ^ T6[(a0>>>16)&0xFF] ^\n+             T7[(t3>>> 8)&0xFF] ^ T8[(a2     )&0xFF] ^ K[keyOffset++];\n+        t2 = T5[(a2>>>24)     ] ^ T6[(a1>>>16)&0xFF] ^\n+             T7[(a0>>> 8)&0xFF] ^ T8[(t3     )&0xFF] ^ K[keyOffset++];\n+        t3 = T5[(t3>>>24)     ] ^ T6[(a2>>>16)&0xFF] ^\n+             T7[(a1>>> 8)&0xFF] ^ T8[(a0     )&0xFF] ^ K[keyOffset++];\n+        a0 = T5[(t0>>>24)     ] ^ T6[(t3>>>16)&0xFF] ^\n+             T7[(t2>>> 8)&0xFF] ^ T8[(t1     )&0xFF] ^ K[keyOffset++];\n+        a1 = T5[(t1>>>24)     ] ^ T6[(t0>>>16)&0xFF] ^\n+             T7[(t3>>> 8)&0xFF] ^ T8[(t2     )&0xFF] ^ K[keyOffset++];\n+        a2 = T5[(t2>>>24)     ] ^ T6[(t1>>>16)&0xFF] ^\n+             T7[(t0>>> 8)&0xFF] ^ T8[(t3     )&0xFF] ^ K[keyOffset++];\n+        t3 = T5[(t3>>>24)     ] ^ T6[(t2>>>16)&0xFF] ^\n+             T7[(t1>>> 8)&0xFF] ^ T8[(t0     )&0xFF] ^ K[keyOffset++];\n+        t0 = T5[(a0>>>24)     ] ^ T6[(t3>>>16)&0xFF] ^\n+             T7[(a2>>> 8)&0xFF] ^ T8[(a1     )&0xFF] ^ K[keyOffset++];\n+        t1 = T5[(a1>>>24)     ] ^ T6[(a0>>>16)&0xFF] ^\n+             T7[(t3>>> 8)&0xFF] ^ T8[(a2     )&0xFF] ^ K[keyOffset++];\n+        t2 = T5[(a2>>>24)     ] ^ T6[(a1>>>16)&0xFF] ^\n+             T7[(a0>>> 8)&0xFF] ^ T8[(t3     )&0xFF] ^ K[keyOffset++];\n+        t3 = T5[(t3>>>24)     ] ^ T6[(a2>>>16)&0xFF] ^\n+             T7[(a1>>> 8)&0xFF] ^ T8[(a0     )&0xFF] ^ K[keyOffset++];\n+        a0 = T5[(t0>>>24)     ] ^ T6[(t3>>>16)&0xFF] ^\n+             T7[(t2>>> 8)&0xFF] ^ T8[(t1     )&0xFF] ^ K[keyOffset++];\n+        a1 = T5[(t1>>>24)     ] ^ T6[(t0>>>16)&0xFF] ^\n+             T7[(t3>>> 8)&0xFF] ^ T8[(t2     )&0xFF] ^ K[keyOffset++];\n+        a2 = T5[(t2>>>24)     ] ^ T6[(t1>>>16)&0xFF] ^\n+             T7[(t0>>> 8)&0xFF] ^ T8[(t3     )&0xFF] ^ K[keyOffset++];\n+        t3 = T5[(t3>>>24)     ] ^ T6[(t2>>>16)&0xFF] ^\n+             T7[(t1>>> 8)&0xFF] ^ T8[(t0     )&0xFF] ^ K[keyOffset++];\n+        t0 = T5[(a0>>>24)     ] ^ T6[(t3>>>16)&0xFF] ^\n+             T7[(a2>>> 8)&0xFF] ^ T8[(a1     )&0xFF] ^ K[keyOffset++];\n+        t1 = T5[(a1>>>24)     ] ^ T6[(a0>>>16)&0xFF] ^\n+             T7[(t3>>> 8)&0xFF] ^ T8[(a2     )&0xFF] ^ K[keyOffset++];\n+        t2 = T5[(a2>>>24)     ] ^ T6[(a1>>>16)&0xFF] ^\n+             T7[(a0>>> 8)&0xFF] ^ T8[(t3     )&0xFF] ^ K[keyOffset++];\n+        t3 = T5[(t3>>>24)     ] ^ T6[(a2>>>16)&0xFF] ^\n+             T7[(a1>>> 8)&0xFF] ^ T8[(a0     )&0xFF] ^ K[keyOffset++];\n+        a0 = T5[(t0>>>24)     ] ^ T6[(t3>>>16)&0xFF] ^\n+             T7[(t2>>> 8)&0xFF] ^ T8[(t1     )&0xFF] ^ K[keyOffset++];\n+        a1 = T5[(t1>>>24)     ] ^ T6[(t0>>>16)&0xFF] ^\n+             T7[(t3>>> 8)&0xFF] ^ T8[(t2     )&0xFF] ^ K[keyOffset++];\n+        a2 = T5[(t2>>>24)     ] ^ T6[(t1>>>16)&0xFF] ^\n+             T7[(t0>>> 8)&0xFF] ^ T8[(t3     )&0xFF] ^ K[keyOffset++];\n+        t3 = T5[(t3>>>24)     ] ^ T6[(t2>>>16)&0xFF] ^\n+             T7[(t1>>> 8)&0xFF] ^ T8[(t0     )&0xFF] ^ K[keyOffset];\n+\n+        t1 = K[0];\n+        out[outOffset++] = (byte)(Si[(a0 >>> 24)       ] ^ (t1 >>> 24));\n+        out[outOffset++] = (byte)(Si[(t3 >>> 16) & 0xFF] ^ (t1 >>> 16));\n+        out[outOffset++] = (byte)(Si[(a2 >>>  8) & 0xFF] ^ (t1 >>>  8));\n+        out[outOffset++] = (byte)(Si[(a1       ) & 0xFF] ^ (t1       ));\n+        t1 = K[1];\n+        out[outOffset++] = (byte)(Si[(a1 >>> 24)       ] ^ (t1 >>> 24));\n+        out[outOffset++] = (byte)(Si[(a0 >>> 16) & 0xFF] ^ (t1 >>> 16));\n+        out[outOffset++] = (byte)(Si[(t3 >>>  8) & 0xFF] ^ (t1 >>>  8));\n+        out[outOffset++] = (byte)(Si[(a2       ) & 0xFF] ^ (t1       ));\n+        t1 = K[2];\n+        out[outOffset++] = (byte)(Si[(a2 >>> 24)       ] ^ (t1 >>> 24));\n+        out[outOffset++] = (byte)(Si[(a1 >>> 16) & 0xFF] ^ (t1 >>> 16));\n+        out[outOffset++] = (byte)(Si[(a0 >>>  8) & 0xFF] ^ (t1 >>>  8));\n+        out[outOffset++] = (byte)(Si[(t3       ) & 0xFF] ^ (t1       ));\n+        t1 = K[3];\n+        out[outOffset++] = (byte)(Si[(t3 >>> 24)       ] ^ (t1 >>> 24));\n+        out[outOffset++] = (byte)(Si[(a2 >>> 16) & 0xFF] ^ (t1 >>> 16));\n+        out[outOffset++] = (byte)(Si[(a1 >>>  8) & 0xFF] ^ (t1 >>>  8));\n+        out[outOffset  ] = (byte)(Si[(a0       ) & 0xFF] ^ (t1       ));\n+    }\n+\n+    \/**\n+     * Expand a user-supplied key material into a session key.\n+     *\n+     * @param k The 128\/192\/256-bit cipher key to use.\n+     * @exception InvalidKeyException  If the key is invalid.\n+     *\/\n+    private void makeSessionKey(byte[] k) throws InvalidKeyException {\n+        if (!isKeySizeValid(k.length)) {\n+            throw new InvalidKeyException(\"Invalid AES key length: \" +\n+                    k.length + \" bytes\");\n+        }\n+\n+        final int BC = 4;\n+\n+        int ROUNDS          = getRounds(k.length);\n+        int ROUND_KEY_COUNT = (ROUNDS + 1) * BC;\n+\n+        int[] Ke = new int[ROUND_KEY_COUNT]; \/\/ encryption round keys\n+        int[] Kd = new int[ROUND_KEY_COUNT]; \/\/ decryption round keys\n+\n+        int KC = k.length\/4; \/\/ keylen in 32-bit elements\n+\n+        int[] tk = new int[KC];\n+        int i, j;\n+\n+        \/\/ copy user material bytes into temporary ints\n+        for (i = 0, j = 0; i < KC; i++, j+=4) {\n+            tk[i] = (k[j]       ) << 24 |\n+                    (k[j+1] & 0xFF) << 16 |\n+                    (k[j+2] & 0xFF) <<  8 |\n+                    (k[j+3] & 0xFF);\n+        }\n+\n+        \/\/ copy values into round key arrays\n+        int t = 0;\n+        for (j = 0; (j < KC) && (t < ROUND_KEY_COUNT); j++, t++) {\n+            Ke[t] = tk[j];\n+            Kd[(ROUNDS - (t \/ BC))*BC + (t % BC)] = tk[j];\n+        }\n+        int tt, rconpointer = 0;\n+        while (t < ROUND_KEY_COUNT) {\n+            \/\/ extrapolate using phi (the round key evolution function)\n+            tt = tk[KC - 1];\n+            tk[0] ^= (S[(tt >>> 16) & 0xFF]       ) << 24 ^\n+                     (S[(tt >>>  8) & 0xFF] & 0xFF) << 16 ^\n+                     (S[(tt       ) & 0xFF] & 0xFF) <<  8 ^\n+                     (S[(tt >>> 24)       ] & 0xFF)       ^\n+                     (rcon[rconpointer++]         ) << 24;\n+            if (KC != 8)\n+                for (i = 1, j = 0; i < KC; i++, j++) tk[i] ^= tk[j];\n+            else {\n+                for (i = 1, j = 0; i < KC \/ 2; i++, j++) tk[i] ^= tk[j];\n+                tt = tk[KC \/ 2 - 1];\n+                tk[KC \/ 2] ^= (S[(tt       ) & 0xFF] & 0xFF)       ^\n+                              (S[(tt >>>  8) & 0xFF] & 0xFF) <<  8 ^\n+                              (S[(tt >>> 16) & 0xFF] & 0xFF) << 16 ^\n+                              (S[(tt >>> 24)       ]       ) << 24;\n+                for (j = KC \/ 2, i = j + 1; i < KC; i++, j++) tk[i] ^= tk[j];\n+            }\n+            \/\/ copy values into round key arrays\n+            for (j = 0; (j < KC) && (t < ROUND_KEY_COUNT); j++, t++) {\n+                Ke[t] = tk[j];\n+                Kd[(ROUNDS - (t \/ BC))*BC + (t % BC)] = tk[j];\n+            }\n+        }\n+        for (int r = 1; r < ROUNDS; r++) {\n+            \/\/ inverse MixColumn where needed\n+            for (j = 0; j < BC; j++) {\n+                int idx = r*BC + j;\n+                tt = Kd[idx];\n+                Kd[idx] = U1[(tt >>> 24) & 0xFF] ^\n+                          U2[(tt >>> 16) & 0xFF] ^\n+                          U3[(tt >>>  8) & 0xFF] ^\n+                          U4[ tt         & 0xFF];\n+            }\n+        }\n+\n+        \/\/ For decryption round keys, need to rotate right by 4 ints.\n+        \/\/ Do that without allocating and zeroing the small buffer.\n+        int KdTail_0 = Kd[Kd.length - 4];\n+        int KdTail_1 = Kd[Kd.length - 3];\n+        int KdTail_2 = Kd[Kd.length - 2];\n+        int KdTail_3 = Kd[Kd.length - 1];\n+        System.arraycopy(Kd, 0, Kd, 4, Kd.length - 4);\n+        Kd[0] = KdTail_0;\n+        Kd[1] = KdTail_1;\n+        Kd[2] = KdTail_2;\n+        Kd[3] = KdTail_3;\n+\n+        Arrays.fill(tk, 0);\n+        ROUNDS_12 = (ROUNDS>=12);\n+        ROUNDS_14 = (ROUNDS==14);\n+        limit = ROUNDS*4;\n+\n+        \/\/ store the expanded sub keys into 'sessionK'\n+        if (sessionK != null) {\n+            \/\/ erase the previous values in sessionK\n+            Arrays.fill(sessionK[0], 0);\n+            Arrays.fill(sessionK[1], 0);\n+        } else {\n+            sessionK = new int[2][];\n+        }\n+        sessionK[0] = Ke;\n+        sessionK[1] = Kd;\n+    }\n+\n+    \/**\n+     * Return The number of rounds for a given Rijndael keysize.\n+     *\n+     * @param keySize  The size of the user key material in bytes.\n+     *                 MUST be one of (16, 24, 32).\n+     * @return         The number of rounds.\n+     *\/\n+    private static int getRounds(int keySize) {\n+        return (keySize >> 2) + 6;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AESCrypt.java","additions":1437,"deletions":0,"binary":false,"changes":1437,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,1 +94,1 @@\n-            (!AES_Crypt.isKeySizeValid(keysize\/8))) {\n+            (!AESCrypt.isKeySizeValid(keysize\/8))) {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AESKeyGenerator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-        super(new AES_Crypt());\n+        super(new AESCrypt());\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AESKeyWrap.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,1 +90,1 @@\n-        super(new AES_Crypt());\n+        super(new AESCrypt());\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AESKeyWrapPadded.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1392 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.crypto.provider;\n-\n-import java.security.InvalidKeyException;\n-import java.security.MessageDigest;\n-import java.util.Arrays;\n-\n-import jdk.internal.vm.annotation.IntrinsicCandidate;\n-\n-\/**\n- * Implementation of the AES cipher, which is based on the following documents:\n- *\n- * @spec https:\/\/csrc.nist.gov\/csrc\/media\/projects\/cryptographic-standards-and-guidelines\/documents\/aes-development\/rijndael-ammended.pdf\n- *\n- * @spec https:\/\/nvlpubs.nist.gov\/nistpubs\/FIPS\/NIST.FIPS.197-upd1.pdf\n- *\n- * https:\/\/www.internationaljournalcorner.com\/index.php\/ijird_ojs\/article\/view\/134688\n- *\/\n-final class AES_Crypt extends SymmetricCipher {\n-\n-    \/\/ Number of words in a block\n-    private static final int WB = 4;\n-    \/\/ Number of bytes in a word\n-    private static final int BW = 4;\n-\n-    private static final int AES_128_ROUNDS = 10;\n-    private static final int AES_192_ROUNDS = 12;\n-    private static final int AES_256_ROUNDS = 14;\n-\n-    private int rounds;\n-    private byte[] prevKey = null;\n-\n-    \/\/ Following two attributes are specific to Intrinsics where sessionK is\n-    \/\/ used for PPC64, S390, and RISCV64 architectures, whereas K is used for\n-    \/\/ everything else.\n-    private int[][] sessionK = null;\n-    private int[] K = null;\n-\n-    \/\/ Round constant\n-    private static final int[] RCON = {\n-            0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000,\n-            0x20000000, 0x40000000, 0x80000000, 0x1B000000, 0x36000000,\n-    };\n-\n-    private static final byte[][] SBOX = {\n-            { (byte)0x63, (byte)0x7C, (byte)0x77, (byte)0x7B, (byte)0xF2,\n-              (byte)0x6B, (byte)0x6F, (byte)0xC5, (byte)0x30, (byte)0x01,\n-              (byte)0x67, (byte)0x2B, (byte)0xFE, (byte)0xD7, (byte)0xAB,\n-              (byte)0x76 },\n-            { (byte)0xCA, (byte)0x82, (byte)0xC9, (byte)0x7D, (byte)0xFA,\n-              (byte)0x59, (byte)0x47, (byte)0xF0, (byte)0xAD, (byte)0xD4,\n-              (byte)0xA2, (byte)0xAF, (byte)0x9C, (byte)0xA4, (byte)0x72,\n-              (byte)0xC0 },\n-            { (byte)0xB7, (byte)0xFD, (byte)0x93, (byte)0x26, (byte)0x36,\n-              (byte)0x3F, (byte)0xF7, (byte)0xCC, (byte)0x34, (byte)0xA5,\n-              (byte)0xE5, (byte)0xF1, (byte)0x71, (byte)0xD8, (byte)0x31,\n-              (byte)0x15 },\n-            { (byte)0x04, (byte)0xC7, (byte)0x23, (byte)0xC3, (byte)0x18,\n-              (byte)0x96, (byte)0x05, (byte)0x9A, (byte)0x07, (byte)0x12,\n-              (byte)0x80, (byte)0xE2, (byte)0xEB, (byte)0x27, (byte)0xB2,\n-              (byte)0x75 },\n-            { (byte)0x09, (byte)0x83, (byte)0x2C, (byte)0x1A, (byte)0x1B,\n-              (byte)0x6E, (byte)0x5A, (byte)0xA0, (byte)0x52, (byte)0x3B,\n-              (byte)0xD6, (byte)0xB3, (byte)0x29, (byte)0xE3, (byte)0x2F,\n-              (byte)0x84 },\n-            { (byte)0x53, (byte)0xD1, (byte)0x00, (byte)0xED, (byte)0x20,\n-              (byte)0xFC, (byte)0xB1, (byte)0x5B, (byte)0x6A, (byte)0xCB,\n-              (byte)0xBE, (byte)0x39, (byte)0x4A, (byte)0x4C, (byte)0x58,\n-              (byte)0xCF },\n-            { (byte)0xD0, (byte)0xEF, (byte)0xAA, (byte)0xFB, (byte)0x43,\n-              (byte)0x4D, (byte)0x33, (byte)0x85, (byte)0x45, (byte)0xF9,\n-              (byte)0x02, (byte)0x7F, (byte)0x50, (byte)0x3C, (byte)0x9F,\n-              (byte)0xA8 },\n-            { (byte)0x51, (byte)0xA3, (byte)0x40, (byte)0x8F, (byte)0x92,\n-              (byte)0x9D, (byte)0x38, (byte)0xF5, (byte)0xBC, (byte)0xB6,\n-              (byte)0xDA, (byte)0x21, (byte)0x10, (byte)0xFF, (byte)0xF3,\n-              (byte)0xD2 },\n-            { (byte)0xCD, (byte)0x0C, (byte)0x13, (byte)0xEC, (byte)0x5F,\n-              (byte)0x97, (byte)0x44, (byte)0x17, (byte)0xC4, (byte)0xA7,\n-              (byte)0x7E, (byte)0x3D, (byte)0x64, (byte)0x5D, (byte)0x19,\n-              (byte)0x73 },\n-            { (byte)0x60, (byte)0x81, (byte)0x4F, (byte)0xDC, (byte)0x22,\n-              (byte)0x2A, (byte)0x90, (byte)0x88, (byte)0x46, (byte)0xEE,\n-              (byte)0xB8, (byte)0x14, (byte)0xDE, (byte)0x5E, (byte)0x0B,\n-              (byte)0xDB },\n-            { (byte)0xE0, (byte)0x32, (byte)0x3A, (byte)0x0A, (byte)0x49,\n-              (byte)0x06, (byte)0x24, (byte)0x5C, (byte)0xC2, (byte)0xD3,\n-              (byte)0xAC, (byte)0x62, (byte)0x91, (byte)0x95, (byte)0xE4,\n-              (byte)0x79 },\n-            { (byte)0xE7, (byte)0xC8, (byte)0x37, (byte)0x6D, (byte)0x8D,\n-              (byte)0xD5, (byte)0x4E, (byte)0xA9, (byte)0x6C, (byte)0x56,\n-              (byte)0xF4, (byte)0xEA, (byte)0x65, (byte)0x7A, (byte)0xAE,\n-              (byte)0x08 },\n-            { (byte)0xBA, (byte)0x78, (byte)0x25, (byte)0x2E, (byte)0x1C,\n-              (byte)0xA6, (byte)0xB4, (byte)0xC6, (byte)0xE8, (byte)0xDD,\n-              (byte)0x74, (byte)0x1F, (byte)0x4B, (byte)0xBD, (byte)0x8B,\n-              (byte)0x8A },\n-            { (byte)0x70, (byte)0x3E, (byte)0xB5, (byte)0x66, (byte)0x48,\n-              (byte)0x03, (byte)0xF6, (byte)0x0E, (byte)0x61, (byte)0x35,\n-              (byte)0x57, (byte)0xB9, (byte)0x86, (byte)0xC1, (byte)0x1D,\n-              (byte)0x9E },\n-            { (byte)0xE1, (byte)0xF8, (byte)0x98, (byte)0x11, (byte)0x69,\n-              (byte)0xD9, (byte)0x8E, (byte)0x94, (byte)0x9B, (byte)0x1E,\n-              (byte)0x87, (byte)0xE9, (byte)0xCE, (byte)0x55, (byte)0x28,\n-              (byte)0xDF },\n-            { (byte)0x8C, (byte)0xA1, (byte)0x89, (byte)0x0D, (byte)0xBF,\n-              (byte)0xE6, (byte)0x42, (byte)0x68, (byte)0x41, (byte)0x99,\n-              (byte)0x2D, (byte)0x0F, (byte)0xB0, (byte)0x54, (byte)0xBB,\n-              (byte)0x16 }\n-    };\n-\n-    \/\/ Lookup table for row 0 transforms, see section 5.2.1 of original spec.\n-    private static final int[] T0 = {\n-            0xC66363A5, 0xF87C7C84, 0xEE777799, 0xF67B7B8D, 0xFFF2F20D,\n-            0xD66B6BBD, 0xDE6F6FB1, 0x91C5C554, 0x60303050, 0x02010103,\n-            0xCE6767A9, 0x562B2B7D, 0xE7FEFE19, 0xB5D7D762, 0x4DABABE6,\n-            0xEC76769A, 0x8FCACA45, 0x1F82829D, 0x89C9C940, 0xFA7D7D87,\n-            0xEFFAFA15, 0xB25959EB, 0x8E4747C9, 0xFBF0F00B, 0x41ADADEC,\n-            0xB3D4D467, 0x5FA2A2FD, 0x45AFAFEA, 0x239C9CBF, 0x53A4A4F7,\n-            0xE4727296, 0x9BC0C05B, 0x75B7B7C2, 0xE1FDFD1C, 0x3D9393AE,\n-            0x4C26266A, 0x6C36365A, 0x7E3F3F41, 0xF5F7F702, 0x83CCCC4F,\n-            0x6834345C, 0x51A5A5F4, 0xD1E5E534, 0xF9F1F108, 0xE2717193,\n-            0xABD8D873, 0x62313153, 0x2A15153F, 0x0804040C, 0x95C7C752,\n-            0x46232365, 0x9DC3C35E, 0x30181828, 0x379696A1, 0x0A05050F,\n-            0x2F9A9AB5, 0x0E070709, 0x24121236, 0x1B80809B, 0xDFE2E23D,\n-            0xCDEBEB26, 0x4E272769, 0x7FB2B2CD, 0xEA75759F, 0x1209091B,\n-            0x1D83839E, 0x582C2C74, 0x341A1A2E, 0x361B1B2D, 0xDC6E6EB2,\n-            0xB45A5AEE, 0x5BA0A0FB, 0xA45252F6, 0x763B3B4D, 0xB7D6D661,\n-            0x7DB3B3CE, 0x5229297B, 0xDDE3E33E, 0x5E2F2F71, 0x13848497,\n-            0xA65353F5, 0xB9D1D168, 0x00000000, 0xC1EDED2C, 0x40202060,\n-            0xE3FCFC1F, 0x79B1B1C8, 0xB65B5BED, 0xD46A6ABE, 0x8DCBCB46,\n-            0x67BEBED9, 0x7239394B, 0x944A4ADE, 0x984C4CD4, 0xB05858E8,\n-            0x85CFCF4A, 0xBBD0D06B, 0xC5EFEF2A, 0x4FAAAAE5, 0xEDFBFB16,\n-            0x864343C5, 0x9A4D4DD7, 0x66333355, 0x11858594, 0x8A4545CF,\n-            0xE9F9F910, 0x04020206, 0xFE7F7F81, 0xA05050F0, 0x783C3C44,\n-            0x259F9FBA, 0x4BA8A8E3, 0xA25151F3, 0x5DA3A3FE, 0x804040C0,\n-            0x058F8F8A, 0x3F9292AD, 0x219D9DBC, 0x70383848, 0xF1F5F504,\n-            0x63BCBCDF, 0x77B6B6C1, 0xAFDADA75, 0x42212163, 0x20101030,\n-            0xE5FFFF1A, 0xFDF3F30E, 0xBFD2D26D, 0x81CDCD4C, 0x180C0C14,\n-            0x26131335, 0xC3ECEC2F, 0xBE5F5FE1, 0x359797A2, 0x884444CC,\n-            0x2E171739, 0x93C4C457, 0x55A7A7F2, 0xFC7E7E82, 0x7A3D3D47,\n-            0xC86464AC, 0xBA5D5DE7, 0x3219192B, 0xE6737395, 0xC06060A0,\n-            0x19818198, 0x9E4F4FD1, 0xA3DCDC7F, 0x44222266, 0x542A2A7E,\n-            0x3B9090AB, 0x0B888883, 0x8C4646CA, 0xC7EEEE29, 0x6BB8B8D3,\n-            0x2814143C, 0xA7DEDE79, 0xBC5E5EE2, 0x160B0B1D, 0xADDBDB76,\n-            0xDBE0E03B, 0x64323256, 0x743A3A4E, 0x140A0A1E, 0x924949DB,\n-            0x0C06060A, 0x4824246C, 0xB85C5CE4, 0x9FC2C25D, 0xBDD3D36E,\n-            0x43ACACEF, 0xC46262A6, 0x399191A8, 0x319595A4, 0xD3E4E437,\n-            0xF279798B, 0xD5E7E732, 0x8BC8C843, 0x6E373759, 0xDA6D6DB7,\n-            0x018D8D8C, 0xB1D5D564, 0x9C4E4ED2, 0x49A9A9E0, 0xD86C6CB4,\n-            0xAC5656FA, 0xF3F4F407, 0xCFEAEA25, 0xCA6565AF, 0xF47A7A8E,\n-            0x47AEAEE9, 0x10080818, 0x6FBABAD5, 0xF0787888, 0x4A25256F,\n-            0x5C2E2E72, 0x381C1C24, 0x57A6A6F1, 0x73B4B4C7, 0x97C6C651,\n-            0xCBE8E823, 0xA1DDDD7C, 0xE874749C, 0x3E1F1F21, 0x964B4BDD,\n-            0x61BDBDDC, 0x0D8B8B86, 0x0F8A8A85, 0xE0707090, 0x7C3E3E42,\n-            0x71B5B5C4, 0xCC6666AA, 0x904848D8, 0x06030305, 0xF7F6F601,\n-            0x1C0E0E12, 0xC26161A3, 0x6A35355F, 0xAE5757F9, 0x69B9B9D0,\n-            0x17868691, 0x99C1C158, 0x3A1D1D27, 0x279E9EB9, 0xD9E1E138,\n-            0xEBF8F813, 0x2B9898B3, 0x22111133, 0xD26969BB, 0xA9D9D970,\n-            0x078E8E89, 0x339494A7, 0x2D9B9BB6, 0x3C1E1E22, 0x15878792,\n-            0xC9E9E920, 0x87CECE49, 0xAA5555FF, 0x50282878, 0xA5DFDF7A,\n-            0x038C8C8F, 0x59A1A1F8, 0x09898980, 0x1A0D0D17, 0x65BFBFDA,\n-            0xD7E6E631, 0x844242C6, 0xD06868B8, 0x824141C3, 0x299999B0,\n-            0x5A2D2D77, 0x1E0F0F11, 0x7BB0B0CB, 0xA85454FC, 0x6DBBBBD6,\n-            0x2C16163A,\n-    };\n-\n-    \/\/ Lookup table for row 1 transforms, see section 5.2.1 of original spec.\n-    private static final int[] T1 = {\n-            0xA5C66363, 0x84F87C7C, 0x99EE7777, 0x8DF67B7B, 0x0DFFF2F2,\n-            0xBDD66B6B, 0xB1DE6F6F, 0x5491C5C5, 0x50603030, 0x03020101,\n-            0xA9CE6767, 0x7D562B2B, 0x19E7FEFE, 0x62B5D7D7, 0xE64DABAB,\n-            0x9AEC7676, 0x458FCACA, 0x9D1F8282, 0x4089C9C9, 0x87FA7D7D,\n-            0x15EFFAFA, 0xEBB25959, 0xC98E4747, 0x0BFBF0F0, 0xEC41ADAD,\n-            0x67B3D4D4, 0xFD5FA2A2, 0xEA45AFAF, 0xBF239C9C, 0xF753A4A4,\n-            0x96E47272, 0x5B9BC0C0, 0xC275B7B7, 0x1CE1FDFD, 0xAE3D9393,\n-            0x6A4C2626, 0x5A6C3636, 0x417E3F3F, 0x02F5F7F7, 0x4F83CCCC,\n-            0x5C683434, 0xF451A5A5, 0x34D1E5E5, 0x08F9F1F1, 0x93E27171,\n-            0x73ABD8D8, 0x53623131, 0x3F2A1515, 0x0C080404, 0x5295C7C7,\n-            0x65462323, 0x5E9DC3C3, 0x28301818, 0xA1379696, 0x0F0A0505,\n-            0xB52F9A9A, 0x090E0707, 0x36241212, 0x9B1B8080, 0x3DDFE2E2,\n-            0x26CDEBEB, 0x694E2727, 0xCD7FB2B2, 0x9FEA7575, 0x1B120909,\n-            0x9E1D8383, 0x74582C2C, 0x2E341A1A, 0x2D361B1B, 0xB2DC6E6E,\n-            0xEEB45A5A, 0xFB5BA0A0, 0xF6A45252, 0x4D763B3B, 0x61B7D6D6,\n-            0xCE7DB3B3, 0x7B522929, 0x3EDDE3E3, 0x715E2F2F, 0x97138484,\n-            0xF5A65353, 0x68B9D1D1, 0x00000000, 0x2CC1EDED, 0x60402020,\n-            0x1FE3FCFC, 0xC879B1B1, 0xEDB65B5B, 0xBED46A6A, 0x468DCBCB,\n-            0xD967BEBE, 0x4B723939, 0xDE944A4A, 0xD4984C4C, 0xE8B05858,\n-            0x4A85CFCF, 0x6BBBD0D0, 0x2AC5EFEF, 0xE54FAAAA, 0x16EDFBFB,\n-            0xC5864343, 0xD79A4D4D, 0x55663333, 0x94118585, 0xCF8A4545,\n-            0x10E9F9F9, 0x06040202, 0x81FE7F7F, 0xF0A05050, 0x44783C3C,\n-            0xBA259F9F, 0xE34BA8A8, 0xF3A25151, 0xFE5DA3A3, 0xC0804040,\n-            0x8A058F8F, 0xAD3F9292, 0xBC219D9D, 0x48703838, 0x04F1F5F5,\n-            0xDF63BCBC, 0xC177B6B6, 0x75AFDADA, 0x63422121, 0x30201010,\n-            0x1AE5FFFF, 0x0EFDF3F3, 0x6DBFD2D2, 0x4C81CDCD, 0x14180C0C,\n-            0x35261313, 0x2FC3ECEC, 0xE1BE5F5F, 0xA2359797, 0xCC884444,\n-            0x392E1717, 0x5793C4C4, 0xF255A7A7, 0x82FC7E7E, 0x477A3D3D,\n-            0xACC86464, 0xE7BA5D5D, 0x2B321919, 0x95E67373, 0xA0C06060,\n-            0x98198181, 0xD19E4F4F, 0x7FA3DCDC, 0x66442222, 0x7E542A2A,\n-            0xAB3B9090, 0x830B8888, 0xCA8C4646, 0x29C7EEEE, 0xD36BB8B8,\n-            0x3C281414, 0x79A7DEDE, 0xE2BC5E5E, 0x1D160B0B, 0x76ADDBDB,\n-            0x3BDBE0E0, 0x56643232, 0x4E743A3A, 0x1E140A0A, 0xDB924949,\n-            0x0A0C0606, 0x6C482424, 0xE4B85C5C, 0x5D9FC2C2, 0x6EBDD3D3,\n-            0xEF43ACAC, 0xA6C46262, 0xA8399191, 0xA4319595, 0x37D3E4E4,\n-            0x8BF27979, 0x32D5E7E7, 0x438BC8C8, 0x596E3737, 0xB7DA6D6D,\n-            0x8C018D8D, 0x64B1D5D5, 0xD29C4E4E, 0xE049A9A9, 0xB4D86C6C,\n-            0xFAAC5656, 0x07F3F4F4, 0x25CFEAEA, 0xAFCA6565, 0x8EF47A7A,\n-            0xE947AEAE, 0x18100808, 0xD56FBABA, 0x88F07878, 0x6F4A2525,\n-            0x725C2E2E, 0x24381C1C, 0xF157A6A6, 0xC773B4B4, 0x5197C6C6,\n-            0x23CBE8E8, 0x7CA1DDDD, 0x9CE87474, 0x213E1F1F, 0xDD964B4B,\n-            0xDC61BDBD, 0x860D8B8B, 0x850F8A8A, 0x90E07070, 0x427C3E3E,\n-            0xC471B5B5, 0xAACC6666, 0xD8904848, 0x05060303, 0x01F7F6F6,\n-            0x121C0E0E, 0xA3C26161, 0x5F6A3535, 0xF9AE5757, 0xD069B9B9,\n-            0x91178686, 0x5899C1C1, 0x273A1D1D, 0xB9279E9E, 0x38D9E1E1,\n-            0x13EBF8F8, 0xB32B9898, 0x33221111, 0xBBD26969, 0x70A9D9D9,\n-            0x89078E8E, 0xA7339494, 0xB62D9B9B, 0x223C1E1E, 0x92158787,\n-            0x20C9E9E9, 0x4987CECE, 0xFFAA5555, 0x78502828, 0x7AA5DFDF,\n-            0x8F038C8C, 0xF859A1A1, 0x80098989, 0x171A0D0D, 0xDA65BFBF,\n-            0x31D7E6E6, 0xC6844242, 0xB8D06868, 0xC3824141, 0xB0299999,\n-            0x775A2D2D, 0x111E0F0F, 0xCB7BB0B0, 0xFCA85454, 0xD66DBBBB,\n-            0x3A2C1616,\n-    };\n-\n-    \/\/ Lookup table for row 2 transforms, see section 5.2.1 of original spec.\n-    private static final int[] T2 = {\n-            0x63A5C663, 0x7C84F87C, 0x7799EE77, 0x7B8DF67B, 0xF20DFFF2,\n-            0x6BBDD66B, 0x6FB1DE6F, 0xC55491C5, 0x30506030, 0x01030201,\n-            0x67A9CE67, 0x2B7D562B, 0xFE19E7FE, 0xD762B5D7, 0xABE64DAB,\n-            0x769AEC76, 0xCA458FCA, 0x829D1F82, 0xC94089C9, 0x7D87FA7D,\n-            0xFA15EFFA, 0x59EBB259, 0x47C98E47, 0xF00BFBF0, 0xADEC41AD,\n-            0xD467B3D4, 0xA2FD5FA2, 0xAFEA45AF, 0x9CBF239C, 0xA4F753A4,\n-            0x7296E472, 0xC05B9BC0, 0xB7C275B7, 0xFD1CE1FD, 0x93AE3D93,\n-            0x266A4C26, 0x365A6C36, 0x3F417E3F, 0xF702F5F7, 0xCC4F83CC,\n-            0x345C6834, 0xA5F451A5, 0xE534D1E5, 0xF108F9F1, 0x7193E271,\n-            0xD873ABD8, 0x31536231, 0x153F2A15, 0x040C0804, 0xC75295C7,\n-            0x23654623, 0xC35E9DC3, 0x18283018, 0x96A13796, 0x050F0A05,\n-            0x9AB52F9A, 0x07090E07, 0x12362412, 0x809B1B80, 0xE23DDFE2,\n-            0xEB26CDEB, 0x27694E27, 0xB2CD7FB2, 0x759FEA75, 0x091B1209,\n-            0x839E1D83, 0x2C74582C, 0x1A2E341A, 0x1B2D361B, 0x6EB2DC6E,\n-            0x5AEEB45A, 0xA0FB5BA0, 0x52F6A452, 0x3B4D763B, 0xD661B7D6,\n-            0xB3CE7DB3, 0x297B5229, 0xE33EDDE3, 0x2F715E2F, 0x84971384,\n-            0x53F5A653, 0xD168B9D1, 0x00000000, 0xED2CC1ED, 0x20604020,\n-            0xFC1FE3FC, 0xB1C879B1, 0x5BEDB65B, 0x6ABED46A, 0xCB468DCB,\n-            0xBED967BE, 0x394B7239, 0x4ADE944A, 0x4CD4984C, 0x58E8B058,\n-            0xCF4A85CF, 0xD06BBBD0, 0xEF2AC5EF, 0xAAE54FAA, 0xFB16EDFB,\n-            0x43C58643, 0x4DD79A4D, 0x33556633, 0x85941185, 0x45CF8A45,\n-            0xF910E9F9, 0x02060402, 0x7F81FE7F, 0x50F0A050, 0x3C44783C,\n-            0x9FBA259F, 0xA8E34BA8, 0x51F3A251, 0xA3FE5DA3, 0x40C08040,\n-            0x8F8A058F, 0x92AD3F92, 0x9DBC219D, 0x38487038, 0xF504F1F5,\n-            0xBCDF63BC, 0xB6C177B6, 0xDA75AFDA, 0x21634221, 0x10302010,\n-            0xFF1AE5FF, 0xF30EFDF3, 0xD26DBFD2, 0xCD4C81CD, 0x0C14180C,\n-            0x13352613, 0xEC2FC3EC, 0x5FE1BE5F, 0x97A23597, 0x44CC8844,\n-            0x17392E17, 0xC45793C4, 0xA7F255A7, 0x7E82FC7E, 0x3D477A3D,\n-            0x64ACC864, 0x5DE7BA5D, 0x192B3219, 0x7395E673, 0x60A0C060,\n-            0x81981981, 0x4FD19E4F, 0xDC7FA3DC, 0x22664422, 0x2A7E542A,\n-            0x90AB3B90, 0x88830B88, 0x46CA8C46, 0xEE29C7EE, 0xB8D36BB8,\n-            0x143C2814, 0xDE79A7DE, 0x5EE2BC5E, 0x0B1D160B, 0xDB76ADDB,\n-            0xE03BDBE0, 0x32566432, 0x3A4E743A, 0x0A1E140A, 0x49DB9249,\n-            0x060A0C06, 0x246C4824, 0x5CE4B85C, 0xC25D9FC2, 0xD36EBDD3,\n-            0xACEF43AC, 0x62A6C462, 0x91A83991, 0x95A43195, 0xE437D3E4,\n-            0x798BF279, 0xE732D5E7, 0xC8438BC8, 0x37596E37, 0x6DB7DA6D,\n-            0x8D8C018D, 0xD564B1D5, 0x4ED29C4E, 0xA9E049A9, 0x6CB4D86C,\n-            0x56FAAC56, 0xF407F3F4, 0xEA25CFEA, 0x65AFCA65, 0x7A8EF47A,\n-            0xAEE947AE, 0x08181008, 0xBAD56FBA, 0x7888F078, 0x256F4A25,\n-            0x2E725C2E, 0x1C24381C, 0xA6F157A6, 0xB4C773B4, 0xC65197C6,\n-            0xE823CBE8, 0xDD7CA1DD, 0x749CE874, 0x1F213E1F, 0x4BDD964B,\n-            0xBDDC61BD, 0x8B860D8B, 0x8A850F8A, 0x7090E070, 0x3E427C3E,\n-            0xB5C471B5, 0x66AACC66, 0x48D89048, 0x03050603, 0xF601F7F6,\n-            0x0E121C0E, 0x61A3C261, 0x355F6A35, 0x57F9AE57, 0xB9D069B9,\n-            0x86911786, 0xC15899C1, 0x1D273A1D, 0x9EB9279E, 0xE138D9E1,\n-            0xF813EBF8, 0x98B32B98, 0x11332211, 0x69BBD269, 0xD970A9D9,\n-            0x8E89078E, 0x94A73394, 0x9BB62D9B, 0x1E223C1E, 0x87921587,\n-            0xE920C9E9, 0xCE4987CE, 0x55FFAA55, 0x28785028, 0xDF7AA5DF,\n-            0x8C8F038C, 0xA1F859A1, 0x89800989, 0x0D171A0D, 0xBFDA65BF,\n-            0xE631D7E6, 0x42C68442, 0x68B8D068, 0x41C38241, 0x99B02999,\n-            0x2D775A2D, 0x0F111E0F, 0xB0CB7BB0, 0x54FCA854, 0xBBD66DBB,\n-            0x163A2C16,\n-    };\n-\n-    \/\/ Lookup table for row 3 transforms, see section 5.2.1 of original spec.\n-    private static final int[] T3 = {\n-            0x6363A5C6, 0x7C7C84F8, 0x777799EE, 0x7B7B8DF6, 0xF2F20DFF,\n-            0x6B6BBDD6, 0x6F6FB1DE, 0xC5C55491, 0x30305060, 0x01010302,\n-            0x6767A9CE, 0x2B2B7D56, 0xFEFE19E7, 0xD7D762B5, 0xABABE64D,\n-            0x76769AEC, 0xCACA458F, 0x82829D1F, 0xC9C94089, 0x7D7D87FA,\n-            0xFAFA15EF, 0x5959EBB2, 0x4747C98E, 0xF0F00BFB, 0xADADEC41,\n-            0xD4D467B3, 0xA2A2FD5F, 0xAFAFEA45, 0x9C9CBF23, 0xA4A4F753,\n-            0x727296E4, 0xC0C05B9B, 0xB7B7C275, 0xFDFD1CE1, 0x9393AE3D,\n-            0x26266A4C, 0x36365A6C, 0x3F3F417E, 0xF7F702F5, 0xCCCC4F83,\n-            0x34345C68, 0xA5A5F451, 0xE5E534D1, 0xF1F108F9, 0x717193E2,\n-            0xD8D873AB, 0x31315362, 0x15153F2A, 0x04040C08, 0xC7C75295,\n-            0x23236546, 0xC3C35E9D, 0x18182830, 0x9696A137, 0x05050F0A,\n-            0x9A9AB52F, 0x0707090E, 0x12123624, 0x80809B1B, 0xE2E23DDF,\n-            0xEBEB26CD, 0x2727694E, 0xB2B2CD7F, 0x75759FEA, 0x09091B12,\n-            0x83839E1D, 0x2C2C7458, 0x1A1A2E34, 0x1B1B2D36, 0x6E6EB2DC,\n-            0x5A5AEEB4, 0xA0A0FB5B, 0x5252F6A4, 0x3B3B4D76, 0xD6D661B7,\n-            0xB3B3CE7D, 0x29297B52, 0xE3E33EDD, 0x2F2F715E, 0x84849713,\n-            0x5353F5A6, 0xD1D168B9, 0x00000000, 0xEDED2CC1, 0x20206040,\n-            0xFCFC1FE3, 0xB1B1C879, 0x5B5BEDB6, 0x6A6ABED4, 0xCBCB468D,\n-            0xBEBED967, 0x39394B72, 0x4A4ADE94, 0x4C4CD498, 0x5858E8B0,\n-            0xCFCF4A85, 0xD0D06BBB, 0xEFEF2AC5, 0xAAAAE54F, 0xFBFB16ED,\n-            0x4343C586, 0x4D4DD79A, 0x33335566, 0x85859411, 0x4545CF8A,\n-            0xF9F910E9, 0x02020604, 0x7F7F81FE, 0x5050F0A0, 0x3C3C4478,\n-            0x9F9FBA25, 0xA8A8E34B, 0x5151F3A2, 0xA3A3FE5D, 0x4040C080,\n-            0x8F8F8A05, 0x9292AD3F, 0x9D9DBC21, 0x38384870, 0xF5F504F1,\n-            0xBCBCDF63, 0xB6B6C177, 0xDADA75AF, 0x21216342, 0x10103020,\n-            0xFFFF1AE5, 0xF3F30EFD, 0xD2D26DBF, 0xCDCD4C81, 0x0C0C1418,\n-            0x13133526, 0xECEC2FC3, 0x5F5FE1BE, 0x9797A235, 0x4444CC88,\n-            0x1717392E, 0xC4C45793, 0xA7A7F255, 0x7E7E82FC, 0x3D3D477A,\n-            0x6464ACC8, 0x5D5DE7BA, 0x19192B32, 0x737395E6, 0x6060A0C0,\n-            0x81819819, 0x4F4FD19E, 0xDCDC7FA3, 0x22226644, 0x2A2A7E54,\n-            0x9090AB3B, 0x8888830B, 0x4646CA8C, 0xEEEE29C7, 0xB8B8D36B,\n-            0x14143C28, 0xDEDE79A7, 0x5E5EE2BC, 0x0B0B1D16, 0xDBDB76AD,\n-            0xE0E03BDB, 0x32325664, 0x3A3A4E74, 0x0A0A1E14, 0x4949DB92,\n-            0x06060A0C, 0x24246C48, 0x5C5CE4B8, 0xC2C25D9F, 0xD3D36EBD,\n-            0xACACEF43, 0x6262A6C4, 0x9191A839, 0x9595A431, 0xE4E437D3,\n-            0x79798BF2, 0xE7E732D5, 0xC8C8438B, 0x3737596E, 0x6D6DB7DA,\n-            0x8D8D8C01, 0xD5D564B1, 0x4E4ED29C, 0xA9A9E049, 0x6C6CB4D8,\n-            0x5656FAAC, 0xF4F407F3, 0xEAEA25CF, 0x6565AFCA, 0x7A7A8EF4,\n-            0xAEAEE947, 0x08081810, 0xBABAD56F, 0x787888F0, 0x25256F4A,\n-            0x2E2E725C, 0x1C1C2438, 0xA6A6F157, 0xB4B4C773, 0xC6C65197,\n-            0xE8E823CB, 0xDDDD7CA1, 0x74749CE8, 0x1F1F213E, 0x4B4BDD96,\n-            0xBDBDDC61, 0x8B8B860D, 0x8A8A850F, 0x707090E0, 0x3E3E427C,\n-            0xB5B5C471, 0x6666AACC, 0x4848D890, 0x03030506, 0xF6F601F7,\n-            0x0E0E121C, 0x6161A3C2, 0x35355F6A, 0x5757F9AE, 0xB9B9D069,\n-            0x86869117, 0xC1C15899, 0x1D1D273A, 0x9E9EB927, 0xE1E138D9,\n-            0xF8F813EB, 0x9898B32B, 0x11113322, 0x6969BBD2, 0xD9D970A9,\n-            0x8E8E8907, 0x9494A733, 0x9B9BB62D, 0x1E1E223C, 0x87879215,\n-            0xE9E920C9, 0xCECE4987, 0x5555FFAA, 0x28287850, 0xDFDF7AA5,\n-            0x8C8C8F03, 0xA1A1F859, 0x89898009, 0x0D0D171A, 0xBFBFDA65,\n-            0xE6E631D7, 0x4242C684, 0x6868B8D0, 0x4141C382, 0x9999B029,\n-            0x2D2D775A, 0x0F0F111E, 0xB0B0CB7B, 0x5454FCA8, 0xBBBBD66D,\n-            0x16163A2C,\n-    };\n-\n-    \/\/ Lookup table for row 0 inverse transforms, see section 5.2.1 of original\n-    \/\/ spec.\n-    private static final int[] TI0 = {\n-            0x51F4A750, 0x7E416553, 0x1A17A4C3, 0x3A275E96, 0x3BAB6BCB,\n-            0x1F9D45F1, 0xACFA58AB, 0x4BE30393, 0x2030FA55, 0xAD766DF6,\n-            0x88CC7691, 0xF5024C25, 0x4FE5D7FC, 0xC52ACBD7, 0x26354480,\n-            0xB562A38F, 0xDEB15A49, 0x25BA1B67, 0x45EA0E98, 0x5DFEC0E1,\n-            0xC32F7502, 0x814CF012, 0x8D4697A3, 0x6BD3F9C6, 0x038F5FE7,\n-            0x15929C95, 0xBF6D7AEB, 0x955259DA, 0xD4BE832D, 0x587421D3,\n-            0x49E06929, 0x8EC9C844, 0x75C2896A, 0xF48E7978, 0x99583E6B,\n-            0x27B971DD, 0xBEE14FB6, 0xF088AD17, 0xC920AC66, 0x7DCE3AB4,\n-            0x63DF4A18, 0xE51A3182, 0x97513360, 0x62537F45, 0xB16477E0,\n-            0xBB6BAE84, 0xFE81A01C, 0xF9082B94, 0x70486858, 0x8F45FD19,\n-            0x94DE6C87, 0x527BF8B7, 0xAB73D323, 0x724B02E2, 0xE31F8F57,\n-            0x6655AB2A, 0xB2EB2807, 0x2FB5C203, 0x86C57B9A, 0xD33708A5,\n-            0x302887F2, 0x23BFA5B2, 0x02036ABA, 0xED16825C, 0x8ACF1C2B,\n-            0xA779B492, 0xF307F2F0, 0x4E69E2A1, 0x65DAF4CD, 0x0605BED5,\n-            0xD134621F, 0xC4A6FE8A, 0x342E539D, 0xA2F355A0, 0x058AE132,\n-            0xA4F6EB75, 0x0B83EC39, 0x4060EFAA, 0x5E719F06, 0xBD6E1051,\n-            0x3E218AF9, 0x96DD063D, 0xDD3E05AE, 0x4DE6BD46, 0x91548DB5,\n-            0x71C45D05, 0x0406D46F, 0x605015FF, 0x1998FB24, 0xD6BDE997,\n-            0x894043CC, 0x67D99E77, 0xB0E842BD, 0x07898B88, 0xE7195B38,\n-            0x79C8EEDB, 0xA17C0A47, 0x7C420FE9, 0xF8841EC9, 0x00000000,\n-            0x09808683, 0x322BED48, 0x1E1170AC, 0x6C5A724E, 0xFD0EFFFB,\n-            0x0F853856, 0x3DAED51E, 0x362D3927, 0x0A0FD964, 0x685CA621,\n-            0x9B5B54D1, 0x24362E3A, 0x0C0A67B1, 0x9357E70F, 0xB4EE96D2,\n-            0x1B9B919E, 0x80C0C54F, 0x61DC20A2, 0x5A774B69, 0x1C121A16,\n-            0xE293BA0A, 0xC0A02AE5, 0x3C22E043, 0x121B171D, 0x0E090D0B,\n-            0xF28BC7AD, 0x2DB6A8B9, 0x141EA9C8, 0x57F11985, 0xAF75074C,\n-            0xEE99DDBB, 0xA37F60FD, 0xF701269F, 0x5C72F5BC, 0x44663BC5,\n-            0x5BFB7E34, 0x8B432976, 0xCB23C6DC, 0xB6EDFC68, 0xB8E4F163,\n-            0xD731DCCA, 0x42638510, 0x13972240, 0x84C61120, 0x854A247D,\n-            0xD2BB3DF8, 0xAEF93211, 0xC729A16D, 0x1D9E2F4B, 0xDCB230F3,\n-            0x0D8652EC, 0x77C1E3D0, 0x2BB3166C, 0xA970B999, 0x119448FA,\n-            0x47E96422, 0xA8FC8CC4, 0xA0F03F1A, 0x567D2CD8, 0x223390EF,\n-            0x87494EC7, 0xD938D1C1, 0x8CCAA2FE, 0x98D40B36, 0xA6F581CF,\n-            0xA57ADE28, 0xDAB78E26, 0x3FADBFA4, 0x2C3A9DE4, 0x5078920D,\n-            0x6A5FCC9B, 0x547E4662, 0xF68D13C2, 0x90D8B8E8, 0x2E39F75E,\n-            0x82C3AFF5, 0x9F5D80BE, 0x69D0937C, 0x6FD52DA9, 0xCF2512B3,\n-            0xC8AC993B, 0x10187DA7, 0xE89C636E, 0xDB3BBB7B, 0xCD267809,\n-            0x6E5918F4, 0xEC9AB701, 0x834F9AA8, 0xE6956E65, 0xAAFFE67E,\n-            0x21BCCF08, 0xEF15E8E6, 0xBAE79BD9, 0x4A6F36CE, 0xEA9F09D4,\n-            0x29B07CD6, 0x31A4B2AF, 0x2A3F2331, 0xC6A59430, 0x35A266C0,\n-            0x744EBC37, 0xFC82CAA6, 0xE090D0B0, 0x33A7D815, 0xF104984A,\n-            0x41ECDAF7, 0x7FCD500E, 0x1791F62F, 0x764DD68D, 0x43EFB04D,\n-            0xCCAA4D54, 0xE49604DF, 0x9ED1B5E3, 0x4C6A881B, 0xC12C1FB8,\n-            0x4665517F, 0x9D5EEA04, 0x018C355D, 0xFA877473, 0xFB0B412E,\n-            0xB3671D5A, 0x92DBD252, 0xE9105633, 0x6DD64713, 0x9AD7618C,\n-            0x37A10C7A, 0x59F8148E, 0xEB133C89, 0xCEA927EE, 0xB761C935,\n-            0xE11CE5ED, 0x7A47B13C, 0x9CD2DF59, 0x55F2733F, 0x1814CE79,\n-            0x73C737BF, 0x53F7CDEA, 0x5FFDAA5B, 0xDF3D6F14, 0x7844DB86,\n-            0xCAAFF381, 0xB968C43E, 0x3824342C, 0xC2A3405F, 0x161DC372,\n-            0xBCE2250C, 0x283C498B, 0xFF0D9541, 0x39A80171, 0x080CB3DE,\n-            0xD8B4E49C, 0x6456C190, 0x7BCB8461, 0xD532B670, 0x486C5C74,\n-            0xD0B85742,\n-    };\n-\n-    \/\/ Lookup table for row 1 inverse transforms, see section 5.2.1 of original\n-    \/\/ spec.\n-    private static final int[] TI1 = {\n-            0x5051F4A7, 0x537E4165, 0xC31A17A4, 0x963A275E, 0xCB3BAB6B,\n-            0xF11F9D45, 0xABACFA58, 0x934BE303, 0x552030FA, 0xF6AD766D,\n-            0x9188CC76, 0x25F5024C, 0xFC4FE5D7, 0xD7C52ACB, 0x80263544,\n-            0x8FB562A3, 0x49DEB15A, 0x6725BA1B, 0x9845EA0E, 0xE15DFEC0,\n-            0x02C32F75, 0x12814CF0, 0xA38D4697, 0xC66BD3F9, 0xE7038F5F,\n-            0x9515929C, 0xEBBF6D7A, 0xDA955259, 0x2DD4BE83, 0xD3587421,\n-            0x2949E069, 0x448EC9C8, 0x6A75C289, 0x78F48E79, 0x6B99583E,\n-            0xDD27B971, 0xB6BEE14F, 0x17F088AD, 0x66C920AC, 0xB47DCE3A,\n-            0x1863DF4A, 0x82E51A31, 0x60975133, 0x4562537F, 0xE0B16477,\n-            0x84BB6BAE, 0x1CFE81A0, 0x94F9082B, 0x58704868, 0x198F45FD,\n-            0x8794DE6C, 0xB7527BF8, 0x23AB73D3, 0xE2724B02, 0x57E31F8F,\n-            0x2A6655AB, 0x07B2EB28, 0x032FB5C2, 0x9A86C57B, 0xA5D33708,\n-            0xF2302887, 0xB223BFA5, 0xBA02036A, 0x5CED1682, 0x2B8ACF1C,\n-            0x92A779B4, 0xF0F307F2, 0xA14E69E2, 0xCD65DAF4, 0xD50605BE,\n-            0x1FD13462, 0x8AC4A6FE, 0x9D342E53, 0xA0A2F355, 0x32058AE1,\n-            0x75A4F6EB, 0x390B83EC, 0xAA4060EF, 0x065E719F, 0x51BD6E10,\n-            0xF93E218A, 0x3D96DD06, 0xAEDD3E05, 0x464DE6BD, 0xB591548D,\n-            0x0571C45D, 0x6F0406D4, 0xFF605015, 0x241998FB, 0x97D6BDE9,\n-            0xCC894043, 0x7767D99E, 0xBDB0E842, 0x8807898B, 0x38E7195B,\n-            0xDB79C8EE, 0x47A17C0A, 0xE97C420F, 0xC9F8841E, 0x00000000,\n-            0x83098086, 0x48322BED, 0xAC1E1170, 0x4E6C5A72, 0xFBFD0EFF,\n-            0x560F8538, 0x1E3DAED5, 0x27362D39, 0x640A0FD9, 0x21685CA6,\n-            0xD19B5B54, 0x3A24362E, 0xB10C0A67, 0x0F9357E7, 0xD2B4EE96,\n-            0x9E1B9B91, 0x4F80C0C5, 0xA261DC20, 0x695A774B, 0x161C121A,\n-            0x0AE293BA, 0xE5C0A02A, 0x433C22E0, 0x1D121B17, 0x0B0E090D,\n-            0xADF28BC7, 0xB92DB6A8, 0xC8141EA9, 0x8557F119, 0x4CAF7507,\n-            0xBBEE99DD, 0xFDA37F60, 0x9FF70126, 0xBC5C72F5, 0xC544663B,\n-            0x345BFB7E, 0x768B4329, 0xDCCB23C6, 0x68B6EDFC, 0x63B8E4F1,\n-            0xCAD731DC, 0x10426385, 0x40139722, 0x2084C611, 0x7D854A24,\n-            0xF8D2BB3D, 0x11AEF932, 0x6DC729A1, 0x4B1D9E2F, 0xF3DCB230,\n-            0xEC0D8652, 0xD077C1E3, 0x6C2BB316, 0x99A970B9, 0xFA119448,\n-            0x2247E964, 0xC4A8FC8C, 0x1AA0F03F, 0xD8567D2C, 0xEF223390,\n-            0xC787494E, 0xC1D938D1, 0xFE8CCAA2, 0x3698D40B, 0xCFA6F581,\n-            0x28A57ADE, 0x26DAB78E, 0xA43FADBF, 0xE42C3A9D, 0x0D507892,\n-            0x9B6A5FCC, 0x62547E46, 0xC2F68D13, 0xE890D8B8, 0x5E2E39F7,\n-            0xF582C3AF, 0xBE9F5D80, 0x7C69D093, 0xA96FD52D, 0xB3CF2512,\n-            0x3BC8AC99, 0xA710187D, 0x6EE89C63, 0x7BDB3BBB, 0x09CD2678,\n-            0xF46E5918, 0x01EC9AB7, 0xA8834F9A, 0x65E6956E, 0x7EAAFFE6,\n-            0x0821BCCF, 0xE6EF15E8, 0xD9BAE79B, 0xCE4A6F36, 0xD4EA9F09,\n-            0xD629B07C, 0xAF31A4B2, 0x312A3F23, 0x30C6A594, 0xC035A266,\n-            0x37744EBC, 0xA6FC82CA, 0xB0E090D0, 0x1533A7D8, 0x4AF10498,\n-            0xF741ECDA, 0x0E7FCD50, 0x2F1791F6, 0x8D764DD6, 0x4D43EFB0,\n-            0x54CCAA4D, 0xDFE49604, 0xE39ED1B5, 0x1B4C6A88, 0xB8C12C1F,\n-            0x7F466551, 0x049D5EEA, 0x5D018C35, 0x73FA8774, 0x2EFB0B41,\n-            0x5AB3671D, 0x5292DBD2, 0x33E91056, 0x136DD647, 0x8C9AD761,\n-            0x7A37A10C, 0x8E59F814, 0x89EB133C, 0xEECEA927, 0x35B761C9,\n-            0xEDE11CE5, 0x3C7A47B1, 0x599CD2DF, 0x3F55F273, 0x791814CE,\n-            0xBF73C737, 0xEA53F7CD, 0x5B5FFDAA, 0x14DF3D6F, 0x867844DB,\n-            0x81CAAFF3, 0x3EB968C4, 0x2C382434, 0x5FC2A340, 0x72161DC3,\n-            0x0CBCE225, 0x8B283C49, 0x41FF0D95, 0x7139A801, 0xDE080CB3,\n-            0x9CD8B4E4, 0x906456C1, 0x617BCB84, 0x70D532B6, 0x74486C5C,\n-            0x42D0B857,\n-    };\n-\n-    \/\/ Lookup table for row 2 inverse transforms, see section 5.2.1 of original\n-    \/\/ spec.\n-    private static final int[] TI2 = {\n-            0xA75051F4, 0x65537E41, 0xA4C31A17, 0x5E963A27, 0x6BCB3BAB,\n-            0x45F11F9D, 0x58ABACFA, 0x03934BE3, 0xFA552030, 0x6DF6AD76,\n-            0x769188CC, 0x4C25F502, 0xD7FC4FE5, 0xCBD7C52A, 0x44802635,\n-            0xA38FB562, 0x5A49DEB1, 0x1B6725BA, 0x0E9845EA, 0xC0E15DFE,\n-            0x7502C32F, 0xF012814C, 0x97A38D46, 0xF9C66BD3, 0x5FE7038F,\n-            0x9C951592, 0x7AEBBF6D, 0x59DA9552, 0x832DD4BE, 0x21D35874,\n-            0x692949E0, 0xC8448EC9, 0x896A75C2, 0x7978F48E, 0x3E6B9958,\n-            0x71DD27B9, 0x4FB6BEE1, 0xAD17F088, 0xAC66C920, 0x3AB47DCE,\n-            0x4A1863DF, 0x3182E51A, 0x33609751, 0x7F456253, 0x77E0B164,\n-            0xAE84BB6B, 0xA01CFE81, 0x2B94F908, 0x68587048, 0xFD198F45,\n-            0x6C8794DE, 0xF8B7527B, 0xD323AB73, 0x02E2724B, 0x8F57E31F,\n-            0xAB2A6655, 0x2807B2EB, 0xC2032FB5, 0x7B9A86C5, 0x08A5D337,\n-            0x87F23028, 0xA5B223BF, 0x6ABA0203, 0x825CED16, 0x1C2B8ACF,\n-            0xB492A779, 0xF2F0F307, 0xE2A14E69, 0xF4CD65DA, 0xBED50605,\n-            0x621FD134, 0xFE8AC4A6, 0x539D342E, 0x55A0A2F3, 0xE132058A,\n-            0xEB75A4F6, 0xEC390B83, 0xEFAA4060, 0x9F065E71, 0x1051BD6E,\n-            0x8AF93E21, 0x063D96DD, 0x05AEDD3E, 0xBD464DE6, 0x8DB59154,\n-            0x5D0571C4, 0xD46F0406, 0x15FF6050, 0xFB241998, 0xE997D6BD,\n-            0x43CC8940, 0x9E7767D9, 0x42BDB0E8, 0x8B880789, 0x5B38E719,\n-            0xEEDB79C8, 0x0A47A17C, 0x0FE97C42, 0x1EC9F884, 0x00000000,\n-            0x86830980, 0xED48322B, 0x70AC1E11, 0x724E6C5A, 0xFFFBFD0E,\n-            0x38560F85, 0xD51E3DAE, 0x3927362D, 0xD9640A0F, 0xA621685C,\n-            0x54D19B5B, 0x2E3A2436, 0x67B10C0A, 0xE70F9357, 0x96D2B4EE,\n-            0x919E1B9B, 0xC54F80C0, 0x20A261DC, 0x4B695A77, 0x1A161C12,\n-            0xBA0AE293, 0x2AE5C0A0, 0xE0433C22, 0x171D121B, 0x0D0B0E09,\n-            0xC7ADF28B, 0xA8B92DB6, 0xA9C8141E, 0x198557F1, 0x074CAF75,\n-            0xDDBBEE99, 0x60FDA37F, 0x269FF701, 0xF5BC5C72, 0x3BC54466,\n-            0x7E345BFB, 0x29768B43, 0xC6DCCB23, 0xFC68B6ED, 0xF163B8E4,\n-            0xDCCAD731, 0x85104263, 0x22401397, 0x112084C6, 0x247D854A,\n-            0x3DF8D2BB, 0x3211AEF9, 0xA16DC729, 0x2F4B1D9E, 0x30F3DCB2,\n-            0x52EC0D86, 0xE3D077C1, 0x166C2BB3, 0xB999A970, 0x48FA1194,\n-            0x642247E9, 0x8CC4A8FC, 0x3F1AA0F0, 0x2CD8567D, 0x90EF2233,\n-            0x4EC78749, 0xD1C1D938, 0xA2FE8CCA, 0x0B3698D4, 0x81CFA6F5,\n-            0xDE28A57A, 0x8E26DAB7, 0xBFA43FAD, 0x9DE42C3A, 0x920D5078,\n-            0xCC9B6A5F, 0x4662547E, 0x13C2F68D, 0xB8E890D8, 0xF75E2E39,\n-            0xAFF582C3, 0x80BE9F5D, 0x937C69D0, 0x2DA96FD5, 0x12B3CF25,\n-            0x993BC8AC, 0x7DA71018, 0x636EE89C, 0xBB7BDB3B, 0x7809CD26,\n-            0x18F46E59, 0xB701EC9A, 0x9AA8834F, 0x6E65E695, 0xE67EAAFF,\n-            0xCF0821BC, 0xE8E6EF15, 0x9BD9BAE7, 0x36CE4A6F, 0x09D4EA9F,\n-            0x7CD629B0, 0xB2AF31A4, 0x23312A3F, 0x9430C6A5, 0x66C035A2,\n-            0xBC37744E, 0xCAA6FC82, 0xD0B0E090, 0xD81533A7, 0x984AF104,\n-            0xDAF741EC, 0x500E7FCD, 0xF62F1791, 0xD68D764D, 0xB04D43EF,\n-            0x4D54CCAA, 0x04DFE496, 0xB5E39ED1, 0x881B4C6A, 0x1FB8C12C,\n-            0x517F4665, 0xEA049D5E, 0x355D018C, 0x7473FA87, 0x412EFB0B,\n-            0x1D5AB367, 0xD25292DB, 0x5633E910, 0x47136DD6, 0x618C9AD7,\n-            0x0C7A37A1, 0x148E59F8, 0x3C89EB13, 0x27EECEA9, 0xC935B761,\n-            0xE5EDE11C, 0xB13C7A47, 0xDF599CD2, 0x733F55F2, 0xCE791814,\n-            0x37BF73C7, 0xCDEA53F7, 0xAA5B5FFD, 0x6F14DF3D, 0xDB867844,\n-            0xF381CAAF, 0xC43EB968, 0x342C3824, 0x405FC2A3, 0xC372161D,\n-            0x250CBCE2, 0x498B283C, 0x9541FF0D, 0x017139A8, 0xB3DE080C,\n-            0xE49CD8B4, 0xC1906456, 0x84617BCB, 0xB670D532, 0x5C74486C,\n-            0x5742D0B8,\n-    };\n-\n-    \/\/ Lookup table for row 3 inverse transforms, see section 5.2.1 of original\n-    \/\/ spec.\n-    private static final int[] TI3 = {\n-            0xF4A75051, 0x4165537E, 0x17A4C31A, 0x275E963A, 0xAB6BCB3B,\n-            0x9D45F11F, 0xFA58ABAC, 0xE303934B, 0x30FA5520, 0x766DF6AD,\n-            0xCC769188, 0x024C25F5, 0xE5D7FC4F, 0x2ACBD7C5, 0x35448026,\n-            0x62A38FB5, 0xB15A49DE, 0xBA1B6725, 0xEA0E9845, 0xFEC0E15D,\n-            0x2F7502C3, 0x4CF01281, 0x4697A38D, 0xD3F9C66B, 0x8F5FE703,\n-            0x929C9515, 0x6D7AEBBF, 0x5259DA95, 0xBE832DD4, 0x7421D358,\n-            0xE0692949, 0xC9C8448E, 0xC2896A75, 0x8E7978F4, 0x583E6B99,\n-            0xB971DD27, 0xE14FB6BE, 0x88AD17F0, 0x20AC66C9, 0xCE3AB47D,\n-            0xDF4A1863, 0x1A3182E5, 0x51336097, 0x537F4562, 0x6477E0B1,\n-            0x6BAE84BB, 0x81A01CFE, 0x082B94F9, 0x48685870, 0x45FD198F,\n-            0xDE6C8794, 0x7BF8B752, 0x73D323AB, 0x4B02E272, 0x1F8F57E3,\n-            0x55AB2A66, 0xEB2807B2, 0xB5C2032F, 0xC57B9A86, 0x3708A5D3,\n-            0x2887F230, 0xBFA5B223, 0x036ABA02, 0x16825CED, 0xCF1C2B8A,\n-            0x79B492A7, 0x07F2F0F3, 0x69E2A14E, 0xDAF4CD65, 0x05BED506,\n-            0x34621FD1, 0xA6FE8AC4, 0x2E539D34, 0xF355A0A2, 0x8AE13205,\n-            0xF6EB75A4, 0x83EC390B, 0x60EFAA40, 0x719F065E, 0x6E1051BD,\n-            0x218AF93E, 0xDD063D96, 0x3E05AEDD, 0xE6BD464D, 0x548DB591,\n-            0xC45D0571, 0x06D46F04, 0x5015FF60, 0x98FB2419, 0xBDE997D6,\n-            0x4043CC89, 0xD99E7767, 0xE842BDB0, 0x898B8807, 0x195B38E7,\n-            0xC8EEDB79, 0x7C0A47A1, 0x420FE97C, 0x841EC9F8, 0x00000000,\n-            0x80868309, 0x2BED4832, 0x1170AC1E, 0x5A724E6C, 0x0EFFFBFD,\n-            0x8538560F, 0xAED51E3D, 0x2D392736, 0x0FD9640A, 0x5CA62168,\n-            0x5B54D19B, 0x362E3A24, 0x0A67B10C, 0x57E70F93, 0xEE96D2B4,\n-            0x9B919E1B, 0xC0C54F80, 0xDC20A261, 0x774B695A, 0x121A161C,\n-            0x93BA0AE2, 0xA02AE5C0, 0x22E0433C, 0x1B171D12, 0x090D0B0E,\n-            0x8BC7ADF2, 0xB6A8B92D, 0x1EA9C814, 0xF1198557, 0x75074CAF,\n-            0x99DDBBEE, 0x7F60FDA3, 0x01269FF7, 0x72F5BC5C, 0x663BC544,\n-            0xFB7E345B, 0x4329768B, 0x23C6DCCB, 0xEDFC68B6, 0xE4F163B8,\n-            0x31DCCAD7, 0x63851042, 0x97224013, 0xC6112084, 0x4A247D85,\n-            0xBB3DF8D2, 0xF93211AE, 0x29A16DC7, 0x9E2F4B1D, 0xB230F3DC,\n-            0x8652EC0D, 0xC1E3D077, 0xB3166C2B, 0x70B999A9, 0x9448FA11,\n-            0xE9642247, 0xFC8CC4A8, 0xF03F1AA0, 0x7D2CD856, 0x3390EF22,\n-            0x494EC787, 0x38D1C1D9, 0xCAA2FE8C, 0xD40B3698, 0xF581CFA6,\n-            0x7ADE28A5, 0xB78E26DA, 0xADBFA43F, 0x3A9DE42C, 0x78920D50,\n-            0x5FCC9B6A, 0x7E466254, 0x8D13C2F6, 0xD8B8E890, 0x39F75E2E,\n-            0xC3AFF582, 0x5D80BE9F, 0xD0937C69, 0xD52DA96F, 0x2512B3CF,\n-            0xAC993BC8, 0x187DA710, 0x9C636EE8, 0x3BBB7BDB, 0x267809CD,\n-            0x5918F46E, 0x9AB701EC, 0x4F9AA883, 0x956E65E6, 0xFFE67EAA,\n-            0xBCCF0821, 0x15E8E6EF, 0xE79BD9BA, 0x6F36CE4A, 0x9F09D4EA,\n-            0xB07CD629, 0xA4B2AF31, 0x3F23312A, 0xA59430C6, 0xA266C035,\n-            0x4EBC3774, 0x82CAA6FC, 0x90D0B0E0, 0xA7D81533, 0x04984AF1,\n-            0xECDAF741, 0xCD500E7F, 0x91F62F17, 0x4DD68D76, 0xEFB04D43,\n-            0xAA4D54CC, 0x9604DFE4, 0xD1B5E39E, 0x6A881B4C, 0x2C1FB8C1,\n-            0x65517F46, 0x5EEA049D, 0x8C355D01, 0x877473FA, 0x0B412EFB,\n-            0x671D5AB3, 0xDBD25292, 0x105633E9, 0xD647136D, 0xD7618C9A,\n-            0xA10C7A37, 0xF8148E59, 0x133C89EB, 0xA927EECE, 0x61C935B7,\n-            0x1CE5EDE1, 0x47B13C7A, 0xD2DF599C, 0xF2733F55, 0x14CE7918,\n-            0xC737BF73, 0xF7CDEA53, 0xFDAA5B5F, 0x3D6F14DF, 0x44DB8678,\n-            0xAFF381CA, 0x68C43EB9, 0x24342C38, 0xA3405FC2, 0x1DC37216,\n-            0xE2250CBC, 0x3C498B28, 0x0D9541FF, 0xA8017139, 0x0CB3DE08,\n-            0xB4E49CD8, 0x56C19064, 0xCB84617B, 0x32B670D5, 0x6C5C7448,\n-            0xB85742D0,\n-    };\n-\n-    \/\/ Lookup table for inverse substitution transform of last round as\n-    \/\/ described in the international journal article referenced.\n-    private static final int[] TI4 = {\n-            0x52525252, 0x09090909, 0x6A6A6A6A, 0xD5D5D5D5, 0x30303030,\n-            0x36363636, 0xA5A5A5A5, 0x38383838, 0xBFBFBFBF, 0x40404040,\n-            0xA3A3A3A3, 0x9E9E9E9E, 0x81818181, 0xF3F3F3F3, 0xD7D7D7D7,\n-            0xFBFBFBFB, 0x7C7C7C7C, 0xE3E3E3E3, 0x39393939, 0x82828282,\n-            0x9B9B9B9B, 0x2F2F2F2F, 0xFFFFFFFF, 0x87878787, 0x34343434,\n-            0x8E8E8E8E, 0x43434343, 0x44444444, 0xC4C4C4C4, 0xDEDEDEDE,\n-            0xE9E9E9E9, 0xCBCBCBCB, 0x54545454, 0x7B7B7B7B, 0x94949494,\n-            0x32323232, 0xA6A6A6A6, 0xC2C2C2C2, 0x23232323, 0x3D3D3D3D,\n-            0xEEEEEEEE, 0x4C4C4C4C, 0x95959595, 0x0B0B0B0B, 0x42424242,\n-            0xFAFAFAFA, 0xC3C3C3C3, 0x4E4E4E4E, 0x08080808, 0x2E2E2E2E,\n-            0xA1A1A1A1, 0x66666666, 0x28282828, 0xD9D9D9D9, 0x24242424,\n-            0xB2B2B2B2, 0x76767676, 0x5B5B5B5B, 0xA2A2A2A2, 0x49494949,\n-            0x6D6D6D6D, 0x8B8B8B8B, 0xD1D1D1D1, 0x25252525, 0x72727272,\n-            0xF8F8F8F8, 0xF6F6F6F6, 0x64646464, 0x86868686, 0x68686868,\n-            0x98989898, 0x16161616, 0xD4D4D4D4, 0xA4A4A4A4, 0x5C5C5C5C,\n-            0xCCCCCCCC, 0x5D5D5D5D, 0x65656565, 0xB6B6B6B6, 0x92929292,\n-            0x6C6C6C6C, 0x70707070, 0x48484848, 0x50505050, 0xFDFDFDFD,\n-            0xEDEDEDED, 0xB9B9B9B9, 0xDADADADA, 0x5E5E5E5E, 0x15151515,\n-            0x46464646, 0x57575757, 0xA7A7A7A7, 0x8D8D8D8D, 0x9D9D9D9D,\n-            0x84848484, 0x90909090, 0xD8D8D8D8, 0xABABABAB, 0x00000000,\n-            0x8C8C8C8C, 0xBCBCBCBC, 0xD3D3D3D3, 0x0A0A0A0A, 0xF7F7F7F7,\n-            0xE4E4E4E4, 0x58585858, 0x05050505, 0xB8B8B8B8, 0xB3B3B3B3,\n-            0x45454545, 0x06060606, 0xD0D0D0D0, 0x2C2C2C2C, 0x1E1E1E1E,\n-            0x8F8F8F8F, 0xCACACACA, 0x3F3F3F3F, 0x0F0F0F0F, 0x02020202,\n-            0xC1C1C1C1, 0xAFAFAFAF, 0xBDBDBDBD, 0x03030303, 0x01010101,\n-            0x13131313, 0x8A8A8A8A, 0x6B6B6B6B, 0x3A3A3A3A, 0x91919191,\n-            0x11111111, 0x41414141, 0x4F4F4F4F, 0x67676767, 0xDCDCDCDC,\n-            0xEAEAEAEA, 0x97979797, 0xF2F2F2F2, 0xCFCFCFCF, 0xCECECECE,\n-            0xF0F0F0F0, 0xB4B4B4B4, 0xE6E6E6E6, 0x73737373, 0x96969696,\n-            0xACACACAC, 0x74747474, 0x22222222, 0xE7E7E7E7, 0xADADADAD,\n-            0x35353535, 0x85858585, 0xE2E2E2E2, 0xF9F9F9F9, 0x37373737,\n-            0xE8E8E8E8, 0x1C1C1C1C, 0x75757575, 0xDFDFDFDF, 0x6E6E6E6E,\n-            0x47474747, 0xF1F1F1F1, 0x1A1A1A1A, 0x71717171, 0x1D1D1D1D,\n-            0x29292929, 0xC5C5C5C5, 0x89898989, 0x6F6F6F6F, 0xB7B7B7B7,\n-            0x62626262, 0x0E0E0E0E, 0xAAAAAAAA, 0x18181818, 0xBEBEBEBE,\n-            0x1B1B1B1B, 0xFCFCFCFC, 0x56565656, 0x3E3E3E3E, 0x4B4B4B4B,\n-            0xC6C6C6C6, 0xD2D2D2D2, 0x79797979, 0x20202020, 0x9A9A9A9A,\n-            0xDBDBDBDB, 0xC0C0C0C0, 0xFEFEFEFE, 0x78787878, 0xCDCDCDCD,\n-            0x5A5A5A5A, 0xF4F4F4F4, 0x1F1F1F1F, 0xDDDDDDDD, 0xA8A8A8A8,\n-            0x33333333, 0x88888888, 0x07070707, 0xC7C7C7C7, 0x31313131,\n-            0xB1B1B1B1, 0x12121212, 0x10101010, 0x59595959, 0x27272727,\n-            0x80808080, 0xECECECEC, 0x5F5F5F5F, 0x60606060, 0x51515151,\n-            0x7F7F7F7F, 0xA9A9A9A9, 0x19191919, 0xB5B5B5B5, 0x4A4A4A4A,\n-            0x0D0D0D0D, 0x2D2D2D2D, 0xE5E5E5E5, 0x7A7A7A7A, 0x9F9F9F9F,\n-            0x93939393, 0xC9C9C9C9, 0x9C9C9C9C, 0xEFEFEFEF, 0xA0A0A0A0,\n-            0xE0E0E0E0, 0x3B3B3B3B, 0x4D4D4D4D, 0xAEAEAEAE, 0x2A2A2A2A,\n-            0xF5F5F5F5, 0xB0B0B0B0, 0xC8C8C8C8, 0xEBEBEBEB, 0xBBBBBBBB,\n-            0x3C3C3C3C, 0x83838383, 0x53535353, 0x99999999, 0x61616161,\n-            0x17171717, 0x2B2B2B2B, 0x04040404, 0x7E7E7E7E, 0xBABABABA,\n-            0x77777777, 0xD6D6D6D6, 0x26262626, 0xE1E1E1E1, 0x69696969,\n-            0x14141414, 0x63636363, 0x55555555, 0x21212121, 0x0C0C0C0C,\n-            0x7D7D7D7D,\n-    };\n-\n-    \/\/ Lookup table for row 0 of the inverse mix column transform.\n-    private static final int[] TMI0 = {\n-            0x00000000, 0x0E090D0B, 0x1C121A16, 0x121B171D, 0x3824342C,\n-            0x362D3927, 0x24362E3A, 0x2A3F2331, 0x70486858, 0x7E416553,\n-            0x6C5A724E, 0x62537F45, 0x486C5C74, 0x4665517F, 0x547E4662,\n-            0x5A774B69, 0xE090D0B0, 0xEE99DDBB, 0xFC82CAA6, 0xF28BC7AD,\n-            0xD8B4E49C, 0xD6BDE997, 0xC4A6FE8A, 0xCAAFF381, 0x90D8B8E8,\n-            0x9ED1B5E3, 0x8CCAA2FE, 0x82C3AFF5, 0xA8FC8CC4, 0xA6F581CF,\n-            0xB4EE96D2, 0xBAE79BD9, 0xDB3BBB7B, 0xD532B670, 0xC729A16D,\n-            0xC920AC66, 0xE31F8F57, 0xED16825C, 0xFF0D9541, 0xF104984A,\n-            0xAB73D323, 0xA57ADE28, 0xB761C935, 0xB968C43E, 0x9357E70F,\n-            0x9D5EEA04, 0x8F45FD19, 0x814CF012, 0x3BAB6BCB, 0x35A266C0,\n-            0x27B971DD, 0x29B07CD6, 0x038F5FE7, 0x0D8652EC, 0x1F9D45F1,\n-            0x119448FA, 0x4BE30393, 0x45EA0E98, 0x57F11985, 0x59F8148E,\n-            0x73C737BF, 0x7DCE3AB4, 0x6FD52DA9, 0x61DC20A2, 0xAD766DF6,\n-            0xA37F60FD, 0xB16477E0, 0xBF6D7AEB, 0x955259DA, 0x9B5B54D1,\n-            0x894043CC, 0x87494EC7, 0xDD3E05AE, 0xD33708A5, 0xC12C1FB8,\n-            0xCF2512B3, 0xE51A3182, 0xEB133C89, 0xF9082B94, 0xF701269F,\n-            0x4DE6BD46, 0x43EFB04D, 0x51F4A750, 0x5FFDAA5B, 0x75C2896A,\n-            0x7BCB8461, 0x69D0937C, 0x67D99E77, 0x3DAED51E, 0x33A7D815,\n-            0x21BCCF08, 0x2FB5C203, 0x058AE132, 0x0B83EC39, 0x1998FB24,\n-            0x1791F62F, 0x764DD68D, 0x7844DB86, 0x6A5FCC9B, 0x6456C190,\n-            0x4E69E2A1, 0x4060EFAA, 0x527BF8B7, 0x5C72F5BC, 0x0605BED5,\n-            0x080CB3DE, 0x1A17A4C3, 0x141EA9C8, 0x3E218AF9, 0x302887F2,\n-            0x223390EF, 0x2C3A9DE4, 0x96DD063D, 0x98D40B36, 0x8ACF1C2B,\n-            0x84C61120, 0xAEF93211, 0xA0F03F1A, 0xB2EB2807, 0xBCE2250C,\n-            0xE6956E65, 0xE89C636E, 0xFA877473, 0xF48E7978, 0xDEB15A49,\n-            0xD0B85742, 0xC2A3405F, 0xCCAA4D54, 0x41ECDAF7, 0x4FE5D7FC,\n-            0x5DFEC0E1, 0x53F7CDEA, 0x79C8EEDB, 0x77C1E3D0, 0x65DAF4CD,\n-            0x6BD3F9C6, 0x31A4B2AF, 0x3FADBFA4, 0x2DB6A8B9, 0x23BFA5B2,\n-            0x09808683, 0x07898B88, 0x15929C95, 0x1B9B919E, 0xA17C0A47,\n-            0xAF75074C, 0xBD6E1051, 0xB3671D5A, 0x99583E6B, 0x97513360,\n-            0x854A247D, 0x8B432976, 0xD134621F, 0xDF3D6F14, 0xCD267809,\n-            0xC32F7502, 0xE9105633, 0xE7195B38, 0xF5024C25, 0xFB0B412E,\n-            0x9AD7618C, 0x94DE6C87, 0x86C57B9A, 0x88CC7691, 0xA2F355A0,\n-            0xACFA58AB, 0xBEE14FB6, 0xB0E842BD, 0xEA9F09D4, 0xE49604DF,\n-            0xF68D13C2, 0xF8841EC9, 0xD2BB3DF8, 0xDCB230F3, 0xCEA927EE,\n-            0xC0A02AE5, 0x7A47B13C, 0x744EBC37, 0x6655AB2A, 0x685CA621,\n-            0x42638510, 0x4C6A881B, 0x5E719F06, 0x5078920D, 0x0A0FD964,\n-            0x0406D46F, 0x161DC372, 0x1814CE79, 0x322BED48, 0x3C22E043,\n-            0x2E39F75E, 0x2030FA55, 0xEC9AB701, 0xE293BA0A, 0xF088AD17,\n-            0xFE81A01C, 0xD4BE832D, 0xDAB78E26, 0xC8AC993B, 0xC6A59430,\n-            0x9CD2DF59, 0x92DBD252, 0x80C0C54F, 0x8EC9C844, 0xA4F6EB75,\n-            0xAAFFE67E, 0xB8E4F163, 0xB6EDFC68, 0x0C0A67B1, 0x02036ABA,\n-            0x10187DA7, 0x1E1170AC, 0x342E539D, 0x3A275E96, 0x283C498B,\n-            0x26354480, 0x7C420FE9, 0x724B02E2, 0x605015FF, 0x6E5918F4,\n-            0x44663BC5, 0x4A6F36CE, 0x587421D3, 0x567D2CD8, 0x37A10C7A,\n-            0x39A80171, 0x2BB3166C, 0x25BA1B67, 0x0F853856, 0x018C355D,\n-            0x13972240, 0x1D9E2F4B, 0x47E96422, 0x49E06929, 0x5BFB7E34,\n-            0x55F2733F, 0x7FCD500E, 0x71C45D05, 0x63DF4A18, 0x6DD64713,\n-            0xD731DCCA, 0xD938D1C1, 0xCB23C6DC, 0xC52ACBD7, 0xEF15E8E6,\n-            0xE11CE5ED, 0xF307F2F0, 0xFD0EFFFB, 0xA779B492, 0xA970B999,\n-            0xBB6BAE84, 0xB562A38F, 0x9F5D80BE, 0x91548DB5, 0x834F9AA8,\n-            0x8D4697A3,\n-    };\n-\n-    \/\/ Lookup table for row 1 of the inverse mix column transform.\n-    private static final int[] TMI1 = {\n-            0x00000000, 0x0B0E090D, 0x161C121A, 0x1D121B17, 0x2C382434,\n-            0x27362D39, 0x3A24362E, 0x312A3F23, 0x58704868, 0x537E4165,\n-            0x4E6C5A72, 0x4562537F, 0x74486C5C, 0x7F466551, 0x62547E46,\n-            0x695A774B, 0xB0E090D0, 0xBBEE99DD, 0xA6FC82CA, 0xADF28BC7,\n-            0x9CD8B4E4, 0x97D6BDE9, 0x8AC4A6FE, 0x81CAAFF3, 0xE890D8B8,\n-            0xE39ED1B5, 0xFE8CCAA2, 0xF582C3AF, 0xC4A8FC8C, 0xCFA6F581,\n-            0xD2B4EE96, 0xD9BAE79B, 0x7BDB3BBB, 0x70D532B6, 0x6DC729A1,\n-            0x66C920AC, 0x57E31F8F, 0x5CED1682, 0x41FF0D95, 0x4AF10498,\n-            0x23AB73D3, 0x28A57ADE, 0x35B761C9, 0x3EB968C4, 0x0F9357E7,\n-            0x049D5EEA, 0x198F45FD, 0x12814CF0, 0xCB3BAB6B, 0xC035A266,\n-            0xDD27B971, 0xD629B07C, 0xE7038F5F, 0xEC0D8652, 0xF11F9D45,\n-            0xFA119448, 0x934BE303, 0x9845EA0E, 0x8557F119, 0x8E59F814,\n-            0xBF73C737, 0xB47DCE3A, 0xA96FD52D, 0xA261DC20, 0xF6AD766D,\n-            0xFDA37F60, 0xE0B16477, 0xEBBF6D7A, 0xDA955259, 0xD19B5B54,\n-            0xCC894043, 0xC787494E, 0xAEDD3E05, 0xA5D33708, 0xB8C12C1F,\n-            0xB3CF2512, 0x82E51A31, 0x89EB133C, 0x94F9082B, 0x9FF70126,\n-            0x464DE6BD, 0x4D43EFB0, 0x5051F4A7, 0x5B5FFDAA, 0x6A75C289,\n-            0x617BCB84, 0x7C69D093, 0x7767D99E, 0x1E3DAED5, 0x1533A7D8,\n-            0x0821BCCF, 0x032FB5C2, 0x32058AE1, 0x390B83EC, 0x241998FB,\n-            0x2F1791F6, 0x8D764DD6, 0x867844DB, 0x9B6A5FCC, 0x906456C1,\n-            0xA14E69E2, 0xAA4060EF, 0xB7527BF8, 0xBC5C72F5, 0xD50605BE,\n-            0xDE080CB3, 0xC31A17A4, 0xC8141EA9, 0xF93E218A, 0xF2302887,\n-            0xEF223390, 0xE42C3A9D, 0x3D96DD06, 0x3698D40B, 0x2B8ACF1C,\n-            0x2084C611, 0x11AEF932, 0x1AA0F03F, 0x07B2EB28, 0x0CBCE225,\n-            0x65E6956E, 0x6EE89C63, 0x73FA8774, 0x78F48E79, 0x49DEB15A,\n-            0x42D0B857, 0x5FC2A340, 0x54CCAA4D, 0xF741ECDA, 0xFC4FE5D7,\n-            0xE15DFEC0, 0xEA53F7CD, 0xDB79C8EE, 0xD077C1E3, 0xCD65DAF4,\n-            0xC66BD3F9, 0xAF31A4B2, 0xA43FADBF, 0xB92DB6A8, 0xB223BFA5,\n-            0x83098086, 0x8807898B, 0x9515929C, 0x9E1B9B91, 0x47A17C0A,\n-            0x4CAF7507, 0x51BD6E10, 0x5AB3671D, 0x6B99583E, 0x60975133,\n-            0x7D854A24, 0x768B4329, 0x1FD13462, 0x14DF3D6F, 0x09CD2678,\n-            0x02C32F75, 0x33E91056, 0x38E7195B, 0x25F5024C, 0x2EFB0B41,\n-            0x8C9AD761, 0x8794DE6C, 0x9A86C57B, 0x9188CC76, 0xA0A2F355,\n-            0xABACFA58, 0xB6BEE14F, 0xBDB0E842, 0xD4EA9F09, 0xDFE49604,\n-            0xC2F68D13, 0xC9F8841E, 0xF8D2BB3D, 0xF3DCB230, 0xEECEA927,\n-            0xE5C0A02A, 0x3C7A47B1, 0x37744EBC, 0x2A6655AB, 0x21685CA6,\n-            0x10426385, 0x1B4C6A88, 0x065E719F, 0x0D507892, 0x640A0FD9,\n-            0x6F0406D4, 0x72161DC3, 0x791814CE, 0x48322BED, 0x433C22E0,\n-            0x5E2E39F7, 0x552030FA, 0x01EC9AB7, 0x0AE293BA, 0x17F088AD,\n-            0x1CFE81A0, 0x2DD4BE83, 0x26DAB78E, 0x3BC8AC99, 0x30C6A594,\n-            0x599CD2DF, 0x5292DBD2, 0x4F80C0C5, 0x448EC9C8, 0x75A4F6EB,\n-            0x7EAAFFE6, 0x63B8E4F1, 0x68B6EDFC, 0xB10C0A67, 0xBA02036A,\n-            0xA710187D, 0xAC1E1170, 0x9D342E53, 0x963A275E, 0x8B283C49,\n-            0x80263544, 0xE97C420F, 0xE2724B02, 0xFF605015, 0xF46E5918,\n-            0xC544663B, 0xCE4A6F36, 0xD3587421, 0xD8567D2C, 0x7A37A10C,\n-            0x7139A801, 0x6C2BB316, 0x6725BA1B, 0x560F8538, 0x5D018C35,\n-            0x40139722, 0x4B1D9E2F, 0x2247E964, 0x2949E069, 0x345BFB7E,\n-            0x3F55F273, 0x0E7FCD50, 0x0571C45D, 0x1863DF4A, 0x136DD647,\n-            0xCAD731DC, 0xC1D938D1, 0xDCCB23C6, 0xD7C52ACB, 0xE6EF15E8,\n-            0xEDE11CE5, 0xF0F307F2, 0xFBFD0EFF, 0x92A779B4, 0x99A970B9,\n-            0x84BB6BAE, 0x8FB562A3, 0xBE9F5D80, 0xB591548D, 0xA8834F9A,\n-            0xA38D4697,\n-    };\n-\n-    \/\/ Lookup table for row 2 of the inverse mix column transform.\n-    private static final int[] TMI2 = {\n-            0x00000000, 0x0D0B0E09, 0x1A161C12, 0x171D121B, 0x342C3824,\n-            0x3927362D, 0x2E3A2436, 0x23312A3F, 0x68587048, 0x65537E41,\n-            0x724E6C5A, 0x7F456253, 0x5C74486C, 0x517F4665, 0x4662547E,\n-            0x4B695A77, 0xD0B0E090, 0xDDBBEE99, 0xCAA6FC82, 0xC7ADF28B,\n-            0xE49CD8B4, 0xE997D6BD, 0xFE8AC4A6, 0xF381CAAF, 0xB8E890D8,\n-            0xB5E39ED1, 0xA2FE8CCA, 0xAFF582C3, 0x8CC4A8FC, 0x81CFA6F5,\n-            0x96D2B4EE, 0x9BD9BAE7, 0xBB7BDB3B, 0xB670D532, 0xA16DC729,\n-            0xAC66C920, 0x8F57E31F, 0x825CED16, 0x9541FF0D, 0x984AF104,\n-            0xD323AB73, 0xDE28A57A, 0xC935B761, 0xC43EB968, 0xE70F9357,\n-            0xEA049D5E, 0xFD198F45, 0xF012814C, 0x6BCB3BAB, 0x66C035A2,\n-            0x71DD27B9, 0x7CD629B0, 0x5FE7038F, 0x52EC0D86, 0x45F11F9D,\n-            0x48FA1194, 0x03934BE3, 0x0E9845EA, 0x198557F1, 0x148E59F8,\n-            0x37BF73C7, 0x3AB47DCE, 0x2DA96FD5, 0x20A261DC, 0x6DF6AD76,\n-            0x60FDA37F, 0x77E0B164, 0x7AEBBF6D, 0x59DA9552, 0x54D19B5B,\n-            0x43CC8940, 0x4EC78749, 0x05AEDD3E, 0x08A5D337, 0x1FB8C12C,\n-            0x12B3CF25, 0x3182E51A, 0x3C89EB13, 0x2B94F908, 0x269FF701,\n-            0xBD464DE6, 0xB04D43EF, 0xA75051F4, 0xAA5B5FFD, 0x896A75C2,\n-            0x84617BCB, 0x937C69D0, 0x9E7767D9, 0xD51E3DAE, 0xD81533A7,\n-            0xCF0821BC, 0xC2032FB5, 0xE132058A, 0xEC390B83, 0xFB241998,\n-            0xF62F1791, 0xD68D764D, 0xDB867844, 0xCC9B6A5F, 0xC1906456,\n-            0xE2A14E69, 0xEFAA4060, 0xF8B7527B, 0xF5BC5C72, 0xBED50605,\n-            0xB3DE080C, 0xA4C31A17, 0xA9C8141E, 0x8AF93E21, 0x87F23028,\n-            0x90EF2233, 0x9DE42C3A, 0x063D96DD, 0x0B3698D4, 0x1C2B8ACF,\n-            0x112084C6, 0x3211AEF9, 0x3F1AA0F0, 0x2807B2EB, 0x250CBCE2,\n-            0x6E65E695, 0x636EE89C, 0x7473FA87, 0x7978F48E, 0x5A49DEB1,\n-            0x5742D0B8, 0x405FC2A3, 0x4D54CCAA, 0xDAF741EC, 0xD7FC4FE5,\n-            0xC0E15DFE, 0xCDEA53F7, 0xEEDB79C8, 0xE3D077C1, 0xF4CD65DA,\n-            0xF9C66BD3, 0xB2AF31A4, 0xBFA43FAD, 0xA8B92DB6, 0xA5B223BF,\n-            0x86830980, 0x8B880789, 0x9C951592, 0x919E1B9B, 0x0A47A17C,\n-            0x074CAF75, 0x1051BD6E, 0x1D5AB367, 0x3E6B9958, 0x33609751,\n-            0x247D854A, 0x29768B43, 0x621FD134, 0x6F14DF3D, 0x7809CD26,\n-            0x7502C32F, 0x5633E910, 0x5B38E719, 0x4C25F502, 0x412EFB0B,\n-            0x618C9AD7, 0x6C8794DE, 0x7B9A86C5, 0x769188CC, 0x55A0A2F3,\n-            0x58ABACFA, 0x4FB6BEE1, 0x42BDB0E8, 0x09D4EA9F, 0x04DFE496,\n-            0x13C2F68D, 0x1EC9F884, 0x3DF8D2BB, 0x30F3DCB2, 0x27EECEA9,\n-            0x2AE5C0A0, 0xB13C7A47, 0xBC37744E, 0xAB2A6655, 0xA621685C,\n-            0x85104263, 0x881B4C6A, 0x9F065E71, 0x920D5078, 0xD9640A0F,\n-            0xD46F0406, 0xC372161D, 0xCE791814, 0xED48322B, 0xE0433C22,\n-            0xF75E2E39, 0xFA552030, 0xB701EC9A, 0xBA0AE293, 0xAD17F088,\n-            0xA01CFE81, 0x832DD4BE, 0x8E26DAB7, 0x993BC8AC, 0x9430C6A5,\n-            0xDF599CD2, 0xD25292DB, 0xC54F80C0, 0xC8448EC9, 0xEB75A4F6,\n-            0xE67EAAFF, 0xF163B8E4, 0xFC68B6ED, 0x67B10C0A, 0x6ABA0203,\n-            0x7DA71018, 0x70AC1E11, 0x539D342E, 0x5E963A27, 0x498B283C,\n-            0x44802635, 0x0FE97C42, 0x02E2724B, 0x15FF6050, 0x18F46E59,\n-            0x3BC54466, 0x36CE4A6F, 0x21D35874, 0x2CD8567D, 0x0C7A37A1,\n-            0x017139A8, 0x166C2BB3, 0x1B6725BA, 0x38560F85, 0x355D018C,\n-            0x22401397, 0x2F4B1D9E, 0x642247E9, 0x692949E0, 0x7E345BFB,\n-            0x733F55F2, 0x500E7FCD, 0x5D0571C4, 0x4A1863DF, 0x47136DD6,\n-            0xDCCAD731, 0xD1C1D938, 0xC6DCCB23, 0xCBD7C52A, 0xE8E6EF15,\n-            0xE5EDE11C, 0xF2F0F307, 0xFFFBFD0E, 0xB492A779, 0xB999A970,\n-            0xAE84BB6B, 0xA38FB562, 0x80BE9F5D, 0x8DB59154, 0x9AA8834F,\n-            0x97A38D46,\n-    };\n-\n-    \/\/ Lookup table for row 3 of the inverse mix column transform.\n-    private static final int[] TMI3 = {\n-            0x00000000, 0x090D0B0E, 0x121A161C, 0x1B171D12, 0x24342C38,\n-            0x2D392736, 0x362E3A24, 0x3F23312A, 0x48685870, 0x4165537E,\n-            0x5A724E6C, 0x537F4562, 0x6C5C7448, 0x65517F46, 0x7E466254,\n-            0x774B695A, 0x90D0B0E0, 0x99DDBBEE, 0x82CAA6FC, 0x8BC7ADF2,\n-            0xB4E49CD8, 0xBDE997D6, 0xA6FE8AC4, 0xAFF381CA, 0xD8B8E890,\n-            0xD1B5E39E, 0xCAA2FE8C, 0xC3AFF582, 0xFC8CC4A8, 0xF581CFA6,\n-            0xEE96D2B4, 0xE79BD9BA, 0x3BBB7BDB, 0x32B670D5, 0x29A16DC7,\n-            0x20AC66C9, 0x1F8F57E3, 0x16825CED, 0x0D9541FF, 0x04984AF1,\n-            0x73D323AB, 0x7ADE28A5, 0x61C935B7, 0x68C43EB9, 0x57E70F93,\n-            0x5EEA049D, 0x45FD198F, 0x4CF01281, 0xAB6BCB3B, 0xA266C035,\n-            0xB971DD27, 0xB07CD629, 0x8F5FE703, 0x8652EC0D, 0x9D45F11F,\n-            0x9448FA11, 0xE303934B, 0xEA0E9845, 0xF1198557, 0xF8148E59,\n-            0xC737BF73, 0xCE3AB47D, 0xD52DA96F, 0xDC20A261, 0x766DF6AD,\n-            0x7F60FDA3, 0x6477E0B1, 0x6D7AEBBF, 0x5259DA95, 0x5B54D19B,\n-            0x4043CC89, 0x494EC787, 0x3E05AEDD, 0x3708A5D3, 0x2C1FB8C1,\n-            0x2512B3CF, 0x1A3182E5, 0x133C89EB, 0x082B94F9, 0x01269FF7,\n-            0xE6BD464D, 0xEFB04D43, 0xF4A75051, 0xFDAA5B5F, 0xC2896A75,\n-            0xCB84617B, 0xD0937C69, 0xD99E7767, 0xAED51E3D, 0xA7D81533,\n-            0xBCCF0821, 0xB5C2032F, 0x8AE13205, 0x83EC390B, 0x98FB2419,\n-            0x91F62F17, 0x4DD68D76, 0x44DB8678, 0x5FCC9B6A, 0x56C19064,\n-            0x69E2A14E, 0x60EFAA40, 0x7BF8B752, 0x72F5BC5C, 0x05BED506,\n-            0x0CB3DE08, 0x17A4C31A, 0x1EA9C814, 0x218AF93E, 0x2887F230,\n-            0x3390EF22, 0x3A9DE42C, 0xDD063D96, 0xD40B3698, 0xCF1C2B8A,\n-            0xC6112084, 0xF93211AE, 0xF03F1AA0, 0xEB2807B2, 0xE2250CBC,\n-            0x956E65E6, 0x9C636EE8, 0x877473FA, 0x8E7978F4, 0xB15A49DE,\n-            0xB85742D0, 0xA3405FC2, 0xAA4D54CC, 0xECDAF741, 0xE5D7FC4F,\n-            0xFEC0E15D, 0xF7CDEA53, 0xC8EEDB79, 0xC1E3D077, 0xDAF4CD65,\n-            0xD3F9C66B, 0xA4B2AF31, 0xADBFA43F, 0xB6A8B92D, 0xBFA5B223,\n-            0x80868309, 0x898B8807, 0x929C9515, 0x9B919E1B, 0x7C0A47A1,\n-            0x75074CAF, 0x6E1051BD, 0x671D5AB3, 0x583E6B99, 0x51336097,\n-            0x4A247D85, 0x4329768B, 0x34621FD1, 0x3D6F14DF, 0x267809CD,\n-            0x2F7502C3, 0x105633E9, 0x195B38E7, 0x024C25F5, 0x0B412EFB,\n-            0xD7618C9A, 0xDE6C8794, 0xC57B9A86, 0xCC769188, 0xF355A0A2,\n-            0xFA58ABAC, 0xE14FB6BE, 0xE842BDB0, 0x9F09D4EA, 0x9604DFE4,\n-            0x8D13C2F6, 0x841EC9F8, 0xBB3DF8D2, 0xB230F3DC, 0xA927EECE,\n-            0xA02AE5C0, 0x47B13C7A, 0x4EBC3774, 0x55AB2A66, 0x5CA62168,\n-            0x63851042, 0x6A881B4C, 0x719F065E, 0x78920D50, 0x0FD9640A,\n-            0x06D46F04, 0x1DC37216, 0x14CE7918, 0x2BED4832, 0x22E0433C,\n-            0x39F75E2E, 0x30FA5520, 0x9AB701EC, 0x93BA0AE2, 0x88AD17F0,\n-            0x81A01CFE, 0xBE832DD4, 0xB78E26DA, 0xAC993BC8, 0xA59430C6,\n-            0xD2DF599C, 0xDBD25292, 0xC0C54F80, 0xC9C8448E, 0xF6EB75A4,\n-            0xFFE67EAA, 0xE4F163B8, 0xEDFC68B6, 0x0A67B10C, 0x036ABA02,\n-            0x187DA710, 0x1170AC1E, 0x2E539D34, 0x275E963A, 0x3C498B28,\n-            0x35448026, 0x420FE97C, 0x4B02E272, 0x5015FF60, 0x5918F46E,\n-            0x663BC544, 0x6F36CE4A, 0x7421D358, 0x7D2CD856, 0xA10C7A37,\n-            0xA8017139, 0xB3166C2B, 0xBA1B6725, 0x8538560F, 0x8C355D01,\n-            0x97224013, 0x9E2F4B1D, 0xE9642247, 0xE0692949, 0xFB7E345B,\n-            0xF2733F55, 0xCD500E7F, 0xC45D0571, 0xDF4A1863, 0xD647136D,\n-            0x31DCCAD7, 0x38D1C1D9, 0x23C6DCCB, 0x2ACBD7C5, 0x15E8E6EF,\n-            0x1CE5EDE1, 0x07F2F0F3, 0x0EFFFBFD, 0x79B492A7, 0x70B999A9,\n-            0x6BAE84BB, 0x62A38FB5, 0x5D80BE9F, 0x548DB591, 0x4F9AA883,\n-            0x4697A38D,\n-    };\n-\n-    \/**\n-     * Return the block cipher size.\n-     *\n-     * @return the AES block cipher size (in bytes).\n-     *\/\n-    int getBlockSize() {\n-        return AESConstants.AES_BLOCK_SIZE;\n-    }\n-\n-    \/**\n-     * Verifies if the length argument is a valid key size or not.\n-     *\n-     * @param len the size of the key (in bytes) to be validated.\n-     *\n-     * @return {@code true} if the size of the key is valid else {@code false}.\n-     *\/\n-    static boolean isKeySizeValid(int len) {\n-        for (int kLength : AESConstants.AES_KEYSIZES) {\n-            if (len == kLength) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    \/**\n-     * Check algorithm and initalize round keys for decryption and encryption.\n-     *\n-     * @param decrypting [in] indicates if encrypting ({@code false}) or\n-     *      decrypting ({@code true}).\n-     * @param algorithm [in] the case insentive string name for the AES cipher.\n-     * @param key [in] the symmetric key byte array for encryption\/decryption.\n-     *\n-     * @throws InvalidKeyException if an incorrect algorithm is given or if\n-     * an invalid key size is provided.\n-     *\/\n-    void init(boolean decrypting, String algorithm, byte[] key)\n-            throws InvalidKeyException {\n-        int decrypt = decrypting ? 1 : 0;\n-\n-        if (!algorithm.equalsIgnoreCase(\"AES\")\n-                && !algorithm.equalsIgnoreCase(\"Rijndael\")) {\n-            throw new InvalidKeyException (\"Invalid algorithm name.\");\n-        }\n-        if (key.length == AESConstants.AES_KEYSIZES[0]) {\n-            rounds = AES_128_ROUNDS;\n-        } else if (key.length == AESConstants.AES_KEYSIZES[1]) {\n-            rounds = AES_192_ROUNDS;\n-        } else if (key.length == AESConstants.AES_KEYSIZES[2]) {\n-            rounds = AES_256_ROUNDS;\n-        } else {\n-            throw new InvalidKeyException(\"Invalid key length (\" + key.length\n-                    + \").\");\n-        }\n-        if (!MessageDigest.isEqual(prevKey, key)) {\n-            if (sessionK == null) {\n-                sessionK = new int[2][];\n-            } else {\n-                Arrays.fill(sessionK[0], 0);\n-                Arrays.fill(sessionK[1], 0);\n-            }\n-            sessionK[0] = genRoundKeys(key, rounds);\n-            sessionK[1] = genInvRoundKeys(sessionK[0], rounds);\n-            if (prevKey != null) {\n-                Arrays.fill(prevKey, (byte) 0);\n-            }\n-            prevKey = key.clone();\n-        }\n-        K = sessionK[decrypt];\n-    }\n-\n-    \/**\n-     * Generate the cipher's round keys as outlined in section 5.2 of the spec.\n-     *\n-     * @param key [in] the symmetric key byte array.\n-     *\n-     * @return w the cipher round keys.\n-     *\/\n-    private static int[] genRoundKeys(byte[] key, int rounds) {\n-        int wLen = WB * (rounds + 1);\n-        int[] w = new int[wLen];\n-        int nk = key.length \/ BW;\n-\n-        for (int i = 0, j = 0; i < nk; i++, j += BW) {\n-            w[i] = ((key[j] & 0xFF) << 24) | ((key[j + 1] & 0xFF) << 16)\n-                    | ((key[j + 2] & 0xFF) << 8) | (key[j + 3] & 0xFF);\n-        }\n-        for (int i = nk; i < wLen; i++) {\n-            int tmp = w[i - 1];\n-            if (i % nk == 0) {\n-                int rW = (tmp << 8) & 0xFFFFFF00 | (tmp >>> 24);\n-                tmp = subWord(rW) ^ RCON[(i \/ nk) - 1];\n-            } else if ((nk > 6) && ((i % nk) == WB)) {\n-                tmp = subWord(tmp);\n-            }\n-            w[i] = w[i - nk] ^ tmp;\n-        }\n-\n-        return w;\n-    }\n-\n-    \/**\n-     * Generate the inverse cipher round keys.\n-     *\n-     * @return w1 the inverse cipher round keys.\n-     *\/\n-    private static int[] genInvRoundKeys(int[] w, int rounds) {\n-        int kLen = w.length;;\n-        int[] temp = new int[WB];\n-        int[] dw = new int[kLen];\n-\n-        \/\/ Intrinsics requires the inverse key expansion to be reverse order\n-        \/\/ except for the first and last round key as the first two round keys\n-        \/\/ are without a mix column transform.\n-        for (int i = 1; i < rounds; i++) {\n-            System.arraycopy(w, i * WB, temp, 0, WB);\n-            temp[0] = TMI0[temp[0] >>> 24] ^ TMI1[(temp[0] >> 16) & 0xFF]\n-                    ^ TMI2[(temp[0] >> 8) & 0xFF] ^ TMI3[temp[0] & 0xFF];\n-            temp[1] = TMI0[temp[1] >>> 24] ^ TMI1[(temp[1] >> 16) & 0xFF]\n-                    ^ TMI2[(temp[1] >> 8) & 0xFF] ^ TMI3[temp[1] & 0xFF];\n-            temp[2] = TMI0[temp[2] >>> 24] ^ TMI1[(temp[2] >> 16) & 0xFF]\n-                    ^ TMI2[(temp[2] >> 8) & 0xFF] ^ TMI3[temp[2] & 0xFF];\n-            temp[3] = TMI0[temp[3] >>> 24] ^ TMI1[(temp[3] >> 16) & 0xFF]\n-                    ^ TMI2[(temp[3] >> 8) & 0xFF] ^ TMI3[temp[3] & 0xFF];\n-            System.arraycopy(temp, 0, dw, kLen - (i * WB), WB);\n-        }\n-        System.arraycopy(w, kLen - WB, dw, WB, WB);\n-        System.arraycopy(w, 0, dw, 0, WB);\n-        Arrays.fill(temp, 0);\n-\n-        return dw;\n-    }\n-\n-    \/**\n-     * Subtitute the word as a step of key expansion.\n-     *\n-     * @param state [in] the targeted word for substituion.\n-     * @param sub [in] the substitute table for cipher and inverse cipher.\n-     *\n-     * @return the substituted word.\n-     *\/\n-    private static int subWord(int word) {\n-        byte b0 = (byte) (word >>> 24);\n-        byte b1 = (byte) ((word >> 16) & 0xFF);\n-        byte b2 = (byte) ((word >> 8) & 0xFF);\n-        byte b3 = (byte) (word & 0xFF);\n-\n-        return ((SBOX[(b0 & 0xF0) >> 4][b0 & 0x0F] & 0xFF) << 24)\n-                | ((SBOX[(b1 & 0xF0) >> 4][b1 & 0x0F] & 0xFF) << 16)\n-                | ((SBOX[(b2 & 0xF0) >> 4][b2 & 0x0F] & 0xFF) << 8)\n-                | (SBOX[(b3 & 0xF0) >> 4][b3 & 0x0F] & 0xFF);\n-    }\n-\n-    \/**\n-     * Method for one block of encryption.\n-     *\n-     * @param p [in] the plaintext to be encrypted.\n-     * @param po [in] the plaintext offset in the array of bytes.\n-     * @param c [out] the ciphertext output.\n-     * @param co [in] the ciphertext offset in the array of bytes.\n-     *\/\n-    @IntrinsicCandidate\n-    private void implEncryptBlock(byte[] p, int po, byte[] c, int co) {\n-        int ti0, ti1, ti2, ti3;\n-        int a0, a1, a2, a3;\n-        int w = K.length - WB;\n-\n-        a0 = ((p[po] & 0xFF) << 24) ^ ((p[po + 1] & 0xFF) << 16)\n-                ^ ((p[po + 2] & 0xFF) << 8) ^ (p[po + 3] & 0xFF) ^ K[0];\n-        a1 = ((p[po + 4] & 0xFF) << 24) ^ ((p[po + 5] & 0xFF) << 16)\n-                ^ ((p[po + 6] & 0xFF) << 8) ^ (p[po + 7] & 0xFF) ^ K[1];\n-        a2 = ((p[po + 8] & 0xFF) << 24) ^ ((p[po + 9] & 0xFF) << 16)\n-                ^ ((p[po + 10] & 0xFF) << 8) ^ (p[po + 11] & 0xFF) ^ K[2];\n-        a3 = ((p[po + 12] & 0xFF) << 24) ^ ((p[po + 13] & 0xFF) << 16)\n-                ^ ((p[po + 14] & 0xFF) << 8) ^ (p[po + 15] & 0xFF) ^ K[3];\n-\n-        ti0 = T0[a0 >>> 24] ^ T1[(a1 >> 16) & 0xFF]\n-                ^ T2[(a2 >> 8) & 0xFF] ^ T3[a3 & 0xFF] ^ K[4];\n-        ti1 = T0[a1 >>> 24] ^ T1[(a2 >> 16) & 0xFF]\n-                ^ T2[(a3 >> 8) & 0xFF] ^ T3[a0 & 0xFF] ^ K[5];\n-        ti2 = T0[a2 >>> 24] ^ T1[(a3 >> 16) & 0xFF]\n-                ^ T2[(a0 >> 8) & 0xFF] ^ T3[a1 & 0xFF] ^ K[6];\n-        ti3 = T0[a3 >>> 24] ^ T1[(a0 >> 16) & 0xFF]\n-                ^ T2[(a1 >> 8) & 0xFF] ^ T3[a2 & 0xFF] ^ K[7];\n-\n-        a0 = T0[ti0 >>> 24] ^ T1[(ti1 >> 16) & 0xFF]\n-                ^ T2[(ti2 >> 8) & 0xFF] ^ T3[ti3 & 0xFF] ^ K[8];\n-        a1 = T0[ti1 >>> 24] ^ T1[(ti2 >> 16) & 0xFF]\n-                ^ T2[(ti3 >> 8) & 0xFF] ^ T3[ti0 & 0xFF] ^ K[9];\n-        a2 = T0[ti2 >>> 24] ^ T1[(ti3 >> 16) & 0xFF]\n-                ^ T2[(ti0 >> 8) & 0xFF] ^ T3[ti1 & 0xFF] ^ K[10];\n-        a3 = T0[ti3 >>> 24] ^ T1[(ti0 >> 16) & 0xFF]\n-                ^ T2[(ti1 >> 8) & 0xFF] ^ T3[ti2 & 0xFF] ^ K[11];\n-\n-        ti0 = T0[a0 >>> 24] ^ T1[(a1 >> 16) & 0xFF]\n-                ^ T2[(a2 >> 8) & 0xFF] ^ T3[a3 & 0xFF] ^ K[12];\n-        ti1 = T0[a1 >>> 24] ^ T1[(a2 >> 16) & 0xFF]\n-                ^ T2[(a3 >> 8) & 0xFF] ^ T3[a0 & 0xFF] ^ K[13];\n-        ti2 = T0[a2 >>> 24] ^ T1[(a3 >> 16) & 0xFF]\n-                ^ T2[(a0 >> 8) & 0xFF] ^ T3[a1 & 0xFF] ^ K[14];\n-        ti3 = T0[a3 >>> 24] ^ T1[(a0 >> 16) & 0xFF]\n-                ^ T2[(a1 >> 8) & 0xFF] ^ T3[a2 & 0xFF] ^ K[15];\n-\n-        a0 = T0[ti0 >>> 24] ^ T1[(ti1 >> 16) & 0xFF]\n-                ^ T2[(ti2 >> 8) & 0xFF] ^ T3[ti3 & 0xFF] ^ K[16];\n-        a1 = T0[ti1 >>> 24] ^ T1[(ti2 >> 16) & 0xFF]\n-                ^ T2[(ti3 >> 8) & 0xFF] ^ T3[ti0 & 0xFF] ^ K[17];\n-        a2 = T0[ti2 >>> 24] ^ T1[(ti3 >> 16) & 0xFF]\n-                ^ T2[(ti0 >> 8) & 0xFF] ^ T3[ti1 & 0xFF] ^ K[18];\n-        a3 = T0[ti3 >>> 24] ^ T1[(ti0 >> 16) & 0xFF]\n-                ^ T2[(ti1 >> 8) & 0xFF] ^ T3[ti2 & 0xFF] ^ K[19];\n-\n-        ti0 = T0[a0 >>> 24] ^ T1[(a1 >> 16) & 0xFF]\n-                ^ T2[(a2 >> 8) & 0xFF] ^ T3[a3 & 0xFF] ^ K[20];\n-        ti1 = T0[a1 >>> 24] ^ T1[(a2 >> 16) & 0xFF]\n-                ^ T2[(a3 >> 8) & 0xFF] ^ T3[a0 & 0xFF] ^ K[21];\n-        ti2 = T0[a2 >>> 24] ^ T1[(a3 >> 16) & 0xFF]\n-                ^ T2[(a0 >> 8) & 0xFF] ^ T3[a1 & 0xFF] ^ K[22];\n-        ti3 = T0[a3 >>> 24] ^ T1[(a0 >> 16) & 0xFF]\n-                ^ T2[(a1 >> 8) & 0xFF] ^ T3[a2 & 0xFF] ^ K[23];\n-\n-        a0 = T0[ti0 >>> 24] ^ T1[(ti1 >> 16) & 0xFF]\n-                ^ T2[(ti2 >> 8) & 0xFF] ^ T3[ti3 & 0xFF] ^ K[24];\n-        a1 = T0[ti1 >>> 24] ^ T1[(ti2 >> 16) & 0xFF]\n-                ^ T2[(ti3 >> 8) & 0xFF] ^ T3[ti0 & 0xFF] ^ K[25];\n-        a2 = T0[ti2 >>> 24] ^ T1[(ti3 >> 16) & 0xFF]\n-                ^ T2[(ti0 >> 8) & 0xFF] ^ T3[ti1 & 0xFF] ^ K[26];\n-        a3 = T0[ti3 >>> 24] ^ T1[(ti0 >> 16) & 0xFF]\n-                ^ T2[(ti1 >> 8) & 0xFF] ^ T3[ti2 & 0xFF] ^ K[27];\n-\n-        ti0 = T0[a0 >>> 24] ^ T1[(a1 >> 16) & 0xFF]\n-                ^ T2[(a2 >> 8) & 0xFF] ^ T3[a3 & 0xFF] ^ K[28];\n-        ti1 = T0[a1 >>> 24] ^ T1[(a2 >> 16) & 0xFF]\n-                ^ T2[(a3 >> 8) & 0xFF] ^ T3[a0 & 0xFF] ^ K[29];\n-        ti2 = T0[a2 >>> 24] ^ T1[(a3 >> 16) & 0xFF]\n-                ^ T2[(a0 >> 8) & 0xFF] ^ T3[a1 & 0xFF] ^ K[30];\n-        ti3 = T0[a3 >>> 24] ^ T1[(a0 >> 16) & 0xFF]\n-                ^ T2[(a1 >> 8) & 0xFF] ^ T3[a2 & 0xFF] ^ K[31];\n-\n-        a0 = T0[ti0 >>> 24] ^ T1[(ti1 >> 16) & 0xFF]\n-                ^ T2[(ti2 >> 8) & 0xFF] ^ T3[ti3 & 0xFF] ^ K[32];\n-        a1 = T0[ti1 >>> 24] ^ T1[(ti2 >> 16) & 0xFF]\n-                ^ T2[(ti3 >> 8) & 0xFF] ^ T3[ti0 & 0xFF] ^ K[33];\n-        a2 = T0[ti2 >>> 24] ^ T1[(ti3 >> 16) & 0xFF]\n-                ^ T2[(ti0 >> 8) & 0xFF] ^ T3[ti1 & 0xFF] ^ K[34];\n-        a3 = T0[ti3 >>> 24] ^ T1[(ti0 >> 16) & 0xFF]\n-                ^ T2[(ti1 >> 8) & 0xFF] ^ T3[ti2 & 0xFF] ^ K[35];\n-\n-        ti0 = T0[a0 >>> 24] ^ T1[(a1 >> 16) & 0xFF]\n-                ^ T2[(a2 >> 8) & 0xFF] ^ T3[a3 & 0xFF] ^ K[36];\n-        ti1 = T0[a1 >>> 24] ^ T1[(a2 >> 16) & 0xFF]\n-                ^ T2[(a3 >> 8) & 0xFF] ^ T3[a0 & 0xFF] ^ K[37];\n-        ti2 = T0[a2 >>> 24] ^ T1[(a3 >> 16) & 0xFF]\n-                ^ T2[(a0 >> 8) & 0xFF] ^ T3[a1 & 0xFF] ^ K[38];\n-        ti3 = T0[a3 >>> 24] ^ T1[(a0 >> 16) & 0xFF]\n-                ^ T2[(a1 >> 8) & 0xFF] ^ T3[a2 & 0xFF] ^ K[39];\n-\n-        if (rounds > AES_128_ROUNDS) {\n-            a0 = T0[ti0 >>> 24] ^ T1[(ti1 >> 16) & 0xFF]\n-                    ^ T2[(ti2 >> 8) & 0xFF] ^ T3[ti3 & 0xFF] ^ K[40];\n-            a1 = T0[ti1 >>> 24] ^ T1[(ti2 >> 16) & 0xFF]\n-                    ^ T2[(ti3 >> 8) & 0xFF] ^ T3[ti0 & 0xFF] ^ K[41];\n-            a2 = T0[ti2 >>> 24] ^ T1[(ti3 >> 16) & 0xFF]\n-                    ^ T2[(ti0 >> 8) & 0xFF] ^ T3[ti1 & 0xFF] ^ K[42];\n-            a3 = T0[ti3 >>> 24] ^ T1[(ti0 >> 16) & 0xFF]\n-                    ^ T2[(ti1 >> 8) & 0xFF] ^ T3[ti2 & 0xFF] ^ K[43];\n-\n-            ti0 = T0[a0 >>> 24] ^ T1[(a1 >> 16) & 0xFF]\n-                    ^ T2[(a2 >> 8) & 0xFF] ^ T3[a3 & 0xFF] ^ K[44];\n-            ti1 = T0[a1 >>> 24] ^ T1[(a2 >> 16) & 0xFF]\n-                    ^ T2[(a3 >> 8) & 0xFF] ^ T3[a0 & 0xFF] ^ K[45];\n-            ti2 = T0[a2 >>> 24] ^ T1[(a3 >> 16) & 0xFF]\n-                    ^ T2[(a0 >> 8) & 0xFF] ^ T3[a1 & 0xFF] ^ K[46];\n-            ti3 = T0[a3 >>> 24] ^ T1[(a0 >> 16) & 0xFF]\n-                    ^ T2[(a1 >> 8) & 0xFF] ^ T3[a2 & 0xFF] ^ K[47];\n-        }\n-        if (rounds > AES_192_ROUNDS) {\n-            a0 = T0[ti0 >>> 24] ^ T1[(ti1 >> 16) & 0xFF]\n-                    ^ T2[(ti2 >> 8) & 0xFF] ^ T3[ti3 & 0xFF] ^ K[48];\n-            a1 = T0[ti1 >>> 24] ^ T1[(ti2 >> 16) & 0xFF]\n-                    ^ T2[(ti3 >> 8) & 0xFF] ^ T3[ti0 & 0xFF] ^ K[49];\n-            a2 = T0[ti2 >>> 24] ^ T1[(ti3 >> 16) & 0xFF]\n-                    ^ T2[(ti0 >> 8) & 0xFF] ^ T3[ti1 & 0xFF] ^ K[50];\n-            a3 = T0[ti3 >>> 24] ^ T1[(ti0 >> 16) & 0xFF]\n-                    ^ T2[(ti1 >> 8) & 0xFF] ^ T3[ti2 & 0xFF] ^ K[51];\n-\n-            ti0 = T0[a0 >>> 24] ^ T1[(a1 >> 16) & 0xFF]\n-                    ^ T2[(a2 >> 8) & 0xFF] ^ T3[a3 & 0xFF] ^ K[52];\n-            ti1 = T0[a1 >>> 24] ^ T1[(a2 >> 16) & 0xFF]\n-                    ^ T2[(a3 >> 8) & 0xFF] ^ T3[a0 & 0xFF] ^ K[53];\n-            ti2 = T0[a2 >>> 24] ^ T1[(a3 >> 16) & 0xFF]\n-                    ^ T2[(a0 >> 8) & 0xFF] ^ T3[a1 & 0xFF] ^ K[54];\n-            ti3 = T0[a3 >>> 24] ^ T1[(a0 >> 16) & 0xFF]\n-                    ^ T2[(a1 >> 8) & 0xFF] ^ T3[a2 & 0xFF] ^ K[55];\n-        }\n-\n-        a0 = T2[ti0 >>> 24] & 0xFF000000\n-                ^ T3[(ti1 >> 16) & 0xFF] & 0xFF0000\n-                ^ T0[(ti2 >> 8) & 0xFF] & 0xFF00\n-                ^ T1[ti3 & 0xFF] & 0xFF ^ K[w];\n-        a1 = T2[ti1 >>> 24] & 0xFF000000\n-                ^ T3[(ti2 >> 16) & 0xFF] & 0xFF0000\n-                ^ T0[(ti3 >> 8) & 0xFF] & 0xFF00\n-                ^ T1[ti0 & 0xFF] & 0xFF ^ K[w + 1];\n-        a2 = T2[ti2 >>> 24] & 0xFF000000\n-                ^ T3[(ti3 >> 16) & 0xFF] & 0xFF0000\n-                ^ T0[(ti0 >> 8) & 0xFF] & 0xFF00\n-                ^ T1[ti1 & 0xFF] & 0xFF ^ K[w + 2];\n-        a3 = T2[ti3 >>> 24] & 0xFF000000\n-                ^ T3[(ti0 >> 16) & 0xFF] & 0xFF0000\n-                ^ T0[(ti1 >> 8) & 0xFF] & 0xFF00\n-                ^ T1[ti2 & 0xFF] & 0xFF ^ K[w + 3];\n-\n-        c[co] = (byte) (a0 >>> 24);\n-        c[co + 1] = (byte) ((a0 >> 16) & 0xFF);\n-        c[co + 2] = (byte) ((a0 >> 8) & 0xFF);\n-        c[co + 3] = (byte) (a0 & 0xFF);\n-        c[co + 4] = (byte) (a1 >>> 24);\n-        c[co + 5] = (byte) ((a1 >> 16) & 0xFF);\n-        c[co + 6] = (byte) ((a1 >> 8) & 0xFF);\n-        c[co + 7] = (byte) (a1 & 0xFF);\n-        c[co + 8] = (byte) (a2 >>> 24);\n-        c[co + 9] = (byte) ((a2 >> 16) & 0xFF);\n-        c[co + 10] = (byte) ((a2 >> 8) & 0xFF);\n-        c[co + 11] = (byte) (a2 & 0xFF);\n-        c[co + 12] = (byte) (a3 >> 24);\n-        c[co + 13] = (byte) ((a3 >> 16) & 0xFF);\n-        c[co + 14] = (byte) ((a3 >> 8) & 0xFF);\n-        c[co + 15] = (byte) (a3 & 0xFF);\n-    }\n-\n-    \/**\n-     * Method for one block of decryption.\n-     *\n-     * @param c [in] the ciphertext to be decrypted.\n-     * @param co [in] the ciphertext offset in the array of bytes.\n-     * @param p [out] the plaintext output.\n-     * @param po [in] the plaintext offset in the array of bytes.\n-     *\/\n-    @IntrinsicCandidate\n-    private void implDecryptBlock(byte[] c, int co, byte[] p, int po) {\n-        int ti0, ti1, ti2, ti3;\n-        int a0, a1, a2, a3;\n-\n-        ti0 = ((c[co] & 0xFF) << 24) ^ ((c[co + 1] & 0xFF) << 16)\n-                ^ ((c[co + 2] & 0xFF) << 8) ^ (c[co + 3] & 0xFF) ^ K[4];\n-        ti1 = ((c[co + 4] & 0xFF) << 24) ^ ((c[co + 5] & 0xFF) << 16)\n-                ^ ((c[co + 6] & 0xFF) << 8) ^ (c[co + 7] & 0xFF) ^ K[5];\n-        ti2 = ((c[co + 8] & 0xFF) << 24) ^ ((c[co + 9] & 0xFF) << 16)\n-                ^ ((c[co + 10] & 0xFF) << 8) ^ (c[co + 11] & 0xFF) ^ K[6];\n-        ti3 = ((c[co + 12] & 0xFF) << 24) ^ ((c[co + 13] & 0xFF) << 16)\n-                ^ ((c[co + 14] & 0xFF) << 8) ^ (c[co + 15] & 0xFF) ^ K[7];\n-\n-        a0 = TI0[ti0 >>> 24] ^ TI1[(ti3 >> 16) & 0xFF]\n-                ^ TI2[(ti2 >> 8) & 0xFF] ^ TI3[ti1 & 0xFF] ^ K[8];\n-        a1 = TI0[ti1 >>> 24] ^ TI1[(ti0 >> 16) & 0xFF]\n-                ^ TI2[(ti3 >> 8) & 0xFF] ^ TI3[ti2 & 0xFF] ^ K[9];\n-        a2 = TI0[ti2 >>> 24] ^ TI1[(ti1 >> 16) & 0xFF]\n-                ^ TI2[(ti0 >> 8) & 0xFF] ^ TI3[ti3 & 0xFF] ^ K[10];\n-        a3 = TI0[ti3 >>> 24] ^ TI1[(ti2 >> 16) & 0xFF]\n-                ^ TI2[(ti1 >> 8) & 0xFF] ^ TI3[ti0 & 0xFF] ^ K[11];\n-\n-        ti0 = TI0[a0 >>> 24] ^ TI1[(a3 >> 16) & 0xFF]\n-                ^ TI2[(a2 >> 8) & 0xFF] ^ TI3[a1 & 0xFF] ^ K[12];\n-        ti1 = TI0[a1 >>> 24] ^ TI1[(a0 >> 16) & 0xFF]\n-                ^ TI2[(a3 >> 8) & 0xFF] ^ TI3[a2 & 0xFF] ^ K[13];\n-        ti2 = TI0[a2 >>> 24] ^ TI1[(a1 >> 16) & 0xFF]\n-                ^ TI2[(a0 >> 8) & 0xFF] ^ TI3[a3 & 0xFF] ^ K[14];\n-        ti3 = TI0[a3 >>> 24] ^ TI1[(a2 >> 16) & 0xFF]\n-                ^ TI2[(a1 >> 8) & 0xFF] ^ TI3[a0 & 0xFF] ^ K[15];\n-\n-        a0 = TI0[ti0 >>> 24] ^ TI1[(ti3 >> 16) & 0xFF]\n-                ^ TI2[(ti2 >> 8) & 0xFF] ^ TI3[ti1 & 0xFF] ^ K[16];\n-        a1 = TI0[ti1 >>> 24] ^ TI1[(ti0 >> 16) & 0xFF]\n-                ^ TI2[(ti3 >> 8) & 0xFF] ^ TI3[ti2 & 0xFF] ^ K[17];\n-        a2 = TI0[ti2 >>> 24] ^ TI1[(ti1 >> 16) & 0xFF]\n-                ^ TI2[(ti0 >> 8) & 0xFF] ^ TI3[ti3 & 0xFF] ^ K[18];\n-        a3 = TI0[ti3 >>> 24] ^ TI1[(ti2 >> 16) & 0xFF]\n-                ^ TI2[(ti1 >> 8) & 0xFF] ^ TI3[ti0 & 0xFF] ^ K[19];\n-\n-        ti0 = TI0[a0 >>> 24] ^ TI1[(a3 >> 16) & 0xFF]\n-                ^ TI2[(a2 >> 8) & 0xFF] ^ TI3[a1 & 0xFF] ^ K[20];\n-        ti1 = TI0[a1 >>> 24] ^ TI1[(a0 >> 16) & 0xFF]\n-                ^ TI2[(a3 >> 8) & 0xFF] ^ TI3[a2 & 0xFF] ^ K[21];\n-        ti2 = TI0[a2 >>> 24] ^ TI1[(a1 >> 16) & 0xFF]\n-                ^ TI2[(a0 >> 8) & 0xFF] ^ TI3[a3 & 0xFF] ^ K[22];\n-        ti3 = TI0[a3 >>> 24] ^ TI1[(a2 >> 16) & 0xFF]\n-                ^ TI2[(a1 >> 8) & 0xFF] ^ TI3[a0 & 0xFF] ^ K[23];\n-\n-        a0 = TI0[ti0 >>> 24] ^ TI1[(ti3 >> 16) & 0xFF]\n-                ^ TI2[(ti2 >> 8) & 0xFF] ^ TI3[ti1 & 0xFF] ^ K[24];\n-        a1 = TI0[ti1 >>> 24] ^ TI1[(ti0 >> 16) & 0xFF]\n-                ^ TI2[(ti3 >> 8) & 0xFF] ^ TI3[ti2 & 0xFF] ^ K[25];\n-        a2 = TI0[ti2 >>> 24] ^ TI1[(ti1 >> 16) & 0xFF]\n-                ^ TI2[(ti0 >> 8) & 0xFF] ^ TI3[ti3 & 0xFF] ^ K[26];\n-        a3 = TI0[ti3 >>> 24] ^ TI1[(ti2 >> 16) & 0xFF]\n-                ^ TI2[(ti1 >> 8) & 0xFF] ^ TI3[ti0 & 0xFF] ^ K[27];\n-\n-        ti0 = TI0[a0 >>> 24] ^ TI1[(a3 >> 16) & 0xFF]\n-                ^ TI2[(a2 >> 8) & 0xFF] ^ TI3[a1 & 0xFF] ^ K[28];\n-        ti1 = TI0[a1 >>> 24] ^ TI1[(a0 >> 16) & 0xFF]\n-                ^ TI2[(a3 >> 8) & 0xFF] ^ TI3[a2 & 0xFF] ^ K[29];\n-        ti2 = TI0[a2 >>> 24] ^ TI1[(a1 >> 16) & 0xFF]\n-                ^ TI2[(a0 >> 8) & 0xFF] ^ TI3[a3 & 0xFF] ^ K[30];\n-        ti3 = TI0[a3 >>> 24] ^ TI1[(a2 >> 16) & 0xFF]\n-                ^ TI2[(a1 >> 8) & 0xFF] ^ TI3[a0 & 0xFF] ^ K[31];\n-\n-        a0 = TI0[ti0 >>> 24] ^ TI1[(ti3 >> 16) & 0xFF]\n-                ^ TI2[(ti2 >> 8) & 0xFF] ^ TI3[ti1 & 0xFF] ^ K[32];\n-        a1 = TI0[ti1 >>> 24] ^ TI1[(ti0 >> 16) & 0xFF]\n-                ^ TI2[(ti3 >> 8) & 0xFF] ^ TI3[ti2 & 0xFF] ^ K[33];\n-        a2 = TI0[ti2 >>> 24] ^ TI1[(ti1 >> 16) & 0xFF]\n-                ^ TI2[(ti0 >> 8) & 0xFF] ^ TI3[ti3 & 0xFF] ^ K[34];\n-        a3 = TI0[ti3 >>> 24] ^ TI1[(ti2 >> 16) & 0xFF]\n-                ^ TI2[(ti1 >> 8) & 0xFF] ^ TI3[ti0 & 0xFF] ^ K[35];\n-\n-        ti0 = TI0[a0 >>> 24] ^ TI1[(a3 >> 16) & 0xFF]\n-                ^ TI2[(a2 >> 8) & 0xFF] ^ TI3[a1 & 0xFF] ^ K[36];\n-        ti1 = TI0[a1 >>> 24] ^ TI1[(a0 >> 16) & 0xFF]\n-                ^ TI2[(a3 >> 8) & 0xFF] ^ TI3[a2 & 0xFF] ^ K[37];\n-        ti2 = TI0[a2 >>> 24] ^ TI1[(a1 >> 16) & 0xFF]\n-                ^ TI2[(a0 >> 8) & 0xFF] ^ TI3[a3 & 0xFF] ^ K[38];\n-        ti3 = TI0[a3 >>> 24] ^ TI1[(a2 >> 16) & 0xFF]\n-                ^ TI2[(a1 >> 8) & 0xFF] ^ TI3[a0 & 0xFF] ^ K[39];\n-\n-        a0 = TI0[ti0 >>> 24] ^ TI1[(ti3 >> 16) & 0xFF]\n-                ^ TI2[(ti2 >> 8) & 0xFF] ^ TI3[ti1 & 0xFF] ^ K[40];\n-        a1 = TI0[ti1 >>> 24] ^ TI1[(ti0 >> 16) & 0xFF]\n-                ^ TI2[(ti3 >> 8) & 0xFF] ^ TI3[ti2 & 0xFF] ^ K[41];\n-        a2 = TI0[ti2 >>> 24] ^ TI1[(ti1 >> 16) & 0xFF]\n-                ^ TI2[(ti0 >> 8) & 0xFF] ^ TI3[ti3 & 0xFF] ^ K[42];\n-        a3 = TI0[ti3 >>> 24] ^ TI1[(ti2 >> 16) & 0xFF]\n-                ^ TI2[(ti1 >> 8) & 0xFF] ^ TI3[ti0 & 0xFF] ^ K[43];\n-\n-        if (rounds > AES_128_ROUNDS) {\n-            ti0 = TI0[a0 >>> 24] ^ TI1[(a3 >> 16) & 0xFF]\n-                    ^ TI2[(a2 >> 8) & 0xFF] ^ TI3[a1 & 0xFF] ^ K[44];\n-            ti1 = TI0[a1 >>> 24] ^ TI1[(a0 >> 16) & 0xFF]\n-                    ^ TI2[(a3 >> 8) & 0xFF] ^ TI3[a2 & 0xFF] ^ K[45];\n-            ti2 = TI0[a2 >>> 24] ^ TI1[(a1 >> 16) & 0xFF]\n-                    ^ TI2[(a0 >> 8) & 0xFF] ^ TI3[a3 & 0xFF] ^ K[46];\n-            ti3 = TI0[a3 >>> 24] ^ TI1[(a2 >> 16) & 0xFF]\n-                    ^ TI2[(a1 >> 8) & 0xFF] ^ TI3[a0 & 0xFF] ^ K[47];\n-\n-            a0 = TI0[ti0 >>> 24] ^ TI1[(ti3 >> 16) & 0xFF]\n-                    ^ TI2[(ti2 >> 8) & 0xFF] ^ TI3[ti1 & 0xFF] ^ K[48];\n-            a1 = TI0[ti1 >>> 24] ^ TI1[(ti0 >> 16) & 0xFF]\n-                    ^ TI2[(ti3 >> 8) & 0xFF] ^ TI3[ti2 & 0xFF] ^ K[49];\n-            a2 = TI0[ti2 >>> 24] ^ TI1[(ti1 >> 16) & 0xFF]\n-                    ^ TI2[(ti0 >> 8) & 0xFF] ^ TI3[ti3 & 0xFF] ^ K[50];\n-            a3 = TI0[ti3 >>> 24] ^ TI1[(ti2 >> 16) & 0xFF]\n-                    ^ TI2[(ti1 >> 8) & 0xFF] ^ TI3[ti0 & 0xFF] ^ K[51];\n-        }\n-        if (rounds > AES_192_ROUNDS) {\n-            ti0 = TI0[a0 >>> 24] ^ TI1[(a3 >> 16) & 0xFF]\n-                    ^ TI2[(a2 >> 8) & 0xFF] ^ TI3[a1 & 0xFF] ^ K[52];\n-            ti1 = TI0[a1 >>> 24] ^ TI1[(a0 >> 16) & 0xFF]\n-                    ^ TI2[(a3 >> 8) & 0xFF] ^ TI3[a2 & 0xFF] ^ K[53];\n-            ti2 = TI0[a2 >>> 24] ^ TI1[(a1 >> 16) & 0xFF]\n-                    ^ TI2[(a0 >> 8) & 0xFF] ^ TI3[a3 & 0xFF] ^ K[54];\n-            ti3 = TI0[a3 >>> 24] ^ TI1[(a2 >> 16) & 0xFF]\n-                    ^ TI2[(a1 >> 8) & 0xFF] ^ TI3[a0 & 0xFF] ^ K[55];\n-\n-            a0 = TI0[ti0 >>> 24] ^ TI1[(ti3 >> 16) & 0xFF]\n-                    ^ TI2[(ti2 >> 8) & 0xFF] ^ TI3[ti1 & 0xFF] ^ K[56];\n-            a1 = TI0[ti1 >>> 24] ^ TI1[(ti0 >> 16) & 0xFF]\n-                    ^ TI2[(ti3 >> 8) & 0xFF] ^ TI3[ti2 & 0xFF] ^ K[57];\n-            a2 = TI0[ti2 >>> 24] ^ TI1[(ti1 >> 16) & 0xFF]\n-                    ^ TI2[(ti0 >> 8) & 0xFF] ^ TI3[ti3 & 0xFF] ^ K[58];\n-            a3 = TI0[ti3 >>> 24] ^ TI1[(ti2 >> 16) & 0xFF]\n-                    ^ TI2[(ti1 >> 8) & 0xFF] ^ TI3[ti0 & 0xFF] ^ K[59];\n-        }\n-\n-        ti0 = TI4[a0 >>> 24] & 0xFF000000 ^ TI4[(a3 >> 16) & 0xFF] & 0xFF0000\n-                ^ TI4[(a2 >> 8) & 0xFF] & 0xFF00 ^ TI4[a1 & 0xFF] & 0xFF ^ K[0];\n-        ti1 = TI4[a1 >>> 24] & 0xFF000000 ^ TI4[(a0 >> 16) & 0xFF] & 0xFF0000\n-                ^ TI4[(a3 >> 8) & 0xFF] & 0xFF00 ^ TI4[a2 & 0xFF] & 0xFF ^ K[1];\n-        ti2 = TI4[a2 >>> 24] & 0xFF000000 ^ TI4[(a1 >> 16) & 0xFF] & 0xFF0000\n-                ^ TI4[(a0 >> 8) & 0xFF] & 0xFF00 ^ TI4[a3 & 0xFF] & 0xFF ^ K[2];\n-        ti3 = TI4[a3 >>> 24] & 0xFF000000 ^ TI4[(a2 >> 16) & 0xFF] & 0xFF0000\n-                ^ TI4[(a1 >> 8) & 0xFF] & 0xFF00 ^ TI4[a0 & 0xFF] & 0xFF ^ K[3];\n-\n-        p[po] = (byte) (ti0 >>> 24);\n-        p[po + 1] = (byte) ((ti0 >> 16) & 0xFF);\n-        p[po + 2] = (byte) ((ti0 >> 8) & 0xFF);\n-        p[po + 3] = (byte) (ti0 & 0xFF);\n-        p[po + 4] = (byte) (ti1 >>> 24);\n-        p[po + 5] = (byte) ((ti1 >> 16) & 0xFF);\n-        p[po + 6] = (byte) ((ti1 >> 8) & 0xFF);\n-        p[po + 7] = (byte) (ti1 & 0xFF);\n-        p[po + 8] = (byte) (ti2 >>> 24);\n-        p[po + 9] = (byte) ((ti2 >> 16) & 0xFF);\n-        p[po + 10] = (byte) ((ti2 >> 8) & 0xFF);\n-        p[po + 11] = (byte) (ti2 & 0xFF);\n-        p[po + 12] = (byte) (ti3 >>> 24);\n-        p[po + 13] = (byte) ((ti3 >> 16) & 0xFF);\n-        p[po + 14] = (byte) ((ti3 >> 8) & 0xFF);\n-        p[po + 15] = (byte) (ti3 & 0xFF);\n-    }\n-\n-    \/**\n-     * Method for one block of encryption.\n-     *\n-     * @param plain [in] the plaintext to be encrypted.\n-     * @param pOff [in] the plaintext offset in the array of bytes.\n-     * @param cipher [out] the encrypted ciphertext output.\n-     * @param cOff [in] the ciphertext offset in the array of bytes.\n-     *\/\n-    void encryptBlock(byte[] plain, int pOff, byte[] cipher, int cOff) {\n-        implEncryptBlock(plain, pOff, cipher, cOff);\n-    }\n-\n-    \/**\n-     * Method for one block of decryption.\n-     *\n-     * @param cipher [in] the ciphertext to be decrypted.\n-     * @param cOff [in] the ciphertext offset in the array of bytes.\n-     * @param plain [out] the decrypted plaintext output.\n-     * @param pOff [in] the plaintext offset in the array of bytes.\n-     *\/\n-    void decryptBlock(byte[] cipher, int cOff, byte[] plain, int pOff) {\n-        implDecryptBlock(cipher, cOff, plain, pOff);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AES_Crypt.java","additions":0,"deletions":1392,"binary":false,"changes":1392,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n- * AES_Crypt.encryptBlock method can be intrinsified on the HotSpot VM\n+ * AESCrypt.encryptBlock method can be intrinsified on the HotSpot VM\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GCTR.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-     * @param embeddedCipher Cipher object, such as AES_Crypt.\n+     * @param embeddedCipher Cipher object, such as AESCrypt.\n@@ -201,1 +201,1 @@\n-        if (!AES_Crypt.isKeySizeValid(encoded.length)) {\n+        if (!AESCrypt.isKeySizeValid(encoded.length)) {\n@@ -1696,1 +1696,1 @@\n-            super(-1, new AES_Crypt());\n+            super(-1, new AESCrypt());\n@@ -1702,1 +1702,1 @@\n-            super(16, new AES_Crypt());\n+            super(16, new AESCrypt());\n@@ -1708,1 +1708,1 @@\n-            super(24, new AES_Crypt());\n+            super(24, new AESCrypt());\n@@ -1714,1 +1714,1 @@\n-            super(32, new AES_Crypt());\n+            super(32, new AESCrypt());\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GaloisCounterMode.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -140,1 +140,1 @@\n-            !AES_Crypt.isKeySizeValid(keyLen) ||\n+            !AESCrypt.isKeySizeValid(keyLen) ||\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/KeyWrapCipher.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,1 +71,1 @@\n-            cipher = new CipherCore(new AES_Crypt(), blkSize);\n+            cipher = new CipherCore(new AESCrypt(), blkSize);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBES2Core.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n- * @see AES_Crypt\n+ * @see AESCrypt\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/SymmetricCipher.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1451,2 +1451,2 @@\n-        byte[] newValue = (s instanceof String str && str.length() == len)\n-            ? putStringAt(currValue, coder, count, dstOffset, str)\n+        byte[] newValue = (s instanceof String str)\n+            ? putStringAt(currValue, coder, count, dstOffset, str, start, end)\n@@ -1931,1 +1931,1 @@\n-     private static byte[] putStringAt(byte[] value, byte coder, int count, int index, String str) {\n+     private static byte[] putStringAt(byte[] value, byte coder, int count, int index, String str, int off, int end) {\n@@ -1934,1 +1934,1 @@\n-        str.getBytes(newValue, 0, index, coder, str.length());\n+        str.getBytes(newValue, off, index, coder, end - off);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/AbstractStringBuilder.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -58,0 +58,2 @@\n+ * @author  Nakul Saraiya\n+ * @author  Joseph D. Darcy\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Byte.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n- * Copyright (c) 2025, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -37,1 +36,0 @@\n-import jdk.internal.util.DecimalDigits;\n@@ -357,0 +355,3 @@\n+ * @author  Lee Boynton\n+ * @author  Arthur van Hoff\n+ * @author  Joseph D. Darcy\n@@ -697,0 +698,1 @@\n+     * @author Joseph D. Darcy\n@@ -704,1 +706,1 @@\n-        if (!isFinite(d)) {\n+        if (!isFinite(d) )\n@@ -707,11 +709,3 @@\n-        }\n-\n-        long doubleToLongBits = Double.doubleToLongBits(d);\n-        boolean negative = doubleToLongBits < 0;\n-\n-        if (d == 0.0) {\n-            return negative ? \"-0x0.0p0\" : \"0x0.0p0\";\n-        }\n-        d = Math.abs(d);\n-        \/\/ Check if the value is subnormal (less than the smallest normal value)\n-        boolean subnormal = d < Double.MIN_NORMAL;\n+        else {\n+            \/\/ Initialized to maximum size of output.\n+            StringBuilder answer = new StringBuilder(24);\n@@ -719,4 +713,2 @@\n-        \/\/ Isolate significand bits and OR in a high-order bit\n-        \/\/ so that the string representation has a known length.\n-        \/\/ This ensures we always have 13 hex digits to work with (52 bits \/ 4 bits per hex digit)\n-        long signifBits = doubleToLongBits & DoubleConsts.SIGNIF_BIT_MASK;\n+            if (Math.copySign(1.0, d) == -1.0)    \/\/ value is negative,\n+                answer.append(\"-\");                  \/\/ so append sign info\n@@ -724,5 +716,1 @@\n-        \/\/ Calculate the number of trailing zeros in the significand (in groups of 4 bits)\n-        \/\/ This is used to remove trailing zeros from the hex representation\n-        \/\/ We limit to 12 because we want to keep at least 1 hex digit (13 total - 12 = 1)\n-        \/\/ assert 0 <= trailingZeros && trailingZeros <= 12\n-        int trailingZeros = Long.numberOfTrailingZeros(signifBits | 1L << 4 * 12) >> 2;\n+            answer.append(\"0x\");\n@@ -730,3 +718,1 @@\n-        \/\/ Determine the exponent value based on whether the number is subnormal or normal\n-        \/\/ Subnormal numbers use the minimum exponent, normal numbers use the actual exponent\n-        int exp = subnormal ? Double.MIN_EXPONENT : Math.getExponent(d);\n+            d = Math.abs(d);\n@@ -734,8 +720,4 @@\n-        \/\/ Calculate the total length of the resulting string:\n-        \/\/ Sign (optional) + prefix \"0x\" + implicit bit + \".\" + hex digits + \"p\" + exponent\n-        int charlen = (negative ? 1 : 0) \/\/ sign character\n-                + 4 \/\/ \"0x1.\" or \"0x0.\"\n-                + 13 - trailingZeros \/\/ hex digits (13 max, minus trailing zeros)\n-                + 1 \/\/ \"p\"\n-                + DecimalDigits.stringSize(exp) \/\/ exponent\n-                ;\n+            if(d == 0.0) {\n+                answer.append(\"0.0p0\");\n+            } else {\n+                boolean subnormal = (d < Double.MIN_NORMAL);\n@@ -743,3 +725,6 @@\n-        \/\/ Create a byte array to hold the result characters\n-        byte[] chars = new byte[charlen];\n-        int index = 0;\n+                \/\/ Isolate significand bits and OR in a high-order bit\n+                \/\/ so that the string representation has a known\n+                \/\/ length.\n+                long signifBits = (Double.doubleToLongBits(d)\n+                                   & DoubleConsts.SIGNIF_BIT_MASK) |\n+                    0x1000000000000000L;\n@@ -747,4 +732,3 @@\n-        \/\/ Add the sign character if the number is negative\n-        if (negative) {  \/\/ value is negative\n-            chars[index++] = '-';\n-        }\n+                \/\/ Subnormal values have a 0 implicit bit; normal\n+                \/\/ values have a 1 implicit bit.\n+                answer.append(subnormal ? \"0.\" : \"1.\");\n@@ -752,7 +736,8 @@\n-        \/\/ Add the prefix and the implicit bit ('1' for normal, '0' for subnormal)\n-        \/\/ Subnormal values have a 0 implicit bit; normal values have a 1 implicit bit.\n-        chars[index    ] = '0';      \/\/ Hex prefix\n-        chars[index + 1] = 'x';  \/\/ Hex prefix\n-        chars[index + 2] = (byte) (subnormal ? '0' : '1');  \/\/ Implicit bit\n-        chars[index + 3] = '.';  \/\/ Decimal point\n-        index += 4;\n+                \/\/ Isolate the low-order 13 digits of the hex\n+                \/\/ representation.  If all the digits are zero,\n+                \/\/ replace with a single 0; otherwise, remove all\n+                \/\/ trailing zeros.\n+                String signif = Long.toHexString(signifBits).substring(3,16);\n+                answer.append(signif.equals(\"0000000000000\") ? \/\/ 13 zeros\n+                              \"0\":\n+                              signif.replaceFirst(\"0{1,12}$\", \"\"));\n@@ -760,8 +745,10 @@\n-        \/\/ Convert significand to hex digits manually to avoid creating temporary strings\n-        \/\/ Extract the 13 hex digits (52 bits) from signifBits\n-        \/\/ We need to extract bits 48-51, 44-47, ..., 0-3 (13 groups of 4 bits)\n-        for (int sh = 4 * 12, end = 4 * trailingZeros; sh >= end; sh -= 4) {\n-            \/\/ Extract 4 bits at a time from left to right\n-            \/\/ Shift right by sh positions and mask with 0xF\n-            \/\/ Integer.digits maps values 0-15 to '0'-'f' characters\n-            chars[index++] = Integer.digits[((int)(signifBits >> sh)) & 0xF];\n+                answer.append('p');\n+                \/\/ If the value is subnormal, use the E_min exponent\n+                \/\/ value for double; otherwise, extract and report d's\n+                \/\/ exponent (the representation of a subnormal uses\n+                \/\/ E_min -1).\n+                answer.append(subnormal ?\n+                              Double.MIN_EXPONENT:\n+                              Math.getExponent(d));\n+            }\n+            return answer.toString();\n@@ -769,9 +756,0 @@\n-\n-        \/\/ Add the exponent indicator\n-        chars[index] = 'p';\n-\n-        \/\/ Append the exponent value to the character array\n-        \/\/ This method writes the decimal representation of exp directly into the byte array\n-        DecimalDigits.uncheckedGetCharsLatin1(exp, charlen, chars);\n-\n-        return String.newStringWithLatin1Bytes(chars);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Double.java","additions":43,"deletions":65,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -73,0 +73,3 @@\n+ * @author  Lee Boynton\n+ * @author  Arthur van Hoff\n+ * @author  Joseph D. Darcy\n@@ -411,0 +414,1 @@\n+     * @author Joseph D. Darcy\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,0 +71,4 @@\n+ * @author  Lee Boynton\n+ * @author  Arthur van Hoff\n+ * @author  Josh Bloch\n+ * @author  Joseph D. Darcy\n@@ -366,3 +370,9 @@\n-        byte[] buf = new byte[chars];\n-        formatUnsignedInt(val, shift, buf, chars);\n-        return String.newStringWithLatin1Bytes(buf);\n+        if (COMPACT_STRINGS) {\n+            byte[] buf = new byte[chars];\n+            formatUnsignedInt(val, shift, buf, chars);\n+            return new String(buf, LATIN1);\n+        } else {\n+            byte[] buf = new byte[chars * 2];\n+            formatUnsignedIntUTF16(val, shift, buf, chars);\n+            return new String(buf, UTF16);\n+        }\n@@ -391,0 +401,20 @@\n+    \/**\n+     * Format an {@code int} (treated as unsigned) into a byte buffer (UTF16 version). If\n+     * {@code len} exceeds the formatted ASCII representation of {@code val},\n+     * {@code buf} will be padded with leading zeroes.\n+     *\n+     * @param val the unsigned int to format\n+     * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)\n+     * @param buf the byte buffer to write to\n+     * @param len the number of characters to write\n+     *\/\n+    private static void formatUnsignedIntUTF16(int val, int shift, byte[] buf, int len) {\n+        int charPos = len;\n+        int radix = 1 << shift;\n+        int mask = radix - 1;\n+        do {\n+            StringUTF16.putChar(buf, --charPos, Integer.digits[val & mask]);\n+            val >>>= shift;\n+        } while (charPos > 0);\n+    }\n+\n@@ -404,3 +434,9 @@\n-        byte[] buf = new byte[size];\n-        DecimalDigits.uncheckedGetCharsLatin1(i, size, buf);\n-        return String.newStringWithLatin1Bytes(buf);\n+        if (COMPACT_STRINGS) {\n+            byte[] buf = new byte[size];\n+            DecimalDigits.uncheckedGetCharsLatin1(i, size, buf);\n+            return new String(buf, LATIN1);\n+        } else {\n+            byte[] buf = new byte[size * 2];\n+            DecimalDigits.uncheckedGetCharsUTF16(i, size, buf);\n+            return new String(buf, UTF16);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":42,"deletions":6,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -71,0 +71,4 @@\n+ * @author  Lee Boynton\n+ * @author  Arthur van Hoff\n+ * @author  Josh Bloch\n+ * @author  Joseph D. Darcy\n@@ -394,3 +398,9 @@\n-        byte[] buf = new byte[chars];\n-        formatUnsignedLong0(val, shift, buf, 0, chars);\n-        return String.newStringWithLatin1Bytes(buf);\n+        if (COMPACT_STRINGS) {\n+            byte[] buf = new byte[chars];\n+            formatUnsignedLong0(val, shift, buf, 0, chars);\n+            return new String(buf, LATIN1);\n+        } else {\n+            byte[] buf = new byte[chars * 2];\n+            formatUnsignedLong0UTF16(val, shift, buf, 0, chars);\n+            return new String(buf, UTF16);\n+        }\n@@ -420,0 +430,21 @@\n+    \/**\n+     * Format a long (treated as unsigned) into a byte buffer (UTF16 version). If\n+     * {@code len} exceeds the formatted ASCII representation of {@code val},\n+     * {@code buf} will be padded with leading zeroes.\n+     *\n+     * @param val the unsigned long to format\n+     * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)\n+     * @param buf the byte buffer to write to\n+     * @param offset the offset in the destination buffer to start at\n+     * @param len the number of characters to write\n+     *\/\n+    private static void formatUnsignedLong0UTF16(long val, int shift, byte[] buf, int offset, int len) {\n+        int charPos = offset + len;\n+        int radix = 1 << shift;\n+        int mask = radix - 1;\n+        do {\n+            StringUTF16.putChar(buf, --charPos, Integer.digits[((int) val) & mask]);\n+            val >>>= shift;\n+        } while (charPos > offset);\n+    }\n+\n@@ -432,3 +463,9 @@\n-        byte[] buf = new byte[size];\n-        DecimalDigits.uncheckedGetCharsLatin1(i, size, buf);\n-        return String.newStringWithLatin1Bytes(buf);\n+        if (COMPACT_STRINGS) {\n+            byte[] buf = new byte[size];\n+            DecimalDigits.uncheckedGetCharsLatin1(i, size, buf);\n+            return new String(buf, LATIN1);\n+        } else {\n+            byte[] buf = new byte[size * 2];\n+            DecimalDigits.uncheckedGetCharsUTF16(i, size, buf);\n+            return new String(buf, UTF16);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":43,"deletions":6,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2532,0 +2532,1 @@\n+     * @author Joseph D. Darcy\n@@ -2578,0 +2579,1 @@\n+     * @author Joseph D. Darcy\n@@ -2618,0 +2620,1 @@\n+     * @author Joseph D. Darcy\n@@ -2639,0 +2642,1 @@\n+     * @author Joseph D. Darcy\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Math.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -58,0 +58,2 @@\n+ * @author  Nakul Saraiya\n+ * @author  Joseph D. Darcy\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Short.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,0 +104,1 @@\n+ * @author  Joseph D. Darcy\n@@ -495,0 +496,1 @@\n+     * @author Joseph D. Darcy\n@@ -2015,0 +2017,1 @@\n+     * @author Joseph D. Darcy\n@@ -2041,0 +2044,1 @@\n+     * @author Joseph D. Darcy\n@@ -2061,0 +2065,1 @@\n+     * @author Joseph D. Darcy\n@@ -2081,0 +2086,1 @@\n+     * @author Joseph D. Darcy\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StrictMath.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,5 +28,0 @@\n-import java.lang.classfile.ClassFile;\n-import java.lang.classfile.ClassHierarchyResolver;\n-import java.lang.classfile.Opcode;\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.MethodTypeDesc;\n@@ -39,1 +34,0 @@\n-import java.lang.reflect.Modifier;\n@@ -46,2 +40,0 @@\n-import static java.lang.classfile.ClassFile.ACC_STATIC;\n-import static java.lang.constant.ConstantDescs.*;\n@@ -69,3 +61,3 @@\n-    private static final MethodHandle IS_NULL;\n-    private static final MethodHandle IS_ARG0_NULL;\n-    private static final MethodHandle IS_ARG1_NULL;\n+    private static final MethodHandle OBJECTS_EQUALS;\n+    private static final MethodHandle OBJECTS_HASHCODE;\n+    private static final MethodHandle OBJECTS_TOSTRING;\n@@ -74,4 +66,0 @@\n-    private static final MethodType MT_OBJECT_BOOLEAN = MethodType.methodType(boolean.class, Object.class);\n-    private static final MethodType MT_INT = MethodType.methodType(int.class);\n-    private static final MethodTypeDesc MTD_OBJECT_BOOLEAN = MethodTypeDesc.of(CD_boolean, CD_Object);\n-    private static final MethodTypeDesc MTD_INT = MethodTypeDesc.of(CD_int);\n@@ -81,0 +69,1 @@\n+    private static final HashMap<Class<?>, MethodHandle> primitiveToString = new HashMap<>();\n@@ -90,6 +79,6 @@\n-\n-            var objectsIsNull = publicLookup.findStatic(Objects.class, \"isNull\",\n-                                                        MethodType.methodType(boolean.class, Object.class));\n-            IS_NULL = objectsIsNull;\n-            IS_ARG0_NULL = MethodHandles.dropArguments(objectsIsNull, 1, Object.class);\n-            IS_ARG1_NULL = MethodHandles.dropArguments(objectsIsNull, 0, Object.class);\n+            OBJECTS_EQUALS = publicLookup.findStatic(Objects.class, \"equals\",\n+                                                     MethodType.methodType(boolean.class, Object.class, Object.class));\n+            OBJECTS_HASHCODE = publicLookup.findStatic(Objects.class, \"hashCode\",\n+                                                       MethodType.methodType(int.class, Object.class));\n+            OBJECTS_TOSTRING = publicLookup.findStatic(Objects.class, \"toString\",\n+                                                       MethodType.methodType(String.class, Object.class));\n@@ -135,0 +124,17 @@\n+\n+            primitiveToString.put(byte.class, lookup.findStatic(Byte.class, \"toString\",\n+                                                                MethodType.methodType(String.class, byte.class)));\n+            primitiveToString.put(short.class, lookup.findStatic(Short.class, \"toString\",\n+                                                                 MethodType.methodType(String.class, short.class)));\n+            primitiveToString.put(char.class, lookup.findStatic(Character.class, \"toString\",\n+                                                                MethodType.methodType(String.class, char.class)));\n+            primitiveToString.put(int.class, lookup.findStatic(Integer.class, \"toString\",\n+                                                               MethodType.methodType(String.class, int.class)));\n+            primitiveToString.put(long.class, lookup.findStatic(Long.class, \"toString\",\n+                                                                MethodType.methodType(String.class, long.class)));\n+            primitiveToString.put(float.class, lookup.findStatic(Float.class, \"toString\",\n+                                                                 MethodType.methodType(String.class, float.class)));\n+            primitiveToString.put(double.class, lookup.findStatic(Double.class, \"toString\",\n+                                                                  MethodType.methodType(String.class, double.class)));\n+            primitiveToString.put(boolean.class, lookup.findStatic(Boolean.class, \"toString\",\n+                                                                   MethodType.methodType(String.class, boolean.class)));\n@@ -156,7 +162,4 @@\n-    private static MethodHandle equalator(MethodHandles.Lookup lookup, Class<?> clazz) throws Throwable {\n-        if (clazz.isPrimitive())\n-            return primitiveEquals.get(clazz);\n-        MethodType mt = MethodType.methodType(boolean.class, clazz, clazz);\n-        return MethodHandles.guardWithTest(IS_ARG0_NULL.asType(mt),\n-                                           IS_ARG1_NULL.asType(mt),\n-                                           lookup.findVirtual(clazz, \"equals\", MT_OBJECT_BOOLEAN).asType(mt));\n+    private static MethodHandle equalator(Class<?> clazz) {\n+        return (clazz.isPrimitive()\n+                ? primitiveEquals.get(clazz)\n+                : OBJECTS_EQUALS.asType(MethodType.methodType(boolean.class, clazz, clazz)));\n@@ -166,7 +169,4 @@\n-    private static MethodHandle hasher(MethodHandles.Lookup lookup, Class<?> clazz) throws Throwable {\n-        if (clazz.isPrimitive())\n-            return primitiveHashers.get(clazz);\n-        MethodType mt = MethodType.methodType(int.class, clazz);\n-        return MethodHandles.guardWithTest(IS_NULL.asType(MethodType.methodType(boolean.class, clazz)),\n-                                           MethodHandles.dropArguments(MethodHandles.zero(int.class), 0, clazz),\n-                                           lookup.findVirtual(clazz, \"hashCode\", MT_INT).asType(mt));\n+    private static MethodHandle hasher(Class<?> clazz) {\n+        return (clazz.isPrimitive()\n+                ? primitiveHashers.get(clazz)\n+                : OBJECTS_HASHCODE.asType(MethodType.methodType(int.class, clazz)));\n@@ -175,16 +175,5 @@\n-    \/\/ If this type must be a monomorphic receiver, that is, one that has no\n-    \/\/ subtypes in the JVM.  For example, Object-typed fields may have a more\n-    \/\/ specific one type at runtime and thus need optimizations.\n-    private static boolean isMonomorphic(Class<?> type) {\n-        \/\/ Includes primitives and final classes, but not arrays.\n-        \/\/ All array classes are reported to be final, but Object[] can have subtypes like String[]\n-        return Modifier.isFinal(type.getModifiers()) && !type.isArray();\n-    }\n-\n-    private static String specializerClassName(Class<?> targetClass, String kind) {\n-        String name = targetClass.getName();\n-        if (targetClass.isHidden()) {\n-            \/\/ use the original class name\n-            name = name.replace('\/', '_');\n-        }\n-        return name + \"$$\" + kind + \"Specializer\";\n+    \/** Get the stringifier for a value of a given type *\/\n+    private static MethodHandle stringifier(Class<?> clazz) {\n+        return (clazz.isPrimitive()\n+                ? primitiveToString.get(clazz)\n+                : OBJECTS_TOSTRING.asType(MethodType.methodType(String.class, clazz)));\n@@ -199,2 +188,2 @@\n-    private static MethodHandle makeEquals(MethodHandles.Lookup lookup, Class<?> receiverClass,\n-                                           List<MethodHandle> getters) throws Throwable {\n+    private static MethodHandle makeEquals(Class<?> receiverClass,\n+                                          List<MethodHandle> getters) {\n@@ -209,64 +198,2 @@\n-        int size = getters.size();\n-        MethodHandle[] equalators = new MethodHandle[size];\n-        boolean hasPolymorphism = false;\n-        for (int i = 0; i < size; i++) {\n-            var getter = getters.get(i);\n-            var type = getter.type().returnType();\n-            if (isMonomorphic(type)) {\n-                equalators[i] = equalator(lookup, type);\n-            } else {\n-                hasPolymorphism = true;\n-            }\n-        }\n-\n-        \/\/ Currently, hotspot does not support polymorphic inlining.\n-        \/\/ As a result, if we have a MethodHandle to Object.equals,\n-        \/\/ it does not enjoy separate profiles like individual invokevirtuals,\n-        \/\/ and we must spin bytecode to accomplish separate profiling.\n-        if (hasPolymorphism) {\n-            String[] names = new String[size];\n-\n-            var classFileContext = ClassFile.of(ClassFile.ClassHierarchyResolverOption.of(ClassHierarchyResolver.ofClassLoading(lookup)));\n-            var bytes = classFileContext.build(ClassDesc.of(specializerClassName(lookup.lookupClass(), \"Equalator\")), clb -> {\n-                for (int i = 0; i < size; i++) {\n-                    if (equalators[i] == null) {\n-                        var name = \"equalator\".concat(Integer.toString(i));\n-                        names[i] = name;\n-                        var type = getters.get(i).type().returnType();\n-                        boolean isInterface = type.isInterface();\n-                        var typeDesc = type.describeConstable().orElseThrow();\n-                        clb.withMethodBody(name, MethodTypeDesc.of(CD_boolean, typeDesc, typeDesc), ACC_STATIC, cob -> {\n-                            var nonNullPath = cob.newLabel();\n-                            var fail = cob.newLabel();\n-                            cob.aload(0)\n-                               .ifnonnull(nonNullPath)\n-                               .aload(1)\n-                               .ifnonnull(fail)\n-                               .iconst_1() \/\/ arg0 null, arg1 null\n-                               .ireturn()\n-                               .labelBinding(fail)\n-                               .iconst_0() \/\/ arg0 null, arg1 non-null\n-                               .ireturn()\n-                               .labelBinding(nonNullPath)\n-                               .aload(0) \/\/ arg0.equals(arg1) - bytecode subject to customized profiling\n-                               .aload(1)\n-                               .invoke(isInterface ? Opcode.INVOKEINTERFACE : Opcode.INVOKEVIRTUAL, typeDesc, \"equals\", MTD_OBJECT_BOOLEAN, isInterface)\n-                               .ireturn();\n-                        });\n-                    }\n-                }\n-            });\n-\n-            var specializerLookup = lookup.defineHiddenClass(bytes, true, MethodHandles.Lookup.ClassOption.STRONG);\n-\n-            for (int i = 0; i < size; i++) {\n-                if (equalators[i] == null) {\n-                    var type = getters.get(i).type().returnType();\n-                    equalators[i] = specializerLookup.findStatic(specializerLookup.lookupClass(), names[i], MethodType.methodType(boolean.class, type, type));\n-                }\n-            }\n-        }\n-\n-        for (int i = 0; i < size; i++) {\n-            var getter = getters.get(i);\n-            MethodHandle equalator = equalators[i]; \/\/ (TT)Z\n+        for (MethodHandle getter : getters) {\n+            MethodHandle equalator = equalator(getter.type().returnType()); \/\/ (TT)Z\n@@ -288,2 +215,2 @@\n-    private static MethodHandle makeHashCode(MethodHandles.Lookup lookup, Class<?> receiverClass,\n-                                             List<MethodHandle> getters) throws Throwable {\n+    private static MethodHandle makeHashCode(Class<?> receiverClass,\n+                                            List<MethodHandle> getters) {\n@@ -292,54 +219,0 @@\n-        int size = getters.size();\n-        MethodHandle[] hashers = new MethodHandle[size];\n-        boolean hasPolymorphism = false;\n-        for (int i = 0; i < size; i++) {\n-            var getter = getters.get(i);\n-            var type = getter.type().returnType();\n-            if (isMonomorphic(type)) {\n-                hashers[i] = hasher(lookup, type);\n-            } else {\n-                hasPolymorphism = true;\n-            }\n-        }\n-\n-        \/\/ Currently, hotspot does not support polymorphic inlining.\n-        \/\/ As a result, if we have a MethodHandle to Object.hashCode,\n-        \/\/ it does not enjoy separate profiles like individual invokevirtuals,\n-        \/\/ and we must spin bytecode to accomplish separate profiling.\n-        if (hasPolymorphism) {\n-            String[] names = new String[size];\n-\n-            var classFileContext = ClassFile.of(ClassFile.ClassHierarchyResolverOption.of(ClassHierarchyResolver.ofClassLoading(lookup)));\n-            var bytes = classFileContext.build(ClassDesc.of(specializerClassName(lookup.lookupClass(), \"Hasher\")), clb -> {\n-                for (int i = 0; i < size; i++) {\n-                    if (hashers[i] == null) {\n-                        var name = \"hasher\".concat(Integer.toString(i));\n-                        names[i] = name;\n-                        var type = getters.get(i).type().returnType();\n-                        boolean isInterface = type.isInterface();\n-                        var typeDesc = type.describeConstable().orElseThrow();\n-                        clb.withMethodBody(name, MethodTypeDesc.of(CD_int, typeDesc), ACC_STATIC, cob -> {\n-                            var nonNullPath = cob.newLabel();\n-                            cob.aload(0)\n-                               .ifnonnull(nonNullPath)\n-                               .iconst_0() \/\/ null hash is 0\n-                               .ireturn()\n-                               .labelBinding(nonNullPath)\n-                               .aload(0) \/\/ arg0.hashCode() - bytecode subject to customized profiling\n-                               .invoke(isInterface ? Opcode.INVOKEINTERFACE : Opcode.INVOKEVIRTUAL, typeDesc, \"hashCode\", MTD_INT, isInterface)\n-                               .ireturn();\n-                        });\n-                    }\n-                }\n-            });\n-\n-            var specializerLookup = lookup.defineHiddenClass(bytes, true, MethodHandles.Lookup.ClassOption.STRONG);\n-\n-            for (int i = 0; i < size; i++) {\n-                if (hashers[i] == null) {\n-                    var type = getters.get(i).type().returnType();\n-                    hashers[i] = specializerLookup.findStatic(specializerLookup.lookupClass(), names[i], MethodType.methodType(int.class, type));\n-                }\n-            }\n-        }\n-\n@@ -347,3 +220,2 @@\n-        for (int i = 0; i < size; i++) {\n-            var getter = getters.get(i);\n-            MethodHandle hasher = hashers[i]; \/\/ (T)I\n+        for (MethodHandle getter : getters) {\n+            MethodHandle hasher = hasher(getter.type().returnType()); \/\/ (T)I\n@@ -534,1 +406,1 @@\n-                yield makeEquals(lookup, recordClass, getterList);\n+                yield makeEquals(recordClass, getterList);\n@@ -539,1 +411,1 @@\n-                yield makeHashCode(lookup, recordClass, getterList);\n+                yield makeHashCode(recordClass, getterList);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ObjectMethods.java","additions":50,"deletions":178,"binary":false,"changes":228,"status":"modified"},{"patch":"@@ -157,1 +157,1 @@\n- * <tr><th scope=\"row\">Square root<\/th><td>ceil(radicand.scale()\/2.0)<\/td>\n+ * <tr><th scope=\"row\">Square root<\/th><td>radicand.scale()\/2<\/td>\n@@ -330,0 +330,4 @@\n+ * @author  Josh Bloch\n+ * @author  Mike Cowlishaw\n+ * @author  Joseph D. Darcy\n+ * @author  Sergey V. Kuksenko\n@@ -1778,0 +1782,1 @@\n+     * @author Joseph D. Darcy\n@@ -1946,0 +1951,1 @@\n+     * @author Joseph D. Darcy\n@@ -2116,1 +2122,1 @@\n-     * {@code Math.ceilDiv(this.scale(), 2)}. The value of the returned result is\n+     * {@code this.scale()\/2}. The value of the returned result is\n@@ -2177,1 +2183,1 @@\n-        final int preferredScale = Math.ceilDiv(this.scale, 2);\n+        final int preferredScale = this.scale\/2;\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -54,0 +54,2 @@\n+ * @author  Mike Cowlishaw\n+ * @author  Joseph D. Darcy\n","filename":"src\/java.base\/share\/classes\/java\/math\/MathContext.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -118,0 +118,3 @@\n+ * @author  Josh Bloch\n+ * @author  Mike Cowlishaw\n+ * @author  Joseph D. Darcy\n","filename":"src\/java.base\/share\/classes\/java\/math\/RoundingMode.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,7 +38,8 @@\n-public enum ByteOrder  {\n-    \/**\n-     * Constant denoting little-endian byte order.  In this order, the bytes of\n-     * a multibyte value are ordered from least significant to most\n-     * significant.\n-     *\/\n-    LITTLE_ENDIAN,\n+public final class ByteOrder {\n+\n+    private final String name;\n+\n+    private ByteOrder(String name) {\n+        this.name = name;\n+    }\n+\n@@ -49,1 +50,2 @@\n-    BIG_ENDIAN;\n+    public static final ByteOrder BIG_ENDIAN\n+        = new ByteOrder(\"BIG_ENDIAN\");\n@@ -51,0 +53,7 @@\n+    \/**\n+     * Constant denoting little-endian byte order.  In this order, the bytes of\n+     * a multibyte value are ordered from least significant to most\n+     * significant.\n+     *\/\n+    public static final ByteOrder LITTLE_ENDIAN\n+        = new ByteOrder(\"LITTLE_ENDIAN\");\n@@ -72,0 +81,14 @@\n+\n+    \/**\n+     * Constructs a string describing this object.\n+     *\n+     * <p> This method returns the string\n+     * {@code \"BIG_ENDIAN\"} for {@link #BIG_ENDIAN} and\n+     * {@code \"LITTLE_ENDIAN\"} for {@link #LITTLE_ENDIAN}.\n+     *\n+     * @return  The specified string\n+     *\/\n+    public String toString() {\n+        return name;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/nio\/ByteOrder.java","additions":32,"deletions":9,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-     * <p> For many types of channels, a write operation will return only after\n+     * <p> Unless otherwise specified, a write operation will return only after\n@@ -82,5 +82,2 @@\n-     * none at all.  A socket channel in {@linkplain\n-     * SelectableChannel#isBlocking non-blocking mode}, for example, cannot\n-     * write any more bytes than are free in the socket's output buffer.  The\n-     * write method may need to be invoked more than once to ensure that all\n-     * {@linkplain ByteBuffer#hasRemaining remaining} bytes are written.\n+     * none at all.  A socket channel in non-blocking mode, for example, cannot\n+     * write any more bytes than are free in the socket's output buffer.\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/GatheringByteChannel.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2005, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-     * <p> For many types of channels, a write operation will return only after\n+     * <p> Unless otherwise specified, a write operation will return only after\n@@ -71,5 +71,2 @@\n-     * none at all.  A socket channel in {@linkplain\n-     * SelectableChannel#isBlocking non-blocking mode}, for example, cannot\n-     * write any more bytes than are free in the socket's output buffer.  The\n-     * write method may need to be invoked more than once to ensure that all\n-     * {@linkplain ByteBuffer#hasRemaining remaining} bytes are written.\n+     * none at all.  A socket channel in non-blocking mode, for example, cannot\n+     * write any more bytes than are free in the socket's output buffer.\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/WritableByteChannel.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -141,31 +141,0 @@\n-    \/**\n-     * The minimum supported {@code Duration}, which is {@link Long#MIN_VALUE}\n-     * seconds.\n-     *\n-     * @apiNote This constant represents the smallest possible instance of\n-     * {@code Duration}. Since {@code Duration} is directed, the smallest\n-     * possible duration is negative.\n-     *\n-     * The constant is intended to be used as a sentinel value or in tests.\n-     * Care should be taken when performing arithmetic on {@code MIN} as there\n-     * is a high risk that {@link ArithmeticException} or {@link DateTimeException}\n-     * will be thrown.\n-     *\n-     * @since 26\n-     *\/\n-    public static final Duration MIN = new Duration(Long.MIN_VALUE, 0);\n-    \/**\n-     * The maximum supported {@code Duration}, which is {@link Long#MAX_VALUE}\n-     * seconds and {@code 999,999,999} nanoseconds.\n-     *\n-     * @apiNote This constant represents the largest possible instance of\n-     * {@code Duration}.\n-     *\n-     * The constant is intended to be used as a sentinel value or in tests.\n-     * Care should be taken when performing arithmetic on {@code MAX} as there\n-     * is a high risk that {@link ArithmeticException} or {@link DateTimeException}\n-     * will be thrown.\n-     *\n-     * @since 26\n-     *\/\n-    public static final Duration MAX = new Duration(Long.MAX_VALUE, 999_999_999);\n","filename":"src\/java.base\/share\/classes\/java\/time\/Duration.java","additions":0,"deletions":31,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n@@ -187,1 +187,2 @@\n-     * The estimated duration of this unit is artificially defined as {@link Duration#MAX}.\n+     * The estimated duration of this unit is artificially defined as the largest duration\n+     * supported by {@link Duration}.\n@@ -189,1 +190,1 @@\n-    FOREVER(\"Forever\", Duration.MAX);\n+    FOREVER(\"Forever\", Duration.ofSeconds(Long.MAX_VALUE, 999_999_999));\n","filename":"src\/java.base\/share\/classes\/java\/time\/temporal\/ChronoUnit.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1907,2 +1907,2 @@\n-                if (Thread.currentThread() instanceof ForkJoinWorkerThread wt)\n-                    ForkJoinPool.helpAsyncBlocker(wt.pool, q);\n+                if (Thread.currentThread() instanceof ForkJoinWorkerThread)\n+                    ForkJoinPool.helpAsyncBlocker(defaultExecutor(), q);\n@@ -1953,2 +1953,2 @@\n-                if (Thread.currentThread() instanceof ForkJoinWorkerThread wt)\n-                    ForkJoinPool.helpAsyncBlocker(wt.pool, q);\n+                if (Thread.currentThread() instanceof ForkJoinWorkerThread)\n+                    ForkJoinPool.helpAsyncBlocker(defaultExecutor(), q);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/CompletableFuture.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+ *\n+ * @author Joseph D. Darcy\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/DoubleConsts.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+ *\n+ * @author Joseph D. Darcy\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/FloatConsts.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -862,16 +862,0 @@\n-    \/**\n-     * Checks that the BMPString does not contain any surrogate characters,\n-     * which are outside the Basic Multilingual Plane.\n-     *\n-     * @throws IOException if illegal characters are detected\n-     *\/\n-    public void validateBMPString() throws IOException {\n-        String bmpString = getBMPString();\n-        for (int i = 0; i < bmpString.length(); i++) {\n-            if (Character.isSurrogate(bmpString.charAt(i))) {\n-                throw new IOException(\n-                    \"Illegal character in BMPString, index: \" + i);\n-            }\n-         }\n-     }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/DerValue.java","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import java.nio.charset.Charset;\n@@ -35,1 +34,0 @@\n-import static java.nio.charset.StandardCharsets.ISO_8859_1;\n@@ -37,1 +35,0 @@\n-import static java.nio.charset.StandardCharsets.UTF_16BE;\n@@ -595,4 +592,0 @@\n-\n-        if (value.tag == DerValue.tag_BMPString) {\n-            value.validateBMPString();\n-        }\n@@ -723,2 +716,1 @@\n-            String valStr =\n-                new String(value.getDataBytes(), getCharset(value, false));\n+            String valStr = new String(value.getDataBytes(), UTF_8);\n@@ -843,2 +835,1 @@\n-            String valStr =\n-                new String(value.getDataBytes(), getCharset(value, true));\n+            String valStr = new String(value.getDataBytes(), UTF_8);\n@@ -939,33 +930,0 @@\n-    \/*\n-     * Returns the charset that should be used to decode each DN string type.\n-     *\n-     * This method ensures that multi-byte (UTF8String and BMPString) types\n-     * are decoded using the correct charset and the String forms represent\n-     * the correct characters. For 8-bit ASCII-based types (PrintableString\n-     * and IA5String), we return ISO_8859_1 rather than ASCII, so that the\n-     * complete range of characters can be represented, as many certificates\n-     * do not comply with the Internationalized Domain Name ACE format.\n-     *\n-     * NOTE: this method only supports DirectoryStrings of the types returned\n-     * by isDerString().\n-     *\/\n-    private static Charset getCharset(DerValue value, boolean canonical) {\n-        if (canonical) {\n-            return switch (value.tag) {\n-                case DerValue.tag_PrintableString -> ISO_8859_1;\n-                case DerValue.tag_UTF8String -> UTF_8;\n-                default -> throw new Error(\"unexpected tag: \" + value.tag);\n-            };\n-        }\n-\n-        return switch (value.tag) {\n-            case DerValue.tag_PrintableString,\n-                 DerValue.tag_T61String,\n-                 DerValue.tag_IA5String,\n-                 DerValue.tag_GeneralString -> ISO_8859_1;\n-            case DerValue.tag_BMPString -> UTF_16BE;\n-            case DerValue.tag_UTF8String -> UTF_8;\n-            default -> throw new Error(\"unexpected tag: \" + value.tag);\n-        };\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/AVA.java","additions":3,"deletions":45,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -130,24 +130,3 @@\n-\n-        if (params == null) {\n-            this.encodedParams = null;\n-            this.algParams = null;\n-            return;\n-        }\n-\n-        \/*\n-         * If the parameters field explicitly contains an ASN.1 NULL, treat it as\n-         * \"no parameters\" rather than storing a literal NULL encoding.\n-         *\n-         * This canonicalization ensures consistent encoding\/decoding behavior:\n-         *  - Algorithms that omit parameters and those that encode explicit NULL\n-         *   are treated equivalently (encodedParams == null).\n-         *\/\n-        if (params.tag == DerValue.tag_Null) {\n-            if (params.length() != 0) {\n-                throw new IOException(\"Invalid ASN.1 NULL in AlgorithmId parameters: \" +\n-                        \"non-zero length\");\n-            }\n-            \/\/ Canonicalize to \"no parameters\" representation for consistency\n-            this.encodedParams = null;\n-            this.algParams = null;\n-            return;\n+        if (params != null) {\n+            encodedParams = params.toByteArray();\n+            decodeParams();\n@@ -155,4 +134,0 @@\n-\n-        \/\/ Normal case: non-NULL params -> store and decode\n-        this.encodedParams = params.toByteArray();\n-        decodeParams();\n@@ -191,1 +166,31 @@\n-            if (OIDS_REQUIRING_NULL.contains(algid.toString())) {\n+            \/\/ MessageDigest algorithms usually have a NULL parameters even\n+            \/\/ if most RFCs suggested absent.\n+            \/\/ RSA key and signature algorithms requires the NULL parameters\n+            \/\/ to be present, see A.1 and A.2.4 of RFC 8017.\n+            if (algid.equals(RSAEncryption_oid)\n+                    || algid.equals(MD2_oid)\n+                    || algid.equals(MD5_oid)\n+                    || algid.equals(SHA_oid)\n+                    || algid.equals(SHA224_oid)\n+                    || algid.equals(SHA256_oid)\n+                    || algid.equals(SHA384_oid)\n+                    || algid.equals(SHA512_oid)\n+                    || algid.equals(SHA512_224_oid)\n+                    || algid.equals(SHA512_256_oid)\n+                    || algid.equals(SHA3_224_oid)\n+                    || algid.equals(SHA3_256_oid)\n+                    || algid.equals(SHA3_384_oid)\n+                    || algid.equals(SHA3_512_oid)\n+                    || algid.equals(SHA1withRSA_oid)\n+                    || algid.equals(SHA224withRSA_oid)\n+                    || algid.equals(SHA256withRSA_oid)\n+                    || algid.equals(SHA384withRSA_oid)\n+                    || algid.equals(SHA512withRSA_oid)\n+                    || algid.equals(SHA512$224withRSA_oid)\n+                    || algid.equals(SHA512$256withRSA_oid)\n+                    || algid.equals(MD2withRSA_oid)\n+                    || algid.equals(MD5withRSA_oid)\n+                    || algid.equals(SHA3_224withRSA_oid)\n+                    || algid.equals(SHA3_256withRSA_oid)\n+                    || algid.equals(SHA3_384withRSA_oid)\n+                    || algid.equals(SHA3_512withRSA_oid)) {\n@@ -193,2 +198,0 @@\n-            } else {\n-                \/\/ Parameters omitted\n@@ -646,50 +649,26 @@\n-    \/* Set of OIDs that must explicitly encode a NULL parameter in AlgorithmIdentifier.\n-     * References:\n-         - RFC 8017 (PKCS #1) §A.1, §A.2.4: RSA key and signature algorithms\n-         - RFC 9879 (HMAC) §4: HMAC algorithm identifiers\n-         - RFC 9688 (HMAC with SHA-3) §4.3: HMAC-SHA3 algorithms MUST omit parameters\n-     *\/\n-    private static final Set<String> OIDS_REQUIRING_NULL = Set.of(\n-            \/\/ MessageDigest algorithms usually have a NULL parameters even\n-            \/\/ if most RFCs suggested absent.\n-            KnownOIDs.MD2.value(),\n-            KnownOIDs.MD5.value(),\n-            KnownOIDs.SHA_1.value(),\n-            KnownOIDs.SHA_224.value(),\n-            KnownOIDs.SHA_256.value(),\n-            KnownOIDs.SHA_384.value(),\n-            KnownOIDs.SHA_512.value(),\n-            KnownOIDs.SHA_512$224.value(),\n-            KnownOIDs.SHA_512$256.value(),\n-            KnownOIDs.SHA3_224.value(),\n-            KnownOIDs.SHA3_256.value(),\n-            KnownOIDs.SHA3_384.value(),\n-            KnownOIDs.SHA3_512.value(),\n-\n-            \/\/--- RSA key and signature algorithms (RFC 8017 §A.1, §A.2.4)\n-            KnownOIDs.RSA.value(),\n-            KnownOIDs.SHA1withRSA.value(),\n-            KnownOIDs.SHA224withRSA.value(),\n-            KnownOIDs.SHA256withRSA.value(),\n-            KnownOIDs.SHA384withRSA.value(),\n-            KnownOIDs.SHA512withRSA.value(),\n-            KnownOIDs.SHA512$224withRSA.value(),\n-            KnownOIDs.SHA512$256withRSA.value(),\n-            KnownOIDs.MD2withRSA.value(),\n-            KnownOIDs.MD5withRSA.value(),\n-            KnownOIDs.SHA3_224withRSA.value(),\n-            KnownOIDs.SHA3_256withRSA.value(),\n-            KnownOIDs.SHA3_384withRSA.value(),\n-            KnownOIDs.SHA3_512withRSA.value(),\n-\n-            \/\/ HMACs per RFC 9879 (Section 4): these require explicit NULL parameters\n-            \/\/ Note: HMAC-SHA3 algorithms (RFC 9688 §4.3) MUST omit parameters,\n-            \/\/ so they are intentionally excluded from this list.\n-            KnownOIDs.HmacSHA1.value(),\n-            KnownOIDs.HmacSHA224.value(),\n-            KnownOIDs.HmacSHA256.value(),\n-            KnownOIDs.HmacSHA384.value(),\n-            KnownOIDs.HmacSHA512.value(),\n-            KnownOIDs.HmacSHA512$224.value(),\n-            KnownOIDs.HmacSHA512$256.value()\n-    );\n+    public static final ObjectIdentifier SHA1withRSA_oid =\n+            ObjectIdentifier.of(KnownOIDs.SHA1withRSA);\n+    public static final ObjectIdentifier SHA224withRSA_oid =\n+            ObjectIdentifier.of(KnownOIDs.SHA224withRSA);\n+    public static final ObjectIdentifier SHA256withRSA_oid =\n+            ObjectIdentifier.of(KnownOIDs.SHA256withRSA);\n+    public static final ObjectIdentifier SHA384withRSA_oid =\n+            ObjectIdentifier.of(KnownOIDs.SHA384withRSA);\n+    public static final ObjectIdentifier SHA512withRSA_oid =\n+            ObjectIdentifier.of(KnownOIDs.SHA512withRSA);\n+    public static final ObjectIdentifier SHA512$224withRSA_oid =\n+            ObjectIdentifier.of(KnownOIDs.SHA512$224withRSA);\n+    public static final ObjectIdentifier SHA512$256withRSA_oid =\n+            ObjectIdentifier.of(KnownOIDs.SHA512$256withRSA);\n+    public static final ObjectIdentifier MD2withRSA_oid =\n+            ObjectIdentifier.of(KnownOIDs.MD2withRSA);\n+    public static final ObjectIdentifier MD5withRSA_oid =\n+            ObjectIdentifier.of(KnownOIDs.MD5withRSA);\n+    public static final ObjectIdentifier SHA3_224withRSA_oid =\n+            ObjectIdentifier.of(KnownOIDs.SHA3_224withRSA);\n+    public static final ObjectIdentifier SHA3_256withRSA_oid =\n+            ObjectIdentifier.of(KnownOIDs.SHA3_256withRSA);\n+    public static final ObjectIdentifier SHA3_384withRSA_oid =\n+            ObjectIdentifier.of(KnownOIDs.SHA3_384withRSA);\n+    public static final ObjectIdentifier SHA3_512withRSA_oid =\n+            ObjectIdentifier.of(KnownOIDs.SHA3_512withRSA);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/AlgorithmId.java","additions":61,"deletions":82,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -0,0 +1,36 @@\n+## Cryptix AES v3.2.0\n+\n+### Cryptix General License\n+<pre>\n+\n+Cryptix General License\n+\n+Copyright (c) 1995-2005 The Cryptix Foundation Limited.\n+All rights reserved.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+  1. Redistributions of source code must retain the copyright notice,\n+     this list of conditions and the following disclaimer.\n+\n+  2. Redistributions in binary form must reproduce the above copyright\n+     notice, this list of conditions and the following disclaimer in\n+     the documentation and\/or other materials provided with the\n+     distribution.\n+\n+THIS SOFTWARE IS PROVIDED BY THE CRYPTIX FOUNDATION LIMITED AND\n+CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,\n+INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n+IN NO EVENT SHALL THE CRYPTIX FOUNDATION LIMITED OR CONTRIBUTORS BE\n+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n+OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n+IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+\n+<\/pre>\n","filename":"src\/java.base\/share\/legal\/aes.md","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -398,2 +398,1 @@\n-static jboolean isLegalOffset(context_type *, int bci, int offset);\n-static jboolean isLegalTarget(context_type *, int target);\n+static jboolean isLegalTarget(context_type *, int offset);\n@@ -1158,2 +1157,0 @@\n-        if (!isLegalOffset(context, offset, jump))\n-            CCerror(context, \"Illegal target of jump or branch\");\n@@ -1161,0 +1158,2 @@\n+        if (!isLegalTarget(context, target))\n+            CCerror(context, \"Illegal target of jump or branch\");\n@@ -1174,2 +1173,0 @@\n-        if (!isLegalOffset(context, offset, jump))\n-            CCerror(context, \"Illegal target of jump or branch\");\n@@ -1177,0 +1174,2 @@\n+        if (!isLegalTarget(context, target))\n+            CCerror(context, \"Illegal target of jump or branch\");\n@@ -1215,2 +1214,1 @@\n-        int jump = _ck_ntohl(lpc[0]);\n-        if (!isLegalOffset(context, offset, jump))\n+        if (!isLegalTarget(context, offset + _ck_ntohl(lpc[0])))\n@@ -1218,2 +1216,1 @@\n-        int target = offset + jump;\n-        saved_operand[keys + 1] = code_data[target];\n+        saved_operand[keys + 1] = code_data[offset + _ck_ntohl(lpc[0])];\n@@ -1221,2 +1218,2 @@\n-            jump = _ck_ntohl(lptr[0]);\n-            if (!isLegalOffset(context, offset, jump))\n+            int target = offset + _ck_ntohl(lptr[0]);\n+            if (!isLegalTarget(context, target))\n@@ -1224,1 +1221,0 @@\n-            target = offset + jump;\n@@ -1753,10 +1749,1 @@\n-isLegalTarget(context_type *context, int target)\n-{\n-    int code_length = context->code_length;\n-    int *code_data = context->code_data;\n-    return (target >= 0 && target < code_length && code_data[target] >= 0);\n-}\n-\n-\/* Given a bci and offset, make sure the offset is valid and the target is legal *\/\n-static jboolean\n-isLegalOffset(context_type *context, int bci, int offset)\n+isLegalTarget(context_type *context, int offset)\n@@ -1766,5 +1753,1 @@\n-    int max_offset = 65535; \/\/ JVMS 4.11\n-    int min_offset = -65535;\n-    if (offset < min_offset || offset > max_offset) return JNI_FALSE;\n-    int target = bci + offset;\n-    return (target >= 0 && target < code_length && code_data[target] >= 0);\n+    return (offset >= 0 && offset < code_length && code_data[offset] >= 0);\n","filename":"src\/java.base\/share\/native\/libverify\/check_code.c","additions":11,"deletions":28,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -202,0 +202,1 @@\n+    private static final int VERIFICATION_WIN32 = 1;\n@@ -386,0 +387,6 @@\n+    \/\/ Old version that can be bypassed\n+    private boolean isShellFile(String executablePath) {\n+        String upPath = executablePath.toUpperCase(Locale.ROOT);\n+        return (upPath.endsWith(\".CMD\") || upPath.endsWith(\".BAT\"));\n+    }\n+\n@@ -468,1 +475,2 @@\n-            boolean isShell = !isExe(executablePath);\n+            boolean isShell = allowAmbiguousCommands ? isShellFile(executablePath)\n+                    : !isExe(executablePath);\n@@ -471,1 +479,2 @@\n-                    isShell ? VERIFICATION_CMD_BAT : VERIFICATION_WIN32_SAFE,\n+                    isShell ? VERIFICATION_CMD_BAT\n+                            : (allowAmbiguousCommands ? VERIFICATION_WIN32 : VERIFICATION_WIN32_SAFE),\n","filename":"src\/java.base\/windows\/classes\/java\/lang\/ProcessImpl.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -578,1 +578,1 @@\n-     * Creates a {@code GridBagConstraints} object with\n+     * Creates a {@code GridBagConstraint} object with\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/GridBagConstraints.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -349,13 +349,0 @@\n-        private static int toRangeHash(Set<Range> ranges) {\n-            int m = 0;\n-            for (Range range : ranges) {\n-                int index = range.ordinal();\n-                if (index < NUM_KEYS) {\n-                    m |= 1 << index;\n-                } else {\n-                    m |=  (1 << NUM_KEYS) + index;\n-                }\n-            }\n-            return m;\n-        }\n-\n@@ -592,1 +579,1 @@\n-    private static final int ctCacheLimit = contexts.length - 2;\n+    private static int ctCacheLimit = contexts.length - 2;\n@@ -1526,3 +1513,0 @@\n-        if (((this.mask & ARABIC) != 0) && ((this.mask & EASTERN_ARABIC) != 0)) {\n-            this.mask &= ~ARABIC;\n-        }\n@@ -1814,1 +1798,9 @@\n-        return (rangeSet != null) ? Range.toRangeHash(rangeSet) : (mask & ~CONTEXTUAL_MASK);\n+        int hash = mask;\n+        if (rangeSet != null) {\n+            \/\/ Use the CONTEXTUAL_MASK bit only for the enum-based\n+            \/\/ NumericShaper. A deserialized NumericShaper might have\n+            \/\/ bit masks.\n+            hash &= CONTEXTUAL_MASK;\n+            hash ^= rangeSet.hashCode();\n+        }\n+        return hash;\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/font\/NumericShaper.java","additions":10,"deletions":18,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -144,3 +144,6 @@\n-     * @throws IllegalArgumentException if the product of {@code w}\n-     *         and {@code h} is greater than {@code Integer.MAX_VALUE}\n-     *         or {@code w} or {@code h} is not greater than 0.\n+     * @throws IllegalArgumentException if {@code w} or\n+     *         {@code h} equals either\n+     *         {@code Integer.MAX_VALUE} or\n+     *         {@code Integer.MIN_VALUE}\n+     * @throws IllegalArgumentException if {@code dataType} is not\n+     *         one of the supported data types\n@@ -172,2 +175,2 @@\n-     * @throws IllegalArgumentException if the number of bands is not greater than 0\n-     * @throws ArrayIndexOutOfBoundsException if any of the bank indices is out of bounds\n+     * @throws IllegalArgumentException if {@code dataType} is not\n+     *         one of the supported data types\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/image\/BandedSampleModel.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2008, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * may be performed by a single class such as RenderableImageOp through\n+ * may be performed by a single class such as RenderedImageOp through\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/image\/renderable\/ContextualRenderedImageFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2014, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-     * Constructs a {@code RenderableImageOp} given a\n+     * Constructs a RenderedImageOp given a\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/image\/renderable\/RenderableImageOp.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2014, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,2 +41,2 @@\n- * The layout manager used by {@code JScrollPane}.\n- * {@code ScrollPaneLayout} is\n+ * The layout manager used by <code>JScrollPane<\/code>.\n+ * <code>JScrollPaneLayout<\/code> is\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/ScrollPaneLayout.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -147,3 +147,1 @@\n-    private int perpendiculardfddf(final double[] pts, final int off,\n-                                   final double A, final double B)\n-    {\n+    private int perpendiculardfddf(final double[] pts, final int off) {\n@@ -160,1 +158,1 @@\n-        return Helpers.cubicRootsInAB(a, b, c, d, pts, off, A, B);\n+        return Helpers.cubicRootsInAB(a, b, c, d, pts, off, 0.0d, 1.0d);\n@@ -176,3 +174,1 @@\n-    int rootsOfROCMinusW(final double[] roots, final int off, final double w2,\n-                         final double A, final double B)\n-    {\n+    int rootsOfROCMinusW(final double[] roots, final int off, final double w2, final double err) {\n@@ -183,2 +179,1 @@\n-        final int end = off + perpendiculardfddf(roots, off, A, B);\n-        Helpers.isort(roots, off, end);\n+        final int end = off + perpendiculardfddf(roots, off);\n@@ -187,3 +182,1 @@\n-        double t0 = 0.0d;\n-        double ft0 = eliminateInf(ROCsq(t0) - w2);\n-        double t1, ft1;\n+        double t0 = 0.0d, ft0 = ROCsq(t0) - w2;\n@@ -192,2 +185,1 @@\n-            t1 = roots[i];\n-            ft1 = eliminateInf(ROCsq(t1) - w2);\n+            double t1 = roots[i], ft1 = ROCsq(t1) - w2;\n@@ -199,1 +191,1 @@\n-                roots[ret++] = falsePositionROCsqMinusX(t0, t1, ft0, ft1, w2, A); \/\/ A = err\n+                roots[ret++] = falsePositionROCsqMinusX(t0, t1, w2, err);\n@@ -204,0 +196,1 @@\n+\n@@ -207,6 +200,3 @@\n-    private final static double MAX_ROC_SQ = 1e20;\n-\n-    private static double eliminateInf(final double x2) {\n-        \/\/ limit the value of x to avoid numerical problems (smaller step):\n-        \/\/ must handle NaN and +Infinity:\n-        return (x2 <= MAX_ROC_SQ) ? x2 : MAX_ROC_SQ;\n+    private static double eliminateInf(final double x) {\n+        return (x == Double.POSITIVE_INFINITY ? Double.MAX_VALUE :\n+               (x == Double.NEGATIVE_INFINITY ? Double.MIN_VALUE : x));\n@@ -223,1 +213,0 @@\n-                                            final double ft0, final double ft1,\n@@ -228,2 +217,2 @@\n-        double s = t0, fs = eliminateInf(ft0);\n-        double t = t1, ft = eliminateInf(ft1);\n+        double t = t1, ft = eliminateInf(ROCsq(t) - w2);\n+        double s = t0, fs = eliminateInf(ROCsq(s) - w2);\n@@ -232,1 +221,1 @@\n-        for (int i = 0; i < iterLimit && Math.abs(t - s) > err; i++) {\n+        for (int i = 0; i < iterLimit && Math.abs(t - s) > err * Math.abs(t + s); i++) {\n@@ -234,1 +223,1 @@\n-            fr = eliminateInf(ROCsq(r) - w2);\n+            fr = ROCsq(r) - w2;\n@@ -255,1 +244,1 @@\n-        return (Math.abs(ft) <= Math.abs(fs)) ? t : s;\n+        return r;\n@@ -270,4 +259,4 @@\n-        final double dx2dy2 = dx * dx + dy * dy; \/\/ positive\n-        final double dxddyddxdy = dx * ddy - dy * ddx;\n-        \/\/ may return +Infinity if dxddyddxdy = 0 or NaN if 0\/0:\n-        return (dx2dy2 * dx2dy2 * dx2dy2) \/ (dxddyddxdy * dxddyddxdy); \/\/ both positive\n+        final double dx2dy2 = dx * dx + dy * dy;\n+        final double ddx2ddy2 = ddx * ddx + ddy * ddy;\n+        final double ddxdxddydy = ddx * dx + ddy * dy;\n+        return dx2dy2 * ((dx2dy2 * dx2dy2) \/ (dx2dy2 * ddx2ddy2 - ddxdxddydy * ddxdxddydy));\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/Curve.java","additions":21,"deletions":32,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -567,1 +567,1 @@\n-        return Math.abs(num) < 2.0d * Helpers.ulp(num);\n+        return Math.abs(num) < 2.0d * Math.ulp(num);\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/DMarlinRenderingEngine.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,4 +34,0 @@\n-    private final static double T_ERR = 1e-4;\n-    private final static double T_A = T_ERR;\n-    private final static double T_B = 1.0 - T_ERR;\n-\n@@ -44,3 +40,0 @@\n-    \/** use lower precision like former Pisces and Marlin (float-precision) *\/\n-    static double ulp(final double value) { return Math.ulp((float)value); }\n-\n@@ -332,1 +325,1 @@\n-        ret += c.rootsOfROCMinusW(ts, ret, w2, T_A, T_B);\n+        ret += c.rootsOfROCMinusW(ts, ret, w2, 0.0001d);\n@@ -334,2 +327,2 @@\n-        ret = filterOutNotInAB(ts, 0, ret, T_A, T_B);\n-        isort(ts, 0, ret);\n+        ret = filterOutNotInAB(ts, 0, ret, 0.0001d, 0.9999d);\n+        isort(ts, ret);\n@@ -364,1 +357,1 @@\n-        isort(ts, 0, ret);\n+        isort(ts, ret);\n@@ -384,2 +377,2 @@\n-    static void isort(final double[] a, final int off, final int len) {\n-        for (int i = off + 1, j; i < len; i++) {\n+    static void isort(final double[] a, final int len) {\n+        for (int i = 1, j; i < len; i++) {\n@@ -388,1 +381,1 @@\n-            for (; j >= off && a[j] > ai; j--) {\n+            for (; j >= 0 && a[j] > ai; j--) {\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/Helpers.java","additions":8,"deletions":15,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -889,2 +889,2 @@\n-        final boolean p1eqp2 = Helpers.withinD(dx1, dy1, 6.0d * Helpers.ulp(y2));\n-        final boolean p3eqp4 = Helpers.withinD(dx4, dy4, 6.0d * Helpers.ulp(y4));\n+        final boolean p1eqp2 = Helpers.withinD(dx1, dy1, 6.0d * Math.ulp(y2));\n+        final boolean p3eqp4 = Helpers.withinD(dx4, dy4, 6.0d * Math.ulp(y4));\n@@ -908,1 +908,1 @@\n-        if (Helpers.within(dotsq, l1sq * l4sq, 4.0d * Helpers.ulp(dotsq))) {\n+        if (Helpers.within(dotsq, l1sq * l4sq, 4.0d * Math.ulp(dotsq))) {\n@@ -1081,2 +1081,2 @@\n-        final boolean p1eqp2 = Helpers.withinD(dx12, dy12, 6.0d * Helpers.ulp(y2));\n-        final boolean p2eqp3 = Helpers.withinD(dx23, dy23, 6.0d * Helpers.ulp(y3));\n+        final boolean p1eqp2 = Helpers.withinD(dx12, dy12, 6.0d * Math.ulp(y2));\n+        final boolean p2eqp3 = Helpers.withinD(dx23, dy23, 6.0d * Math.ulp(y3));\n@@ -1094,1 +1094,1 @@\n-        if (Helpers.within(dotsq, l1sq * l3sq, 4.0d * Helpers.ulp(dotsq))) {\n+        if (Helpers.within(dotsq, l1sq * l3sq, 4.0d * Math.ulp(dotsq))) {\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/Stroker.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+itcavantgarde=avantgarde_book\n","filename":"src\/java.desktop\/share\/conf\/psfontj2d.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -282,3 +282,1 @@\n-                if (colorMap &&\n-                    colorMap->Colors &&\n-                    transparentColor < 0) {\n+                if (transparentColor < 0) {\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/splashscreen_gif.c","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -279,1 +279,4 @@\n-        fp_glib_check_version = dl_symbol(\"glib_check_version\");\n+        fp_glib_check_version = dlsym(gtk3_libhandle, \"glib_check_version\");\n+        if (!fp_glib_check_version) {\n+            dlerror();\n+        }\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/gtk3_interface.c","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -79,1 +79,3 @@\n-    @Override\n+    \/**\n+     * Paint MenuItem.\n+     *\/\n@@ -85,8 +87,5 @@\n-            WindowsMenuItemUI.paintMenuItem(accessor, g, c,\n-                                            checkIcon, arrowIcon,\n-                                            background, foreground,\n-                                            disabledForeground,\n-                                            acceleratorSelectionForeground,\n-                                            acceleratorForeground,\n-                                            defaultTextIconGap,\n-                                            menuItem, getPropertyPrefix());\n+            WindowsMenuItemUI.paintMenuItem(accessor, g, c, checkIcon,\n+                    arrowIcon, background, foreground,\n+                    disabledForeground, acceleratorSelectionForeground,\n+                    acceleratorForeground, defaultTextIconGap,\n+                    menuItem, getPropertyPrefix());\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsCheckBoxMenuItemUI.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.awt.Insets;\n@@ -35,0 +36,1 @@\n+import java.util.Enumeration;\n@@ -36,0 +38,2 @@\n+import javax.swing.AbstractButton;\n+import javax.swing.ButtonGroup;\n@@ -37,0 +41,1 @@\n+import javax.swing.DefaultButtonModel;\n@@ -130,0 +135,21 @@\n+    protected void installDefaults() {\n+        super.installDefaults();\n+        String prefix = getPropertyPrefix();\n+\n+        if (acceleratorSelectionForeground == null ||\n+                acceleratorSelectionForeground instanceof UIResource) {\n+            acceleratorSelectionForeground =\n+                    UIManager.getColor(prefix + \".acceleratorSelectionForeground\");\n+        }\n+        if (acceleratorForeground == null ||\n+                acceleratorForeground instanceof UIResource) {\n+            acceleratorForeground =\n+                    UIManager.getColor(prefix + \".acceleratorForeground\");\n+        }\n+        if (disabledForeground == null ||\n+                disabledForeground instanceof UIResource) {\n+            disabledForeground =\n+                    UIManager.getColor(prefix + \".disabledForeground\");\n+        }\n+    }\n+\n@@ -142,1 +168,0 @@\n-    @Override\n@@ -148,7 +173,4 @@\n-            WindowsMenuItemUI.paintMenuItem(accessor, g, c,\n-                                            checkIcon, arrowIcon,\n-                                            background, foreground,\n-                                            disabledForeground,\n-                                            acceleratorSelectionForeground,\n-                                            acceleratorForeground,\n-                                            defaultTextIconGap, menuItem,\n+            WindowsMenuItemUI.paintMenuItem(accessor, g, c, checkIcon,\n+                                            arrowIcon, background, foreground,\n+                                            disabledForeground, acceleratorSelectionForeground,\n+                                            acceleratorForeground, defaultTextIconGap, menuItem,\n@@ -163,2 +185,1 @@\n-                              JComponent c,\n-                              Icon checkIcon, Icon arrowIcon,\n+                              JComponent c, Icon checkIcon, Icon arrowIcon,\n@@ -169,4 +190,1 @@\n-                              int defaultTextIconGap, JMenuItem menuItem,\n-                              String prefix) {\n-        assert c == menuItem : \"menuItem passed as 'c' must be the same\";\n-\n+                              int defaultTextIconGap, JMenuItem menuItem, String prefix) {\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsMenuItemUI.java","additions":32,"deletions":14,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -134,1 +134,3 @@\n-    @Override\n+    \/**\n+     * Paint MenuItem.\n+     *\/\n@@ -136,4 +138,3 @@\n-                                 Icon checkIcon, Icon arrowIcon,\n-                                 Color background, Color foreground,\n-                                 int defaultTextIconGap) {\n-        assert c == menuItem : \"menuItem passed as 'c' must be the same\";\n+                              Icon checkIcon, Icon arrowIcon,\n+                              Color background, Color foreground,\n+                              int defaultTextIconGap) {\n@@ -141,2 +142,1 @@\n-            WindowsMenuItemUI.paintMenuItem(accessor, g, c,\n-                                            checkIcon, arrowIcon,\n+            WindowsMenuItemUI.paintMenuItem(accessor, g, c, checkIcon, arrowIcon,\n@@ -144,4 +144,2 @@\n-                                            disabledForeground,\n-                                            acceleratorSelectionForeground,\n-                                            acceleratorForeground,\n-                                            defaultTextIconGap, menuItem,\n+                                            disabledForeground, acceleratorSelectionForeground,\n+                                            acceleratorForeground, defaultTextIconGap, menuItem,\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsMenuUI.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -79,1 +79,3 @@\n-    @Override\n+    \/**\n+     * Paint MenuItem.\n+     *\/\n@@ -85,8 +87,5 @@\n-            WindowsMenuItemUI.paintMenuItem(accessor, g, c,\n-                                            checkIcon, arrowIcon,\n-                                            background, foreground,\n-                                            disabledForeground,\n-                                            acceleratorSelectionForeground,\n-                                            acceleratorForeground,\n-                                            defaultTextIconGap,\n-                                            menuItem, getPropertyPrefix());\n+            WindowsMenuItemUI.paintMenuItem(accessor, g, c, checkIcon,\n+                    arrowIcon, background, foreground,\n+                    disabledForeground, acceleratorSelectionForeground,\n+                    acceleratorForeground, defaultTextIconGap,\n+                    menuItem, getPropertyPrefix());\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsRadioButtonMenuItemUI.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -293,2 +293,1 @@\n-        String method = request.method();\n-        sb.append(method)\n+        sb.append(request.method())\n@@ -304,0 +303,1 @@\n+        \/\/ GET, HEAD and DELETE with no request body should not set the Content-Length header\n@@ -307,6 +307,1 @@\n-                \/\/ PUT and POST with no request body should set the Content-Length header\n-                \/\/ even when the content is empty.\n-                \/\/ Other methods defined in RFC 9110 should not send the header in that case.\n-                if (\"POST\".equals(method) || \"PUT\".equals(method)) {\n-                    systemHeadersBuilder.setHeader(\"Content-Length\", \"0\");\n-                }\n+                systemHeadersBuilder.setHeader(\"Content-Length\", \"0\");\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http1Request.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -177,2 +177,3 @@\n-     * The capacity of ephemeral {@link ByteBuffer}s allocated to pass data to and from the client.\n-     * It is ensured to have a value between 1 and 2^14 (16,384).\n+     * Allocated buffer size. Must never be higher than 16K. But can be lower\n+     * if smaller allocation units preferred. HTTP\/2 mandates that all\n+     * implementations support frame payloads of at least 16K.\n@@ -180,0 +181,2 @@\n+    private static final int DEFAULT_BUFSIZE = 16 * 1024;\n+\n@@ -181,10 +184,2 @@\n-            \"jdk.httpclient.bufsize\", 1,\n-            \/\/ We cap at 2^14 (16,384) for two main reasons:\n-            \/\/ - The initial frame size is 2^14 (RFC 9113)\n-            \/\/ - SSL record layer fragments data in chunks of 2^14 bytes or less (RFC 5246)\n-            1 << 14,\n-            \/\/ We choose 2^14 (16,384) as the default, because:\n-            \/\/ 1. It maximizes throughput within the limits described above\n-            \/\/ 2. It is small enough to not create a GC bottleneck when it is partially filled\n-            1 << 14,\n-            true);\n+            \"jdk.httpclient.bufsize\", DEFAULT_BUFSIZE\n+    );\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/Utils.java","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -51,3 +51,1 @@\n- * The capacity of internal ephemeral buffers allocated to pass data to and from the\n- * client, in bytes. Valid values are in the range [1, 2^14 (16384)].\n- * If an invalid value is provided, the default value is used.\n+ * The size to use for internal allocated buffers in bytes.\n","filename":"src\/java.net.http\/share\/classes\/module-info.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n- * @LastModified: June 2025\n+ * @LastModified: May 2025\n@@ -62,3 +62,0 @@\n-    \/**\n-     * Creates a new {@code DocumentBuilderFactory} instance.\n-     *\/\n@@ -66,10 +63,0 @@\n-        this(null, null);\n-    }\n-\n-    \/**\n-     * Creates a new {@code DocumentBuilderFactory} instance with a {@code XMLSecurityManager}\n-     * and {@code XMLSecurityPropertyManager}.\n-     * @param xsm the {@code XMLSecurityManager}\n-     * @param xspm the {@code XMLSecurityPropertyManager}\n-     *\/\n-    public DocumentBuilderFactoryImpl(XMLSecurityManager xsm, XMLSecurityPropertyManager xspm) {\n@@ -78,2 +65,2 @@\n-        fSecurityManager = (xsm == null) ? config.getXMLSecurityManager(true) : xsm;\n-        fSecurityPropertyMgr = (xspm == null) ? config.getXMLSecurityPropertyManager(true) : xspm;\n+        fSecurityManager = config.getXMLSecurityManager(true);\n+        fSecurityPropertyMgr = config.getXMLSecurityPropertyManager(true);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/jaxp\/DocumentBuilderFactoryImpl.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @LastModified: June 2025\n+ * @LastModified: May 2025\n@@ -75,1 +75,0 @@\n-        private XMLSecurityPropertyManager _xmlSecPropMgr;\n@@ -84,1 +83,0 @@\n-            _xmlSecPropMgr = config.getXMLSecurityPropertyManager(true);\n@@ -134,1 +132,1 @@\n-                    !_isNotSecureProcessing, _featureManager, _xmlSecMgr, _xmlSecPropMgr);\n+                    !_isNotSecureProcessing, _featureManager, _xmlSecMgr);\n@@ -188,1 +186,0 @@\n-                    _xmlSecMgr.setSecureProcessing(value);\n@@ -344,1 +341,2 @@\n-        if (JdkXmlUtils.setProperty(_xmlSecMgr, _xmlSecPropMgr, name, value)) {\n+        if (_xmlSecMgr != null &&\n+                _xmlSecMgr.setLimit(name, JdkProperty.State.APIPROPERTY, value)) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xpath\/internal\/jaxp\/XPathFactoryImpl.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import jdk.xml.internal.XMLSecurityPropertyManager;\n@@ -54,1 +53,1 @@\n- * @LastModified: June 2025\n+ * @LastModified: May 2025\n@@ -66,2 +65,1 @@\n-                JdkXmlConfig.getInstance(false).getXMLSecurityManager(false),\n-                JdkXmlConfig.getInstance(false).getXMLSecurityPropertyManager(false));\n+                JdkXmlConfig.getInstance(false).getXMLSecurityManager(false));\n@@ -72,1 +70,1 @@\n-            XMLSecurityManager xmlSecMgr, XMLSecurityPropertyManager xmlSecPropMgr) {\n+            XMLSecurityManager xmlSecMgr) {\n@@ -80,1 +78,0 @@\n-        this.xmlSecPropMgr = xmlSecPropMgr;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xpath\/internal\/jaxp\/XPathImpl.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import javax.xml.XMLConstants;\n@@ -48,1 +47,0 @@\n-import jdk.xml.internal.XMLSecurityPropertyManager;\n@@ -59,1 +57,1 @@\n- * @LastModified: June 2025\n+ * @LastModified: Apr 2025\n@@ -72,1 +70,0 @@\n-    XMLSecurityPropertyManager xmlSecPropMgr;\n@@ -134,6 +131,1 @@\n-            DocumentBuilderFactory dbf = JdkXmlUtils.getDOMFactory(\n-                    overrideDefaultParser, xmlSecMgr, xmlSecPropMgr);\n-            if (xmlSecMgr != null && xmlSecMgr.isSecureProcessingSet()) {\n-                dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING,\n-                        xmlSecMgr.isSecureProcessing());\n-            }\n+            DocumentBuilderFactory dbf = JdkXmlUtils.getDOMFactory(overrideDefaultParser);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xpath\/internal\/jaxp\/XPathImplUtil.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -448,14 +448,0 @@\n-        return getDOMFactory(overrideDefaultParser, null, null);\n-    }\n-\n-    \/**\n-     * {@return a DocumentBuilderFactory instance}\n-     *\n-     * @param overrideDefaultParser a flag indicating whether the system-default\n-     * implementation may be overridden. If the system property of the\n-     * DOM factory ID is set, override is always allowed.\n-     * @param xsm XMLSecurityManager\n-     * @param xspm XMLSecurityPropertyManager\n-     *\/\n-    public static DocumentBuilderFactory getDOMFactory(boolean overrideDefaultParser,\n-            XMLSecurityManager xsm, XMLSecurityPropertyManager xspm) {\n@@ -470,1 +456,1 @@\n-                        ? new DocumentBuilderFactoryImpl(xsm, xspm)\n+                        ? new DocumentBuilderFactoryImpl()\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/JdkXmlUtils.java","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -247,6 +247,0 @@\n-    \/**\n-     * Flag indicating the secure processing is set explicitly through factories'\n-     * setFeature method and then the setSecureProcessing method\n-     *\/\n-    boolean secureProcessingSet;\n-\n@@ -349,1 +343,0 @@\n-        secureProcessingSet = true;\n@@ -368,9 +361,0 @@\n-    \/**\n-     * Returns the state indicating whether the Secure Processing is set explicitly,\n-     * via factories' setFeature and then this class' setSecureProcessing method.\n-     * @return the state indicating whether the Secure Processing is set explicitly\n-     *\/\n-    public boolean isSecureProcessingSet() {\n-        return secureProcessingSet;\n-    }\n-\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/XMLSecurityManager.java","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1,604 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.javac.comp;\n-\n-import java.util.Map;\n-import java.util.Map.Entry;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Set;\n-import com.sun.tools.javac.code.*;\n-import com.sun.tools.javac.tree.*;\n-import com.sun.tools.javac.util.*;\n-\n-import com.sun.tools.javac.code.Symbol.*;\n-import com.sun.tools.javac.tree.JCTree.*;\n-\n-import com.sun.tools.javac.code.Kinds.Kind;\n-import com.sun.tools.javac.code.Type.TypeVar;\n-import java.util.Arrays;\n-import java.util.Iterator;\n-import java.util.function.Predicate;\n-import java.util.stream.Collectors;\n-\n-import static java.util.stream.Collectors.groupingBy;\n-\n-\/** A class to compute exhaustiveness of set of switch cases.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class ExhaustivenessComputer {\n-    protected static final Context.Key<ExhaustivenessComputer> exhaustivenessKey = new Context.Key<>();\n-\n-    private final Symtab syms;\n-    private final Types types;\n-    private final Check chk;\n-    private final Infer infer;\n-\n-    public static ExhaustivenessComputer instance(Context context) {\n-        ExhaustivenessComputer instance = context.get(exhaustivenessKey);\n-        if (instance == null)\n-            instance = new ExhaustivenessComputer(context);\n-        return instance;\n-    }\n-\n-    @SuppressWarnings(\"this-escape\")\n-    protected ExhaustivenessComputer(Context context) {\n-        context.put(exhaustivenessKey, this);\n-        syms = Symtab.instance(context);\n-        types = Types.instance(context);\n-        chk = Check.instance(context);\n-        infer = Infer.instance(context);\n-    }\n-\n-    public boolean exhausts(JCExpression selector, List<JCCase> cases) {\n-        Set<PatternDescription> patternSet = new HashSet<>();\n-        Map<Symbol, Set<Symbol>> enum2Constants = new HashMap<>();\n-        Set<Object> booleanLiterals = new HashSet<>(Set.of(0, 1));\n-        for (JCCase c : cases) {\n-            if (!TreeInfo.unguardedCase(c))\n-                continue;\n-\n-            for (var l : c.labels) {\n-                if (l instanceof JCPatternCaseLabel patternLabel) {\n-                    for (Type component : components(selector.type)) {\n-                        patternSet.add(makePatternDescription(component, patternLabel.pat));\n-                    }\n-                } else if (l instanceof JCConstantCaseLabel constantLabel) {\n-                    if (types.unboxedTypeOrType(selector.type).hasTag(TypeTag.BOOLEAN)) {\n-                        Object value = ((JCLiteral) constantLabel.expr).value;\n-                        booleanLiterals.remove(value);\n-                    } else {\n-                        Symbol s = TreeInfo.symbol(constantLabel.expr);\n-                        if (s != null && s.isEnum()) {\n-                            enum2Constants.computeIfAbsent(s.owner, x -> {\n-                                Set<Symbol> result = new HashSet<>();\n-                                s.owner.members()\n-                                        .getSymbols(sym -> sym.kind == Kind.VAR && sym.isEnum())\n-                                        .forEach(result::add);\n-                                return result;\n-                            }).remove(s);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        if (types.unboxedTypeOrType(selector.type).hasTag(TypeTag.BOOLEAN) && booleanLiterals.isEmpty()) {\n-            return true;\n-        }\n-\n-        for (Entry<Symbol, Set<Symbol>> e : enum2Constants.entrySet()) {\n-            if (e.getValue().isEmpty()) {\n-                patternSet.add(new BindingPattern(e.getKey().type));\n-            }\n-        }\n-        Set<PatternDescription> patterns = patternSet;\n-        boolean useHashes = true;\n-        try {\n-            boolean repeat = true;\n-            while (repeat) {\n-                Set<PatternDescription> updatedPatterns;\n-                updatedPatterns = reduceBindingPatterns(selector.type, patterns);\n-                updatedPatterns = reduceNestedPatterns(updatedPatterns, useHashes);\n-                updatedPatterns = reduceRecordPatterns(updatedPatterns);\n-                updatedPatterns = removeCoveredRecordPatterns(updatedPatterns);\n-                repeat = !updatedPatterns.equals(patterns);\n-                if (checkCovered(selector.type, patterns)) {\n-                    return true;\n-                }\n-                if (!repeat) {\n-                    \/\/there may be situation like:\n-                    \/\/class B permits S1, S2\n-                    \/\/patterns: R(S1, B), R(S2, S2)\n-                    \/\/this might be joined to R(B, S2), as B could be rewritten to S2\n-                    \/\/but hashing in reduceNestedPatterns will not allow that\n-                    \/\/disable the use of hashing, and use subtyping in\n-                    \/\/reduceNestedPatterns to handle situations like this:\n-                    repeat = useHashes;\n-                    useHashes = false;\n-                } else {\n-                    \/\/if a reduction happened, make sure hashing in reduceNestedPatterns\n-                    \/\/is enabled, as the hashing speeds up the process significantly:\n-                    useHashes = true;\n-                }\n-                patterns = updatedPatterns;\n-            }\n-            return checkCovered(selector.type, patterns);\n-        } catch (CompletionFailure cf) {\n-            chk.completionError(selector.pos(), cf);\n-            return true; \/\/error recovery\n-        }\n-    }\n-\n-    private boolean checkCovered(Type seltype, Iterable<PatternDescription> patterns) {\n-        for (Type seltypeComponent : components(seltype)) {\n-            for (PatternDescription pd : patterns) {\n-                if(isBpCovered(seltypeComponent, pd)) {\n-                    return true;\n-                }\n-            }\n-        }\n-        return false;\n-    }\n-\n-    private List<Type> components(Type seltype) {\n-        return switch (seltype.getTag()) {\n-            case CLASS -> {\n-                if (seltype.isCompound()) {\n-                    if (seltype.isIntersection()) {\n-                        yield ((Type.IntersectionClassType) seltype).getComponents()\n-                                                                    .stream()\n-                                                                    .flatMap(t -> components(t).stream())\n-                                                                    .collect(List.collector());\n-                    }\n-                    yield List.nil();\n-                }\n-                yield List.of(types.erasure(seltype));\n-            }\n-            case TYPEVAR -> components(((TypeVar) seltype).getUpperBound());\n-            default -> List.of(types.erasure(seltype));\n-        };\n-    }\n-\n-    \/* In a set of patterns, search for a sub-set of binding patterns that\n-     * in combination exhaust their sealed supertype. If such a sub-set\n-     * is found, it is removed, and replaced with a binding pattern\n-     * for the sealed supertype.\n-     *\/\n-    private Set<PatternDescription> reduceBindingPatterns(Type selectorType, Set<PatternDescription> patterns) {\n-        Set<Symbol> existingBindings = patterns.stream()\n-                                               .filter(pd -> pd instanceof BindingPattern)\n-                                               .map(pd -> ((BindingPattern) pd).type.tsym)\n-                                               .collect(Collectors.toSet());\n-\n-        for (PatternDescription pdOne : patterns) {\n-            if (pdOne instanceof BindingPattern bpOne) {\n-                Set<PatternDescription> toAdd = new HashSet<>();\n-\n-                for (Type sup : types.directSupertypes(bpOne.type)) {\n-                    ClassSymbol clazz = (ClassSymbol) types.erasure(sup).tsym;\n-\n-                    clazz.complete();\n-\n-                    if (clazz.isSealed() && clazz.isAbstract() &&\n-                        \/\/if a binding pattern for clazz already exists, no need to analyze it again:\n-                        !existingBindings.contains(clazz)) {\n-                        ListBuffer<PatternDescription> bindings = new ListBuffer<>();\n-                        \/\/do not reduce to types unrelated to the selector type:\n-                        Type clazzErasure = types.erasure(clazz.type);\n-                        if (components(selectorType).stream()\n-                                                    .map(types::erasure)\n-                                                    .noneMatch(c -> types.isSubtype(clazzErasure, c))) {\n-                            continue;\n-                        }\n-\n-                        Set<Symbol> permitted = allPermittedSubTypes(clazz, csym -> {\n-                            Type instantiated;\n-                            if (csym.type.allparams().isEmpty()) {\n-                                instantiated = csym.type;\n-                            } else {\n-                                instantiated = infer.instantiatePatternType(selectorType, csym);\n-                            }\n-\n-                            return instantiated != null && types.isCastable(selectorType, instantiated);\n-                        });\n-\n-                        for (PatternDescription pdOther : patterns) {\n-                            if (pdOther instanceof BindingPattern bpOther) {\n-                                Set<Symbol> currentPermittedSubTypes =\n-                                        allPermittedSubTypes(bpOther.type.tsym, s -> true);\n-\n-                                PERMITTED: for (Iterator<Symbol> it = permitted.iterator(); it.hasNext();) {\n-                                    Symbol perm = it.next();\n-\n-                                    for (Symbol currentPermitted : currentPermittedSubTypes) {\n-                                        if (types.isSubtype(types.erasure(currentPermitted.type),\n-                                                            types.erasure(perm.type))) {\n-                                            it.remove();\n-                                            continue PERMITTED;\n-                                        }\n-                                    }\n-                                    if (types.isSubtype(types.erasure(perm.type),\n-                                                        types.erasure(bpOther.type))) {\n-                                        it.remove();\n-                                    }\n-                                }\n-                            }\n-                        }\n-\n-                        if (permitted.isEmpty()) {\n-                            toAdd.add(new BindingPattern(clazz.type));\n-                        }\n-                    }\n-                }\n-\n-                if (!toAdd.isEmpty()) {\n-                    Set<PatternDescription> newPatterns = new HashSet<>(patterns);\n-                    newPatterns.addAll(toAdd);\n-                    return newPatterns;\n-                }\n-            }\n-        }\n-        return patterns;\n-    }\n-\n-    private Set<Symbol> allPermittedSubTypes(TypeSymbol root, Predicate<ClassSymbol> accept) {\n-        Set<Symbol> permitted = new HashSet<>();\n-        List<ClassSymbol> permittedSubtypesClosure = baseClasses(root);\n-\n-        while (permittedSubtypesClosure.nonEmpty()) {\n-            ClassSymbol current = permittedSubtypesClosure.head;\n-\n-            permittedSubtypesClosure = permittedSubtypesClosure.tail;\n-\n-            current.complete();\n-\n-            if (current.isSealed() && current.isAbstract()) {\n-                for (Type t : current.getPermittedSubclasses()) {\n-                    ClassSymbol csym = (ClassSymbol) t.tsym;\n-\n-                    if (accept.test(csym)) {\n-                        permittedSubtypesClosure = permittedSubtypesClosure.prepend(csym);\n-                        permitted.add(csym);\n-                    }\n-                }\n-            }\n-        }\n-\n-        return permitted;\n-    }\n-\n-    private List<ClassSymbol> baseClasses(TypeSymbol root) {\n-        if (root instanceof ClassSymbol clazz) {\n-            return List.of(clazz);\n-        } else if (root instanceof TypeVariableSymbol tvar) {\n-            ListBuffer<ClassSymbol> result = new ListBuffer<>();\n-            for (Type bound : tvar.getBounds()) {\n-                result.appendList(baseClasses(bound.tsym));\n-            }\n-            return result.toList();\n-        } else {\n-            return List.nil();\n-        }\n-    }\n-\n-    \/* Among the set of patterns, find sub-set of patterns such:\n-     * $record($prefix$, $nested, $suffix$)\n-     * Where $record, $prefix$ and $suffix$ is the same for each pattern\n-     * in the set, and the patterns only differ in one \"column\" in\n-     * the $nested pattern.\n-     * Then, the set of $nested patterns is taken, and passed recursively\n-     * to reduceNestedPatterns and to reduceBindingPatterns, to\n-     * simplify the pattern. If that succeeds, the original found sub-set\n-     * of patterns is replaced with a new set of patterns of the form:\n-     * $record($prefix$, $resultOfReduction, $suffix$)\n-     *\n-     * useHashes: when true, patterns will be subject to exact equivalence;\n-     *            when false, two binding patterns will be considered equivalent\n-     *            if one of them is more generic than the other one;\n-     *            when false, the processing will be significantly slower,\n-     *            as pattern hashes cannot be used to speed up the matching process\n-     *\/\n-    private Set<PatternDescription> reduceNestedPatterns(Set<PatternDescription> patterns,\n-                                                         boolean useHashes) {\n-        \/* implementation note:\n-         * finding a sub-set of patterns that only differ in a single\n-         * column is time-consuming task, so this method speeds it up by:\n-         * - group the patterns by their record class\n-         * - for each column (nested pattern) do:\n-         * -- group patterns by their hash\n-         * -- in each such by-hash group, find sub-sets that only differ in\n-         *    the chosen column, and then call reduceBindingPatterns and reduceNestedPatterns\n-         *    on patterns in the chosen column, as described above\n-         *\/\n-        var groupByRecordClass =\n-                patterns.stream()\n-                        .filter(pd -> pd instanceof RecordPattern)\n-                        .map(pd -> (RecordPattern) pd)\n-                        .collect(groupingBy(pd -> (ClassSymbol) pd.recordType.tsym));\n-\n-        for (var e : groupByRecordClass.entrySet()) {\n-            int nestedPatternsCount = e.getKey().getRecordComponents().size();\n-            Set<RecordPattern> current = new HashSet<>(e.getValue());\n-\n-            for (int mismatchingCandidate = 0;\n-                 mismatchingCandidate < nestedPatternsCount;\n-                 mismatchingCandidate++) {\n-                int mismatchingCandidateFin = mismatchingCandidate;\n-                var groupEquivalenceCandidates =\n-                        current\n-                         .stream()\n-                         \/\/error recovery, ignore patterns with incorrect number of nested patterns:\n-                         .filter(pd -> pd.nested.length == nestedPatternsCount)\n-                         .collect(groupingBy(pd -> useHashes ? pd.hashCode(mismatchingCandidateFin) : 0));\n-                for (var candidates : groupEquivalenceCandidates.values()) {\n-                    var candidatesArr = candidates.toArray(RecordPattern[]::new);\n-\n-                    for (int firstCandidate = 0;\n-                         firstCandidate < candidatesArr.length;\n-                         firstCandidate++) {\n-                        RecordPattern rpOne = candidatesArr[firstCandidate];\n-                        ListBuffer<RecordPattern> join = new ListBuffer<>();\n-\n-                        join.append(rpOne);\n-\n-                        NEXT_PATTERN: for (int nextCandidate = 0;\n-                                           nextCandidate < candidatesArr.length;\n-                                           nextCandidate++) {\n-                            if (firstCandidate == nextCandidate) {\n-                                continue;\n-                            }\n-\n-                            RecordPattern rpOther = candidatesArr[nextCandidate];\n-                            if (rpOne.recordType.tsym == rpOther.recordType.tsym) {\n-                                for (int i = 0; i < rpOne.nested.length; i++) {\n-                                    if (i != mismatchingCandidate) {\n-                                        if (!rpOne.nested[i].equals(rpOther.nested[i])) {\n-                                            if (useHashes ||\n-                                                \/\/when not using hashes,\n-                                                \/\/check if rpOne.nested[i] is\n-                                                \/\/a subtype of rpOther.nested[i]:\n-                                                !(rpOne.nested[i] instanceof BindingPattern bpOne) ||\n-                                                !(rpOther.nested[i] instanceof BindingPattern bpOther) ||\n-                                                !types.isSubtype(types.erasure(bpOne.type), types.erasure(bpOther.type))) {\n-                                                continue NEXT_PATTERN;\n-                                            }\n-                                        }\n-                                    }\n-                                }\n-                                join.append(rpOther);\n-                            }\n-                        }\n-\n-                        var nestedPatterns = join.stream().map(rp -> rp.nested[mismatchingCandidateFin]).collect(Collectors.toSet());\n-                        var updatedPatterns = reduceNestedPatterns(nestedPatterns, useHashes);\n-\n-                        updatedPatterns = reduceRecordPatterns(updatedPatterns);\n-                        updatedPatterns = removeCoveredRecordPatterns(updatedPatterns);\n-                        updatedPatterns = reduceBindingPatterns(rpOne.fullComponentTypes()[mismatchingCandidateFin], updatedPatterns);\n-\n-                        if (!nestedPatterns.equals(updatedPatterns)) {\n-                            if (useHashes) {\n-                                current.removeAll(join);\n-                            }\n-\n-                            for (PatternDescription nested : updatedPatterns) {\n-                                PatternDescription[] newNested =\n-                                        Arrays.copyOf(rpOne.nested, rpOne.nested.length);\n-                                newNested[mismatchingCandidateFin] = nested;\n-                                current.add(new RecordPattern(rpOne.recordType(),\n-                                                                rpOne.fullComponentTypes(),\n-                                                                newNested));\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-\n-            if (!current.equals(new HashSet<>(e.getValue()))) {\n-                Set<PatternDescription> result = new HashSet<>(patterns);\n-                result.removeAll(e.getValue());\n-                result.addAll(current);\n-                return result;\n-            }\n-        }\n-        return patterns;\n-    }\n-\n-    \/* In the set of patterns, find those for which, given:\n-     * $record($nested1, $nested2, ...)\n-     * all the $nestedX pattern cover the given record component,\n-     * and replace those with a simple binding pattern over $record.\n-     *\/\n-    private Set<PatternDescription> reduceRecordPatterns(Set<PatternDescription> patterns) {\n-        var newPatterns = new HashSet<PatternDescription>();\n-        boolean modified = false;\n-        for (PatternDescription pd : patterns) {\n-            if (pd instanceof RecordPattern rpOne) {\n-                PatternDescription reducedPattern = reduceRecordPattern(rpOne);\n-                if (reducedPattern != rpOne) {\n-                    newPatterns.add(reducedPattern);\n-                    modified = true;\n-                    continue;\n-                }\n-            }\n-            newPatterns.add(pd);\n-        }\n-        return modified ? newPatterns : patterns;\n-    }\n-\n-    private PatternDescription reduceRecordPattern(PatternDescription pattern) {\n-        if (pattern instanceof RecordPattern rpOne) {\n-            Type[] componentType = rpOne.fullComponentTypes();\n-            \/\/error recovery, ignore patterns with incorrect number of nested patterns:\n-            if (componentType.length != rpOne.nested.length) {\n-                return pattern;\n-            }\n-            PatternDescription[] reducedNestedPatterns = null;\n-            boolean covered = true;\n-            for (int i = 0; i < componentType.length; i++) {\n-                PatternDescription newNested = reduceRecordPattern(rpOne.nested[i]);\n-                if (newNested != rpOne.nested[i]) {\n-                    if (reducedNestedPatterns == null) {\n-                        reducedNestedPatterns = Arrays.copyOf(rpOne.nested, rpOne.nested.length);\n-                    }\n-                    reducedNestedPatterns[i] = newNested;\n-                }\n-\n-                covered &= checkCovered(componentType[i], List.of(newNested));\n-            }\n-            if (covered) {\n-                return new BindingPattern(rpOne.recordType);\n-            } else if (reducedNestedPatterns != null) {\n-                return new RecordPattern(rpOne.recordType, rpOne.fullComponentTypes(), reducedNestedPatterns);\n-            }\n-        }\n-        return pattern;\n-    }\n-\n-    private Set<PatternDescription> removeCoveredRecordPatterns(Set<PatternDescription> patterns) {\n-        Set<Symbol> existingBindings = patterns.stream()\n-                                               .filter(pd -> pd instanceof BindingPattern)\n-                                               .map(pd -> ((BindingPattern) pd).type.tsym)\n-                                               .collect(Collectors.toSet());\n-        Set<PatternDescription> result = new HashSet<>(patterns);\n-\n-        for (Iterator<PatternDescription> it = result.iterator(); it.hasNext();) {\n-            PatternDescription pd = it.next();\n-            if (pd instanceof RecordPattern rp && existingBindings.contains(rp.recordType.tsym)) {\n-                it.remove();\n-            }\n-        }\n-\n-        return result;\n-    }\n-\n-    private boolean isBpCovered(Type componentType, PatternDescription newNested) {\n-        if (newNested instanceof BindingPattern bp) {\n-            Type seltype = types.erasure(componentType);\n-            Type pattype = types.erasure(bp.type);\n-\n-            return seltype.isPrimitive() ?\n-                    types.isUnconditionallyExact(seltype, pattype) :\n-                    (bp.type.isPrimitive() && types.isUnconditionallyExact(types.unboxedType(seltype), bp.type)) || types.isSubtype(seltype, pattype);\n-        }\n-        return false;\n-    }\n-\n-    sealed interface PatternDescription { }\n-    public PatternDescription makePatternDescription(Type selectorType, JCPattern pattern) {\n-        if (pattern instanceof JCBindingPattern binding) {\n-            Type type = !selectorType.isPrimitive() && types.isSubtype(selectorType, binding.type)\n-                    ? selectorType : binding.type;\n-            return new BindingPattern(type);\n-        } else if (pattern instanceof JCRecordPattern record) {\n-            Type[] componentTypes;\n-\n-            if (!record.type.isErroneous()) {\n-                componentTypes = ((ClassSymbol) record.type.tsym).getRecordComponents()\n-                        .map(r -> types.memberType(record.type, r))\n-                        .toArray(s -> new Type[s]);\n-            }\n-            else {\n-                componentTypes = record.nested.map(t -> types.createErrorType(t.type)).toArray(s -> new Type[s]);;\n-            }\n-\n-            PatternDescription[] nestedDescriptions =\n-                    new PatternDescription[record.nested.size()];\n-            int i = 0;\n-            for (List<JCPattern> it = record.nested;\n-                 it.nonEmpty();\n-                 it = it.tail, i++) {\n-                Type componentType = i < componentTypes.length ? componentTypes[i]\n-                                                               : syms.errType;\n-                nestedDescriptions[i] = makePatternDescription(types.erasure(componentType), it.head);\n-            }\n-            return new RecordPattern(record.type, componentTypes, nestedDescriptions);\n-        } else if (pattern instanceof JCAnyPattern) {\n-            return new BindingPattern(selectorType);\n-        } else {\n-            throw Assert.error();\n-        }\n-    }\n-    record BindingPattern(Type type) implements PatternDescription {\n-        @Override\n-        public int hashCode() {\n-            return type.tsym.hashCode();\n-        }\n-        @Override\n-        public boolean equals(Object o) {\n-            return o instanceof BindingPattern other &&\n-                    type.tsym == other.type.tsym;\n-        }\n-        @Override\n-        public String toString() {\n-            return type.tsym + \" _\";\n-        }\n-    }\n-    record RecordPattern(Type recordType, int _hashCode, Type[] fullComponentTypes, PatternDescription... nested) implements PatternDescription {\n-\n-        public RecordPattern(Type recordType, Type[] fullComponentTypes, PatternDescription[] nested) {\n-            this(recordType, hashCode(-1, recordType, nested), fullComponentTypes, nested);\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return _hashCode;\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            return o instanceof RecordPattern other &&\n-                    recordType.tsym == other.recordType.tsym &&\n-                    Arrays.equals(nested, other.nested);\n-        }\n-\n-        public int hashCode(int excludeComponent) {\n-            return hashCode(excludeComponent, recordType, nested);\n-        }\n-\n-        public static int hashCode(int excludeComponent, Type recordType, PatternDescription... nested) {\n-            int hash = 5;\n-            hash =  41 * hash + recordType.tsym.hashCode();\n-            for (int  i = 0; i < nested.length; i++) {\n-                if (i != excludeComponent) {\n-                    hash = 41 * hash + nested[i].hashCode();\n-                }\n-            }\n-            return hash;\n-        }\n-        @Override\n-        public String toString() {\n-            return recordType.tsym + \"(\" + Arrays.stream(nested)\n-                    .map(pd -> pd.toString())\n-                    .collect(Collectors.joining(\", \")) + \")\";\n-        }\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ExhaustivenessComputer.java","additions":0,"deletions":604,"binary":false,"changes":604,"status":"deleted"},{"patch":"@@ -30,0 +30,2 @@\n+import java.util.Map;\n+import java.util.Map.Entry;\n@@ -31,0 +33,2 @@\n+import java.util.HashSet;\n+import java.util.Set;\n@@ -50,0 +54,1 @@\n+import com.sun.tools.javac.code.Kinds.Kind;\n@@ -51,0 +56,1 @@\n+import com.sun.tools.javac.code.Type.TypeVar;\n@@ -56,0 +62,6 @@\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import static java.util.stream.Collectors.groupingBy;\n@@ -204,1 +216,0 @@\n-    private final ExhaustivenessComputer exhaustiveness;\n@@ -206,0 +217,1 @@\n+    private final Infer infer;\n@@ -327,0 +339,1 @@\n+        infer = Infer.instance(context);\n@@ -329,1 +342,1 @@\n-        exhaustiveness = ExhaustivenessComputer.instance(context);\n+        Source source = Source.instance(context);\n@@ -699,1 +712,1 @@\n-                tree.isExhaustive |= exhaustiveness.exhausts(tree.selector, tree.cases);\n+                tree.isExhaustive |= exhausts(tree.selector, tree.cases);\n@@ -738,1 +751,1 @@\n-                tree.isExhaustive = exhaustiveness.exhausts(tree.selector, tree.cases);\n+                tree.isExhaustive = exhausts(tree.selector, tree.cases);\n@@ -748,0 +761,423 @@\n+        private boolean exhausts(JCExpression selector, List<JCCase> cases) {\n+            Set<PatternDescription> patternSet = new HashSet<>();\n+            Map<Symbol, Set<Symbol>> enum2Constants = new HashMap<>();\n+            Set<Object> booleanLiterals = new HashSet<>(Set.of(0, 1));\n+            for (JCCase c : cases) {\n+                if (!TreeInfo.unguardedCase(c))\n+                    continue;\n+\n+                for (var l : c.labels) {\n+                    if (l instanceof JCPatternCaseLabel patternLabel) {\n+                        for (Type component : components(selector.type)) {\n+                            patternSet.add(makePatternDescription(component, patternLabel.pat));\n+                        }\n+                    } else if (l instanceof JCConstantCaseLabel constantLabel) {\n+                        if (types.unboxedTypeOrType(selector.type).hasTag(TypeTag.BOOLEAN)) {\n+                            Object value = ((JCLiteral) constantLabel.expr).value;\n+                            booleanLiterals.remove(value);\n+                        } else {\n+                            Symbol s = TreeInfo.symbol(constantLabel.expr);\n+                            if (s != null && s.isEnum()) {\n+                                enum2Constants.computeIfAbsent(s.owner, x -> {\n+                                    Set<Symbol> result = new HashSet<>();\n+                                    s.owner.members()\n+                                            .getSymbols(sym -> sym.kind == Kind.VAR && sym.isEnum())\n+                                            .forEach(result::add);\n+                                    return result;\n+                                }).remove(s);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (types.unboxedTypeOrType(selector.type).hasTag(TypeTag.BOOLEAN) && booleanLiterals.isEmpty()) {\n+                return true;\n+            }\n+\n+            for (Entry<Symbol, Set<Symbol>> e : enum2Constants.entrySet()) {\n+                if (e.getValue().isEmpty()) {\n+                    patternSet.add(new BindingPattern(e.getKey().type));\n+                }\n+            }\n+            Set<PatternDescription> patterns = patternSet;\n+            boolean useHashes = true;\n+            try {\n+                boolean repeat = true;\n+                while (repeat) {\n+                    Set<PatternDescription> updatedPatterns;\n+                    updatedPatterns = reduceBindingPatterns(selector.type, patterns);\n+                    updatedPatterns = reduceNestedPatterns(updatedPatterns, useHashes);\n+                    updatedPatterns = reduceRecordPatterns(updatedPatterns);\n+                    updatedPatterns = removeCoveredRecordPatterns(updatedPatterns);\n+                    repeat = !updatedPatterns.equals(patterns);\n+                    if (checkCovered(selector.type, patterns)) {\n+                        return true;\n+                    }\n+                    if (!repeat) {\n+                        \/\/there may be situation like:\n+                        \/\/class B permits S1, S2\n+                        \/\/patterns: R(S1, B), R(S2, S2)\n+                        \/\/this might be joined to R(B, S2), as B could be rewritten to S2\n+                        \/\/but hashing in reduceNestedPatterns will not allow that\n+                        \/\/disable the use of hashing, and use subtyping in\n+                        \/\/reduceNestedPatterns to handle situations like this:\n+                        repeat = useHashes;\n+                        useHashes = false;\n+                    } else {\n+                        \/\/if a reduction happened, make sure hashing in reduceNestedPatterns\n+                        \/\/is enabled, as the hashing speeds up the process significantly:\n+                        useHashes = true;\n+                    }\n+                    patterns = updatedPatterns;\n+                }\n+                return checkCovered(selector.type, patterns);\n+            } catch (CompletionFailure cf) {\n+                chk.completionError(selector.pos(), cf);\n+                return true; \/\/error recovery\n+            }\n+        }\n+\n+        private boolean checkCovered(Type seltype, Iterable<PatternDescription> patterns) {\n+            for (Type seltypeComponent : components(seltype)) {\n+                for (PatternDescription pd : patterns) {\n+                    if(isBpCovered(seltypeComponent, pd)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n+        private List<Type> components(Type seltype) {\n+            return switch (seltype.getTag()) {\n+                case CLASS -> {\n+                    if (seltype.isCompound()) {\n+                        if (seltype.isIntersection()) {\n+                            yield ((Type.IntersectionClassType) seltype).getComponents()\n+                                                                        .stream()\n+                                                                        .flatMap(t -> components(t).stream())\n+                                                                        .collect(List.collector());\n+                        }\n+                        yield List.nil();\n+                    }\n+                    yield List.of(types.erasure(seltype));\n+                }\n+                case TYPEVAR -> components(((TypeVar) seltype).getUpperBound());\n+                default -> List.of(types.erasure(seltype));\n+            };\n+        }\n+\n+        \/* In a set of patterns, search for a sub-set of binding patterns that\n+         * in combination exhaust their sealed supertype. If such a sub-set\n+         * is found, it is removed, and replaced with a binding pattern\n+         * for the sealed supertype.\n+         *\/\n+        private Set<PatternDescription> reduceBindingPatterns(Type selectorType, Set<PatternDescription> patterns) {\n+            Set<Symbol> existingBindings = patterns.stream()\n+                                                   .filter(pd -> pd instanceof BindingPattern)\n+                                                   .map(pd -> ((BindingPattern) pd).type.tsym)\n+                                                   .collect(Collectors.toSet());\n+\n+            for (PatternDescription pdOne : patterns) {\n+                if (pdOne instanceof BindingPattern bpOne) {\n+                    Set<PatternDescription> toAdd = new HashSet<>();\n+\n+                    for (Type sup : types.directSupertypes(bpOne.type)) {\n+                        ClassSymbol clazz = (ClassSymbol) types.erasure(sup).tsym;\n+\n+                        clazz.complete();\n+\n+                        if (clazz.isSealed() && clazz.isAbstract() &&\n+                            \/\/if a binding pattern for clazz already exists, no need to analyze it again:\n+                            !existingBindings.contains(clazz)) {\n+                            ListBuffer<PatternDescription> bindings = new ListBuffer<>();\n+                            \/\/do not reduce to types unrelated to the selector type:\n+                            Type clazzErasure = types.erasure(clazz.type);\n+                            if (components(selectorType).stream()\n+                                                        .map(types::erasure)\n+                                                        .noneMatch(c -> types.isSubtype(clazzErasure, c))) {\n+                                continue;\n+                            }\n+\n+                            Set<Symbol> permitted = allPermittedSubTypes(clazz, csym -> {\n+                                Type instantiated;\n+                                if (csym.type.allparams().isEmpty()) {\n+                                    instantiated = csym.type;\n+                                } else {\n+                                    instantiated = infer.instantiatePatternType(selectorType, csym);\n+                                }\n+\n+                                return instantiated != null && types.isCastable(selectorType, instantiated);\n+                            });\n+\n+                            for (PatternDescription pdOther : patterns) {\n+                                if (pdOther instanceof BindingPattern bpOther) {\n+                                    Set<Symbol> currentPermittedSubTypes =\n+                                            allPermittedSubTypes(bpOther.type.tsym, s -> true);\n+\n+                                    PERMITTED: for (Iterator<Symbol> it = permitted.iterator(); it.hasNext();) {\n+                                        Symbol perm = it.next();\n+\n+                                        for (Symbol currentPermitted : currentPermittedSubTypes) {\n+                                            if (types.isSubtype(types.erasure(currentPermitted.type),\n+                                                                types.erasure(perm.type))) {\n+                                                it.remove();\n+                                                continue PERMITTED;\n+                                            }\n+                                        }\n+                                        if (types.isSubtype(types.erasure(perm.type),\n+                                                            types.erasure(bpOther.type))) {\n+                                            it.remove();\n+                                        }\n+                                    }\n+                                }\n+                            }\n+\n+                            if (permitted.isEmpty()) {\n+                                toAdd.add(new BindingPattern(clazz.type));\n+                            }\n+                        }\n+                    }\n+\n+                    if (!toAdd.isEmpty()) {\n+                        Set<PatternDescription> newPatterns = new HashSet<>(patterns);\n+                        newPatterns.addAll(toAdd);\n+                        return newPatterns;\n+                    }\n+                }\n+            }\n+            return patterns;\n+        }\n+\n+        private Set<Symbol> allPermittedSubTypes(TypeSymbol root, Predicate<ClassSymbol> accept) {\n+            Set<Symbol> permitted = new HashSet<>();\n+            List<ClassSymbol> permittedSubtypesClosure = baseClasses(root);\n+\n+            while (permittedSubtypesClosure.nonEmpty()) {\n+                ClassSymbol current = permittedSubtypesClosure.head;\n+\n+                permittedSubtypesClosure = permittedSubtypesClosure.tail;\n+\n+                current.complete();\n+\n+                if (current.isSealed() && current.isAbstract()) {\n+                    for (Type t : current.getPermittedSubclasses()) {\n+                        ClassSymbol csym = (ClassSymbol) t.tsym;\n+\n+                        if (accept.test(csym)) {\n+                            permittedSubtypesClosure = permittedSubtypesClosure.prepend(csym);\n+                            permitted.add(csym);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            return permitted;\n+        }\n+\n+        private List<ClassSymbol> baseClasses(TypeSymbol root) {\n+            if (root instanceof ClassSymbol clazz) {\n+                return List.of(clazz);\n+            } else if (root instanceof TypeVariableSymbol tvar) {\n+                ListBuffer<ClassSymbol> result = new ListBuffer<>();\n+                for (Type bound : tvar.getBounds()) {\n+                    result.appendList(baseClasses(bound.tsym));\n+                }\n+                return result.toList();\n+            } else {\n+                return List.nil();\n+            }\n+        }\n+\n+        \/* Among the set of patterns, find sub-set of patterns such:\n+         * $record($prefix$, $nested, $suffix$)\n+         * Where $record, $prefix$ and $suffix$ is the same for each pattern\n+         * in the set, and the patterns only differ in one \"column\" in\n+         * the $nested pattern.\n+         * Then, the set of $nested patterns is taken, and passed recursively\n+         * to reduceNestedPatterns and to reduceBindingPatterns, to\n+         * simplify the pattern. If that succeeds, the original found sub-set\n+         * of patterns is replaced with a new set of patterns of the form:\n+         * $record($prefix$, $resultOfReduction, $suffix$)\n+         *\n+         * useHashes: when true, patterns will be subject to exact equivalence;\n+         *            when false, two binding patterns will be considered equivalent\n+         *            if one of them is more generic than the other one;\n+         *            when false, the processing will be significantly slower,\n+         *            as pattern hashes cannot be used to speed up the matching process\n+         *\/\n+        private Set<PatternDescription> reduceNestedPatterns(Set<PatternDescription> patterns,\n+                                                             boolean useHashes) {\n+            \/* implementation note:\n+             * finding a sub-set of patterns that only differ in a single\n+             * column is time-consuming task, so this method speeds it up by:\n+             * - group the patterns by their record class\n+             * - for each column (nested pattern) do:\n+             * -- group patterns by their hash\n+             * -- in each such by-hash group, find sub-sets that only differ in\n+             *    the chosen column, and then call reduceBindingPatterns and reduceNestedPatterns\n+             *    on patterns in the chosen column, as described above\n+             *\/\n+            var groupByRecordClass =\n+                    patterns.stream()\n+                            .filter(pd -> pd instanceof RecordPattern)\n+                            .map(pd -> (RecordPattern) pd)\n+                            .collect(groupingBy(pd -> (ClassSymbol) pd.recordType.tsym));\n+\n+            for (var e : groupByRecordClass.entrySet()) {\n+                int nestedPatternsCount = e.getKey().getRecordComponents().size();\n+                Set<RecordPattern> current = new HashSet<>(e.getValue());\n+\n+                for (int mismatchingCandidate = 0;\n+                     mismatchingCandidate < nestedPatternsCount;\n+                     mismatchingCandidate++) {\n+                    int mismatchingCandidateFin = mismatchingCandidate;\n+                    var groupEquivalenceCandidates =\n+                            current\n+                             .stream()\n+                             \/\/error recovery, ignore patterns with incorrect number of nested patterns:\n+                             .filter(pd -> pd.nested.length == nestedPatternsCount)\n+                             .collect(groupingBy(pd -> useHashes ? pd.hashCode(mismatchingCandidateFin) : 0));\n+                    for (var candidates : groupEquivalenceCandidates.values()) {\n+                        var candidatesArr = candidates.toArray(RecordPattern[]::new);\n+\n+                        for (int firstCandidate = 0;\n+                             firstCandidate < candidatesArr.length;\n+                             firstCandidate++) {\n+                            RecordPattern rpOne = candidatesArr[firstCandidate];\n+                            ListBuffer<RecordPattern> join = new ListBuffer<>();\n+\n+                            join.append(rpOne);\n+\n+                            NEXT_PATTERN: for (int nextCandidate = 0;\n+                                               nextCandidate < candidatesArr.length;\n+                                               nextCandidate++) {\n+                                if (firstCandidate == nextCandidate) {\n+                                    continue;\n+                                }\n+\n+                                RecordPattern rpOther = candidatesArr[nextCandidate];\n+                                if (rpOne.recordType.tsym == rpOther.recordType.tsym) {\n+                                    for (int i = 0; i < rpOne.nested.length; i++) {\n+                                        if (i != mismatchingCandidate) {\n+                                            if (!rpOne.nested[i].equals(rpOther.nested[i])) {\n+                                                if (useHashes ||\n+                                                    \/\/when not using hashes,\n+                                                    \/\/check if rpOne.nested[i] is\n+                                                    \/\/a subtype of rpOther.nested[i]:\n+                                                    !(rpOne.nested[i] instanceof BindingPattern bpOne) ||\n+                                                    !(rpOther.nested[i] instanceof BindingPattern bpOther) ||\n+                                                    !types.isSubtype(types.erasure(bpOne.type), types.erasure(bpOther.type))) {\n+                                                    continue NEXT_PATTERN;\n+                                                }\n+                                            }\n+                                        }\n+                                    }\n+                                    join.append(rpOther);\n+                                }\n+                            }\n+\n+                            var nestedPatterns = join.stream().map(rp -> rp.nested[mismatchingCandidateFin]).collect(Collectors.toSet());\n+                            var updatedPatterns = reduceNestedPatterns(nestedPatterns, useHashes);\n+\n+                            updatedPatterns = reduceRecordPatterns(updatedPatterns);\n+                            updatedPatterns = removeCoveredRecordPatterns(updatedPatterns);\n+                            updatedPatterns = reduceBindingPatterns(rpOne.fullComponentTypes()[mismatchingCandidateFin], updatedPatterns);\n+\n+                            if (!nestedPatterns.equals(updatedPatterns)) {\n+                                if (useHashes) {\n+                                    current.removeAll(join);\n+                                }\n+\n+                                for (PatternDescription nested : updatedPatterns) {\n+                                    PatternDescription[] newNested =\n+                                            Arrays.copyOf(rpOne.nested, rpOne.nested.length);\n+                                    newNested[mismatchingCandidateFin] = nested;\n+                                    current.add(new RecordPattern(rpOne.recordType(),\n+                                                                    rpOne.fullComponentTypes(),\n+                                                                    newNested));\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                if (!current.equals(new HashSet<>(e.getValue()))) {\n+                    Set<PatternDescription> result = new HashSet<>(patterns);\n+                    result.removeAll(e.getValue());\n+                    result.addAll(current);\n+                    return result;\n+                }\n+            }\n+            return patterns;\n+        }\n+\n+        \/* In the set of patterns, find those for which, given:\n+         * $record($nested1, $nested2, ...)\n+         * all the $nestedX pattern cover the given record component,\n+         * and replace those with a simple binding pattern over $record.\n+         *\/\n+        private Set<PatternDescription> reduceRecordPatterns(Set<PatternDescription> patterns) {\n+            var newPatterns = new HashSet<PatternDescription>();\n+            boolean modified = false;\n+            for (PatternDescription pd : patterns) {\n+                if (pd instanceof RecordPattern rpOne) {\n+                    PatternDescription reducedPattern = reduceRecordPattern(rpOne);\n+                    if (reducedPattern != rpOne) {\n+                        newPatterns.add(reducedPattern);\n+                        modified = true;\n+                        continue;\n+                    }\n+                }\n+                newPatterns.add(pd);\n+            }\n+            return modified ? newPatterns : patterns;\n+        }\n+\n+        private PatternDescription reduceRecordPattern(PatternDescription pattern) {\n+            if (pattern instanceof RecordPattern rpOne) {\n+                Type[] componentType = rpOne.fullComponentTypes();\n+                \/\/error recovery, ignore patterns with incorrect number of nested patterns:\n+                if (componentType.length != rpOne.nested.length) {\n+                    return pattern;\n+                }\n+                PatternDescription[] reducedNestedPatterns = null;\n+                boolean covered = true;\n+                for (int i = 0; i < componentType.length; i++) {\n+                    PatternDescription newNested = reduceRecordPattern(rpOne.nested[i]);\n+                    if (newNested != rpOne.nested[i]) {\n+                        if (reducedNestedPatterns == null) {\n+                            reducedNestedPatterns = Arrays.copyOf(rpOne.nested, rpOne.nested.length);\n+                        }\n+                        reducedNestedPatterns[i] = newNested;\n+                    }\n+\n+                    covered &= checkCovered(componentType[i], List.of(newNested));\n+                }\n+                if (covered) {\n+                    return new BindingPattern(rpOne.recordType);\n+                } else if (reducedNestedPatterns != null) {\n+                    return new RecordPattern(rpOne.recordType, rpOne.fullComponentTypes(), reducedNestedPatterns);\n+                }\n+            }\n+            return pattern;\n+        }\n+\n+        private Set<PatternDescription> removeCoveredRecordPatterns(Set<PatternDescription> patterns) {\n+            Set<Symbol> existingBindings = patterns.stream()\n+                                                   .filter(pd -> pd instanceof BindingPattern)\n+                                                   .map(pd -> ((BindingPattern) pd).type.tsym)\n+                                                   .collect(Collectors.toSet());\n+            Set<PatternDescription> result = new HashSet<>(patterns);\n+\n+            for (Iterator<PatternDescription> it = result.iterator(); it.hasNext();) {\n+                PatternDescription pd = it.next();\n+                if (pd instanceof RecordPattern rp && existingBindings.contains(rp.recordType.tsym)) {\n+                    it.remove();\n+                }\n+            }\n+\n+            return result;\n+        }\n+\n@@ -893,0 +1329,12 @@\n+    private boolean isBpCovered(Type componentType, PatternDescription newNested) {\n+        if (newNested instanceof BindingPattern bp) {\n+            Type seltype = types.erasure(componentType);\n+            Type pattype = types.erasure(bp.type);\n+\n+            return seltype.isPrimitive() ?\n+                    types.isUnconditionallyExact(seltype, pattype) :\n+                    (bp.type.isPrimitive() && types.isUnconditionallyExact(types.unboxedType(seltype), bp.type)) || types.isSubtype(seltype, pattype);\n+        }\n+        return false;\n+    }\n+\n@@ -3028,0 +3476,89 @@\n+    sealed interface PatternDescription { }\n+    public PatternDescription makePatternDescription(Type selectorType, JCPattern pattern) {\n+        if (pattern instanceof JCBindingPattern binding) {\n+            Type type = !selectorType.isPrimitive() && types.isSubtype(selectorType, binding.type)\n+                    ? selectorType : binding.type;\n+            return new BindingPattern(type);\n+        } else if (pattern instanceof JCRecordPattern record) {\n+            Type[] componentTypes;\n+\n+            if (!record.type.isErroneous()) {\n+                componentTypes = ((ClassSymbol) record.type.tsym).getRecordComponents()\n+                        .map(r -> types.memberType(record.type, r))\n+                        .toArray(s -> new Type[s]);\n+            }\n+            else {\n+                componentTypes = record.nested.map(t -> types.createErrorType(t.type)).toArray(s -> new Type[s]);;\n+            }\n+\n+            PatternDescription[] nestedDescriptions =\n+                    new PatternDescription[record.nested.size()];\n+            int i = 0;\n+            for (List<JCPattern> it = record.nested;\n+                 it.nonEmpty();\n+                 it = it.tail, i++) {\n+                Type componentType = i < componentTypes.length ? componentTypes[i]\n+                                                               : syms.errType;\n+                nestedDescriptions[i] = makePatternDescription(types.erasure(componentType), it.head);\n+            }\n+            return new RecordPattern(record.type, componentTypes, nestedDescriptions);\n+        } else if (pattern instanceof JCAnyPattern) {\n+            return new BindingPattern(selectorType);\n+        } else {\n+            throw Assert.error();\n+        }\n+    }\n+    record BindingPattern(Type type) implements PatternDescription {\n+        @Override\n+        public int hashCode() {\n+            return type.tsym.hashCode();\n+        }\n+        @Override\n+        public boolean equals(Object o) {\n+            return o instanceof BindingPattern other &&\n+                    type.tsym == other.type.tsym;\n+        }\n+        @Override\n+        public String toString() {\n+            return type.tsym + \" _\";\n+        }\n+    }\n+    record RecordPattern(Type recordType, int _hashCode, Type[] fullComponentTypes, PatternDescription... nested) implements PatternDescription {\n+\n+        public RecordPattern(Type recordType, Type[] fullComponentTypes, PatternDescription[] nested) {\n+            this(recordType, hashCode(-1, recordType, nested), fullComponentTypes, nested);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return _hashCode;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            return o instanceof RecordPattern other &&\n+                    recordType.tsym == other.recordType.tsym &&\n+                    Arrays.equals(nested, other.nested);\n+        }\n+\n+        public int hashCode(int excludeComponent) {\n+            return hashCode(excludeComponent, recordType, nested);\n+        }\n+\n+        public static int hashCode(int excludeComponent, Type recordType, PatternDescription... nested) {\n+            int hash = 5;\n+            hash =  41 * hash + recordType.tsym.hashCode();\n+            for (int  i = 0; i < nested.length; i++) {\n+                if (i != excludeComponent) {\n+                    hash = 41 * hash + nested[i].hashCode();\n+                }\n+            }\n+            return hash;\n+        }\n+        @Override\n+        public String toString() {\n+            return recordType.tsym + \"(\" + Arrays.stream(nested)\n+                    .map(pd -> pd.toString())\n+                    .collect(Collectors.joining(\", \")) + \")\";\n+        }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":541,"deletions":4,"binary":false,"changes":545,"status":"modified"},{"patch":"@@ -183,2 +183,0 @@\n-  public boolean isContinuationStub()   { return getName().equals(\"StubRoutines (continuation stubs)\"); }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/CodeBlob.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,63 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2025, NTT DATA.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.runtime;\n-\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.types.*;\n-\n-\n-public class ContinuationEntry extends VMObject {\n-    private static long size;\n-    private static Address returnPC;\n-\n-    static {\n-        VM.registerVMInitializedObserver((o, d) -> initialize(VM.getVM().getTypeDataBase()));\n-    }\n-\n-    private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-        Type type = db.lookupType(\"ContinuationEntry\");\n-        size = type.getSize();\n-        returnPC = type.getAddressField(\"_return_pc\").getValue();\n-    }\n-\n-    public ContinuationEntry(Address addr) {\n-        super(addr);\n-    }\n-\n-    public Address getEntryPC() {\n-        return returnPC;\n-    }\n-\n-    public Address getEntrySP(){\n-        return this.getAddress();\n-    }\n-\n-    public Address getEntryFP(){\n-        return this.getAddress().addOffsetTo(size);\n-    }\n-\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ContinuationEntry.java","additions":0,"deletions":63,"binary":false,"changes":63,"status":"deleted"},{"patch":"@@ -50,1 +50,0 @@\n-  private static AddressField  contEntryField;\n@@ -99,1 +98,0 @@\n-    contEntryField    = type.getAddressField(\"_cont_entry\");\n@@ -345,4 +343,0 @@\n-  public ContinuationEntry getContEntry() {\n-      return VMObjectFactory.newObject(ContinuationEntry.class, contEntryField.getValue(addr));\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/JavaThread.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -273,7 +273,1 @@\n-      if (cb.isUpcallStub()) {\n-        return senderForUpcallStub(map, (UpcallStub)cb);\n-      } else if (cb.isContinuationStub()) {\n-        return senderForContinuationStub(map, cb);\n-      } else {\n-        return senderForCompiledFrame(map, cb);\n-      }\n+      return cb.isUpcallStub() ? senderForUpcallStub(map, (UpcallStub)cb) : senderForCompiledFrame(map, cb);\n@@ -365,10 +359,0 @@\n-  private Frame senderForContinuationStub(AARCH64RegisterMap map, CodeBlob cb) {\n-    var contEntry = map.getThread().getContEntry();\n-\n-    Address senderSP = contEntry.getEntrySP();\n-    Address senderPC = contEntry.getEntryPC();\n-    Address senderFP = contEntry.getEntryFP();\n-\n-    return new AARCH64Frame(senderSP, senderFP, senderPC);\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/aarch64\/AARCH64Frame.java","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -261,7 +261,1 @@\n-      if (cb.isUpcallStub()) {\n-        return senderForUpcallStub(map, (UpcallStub)cb);\n-      } else if (cb.isContinuationStub()) {\n-        return senderForContinuationStub(map, cb);\n-      } else {\n-        return senderForCompiledFrame(map, cb);\n-      }\n+      return cb.isUpcallStub() ? senderForUpcallStub(map, (UpcallStub)cb) : senderForCompiledFrame(map, cb);\n@@ -340,9 +334,0 @@\n-  private Frame senderForContinuationStub(PPC64RegisterMap map, CodeBlob cb) {\n-    var contEntry = map.getThread().getContEntry();\n-\n-    Address sp = contEntry.getEntrySP();\n-    Address pc = contEntry.getEntryPC();\n-    Address fp = contEntry.getEntryFP();\n-\n-    return new PPC64Frame(sp, fp, pc);\n-  }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ppc64\/PPC64Frame.java","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -265,7 +265,1 @@\n-      if (cb.isUpcallStub()) {\n-        return senderForUpcallStub(map, (UpcallStub)cb);\n-      } else if (cb.isContinuationStub()) {\n-        return senderForContinuationStub(map, cb);\n-      } else {\n-        return senderForCompiledFrame(map, cb);\n-      }\n+      return cb.isUpcallStub() ? senderForUpcallStub(map, (UpcallStub)cb) : senderForCompiledFrame(map, cb);\n@@ -357,10 +351,0 @@\n-  private Frame senderForContinuationStub(RISCV64RegisterMap map, CodeBlob cb) {\n-    var contEntry = map.getThread().getContEntry();\n-\n-    Address senderSP = contEntry.getEntrySP();\n-    Address senderPC = contEntry.getEntryPC();\n-    Address senderFP = contEntry.getEntryFP();\n-\n-    return new RISCV64Frame(senderSP, senderFP, senderPC);\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/riscv64\/RISCV64Frame.java","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -273,7 +273,1 @@\n-      if (cb.isUpcallStub()) {\n-        return senderForUpcallStub(map, (UpcallStub)cb);\n-      } else if (cb.isContinuationStub()) {\n-        return senderForContinuationStub(map, cb);\n-      } else {\n-        return senderForCompiledFrame(map, cb);\n-      }\n+      return cb.isUpcallStub() ? senderForUpcallStub(map, (UpcallStub)cb) : senderForCompiledFrame(map, cb);\n@@ -365,10 +359,0 @@\n-  private Frame senderForContinuationStub(X86RegisterMap map, CodeBlob cb) {\n-    var contEntry = map.getThread().getContEntry();\n-\n-    Address senderSP = contEntry.getEntrySP();\n-    Address senderPC = contEntry.getEntryPC();\n-    Address senderFP = contEntry.getEntryFP();\n-\n-    return new X86Frame(senderSP, senderFP, senderPC);\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/x86\/X86Frame.java","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-import com.sun.net.httpserver.*;\n-\n@@ -114,8 +112,0 @@\n- * @implNote\n- * Prior to JDK 26, in the JDK default implementation, the {@link HttpExchange} attribute map was\n- * shared with the enclosing {@link HttpContext}.\n- * Since JDK 26, by default, exchange attributes are per-exchange and the context attributes must\n- * be accessed by calling {@link HttpExchange#getHttpContext() getHttpContext()}{@link\n- * HttpContext#getAttributes() .getAttributes()}. <br>\n- * A new system property, <b>{@systemProperty jdk.httpserver.attributes}<\/b> (default value: {@code \"\"})\n- * allows to revert this new behavior. Set this property to \"context\" to restore the pre JDK 26 behavior.\n","filename":"src\/jdk.httpserver\/share\/classes\/module-info.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -60,0 +60,2 @@\n+    boolean upgrade;\n+    boolean upgraded;\n@@ -73,0 +75,1 @@\n+    private static final String GET = \"GET\";\n@@ -98,0 +101,1 @@\n+        this.upgrade = isUpgradeRequest(reqHdrs);\n@@ -132,0 +136,9 @@\n+    \/\/ check if Upgrade connection\n+    private boolean isUpgradeRequest(Headers headers) {\n+        var values = headers.get(\"Connection\");\n+        return values != null\n+            && headers.get(\"Upgrade\") != null\n+            && GET.equals(getRequestMethod())\n+            && values.stream().filter(\"Upgrade\"::equalsIgnoreCase).findAny().isPresent();\n+    }\n+\n@@ -165,1 +178,3 @@\n-        if (reqContentLen == -1L) {\n+        if (upgrade) {\n+            uis_orig = new UpgradeInputStream(this, ris);\n+        } else if (reqContentLen == -1L) {\n@@ -167,1 +182,0 @@\n-            uis = uis_orig;\n@@ -170,1 +184,0 @@\n-            uis = uis_orig;\n@@ -172,0 +185,1 @@\n+        uis = uis_orig;\n@@ -224,1 +238,2 @@\n-        \/* check for response type that is not allowed to send a body *\/\n+        \/* check for connection upgrade *\/\n+        if (rCode == 101) {\n@@ -226,3 +241,10 @@\n-        if ((rCode>=100 && rCode <200) \/* informational *\/\n-            ||(rCode == 204)           \/* no content *\/\n-            ||(rCode == 304))          \/* not modified *\/\n+            if (contentLen != 0) {\n+                logger.log(\n+                    Level.WARNING,\n+                    () -> \"sendResponseHeaders: rCode = \" + rCode + \": forcing contentLen = 0\");\n+            }\n+            contentLen = 0;\n+        \/* check for response type that is not allowed to send a body *\/\n+        } else if (rCode >= 100 && rCode < 200 \/* informational *\/\n+            || rCode == 204           \/* no content *\/\n+            || rCode == 304)          \/* not modified *\/\n@@ -256,0 +278,3 @@\n+                } else if (upgrade && rCode == 101) {\n+                    o.setWrappedStream (new UpgradeOutputStream (this, ros));\n+                    close = true;\n@@ -294,0 +319,3 @@\n+        } else if (upgrade && rCode == 101) {\n+            upgraded = true;\n+            ros.flush();\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/ExchangeImpl.java","additions":35,"deletions":7,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2005, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.net.httpserver;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+\/**\n+ * A class which allows the caller to read the underlying stream for an upgrade request.\n+ * close() does not close the underlying stream\n+ *\/\n+class UpgradeInputStream extends LeftOverInputStream {\n+\n+    UpgradeInputStream(ExchangeImpl t, InputStream src) {\n+        super(t, src);\n+    }\n+\n+    @Override\n+    protected int readImpl(byte[] b, int off, int len) throws IOException {\n+        if (!t.upgraded) {\n+            return -1;\n+        }\n+        return in.read(b, off, len);\n+    }\n+\n+    @Override\n+    public int available() throws IOException {\n+        if (!t.upgraded) {\n+            return 0;\n+        }\n+        return in.available();\n+    }\n+\n+    @Override\n+    public void reset() throws IOException {\n+        throw new IOException(\"mark\/reset not supported\");\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        closed = true;\n+        t.getServerImpl().requestCompleted(t.getConnection());\n+    }\n+\n+    @Override\n+    public byte[] readAllBytes() throws IOException {\n+        if (!t.upgraded) {\n+          return new byte[0];\n+        }\n+        throw new IOException(\"readAllBytes not supported for upgraded requests\");\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/UpgradeInputStream.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.net.httpserver;\n+\n+import java.io.FilterOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.util.Objects;\n+\n+\/**\n+ * a class which allows the caller to write an indefinite number of bytes to an underlying stream.\n+ * Used for upgraded connections only.\n+ *\/\n+class UpgradeOutputStream extends FilterOutputStream {\n+    private boolean closed = false;\n+    ExchangeImpl t;\n+\n+    UpgradeOutputStream(ExchangeImpl t, OutputStream src) {\n+        super(src);\n+        this.t = t;\n+    }\n+\n+    @Override\n+    public void write(int b) throws IOException {\n+        if (closed) {\n+            throw new IOException(\"stream closed\");\n+        }\n+        out.write(b);\n+    }\n+\n+    @Override\n+    public void write(byte[] b, int off, int len) throws IOException {\n+        Objects.checkFromIndexSize(off, len, b.length);\n+        if (len == 0) {\n+            return;\n+        }\n+        if (closed) {\n+            throw new IOException(\"stream closed\");\n+        }\n+        out.write(b, off, len);\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        if (closed) {\n+            return;\n+        }\n+        closed = true;\n+        flush();\n+        LeftOverInputStream is = t.getOriginalInputStream();\n+        if (!is.isClosed()) {\n+            is.close();\n+        }\n+        Event e = new Event.WriteFinished(t);\n+        t.getHttpContext().getServerImpl().addEvent(e);\n+        out.close();\n+    }\n+}\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/UpgradeOutputStream.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -334,1 +334,0 @@\n-        copyResource(DocPaths.SORT_A_Z_SVG, DocPaths.RESOURCE_FILES.resolve(DocPaths.SORT_A_Z_SVG), true);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDoclet.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -123,1 +123,0 @@\n-    static final HtmlId TOC_ORDER_TOGGLE = HtmlId.of(\"toc-lexical-order-toggle\");\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlIds.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -115,10 +115,0 @@\n-\n-            header.add(Entity.NO_BREAK_SPACE)\n-                    .add(HtmlTree.BUTTON(HtmlStyles.tocSortToggle)\n-                            .setId(HtmlIds.TOC_ORDER_TOGGLE)\n-                            .add(HtmlTree.IMG(writer.pathToRoot.resolve(DocPaths.RESOURCE_FILES)\n-                                            .resolve(DocPaths.SORT_A_Z_SVG),\n-                                    writer.resources.getText(\"doclet.sort_table_of_contents\")\n-                            ))\n-                    );\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/TableOfContents.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -167,10 +167,0 @@\n-    \/**\n-     * The class used for lexical order toggle in the table of contents.\n-     *\/\n-    tocSortToggle,\n-\n-     \/**\n-     * The class used to indicate the state of the lexical sort toggle.\n-     *\/\n-    tocSortIsActive,\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/HtmlStyles.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,8 +26,0 @@\n-const sortLexicalLabel = \"##REPLACE:doclet.Sort_lexicographically##\";\n-const sortSourceLabel  = \"##REPLACE:doclet.Sort_by_source_order##\";\n-const TOC_ALPHA  = \"alpha\";\n-const TOC_SOURCE = \"source\";\n-var origOlOrder = new Map();\n-var origContainerOrder = new Map();\n-var snapshotted = false;\n-\n@@ -420,3 +412,0 @@\n-\n-    snapshotAllOnce();\n-\n@@ -654,162 +643,0 @@\n-\n-    function allTocNavs() {\n-        return Array.from(document.querySelectorAll(\"nav.toc\"));\n-    }\n-\n-    function nestedTocLists(scope) {\n-        const listsToSort = [];\n-        const sectionLinks = scope.querySelectorAll(\"ol.toc-list > li > a\");\n-\n-        sectionLinks.forEach(function(link) {\n-            const href = link.getAttribute(\"href\");\n-            if (href === \"#constructor-detail\" || href === \"#method-detail\"\n-                || href === \"#field-detail\" || href === \"#annotation-interface-element-detail\"\n-                || href === \"#enum-constant-detail\" || href === \"#property-detail\") {\n-                const memberList = link.nextElementSibling;\n-                if (memberList && memberList.tagName === 'OL') {\n-                    listsToSort.push(memberList);\n-                }\n-            }\n-        });\n-\n-        return listsToSort;\n-    }\n-\n-    function textForLi(li) {\n-        return li.querySelector(\":scope > a\").textContent.trim();\n-    }\n-\n-    function alphaCompare(a, b) {\n-        return textForLi(a).localeCompare(textForLi(b), undefined, {\n-            numeric: true,\n-            sensitivity: \"base\"\n-        });\n-    }\n-\n-    function snapshotTocOnce(nav){\n-        nestedTocLists(nav).forEach(function(ol){\n-            if (!origOlOrder.has(ol)) origOlOrder.set(ol, Array.from(ol.children));\n-        });\n-    }\n-    function restoreToc(nav){\n-        nestedTocLists(nav).forEach(function(ol){\n-            var orig = origOlOrder.get(ol);\n-            if (orig) orig.forEach(function(li){ ol.appendChild(li); });\n-        });\n-    }\n-    function sortTocAlpha(nav){\n-        nestedTocLists(nav).forEach(function(ol){\n-            var lis = Array.from(ol.children);\n-            if (lis.length < 2) return;\n-            lis.slice().sort(alphaCompare).forEach(function(li){ ol.appendChild(li); });\n-        });\n-    }\n-\n-    function snapshotAllOnce() {\n-        if (snapshotted) return;\n-        allTocNavs().forEach(snapshotTocOnce);\n-        snapshotted = true;\n-    }\n-\n-    function restoreAllMemberContainers(){\n-        origContainerOrder.forEach(function(kids, container){\n-            kids.forEach(function(ch){ container.appendChild(ch); });\n-        });\n-    }\n-\n-    function reorderMemberDetailsAlpha() {\n-        var sidebarNav = document.querySelector(\".main-grid nav.toc\");\n-        var mainRoot = document.querySelector(\".main-grid main\");\n-        if (!sidebarNav || !mainRoot) return;\n-\n-        var containers = Array.from(\n-            mainRoot.querySelectorAll(\"ul.member-list\")\n-        );\n-\n-        containers.forEach(function(container) {\n-            var links = Array.from(sidebarNav.querySelectorAll(\"a[href^='#']\")).filter(function(a) {\n-                var id = a.getAttribute(\"href\").slice(1);\n-                if (!id) return false;\n-                var target = document.getElementById(decodeURI(id));\n-                return target && container.contains(target);\n-            });\n-            if (links.length < 2) return;\n-\n-            var items = links.map(function(a) {\n-                var id = a.getAttribute(\"href\").slice(1);\n-                var target = document.getElementById(decodeURI(id));\n-                if (!target) return null;\n-                var block = target.closest(\"section.detail, div.detail\") || target;\n-                var li = block.closest(\"li\");\n-                if (li.parentElement !== container) return null;\n-                return {\n-                    node: li,\n-                    text: (a.textContent || \"\").trim()\n-                };\n-            }).filter(Boolean);\n-\n-            if (items.length < 2) return;\n-\n-            if (!origContainerOrder.has(container)) {\n-                origContainerOrder.set(container, Array.from(container.children));\n-            }\n-\n-            items.slice()\n-                .sort(function(x, y) {\n-                    return x.text.localeCompare(y.text, undefined, {\n-                        numeric: true,\n-                        sensitivity: \"base\"\n-                    });\n-                })\n-                .forEach(function(it) {\n-                    container.appendChild(it.node);\n-                });\n-        });\n-    }\n-\n-    function updateToggleButtons(order){\n-        const next = (order === TOC_ALPHA) ? sortSourceLabel : sortLexicalLabel;\n-        document.querySelectorAll(\".toc-sort-toggle\").forEach(function(btn){\n-            btn.setAttribute(\"aria-label\", next);\n-            btn.setAttribute(\"title\", next);\n-            btn.setAttribute(\"aria-pressed\", order === TOC_ALPHA);\n-\n-            if (order === TOC_ALPHA) {\n-                btn.classList.add(\"toc-sort-is-active\");\n-            } else {\n-                btn.classList.remove(\"toc-sort-is-active\");\n-            }\n-\n-            var img = btn.querySelector(\"img\");\n-            if (img) img.alt = next;\n-        });\n-    }\n-\n-    var tocOrder = TOC_SOURCE;\n-    updateToggleButtons(tocOrder);\n-\n-    function applyAlpha(){\n-        snapshotAllOnce();\n-        reorderMemberDetailsAlpha();\n-        allTocNavs().forEach(sortTocAlpha);\n-        initSectionData(); handleScroll();\n-        updateToggleButtons(TOC_ALPHA);\n-        tocOrder = TOC_ALPHA;\n-    }\n-\n-    function applySource(){\n-        snapshotAllOnce();\n-        restoreAllMemberContainers();\n-        allTocNavs().forEach(restoreToc);\n-        initSectionData(); handleScroll();\n-        updateToggleButtons(TOC_SOURCE);\n-        tocOrder = TOC_SOURCE;\n-    }\n-\n-    document.querySelectorAll(\".toc-sort-toggle\").forEach(function(btn) {\n-      btn.addEventListener(\"click\", function() {\n-          if (tocOrder === TOC_SOURCE) applyAlpha(); else applySource();\n-          if (typeof btn.blur === \"function\") btn.blur();\n-      });\n-    });\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/script.js.template","additions":0,"deletions":173,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -1,16 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-\n-<!--\n- Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\n- Licensed under the Universal Permissive License v 1.0 as shown at https:\/\/oss.oracle.com\/licenses\/upl\/\n--->\n-\n-<svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" viewBox=\"0 0 32 32\">\n-<line fill=\"none\" stroke=\"#505050\" stroke-width=\"2\" stroke-miterlimit=\"10\" x1=\"23\" y1=\"26.1\" x2=\"23\" y2=\"5\"\/>\n-    <polyline fill=\"none\" stroke=\"#505050\" stroke-width=\"2\" stroke-miterlimit=\"10\" points=\"18.7,21.8 23,26.1 27.3,21.8 \"\/>\n-    <polyline fill=\"none\" stroke=\"#505050\" stroke-width=\"2\" stroke-miterlimit=\"10\" points=\"12,15 12,14 9.1,6 8.9,6 6,14 6,15 \"\/>\n-    <line fill=\"none\" stroke=\"#505050\" stroke-width=\"2\" stroke-miterlimit=\"10\" x1=\"6\" y1=\"12\" x2=\"12\" y2=\"12\"\/>\n-    <polyline fill=\"none\" stroke=\"#505050\" stroke-width=\"2\" stroke-miterlimit=\"10\" points=\"5,18 12,18 12,19 6,25 6,26 13,26 \"\/>\n-<\/svg>\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/sort-a-z.svg","additions":0,"deletions":16,"binary":false,"changes":16,"status":"deleted"},{"patch":"@@ -696,0 +696,1 @@\n+    border: none;\n@@ -699,1 +700,0 @@\n-    border: 1px solid transparent;\n@@ -1904,5 +1904,0 @@\n-    .top-nav nav.toc .toc-sort-toggle {\n-        background: transparent;\n-        border: 0;\n-        margin-left: 4px;\n-    }\n@@ -1965,27 +1960,0 @@\n-\n-nav.toc div.toc-header input.filter-input {\n-    flex: 1 1 auto;\n-    min-width: 0;\n-}\n-\n-nav.toc div.toc-header .toc-sort-toggle {\n-    flex: 0 0 auto;\n-    position: static;\n-    display: inline-flex;\n-    align-items: center;\n-    padding: .5em;\n-    cursor: pointer;\n-}\n-\n-nav.toc div.toc-header .toc-sort-toggle > img {\n-    width: 22px;\n-    height: 22px;\n-    vertical-align: middle;\n-    filter: var(--icon-filter);\n-}\n-\n-nav.toc div.toc-header .toc-sort-toggle.toc-sort-is-active {\n-    background-color: var(--toc-highlight-color);\n-    border-radius: 4px;\n-}\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/stylesheet.css","additions":1,"deletions":33,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -254,2 +254,0 @@\n-doclet.Sort_lexicographically=Sort member details lexicographically\n-doclet.Sort_by_source_order=Sort member details by source order\n@@ -261,1 +259,0 @@\n-doclet.sort_table_of_contents=Sort member details in lexicographical order\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/doclets.properties","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -118,3 +118,0 @@\n-    \/** The name of the table of contents toggle icon file. *\/\n-    public static final DocPath SORT_A_Z_SVG = DocPath.create(\"sort-a-z.svg\");\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/DocPaths.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -707,1 +707,1 @@\n-:   Dump all threads, with stack traces, to a file in plain text or JSON format.\n+:   Dump threads, with stack traces, to a file in plain text or JSON format.\n@@ -726,2 +726,1 @@\n-:   Print all platform threads, and mounted virtual threads, with stack traces.\n-    The Thread.dump_to_file command will print all threads to a file.\n+:   Prints all threads with stacktraces.\n","filename":"src\/jdk.jcmd\/share\/man\/jcmd.md","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-import java.net.URI;\n@@ -137,18 +136,1 @@\n-        JMXServiceURL jmxServiceURL = new JMXServiceURL(url);\n-        setParameters(jmxServiceURL, userName, password);\n-        if (\"rmi\".equals(jmxServiceURL.getProtocol())) {\n-            String path = jmxServiceURL.getURLPath();\n-            if (path.startsWith(\"\/jndi\/\")) {\n-                int end = path.indexOf(';');\n-                if (end < 0) end = path.length();\n-                String registryURIStr = path.substring(6, end);\n-                URI registryURI = URI.create(registryURIStr);\n-                if (\"rmi\".equals(registryURI.getScheme())\n-                        && \"\/jmxrmi\".equals(registryURI.getPath())) {\n-                    this.registryHostName = registryURI.getHost();\n-                    this.registryPort = registryURI.getPort();\n-                    this.vmConnector = true;\n-                    checkSslConfig();\n-                }\n-            }\n-        }\n+        setParameters(new JMXServiceURL(url), userName, password);\n","filename":"src\/jdk.jconsole\/share\/classes\/sun\/tools\/jconsole\/ProxyClient.java","additions":2,"deletions":20,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -893,0 +893,2 @@\n+ \"debugflags=flags             debug flags (bitmask)           none\\n\"\n+ \"                               USE_ITERATE_THROUGH_HEAP 0x01\\n\"\n@@ -1193,0 +1195,7 @@\n+        } else if (strcmp(buf, \"debugflags\") == 0) {\n+            \/*LINTED*\/\n+            if (!get_tok(&str, current, (int)(end - current), ',')) {\n+                goto syntax_error;\n+            }\n+            \/*LINTED*\/\n+            gdata->debugflags = (unsigned)strtol(current, NULL, 0);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/debugInit.c","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2733,0 +2733,4 @@\n+\/* Two different cbObjectCounter's, one for FollowReferences, one for\n+ *    IterateThroughHeap. Pick a card, any card.\n+ *\/\n+\n@@ -2794,0 +2798,32 @@\n+\/* Callback for instance count heap traversal (heap_iteration_callback) *\/\n+static jint JNICALL\n+cbObjectCounter(jlong class_tag, jlong size, jlong* tag_ptr, jint length,\n+                        void* user_data)\n+{\n+    ClassCountData  *data;\n+    int              index;\n+\n+    \/* Check data structure *\/\n+    data = (ClassCountData*)user_data;\n+    if (data == NULL) {\n+        return JVMTI_VISIT_ABORT;\n+    }\n+\n+    \/* Classes with no tag should be filtered out. *\/\n+    if ( class_tag == (jlong)0 ) {\n+        data->error = AGENT_ERROR_INTERNAL;\n+        return JVMTI_VISIT_ABORT;\n+    }\n+\n+    \/* Class tag is actually an index into data arrays *\/\n+    index = CLASSTAG2INDEX(class_tag);\n+    if (index < 0 || index >= data->classCount) {\n+        data->error = AGENT_ERROR_ILLEGAL_ARGUMENT;\n+        return JVMTI_VISIT_ABORT;\n+    }\n+\n+    \/* Bump instance count on this class *\/\n+    data->counts[index]++;\n+    return JVMTI_VISIT_OBJECTS;\n+}\n+\n@@ -2846,13 +2882,19 @@\n-        \/* Using FollowReferences only gives us live objects, but we\n-         *   need to tag the objects to avoid counting them twice since\n-         *   the callback is per reference.\n-         *   The jclass objects have been tagged with their index in the\n-         *   supplied list, and that tag may flip to negative if it\n-         *   is also an object of interest.\n-         *   All other objects being counted that weren't in the\n-         *   supplied classes list will have a negative classCount\n-         *   tag value. So all objects counted will have negative tags.\n-         *   If the absolute tag value is an index in the supplied\n-         *   list, then it's one of the supplied classes.\n-         *\/\n-        data.negObjTag = -INDEX2CLASSTAG(classCount);\n+        \/* Check debug flags to see how to do this. *\/\n+        if ( (gdata->debugflags & USE_ITERATE_THROUGH_HEAP) == 0 ) {\n+\n+            \/* Using FollowReferences only gives us live objects, but we\n+             *   need to tag the objects to avoid counting them twice since\n+             *   the callback is per reference.\n+             *   The jclass objects have been tagged with their index in the\n+             *   supplied list, and that tag may flip to negative if it\n+             *   is also an object of interest.\n+             *   All other objects being counted that weren't in the\n+             *   supplied classes list will have a negative classCount\n+             *   tag value. So all objects counted will have negative tags.\n+             *   If the absolute tag value is an index in the supplied\n+             *   list, then it's one of the supplied classes.\n+             *\/\n+            data.negObjTag = -INDEX2CLASSTAG(classCount);\n+\n+            \/* Setup callbacks, only using object reference callback *\/\n+            heap_callbacks.heap_reference_callback = &cbObjectCounterFromRef;\n@@ -2860,2 +2902,4 @@\n-        \/* Setup callbacks, only using object reference callback *\/\n-        heap_callbacks.heap_reference_callback = &cbObjectCounterFromRef;\n+            \/* Follow references, no initiating object, tagged classes only *\/\n+            error = JVMTI_FUNC_PTR(jvmti,FollowReferences)\n+                          (jvmti, JVMTI_HEAP_FILTER_CLASS_UNTAGGED,\n+                           NULL, NULL, &heap_callbacks, &data);\n@@ -2863,4 +2907,22 @@\n-        \/* Follow references, no initiating object, tagged classes only *\/\n-        error = JVMTI_FUNC_PTR(jvmti,FollowReferences)\n-                      (jvmti, JVMTI_HEAP_FILTER_CLASS_UNTAGGED,\n-                       NULL, NULL, &heap_callbacks, &data);\n+        } else {\n+\n+            \/* Using IterateThroughHeap means that we will visit each object\n+             *   once, so no special tag tricks here. Just simple counting.\n+             *   However in this case the object might not be live, so we do\n+             *   a GC beforehand to make sure we minimize this.\n+             *\/\n+\n+            \/* FIXUP: Need some kind of trigger here to avoid excessive GC's? *\/\n+            error = JVMTI_FUNC_PTR(jvmti,ForceGarbageCollection)(jvmti);\n+            if ( error != JVMTI_ERROR_NONE ) {\n+\n+                \/* Setup callbacks, just need object callback *\/\n+                heap_callbacks.heap_iteration_callback = &cbObjectCounter;\n+\n+                \/* Iterate through entire heap, tagged classes only *\/\n+                error = JVMTI_FUNC_PTR(jvmti,IterateThroughHeap)\n+                              (jvmti, JVMTI_HEAP_FILTER_CLASS_UNTAGGED,\n+                               NULL, &heap_callbacks, &data);\n+\n+            }\n+        }\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.c","additions":82,"deletions":20,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,0 +95,6 @@\n+    \/* Debug flags (bit mask) *\/\n+    int      debugflags;\n+\n+    \/* Possible debug flags *\/\n+    #define USE_ITERATE_THROUGH_HEAP 0X001\n+\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.h","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -260,5 +260,0 @@\n-            sortedCache[i] = null;\n-        }\n-        \/\/ Shrink array\n-        if (index > 100_000 && 4 * index < sortedCache.length) {\n-            sortedCache = new RecordedEvent[2 * index];\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventDirectoryStream.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -130,4 +130,0 @@\n-            if (index > 100_000 && 4 * index < cacheSorted.length) {\n-                cacheSorted = new RecordedEvent[2 * index];\n-            }\n-            onFlush();\n@@ -143,1 +139,0 @@\n-            cacheSorted[i] = null;\n@@ -145,0 +140,1 @@\n+        onFlush();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventFileStream.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -282,0 +282,2 @@\n+  jdk.crypto.ec provides java.security.Provider used by java.base\n+  jdk.crypto.mscapi provides java.security.Provider used by java.base\n","filename":"src\/jdk.jlink\/share\/man\/jlink.md","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-        app = copyWithUnresolvedAppImageLayout(app);\n+        app = normalizeAppImageLayout(app);\n@@ -246,1 +246,1 @@\n-    private static MacApplication copyWithUnresolvedAppImageLayout(MacApplication app) {\n+    private static MacApplication normalizeAppImageLayout(MacApplication app) {\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/AppImageSigner.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_APP_IMAGE_FILE;\n+import static jdk.jpackage.internal.StandardBundlerParam.SIGN_BUNDLE;\n@@ -30,0 +32,3 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.text.MessageFormat;\n@@ -31,0 +36,1 @@\n+import java.util.Optional;\n@@ -41,1 +47,20 @@\n-        if (PREDEFINED_APP_IMAGE.fetchFrom(params) == null) {\n+        if (PREDEFINED_APP_IMAGE.fetchFrom(params) != null) {\n+            Path applicationImage = PREDEFINED_APP_IMAGE.fetchFrom(params);\n+            if (new MacAppImageFileExtras(PREDEFINED_APP_IMAGE_FILE.fetchFrom(params)).signed()) {\n+                var appLayout = ApplicationLayoutUtils.PLATFORM_APPLICATION_LAYOUT.resolveAt(applicationImage);\n+                if (!Files.exists(\n+                        PackageFile.getPathInAppImage(appLayout))) {\n+                    Log.info(MessageFormat.format(I18N.getString(\n+                            \"warning.per.user.app.image.signed\"),\n+                            PackageFile.getPathInAppImage(appLayout)));\n+                }\n+            } else {\n+                if (Optional.ofNullable(\n+                        SIGN_BUNDLE.fetchFrom(params)).orElse(Boolean.FALSE)) {\n+                    \/\/ if signing bundle with app-image, warn user if app-image\n+                    \/\/ is not already signed.\n+                    Log.info(MessageFormat.format(I18N.getString(\n+                            \"warning.unsigned.app.image\"), getID()));\n+                }\n+            }\n+        } else {\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacBaseInstallerBundler.java","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-            final var mainLauncherStartupInfo = new MainLauncherStartupInfo(superAppBuilder.mainLauncherClassName().orElseThrow());\n+            final var mainLauncherStartupInfo = new MainLauncherStartupInfo(PREDEFINED_APP_IMAGE_FILE.fetchFrom(params).getMainClass());\n@@ -125,1 +125,1 @@\n-            final var appImageFileExtras = new MacAppImageFileExtras(superAppBuilder.externalApplication().orElseThrow());\n+            final var appImageFileExtras = new MacAppImageFileExtras(PREDEFINED_APP_IMAGE_FILE.fetchFrom(params));\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacFromParams.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import static jdk.jpackage.internal.MacPackagingPipeline.APPLICATION_LAYOUT;\n@@ -30,1 +29,0 @@\n-import java.nio.file.Files;\n@@ -62,15 +60,1 @@\n-\n-        var macPkg = MacPackage.create(pkg, new MacPackageMixin.Stub(pkg.predefinedAppImage().map(v -> predefinedAppImageSigned)));\n-        validatePredefinedAppImage(macPkg);\n-        return macPkg;\n-    }\n-\n-    private static void validatePredefinedAppImage(MacPackage pkg) {\n-        if (pkg.predefinedAppImageSigned().orElse(false)) {\n-            pkg.predefinedAppImage().ifPresent(predefinedAppImage -> {\n-                var thePackageFile = PackageFile.getPathInAppImage(APPLICATION_LAYOUT);\n-                if (!Files.exists(predefinedAppImage.resolve(thePackageFile))) {\n-                    Log.info(I18N.format(\"warning.per.user.app.image.signed\", thePackageFile));\n-                }\n-            });\n-        }\n+        return MacPackage.create(pkg, new MacPackageMixin.Stub(pkg.predefinedAppImage().map(v -> predefinedAppImageSigned)));\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPackageBuilder.java","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -46,3 +46,1 @@\n-        var pkg = MacPkgPackage.create(pkgBuilder.create(), new MacPkgPackageMixin.Stub(createSigningConfig()));\n-        validatePredefinedAppImage(pkg);\n-        return pkg;\n+        return MacPkgPackage.create(pkgBuilder.create(), new MacPkgPackageMixin.Stub(createSigningConfig()));\n@@ -61,8 +59,0 @@\n-    private static void validatePredefinedAppImage(MacPkgPackage pkg) {\n-        if (!pkg.predefinedAppImageSigned().orElse(false) && pkg.sign()) {\n-            pkg.predefinedAppImage().ifPresent(predefinedAppImage -> {\n-                Log.info(I18N.format(\"warning.unsigned.app.image\", \"pkg\"));\n-            });\n-        }\n-    }\n-\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPkgPackageBuilder.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -89,3 +89,0 @@\n-\n-        externalApp = Objects.requireNonNull(app);\n-\n@@ -118,13 +115,0 @@\n-    Optional<ExternalApplication> externalApplication() {\n-        return Optional.ofNullable(externalApp);\n-    }\n-\n-    Optional<String> mainLauncherClassName() {\n-        return launchers()\n-                .map(ApplicationLaunchers::mainLauncher)\n-                .flatMap(Launcher::startupInfo)\n-                .map(LauncherStartupInfo::qualifiedClassName).or(() -> {\n-                    return externalApplication().map(ExternalApplication::getMainClass);\n-                });\n-    }\n-\n@@ -227,1 +211,0 @@\n-    private ExternalApplication externalApp;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ApplicationBuilder.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import java.nio.file.StandardCopyOption;\n@@ -152,2 +151,1 @@\n-        FileUtils.copyRecursive(srcDir, dstDir.toAbsolutePath(), excludes,\n-                LinkOption.NOFOLLOW_LINKS, StandardCopyOption.REPLACE_EXISTING);\n+        FileUtils.copyRecursive(srcDir, dstDir.toAbsolutePath(), excludes, LinkOption.NOFOLLOW_LINKS);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ApplicationImageUtils.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-\n+        Log.verbose (\"\\njpackage argument list: \\n\" + argList + \"\\n\");\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Arguments.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-                runtimeBuilderBuilder.modulePath(MODULE_PATH.fetchFrom(params));\n+                MODULE_PATH.copyInto(params, runtimeBuilderBuilder::modulePath);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/FromParams.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.io.BufferedReader;\n+import java.io.InputStreamReader;\n@@ -46,1 +48,1 @@\n-        Files.createDirectories(destFile.getParent());\n+        Files.createDirectories(getParent(destFile));\n@@ -53,0 +55,20 @@\n+    public static boolean exists(Path path) {\n+        if (path == null) {\n+            return false;\n+        }\n+\n+        return Files.exists(path);\n+    }\n+\n+    \/\/ run \"launcher paramfile\" in the directory where paramfile is kept\n+    public static void run(String launcher, Path paramFile)\n+            throws IOException {\n+        if (IOUtils.exists(paramFile)) {\n+            ProcessBuilder pb =\n+                    new ProcessBuilder(launcher,\n+                        getFileName(paramFile).toString());\n+            pb = pb.directory(getParent(paramFile).toFile());\n+            exec(pb);\n+        }\n+    }\n+\n@@ -64,0 +86,15 @@\n+    \/\/ See JDK-8236282\n+    \/\/ Reading output from some processes (currently known \"hdiutil attach\")\n+    \/\/ might hang even if process already exited. Only possible workaround found\n+    \/\/ in \"hdiutil attach\" case is to redirect the output to a temp file and then\n+    \/\/ read this file back.\n+    public static void exec(ProcessBuilder pb, boolean writeOutputToFile)\n+            throws IOException {\n+        exec(pb, false, null, writeOutputToFile, Executor.INFINITE_TIMEOUT);\n+    }\n+\n+    static void exec(ProcessBuilder pb, boolean testForPresenceOnly,\n+            PrintStream consumer) throws IOException {\n+        exec(pb, testForPresenceOnly, consumer, false, Executor.INFINITE_TIMEOUT);\n+    }\n+\n@@ -93,0 +130,45 @@\n+    public static int getProcessOutput(List<String> result, String... args)\n+            throws IOException, InterruptedException {\n+\n+        ProcessBuilder pb = new ProcessBuilder(args);\n+\n+        final Process p = pb.start();\n+\n+        List<String> list = new ArrayList<>();\n+\n+        final BufferedReader in =\n+                new BufferedReader(new InputStreamReader(p.getInputStream()));\n+        final BufferedReader err =\n+                new BufferedReader(new InputStreamReader(p.getErrorStream()));\n+\n+        Thread t = new Thread(() -> {\n+            try {\n+                String line;\n+                while ((line = in.readLine()) != null) {\n+                    list.add(line);\n+                }\n+            } catch (IOException ioe) {\n+                Log.verbose(ioe);\n+            }\n+\n+            try {\n+                String line;\n+                while ((line = err.readLine()) != null) {\n+                    Log.error(line);\n+                }\n+            } catch (IOException ioe) {\n+                  Log.verbose(ioe);\n+            }\n+        });\n+        t.setDaemon(true);\n+        t.start();\n+\n+        int ret = p.waitFor();\n+        Log.verbose(pb.command(), list, ret, IOUtils.getPID(p));\n+\n+        result.clear();\n+        result.addAll(list);\n+\n+        return ret;\n+    }\n+\n@@ -109,0 +191,22 @@\n+    public static Path getParent(Path p) {\n+        Path parent = p.getParent();\n+        if (parent == null) {\n+            IllegalArgumentException iae =\n+                    new IllegalArgumentException(p.toString());\n+            Log.verbose(iae);\n+            throw iae;\n+        }\n+        return parent;\n+    }\n+\n+    public static Path getFileName(Path p) {\n+        Path filename = p.getFileName();\n+        if (filename == null) {\n+            IllegalArgumentException iae =\n+                    new IllegalArgumentException(p.toString());\n+            Log.verbose(iae);\n+            throw iae;\n+        }\n+        return filename;\n+    }\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/IOUtils.java","additions":105,"deletions":1,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import static jdk.jpackage.internal.model.RuntimeBuilder.getDefaultModulePath;\n@@ -29,1 +28,0 @@\n-import java.io.IOException;\n@@ -37,1 +35,0 @@\n-import java.nio.file.Files;\n@@ -99,46 +96,0 @@\n-    \/**\n-     * Returns a list of paths that includes the location where the \"java.base\"\n-     * module can be found.\n-     * <p>\n-     * Returns the specified path list if \"java.base\" module can be found in one of\n-     * the paths from the specified path list.\n-     * <p>\n-     * Returns a new path list created from the specified path list with the path of\n-     * \"java.base\" module in the current runtime appended otherwise.\n-     *\n-     * @param modulePath the path list where to look up for \"java.base\" module\n-     * @return the path list that includes location of \"java.base\" module\n-     *\/\n-    static List<Path> ensureBaseModuleInModulePath(List<Path> modulePath) {\n-        if (modulePath.stream().anyMatch(path -> {\n-            return Files.isRegularFile(path.resolve(\"java.base.jmod\"));\n-        })) {\n-            return modulePath;\n-        } else {\n-            \/\/ There is no \"java.base.jmod\" file in the `modulePath` path list.\n-            \/\/ Pick items from the default module path list that are not yet\n-            \/\/ in the `modulePath` path list and append them to it.\n-\n-            var missingDefaultModulePath = getDefaultModulePath();\n-\n-            if (!modulePath.isEmpty()) {\n-                missingDefaultModulePath.stream().filter(defaultPath -> {\n-                    return modulePath.stream().anyMatch(path -> {\n-                        try {\n-                            return Files.isSameFile(path, defaultPath);\n-                        } catch (IOException ex) {\n-                            \/\/ Assume `defaultPath` path doesn't exist in `modulePath` list.\n-                            return false;\n-                        }\n-                    });\n-                }).toList();\n-            }\n-\n-            if (missingDefaultModulePath.isEmpty()) {\n-                return modulePath;\n-            } else {\n-                return Stream.of(modulePath, missingDefaultModulePath).flatMap(Collection::stream).toList();\n-            }\n-        }\n-    }\n-\n@@ -267,1 +218,1 @@\n-        return strings.stream().sorted().collect(Collectors.joining(\",\"));\n+        return strings.stream().collect(Collectors.joining(\",\"));\n@@ -282,1 +233,1 @@\n-    }\n+    };\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/JLinkRuntimeBuilder.java","additions":2,"deletions":51,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.io.UncheckedIOException;\n@@ -184,9 +183,0 @@\n-    Source probe() {\n-        try {\n-            return saveToStream(null);\n-        } catch (IOException ex) {\n-            \/\/ Should never happen.\n-            throw new UncheckedIOException(ex);\n-        }\n-    }\n-\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/OverridableResource.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import static jdk.jpackage.internal.model.RuntimeBuilder.getDefaultModulePath;\n@@ -58,0 +59,1 @@\n+    private static final String JAVABASEJMOD = \"java.base.jmod\";\n@@ -416,1 +418,1 @@\n-                    p -> JLinkRuntimeBuilder.ensureBaseModuleInModulePath(List.of()),\n+                    p -> getDefaultModulePath(),\n@@ -421,1 +423,20 @@\n-                        return JLinkRuntimeBuilder.ensureBaseModuleInModulePath(modulePath);\n+                        Path javaBasePath = findPathOfModule(modulePath, JAVABASEJMOD);\n+\n+                        \/\/ Add the default JDK module path to the module path.\n+                        if (javaBasePath == null) {\n+                            List<Path> jdkModulePath = getDefaultModulePath();\n+\n+                            if (jdkModulePath != null) {\n+                                modulePath = Stream.concat(modulePath.stream(),\n+                                        jdkModulePath.stream()).toList();\n+                                javaBasePath = findPathOfModule(modulePath, JAVABASEJMOD);\n+                            }\n+                        }\n+\n+                        if (javaBasePath == null ||\n+                                !Files.exists(javaBasePath)) {\n+                            Log.error(String.format(I18N.getString(\n+                                    \"warning.no.jdk.modules.found\")));\n+                        }\n+\n+                        return modulePath;\n@@ -424,0 +445,14 @@\n+    \/\/ Returns the path to the JDK modules in the user defined module path.\n+    private static Path findPathOfModule( List<Path> modulePath, String moduleName) {\n+\n+        for (Path path : modulePath) {\n+            Path moduleNamePath = path.resolve(moduleName);\n+\n+            if (Files.exists(moduleNamePath)) {\n+                return path;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/StandardBundlerParam.java","additions":37,"deletions":2,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-    public static Optional<ApplicationLaunchers> fromList(List<? extends Launcher> launchers) {\n+    public static Optional<ApplicationLaunchers> fromList(List<Launcher> launchers) {\n@@ -65,1 +65,1 @@\n-                    List.copyOf(launchers.subList(1, launchers.size()))));\n+                    launchers.subList(1, launchers.size())));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/ApplicationLaunchers.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.lang.module.ModuleFinder;\n@@ -50,7 +49,1 @@\n-     * Gets the default set of paths where jlink should look up for system Java\n-     * modules.\n-     *\n-     * <p>\n-     * These paths are for {@code jlink} command. Using them with\n-     * {@link ModuleFinder#of(Path...)} may not work as expected: attempt to find\n-     * \"java.base\" module in these paths will fail.\n+     * Gets the default set of paths where to find Java modules.\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/RuntimeBuilder.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -81,0 +81,2 @@\n+warning.no.jdk.modules.found=Warning: No JDK Modules found\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/MainResources.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.nio.file.StandardCopyOption;\n@@ -110,11 +109,0 @@\n-            if (List.of(options).contains(StandardCopyOption.REPLACE_EXISTING)) {\n-                \/\/ They requested copying with replacing the existing content.\n-                if (src == null && Files.isRegularFile(dest)) {\n-                    \/\/ This copy action creates a directory, but a file at the same path already exists, so delete it.\n-                    Files.deleteIfExists(dest);\n-                } else if (src != null && Files.isDirectory(dest)) {\n-                    \/\/ This copy action copies a file, but a directory at the same path exists already, so delete it.\n-                    deleteRecursive(dest);\n-                }\n-            }\n-\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/FileUtils.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,73 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal.util;\n-\n-import java.util.Objects;\n-\n-\/**\n- * Object wrapper implementing {@link Object#equals(Object)} such that it\n- * returns {@code true} only when the argument is another instance of this class\n- * wrapping the same object.\n- * <p>\n- * The class guarantees that {@link Object#equals(Object)} and\n- * {@link Object#hashCode()} methods of the wrapped object will never be called\n- * inside of the class methods.\n- *\n- * @param <T> the type of the wrapped value\n- *\/\n-public final class IdentityWrapper<T> {\n-\n-    public IdentityWrapper(T value) {\n-        this.value = Objects.requireNonNull(value);\n-    }\n-\n-    public T value() {\n-        return value;\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return System.identityHashCode(value);\n-    }\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-        if (this == obj) {\n-            return true;\n-        }\n-        if ((obj == null) || (getClass() != obj.getClass())) {\n-            return false;\n-        }\n-        var other = (IdentityWrapper<?>) obj;\n-        return value == other.value;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return String.format(\"Identity[%s]\", value);\n-    }\n-\n-    private final T value;\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/IdentityWrapper.java","additions":0,"deletions":73,"binary":false,"changes":73,"status":"deleted"},{"patch":"@@ -7,3 +7,1 @@\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n+ * published by the Free Software Foundation.\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/Result.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import static java.util.stream.Collectors.toMap;\n-\n@@ -35,1 +33,0 @@\n-import java.util.TreeMap;\n@@ -37,0 +34,2 @@\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Collectors;\n@@ -50,5 +49,5 @@\n-        scripts = EnumSet.allOf(scriptIdsType).stream().collect(toMap(x -> x, scriptId -> {\n-            return new ShellScriptResource(scriptId.name()).setResource(scriptId.get());\n-        }, (a, b) -> {\n-            throw new UnsupportedOperationException();\n-        }, TreeMap::new));\n+        scripts = EnumSet.allOf(scriptIdsType).stream().collect(\n+                Collectors.toMap(UnaryOperator.identity(), scriptId -> {\n+                    return new ShellScriptResource(scriptId.name()).setResource(\n+                            scriptId.get());\n+                }));\n","filename":"src\/jdk.jpackage\/unix\/classes\/jdk\/jpackage\/internal\/PackageScripts.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-        return msiBundler.validate(params, WinFromParams.EXE_PACKAGE);\n+        return msiBundler.validate(params);\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinExeBundler.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import jdk.jpackage.internal.model.Package;\n@@ -84,5 +83,1 @@\n-    public boolean validate(Map<String, ? super Object> params) throws ConfigException {\n-        return validate(params, WinFromParams.MSI_PACKAGE);\n-    }\n-\n-    boolean validate(Map<String, ? super Object> params, BundlerParamInfo<? extends Package> pkgParam)\n+    public boolean validate(Map<String, ? super Object> params)\n@@ -92,1 +87,1 @@\n-            pkgParam.fetchFrom(params);\n+            WinFromParams.APPLICATION.fetchFrom(params);\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinMsiBundler.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -251,1 +251,1 @@\n-                return path.getFileName().toString();\n+                return IOUtils.getFileName(path).toString();\n@@ -528,1 +528,1 @@\n-                launcherPath.getFileName(), \"\").toString();\n+                IOUtils.getFileName(launcherPath), \"\").toString();\n@@ -715,1 +715,1 @@\n-            xml.writeAttribute(\"Name\", dir.getFileName().toString());\n+            xml.writeAttribute(\"Name\", IOUtils.getFileName(dir).toString());\n@@ -821,1 +821,1 @@\n-                if (src.getFileName().toString().endsWith(\".ico\")) {\n+                if (IOUtils.getFileName(src).toString().endsWith(\".ico\")) {\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixAppImageFragmentBuilder.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -244,1 +244,1 @@\n-        Files.createDirectories(msi.getParent());\n+        Files.createDirectories(IOUtils.getParent(msi));\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixPipeline.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import java.util.TreeMap;\n@@ -148,1 +147,1 @@\n-            Files.createDirectories(resourceSaveAsFile.getParent());\n+            Files.createDirectories(IOUtils.getParent(resourceSaveAsFile));\n@@ -197,1 +196,1 @@\n-        private final Map<Path, OverridableResource> resources = new TreeMap<>();\n+        private final Map<Path, OverridableResource> resources = new HashMap<>();\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixSourceConverter.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,61 +0,0 @@\n-# Javac microbenchmarks\n-\n-The Javac Microbenchmarks is a collection of microbenchmarks for measuring\n-the performance of Javac API using the\n-[JMH](http:\/\/openjdk.java.net\/projects\/code-tools\/jmh\/) framework.\n-\n-\n-## Building and running the project\n-\n-Currently, the project can be built and run with JDK 9 and later. This is\n-a Maven project and is built by:\n-\n-    $ mvn clean install\n-\n-After building, the executable jar is target\/micros-javac-[version].jar.\n-Run the benchmarks with:\n-\n-    $ java -jar target\/micros-javac-*.jar [optional jmh parameters]\n-\n-See the entire list of benchmarks using:\n-\n-    $ java -jar target\/micros-javacs-*.jar -l [optional regex to select benchmarks]\n-\n-For example:\n-\n-    $ java -jar target\/micros-javac-1.0-SNAPSHOT.jar -l\n-    Benchmarks:\n-    org.openjdk.bench.langtools.javac.GroupJavacBenchmark.coldGroup\n-    org.openjdk.bench.langtools.javac.GroupJavacBenchmark.hotGroup\n-    org.openjdk.bench.langtools.javac.SingleJavacBenchmark.compileCold\n-    org.openjdk.bench.langtools.javac.SingleJavacBenchmark.compileHot\n-\n-And the same regex syntax works to run some test:\n-\n-    $ java -jar target\/micros-javac-1.0-SNAPSHOT.jar SingleJavacBenchmark.compileHot\n-\n-## Troubleshooting\n-\n-### Build of micros-javac module got stuck\n-\n-If you build got stuck on `[get] Getting: https:\/\/download.java.net\/openjdk\/jdk11\/ri\/openjdk-11+28_windows-x64_bin.zip` then you are probably experiencing some networking or web proxy obstacles.\n-\n-One solution is to download required reference JDK from [https:\/\/download.java.net\/openjdk\/jdk11\/ri\/openjdk-11+28_windows-x64_bin.zip](https:\/\/download.java.net\/openjdk\/jdk11\/ri\/openjdk-11+28_windows-x64_bin.zip) manually and then build the project with property pointing to the local copy:\n-\n-    $ mvn clean install -Djavac.benchmark.openjdk.zip.download.url=file:\/\/\/<your download location>\/openjdk-11+28_windows-x64_bin.zip\n-\n-Note: Please use `openjdk-11+28_windows-x64_bin.zip` to build the project no matter what target platform is.\n-\n-Another solution might be to add proxy settings:\n-\n-    $ mvn -Dhttps.proxyHost=... -Dhttps.proxyPort=... clean install\n-\n-### Execution of micros-javac benchmarks takes several hours\n-\n-micros-javac benchmarks consist of two sets of benchmarks:\n- * `SingleJavacBenchmark` (which is parametrized) measures each single javac compilation stage in an isolated run. This benchmark is designed for exact automated performance regression testing and it takes several hours to execute completely.\n- * `GroupJavacBenchmark` is grouping the measurements of all javac compilation stages into one run and its execution should take less than 30 minutes on a regular developers computer.\n-\n-Solution to speed up javac benchmarking is to select only `GroupJavacBenchmark` for execution using following command line:\n-\n-    $ java -jar target\/micros-javac-1.0-SNAPSHOT.jar .*GroupJavacBenchmark.*\n","filename":"test\/benchmarks\/micros-javac\/README.md","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -1,139 +0,0 @@\n-<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/maven-v4_0_0.xsd\">\n-    <!--\n-     Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n-     DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\n-     This code is free software; you can redistribute it and\/or modify it\n-     under the terms of the GNU General Public License version 2 only, as\n-     published by the Free Software Foundation.\n-\n-     This code is distributed in the hope that it will be useful, but WITHOUT\n-     ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-     FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-     version 2 for more details (a copy is included in the LICENSE file that\n-     accompanied this code).\n-\n-     You should have received a copy of the GNU General Public License version\n-     2 along with this work; if not, write to the Free Software Foundation,\n-     Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n-     Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-     or visit www.oracle.com if you need additional information or have any\n-     questions.\n-    -->\n-    <modelVersion>4.0.0<\/modelVersion>\n-    <groupId>org.openjdk<\/groupId>\n-    <artifactId>micros-javac<\/artifactId>\n-    <packaging>jar<\/packaging>\n-    <version>1.0-SNAPSHOT<\/version>\n-    <name>OpenJDK Microbenchmark of Java Compile<\/name>\n-    <properties>\n-        <javac.benchmark.openjdk.zip.download.url>https:\/\/download.java.net\/openjdk\/jdk11\/ri\/openjdk-11+28_windows-x64_bin.zip<\/javac.benchmark.openjdk.zip.download.url>\n-        <project.build.sourceEncoding>UTF-8<\/project.build.sourceEncoding>\n-        <jmh.version>1.36<\/jmh.version>\n-    <\/properties>\n-\n-    <build>\n-        <plugins>\n-            <plugin>\n-                <groupId>org.apache.maven.plugins<\/groupId>\n-                <artifactId>maven-shade-plugin<\/artifactId>\n-                <version>3.6.1<\/version>\n-                <executions>\n-                    <execution>\n-                        <phase>package<\/phase>\n-                        <goals>\n-                            <goal>shade<\/goal>\n-                        <\/goals>\n-                        <configuration>\n-                            <transformers>\n-                                <transformer implementation=\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\">\n-                                    <mainClass>org.openjdk.jmh.Main<\/mainClass>\n-                                <\/transformer>\n-                                <transformer implementation=\"org.apache.maven.plugins.shade.resource.AppendingTransformer\">\n-                                    <resource>META-INF\/BenchmarkList<\/resource>\n-                                <\/transformer>\n-                                <transformer implementation=\"org.apache.maven.plugins.shade.resource.AppendingTransformer\">\n-                                    <resource>META-INF\/CompilerHints<\/resource>\n-                                <\/transformer>\n-                            <\/transformers>\n-                            <createDependencyReducedPom>false<\/createDependencyReducedPom>\n-                        <\/configuration>\n-                    <\/execution>\n-                <\/executions>\n-            <\/plugin>\n-            <plugin>\n-                <groupId>org.apache.maven.plugins<\/groupId>\n-                <artifactId>maven-compiler-plugin<\/artifactId>\n-                <version>3.14.1<\/version>\n-                <configuration>\n-                    <source>1.8<\/source>\n-                    <target>1.8<\/target>\n-                    <annotationProcessorPaths>\n-                        <path>\n-                            <groupId>org.openjdk.jmh<\/groupId>\n-                            <artifactId>jmh-generator-annprocess<\/artifactId>\n-                            <version>${jmh.version}<\/version>\n-                        <\/path>\n-                    <\/annotationProcessorPaths>\n-                <\/configuration>\n-            <\/plugin>\n-            <plugin>\n-                <groupId>org.apache.maven.plugins<\/groupId>\n-                <artifactId>maven-release-plugin<\/artifactId>\n-                <version>3.1.1<\/version>\n-            <\/plugin>\n-            <plugin>\n-                <artifactId>maven-deploy-plugin<\/artifactId>\n-                <version>3.1.4<\/version>\n-            <\/plugin>\n-            <plugin>\n-                <artifactId>maven-antrun-plugin<\/artifactId>\n-                <version>3.1.0<\/version>\n-                <executions>\n-                    <execution>\n-                        <phase>process-resources<\/phase>\n-                        <configuration>\n-                            <target>\n-                                <mkdir dir=\"${project.build.outputDirectory}\"\/>\n-                                <get src=\"${javac.benchmark.openjdk.zip.download.url}\" dest=\"${project.build.directory}\/jdk-bin.zip\" skipexisting=\"true\" verbose=\"true\"\/>\n-                                <unzip src=\"${project.build.directory}\/jdk-bin.zip\" dest=\"${project.build.outputDirectory}\">\n-                                    <patternset>\n-                                        <include name=\"*\/lib\/src.zip\"\/>\n-                                        <include name=\"*\/release\"\/>\n-                                    <\/patternset>\n-                                    <mapper type=\"flatten\"\/>\n-                                <\/unzip>\n-                                <loadfile srcFile=\"${project.build.outputDirectory}\/release\" property=\"release.info\"\/>\n-                                <echo>\n--------------------------------------------------\n-Bundling JDK sources with following release info:\n--------------------------------------------------\n-${release.info}\n--------------------------------------------------\n-                                <\/echo>\n-                            <\/target>\n-                        <\/configuration>\n-                        <goals>\n-                            <goal>run<\/goal>\n-                        <\/goals>\n-                    <\/execution>\n-                <\/executions>\n-            <\/plugin>\n-        <\/plugins>\n-    <\/build>\n-\n-    <dependencies>\n-        <dependency>\n-            <groupId>org.openjdk.jmh<\/groupId>\n-            <artifactId>jmh-core<\/artifactId>\n-            <version>${jmh.version}<\/version>\n-        <\/dependency>\n-        <dependency>\n-            <groupId>org.openjdk.jmh<\/groupId>\n-            <artifactId>jmh-generator-annprocess<\/artifactId>\n-            <version>${jmh.version}<\/version>\n-            <scope>provided<\/scope>\n-        <\/dependency>\n-    <\/dependencies>\n-<\/project>\n","filename":"test\/benchmarks\/micros-javac\/pom.xml","additions":0,"deletions":139,"binary":false,"changes":139,"status":"deleted"},{"patch":"@@ -1,231 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.langtools.javac;\n-\n-import java.io.IOException;\n-import java.util.concurrent.TimeUnit;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Group;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-@State(Scope.Benchmark)\n-public class GroupJavacBenchmark extends JavacBenchmark {\n-\n-    public static final String COLD_GROUP_NAME = \"coldGroup\";\n-    public static final int COLD_ITERATION_WARMUPS = 0;\n-    public static final int COLD_ITERATIONS = 1;\n-    public static final int COLD_FORK_WARMUPS = 1;\n-    public static final int COLD_FORKS = 15;\n-\n-    public static final String HOT_GROUP_NAME = \"hotGroup\";\n-    public static final int HOT_ITERATION_WARMUPS = 8;\n-    public static final int HOT_ITERATIONS = 10;\n-    public static final int HOT_FORK_WARMUPS = 0;\n-    public static final int HOT_FORKS = 1;\n-\n-    @Benchmark\n-    @Group(COLD_GROUP_NAME)\n-    @BenchmarkMode(Mode.SingleShotTime)\n-    @Warmup(iterations = COLD_ITERATION_WARMUPS)\n-    @Measurement(iterations = COLD_ITERATIONS)\n-    @Fork(warmups = COLD_FORK_WARMUPS, value = COLD_FORKS, jvmArgsPrepend = { \"--add-exports=jdk.compiler\/com.sun.tools.javac.file=ALL-UNNAMED\", \"--add-exports=jdk.compiler\/com.sun.tools.javac.main=ALL-UNNAMED\",  \"--add-exports=jdk.compiler\/com.sun.tools.javac.util=ALL-UNNAMED\" })\n-    @OutputTimeUnit(TimeUnit.SECONDS)\n-    public void cold1_Init() throws InterruptedException {\n-        Stage.Init.waitFor();\n-    }\n-\n-    @Benchmark\n-    @Group(COLD_GROUP_NAME)\n-    @BenchmarkMode(Mode.SingleShotTime)\n-    @Warmup(iterations = COLD_ITERATION_WARMUPS)\n-    @Measurement(iterations = COLD_ITERATIONS)\n-    @Fork(warmups = COLD_FORK_WARMUPS, value = COLD_FORKS, jvmArgsPrepend = { \"--add-exports=jdk.compiler\/com.sun.tools.javac.file=ALL-UNNAMED\", \"--add-exports=jdk.compiler\/com.sun.tools.javac.main=ALL-UNNAMED\",  \"--add-exports=jdk.compiler\/com.sun.tools.javac.util=ALL-UNNAMED\" })\n-    @OutputTimeUnit(TimeUnit.SECONDS)\n-    public void cold2_Parse() throws InterruptedException {\n-        Stage.Parse.waitFor();\n-    }\n-\n-    @Benchmark\n-    @Group(COLD_GROUP_NAME)\n-    @BenchmarkMode(Mode.SingleShotTime)\n-    @Warmup(iterations = COLD_ITERATION_WARMUPS)\n-    @Measurement(iterations = COLD_ITERATIONS)\n-    @Fork(warmups = COLD_FORK_WARMUPS, value = COLD_FORKS, jvmArgsPrepend = { \"--add-exports=jdk.compiler\/com.sun.tools.javac.file=ALL-UNNAMED\", \"--add-exports=jdk.compiler\/com.sun.tools.javac.main=ALL-UNNAMED\",  \"--add-exports=jdk.compiler\/com.sun.tools.javac.util=ALL-UNNAMED\" })\n-    @OutputTimeUnit(TimeUnit.SECONDS)\n-    public void cold3_InitModules() throws InterruptedException {\n-        Stage.InitModules.waitFor();\n-    }\n-\n-    @Benchmark\n-    @Group(COLD_GROUP_NAME)\n-    @BenchmarkMode(Mode.SingleShotTime)\n-    @Warmup(iterations = COLD_ITERATION_WARMUPS)\n-    @Measurement(iterations = COLD_ITERATIONS)\n-    @Fork(warmups = COLD_FORK_WARMUPS, value = COLD_FORKS, jvmArgsPrepend = { \"--add-exports=jdk.compiler\/com.sun.tools.javac.file=ALL-UNNAMED\", \"--add-exports=jdk.compiler\/com.sun.tools.javac.main=ALL-UNNAMED\",  \"--add-exports=jdk.compiler\/com.sun.tools.javac.util=ALL-UNNAMED\" })\n-    @OutputTimeUnit(TimeUnit.SECONDS)\n-    public void cold4_Enter() throws InterruptedException {\n-        Stage.Enter.waitFor();\n-    }\n-\n-    @Benchmark\n-    @Group(COLD_GROUP_NAME)\n-    @BenchmarkMode(Mode.SingleShotTime)\n-    @Warmup(iterations = COLD_ITERATION_WARMUPS)\n-    @Measurement(iterations = COLD_ITERATIONS)\n-    @Fork(warmups = COLD_FORK_WARMUPS, value = COLD_FORKS, jvmArgsPrepend = { \"--add-exports=jdk.compiler\/com.sun.tools.javac.file=ALL-UNNAMED\", \"--add-exports=jdk.compiler\/com.sun.tools.javac.main=ALL-UNNAMED\",  \"--add-exports=jdk.compiler\/com.sun.tools.javac.util=ALL-UNNAMED\" })\n-    @OutputTimeUnit(TimeUnit.SECONDS)\n-    public void cold5_Attribute() throws InterruptedException {\n-        Stage.Attribute.waitFor();\n-    }\n-\n-    @Benchmark\n-    @Group(COLD_GROUP_NAME)\n-    @BenchmarkMode(Mode.SingleShotTime)\n-    @Warmup(iterations = COLD_ITERATION_WARMUPS)\n-    @Measurement(iterations = COLD_ITERATIONS)\n-    @Fork(warmups = COLD_FORK_WARMUPS, value = COLD_FORKS, jvmArgsPrepend = { \"--add-exports=jdk.compiler\/com.sun.tools.javac.file=ALL-UNNAMED\", \"--add-exports=jdk.compiler\/com.sun.tools.javac.main=ALL-UNNAMED\",  \"--add-exports=jdk.compiler\/com.sun.tools.javac.util=ALL-UNNAMED\" })\n-    @OutputTimeUnit(TimeUnit.SECONDS)\n-    public void cold6_Flow() throws InterruptedException {\n-        Stage.Flow.waitFor();\n-    }\n-\n-    @Benchmark\n-    @Group(COLD_GROUP_NAME)\n-    @BenchmarkMode(Mode.SingleShotTime)\n-    @Warmup(iterations = COLD_ITERATION_WARMUPS)\n-    @Measurement(iterations = COLD_ITERATIONS)\n-    @Fork(warmups = COLD_FORK_WARMUPS, value = COLD_FORKS, jvmArgsPrepend = { \"--add-exports=jdk.compiler\/com.sun.tools.javac.file=ALL-UNNAMED\", \"--add-exports=jdk.compiler\/com.sun.tools.javac.main=ALL-UNNAMED\",  \"--add-exports=jdk.compiler\/com.sun.tools.javac.util=ALL-UNNAMED\" })\n-    @OutputTimeUnit(TimeUnit.SECONDS)\n-    public void cold7_Desugar() throws InterruptedException {\n-        Stage.Desugar.waitFor();\n-    }\n-\n-    @Benchmark\n-    @Group(COLD_GROUP_NAME)\n-    @BenchmarkMode(Mode.SingleShotTime)\n-    @Warmup(iterations = COLD_ITERATION_WARMUPS)\n-    @Measurement(iterations = COLD_ITERATIONS)\n-    @Fork(warmups = COLD_FORK_WARMUPS, value = COLD_FORKS, jvmArgsPrepend = { \"--add-exports=jdk.compiler\/com.sun.tools.javac.file=ALL-UNNAMED\", \"--add-exports=jdk.compiler\/com.sun.tools.javac.main=ALL-UNNAMED\",  \"--add-exports=jdk.compiler\/com.sun.tools.javac.util=ALL-UNNAMED\" })\n-    @OutputTimeUnit(TimeUnit.SECONDS)\n-    public void cold8_Generate(Blackhole bh) throws IOException {\n-        compile(bh, Stage.Generate);\n-    }\n-\n-    @Benchmark\n-    @Group(HOT_GROUP_NAME)\n-    @BenchmarkMode(Mode.SingleShotTime)\n-    @Warmup(iterations = HOT_ITERATION_WARMUPS)\n-    @Measurement(iterations = HOT_ITERATIONS)\n-    @Fork(warmups = HOT_FORK_WARMUPS, value = HOT_FORKS, jvmArgsPrepend = { \"--add-exports=jdk.compiler\/com.sun.tools.javac.file=ALL-UNNAMED\", \"--add-exports=jdk.compiler\/com.sun.tools.javac.main=ALL-UNNAMED\",  \"--add-exports=jdk.compiler\/com.sun.tools.javac.util=ALL-UNNAMED\" })\n-    @OutputTimeUnit(TimeUnit.SECONDS)\n-    public void hot1_Init() throws InterruptedException {\n-        Stage.Init.waitFor();\n-    }\n-\n-    @Benchmark\n-    @Group(HOT_GROUP_NAME)\n-    @BenchmarkMode(Mode.SingleShotTime)\n-    @Warmup(iterations = HOT_ITERATION_WARMUPS)\n-    @Measurement(iterations = HOT_ITERATIONS)\n-    @Fork(warmups = HOT_FORK_WARMUPS, value = HOT_FORKS, jvmArgsPrepend = { \"--add-exports=jdk.compiler\/com.sun.tools.javac.file=ALL-UNNAMED\", \"--add-exports=jdk.compiler\/com.sun.tools.javac.main=ALL-UNNAMED\",  \"--add-exports=jdk.compiler\/com.sun.tools.javac.util=ALL-UNNAMED\" })\n-    @OutputTimeUnit(TimeUnit.SECONDS)\n-    public void hot2_Parse() throws InterruptedException {\n-        Stage.Parse.waitFor();\n-    }\n-\n-    @Benchmark\n-    @Group(HOT_GROUP_NAME)\n-    @BenchmarkMode(Mode.SingleShotTime)\n-    @Warmup(iterations = HOT_ITERATION_WARMUPS)\n-    @Measurement(iterations = HOT_ITERATIONS)\n-    @Fork(warmups = HOT_FORK_WARMUPS, value = HOT_FORKS, jvmArgsPrepend = { \"--add-exports=jdk.compiler\/com.sun.tools.javac.file=ALL-UNNAMED\", \"--add-exports=jdk.compiler\/com.sun.tools.javac.main=ALL-UNNAMED\",  \"--add-exports=jdk.compiler\/com.sun.tools.javac.util=ALL-UNNAMED\" })\n-    @OutputTimeUnit(TimeUnit.SECONDS)\n-    public void hot3_InitModules() throws InterruptedException {\n-        Stage.InitModules.waitFor();\n-    }\n-\n-    @Benchmark\n-    @Group(HOT_GROUP_NAME)\n-    @BenchmarkMode(Mode.SingleShotTime)\n-    @Warmup(iterations = HOT_ITERATION_WARMUPS)\n-    @Measurement(iterations = HOT_ITERATIONS)\n-    @Fork(warmups = HOT_FORK_WARMUPS, value = HOT_FORKS, jvmArgsPrepend = { \"--add-exports=jdk.compiler\/com.sun.tools.javac.file=ALL-UNNAMED\", \"--add-exports=jdk.compiler\/com.sun.tools.javac.main=ALL-UNNAMED\",  \"--add-exports=jdk.compiler\/com.sun.tools.javac.util=ALL-UNNAMED\" })\n-    @OutputTimeUnit(TimeUnit.SECONDS)\n-    public void hot4_Enter() throws InterruptedException {\n-        Stage.Enter.waitFor();\n-    }\n-\n-    @Benchmark\n-    @Group(HOT_GROUP_NAME)\n-    @BenchmarkMode(Mode.SingleShotTime)\n-    @Warmup(iterations = HOT_ITERATION_WARMUPS)\n-    @Measurement(iterations = HOT_ITERATIONS)\n-    @Fork(warmups = HOT_FORK_WARMUPS, value = HOT_FORKS, jvmArgsPrepend = { \"--add-exports=jdk.compiler\/com.sun.tools.javac.file=ALL-UNNAMED\", \"--add-exports=jdk.compiler\/com.sun.tools.javac.main=ALL-UNNAMED\",  \"--add-exports=jdk.compiler\/com.sun.tools.javac.util=ALL-UNNAMED\" })\n-    @OutputTimeUnit(TimeUnit.SECONDS)\n-    public void hot5_Attribute() throws InterruptedException {\n-        Stage.Attribute.waitFor();\n-    }\n-\n-    @Benchmark\n-    @Group(HOT_GROUP_NAME)\n-    @BenchmarkMode(Mode.SingleShotTime)\n-    @Warmup(iterations = HOT_ITERATION_WARMUPS)\n-    @Measurement(iterations = HOT_ITERATIONS)\n-    @Fork(warmups = HOT_FORK_WARMUPS, value = HOT_FORKS, jvmArgsPrepend = { \"--add-exports=jdk.compiler\/com.sun.tools.javac.file=ALL-UNNAMED\", \"--add-exports=jdk.compiler\/com.sun.tools.javac.main=ALL-UNNAMED\",  \"--add-exports=jdk.compiler\/com.sun.tools.javac.util=ALL-UNNAMED\" })\n-    @OutputTimeUnit(TimeUnit.SECONDS)\n-    public void hot6_Flow() throws InterruptedException {\n-        Stage.Flow.waitFor();\n-    }\n-\n-    @Benchmark\n-    @Group(HOT_GROUP_NAME)\n-    @BenchmarkMode(Mode.SingleShotTime)\n-    @Warmup(iterations = HOT_ITERATION_WARMUPS)\n-    @Measurement(iterations = HOT_ITERATIONS)\n-    @Fork(warmups = HOT_FORK_WARMUPS, value = HOT_FORKS, jvmArgsPrepend = { \"--add-exports=jdk.compiler\/com.sun.tools.javac.file=ALL-UNNAMED\", \"--add-exports=jdk.compiler\/com.sun.tools.javac.main=ALL-UNNAMED\",  \"--add-exports=jdk.compiler\/com.sun.tools.javac.util=ALL-UNNAMED\" })\n-    @OutputTimeUnit(TimeUnit.SECONDS)\n-    public void hot7_Desugar() throws InterruptedException {\n-        Stage.Desugar.waitFor();\n-    }\n-\n-    @Benchmark\n-    @Group(HOT_GROUP_NAME)\n-    @BenchmarkMode(Mode.SingleShotTime)\n-    @Warmup(iterations = HOT_ITERATION_WARMUPS)\n-    @Measurement(iterations = HOT_ITERATIONS)\n-    @Fork(warmups = HOT_FORK_WARMUPS, value = HOT_FORKS, jvmArgsPrepend = { \"--add-exports=jdk.compiler\/com.sun.tools.javac.file=ALL-UNNAMED\", \"--add-exports=jdk.compiler\/com.sun.tools.javac.main=ALL-UNNAMED\",  \"--add-exports=jdk.compiler\/com.sun.tools.javac.util=ALL-UNNAMED\" })\n-    @OutputTimeUnit(TimeUnit.SECONDS)\n-    public void hot8_Generate(Blackhole bh) throws IOException {\n-        compile(bh, Stage.Generate);\n-    }\n-}\n","filename":"test\/benchmarks\/micros-javac\/src\/main\/java\/org\/openjdk\/bench\/langtools\/javac\/GroupJavacBenchmark.java","additions":0,"deletions":231,"binary":false,"changes":231,"status":"deleted"},{"patch":"@@ -1,198 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.langtools.javac;\n-\n-import com.sun.tools.javac.comp.AttrContext;\n-import com.sun.tools.javac.comp.Env;\n-import com.sun.tools.javac.file.JavacFileManager;\n-import com.sun.tools.javac.main.JavaCompiler;\n-import com.sun.tools.javac.main.Main;\n-import com.sun.tools.javac.tree.JCTree;\n-import com.sun.tools.javac.util.Context;\n-import com.sun.tools.javac.util.Context.Factory;\n-import com.sun.tools.javac.util.List;\n-import com.sun.tools.javac.util.ListBuffer;\n-import com.sun.tools.javac.util.Pair;\n-import java.io.BufferedInputStream;\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.OutputStream;\n-import java.io.PrintStream;\n-import java.nio.charset.StandardCharsets;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.Comparator;\n-import java.util.Queue;\n-import static java.util.logging.Level.FINE;\n-import static java.util.logging.Level.CONFIG;\n-import java.util.logging.Logger;\n-import java.util.zip.ZipEntry;\n-import java.util.zip.ZipInputStream;\n-import javax.tools.FileObject;\n-import javax.tools.ForwardingJavaFileObject;\n-import javax.tools.JavaFileManager;\n-import javax.tools.JavaFileObject;\n-import org.openjdk.jmh.annotations.Level;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.TearDown;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-@State(Scope.Benchmark)\n-public class JavacBenchmark {\n-\n-    static final Logger LOG = Logger.getLogger(JavacBenchmark.class.getName());\n-\n-    public enum Stage {\n-        Init, Parse, InitModules, Enter, Attribute, Flow, Desugar, Generate;\n-\n-        public synchronized void waitFor() throws InterruptedException {\n-            wait();\n-        }\n-        public synchronized void notifyDone() {\n-            notifyAll();\n-            LOG.log(FINE, \"{0} finished.\", this.name());\n-        }\n-        public boolean isAfter(Stage other) {\n-            return ordinal() > other.ordinal();\n-        }\n-    }\n-\n-    private Path root;\n-    private Path srcList;\n-\n-    @Setup(Level.Trial)\n-    public void setup(Blackhole bh) throws IOException, InterruptedException {\n-        LOG.log(CONFIG, \"Release info of the sources to be compiled by the benchmark:\\n{0}\", new String(JavacBenchmark.class.getResourceAsStream(\"\/release\").readAllBytes(), StandardCharsets.UTF_8));\n-        root = Files.createTempDirectory(\"JavacBenchmarkRoot\");\n-        srcList = root.resolve(\"sources.list\");\n-        int i = 0;\n-        try (PrintStream srcListOut = new PrintStream(srcList.toFile())) {\n-            try (ZipInputStream zis = new ZipInputStream(new BufferedInputStream(JavacBenchmark.class.getResourceAsStream(\"\/src.zip\")))) {\n-                for (ZipEntry entry; (entry = zis.getNextEntry()) != null;) {\n-                    final String ename = entry.getName();\n-                    if (!ename.startsWith(\"java.desktop\") && !ename.startsWith(\"jdk.internal.vm.compiler\") && !ename.startsWith(\"jdk.aot\") && !ename.startsWith(\"jdk.accessibility\")) {\n-                        if (!entry.isDirectory() && ename.endsWith(\".java\")) {\n-                            Path dst = root.resolve(ename);\n-                            Files.createDirectories(dst.getParent());\n-                            Files.copy(zis, dst);\n-                            Files.readAllBytes(dst); \/\/reads all the file back to exclude antivirus scanning time from following measurements\n-                            srcListOut.println(dst.toString());\n-                            i++;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        Files.walk(root).map(Path::toFile).forEach(File::deleteOnExit); \/\/mark all files and folders for deletion on JVM exit for cases when tearDown is not executed\n-        Thread.sleep(10000); \/\/give some more time for the system to catch a breath for more precise measurement\n-        LOG.log(FINE, \"Extracted {0} sources.\", i);\n-    }\n-\n-    @TearDown(Level.Trial)\n-    public void tearDown() throws IOException {\n-        Files.walk(root).sorted(Comparator.reverseOrder()).map(Path::toFile).forEachOrdered(File::delete);\n-        LOG.fine(\"Sources deleted.\");\n-    }\n-\n-    protected void compile(Blackhole bh, final Stage stopAt) throws IOException {\n-        final OutputStream bhos = new OutputStream() {\n-            @Override\n-            public void write(int b) throws IOException {\n-                bh.consume(b);\n-            }\n-            @Override\n-            public void write(byte[] b, int off, int len) throws IOException {\n-                bh.consume(b);\n-            }\n-        };\n-        final Context ctx = new Context();\n-        \/\/inject JavaCompiler wrapping all measured methods so they directly report to the benchmark\n-        ctx.put(JavaCompiler.compilerKey, (Factory<JavaCompiler>)(c) -> {\n-            return new JavaCompiler(c) {\n-                @Override\n-                public List<JCTree.JCCompilationUnit> parseFiles(Iterable<JavaFileObject> fileObjects) {\n-                    Stage.Init.notifyDone();\n-                    return stopAt.isAfter(Stage.Init) ? super.parseFiles(fileObjects) : List.nil();\n-                }\n-\n-                @Override\n-                public List<JCTree.JCCompilationUnit> initModules(List<JCTree.JCCompilationUnit> roots) {\n-                    Stage.Parse.notifyDone();\n-                    return stopAt.isAfter(Stage.Parse) ? super.initModules(roots) : List.nil();\n-                }\n-\n-                @Override\n-                public List<JCTree.JCCompilationUnit> enterTrees(List<JCTree.JCCompilationUnit> roots) {\n-                    Stage.InitModules.notifyDone();\n-                    return stopAt.isAfter(Stage.InitModules) ? super.enterTrees(roots) : List.nil();\n-                }\n-\n-                @Override\n-                public Queue<Env<AttrContext>> attribute(Queue<Env<AttrContext>> envs) {\n-                    Stage.Enter.notifyDone();\n-                    return stopAt.isAfter(Stage.Enter) ? super.attribute(envs) : new ListBuffer<>();\n-                }\n-\n-                @Override\n-                public Queue<Env<AttrContext>> flow(Queue<Env<AttrContext>> envs) {\n-                    Stage.Attribute.notifyDone();\n-                    return stopAt.isAfter(Stage.Attribute) ? super.flow(envs) : new ListBuffer<>();\n-                }\n-\n-                @Override\n-                public Queue<Pair<Env<AttrContext>, JCTree.JCClassDecl>> desugar(Queue<Env<AttrContext>> envs) {\n-                    Stage.Flow.notifyDone();\n-                    return stopAt.isAfter(Stage.Flow) ? super.desugar(envs) : new ListBuffer<>();\n-                }\n-\n-                @Override\n-                public void generate(Queue<Pair<Env<AttrContext>, JCTree.JCClassDecl>> queue) {\n-                    Stage.Desugar.notifyDone();\n-                    if (stopAt.isAfter(Stage.Desugar)) super.generate(queue);\n-                }\n-            };\n-        });\n-        \/\/JavaFileManager directing all writes to a Blackhole to avoid measurement fluctuations due to delayed filesystem writes\n-        try (JavacFileManager mngr = new JavacFileManager(ctx, true, null) {\n-            @Override\n-            public JavaFileObject getJavaFileForOutput(JavaFileManager.Location arg0, String arg1, JavaFileObject.Kind arg2, FileObject arg3) throws IOException {\n-                return new ForwardingJavaFileObject<JavaFileObject>(super.getJavaFileForOutput(arg0, arg1, arg2, arg3)) {\n-                    @Override\n-                    public OutputStream openOutputStream() throws IOException {\n-                        return bhos;\n-                    }\n-                };\n-            }\n-        }) {\n-            String[] cmdLine = new String[] {\"-XDcompilePolicy=simple\", \"-implicit:none\", \"-nowarn\", \"--module-source-path\", root.toString(), \"-d\", root.toString(), \"-XDignore.symbol.file=true\", \"@\" + srcList.toString()};\n-            if (new Main(\"javac\").compile(cmdLine, ctx).exitCode != 0) {\n-                throw new IOException(\"compilation failed\");\n-            }\n-        }\n-        LOG.fine(\"Compilation finished.\");\n-    }\n-}\n","filename":"test\/benchmarks\/micros-javac\/src\/main\/java\/org\/openjdk\/bench\/langtools\/javac\/JavacBenchmark.java","additions":0,"deletions":198,"binary":false,"changes":198,"status":"deleted"},{"patch":"@@ -1,69 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.langtools.javac;\n-\n-import java.io.IOException;\n-import java.util.concurrent.TimeUnit;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Threads;\n-import org.openjdk.jmh.annotations.Warmup;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-@State(Scope.Benchmark)\n-public class SingleJavacBenchmark extends JavacBenchmark {\n-\n-    @Param\n-    public Stage stopStage;\n-\n-    @Benchmark\n-    @Threads(1)\n-    @BenchmarkMode(Mode.SingleShotTime)\n-    @Warmup(iterations = 0)\n-    @Measurement(iterations = 1)\n-    @Fork(warmups = 1, value = 15, jvmArgsPrepend = { \"--add-exports=jdk.compiler\/com.sun.tools.javac.file=ALL-UNNAMED\", \"--add-exports=jdk.compiler\/com.sun.tools.javac.main=ALL-UNNAMED\",  \"--add-exports=jdk.compiler\/com.sun.tools.javac.util=ALL-UNNAMED\" })\n-    @OutputTimeUnit(TimeUnit.SECONDS)\n-    public void compileCold(Blackhole bh) throws IOException {\n-        compile(bh, stopStage);\n-    }\n-\n-    @Benchmark\n-    @Threads(1)\n-    @BenchmarkMode(Mode.SingleShotTime)\n-    @Warmup(iterations = 8)\n-    @Measurement(iterations = 10)\n-    @Fork(warmups = 0, value = 1, jvmArgsPrepend = { \"--add-exports=jdk.compiler\/com.sun.tools.javac.file=ALL-UNNAMED\", \"--add-exports=jdk.compiler\/com.sun.tools.javac.main=ALL-UNNAMED\",  \"--add-exports=jdk.compiler\/com.sun.tools.javac.util=ALL-UNNAMED\" })\n-    @OutputTimeUnit(TimeUnit.SECONDS)\n-    public void compileHot(Blackhole bh) throws IOException {\n-        compile(bh, stopStage);\n-    }\n-}\n","filename":"test\/benchmarks\/micros-javac\/src\/main\/java\/org\/openjdk\/bench\/langtools\/javac\/SingleJavacBenchmark.java","additions":0,"deletions":69,"binary":false,"changes":69,"status":"deleted"},{"patch":"@@ -3,1 +3,1 @@\n-# Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,2 +42,0 @@\n-\n-jdk\/javadoc\/doccheck\/checks\/jdkCheckLinks.java 8370249 generic-all\n","filename":"test\/docs\/ProblemList.txt","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2146,4 +2146,0 @@\n-                        [\"splice\",   \"__ sve_splice(z0, __ B, p0, z1);\",                   \"splice\\tz0.b, p0, z0.b, z1.b\"],\n-                        [\"splice\",   \"__ sve_splice(z0, __ H, p0, z1);\",                   \"splice\\tz0.h, p0, z0.h, z1.h\"],\n-                        [\"splice\",   \"__ sve_splice(z0, __ S, p0, z1);\",                   \"splice\\tz0.s, p0, z0.s, z1.s\"],\n-                        [\"splice\",   \"__ sve_splice(z0, __ D, p0, z1);\",                   \"splice\\tz0.d, p0, z0.d, z1.d\"],\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1159,4 +1159,0 @@\n-    __ sve_splice(z0, __ B, p0, z1);                   \/\/       splice  z0.b, p0, z0.b, z1.b\n-    __ sve_splice(z0, __ H, p0, z1);                   \/\/       splice  z0.h, p0, z0.h, z1.h\n-    __ sve_splice(z0, __ S, p0, z1);                   \/\/       splice  z0.s, p0, z0.s, z1.s\n-    __ sve_splice(z0, __ D, p0, z1);                   \/\/       splice  z0.d, p0, z0.d, z1.d\n@@ -1452,7 +1448,7 @@\n-    0x14000000,     0x17ffffd7,     0x140004bb,     0x94000000,\n-    0x97ffffd4,     0x940004b8,     0x3400000a,     0x34fffa2a,\n-    0x340096aa,     0x35000008,     0x35fff9c8,     0x35009648,\n-    0xb400000b,     0xb4fff96b,     0xb40095eb,     0xb500001d,\n-    0xb5fff91d,     0xb500959d,     0x10000013,     0x10fff8b3,\n-    0x10009533,     0x90000013,     0x36300016,     0x3637f836,\n-    0x363094b6,     0x3758000c,     0x375ff7cc,     0x3758944c,\n+    0x14000000,     0x17ffffd7,     0x140004b7,     0x94000000,\n+    0x97ffffd4,     0x940004b4,     0x3400000a,     0x34fffa2a,\n+    0x3400962a,     0x35000008,     0x35fff9c8,     0x350095c8,\n+    0xb400000b,     0xb4fff96b,     0xb400956b,     0xb500001d,\n+    0xb5fff91d,     0xb500951d,     0x10000013,     0x10fff8b3,\n+    0x100094b3,     0x90000013,     0x36300016,     0x3637f836,\n+    0x36309436,     0x3758000c,     0x375ff7cc,     0x375893cc,\n@@ -1463,13 +1459,13 @@\n-    0x54009220,     0x54000001,     0x54fff541,     0x540091c1,\n-    0x54000002,     0x54fff4e2,     0x54009162,     0x54000002,\n-    0x54fff482,     0x54009102,     0x54000003,     0x54fff423,\n-    0x540090a3,     0x54000003,     0x54fff3c3,     0x54009043,\n-    0x54000004,     0x54fff364,     0x54008fe4,     0x54000005,\n-    0x54fff305,     0x54008f85,     0x54000006,     0x54fff2a6,\n-    0x54008f26,     0x54000007,     0x54fff247,     0x54008ec7,\n-    0x54000008,     0x54fff1e8,     0x54008e68,     0x54000009,\n-    0x54fff189,     0x54008e09,     0x5400000a,     0x54fff12a,\n-    0x54008daa,     0x5400000b,     0x54fff0cb,     0x54008d4b,\n-    0x5400000c,     0x54fff06c,     0x54008cec,     0x5400000d,\n-    0x54fff00d,     0x54008c8d,     0x5400000e,     0x54ffefae,\n-    0x54008c2e,     0x5400000f,     0x54ffef4f,     0x54008bcf,\n+    0x540091a0,     0x54000001,     0x54fff541,     0x54009141,\n+    0x54000002,     0x54fff4e2,     0x540090e2,     0x54000002,\n+    0x54fff482,     0x54009082,     0x54000003,     0x54fff423,\n+    0x54009023,     0x54000003,     0x54fff3c3,     0x54008fc3,\n+    0x54000004,     0x54fff364,     0x54008f64,     0x54000005,\n+    0x54fff305,     0x54008f05,     0x54000006,     0x54fff2a6,\n+    0x54008ea6,     0x54000007,     0x54fff247,     0x54008e47,\n+    0x54000008,     0x54fff1e8,     0x54008de8,     0x54000009,\n+    0x54fff189,     0x54008d89,     0x5400000a,     0x54fff12a,\n+    0x54008d2a,     0x5400000b,     0x54fff0cb,     0x54008ccb,\n+    0x5400000c,     0x54fff06c,     0x54008c6c,     0x5400000d,\n+    0x54fff00d,     0x54008c0d,     0x5400000e,     0x54ffefae,\n+    0x54008bae,     0x5400000f,     0x54ffef4f,     0x54008b4f,\n@@ -1696,2 +1692,1 @@\n-    0x6585c891,     0x65c5c891,     0x052c8020,     0x056c8020,\n-    0x05ac8020,     0x05ec8020,     0x45b0c210,     0x45f1c231,\n+    0x6585c891,     0x65c5c891,     0x45b0c210,     0x45f1c231,\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":21,"deletions":26,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"memory\/arena.hpp\"\n@@ -146,15 +145,0 @@\n-static void test_chunkpool_lock() {\n-  if (!MemTracker::enabled()) {\n-    tty->print_cr(\"Skipped\");\n-    return;\n-  }\n-  PrintNMTStatistics = true;\n-  {\n-    ChunkPoolLocker cpl;\n-    char* mem = (char*)os::malloc(100, mtTest);\n-    memset(mem - 16, 0, 100 + 16 + 2);\n-    os::free(mem);\n-  }\n-}\n-DEFINE_TEST(test_chunkpool_lock, COMMON_NMT_HEAP_CORRUPTION_MESSAGE_PREFIX);\n-\n@@ -183,10 +167,0 @@\n-TEST_VM_FATAL_ERROR_MSG(NMT, memory_corruption_call_stack, \".*header canary.*\") {\n-  if (MemTracker::tracking_level() != NMT_detail) {\n-    guarantee(false, \"fake message ignore this - header canary\");\n-  }\n-  const size_t SIZE = 1024;\n-  char* p = (char*)os::malloc(SIZE, mtTest);\n-  *(p - 1) = 0;\n-  os::free(p);\n-}\n-\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_buffer_overflow_detection.cpp","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-  ASSERT_TRUE(rm.size() == expected);\n+  ASSERT_TRUE(rm.Size() == expected);\n@@ -38,1 +38,1 @@\n-    ASSERT_TRUE(!rm.is_empty());\n+    ASSERT_TRUE(!rm.is_Empty());\n@@ -40,1 +40,1 @@\n-    ASSERT_TRUE(rm.is_empty());\n+    ASSERT_TRUE(rm.is_Empty());\n@@ -63,8 +63,8 @@\n-  rm.insert(30);\n-  rm.insert(31);\n-  rm.insert(32);\n-  rm.insert(33);\n-  rm.insert(62);\n-  rm.insert(63);\n-  rm.insert(64);\n-  rm.insert(65);\n+  rm.Insert(30);\n+  rm.Insert(31);\n+  rm.Insert(32);\n+  rm.Insert(33);\n+  rm.Insert(62);\n+  rm.Insert(63);\n+  rm.Insert(64);\n+  rm.Insert(65);\n@@ -85,1 +85,1 @@\n-  \/\/ Check that set_all doesn't add bits outside of rm.rm_size_bits()\n+  \/\/ Check that Set_All doesn't add bits outside of rm.rm_size_bits()\n@@ -87,4 +87,4 @@\n-  rm.set_all();\n-  ASSERT_TRUE(rm.size() == rm.rm_size_in_bits());\n-  ASSERT_TRUE(!rm.is_empty());\n-  \/\/ set_all sets infinite_stack\n+  rm.Set_All();\n+  ASSERT_TRUE(rm.Size() == rm.rm_size_in_bits());\n+  ASSERT_TRUE(!rm.is_Empty());\n+  \/\/ Set_All sets infinite_stack\n@@ -98,2 +98,2 @@\n-  rm.set_all();\n-  rm.clear();\n+  rm.Set_All();\n+  rm.Clear();\n@@ -103,1 +103,1 @@\n-TEST_VM(RegMask, and_with) {\n+TEST_VM(RegMask, AND) {\n@@ -105,1 +105,1 @@\n-  rm1.insert(OptoReg::Name(1));\n+  rm1.Insert(OptoReg::Name(1));\n@@ -107,1 +107,1 @@\n-  ASSERT_TRUE(rm1.member(OptoReg::Name(1)));\n+  ASSERT_TRUE(rm1.Member(OptoReg::Name(1)));\n@@ -109,1 +109,1 @@\n-  rm1.and_with(rm1);\n+  rm1.AND(rm1);\n@@ -113,1 +113,1 @@\n-  rm1.and_with(rm2);\n+  rm1.AND(rm2);\n@@ -118,1 +118,1 @@\n-TEST_VM(RegMask, or_with) {\n+TEST_VM(RegMask, OR) {\n@@ -120,1 +120,1 @@\n-  rm1.insert(OptoReg::Name(1));\n+  rm1.Insert(OptoReg::Name(1));\n@@ -122,1 +122,1 @@\n-  ASSERT_TRUE(rm1.member(OptoReg::Name(1)));\n+  ASSERT_TRUE(rm1.Member(OptoReg::Name(1)));\n@@ -124,1 +124,1 @@\n-  rm1.or_with(rm1);\n+  rm1.OR(rm1);\n@@ -128,1 +128,1 @@\n-  rm1.or_with(rm2);\n+  rm1.OR(rm2);\n@@ -133,1 +133,1 @@\n-TEST_VM(RegMask, subtract) {\n+TEST_VM(RegMask, SUBTRACT) {\n@@ -137,1 +137,1 @@\n-  rm2.set_all();\n+  rm2.Set_All();\n@@ -139,1 +139,1 @@\n-    rm1.insert(i);\n+    rm1.Insert(i);\n@@ -143,1 +143,1 @@\n-  rm2.subtract(rm1);\n+  rm2.SUBTRACT(rm1);\n@@ -148,1 +148,1 @@\n-TEST_VM(RegMask, subtract_inner) {\n+TEST_VM(RegMask, SUBTRACT_inner) {\n@@ -151,1 +151,1 @@\n-  rm2.set_all();\n+  rm2.Set_All();\n@@ -153,1 +153,1 @@\n-    rm1.insert(i);\n+    rm1.Insert(i);\n@@ -155,1 +155,1 @@\n-  rm2.subtract_inner(rm1);\n+  rm2.SUBTRACT_inner(rm1);\n@@ -164,1 +164,1 @@\n-    rm.insert(i);\n+    rm.Insert(i);\n@@ -168,1 +168,1 @@\n-    rm.remove(i);\n+    rm.Remove(i);\n@@ -179,2 +179,2 @@\n-    rm.insert(i);\n-    rm.insert(i + 1);\n+    rm.Insert(i);\n+    rm.Insert(i + 1);\n@@ -185,1 +185,1 @@\n-    rm.clear();\n+    rm.Clear();\n@@ -188,3 +188,3 @@\n-  rm.clear();\n-  rm.insert(rm.rm_size_in_bits() - 2);\n-  rm.insert(rm.rm_size_in_bits() - 1);\n+  rm.Clear();\n+  rm.Insert(rm.rm_size_in_bits() - 2);\n+  rm.Insert(rm.rm_size_in_bits() - 1);\n@@ -201,1 +201,1 @@\n-        rm.insert(j);\n+        rm.Insert(j);\n@@ -205,1 +205,1 @@\n-      rm.clear();\n+      rm.Clear();\n@@ -209,1 +209,1 @@\n-      rm.insert(j);\n+      rm.Insert(j);\n@@ -213,1 +213,1 @@\n-    rm.clear();\n+    rm.Clear();\n@@ -220,1 +220,1 @@\n-  ASSERT_FALSE(rm.member(OptoReg::Name(rm.rm_size_in_bits())));\n+  ASSERT_FALSE(rm.Member(OptoReg::Name(rm.rm_size_in_bits())));\n@@ -222,1 +222,1 @@\n-  ASSERT_TRUE(rm.member(OptoReg::Name(rm.rm_size_in_bits())));\n+  ASSERT_TRUE(rm.Member(OptoReg::Name(rm.rm_size_in_bits())));\n@@ -227,3 +227,3 @@\n-  rm.insert(OptoReg::Name(44));\n-  rm.insert(OptoReg::Name(30));\n-  rm.insert(OptoReg::Name(54));\n+  rm.Insert(OptoReg::Name(44));\n+  rm.Insert(OptoReg::Name(30));\n+  rm.Insert(OptoReg::Name(54));\n@@ -234,1 +234,1 @@\n-  rm.clear();\n+  rm.Clear();\n@@ -245,8 +245,8 @@\n-  rm.insert(OptoReg::Name(24));\n-  rm.insert(OptoReg::Name(25));\n-  rm.insert(OptoReg::Name(26));\n-  rm.insert(OptoReg::Name(27));\n-  rm.insert(OptoReg::Name(16));\n-  rm.insert(OptoReg::Name(17));\n-  rm.insert(OptoReg::Name(18));\n-  rm.insert(OptoReg::Name(19));\n+  rm.Insert(OptoReg::Name(24));\n+  rm.Insert(OptoReg::Name(25));\n+  rm.Insert(OptoReg::Name(26));\n+  rm.Insert(OptoReg::Name(27));\n+  rm.Insert(OptoReg::Name(16));\n+  rm.Insert(OptoReg::Name(17));\n+  rm.Insert(OptoReg::Name(18));\n+  rm.Insert(OptoReg::Name(19));\n@@ -258,2 +258,2 @@\n-  rm.insert(OptoReg::Name(30));\n-  rm.insert(OptoReg::Name(31));\n+  rm.Insert(OptoReg::Name(30));\n+  rm.Insert(OptoReg::Name(31));\n@@ -261,6 +261,6 @@\n-  rm.insert(OptoReg::Name(32));\n-  rm.insert(OptoReg::Name(37));\n-  rm.insert(OptoReg::Name(62));\n-  rm.insert(OptoReg::Name(71));\n-  rm.insert(OptoReg::Name(74));\n-  rm.insert(OptoReg::Name(75));\n+  rm.Insert(OptoReg::Name(32));\n+  rm.Insert(OptoReg::Name(37));\n+  rm.Insert(OptoReg::Name(62));\n+  rm.Insert(OptoReg::Name(71));\n+  rm.Insert(OptoReg::Name(74));\n+  rm.Insert(OptoReg::Name(75));\n@@ -272,4 +272,4 @@\n-  ASSERT_TRUE(rm.member(OptoReg::Name(30)));\n-  ASSERT_TRUE(rm.member(OptoReg::Name(31)));\n-  ASSERT_TRUE(rm.member(OptoReg::Name(74)));\n-  ASSERT_TRUE(rm.member(OptoReg::Name(75)));\n+  ASSERT_TRUE(rm.Member(OptoReg::Name(30)));\n+  ASSERT_TRUE(rm.Member(OptoReg::Name(31)));\n+  ASSERT_TRUE(rm.Member(OptoReg::Name(74)));\n+  ASSERT_TRUE(rm.Member(OptoReg::Name(75)));\n@@ -277,2 +277,2 @@\n-  rm.remove(OptoReg::Name(30));\n-  rm.remove(OptoReg::Name(74));\n+  rm.Remove(OptoReg::Name(30));\n+  rm.Remove(OptoReg::Name(74));\n@@ -284,13 +284,13 @@\n-  rm.insert(OptoReg::Name(3));\n-  rm.insert(OptoReg::Name(20));\n-  rm.insert(OptoReg::Name(21));\n-  rm.insert(OptoReg::Name(22));\n-  rm.insert(OptoReg::Name(23));\n-  rm.insert(OptoReg::Name(25));\n-  rm.insert(OptoReg::Name(26));\n-  rm.insert(OptoReg::Name(27));\n-  rm.insert(OptoReg::Name(40));\n-  rm.insert(OptoReg::Name(42));\n-  rm.insert(OptoReg::Name(43));\n-  rm.insert(OptoReg::Name(44));\n-  rm.insert(OptoReg::Name(45));\n+  rm.Insert(OptoReg::Name(3));\n+  rm.Insert(OptoReg::Name(20));\n+  rm.Insert(OptoReg::Name(21));\n+  rm.Insert(OptoReg::Name(22));\n+  rm.Insert(OptoReg::Name(23));\n+  rm.Insert(OptoReg::Name(25));\n+  rm.Insert(OptoReg::Name(26));\n+  rm.Insert(OptoReg::Name(27));\n+  rm.Insert(OptoReg::Name(40));\n+  rm.Insert(OptoReg::Name(42));\n+  rm.Insert(OptoReg::Name(43));\n+  rm.Insert(OptoReg::Name(44));\n+  rm.Insert(OptoReg::Name(45));\n@@ -310,1 +310,1 @@\n-  rm.insert(OptoReg::Name(3));\n+  rm.Insert(OptoReg::Name(3));\n@@ -330,5 +330,5 @@\n-  rm1.insert(OptoReg::Name(23));\n-  rm1.insert(OptoReg::Name(2));\n-  rm1.insert(OptoReg::Name(12));\n-  rm2.insert(OptoReg::Name(1));\n-  rm2.insert(OptoReg::Name(4));\n+  rm1.Insert(OptoReg::Name(23));\n+  rm1.Insert(OptoReg::Name(2));\n+  rm1.Insert(OptoReg::Name(12));\n+  rm2.Insert(OptoReg::Name(1));\n+  rm2.Insert(OptoReg::Name(4));\n@@ -337,1 +337,1 @@\n-  rm1.insert(OptoReg::Name(4));\n+  rm1.Insert(OptoReg::Name(4));\n@@ -345,4 +345,4 @@\n-  rm.insert(OptoReg::Name(3));\n-  rm.insert(OptoReg::Name(5));\n-  rm.insert(OptoReg::Name(6));\n-  rm.insert(OptoReg::Name(7));\n+  rm.Insert(OptoReg::Name(3));\n+  rm.Insert(OptoReg::Name(5));\n+  rm.Insert(OptoReg::Name(6));\n+  rm.Insert(OptoReg::Name(7));\n@@ -358,1 +358,1 @@\n-  ASSERT_TRUE(rm.member(reg1));\n+  ASSERT_TRUE(rm.Member(reg1));\n@@ -360,5 +360,5 @@\n-  rm.clear();\n-  rm.insert(reg1);\n-  ASSERT_TRUE(rm.member(reg1));\n-  rm.remove(reg1);\n-  ASSERT_FALSE(rm.member(reg1));\n+  rm.Clear();\n+  rm.Insert(reg1);\n+  ASSERT_TRUE(rm.Member(reg1));\n+  rm.Remove(reg1);\n+  ASSERT_FALSE(rm.Member(reg1));\n@@ -367,4 +367,4 @@\n-  rm.clear();\n-  rm.insert(reg2);\n-  ASSERT_FALSE(rm.member(reg1));\n-  ASSERT_TRUE(rm.member(reg2));\n+  rm.Clear();\n+  rm.Insert(reg2);\n+  ASSERT_FALSE(rm.Member(reg1));\n+  ASSERT_TRUE(rm.Member(reg2));\n@@ -379,1 +379,1 @@\n-  rm.clear();\n+  rm.Clear();\n@@ -382,2 +382,2 @@\n-  rm.insert(reg1);\n-  rm.insert(reg2);\n+  rm.Insert(reg1);\n+  rm.Insert(reg2);\n@@ -403,1 +403,1 @@\n-  rm.clear();\n+  rm.Clear();\n@@ -405,8 +405,8 @@\n-  rm.insert(reg1);\n-  rm.insert(reg2);\n-  rm.insert(reg3);\n-  rm.insert(reg4);\n-  rm.insert(reg5);\n-  rm.insert(reg6);\n-  rm.insert(reg7);\n-  rm.insert(reg8);\n+  rm.Insert(reg1);\n+  rm.Insert(reg2);\n+  rm.Insert(reg3);\n+  rm.Insert(reg4);\n+  rm.Insert(reg5);\n+  rm.Insert(reg6);\n+  rm.Insert(reg7);\n+  rm.Insert(reg8);\n@@ -416,1 +416,1 @@\n-TEST_VM(RegMask, rollover_and_set_all_from) {\n+TEST_VM(RegMask, rollover_and_Set_All_From) {\n@@ -421,2 +421,2 @@\n-  rm.clear();\n-  rm.set_all_from(reg1);\n+  rm.Clear();\n+  rm.Set_All_From(reg1);\n@@ -426,1 +426,1 @@\n-TEST_VM(RegMask, rollover_and_set_all_from_offset) {\n+TEST_VM(RegMask, rollover_and_Set_All_From_Offset) {\n@@ -430,2 +430,2 @@\n-  rm.clear();\n-  rm.set_all_from_offset();\n+  rm.Clear();\n+  rm.Set_All_From_Offset();\n@@ -443,5 +443,5 @@\n-  rm.clear();\n-  rm.insert(reg1);\n-  rm.insert(reg2);\n-  rm.insert(reg3);\n-  rm.insert(reg4);\n+  rm.Clear();\n+  rm.Insert(reg1);\n+  rm.Insert(reg2);\n+  rm.Insert(reg3);\n+  rm.Insert(reg4);\n@@ -456,1 +456,1 @@\n-TEST_VM(RegMask, rollover_and_subtract_inner_disjoint) {\n+TEST_VM(RegMask, rollover_and_SUBTRACT_inner_disjoint) {\n@@ -462,2 +462,2 @@\n-  rm1.clear();\n-  rm1.subtract_inner(rm2);\n+  rm1.Clear();\n+  rm1.SUBTRACT_inner(rm2);\n@@ -465,1 +465,1 @@\n-  rm2.subtract_inner(rm1);\n+  rm2.SUBTRACT_inner(rm1);\n@@ -467,3 +467,3 @@\n-  rm1.insert(reg1);\n-  rm2.insert(42);\n-  rm1.subtract_inner(rm2);\n+  rm1.Insert(reg1);\n+  rm2.Insert(42);\n+  rm1.SUBTRACT_inner(rm2);\n@@ -471,1 +471,1 @@\n-  rm2.subtract_inner(rm1);\n+  rm2.SUBTRACT_inner(rm1);\n@@ -475,1 +475,1 @@\n-TEST_VM(RegMask, rollover_and_subtract_inner_overlap) {\n+TEST_VM(RegMask, rollover_and_SUBTRACT_inner_overlap) {\n@@ -481,1 +481,1 @@\n-  rm1.clear();\n+  rm1.Clear();\n@@ -484,2 +484,2 @@\n-  rm2.clear();\n-  rm1.subtract_inner(rm2);\n+  rm2.Clear();\n+  rm1.SUBTRACT_inner(rm2);\n@@ -487,1 +487,1 @@\n-  rm2.subtract_inner(rm1);\n+  rm2.SUBTRACT_inner(rm1);\n@@ -489,3 +489,3 @@\n-  rm1.insert(reg1);\n-  rm2.insert(reg1);\n-  rm1.subtract_inner(rm2);\n+  rm1.Insert(reg1);\n+  rm2.Insert(reg1);\n+  rm1.SUBTRACT_inner(rm2);\n@@ -493,2 +493,2 @@\n-  rm1.insert(reg1);\n-  rm2.subtract_inner(rm1);\n+  rm1.Insert(reg1);\n+  rm2.SUBTRACT_inner(rm1);\n@@ -505,1 +505,1 @@\n-  rm2.member(0); \/\/ Safeguard in RegMask must catch this.\n+  rm2.Member(0); \/\/ Safeguard in RegMask must catch this.\n@@ -511,1 +511,1 @@\n-  rm.insert(std::numeric_limits<OptoReg::Name>::max());\n+  rm.Insert(std::numeric_limits<OptoReg::Name>::max());\n@@ -518,1 +518,1 @@\n-  rm.insert(rm.rm_size_in_bits());\n+  rm.Insert(rm.rm_size_in_bits());\n@@ -526,2 +526,2 @@\n-  \/\/ Cannot assign with different offsets\n-  rm2.assignFrom(rm1);\n+  \/\/ Cannot copy with different offsets\n+  rm2 = rm1;\n@@ -552,2 +552,2 @@\n-  rm.insert(OptoReg::Name(first_extended() + (BitsPerWord * n) - 1));\n-  rm.clear();\n+  rm.Insert(OptoReg::Name(first_extended() + (BitsPerWord * n) - 1));\n+  rm.Clear();\n@@ -565,8 +565,8 @@\n-  rm.insert(30);\n-  rm.insert(31);\n-  rm.insert(33);\n-  rm.insert(62);\n-  rm.insert(first_extended());\n-  rm.insert(first_extended() + 42);\n-  rm.insert(first_extended() + 55);\n-  rm.insert(first_extended() + 456);\n+  rm.Insert(30);\n+  rm.Insert(31);\n+  rm.Insert(33);\n+  rm.Insert(62);\n+  rm.Insert(first_extended());\n+  rm.Insert(first_extended() + 42);\n+  rm.Insert(first_extended() + 55);\n+  rm.Insert(first_extended() + 456);\n@@ -586,2 +586,2 @@\n-TEST_VM(RegMask, set_all_extended) {\n-  \/\/ Check that set_all doesn't add bits outside of rm.rm_size_bits() on\n+TEST_VM(RegMask, Set_ALL_extended) {\n+  \/\/ Check that Set_All doesn't add bits outside of rm.rm_size_bits() on\n@@ -591,4 +591,4 @@\n-  rm.set_all();\n-  ASSERT_EQ(rm.size(), rm.rm_size_in_bits());\n-  ASSERT_TRUE(!rm.is_empty());\n-  \/\/ set_all sets infinite_stack bit\n+  rm.Set_All();\n+  ASSERT_EQ(rm.Size(), rm.rm_size_in_bits());\n+  ASSERT_TRUE(!rm.is_Empty());\n+  \/\/ Set_All sets infinite_stack bit\n@@ -599,1 +599,1 @@\n-TEST_VM(RegMask, set_all_from_extended) {\n+TEST_VM(RegMask, Set_ALL_From_extended) {\n@@ -602,1 +602,1 @@\n-  rm.set_all_from(OptoReg::Name(42));\n+  rm.Set_All_From(OptoReg::Name(42));\n@@ -606,1 +606,1 @@\n-TEST_VM(RegMask, set_all_from_extended_grow) {\n+TEST_VM(RegMask, Set_ALL_From_extended_grow) {\n@@ -608,1 +608,1 @@\n-  rm.set_all_from(first_extended() + OptoReg::Name(42));\n+  rm.Set_All_From(first_extended() + OptoReg::Name(42));\n@@ -613,2 +613,2 @@\n-TEST_VM(RegMask, clear_extended) {\n-  \/\/ Check that clear doesn't leave any stray bits on extended RegMasks.\n+TEST_VM(RegMask, Clear_extended) {\n+  \/\/ Check that Clear doesn't leave any stray bits on extended RegMasks.\n@@ -616,1 +616,1 @@\n-  rm.insert(first_extended());\n+  rm.Insert(first_extended());\n@@ -618,2 +618,2 @@\n-  rm.set_all();\n-  rm.clear();\n+  rm.Set_All();\n+  rm.Clear();\n@@ -623,1 +623,1 @@\n-TEST_VM(RegMask, and_with_extended_basic) {\n+TEST_VM(RegMask, AND_extended_basic) {\n@@ -625,1 +625,1 @@\n-  rm1.insert(OptoReg::Name(first_extended()));\n+  rm1.Insert(OptoReg::Name(first_extended()));\n@@ -628,1 +628,1 @@\n-  ASSERT_TRUE(rm1.member(OptoReg::Name(first_extended())));\n+  ASSERT_TRUE(rm1.Member(OptoReg::Name(first_extended())));\n@@ -630,1 +630,1 @@\n-  rm1.and_with(rm1);\n+  rm1.AND(rm1);\n@@ -635,1 +635,1 @@\n-  rm1.and_with(rm2);\n+  rm1.AND(rm2);\n@@ -640,1 +640,1 @@\n-TEST_VM(RegMask, and_with_extended_extended) {\n+TEST_VM(RegMask, AND_extended_extended) {\n@@ -642,1 +642,1 @@\n-  rm1.insert(OptoReg::Name(first_extended()));\n+  rm1.Insert(OptoReg::Name(first_extended()));\n@@ -645,1 +645,1 @@\n-  ASSERT_TRUE(rm1.member(OptoReg::Name(first_extended())));\n+  ASSERT_TRUE(rm1.Member(OptoReg::Name(first_extended())));\n@@ -647,1 +647,1 @@\n-  rm1.and_with(rm1);\n+  rm1.AND(rm1);\n@@ -652,1 +652,1 @@\n-  rm1.and_with(rm2);\n+  rm1.AND(rm2);\n@@ -657,1 +657,1 @@\n-TEST_VM(RegMask, or_with_extended_basic) {\n+TEST_VM(RegMask, OR_extended_basic) {\n@@ -659,1 +659,1 @@\n-  rm1.insert(OptoReg::Name(first_extended()));\n+  rm1.Insert(OptoReg::Name(first_extended()));\n@@ -662,1 +662,1 @@\n-  ASSERT_TRUE(rm1.member(OptoReg::Name(first_extended())));\n+  ASSERT_TRUE(rm1.Member(OptoReg::Name(first_extended())));\n@@ -664,1 +664,1 @@\n-  rm1.or_with(rm1);\n+  rm1.OR(rm1);\n@@ -669,1 +669,1 @@\n-  rm1.or_with(rm2);\n+  rm1.OR(rm2);\n@@ -674,1 +674,1 @@\n-TEST_VM(RegMask, or_with_extended_extended) {\n+TEST_VM(RegMask, OR_extended_extended) {\n@@ -676,1 +676,1 @@\n-  rm1.insert(OptoReg::Name(first_extended()));\n+  rm1.Insert(OptoReg::Name(first_extended()));\n@@ -679,1 +679,1 @@\n-  ASSERT_TRUE(rm1.member(OptoReg::Name(first_extended())));\n+  ASSERT_TRUE(rm1.Member(OptoReg::Name(first_extended())));\n@@ -681,1 +681,1 @@\n-  rm1.or_with(rm1);\n+  rm1.OR(rm1);\n@@ -686,1 +686,1 @@\n-  rm1.or_with(rm2);\n+  rm1.OR(rm2);\n@@ -691,1 +691,1 @@\n-TEST_VM(RegMask, subtract_extended) {\n+TEST_VM(RegMask, SUBTRACT_extended) {\n@@ -697,1 +697,1 @@\n-  rm2.set_all();\n+  rm2.Set_All();\n@@ -700,1 +700,1 @@\n-    rm1.insert(i);\n+    rm1.Insert(i);\n@@ -704,1 +704,1 @@\n-  rm2.subtract(rm1);\n+  rm2.SUBTRACT(rm1);\n@@ -713,1 +713,1 @@\n-  ASSERT_FALSE(rm.member(OptoReg::Name(rm.rm_size_in_bits())));\n+  ASSERT_FALSE(rm.Member(OptoReg::Name(rm.rm_size_in_bits())));\n@@ -715,1 +715,1 @@\n-  ASSERT_TRUE(rm.member(OptoReg::Name(rm.rm_size_in_bits())));\n+  ASSERT_TRUE(rm.Member(OptoReg::Name(rm.rm_size_in_bits())));\n@@ -725,5 +725,5 @@\n-  rm1.insert(OptoReg::Name(23));\n-  rm1.insert(OptoReg::Name(2));\n-  rm1.insert(OptoReg::Name(first_extended() + 12));\n-  rm2.insert(OptoReg::Name(1));\n-  rm2.insert(OptoReg::Name(first_extended() + 4));\n+  rm1.Insert(OptoReg::Name(23));\n+  rm1.Insert(OptoReg::Name(2));\n+  rm1.Insert(OptoReg::Name(first_extended() + 12));\n+  rm2.Insert(OptoReg::Name(1));\n+  rm2.Insert(OptoReg::Name(first_extended() + 4));\n@@ -732,1 +732,1 @@\n-  rm1.insert(OptoReg::Name(first_extended() + 4));\n+  rm1.Insert(OptoReg::Name(first_extended() + 4));\n@@ -741,1 +741,1 @@\n-  rm.insert(OptoReg::Name(1));\n+  rm.Insert(OptoReg::Name(1));\n@@ -743,1 +743,1 @@\n-  rm.insert(OptoReg::Name(first_extended()));\n+  rm.Insert(OptoReg::Name(first_extended()));\n@@ -745,1 +745,1 @@\n-  rm.clear();\n+  rm.Clear();\n@@ -750,1 +750,1 @@\n-TEST_VM(RegMask, subtract_inner_basic_extended) {\n+TEST_VM(RegMask, SUBTRACT_inner_basic_extended) {\n@@ -753,2 +753,2 @@\n-  rm1.insert(OptoReg::Name(1));\n-  rm1.insert(OptoReg::Name(42));\n+  rm1.Insert(OptoReg::Name(1));\n+  rm1.Insert(OptoReg::Name(42));\n@@ -756,2 +756,2 @@\n-  rm2.insert(OptoReg::Name(1));\n-  rm2.insert(OptoReg::Name(first_extended() + 20));\n+  rm2.Insert(OptoReg::Name(1));\n+  rm2.Insert(OptoReg::Name(first_extended() + 20));\n@@ -759,1 +759,1 @@\n-  rm1.subtract_inner(rm2);\n+  rm1.SUBTRACT_inner(rm2);\n@@ -762,1 +762,1 @@\n-  ASSERT_TRUE(rm1.member(OptoReg::Name(42)));\n+  ASSERT_TRUE(rm1.Member(OptoReg::Name(42)));\n@@ -765,1 +765,1 @@\n-TEST_VM(RegMask, subtract_inner_extended_basic) {\n+TEST_VM(RegMask, SUBTRACT_inner_extended_basic) {\n@@ -768,3 +768,3 @@\n-  rm1.insert(OptoReg::Name(1));\n-  rm1.insert(OptoReg::Name(42));\n-  rm1.insert(OptoReg::Name(first_extended() + 20));\n+  rm1.Insert(OptoReg::Name(1));\n+  rm1.Insert(OptoReg::Name(42));\n+  rm1.Insert(OptoReg::Name(first_extended() + 20));\n@@ -772,1 +772,1 @@\n-  rm2.insert(OptoReg::Name(1));\n+  rm2.Insert(OptoReg::Name(1));\n@@ -774,1 +774,1 @@\n-  rm1.subtract_inner(rm2);\n+  rm1.SUBTRACT_inner(rm2);\n@@ -776,2 +776,2 @@\n-  ASSERT_TRUE(rm1.member(OptoReg::Name(42)));\n-  ASSERT_TRUE(rm1.member(OptoReg::Name(first_extended() + 20)));\n+  ASSERT_TRUE(rm1.Member(OptoReg::Name(42)));\n+  ASSERT_TRUE(rm1.Member(OptoReg::Name(first_extended() + 20)));\n@@ -787,2 +787,2 @@\n-  rm.insert(reg1);\n-  ASSERT_TRUE(rm.member(reg1));\n+  rm.Insert(reg1);\n+  ASSERT_TRUE(rm.Member(reg1));\n@@ -791,1 +791,1 @@\n-TEST_VM(RegMask, rollover_and_subtract_inner_disjoint_extended) {\n+TEST_VM(RegMask, rollover_and_SUBTRACT_inner_disjoint_extended) {\n@@ -798,2 +798,2 @@\n-  rm1.clear();\n-  rm1.subtract_inner(rm2);\n+  rm1.Clear();\n+  rm1.SUBTRACT_inner(rm2);\n@@ -801,1 +801,1 @@\n-  rm2.subtract_inner(rm1);\n+  rm2.SUBTRACT_inner(rm1);\n@@ -803,3 +803,3 @@\n-  rm1.insert(reg1);\n-  rm2.insert(42);\n-  rm1.subtract_inner(rm2);\n+  rm1.Insert(reg1);\n+  rm2.Insert(42);\n+  rm1.SUBTRACT_inner(rm2);\n@@ -807,1 +807,1 @@\n-  rm2.subtract_inner(rm1);\n+  rm2.SUBTRACT_inner(rm1);\n@@ -811,1 +811,1 @@\n-TEST_VM(RegMask, rollover_and_subtract_inner_overlap_extended) {\n+TEST_VM(RegMask, rollover_and_SUBTRACT_inner_overlap_extended) {\n@@ -818,2 +818,2 @@\n-  rm2.clear();\n-  rm1.subtract_inner(rm2);\n+  rm2.Clear();\n+  rm1.SUBTRACT_inner(rm2);\n@@ -821,1 +821,1 @@\n-  rm2.subtract_inner(rm1);\n+  rm2.SUBTRACT_inner(rm1);\n@@ -823,3 +823,3 @@\n-  rm1.insert(reg1);\n-  rm2.insert(reg1);\n-  rm1.subtract_inner(rm2);\n+  rm1.Insert(reg1);\n+  rm2.Insert(reg1);\n+  rm1.SUBTRACT_inner(rm2);\n@@ -827,2 +827,2 @@\n-  rm1.insert(reg1);\n-  rm2.subtract_inner(rm1);\n+  rm1.Insert(reg1);\n+  rm2.SUBTRACT_inner(rm1);\n@@ -858,1 +858,1 @@\n-  ASSERT_EQ(mask_ref.count_one_bits(), mask.size());\n+  ASSERT_EQ(mask_ref.count_one_bits(), mask.Size());\n@@ -873,1 +873,1 @@\n-  mask_aux.clear();\n+  mask_aux.Clear();\n@@ -939,1 +939,1 @@\n-    mask_aux.insert(reg);\n+    mask_aux.Insert(reg);\n@@ -997,1 +997,1 @@\n-      mask.insert(reg);\n+      mask.Insert(reg);\n@@ -1013,1 +1013,1 @@\n-      mask.remove(reg);\n+      mask.Remove(reg);\n@@ -1020,1 +1020,1 @@\n-      mask.clear();\n+      mask.Clear();\n@@ -1026,1 +1026,1 @@\n-        \/\/ set_all expects a zero-offset.\n+        \/\/ Set_All expects a zero-offset.\n@@ -1030,1 +1030,1 @@\n-        tty->print_cr(\"action: set_all\");\n+        tty->print_cr(\"action: Set_All\");\n@@ -1032,1 +1032,1 @@\n-      mask.set_all();\n+      mask.Set_All();\n@@ -1038,1 +1038,1 @@\n-        tty->print_cr(\"action: and_with\");\n+        tty->print_cr(\"action: AND\");\n@@ -1042,1 +1042,1 @@\n-      mask.and_with(mask_aux);\n+      mask.AND(mask_aux);\n@@ -1051,1 +1051,1 @@\n-        tty->print_cr(\"action: or_with\");\n+        tty->print_cr(\"action: OR\");\n@@ -1055,1 +1055,1 @@\n-      mask.or_with(mask_aux);\n+      mask.OR(mask_aux);\n@@ -1064,1 +1064,1 @@\n-        tty->print_cr(\"action: subtract\");\n+        tty->print_cr(\"action: SUBTRACT\");\n@@ -1068,1 +1068,1 @@\n-      mask.subtract(mask_aux);\n+      mask.SUBTRACT(mask_aux);\n@@ -1079,1 +1079,1 @@\n-        tty->print_cr(\"action: subtract_inner\");\n+        tty->print_cr(\"action: SUBTRACT_inner\");\n@@ -1083,1 +1083,1 @@\n-      \/\/ subtract_inner expects an argument register mask with infinite_stack =\n+      \/\/ SUBTRACT_inner expects an argument register mask with infinite_stack =\n@@ -1086,2 +1086,2 @@\n-      mask.subtract_inner(mask_aux);\n-      \/\/ subtract_inner does not have \"stack-extension semantics\".\n+      mask.SUBTRACT_inner(mask_aux);\n+      \/\/ SUBTRACT_inner does not have \"stack-extension semantics\".\n@@ -1109,1 +1109,1 @@\n-      mask.clear();\n+      mask.Clear();\n@@ -1123,1 +1123,1 @@\n-      mask.clear();\n+      mask.Clear();\n@@ -1130,1 +1130,1 @@\n-        tty->print_cr(\"action: set_all_from_offset\");\n+        tty->print_cr(\"action: Set_All_From_Offset\");\n@@ -1132,1 +1132,1 @@\n-      mask.set_all_from_offset();\n+      mask.Set_All_From_Offset();\n@@ -1139,1 +1139,1 @@\n-        tty->print_cr(\"action: set_all_from\");\n+        tty->print_cr(\"action: Set_All_From\");\n@@ -1144,1 +1144,1 @@\n-      mask.set_all_from(reg);\n+      mask.Set_All_From(reg);\n@@ -1157,1 +1157,1 @@\n-  rm.clear();\n+  rm.Clear();\n@@ -1162,1 +1162,1 @@\n-    rm.insert(reg);\n+    rm.Insert(reg);\n@@ -1178,1 +1178,1 @@\n-    rm.insert(reg);\n+    rm.Insert(reg);\n@@ -1181,1 +1181,1 @@\n-      rm.remove(reg);\n+      rm.Remove(reg);\n@@ -1244,2 +1244,2 @@\n-    \/\/ Set destination to source\n-    dst.assignFrom(src);\n+    \/\/ Copy source to destination\n+    dst = src;\n","filename":"test\/hotspot\/gtest\/opto\/test_regmask.cpp","additions":281,"deletions":281,"binary":false,"changes":562,"status":"modified"},{"patch":"@@ -36,0 +36,5 @@\n+####\n+## Tests for functionality which currently is not supported for virtual threads\n+\n+vmTestbase\/nsk\/jvmti\/GetCurrentThreadCpuTime\/curthrcputime001\/TestDescription.java 8348844 generic-all\n+vmTestbase\/nsk\/jvmti\/GetThreadCpuTime\/thrcputime001\/TestDescription.java 8348844 generic-all\n@@ -80,0 +85,11 @@\n+##########\n+## Tests incompatible with  with virtual test thread factory.\n+## There is no goal to run all test with virtual test thread factory.\n+## So any test migth be added as incompatible, the bug is not required.\n+\n+gc\/arguments\/TestNewSizeThreadIncrease.java 0000000 generic-all\n+gc\/g1\/TestSkipRebuildRemsetPhase.java 0000000 generic-all\n+runtime\/ErrorHandling\/MachCodeFramesInErrorFile.java 0000000 generic-all\n+runtime\/Thread\/AsyncExceptionOnMonitorEnter.java 0000000 generic-all\n+runtime\/Thread\/StopAtExit.java 0000000 generic-all\n+runtime\/handshake\/HandshakeWalkStackTest.java 0000000 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-Virtual.txt","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -136,1 +136,1 @@\n-serviceability\/sa\/sadebugd\/DebugdConnectTest.java 8239062,8270326 generic-all\n+serviceability\/sa\/sadebugd\/DebugdConnectTest.java 8239062,8270326,8344261 generic-all\n@@ -156,0 +156,4 @@\n+serviceability\/sa\/JhsdbThreadInfoTest.java              8344261 generic-all\n+serviceability\/sa\/TestJhsdbJstackLock.java              8344261 generic-all\n+serviceability\/attach\/RemovingUnixDomainSocketTest.java 8344261 generic-all\n+\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -573,1 +573,0 @@\n- -runtime\/cds\/appcds\/VerifyObjArrayCloneTest.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n- * @requires os.arch == \"aarch64\" | os.arch == \"amd64\" | os.arch == \"x86_64\" | os.arch == \"ppc64\" | os.arch == \"ppc64le\" | os.arch == \"riscv64\"\n+ * @requires os.arch==\"aarch64\" | os.arch==\"amd64\" | os.arch == \"ppc64\" | os.arch == \"ppc64le\" | os.arch == \"riscv64\"\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestBit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,11 +57,0 @@\n-            \"testShiftValue\",\n-            \"testShiftValueOverflow\",\n-            \"testShiftMultiple32\",\n-            \"testShiftOfAddSameInput\",\n-            \"testLargeShiftOfAddSameInput\",\n-            \"testShiftOfAddConstant\",\n-            \"testLShiftOfAndOfRShiftSameCon\",\n-            \"testLShiftOfAndOfURShiftSameCon\",\n-            \"testLShiftOfAndOfRShift\",\n-            \"testLShiftOfAndOfURShift\",\n-            \"testLShiftOfAndOfCon\",\n@@ -85,23 +74,0 @@\n-\n-        Asserts.assertEQ(42 << 1, testShiftValue(42));\n-        Asserts.assertEQ(Integer.MAX_VALUE << 1, testShiftValueOverflow(Integer.MAX_VALUE));\n-        Asserts.assertEQ((Integer.MAX_VALUE-1) << 1, testShiftValueOverflow(Integer.MAX_VALUE-1));\n-\n-        assertResult(a, b);\n-        assertResult(c, d);\n-        assertResult(a, min);\n-        assertResult(a, max);\n-        assertResult(min, a);\n-        assertResult(max, a);\n-        assertResult(min, max);\n-        assertResult(max, min);\n-        assertResult(min, min);\n-        assertResult(max, max);\n-    }\n-\n-    private void assertResult(int a, int b) {\n-        otherInput = b;\n-        Asserts.assertEQ(((a >> 4) & b) << 4, testLShiftOfAndOfRShiftSameCon(a));\n-        Asserts.assertEQ(((a >>> 4) & b) << 4, testLShiftOfAndOfURShiftSameCon(a));\n-        Asserts.assertEQ(((a >> 4) & b) << 8, testLShiftOfAndOfRShift(a));\n-        Asserts.assertEQ(((a >>> 4) & b) << 8, testLShiftOfAndOfURShift(a));\n@@ -120,5 +86,0 @@\n-        Asserts.assertEQ(a, testShiftMultiple32(a));\n-        Asserts.assertEQ((a + a) << 1, testShiftOfAddSameInput(a));\n-        Asserts.assertEQ((a + a) << 31, testLargeShiftOfAddSameInput(a));\n-        Asserts.assertEQ(((a + 1) << 1) + 1, testShiftOfAddConstant(a));\n-        Asserts.assertEQ((a & ((1 << (32 - 10)) -1)) << 10, testLShiftOfAndOfCon(a));\n@@ -309,103 +270,0 @@\n-\n-    @Test\n-    @IR(counts = {IRNode.LSHIFT, \"1\"}, failOn = { IRNode.IF } )\n-    public int testShiftValue(int x) {\n-        x = Integer.min(Integer.max(x, 10), 100);\n-        int shift = x << 1;\n-        if (shift > 200 || shift < 20) {\n-            throw new RuntimeException(\"never taken\");\n-        }\n-        return shift;\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LSHIFT, \"1\", IRNode.IF, \"2\" } )\n-    public int testShiftValueOverflow(int x) {\n-        x = Integer.max(x, Integer.MAX_VALUE - 1);\n-        int shift = x << 1;\n-        if (shift != -2 && shift != -4) {\n-            throw new RuntimeException(\"never taken\");\n-        }\n-        return shift;\n-    }\n-\n-    @Test\n-    @IR(failOn = { IRNode.LSHIFT_I } )\n-    public int testShiftMultiple32(int x) {\n-        return x << 128;\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.LSHIFT_I, \"1\" }, failOn = { IRNode.ADD_I } )\n-    public int testShiftOfAddSameInput(int x) {\n-        return (x + x) << 1;\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.LSHIFT_I, \"1\", IRNode.ADD_I, \"1\" } )\n-    public int testLargeShiftOfAddSameInput(int x) {\n-        return (x + x) << 31;\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.LSHIFT_I, \"1\",  IRNode.ADD_I, \"1\" } )\n-    public int testShiftOfAddConstant(int x) {\n-        return ((x + 1) << 1) + 1;\n-    }\n-\n-    static short shortField;\n-    static byte byteField;\n-\n-    @Test\n-    @IR(counts = { IRNode.ADD_I, \"1\"} , failOn = { IRNode.LSHIFT_I, IRNode.RSHIFT_I } )\n-    @Arguments( values = { Argument.NUMBER_42 })\n-    public void testStoreShort(int x) {\n-        shortField = (short)(x + x);\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.ADD_I, \"1\"} , failOn = { IRNode.LSHIFT_I, IRNode.RSHIFT_I } )\n-    @Arguments( values = { Argument.NUMBER_42 })\n-    public void testStoreByte(int x) {\n-        byteField = (byte)(x + x);\n-    }\n-\n-    static int otherInput;\n-\n-    @Test\n-    @IR(counts = { IRNode.AND_I, \"1\", IRNode.LSHIFT_I, \"1\" } , failOn = { IRNode.RSHIFT_I } )\n-    public int testLShiftOfAndOfRShiftSameCon(int x) {\n-        int shift = x >> 4;\n-        int y = otherInput;\n-        return (shift & y) << 4;\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.AND_I, \"1\", IRNode.LSHIFT_I, \"1\" } , failOn = { IRNode.URSHIFT_I } )\n-    public int testLShiftOfAndOfURShiftSameCon(int x) {\n-        int shift = x >>> 4;\n-        int y = otherInput;\n-        return (shift & y) << 4;\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.AND_I, \"2\", IRNode.LSHIFT_I, \"2\" } , failOn = { IRNode.RSHIFT_I } )\n-    public int testLShiftOfAndOfRShift(int x) {\n-        int shift = x >> 4;\n-        int y = otherInput;\n-        return (shift & y) << 8;\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.AND_I, \"2\", IRNode.LSHIFT_I, \"2\" } , failOn = { IRNode.URSHIFT_I } )\n-    public int testLShiftOfAndOfURShift(int x) {\n-        int shift = x >>> 4;\n-        int y = otherInput;\n-        return (shift & y) << 8;\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.LSHIFT_I, \"1\" } , failOn = { IRNode.AND_I } )\n-    public int testLShiftOfAndOfCon(int x) {\n-        return (x & ((1 << (32 - 10)) -1)) << 10;\n-    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/LShiftINodeIdealizationTests.java","additions":0,"deletions":142,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -55,11 +55,0 @@\n-            \"testShiftValue\",\n-            \"testShiftValueOverflow\",\n-            \"testShiftMultiple64\",\n-            \"testShiftOfAddSameInput\",\n-            \"testLargeShiftOfAddSameInput\",\n-            \"testShiftOfAddConstant\",\n-            \"testLShiftOfAndOfRShiftSameCon\",\n-            \"testLShiftOfAndOfURShiftSameCon\",\n-            \"testLShiftOfAndOfRShift\",\n-            \"testLShiftOfAndOfURShift\",\n-            \"testLShiftOfAndOfCon\",\n@@ -83,23 +72,0 @@\n-\n-        Asserts.assertEQ(42L << 1, testShiftValue(42));\n-        Asserts.assertEQ(Long.MAX_VALUE << 1, testShiftValueOverflow(Long.MAX_VALUE));\n-        Asserts.assertEQ((Long.MAX_VALUE-1) << 1, testShiftValueOverflow(Long.MAX_VALUE-1));\n-\n-        assertResult(a, b);\n-        assertResult(c, d);\n-        assertResult(a, min);\n-        assertResult(a, max);\n-        assertResult(min, a);\n-        assertResult(max, a);\n-        assertResult(min, max);\n-        assertResult(max, min);\n-        assertResult(min, min);\n-        assertResult(max, max);\n-    }\n-\n-    private void assertResult(long a, long b) {\n-        otherInput = b;\n-        Asserts.assertEQ(((a >> 4) & b) << 4, testLShiftOfAndOfRShiftSameCon(a));\n-        Asserts.assertEQ(((a >>> 4) & b) << 4, testLShiftOfAndOfURShiftSameCon(a));\n-        Asserts.assertEQ(((a >> 4) & b) << 8, testLShiftOfAndOfRShift(a));\n-        Asserts.assertEQ(((a >>> 4) & b) << 8, testLShiftOfAndOfURShift(a));\n@@ -116,5 +82,0 @@\n-        Asserts.assertEQ(a, testShiftMultiple64(a));\n-        Asserts.assertEQ((a + a) << 1, testShiftOfAddSameInput(a));\n-        Asserts.assertEQ((a + a) << 63, testLargeShiftOfAddSameInput(a));\n-        Asserts.assertEQ(((a + 1) << 1) + 1, testShiftOfAddConstant(a));\n-        Asserts.assertEQ((a & ((1L << (64 - 10)) -1)) << 10, testLShiftOfAndOfCon(a));\n@@ -275,86 +236,0 @@\n-\n-    @Test\n-    @IR(counts = {IRNode.LSHIFT, \"1\"}, failOn = { IRNode.IF } )\n-    public long testShiftValue(long x) {\n-        x = Long.min(Long.max(x, 10), 100);\n-        long shift = x << 1;\n-        if (shift > 200 || shift < 20) {\n-            throw new RuntimeException(\"never taken\");\n-        }\n-        return shift;\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LSHIFT, \"1\", IRNode.IF, \"2\" } )\n-    public long testShiftValueOverflow(long x) {\n-        x = Long.max(x, Long.MAX_VALUE - 1);\n-        long shift = x << 1;\n-        if (shift != -2 && shift != -4) {\n-            throw new RuntimeException(\"never taken\");\n-        }\n-        return shift;\n-    }\n-\n-    @Test\n-    @IR(failOn = { IRNode.LSHIFT_L } )\n-    public long testShiftMultiple64(long x) {\n-        return x << 128;\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.LSHIFT_L, \"1\" }, failOn = { IRNode.ADD_L } )\n-    public long testShiftOfAddSameInput(long x) {\n-        return (x + x) << 1;\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.LSHIFT_L, \"1\", IRNode.ADD_L, \"1\" } )\n-    public long testLargeShiftOfAddSameInput(long x) {\n-        return (x + x) << 63;\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.LSHIFT_L, \"1\",  IRNode.ADD_L, \"1\" } )\n-    public long testShiftOfAddConstant(long x) {\n-        return ((x + 1) << 1) + 1;\n-    }\n-\n-    static long otherInput;\n-\n-    @Test\n-    @IR(counts = { IRNode.AND_L, \"1\", IRNode.LSHIFT_L, \"1\" } , failOn = { IRNode.RSHIFT_L } )\n-    public long testLShiftOfAndOfRShiftSameCon(long x) {\n-        long shift = x >> 4;\n-        long y = otherInput;\n-        return (shift & y) << 4;\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.AND_L, \"1\", IRNode.LSHIFT_L, \"1\" } , failOn = { IRNode.URSHIFT_L } )\n-    public long testLShiftOfAndOfURShiftSameCon(long x) {\n-        long shift = x >>> 4;\n-        long y = otherInput;\n-        return (shift & y) << 4;\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.AND_L, \"2\", IRNode.LSHIFT_L, \"2\" } , failOn = { IRNode.RSHIFT_L } )\n-    public long testLShiftOfAndOfRShift(long x) {\n-        long shift = x >> 4;\n-        long y = otherInput;\n-        return (shift & y) << 8;\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.AND_L, \"2\", IRNode.LSHIFT_L, \"2\" } , failOn = { IRNode.URSHIFT_L } )\n-    public long testLShiftOfAndOfURShift(long x) {\n-        long shift = x >>> 4;\n-        long y = otherInput;\n-        return (shift & y) << 8;\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.LSHIFT_L, \"1\" } , failOn = { IRNode.AND_L } )\n-    public long testLShiftOfAndOfCon(long x) {\n-        return (x & ((1L << (64 - 10)) -1)) << 10;\n-    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/LShiftLNodeIdealizationTests.java","additions":0,"deletions":125,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @requires os.arch == \"amd64\" | os.arch == \"x86_64\" | os.arch == \"aarch64\" | (os.arch == \"riscv64\" & vm.cpu.features ~= \".*zbb.*\")\n+ * @requires os.arch == \"x86_64\" | os.arch == \"aarch64\" | (os.arch == \"riscv64\" & vm.cpu.features ~= \".*zbb.*\")\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/RotateLeftNodeIntIdealizationTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @requires os.arch == \"amd64\" | os.arch == \"x86_64\" | os.arch == \"aarch64\" | (os.arch == \"riscv64\" & vm.cpu.features ~= \".*zbb.*\")\n+ * @requires os.arch == \"x86_64\" | os.arch == \"aarch64\" | (os.arch == \"riscv64\" & vm.cpu.features ~= \".*zbb.*\")\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/RotateLeftNodeLongIdealizationTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,9 @@\n+import org.objectweb.asm.ClassReader;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.ClassWriter;\n+import org.objectweb.asm.Handle;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.Opcodes;\n+\n+import java.io.FileInputStream;\n@@ -27,11 +36,0 @@\n-import java.lang.classfile.ClassFile;\n-import java.lang.classfile.ClassTransform;\n-import java.lang.classfile.CodeBuilder;\n-import java.lang.classfile.CodeElement;\n-import java.lang.classfile.CodeTransform;\n-import java.lang.classfile.Label;\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.DirectMethodHandleDesc;\n-import java.lang.constant.DynamicCallSiteDesc;\n-import java.lang.constant.MethodHandleDesc;\n-import java.lang.constant.MethodTypeDesc;\n@@ -44,0 +42,1 @@\n+import java.nio.file.Paths;\n@@ -46,2 +45,0 @@\n-import static java.lang.constant.ConstantDescs.*;\n-\n@@ -53,1 +50,1 @@\n-public final class InvokeDynamicPatcher {\n+public class InvokeDynamicPatcher extends ClassVisitor {\n@@ -55,1 +52,2 @@\n-    private static final ClassDesc CLASS = InvokeDynamic.class.describeConstable().orElseThrow();\n+    private static final String CLASS = InvokeDynamic.class.getName()\n+            .replace('.', '\/');\n@@ -61,6 +59,6 @@\n-    private static final ClassDesc CALL_NATIVE_FIELD_DESC = CD_boolean;\n-    private static final MethodTypeDesc CALLEE_METHOD_DESC = MethodTypeDesc.of(\n-            CD_boolean, CLASS, CD_int, CD_long, CD_float, CD_double, CD_String);\n-    private static final MethodTypeDesc ASSERTTRUE_METHOD_DESC = MethodTypeDesc.of(\n-            CD_void, CD_boolean, CD_String);\n-    private static final ClassDesc ASSERTS_CLASS = ClassDesc.ofInternalName(\"jdk\/test\/lib\/Asserts\");\n+    private static final String CALL_NATIVE_FIELD_DESC = \"Z\";\n+    private static final String CALLEE_METHOD_DESC\n+            = \"(L\" + CLASS + \";IJFDLjava\/lang\/String;)Z\";\n+    private static final String ASSERTTRUE_METHOD_DESC\n+            = \"(ZLjava\/lang\/String;)V\";\n+    private static final String ASSERTS_CLASS = \"jdk\/test\/lib\/Asserts\";\n@@ -69,9 +67,28 @@\n-    public static void main(String args[]) throws IOException, URISyntaxException {\n-        Path filePath = Path.of(InvokeDynamic.class.getProtectionDomain().getCodeSource()\n-                    .getLocation().toURI()).resolve(InvokeDynamic.class.getName().replace('.', '\/') +\".class\");\n-        var bytes = ClassFile.of().transformClass(ClassFile.of().parse(filePath),\n-                ClassTransform.transformingMethodBodies(m -> m.methodName().equalsString(CALLER_METHOD_NAME), new CodeTransform() {\n-                    @Override\n-                    public void accept(CodeBuilder builder, CodeElement element) {\n-                        \/\/ discard\n-                    }\n+    public static void main(String args[]) {\n+        ClassReader cr;\n+        Path filePath;\n+        try {\n+            filePath = Paths.get(InvokeDynamic.class.getProtectionDomain().getCodeSource()\n+                    .getLocation().toURI()).resolve(CLASS + \".class\");\n+        } catch (URISyntaxException ex) {\n+            throw new Error(\"TESTBUG: Can't get code source\" + ex, ex);\n+        }\n+        try (FileInputStream fis = new FileInputStream(filePath.toFile())) {\n+            cr = new ClassReader(fis);\n+        } catch (IOException e) {\n+            throw new Error(\"Error reading file\", e);\n+        }\n+        ClassWriter cw = new ClassWriter(cr,\n+                ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);\n+        cr.accept(new InvokeDynamicPatcher(Opcodes.ASM5, cw), 0);\n+        try {\n+            Files.write(filePath, cw.toByteArray(),\n+                    StandardOpenOption.WRITE);\n+        } catch (IOException e) {\n+            throw new Error(e);\n+        }\n+    }\n+\n+    public InvokeDynamicPatcher(int api, ClassWriter cw) {\n+        super(api, cw);\n+    }\n@@ -79,63 +96,75 @@\n-                    \/* the code generated looks like\n-                     *  0: aload_0\n-                     *  1: ldc           #125  \/\/ int 1\n-                     *  3: ldc2_w        #126  \/\/ long 2l\n-                     *  6: ldc           #128  \/\/ float 3.0f\n-                     *  8: ldc2_w        #129  \/\/ double 4.0d\n-                     * 11: ldc           #132  \/\/ String 5\n-                     * 13: aload_0\n-                     * 14: getfield      #135  \/\/ Field nativeCallee:Z\n-                     * 17: ifeq          28\n-                     * 20: invokedynamic #181,  0            \/\/ InvokeDynamic #1:calleeNative:(Lcompiler\/calls\/common\/InvokeDynamic;IJFDLjava\/lang\/String;)Z\n-                     * 25: goto          33\n-                     * 28: invokedynamic #183,  0            \/\/ InvokeDynamic #1:callee:(Lcompiler\/calls\/common\/InvokeDynamic;IJFDLjava\/lang\/String;)Z\n-                     * 33: ldc           #185                \/\/ String Call insuccessfull\n-                     * 35: invokestatic  #191                \/\/ Method jdk\/test\/lib\/Asserts.assertTrue:(ZLjava\/lang\/String;)V\n-                     * 38: return\n-                     *\n-                     * or, using java-like pseudo-code\n-                     * if (this.nativeCallee == false) {\n-                     *     invokedynamic-call-return-value = invokedynamic-of-callee\n-                     * } else {\n-                     *     invokedynamic-call-return-value = invokedynamic-of-nativeCallee\n-                     * }\n-                     * Asserts.assertTrue(invokedynamic-call-return-value, error-message);\n-                     * return;\n-                     *\/\n-                    @Override\n-                    public void atEnd(CodeBuilder builder) {\n-                        Label nonNativeLabel = builder.newLabel();\n-                        Label checkLabel = builder.newLabel();\n-                        MethodType mtype = MethodType.methodType(CallSite.class,\n-                                MethodHandles.Lookup.class, String.class, MethodType.class);\n-                        DirectMethodHandleDesc dmh = MethodHandleDesc.of(DirectMethodHandleDesc.Kind.STATIC,\n-                                CLASS, BOOTSTRAP_METHOD_NAME, mtype.descriptorString());\n-                        \/\/ push callee parameters onto stack\n-                        builder.aload(builder.receiverSlot())\n-                               .ldc(1)\n-                               .ldc(2L)\n-                               .ldc(3.0f)\n-                               .ldc(4.0d)\n-                               .ldc(\"5\")\n-                               \/\/ params loaded. let's decide what method to call\n-                               .aload(builder.receiverSlot())\n-                               \/\/ get nativeCallee field\n-                               .getfield(CLASS, CALL_NATIVE_FIELD, CALL_NATIVE_FIELD_DESC)\n-                               \/\/ if nativeCallee == false goto nonNativeLabel\n-                               .ifeq(nonNativeLabel)\n-                               \/\/ invokedynamic nativeCalleeMethod using bootstrap method\n-                               .invokedynamic(DynamicCallSiteDesc.of(dmh, NATIVE_CALLEE_METHOD_NAME, CALLEE_METHOD_DESC))\n-                               \/\/ goto checkLabel\n-                               .goto_(checkLabel)\n-                               \/\/ label: nonNativeLabel\n-                               .labelBinding(nonNativeLabel)\n-                               \/\/ invokedynamic calleeMethod using bootstrap method\n-                               .invokedynamic(DynamicCallSiteDesc.of(dmh, CALLEE_METHOD_NAME, CALLEE_METHOD_DESC))\n-                               .labelBinding(checkLabel)\n-                               .ldc(CallsBase.CALL_ERR_MSG)\n-                               .invokestatic(ASSERTS_CLASS, ASSERTTRUE_METHOD_NAME, ASSERTTRUE_METHOD_DESC)\n-                               \/\/ label: return\n-                               .return_();\n-                    }\n-                }));\n-        Files.write(filePath, bytes, StandardOpenOption.WRITE);\n+    @Override\n+    public MethodVisitor visitMethod(final int access, final String name,\n+            final String desc, final String signature,\n+            final String[] exceptions) {\n+        \/* a code generate looks like\n+         *  0: aload_0\n+         *  1: ldc           #125  \/\/ int 1\n+         *  3: ldc2_w        #126  \/\/ long 2l\n+         *  6: ldc           #128  \/\/ float 3.0f\n+         *  8: ldc2_w        #129  \/\/ double 4.0d\n+         * 11: ldc           #132  \/\/ String 5\n+         * 13: aload_0\n+         * 14: getfield      #135  \/\/ Field nativeCallee:Z\n+         * 17: ifeq          28\n+         * 20: invokedynamic #181,  0            \/\/ InvokeDynamic #1:calleeNative:(Lcompiler\/calls\/common\/InvokeDynamic;IJFDLjava\/lang\/String;)Z\n+         * 25: goto          33\n+         * 28: invokedynamic #183,  0            \/\/ InvokeDynamic #1:callee:(Lcompiler\/calls\/common\/InvokeDynamic;IJFDLjava\/lang\/String;)Z\n+         * 33: ldc           #185                \/\/ String Call insuccessfull\n+         * 35: invokestatic  #191                \/\/ Method jdk\/test\/lib\/Asserts.assertTrue:(ZLjava\/lang\/String;)V\n+         * 38: return\n+         *\n+         * or, using java-like pseudo-code\n+         * if (this.nativeCallee == false) {\n+         *     invokedynamic-call-return-value = invokedynamic-of-callee\n+         * } else {\n+         *     invokedynamic-call-return-value = invokedynamic-of-nativeCallee\n+         * }\n+         * Asserts.assertTrue(invokedynamic-call-return-value, error-message);\n+         * return;\n+         *\/\n+        if (name.equals(CALLER_METHOD_NAME)) {\n+            MethodVisitor mv = cv.visitMethod(access, name, desc,\n+                    signature, exceptions);\n+            Label nonNativeLabel = new Label();\n+            Label checkLabel = new Label();\n+            MethodType mtype = MethodType.methodType(CallSite.class,\n+                    MethodHandles.Lookup.class, String.class, MethodType.class);\n+            Handle bootstrap = new Handle(Opcodes.H_INVOKESTATIC, CLASS,\n+                    BOOTSTRAP_METHOD_NAME, mtype.toMethodDescriptorString());\n+            mv.visitCode();\n+            \/\/ push callee parameters onto stack\n+            mv.visitVarInsn(Opcodes.ALOAD, 0);\/\/push \"this\"\n+            mv.visitLdcInsn(1);\n+            mv.visitLdcInsn(2L);\n+            mv.visitLdcInsn(3.0f);\n+            mv.visitLdcInsn(4.0d);\n+            mv.visitLdcInsn(\"5\");\n+            \/\/ params loaded. let's decide what method to call\n+            mv.visitVarInsn(Opcodes.ALOAD, 0); \/\/ push \"this\"\n+            \/\/ get nativeCallee field\n+            mv.visitFieldInsn(Opcodes.GETFIELD, CLASS, CALL_NATIVE_FIELD,\n+                    CALL_NATIVE_FIELD_DESC);\n+            \/\/ if nativeCallee == false goto nonNativeLabel\n+            mv.visitJumpInsn(Opcodes.IFEQ, nonNativeLabel);\n+            \/\/ invokedynamic nativeCalleeMethod using bootstrap method\n+            mv.visitInvokeDynamicInsn(NATIVE_CALLEE_METHOD_NAME,\n+                    CALLEE_METHOD_DESC, bootstrap);\n+            \/\/ goto checkLabel\n+            mv.visitJumpInsn(Opcodes.GOTO, checkLabel);\n+            \/\/ label: nonNativeLabel\n+            mv.visitLabel(nonNativeLabel);\n+            \/\/ invokedynamic calleeMethod using bootstrap method\n+            mv.visitInvokeDynamicInsn(CALLEE_METHOD_NAME, CALLEE_METHOD_DESC,\n+                    bootstrap);\n+            mv.visitLabel(checkLabel);\n+            mv.visitLdcInsn(CallsBase.CALL_ERR_MSG);\n+            mv.visitMethodInsn(Opcodes.INVOKESTATIC, ASSERTS_CLASS,\n+                    ASSERTTRUE_METHOD_NAME, ASSERTTRUE_METHOD_DESC, false);\n+            \/\/ label: return\n+            mv.visitInsn(Opcodes.RETURN);\n+            mv.visitMaxs(0, 0);\n+            mv.visitEnd();\n+            return null;\n+        }\n+        return super.visitMethod(access, name, desc, signature, exceptions);\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/common\/InvokeDynamicPatcher.java","additions":122,"deletions":93,"binary":false,"changes":215,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @library \/testlibrary\/asm\n@@ -31,1 +32,0 @@\n- * @build compiler.calls.common.InvokeDynamic\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/fromCompiled\/CompiledInvokeDynamic2CompiledTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @library \/testlibrary\/asm\n@@ -31,1 +32,0 @@\n- * @build compiler.calls.common.InvokeDynamic\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/fromCompiled\/CompiledInvokeDynamic2InterpretedTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @library \/testlibrary\/asm\n@@ -31,1 +32,0 @@\n- * @build compiler.calls.common.InvokeDynamic\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/fromCompiled\/CompiledInvokeDynamic2NativeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @library \/testlibrary\/asm\n@@ -31,1 +32,0 @@\n- * @build compiler.calls.common.InvokeDynamic\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/fromInterpreted\/InterpretedInvokeDynamic2CompiledTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @library \/testlibrary\/asm\n@@ -31,1 +32,0 @@\n- * @build compiler.calls.common.InvokeDynamic\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/fromInterpreted\/InterpretedInvokeDynamic2InterpretedTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @library \/testlibrary\/asm\n@@ -31,1 +32,0 @@\n- * @build compiler.calls.common.InvokeDynamic\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/fromInterpreted\/InterpretedInvokeDynamic2NativeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -158,1 +158,1 @@\n-            !Compiler.isIntrinsicAvailable(CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION, \"com.sun.crypto.provider.AES_Crypt\", \"implEncryptBlock\", byte[].class, int.class, byte[].class, int.class)) {\n+            !Compiler.isIntrinsicAvailable(CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION, \"com.sun.crypto.provider.AESCrypt\", \"implEncryptBlock\", byte[].class, int.class, byte[].class, int.class)) {\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/aes\/TestAESMain.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-            + \".provider\\\\.AES_Crypt::(implEncryptBlock|implDecryptBlock) \\\\([0-9]+ \"\n+            + \".provider\\\\.AESCrypt::(implEncryptBlock|implDecryptBlock) \\\\([0-9]+ \"\n","filename":"test\/hotspot\/jtreg\/compiler\/cpuflags\/AESIntrinsicsBase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,62 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-super class IllegalAccessInCatch\n-    version 52:0\n-{\n-    \/*\n-      static int test() {\n-        try {\n-          return 1 \/ 0;\n-        } catch (jdk.internal.agent.AgentConfigurationError e1) {\n-          try {\n-            return 0;\n-          } catch (IllegalAccessError e2) {\n-            return 1;\n-          }\n-        }\n-      }\n-    *\/\n-    static Method test:\"()I\"\n-    stack 2 locals 1\n-  {\n-    iconst_1;\n-    iconst_0;\n-    try t0;\n-    idiv;\n-    endtry t0;\n-    ireturn;\n-    catch t0 jdk\/internal\/agent\/AgentConfigurationError; \/\/ loadable but not accessible from unnamed module\n-    stack_frame_type full;\n-    stack_map class java\/lang\/Throwable;\n-    try t1;\n-    iconst_0;\n-    ireturn;\n-    endtry t1;\n-    catch t1 java\/lang\/IllegalAccessError;\n-    stack_frame_type full;\n-    stack_map class java\/lang\/Throwable;\n-    iconst_1;\n-    ireturn;\n-  }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/exceptions\/IllegalAccessInCatch.jasm","additions":0,"deletions":62,"binary":false,"changes":62,"status":"deleted"},{"patch":"@@ -1,67 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8367002\n- * @summary Compilers might not generate handlers for recursive exceptions\n- *\n- * @compile IllegalAccessInCatch.jasm\n- * @run main\/othervm -Xbatch\n- *   -XX:CompileCommand=compileonly,IllegalAccessInCatch*::test\n- *   -XX:-TieredCompilation\n- *   TestAccessErrorInCatch\n- * @run main\/othervm -Xbatch\n- *   -XX:CompileCommand=compileonly,IllegalAccessInCatch*::test\n- *   -XX:TieredStopAtLevel=3\n- *   TestAccessErrorInCatch\n- *\/\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-\n-import java.nio.file.Files;\n-import java.nio.file.FileSystems;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-\n-public class TestAccessErrorInCatch {\n-\n-    public static void main(String[] args) throws Throwable {\n-        Path TEST_CLASSES_DIR = FileSystems.getDefault().getPath(System.getProperty(\"test.classes\"));\n-        byte[] bytes = Files.readAllBytes(TEST_CLASSES_DIR.resolve(\"IllegalAccessInCatch.class\"));\n-\n-        var l = MethodHandles.lookup().defineHiddenClass(bytes, true);\n-        Class<?> anonClass = l.lookupClass();\n-        MethodHandle mh = l.findStatic(anonClass, \"test\", MethodType.methodType(int.class));\n-        for (int i = 0; i < 16_000; i++) {\n-            invoke(mh);\n-        }\n-        System.out.println(invoke(mh));\n-    }\n-\n-    private static int invoke(MethodHandle mh) throws Throwable {\n-        return (int) mh.invokeExact();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/exceptions\/TestAccessErrorInCatch.java","additions":0,"deletions":67,"binary":false,"changes":67,"status":"deleted"},{"patch":"@@ -883,10 +883,0 @@\n-        {\n-            Outer o = new Outer();\n-            Object oldVal = new Object();\n-            o.f = oldVal;\n-            Object cmpVal = new Object();\n-            Object newVal = new Object();\n-            Object oldVal2 = testCompareAndExchange(o, cmpVal, newVal);\n-            Asserts.assertEquals(oldVal2, oldVal);\n-            Asserts.assertEquals(o.f, oldVal);\n-        }\n@@ -902,10 +892,0 @@\n-        {\n-            Outer o = new Outer();\n-            Object oldVal = new Object();\n-            o.f = oldVal;\n-            Object cmpVal = new Object();\n-            Object newVal = new Object();\n-            boolean b = testCompareAndSwap(o, cmpVal, newVal);\n-            Asserts.assertFalse(b);\n-            Asserts.assertEquals(o.f, oldVal);\n-        }\n","filename":"test\/hotspot\/jtreg\/compiler\/gcbarriers\/TestG1BarrierGeneration.java","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-\/*\n+\/**\n@@ -29,0 +29,1 @@\n+ * @library \/testlibrary\/asm\n@@ -39,0 +40,6 @@\n+import org.objectweb.asm.ClassReader;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.ClassWriter;\n+import org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.Opcodes;\n+\n@@ -42,4 +49,0 @@\n-import java.lang.classfile.ClassFile;\n-import java.lang.classfile.ClassHierarchyResolver;\n-import java.lang.classfile.ClassTransform;\n-import java.lang.classfile.instruction.ConstantInstruction;\n@@ -159,7 +162,16 @@\n-                var context = ClassFile.of(ClassFile.ClassHierarchyResolverOption.of(ClassHierarchyResolver.ofResourceParsing(cl)));\n-                return context.transformClass(context.parse(classfileBuffer), ClassTransform.transformingMethodBodies((codeBuilder, codeElement) -> {\n-                    if (codeElement instanceof ConstantInstruction.LoadConstantInstruction ldc) {\n-                        System.out.println(\"replacing \\\"\" + ldc.constantEntry().constantValue() + \"\\\" with \\\"bar\\\"\");\n-                        codeBuilder.ldc(\"bar\");\n-                    } else {\n-                        codeBuilder.with(codeElement);\n+                ClassReader cr = new ClassReader(classfileBuffer);\n+                ClassWriter cw = new ClassWriter(cr, ClassWriter.COMPUTE_FRAMES);\n+                ClassVisitor adapter = new ClassVisitor(Opcodes.ASM5, cw) {\n+                    @Override\n+                    public MethodVisitor visitMethod(int access, String base, String desc, String signature, String[] exceptions) {\n+                        MethodVisitor mv = cv.visitMethod(access, base, desc, signature, exceptions);\n+                        if (mv != null) {\n+                            mv = new MethodVisitor(Opcodes.ASM5, mv) {\n+                                @Override\n+                                public void visitLdcInsn(Object cst) {\n+                                    System.out.println(\"replacing \\\"\" + cst + \"\\\" with \\\"bar\\\"\");\n+                                    mv.visitLdcInsn(\"bar\");\n+                                }\n+                            };\n+                        }\n+                        return mv;\n@@ -167,1 +179,5 @@\n-                }));\n+                };\n+\n+                cr.accept(adapter, ClassReader.SKIP_FRAMES);\n+                cw.visitEnd();\n+                return cw.toByteArray();\n","filename":"test\/hotspot\/jtreg\/compiler\/jsr292\/RedefineMethodUsedByMultipleMethodHandles.java","additions":29,"deletions":13,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -26,0 +26,8 @@\n+import org.objectweb.asm.ClassReader;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.ClassWriter;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.tree.ClassNode;\n+import jdk.test.lib.Utils;\n@@ -29,0 +37,1 @@\n+import jdk.vm.ci.hotspot.HotSpotNmethod;\n@@ -32,8 +41,0 @@\n-import java.lang.classfile.Attributes;\n-import java.lang.classfile.ClassFile;\n-import java.lang.classfile.ClassModel;\n-import java.lang.classfile.MethodModel;\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.ConstantDescs;\n-import java.lang.constant.MethodTypeDesc;\n-import java.lang.invoke.MethodType;\n@@ -42,0 +43,1 @@\n+import java.lang.reflect.Field;\n@@ -44,2 +46,2 @@\n-import java.util.Arrays;\n-import java.util.List;\n+import java.lang.reflect.Parameter;\n+import java.util.HashMap;\n@@ -72,15 +74,10 @@\n-        ClassModel classModel = findClassBytes(method.getDeclaringClass());\n-        MethodModel methodModel = findMethod(classModel, method);\n-        if (methodModel == null)\n-            return Map.of();\n-\n-        var foundLineNumberTable = methodModel.code().flatMap(code ->\n-                code.findAttribute(Attributes.lineNumberTable()));\n-        if (foundLineNumberTable.isEmpty()) {\n-            boolean isEmptyMethod = Modifier.isAbstract(method.getModifiers())\n-                    || Modifier.isNative(method.getModifiers());\n-            if (!isEmptyMethod) {\n-                throw new Error(method + \" doesn't contains the line numbers table \"\n-                        + \"(the method marked neither abstract nor native)\");\n-            }\n-            return Map.of();\n+        Map<Integer, Integer> lineNumbers = new TreeMap<>();\n+        Class<?> aClass = method.getDeclaringClass();\n+        ClassReader cr;\n+        try {\n+            Module aModule = aClass.getModule();\n+            String name = aClass.getName();\n+            cr = new ClassReader(aModule.getResourceAsStream(\n+                    name.replace('.', '\/') + \".class\"));\n+        } catch (IOException e) {\n+                        throw new Error(\"TEST BUG: can read \" + aClass.getName() + \" : \" + e, e);\n@@ -88,0 +85,2 @@\n+        ClassNode cn = new ClassNode();\n+        cr.accept(cn, ClassReader.EXPAND_FRAMES);\n@@ -89,3 +88,11 @@\n-        Map<Integer, Integer> lineNumbers = new TreeMap<>();\n-        foundLineNumberTable.get().lineNumbers().forEach(ln ->\n-                lineNumbers.put(ln.startPc(), ln.lineNumber()));\n+        Map<Label, Integer> labels = new HashMap<>();\n+        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);\n+        ClassVisitor cv = new ClassVisitorForLabels(cw, labels, method);\n+        cr.accept(cv, ClassReader.EXPAND_FRAMES);\n+        labels.forEach((k, v) -> lineNumbers.put(k.getOffset(), v));\n+        boolean isEmptyMethod = Modifier.isAbstract(method.getModifiers())\n+                || Modifier.isNative(method.getModifiers());\n+        if (lineNumbers.isEmpty() && !isEmptyMethod) {\n+            throw new Error(method + \" doesn't contains the line numbers table \"\n+                    +\"(the method marked neither abstract nor native)\");\n+        }\n@@ -95,12 +102,9 @@\n-    \/\/ Finds the ClassFile API model of a given class, or fail with an Error.\n-    public static ClassModel findClassBytes(Class<?> clazz) {\n-        String binaryName = clazz.getName();\n-        byte[] fileBytes;\n-        try (var inputStream = clazz.getModule().getResourceAsStream(\n-                binaryName.replace('.', '\/') + \".class\")) {\n-            fileBytes = inputStream.readAllBytes();\n-        } catch (IOException e) {\n-            throw new Error(\"TEST BUG: cannot read \" + binaryName, e);\n-        }\n-        return ClassFile.of().parse(fileBytes);\n-    }\n+    private static class ClassVisitorForLabels extends ClassVisitor {\n+        private final Map<Label, Integer> lineNumbers;\n+        private final String targetName;\n+        private final String targetDesc;\n+\n+        public ClassVisitorForLabels(ClassWriter cw, Map<Label, Integer> lines,\n+                                     Executable target) {\n+            super(Opcodes.ASM7, cw);\n+            this.lineNumbers = lines;\n@@ -108,6 +112,15 @@\n-    \/\/ Finds a matching method in a class model, or null if none match.\n-    public static MethodModel findMethod(ClassModel classModel, Executable method) {\n-        MethodTypeDesc methodType = MethodType.methodType(\n-                method instanceof Method m ? m.getReturnType() : void.class,\n-                method.getParameterTypes()).describeConstable().orElseThrow();\n-        String methodName = method instanceof Method m ? m.getName() : ConstantDescs.INIT_NAME;\n+            StringBuilder builder = new StringBuilder(\"(\");\n+            for (Parameter parameter : target.getParameters()) {\n+                builder.append(Utils.toJVMTypeSignature(parameter.getType()));\n+            }\n+            builder.append(\")\");\n+            if (target instanceof Constructor) {\n+                targetName = \"<init>\";\n+                builder.append(\"V\");\n+            } else {\n+                targetName = target.getName();\n+                builder.append(Utils.toJVMTypeSignature(\n+                        ((Method) target).getReturnType()));\n+            }\n+            targetDesc = builder.toString();\n+        }\n@@ -115,4 +128,14 @@\n-        for (var methodModel : classModel.methods()) {\n-            if (methodModel.methodName().equalsString(methodName)\n-                    && methodModel.methodType().isMethodType(methodType)) {\n-                return methodModel;\n+        @Override\n+        public final MethodVisitor visitMethod(int access, String name,\n+                                               String desc, String signature,\n+                                               String[] exceptions) {\n+            MethodVisitor mv = cv.visitMethod(access, name, desc, signature,\n+                    exceptions);\n+            if (targetDesc.equals(desc) && targetName.equals(name)) {\n+                return new MethodVisitor(Opcodes.ASM7, mv) {\n+                    @Override\n+                    public void visitLineNumber(int i, Label label) {\n+                        super.visitLineNumber(i, label);\n+                        lineNumbers.put(label, i);\n+                    }\n+                };\n@@ -120,0 +143,1 @@\n+            return  mv;\n@@ -121,1 +145,0 @@\n-        return null;\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/common\/CTVMUtilities.java","additions":74,"deletions":51,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -117,1 +117,1 @@\n-            classes.add(Class.forName(\"com.sun.crypto.provider.AES_Crypt\"));\n+            classes.add(Class.forName(\"com.sun.crypto.provider.AESCrypt\"));\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/TestHotSpotJVMCIRuntime.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,3 +38,0 @@\n-        if (Double.compare(lo, hi) >= 0) {\n-            throw new EmptyGeneratorException();\n-        }\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/generators\/UniformDoubleGenerator.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,3 +38,0 @@\n-        if (Float.compare(lo, hi) >= 0) {\n-            throw new EmptyGeneratorException();\n-        }\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/generators\/UniformFloatGenerator.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2843,30 +2843,0 @@\n-    public static final String COMPRESS_VB = VECTOR_PREFIX + \"COMPRESS_VB\" + POSTFIX;\n-    static {\n-        vectorNode(COMPRESS_VB, \"CompressV\", TYPE_BYTE);\n-    }\n-\n-    public static final String COMPRESS_VS = VECTOR_PREFIX + \"COMPRESS_VS\" + POSTFIX;\n-    static {\n-        vectorNode(COMPRESS_VS, \"CompressV\", TYPE_SHORT);\n-    }\n-\n-    public static final String COMPRESS_VI = VECTOR_PREFIX + \"COMPRESS_VI\" + POSTFIX;\n-    static {\n-        vectorNode(COMPRESS_VI, \"CompressV\", TYPE_INT);\n-    }\n-\n-    public static final String COMPRESS_VL = VECTOR_PREFIX + \"COMPRESS_VL\" + POSTFIX;\n-    static {\n-        vectorNode(COMPRESS_VL, \"CompressV\", TYPE_LONG);\n-    }\n-\n-    public static final String COMPRESS_VF = VECTOR_PREFIX + \"COMPRESS_VF\" + POSTFIX;\n-    static {\n-        vectorNode(COMPRESS_VF, \"CompressV\", TYPE_FLOAT);\n-    }\n-\n-    public static final String COMPRESS_VD = VECTOR_PREFIX + \"COMPRESS_VD\" + POSTFIX;\n-    static {\n-        vectorNode(COMPRESS_VD, \"CompressV\", TYPE_DOUBLE);\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -330,4 +330,2 @@\n-            if (!scenarioIndices.add(scenarioIndex)) {\n-                TestFormat.failNoThrow(\"Cannot define two scenarios with the same index \" + scenarioIndex);\n-                continue;\n-            }\n+            TestFormat.checkNoThrow(scenarioIndices.add(scenarioIndex),\n+                             \"Cannot define two scenarios with the same index \" + scenarioIndex);\n@@ -341,1 +339,1 @@\n-     * Add the cross-product (cartesian product) of sets of flags as Scenarios. Unlike when constructing\n+     * Add the cross-product (cartesian product) of sets of flags as Scenarios. Unlike when when constructing\n@@ -343,4 +341,1 @@\n-     * flags that have to be specified together. Further, an empty string in a set stands in for \"no flag\".\n-     * <p>\n-     * Passing a single set will create a scenario for each of the provided flags in the set (i.e. the same as\n-     * passing an additional set with an empty string only).\n+     * flags that have to be specified togeher. Further, an empty string in a set stands in for \"no flag\".\n@@ -363,1 +358,1 @@\n-     * @param flagSets sets of flags to generate the cross product for.\n+     * @param sets sets of flags to generate the cross product for.\n@@ -384,1 +379,1 @@\n-                Stream.of(Collections.emptyList()), \/\/ Initialize Stream<List<String>> acc with a Stream containing an empty list of Strings.\n+                Stream.of(Collections.<String>emptyList()), \/\/ Initialize Stream<List<String>> acc with a Stream containing an empty list of Strings.\n@@ -392,2 +387,2 @@\n-                    ), \/\/ ...that get flattened into one big List<List<String>>.\n-                Stream::concat); \/\/ combiner; if any reduction steps are executed in parallel, just concat two streams.\n+                    ), \/\/ ...that get flattend into one big List<List<String>>.\n+                (a, b) -> Stream.concat(a, b)); \/\/ combiner; if any reduction steps are executed in parallel, just concat two streams.\n@@ -399,1 +394,1 @@\n-                     .map(s -> Set.of(s.split(\"[ ]\"))) \/\/ Split multiple flags in the same string into separate strings.\n+                     .map(s -> Set.of(s.split(\"[ ]\"))) \/\/ Split muliple flags in the same string into separate strings.\n@@ -402,1 +397,1 @@\n-                     .toList()\n+                     .collect(Collectors.toList())\n@@ -404,1 +399,1 @@\n-            .toList().toArray(new Scenario[0]);\n+            .collect(Collectors.toList()).toArray(new Scenario[0]);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":11,"deletions":16,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -109,1 +109,0 @@\n-        \"avx512_vbmi2\",\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,93 +0,0 @@\n-\/*\n- * Copyright (c) 2025 IBM Corporation. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8369258\n- * @summary C2: enable ReassociateInvariants for all loop types\n- * @library \/test\/lib \/\n- * @run driver compiler.loopopts.TestReassociateInvariants\n- *\/\n-\n-package compiler.loopopts;\n-\n-\n-import compiler.lib.ir_framework.*;\n-\n-import java.util.Objects;\n-\n-public class TestReassociateInvariants {\n-    private static long longStart = 0;\n-    private static long longStop = 1000;\n-    private static int intStart = 0;\n-    private static int intStop = 1000;\n-\n-    public static void main(String[] args) {\n-        TestFramework.runWithFlags(\"-XX:-ShortRunningLongLoop\");\n-    }\n-\n-    \/\/ The IR framework is not powerful enough to directly check\n-    \/\/ wether invariants are moved out of a loop so tests below rely on\n-    \/\/ some side effect that can be observed by the IR framework.\n-\n-    \/\/ Once a + (b + i) is transformed into i + (a + b), the a + b\n-    \/\/ before the loop and the one from inside the loop common and one\n-    \/\/ Add is removed.\n-    @Test\n-    @IR(counts = {IRNode.ADD_I, \"3\"})\n-    @Arguments(values = { Argument.NUMBER_42, Argument.NUMBER_42 })\n-    public int test1(int a, int b) {\n-        int v = a + b;\n-        for (int i = 1; i < 100; i *= 2) {\n-            v += a + (b + i);\n-        }\n-        return v;\n-    }\n-\n-    \/\/ Range Check Elimination only happens once a + (b + i) is\n-    \/\/ transformed into i + (a + b). With the range check eliminated,\n-    \/\/ the loop can be removed. At this point, C2 doesn't support\n-    \/\/ removal of long counted loop. The long counted loop is\n-    \/\/ transformed into a loop nest with an inner int counted\n-    \/\/ loop. That one is empty and is removed.\n-    @Test\n-    @IR(failOn = { IRNode.COUNTED_LOOP, IRNode.LONG_COUNTED_LOOP })\n-    @IR(counts = { IRNode.LOOP, \"1\" })\n-    @Arguments(values = { Argument.NUMBER_42, Argument.NUMBER_42 })\n-    public void test2(long a, long b) {\n-        for (long i = longStart; i < longStop; i++) {\n-            Objects.checkIndex(a + (b + i), Long.MAX_VALUE);\n-        }\n-    }\n-\n-    \/\/ Same here for an int counted loop with long range checks\n-    @Test\n-    @IR(failOn = { IRNode.COUNTED_LOOP })\n-    @IR(counts = { IRNode.LOOP, \"1\" })\n-    @Arguments(values = { Argument.NUMBER_42, Argument.NUMBER_42 })\n-    public void test3(long a, long b) {\n-        for (int i = intStart; i < intStop; i++) {\n-            Objects.checkIndex(a + (b + i), Long.MAX_VALUE);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestReassociateInvariants.java","additions":0,"deletions":93,"binary":false,"changes":93,"status":"deleted"},{"patch":"@@ -115,4 +115,1 @@\n- * - Generate cases that would catch bugs like JDK-8369902:\n- *   - Large long constants, or scales. Probably only possible for MemorySegment.\n- *   - Large number of invar, and reuse of invar so that they could cancle\n- *     to zero, and need to be filtered out.\n+ *\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAliasingFuzzer.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,107 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8369902\n- * @summary Bug in MemPointerParser::canonicalize_raw_summands let to wrong result, because a\n- *          NaN summand was filtered out, instead of making the MemPointer \/ VPointer invalid.\n- * @run main\/othervm\n- *      -XX:+IgnoreUnrecognizedVMOptions\n- *      -XX:CompileCommand=compileonly,*TestDoNotFilterNaNSummands::test\n- *      -Xbatch\n- *      compiler.loopopts.superword.TestDoNotFilterNaNSummands\n- * @run main compiler.loopopts.superword.TestDoNotFilterNaNSummands\n- *\/\n-\n-package compiler.loopopts.superword;\n-\n-\/\/ This was the test found by the fuzzer. If you are looking for a simpler example with the same issue,\n-\/\/ please look at TestMemorySegmentFilterSummands::test2.\n-public class TestDoNotFilterNaNSummands {\n-    static final int N = 100;\n-    static int zero = 0;\n-\n-    static int[] test() {\n-        int x = -4;\n-        int aI[] = new int[N];\n-        for (int k = 0; k < N; k++) {\n-            \/\/ Note that x is always \"-4\", and N is a compile time constant. The modulo \"%\"\n-            \/\/ gets optimized with magic numbers and shift\/mul\/sub trick, in the long domain,\n-            \/\/ which somehow creates some large long constant that cannot be represented\n-            \/\/ as an int.\n-            int idx = (x >>> 1) % N;\n-            \/\/ This is the CountedLoop that we may try to auto vectorize.\n-            \/\/ We have a linear access (i) and a constant index access (idx), which eventually\n-            \/\/ cross, so there is aliasing. If there is vectorization with an aliasing runtime\n-            \/\/ check, this check must fail.\n-            for (int i = 1; i < 63; i++) {\n-                aI[i] = 2;\n-                \/\/ The MemPointer \/ VPointer for the accesses below contain a large constant\n-                \/\/ long constant offset that cannot be represented as an int, so the scaleL\n-                \/\/ NoOverflowInt becomes NaN. In MemPointerParser::canonicalize_raw_summands\n-                \/\/ we are supposed to filter out zero summands, but since we WRONGLY filtered\n-                \/\/ out NaNs instead, this summand got filtered out, and later we did not detect\n-                \/\/ that the MemPointer contains a NaN. Instead, we just get a \"valid\" looking\n-                \/\/ VPointer, and generate runtime checks that are missing the long constant\n-                \/\/ offset, leading to wrong decisions, and hence vectorization even though\n-                \/\/ we have aliasing. This means that the accesses from above and below get\n-                \/\/ reordered in an illegal way, leading to wrong results.\n-                aI[idx] += 1;\n-            }\n-            for (int i = 0; i < 100; i++) {\n-                \/\/ It is a no-op, but the compiler can't know statically that zero=0.\n-                \/\/ Seems to be required in the graph, no idea why.\n-                x >>= zero;\n-            }\n-        }\n-        return aI;\n-    }\n-\n-    \/\/ Use the sum as an easy way to compare the results.\n-    public static int sum(int[] aI) {\n-        int sum = 0;\n-        for (int i = 0; i < aI.length; i++) { sum += aI[i]; }\n-        return sum;\n-    }\n-\n-    public static void main(String[] args) {\n-        \/\/ Run once, hopefully before compilation, so get interpreter results.\n-        int[] aIG = test();\n-        int gold = sum(aIG);\n-\n-        \/\/ Repeat execution, until eventually compilation happens, compare\n-        \/\/ compiler results to interpreter results.\n-        for (int k = 0; k < 1000; k++) {\n-            int[] aI = test();\n-            int val = sum(aI);\n-            if (gold != val) {\n-                System.out.println(\"Detected wrong result, printing values of arrays:\");\n-                for (int i = 0; i < aI.length; i++) {\n-                    System.out.println(\"at \" + i + \": \" + aIG[i] + \" vs \" + aI[i]);\n-                }\n-                throw new RuntimeException(\"wrong result: \" + gold + \" \" + val);\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestDoNotFilterNaNSummands.java","additions":0,"deletions":107,"binary":false,"changes":107,"status":"deleted"},{"patch":"@@ -1,140 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.loopopts.superword;\n-\n-import java.lang.foreign.*;\n-import java.util.Set;\n-\n-import compiler.lib.ir_framework.*;\n-import compiler.lib.verify.*;\n-\n-\/*\n- * @test\n- * @bug 8369902\n- * @summary Bug in MemPointerParser::canonicalize_raw_summands let to wrong results or assert.\n- * @library \/test\/lib \/\n- * @run driver compiler.loopopts.superword.TestMemorySegmentFilterSummands\n- *\/\n-\n-public class TestMemorySegmentFilterSummands {\n-\n-    static long init  = 1000;\n-    static long limit = 9000;\n-\n-    static long invar0 = 0;\n-    static long invar1 = 0;\n-    static long invar2 = 0;\n-    static long invar3 = 0;\n-    static long invar4 = 0;\n-    static long invarX = 0;\n-\n-    public static final long BIG = 0x200000000L;\n-    public static long big = -BIG;\n-\n-    static MemorySegment a1 = Arena.ofAuto().allocate(10_000);\n-    static MemorySegment b1 = Arena.ofAuto().allocate(10_000);\n-    static {\n-        for (long i = init; i < limit; i++) {\n-            a1.set(ValueLayout.JAVA_BYTE, i, (byte)((i & 0xf) + 1));\n-        }\n-    }\n-\n-    static MemorySegment a2 = MemorySegment.ofArray(new byte[40_000]);\n-    static MemorySegment b2 = a2;\n-\n-    public static void main(String[] args) {\n-        TestFramework f = new TestFramework();\n-        f.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\");\n-        f.addCrossProductScenarios(Set.of(\"-XX:-AlignVector\", \"-XX:+AlignVector\"),\n-                                   Set.of(\"-XX:-ShortRunningLongLoop\", \"-XX:+ShortRunningLoop\"));\n-        f.start();\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.STORE_VECTOR,   \"> 0\",\n-                  IRNode.LOAD_VECTOR_B,  \"> 0\",\n-                  \".*multiversion.*\",    \"= 0\"}, \/\/ AutoVectorization Predicate SUFFICES, there is no aliasing\n-        phase = CompilePhase.PRINT_IDEAL,\n-        applyIfPlatform = {\"64-bit\", \"true\"},\n-        applyIf = {\"AlignVector\", \"false\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    public static void test1() {\n-        long invar = 0;\n-        invar += invarX; \/\/ cancles out with above\n-        invar += invar0;\n-        invar += invar1;\n-        invar += invar2;\n-        invar += invar3;\n-        invar += invar4;\n-        invar -= invarX; \/\/ cancles out with above\n-        \/\/ invar contains a raw summand for invarX, which has a scaleL=0. It needs to be filtered out.\n-        \/\/ The two occurances of invarX are conveniently put in a long chain, so that IGVN cannot see\n-        \/\/ that they cancle out, so that they are not optimized out before loop-opts.\n-        for (long i = init; i < limit; i++) {\n-            byte v = a1.get(ValueLayout.JAVA_BYTE, i + invar);\n-            b1.set(ValueLayout.JAVA_BYTE, i + invar, v);\n-        }\n-    }\n-\n-    @Check(test = \"test1\")\n-    static void check1() {\n-        Verify.checkEQ(a1, b1);\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    \/\/ This test could in principle show vectorization, but it would probably need to do some special\n-    \/\/ tricks to only vectorize around the overlap. Still, it could happen that at some point we end\n-    \/\/ up multiversioning, and having a vectorized loop that is never entered.\n-    \/\/\n-    \/\/ For now, the long constant BIG leads to an invalid VPointer, which means we do not vectorize.\n-    static void test2() {\n-        \/\/ At runtime, \"BIG + big\" is zero. But BIG is a long constant that cannot be represented as\n-        \/\/ an int, and so the scaleL NoOverflowInt is a NaN. We should not filter it out from the summands,\n-        \/\/ but instead make the MemPointer \/ VPointer invalid, which prevents vectorization.\n-        long adr = 4L * 5000 + BIG + big;\n-\n-        for (long i = init; i < limit; i++) {\n-            \/\/ The reference to a2 iterates linearly, while the reference to \"b2\" stays at the same adr.\n-            \/\/ But the two alias: in the middle of the \"a2\" range it crosses over \"b2\" adr, so the\n-            \/\/ aliasing runtime check (if we generate one) should fail. But if \"BIG\" is just filtered\n-            \/\/ out from the summands, we instead just create a runtime check without it, which leads\n-            \/\/ to a wrong answer, and the check does not fail, and we get wrong results.\n-            a2.set(ValueLayout.JAVA_INT_UNALIGNED, 4L * i, 0);\n-            int v = b2.get(ValueLayout.JAVA_INT_UNALIGNED, adr);\n-            b2.set(ValueLayout.JAVA_INT_UNALIGNED, adr, v + 1);\n-        }\n-    }\n-\n-    @Check(test = \"test2\")\n-    static void check2() {\n-        int s = 0;\n-        for (long i = init; i < limit; i++) {\n-            s += a2.get(ValueLayout.JAVA_INT_UNALIGNED, 4L * i);\n-        }\n-        if (s != 4000) {\n-            throw new RuntimeException(\"wrong value\");\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegmentFilterSummands.java","additions":0,"deletions":140,"binary":false,"changes":140,"status":"deleted"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8324751\n+ * @summary Reported issue: JDK-8360204: C2 SuperWord: missing RCE with MemorySegment.getAtIndex\n+ *          The examples are generated from TestAliasingFuzzer.java\n+ *          So if you see something change here, you may want to investigate if we\n+ *          can also tighten up the IR rules there.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment_8360204\n+ *\/\n+\n+public class TestMemorySegment_8360204 {\n+\n+    public static MemorySegment a = Arena.ofAuto().allocate(10_000);\n+    public static MemorySegment b = Arena.ofAuto().allocate(10_000);\n+\n+    private static long invar0_1159 = 0;\n+    private static long invar1_1159 = 0;\n+\n+    public static void main(String[] args) {\n+        TestFramework f = new TestFramework();\n+        f.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\");\n+        f.addScenarios(new Scenario(0, \"-XX:-AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(1, \"-XX:+AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(2, \"-XX:-AlignVector\", \"-XX:+ShortRunningLongLoop\"),\n+                       new Scenario(3, \"-XX:+AlignVector\", \"-XX:+ShortRunningLongLoop\"));\n+        f.start();\n+    }\n+\n+    @Setup\n+    static Object[] setup() {\n+        return new Object[] { a, -19125L, b, 71734L + 2_000L, 0, 1_000 };\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\",\n+                  \".*multiversion.*\",   \"> 0\"}, \/\/ Sadly, we now multiversion\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    \/\/ There is no aliasing, so we should compile without multiversioning.\n+    \/\/ But currently, there seems to be some issue with RCE, we peel and lose the predicate.\n+    \/\/ Then we multiversion.\n+    \/\/ We could imagine that this would eventually vectorize, but since one counts up, and the other down,\n+    \/\/ we would have to implement shuffle first.\n+    \/\/\n+    \/\/ If you see this IR rule fail: investigate JDK-8360204, possibly close it and fix this IR rule!\n+    \/\/ Also: consider renaming the file to something more descriptive: what have you fixed with this?\n+    \/\/ And: you may now be able to tighten IR rules in TestAliasingFuzzer.java\n+    public static void test(MemorySegment container_0, long invar0_0, MemorySegment container_1, long invar0_1, long ivLo, long ivHi) {\n+        for (long i = ivLo; i < ivHi; i+=1) {\n+            var v = container_0.getAtIndex(ValueLayout.JAVA_INT_UNALIGNED, 19125L + 1L * i + 1L * invar0_0 + 0L * invar0_1159 + 1L * invar1_1159);\n+            container_1.setAtIndex(ValueLayout.JAVA_INT_UNALIGNED, -71734L + -1L * i + 1L * invar0_1 + 1L * invar0_1159 + 0L * invar1_1159, v);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegment_8360204.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8324751\n+ * @summary Reported issue: JDK-8365982: C2 SuperWord: missing RCE \/ strange Multiversioning with MemorySegment.set\n+ *          The examples are generated from TestAliasingFuzzer.java\n+ *          So if you see something change here, you may want to investigate if we\n+ *          can also tighten up the IR rules there.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment_8365982\n+ *\/\n+\n+public class TestMemorySegment_8365982 {\n+\n+    public static MemorySegment a = MemorySegment.ofArray(new short[100_000]);\n+    public static MemorySegment b = MemorySegment.ofArray(new short[100_000]);\n+\n+    private static long invar0_853 = 0;\n+    private static long invar1_853 = 0;\n+    private static long invar2_853 = 0;\n+\n+    public static void main(String[] args) {\n+        TestFramework f = new TestFramework();\n+        f.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\");\n+        f.addScenarios(new Scenario(0, \"-XX:-AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(1, \"-XX:+AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(2, \"-XX:-AlignVector\", \"-XX:+ShortRunningLongLoop\"),\n+                       new Scenario(3, \"-XX:+AlignVector\", \"-XX:+ShortRunningLongLoop\"));\n+        f.start();\n+    }\n+\n+    @Setup\n+    static Object[] setup() {\n+        return new Object[] { a, -50_000, b, -30_000, 0, 10_000 };\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.STORE_VECTOR, \"> 0\",\n+                  IRNode.REPLICATE_S,  \"> 0\",\n+                  \".*multiversion.*\",  \"= 0\"}, \/\/ Good: The AutoVectorization predicate suffices.\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"ShortRunningLongLoop\", \"false\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    \/\/\n+    @IR(counts = {IRNode.STORE_VECTOR, \"> 0\",\n+                  IRNode.REPLICATE_S,  \"> 0\",\n+                  \".*multiversion.*\",  \"> 0\"}, \/\/ Bad: Sadly, we now multiversion\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"ShortRunningLongLoop\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Some but not all predicates are RCE'd at the beginning. After unrolling, we multiversion (why?).\n+    \/\/ After PreMainPost, we can do more RangeCheck. Now the main-loop of the multiversion_fast loop\n+    \/\/ does not have any range checks any more.\n+    \/\/ Now it vectorizes. That's good, but we should be able to vectorize without multiversioning.\n+    \/\/\n+    \/\/ If you see this IR rule fail: investigate JDK-8365982, possibly close it and fix this IR rule!\n+    \/\/ Also: consider renaming the file to something more descriptive: what have you fixed with this?\n+    \/\/ And: you may now be able to tighten IR rules in TestAliasingFuzzer.java\n+    public static void test(MemorySegment container_0, long invar0_0, MemorySegment container_1, long invar0_1, long ivLo, long ivHi) {\n+        for (long i = ivHi-1; i >= ivLo; i-=1) {\n+            container_0.set(ValueLayout.JAVA_CHAR_UNALIGNED, -47143L + -2L * i + -2L * invar0_0 + -1L * invar0_853 + -1L * invar1_853 + 0L * invar2_853, (char)0x0102030405060708L);\n+            container_1.set(ValueLayout.JAVA_CHAR_UNALIGNED, 74770L + 2L * i + 2L * invar0_1 + 0L * invar0_853 + 0L * invar1_853 + 0L * invar2_853, (char)0x1112131415161718L);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegment_8365982.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -1,83 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.loopopts.superword;\n-\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.ValueLayout;\n-\n-import compiler.lib.ir_framework.*;\n-\n-\/*\n- * @test\n- * @bug 8324751 8369258\n- * @summary Reported issue: JDK-8360204: C2 SuperWord: missing RCE with MemorySegment.getAtIndex\n- *          The examples are generated from TestAliasingFuzzer.java\n- *          So if you see something change here, you may want to investigate if we\n- *          can also tighten up the IR rules there.\n- * @library \/test\/lib \/\n- * @run driver compiler.loopopts.superword.TestMemorySegment_ReassociateInvariants1\n- *\/\n-\n-public class TestMemorySegment_ReassociateInvariants1 {\n-\n-    public static MemorySegment a = Arena.ofAuto().allocate(10_000);\n-    public static MemorySegment b = Arena.ofAuto().allocate(10_000);\n-\n-    private static long invar0_1159 = 0;\n-    private static long invar1_1159 = 0;\n-\n-    public static void main(String[] args) {\n-        TestFramework f = new TestFramework();\n-        f.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\");\n-        f.addScenarios(new Scenario(0, \"-XX:-AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n-                       new Scenario(1, \"-XX:+AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n-                       new Scenario(2, \"-XX:-AlignVector\", \"-XX:+ShortRunningLongLoop\"),\n-                       new Scenario(3, \"-XX:+AlignVector\", \"-XX:+ShortRunningLongLoop\"));\n-        f.start();\n-    }\n-\n-    @Setup\n-    static Object[] setup() {\n-        return new Object[] { a, -19125L, b, 71734L + 2_000L, 0, 1_000 };\n-    }\n-\n-    @Test\n-    @Arguments(setup = \"setup\")\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n-                  IRNode.STORE_VECTOR,  \"= 0\",\n-                  \".*multiversion.*\",   \"= 0\"},\n-        phase = CompilePhase.PRINT_IDEAL,\n-        applyIfPlatform = {\"64-bit\", \"true\"},\n-        applyIf = {\"AlignVector\", \"false\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    \/\/ We could imagine that this would eventually vectorize, but since one counts up, and the other down,\n-    \/\/ we would have to implement shuffle first.\n-    public static void test(MemorySegment container_0, long invar0_0, MemorySegment container_1, long invar0_1, long ivLo, long ivHi) {\n-        for (long i = ivLo; i < ivHi; i+=1) {\n-            var v = container_0.getAtIndex(ValueLayout.JAVA_INT_UNALIGNED, 19125L + 1L * i + 1L * invar0_0 + 0L * invar0_1159 + 1L * invar1_1159);\n-            container_1.setAtIndex(ValueLayout.JAVA_INT_UNALIGNED, -71734L + -1L * i + 1L * invar0_1 + 1L * invar0_1159 + 0L * invar1_1159, v);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegment_ReassociateInvariants1.java","additions":0,"deletions":83,"binary":false,"changes":83,"status":"deleted"},{"patch":"@@ -1,90 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.loopopts.superword;\n-\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.ValueLayout;\n-\n-import compiler.lib.ir_framework.*;\n-\n-\/*\n- * @test\n- * @bug 8324751 8369258\n- * @summary Reported issue: JDK-8365982: C2 SuperWord: missing RCE \/ strange Multiversioning with MemorySegment.set\n- *          The examples are generated from TestAliasingFuzzer.java\n- *          So if you see something change here, you may want to investigate if we\n- *          can also tighten up the IR rules there.\n- * @library \/test\/lib \/\n- * @run driver compiler.loopopts.superword.TestMemorySegment_ReassociateInvariants2\n- *\/\n-\n-public class TestMemorySegment_ReassociateInvariants2 {\n-\n-    public static MemorySegment a = MemorySegment.ofArray(new short[100_000]);\n-    public static MemorySegment b = MemorySegment.ofArray(new short[100_000]);\n-\n-    private static long invar0_853 = 0;\n-    private static long invar1_853 = 0;\n-    private static long invar2_853 = 0;\n-\n-    public static void main(String[] args) {\n-        TestFramework f = new TestFramework();\n-        f.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\");\n-        f.addScenarios(new Scenario(0, \"-XX:-AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n-                       new Scenario(1, \"-XX:+AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n-                       new Scenario(2, \"-XX:-AlignVector\", \"-XX:+ShortRunningLongLoop\"),\n-                       new Scenario(3, \"-XX:+AlignVector\", \"-XX:+ShortRunningLongLoop\"));\n-        f.start();\n-    }\n-\n-    @Setup\n-    static Object[] setup() {\n-        return new Object[] { a, -50_000, b, -30_000, 0, 10_000 };\n-    }\n-\n-    @Test\n-    @Arguments(setup = \"setup\")\n-    @IR(counts = {IRNode.STORE_VECTOR, \"> 0\",\n-                  IRNode.REPLICATE_S,  \"> 0\",\n-                  \".*multiversion.*\",  \"= 0\"}, \/\/ Good: The AutoVectorization predicate suffices.\n-        phase = CompilePhase.PRINT_IDEAL,\n-        applyIfPlatform = {\"64-bit\", \"true\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"ShortRunningLongLoop\", \"false\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    \/\/\n-    @IR(counts = {IRNode.STORE_VECTOR, \"> 0\",\n-                  IRNode.REPLICATE_S,  \"> 0\",\n-                  \".*multiversion.*\",  \"= 0\"},\n-        phase = CompilePhase.PRINT_IDEAL,\n-        applyIfPlatform = {\"64-bit\", \"true\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"ShortRunningLongLoop\", \"true\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    public static void test(MemorySegment container_0, long invar0_0, MemorySegment container_1, long invar0_1, long ivLo, long ivHi) {\n-        for (long i = ivHi-1; i >= ivLo; i-=1) {\n-            container_0.set(ValueLayout.JAVA_CHAR_UNALIGNED, -47143L + -2L * i + -2L * invar0_0 + -1L * invar0_853 + -1L * invar1_853 + 0L * invar2_853, (char)0x0102030405060708L);\n-            container_1.set(ValueLayout.JAVA_CHAR_UNALIGNED, 74770L + 2L * i + 2L * invar0_1 + 0L * invar0_853 + 0L * invar1_853 + 0L * invar2_853, (char)0x1112131415161718L);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegment_ReassociateInvariants2.java","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -1,95 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8369898\n- * @summary Bug in PhaseIdealLoop::create_new_if_for_multiversion, that messed up the\n- *          _loop_or_ctrl data structure while doing SuperWord for a first loop, and\n- *          then get_ctrl asserted for a second loop that was also SuperWord-ed in the\n- *          same loop-opts-phase.\n- * @run main\/othervm\n- *      -XX:CompileCommand=compileonly,*TestMultiversionSlowProjReplacementAndGetCtrl::test\n- *      -XX:CompileCommand=exclude,*TestMultiversionSlowProjReplacementAndGetCtrl::dontinline\n- *      -XX:-TieredCompilation\n- *      -Xbatch\n- *      compiler.loopopts.superword.TestMultiversionSlowProjReplacementAndGetCtrl\n- * @run main compiler.loopopts.superword.TestMultiversionSlowProjReplacementAndGetCtrl\n- *\/\n-\n-package compiler.loopopts.superword;\n-\n-public class TestMultiversionSlowProjReplacementAndGetCtrl {\n-    static final int N = 400;\n-\n-    static void dontinline() {}\n-\n-    static long test() {\n-        int x = 0;\n-        int arrayI[] = new int[N];\n-        byte[] arrayB = new byte[N];\n-        dontinline();\n-        \/\/ CallStaticJava for dontinline\n-        \/\/ -> memory Proj\n-        \/\/ -> it is used in both the k-indexed and j-indexed loops by their loads\/stores.\n-        for (int k = 8; k < 92; ++k) {\n-            \/\/ Loop here is multiversioned, and eventually we insert an aliasing runtime check.\n-            \/\/ This means that a StoreN (with mem input Proj from above) has its ctrl changed\n-            \/\/ from the old multiversion_if_proj to a new region. We have to be careful to update\n-            \/\/ the _loop_or_ctrl side-table so that get_ctrl for StoreN is sane.\n-            \/\/\n-            \/\/ Below is some nested loop material I could not reduce further. Maybe because\n-            \/\/ of loop-opts phase timing. Because we have to SuperWord the k-indexed loop\n-            \/\/ above in the same loop-opts-phase as the j-indexed loop below, so that they\n-            \/\/ have a shared _loop_or_ctrl data structure.\n-            int y = 6;\n-            while (--y > 0) {}\n-            for (long i = 1; i < 6; i++) {\n-                \/\/ I suspect that it is the two array references below that are SuperWord-ed,\n-                \/\/ and since we do not manage to statically prove they cannot overlap, we add\n-                \/\/ a speculative runtime check, i.e. multiversioning in this case.\n-                arrayI[0] += 1;\n-                arrayI[k] = 0;\n-                try {\n-                    x = 2 \/ k % y;\n-                } catch (ArithmeticException a_e) {\n-                }\n-            }\n-        }\n-        long sum = 0;\n-        for (int j = 0; j < arrayB.length; j++) {\n-            \/\/ Load below has mem input from Proj below dontinline\n-            \/\/ We look up to the mem input (Proj), and down to uses\n-            \/\/ that are Stores, checking in_bb on them, which calls\n-            \/\/ get_ctrl on that StoreN from the other loop above.\n-            sum += arrayB[j];\n-        }\n-        return sum;\n-    }\n-\n-    public static void main(String[] strArr) {\n-        for (int i = 0; i < 1_000; i++) {\n-            test();\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMultiversionSlowProjReplacementAndGetCtrl.java","additions":0,"deletions":95,"binary":false,"changes":95,"status":"deleted"},{"patch":"@@ -1,246 +0,0 @@\n-\/*\n- * Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.vectorapi;\n-\n-import compiler.lib.generators.*;\n-import compiler.lib.ir_framework.*;\n-import jdk.incubator.vector.*;\n-import jdk.test.lib.Asserts;\n-\n-\/**\n- * @test\n- * @bug 8366333\n- * @key randomness\n- * @library \/test\/lib \/\n- * @summary IR test for VectorAPI compress\n- * @modules jdk.incubator.vector\n- *\n- * @run driver compiler.vectorapi.VectorCompressTest\n- *\/\n-\n-public class VectorCompressTest {\n-    static final VectorSpecies<Byte> B_SPECIES = ByteVector.SPECIES_MAX;\n-    static final VectorSpecies<Short> S_SPECIES = ShortVector.SPECIES_MAX;\n-    static final VectorSpecies<Integer> I_SPECIES = IntVector.SPECIES_MAX;\n-    static final VectorSpecies<Float> F_SPECIES = FloatVector.SPECIES_MAX;\n-    static final VectorSpecies<Long> L_SPECIES = LongVector.SPECIES_MAX;\n-    static final VectorSpecies<Double> D_SPECIES = DoubleVector.SPECIES_MAX;\n-    static final int LENGTH = 512;\n-    static final Generators RD = Generators.G;\n-    static byte[] ba, bb;\n-    static short[] sa, sb;\n-    static int[] ia, ib;\n-    static long[] la, lb;\n-    static float[] fa, fb;\n-    static double[] da, db;\n-    static boolean[] ma;\n-\n-    static {\n-        ba = new byte[LENGTH];\n-        bb = new byte[LENGTH];\n-        sa = new short[LENGTH];\n-        sb = new short[LENGTH];\n-        ia = new int[LENGTH];\n-        ib = new int[LENGTH];\n-        la = new long[LENGTH];\n-        lb = new long[LENGTH];\n-        fa = new float[LENGTH];\n-        fb = new float[LENGTH];\n-        da = new double[LENGTH];\n-        db = new double[LENGTH];\n-        ma = new boolean[LENGTH];\n-\n-        Generator<Integer> iGen = RD.ints();\n-        Generator<Long> lGen = RD.longs();\n-        Generator<Float> fGen = RD.floats();\n-        Generator<Double> dGen = RD.doubles();\n-\n-        for (int i = 0; i < LENGTH; i++) {\n-            ba[i] = iGen.next().byteValue();\n-            sa[i] = iGen.next().shortValue();\n-            ma[i] = iGen.next() % 2 == 0;\n-        }\n-        RD.fill(iGen, ia);\n-        RD.fill(lGen, la);\n-        RD.fill(fGen, fa);\n-        RD.fill(dGen, da);\n-    }\n-\n-    @DontInline\n-    static void verifyVectorCompressByte(int vlen) {\n-        int index = 0;\n-        for (int i = 0; i < vlen; i++) {\n-            if (ma[i]) {\n-                Asserts.assertEquals(ba[i], bb[index++]);\n-            }\n-        }\n-        for (int i = index; i < vlen; i++) {\n-            Asserts.assertEquals((byte)0, bb[i]);\n-        }\n-    }\n-\n-    @DontInline\n-    static void verifyVectorCompressShort(int vlen) {\n-        int index = 0;\n-        for (int i = 0; i < vlen; i++) {\n-            if (ma[i]) {\n-                Asserts.assertEquals(sa[i], sb[index++]);\n-            }\n-        }\n-        for (int i = index; i < vlen; i++) {\n-            Asserts.assertEquals((short)0, sb[i]);\n-        }\n-    }\n-\n-    @DontInline\n-    static void verifyVectorCompressInteger(int vlen) {\n-        int index = 0;\n-        for (int i = 0; i < vlen; i++) {\n-            if (ma[i]) {\n-                Asserts.assertEquals(ia[i], ib[index++]);\n-            }\n-        }\n-        for (int i = index; i < vlen; i++) {\n-            Asserts.assertEquals(0, ib[i]);\n-        }\n-    }\n-\n-    @DontInline\n-    static void verifyVectorCompressLong(int vlen) {\n-        int index = 0;\n-        for (int i = 0; i < vlen; i++) {\n-            if (ma[i]) {\n-                Asserts.assertEquals(la[i], lb[index++]);\n-            }\n-        }\n-        for (int i = index; i < vlen; i++) {\n-            Asserts.assertEquals(0L, lb[i]);\n-        }\n-    }\n-\n-    @DontInline\n-    static void verifyVectorCompressFloat(int vlen) {\n-        int index = 0;\n-        for (int i = 0; i < vlen; i++) {\n-            if (ma[i]) {\n-                Asserts.assertEquals(fa[i], fb[index++]);\n-            }\n-        }\n-        for (int i = index; i < vlen; i++) {\n-            Asserts.assertEquals(0.0f, fb[i]);\n-        }\n-    }\n-\n-    @DontInline\n-    static void verifyVectorCompressDouble(int vlen) {\n-        int index = 0;\n-        for (int i = 0; i < vlen; i++) {\n-            if (ma[i]) {\n-                Asserts.assertEquals(da[i], db[index++]);\n-            }\n-        }\n-        for (int i = index; i < vlen; i++) {\n-            Asserts.assertEquals(0.0, db[i]);\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.COMPRESS_VB, \"= 1\" },\n-        applyIfCPUFeature = { \"sve\", \"true\" })\n-    @IR(counts = { IRNode.COMPRESS_VB, \"= 1\" },\n-        applyIfCPUFeatureAnd = {\"avx512_vbmi2\", \"true\", \"avx512vl\", \"true\"})\n-    public static void testVectorCompressByte() {\n-        ByteVector av = ByteVector.fromArray(B_SPECIES, ba, 0);\n-        VectorMask<Byte> m = VectorMask.fromArray(B_SPECIES, ma, 0);\n-        av.compress(m).intoArray(bb, 0);\n-        verifyVectorCompressByte(B_SPECIES.length());\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.COMPRESS_VS, \"= 1\" },\n-        applyIfCPUFeature = { \"sve\", \"true\" })\n-    @IR(counts = { IRNode.COMPRESS_VS, \"= 1\" },\n-        applyIfCPUFeatureAnd = {\"avx512_vbmi2\", \"true\", \"avx512vl\", \"true\"})\n-    public static void testVectorCompressShort() {\n-        ShortVector av = ShortVector.fromArray(S_SPECIES, sa, 0);\n-        VectorMask<Short> m = VectorMask.fromArray(S_SPECIES, ma, 0);\n-        av.compress(m).intoArray(sb, 0);\n-        verifyVectorCompressShort(S_SPECIES.length());\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.COMPRESS_VI, \"= 1\" },\n-        applyIfCPUFeature = { \"sve\", \"true\" })\n-    @IR(counts = { IRNode.COMPRESS_VI, \"= 1\" },\n-        applyIfCPUFeatureAnd = {\"avx512f\", \"true\", \"avx512vl\", \"true\"})\n-    public static void testVectorCompressInt() {\n-        IntVector av = IntVector.fromArray(I_SPECIES, ia, 0);\n-        VectorMask<Integer> m = VectorMask.fromArray(I_SPECIES, ma, 0);\n-        av.compress(m).intoArray(ib, 0);\n-        verifyVectorCompressInteger(I_SPECIES.length());\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.COMPRESS_VL, \"= 1\" },\n-        applyIfCPUFeature = { \"sve\", \"true\" })\n-    @IR(counts = { IRNode.COMPRESS_VL, \"= 1\" },\n-        applyIfCPUFeatureAnd = {\"avx512f\", \"true\", \"avx512vl\", \"true\"})\n-    public static void testVectorCompressLong() {\n-        LongVector av = LongVector.fromArray(L_SPECIES, la, 0);\n-        VectorMask<Long> m = VectorMask.fromArray(L_SPECIES, ma, 0);\n-        av.compress(m).intoArray(lb, 0);\n-        verifyVectorCompressLong(L_SPECIES.length());\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.COMPRESS_VF, \"= 1\" },\n-        applyIfCPUFeature = { \"sve\", \"true\" })\n-    @IR(counts = { IRNode.COMPRESS_VF, \"= 1\" },\n-        applyIfCPUFeatureAnd = {\"avx512f\", \"true\", \"avx512vl\", \"true\"})\n-    public static void testVectorCompressFloat() {\n-        FloatVector av = FloatVector.fromArray(F_SPECIES, fa, 0);\n-        VectorMask<Float> m = VectorMask.fromArray(F_SPECIES, ma, 0);\n-        av.compress(m).intoArray(fb, 0);\n-        verifyVectorCompressFloat(F_SPECIES.length());\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.COMPRESS_VD, \"= 1\" },\n-        applyIfCPUFeature = { \"sve\", \"true\" })\n-    @IR(counts = { IRNode.COMPRESS_VD, \"= 1\" },\n-        applyIfCPUFeatureAnd = {\"avx512f\", \"true\", \"avx512vl\", \"true\"})\n-    public static void testVectorCompressDouble() {\n-        DoubleVector av = DoubleVector.fromArray(D_SPECIES, da, 0);\n-        VectorMask<Double> m = VectorMask.fromArray(D_SPECIES, ma, 0);\n-        av.compress(m).intoArray(db, 0);\n-        verifyVectorCompressDouble(D_SPECIES.length());\n-    }\n-\n-    public static void main(String[] args) {\n-        TestFramework testFramework = new TestFramework();\n-        testFramework.setDefaultWarmup(10000)\n-                     .addFlags(\"--add-modules=jdk.incubator.vector\")\n-                     .start();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorCompressTest.java","additions":0,"deletions":246,"binary":false,"changes":246,"status":"deleted"},{"patch":"@@ -38,1 +38,1 @@\n- * @requires vm.opt.final.MaxVectorSize == \"null\" | vm.opt.final.MaxVectorSize >= 16\n+ * @requires (os.arch != \"riscv64\" | (os.arch == \"riscv64\" & vm.cpu.features ~= \".*rvv.*\"))\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskCompareNotTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * @bug 8350177 8362171 8369881\n+ * @bug 8350177 8362171\n@@ -354,51 +354,0 @@\n-    @Test\n-    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n-    @Arguments(setup = \"setupByteArray\")\n-    public Object[] testByteReverseBytesS(byte[] in) {\n-        byte[] res = new byte[SIZE];\n-        for (int i = 0; i < SIZE; i++) {\n-            res[i] = (byte)Short.reverseBytes(in[i]);\n-        }\n-\n-        return new Object[] { in, res };\n-    }\n-\n-    @Check(test = \"testByteReverseBytesS\")\n-    public void checkTestByteReverseBytesS(Object[] vals) {\n-        byte[] in = (byte[]) vals[0];\n-        byte[] res = (byte[]) vals[1];\n-\n-        for (int i = 0; i < SIZE; i++) {\n-            byte val = (byte)Short.reverseBytes(in[i]);\n-            if (res[i] != val) {\n-                throw new IllegalStateException(\"Expected \" + val + \" but got \" + res[i] + \" for \" + in[i]);\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n-    @Arguments(setup = \"setupByteArray\")\n-    public Object[] testByteReverseBytesUS(byte[] in) {\n-        byte[] res = new byte[SIZE];\n-        for (int i = 0; i < SIZE; i++) {\n-            res[i] = (byte)Character.reverseBytes((char)in[i]);\n-        }\n-\n-        return new Object[] { in, res };\n-    }\n-\n-    @Check(test = \"testByteReverseBytesUS\")\n-    public void checkTestByteReverseBytesUS(Object[] vals) {\n-        byte[] in = (byte[]) vals[0];\n-        byte[] res = (byte[]) vals[1];\n-\n-        for (int i = 0; i < SIZE; i++) {\n-            byte val = (byte)Character.reverseBytes((char)in[i]);\n-            if (res[i] != val) {\n-                throw new IllegalStateException(\"Expected \" + val + \" but got \" + res[i] + \" for \" + in[i]);\n-            }\n-        }\n-    }\n-\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestSubwordTruncation.java","additions":1,"deletions":52,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n- * @requires test.thread.factory == null\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestNewSizeThreadIncrease.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n- * @requires test.thread.factory == null\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestSkipRebuildRemsetPhase.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,87 +0,0 @@\n-\/*\n- * Copyright (c) 2025, IBM Corporation. All rights reserved.\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Test that we get ASAN-reports and hs-err files on ASAN error\n- * @library \/test\/lib\n- * @requires vm.asan\n- * @requires vm.flagless\n- * @requires vm.debug == true & os.family == \"linux\"\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @run driver AsanReportTest\n- *\/\n-\n-\/\/ Note: this test can only run on debug since it relies on VMError::controlled_crash() which\n-\/\/ only exists in debug builds.\n-import java.io.File;\n-import java.util.regex.Pattern;\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-\n-public class AsanReportTest {\n-\n-    private static void do_test() throws Exception {\n-\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n-                \"-Xmx64M\", \"-XX:CompressedClassSpaceSize=64M\",\n-                \/\/ Default ASAN options should prevent core file generation, which should overrule +CreateCoredumpOnCrash.\n-                \/\/ We test below.\n-                \"-XX:+CreateCoredumpOnCrash\",\n-                \"-Xlog:asan\",\n-                \/\/ Switch off NMT since it can alter the error ASAN sees; we want the pure double free error\n-                \"-XX:NativeMemoryTracking=off\",\n-                \/\/ Causes double-free in controlled_crash\n-                \"-XX:ErrorHandlerTest=18\",\n-                \"-version\");\n-\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-\n-        output.shouldNotHaveExitValue(0);\n-\n-        \/\/ ASAN error should appear on stderr\n-        output.shouldContain(\"CreateCoredumpOnCrash overruled\");\n-        output.shouldContain(\"JVM caught ASAN Error\");\n-        output.shouldMatch(\"AddressSanitizer.*double-free\");\n-        output.shouldMatch(\"# +A fatal error has been detected by the Java Runtime Environment\");\n-        output.shouldMatch(\"# +fatal error: ASAN\");\n-        output.shouldNotContain(\"Aborted (core dumped)\");\n-\n-        File hs_err_file = HsErrFileUtils.openHsErrFileFromOutput(output);\n-        Pattern[] pat = new Pattern[] {\n-                Pattern.compile(\".*A S A N.*\"),\n-                Pattern.compile(\".*AddressSanitizer.*double-free.*\"),\n-                Pattern.compile(\".*(crash_with_segfault|controlled_crash).*\")\n-        };\n-        HsErrFileUtils.checkHsErrFileContent(hs_err_file, pat, false);\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        do_test();\n-    }\n-\n-}\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/AsanReportTest.java","additions":0,"deletions":87,"binary":false,"changes":87,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n- * @requires test.thread.factory == null\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/MachCodeFramesInErrorFile.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,5 +24,1 @@\n-import java.lang.classfile.ClassFile;\n-import java.lang.classfile.ClassTransform;\n-import java.lang.classfile.CodeBuilder;\n-import java.lang.classfile.CodeElement;\n-import java.lang.classfile.CodeTransform;\n+import org.objectweb.asm.*;\n@@ -31,14 +27,21 @@\n-    static byte[] fixup(byte[] buf) {\n-        return ClassFile.of().transformClass(ClassFile.of().parse(buf), ClassTransform.transformingMethodBodies(\n-                m -> m.methodName().equalsString(\"callme\"),\n-                new CodeTransform() {\n-                    @Override\n-                    public void atStart(CodeBuilder builder) {\n-                        \/\/ make receiver go dead!\n-                        builder.aconst_null().astore(0);\n-                    }\n-\n-                    @Override\n-                    public void accept(CodeBuilder builder, CodeElement element) {\n-                        builder.with(element); \/\/ pass through\n-                    }\n+    static byte[] fixup(byte[] buf) throws java.io.IOException {\n+        ClassReader cr = new ClassReader(buf);\n+        ClassWriter cw = new ClassWriter(0);\n+        ClassVisitor cv = new ClassVisitor(Opcodes.ASM4, cw) {\n+            public MethodVisitor visitMethod(\n+                final int access,\n+                final String name,\n+                final String desc,\n+                final String signature,\n+                final String[] exceptions)\n+            {\n+                MethodVisitor mv = super.visitMethod(access,\n+                        name,\n+                        desc,\n+                        signature,\n+                        exceptions);\n+                if (mv == null)  return null;\n+                if (name.equals(\"callme\")) {\n+                    \/\/ make receiver go dead!\n+                    mv.visitInsn(Opcodes.ACONST_NULL);\n+                    mv.visitVarInsn(Opcodes.ASTORE, 0);\n@@ -46,1 +49,5 @@\n-        ));\n+                return mv;\n+            }\n+        };\n+        cr.accept(cv, 0);\n+        return cw.toByteArray();\n","filename":"test\/hotspot\/jtreg\/runtime\/MirrorFrame\/Asmator.java","additions":27,"deletions":20,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @library \/testlibrary\/asm\n","filename":"test\/hotspot\/jtreg\/runtime\/MirrorFrame\/Test8003720.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,2 +42,1 @@\n- * @comment Temporarily exclude on Musl-C debug until JDK-8366133 is fixed.\n- * @requires os.family != \"windows\" & os.family != \"aix\" & (!vm.musl | !vm.debug)\n+ * @requires os.family != \"windows\" & os.family != \"aix\"\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/MonitorWithDeadObjectTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,115 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Check the allocation-site stack trace of a corrupted memory at free() time\n- * @modules java.base\/jdk.internal.misc\n- * @library \/test\/lib\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:NativeMemoryTracking=detail NMTPrintMallocSiteOfCorruptedMemory\n- *\/\n-\n-import jdk.test.lib.Utils;\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.whitebox.WhiteBox;\n-\n-public class NMTPrintMallocSiteOfCorruptedMemory {\n-    private static final String HEADER_ARG = \"header\";\n-    private static final String FOOTER_ARG = \"footer\";\n-    private static final String HEADER_AND_SITE_ARG = \"header-and-site\";\n-    private static final String FOOTER_AND_SITE_ARG = \"footer-and-site\";\n-    private static final int MALLOC_SIZE = 10;\n-    private static WhiteBox wb = WhiteBox.getWhiteBox();\n-\n-    static {\n-        System.loadLibrary(\"MallocHeaderModifier\");\n-    }\n-\n-    public static native byte modifyHeaderCanary(long malloc_memory);\n-    public static native byte modifyFooterCanary(long malloc_memory, long size);\n-    public static native byte modifyHeaderCanaryAndSiteMarker(long malloc_memory);\n-    public static native byte modifyFooterCanaryAndSiteMarker(long malloc_memory, long size);\n-\n-    private static void runThisTestWith(String arg) throws Exception {\n-        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(new String[] {\"-Xbootclasspath\/a:.\",\n-                                                                                    \"-XX:+UnlockDiagnosticVMOptions\",\n-                                                                                    \"-XX:+WhiteBoxAPI\",\n-                                                                                    \"-XX:NativeMemoryTracking=detail\",\n-                                                                                    \"-Djava.library.path=\" + Utils.TEST_NATIVE_PATH,\n-                                                                                    \"NMTPrintMallocSiteOfCorruptedMemory\",\n-                                                                                    arg});\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-        output.shouldMatch(\"NMT Block at .*, corruption at: \");\n-        switch(arg) {\n-            case HEADER_AND_SITE_ARG, FOOTER_AND_SITE_ARG -> output.shouldContain(\"allocation-site cannot be shown since the marker is also corrupted.\");\n-            case HEADER_ARG, FOOTER_ARG -> {\n-                output.shouldContain(\"allocated from:\");\n-                output.shouldMatch(\"\\\\[.*\\\\]WB_NMTMalloc\\\\+0x.*\");\n-            }\n-        }\n-    }\n-\n-    private static void testModifyHeaderCanary() {\n-        long addr = wb.NMTMalloc(MALLOC_SIZE);\n-        modifyHeaderCanary(addr);\n-        wb.NMTFree(addr);\n-    }\n-\n-    private static void testModifyFooterCanary() {\n-        long addr = wb.NMTMalloc(MALLOC_SIZE);\n-        modifyFooterCanary(addr, MALLOC_SIZE);\n-        wb.NMTFree(addr);\n-    }\n-\n-    private static void testModifyHeaderCanaryAndSiteMarker() {\n-        long addr = wb.NMTMalloc(MALLOC_SIZE);\n-        modifyHeaderCanaryAndSiteMarker(addr);\n-        wb.NMTFree(addr);\n-    }\n-\n-    private static void testModifyFooterCanaryAndSiteMarker() {\n-        long addr = wb.NMTMalloc(MALLOC_SIZE);\n-        modifyFooterCanaryAndSiteMarker(addr, MALLOC_SIZE);\n-        wb.NMTFree(addr);\n-    }\n-\n-    public static void main(String args[]) throws Exception {\n-        if (args != null && args.length == 1) {\n-            switch (args[0]) {\n-                case HEADER_ARG -> testModifyHeaderCanary();\n-                case FOOTER_ARG -> testModifyFooterCanary();\n-                case HEADER_AND_SITE_ARG -> testModifyHeaderCanaryAndSiteMarker();\n-                case FOOTER_AND_SITE_ARG -> testModifyFooterCanaryAndSiteMarker();\n-                default -> throw new RuntimeException(\"Invalid argument for NMTPrintMallocSiteOfCorruptedMemory (\" + args[0] + \")\");\n-            }\n-        } else {\n-            runThisTestWith(HEADER_ARG);\n-            runThisTestWith(FOOTER_ARG);\n-            runThisTestWith(HEADER_AND_SITE_ARG);\n-            runThisTestWith(FOOTER_AND_SITE_ARG);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/NMTPrintMallocSiteOfCorruptedMemory.java","additions":0,"deletions":115,"binary":false,"changes":115,"status":"deleted"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"jni.h\"\n-#include <stdint.h>\n-#include <string.h>\n-\n-JNIEXPORT jint JNICALL\n-Java_NMTPrintMallocSiteOfCorruptedMemory_modifyHeaderCanary(JNIEnv *env, jclass cls, jlong addr) {\n-  *((jint*)(uintptr_t)addr - 1) = 0;\n-  return 0;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_NMTPrintMallocSiteOfCorruptedMemory_modifyFooterCanary(JNIEnv *env, jclass cls, jlong addr, jint size) {\n-  *((jbyte*)(uintptr_t)addr + size + 1) = 0;\n-  return 0;\n-}\n-JNIEXPORT jint JNICALL\n-Java_NMTPrintMallocSiteOfCorruptedMemory_modifyHeaderCanaryAndSiteMarker(JNIEnv *env, jclass cls, jlong addr) {\n-  jbyte* p = (jbyte*)(uintptr_t)addr - 16;\n-  memset(p, 0xFF , 16);\n-  return 0;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_NMTPrintMallocSiteOfCorruptedMemory_modifyFooterCanaryAndSiteMarker(JNIEnv *env, jclass cls, jlong addr, jint size) {\n-  jbyte* p = (jbyte*)(uintptr_t)addr - 16;\n-  memset(p, 0xFF , 16);\n-  *((jbyte*)(uintptr_t)addr + size + 1) = 0;\n-  return 0;\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/libMallocHeaderModifier.c","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -28,1 +28,0 @@\n- * @requires test.thread.factory == null\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/AsyncExceptionOnMonitorEnter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @requires test.thread.factory == null\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/StopAtExit.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,412 +0,0 @@\n-\/*\n- * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.BufferedReader;\n-import java.io.FileReader;\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-\/*\n-\n-This is a simple parser for parsing the output of\n-\n-   java -Xshare:dump -Xlog:aot+map=debug,aot+map+oops=trace:file=aot.map:none:filesize=0\n-\n-The map file contains patterns like this for the heap objects:\n-\n-======================================================================\n-0x00000000ffe00000: @@ Object (0xffe00000) java.lang.String \"\"\n- - klass: 'java\/lang\/String' 0x0000000800010220\n- - fields (3 words):\n- - private 'hash' 'I' @12  0 (0x00000000)\n- - private final 'coder' 'B' @16  0 (0x00)\n- - private 'hashIsZero' 'Z' @17  true (0x01)\n- - injected 'flags' 'B' @18  1 (0x01)\n- - private final 'value' '[B' @20 0x00000000ffe00018 (0xffe00018) [B length: 0\n-0x00000000ffe00018: @@ Object (0xffe00018) [B length: 0\n- - klass: {type array byte} 0x00000008000024d8\n-======================================================================\n-\n-Currently this parser just check the output related to JDK-8308903.\n-I.e., each oop field must point to a valid HeapObject. For example, the 'value' field\n-in the String must point to a valid byte array.\n-\n-This parser can be extended to check for the other parts of the map file, or perform\n-more analysis on the HeapObjects.\n-\n-*\/\n-\n-public class AOTMapReader {\n-    public static class MapFile {\n-        HashSet<String> classes = new HashSet<>();\n-        ArrayList<HeapObject> heapObjects = new ArrayList<>();\n-        HashMap<Long, HeapObject> oopToObject = new HashMap<>();\n-        HashMap<Long, HeapObject> narrowOopToObject = new HashMap<>();\n-        public int stringCount = 0;\n-\n-        void add(HeapObject heapObject) {\n-            heapObjects.add(heapObject);\n-            oopToObject.put(heapObject.address.oop, heapObject);\n-            if (heapObject.address.narrowOop != 0) {\n-                narrowOopToObject.put(heapObject.address.narrowOop, heapObject);\n-            }\n-            if (heapObject.className.equals(\"java.lang.String\")) {\n-                stringCount ++;\n-            }\n-        }\n-\n-        public int heapObjectCount() {\n-            return heapObjects.size();\n-        }\n-\n-        void addClass(String className) {\n-            classes.add(className);\n-        }\n-\n-        public boolean hasClass(String className) {\n-            return classes.contains(className);\n-        }\n-\n-        public void shouldHaveClass(String className) {\n-            if (!hasClass(className)) {\n-                throw new RuntimeException(\"AOT map file is missing class \" + className);\n-            }\n-        }\n-    }\n-\n-    public static class HeapAddress {\n-        long oop;\n-        long narrowOop;\n-\n-        HeapAddress(String oopStr, String narrowOopStr) {\n-            oop = Long.parseUnsignedLong(oopStr, 16);\n-            if (narrowOopStr != null) {\n-                narrowOop = Long.parseUnsignedLong(narrowOopStr, 16);\n-            }\n-        }\n-    }\n-\n-    public static class Klass {\n-        long address;\n-        String name;\n-\n-        static Klass getKlass(String name, String addr) {\n-            \/\/ TODO: look up from a table of known Klasses\n-            Klass k = new Klass();\n-            k.name = name;\n-            k.address =  Long.parseUnsignedLong(addr, 16);\n-            return k;\n-        }\n-    }\n-\n-    public static class HeapObject {\n-        HeapAddress address;\n-        ArrayList<Field> fields;\n-        String className;\n-        Klass klass;\n-\n-        HeapObject(String className, String oop, String narrowOop) {\n-            this.className = className;\n-            address = new HeapAddress(oop, narrowOop);\n-        }\n-\n-        void setKlass(String klassName, String address) {\n-            klass = Klass.getKlass(klassName, address);\n-        }\n-\n-        void addOopField(String name, String offset, String oopStr, String narrowOopStr) {\n-            if (fields == null) {\n-                fields = new ArrayList<Field>();\n-            }\n-            fields.add(new Field(name, offset, oopStr, narrowOopStr));\n-        }\n-    }\n-\n-    public static class Field {\n-        String name;\n-        int offset;\n-        HeapAddress referentAddress; \/\/ non-null iff this is an object field\n-        int lineCount;\n-\n-        Field(String name, String offset, String oopStr, String narrowOopStr) {\n-            this.name = name;\n-            this.offset = Integer.parseInt(offset);\n-            this.referentAddress = new HeapAddress(oopStr, narrowOopStr);\n-            this.lineCount = AOTMapReader.lineCount;\n-        }\n-    }\n-\n-    \/\/ 0x00000007ffc00000:   4a5b8701 00000063 00010290 00000000 00010100 fff80003\n-    static Pattern rawDataPattern = Pattern.compile(\"^0x([0-9a-f]+): *( [0-9a-f]+)+ *$\");\n-\n-    \/\/ -------------------------------------------------------------------------------\n-    \/\/ Patterns for heap objects\n-    \/\/ -------------------------------------------------------------------------------\n-\n-    \/\/ (one address)\n-    \/\/ 0x00000007ffc00000: @@ Object java.lang.String\n-    static Pattern objPattern1 = Pattern.compile(\"^0x([0-9a-f]+): @@ Object ([^ ]*)\");\n-\n-    \/\/ (two addresses)\n-    \/\/ 0x00000007ffc00000: @@ Object (0xfff80000) java.lang.String\n-    static Pattern objPattern2 = Pattern.compile(\"^0x([0-9a-f]+): @@ Object [(]0x([0-9a-f]+)[)] ([^ ]*)\");\n-\n-    \/\/  - klass: 'java\/lang\/String' 0x0000000800010290\n-    static Pattern instanceObjKlassPattern = Pattern.compile(\"^ - klass: '([^']+)' 0x([0-9a-f]+)\");\n-\n-    \/\/  - klass: {type array byte} 0x00000008000024c8\n-    static Pattern typeArrayKlassPattern = Pattern.compile(\"^ - klass: [{]type array ([a-z]+)[}] 0x([0-9a-f]+)\");\n-\n-    \/\/  - klass: 'java\/lang\/Object'[] 0x00000008000013e0\n-    static Pattern objArrayKlassPattern = Pattern.compile(\"^ - klass: ('[^']+'(\\\\[\\\\])+) 0x([0-9a-f]+)\");\n-\n-    \/\/  - fields (3 words):\n-    static Pattern fieldsWordsPattern = Pattern.compile(\"^ - fields [(]([0-9]+) words[)]:$\");\n-\n-    \/\/ (one address)\n-    \/\/  - final 'key' 'Ljava\/lang\/Object;' @16 0x00000007ffc68260 java.lang.String\n-    static Pattern oopFieldPattern1 = Pattern.compile(\" - [^']* '([^']+)'.*@([0-9]+) 0x([0-9a-f]+) (.*)\");\n-\n-    \/\/ (two addresses)\n-    \/\/  - final 'key' 'Ljava\/lang\/Object;' @16 0x00000007ffc68260 (0xfff8d04c) java.lang.String\n-    static Pattern oopFieldPattern2 = Pattern.compile(\" - [^']* '([^']+)'.*@([0-9]+) 0x([0-9a-f]+) [(]0x([0-9a-f]+)[)] (.*)\");\n-\n-    \/\/ (injected module_entry)\n-    \/\/  - injected 'module_entry' 'J' @16 0 (0x0000000000000000)\n-    static Pattern moduleEntryPattern = Pattern.compile(\"- injected 'module_entry' 'J' @[0-9]+[ ]+([0-9]+)\");\n-\n-    \/\/ -------------------------------------------------------------------------------\n-    \/\/ Patterns for metaspace objects\n-    \/\/ -------------------------------------------------------------------------------\n-\n-    \/\/ 0x00000008000d1698: @@ Class             512 [Ljdk.internal.vm.FillerElement;\n-    \/\/ 0x00000008000d18a0: @@ Class             520 java.lang.Cloneable\n-    static Pattern classPattern = Pattern.compile(\"^0x([0-9a-f]+): @@ Class [ ]*([0-9]+) (.*)\");\n-\n-\n-    private static Matcher match(String line, Pattern pattern) {\n-        Matcher m = pattern.matcher(line);\n-        if (m.find()) {\n-            return m;\n-        } else {\n-            return null;\n-        }\n-    }\n-\n-    private static void parseHeapObject(String className, String oop, String narrowOop) throws IOException {\n-        HeapObject heapObject = parseHeapObjectImpl(className, oop, narrowOop);\n-        mapFile.add(heapObject);\n-    }\n-\n-    private static HeapObject parseHeapObjectImpl(String className, String oop, String narrowOop) throws IOException {\n-        HeapObject heapObject = new HeapObject(className, oop, narrowOop);\n-        Matcher m;\n-\n-        nextLine();\n-        while (line != null && match(line, rawDataPattern) != null) { \/\/ skip raw data\n-            nextLine();\n-        }\n-\n-        if (line == null || !line.startsWith(\" - \")) {\n-            return heapObject;\n-        }\n-\n-        if ((m = match(line, instanceObjKlassPattern)) != null) {\n-            heapObject.setKlass(m.group(1), m.group(2));\n-            nextLine();\n-            if ((m = match(line, fieldsWordsPattern)) == null) {\n-                throw new RuntimeException(\"Expected field size info\");\n-            }\n-            while (true) {\n-                nextLine();\n-                if (line == null || !line.startsWith(\" - \")) {\n-                    return heapObject;\n-                }\n-                if (!line.contains(\"marked metadata pointer\")) {\n-                    if ((m = match(line, oopFieldPattern2)) != null) {\n-                        heapObject.addOopField(m.group(1), m.group(2), m.group(3), m.group(4));\n-                    } else if ((m = match(line, oopFieldPattern1)) != null) {\n-                        heapObject.addOopField(m.group(1), m.group(2), m.group(3), null);\n-                    } else if ((m = match(line, moduleEntryPattern)) != null) {\n-                        String value = m.group(1);\n-                        if (!value.equals(\"0\")) {\n-                            throw new RuntimeException(\"module_entry should be 0 but found: \" + line);\n-                        }\n-                    }\n-                }\n-            }\n-        } else if ((m = match(line, typeArrayKlassPattern)) != null) {\n-            heapObject.setKlass(m.group(1), m.group(2));\n-            \/\/ TODO: read all the array elements\n-            while (true) {\n-                nextLine();\n-                if (line == null || !line.startsWith(\" - \")) {\n-                    return heapObject;\n-                }\n-            }\n-        } else if ((m = match(line, objArrayKlassPattern)) != null) {\n-            heapObject.setKlass(m.group(1), m.group(3));\n-            \/\/ TODO: read all the array elements\n-            while (true) {\n-                nextLine();\n-                if (line == null || !line.startsWith(\" - \")) {\n-                    return heapObject;\n-                }\n-            }\n-        } else {\n-            throw new RuntimeException(\"Expected klass info\");\n-        }\n-    }\n-\n-    private static void parseClassObject(String className, String addr, String size) throws IOException {\n-        mapFile.addClass(className);\n-        nextLine();\n-    }\n-\n-    static MapFile mapFile;\n-    static BufferedReader reader;\n-    static String line = null; \/\/ current line being parsed\n-    static int lineCount = 0;\n-    static String nextLine()  throws IOException {\n-        line = reader.readLine();\n-        ++ lineCount;\n-        return line;\n-    }\n-\n-    public static MapFile read(String fileName) {\n-        mapFile = new MapFile();\n-        lineCount = 0;\n-\n-        try (BufferedReader r = new BufferedReader(new FileReader(fileName))) {\n-            reader = r;\n-            nextLine();\n-\n-            Matcher m;\n-            while (line != null) {\n-                if ((m = match(line, objPattern2)) != null) {\n-                    parseHeapObject(m.group(3), m.group(1), m.group(2));\n-                } else if ((m = match(line, objPattern1)) != null) {\n-                    parseHeapObject(m.group(2), m.group(1), null);\n-                } else if ((m = match(line, classPattern)) != null) {\n-                    parseClassObject(m.group(3), m.group(1), m.group(2)); \/\/ name, addr, size\n-                } else {\n-                    nextLine();\n-                }\n-            }\n-            return mapFile;\n-        } catch (Throwable t) {\n-            System.out.println(\"Error parsing line \" + lineCount + \": \" + line);\n-            throw new RuntimeException(t);\n-        } finally {\n-            System.out.println(\"Parsed \" + lineCount + \" lines in \" + fileName);\n-            System.out.println(\"Found \" + mapFile.heapObjectCount() + \" heap objects (\"\n-                               + mapFile.stringCount + \" strings)\");\n-            mapFile = null;\n-            reader = null;\n-            line = null;\n-            lineCount = 0;\n-        }\n-    }\n-\n-    private static void mustContain(HashMap<Long, HeapObject> allObjects, Field field, long pointer, boolean isNarrow) {\n-        if (allObjects.get(pointer) == null) {\n-            throw new RuntimeException((isNarrow ? \"narrowOop\" : \"oop\") + \" pointer 0x\" + Long.toHexString(pointer) +\n-                                       \" on line \" + field.lineCount + \" doesn't point to a valid heap object\");\n-        }\n-    }\n-\n-    public static void validate(MapFile mapFile, String classLoadLogFile) throws IOException {\n-        validateOops(mapFile);\n-        if (classLoadLogFile != null) {\n-            validateClasses(mapFile, classLoadLogFile);\n-        }\n-    }\n-\n-    \/\/ Check that each oop fields in the HeapObjects must point to a valid HeapObject.\n-    static void validateOops(MapFile mapFile) {\n-        int count1 = 0;\n-        int count2 = 0;\n-        for (HeapObject heapObject : mapFile.heapObjects) {\n-            if (heapObject.fields != null) {\n-                for (Field field : heapObject.fields) {\n-                    HeapAddress referentAddress = field.referentAddress;\n-                    long oop = referentAddress.oop;\n-                    long narrowOop = referentAddress.narrowOop;\n-                    \/\/ Is this test actually doing something?\n-                    \/\/     To see how an invalidate pointer may be found, change oop in the\n-                    \/\/     following line to oop+1\n-                    if (oop != 0) {\n-                        mustContain(mapFile.oopToObject, field, oop, false);\n-                        count1 ++;\n-                    }\n-                    if (narrowOop != 0) {\n-                        mustContain(mapFile.narrowOopToObject, field, narrowOop, true);\n-                        count2 ++;\n-                    }\n-                }\n-            }\n-        }\n-        System.out.println(\"Found \" + count1 + \" non-null oop field references (normal)\");\n-        System.out.println(\"Found \" + count2 + \" non-null oop field references (narrow)\");\n-\n-        if (mapFile.heapObjectCount() > 0) {\n-            \/\/ heapObjectCount() may be zero if the selected GC doesn't support heap object archiving.\n-            if (mapFile.stringCount <= 0) {\n-                throw new RuntimeException(\"AOT map file should contain at least one string\");\n-            }\n-            if (count1 < mapFile.stringCount) {\n-                throw new RuntimeException(\"AOT map file seems incorrect: \" + mapFile.heapObjectCount() +\n-                                           \" objects (\" + mapFile.stringCount + \" strings). Each string should\" +\n-                                           \" have one non-null oop field but we found only \" + count1 +\n-                                           \" non-null oop field references\");\n-            }\n-        }\n-    }\n-\n-    \/\/ classLoadLogFile should be generated with -Xlog:class+load:file=<classLoadLogFile>:none:filesize=0\n-    \/\/ Check that every class loaded from \"source: shared objects file\" have an entry inside the mapFile.\n-    static void validateClasses(MapFile mapFile, String classLoadLogFile) throws IOException {\n-        try (BufferedReader r = new BufferedReader(new FileReader(classLoadLogFile))) {\n-            String line;\n-            String suffix = \" source: shared objects file\";\n-            int suffixLen = suffix.length();\n-            while ((line = r.readLine()) != null) {\n-                if (line.endsWith(suffix)) {\n-                    String className = line.substring(0, line.length() - suffixLen);\n-                    if (!mapFile.hasClass(className)) {\n-                        throw new RuntimeException(\"AOT map file is missing class \" + className);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    public static void main(String args[]) throws IOException {\n-        MapFile mapFile = read(args[0]);\n-        validate(mapFile, null);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/AOTMapReader.java","additions":0,"deletions":412,"binary":false,"changes":412,"status":"deleted"},{"patch":"@@ -0,0 +1,351 @@\n+\/*\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.BufferedReader;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/*\n+\n+This is a simple parser for parsing the output of\n+\n+   java -Xshare:dump -Xlog:aot+map=debug,aot+map+oops=trace:file=cds.map:none:filesize=0\n+\n+The map file contains patterns like this for the heap objects:\n+\n+======================================================================\n+0x00000000ffe00000: @@ Object (0xffe00000) java.lang.String \"\"\n+ - klass: 'java\/lang\/String' 0x0000000800010220\n+ - fields (3 words):\n+ - private 'hash' 'I' @12  0 (0x00000000)\n+ - private final 'coder' 'B' @16  0 (0x00)\n+ - private 'hashIsZero' 'Z' @17  true (0x01)\n+ - injected 'flags' 'B' @18  1 (0x01)\n+ - private final 'value' '[B' @20 0x00000000ffe00018 (0xffe00018) [B length: 0\n+0x00000000ffe00018: @@ Object (0xffe00018) [B length: 0\n+ - klass: {type array byte} 0x00000008000024d8\n+======================================================================\n+\n+Currently this parser just check the output related to JDK-8308903.\n+I.e., each oop field must point to a valid HeapObject. For example, the 'value' field\n+in the String must point to a valid byte array.\n+\n+This parser can be extended to check for the other parts of the map file, or perform\n+more analysis on the HeapObjects.\n+\n+*\/\n+\n+public class CDSMapReader {\n+    public static class MapFile {\n+        ArrayList<HeapObject> heapObjects = new ArrayList<>();\n+        HashMap<Long, HeapObject> oopToObject = new HashMap<>();\n+        HashMap<Long, HeapObject> narrowOopToObject = new HashMap<>();\n+        public int stringCount = 0;\n+\n+        void add(HeapObject heapObject) {\n+            heapObjects.add(heapObject);\n+            oopToObject.put(heapObject.address.oop, heapObject);\n+            if (heapObject.address.narrowOop != 0) {\n+                narrowOopToObject.put(heapObject.address.narrowOop, heapObject);\n+            }\n+            if (heapObject.className.equals(\"java.lang.String\")) {\n+                stringCount ++;\n+            }\n+        }\n+\n+        public int heapObjectCount() {\n+            return heapObjects.size();\n+        }\n+    }\n+\n+    public static class HeapAddress {\n+        long oop;\n+        long narrowOop;\n+\n+        HeapAddress(String oopStr, String narrowOopStr) {\n+            oop = Long.parseUnsignedLong(oopStr, 16);\n+            if (narrowOopStr != null) {\n+                narrowOop = Long.parseUnsignedLong(narrowOopStr, 16);\n+            }\n+        }\n+    }\n+\n+    public static class Klass {\n+        long address;\n+        String name;\n+\n+        static Klass getKlass(String name, String addr) {\n+            \/\/ TODO: look up from a table of known Klasses\n+            Klass k = new Klass();\n+            k.name = name;\n+            k.address =  Long.parseUnsignedLong(addr, 16);\n+            return k;\n+        }\n+    }\n+\n+    public static class HeapObject {\n+        HeapAddress address;\n+        ArrayList<Field> fields;\n+        String className;\n+        Klass klass;\n+\n+        HeapObject(String className, String oop, String narrowOop) {\n+            this.className = className;\n+            address = new HeapAddress(oop, narrowOop);\n+        }\n+\n+        void setKlass(String klassName, String address) {\n+            klass = Klass.getKlass(klassName, address);\n+        }\n+\n+        void addOopField(String name, String offset, String oopStr, String narrowOopStr) {\n+            if (fields == null) {\n+                fields = new ArrayList<Field>();\n+            }\n+            fields.add(new Field(name, offset, oopStr, narrowOopStr));\n+        }\n+    }\n+\n+    public static class Field {\n+        String name;\n+        int offset;\n+        HeapAddress referentAddress; \/\/ non-null iff this is an object field\n+        int lineCount;\n+\n+        Field(String name, String offset, String oopStr, String narrowOopStr) {\n+            this.name = name;\n+            this.offset = Integer.parseInt(offset);\n+            this.referentAddress = new HeapAddress(oopStr, narrowOopStr);\n+            this.lineCount = CDSMapReader.lineCount;\n+        }\n+    }\n+\n+    \/\/ 0x00000007ffc00000:   4a5b8701 00000063 00010290 00000000 00010100 fff80003\n+    static Pattern rawDataPattern = Pattern.compile(\"^0x([0-9a-f]+): *( [0-9a-f]+)+ *$\");\n+\n+    \/\/ (one address)\n+    \/\/ 0x00000007ffc00000: @@ Object java.lang.String\n+    static Pattern objPattern1 = Pattern.compile(\"^0x([0-9a-f]+): @@ Object ([^ ]*)\");\n+\n+    \/\/ (two addresses)\n+    \/\/ 0x00000007ffc00000: @@ Object (0xfff80000) java.lang.String\n+    static Pattern objPattern2 = Pattern.compile(\"^0x([0-9a-f]+): @@ Object [(]0x([0-9a-f]+)[)] ([^ ]*)\");\n+\n+    \/\/  - klass: 'java\/lang\/String' 0x0000000800010290\n+    static Pattern instanceObjKlassPattern = Pattern.compile(\"^ - klass: '([^']+)' 0x([0-9a-f]+)\");\n+\n+    \/\/  - klass: {type array byte} 0x00000008000024c8\n+    static Pattern typeArrayKlassPattern = Pattern.compile(\"^ - klass: [{]type array ([a-z]+)[}] 0x([0-9a-f]+)\");\n+\n+    \/\/  - klass: 'java\/lang\/Object'[] 0x00000008000013e0\n+    static Pattern objArrayKlassPattern = Pattern.compile(\"^ - klass: ('[^']+'(\\\\[\\\\])+) 0x([0-9a-f]+)\");\n+\n+    \/\/  - fields (3 words):\n+    static Pattern fieldsWordsPattern = Pattern.compile(\"^ - fields [(]([0-9]+) words[)]:$\");\n+\n+    \/\/ (one address)\n+    \/\/  - final 'key' 'Ljava\/lang\/Object;' @16 0x00000007ffc68260 java.lang.String\n+    static Pattern oopFieldPattern1 = Pattern.compile(\" - [^']* '([^']+)'.*@([0-9]+) 0x([0-9a-f]+) (.*)\");\n+\n+    \/\/ (two addresses)\n+    \/\/  - final 'key' 'Ljava\/lang\/Object;' @16 0x00000007ffc68260 (0xfff8d04c) java.lang.String\n+    static Pattern oopFieldPattern2 = Pattern.compile(\" - [^']* '([^']+)'.*@([0-9]+) 0x([0-9a-f]+) [(]0x([0-9a-f]+)[)] (.*)\");\n+\n+    \/\/ (injected module_entry)\n+    \/\/  - injected 'module_entry' 'J' @16 0 (0x0000000000000000)\n+    static Pattern moduleEntryPattern = Pattern.compile(\"- injected 'module_entry' 'J' @[0-9]+[ ]+([0-9]+)\");\n+\n+    private static Matcher match(String line, Pattern pattern) {\n+        Matcher m = pattern.matcher(line);\n+        if (m.find()) {\n+            return m;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private static void parseHeapObject(String className, String oop, String narrowOop) throws IOException {\n+        HeapObject heapObject = parseHeapObjectImpl(className, oop, narrowOop);\n+        mapFile.add(heapObject);\n+    }\n+\n+    private static HeapObject parseHeapObjectImpl(String className, String oop, String narrowOop) throws IOException {\n+        HeapObject heapObject = new HeapObject(className, oop, narrowOop);\n+        Matcher m;\n+\n+        nextLine();\n+        while (line != null && match(line, rawDataPattern) != null) { \/\/ skip raw data\n+            nextLine();\n+        }\n+\n+        if (line == null || !line.startsWith(\" - \")) {\n+            return heapObject;\n+        }\n+\n+        if ((m = match(line, instanceObjKlassPattern)) != null) {\n+            heapObject.setKlass(m.group(1), m.group(2));\n+            nextLine();\n+            if ((m = match(line, fieldsWordsPattern)) == null) {\n+                throw new RuntimeException(\"Expected field size info\");\n+            }\n+            while (true) {\n+                nextLine();\n+                if (line == null || !line.startsWith(\" - \")) {\n+                    return heapObject;\n+                }\n+                if (!line.contains(\"marked metadata pointer\")) {\n+                    if ((m = match(line, oopFieldPattern2)) != null) {\n+                        heapObject.addOopField(m.group(1), m.group(2), m.group(3), m.group(4));\n+                    } else if ((m = match(line, oopFieldPattern1)) != null) {\n+                        heapObject.addOopField(m.group(1), m.group(2), m.group(3), null);\n+                    } else if ((m = match(line, moduleEntryPattern)) != null) {\n+                        String value = m.group(1);\n+                        if (!value.equals(\"0\")) {\n+                            throw new RuntimeException(\"module_entry should be 0 but found: \" + line);\n+                        }\n+                    }\n+                }\n+            }\n+        } else if ((m = match(line, typeArrayKlassPattern)) != null) {\n+            heapObject.setKlass(m.group(1), m.group(2));\n+            \/\/ TODO: read all the array elements\n+            while (true) {\n+                nextLine();\n+                if (line == null || !line.startsWith(\" - \")) {\n+                    return heapObject;\n+                }\n+            }\n+        } else if ((m = match(line, objArrayKlassPattern)) != null) {\n+            heapObject.setKlass(m.group(1), m.group(3));\n+            \/\/ TODO: read all the array elements\n+            while (true) {\n+                nextLine();\n+                if (line == null || !line.startsWith(\" - \")) {\n+                    return heapObject;\n+                }\n+            }\n+        } else {\n+            throw new RuntimeException(\"Expected klass info\");\n+        }\n+    }\n+\n+    static MapFile mapFile;\n+    static BufferedReader reader;\n+    static String line = null; \/\/ current line being parsed\n+    static int lineCount = 0;\n+    static String nextLine()  throws IOException {\n+        line = reader.readLine();\n+        ++ lineCount;\n+        return line;\n+    }\n+\n+    public static MapFile read(String fileName) {\n+        mapFile = new MapFile();\n+        lineCount = 0;\n+\n+        try (BufferedReader r = new BufferedReader(new FileReader(fileName))) {\n+            reader = r;\n+            nextLine();\n+\n+            Matcher m;\n+            while (line != null) {\n+                if ((m = match(line, objPattern2)) != null) {\n+                    parseHeapObject(m.group(3), m.group(1), m.group(2));\n+                } else if ((m = match(line, objPattern1)) != null) {\n+                    parseHeapObject(m.group(2), m.group(1), null);\n+                } else {\n+                    nextLine();\n+                }\n+            }\n+            return mapFile;\n+        } catch (Throwable t) {\n+            System.out.println(\"Error parsing line \" + lineCount + \": \" + line);\n+            throw new RuntimeException(t);\n+        } finally {\n+            System.out.println(\"Parsed \" + lineCount + \" lines in \" + fileName);\n+            System.out.println(\"Found \" + mapFile.heapObjectCount() + \" heap objects (\"\n+                               + mapFile.stringCount + \" strings)\");\n+            mapFile = null;\n+            reader = null;\n+            line = null;\n+            lineCount = 0;\n+        }\n+    }\n+\n+    private static void mustContain(HashMap<Long, HeapObject> allObjects, Field field, long pointer, boolean isNarrow) {\n+        if (allObjects.get(pointer) == null) {\n+            throw new RuntimeException((isNarrow ? \"narrowOop\" : \"oop\") + \" pointer 0x\" + Long.toHexString(pointer) +\n+                                       \" on line \" + field.lineCount + \" doesn't point to a valid heap object\");\n+        }\n+    }\n+\n+    \/\/ Check that each oop fields in the HeapObjects must point to a valid HeapObject.\n+    public static void validate(MapFile mapFile) {\n+        int count1 = 0;\n+        int count2 = 0;\n+        for (HeapObject heapObject : mapFile.heapObjects) {\n+            if (heapObject.fields != null) {\n+                for (Field field : heapObject.fields) {\n+                    HeapAddress referentAddress = field.referentAddress;\n+                    long oop = referentAddress.oop;\n+                    long narrowOop = referentAddress.narrowOop;\n+                    \/\/ Is this test actually doing something?\n+                    \/\/     To see how an invalidate pointer may be found, change oop in the\n+                    \/\/     following line to oop+1\n+                    if (oop != 0) {\n+                        mustContain(mapFile.oopToObject, field, oop, false);\n+                        count1 ++;\n+                    }\n+                    if (narrowOop != 0) {\n+                        mustContain(mapFile.narrowOopToObject, field, narrowOop, true);\n+                        count2 ++;\n+                    }\n+                }\n+            }\n+        }\n+        System.out.println(\"Found \" + count1 + \" non-null oop field references (normal)\");\n+        System.out.println(\"Found \" + count2 + \" non-null oop field references (narrow)\");\n+\n+        if (mapFile.heapObjectCount() > 0) {\n+            \/\/ heapObjectCount() may be zero if the selected GC doesn't support heap object archiving.\n+            if (mapFile.stringCount <= 0) {\n+                throw new RuntimeException(\"CDS map file should contain at least one string\");\n+            }\n+            if (count1 < mapFile.stringCount) {\n+                throw new RuntimeException(\"CDS map file seems incorrect: \" + mapFile.heapObjectCount() +\n+                                           \" objects (\" + mapFile.stringCount + \" strings). Each string should\" +\n+                                           \" have one non-null oop field but we found only \" + count1 +\n+                                           \" non-null oop field references\");\n+            }\n+        }\n+    }\n+\n+    public static void main(String args[]) {\n+        MapFile mapFile = read(args[0]);\n+        validate(mapFile);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/CDSMapReader.java","additions":351,"deletions":0,"binary":false,"changes":351,"status":"added"},{"patch":"@@ -30,1 +30,1 @@\n- * @run driver\/timeout=240 AOTMapTest\n+ * @run driver\/timeout=240 CDSMapTest\n@@ -40,1 +40,1 @@\n-public class AOTMapTest {\n+public class CDSMapTest {\n@@ -82,2 +82,2 @@\n-        AOTMapReader.MapFile mapFile = AOTMapReader.read(mapName);\n-        AOTMapReader.validate(mapFile, null);\n+        CDSMapReader.MapFile mapFile = CDSMapReader.read(mapName);\n+        CDSMapReader.validate(mapFile);\n@@ -101,2 +101,2 @@\n-        AOTMapReader.MapFile mapFile = AOTMapReader.read(mapName);\n-        AOTMapReader.validate(mapFile, null);\n+        CDSMapReader.MapFile mapFile = CDSMapReader.read(mapName);\n+        CDSMapReader.validate(mapFile);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/CDSMapTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"previous_filename":"test\/hotspot\/jtreg\/runtime\/cds\/AOTMapTest.java","status":"renamed"},{"patch":"@@ -29,2 +29,2 @@\n- * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\n- * @build AOTMapTest Hello\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\n+ * @build AOTMapTest\n@@ -32,1 +32,0 @@\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar cust.jar Hello\n@@ -41,1 +40,1 @@\n- * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\n@@ -44,1 +43,1 @@\n- * @build AOTMapTest Hello\n+ * @build AOTMapTest\n@@ -46,1 +45,0 @@\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar cust.jar Hello\n@@ -50,3 +48,1 @@\n-import java.io.File;\n-import java.net.URL;\n-import java.net.URLClassLoader;\n+\n@@ -61,1 +57,0 @@\n-    static final String classLoadLogFile = \"production.class.load.log\";\n@@ -71,8 +66,2 @@\n-        if (tester.isDynamicWorkflow()) {\n-            \/\/ For dynamic workflow, the AOT map file doesn't include classes in the base archive, so\n-            \/\/ AOTMapReader.validateClasses() will fail.\n-            validate(tester.dumpMapFile, false);\n-        } else {\n-            validate(tester.dumpMapFile, true);\n-        }\n-        validate(tester.runMapFile, true);\n+        validate(tester.dumpMapFile);\n+        validate(tester.runMapFile);\n@@ -81,9 +70,3 @@\n-    static void validate(String mapFileName, boolean checkClases) throws Exception {\n-        AOTMapReader.MapFile mapFile = AOTMapReader.read(mapFileName);\n-        if (checkClases) {\n-            AOTMapReader.validate(mapFile, classLoadLogFile);\n-        } else {\n-            AOTMapReader.validate(mapFile, null);\n-        }\n-        mapFile.shouldHaveClass(\"AOTMapTestApp\"); \/\/ built-in class\n-        mapFile.shouldHaveClass(\"Hello\"); \/\/ unregistered class\n+    static void validate(String mapFileName) {\n+        CDSMapReader.MapFile mapFile = CDSMapReader.read(mapFileName);\n+        CDSMapReader.validate(mapFile);\n@@ -117,1 +100,1 @@\n-            String logSuffix = \":none:filesize=0\";\n+            String logMapSuffix = \":none:filesize=0\";\n@@ -120,1 +103,1 @@\n-                vmArgs.add(logMapPrefix + dumpMapFile + logSuffix);\n+                vmArgs.add(logMapPrefix + dumpMapFile + logMapSuffix);\n@@ -122,2 +105,1 @@\n-                vmArgs.add(logMapPrefix + runMapFile + logSuffix);\n-                vmArgs.add(\"-Xlog:class+load:file=\" + classLoadLogFile + logSuffix);\n+                vmArgs.add(logMapPrefix + runMapFile + logMapSuffix);\n@@ -139,1 +121,1 @@\n-    public static void main(String[] args) throws Exception {\n+    public static void main(String[] args) {\n@@ -141,9 +123,0 @@\n-        testCustomLoader();\n-    }\n-\n-    static void testCustomLoader() throws Exception {\n-        File custJar = new File(\"cust.jar\");\n-        URL[] urls = new URL[] {custJar.toURI().toURL()};\n-        URLClassLoader loader = new URLClassLoader(urls, AOTMapTestApp.class.getClassLoader());\n-        Class<?> c = loader.loadClass(\"Hello\");\n-        System.out.println(c);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCache\/AOTMapTest.java","additions":14,"deletions":41,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -177,0 +177,3 @@\n+               .shouldContain(\"Cannot aot-resolve Lambda proxy because OldConsumer is excluded\")\n+               .shouldContain(\"Cannot aot-resolve Lambda proxy because OldProvider is excluded\")\n+               .shouldContain(\"Cannot aot-resolve Lambda proxy because OldClass is excluded\")\n@@ -179,1 +182,3 @@\n-               .shouldMatch(\"archived indy *CP entry.*StringConcatTest .* => java\/lang\/invoke\/StringConcatFactory.makeConcatWithConstants\");\n+               .shouldNotMatch(\"klasses.* app *SubOfOldClass[$][$]Lambda\/\")\n+               .shouldMatch(\"archived indy *CP entry.*StringConcatTest .* => java\/lang\/invoke\/StringConcatFactory.makeConcatWithConstants\")\n+               .shouldNotMatch(\"archived indy *CP entry.*StringConcatTestOld .* => java\/lang\/invoke\/StringConcatFactory.makeConcatWithConstants\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/resolvedConstants\/ResolvedConstants.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n- * @requires test.thread.factory == null\n","filename":"test\/hotspot\/jtreg\/runtime\/handshake\/HandshakeWalkStackTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,103 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import com.sun.tools.attach.VirtualMachine;\n-import com.sun.tools.attach.AgentLoadException;\n-\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.BeforeAll;\n-import org.junit.jupiter.api.AfterAll;\n-\n-import java.io.File;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.util.concurrent.TimeUnit;\n-import jdk.test.lib.dcmd.PidJcmdExecutor;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.Utils;\n-\n-\/*\n- * @test EarlyDynamicLoad\n- * @summary Test that dynamic attach fails gracefully when the JVM is not in live phase.\n- * @requires vm.jvmti\n- * @library \/test\/lib\n- * @run junit EarlyDynamicLoad\n- *\/\n-public class EarlyDynamicLoad {\n-    private static final String EXPECTED_MESSAGE = \"Dynamic agent loading is only permitted in the live phase\";\n-\n-    private static Process child;\n-\n-    @BeforeAll\n-    static void startAndWaitChild() throws Exception {\n-        child = ProcessTools.createTestJavaProcessBuilder(\n-                        \"-XX:+StartAttachListener\",\n-                        \"-agentpath:\" + Utils.TEST_NATIVE_PATH + File.separator + System.mapLibraryName(\"EarlyDynamicLoad\"),\n-                        \"--version\").start();\n-\n-        \/\/ Wait until the process enters VMStartCallback\n-        try (InputStream is = child.getInputStream()) {\n-            is.read();\n-        }\n-    }\n-\n-    @AfterAll\n-    static void stopChild() throws Exception {\n-        try (OutputStream os = child.getOutputStream()) {\n-            os.write(0);\n-        }\n-\n-        if (!child.waitFor(5, TimeUnit.SECONDS)) {\n-            child.destroyForcibly();\n-            throw new AssertionError(\"Timed out while waiting child process to complete\");\n-        }\n-\n-        OutputAnalyzer analyzer = new OutputAnalyzer(child);\n-        analyzer.shouldHaveExitValue(0);\n-        analyzer.stderrShouldBeEmpty();\n-    }\n-\n-    @Test\n-    public void virtualMachine() throws Exception {\n-        try {\n-            VirtualMachine vm = VirtualMachine.attach(String.valueOf(child.pid()));\n-            vm.loadAgent(\"some.jar\");\n-            vm.detach();\n-            throw new AssertionError(\"Should have failed with AgentLoadException\");\n-        } catch(AgentLoadException exception) {\n-            if (!exception.getMessage().contains(EXPECTED_MESSAGE)) {\n-                throw new AssertionError(\"Unexpected error message\", exception);\n-            }\n-        }\n-    }\n-\n-    @Test\n-    public void jcmd() throws Exception {\n-        PidJcmdExecutor executor = new PidJcmdExecutor(String.valueOf(child.pid()));\n-        OutputAnalyzer out = executor.execute(\"JVMTI.agent_load some.jar\");\n-\n-        out.shouldHaveExitValue(0);\n-        out.stdoutShouldContain(EXPECTED_MESSAGE);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/serviceability\/attach\/EarlyDynamicLoad\/EarlyDynamicLoad.java","additions":0,"deletions":103,"binary":false,"changes":103,"status":"deleted"},{"patch":"@@ -1,59 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <jvmti.h>\n-#include <cstdio>\n-#include <cstring>\n-\n-extern \"C\" {\n-\n-static void JNICALL VMStartCallback(jvmtiEnv* jvmti, JNIEnv* env) {\n-  putchar('1');\n-  fflush(stdout);\n-  getchar();\n-}\n-\n-JNIEXPORT int Agent_OnLoad(JavaVM* vm, char* options, void* reserved) {\n-  jvmtiEnv* jvmti;\n-  if (vm->GetEnv((void**) &jvmti, JVMTI_VERSION_1_0) != JVMTI_ERROR_NONE) {\n-    fprintf(stderr, \"JVMTI error occurred during GetEnv\\n\");\n-    return JNI_ERR;\n-  }\n-\n-  jvmtiEventCallbacks callbacks;\n-  memset(&callbacks, 0, sizeof(callbacks));\n-  callbacks.VMStart = VMStartCallback;\n-\n-  if (jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks)) != JVMTI_ERROR_NONE) {\n-    fprintf(stderr, \"JVMTI error occurred during SetEventCallbacks\\n\");\n-    return JNI_ERR;\n-  }\n-  if (jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_START, nullptr) != JVMTI_ERROR_NONE) {\n-    fprintf(stderr, \"JVMTI error occurred during SetEventNotificationMode\\n\");\n-    return JNI_ERR;\n-  }\n-\n-  return JNI_OK;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/serviceability\/attach\/EarlyDynamicLoad\/libEarlyDynamicLoad.cpp","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"},{"patch":"@@ -30,0 +30,1 @@\n+ * @library \/testlibrary\/asm\n@@ -35,4 +36,5 @@\n-import java.lang.classfile.Attributes;\n-import java.lang.classfile.ClassFile;\n-import java.lang.classfile.ClassModel;\n-import java.lang.classfile.MethodModel;\n+import org.objectweb.asm.ClassReader;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.Opcodes;\n+\n@@ -59,10 +61,20 @@\n-        ClassModel clazz = ClassFile.of().parse(classfileBuffer);\n-        int count = 0;\n-        for (MethodModel method : clazz.methods()) {\n-            var foundStackMapTable = method.code().flatMap(code -> code.findAttribute(Attributes.stackMapTable()));\n-            if (foundStackMapTable.isPresent()) {\n-                int methodFrames = foundStackMapTable.get().entries().size();\n-                log(\"  method \" + method.methodName() + \" - \" + methodFrames + \" frames\");\n-                count += methodFrames;\n-            } else {\n-                log(\"  method \" + method.methodName() + \" - No StackMapTable\");\n+        ClassReader reader = new ClassReader(classfileBuffer);\n+        final int[] frameCount = {0};\n+        ClassVisitor cv = new ClassVisitor(Opcodes.ASM9) {\n+            @Override\n+            public MethodVisitor visitMethod(int access, String name,\n+                                             String descriptor, String signature,\n+                                             String[] exceptions) {\n+                return new MethodVisitor(Opcodes.ASM9) {\n+                    private int methodFrames = 0;\n+                    @Override\n+                    public void visitFrame(int type, int numLocal, Object[] local,\n+                                           int numStack, Object[] stack) {\n+                        methodFrames++;\n+                    }\n+                    @Override\n+                    public void visitEnd() {\n+                        log(\"  method \" + name + \" - \" + methodFrames + \" frames\");\n+                        frameCount[0] += methodFrames;\n+                    }\n+                };\n@@ -70,2 +82,3 @@\n-        }\n-        return count;\n+        };\n+        reader.accept(cv, 0);\n+        return frameCount[0];\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/MissedStackMapFrames\/MissedStackMapFrames.java","additions":29,"deletions":16,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @library \/testlibrary\/asm\n@@ -48,5 +49,0 @@\n-import java.lang.classfile.ClassBuilder;\n-import java.lang.classfile.ClassElement;\n-import java.lang.classfile.ClassFile;\n-import java.lang.classfile.ClassTransform;\n-import java.lang.classfile.FieldModel;\n@@ -62,0 +58,1 @@\n+import java.lang.reflect.TypeVariable;\n@@ -63,1 +60,2 @@\n-import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedList;\n@@ -66,0 +64,5 @@\n+import org.objectweb.asm.ClassReader;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.ClassWriter;\n+import org.objectweb.asm.FieldVisitor;\n+import static org.objectweb.asm.Opcodes.ASM7;\n@@ -86,4 +89,24 @@\n-            \/\/ Shuffle constant pool\n-            ClassFile context = ClassFile.of(ClassFile.ConstantPoolSharingOption.NEW_POOL);\n-            return context.transformClass(context.parse(classfileBuffer), new ClassTransform() {\n-                final List<FieldModel> dummyFields = new ArrayList<>();\n+            ClassWriter cw = new ClassWriter(0);\n+            ClassVisitor cv = new ReAddDummyFieldsClassVisitor(ASM7, cw) { };\n+            ClassReader cr = new ClassReader(classfileBuffer);\n+            cr.accept(cv, 0);\n+            return cw.toByteArray();\n+        }\n+\n+        public class ReAddDummyFieldsClassVisitor extends ClassVisitor {\n+\n+            LinkedList<F> fields = new LinkedList<>();\n+\n+            public ReAddDummyFieldsClassVisitor(int api, ClassVisitor cv) {\n+                super(api, cv);\n+            }\n+\n+            @Override public FieldVisitor visitField(int access, String name,\n+                    String desc, String signature, Object value) {\n+                if (name.startsWith(\"dummy\")) {\n+                    \/\/ Remove dummy field\n+                    fields.addLast(new F(access, name, desc, signature, value));\n+                    return null;\n+                }\n+                return cv.visitField(access, name, desc, signature, value);\n+            }\n@@ -91,8 +114,5 @@\n-                @Override\n-                public void accept(ClassBuilder builder, ClassElement element) {\n-                    if (element instanceof FieldModel field && field.fieldName().stringValue().startsWith(\"dummy\")) {\n-                        \/\/ Hold on to the associated constant pool entries too\n-                        dummyFields.addLast(field);\n-                    } else {\n-                        builder.with(element);\n-                    }\n+            @Override public void visitEnd() {\n+                F f;\n+                while ((f = fields.pollFirst()) != null) {\n+                    \/\/ Re-add dummy fields\n+                    cv.visitField(f.access, f.name, f.desc, f.signature, f.value);\n@@ -100,0 +120,1 @@\n+            }\n@@ -101,4 +122,12 @@\n-                @Override\n-                public void atEnd(ClassBuilder builder) {\n-                    \/\/ Add the associated constant pool entries to the end of the CP\n-                    dummyFields.forEach(builder);\n+            private class F {\n+                private int access;\n+                private String name;\n+                private String desc;\n+                private String signature;\n+                private Object value;\n+                F(int access, String name, String desc, String signature, Object value) {\n+                    this.access = access;\n+                    this.name = name;\n+                    this.desc = desc;\n+                    this.signature = signature;\n+                    this.value = value;\n@@ -106,1 +135,1 @@\n-            });\n+            }\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineAnnotations.java","additions":52,"deletions":23,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -38,5 +38,0 @@\n-import java.lang.classfile.ClassBuilder;\n-import java.lang.classfile.ClassElement;\n-import java.lang.classfile.ClassFile;\n-import java.lang.classfile.ClassTransform;\n-import java.lang.classfile.attribute.SourceFileAttribute;\n@@ -149,2 +144,3 @@\n-        ClassFile context = ClassFile.of();\n-        return context.transformClass(context.parse(bytecode), new ClassTransform() {\n+        ClassWriter cw = new ClassWriter(0);\n+        ClassReader cr = new ClassReader(bytecode);\n+        cr.accept(new ClassVisitor(Opcodes.ASM7, cw) {\n@@ -153,8 +149,4 @@\n-            public void accept(ClassBuilder builder, ClassElement element) {\n-                if (element instanceof SourceFileAttribute src) {\n-                    sourceSet = true;\n-                    log(\"Changing source: \\\"\" + src.sourceFile() + \"\\\" -> \\\"\" + sourceFileNameNew + \"\\\"\");\n-                    builder.with(SourceFileAttribute.of(sourceFileNameNew));\n-                } else {\n-                    builder.with(element);\n-                }\n+            public void visitSource(String source, String debug) {\n+                sourceSet = true;\n+                log(\"Changing source: \\\"\" + source + \"\\\" -> \\\"\" + sourceFileNameNew + \"\\\"\");\n+                super.visitSource(sourceFileNameNew, debug);\n@@ -164,1 +156,1 @@\n-            public void atEnd(ClassBuilder builder) {\n+            public void visitEnd() {\n@@ -167,1 +159,1 @@\n-                    builder.with(SourceFileAttribute.of(sourceFileNameNew));\n+                    super.visitSource(sourceFileNameNew, null);\n@@ -169,0 +161,1 @@\n+                super.visitEnd();\n@@ -170,1 +163,2 @@\n-        });\n+        }, 0);\n+        return cw.toByteArray();\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineGenericSignatureTest.java","additions":12,"deletions":18,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @library \/testlibrary\/asm\n@@ -43,4 +44,0 @@\n-import java.lang.classfile.ClassBuilder;\n-import java.lang.classfile.ClassElement;\n-import java.lang.classfile.ClassFile;\n-import java.lang.classfile.ClassFileVersion;\n@@ -52,0 +49,8 @@\n+import java.util.Arrays;\n+\n+import org.objectweb.asm.ClassReader;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.ClassWriter;\n+\n+import static org.objectweb.asm.Opcodes.ASM6;\n+import static org.objectweb.asm.Opcodes.V1_8;\n@@ -67,8 +72,25 @@\n-            return ClassFile.of().transformClass(ClassFile.of().parse(classfileBuffer), (classBuilder, classElement) -> {\n-                if (classElement instanceof ClassFileVersion cfv) {\n-                    \/\/ Force a redefine with different class file versions\n-                    classBuilder.with(ClassFileVersion.of(cfv.majorVersion() - 1, 0));\n-                } else {\n-                    classBuilder.with(classElement);\n-                }\n-            });\n+            ClassWriter cw = new ClassWriter(0);\n+            \/\/ Force an older ASM to force a bytecode update\n+            ClassVisitor cv = new DummyClassVisitor(ASM6, cw) { };\n+            ClassReader cr = new ClassReader(classfileBuffer);\n+            cr.accept(cv, 0);\n+            byte[] bytes = cw.toByteArray();\n+            return bytes;\n+        }\n+\n+        public class DummyClassVisitor extends ClassVisitor {\n+\n+            public DummyClassVisitor(int api, ClassVisitor cv) {\n+                super(api, cv);\n+            }\n+\n+            public void visit(\n+                    final int version,\n+                    final int access,\n+                    final String name,\n+                    final String signature,\n+                    final String superName,\n+                    final String[] interfaces) {\n+                \/\/ Artificially lower to JDK 8 version to force a redefine\n+                cv.visit(V1_8, access, name, signature, superName, interfaces);\n+            }\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineObject.java","additions":34,"deletions":12,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @library \/testlibrary\/asm\n@@ -44,11 +45,7 @@\n-import java.lang.classfile.Annotation;\n-import java.lang.classfile.AnnotationElement;\n-import java.lang.classfile.AnnotationValue;\n-import java.lang.classfile.Attributes;\n-import java.lang.classfile.ClassFile;\n-import java.lang.classfile.ClassModel;\n-import java.lang.classfile.ClassTransform;\n-import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n-import java.lang.constant.ClassDesc;\n-import java.util.List;\n-import java.util.NoSuchElementException;\n+\n+import org.objectweb.asm.AnnotationVisitor;\n+import org.objectweb.asm.ClassReader;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.ClassWriter;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n@@ -87,1 +84,43 @@\n-    private static final ClassDesc CD_ClassVersion = ClassVersion.class.describeConstable().orElseThrow();\n+    private static class VersionScanner extends ClassVisitor {\n+        private Integer detectedVersion;\n+        private Integer versionToSet;\n+        \/\/ to get version\n+        public VersionScanner() {\n+            super(Opcodes.ASM7);\n+        }\n+        \/\/ to set version\n+        public VersionScanner(int verToSet, ClassVisitor classVisitor) {\n+            super(Opcodes.ASM7, classVisitor);\n+            versionToSet = verToSet;\n+        }\n+\n+        public int detectedVersion() {\n+            if (detectedVersion == null) {\n+                throw new RuntimeException(\"Version not detected\");\n+            }\n+            return detectedVersion;\n+        }\n+\n+        @Override\n+        public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {\n+            \/\/log(\"visitAnnotation: descr = '\" + descriptor + \"', visible = \" + visible);\n+            if (Type.getDescriptor(ClassVersion.class).equals(descriptor)) {\n+                return new AnnotationVisitor(Opcodes.ASM7, super.visitAnnotation(descriptor, visible)) {\n+                    @Override\n+                    public void visit(String name, Object value) {\n+                        \/\/log(\"visit: name = '\" + name + \"', value = \" + value\n+                        \/\/        + \" (\" + (value == null ? \"N\/A\" : value.getClass()) + \")\");\n+                        if (\"value\".equals(name) && value instanceof Integer intValue) {\n+                            detectedVersion = intValue;\n+                            if (versionToSet != null) {\n+                                \/\/log(\"replace with \" + versionToSet);\n+                                value = versionToSet;\n+                            }\n+                        }\n+                        super.visit(name, value);\n+                    }\n+                };\n+            }\n+            return super.visitAnnotation(descriptor, visible);\n+        }\n+    }\n@@ -94,4 +133,4 @@\n-        return ClassFile.of().transformClass(ClassFile.of().parse(initialClassBytes),\n-                \/\/ overwrites previously passed RVAA\n-                ClassTransform.endHandler(classBuilder -> classBuilder.with(RuntimeVisibleAnnotationsAttribute\n-                        .of(Annotation.of(CD_ClassVersion, AnnotationElement.ofInt(\"value\", ver))))));\n+        ClassWriter cw = new ClassWriter(0);\n+        ClassReader cr = new ClassReader(initialClassBytes);\n+        cr.accept(new VersionScanner(ver, cw), 0);\n+        return cw.toByteArray();\n@@ -102,11 +141,4 @@\n-        ClassModel classModel = ClassFile.of().parse(classBytes);\n-        RuntimeVisibleAnnotationsAttribute rvaa = classModel.findAttribute(Attributes.runtimeVisibleAnnotations()).orElseThrow();\n-        List<AnnotationElement> classVersionElementValuePairs = rvaa.annotations().stream()\n-                .filter(anno -> anno.className().isFieldType(CD_ClassVersion))\n-                .findFirst().orElseThrow().elements();\n-        if (classVersionElementValuePairs.size() != 1)\n-            throw new NoSuchElementException();\n-        AnnotationElement elementValuePair = classVersionElementValuePairs.getFirst();\n-        if (!elementValuePair.name().equalsString(\"value\") || !(elementValuePair.value() instanceof AnnotationValue.OfInt intVal))\n-            throw new NoSuchElementException();\n-        return intVal.intValue();\n+        ClassReader cr = new ClassReader(classBytes);\n+        VersionScanner scanner = new VersionScanner();\n+        cr.accept(scanner, 0);\n+        return scanner.detectedVersion();\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineRetransform\/RedefineRetransform.java","additions":59,"deletions":27,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n- * @library \/test\/lib\n@@ -34,0 +33,1 @@\n+import java.util.concurrent.*;\n@@ -37,4 +37,2 @@\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.ThreadFactory;\n-import jdk.test.lib.thread.VThreadScheduler;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n@@ -64,1 +62,1 @@\n-            ThreadFactory factory = VThreadScheduler.virtualThreadBuilder(scheduler).factory();\n+            ThreadFactory factory = virtualThreadBuilder(scheduler).factory();\n@@ -103,0 +101,18 @@\n+\n+    private static Thread.Builder.OfVirtual virtualThreadBuilder(Executor scheduler) {\n+        Thread.Builder.OfVirtual builder = Thread.ofVirtual();\n+        try {\n+            Class<?> clazz = Class.forName(\"java.lang.ThreadBuilders$VirtualThreadBuilder\");\n+            Constructor<?> ctor = clazz.getDeclaredConstructor(Executor.class);\n+            ctor.setAccessible(true);\n+            return (Thread.Builder.OfVirtual) ctor.newInstance(scheduler);\n+        } catch (InvocationTargetException e) {\n+            Throwable cause = e.getCause();\n+            if (cause instanceof RuntimeException re) {\n+                throw re;\n+            }\n+            throw new RuntimeException(e);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/ThreadStateTest\/ThreadStateTest.java","additions":23,"deletions":7,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1,87 +0,0 @@\n-\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2025, NTT DATA\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SymbolLookup;\n-import java.lang.foreign.ValueLayout;\n-import java.util.concurrent.CountDownLatch;\n-\n-import jdk.test.lib.apps.LingeredApp;\n-\n-public class LingeredAppWithVirtualThread extends LingeredApp implements Runnable {\n-\n-    private static final String THREAD_NAME = \"target thread\";\n-\n-    private static final MethodHandle hndSleep;\n-\n-    private static final int sleepArg;\n-\n-    private static final CountDownLatch signal = new CountDownLatch(1);\n-\n-    static {\n-        MemorySegment func;\n-        if (System.getProperty(\"os.name\").startsWith(\"Windows\")) {\n-            func = SymbolLookup.libraryLookup(\"Kernel32\", Arena.global())\n-                               .findOrThrow(\"Sleep\");\n-            sleepArg = 3600_000; \/\/ 1h in milliseconds\n-        } else {\n-            func = Linker.nativeLinker()\n-                         .defaultLookup()\n-                         .findOrThrow(\"sleep\");\n-            sleepArg = 3600; \/\/ 1h in seconds\n-        }\n-\n-        var desc = FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.JAVA_INT);\n-        hndSleep = Linker.nativeLinker().downcallHandle(func, desc);\n-    }\n-\n-    @Override\n-    public void run() {\n-        Thread.yield();\n-        signal.countDown();\n-        try {\n-            hndSleep.invoke(sleepArg);\n-        } catch (Throwable t) {\n-            throw new RuntimeException(t);\n-        }\n-    }\n-\n-    public static void main(String[] args) {\n-        try {\n-            Thread.ofVirtual()\n-                  .name(THREAD_NAME)\n-                  .start(new LingeredAppWithVirtualThread());\n-\n-            signal.await();\n-            LingeredApp.main(args);\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/LingeredAppWithVirtualThread.java","additions":0,"deletions":87,"binary":false,"changes":87,"status":"deleted"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2025, NTT DATA\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-import jdk.test.lib.JDKToolLauncher;\n-import jdk.test.lib.SA.SATestUtils;\n-import jdk.test.lib.Utils;\n-import jdk.test.lib.apps.LingeredApp;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-\/**\n- * @test\n- * @bug 8369505\n- * @requires vm.hasSA\n- * @library \/test\/lib\n- * @run driver TestJhsdbJstackWithVirtualThread\n- *\/\n-public class TestJhsdbJstackWithVirtualThread {\n-\n-    private static void runJstack(LingeredApp app) throws Exception {\n-        JDKToolLauncher launcher = JDKToolLauncher.createUsingTestJDK(\"jhsdb\");\n-        launcher.addVMArgs(Utils.getFilteredTestJavaOpts(\"-showversion\"));\n-        launcher.addToolArg(\"jstack\");\n-        launcher.addToolArg(\"--pid\");\n-        launcher.addToolArg(Long.toString(app.getPid()));\n-\n-        ProcessBuilder pb = SATestUtils.createProcessBuilder(launcher);\n-        Process jhsdb = pb.start();\n-        OutputAnalyzer out = new OutputAnalyzer(jhsdb);\n-\n-        jhsdb.waitFor();\n-\n-        System.out.println(out.getStdout());\n-        System.err.println(out.getStderr());\n-\n-        out.stderrShouldBeEmptyIgnoreDeprecatedWarnings();\n-        out.shouldNotContain(\"must have non-zero frame size\");\n-    }\n-\n-    public static void main(String... args) throws Exception {\n-        SATestUtils.skipIfCannotAttach(); \/\/ throws SkippedException if attach not expected to work.\n-        LingeredApp app = null;\n-\n-        try {\n-            app = new LingeredAppWithVirtualThread();\n-            LingeredApp.startApp(app);\n-            System.out.println(\"Started LingeredApp with pid \" + app.getPid());\n-            runJstack(app);\n-            System.out.println(\"Test Completed\");\n-        } catch (Throwable e) {\n-            e.printStackTrace();\n-            throw e;\n-        } finally {\n-            LingeredApp.stopApp(app);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestJhsdbJstackWithVirtualThread.java","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -394,1 +394,1 @@\n-        Asserts.assertThrows(EmptyGeneratorException.class, () -> G.uniformDoubles(0, 0));\n+        Asserts.assertNotNull(G.uniformDoubles(0, 0));\n@@ -400,1 +400,1 @@\n-        Asserts.assertThrows(EmptyGeneratorException.class, () -> G.uniformFloats(0, 0));\n+        Asserts.assertNotNull(G.uniformFloats(0, 0));\n@@ -595,7 +595,2 @@\n-            float lo = 1, hi = 0;\n-            \/\/ Failure of a single round is very rare, repeated failure even rarer.\n-            while (lo >= hi) {\n-                float a = floatBoundGen.next(), b = floatBoundGen.next();\n-                lo = Math.min(a, b);\n-                hi = Math.max(a, b);\n-            }\n+            float a = floatBoundGen.next(), b = floatBoundGen.next();\n+            float lo = Math.min(a, b), hi = Math.max(a, b);\n@@ -612,7 +607,2 @@\n-            double lo = 1, hi = 0;\n-            \/\/ Failure of a single round is very rare, repeated failure even rarer.\n-            while (lo >= hi) {\n-                double a = doubleBoundGen.next(), b = doubleBoundGen.next();\n-                lo = Math.min(a, b);\n-                hi = Math.max(a, b);\n-            }\n+            double a = doubleBoundGen.next(), b = doubleBoundGen.next();\n+            double lo = Math.min(a, b), hi = Math.max(a, b);\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/generators\/tests\/TestGenerators.java","additions":6,"deletions":16,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -26,7 +26,1 @@\n-import java.io.ByteArrayOutputStream;\n-import java.io.PrintStream;\n-import java.lang.reflect.Field;\n-import java.util.*;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-import java.util.stream.Collectors;\n+import java.util.Set;\n@@ -35,1 +29,0 @@\n-import compiler.lib.ir_framework.shared.TestFormatException;\n@@ -37,0 +30,1 @@\n+import compiler.lib.ir_framework.shared.TestFormatException;\n@@ -41,1 +35,0 @@\n- * @bug 8365262 8369232\n@@ -49,0 +42,5 @@\n+    static void hasNFailures(String s, int count) {\n+        if (!s.matches(\"The following scenarios have failed: (#[0-9](, )?){\" + count + \"}. Please check stderr for more information.\")) {\n+            throw new RuntimeException(\"Expected \" + count + \" failures in \\\"\" + s + \"\\\"\");\n+        }\n+    }\n@@ -51,3 +49,11 @@\n-        expectFormatFailure((Set<String>[]) null);\n-        expectFormatFailure(Set.of(\"foo\", \"bar\"), null);\n-\n+        \/\/ Test argument handling\n+        try {\n+            TestFramework t = new TestFramework();\n+            t.addCrossProductScenarios((Set<String>[]) null);\n+            Asserts.fail(\"Should have thrown exception\");\n+        } catch (TestFormatException e) {}\n+        try {\n+            TestFramework t = new TestFramework();\n+            t.addCrossProductScenarios(Set.of(\"foo\", \"bar\"), null);\n+            Asserts.fail(\"Should have thrown exception\");\n+        } catch (TestFormatException e) {}\n@@ -57,6 +63,2 @@\n-            shouldHaveThrown();\n-        } catch (NullPointerException _) {\n-            \/\/ Expected: Set.of prevents null elements\n-        }\n-\n-\n+            Asserts.fail(\"Should have thrown exception\");\n+        } catch (NullPointerException e) {} \/\/ Set.of prevents null elements\n@@ -71,102 +73,0 @@\n-        new TestCase()\n-                .inputFlags(Set.of(\n-                                    Set.of(\"-XX:TLABRefillWasteFraction=51\",\n-                                           \"-XX:TLABRefillWasteFraction=53\",\n-                                           \"-XX:TLABRefillWasteFraction=64\")\n-                            )\n-                )\n-                .expectedScenariosWithFlags(Set.of(\n-                        Set.of(\"-XX:TLABRefillWasteFraction=51\"),\n-                        Set.of(\"-XX:TLABRefillWasteFraction=53\"),\n-                        Set.of(\"-XX:TLABRefillWasteFraction=64\")\n-                ))\n-                .run();\n-\n-        \/\/ The cross product of a set with one element and a set with three elements is three sets.\n-        new TestCase()\n-                .inputFlags(Set.of(\n-                                    Set.of(\"-XX:TLABRefillWasteFraction=53\"),\n-                                    Set.of(\"-XX:+UseNewCode\", \"-XX:+UseNewCode2\", \"-XX:+UseNewCode3\")\n-                            )\n-                )\n-                .expectedScenariosWithFlags(Set.of(\n-                        Set.of(\"-XX:TLABRefillWasteFraction=53\", \"-XX:+UseNewCode\"),\n-                        Set.of(\"-XX:TLABRefillWasteFraction=53\", \"-XX:+UseNewCode2\"),\n-                        Set.of(\"-XX:TLABRefillWasteFraction=53\", \"-XX:+UseNewCode3\")\n-                ))\n-                .run();\n-\n-\n-        \/\/ The cross product of two sets with two elements is four sets.\n-        new TestCase()\n-                .inputFlags(Set.of(\n-                                    Set.of(\"-XX:TLABRefillWasteFraction=53\", \"-XX:TLABRefillWasteFraction=64\"),\n-                                    Set.of(\"-XX:+UseNewCode\", \"-XX:-UseNewCode\")\n-                            )\n-                )\n-                .expectedScenariosWithFlags(Set.of(\n-                        Set.of(\"-XX:TLABRefillWasteFraction=53\", \"-XX:+UseNewCode\"),\n-                        Set.of(\"-XX:TLABRefillWasteFraction=53\", \"-XX:-UseNewCode\"),\n-                        Set.of(\"-XX:TLABRefillWasteFraction=64\", \"-XX:+UseNewCode\"),\n-                        Set.of(\"-XX:TLABRefillWasteFraction=64\", \"-XX:-UseNewCode\")\n-                ))\n-                .run();\n-\n-\n-        \/\/ Test with a pair of flags.\n-        new TestCase()\n-                .inputFlags(Set.of(\n-                                    Set.of(\"-XX:TLABRefillWasteFraction=50 -XX:+UseNewCode\", \"-XX:TLABRefillWasteFraction=40\"),\n-                                    Set.of(\"-XX:+UseNewCode2\")\n-                            )\n-                )\n-                .expectedScenariosWithFlags(Set.of(\n-                        Set.of(\"-XX:TLABRefillWasteFraction=50\", \"-XX:+UseNewCode\", \"-XX:+UseNewCode2\"),\n-                        Set.of(\"-XX:TLABRefillWasteFraction=40\", \"-XX:+UseNewCode2\")\n-                ))\n-                .run();\n-\n-        \/\/ Test with an empty string, resulting in 6 scenarios.\n-        new TestCase()\n-                .inputFlags(Set.of(\n-                                    Set.of(\"\", \"-XX:TLABRefillWasteFraction=51\", \"-XX:TLABRefillWasteFraction=53\"),\n-                                    Set.of(\"-XX:+UseNewCode\", \"-XX:+UseNewCode2\")\n-                            )\n-                )\n-                .expectedScenariosWithFlags(Set.of(\n-                        Set.of(\"-XX:+UseNewCode\"),\n-                        Set.of(\"-XX:+UseNewCode2\"),\n-                        Set.of(\"-XX:TLABRefillWasteFraction=51\", \"-XX:+UseNewCode\"),\n-                        Set.of(\"-XX:TLABRefillWasteFraction=51\", \"-XX:+UseNewCode2\"),\n-                        Set.of(\"-XX:TLABRefillWasteFraction=53\", \"-XX:+UseNewCode\"),\n-                        Set.of(\"-XX:TLABRefillWasteFraction=53\", \"-XX:+UseNewCode2\")\n-                ))\n-                .run();\n-\n-        \/\/ Test with 3 input sets which equals to 2x2x2 = 8 scenarios.\n-        new TestCase()\n-                .inputFlags(Set.of(\n-                                    Set.of(\"-XX:TLABRefillWasteFraction=51\",\n-                                           \"-XX:TLABRefillWasteFraction=53\"),\n-                                    Set.of(\"-XX:+UseNewCode\",\n-                                           \"-XX:-UseNewCode\"),\n-                                    Set.of(\"-XX:+UseNewCode2\",\n-                                           \"-XX:-UseNewCode2\")\n-                            )\n-                )\n-                .expectedScenariosWithFlags(Set.of(\n-                        Set.of(\"-XX:TLABRefillWasteFraction=51\", \"-XX:+UseNewCode\", \"-XX:+UseNewCode2\"),\n-                        Set.of(\"-XX:TLABRefillWasteFraction=53\", \"-XX:+UseNewCode\", \"-XX:+UseNewCode2\"),\n-                        Set.of(\"-XX:TLABRefillWasteFraction=51\", \"-XX:-UseNewCode\", \"-XX:+UseNewCode2\"),\n-                        Set.of(\"-XX:TLABRefillWasteFraction=53\", \"-XX:-UseNewCode\", \"-XX:+UseNewCode2\"),\n-                        Set.of(\"-XX:TLABRefillWasteFraction=51\", \"-XX:+UseNewCode\", \"-XX:-UseNewCode2\"),\n-                        Set.of(\"-XX:TLABRefillWasteFraction=53\", \"-XX:+UseNewCode\", \"-XX:-UseNewCode2\"),\n-                        Set.of(\"-XX:TLABRefillWasteFraction=51\", \"-XX:-UseNewCode\", \"-XX:-UseNewCode2\"),\n-                        Set.of(\"-XX:TLABRefillWasteFraction=53\", \"-XX:-UseNewCode\", \"-XX:-UseNewCode2\")\n-                ))\n-                .run();\n-\n-        TestFramework testFramework = new TestFramework();\n-        testFramework.addScenarios(new Scenario(0, \"-XX:TLABRefillWasteFraction=50\", \"-XX:+UseNewCode\"));\n-        testFramework.addCrossProductScenarios(Set.of(\"-XX:TLABRefillWasteFraction=51\", \"-XX:TLABRefillWasteFraction=53\"),\n-                                               Set.of(\"-XX:+UseNewCode\", \"-XX:+UseNewCode2\"));\n@@ -174,4 +74,8 @@\n-            testFramework.addScenarios(new Scenario(4, \"-XX:+UseNewCode3\")); \/\/ fails because index 4 is already used\n-            shouldHaveThrown();\n-        } catch (TestFormatException _) {\n-            \/\/ Expected.\n+            TestFramework t1 = new TestFramework();\n+            t1.addCrossProductScenarios(Set.of(\"-XX:TLABRefillWasteFraction=51\",\n+                                               \"-XX:TLABRefillWasteFraction=53\",\n+                                               \"-XX:TLABRefillWasteFraction=64\"));\n+            t1.start();\n+            Asserts.fail(\"Should have thrown exception\");\n+        } catch (TestRunException e) {\n+            hasNFailures(e.getMessage(), 3);\n@@ -179,1 +83,0 @@\n-        testFramework.addScenarios(new Scenario(5, \"-XX:+UseNewCode3\"));\n@@ -181,16 +84,1 @@\n-        new TestCase()\n-                .expectedScenariosWithFlags(Set.of(\n-                        Set.of(\"-XX:TLABRefillWasteFraction=50\", \"-XX:+UseNewCode\"),\n-                        Set.of(\"-XX:TLABRefillWasteFraction=51\", \"-XX:+UseNewCode\"),\n-                        Set.of(\"-XX:TLABRefillWasteFraction=51\", \"-XX:+UseNewCode2\"),\n-                        Set.of(\"-XX:TLABRefillWasteFraction=53\", \"-XX:+UseNewCode\"),\n-                        Set.of(\"-XX:TLABRefillWasteFraction=53\", \"-XX:+UseNewCode2\"),\n-                        Set.of(\"-XX:+UseNewCode3\")\n-                ))\n-                .runWithPreAddedScenarios(testFramework);\n-\n-        runEndToEndTest();\n-    }\n-\n-    private static void expectFormatFailure(Set<String>... flagSets) {\n-        TestFramework testFramework = new TestFramework();\n+        \/\/ The cross product of a set with one element and a set with three elements is three sets.\n@@ -198,82 +86,7 @@\n-            testFramework.addCrossProductScenarios(flagSets);\n-            shouldHaveThrown();\n-        } catch (TestFormatException _) {\n-            \/\/ Expected.\n-        }\n-    }\n-\n-    private static void shouldHaveThrown() {\n-        Asserts.fail(\"Should have thrown exception\");\n-    }\n-\n-    static class TestCase {\n-        private Set<Set<String>> inputFlags;\n-        private Set<Set<String>> expectedScenariosWithFlags;\n-\n-        public TestCase inputFlags(Set<Set<String>> inputFlags) {\n-            this.inputFlags = inputFlags;\n-            return this;\n-        }\n-\n-        public TestCase expectedScenariosWithFlags(Set<Set<String>> expectedScenariosWithFlags) {\n-            this.expectedScenariosWithFlags = expectedScenariosWithFlags;\n-            return this;\n-        }\n-\n-        public void run() {\n-            TestFramework testFramework = new TestFramework();\n-            testFramework.addCrossProductScenarios(inputFlags.toArray(new Set[0]));\n-            runWithPreAddedScenarios(testFramework);\n-        }\n-\n-        public void runWithPreAddedScenarios(TestFramework testFramework) {\n-            List<Scenario> scenariosFromCrossProduct = getScenarios(testFramework);\n-            assertScenarioCount(expectedScenariosWithFlags.size(), scenariosFromCrossProduct);\n-            assertScenariosWithFlags(scenariosFromCrossProduct, expectedScenariosWithFlags);\n-            assertSameResultWhenManuallyAdding(scenariosFromCrossProduct, expectedScenariosWithFlags);\n-        }\n-\n-        private static void assertScenarioCount(int expectedCount, List<Scenario> scenarios) {\n-            Asserts.assertEQ(expectedCount, scenarios.size(), \"Scenario count is off\");\n-        }\n-\n-        \/**\n-         * Check that the added scenarios to the IR framework with TestFramework.addCrossProductScenarios()\n-         * (i.e. 'scenariosFromCrossProduct') match the expected flag combos (i.e. 'expectedScenariosWithFlags').\n-         *\/\n-        private static void assertScenariosWithFlags(List<Scenario> scenariosFromCrossProduct,\n-                                                     Set<Set<String>> expectedScenariosWithFlags) {\n-            for (Set<String> expectedScenarioFlags : expectedScenariosWithFlags) {\n-                if (scenariosFromCrossProduct.stream()\n-                        .map(Scenario::getFlags)\n-                        .map(Set::copyOf)\n-                        .anyMatch(flags -> flags.equals(expectedScenarioFlags))) {\n-                    continue;\n-                }\n-                System.err.println(\"Scenarios from cross product:\");\n-                for (Scenario s : scenariosFromCrossProduct) {\n-                    System.err.println(Arrays.toString(s.getFlags().toArray()));\n-                }\n-                throw new RuntimeException(\"Could not find a scenario with the provided flags: \" + Arrays.toString(expectedScenarioFlags.toArray()));\n-            }\n-        }\n-\n-        \/**\n-         * Add scenarios for the provided flag sets in 'expectedScenariosWithFlags' by using TestFramework.addScenarios().\n-         * We should end up with the same scenarios as if we added them with TestFramework.addCrossProductScenarios().\n-         * This is verified by this method by comparing the flags of the scenarios, ignoring scenario indices.\n-         *\/\n-        private static void assertSameResultWhenManuallyAdding(List<Scenario> scenariosFromCrossProduct,\n-                                                               Set<Set<String>> expectedScenariosWithFlags) {\n-            List<Scenario> expectedScenarios = getScenariosWithFlags(expectedScenariosWithFlags);\n-            List<Scenario> fetchedScenarios = addScenariosAndFetchFromFramework(expectedScenarios);\n-            assertSameScenarios(scenariosFromCrossProduct, fetchedScenarios);\n-        }\n-\n-        private static List<Scenario> getScenariosWithFlags(Set<Set<String>> expectedScenariosWithFlags) {\n-            List<Scenario> expecedScenarioList = new ArrayList<>();\n-            int index = -1; \/\/ Use some different indices - should not matter what we choose.\n-            for (Set<String> expectedScenarioFlags : expectedScenariosWithFlags) {\n-                expecedScenarioList.add(new Scenario(index--, expectedScenarioFlags.toArray(new String[0])));\n-            }\n-            return expecedScenarioList;\n+            TestFramework t2 = new TestFramework();\n+            t2.addCrossProductScenarios(Set.of(\"-XX:TLABRefillWasteFraction=53\"),\n+                                        Set.of(\"-XX:+UseNewCode\", \"-XX:+UseNewCode2\", \"-XX:+UseNewCode3\"));\n+            t2.start();\n+            Asserts.fail(\"Should have thrown exception\");\n+        } catch (TestRunException e) {\n+            hasNFailures(e.getMessage(), 3);\n@@ -282,4 +95,9 @@\n-        private static List<Scenario> addScenariosAndFetchFromFramework(List<Scenario> expecedScenarioList) {\n-            TestFramework testFramework = new TestFramework();\n-            testFramework.addScenarios(expecedScenarioList.toArray(new Scenario[0]));\n-            return getScenarios(testFramework);\n+        \/\/ The cross product of two sets with two elements is four sets.\n+        try {\n+            TestFramework t3 = new TestFramework();\n+            t3.addCrossProductScenarios(Set.of(\"-XX:TLABRefillWasteFraction=53\", \"-XX:TLABRefillWasteFraction=64\"),\n+                                        Set.of(\"-XX:+UseNewCode\", \"-XX:-UseNewCode\"));\n+            t3.start();\n+            Asserts.fail(\"Should have thrown exception\");\n+        } catch (TestRunException e) {\n+            hasNFailures(e.getMessage(), 4);\n@@ -288,3 +106,9 @@\n-        private static void assertSameScenarios(List<Scenario> scenariosFromCrossProduct,\n-                                                List<Scenario> expectedScenarios) {\n-            assertScenariosWithFlags(scenariosFromCrossProduct, fetchFlags(expectedScenarios));\n+        \/\/ Test with a pair of flags.\n+        try {\n+            TestFramework t4 = new TestFramework();\n+            t4.addCrossProductScenarios(Set.of(\"-XX:TLABRefillWasteFraction=50 -XX:+UseNewCode\", \"-XX:TLABRefillWasteFraction=40\"),\n+                                        Set.of(\"-XX:+UseNewCode2\"));\n+            t4.start();\n+            Asserts.fail(\"Should have thrown exception\");\n+        } catch (TestRunException e) {\n+            hasNFailures(e.getMessage(), 1);\n@@ -293,4 +117,9 @@\n-        private static Set<Set<String>> fetchFlags(List<Scenario> scenarios) {\n-            return scenarios.stream()\n-                    .map(scenario -> new HashSet<>(scenario.getFlags()))\n-                    .collect(Collectors.toSet());\n+        \/\/ Test with an empty string. All 6 scenarios fail because 64 is the default value for TLABRefillWasteFraction.\n+        try {\n+            TestFramework t5 = new TestFramework();\n+            t5.addCrossProductScenarios(Set.of(\"\", \"-XX:TLABRefillWasteFraction=51\", \"-XX:TLABRefillWasteFraction=53\"),\n+                                        Set.of(\"-XX:+UseNewCode\", \"-XX:+UseNewCode2\"));\n+            t5.start();\n+            Asserts.fail(\"Should have thrown exception\");\n+        } catch (TestRunException e) {\n+            hasNFailures(e.getMessage(), 6);\n@@ -298,1 +127,0 @@\n-    }\n@@ -300,2 +128,0 @@\n-    private static List<Scenario> getScenarios(TestFramework testFramework) {\n-        Field field;\n@@ -303,5 +129,13 @@\n-            field = TestFramework.class.getDeclaredField(\"scenarios\");\n-            field.setAccessible(true);\n-            return (List<Scenario>)field.get(testFramework);\n-        } catch (NoSuchFieldException | IllegalAccessException e) {\n-            throw new RuntimeException(e);\n+            TestFramework t6 = new TestFramework();\n+            t6.addScenarios(new Scenario(0, \"-XX:TLABRefillWasteFraction=50\", \"-XX:+UseNewCode\")); \/\/ failPair\n+            t6.addCrossProductScenarios(Set.of(\"-XX:TLABRefillWasteFraction=51\", \"-XX:TLABRefillWasteFraction=53\"),\n+                                        Set.of(\"-XX:+UseNewCode\", \"-XX:+UseNewCode2\"));\n+            try {\n+                t6.addScenarios(new Scenario(4, \"-XX:+UseNewCode3\")); \/\/ fails because index 4 is already used\n+            Asserts.fail(\"Should have thrown exception\");\n+            } catch (TestFormatException e) {}\n+            t6.addScenarios(new Scenario(5, \"-XX:+UseNewCode3\")); \/\/ fail default\n+            t6.start();\n+            Asserts.fail(\"Should have thrown exception\");\n+        } catch (TestRunException e) {\n+            hasNFailures(e.getMessage(), 6);\n@@ -311,12 +145,4 @@\n-    \/**\n-     *  Also run a simple end-to-end test to sanity check the API method. We capture the stderr to fetch the\n-     *  scenario flags.\n-     *\/\n-    private static void runEndToEndTest() {\n-        TestFramework testFramework = new TestFramework();\n-\n-        \/\/ Capture stderr\n-        PrintStream originalErr = System.err;\n-        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n-        PrintStream printStream = new PrintStream(outputStream);\n-        System.setErr(printStream);\n+    @Test\n+    @IR(applyIf = {\"TLABRefillWasteFraction\", \"64\"}, counts = {IRNode.CALL, \"1\"})\n+    public void failDefault() {\n+    }\n@@ -324,18 +150,3 @@\n-        try {\n-            testFramework\n-                    .addCrossProductScenarios(Set.of(\"-XX:+UseNewCode\", \"-XX:-UseNewCode\"),\n-                                              Set.of(\"-XX:+UseNewCode2\", \"-XX:-UseNewCode2\"))\n-                    .addFlags()\n-                    .start();\n-            shouldHaveThrown();\n-        } catch (TestRunException e) {\n-            \/\/ Expected.\n-            System.setErr(originalErr);\n-            Asserts.assertTrue(e.getMessage().contains(\"The following scenarios have failed: #0, #1, #2, #3.\"));\n-            String stdErr = outputStream.toString();\n-            Asserts.assertTrue(stdErr.contains(\"Scenario flags: [-XX:+UseNewCode, -XX:+UseNewCode2]\"));\n-            Asserts.assertTrue(stdErr.contains(\"Scenario flags: [-XX:-UseNewCode, -XX:-UseNewCode2]\"));\n-            Asserts.assertTrue(stdErr.contains(\"Scenario flags: [-XX:+UseNewCode, -XX:-UseNewCode2]\"));\n-            Asserts.assertTrue(stdErr.contains(\"Scenario flags: [-XX:-UseNewCode, -XX:+UseNewCode2]\"));\n-            Asserts.assertEQ(4, scenarioCount(stdErr));\n-        }\n+    @Test\n+    @IR(applyIf = {\"TLABRefillWasteFraction\", \"51\"}, counts = {IRNode.CALL, \"1\"})\n+    public void fail1() {\n@@ -344,8 +155,3 @@\n-    public static int scenarioCount(String stdErr) {\n-        Pattern pattern = Pattern.compile(\"Scenario flags\");\n-        Matcher matcher = pattern.matcher(stdErr);\n-        int count = 0;\n-        while (matcher.find()) {\n-            count++;\n-        }\n-        return count;\n+    @Test\n+    @IR(applyIf = {\"TLABRefillWasteFraction\", \"53\"}, counts = {IRNode.CALL, \"1\"})\n+    public void fail2() {\n@@ -355,2 +161,2 @@\n-    public void endToEndTest() {\n-        throw new RuntimeException(\"executed test\");\n+    @IR(applyIfAnd = {\"TLABRefillWasteFraction\", \"50\", \"UseNewCode\", \"true\"}, counts = {IRNode.CALL, \"1\"})\n+    public void failPair() {\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestScenariosCrossProduct.java","additions":88,"deletions":282,"binary":false,"changes":370,"status":"modified"},{"patch":"@@ -73,7 +73,0 @@\n-            \/\/\n-            \/\/ Some expressions can throw Exceptions. We have to catch them. In such a case, we return\n-            \/\/ the Exception instead of the value from the expression, and compare the Exceptions.\n-            \/\/\n-            \/\/ Some Expressions do not have a deterministic result. For example, different NaN or\n-            \/\/ precision results from some operators. We only compare the results if we know that the\n-            \/\/ result is deterministically the same.\n@@ -86,5 +79,3 @@\n-                    Object v0 = ${primitiveConTest}_compiled();\n-                    Object v1 = ${primitiveConTest}_reference();\n-                \"\"\",\n-                expression.info.isResultDeterministic ? \"Verify.checkEQ(v0, v1);\\n\" : \"\",\n-                \"\"\"\n+                    #returnType v0 = ${primitiveConTest}_compiled();\n+                    #returnType v1 = ${primitiveConTest}_reference();\n+                    Verify.checkEQ(v0, v1);\n@@ -94,2 +85,1 @@\n-                public static Object ${primitiveConTest}_compiled() {\n-                try {\n+                public static #returnType ${primitiveConTest}_compiled() {\n@@ -97,4 +87,1 @@\n-                    \"return \", expressionToken, \";\\n\",\n-                    expression.info.exceptions.stream().map(exception ->\n-                        \"} catch (\" + exception + \" e) { return e;\\n\"\n-                    ).toList(),\n+                \"return \", expressionToken, \";\\n\",\n@@ -102,3 +89,0 @@\n-                    } finally {\n-                        \/\/ Just so that javac is happy if there are no exceptions to catch.\n-                    }\n@@ -108,2 +92,1 @@\n-                public static Object ${primitiveConTest}_reference() {\n-                try {\n+                public static #returnType ${primitiveConTest}_reference() {\n@@ -111,4 +94,1 @@\n-                    \"return \", expressionToken, \";\\n\",\n-                    expression.info.exceptions.stream().map(exception ->\n-                        \"} catch (\" + exception + \" e) { return e;\\n\"\n-                    ).toList(),\n+                \"return \", expressionToken, \";\\n\",\n@@ -116,3 +96,0 @@\n-                    } finally {\n-                        \/\/ Just so that javac is happy if there are no exceptions to catch.\n-                    }\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/examples\/TestExpressions.java","additions":7,"deletions":30,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -29,3 +29,0 @@\n-import java.lang.classfile.ClassFile;\n-import java.lang.classfile.ClassTransform;\n-import java.lang.constant.ClassDesc;\n@@ -48,0 +45,5 @@\n+import org.objectweb.asm.ClassReader;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.ClassWriter;\n+import org.objectweb.asm.Opcodes;\n+\n@@ -262,4 +264,5 @@\n-       var context = ClassFile.of();\n-       return context.transformClass(context.parse(classToMorph),\n-               ClassDesc.ofInternalName(newName),\n-               ClassTransform.ACCEPT_ALL);\n+       ClassReader cr = new ClassReader(classToMorph);\n+       ClassWriter cw = new ClassWriter(cr, ClassWriter.COMPUTE_MAXS);\n+       ClassVisitor cv = new ClassRenamer(cw, newName);\n+       cr.accept(cv, 0);\n+       return cw.toByteArray();\n@@ -267,0 +270,18 @@\n+\n+    \/**\n+     * Visitor to rename class.\n+     *\/\n+    static class ClassRenamer extends ClassVisitor implements Opcodes {\n+        private final String newName;\n+\n+        public ClassRenamer(ClassVisitor cv, String newName) {\n+            super(ASM4, cv);\n+            this.newName = newName;\n+        }\n+\n+        @Override\n+        public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n+            cv.visit(version, access, newName, signature, superName, interfaces);\n+        }\n+\n+    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/GenClassPoolJar.java","additions":28,"deletions":7,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @library \/testlibrary\/asm\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_rootClass_inMemoryCompilation_keep_cl\/TestDescription.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @library \/testlibrary\/asm\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_rootClass_inMemoryCompilation_keep_class\/TestDescription.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @library \/testlibrary\/asm\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_rootClass_inMemoryCompilation_keep_obj\/TestDescription.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @library \/testlibrary\/asm\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_rootClass_keep_cl\/TestDescription.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @library \/testlibrary\/asm\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_rootClass_keep_class\/TestDescription.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @library \/testlibrary\/asm\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_rootClass_keep_obj\/TestDescription.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+ * @requires vm.gc != \"Serial\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/vector\/CircularListLow\/TestDescription.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+ * @requires vm.gc != \"Serial\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/vector\/LinearListLow\/TestDescription.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -139,9 +139,0 @@\n-        } catch (InvocationTargetException ite) {\n-            Throwable cause = ite.getCause();\n-            if (cause != null && (cause instanceof OutOfMemoryError) && cause.getMessage().contains(\"Metaspace\")) {\n-                \/\/ avoid string concatenation, which may create more classes.\n-                System.out.println(\"Got OOME in metaspace in PerformChecksHelper.callMethods(Class clazz). \");\n-                System.out.println(\"This is possible with -triggerUnloadingByFillingMetaspace\");\n-            } else {\n-                throw ite;\n-            }\n@@ -149,1 +140,1 @@\n-            if (e.getMessage().contains(\"Metaspace\")) {\n+            if (e.getMessage().trim().toLowerCase().contains(\"metaspace\")) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/common\/PerformChecksHelper.java","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import java.lang.classfile.ClassFile;\n-import java.lang.classfile.ClassModel;\n-import java.lang.classfile.FieldModel;\n@@ -34,0 +31,5 @@\n+import org.objectweb.asm.ClassReader;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.FieldVisitor;\n+import org.objectweb.asm.Opcodes;\n+\n@@ -80,1 +82,2 @@\n-        List<String> fields = getFields(cls);\n+        FieldExplorer explorer = new FieldExplorer(cls);\n+        List<String> fields = explorer.get();\n@@ -84,5 +87,23 @@\n-    private static InputStream getClassBytes(Class<?> cls) throws Exception {\n-        String clsName = cls.getName();\n-        String clsPath = clsName.replace('.', '\/') + \".class\";\n-        return cls.getClassLoader().getResourceAsStream(clsPath);\n-    }\n+    \/\/ helper class to get list of the class fields\n+    \/\/ in the order they appear in the class file\n+    static class FieldExplorer extends ClassVisitor {\n+        private final Class cls;\n+        private List<String> fieldNameAndSig = new ArrayList<>();\n+        private FieldExplorer(Class cls) {\n+            super(Opcodes.ASM7);\n+            this.cls = cls;\n+        }\n+\n+        @Override\n+        public FieldVisitor visitField(int access, String name, String descriptor, String signature, Object value) {\n+            System.out.println(\"  field '\" + name + \"', type = \" + descriptor);\n+            fieldNameAndSig.add(name);\n+            fieldNameAndSig.add(descriptor);\n+            return super.visitField(access, name, descriptor, signature, value);\n+        }\n+\n+        private InputStream getClassBytes() throws Exception {\n+            String clsName = cls.getName();\n+            String clsPath = clsName.replace('.', '\/') + \".class\";\n+            return cls.getClassLoader().getResourceAsStream(clsPath);\n+        }\n@@ -90,10 +111,6 @@\n-    \/\/ get list of the class fields in the order they appear in the class file\n-    \/\/ each field is represented by 2 Strings in the list: name and type descriptor\n-    public static List<String> getFields(Class<?> cls) throws Exception {\n-        System.out.println(\"Class \" + cls.getName());\n-        List<String> fieldNameAndSig = new ArrayList<>();\n-        try (InputStream classBytes = getClassBytes(cls)) {\n-            ClassModel classModel = ClassFile.of().parse(classBytes.readAllBytes());\n-            for (FieldModel field : classModel.fields()) {\n-                fieldNameAndSig.add(field.fieldName().stringValue());\n-                fieldNameAndSig.add(field.fieldType().stringValue());\n+        \/\/ each field is represented by 2 Strings in the list: name and type descriptor\n+        public List<String> get() throws Exception {\n+            System.out.println(\"Class \" + cls.getName());\n+            try (InputStream classBytes = getClassBytes()) {\n+                ClassReader classReader = new ClassReader(classBytes);\n+                classReader.accept(this, 0);\n@@ -101,0 +118,1 @@\n+            return fieldNameAndSig;\n@@ -102,1 +120,0 @@\n-        return fieldNameAndSig;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetClassFields\/getclfld007.java","additions":37,"deletions":20,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,1 +74,0 @@\n- * @requires test.thread.factory == null\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetCurrentThreadCpuTime\/curthrcputime001\/TestDescription.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,1 +74,0 @@\n- * @requires test.thread.factory == null\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadCpuTime\/thrcputime001\/TestDescription.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,2 +126,0 @@\n-    \/\/ The thread name prefix is used to find thread from jvmti agent.\n-    final static String threadNamePrefix = \"Debuggee Thread\";\n@@ -135,1 +133,1 @@\n-        super(threadNamePrefix + \" \" + o1 + o2);\n+        super(\"Debuggee Thread \" + o1 + o2);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/contention\/TC03\/tc03t001.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,2 +44,2 @@\n-static threadDesc *debuggee_threads = nullptr;\n-static jint debuggee_threads_cnt = 0;\n+static threadDesc *threadList = nullptr;\n+static jint threads_count = 0;\n@@ -48,3 +48,0 @@\n-static const char* THREAD_NAME_PREFIX = \"Debugee Thread\";\n-static const size_t THREAD_NAME_PREFIX_LEN = strlen(THREAD_NAME_PREFIX);\n-\n@@ -62,1 +59,1 @@\n-        NSK_DISPLAY1(\" \\\"%s\\\":\\n\", debuggee_threads[pThread].name);\n+        NSK_DISPLAY1(\" \\\"%s\\\":\\n\", threadList[pThread].name);\n@@ -64,1 +61,1 @@\n-                jvmti->GetCurrentContendedMonitor(debuggee_threads[pThread].thread, &monitor)))\n+                jvmti->GetCurrentContendedMonitor(threadList[pThread].thread, &monitor)))\n@@ -80,2 +77,2 @@\n-        for (cThread = 0; cThread < debuggee_threads_cnt; cThread++) {\n-            if (jni->IsSameObject(debuggee_threads[cThread].thread, usageInfo.owner))\n+        for (cThread = 0; cThread < threads_count; cThread++) {\n+            if (jni->IsSameObject(threadList[cThread].thread, usageInfo.owner))\n@@ -90,1 +87,1 @@\n-        if (!NSK_VERIFY(cThread != debuggee_threads_cnt))\n+        if (!NSK_VERIFY(cThread != threads_count))\n@@ -93,1 +90,1 @@\n-            debuggee_threads[cThread].name);\n+            threadList[cThread].name);\n@@ -109,1 +106,0 @@\n-    int threads_count = 0;\n@@ -111,1 +107,1 @@\n-    NSK_DISPLAY0(\"Create debuggee_threads\\n\");\n+    NSK_DISPLAY0(\"Create threadList\\n\");\n@@ -121,1 +117,1 @@\n-            jvmti->Allocate(threads_count*sizeof(threadDesc), (unsigned char**)&debuggee_threads)))\n+            jvmti->Allocate(threads_count*sizeof(threadDesc), (unsigned char**)&threadList)))\n@@ -134,11 +130,3 @@\n-        if (!strncmp(info.name, THREAD_NAME_PREFIX, THREAD_NAME_PREFIX_LEN)) {\n-            NSK_DISPLAY1(\"Skipping thread %s\\n\", info.name);\n-            if (!NSK_JVMTI_VERIFY(jvmti->Deallocate((unsigned char*)info.name)))\n-                return NSK_FALSE;\n-            continue;\n-        }\n-\n-        debuggee_threads[debuggee_threads_cnt].thread = threads[i];\n-        debuggee_threads[debuggee_threads_cnt].dfn = -1;\n-        debuggee_threads[debuggee_threads_cnt].name = info.name;\n-        debuggee_threads_cnt++;\n+        threadList[i].thread = threads[i];\n+        threadList[i].dfn = -1;\n+        threadList[i].name = info.name;\n@@ -151,2 +139,2 @@\n-    for (i = 0; i < debuggee_threads_cnt; i++) {\n-        if (debuggee_threads[i].dfn < 0) {\n+    for (i = 0; i < threads_count; i++) {\n+        if (threadList[i].dfn < 0) {\n@@ -154,1 +142,1 @@\n-            debuggee_threads[i].dfn = gDfn++;\n+            threadList[i].dfn = gDfn++;\n@@ -157,1 +145,1 @@\n-                        jvmti->GetCurrentContendedMonitor(debuggee_threads[pThread].thread, &monitor)))\n+                        jvmti->GetCurrentContendedMonitor(threadList[pThread].thread, &monitor)))\n@@ -165,2 +153,2 @@\n-                for (cThread = 0; cThread < debuggee_threads_cnt; cThread++) {\n-                    if (jni->IsSameObject(debuggee_threads[cThread].thread, usageInfo.owner))\n+                for (cThread = 0; cThread < threads_count; cThread++) {\n+                    if (jni->IsSameObject(threadList[cThread].thread, usageInfo.owner))\n@@ -175,1 +163,1 @@\n-                if (!NSK_VERIFY(cThread != debuggee_threads_cnt))\n+                if (!NSK_VERIFY(cThread != threads_count))\n@@ -177,2 +165,2 @@\n-                if (debuggee_threads[cThread].dfn < 0) {\n-                    debuggee_threads[cThread].dfn = gDfn++;\n+                if (threadList[cThread].dfn < 0) {\n+                    threadList[cThread].dfn = gDfn++;\n@@ -194,3 +182,3 @@\n-    for (i = 0; i < debuggee_threads_cnt; i++) {\n-        if (debuggee_threads[i].name != nullptr) {\n-            if (!NSK_JVMTI_VERIFY(jvmti->Deallocate((unsigned char*)debuggee_threads[i].name)))\n+    for (i = 0; i < threads_count; i++) {\n+        if (threadList[i].name != nullptr) {\n+            if (!NSK_JVMTI_VERIFY(jvmti->Deallocate((unsigned char*)threadList[i].name)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/contention\/TC03\/tc03t001\/tc03t001.cpp","additions":26,"deletions":38,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -107,2 +107,1 @@\n-    \/\/ The thread name prefix is used to find thread from jvmti agent.\n-    final static String threadNamePrefix = \"Debuggee Thread\";\n+\n@@ -116,1 +115,1 @@\n-        super(threadNamePrefix + \" \" + o1 + o2);\n+        super(\"Debuggee Thread \" + o1 + o2);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/contention\/TC03\/tc03t002.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,2 +44,2 @@\n-static threadDesc *debuggee_threads = nullptr;\n-static jint debuggee_threads_cnt = 0;\n+static threadDesc *threadList = nullptr;\n+static jint threads_count = 0;\n@@ -48,3 +48,0 @@\n-static const char* THREAD_NAME_PREFIX = \"Debugee Thread\";\n-static const size_t THREAD_NAME_PREFIX_LEN = strlen(THREAD_NAME_PREFIX);\n-\n@@ -62,1 +59,1 @@\n-        NSK_DISPLAY1(\" \\\"%s\\\":\\n\", debuggee_threads[pThread].name);\n+        NSK_DISPLAY1(\" \\\"%s\\\":\\n\", threadList[pThread].name);\n@@ -64,1 +61,1 @@\n-                jvmti->GetCurrentContendedMonitor(debuggee_threads[pThread].thread, &monitor)))\n+                jvmti->GetCurrentContendedMonitor(threadList[pThread].thread, &monitor)))\n@@ -80,2 +77,2 @@\n-        for (cThread = 0; cThread < debuggee_threads_cnt; cThread++) {\n-            if (jni->IsSameObject(debuggee_threads[cThread].thread, usageInfo.owner))\n+        for (cThread = 0; cThread < threads_count; cThread++) {\n+            if (jni->IsSameObject(threadList[cThread].thread, usageInfo.owner))\n@@ -90,1 +87,1 @@\n-        if (!NSK_VERIFY(cThread != debuggee_threads_cnt))\n+        if (!NSK_VERIFY(cThread != threads_count))\n@@ -93,1 +90,1 @@\n-            debuggee_threads[cThread].name);\n+            threadList[cThread].name);\n@@ -109,1 +106,0 @@\n-    int threads_count = 0;\n@@ -111,1 +107,1 @@\n-    NSK_DISPLAY0(\"Create debuggee_threads\\n\");\n+    NSK_DISPLAY0(\"Create threadList\\n\");\n@@ -121,1 +117,1 @@\n-            jvmti->Allocate(threads_count*sizeof(threadDesc), (unsigned char**)&debuggee_threads)))\n+            jvmti->Allocate(threads_count*sizeof(threadDesc), (unsigned char**)&threadList)))\n@@ -134,11 +130,3 @@\n-        if (!strncmp(info.name, THREAD_NAME_PREFIX, THREAD_NAME_PREFIX_LEN)) {\n-            NSK_DISPLAY1(\"Skipping thread %s\\n\", info.name);\n-            if (!NSK_JVMTI_VERIFY(jvmti->Deallocate((unsigned char*)info.name)))\n-                return NSK_FALSE;\n-            continue;\n-        }\n-\n-        debuggee_threads[debuggee_threads_cnt].thread = threads[i];\n-        debuggee_threads[debuggee_threads_cnt].dfn = -1;\n-        debuggee_threads[debuggee_threads_cnt].name = info.name;\n-        debuggee_threads_cnt++;\n+        threadList[i].thread = threads[i];\n+        threadList[i].dfn = -1;\n+        threadList[i].name = info.name;\n@@ -151,3 +139,2 @@\n-    for (i = 0; i < debuggee_threads_cnt; i++) {\n-\n-        if (debuggee_threads[i].dfn < 0) {\n+    for (i = 0; i < threads_count; i++) {\n+        if (threadList[i].dfn < 0) {\n@@ -155,1 +142,1 @@\n-            debuggee_threads[i].dfn = gDfn++;\n+            threadList[i].dfn = gDfn++;\n@@ -158,1 +145,1 @@\n-                        jvmti->GetCurrentContendedMonitor(debuggee_threads[pThread].thread, &monitor)))\n+                        jvmti->GetCurrentContendedMonitor(threadList[pThread].thread, &monitor)))\n@@ -166,2 +153,2 @@\n-                for (cThread = 0; cThread < debuggee_threads_cnt; cThread++) {\n-                    if (jni->IsSameObject(debuggee_threads[cThread].thread, usageInfo.owner))\n+                for (cThread = 0; cThread < threads_count; cThread++) {\n+                    if (jni->IsSameObject(threadList[cThread].thread, usageInfo.owner))\n@@ -176,1 +163,1 @@\n-                if (!NSK_VERIFY(cThread != debuggee_threads_cnt))\n+                if (!NSK_VERIFY(cThread != threads_count))\n@@ -178,2 +165,2 @@\n-                if (debuggee_threads[cThread].dfn < 0) {\n-                    debuggee_threads[cThread].dfn = gDfn++;\n+                if (threadList[cThread].dfn < 0) {\n+                    threadList[cThread].dfn = gDfn++;\n@@ -195,3 +182,3 @@\n-    for (i = 0; i < debuggee_threads_cnt; i++) {\n-        if (debuggee_threads[i].name != nullptr) {\n-            if (!NSK_JVMTI_VERIFY(jvmti->Deallocate((unsigned char*)debuggee_threads[i].name)))\n+    for (i = 0; i < threads_count; i++) {\n+        if (threadList[i].name != nullptr) {\n+            if (!NSK_JVMTI_VERIFY(jvmti->Deallocate((unsigned char*)threadList[i].name)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/contention\/TC03\/tc03t002\/tc03t002.cpp","additions":26,"deletions":39,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-import java.lang.ref.PhantomReference;\n+import java.lang.ref.Cleaner;\n@@ -80,1 +80,1 @@\n-     * Phantom reference to the class loader.\n+     * Whole amount of time in milliseconds to wait for class loader to be reclaimed.\n@@ -82,1 +82,11 @@\n-    private PhantomReference<Object> customClassLoaderPhantomRef = null;\n+    private static final int WAIT_TIMEOUT = 15000;\n+\n+    \/**\n+     * Sleep time in milliseconds for the loop waiting for the class loader to be reclaimed.\n+     *\/\n+    private static final int WAIT_DELTA = 1000;\n+\n+    \/**\n+     * Has class loader been reclaimed or not.\n+     *\/\n+    volatile boolean is_reclaimed = false;\n@@ -94,8 +104,0 @@\n-    \/**\n-     * Has class loader been reclaimed or not.\n-     *\/\n-    private boolean isClassLoaderReclaimed() {\n-        return customClassLoaderPhantomRef != null\n-            && customClassLoaderPhantomRef.refersTo(null);\n-    }\n-\n@@ -139,1 +141,2 @@\n-        customClassLoaderPhantomRef = new PhantomReference<>(customClassLoader, null);\n+        \/\/ Register a Cleaner to inform us when the class loader has been reclaimed.\n+        Cleaner.create().register(customClassLoader, () -> { is_reclaimed = true; } );\n@@ -154,1 +157,2 @@\n-        customClassLoaderPhantomRef = new PhantomReference<>(customClassLoader, null);\n+        \/\/ Register a Cleaner to inform us when the class loader has been reclaimed.\n+        Cleaner.create().register(customClassLoader, () -> { is_reclaimed = true; } );\n@@ -243,0 +247,2 @@\n+        is_reclaimed = false;\n+\n@@ -244,0 +250,1 @@\n+        long waitTimeout = (customClassLoader == null) ? 0 : WAIT_TIMEOUT;\n@@ -250,0 +257,14 @@\n+        \/\/ give GC chance to run and wait for receiving reclaim notification\n+        long timeToFinish = System.currentTimeMillis() + waitTimeout;\n+        while (!is_reclaimed && System.currentTimeMillis() < timeToFinish) {\n+            if (!stresser.continueExecution()) {\n+                return false;\n+            }\n+            try {\n+                \/\/ suspend thread for a while\n+                Thread.sleep(WAIT_DELTA);\n+            } catch (InterruptedException e) {\n+                throw new Failure(\"Unexpected InterruptedException while class unloading: \" + e);\n+            }\n+        }\n+\n@@ -251,1 +272,1 @@\n-        if (isClassLoaderReclaimed()) {\n+        if (is_reclaimed) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/ClassUnloader.java","additions":36,"deletions":15,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -152,0 +152,2 @@\n+    public static final int MAX_UNLOAD_ATTEMPS = 5;\n+\n@@ -155,0 +157,2 @@\n+        int unloadAttemps = 0;\n+\n@@ -156,1 +160,5 @@\n-            boolean wasUnloaded = classUnloader.unloadClass();\n+            boolean wasUnloaded = false;\n+\n+            while (!wasUnloaded && (unloadAttemps++ < MAX_UNLOAD_ATTEMPS)) {\n+                wasUnloaded = classUnloader.unloadClass();\n+            }\n@@ -178,0 +186,7 @@\n+    static public void sleep1sec() {\n+        try {\n+            Thread.sleep(1000);\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n@@ -350,0 +365,3 @@\n+    public void voidValueMethod() {\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/AbstractDebuggeeTest.java","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n- * @run main\/othervm\/timeout=480\n+ * @run main\/othervm\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/compact\/Humongous_NonbranchyTree5M\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+javax\/management\/remote\/mandatory\/loading\/MissingClassTest.java 8145413 windows-x64\n+\n@@ -41,0 +43,21 @@\n+##########\n+## Tests incompatible with virtual test thread factory.\n+## There is no goal to run all test with virtual test thread factory.\n+## So any test might be added as incompatible, the bug id is not required.\n+\n+# Incorrect stack\/threadgroup\/exception expectations for main thread\n+java\/lang\/StackWalker\/DumpStackTest.java 0000000 generic-all\n+java\/lang\/StackWalker\/StackWalkTest.java 0000000 generic-all\n+java\/lang\/StackWalker\/CallerFromMain.java 0000000 generic-all\n+java\/lang\/Thread\/MainThreadTest.java 0000000 generic-all\n+java\/lang\/Thread\/UncaughtExceptionsTest.java 0000000 generic-all\n+java\/lang\/invoke\/condy\/CondyNestedResolutionTest.java 0000000 generic-all\n+java\/lang\/ref\/OOMEInReferenceHandler.java 0000000 generic-all\n+java\/util\/concurrent\/locks\/Lock\/OOMEInAQS.java 0000000 generic-all\n+jdk\/internal\/vm\/Continuation\/Scoped.java 0000000 generic-all\n+\n+# The problems with permissions\n+jdk\/jfr\/startupargs\/TestDumpOnExit.java 0000000 generic-all\n+java\/util\/Properties\/StoreReproducibilityTest.java 0000000 generic-all\n+javax\/management\/ImplementationVersion\/ImplVersionTest.java 0000000 generic-all\n+javax\/management\/remote\/mandatory\/version\/ImplVersionTest.java 0000000 generic-all\n","filename":"test\/jdk\/ProblemList-Virtual.txt","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -590,1 +590,0 @@\n-java\/nio\/channels\/AsyncCloseAndInterrupt.java                   8368290 macosx-26.0.1\n@@ -680,0 +679,1 @@\n+javax\/swing\/JTabbedPane\/4624207\/bug4624207.java 8064922 macosx-all\n@@ -753,1 +753,0 @@\n-jdk\/jfr\/jvm\/TestWaste.java                                      8369949 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,193 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.awt.BorderLayout;\n-import java.awt.Color;\n-import java.awt.event.InputEvent;\n-import java.awt.event.KeyEvent;\n-\n-import javax.swing.Box;\n-import javax.swing.JFrame;\n-import javax.swing.JLabel;\n-import javax.swing.JMenu;\n-import javax.swing.JMenuBar;\n-import javax.swing.JMenuItem;\n-import javax.swing.JPanel;\n-import javax.swing.KeyStroke;\n-import javax.swing.UIManager;\n-\n-import static javax.swing.BorderFactory.createEmptyBorder;\n-\n-\/*\n- * @test id=windows\n- * @bug 8348760 8365375 8365389 8365625\n- * @requires (os.family == \"windows\")\n- * @summary Verify that Windows Look & Feel allows changing\n- *          accelerator colors\n- * @library \/java\/awt\/regtesthelpers\n- * @build PassFailJFrame\n- * @run main\/manual MenuItemAcceleratorColor\n- *\/\n-\n-\/*\n- * @test id=classic\n- * @bug 8348760 8365375 8365389 8365625\n- * @requires (os.family == \"windows\")\n- * @summary Verify that Windows Classic Look & Feel allows changing\n- *          accelerator colors\n- * @library \/java\/awt\/regtesthelpers\n- * @build PassFailJFrame\n- * @run main\/manual MenuItemAcceleratorColor classic\n- *\/\n-public final class MenuItemAcceleratorColor {\n-    private static final String INSTRUCTIONS =\n-            \"Click the Menu to open it.\\n\" +\n-            \"\\n\" +\n-            \"Verify that the first and the last menu items render \" +\n-            \"their accelerators using the default colors, the color \" +\n-            \"should match that of the menu item itself in regular and \" +\n-            \"selected states.\\n\" +\n-            \"\\n\" +\n-            \"Verify that the second menu item renders its accelerator \" +\n-            \"with green and that the color changes to red when selected.\\n\" +\n-            \"\\n\" +\n-            \"Verify that the third menu item renders its accelerator \" +\n-            \"with magenta and yellow correspondingly.\\n\" +\n-            \"\\n\" +\n-            \"Verify that only the fifth menu item renders its accelerator \" +\n-            \"with blue; both the fourth and sixth should render their \" +\n-            \"accelerator with a shade of gray.\\n\" +\n-            \"\\n\" +\n-            \"If the above conditions are satisfied, press the Pass button; \" +\n-            \"otherwise, press the Fail button.\";\n-\n-    public static void main(String[] args) throws Exception {\n-        UIManager.setLookAndFeel((args.length > 0 && \"classic\".equals(args[0]))\n-                                 ? \"com.sun.java.swing.plaf.windows.WindowsClassicLookAndFeel\"\n-                                 : \"com.sun.java.swing.plaf.windows.WindowsLookAndFeel\");\n-\n-        PassFailJFrame.builder()\n-                      .instructions(INSTRUCTIONS)\n-                      .rows(20)\n-                      .columns(60)\n-                      .testUI(MenuItemAcceleratorColor::createUI)\n-                      .build()\n-                      .awaitAndCheck();\n-    }\n-\n-    private static Box createInfoPanel() {\n-        Box box = Box.createVerticalBox();\n-        box.add(new JLabel(\"Look and Feel: \"\n-                           + UIManager.getLookAndFeel()\n-                                      .getName()));\n-        box.add(new JLabel(\"Java version: \"\n-                           + System.getProperty(\"java.runtime.version\")));\n-        return box;\n-    }\n-\n-    private static JFrame createUI() {\n-        JPanel content = new JPanel(new BorderLayout());\n-        content.setBorder(createEmptyBorder(8, 8, 8, 8));\n-        content.add(createInfoPanel(),\n-                    BorderLayout.SOUTH);\n-\n-        JFrame frame = new JFrame(\"Accelerator colors in Windows L&F\");\n-        frame.setJMenuBar(createMenuBar());\n-        frame.add(content, BorderLayout.CENTER);\n-        frame.setSize(350, 370);\n-        return frame;\n-    }\n-\n-    private static JMenuBar createMenuBar() {\n-        JMenuItem first = new JMenuItem(\"First menu item\");\n-        first.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F,\n-                                                    InputEvent.CTRL_DOWN_MASK));\n-\n-        \/\/ Modify colors for accelerator rendering\n-        Color acceleratorForeground = UIManager.getColor(\"MenuItem.acceleratorForeground\");\n-        Color acceleratorSelectionForeground = UIManager.getColor(\"MenuItem.acceleratorSelectionForeground\");\n-        UIManager.put(\"MenuItem.acceleratorForeground\", Color.GREEN);\n-        UIManager.put(\"MenuItem.acceleratorSelectionForeground\", Color.RED);\n-\n-        JMenuItem second = new JMenuItem(\"Second menu item\");\n-        second.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_S,\n-                                                     InputEvent.SHIFT_DOWN_MASK\n-                                                     | InputEvent.CTRL_DOWN_MASK));\n-\n-        UIManager.put(\"MenuItem.acceleratorForeground\", Color.MAGENTA);\n-        UIManager.put(\"MenuItem.acceleratorSelectionForeground\", Color.YELLOW);\n-        JMenuItem third = new JMenuItem(\"Third menu item\");\n-        third.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_T,\n-                                                    InputEvent.ALT_DOWN_MASK));\n-\n-        \/\/ Restore colors\n-        UIManager.put(\"MenuItem.acceleratorForeground\", acceleratorForeground);\n-        UIManager.put(\"MenuItem.acceleratorSelectionForeground\", acceleratorSelectionForeground);\n-\n-\n-        \/\/ Disabled foreground\n-        JMenuItem fourth = new JMenuItem(\"Fourth menu item\");\n-        fourth.setEnabled(false);\n-        fourth.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F,\n-                                                     InputEvent.CTRL_DOWN_MASK));\n-\n-        Color disabledForeground = UIManager.getColor(\"MenuItem.disabledForeground\");\n-        UIManager.put(\"MenuItem.disabledForeground\", Color.BLUE);\n-\n-        JMenuItem fifth = new JMenuItem(\"Fifth menu item\");\n-        fifth.setEnabled(false);\n-        fifth.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F,\n-                                                    InputEvent.CTRL_DOWN_MASK\n-                                                    | InputEvent.SHIFT_DOWN_MASK));\n-\n-        \/\/ Restore disabled foreground\n-        UIManager.put(\"MenuItem.disabledForeground\", disabledForeground);\n-\n-        JMenuItem sixth = new JMenuItem(\"Sixth menu item\");\n-        sixth.setEnabled(false);\n-        sixth.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_X,\n-                                                    InputEvent.CTRL_DOWN_MASK\n-                                                    | InputEvent.ALT_DOWN_MASK));\n-\n-\n-        JMenuItem quit = new JMenuItem(\"Quit\");\n-        quit.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_Q,\n-                                                   InputEvent.CTRL_DOWN_MASK));\n-\n-        JMenu menu = new JMenu(\"Menu\");\n-        menu.add(first);\n-        menu.add(second);\n-        menu.add(third);\n-        menu.addSeparator();\n-        menu.add(fourth);\n-        menu.add(fifth);\n-        menu.add(sixth);\n-        menu.addSeparator();\n-        menu.add(quit);\n-\n-        JMenuBar menuBar = new JMenuBar();\n-        menuBar.add(menu);\n-\n-        return menuBar;\n-    }\n-}\n","filename":"test\/jdk\/com\/sun\/java\/swing\/plaf\/windows\/MenuItem\/MenuItemAcceleratorColor.java","additions":0,"deletions":193,"binary":false,"changes":193,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,3 +30,0 @@\n- * @run junit\/othervm -Djdk.httpserver.attributes=context ExchangeAttributeTest\n- * @run junit\/othervm -Djdk.httpserver.attributes=random-string ExchangeAttributeTest\n- * @run junit\/othervm -Djdk.httpserver.attributes ExchangeAttributeTest\n@@ -77,1 +74,1 @@\n-        server.createContext(\"\/\", handler).getAttributes().put(\"attr\", \"context-val\");\n+        server.createContext(\"\/\", handler);\n@@ -107,11 +104,2 @@\n-                if (\"context\".equals(System.getProperty(\"jdk.httpserver.attributes\"))) {\n-                    exchange.setAttribute(\"attr\", \"val\");\n-                    assertEquals(\"val\", exchange.getAttribute(\"attr\"));\n-                    assertEquals(\"val\", exchange.getHttpContext().getAttributes().get(\"attr\"));\n-                } else {\n-                    assertNull(exchange.getAttribute(\"attr\"));\n-                    assertEquals(\"context-val\", exchange.getHttpContext().getAttributes().get(\"attr\"));\n-                    exchange.setAttribute(\"attr\", \"val\");\n-                    assertEquals(\"val\", exchange.getAttribute(\"attr\"));\n-                    assertEquals(\"context-val\", exchange.getHttpContext().getAttributes().get(\"attr\"));\n-                }\n+                exchange.setAttribute(\"attr\", \"val\");\n+                assertEquals(\"val\", exchange.getAttribute(\"attr\"));\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/ExchangeAttributeTest.java","additions":4,"deletions":16,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,263 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test id=default\n+ * @bug 8368695\n+ * @summary Test 101 switching protocal response handling\n+ * @run junit\/othervm SwitchingProtocolTest\n+ *\/\n+\/**\n+ * @test id=preferIPv6\n+ * @bug 8368695\n+ * @summary Test 101 switching protocal response handling ipv6\n+ * @run junit\/othervm -Djava.net.preferIPv6Addresses=true SwitchingProtocolTest\n+ *\/\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.sun.net.httpserver.HttpServer;\n+\n+public class SwitchingProtocolTest {\n+\n+    private static final String RESPONSE_BODY = \"Here is my reply!\";\n+    private static final String REQUEST_BODY = \"I will send all the data.\";\n+    private static final int REQUEST_LENGTH = REQUEST_BODY.getBytes().length;\n+    private static final int msgCode = 101;\n+    private static final String someContext = \"\/context\";\n+\n+    static {\n+        Logger.getLogger(\"\").setLevel(Level.ALL);\n+        Logger.getLogger(\"\").getHandlers()[0].setLevel(Level.ALL);\n+    }\n+\n+    @Test\n+    public void testSendResponse() throws Exception {\n+        System.out.println(\"testSendResponse()\");\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n+        HttpServer server = HttpServer.create(new InetSocketAddress(8080), 0);\n+        HttpServer.create(new InetSocketAddress(loopback, 0), 0);\n+        ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor();\n+        server.setExecutor(executor);\n+        try {\n+            server.createContext(\n+                someContext,\n+                msg -> {\n+                    byte[] reply = RESPONSE_BODY.getBytes(UTF_8);\n+                    System.err.println(\"Handling request: \" + msg.getRequestURI());\n+                    try {\n+                        assertEquals(-1, msg.getRequestBody().read());\n+                        assertEquals(0, msg.getRequestBody().readAllBytes().length);\n+                        msg.sendResponseHeaders(msgCode, -1);\n+                        \/\/ Read and assert request body\n+                        byte[] requestBytes = msg.getRequestBody().readNBytes(REQUEST_LENGTH);\n+                        String requestBody = new String(requestBytes, UTF_8);\n+                        assertEquals(REQUEST_BODY, requestBody);\n+                        msg.getResponseBody().write(reply);\n+                        msg.getResponseBody().flush();\n+                    } finally {\n+                        \/\/ don't close the exchange and don't close any stream\n+                        \/\/ to trigger the assertion.\n+                        System.err.println(\"Request handled: \" + msg.getRequestURI());\n+                    }\n+                });\n+            server.start();\n+            System.out.println(\"Server started at port \" + server.getAddress().getPort());\n+\n+            runRawSocketHttpClient(loopback, server.getAddress().getPort());\n+        } finally {\n+            System.out.println(\"shutting server down\");\n+            executor.shutdown();\n+            server.stop(0);\n+        }\n+        System.out.println(\"Server finished.\");\n+    }\n+\n+    @Test\n+    public void testCloseOutputStream() throws Exception {\n+        System.out.println(\"testCloseOutputStream()\");\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n+        HttpServer server = HttpServer.create(new InetSocketAddress(loopback, 0), 0);\n+        ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor();\n+        server.setExecutor(executor);\n+        try {\n+            server.createContext(\n+                someContext,\n+                msg -> {\n+                    System.err.println(\"Handling request: \" + msg.getRequestURI());\n+                    byte[] reply = RESPONSE_BODY.getBytes(UTF_8);\n+                    try {\n+                        try {\n+                            msg.sendResponseHeaders(msgCode, -1);\n+                            msg.getResponseBody().write(reply);\n+                            msg.getResponseBody().flush();\n+                            \/\/ Read and assert request body\n+                            byte[] requestBytes = msg.getRequestBody().readNBytes(REQUEST_LENGTH);\n+                            String requestBody = new String(requestBytes, UTF_8);\n+                            assertEquals(REQUEST_BODY, requestBody);\n+                            msg.getResponseBody().close();\n+                            Thread.sleep(50);\n+                        } catch (IOException | InterruptedException ie) {\n+                            ie.printStackTrace();\n+                        }\n+                    } finally {\n+                        System.err.println(\"Request handled: \" + msg.getRequestURI());\n+                    }\n+                });\n+            server.start();\n+            System.out.println(\"Server started at port \" + server.getAddress().getPort());\n+\n+            runRawSocketHttpClient(loopback, server.getAddress().getPort());\n+        } finally {\n+            System.out.println(\"shutting server down\");\n+            executor.shutdown();\n+            server.stop(0);\n+        }\n+        System.out.println(\"Server finished.\");\n+    }\n+\n+\n+    @Test\n+    public void testException() throws Exception {\n+        System.out.println(\"testException()\");\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n+        HttpServer server = HttpServer.create(new InetSocketAddress(loopback, 0), 0);\n+        ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor();\n+        server.setExecutor(executor);\n+        try {\n+            server.createContext(\n+                someContext,\n+                msg -> {\n+                    msg.sendResponseHeaders(msgCode, -1);\n+                    throw new RuntimeException(\"Simulated exception\");\n+                });\n+            server.start();\n+            System.out.println(\"Server started at port \" + server.getAddress().getPort());\n+\n+            runRawSocketHttpClient(loopback, server.getAddress().getPort(), true);\n+        } finally {\n+            System.out.println(\"shutting server down\");\n+            executor.shutdown();\n+            server.stop(0);\n+        }\n+        System.out.println(\"Server finished.\");\n+    }\n+\n+    static void runRawSocketHttpClient(InetAddress address, int port) throws Exception {\n+        runRawSocketHttpClient(address, port, false);\n+    }\n+\n+    static void runRawSocketHttpClient(InetAddress address, int port, boolean exception)\n+        throws Exception {\n+        Socket socket = null;\n+        PrintWriter writer = null;\n+        BufferedReader reader = null;\n+        final String CRLF = \"\\r\\n\";\n+        try {\n+            socket = new Socket(address, port);\n+            writer = new PrintWriter(new OutputStreamWriter(socket.getOutputStream()));\n+            System.out.println(\"Client connected by socket: \" + socket);\n+            String body = REQUEST_BODY;\n+            var contentLength = body.getBytes(UTF_8).length;\n+\n+            writer.print(\"GET \" + someContext + \"\/ HTTP\/1.1\" + CRLF);\n+            writer.print(\"User-Agent: Java\/\" + System.getProperty(\"java.version\") + CRLF);\n+            writer.print(\"Host: \" + address.getHostName() + CRLF);\n+            writer.print(\"Accept: *\/*\" + CRLF);\n+            writer.print(\"Content-Length: \" + contentLength + CRLF);\n+            writer.print(\"Connection: keep-alive\" + CRLF);\n+            writer.print(\"Connection: Upgrade\" + CRLF);\n+            writer.print(\"Upgrade: custom\" + CRLF);\n+            writer.print(CRLF); \/\/ Important, else the server will expect that\n+            \/\/ there's more into the request.\n+            writer.flush();\n+            System.out.println(\"Client wrote request to socket: \" + socket);\n+\n+            System.out.println(\"Client wrote body to socket: \" + socket);\n+\n+            reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            System.out.println(\"Client start reading from server:\");\n+            String line = reader.readLine();\n+            StringBuilder responseBody = new StringBuilder();\n+            for (; line != null; line = reader.readLine()) {\n+                if (line.isEmpty()) {\n+                    break;\n+                }\n+                System.out.println(\"\\\"\" + line + \"\\\"\");\n+            }\n+            \/\/ Write request body after headers\n+            writer.print(body);\n+            writer.flush();\n+            \/\/ Read response body\n+            char[] buf = new char[RESPONSE_BODY.length()];\n+            int read = reader.read(buf);\n+            if (read > 0) {\n+                responseBody.append(buf, 0, read);\n+            }\n+            String actualResponse = responseBody.toString();\n+            assertEquals(RESPONSE_BODY, actualResponse, \"Response body does not match\");\n+            System.out.println(\"Client finished reading from server\");\n+        } catch (SocketException se) {\n+            if (!exception) {\n+                fail(\"Unexpected exception: \" + se);\n+            }\n+            assertEquals(\"Connection reset\", se.getMessage());\n+        } finally {\n+            if (writer != null) {\n+                writer.close();\n+            }\n+            if (reader != null)\n+                try {\n+                    reader.close();\n+                } catch (IOException logOrIgnore) {\n+                    logOrIgnore.printStackTrace();\n+                }\n+            if (socket != null) {\n+                try {\n+                    socket.close();\n+                } catch (IOException logOrIgnore) {\n+                    logOrIgnore.printStackTrace();\n+                }\n+            }\n+        }\n+        System.out.println(\"Client finished.\");\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/SwitchingProtocolTest.java","additions":263,"deletions":0,"binary":false,"changes":263,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n-  @bug 5051056 8367702\n+  @bug 50510568367702\n","filename":"test\/jdk\/java\/awt\/PrintJob\/GetGraphicsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @bug 8020443 6899304 4737732 8357390\n+ * @bug 8020443 6899304 4737732\n@@ -47,1 +47,1 @@\n-    private static final int MARGIN_TOLERANCE = 2;\n+    private static final int MARGIN_TOLERANCE = 1;\n","filename":"test\/jdk\/java\/awt\/Toolkit\/ScreenInsetsTest\/ScreenInsetsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.awt.color.ColorSpace;\n-import java.awt.color.ICC_Profile;\n-import java.io.ByteArrayOutputStream;\n-import java.io.ObjectOutputStream;\n-\n-\/**\n- * @test\n- * @bug 8369032\n- * @summary Checks the size of the serialized ICC_Profile for standard and\n- *          non-standard profiles.\n- *\/\n-public final class SerializedFormSize {\n-\n-    private static final ICC_Profile[] PROFILES = {\n-            ICC_Profile.getInstance(ColorSpace.CS_sRGB),\n-            ICC_Profile.getInstance(ColorSpace.CS_LINEAR_RGB),\n-            ICC_Profile.getInstance(ColorSpace.CS_CIEXYZ),\n-            ICC_Profile.getInstance(ColorSpace.CS_PYCC),\n-            ICC_Profile.getInstance(ColorSpace.CS_GRAY)\n-    };\n-\n-    public static void main(String[] args) throws Exception {\n-        for (ICC_Profile profile : PROFILES) {\n-            byte[] data = profile.getData();\n-            int dataSize = data.length;\n-            int min = 3; \/\/ At least version, name and data fields\n-            int max = 200; \/\/ Small enough to confirm no data saved\n-\n-            \/\/ Standard profile: should serialize to a small size, no data\n-            test(profile, min, max);\n-            \/\/ Non-standard profile: includes full data, but only once\n-            test(ICC_Profile.getInstance(data), dataSize, dataSize + max);\n-        }\n-    }\n-\n-    private static void test(ICC_Profile p, int min, int max) throws Exception {\n-        try (var bos = new ByteArrayOutputStream();\n-             var oos = new ObjectOutputStream(bos))\n-        {\n-            oos.writeObject(p);\n-            int size = bos.size();\n-            if (size < min || size > max) {\n-                System.err.println(\"Expected: >= \" + min + \" and <= \" + max);\n-                System.err.println(\"Actual: \" + size);\n-                throw new RuntimeException(\"Wrong size\");\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/SerializedFormSize.java","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -1,84 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8365077\n- * @summary confirm that an instance which is created with Enum ranges is\n- * equal to another instance which is created with equivalent traditional\n- * ranges, and that in such a case the hashCodes are also equal.\n- *\/\n-\n-import java.awt.font.NumericShaper;\n-import java.awt.font.NumericShaper.Range;\n-import static java.awt.font.NumericShaper.Range.*;\n-import java.util.EnumSet;\n-\n-public class NSEqualsTest {\n-\n-    public static void main(String[] args) {\n-\n-        for (Range r1 : Range.values()) {\n-           test(r1);\n-           for (Range r2 : Range.values()) {\n-              test(r1, r2);\n-           }\n-        }\n-    }\n-\n-    static void test(Range r) {\n-        if (r.ordinal() > MONGOLIAN.ordinal()) {\n-            return;\n-        }\n-        int o = 1 << r.ordinal();\n-        NumericShaper nsr = NumericShaper.getContextualShaper(EnumSet.of(r));\n-        NumericShaper nso = NumericShaper.getContextualShaper(o);\n-        printAndCompare(nsr, nso);\n-    }\n-\n-    static void test(Range r1, Range r2) {\n-        if (r1.ordinal() > MONGOLIAN.ordinal() || r2.ordinal() > MONGOLIAN.ordinal()) {\n-            return;\n-        }\n-        int o1 = 1 << r1.ordinal();\n-        int o2 = 1 << r2.ordinal();\n-\n-        NumericShaper nsr = NumericShaper.getContextualShaper(EnumSet.of(r1, r2));\n-        NumericShaper nso = NumericShaper.getContextualShaper(o1 | o2);\n-        printAndCompare(nsr, nso);\n-    }\n-\n-    static void printAndCompare(NumericShaper nsr, NumericShaper nso) {\n-        System.err.println(nsr);\n-        System.err.println(nso);\n-        System.err.println(nsr.hashCode() + \" vs \" + nso.hashCode() +\n-                           \" equal: \" + nsr.equals(nso));\n-        if (!nsr.equals(nso)) {\n-            throw new RuntimeException(\"Expected equal\");\n-        }\n-        if (nsr.hashCode() != nso.hashCode()) {\n-            throw new RuntimeException(\"Different hash codes:\");\n-        }\n-    }\n-}\n-\n","filename":"test\/jdk\/java\/awt\/font\/NumericShaper\/NSEqualsTest.java","additions":0,"deletions":84,"binary":false,"changes":84,"status":"deleted"},{"patch":"@@ -1,100 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 6453640\n- * @summary Verify BandedSampleModel.createCompatibleSampleModel\n- *          and createSubsetSampleModel behaviour\n- * @run main BSMCreateCompatibleSMTest\n- *\/\n-\n-import java.awt.image.BandedSampleModel;\n-import java.awt.image.DataBuffer;\n-import java.awt.image.RasterFormatException;\n-\n-public class BSMCreateCompatibleSMTest {\n-\n-    public static void main(String[] args) {\n-\n-        \/\/ These should all be OK\n-        BandedSampleModel bsm = new BandedSampleModel(DataBuffer.TYPE_BYTE, 1, 1, 1);\n-        bsm.createCompatibleSampleModel(20_000, 20_000);\n-        int[] bands = { 0 } ;\n-        bsm.createSubsetSampleModel(bands);\n-\n-        \/\/ These should all throw an exception\n-        try {\n-            bsm.createCompatibleSampleModel(-1, 1);\n-            throw new RuntimeException(\"No exception for illegal w\");\n-        } catch (IllegalArgumentException e) {\n-            System.out.println(e);\n-        }\n-\n-        try {\n-            bsm.createCompatibleSampleModel(1, 0);\n-            throw new RuntimeException(\"No exception for illegal h\");\n-        } catch (IllegalArgumentException e) {\n-            System.out.println(e);\n-        }\n-\n-        try {\n-            bsm.createCompatibleSampleModel(-1, -1);\n-            throw new RuntimeException(\"No exception for illegal w+h\");\n-        } catch (IllegalArgumentException e) {\n-            System.out.println(e);\n-        }\n-\n-        try {\n-            bsm.createCompatibleSampleModel(50_000, 50_000);\n-            throw new RuntimeException(\"No exception for too large dims\");\n-        } catch (IllegalArgumentException e) {\n-            System.out.println(e);\n-        }\n-\n-        try {\n-            int[] bands0 = { } ;\n-            bsm.createSubsetSampleModel(bands0);\n-            throw new RuntimeException(\"No exception for empty bands[]\");\n-        } catch (IllegalArgumentException e) {\n-            System.out.println(e);\n-        }\n-\n-        try {\n-            int[] bands1 = { 1 } ;\n-            bsm.createSubsetSampleModel(bands1);\n-            throw new RuntimeException(\"No exception for out of bounds band\");\n-        } catch (ArrayIndexOutOfBoundsException e) {\n-            System.out.println(e);\n-        }\n-\n-        try {\n-            int[] bands2 = { 0, 0 } ;\n-            bsm.createSubsetSampleModel(bands2);\n-            throw new RuntimeException(\"No exception for too many bands\");\n-        } catch (RasterFormatException e) {\n-            System.out.println(e);\n-        }\n-   }\n-\n-}\n","filename":"test\/jdk\/java\/awt\/image\/BandedSampleModel\/BSMCreateCompatibleSMTest.java","additions":0,"deletions":100,"binary":false,"changes":100,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/*\n+\/**\n@@ -29,5 +29,1 @@\n- * @library \/java\/awt\/regtesthelpers\n- * @library \/test\/lib\n- * @build PassFailJFrame\n- * @build jtreg.SkippedException\n- * @run main\/manual PageRanges\n+ * @run main\/manual=yesno PageRanges\n@@ -36,6 +32,2 @@\n-import java.awt.Graphics;\n-import java.awt.print.PageFormat;\n-import java.awt.print.Printable;\n-import java.awt.print.PrinterException;\n-import java.awt.print.PrinterJob;\n-import jtreg.SkippedException;\n+import java.awt.*;\n+import java.awt.print.*;\n@@ -44,7 +36,8 @@\n-    private static final String INSTRUCTIONS = \"\"\"\n-                 This test prints two jobs and tests that the specified range\n-                 of pages is printed.\n-                 In the first dialog, select a page range of 2 to 3, and press OK.\n-                 In the second dialog, select ALL, to print all pages (in total 5 pages).\n-                 Collect the two print outs and confirm the jobs are printed correctly.\n-                 \"\"\";\n+\n+    static String[] instr = {\n+     \"This test prints two jobs, and tests that the specified range\",\n+     \"of pages is printed. You must have a printer installed for this test.\",\n+     \"In the first dialog, select a page range of 2 to 3, and press OK\",\n+     \"In the second dialog, select ALL, to print all pages (in total 5 pages).\",\n+     \"Collect the two print outs and confirm the jobs printed correctly\",\n+    };\n@@ -53,0 +46,3 @@\n+        for (int i=0;i<instr.length;i++) {\n+            System.out.println(instr[i]);\n+        }\n@@ -55,1 +51,2 @@\n-            throw new SkippedException(\"Printer not configured or available.\");\n+           System.out.println(\"No printers. Test cannot continue.\");\n+           return;\n@@ -57,6 +54,0 @@\n-\n-        PassFailJFrame passFailJFrame = PassFailJFrame.builder()\n-                .instructions(INSTRUCTIONS)\n-                .columns(45)\n-                .build();\n-\n@@ -64,2 +55,2 @@\n-        if (job.printDialog()) {\n-            job.print();\n+        if (!job.printDialog()) {\n+           return;\n@@ -67,2 +58,3 @@\n-        if (job.printDialog()) {\n-            job.print();\n+        job.print();\n+        if (!job.printDialog()) {\n+           return;\n@@ -70,0 +62,1 @@\n+        job.print();\n@@ -71,1 +64,1 @@\n-        passFailJFrame.awaitAndCheck();\n+        return;\n@@ -75,1 +68,2 @@\n-                     throws PrinterException {\n+                     throws PrinterException  {\n+\n@@ -81,0 +75,1 @@\n+\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/PageRanges.java","additions":28,"deletions":33,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +24,1 @@\n-\/*\n- * @test\n+\/**\n@@ -29,5 +28,1 @@\n- * @library \/java\/awt\/regtesthelpers\n- * @library \/test\/lib\n- * @build PassFailJFrame\n- * @build jtreg.SkippedException\n- * @run main\/manual PolylinePrintingTest\n+ * @run main\/manual=yesno PolylinePrintingTest\n@@ -36,0 +31,3 @@\n+import java.awt.Dialog;\n+import java.awt.Frame;\n+import java.awt.TextArea;\n@@ -41,0 +39,1 @@\n+import java.awt.print.Paper;\n@@ -44,1 +43,0 @@\n-import jtreg.SkippedException;\n@@ -47,24 +45,0 @@\n-    private static final String INSTRUCTIONS = \"\"\"\n-              Press OK in the print dialog and collect the printed page.\n-              Passing test : Output should show two identical chevrons.\n-              Failing test : The line joins will appear different.\n-              \"\"\";\n-\n-    public static void main(String[] args) throws Exception {\n-        PrinterJob job = PrinterJob.getPrinterJob();\n-        if (job.getPrintService() == null) {\n-            throw new SkippedException(\"Printer not configured or available.\");\n-        }\n-\n-        PassFailJFrame passFailJFrame = PassFailJFrame.builder()\n-                .instructions(INSTRUCTIONS)\n-                .columns(45)\n-                .build();\n-\n-        job.setPrintable(new PolylinePrintingTest());\n-        if (job.printDialog()) {\n-            job.print();\n-        }\n-\n-        passFailJFrame.awaitAndCheck();\n-    }\n@@ -74,0 +48,1 @@\n+\n@@ -94,0 +69,1 @@\n+\n@@ -110,0 +86,24 @@\n+\n+    public PolylinePrintingTest() throws PrinterException {\n+        PrinterJob job = PrinterJob.getPrinterJob();\n+        PageFormat pf = job.defaultPage();\n+        Paper p = pf.getPaper();\n+        p.setImageableArea(0,0,p.getWidth(), p.getHeight());\n+        pf.setPaper(p);\n+        job.setPrintable(this, pf);\n+        if (job.printDialog()) {\n+            job.print();\n+        }\n+    }\n+\n+    public static void main(String[] args) throws PrinterException {\n+        String[] instructions = {\n+             \"You must have a printer available to perform this test.\",\n+             \"OK the print dialog, and collect the printed page.\",\n+             \"Passing test : Output should show two identical chevrons.\",\n+             \"Failing test : The line joins will appear different.\"\n+           };\n+        Sysout.createDialog();\n+        Sysout.printInstructions(instructions);\n+        new PolylinePrintingTest();\n+    }\n@@ -111,0 +111,113 @@\n+\n+class Sysout {\n+   private static TestDialog dialog;\n+\n+   public static void createDialogWithInstructions( String[] instructions )\n+    {\n+      dialog = new TestDialog( new Frame(), \"Instructions\" );\n+      dialog.printInstructions( instructions );\n+      dialog.show();\n+      println( \"Any messages for the tester will display here.\" );\n+    }\n+\n+   public static void createDialog( )\n+    {\n+      dialog = new TestDialog( new Frame(), \"Instructions\" );\n+      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n+      dialog.printInstructions( defInstr );\n+      dialog.show();\n+      println( \"Any messages for the tester will display here.\" );\n+    }\n+\n+\n+   public static void printInstructions( String[] instructions )\n+    {\n+      dialog.printInstructions( instructions );\n+    }\n+\n+\n+   public static void println( String messageIn )\n+    {\n+      dialog.displayMessage( messageIn );\n+    }\n+\n+}\/\/ Sysout  class\n+\n+\/**\n+  This is part of the standard test machinery.  It provides a place for the\n+   test instructions to be displayed, and a place for interactive messages\n+   to the user to be displayed.\n+  To have the test instructions displayed, see Sysout.\n+  To have a message to the user be displayed, see Sysout.\n+  Do not call anything in this dialog directly.\n+  *\/\n+class TestDialog extends Dialog {\n+  TextArea instructionsText;\n+   TextArea messageText;\n+   int maxStringLength = 80;\n+\n+   \/\/DO NOT call this directly, go through Sysout\n+   public TestDialog( Frame frame, String name )\n+    {\n+      super( frame, name );\n+      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n+      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n+      add( \"North\", instructionsText );\n+\n+      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n+      add(\"Center\", messageText);\n+\n+      pack();\n+\n+      show();\n+    }\/\/ TestDialog()\n+\n+   \/\/DO NOT call this directly, go through Sysout\n+   public void printInstructions( String[] instructions )\n+    {\n+      \/\/Clear out any current instructions\n+      instructionsText.setText( \"\" );\n+\n+      \/\/Go down array of instruction strings\n+\n+      String printStr, remainingStr;\n+      for( int i=0; i < instructions.length; i++ )\n+       {\n+         \/\/chop up each into pieces maxSringLength long\n+         remainingStr = instructions[ i ];\n+         while( remainingStr.length() > 0 )\n+          {\n+            \/\/if longer than max then chop off first max chars to print\n+            if( remainingStr.length() >= maxStringLength )\n+             {\n+               \/\/Try to chop on a word boundary\n+               int posOfSpace = remainingStr.\n+                  lastIndexOf( ' ', maxStringLength - 1 );\n+               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n+\n+               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n+               remainingStr = remainingStr.substring( posOfSpace + 1 );\n+             }\n+            \/\/else just print\n+            else\n+             {\n+               printStr = remainingStr;\n+               remainingStr = \"\";\n+             }\n+\n+            instructionsText.append( printStr + \"\\n\" );\n+\n+          }\/\/ while\n+\n+       }\/\/ for\n+\n+    }\/\/printInstructions()\n+\n+   \/\/DO NOT call this directly, go through Sysout\n+   public void displayMessage( String messageIn )\n+    {\n+      messageText.append( messageIn + \"\\n\" );\n+    }\n+\n+}\/\/ TestDialog  class\n+\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/PolylinePrintingTest.java","additions":146,"deletions":33,"binary":false,"changes":179,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/*\n+\/**\n@@ -29,3 +29,1 @@\n- * @library \/java\/awt\/regtesthelpers \/test\/lib\n- * @build PassFailJFrame jtreg.SkippedException\n- * @run main\/manual SwingUIText\n+ * @run main\/manual=yesno PrintTextTest\n@@ -34,14 +32,3 @@\n-import java.awt.Font;\n-import java.awt.Graphics;\n-import java.awt.GridLayout;\n-import java.awt.print.PageFormat;\n-import java.awt.print.Printable;\n-import java.awt.print.PrinterJob;\n-import javax.swing.JButton;\n-import javax.swing.JEditorPane;\n-import javax.swing.JFrame;\n-import javax.swing.JLabel;\n-import javax.swing.JPanel;\n-import javax.swing.JTextArea;\n-import javax.swing.JTextField;\n-import jtreg.SkippedException;\n+import java.awt.*;\n+import javax.swing.*;\n+import java.awt.print.*;\n@@ -50,19 +37,0 @@\n-    private static JFrame frame;\n-    private static final String INSTRUCTIONS = \"\"\"\n-            This test checks that when a Swing UI is printed,\n-            the text in each component aligns with the component’s length as seen on-screen.\n-            It also ensures the text spacing is reasonably even, though this is subjective.\n-            The comparison should be made with JDK 1.5 GA or JDK 1.6 GA.\n-\n-            Steps:\n-            1. Press the \"Print\" or \"OK\" button on the Print dialog.\n-                This will print the content of the \"Swing UI Text Printing Test\" JFrame.\n-            2. Compare the printout with the content of the JFrame.\n-            3. If they match, press Pass; otherwise, press Fail.\n-            \"\"\";\n-\n-    public static void main(String args[])  throws Exception {\n-        PrinterJob job = PrinterJob.getPrinterJob();\n-        if (job.getPrintService() == null) {\n-            throw new SkippedException(\"Printer not configured or available.\");\n-        }\n@@ -70,5 +38,7 @@\n-        PassFailJFrame passFailJFrame = PassFailJFrame.builder()\n-                .instructions(INSTRUCTIONS)\n-                .columns(45)\n-                .testUI(SwingUIText::createTestUI)\n-                .build();\n+    static String[] instructions = {\n+        \"This tests that when a Swing UI is printed, that the text\",\n+        \"in each component properly matches the length of the component\",\n+        \"as seen on-screen, and that the spacing of the text is of\",\n+        \"reasonable even-ness. This latter part is very subjective and\",\n+        \"the comparison has to be with JDK1.5 GA, or JDK 1.6 GA\",\n+    };\n@@ -76,4 +46,1 @@\n-        job.setPrintable(new SwingUIText());\n-        if (job.printDialog()) {\n-            job.print();\n-        }\n+    static JFrame frame;\n@@ -81,1 +48,6 @@\n-        passFailJFrame.awaitAndCheck();\n+    public static void main(String args[]) {\n+        SwingUtilities.invokeLater(new Runnable() {\n+          public void run() {\n+              createUI();\n+          }\n+      });\n@@ -84,2 +56,4 @@\n-    public static JFrame createTestUI() {\n-        frame = new JFrame();\n+    public static void createUI() {\n+\n+        Sysout.createDialogWithInstructions(instructions);\n+\n@@ -87,1 +61,1 @@\n-        panel.setLayout(new GridLayout(4, 1));\n+        panel.setLayout(new GridLayout(4,1));\n@@ -118,1 +92,12 @@\n-        return frame;\n+        frame.setVisible(true);\n+\n+        PrinterJob job = PrinterJob.getPrinterJob();\n+        PageFormat pf = job.defaultPage();\n+        job.setPrintable(new SwingUIText(), pf);\n+        if (job.printDialog()) {\n+            try { job.print(); }\n+            catch (Exception e) {\n+              e.printStackTrace();\n+              throw new RuntimeException(e);\n+            }\n+        }\n@@ -121,0 +106,1 @@\n+\n@@ -123,1 +109,1 @@\n-        panel.setLayout(new GridLayout(2, 1));\n+        panel.setLayout(new GridLayout(2,1));\n@@ -131,1 +117,1 @@\n-        JButton button = new JButton(\"Print \" + text);\n+        JButton button = new JButton(\"Print \"+text);\n@@ -150,1 +136,3 @@\n-    public int print(Graphics g, PageFormat pf, int pageIndex) {\n+    public int print(Graphics g, PageFormat pf, int pageIndex)\n+        throws PrinterException {\n+\n@@ -154,1 +142,0 @@\n-\n@@ -157,0 +144,1 @@\n+\n@@ -161,0 +149,116 @@\n+\n+class Sysout\n+ {\n+   private static TestDialog dialog;\n+\n+   public static void createDialogWithInstructions( String[] instructions )\n+    {\n+      dialog = new TestDialog( new Frame(), \"Instructions\" );\n+      dialog.printInstructions( instructions );\n+      dialog.show();\n+      println( \"Any messages for the tester will display here.\" );\n+    }\n+\n+   public static void createDialog( )\n+    {\n+      dialog = new TestDialog( new Frame(), \"Instructions\" );\n+      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n+      dialog.printInstructions( defInstr );\n+      dialog.show();\n+      println( \"Any messages for the tester will display here.\" );\n+    }\n+\n+\n+   public static void printInstructions( String[] instructions )\n+    {\n+      dialog.printInstructions( instructions );\n+    }\n+\n+\n+   public static void println( String messageIn )\n+    {\n+      dialog.displayMessage( messageIn );\n+    }\n+\n+ }\/\/ Sysout  class\n+\n+\/**\n+  This is part of the standard test machinery.  It provides a place for the\n+   test instructions to be displayed, and a place for interactive messages\n+   to the user to be displayed.\n+  To have the test instructions displayed, see Sysout.\n+  To have a message to the user be displayed, see Sysout.\n+  Do not call anything in this dialog directly.\n+  *\/\n+class TestDialog extends Dialog\n+ {\n+\n+   TextArea instructionsText;\n+   TextArea messageText;\n+   int maxStringLength = 80;\n+\n+   \/\/DO NOT call this directly, go through Sysout\n+   public TestDialog( Frame frame, String name )\n+    {\n+      super( frame, name );\n+      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n+      instructionsText = new TextArea( \"\", 10, maxStringLength, scrollBoth );\n+      add( \"North\", instructionsText );\n+\n+      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n+      add(\"South\", messageText);\n+\n+      pack();\n+\n+      show();\n+    }\/\/ TestDialog()\n+\n+   \/\/DO NOT call this directly, go through Sysout\n+   public void printInstructions( String[] instructions )\n+    {\n+      \/\/Clear out any current instructions\n+      instructionsText.setText( \"\" );\n+\n+      \/\/Go down array of instruction strings\n+\n+      String printStr, remainingStr;\n+      for( int i=0; i < instructions.length; i++ )\n+       {\n+     \/\/chop up each into pieces maxSringLength long\n+     remainingStr = instructions[ i ];\n+     while( remainingStr.length() > 0 )\n+      {\n+        \/\/if longer than max then chop off first max chars to print\n+        if( remainingStr.length() >= maxStringLength )\n+         {\n+           \/\/Try to chop on a word boundary\n+           int posOfSpace = remainingStr.\n+          lastIndexOf( ' ', maxStringLength - 1 );\n+\n+           if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n+\n+           printStr = remainingStr.substring( 0, posOfSpace + 1 );\n+           remainingStr = remainingStr.substring( posOfSpace + 1 );\n+         }\n+        \/\/else just print\n+        else\n+         {\n+           printStr = remainingStr;\n+           remainingStr = \"\";\n+         }\n+\n+            instructionsText.append( printStr + \"\\n\" );\n+\n+      }\/\/ while\n+\n+       }\/\/ for\n+\n+    }\/\/printInstructions()\n+\n+   \/\/DO NOT call this directly, go through Sysout\n+   public void displayMessage( String messageIn )\n+    {\n+      messageText.append( messageIn + \"\\n\" );\n+    }\n+\n+}\/\/ TestDialog  class\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/SwingUIText.java","additions":160,"deletions":56,"binary":false,"changes":216,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n- * @library \/test\/lib\n@@ -38,0 +37,1 @@\n+import java.lang.reflect.Constructor;\n@@ -40,0 +40,1 @@\n+import java.util.concurrent.ExecutorService;\n@@ -42,1 +43,0 @@\n-import java.util.concurrent.ExecutorService;\n@@ -45,1 +45,0 @@\n-import jdk.test.lib.thread.VThreadScheduler;\n@@ -57,1 +56,1 @@\n-            Thread.Builder builder = VThreadScheduler.virtualThreadBuilder(scheduler);\n+            Thread.Builder builder = virtualThreadBuilder(scheduler);\n@@ -122,0 +121,10 @@\n+\n+    \/**\n+     * Returns a builder to create virtual threads that use the given scheduler.\n+     *\/\n+    static Thread.Builder.OfVirtual virtualThreadBuilder(Executor scheduler) throws Exception {\n+        Class<?> clazz = Class.forName(\"java.lang.ThreadBuilders$VirtualThreadBuilder\");\n+        Constructor<?> ctor = clazz.getDeclaredConstructor(Executor.class);\n+        ctor.setAccessible(true);\n+        return (Thread.Builder.OfVirtual) ctor.newInstance(scheduler);\n+    }\n","filename":"test\/jdk\/java\/io\/ByteArrayOutputStream\/WriteToReleasesCarrier.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Stuart Marks, Joseph D. Darcy\n","filename":"test\/jdk\/java\/io\/Serializable\/cloneArray\/CloneArray.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2007, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+ * @author madbot\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Byte\/Decode.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2004, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Class\/IsAnnotationType.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Class\/IsEnum.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Class\/IsSynthetic.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Class\/getEnclosingConstructor\/EnclosingConstructorTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Class\/getEnclosingMethod\/EnclosingMethodTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Double\/BitwiseConversion.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2005, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Double\/Constants.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2005, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Double\/Extrema.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Double\/NaNInfinityParsing.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2017, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Double\/ParseHexFloatingPoint.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,2 +2,1 @@\n- * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2025, Alibaba Group Holding Limited. All Rights Reserved.\n+ * Copyright (c) 2003, 2011, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +31,1 @@\n+ * @author Joseph D. Darcy\n@@ -178,20 +178,0 @@\n-            \/\/ Test cases for trailing zeros in significand\n-            \/\/ These test the removal of trailing zeros in the hexadecimal representation\n-            \/\/ The comments indicate the number of trailing zeros removed from the significand\n-            \/\/ For \"0x1.0p1\", there are 13 trailing zeros in the significand, but only 12 are removed\n-            \/\/ as we always keep at least one hex digit in the significand\n-            {\"0x1.0p1\",                                 \"4000000000000000\"}, \/\/ 12 trailing zeros removed (13 total, but only 12 removed)\n-            {\"0x1.1p1\",                                 \"4001000000000000\"}, \/\/ 12 trailing zeros removed (all zeros after '1')\n-            {\"0x1.01p1\",                                \"4000100000000000\"}, \/\/ 11 trailing zeros removed\n-            {\"0x1.001p1\",                               \"4000010000000000\"}, \/\/ 10 trailing zeros removed\n-            {\"0x1.0001p1\",                              \"4000001000000000\"}, \/\/ 9  trailing zeros removed\n-            {\"0x1.00001p1\",                             \"4000000100000000\"}, \/\/ 8  trailing zeros removed\n-            {\"0x1.000001p1\",                            \"4000000010000000\"}, \/\/ 7  trailing zeros removed\n-            {\"0x1.0000001p1\",                           \"4000000001000000\"}, \/\/ 6  trailing zeros removed\n-            {\"0x1.00000001p1\",                          \"4000000000100000\"}, \/\/ 5  trailing zeros removed\n-            {\"0x1.000000001p1\",                         \"4000000000010000\"}, \/\/ 4  trailing zeros removed\n-            {\"0x1.0000000001p1\",                        \"4000000000001000\"}, \/\/ 3  trailing zeros removed\n-            {\"0x1.00000000001p1\",                       \"4000000000000100\"}, \/\/ 2  trailing zeros removed\n-            {\"0x1.000000000001p1\",                      \"4000000000000010\"}, \/\/ 1  trailing zero  removed (minimum)\n-            {\"0x1.0000000000001p1\",                     \"4000000000000001\"}, \/\/ 0  trailing zeros removed (no trailing zeros to remove)\n-\n","filename":"test\/jdk\/java\/lang\/Double\/ToHexString.java","additions":2,"deletions":22,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Float\/BitwiseConversion.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2005, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Float\/Constants.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2005, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Float\/Extrema.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Float\/NaNInfinityParsing.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+ * @author madbot\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Integer\/Decode.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2007, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Integer\/ParsingTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2012, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Integer\/Unsigned.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2006, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+ * @author madbot\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Long\/Decode.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2007, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Long\/ParsingTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Long\/Unsigned.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2007, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+ * @author madbot\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Short\/Decode.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,0 @@\n- * @summary Test if the getCallerClass method returns empty optional\n- * @requires test.thread.factory == null\n@@ -30,0 +28,1 @@\n+ * @summary Test if the getCallerClass method returns empty optional\n","filename":"test\/jdk\/java\/lang\/StackWalker\/CallerFromMain.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n- * @requires test.thread.factory == null\n","filename":"test\/jdk\/java\/lang\/StackWalker\/DumpStackTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,0 @@\n- * @requires test.thread.factory == null\n","filename":"test\/jdk\/java\/lang\/StackWalker\/StackWalkTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @requires test.thread.factory == null\n","filename":"test\/jdk\/java\/lang\/Thread\/MainThreadTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n- * @requires test.thread.factory == null\n","filename":"test\/jdk\/java\/lang\/Thread\/UncaughtExceptionsTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2013, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+ * @author  Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/Throwable\/SuppressedExceptions.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2016, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/annotation\/Missing\/MissingTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author  Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/annotation\/TestIncompleteAnnotationExceptionNPE.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run testng\/othervm -Djava.io.tmpdir=. ModulesInCustomFileSystem\n+ * @run testng\/othervm ModulesInCustomFileSystem\n","filename":"test\/jdk\/java\/lang\/module\/customfs\/ModulesInCustomFileSystem.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @requires test.thread.factory == null\n","filename":"test\/jdk\/java\/lang\/ref\/OOMEInReferenceHandler.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/reflect\/AnnotatedElement\/TestAnnotatedElementDefaults.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/reflect\/Constructor\/GenericStringTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/reflect\/Constructor\/TestParameterAnnotations.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/reflect\/DefaultAccessibility.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2016, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/reflect\/Field\/GenericStringTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/reflect\/Generics\/HashCodeTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2013, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/reflect\/Generics\/Probe.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/reflect\/Generics\/StringsAndBounds.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/reflect\/Generics\/TestParameterizedType.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/reflect\/Generics\/exceptionCauseTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/reflect\/Generics\/getAnnotationTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/reflect\/Method\/GenericStringTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/reflect\/Method\/IsDefaultTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/reflect\/Method\/defaultMethodModeling\/DefaultMethodModeling.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/lang\/reflect\/TypeVariable\/TestAnnotatedElement.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/math\/BigDecimal\/AddTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2013, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/math\/BigDecimal\/CompareToTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2015, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/math\/BigDecimal\/DivideTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2013, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/math\/BigDecimal\/IntegralDivisionTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/math\/BigDecimal\/NegateTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/math\/BigDecimal\/PowTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/math\/BigDecimal\/PrecisionTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/math\/BigDecimal\/RoundingTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/math\/BigDecimal\/ScaleByPowerOfTenTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -351,1 +351,1 @@\n-                int expectedScale = Math.ceilDiv(scale, 2);\n+                int expectedScale = scale\/2;\n@@ -585,2 +585,1 @@\n-                int preferredScale = Math.ceilDiv(bd.scale(), 2);\n-\n+                int preferredScale = bd.scale()\/2;\n","filename":"test\/jdk\/java\/math\/BigDecimal\/SquareRootTests.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/math\/BigDecimal\/StrippingZerosTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/math\/BigDecimal\/ToPlainStringTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/math\/BigDecimal\/ZeroScalingTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2013, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/math\/BigInteger\/CompareToTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2013, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/math\/BigInteger\/ExtremeShiftingTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/math\/BigInteger\/OperatorNpeTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2007, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/math\/BigInteger\/StringConstructor.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/math\/BigInteger\/TestValueExact.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @author Joseph D. Darcy\n","filename":"test\/jdk\/java\/math\/RoundingMode\/RoundingModeTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,158 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.httpclient.test.lib.common.HttpServerAdapters;\n-import jdk.internal.net.http.common.Utils;\n-import jdk.test.lib.net.SimpleSSLContext;\n-import org.junit.jupiter.api.BeforeAll;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.MethodSource;\n-\n-import javax.net.ssl.SSLContext;\n-import java.io.IOException;\n-import java.net.URI;\n-import java.net.http.HttpClient;\n-import java.net.http.HttpClient.Version;\n-import java.net.http.HttpRequest;\n-import java.net.http.HttpResponse;\n-import java.nio.charset.StandardCharsets;\n-import java.util.Arrays;\n-\n-import static java.net.http.HttpClient.Builder.NO_PROXY;\n-import static java.net.http.HttpClient.Version.HTTP_1_1;\n-import static java.net.http.HttpClient.Version.HTTP_2;\n-import static java.net.http.HttpClient.Version.HTTP_3;\n-import static java.net.http.HttpOption.H3_DISCOVERY;\n-import static java.net.http.HttpOption.Http3DiscoveryMode.HTTP_3_URI_ONLY;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-\n-\/*\n- * @test id\n- * @bug 8367976\n- * @summary Verifies that setting the `jdk.httpclient.bufsize` system property\n- *          to its lowest possible value, 1, does not wedge the client\n- * @library \/test\/jdk\/java\/net\/httpclient\/lib\n- *          \/test\/lib\n- * @run junit\/othervm -Djdk.httpclient.bufsize=1 BufferSize1Test\n- *\/\n-\n-class BufferSize1Test implements HttpServerAdapters {\n-\n-    @BeforeAll\n-    static void verifyBufferSize() {\n-        assertEquals(1, Utils.BUFSIZE);\n-    }\n-\n-    static Object[][] testArgs() {\n-        return new Object[][]{\n-                {HTTP_1_1, false},\n-                {HTTP_1_1, true},\n-                {HTTP_2, false},\n-                {HTTP_2, true},\n-                {HTTP_3, true}\n-        };\n-    }\n-\n-    @ParameterizedTest\n-    @MethodSource(\"testArgs\")\n-    void test(Version version, boolean secure) throws Exception {\n-\n-        \/\/ Create the server\n-        var sslContext = secure || HTTP_3.equals(version) ? new SimpleSSLContext().get() : null;\n-        try (var server = switch (version) {\n-            case HTTP_1_1, HTTP_2 -> HttpTestServer.create(version, sslContext);\n-            case HTTP_3 -> HttpTestServer.create(HTTP_3_URI_ONLY, sslContext);\n-        }) {\n-\n-            \/\/ Add the handler and start the server\n-            var serverHandlerPath = \"\/\" + BufferSize1Test.class.getSimpleName();\n-            server.addHandler(new HttpTestEchoHandler(), serverHandlerPath);\n-            server.start();\n-\n-            \/\/ Create the client\n-            try (var client = createClient(version, sslContext)) {\n-\n-                \/\/ Create the request with body to ensure that `ByteBuffer`s\n-                \/\/ will be used throughout the entire end-to-end interaction.\n-                byte[] requestBodyBytes = \"body\".repeat(1000).getBytes(StandardCharsets.US_ASCII);\n-                var request = createRequest(sslContext, server, serverHandlerPath, version, requestBodyBytes);\n-\n-                \/\/ Execute and verify the request.\n-                \/\/ Do it twice to cover code paths before and after a protocol upgrade.\n-                requestAndVerify(client, request, requestBodyBytes);\n-                requestAndVerify(client, request, requestBodyBytes);\n-\n-            }\n-\n-        }\n-\n-    }\n-\n-    private HttpClient createClient(Version version, SSLContext sslContext) {\n-        var clientBuilder = newClientBuilderForH3()\n-                .proxy(NO_PROXY)\n-                .version(version);\n-        if (sslContext != null) {\n-            clientBuilder.sslContext(sslContext);\n-        }\n-        return clientBuilder.build();\n-    }\n-\n-    private static HttpRequest createRequest(\n-            SSLContext sslContext,\n-            HttpTestServer server,\n-            String serverHandlerPath,\n-            Version version,\n-            byte[] requestBodyBytes) {\n-        var requestUri = URI.create(String.format(\n-                \"%s:\/\/%s%s\/x\",\n-                sslContext == null ? \"http\" : \"https\",\n-                server.serverAuthority(),\n-                serverHandlerPath));\n-        var requestBuilder = HttpRequest\n-                .newBuilder(requestUri)\n-                .version(version)\n-                .POST(HttpRequest.BodyPublishers.ofByteArray(requestBodyBytes));\n-        if (HTTP_3.equals(version)) {\n-            requestBuilder.setOption(H3_DISCOVERY, HTTP_3_URI_ONLY);\n-        }\n-        return requestBuilder.build();\n-    }\n-\n-    private static void requestAndVerify(HttpClient client, HttpRequest request, byte[] requestBodyBytes)\n-            throws IOException, InterruptedException {\n-        var response = client.send(request, HttpResponse.BodyHandlers.ofByteArray());\n-        if (response.statusCode() != 200) {\n-            throw new AssertionError(\"Was expecting status code 200, found: \" + response.statusCode());\n-        }\n-        byte[] responseBodyBytes = response.body();\n-        int mismatchIndex = Arrays.mismatch(requestBodyBytes, responseBodyBytes);\n-        assertTrue(\n-                mismatchIndex < 0,\n-                String.format(\n-                        \"Response body (%s bytes) mismatches the request body (%s bytes) at index %s!\",\n-                        responseBodyBytes.length, requestBodyBytes.length, mismatchIndex));\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/BufferSize1Test.java","additions":0,"deletions":158,"binary":false,"changes":158,"status":"deleted"},{"patch":"@@ -1,106 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.internal.net.http.common.Utils;\n-import org.junit.jupiter.api.BeforeAll;\n-import org.junit.jupiter.api.Test;\n-\n-import java.text.MessageFormat;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.logging.Handler;\n-import java.util.logging.LogRecord;\n-import java.util.logging.Logger;\n-\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-\n-\/*\n- * @test\n- * @bug 8367976\n- * @summary Verifies that the `jdk.httpclient.bufsize` system property is\n- *          clamped correctly\n- *\n- * @library \/test\/lib\n- *\n- * @comment `-Djdk.httpclient.HttpClient.log=errors` is needed to enable\n- *          logging and verify that invalid input gets logged\n- * @run junit\/othervm\n- *      -Djdk.httpclient.HttpClient.log=errors\n- *      -Djdk.httpclient.bufsize=-1\n- *      BufferSizePropertyClampTest\n- * @run junit\/othervm\n- *      -Djdk.httpclient.HttpClient.log=errors\n- *      -Djdk.httpclient.bufsize=0\n- *      BufferSizePropertyClampTest\n- * @run junit\/othervm\n- *      -Djdk.httpclient.HttpClient.log=errors\n- *      -Djdk.httpclient.bufsize=16385\n- *      BufferSizePropertyClampTest\n- *\/\n-\n-class BufferSizePropertyClampTest {\n-\n-    \/** Anchor to avoid the {@code Logger} instance get GC'ed *\/\n-    private static final Logger CLIENT_LOGGER =\n-            Logger.getLogger(\"jdk.httpclient.HttpClient\");\n-\n-    private static final List<String> CLIENT_LOGGER_MESSAGES =\n-            Collections.synchronizedList(new ArrayList<>());\n-\n-    @BeforeAll\n-    static void registerLoggerHandler() {\n-        CLIENT_LOGGER.addHandler(new Handler() {\n-\n-            @Override\n-            public void publish(LogRecord record) {\n-                var message = MessageFormat.format(record.getMessage(), record.getParameters());\n-                CLIENT_LOGGER_MESSAGES.add(message);\n-            }\n-\n-            @Override\n-            public void flush() {\n-                \/\/ Do nothing\n-            }\n-\n-            @Override\n-            public void close() {\n-                \/\/ Do nothing\n-            }\n-\n-        });\n-    }\n-\n-    @Test\n-    void test() {\n-        assertEquals(16384, Utils.BUFSIZE);\n-        assertEquals(\n-                1, CLIENT_LOGGER_MESSAGES.size(),\n-                \"Unexpected number of logger messages: \" + CLIENT_LOGGER_MESSAGES);\n-        var expectedMessage = \"ERROR: Property value for jdk.httpclient.bufsize=\" +\n-                System.getProperty(\"jdk.httpclient.bufsize\") +\n-                \" not in [1..16384]: using default=16384\";\n-        assertEquals(expectedMessage, CLIENT_LOGGER_MESSAGES.getFirst().replaceAll(\",\", \"\"));\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/BufferSizePropertyClampTest.java","additions":0,"deletions":106,"binary":false,"changes":106,"status":"deleted"},{"patch":"@@ -32,1 +32,1 @@\n- * @bug 8283544 8358942\n+ * @bug 8283544\n@@ -34,1 +34,0 @@\n- *          -Djdk.httpclient.allowRestrictedHeaders=content-length\n@@ -99,2 +98,2 @@\n-        testContentLengthServerH2.addHandler(new ContentLengthHandler(), BODY_PATH);\n-        testContentLengthServerH3.addHandler(new ContentLengthHandler(), BODY_PATH);\n+        testContentLengthServerH2.addHandler(new OptionalContentLengthHandler(), BODY_PATH);\n+        testContentLengthServerH3.addHandler(new OptionalContentLengthHandler(), BODY_PATH);\n@@ -167,7 +166,0 @@\n-    @DataProvider(name = \"h1body\")\n-    Object[][] h1body() {\n-        return new Object[][]{\n-                {HTTP_1_1, URI.create(testContentLengthURIH1 + BODY_PATH)}\n-        };\n-    }\n-\n@@ -197,29 +189,0 @@\n-    @Test(dataProvider = \"nobodies\")\n-    \/\/ A GET request with empty request body should have no Content-length header\n-    public void getWithEmptyBody(Version version, URI uri) throws IOException, InterruptedException {\n-        testLog.println(version + \" Checking GET with no request body\");\n-        HttpRequest req = HttpRequest.newBuilder()\n-                .version(version)\n-                .method(\"GET\", HttpRequest.BodyPublishers.noBody())\n-                .uri(uri)\n-                .build();\n-        HttpResponse<String> resp = hc.send(req, HttpResponse.BodyHandlers.ofString(UTF_8));\n-        assertEquals(resp.statusCode(), 200, resp.body());\n-        assertEquals(resp.version(), version);\n-    }\n-\n-    @Test(dataProvider = \"bodies\")\n-    \/\/ A GET request with empty request body and explicitly added Content-length header\n-    public void getWithZeroContentLength(Version version, URI uri) throws IOException, InterruptedException {\n-        testLog.println(version + \" Checking GET with no request body\");\n-        HttpRequest req = HttpRequest.newBuilder()\n-                .version(version)\n-                .method(\"GET\", HttpRequest.BodyPublishers.noBody())\n-                .header(\"Content-length\", \"0\")\n-                .uri(uri)\n-                .build();\n-        HttpResponse<String> resp = hc.send(req, HttpResponse.BodyHandlers.ofString(UTF_8));\n-        assertEquals(resp.statusCode(), 200, resp.body());\n-        assertEquals(resp.version(), version);\n-    }\n-\n@@ -255,14 +218,0 @@\n-    @Test(dataProvider = \"nobodies\")\n-    \/\/ A DELETE request with empty request body should have no Content-length header\n-    public void deleteWithEmptyBody(Version version, URI uri) throws IOException, InterruptedException {\n-        testLog.println(version + \" Checking DELETE with no request body\");\n-        HttpRequest req = HttpRequest.newBuilder()\n-                .version(version)\n-                .method(\"DELETE\", HttpRequest.BodyPublishers.noBody())\n-                .uri(uri)\n-                .build();\n-        HttpResponse<String> resp = hc.send(req, HttpResponse.BodyHandlers.ofString(UTF_8));\n-        assertEquals(resp.statusCode(), 200, resp.body());\n-        assertEquals(resp.version(), version);\n-    }\n-\n@@ -298,14 +247,0 @@\n-    @Test(dataProvider = \"nobodies\")\n-    \/\/ A HEAD request with empty request body should have no Content-length header\n-    public void headWithEmptyBody(Version version, URI uri) throws IOException, InterruptedException {\n-        testLog.println(version + \" Checking HEAD with no request body\");\n-        HttpRequest req = HttpRequest.newBuilder()\n-                .version(version)\n-                .method(\"HEAD\", HttpRequest.BodyPublishers.noBody())\n-                .uri(uri)\n-                .build();\n-        HttpResponse<String> resp = hc.send(req, HttpResponse.BodyHandlers.ofString(UTF_8));\n-        assertEquals(resp.statusCode(), 200, resp.body());\n-        assertEquals(resp.version(), version);\n-    }\n-\n@@ -329,60 +264,0 @@\n-    @Test(dataProvider = \"h1body\")\n-    \/\/ A POST request with empty request body should have a Content-length header\n-    \/\/ in HTTP\/1.1\n-    public void postWithEmptyBody(Version version, URI uri) throws IOException, InterruptedException {\n-        testLog.println(version + \" Checking POST with request body\");\n-        HttpRequest req = HttpRequest.newBuilder()\n-                .version(version)\n-                .method(\"POST\", HttpRequest.BodyPublishers.noBody())\n-                .uri(uri)\n-                .build();\n-        HttpResponse<String> resp = hc.send(req, HttpResponse.BodyHandlers.ofString(UTF_8));\n-        assertEquals(resp.statusCode(), 200, resp.body());\n-        assertEquals(resp.version(), version);\n-    }\n-\n-    @Test(dataProvider = \"bodies\")\n-    \/\/ A POST request with a request body should have a Content-length header\n-    \/\/ in HTTP\/1.1\n-    public void postWithBody(Version version, URI uri) throws IOException, InterruptedException {\n-        testLog.println(version + \" Checking POST with request body\");\n-        HttpRequest req = HttpRequest.newBuilder()\n-                .version(version)\n-                .POST(HttpRequest.BodyPublishers.ofString(\"POST Body\"))\n-                .uri(uri)\n-                .build();\n-        HttpResponse<String> resp = hc.send(req, HttpResponse.BodyHandlers.ofString(UTF_8));\n-        assertEquals(resp.statusCode(), 200, resp.body());\n-        assertEquals(resp.version(), version);\n-    }\n-\n-    @Test(dataProvider = \"h1body\")\n-    \/\/ A PUT request with empty request body should have a Content-length header\n-    \/\/ in HTTP\/1.1\n-    public void putWithEmptyBody(Version version, URI uri) throws IOException, InterruptedException {\n-        testLog.println(version + \" Checking PUT with request body\");\n-        HttpRequest req = HttpRequest.newBuilder()\n-                .version(version)\n-                .method(\"PUT\", HttpRequest.BodyPublishers.noBody())\n-                .uri(uri)\n-                .build();\n-        HttpResponse<String> resp = hc.send(req, HttpResponse.BodyHandlers.ofString(UTF_8));\n-        assertEquals(resp.statusCode(), 200, resp.body());\n-        assertEquals(resp.version(), version);\n-    }\n-\n-    @Test(dataProvider = \"bodies\")\n-    \/\/ A PUT request with a request body should have a Content-length header\n-    \/\/ in HTTP\/1.1\n-    public void putWithBody(Version version, URI uri) throws IOException, InterruptedException {\n-        testLog.println(version + \" Checking PUT with request body\");\n-        HttpRequest req = HttpRequest.newBuilder()\n-                .version(version)\n-                .PUT(HttpRequest.BodyPublishers.ofString(\"PUT Body\"))\n-                .uri(uri)\n-                .build();\n-        HttpResponse<String> resp = hc.send(req, HttpResponse.BodyHandlers.ofString(UTF_8));\n-        assertEquals(resp.statusCode(), 200, resp.body());\n-        assertEquals(resp.version(), version);\n-    }\n-\n@@ -452,0 +327,23 @@\n+\n+    \/**\n+     * A handler used for cases where the presence of a Content-Length\n+     * header is optional. If present, its value must match the number of\n+     * bytes sent in the request body.\n+     *\/\n+    static class OptionalContentLengthHandler implements HttpTestHandler {\n+\n+        @Override\n+        public void handle(HttpTestExchange exchange) throws IOException {\n+            testLog.println(\"OptionalContentLengthHandler: Received Headers \"\n+                    + exchange.getRequestHeaders().entrySet() +\n+                    \" from \" + exchange.getRequestMethod() + \" request.\");\n+            Optional<String> contentLength = exchange.getRequestHeaders().firstValue(\"Content-Length\");\n+\n+            \/\/ Check Content-length header was set\n+            if (contentLength.isPresent()) {\n+                handleResponse(Long.parseLong(contentLength.get()), exchange, \"Request completed\", 200);\n+            } else {\n+                handleResponse(-1, exchange, \"Request completed, no content length\", 200);\n+            }\n+        }\n+    }\n","filename":"test\/jdk\/java\/net\/httpclient\/ContentLengthHeaderTest.java","additions":26,"deletions":128,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+ * @run main\/othervm -Djdk.httpclient.bufsize=-1 OfByteArrayTest testInvalidBufferSize\n+ * @run main\/othervm -Djdk.httpclient.bufsize=0 OfByteArrayTest testInvalidBufferSize\n@@ -89,0 +91,1 @@\n+            case \"testInvalidBufferSize\" -> testInvalidBufferSize();\n@@ -102,0 +105,4 @@\n+    private static void testInvalidBufferSize() {\n+        assertThrows(IllegalArgumentException.class, () -> HttpRequest.BodyPublishers.ofByteArray(new byte[1]));\n+    }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpRequestBodyPublishers\/OfByteArrayTest.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @enablePreview\n@@ -31,1 +30,0 @@\n-import java.security.PEMDecoder;\n@@ -40,0 +38,2 @@\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.CRL;\n@@ -43,0 +43,1 @@\n+import java.io.ByteArrayInputStream;\n@@ -47,2 +48,0 @@\n-    private static final PEMDecoder pemDecoder = PEMDecoder.of();\n-\n@@ -96,1 +95,1 @@\n-    private static X509Certificate getTrustedCertificate() {\n+    private static X509Certificate getTrustedCertificate() throws Exception {\n@@ -108,1 +107,3 @@\n-        return pemDecoder.decode(sCert, X509Certificate.class);\n+        CertificateFactory certFactory = CertificateFactory.getInstance(\"X.509\");\n+        ByteArrayInputStream bytes = new ByteArrayInputStream(sCert.getBytes());\n+        return (X509Certificate)certFactory.generateCertificate(bytes);\n@@ -111,1 +112,1 @@\n-    private static X509Certificate getUserCertificate1() {\n+    private static X509Certificate getUserCertificate1() throws Exception {\n@@ -125,1 +126,3 @@\n-        return pemDecoder.decode(sCert, X509Certificate.class);\n+        CertificateFactory certFactory = CertificateFactory.getInstance(\"X.509\");\n+        ByteArrayInputStream bytes = new ByteArrayInputStream(sCert.getBytes());\n+        return (X509Certificate)certFactory.generateCertificate(bytes);\n@@ -128,1 +131,1 @@\n-    private static X509Certificate getUserCertificate2() {\n+    private static X509Certificate getUserCertificate2() throws Exception {\n@@ -140,1 +143,3 @@\n-        return pemDecoder.decode(sCert, X509Certificate.class);\n+        CertificateFactory certFactory = CertificateFactory.getInstance(\"X.509\");\n+        ByteArrayInputStream bytes = new ByteArrayInputStream(sCert.getBytes());\n+        return (X509Certificate)certFactory.generateCertificate(bytes);\n","filename":"test\/jdk\/java\/security\/cert\/CertPathBuilder\/NoExtensions.java","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2014, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n- * @enablePreview\n@@ -40,0 +39,1 @@\n+ * @author Xuelei Fan\n@@ -42,2 +42,3 @@\n-import java.security.DEREncodable;\n-import java.security.PEMDecoder;\n+import java.io.*;\n+import java.net.SocketException;\n+import java.util.*;\n@@ -45,16 +46,2 @@\n-import java.security.cert.CertPathBuilder;\n-import java.security.cert.CertStore;\n-import java.security.cert.Certificate;\n-import java.security.cert.CollectionCertStoreParameters;\n-import java.security.cert.PKIXBuilderParameters;\n-import java.security.cert.PKIXCertPathBuilderResult;\n-import java.security.cert.TrustAnchor;\n-import java.security.cert.X509CRL;\n-import java.security.cert.X509CertSelector;\n-import java.security.cert.X509Certificate;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.HashSet;\n-import java.util.Set;\n-\n+import java.security.cert.*;\n+import java.security.cert.CertPathValidatorException.BasicReason;\n@@ -199,1 +186,4 @@\n-    private static final PEMDecoder pemDecoder = PEMDecoder.of();\n+    private static Set<TrustAnchor> generateTrustAnchors()\n+            throws CertificateException {\n+        \/\/ generate certificate from cert string\n+        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n@@ -201,2 +191,3 @@\n-    private static Set<TrustAnchor> generateTrustAnchors() {\n-        X509Certificate selfSignedCert = pemDecoder.decode(selfSignedCertStr, X509Certificate.class);\n+        ByteArrayInputStream is =\n+                    new ByteArrayInputStream(selfSignedCertStr.getBytes());\n+        Certificate selfSignedCert = cf.generateCertificate(is);\n@@ -206,1 +197,1 @@\n-            new TrustAnchor(selfSignedCert, null);\n+            new TrustAnchor((X509Certificate)selfSignedCert, null);\n@@ -212,0 +203,4 @@\n+        Collection entries = new HashSet();\n+\n+        \/\/ generate certificate from certificate string\n+        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n@@ -213,1 +208,1 @@\n-        Collection<DEREncodable> entries = new HashSet<>();\n+        ByteArrayInputStream is;\n@@ -215,1 +210,2 @@\n-        DEREncodable cert = pemDecoder.decode(targetCertStr, X509Certificate.class);\n+        is = new ByteArrayInputStream(targetCertStr.getBytes());\n+        Certificate cert = cf.generateCertificate(is);\n@@ -218,1 +214,2 @@\n-        cert = pemDecoder.decode(subCaCertStr, X509Certificate.class);\n+        is = new ByteArrayInputStream(subCaCertStr.getBytes());\n+        cert = cf.generateCertificate(is);\n@@ -221,1 +218,2 @@\n-        cert = pemDecoder.decode(selfSignedCertStr, X509Certificate.class);\n+        is = new ByteArrayInputStream(selfSignedCertStr.getBytes());\n+        cert = cf.generateCertificate(is);\n@@ -224,1 +222,2 @@\n-        cert = pemDecoder.decode(topCrlIssuerCertStr, X509Certificate.class);\n+        is = new ByteArrayInputStream(topCrlIssuerCertStr.getBytes());\n+        cert = cf.generateCertificate(is);\n@@ -227,1 +226,2 @@\n-        cert = pemDecoder.decode(subCrlIssuerCertStr, X509Certificate.class);\n+        is = new ByteArrayInputStream(subCrlIssuerCertStr.getBytes());\n+        cert = cf.generateCertificate(is);\n@@ -231,2 +231,3 @@\n-        DEREncodable mixes = pemDecoder.decode(topCrlStr, X509CRL.class);\n-        entries.add(mixes);\n+        is = new ByteArrayInputStream(topCrlStr.getBytes());\n+        Collection mixes = cf.generateCRLs(is);\n+        entries.addAll(mixes);\n@@ -234,2 +235,3 @@\n-        mixes = pemDecoder.decode(subCrlStr, X509CRL.class);\n-        entries.add(mixes);\n+        is = new ByteArrayInputStream(subCrlStr.getBytes());\n+        mixes = cf.generateCRLs(is);\n+        entries.addAll(mixes);\n@@ -238,1 +240,1 @@\n-                new CollectionCertStoreParameters(entries));\n+                            new CollectionCertStoreParameters(entries));\n@@ -246,1 +248,2 @@\n-        String cert;\n+        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+        ByteArrayInputStream is = null;\n@@ -248,1 +251,1 @@\n-            cert = subCaCertStr;\n+            is = new ByteArrayInputStream(subCaCertStr.getBytes());\n@@ -250,1 +253,1 @@\n-            cert = subCrlIssuerCertStr;\n+            is = new ByteArrayInputStream(subCrlIssuerCertStr.getBytes());\n@@ -252,1 +255,1 @@\n-            cert = targetCertStr;\n+            is = new ByteArrayInputStream(targetCertStr.getBytes());\n@@ -255,1 +258,1 @@\n-        X509Certificate target = pemDecoder.decode(cert, X509Certificate.class);\n+        X509Certificate target = (X509Certificate)cf.generateCertificate(is);\n@@ -269,1 +272,3 @@\n-    private static boolean match(String name, Certificate cert) {\n+    private static boolean match(String name, Certificate cert)\n+                throws Exception {\n+        X509CertSelector selector = new X509CertSelector();\n@@ -272,1 +277,2 @@\n-        String newCert;\n+        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+        ByteArrayInputStream is = null;\n@@ -274,1 +280,1 @@\n-            newCert = subCaCertStr;\n+            is = new ByteArrayInputStream(subCaCertStr.getBytes());\n@@ -276,1 +282,1 @@\n-            newCert = subCrlIssuerCertStr;\n+            is = new ByteArrayInputStream(subCrlIssuerCertStr.getBytes());\n@@ -278,1 +284,1 @@\n-            newCert = targetCertStr;\n+            is = new ByteArrayInputStream(targetCertStr.getBytes());\n@@ -280,1 +286,1 @@\n-        X509Certificate target = pemDecoder.decode(newCert, X509Certificate.class);\n+        X509Certificate target = (X509Certificate)cf.generateCertificate(is);\n","filename":"test\/jdk\/java\/security\/cert\/CertPathBuilder\/selfIssued\/StatusLoopDependency.java","additions":52,"deletions":46,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2014, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n- * @enablePreview\n@@ -40,2 +39,3 @@\n-import java.security.DEREncodable;\n-import java.security.PEMDecoder;\n+import java.io.*;\n+import java.net.SocketException;\n+import java.util.*;\n@@ -43,3 +43,1 @@\n-import java.security.cert.CertPath;\n-import java.security.cert.CertPathValidator;\n-import java.security.cert.CertPathValidatorException;\n+import java.security.cert.*;\n@@ -47,16 +45,0 @@\n-import java.security.cert.CertStore;\n-import java.security.cert.Certificate;\n-import java.security.cert.CertificateException;\n-import java.security.cert.CertificateFactory;\n-import java.security.cert.CollectionCertStoreParameters;\n-import java.security.cert.PKIXParameters;\n-import java.security.cert.TrustAnchor;\n-import java.security.cert.X509CRL;\n-import java.security.cert.X509Certificate;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Set;\n@@ -170,2 +152,0 @@\n-    private static final PEMDecoder pemDecoder = PEMDecoder.of();\n-\n@@ -177,3 +157,10 @@\n-        Certificate targetCert = pemDecoder.decode(targetCertStr, X509Certificate.class);\n-        Certificate subCaCert =  pemDecoder.decode(subCaCertStr, X509Certificate.class);\n-        Certificate selfSignedCert = pemDecoder.decode(selfSignedCertStr, X509Certificate.class);\n+        ByteArrayInputStream is;\n+\n+        is = new ByteArrayInputStream(targetCertStr.getBytes());\n+        Certificate targetCert = cf.generateCertificate(is);\n+\n+        is = new ByteArrayInputStream(subCaCertStr.getBytes());\n+        Certificate subCaCert = cf.generateCertificate(is);\n+\n+        is = new ByteArrayInputStream(selfSignedCertStr.getBytes());\n+        Certificate selfSignedCert = cf.generateCertificate(is);\n@@ -182,1 +169,2 @@\n-        List<Certificate> list = Arrays.asList(targetCert, subCaCert, selfSignedCert);\n+        List<Certificate> list = Arrays.asList(new Certificate[] {\n+                        targetCert, subCaCert, selfSignedCert});\n@@ -190,0 +178,1 @@\n+        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n@@ -191,1 +180,3 @@\n-        final X509Certificate selfSignedCert = pemDecoder.decode(selfSignedCertStr, X509Certificate.class);\n+        ByteArrayInputStream is =\n+                    new ByteArrayInputStream(selfSignedCertStr.getBytes());\n+        Certificate selfSignedCert = cf.generateCertificate(is);\n@@ -195,1 +186,1 @@\n-            new TrustAnchor(selfSignedCert, null);\n+            new TrustAnchor((X509Certificate)selfSignedCert, null);\n@@ -201,1 +192,1 @@\n-        Collection<DEREncodable> entries = new HashSet<>();\n+        Collection entries = new HashSet();\n@@ -204,0 +195,1 @@\n+        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n@@ -205,2 +197,4 @@\n-        DEREncodable mixes = pemDecoder.decode(topCrlStr, X509CRL.class);\n-        entries.add(mixes);\n+        ByteArrayInputStream is =\n+                    new ByteArrayInputStream(topCrlStr.getBytes());\n+        Collection mixes = cf.generateCRLs(is);\n+        entries.addAll(mixes);\n@@ -208,2 +202,3 @@\n-        mixes = pemDecoder.decode(subCrlStr, X509CRL.class);\n-        entries.add(mixes);\n+        is = new ByteArrayInputStream(subCrlStr.getBytes());\n+        mixes = cf.generateCRLs(is);\n+        entries.addAll(mixes);\n@@ -212,2 +207,3 @@\n-        mixes = pemDecoder.decode(topCrlIssuerCertStr, X509Certificate.class);\n-        entries.add(mixes);\n+        is = new ByteArrayInputStream(topCrlIssuerCertStr.getBytes());\n+        mixes = cf.generateCertificates(is);\n+        entries.addAll(mixes);\n@@ -215,2 +211,3 @@\n-        mixes = pemDecoder.decode(subCrlIssuerCertStr, X509Certificate.class);\n-        entries.add(mixes);\n+        is = new ByteArrayInputStream(subCrlIssuerCertStr.getBytes());\n+        mixes = cf.generateCertificates(is);\n+        entries.addAll(mixes);\n","filename":"test\/jdk\/java\/security\/cert\/CertPathValidator\/indirectCRL\/CircularCRLTwoLevel.java","additions":37,"deletions":40,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2014, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n- * @enablePreview\n@@ -40,2 +39,3 @@\n-import java.security.DEREncodable;\n-import java.security.PEMDecoder;\n+import java.io.*;\n+import java.net.SocketException;\n+import java.util.*;\n@@ -43,3 +43,1 @@\n-import java.security.cert.CertPath;\n-import java.security.cert.CertPathValidator;\n-import java.security.cert.CertPathValidatorException;\n+import java.security.cert.*;\n@@ -47,16 +45,0 @@\n-import java.security.cert.CertStore;\n-import java.security.cert.Certificate;\n-import java.security.cert.CertificateException;\n-import java.security.cert.CertificateFactory;\n-import java.security.cert.CollectionCertStoreParameters;\n-import java.security.cert.PKIXParameters;\n-import java.security.cert.TrustAnchor;\n-import java.security.cert.X509CRL;\n-import java.security.cert.X509Certificate;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Set;\n@@ -171,2 +153,0 @@\n-    private static final PEMDecoder pemDecoder = PEMDecoder.of();\n-\n@@ -178,3 +158,10 @@\n-        Certificate targetCert = pemDecoder.decode(targetCertStr, X509Certificate.class);\n-        Certificate subCaCert = pemDecoder.decode(subCaCertStr, X509Certificate.class);\n-        Certificate selfSignedCert = pemDecoder.decode(selfSignedCertStr, X509Certificate.class);\n+        ByteArrayInputStream is;\n+\n+        is = new ByteArrayInputStream(targetCertStr.getBytes());\n+        Certificate targetCert = cf.generateCertificate(is);\n+\n+        is = new ByteArrayInputStream(subCaCertStr.getBytes());\n+        Certificate subCaCert = cf.generateCertificate(is);\n+\n+        is = new ByteArrayInputStream(selfSignedCertStr.getBytes());\n+        Certificate selfSignedCert = cf.generateCertificate(is);\n@@ -183,1 +170,2 @@\n-        List<Certificate> list = Arrays.asList(targetCert, subCaCert, selfSignedCert);\n+        List<Certificate> list = Arrays.asList(new Certificate[] {\n+                        targetCert, subCaCert, selfSignedCert});\n@@ -191,1 +179,5 @@\n-        final X509Certificate selfSignedCert = pemDecoder.decode(selfSignedCertStr, X509Certificate.class);\n+        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+\n+        ByteArrayInputStream is =\n+                    new ByteArrayInputStream(selfSignedCertStr.getBytes());\n+        Certificate selfSignedCert = cf.generateCertificate(is);\n@@ -195,1 +187,1 @@\n-            new TrustAnchor(selfSignedCert, null);\n+            new TrustAnchor((X509Certificate)selfSignedCert, null);\n@@ -201,1 +193,1 @@\n-        Collection<DEREncodable> entries = new HashSet<>();\n+        Collection entries = new HashSet();\n@@ -206,2 +198,4 @@\n-        DEREncodable mixes = pemDecoder.decode(topCrlStr, X509CRL.class);\n-        entries.add(mixes);\n+        ByteArrayInputStream is =\n+                    new ByteArrayInputStream(topCrlStr.getBytes());\n+        Collection mixes = cf.generateCRLs(is);\n+        entries.addAll(mixes);\n@@ -209,2 +203,3 @@\n-        mixes = pemDecoder.decode(subCrlStr, X509CRL.class);\n-        entries.add(mixes);\n+        is = new ByteArrayInputStream(subCrlStr.getBytes());\n+        mixes = cf.generateCRLs(is);\n+        entries.addAll(mixes);\n@@ -213,2 +208,3 @@\n-        mixes = pemDecoder.decode(topCrlIssuerCertStr, X509Certificate.class);\n-        entries.add(mixes);\n+        is = new ByteArrayInputStream(topCrlIssuerCertStr.getBytes());\n+        mixes = cf.generateCertificates(is);\n+        entries.addAll(mixes);\n@@ -216,2 +212,3 @@\n-        mixes = pemDecoder.decode(subCrlIssuerCertStr, X509Certificate.class);\n-        entries.add(mixes);\n+        is = new ByteArrayInputStream(subCrlIssuerCertStr.getBytes());\n+        mixes = cf.generateCertificates(is);\n+        entries.addAll(mixes);\n@@ -220,1 +217,1 @@\n-                new CollectionCertStoreParameters(entries));\n+                            new CollectionCertStoreParameters(entries));\n","filename":"test\/jdk\/java\/security\/cert\/CertPathValidator\/indirectCRL\/CircularCRLTwoLevelRevoked.java","additions":38,"deletions":41,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,2 +74,0 @@\n-import static org.testng.Assert.assertNotEquals;\n-import static org.testng.Assert.assertThrows;\n@@ -120,38 +118,0 @@\n-    @Test\n-    public void test_min() {\n-        assertEquals(Duration.MIN.getSeconds(), Long.MIN_VALUE);\n-        assertEquals(Duration.MIN.getNano(), 0);\n-        \/\/ no duration minimally less than MIN\n-        assertThrows(ArithmeticException.class, () -> Duration.MIN.minusNanos(1));\n-    }\n-\n-    @Test\n-    public void test_max() {\n-        assertEquals(Duration.MAX.getSeconds(), Long.MAX_VALUE);\n-        assertEquals(Duration.MAX.getNano(), 999_999_999);\n-        \/\/ no duration minimally greater than MAX\n-        assertThrows(ArithmeticException.class, () -> Duration.MAX.plusNanos(1));\n-    }\n-\n-    @Test\n-    public void test_constant_properties() {\n-        assertTrue(Duration.MIN.compareTo(Duration.MIN) == 0);\n-        assertEquals(Duration.MIN, Duration.MIN);\n-        assertTrue(Duration.ZERO.compareTo(Duration.ZERO) == 0);\n-        assertEquals(Duration.ZERO, Duration.ZERO);\n-        assertTrue(Duration.MAX.compareTo(Duration.MAX) == 0);\n-        assertEquals(Duration.MAX, Duration.MAX);\n-\n-        assertTrue(Duration.MIN.compareTo(Duration.ZERO) < 0);\n-        assertTrue(Duration.ZERO.compareTo(Duration.MIN) > 0);\n-        assertNotEquals(Duration.ZERO, Duration.MIN);\n-\n-        assertTrue(Duration.ZERO.compareTo(Duration.MAX) < 0);\n-        assertTrue(Duration.MAX.compareTo(Duration.ZERO) > 0);\n-        assertNotEquals(Duration.ZERO, Duration.MAX);\n-\n-        assertTrue(Duration.MIN.compareTo(Duration.MAX) < 0);\n-        assertTrue(Duration.MAX.compareTo(Duration.MIN) > 0);\n-        assertNotEquals(Duration.MIN, Duration.MAX);\n-    }\n-\n","filename":"test\/jdk\/java\/time\/tck\/java\/time\/TCKDuration.java","additions":1,"deletions":41,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.nio.charset.StandardCharsets;\n@@ -36,0 +35,2 @@\n+import java.util.ArrayList;\n+import java.util.Arrays;\n@@ -49,5 +50,0 @@\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertNotNull;\n-import static org.junit.jupiter.api.Assertions.assertNull;\n-import static org.junit.jupiter.api.Assertions.assertThrows;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -56,1 +52,1 @@\n-\/*\n+\/**\n@@ -60,1 +56,0 @@\n- *      8369590\n@@ -63,0 +58,1 @@\n+ * @compile LocaleEnhanceTest.java\n@@ -67,0 +63,7 @@\n+    public LocaleEnhanceTest() {\n+    }\n+\n+    \/\/\/\n+    \/\/\/ Generic sanity tests\n+    \/\/\/\n+\n@@ -79,4 +82,0 @@\n-    \/\/\/\n-    \/\/\/ Generic sanity tests\n-    \/\/\/\n-\n@@ -128,6 +127,6 @@\n-                assertEquals(idl, l.getLanguage(), msg + \"language\");\n-                assertEquals(ids, l.getScript(), msg + \"script\");\n-                assertEquals(idc, l.getCountry(), msg + \"country\");\n-                assertEquals(idv, l.getVariant(), msg + \"variant\");\n-                assertEquals(tag, l.toLanguageTag(), msg + \"tag\");\n-                assertEquals(id, l.toString(), msg + \"id\");\n+                assertEquals(msg + \"language\", idl, l.getLanguage());\n+                assertEquals(msg + \"script\", ids, l.getScript());\n+                assertEquals(msg + \"country\", idc, l.getCountry());\n+                assertEquals(msg + \"variant\", idv, l.getVariant());\n+                assertEquals(msg + \"tag\", tag, l.toLanguageTag());\n+                assertEquals(msg + \"id\", id, l.toString());\n@@ -185,4 +184,4 @@\n-                assertEquals(idl, l.getLanguage(), msg + \" language\");\n-                assertEquals(ids, l.getScript(), msg + \" script\");\n-                assertEquals(idc, l.getCountry(), msg + \" country\");\n-                assertEquals(idv, l.getVariant(), msg + \" variant\");\n+                assertEquals(msg + \" language\", idl, l.getLanguage());\n+                assertEquals(msg + \" script\", ids, l.getScript());\n+                assertEquals(msg + \" country\", idc, l.getCountry());\n+                assertEquals(msg + \" variant\", idv, l.getVariant());\n@@ -190,2 +189,2 @@\n-                assertEquals(tag, l.toLanguageTag(), msg + \"tag\");\n-                assertEquals(id, l.toString(), msg + \"id\");\n+                assertEquals(msg + \"tag\", tag, l.toLanguageTag());\n+                assertEquals(msg + \"id\", id, l.toString());\n@@ -239,1 +238,1 @@\n-            assertEquals(\"und\", l.toLanguageTag(), id);\n+            assertEquals(id, \"und\", l.toLanguageTag());\n@@ -259,1 +258,1 @@\n-                assertEquals(target, tagResult, \"tagResult\");\n+                assertEquals(\"tagResult\", target, tagResult);\n@@ -266,1 +265,1 @@\n-                assertEquals(target, builderResult, \"builderResult\");\n+                assertEquals(\"builderResult\", target, builderResult);\n@@ -279,1 +278,1 @@\n-                    StandardCharsets.UTF_8));\n+                \"UTF-8\"));\n@@ -283,1 +282,1 @@\n-            assertEquals(id, result.toLanguageTag(), \"ulocale\");\n+            assertEquals(\"ulocale\", id, result.toLanguageTag());\n@@ -295,20 +294,20 @@\n-                \/\/ language to lower case, region to upper, variant unchanged\n-                \/\/ short\n-                {\"X\", \"y\", \"z\", \"x\", \"Y\"},\n-                \/\/ long\n-                {\"xXxXxXxXxXxX\", \"yYyYyYyYyYyYyYyY\", \"zZzZzZzZzZzZzZzZ\",\n-                        \"xxxxxxxxxxxx\", \"YYYYYYYYYYYYYYYY\"},\n-                \/\/ mapped language ids\n-                {\"he\", \"IL\", \"\", \"he\"},\n-                {\"iw\", \"IL\", \"\", \"he\"},\n-                {\"yi\", \"DE\", \"\", \"yi\"},\n-                {\"ji\", \"DE\", \"\", \"yi\"},\n-                {\"id\", \"ID\", \"\", \"id\"},\n-                {\"in\", \"ID\", \"\", \"id\"},\n-                \/\/ special variants\n-                {\"ja\", \"JP\", \"JP\"},\n-                {\"th\", \"TH\", \"TH\"},\n-                {\"no\", \"NO\", \"NY\"},\n-                {\"no\", \"NO\", \"NY\"},\n-                \/\/ no canonicalization of 3-letter language codes\n-                {\"eng\", \"US\", \"\"}\n+            \/\/ language to lower case, region to upper, variant unchanged\n+            \/\/ short\n+            { \"X\", \"y\", \"z\", \"x\", \"Y\" },\n+            \/\/ long\n+            { \"xXxXxXxXxXxX\", \"yYyYyYyYyYyYyYyY\", \"zZzZzZzZzZzZzZzZ\",\n+              \"xxxxxxxxxxxx\", \"YYYYYYYYYYYYYYYY\" },\n+            \/\/ mapped language ids\n+            { \"he\", \"IL\", \"\", \"he\" },\n+            { \"iw\", \"IL\", \"\", \"he\" },\n+            { \"yi\", \"DE\", \"\", \"yi\" },\n+            { \"ji\", \"DE\", \"\", \"yi\" },\n+            { \"id\", \"ID\", \"\", \"id\" },\n+            { \"in\", \"ID\", \"\", \"id\" },\n+            \/\/ special variants\n+            { \"ja\", \"JP\", \"JP\" },\n+            { \"th\", \"TH\", \"TH\" },\n+            { \"no\", \"NO\", \"NY\" },\n+            { \"no\", \"NO\", \"NY\" },\n+            \/\/ no canonicalization of 3-letter language codes\n+            { \"eng\", \"US\", \"\" }\n@@ -316,1 +315,1 @@\n-        for (int i = 0; i < tests.length; ++i) {\n+        for (int i = 0; i < tests.length; ++ i) {\n@@ -320,3 +319,3 @@\n-            assertEquals(test.length > 3 ? test[3] : test[0], locale.getLanguage(), id + \" lang\");\n-            assertEquals(test.length > 4 ? test[4] : test[1], locale.getCountry(), id + \" region\");\n-            assertEquals(test.length > 5 ? test[5] : test[2], locale.getVariant(), id + \" variant\");\n+            assertEquals(id + \" lang\", test.length > 3 ? test[3] : test[0], locale.getLanguage());\n+            assertEquals(id + \" region\", test.length > 4 ? test[4] : test[1], locale.getCountry());\n+            assertEquals(id + \" variant\", test.length > 5 ? test[5] : test[2], locale.getVariant());\n@@ -327,1 +326,1 @@\n-    \/\/\/ Locale API Tests\n+    \/\/\/ Locale API tests.\n@@ -334,1 +333,1 @@\n-        assertEquals(\"Latn\", locale.getScript(), \"forLanguageTag\");\n+        assertEquals(\"forLanguageTag\", \"Latn\", locale.getScript());\n@@ -338,1 +337,1 @@\n-        assertEquals(\"Latn\", locale.getScript(), \"builder\");\n+        assertEquals(\"builder\", \"Latn\", locale.getScript());\n@@ -342,1 +341,1 @@\n-        assertEquals(\"\", locale.getScript(), \"script is empty string\");\n+        assertEquals(\"script is empty string\", \"\", locale.getScript());\n@@ -349,1 +348,1 @@\n-        assertNull(locale.getExtension('a'), \"some_ex-tension\");\n+        assertEquals(\"some_ex-tension\", null, locale.getExtension('a'));\n@@ -353,1 +352,1 @@\n-        assertEquals(\"some-ex-tension\", locale.getExtension('a'), \"builder\");\n+        assertEquals(\"builder\", \"some-ex-tension\", locale.getExtension('a'));\n@@ -356,1 +355,1 @@\n-        assertNull(locale.getExtension('b'), \"empty b\");\n+        assertEquals(\"empty b\", null, locale.getExtension('b'));\n@@ -359,1 +358,1 @@\n-        assertThrows(IllegalArgumentException.class, () -> Locale.forLanguageTag(\"\").getExtension('\\uD800'));\n+        new ExpectIAE() { public void call() { Locale.forLanguageTag(\"\").getExtension('\\uD800'); }};\n@@ -363,1 +362,1 @@\n-        assertEquals(\"y-z-blork\", locale.getExtension('x'), \"x\");\n+        assertEquals(\"x\", \"y-z-blork\", locale.getExtension('x'));\n@@ -370,2 +369,2 @@\n-        assertEquals(2, result.size(), \"result size\");\n-        assertTrue(result.contains('a') && result.contains('b'), \"'a','b'\");\n+        assertEquals(\"result size\", 2, result.size());\n+        assertTrue(\"'a','b'\", result.contains('a') && result.contains('b'));\n@@ -374,1 +373,7 @@\n-        assertThrows(UnsupportedOperationException.class, () -> result.add('x'));\n+        try {\n+            result.add('x');\n+            fail(\"expected exception on add to extension key set\");\n+        }\n+        catch (UnsupportedOperationException e) {\n+            \/\/ ok\n+        }\n@@ -378,1 +383,1 @@\n-        assertTrue(locale.getExtensionKeys().isEmpty(), \"empty result\");\n+        assertTrue(\"empty result\", locale.getExtensionKeys().isEmpty());\n@@ -385,3 +390,3 @@\n-        assertEquals(2, attributes.size(), \"number of attributes\");\n-        assertTrue(attributes.contains(\"abc\"), \"attribute abc\");\n-        assertTrue(attributes.contains(\"def\"), \"attribute def\");\n+        assertEquals(\"number of attributes\", 2, attributes.size());\n+        assertTrue(\"attribute abc\", attributes.contains(\"abc\"));\n+        assertTrue(\"attribute def\", attributes.contains(\"def\"));\n@@ -391,1 +396,1 @@\n-        assertTrue(attributes.isEmpty(), \"empty attributes\");\n+        assertTrue(\"empty attributes\", attributes.isEmpty());\n@@ -397,2 +402,2 @@\n-        assertEquals(\"japanese\", locale.getUnicodeLocaleType(\"co\"), \"collation\");\n-        assertEquals(\"thai\", locale.getUnicodeLocaleType(\"nu\"), \"numbers\");\n+        assertEquals(\"collation\", \"japanese\", locale.getUnicodeLocaleType(\"co\"));\n+        assertEquals(\"numbers\", \"thai\", locale.getUnicodeLocaleType(\"nu\"));\n@@ -401,1 +406,1 @@\n-        assertEquals(\"japanese\", locale.getUnicodeLocaleType(\"Co\"), \"key case\");\n+        assertEquals(\"key case\", \"japanese\", locale.getUnicodeLocaleType(\"Co\"));\n@@ -404,1 +409,1 @@\n-        assertNull(locale.getUnicodeLocaleType(\"xx\"), \"locale keyword not present\");\n+        assertEquals(\"locale keyword not present\", null, locale.getUnicodeLocaleType(\"xx\"));\n@@ -408,1 +413,1 @@\n-        assertNull(locale.getUnicodeLocaleType(\"co\"), \"locale extension not present\");\n+        assertEquals(\"locale extension not present\", null, locale.getUnicodeLocaleType(\"co\"));\n@@ -412,1 +417,1 @@\n-        assertEquals(\"\", locale.getUnicodeLocaleType(\"kn\"), \"typeless keyword\");\n+        assertEquals(\"typeless keyword\", \"\", locale.getUnicodeLocaleType(\"kn\"));\n@@ -415,2 +420,2 @@\n-        assertThrows(IllegalArgumentException.class, () -> Locale.forLanguageTag(\"\").getUnicodeLocaleType(\"q\"));\n-        assertThrows(IllegalArgumentException.class, () -> Locale.forLanguageTag(\"\").getUnicodeLocaleType(\"abcdefghi\"));\n+        new ExpectIAE() { public void call() { Locale.forLanguageTag(\"\").getUnicodeLocaleType(\"q\"); }};\n+        new ExpectIAE() { public void call() { Locale.forLanguageTag(\"\").getUnicodeLocaleType(\"abcdefghi\"); }};\n@@ -419,1 +424,1 @@\n-        assertThrows(NullPointerException.class, () -> Locale.forLanguageTag(\"\").getUnicodeLocaleType(null));\n+        new ExpectNPE() { public void call() { Locale.forLanguageTag(\"\").getUnicodeLocaleType(null); }};\n@@ -426,2 +431,2 @@\n-        assertEquals(2, result.size(), \"two keys\");\n-        assertTrue(result.contains(\"co\") && result.contains(\"nu\"), \"co and nu\");\n+        assertEquals(\"two keys\", 2, result.size());\n+        assertTrue(\"co and nu\", result.contains(\"co\") && result.contains(\"nu\"));\n@@ -430,1 +435,7 @@\n-        assertThrows(UnsupportedOperationException.class, () -> result.add(\"frobozz\"));\n+        try {\n+            result.add(\"frobozz\");\n+            fail(\"expected exception when add to locale key set\");\n+        }\n+        catch (UnsupportedOperationException e) {\n+            \/\/ ok\n+        }\n@@ -436,1 +447,1 @@\n-        assertEquals(\"y-x-blork\", locale.getExtension(Locale.PRIVATE_USE_EXTENSION), \"blork\");\n+        assertEquals(\"blork\", \"y-x-blork\", locale.getExtension(Locale.PRIVATE_USE_EXTENSION));\n@@ -439,1 +450,1 @@\n-        assertNull(locale.getExtension(Locale.PRIVATE_USE_EXTENSION), \"no privateuse\");\n+        assertEquals(\"no privateuse\", null, locale.getExtension(Locale.PRIVATE_USE_EXTENSION));\n@@ -447,36 +458,36 @@\n-                \/\/ empty locale canonicalizes to 'und'\n-                {\"\", \"\", \"\", \"und\"},\n-                \/\/ variant alone is not a valid Locale, but has a valid language tag\n-                {\"\", \"\", \"NewYork\", \"und-NewYork\"},\n-                \/\/ standard valid locales\n-                {\"\", \"Us\", \"\", \"und-US\"},\n-                {\"\", \"US\", \"NewYork\", \"und-US-NewYork\"},\n-                {\"EN\", \"\", \"\", \"en\"},\n-                {\"EN\", \"\", \"NewYork\", \"en-NewYork\"},\n-                {\"EN\", \"US\", \"\", \"en-US\"},\n-                {\"EN\", \"US\", \"NewYork\", \"en-US-NewYork\"},\n-                \/\/ underscore in variant will be emitted as multiple variant subtags\n-                {\"en\", \"US\", \"Newer_Yorker\", \"en-US-Newer-Yorker\"},\n-                \/\/ invalid variant subtags are appended as private use\n-                {\"en\", \"US\", \"new_yorker\", \"en-US-x-lvariant-new-yorker\"},\n-                \/\/ the first invalid variant subtags and following variant subtags are appended as private use\n-                {\"en\", \"US\", \"Windows_XP_Home\", \"en-US-Windows-x-lvariant-XP-Home\"},\n-                \/\/ too long variant and following variant subtags disappear\n-                {\"en\", \"US\", \"WindowsVista_SP2\", \"en-US\"},\n-                \/\/ invalid region subtag disappears\n-                {\"en\", \"USA\", \"\", \"en\"},\n-                \/\/ invalid language tag disappears\n-                {\"e\", \"US\", \"\", \"und-US\"},\n-                \/\/ three-letter language tags are not canonicalized\n-                {\"Eng\", \"\", \"\", \"eng\"},\n-                \/\/ legacy languages canonicalize to modern equivalents\n-                {\"he\", \"IL\", \"\", \"he-IL\"},\n-                {\"iw\", \"IL\", \"\", \"he-IL\"},\n-                {\"yi\", \"DE\", \"\", \"yi-DE\"},\n-                {\"ji\", \"DE\", \"\", \"yi-DE\"},\n-                {\"id\", \"ID\", \"\", \"id-ID\"},\n-                {\"in\", \"ID\", \"\", \"id-ID\"},\n-                \/\/ special values are converted on output\n-                {\"ja\", \"JP\", \"JP\", \"ja-JP-u-ca-japanese-x-lvariant-JP\"},\n-                {\"th\", \"TH\", \"TH\", \"th-TH-u-nu-thai-x-lvariant-TH\"},\n-                {\"no\", \"NO\", \"NY\", \"nn-NO\"}\n+            \/\/ empty locale canonicalizes to 'und'\n+            { \"\", \"\", \"\", \"und\" },\n+            \/\/ variant alone is not a valid Locale, but has a valid language tag\n+            { \"\", \"\", \"NewYork\", \"und-NewYork\" },\n+            \/\/ standard valid locales\n+            { \"\", \"Us\", \"\", \"und-US\" },\n+            { \"\", \"US\", \"NewYork\", \"und-US-NewYork\" },\n+            { \"EN\", \"\", \"\", \"en\" },\n+            { \"EN\", \"\", \"NewYork\", \"en-NewYork\" },\n+            { \"EN\", \"US\", \"\", \"en-US\" },\n+            { \"EN\", \"US\", \"NewYork\", \"en-US-NewYork\" },\n+            \/\/ underscore in variant will be emitted as multiple variant subtags\n+            { \"en\", \"US\", \"Newer_Yorker\", \"en-US-Newer-Yorker\" },\n+            \/\/ invalid variant subtags are appended as private use\n+            { \"en\", \"US\", \"new_yorker\", \"en-US-x-lvariant-new-yorker\" },\n+            \/\/ the first invalid variant subtags and following variant subtags are appended as private use\n+            { \"en\", \"US\", \"Windows_XP_Home\", \"en-US-Windows-x-lvariant-XP-Home\" },\n+            \/\/ too long variant and following variant subtags disappear\n+            { \"en\", \"US\", \"WindowsVista_SP2\", \"en-US\" },\n+            \/\/ invalid region subtag disappears\n+            { \"en\", \"USA\", \"\", \"en\" },\n+            \/\/ invalid language tag disappears\n+            { \"e\", \"US\", \"\", \"und-US\" },\n+            \/\/ three-letter language tags are not canonicalized\n+            { \"Eng\", \"\", \"\", \"eng\" },\n+            \/\/ legacy languages canonicalize to modern equivalents\n+            { \"he\", \"IL\", \"\", \"he-IL\" },\n+            { \"iw\", \"IL\", \"\", \"he-IL\" },\n+            { \"yi\", \"DE\", \"\", \"yi-DE\" },\n+            { \"ji\", \"DE\", \"\", \"yi-DE\" },\n+            { \"id\", \"ID\", \"\", \"id-ID\" },\n+            { \"in\", \"ID\", \"\", \"id-ID\" },\n+            \/\/ special values are converted on output\n+            { \"ja\", \"JP\", \"JP\", \"ja-JP-u-ca-japanese-x-lvariant-JP\" },\n+            { \"th\", \"TH\", \"TH\", \"th-TH-u-nu-thai-x-lvariant-TH\" },\n+            { \"no\", \"NO\", \"NY\", \"nn-NO\" }\n@@ -487,1 +498,1 @@\n-            assertEquals(test[3], locale.toLanguageTag(), \"case \" + i);\n+            assertEquals(\"case \" + i, test[3], locale.toLanguageTag());\n@@ -492,8 +503,8 @@\n-                \/\/ case is normalized during the round trip\n-                {\"EN-us\", \"en-US\"},\n-                {\"en-Latn-US\", \"en-Latn-US\"},\n-                \/\/ reordering Unicode locale extensions\n-                {\"de-u-co-phonebk-ca-gregory\", \"de-u-ca-gregory-co-phonebk\"},\n-                \/\/ private use only language tag is preserved (no extra \"und\")\n-                {\"x-elmer\", \"x-elmer\"},\n-                {\"x-lvariant-JP\", \"x-lvariant-JP\"},\n+            \/\/ case is normalized during the round trip\n+            { \"EN-us\", \"en-US\" },\n+            { \"en-Latn-US\", \"en-Latn-US\" },\n+            \/\/ reordering Unicode locale extensions\n+            { \"de-u-co-phonebk-ca-gregory\", \"de-u-ca-gregory-co-phonebk\" },\n+            \/\/ private use only language tag is preserved (no extra \"und\")\n+            { \"x-elmer\", \"x-elmer\" },\n+            { \"x-lvariant-JP\", \"x-lvariant-JP\" },\n@@ -503,1 +514,1 @@\n-            assertEquals(test[1], locale.toLanguageTag(), \"case \" + test[0]);\n+            assertEquals(\"case \" + test[0], test[1], locale.toLanguageTag());\n@@ -516,35 +527,35 @@\n-                \/\/ private use tags only\n-                {\"x-abc\", \"x-abc\"},\n-                {\"x-a-b-c\", \"x-a-b-c\"},\n-                {\"x-a-12345678\", \"x-a-12345678\"},\n-\n-                \/\/ legacy language tags with preferred mappings\n-                {\"i-ami\", \"ami\"},\n-                {\"i-bnn\", \"bnn\"},\n-                {\"i-hak\", \"hak\"},\n-                {\"i-klingon\", \"tlh\"},\n-                {\"i-lux\", \"lb\"}, \/\/ two-letter tag\n-                {\"i-navajo\", \"nv\"}, \/\/ two-letter tag\n-                {\"i-pwn\", \"pwn\"},\n-                {\"i-tao\", \"tao\"},\n-                {\"i-tay\", \"tay\"},\n-                {\"i-tsu\", \"tsu\"},\n-                {\"art-lojban\", \"jbo\"},\n-                {\"no-bok\", \"nb\"},\n-                {\"no-nyn\", \"nn\"},\n-                {\"sgn-BE-FR\", \"sfb\"},\n-                {\"sgn-BE-NL\", \"vgt\"},\n-                {\"sgn-CH-DE\", \"sgg\"},\n-                {\"zh-guoyu\", \"cmn\"},\n-                {\"zh-hakka\", \"hak\"},\n-                {\"zh-min-nan\", \"nan\"},\n-                {\"zh-xiang\", \"hsn\"},\n-\n-                \/\/ irregular legacy language tags, no preferred mappings, drop illegal fields\n-                \/\/ from end.  If no subtag is mappable, fallback to 'und'\n-                {\"i-default\", \"en-x-i-default\"},\n-                {\"i-enochian\", \"x-i-enochian\"},\n-                {\"i-mingo\", \"see-x-i-mingo\"},\n-                {\"en-GB-oed\", \"en-GB-x-oed\"},\n-                {\"zh-min\", \"nan-x-zh-min\"},\n-                {\"cel-gaulish\", \"xtg-x-cel-gaulish\"},\n+            \/\/ private use tags only\n+            { \"x-abc\", \"x-abc\" },\n+            { \"x-a-b-c\", \"x-a-b-c\" },\n+            { \"x-a-12345678\", \"x-a-12345678\" },\n+\n+            \/\/ legacy language tags with preferred mappings\n+            { \"i-ami\", \"ami\" },\n+            { \"i-bnn\", \"bnn\" },\n+            { \"i-hak\", \"hak\" },\n+            { \"i-klingon\", \"tlh\" },\n+            { \"i-lux\", \"lb\" }, \/\/ two-letter tag\n+            { \"i-navajo\", \"nv\" }, \/\/ two-letter tag\n+            { \"i-pwn\", \"pwn\" },\n+            { \"i-tao\", \"tao\" },\n+            { \"i-tay\", \"tay\" },\n+            { \"i-tsu\", \"tsu\" },\n+            { \"art-lojban\", \"jbo\" },\n+            { \"no-bok\", \"nb\" },\n+            { \"no-nyn\", \"nn\" },\n+            { \"sgn-BE-FR\", \"sfb\" },\n+            { \"sgn-BE-NL\", \"vgt\" },\n+            { \"sgn-CH-DE\", \"sgg\" },\n+            { \"zh-guoyu\", \"cmn\" },\n+            { \"zh-hakka\", \"hak\" },\n+            { \"zh-min-nan\", \"nan\" },\n+            { \"zh-xiang\", \"hsn\" },\n+\n+            \/\/ irregular legacy language tags, no preferred mappings, drop illegal fields\n+            \/\/ from end.  If no subtag is mappable, fallback to 'und'\n+            { \"i-default\", \"en-x-i-default\" },\n+            { \"i-enochian\", \"x-i-enochian\" },\n+            { \"i-mingo\", \"see-x-i-mingo\" },\n+            { \"en-GB-oed\", \"en-GB-x-oed\" },\n+            { \"zh-min\", \"nan-x-zh-min\" },\n+            { \"cel-gaulish\", \"xtg-x-cel-gaulish\" },\n@@ -555,1 +566,1 @@\n-            assertEquals(test[1], locale.toLanguageTag(), \"legacy language tag case \" + i);\n+            assertEquals(\"legacy language tag case \" + i, test[1], locale.toLanguageTag());\n@@ -560,27 +571,27 @@\n-        tests = new String[][]{\n-                {\"valid\",\n-                        \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-def-x-y-12345678-z\",\n-                        \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-def-x-y-12345678-z\"},\n-                {\"segment of private use tag too long\",\n-                        \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-def-x-y-123456789-z\",\n-                        \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-def-x-y\"},\n-                {\"segment of private use tag is empty\",\n-                        \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-def-x-y--12345678-z\",\n-                        \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-def-x-y\"},\n-                {\"first segment of private use tag is empty\",\n-                        \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-def-x--y-12345678-z\",\n-                        \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-def\"},\n-                {\"illegal extension tag\",\n-                        \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-def-\\uD800-y-12345678-z\",\n-                        \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-def\"},\n-                {\"locale subtag with no value\",\n-                        \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-x-y-12345678-z\",\n-                        \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-x-y-12345678-z\"},\n-                {\"locale key subtag invalid\",\n-                        \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-123456789-def-x-y-12345678-z\",\n-                        \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc\"},\n-                \/\/ locale key subtag invalid in earlier position, all following subtags\n-                \/\/ dropped (and so the locale extension dropped as well)\n-                {\"locale key subtag invalid in earlier position\",\n-                        \"en-US-Newer-Yorker-a-bb-cc-dd-u-123456789-abc-bb-def-x-y-12345678-z\",\n-                        \"en-US-Newer-Yorker-a-bb-cc-dd\"},\n+        tests = new String[][] {\n+            { \"valid\",\n+              \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-def-x-y-12345678-z\",\n+              \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-def-x-y-12345678-z\" },\n+            { \"segment of private use tag too long\",\n+              \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-def-x-y-123456789-z\",\n+              \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-def-x-y\" },\n+            { \"segment of private use tag is empty\",\n+              \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-def-x-y--12345678-z\",\n+              \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-def-x-y\" },\n+            { \"first segment of private use tag is empty\",\n+              \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-def-x--y-12345678-z\",\n+              \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-def\" },\n+            { \"illegal extension tag\",\n+              \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-def-\\uD800-y-12345678-z\",\n+              \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-def\" },\n+            { \"locale subtag with no value\",\n+              \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-x-y-12345678-z\",\n+              \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-bb-x-y-12345678-z\" },\n+            { \"locale key subtag invalid\",\n+              \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc-123456789-def-x-y-12345678-z\",\n+              \"en-US-Newer-Yorker-a-bb-cc-dd-u-aa-abc\" },\n+            \/\/ locale key subtag invalid in earlier position, all following subtags\n+            \/\/ dropped (and so the locale extension dropped as well)\n+            { \"locale key subtag invalid in earlier position\",\n+              \"en-US-Newer-Yorker-a-bb-cc-dd-u-123456789-abc-bb-def-x-y-12345678-z\",\n+              \"en-US-Newer-Yorker-a-bb-cc-dd\" },\n@@ -593,2 +604,3 @@\n-                assertEquals(test[2], locale.toLanguageTag(), msg);\n-            } catch (IllegalArgumentException e) {\n+                assertEquals(msg, test[2], locale.toLanguageTag());\n+            }\n+            catch (IllegalArgumentException e) {\n@@ -601,2 +613,2 @@\n-        assertEquals(\"aa-00-bb-01\", locale.getExtension('d'), \"extension\");\n-        assertEquals(\"1234\", locale.getExtension('c'), \"extension c\");\n+        assertEquals(\"extension\", \"aa-00-bb-01\", locale.getExtension('d'));\n+        assertEquals(\"extension c\", \"1234\", locale.getExtension('c'));\n@@ -605,1 +617,1 @@\n-        assertEquals(\"ca-gregory\", locale.getExtension(Locale.UNICODE_LOCALE_EXTENSION), \"Unicode extension\");\n+        assertEquals(\"Unicode extension\", \"ca-gregory\", locale.getExtension(Locale.UNICODE_LOCALE_EXTENSION));\n@@ -609,2 +621,2 @@\n-        assertEquals(\"aa-000-bb-001-cc-003\", locale.getExtension(Locale.UNICODE_LOCALE_EXTENSION), \"Unicode keywords\");\n-        assertEquals(\"1234\", locale.getExtension('c'), \"Duplicated Unicode locake key followed by an extension\");\n+        assertEquals(\"Unicode keywords\", \"aa-000-bb-001-cc-003\", locale.getExtension(Locale.UNICODE_LOCALE_EXTENSION));\n+        assertEquals(\"Duplicated Unicode locake key followed by an extension\", \"1234\", locale.getExtension('c'));\n@@ -621,2 +633,2 @@\n-        assertEquals(\"Latin\", latnLocale.getDisplayScript(), \"latn US\");\n-        assertEquals(\"Simplified\", hansLocale.getDisplayScript(), \"hans US\");\n+        assertEquals(\"latn US\", \"Latin\", latnLocale.getDisplayScript());\n+        assertEquals(\"hans US\", \"Simplified\", hansLocale.getDisplayScript());\n@@ -625,2 +637,2 @@\n-        assertEquals(\"Lateinisch\", latnLocale.getDisplayScript(), \"latn DE\");\n-        assertEquals(\"Vereinfacht\", hansLocale.getDisplayScript(), \"hans DE\");\n+        assertEquals(\"latn DE\", \"Lateinisch\", latnLocale.getDisplayScript());\n+        assertEquals(\"hans DE\", \"Vereinfacht\", hansLocale.getDisplayScript());\n@@ -636,2 +648,2 @@\n-        assertEquals(\"Latin\", latnLocale.getDisplayScript(Locale.US), \"latn US\");\n-        assertEquals(\"Simplified\", hansLocale.getDisplayScript(Locale.US), \"hans US\");\n+        assertEquals(\"latn US\", \"Latin\", latnLocale.getDisplayScript(Locale.US));\n+        assertEquals(\"hans US\", \"Simplified\", hansLocale.getDisplayScript(Locale.US));\n@@ -639,2 +651,2 @@\n-        assertEquals(\"Lateinisch\", latnLocale.getDisplayScript(Locale.GERMANY), \"latn DE\");\n-        assertEquals(\"Vereinfacht\", hansLocale.getDisplayScript(Locale.GERMANY), \"hans DE\");\n+        assertEquals(\"latn DE\", \"Lateinisch\", latnLocale.getDisplayScript(Locale.GERMANY));\n+        assertEquals(\"hans DE\", \"Vereinfacht\", hansLocale.getDisplayScript(Locale.GERMANY));\n@@ -686,4 +698,4 @@\n-            assertEquals(displayNameEnglish[i], loc.getDisplayName(Locale.ENGLISH),\n-                    \"English display name for \" + loc.toLanguageTag());\n-            assertEquals(displayNameSimplifiedChinese[i], loc.getDisplayName(Locale.CHINA),\n-                    \"Simplified Chinese display name for \" + loc.toLanguageTag());\n+            assertEquals(\"English display name for \" + loc.toLanguageTag(),\n+                    displayNameEnglish[i], loc.getDisplayName(Locale.ENGLISH));\n+            assertEquals(\"Simplified Chinese display name for \" + loc.toLanguageTag(),\n+                    displayNameSimplifiedChinese[i], loc.getDisplayName(Locale.CHINA));\n@@ -707,4 +719,4 @@\n-                .setLocale(locale)\n-                .build();\n-        assertEquals(target, result.toLanguageTag(), \"long tag\");\n-        assertEquals(locale, result, \"long tag\");\n+            .setLocale(locale)\n+            .build();\n+        assertEquals(\"long tag\", target, result.toLanguageTag());\n+        assertEquals(\"long tag\", locale, result);\n@@ -713,2 +725,3 @@\n-        assertThrows(NullPointerException.class, () -> builder.setLocale(null),\n-                \"Setting null locale should throw NPE\");\n+        new BuilderNPE(\"locale\") {\n+            public void call() { b.setLocale(null); }\n+        };\n@@ -719,2 +732,2 @@\n-        assertEquals(\"ja-JP-u-ca-japanese\", locale.toLanguageTag(), \"ja_JP_JP languagetag\");\n-        assertEquals(\"\", locale.getVariant(), \"ja_JP_JP variant\");\n+        assertEquals(\"ja_JP_JP languagetag\", \"ja-JP-u-ca-japanese\", locale.toLanguageTag());\n+        assertEquals(\"ja_JP_JP variant\", \"\", locale.getVariant());\n@@ -723,2 +736,2 @@\n-        assertEquals(\"th-TH-u-nu-thai\", locale.toLanguageTag(), \"th_TH_TH languagetag\");\n-        assertEquals(\"\", locale.getVariant(), \"th_TH_TH variant\");\n+        assertEquals(\"th_TH_TH languagetag\", \"th-TH-u-nu-thai\", locale.toLanguageTag());\n+        assertEquals(\"th_TH_TH variant\", \"\", locale.getVariant());\n@@ -727,3 +740,3 @@\n-        assertEquals(\"nn-NO\", locale.toLanguageTag(), \"no_NO_NY languagetag\");\n-        assertEquals(\"nn\", locale.getLanguage(), \"no_NO_NY language\");\n-        assertEquals(\"\", locale.getVariant(), \"no_NO_NY variant\");\n+        assertEquals(\"no_NO_NY languagetag\", \"nn-NO\", locale.toLanguageTag());\n+        assertEquals(\"no_NO_NY language\", \"nn\", locale.getLanguage());\n+        assertEquals(\"no_NO_NY variant\", \"\", locale.getVariant());\n@@ -732,2 +745,5 @@\n-        assertThrows(IllformedLocaleException.class,\n-                () -> new Builder().setLocale(Locale.of(\"123\", \"4567\", \"89\")), \"123_4567_89\");\n+        new BuilderILE(\"123_4567_89\") {\n+            public void call() {\n+                b.setLocale(Locale.of(\"123\", \"4567\", \"89\"));\n+            }\n+        };\n@@ -742,14 +758,10 @@\n-                .setLanguageTag(source)\n-                .build()\n-                .toLanguageTag();\n-        assertEquals(target, result, \"language\");\n-\n-        \/\/ redundant extensions are ignored\n-        assertEquals(\"und-a-xx-yy-b-ww-c-vv\",\n-                new Builder().setLanguageTag(\"und-a-xx-yy-b-ww-A-00-11-c-vv\").build().toLanguageTag());\n-        \/\/ redundant Unicode locale extension keys are ignored\n-        assertEquals(\"und-u-cu-usd-nu-thai-xx-1234\",\n-                new Builder().setLanguageTag(\"und-u-nu-thai-cu-usd-NU-chinese-xx-1234\").build().toLanguageTag());\n-        \/\/ redundant Unicode locale extension attributes are ignored\n-        assertEquals(\"und-u-bar-foo\",\n-                new Builder().setLanguageTag(\"und-u-foo-bar-FOO\").build().toLanguageTag());\n+            .setLanguageTag(source)\n+            .build()\n+            .toLanguageTag();\n+        assertEquals(\"language\", target, result);\n+\n+        \/\/ redundant extensions cause a failure\n+        new BuilderILE() { public void call() { b.setLanguageTag(\"und-a-xx-yy-b-ww-A-00-11-c-vv\"); }};\n+\n+        \/\/ redundant Unicode locale extension keys within an Unicode locale extension cause a failure\n+        new BuilderILE() { public void call() { b.setLanguageTag(\"und-u-nu-thai-NU-chinese-xx-1234\"); }};\n@@ -767,3 +779,3 @@\n-        assertEquals(empty.build(), bldr.build(),\n-                \"Setting a %s language tag did not clear the builder\"\n-                .formatted(tag == null ? \"null\" : \"empty\"));\n+        assertEquals(\"Setting a %s language tag did not clear the builder\"\n+                .formatted(tag == null ? \"null\" : \"empty\"),\n+                empty.build(), bldr.build());\n@@ -780,4 +792,4 @@\n-                .setLanguage(source)\n-                .build()\n-                .getLanguage();\n-        assertEquals(target, result, \"en\");\n+            .setLanguage(source)\n+            .build()\n+            .getLanguage();\n+        assertEquals(\"en\", target, result);\n@@ -787,5 +799,5 @@\n-                .setLanguage(target)\n-                .setLanguage(\"\")\n-                .build()\n-                .getLanguage();\n-        assertEquals(defaulted, result, \"empty\");\n+            .setLanguage(target)\n+            .setLanguage(\"\")\n+            .build()\n+            .getLanguage();\n+        assertEquals(\"empty\", defaulted, result);\n@@ -799,1 +811,1 @@\n-        assertEquals(defaulted, result, \"null\");\n+        assertEquals(\"null\", defaulted, result);\n@@ -804,3 +816,1 @@\n-        for (String arg : List.of(\"q\", \"abcdefghi\", \"13\")) {\n-            assertThrows(IllformedLocaleException.class, () -> new Builder().setLanguage(arg));\n-        }\n+        new BuilderILE(\"q\", \"abcdefghi\", \"13\") { public void call() { b.setLanguage(arg); }};\n@@ -809,2 +819,2 @@\n-        assertNotNull(builder.setLanguage(\"zz\").build(), \"2alpha\");\n-        assertNotNull(builder.setLanguage(\"abcdefgh\").build(), \"8alpha\");\n+        assertNotNull(\"2alpha\", builder.setLanguage(\"zz\").build());\n+        assertNotNull(\"8alpha\", builder.setLanguage(\"abcdefgh\").build());\n@@ -814,4 +824,4 @@\n-                .setLanguage(\"eng\")\n-                .build()\n-                .getLanguage();\n-        assertEquals(\"eng\", result, \"eng\");\n+            .setLanguage(\"eng\")\n+            .build()\n+            .getLanguage();\n+        assertEquals(\"eng\", \"eng\", result);\n@@ -828,4 +838,4 @@\n-                .setScript(source)\n-                .build()\n-                .getScript();\n-        assertEquals(target, result, \"script\");\n+            .setScript(source)\n+            .build()\n+            .getScript();\n+        assertEquals(\"script\", target, result);\n@@ -835,5 +845,5 @@\n-                .setScript(target)\n-                .setScript(\"\")\n-                .build()\n-                .getScript();\n-        assertEquals(defaulted, result, \"empty\");\n+            .setScript(target)\n+            .setScript(\"\")\n+            .build()\n+            .getScript();\n+        assertEquals(\"empty\", defaulted, result);\n@@ -847,1 +857,1 @@\n-        assertEquals(defaulted, result, \"null\");\n+        assertEquals(\"null\", defaulted, result);\n@@ -851,4 +861,1 @@\n-        for (String arg : List.of(\"abc\", \"abcde\", \"l3tn\")) {\n-            assertThrows(IllformedLocaleException.class, () -> new Builder().setScript(arg));\n-        }\n-\n+        new BuilderILE(\"abc\", \"abcde\", \"l3tn\") { public void call() { b.setScript(arg); }};\n@@ -857,1 +864,1 @@\n-        assertEquals(\"Wxyz\", builder.setScript(\"wxyz\").build().getScript(), \"4alpha\");\n+        assertEquals(\"4alpha\", \"Wxyz\", builder.setScript(\"wxyz\").build().getScript());\n@@ -868,4 +875,4 @@\n-                .setRegion(source)\n-                .build()\n-                .getCountry();\n-        assertEquals(target, result, \"us\");\n+            .setRegion(source)\n+            .build()\n+            .getCountry();\n+        assertEquals(\"us\", target, result);\n@@ -875,5 +882,5 @@\n-                .setRegion(target)\n-                .setRegion(\"\")\n-                .build()\n-                .getCountry();\n-        assertEquals(defaulted, result, \"empty\");\n+            .setRegion(target)\n+            .setRegion(\"\")\n+            .build()\n+            .getCountry();\n+        assertEquals(\"empty\", defaulted, result);\n@@ -887,1 +894,1 @@\n-        assertEquals(defaulted, result, \"null\");\n+        assertEquals(\"null\", defaulted, result);\n@@ -891,3 +898,1 @@\n-        for (String arg : List.of(\"q\", \"abc\", \"12\", \"1234\", \"a3\", \"12a\")) {\n-            assertThrows(IllformedLocaleException.class, () -> new Builder().setRegion(arg));\n-        }\n+        new BuilderILE(\"q\", \"abc\", \"12\", \"1234\", \"a3\", \"12a\") { public void call() { b.setRegion(arg); }};\n@@ -896,2 +901,2 @@\n-        assertEquals(\"ZZ\", builder.setRegion(\"ZZ\").build().getCountry(), \"2alpha\");\n-        assertEquals(\"000\", builder.setRegion(\"000\").build().getCountry(), \"3digit\");\n+        assertEquals(\"2alpha\", \"ZZ\", builder.setRegion(\"ZZ\").build().getCountry());\n+        assertEquals(\"3digit\", \"000\", builder.setRegion(\"000\").build().getCountry());\n@@ -908,4 +913,4 @@\n-                .setVariant(source)\n-                .build()\n-                .getVariant();\n-        assertEquals(target, result, \"NewYork\");\n+            .setVariant(source)\n+            .build()\n+            .getVariant();\n+        assertEquals(\"NewYork\", target, result);\n@@ -914,4 +919,4 @@\n-                .setVariant(\"NeWeR_YoRkEr\")\n-                .build()\n-                .toLanguageTag();\n-        assertEquals(\"und-NeWeR-YoRkEr\", result, \"newer yorker\");\n+            .setVariant(\"NeWeR_YoRkEr\")\n+            .build()\n+            .toLanguageTag();\n+        assertEquals(\"newer yorker\", \"und-NeWeR-YoRkEr\", result);\n@@ -921,4 +926,4 @@\n-                .setVariant(\"zzzzz_yyyyy_xxxxx\")\n-                .build()\n-                .getVariant();\n-        assertEquals(\"zzzzz_yyyyy_xxxxx\", result, \"zyx\");\n+            .setVariant(\"zzzzz_yyyyy_xxxxx\")\n+            .build()\n+            .getVariant();\n+        assertEquals(\"zyx\", \"zzzzz_yyyyy_xxxxx\", result);\n@@ -928,5 +933,5 @@\n-                .setVariant(target)\n-                .setVariant(\"\")\n-                .build()\n-                .getVariant();\n-        assertEquals(defaulted, result, \"empty\");\n+            .setVariant(target)\n+            .setVariant(\"\")\n+            .build()\n+            .getVariant();\n+        assertEquals(\"empty\", defaulted, result);\n@@ -940,1 +945,1 @@\n-        assertEquals(defaulted, result, \"null\");\n+        assertEquals(\"null\", defaulted, result);\n@@ -944,4 +949,1 @@\n-        for (String arg : List.of(\"abcd\", \"abcdefghi\", \"1ab\", \"1abcdefgh\")) {\n-            assertThrows(IllformedLocaleException.class, () -> new Builder().setVariant(arg));\n-        }\n-\n+        new BuilderILE(\"abcd\", \"abcdefghi\", \"1ab\", \"1abcdefgh\") { public void call() { b.setVariant(arg); }};\n@@ -950,1 +952,1 @@\n-        assertEquals(\"1abc\", builder.setVariant(\"1abc\").build().getVariant(), \"digit+3alpha\");\n+        assertEquals(\"digit+3alpha\", \"1abc\", builder.setVariant(\"1abc\").build().getVariant());\n@@ -953,2 +955,1 @@\n-        assertThrows(IllformedLocaleException.class, () -> new Builder().setVariant(\"abcde-fg\"));\n-\n+        new BuilderILE(\"abcde-fg\") { public void call() { b.setVariant(arg); }};\n@@ -965,4 +966,4 @@\n-                .setExtension(sourceKey, sourceValue)\n-                .build()\n-                .getExtension(sourceKey);\n-        assertEquals(target, result, \"extension\");\n+            .setExtension(sourceKey, sourceValue)\n+            .build()\n+            .getExtension(sourceKey);\n+        assertEquals(\"extension\", target, result);\n@@ -972,5 +973,5 @@\n-                .setExtension(sourceKey, sourceValue)\n-                .setExtension(sourceKey, \"\")\n-                .build()\n-                .getExtension(sourceKey);\n-        assertNull(result, \"empty\");\n+            .setExtension(sourceKey, sourceValue)\n+            .setExtension(sourceKey, \"\")\n+            .build()\n+            .getExtension(sourceKey);\n+        assertEquals(\"empty\", null, result);\n@@ -984,1 +985,1 @@\n-        assertNull(result, \"null\");\n+        assertEquals(\"null\", null, result);\n@@ -988,3 +989,1 @@\n-        assertThrows(IllformedLocaleException.class,\n-                () -> new Builder().setExtension('$', sourceValue));\n-\n+        new BuilderILE(\"$\") { public void call() { b.setExtension('$', sourceValue); }};\n@@ -993,3 +992,1 @@\n-        assertThrows(IllformedLocaleException.class,\n-                () -> new Builder().setExtension(sourceKey, \"ab-cd-123456789\"));\n-\n+        new BuilderILE(\"ab-cd-123456789\") { public void call() { b.setExtension(sourceKey, arg); }};\n@@ -998,3 +995,1 @@\n-        assertThrows(IllformedLocaleException.class,\n-                () -> new Builder().setExtension(sourceKey, \"ab--cd\"));\n-\n+        new BuilderILE(\"ab--cd\") { public void call() { b.setExtension(sourceKey, arg); }};\n@@ -1004,3 +999,3 @@\n-                .setExtension('u', \"co-japanese\")\n-                .build();\n-        assertEquals(\"japanese\", locale.getUnicodeLocaleType(\"co\"), \"locale extension\");\n+            .setExtension('u', \"co-japanese\")\n+            .build();\n+        assertEquals(\"locale extension\", \"japanese\", locale.getUnicodeLocaleType(\"co\"));\n@@ -1010,3 +1005,3 @@\n-                .setUnicodeLocaleKeyword(\"co\", \"japanese\")\n-                .build();\n-        assertEquals(locale, locale2, \"locales with extension\");\n+            .setUnicodeLocaleKeyword(\"co\", \"japanese\")\n+            .build();\n+        assertEquals(\"locales with extension\", locale, locale2);\n@@ -1016,5 +1011,5 @@\n-                .setExtension('u', \"xxx-nu-thai\")\n-                .build();\n-        assertNull(locale3.getUnicodeLocaleType(\"co\"), \"remove co\");\n-        assertEquals(\"thai\", locale3.getUnicodeLocaleType(\"nu\"), \"override thai\");\n-        assertEquals(1, locale3.getUnicodeLocaleAttributes().size(), \"override attribute\");\n+            .setExtension('u', \"xxx-nu-thai\")\n+            .build();\n+        assertEquals(\"remove co\", null, locale3.getUnicodeLocaleType(\"co\"));\n+        assertEquals(\"override thai\", \"thai\", locale3.getUnicodeLocaleType(\"nu\"));\n+        assertEquals(\"override attribute\", 1, locale3.getUnicodeLocaleAttributes().size());\n@@ -1024,4 +1019,4 @@\n-                .setUnicodeLocaleKeyword(\"co\", \"japanese\")\n-                .build();\n-        assertEquals(\"japanese\", locale4.getUnicodeLocaleType(\"co\"), \"extend\");\n-        assertEquals(\"thai\", locale4.getUnicodeLocaleType(\"nu\"), \"extend\");\n+            .setUnicodeLocaleKeyword(\"co\", \"japanese\")\n+            .build();\n+        assertEquals(\"extend\", \"japanese\", locale4.getUnicodeLocaleType(\"co\"));\n+        assertEquals(\"extend\", \"thai\", locale4.getUnicodeLocaleType(\"nu\"));\n@@ -1031,5 +1026,5 @@\n-                .clear()\n-                .setExtension('u', \"456-123-zz-123-yy-456-xx-789\")\n-                .build()\n-                .toLanguageTag();\n-        assertEquals(\"und-u-123-456-xx-789-yy-456-zz-123\", result, \"reorder\");\n+            .clear()\n+            .setExtension('u', \"456-123-zz-123-yy-456-xx-789\")\n+            .build()\n+            .toLanguageTag();\n+        assertEquals(\"reorder\", \"und-u-123-456-xx-789-yy-456-zz-123\", result);\n@@ -1039,5 +1034,5 @@\n-                .clear()\n-                .setExtension('u', \"nu-thai-foobar\")\n-                .build()\n-                .getUnicodeLocaleType(\"nu\");\n-        assertEquals(\"thai-foobar\", result, \"multiple types\");\n+            .clear()\n+            .setExtension('u', \"nu-thai-foobar\")\n+            .build()\n+            .getUnicodeLocaleType(\"nu\");\n+        assertEquals(\"multiple types\", \"thai-foobar\", result);\n@@ -1047,13 +1042,5 @@\n-                .clear()\n-                .setExtension('u', \"nu-thai-NU-chinese-xx-1234\")\n-                .build()\n-                .toLanguageTag();\n-        assertEquals(\"und-u-nu-thai-xx-1234\", result, \"duplicate keys\");\n-\n-        \/\/ redundant locale attributes are ignored\n-        result = builder\n-                .clear()\n-                .setExtension('u', \"posix-posix\")\n-                .build()\n-                .toLanguageTag();\n-        assertEquals(\"und-u-posix\", result, \"duplicate attributes\");\n+            .clear()\n+            .setExtension('u', \"nu-thai-NU-chinese-xx-1234\")\n+            .build()\n+            .toLanguageTag();\n+        assertEquals(\"duplicate keys\", \"und-u-nu-thai-xx-1234\", result);\n@@ -1066,3 +1053,3 @@\n-                .addUnicodeLocaleAttribute(\"def\")\n-                .addUnicodeLocaleAttribute(\"abc\")\n-                .build();\n+            .addUnicodeLocaleAttribute(\"def\")\n+            .addUnicodeLocaleAttribute(\"abc\")\n+            .build();\n@@ -1071,3 +1058,3 @@\n-        assertEquals(2, uattrs.size(), \"number of attributes\");\n-        assertTrue(uattrs.contains(\"abc\"), \"attribute abc\");\n-        assertTrue(uattrs.contains(\"def\"), \"attribute def\");\n+        assertEquals(\"number of attributes\", 2, uattrs.size());\n+        assertTrue(\"attribute abc\", uattrs.contains(\"abc\"));\n+        assertTrue(\"attribute def\", uattrs.contains(\"def\"));\n@@ -1077,1 +1064,1 @@\n-                .build();\n+            .build();\n@@ -1079,2 +1066,1 @@\n-        uattrs = locale.getUnicodeLocaleAttributes();\n-        assertEquals(2, uattrs.size(), \"remove bogus\");\n+        assertEquals(\"remove bogus\", 2, uattrs.size());\n@@ -1084,3 +1070,2 @@\n-                .build();\n-        uattrs = locale.getUnicodeLocaleAttributes();\n-        assertEquals(2, uattrs.size(), \"add duplicate\");\n+            .build();\n+        assertEquals(\"add duplicate\", 2, uattrs.size());\n@@ -1089,5 +1074,2 @@\n-        assertThrows(NullPointerException.class,\n-                () ->  new Builder().addUnicodeLocaleAttribute(null), \"null attribute\");\n-\n-        assertThrows(NullPointerException.class,\n-                () -> new Builder().removeUnicodeLocaleAttribute(null), \"null attribute removal\");\n+        new BuilderNPE(\"null attribute\") { public void call() { b.addUnicodeLocaleAttribute(null); }};\n+        new BuilderNPE(\"null attribute removal\") { public void call() { b.removeUnicodeLocaleAttribute(null); }};\n@@ -1096,2 +1078,1 @@\n-        assertThrows(IllformedLocaleException.class,\n-                     () -> new Builder().addUnicodeLocaleAttribute(\"ca\"), \"invalid attribute\");\n+        new BuilderILE(\"invalid attribute\") { public void call() { b.addUnicodeLocaleAttribute(\"ca\"); }};\n@@ -1105,6 +1086,6 @@\n-                .setUnicodeLocaleKeyword(\"co\", \"japanese\")\n-                .setUnicodeLocaleKeyword(\"nu\", \"thai\")\n-                .build();\n-        assertEquals(\"japanese\", locale.getUnicodeLocaleType(\"co\"), \"co\");\n-        assertEquals(\"thai\", locale.getUnicodeLocaleType(\"nu\"), \"nu\");\n-        assertEquals(2, locale.getUnicodeLocaleKeys().size(), \"keys\");\n+            .setUnicodeLocaleKeyword(\"co\", \"japanese\")\n+            .setUnicodeLocaleKeyword(\"nu\", \"thai\")\n+            .build();\n+        assertEquals(\"co\", \"japanese\", locale.getUnicodeLocaleType(\"co\"));\n+        assertEquals(\"nu\", \"thai\", locale.getUnicodeLocaleType(\"nu\"));\n+        assertEquals(\"keys\", 2, locale.getUnicodeLocaleKeys().size());\n@@ -1114,4 +1095,4 @@\n-                .setUnicodeLocaleKeyword(\"co\", null)\n-                .build()\n-                .toLanguageTag();\n-        assertEquals(\"und-u-nu-thai\", result, \"empty co\");\n+            .setUnicodeLocaleKeyword(\"co\", null)\n+            .build()\n+            .toLanguageTag();\n+        assertEquals(\"empty co\", \"und-u-nu-thai\", result);\n@@ -1121,4 +1102,4 @@\n-                .setUnicodeLocaleKeyword(\"nu\", null)\n-                .build()\n-                .toLanguageTag();\n-        assertEquals(\"und\", result, \"empty nu\");\n+            .setUnicodeLocaleKeyword(\"nu\", null)\n+            .build()\n+            .toLanguageTag();\n+        assertEquals(\"empty nu\", \"und\", result);\n@@ -1128,5 +1109,5 @@\n-                .setUnicodeLocaleKeyword(\"zz\", \"012\")\n-                .setUnicodeLocaleKeyword(\"aa\", \"345\")\n-                .build()\n-                .toLanguageTag();\n-        assertEquals(\"und-u-aa-345-zz-012\", result, \"reordered\");\n+            .setUnicodeLocaleKeyword(\"zz\", \"012\")\n+            .setUnicodeLocaleKeyword(\"aa\", \"345\")\n+            .build()\n+            .toLanguageTag();\n+        assertEquals(\"reordered\", \"und-u-aa-345-zz-012\", result);\n@@ -1135,3 +1116,1 @@\n-        assertThrows(NullPointerException.class,\n-                () -> new Builder().setUnicodeLocaleKeyword(null, \"thai\"), \"keyword\");\n-\n+        new BuilderNPE(\"keyword\") { public void call() { b.setUnicodeLocaleKeyword(null, \"thai\"); }};\n@@ -1140,4 +1119,1 @@\n-        for (String arg : List.of(\"a\", \"abc\")) {\n-            assertThrows(IllformedLocaleException.class,\n-                    () -> new Builder().setUnicodeLocaleKeyword(arg, \"value\"));\n-        }\n+        new BuilderILE(\"a\", \"abc\") { public void call() { b.setUnicodeLocaleKeyword(arg, \"value\"); }};\n@@ -1146,4 +1122,1 @@\n-        for (String arg : List.of(\"ab\", \"abcdefghi\")) {\n-            assertThrows(IllformedLocaleException.class,\n-                    () -> new Builder().setUnicodeLocaleKeyword(\"ab\", arg));\n-        }\n+        new BuilderILE(\"ab\", \"abcdefghi\") { public void call() { b.setUnicodeLocaleKeyword(\"ab\", arg); }};\n@@ -1159,4 +1132,4 @@\n-                .setExtension(Locale.PRIVATE_USE_EXTENSION, source)\n-                .build()\n-                .getExtension(Locale.PRIVATE_USE_EXTENSION);\n-        assertEquals(target, result, \"abc\");\n+            .setExtension(Locale.PRIVATE_USE_EXTENSION, source)\n+            .build()\n+            .getExtension(Locale.PRIVATE_USE_EXTENSION);\n+        assertEquals(\"abc\", target, result);\n@@ -1165,3 +1138,1 @@\n-        assertThrows(IllformedLocaleException.class,\n-                () -> new Builder().setExtension(Locale.PRIVATE_USE_EXTENSION, \"a--b\"),\n-                \"multiple-hyphens should throw IAE\");\n+        new BuilderILE(\"a--b\") { public void call() { b.setExtension(Locale.PRIVATE_USE_EXTENSION, arg); }};\n@@ -1176,5 +1147,5 @@\n-                .setLocale(locale)\n-                .clear()\n-                .build()\n-                .toLanguageTag();\n-        assertEquals(\"und\", result, \"clear\");\n+            .setLocale(locale)\n+            .clear()\n+            .build()\n+            .toLanguageTag();\n+        assertEquals(\"clear\", \"und\", result);\n@@ -1196,27 +1167,27 @@\n-                Locale.ROOT,\n-                Locale.ENGLISH,\n-                Locale.US,\n-                Locale.of(\"en\", \"US\", \"Win\"),\n-                Locale.of(\"en\", \"US\", \"Win_XP\"),\n-                Locale.JAPAN,\n-                Locale.of(\"ja\", \"JP\", \"JP\"),\n-                Locale.of(\"th\", \"TH\"),\n-                Locale.of(\"th\", \"TH\", \"TH\"),\n-                Locale.of(\"no\", \"NO\"),\n-                Locale.of(\"nb\", \"NO\"),\n-                Locale.of(\"nn\", \"NO\"),\n-                Locale.of(\"no\", \"NO\", \"NY\"),\n-                Locale.of(\"nn\", \"NO\", \"NY\"),\n-                Locale.of(\"he\", \"IL\"),\n-                Locale.of(\"he\", \"IL\", \"var\"),\n-                Locale.of(\"Language\", \"Country\", \"Variant\"),\n-                Locale.of(\"\", \"US\"),\n-                Locale.of(\"\", \"\", \"Java\"),\n-                Locale.forLanguageTag(\"en-Latn-US\"),\n-                Locale.forLanguageTag(\"zh-Hans\"),\n-                Locale.forLanguageTag(\"zh-Hant-TW\"),\n-                Locale.forLanguageTag(\"ja-JP-u-ca-japanese\"),\n-                Locale.forLanguageTag(\"und-Hant\"),\n-                Locale.forLanguageTag(\"und-a-123-456\"),\n-                Locale.forLanguageTag(\"en-x-java\"),\n-                Locale.forLanguageTag(\"th-TH-u-ca-buddist-nu-thai-x-lvariant-TH\"),\n+            Locale.ROOT,\n+            Locale.ENGLISH,\n+            Locale.US,\n+            Locale.of(\"en\", \"US\", \"Win\"),\n+            Locale.of(\"en\", \"US\", \"Win_XP\"),\n+            Locale.JAPAN,\n+            Locale.of(\"ja\", \"JP\", \"JP\"),\n+            Locale.of(\"th\", \"TH\"),\n+            Locale.of(\"th\", \"TH\", \"TH\"),\n+            Locale.of(\"no\", \"NO\"),\n+            Locale.of(\"nb\", \"NO\"),\n+            Locale.of(\"nn\", \"NO\"),\n+            Locale.of(\"no\", \"NO\", \"NY\"),\n+            Locale.of(\"nn\", \"NO\", \"NY\"),\n+            Locale.of(\"he\", \"IL\"),\n+            Locale.of(\"he\", \"IL\", \"var\"),\n+            Locale.of(\"Language\", \"Country\", \"Variant\"),\n+            Locale.of(\"\", \"US\"),\n+            Locale.of(\"\", \"\", \"Java\"),\n+            Locale.forLanguageTag(\"en-Latn-US\"),\n+            Locale.forLanguageTag(\"zh-Hans\"),\n+            Locale.forLanguageTag(\"zh-Hant-TW\"),\n+            Locale.forLanguageTag(\"ja-JP-u-ca-japanese\"),\n+            Locale.forLanguageTag(\"und-Hant\"),\n+            Locale.forLanguageTag(\"und-a-123-456\"),\n+            Locale.forLanguageTag(\"en-x-java\"),\n+            Locale.forLanguageTag(\"th-TH-u-ca-buddist-nu-thai-x-lvariant-TH\"),\n@@ -1237,1 +1208,1 @@\n-                assertEquals(locale, o, \"roundtrip \" + locale);\n+                assertEquals(\"roundtrip \" + locale, locale, o);\n@@ -1263,1 +1234,2 @@\n-            fail(\"'dataDir' is null. serialized.data.dir Property value is \" + dataDirName);\n+            fail(\"'dataDir' is null. serialized.data.dir Property value is \"+dataDirName);\n+            return;\n@@ -1265,1 +1237,2 @@\n-            fail(\"'dataDir' is not a directory. dataDir: \" + dataDir.toString());\n+            fail(\"'dataDir' is not a directory. dataDir: \"+dataDir.toString());\n+            return;\n@@ -1291,1 +1264,2 @@\n-                 ObjectInputStream ois = new ObjectInputStream(fis)) {\n+                 ObjectInputStream ois = new ObjectInputStream(fis))\n+            {\n@@ -1293,1 +1267,1 @@\n-                assertEquals(o, locale, \"Deserialize Java 6 Locale \" + locale);\n+                assertEquals(\"Deserialize Java 6 Locale \" + locale, o, locale);\n@@ -1313,9 +1287,9 @@\n-                {\"ja-JP-x-lvariant-JP\", \"ja-JP-u-ca-japanese-x-lvariant-JP\"},   \/\/ special case 1\n-                {\"ja-JP-x-lvariant-JP-XXX\"},\n-                {\"ja-JP-u-ca-japanese-x-lvariant-JP\"},\n-                {\"ja-JP-u-ca-gregory-x-lvariant-JP\"},\n-                {\"ja-JP-u-cu-jpy-x-lvariant-JP\"},\n-                {\"ja-x-lvariant-JP\"},\n-                {\"th-TH-x-lvariant-TH\", \"th-TH-u-nu-thai-x-lvariant-TH\"},   \/\/ special case 2\n-                {\"th-TH-u-nu-thai-x-lvariant-TH\"},\n-                {\"en-US-x-lvariant-JP\"},\n+            {\"ja-JP-x-lvariant-JP\", \"ja-JP-u-ca-japanese-x-lvariant-JP\"},   \/\/ special case 1\n+            {\"ja-JP-x-lvariant-JP-XXX\"},\n+            {\"ja-JP-u-ca-japanese-x-lvariant-JP\"},\n+            {\"ja-JP-u-ca-gregory-x-lvariant-JP\"},\n+            {\"ja-JP-u-cu-jpy-x-lvariant-JP\"},\n+            {\"ja-x-lvariant-JP\"},\n+            {\"th-TH-x-lvariant-TH\", \"th-TH-u-nu-thai-x-lvariant-TH\"},   \/\/ special case 2\n+            {\"th-TH-u-nu-thai-x-lvariant-TH\"},\n+            {\"en-US-x-lvariant-JP\"},\n@@ -1333,1 +1307,1 @@\n-            assertEquals(expected, out, \"Language tag roundtrip by forLanguageTag with input: \" + in);\n+            assertEquals(\"Language tag roundtrip by forLanguageTag with input: \" + in, expected, out);\n@@ -1340,1 +1314,1 @@\n-            assertEquals(expected, out, \"Language tag roundtrip by Builder.setLanguageTag with input: \" + in);\n+            assertEquals(\"Language tag roundtrip by Builder.setLanguageTag with input: \" + in, expected, out);\n@@ -1347,2 +1321,2 @@\n-                {\"en-Latn\", \"en__#Latn\"},\n-                {\"en-u-ca-japanese\", \"en__#u-ca-japanese\"},\n+            {\"en-Latn\", \"en__#Latn\"},\n+            {\"en-u-ca-japanese\", \"en__#u-ca-japanese\"},\n@@ -1357,1 +1331,1 @@\n-            assertEquals(expected, out, \"Empty country field with non-empty script\/extension with input: \" + in);\n+            assertEquals(\"Empty country field with non-empty script\/extension with input: \" + in, expected, out);\n@@ -1371,1 +1345,1 @@\n-                \"java.util.JapaneseImperialCalendar\");\n+                      \"java.util.JapaneseImperialCalendar\");\n@@ -1382,1 +1356,1 @@\n-        assertEquals(expected, cal.getClass().getName(), \"Wrong calendar\");\n+        assertEquals(\"Wrong calendar\", expected, cal.getClass().getName());\n@@ -1388,1 +1362,140 @@\n-        assertEquals(expected, zero, \"Wrong digit zero char\");\n+        assertEquals(\"Wrong digit zero char\", expected, zero);\n+    }\n+\n+    \/\/\/\n+    \/\/\/ utility asserts\n+    \/\/\/\n+\n+    private void assertTrue(String msg, boolean v) {\n+        if (!v) {\n+            fail(msg + \": expected true\");\n+        }\n+    }\n+\n+    private void assertFalse(String msg, boolean v) {\n+        if (v) {\n+            fail(msg + \": expected false\");\n+        }\n+    }\n+\n+    private void assertEquals(String msg, Object e, Object v) {\n+        if (e == null ? v != null : !e.equals(v)) {\n+            if (e != null) {\n+                e = \"'\" + e + \"'\";\n+            }\n+            if (v != null) {\n+                v = \"'\" + v + \"'\";\n+            }\n+            fail(msg + \": expected \" + e + \" but got \" + v);\n+        }\n+    }\n+\n+    private void assertNotEquals(String msg, Object e, Object v) {\n+        if (e == null ? v == null : e.equals(v)) {\n+            if (e != null) {\n+                e = \"'\" + e + \"'\";\n+            }\n+            fail(msg + \": expected not equal \" + e);\n+        }\n+    }\n+\n+    private void assertNull(String msg, Object o) {\n+        if (o != null) {\n+            fail(msg + \": expected null but got '\" + o + \"'\");\n+        }\n+    }\n+\n+    private void assertNotNull(String msg, Object o) {\n+        if (o == null) {\n+            fail(msg + \": expected non null\");\n+        }\n+    }\n+\n+    \/\/ not currently used, might get rid of exceptions from the API\n+    private abstract class ExceptionTest {\n+        private final Class<? extends Exception> exceptionClass;\n+\n+        ExceptionTest(Class<? extends Exception> exceptionClass) {\n+            this.exceptionClass = exceptionClass;\n+        }\n+\n+        public void run() {\n+            String failMsg = null;\n+            try {\n+                call();\n+                failMsg = \"expected \" + exceptionClass.getName() + \"  but no exception thrown.\";\n+            }\n+            catch (Exception e) {\n+                if (!exceptionClass.isAssignableFrom(e.getClass())) {\n+                    failMsg = \"expected \" + exceptionClass.getName() + \" but caught \" + e;\n+                }\n+            }\n+            if (failMsg != null) {\n+                String msg = message();\n+                msg = msg == null ? \"\" : msg + \" \";\n+                fail(msg + failMsg);\n+            }\n+        }\n+\n+        public String message() {\n+            return null;\n+        }\n+\n+        public abstract void call();\n+    }\n+\n+    private abstract class ExpectNPE extends ExceptionTest {\n+        ExpectNPE() {\n+            super(NullPointerException.class);\n+            run();\n+        }\n+    }\n+\n+    private abstract class BuilderNPE extends ExceptionTest {\n+        protected final String msg;\n+        protected final Builder b = new Builder();\n+\n+        BuilderNPE(String msg) {\n+            super(NullPointerException.class);\n+\n+            this.msg = msg;\n+\n+            run();\n+        }\n+\n+        public String message() {\n+            return msg;\n+        }\n+    }\n+\n+    private abstract class ExpectIAE extends ExceptionTest {\n+        ExpectIAE() {\n+            super(IllegalArgumentException.class);\n+            run();\n+        }\n+    }\n+\n+    private abstract class BuilderILE extends ExceptionTest {\n+        protected final String[] args;\n+        protected final Builder b = new Builder();\n+\n+        protected String arg; \/\/ mutates during call\n+\n+        BuilderILE(String... args) {\n+            super(IllformedLocaleException.class);\n+\n+            this.args = args;\n+\n+            run();\n+        }\n+\n+        public void run() {\n+            for (String arg : args) {\n+                this.arg = arg;\n+                super.run();\n+            }\n+        }\n+\n+        public String message() {\n+            return \"arg: '\" + arg + \"'\";\n+        }\n","filename":"test\/jdk\/java\/util\/Locale\/LocaleEnhanceTest.java","additions":598,"deletions":485,"binary":false,"changes":1083,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,0 @@\n- * @requires test.thread.factory == null\n","filename":"test\/jdk\/java\/util\/concurrent\/locks\/Lock\/OOMEInAQS.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-import java.util.concurrent.ForkJoinWorkerThread;\n@@ -5137,42 +5136,0 @@\n-\n-    public void testOnlyHelpsIfInTheSamePool() throws Exception {\n-        class Logic {\n-            interface Extractor { ForkJoinPool pool(CompletableFuture<ForkJoinPool> cf) throws Exception; }\n-            static final List<ForkJoinPool> executeInnerOuter(\n-                ForkJoinPool outer, ForkJoinPool inner, Logic.Extractor extractor\n-            ) throws Exception {\n-                return CompletableFuture.supplyAsync(() ->\n-                    Stream.iterate(1, i -> i + 1)\n-                        .limit(64)\n-                        .map(i -> CompletableFuture.supplyAsync(\n-                            () -> Thread.currentThread() instanceof ForkJoinWorkerThread wt ? wt.getPool() : null, inner)\n-                        )\n-                        .map(cf -> {\n-                            try {\n-                                return extractor.pool(cf);\n-                            } catch (Exception ex) {\n-                                throw new AssertionError(\"Unexpected\", ex);\n-                            }\n-                        })\n-                        .toList()\n-                , outer).join();\n-            }\n-        }\n-\n-        List<Logic.Extractor> extractors =\n-            List.of(\n-                c -> c.get(60, SECONDS),\n-                CompletableFuture::get,\n-                CompletableFuture::join\n-            );\n-\n-        try (var pool = new ForkJoinPool(2)) {\n-            for (var extractor : extractors) {\n-                for (var p : Logic.executeInnerOuter(pool, ForkJoinPool.commonPool(), extractor))\n-                    assertTrue(p != pool); \/\/ The inners should have all been executed by commonPool\n-\n-                for (var p : Logic.executeInnerOuter(pool, pool, extractor))\n-                    assertTrue(p == pool); \/\/ The inners could have been helped by the outer\n-            }\n-        }\n-    }\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/CompletableFutureTest.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n- * @enablePreview\n@@ -42,17 +41,4 @@\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.security.PEMDecoder;\n-import java.security.PEMEncoder;\n-import java.security.interfaces.RSAPrivateKey;\n-import java.security.spec.PKCS8EncodedKeySpec;\n-import javax.net.ssl.KeyManagerFactory;\n-import javax.net.ssl.SNIHostName;\n-import javax.net.ssl.SNIServerName;\n-import javax.net.ssl.SSLContext;\n-import javax.net.ssl.SSLParameters;\n-import javax.net.ssl.SSLServerSocket;\n-import javax.net.ssl.SSLServerSocketFactory;\n-import javax.net.ssl.SSLSession;\n-import javax.net.ssl.SSLSocket;\n-import javax.net.ssl.SSLSocketFactory;\n-import javax.net.ssl.TrustManagerFactory;\n+import java.net.*;\n+import java.util.*;\n+import java.io.*;\n+import javax.net.ssl.*;\n@@ -64,1 +50,3 @@\n-import java.util.ArrayList;\n+import java.security.cert.CertificateFactory;\n+import java.security.spec.*;\n+import java.security.interfaces.*;\n@@ -66,1 +54,0 @@\n-import java.util.List;\n@@ -90,16 +77,16 @@\n-            \"-----BEGIN CERTIFICATE-----\\n\" +\n-            \"MIICkjCCAfugAwIBAgIBADANBgkqhkiG9w0BAQQFADA7MQswCQYDVQQGEwJVUzEN\\n\" +\n-            \"MAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwHhcN\\n\" +\n-            \"MTIwNDE3MTIwNjA3WhcNMzMwMzI4MTIwNjA3WjA7MQswCQYDVQQGEwJVUzENMAsG\\n\" +\n-            \"A1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwgZ8wDQYJ\\n\" +\n-            \"KoZIhvcNAQEBBQADgY0AMIGJAoGBANY+7Enp+1S566kLcKk+qe4Ki6BxaHGZ+v7r\\n\" +\n-            \"vLksx9IQZCbAEf4YLbrZhKzKD3SPIJXyxPFwknAknIh3Knk8mViOZks7T8L3GnJr\\n\" +\n-            \"TBaVvDyTzDJum\/QYiahfO2qpfN\/Oya2UILmqsBAeLyWpzbQsAyWBXfoUtkOUgnzK\\n\" +\n-            \"fk6QAKYrAgMBAAGjgaUwgaIwHQYDVR0OBBYEFEtmQi7jT1ijXOafPsfkrLwSVu9e\\n\" +\n-            \"MGMGA1UdIwRcMFqAFEtmQi7jT1ijXOafPsfkrLwSVu9eoT+kPTA7MQswCQYDVQQG\\n\" +\n-            \"EwJVUzENMAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2\\n\" +\n-            \"Y2WCAQAwDwYDVR0TAQH\/BAUwAwEB\/zALBgNVHQ8EBAMCAQYwDQYJKoZIhvcNAQEE\\n\" +\n-            \"BQADgYEAkKWxMc4+ODk5WwLXXweB8\/IKfVfrizNn0KLEgsZ6xNXFIXDpiPGAFcgl\\n\" +\n-            \"MzFO424JgyvUulsUc\/X16Cnuwwntkk6KUG7vEV7h4o9sAV7Cax3gfQE\/EZFb4ybn\\n\" +\n-            \"aBm1UsujMKd\/ovqbbbxJbmOWzCeo0QfIGleDEyh3NBBZ0i11Kiw=\\n\" +\n-            \"-----END CERTIFICATE-----\";\n+        \"-----BEGIN CERTIFICATE-----\\n\" +\n+        \"MIICkjCCAfugAwIBAgIBADANBgkqhkiG9w0BAQQFADA7MQswCQYDVQQGEwJVUzEN\\n\" +\n+        \"MAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwHhcN\\n\" +\n+        \"MTIwNDE3MTIwNjA3WhcNMzMwMzI4MTIwNjA3WjA7MQswCQYDVQQGEwJVUzENMAsG\\n\" +\n+        \"A1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwgZ8wDQYJ\\n\" +\n+        \"KoZIhvcNAQEBBQADgY0AMIGJAoGBANY+7Enp+1S566kLcKk+qe4Ki6BxaHGZ+v7r\\n\" +\n+        \"vLksx9IQZCbAEf4YLbrZhKzKD3SPIJXyxPFwknAknIh3Knk8mViOZks7T8L3GnJr\\n\" +\n+        \"TBaVvDyTzDJum\/QYiahfO2qpfN\/Oya2UILmqsBAeLyWpzbQsAyWBXfoUtkOUgnzK\\n\" +\n+        \"fk6QAKYrAgMBAAGjgaUwgaIwHQYDVR0OBBYEFEtmQi7jT1ijXOafPsfkrLwSVu9e\\n\" +\n+        \"MGMGA1UdIwRcMFqAFEtmQi7jT1ijXOafPsfkrLwSVu9eoT+kPTA7MQswCQYDVQQG\\n\" +\n+        \"EwJVUzENMAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2\\n\" +\n+        \"Y2WCAQAwDwYDVR0TAQH\/BAUwAwEB\/zALBgNVHQ8EBAMCAQYwDQYJKoZIhvcNAQEE\\n\" +\n+        \"BQADgYEAkKWxMc4+ODk5WwLXXweB8\/IKfVfrizNn0KLEgsZ6xNXFIXDpiPGAFcgl\\n\" +\n+        \"MzFO424JgyvUulsUc\/X16Cnuwwntkk6KUG7vEV7h4o9sAV7Cax3gfQE\/EZFb4ybn\\n\" +\n+        \"aBm1UsujMKd\/ovqbbbxJbmOWzCeo0QfIGleDEyh3NBBZ0i11Kiw=\\n\" +\n+        \"-----END CERTIFICATE-----\";\n@@ -109,15 +96,15 @@\n-            \"-----BEGIN CERTIFICATE-----\\n\" +\n-            \"MIICVTCCAb6gAwIBAgIBAjANBgkqhkiG9w0BAQQFADA7MQswCQYDVQQGEwJVUzEN\\n\" +\n-            \"MAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwHhcN\\n\" +\n-            \"MTIwNDE3MTIwNjA4WhcNMzIwMTAzMTIwNjA4WjBVMQswCQYDVQQGEwJVUzENMAsG\\n\" +\n-            \"A1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UxGDAWBgNV\\n\" +\n-            \"BAMTD3d3dy5leGFtcGxlLmNvbTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA\\n\" +\n-            \"4zFp3PZNzsd3ZwG6FNNWO9eSN+UBymlf8oCwpKJM2tIinmMWvWIXnlx\/2UXIfSAq\\n\" +\n-            \"QEG3aXkAFyEiGGpQlBbqcfrESsHsiz2pnnm5dG2v\/eS0Bwz1jmcuNmwnh3UQw2Vl\\n\" +\n-            \"+BLk8ukdrLjiCT8jARiHExYf1Xg+wUqQ9y8NV26hdaUCAwEAAaNPME0wCwYDVR0P\\n\" +\n-            \"BAQDAgPoMB0GA1UdDgQWBBQwtx+gqzn2w4y82brXlp7tqBYEZDAfBgNVHSMEGDAW\\n\" +\n-            \"gBRLZkIu409Yo1zmnz7H5Ky8ElbvXjANBgkqhkiG9w0BAQQFAAOBgQAJWo8B6Ud+\\n\" +\n-            \"\/OU+UcZLihlfMX02OSlK2ZB7mfqpj2G3JT9yb0A+VbY3uuajmaYYIIxl3kXGz\/n8\\n\" +\n-            \"M2Q\/Ux\/MDxG+IFKHC26Kuj4dAQgzjq2pILVPTE2QnaQTNCsgVZtTaC47SG9FRSoC\\n\" +\n-            \"qvnIvn\/oTpKSqus76I1cR4joDtiV2OEuVw==\\n\" +\n-            \"-----END CERTIFICATE-----\";\n+        \"-----BEGIN CERTIFICATE-----\\n\" +\n+        \"MIICVTCCAb6gAwIBAgIBAjANBgkqhkiG9w0BAQQFADA7MQswCQYDVQQGEwJVUzEN\\n\" +\n+        \"MAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwHhcN\\n\" +\n+        \"MTIwNDE3MTIwNjA4WhcNMzIwMTAzMTIwNjA4WjBVMQswCQYDVQQGEwJVUzENMAsG\\n\" +\n+        \"A1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UxGDAWBgNV\\n\" +\n+        \"BAMTD3d3dy5leGFtcGxlLmNvbTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA\\n\" +\n+        \"4zFp3PZNzsd3ZwG6FNNWO9eSN+UBymlf8oCwpKJM2tIinmMWvWIXnlx\/2UXIfSAq\\n\" +\n+        \"QEG3aXkAFyEiGGpQlBbqcfrESsHsiz2pnnm5dG2v\/eS0Bwz1jmcuNmwnh3UQw2Vl\\n\" +\n+        \"+BLk8ukdrLjiCT8jARiHExYf1Xg+wUqQ9y8NV26hdaUCAwEAAaNPME0wCwYDVR0P\\n\" +\n+        \"BAQDAgPoMB0GA1UdDgQWBBQwtx+gqzn2w4y82brXlp7tqBYEZDAfBgNVHSMEGDAW\\n\" +\n+        \"gBRLZkIu409Yo1zmnz7H5Ky8ElbvXjANBgkqhkiG9w0BAQQFAAOBgQAJWo8B6Ud+\\n\" +\n+        \"\/OU+UcZLihlfMX02OSlK2ZB7mfqpj2G3JT9yb0A+VbY3uuajmaYYIIxl3kXGz\/n8\\n\" +\n+        \"M2Q\/Ux\/MDxG+IFKHC26Kuj4dAQgzjq2pILVPTE2QnaQTNCsgVZtTaC47SG9FRSoC\\n\" +\n+        \"qvnIvn\/oTpKSqus76I1cR4joDtiV2OEuVw==\\n\" +\n+        \"-----END CERTIFICATE-----\";\n@@ -127,16 +114,14 @@\n-            \"-----BEGIN PRIVATE KEY-----\\n\" +\n-            \"MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAOMxadz2Tc7Hd2cB\\n\" +\n-            \"uhTTVjvXkjflAcppX\/KAsKSiTNrSIp5jFr1iF55cf9lFyH0gKkBBt2l5ABchIhhq\\n\" +\n-            \"UJQW6nH6xErB7Is9qZ55uXRtr\/3ktAcM9Y5nLjZsJ4d1EMNlZfgS5PLpHay44gk\/\\n\" +\n-            \"IwEYhxMWH9V4PsFKkPcvDVduoXWlAgMBAAECgYAqX2nuIyXp3fvgA0twXOYlbRRB\\n\" +\n-            \"Rn3qAXM6qFPJsNeCrFR2k+aG1cev6nKR1FkLNTeMGnWZv06MAcr5IML8i7WXyG4C\\n\" +\n-            \"LY\/C0gedn94FDKFlln+bTENwQTGjn4lKysDA+IuNpasTeMCajbic+dPByhIdTOjZ\\n\" +\n-            \"iMCyxbLfpk40zQopVQJBAPyfGmkeHB3GjdbdgujWCGKb2UxBa4O8dy3O4l2yizTn\\n\" +\n-            \"uUqMGcwGY4ciNSVvZQ7jKo4vDmkSuYib4\/woPChaNfMCQQDmO0BQuSWYGNtSwV35\\n\" +\n-            \"lafZfX1dNCLKm1iNA6A12evXgvQiE9WT4mqionig0VZW16HtiY4\/BkHOcos\/K9Um\\n\" +\n-            \"ARQHAkA8mkaRtSF1my5nv1gqVz5Hua+VdZQ\/VDUbDiiL5cszc+ulkJqXsWirAG\/T\\n\" +\n-            \"fTe3LJQG7A7+8fkEZrF4yoY0AAA1AkEAotokezULj5N9iAL5SzL9wIzQYV4ggfny\\n\" +\n-            \"YATBjXXxKccakwQ+ndWZIiMUeoS4ssLialhTgucVI0fIkU2a\/r\/ifwJAc6e+5Pvh\\n\" +\n-            \"MghQj\/U788Od\/v6rgqz\/NGsduZ7uilCMcWiwA73OR2MHMH\/OIuoofuEPrfuV9isV\\n\" +\n-            \"xVXhgpKfP\/pdOA==\\n\" +\n-            \"-----END PRIVATE KEY-----\";\n+        \"MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAOMxadz2Tc7Hd2cB\\n\" +\n+        \"uhTTVjvXkjflAcppX\/KAsKSiTNrSIp5jFr1iF55cf9lFyH0gKkBBt2l5ABchIhhq\\n\" +\n+        \"UJQW6nH6xErB7Is9qZ55uXRtr\/3ktAcM9Y5nLjZsJ4d1EMNlZfgS5PLpHay44gk\/\\n\" +\n+        \"IwEYhxMWH9V4PsFKkPcvDVduoXWlAgMBAAECgYAqX2nuIyXp3fvgA0twXOYlbRRB\\n\" +\n+        \"Rn3qAXM6qFPJsNeCrFR2k+aG1cev6nKR1FkLNTeMGnWZv06MAcr5IML8i7WXyG4C\\n\" +\n+        \"LY\/C0gedn94FDKFlln+bTENwQTGjn4lKysDA+IuNpasTeMCajbic+dPByhIdTOjZ\\n\" +\n+        \"iMCyxbLfpk40zQopVQJBAPyfGmkeHB3GjdbdgujWCGKb2UxBa4O8dy3O4l2yizTn\\n\" +\n+        \"uUqMGcwGY4ciNSVvZQ7jKo4vDmkSuYib4\/woPChaNfMCQQDmO0BQuSWYGNtSwV35\\n\" +\n+        \"lafZfX1dNCLKm1iNA6A12evXgvQiE9WT4mqionig0VZW16HtiY4\/BkHOcos\/K9Um\\n\" +\n+        \"ARQHAkA8mkaRtSF1my5nv1gqVz5Hua+VdZQ\/VDUbDiiL5cszc+ulkJqXsWirAG\/T\\n\" +\n+        \"fTe3LJQG7A7+8fkEZrF4yoY0AAA1AkEAotokezULj5N9iAL5SzL9wIzQYV4ggfny\\n\" +\n+        \"YATBjXXxKccakwQ+ndWZIiMUeoS4ssLialhTgucVI0fIkU2a\/r\/ifwJAc6e+5Pvh\\n\" +\n+        \"MghQj\/U788Od\/v6rgqz\/NGsduZ7uilCMcWiwA73OR2MHMH\/OIuoofuEPrfuV9isV\\n\" +\n+        \"xVXhgpKfP\/pdOA==\";\n@@ -146,15 +131,15 @@\n-            \"-----BEGIN CERTIFICATE-----\\n\" +\n-            \"MIICVTCCAb6gAwIBAgIBBDANBgkqhkiG9w0BAQQFADA7MQswCQYDVQQGEwJVUzEN\\n\" +\n-            \"MAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwHhcN\\n\" +\n-            \"MTIwNDE3MTIwNjA5WhcNMzIwMTAzMTIwNjA5WjBVMQswCQYDVQQGEwJVUzENMAsG\\n\" +\n-            \"A1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UxGDAWBgNV\\n\" +\n-            \"BAMTD3d3dy5leGFtcGxlLm5ldDCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA\\n\" +\n-            \"2VlzF1fvWYczDChrUeJiLJ1M\/dIShCaOTfYGiXfQGEZCAWTacUclwr+rVMnZ75\/c\\n\" +\n-            \"wwg5pNdXRijxMil8DBTS1gFcIFQhosLHvzIAe6ULlg\/xB+\/L6KBz+NTWfo\/2KF6t\\n\" +\n-            \"xatmcToNrCcwi7eUOfbzQje65Tizs56jJYem2m7Rk0ECAwEAAaNPME0wCwYDVR0P\\n\" +\n-            \"BAQDAgPoMB0GA1UdDgQWBBQT\/FR0cAWcZQ7h0X79KGki34OSQjAfBgNVHSMEGDAW\\n\" +\n-            \"gBRLZkIu409Yo1zmnz7H5Ky8ElbvXjANBgkqhkiG9w0BAQQFAAOBgQB67cPIT6fz\\n\" +\n-            \"6Ws8fBpYgW2ad4ci66i1WduBD9CpGFE+jRK2feRj6hvYBXocKj0AMWUFIEB2E3hA\\n\" +\n-            \"oIjxcf1GxIpHVl9DjlhxqXbA0Ktl7\/NGNRlDSLTizOTl3FB1mMTlOGvXDVmpcFhl\\n\" +\n-            \"HuoP1hYvhTsBwPx5igGNchuPtDIUzL2mXw==\\n\" +\n-            \"-----END CERTIFICATE-----\";\n+        \"-----BEGIN CERTIFICATE-----\\n\" +\n+        \"MIICVTCCAb6gAwIBAgIBBDANBgkqhkiG9w0BAQQFADA7MQswCQYDVQQGEwJVUzEN\\n\" +\n+        \"MAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwHhcN\\n\" +\n+        \"MTIwNDE3MTIwNjA5WhcNMzIwMTAzMTIwNjA5WjBVMQswCQYDVQQGEwJVUzENMAsG\\n\" +\n+        \"A1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UxGDAWBgNV\\n\" +\n+        \"BAMTD3d3dy5leGFtcGxlLm5ldDCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA\\n\" +\n+        \"2VlzF1fvWYczDChrUeJiLJ1M\/dIShCaOTfYGiXfQGEZCAWTacUclwr+rVMnZ75\/c\\n\" +\n+        \"wwg5pNdXRijxMil8DBTS1gFcIFQhosLHvzIAe6ULlg\/xB+\/L6KBz+NTWfo\/2KF6t\\n\" +\n+        \"xatmcToNrCcwi7eUOfbzQje65Tizs56jJYem2m7Rk0ECAwEAAaNPME0wCwYDVR0P\\n\" +\n+        \"BAQDAgPoMB0GA1UdDgQWBBQT\/FR0cAWcZQ7h0X79KGki34OSQjAfBgNVHSMEGDAW\\n\" +\n+        \"gBRLZkIu409Yo1zmnz7H5Ky8ElbvXjANBgkqhkiG9w0BAQQFAAOBgQB67cPIT6fz\\n\" +\n+        \"6Ws8fBpYgW2ad4ci66i1WduBD9CpGFE+jRK2feRj6hvYBXocKj0AMWUFIEB2E3hA\\n\" +\n+        \"oIjxcf1GxIpHVl9DjlhxqXbA0Ktl7\/NGNRlDSLTizOTl3FB1mMTlOGvXDVmpcFhl\\n\" +\n+        \"HuoP1hYvhTsBwPx5igGNchuPtDIUzL2mXw==\\n\" +\n+        \"-----END CERTIFICATE-----\";\n@@ -163,16 +148,14 @@\n-            \"-----BEGIN PRIVATE KEY-----\\n\" +\n-            \"MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBANlZcxdX71mHMwwo\\n\" +\n-            \"a1HiYiydTP3SEoQmjk32Bol30BhGQgFk2nFHJcK\/q1TJ2e+f3MMIOaTXV0Yo8TIp\\n\" +\n-            \"fAwU0tYBXCBUIaLCx78yAHulC5YP8Qfvy+igc\/jU1n6P9ihercWrZnE6DawnMIu3\\n\" +\n-            \"lDn280I3uuU4s7OeoyWHptpu0ZNBAgMBAAECgYEAl19H26sfhD+32rDPxZCgBShs\\n\" +\n-            \"dZ33zVe45i0Bcn4iTLWpxKTDyf7eGps4rO2DvfKdYqt40ggzvSZIjUH9JcDe8GmG\\n\" +\n-            \"d3m0ILB7pg4jsFlpyeHpTO8grPLxA1G9s3o0DoFpz\/rooqgFfe\/DrRDmRoOSkgfV\\n\" +\n-            \"\/gseIbgJHRO\/Ctyvdh0CQQD6uFd0HxhH1jl\/JzvPzIH4LSnPcdEh9zsMEb6uzh75\\n\" +\n-            \"9qL+IHD5N2I\/pYZTKqDFIwhJf701+LKag55AX\/zrDt7rAkEA3e00AbnwanDMa6Wj\\n\" +\n-            \"+gFekUQveSVra38LiihzCkyVvQpFjbiF1rUhSNQ0dpU5\/hmrYF0C6H9VXAesfkUY\\n\" +\n-            \"WhpDgwJAYjgZOop77piDycZK7isFt32p5XSHIzFBVocVFlH1XKM8UyXOXDNQL\/Le\\n\" +\n-            \"XnJSrSf+NRzvuNcG0PVC56Ey6brXpQJAY4M4vcltt5zq3R5CQBmbGRJ1IyKXX3Vx\\n\" +\n-            \"bDslEqoyvri7ZYgnY5aG3UxiVgYmIf3KrgQnCLAIS6MZQumiuMxsFwJAK5pEG063\\n\" +\n-            \"9ngUof4fDMvZphqZjZR1zMKz\/V\/9ge0DWBINaqFgsgebNu+MyImsC8C6WKjGmV\/2\\n\" +\n-            \"f1MY0D7sC2vU\/Q==\\n\" +\n-            \"-----END PRIVATE KEY-----\";\n+        \"MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBANlZcxdX71mHMwwo\\n\" +\n+        \"a1HiYiydTP3SEoQmjk32Bol30BhGQgFk2nFHJcK\/q1TJ2e+f3MMIOaTXV0Yo8TIp\\n\" +\n+        \"fAwU0tYBXCBUIaLCx78yAHulC5YP8Qfvy+igc\/jU1n6P9ihercWrZnE6DawnMIu3\\n\" +\n+        \"lDn280I3uuU4s7OeoyWHptpu0ZNBAgMBAAECgYEAl19H26sfhD+32rDPxZCgBShs\\n\" +\n+        \"dZ33zVe45i0Bcn4iTLWpxKTDyf7eGps4rO2DvfKdYqt40ggzvSZIjUH9JcDe8GmG\\n\" +\n+        \"d3m0ILB7pg4jsFlpyeHpTO8grPLxA1G9s3o0DoFpz\/rooqgFfe\/DrRDmRoOSkgfV\\n\" +\n+        \"\/gseIbgJHRO\/Ctyvdh0CQQD6uFd0HxhH1jl\/JzvPzIH4LSnPcdEh9zsMEb6uzh75\\n\" +\n+        \"9qL+IHD5N2I\/pYZTKqDFIwhJf701+LKag55AX\/zrDt7rAkEA3e00AbnwanDMa6Wj\\n\" +\n+        \"+gFekUQveSVra38LiihzCkyVvQpFjbiF1rUhSNQ0dpU5\/hmrYF0C6H9VXAesfkUY\\n\" +\n+        \"WhpDgwJAYjgZOop77piDycZK7isFt32p5XSHIzFBVocVFlH1XKM8UyXOXDNQL\/Le\\n\" +\n+        \"XnJSrSf+NRzvuNcG0PVC56Ey6brXpQJAY4M4vcltt5zq3R5CQBmbGRJ1IyKXX3Vx\\n\" +\n+        \"bDslEqoyvri7ZYgnY5aG3UxiVgYmIf3KrgQnCLAIS6MZQumiuMxsFwJAK5pEG063\\n\" +\n+        \"9ngUof4fDMvZphqZjZR1zMKz\/V\/9ge0DWBINaqFgsgebNu+MyImsC8C6WKjGmV\/2\\n\" +\n+        \"f1MY0D7sC2vU\/Q==\";\n@@ -182,15 +165,15 @@\n-            \"-----BEGIN CERTIFICATE-----\\n\" +\n-            \"MIICVTCCAb6gAwIBAgIBAzANBgkqhkiG9w0BAQQFADA7MQswCQYDVQQGEwJVUzEN\\n\" +\n-            \"MAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwHhcN\\n\" +\n-            \"MTIwNDE3MTIwNjA5WhcNMzIwMTAzMTIwNjA5WjBVMQswCQYDVQQGEwJVUzENMAsG\\n\" +\n-            \"A1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UxGDAWBgNV\\n\" +\n-            \"BAMTD3d3dy5pbnZhbGlkLmNvbTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA\\n\" +\n-            \"q6MyQwzCr2nJ41l0frmHL0qULSyW51MhevBC+1W28i0LE\/efrmpwV3LdnlQEGFak\\n\" +\n-            \"DLDwtnff3iru8dSMcA7KdWVkivsE7ZTP+qFDaWBAy7XXiSsv6yZ2Nh4jJb0YcD28\\n\" +\n-            \"45zk2nAl5Az1\/PuoTi1vpQxzFZKuBm1HGgz3MEZvBvMCAwEAAaNPME0wCwYDVR0P\\n\" +\n-            \"BAQDAgPoMB0GA1UdDgQWBBRRMifrND015Nm8N6gV5X7cg1YjjjAfBgNVHSMEGDAW\\n\" +\n-            \"gBRLZkIu409Yo1zmnz7H5Ky8ElbvXjANBgkqhkiG9w0BAQQFAAOBgQBjkUO6Ri\/B\\n\" +\n-            \"uDC2gDMIyL5+NTe\/1dPPQYM4HhCNa\/KQYvU5lzCKO9Vpa+i+nyrUNNXUu8Tkyq4Y\\n\" +\n-            \"A+aGSm6+FT\/i9rFwkYUdorBtD3KfQiwTIWrVERXBkWI5iZNaVZhx0TFy4vUpf65d\\n\" +\n-            \"QtwkbHpC66fdKc2EdLXkuY9KkmtZZJJ7YA==\\n\" +\n-            \"-----END CERTIFICATE-----\";\n+        \"-----BEGIN CERTIFICATE-----\\n\" +\n+        \"MIICVTCCAb6gAwIBAgIBAzANBgkqhkiG9w0BAQQFADA7MQswCQYDVQQGEwJVUzEN\\n\" +\n+        \"MAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwHhcN\\n\" +\n+        \"MTIwNDE3MTIwNjA5WhcNMzIwMTAzMTIwNjA5WjBVMQswCQYDVQQGEwJVUzENMAsG\\n\" +\n+        \"A1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UxGDAWBgNV\\n\" +\n+        \"BAMTD3d3dy5pbnZhbGlkLmNvbTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA\\n\" +\n+        \"q6MyQwzCr2nJ41l0frmHL0qULSyW51MhevBC+1W28i0LE\/efrmpwV3LdnlQEGFak\\n\" +\n+        \"DLDwtnff3iru8dSMcA7KdWVkivsE7ZTP+qFDaWBAy7XXiSsv6yZ2Nh4jJb0YcD28\\n\" +\n+        \"45zk2nAl5Az1\/PuoTi1vpQxzFZKuBm1HGgz3MEZvBvMCAwEAAaNPME0wCwYDVR0P\\n\" +\n+        \"BAQDAgPoMB0GA1UdDgQWBBRRMifrND015Nm8N6gV5X7cg1YjjjAfBgNVHSMEGDAW\\n\" +\n+        \"gBRLZkIu409Yo1zmnz7H5Ky8ElbvXjANBgkqhkiG9w0BAQQFAAOBgQBjkUO6Ri\/B\\n\" +\n+        \"uDC2gDMIyL5+NTe\/1dPPQYM4HhCNa\/KQYvU5lzCKO9Vpa+i+nyrUNNXUu8Tkyq4Y\\n\" +\n+        \"A+aGSm6+FT\/i9rFwkYUdorBtD3KfQiwTIWrVERXBkWI5iZNaVZhx0TFy4vUpf65d\\n\" +\n+        \"QtwkbHpC66fdKc2EdLXkuY9KkmtZZJJ7YA==\\n\" +\n+        \"-----END CERTIFICATE-----\";\n@@ -199,16 +182,14 @@\n-            \"-----BEGIN PRIVATE KEY-----\\n\" +\n-            \"MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBAKujMkMMwq9pyeNZ\\n\" +\n-            \"dH65hy9KlC0sludTIXrwQvtVtvItCxP3n65qcFdy3Z5UBBhWpAyw8LZ3394q7vHU\\n\" +\n-            \"jHAOynVlZIr7BO2Uz\/qhQ2lgQMu114krL+smdjYeIyW9GHA9vOOc5NpwJeQM9fz7\\n\" +\n-            \"qE4tb6UMcxWSrgZtRxoM9zBGbwbzAgMBAAECgYASJDK40Y12Wvki1Z6xkkyOnBRj\\n\" +\n-            \"XfYpRykfxGtgA2RN3qLwHlk7Zzaul46DIKA6LlYynTUkJDF+Ww1cdDnP0lBlwcmM\\n\" +\n-            \"iD0ck3zYyYBLhQHuVbkK3SYE+ANRhM0icvvqANP2at\/U4awQcPNEae\/KCiecLNu3\\n\" +\n-            \"CJGqyhPDdrEAqPuJGQJBAN46pQC6l3yrcSYE2s53jSmsm2HVVOFlFXjU6k\/RMTxG\\n\" +\n-            \"FfDJtGUAOQ37rPQ06ugr\/gjLAmmPp+FXozaBdA32D80CQQDFuGRgv3WYqbglIcRL\\n\" +\n-            \"JRs6xlj9w1F97s\/aiUenuwhIPNiUoRbV7mnNuZ\/sGF0svOVE7SazRjuFX6UqL9Y9\\n\" +\n-            \"HzG\/AkEA170pCI8cl4w8eUNHRB9trGKEKjMXhwVCFh7lJf2ZBcGodSzr8w2HVhrZ\\n\" +\n-            \"Ke7hiemDYffrbJ1oxmv05+o+x3r0lQJBAL6adVm2+FyFMFnLZXmzeb59O4jWY5bt\\n\" +\n-            \"Qz6\/HG6bpO5OidMuP99YCHMkQQDOs\/PO3Y5GuAoW6IY4n\/Y9S2B80+0CQBl1\/H9\/\\n\" +\n-            \"0n\/vrb6vW6Azds49tuS82RFAnOhtwTyBEajs08WF8rZQ3WD2RHJnH0+jjfL0anIp\\n\" +\n-            \"dQBSeNN7s7b6rRk=\\n\" +\n-            \"-----END PRIVATE KEY-----\";\n+        \"MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBAKujMkMMwq9pyeNZ\\n\" +\n+        \"dH65hy9KlC0sludTIXrwQvtVtvItCxP3n65qcFdy3Z5UBBhWpAyw8LZ3394q7vHU\\n\" +\n+        \"jHAOynVlZIr7BO2Uz\/qhQ2lgQMu114krL+smdjYeIyW9GHA9vOOc5NpwJeQM9fz7\\n\" +\n+        \"qE4tb6UMcxWSrgZtRxoM9zBGbwbzAgMBAAECgYASJDK40Y12Wvki1Z6xkkyOnBRj\\n\" +\n+        \"XfYpRykfxGtgA2RN3qLwHlk7Zzaul46DIKA6LlYynTUkJDF+Ww1cdDnP0lBlwcmM\\n\" +\n+        \"iD0ck3zYyYBLhQHuVbkK3SYE+ANRhM0icvvqANP2at\/U4awQcPNEae\/KCiecLNu3\\n\" +\n+        \"CJGqyhPDdrEAqPuJGQJBAN46pQC6l3yrcSYE2s53jSmsm2HVVOFlFXjU6k\/RMTxG\\n\" +\n+        \"FfDJtGUAOQ37rPQ06ugr\/gjLAmmPp+FXozaBdA32D80CQQDFuGRgv3WYqbglIcRL\\n\" +\n+        \"JRs6xlj9w1F97s\/aiUenuwhIPNiUoRbV7mnNuZ\/sGF0svOVE7SazRjuFX6UqL9Y9\\n\" +\n+        \"HzG\/AkEA170pCI8cl4w8eUNHRB9trGKEKjMXhwVCFh7lJf2ZBcGodSzr8w2HVhrZ\\n\" +\n+        \"Ke7hiemDYffrbJ1oxmv05+o+x3r0lQJBAL6adVm2+FyFMFnLZXmzeb59O4jWY5bt\\n\" +\n+        \"Qz6\/HG6bpO5OidMuP99YCHMkQQDOs\/PO3Y5GuAoW6IY4n\/Y9S2B80+0CQBl1\/H9\/\\n\" +\n+        \"0n\/vrb6vW6Azds49tuS82RFAnOhtwTyBEajs08WF8rZQ3WD2RHJnH0+jjfL0anIp\\n\" +\n+        \"dQBSeNN7s7b6rRk=\";\n@@ -217,16 +198,16 @@\n-    static String targetCertStr_D =\n-            \"-----BEGIN CERTIFICATE-----\\n\" +\n-            \"MIICVDCCAb2gAwIBAgIBBTANBgkqhkiG9w0BAQQFADA7MQswCQYDVQQGEwJVUzEN\\n\" +\n-            \"MAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwHhcN\\n\" +\n-            \"MTIwNDE3MTIwNjEwWhcNMzIwMTAzMTIwNjEwWjBUMQswCQYDVQQGEwJVUzENMAsG\\n\" +\n-            \"A1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UxFzAVBgNV\\n\" +\n-            \"BAMTDkludGVyT3AgVGVzdGVyMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDo\\n\" +\n-            \"Q\/KoAIAC2ljFfW2KwjnxTzi4NQJeUuk2seqKpsAY8x4O5dvixzUl6142zmljapqi\\n\" +\n-            \"bJloQVpfB+CEc5\/l4h5gzGRVzkuqP1oPzDrpZ5GsvmvuHenV\/TzCIgX1cLETzQVt\\n\" +\n-            \"6Rk06okoBPnw3hDJEJiEc1Rv7HCE8p\/p+SaiHrskwwIDAQABo08wTTALBgNVHQ8E\\n\" +\n-            \"BAMCA+gwHQYDVR0OBBYEFPr91O33RIGfFSqza2AwQIgE4QswMB8GA1UdIwQYMBaA\\n\" +\n-            \"FEtmQi7jT1ijXOafPsfkrLwSVu9eMA0GCSqGSIb3DQEBBAUAA4GBANIDFYgAhoj3\\n\" +\n-            \"B8u1YpqeoEp2Lt9TwrYBshaIrbmBPCwCGio0JIsoov3n8BCSg5F+8MnOtPl+TjeO\\n\" +\n-            \"0Ug+7guPdCk\/wg8YNxLHgSsQlpcNJDjWiErqmUPVrg5BPPQb65qMund6KTmMN0y6\\n\" +\n-            \"4EbSmxRpZO\/N0\/5oK4umTk0EeXKNekBj\\n\" +\n-            \"-----END CERTIFICATE-----\";\n+    static String targetCertStr_D=\n+        \"-----BEGIN CERTIFICATE-----\\n\" +\n+        \"MIICVDCCAb2gAwIBAgIBBTANBgkqhkiG9w0BAQQFADA7MQswCQYDVQQGEwJVUzEN\\n\" +\n+        \"MAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwHhcN\\n\" +\n+        \"MTIwNDE3MTIwNjEwWhcNMzIwMTAzMTIwNjEwWjBUMQswCQYDVQQGEwJVUzENMAsG\\n\" +\n+        \"A1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UxFzAVBgNV\\n\" +\n+        \"BAMTDkludGVyT3AgVGVzdGVyMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDo\\n\" +\n+        \"Q\/KoAIAC2ljFfW2KwjnxTzi4NQJeUuk2seqKpsAY8x4O5dvixzUl6142zmljapqi\\n\" +\n+        \"bJloQVpfB+CEc5\/l4h5gzGRVzkuqP1oPzDrpZ5GsvmvuHenV\/TzCIgX1cLETzQVt\\n\" +\n+        \"6Rk06okoBPnw3hDJEJiEc1Rv7HCE8p\/p+SaiHrskwwIDAQABo08wTTALBgNVHQ8E\\n\" +\n+        \"BAMCA+gwHQYDVR0OBBYEFPr91O33RIGfFSqza2AwQIgE4QswMB8GA1UdIwQYMBaA\\n\" +\n+        \"FEtmQi7jT1ijXOafPsfkrLwSVu9eMA0GCSqGSIb3DQEBBAUAA4GBANIDFYgAhoj3\\n\" +\n+        \"B8u1YpqeoEp2Lt9TwrYBshaIrbmBPCwCGio0JIsoov3n8BCSg5F+8MnOtPl+TjeO\\n\" +\n+        \"0Ug+7guPdCk\/wg8YNxLHgSsQlpcNJDjWiErqmUPVrg5BPPQb65qMund6KTmMN0y6\\n\" +\n+        \"4EbSmxRpZO\/N0\/5oK4umTk0EeXKNekBj\\n\" +\n+        \"-----END CERTIFICATE-----\";\n@@ -235,16 +216,14 @@\n-            \"-----BEGIN PRIVATE KEY-----\\n\" +\n-            \"MIICdQIBADANBgkqhkiG9w0BAQEFAASCAl8wggJbAgEAAoGBAOhD8qgAgALaWMV9\\n\" +\n-            \"bYrCOfFPOLg1Al5S6Tax6oqmwBjzHg7l2+LHNSXrXjbOaWNqmqJsmWhBWl8H4IRz\\n\" +\n-            \"n+XiHmDMZFXOS6o\/Wg\/MOulnkay+a+4d6dX9PMIiBfVwsRPNBW3pGTTqiSgE+fDe\\n\" +\n-            \"EMkQmIRzVG\/scITyn+n5JqIeuyTDAgMBAAECgYBw37yIKp4LRONJLnhSq6sO+0n8\\n\" +\n-            \"Mz6waiiN\/Q6XTQwj09pysQAYCGlqwSRrDAqpVsBJWO+Ae+oYLrLMi4hUZnwN75v3\\n\" +\n-            \"pe1nXlrD11RmPLXwBxqFxNSvAs2FgLHZEtwHI7Bn8KybT\/8bGkQ8csLceInYtMDD\\n\" +\n-            \"MuTyy2KRk\/pj60zIKQJBAPgebQiAH6viFQ88AwHaNvQhlUfwmSC1i6f8LVoeqaHC\\n\" +\n-            \"lnP0LJBwlyDeeEInhHrCR2ibnCB6I\/Pig+49XQgabK8CQQDvpJwuGEbsOO+3rkJJ\\n\" +\n-            \"OpOw4toG0QJZdRnT6l8I6BlboQRZSfFh+lGGahvFXkxc4KdUpJ7QPtXU7HHk6Huk\\n\" +\n-            \"8RYtAkA9CW8VGj+wTuuTVdX\/jKjcIa7RhbSFwWNbrcOSWdys+Gt+luCnn6rt4QyA\\n\" +\n-            \"aaxDbquWZkFgE+voQR7nap0KM0XtAkAznd0WAJymHM1lXt9gLoHJQ9N6TGKZKiPa\\n\" +\n-            \"BU1a+cMcfV4WbVrUo7oTnZ9Fr73681iXXq3mZOJh7lvJ1llreZIxAkBEnbiTgEf4\\n\" +\n-            \"tvku68jHcRbRPmdS7CBSWNEBaHLOm4pUSTcxVTKKMHw7vmM5\/UYUxJ8QNKCYxn6O\\n\" +\n-            \"+vtiBwBawwzN\\n\" +\n-            \"-----END PRIVATE KEY-----\";\n+        \"MIICdQIBADANBgkqhkiG9w0BAQEFAASCAl8wggJbAgEAAoGBAOhD8qgAgALaWMV9\\n\" +\n+        \"bYrCOfFPOLg1Al5S6Tax6oqmwBjzHg7l2+LHNSXrXjbOaWNqmqJsmWhBWl8H4IRz\\n\" +\n+        \"n+XiHmDMZFXOS6o\/Wg\/MOulnkay+a+4d6dX9PMIiBfVwsRPNBW3pGTTqiSgE+fDe\\n\" +\n+        \"EMkQmIRzVG\/scITyn+n5JqIeuyTDAgMBAAECgYBw37yIKp4LRONJLnhSq6sO+0n8\\n\" +\n+        \"Mz6waiiN\/Q6XTQwj09pysQAYCGlqwSRrDAqpVsBJWO+Ae+oYLrLMi4hUZnwN75v3\\n\" +\n+        \"pe1nXlrD11RmPLXwBxqFxNSvAs2FgLHZEtwHI7Bn8KybT\/8bGkQ8csLceInYtMDD\\n\" +\n+        \"MuTyy2KRk\/pj60zIKQJBAPgebQiAH6viFQ88AwHaNvQhlUfwmSC1i6f8LVoeqaHC\\n\" +\n+        \"lnP0LJBwlyDeeEInhHrCR2ibnCB6I\/Pig+49XQgabK8CQQDvpJwuGEbsOO+3rkJJ\\n\" +\n+        \"OpOw4toG0QJZdRnT6l8I6BlboQRZSfFh+lGGahvFXkxc4KdUpJ7QPtXU7HHk6Huk\\n\" +\n+        \"8RYtAkA9CW8VGj+wTuuTVdX\/jKjcIa7RhbSFwWNbrcOSWdys+Gt+luCnn6rt4QyA\\n\" +\n+        \"aaxDbquWZkFgE+voQR7nap0KM0XtAkAznd0WAJymHM1lXt9gLoHJQ9N6TGKZKiPa\\n\" +\n+        \"BU1a+cMcfV4WbVrUo7oTnZ9Fr73681iXXq3mZOJh7lvJ1llreZIxAkBEnbiTgEf4\\n\" +\n+        \"tvku68jHcRbRPmdS7CBSWNEBaHLOm4pUSTcxVTKKMHw7vmM5\/UYUxJ8QNKCYxn6O\\n\" +\n+        \"+vtiBwBawwzN\";\n@@ -259,1 +238,1 @@\n-    static char[] passphrase = \"passphrase\".toCharArray();\n+    static char passphrase[] = \"passphrase\".toCharArray();\n@@ -269,1 +248,1 @@\n-    static boolean debug = Boolean.getBoolean(\"test.debug\");\n+    static boolean debug = false;\n@@ -386,1 +365,2 @@\n-        final PEMDecoder pemDecoder = PEMDecoder.of();\n+        \/\/ generate certificate from cert string\n+        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n@@ -392,3 +372,0 @@\n-        \/\/ generate certificate from cert string\n-        Certificate trusedCert = pemDecoder.decode(trustedCertStr, X509Certificate.class);\n-\n@@ -396,0 +373,5 @@\n+        ByteArrayInputStream is =\n+                    new ByteArrayInputStream(trustedCertStr.getBytes());\n+        Certificate trusedCert = cf.generateCertificate(is);\n+        is.close();\n+\n@@ -411,1 +393,2 @@\n-            PKCS8EncodedKeySpec priKeySpec = pemDecoder.decode(keySpecStr, PKCS8EncodedKeySpec.class);\n+            PKCS8EncodedKeySpec priKeySpec = new PKCS8EncodedKeySpec(\n+                                Base64.getMimeDecoder().decode(keySpecStr));\n@@ -418,1 +401,3 @@\n-            Certificate keyCert = pemDecoder.decode(keyCertStr, X509Certificate.class);\n+            is = new ByteArrayInputStream(keyCertStr.getBytes());\n+            Certificate keyCert = cf.generateCertificate(is);\n+            is.close();\n@@ -539,12 +524,14 @@\n-            serverThread = new Thread(() -> {\n-                try {\n-                    doServerSide();\n-                } catch (Exception e) {\n-                    \/*\n-                     * Our server thread just died.\n-                     *\n-                     * Release the client, if not active already...\n-                     *\/\n-                    System.err.println(\"Server died, because of \" + e);\n-                    serverReady = true;\n-                    serverException = e;\n+            serverThread = new Thread() {\n+                public void run() {\n+                    try {\n+                        doServerSide();\n+                    } catch (Exception e) {\n+                        \/*\n+                         * Our server thread just died.\n+                         *\n+                         * Release the client, if not active already...\n+                         *\/\n+                        System.err.println(\"Server died, because of \" + e);\n+                        serverReady = true;\n+                        serverException = e;\n+                    }\n@@ -552,1 +539,1 @@\n-            });\n+            };\n@@ -567,9 +554,11 @@\n-            clientThread = new Thread(() -> {\n-                try {\n-                    doClientSide();\n-                } catch (Exception e) {\n-                    \/*\n-                     * Our client thread just died.\n-                     *\/\n-                    System.err.println(\"Client died, because of \" + e);\n-                    clientException = e;\n+            clientThread = new Thread() {\n+                public void run() {\n+                    try {\n+                        doClientSide();\n+                    } catch (Exception e) {\n+                        \/*\n+                         * Our client thread just died.\n+                         *\/\n+                        System.err.println(\"Client died, because of \" + e);\n+                        clientException = e;\n+                    }\n@@ -577,1 +566,1 @@\n-            });\n+            };\n","filename":"test\/jdk\/javax\/net\/ssl\/ServerName\/SSLSocketSNISensitive.java","additions":182,"deletions":193,"binary":false,"changes":375,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/javax\/net\/ssl\/interop\/ClientHelloBufferUnderflowException.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/javax\/net\/ssl\/interop\/ClientHelloChromeInterOp.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,8 +24,4 @@\n-import javax.net.ssl.KeyManagerFactory;\n-import javax.net.ssl.SSLContext;\n-import javax.net.ssl.SSLEngine;\n-import javax.net.ssl.SSLEngineResult;\n-import javax.net.ssl.SSLEngineResult.HandshakeStatus;\n-import javax.net.ssl.SSLSession;\n-import javax.net.ssl.TrustManagerFactory;\n-import java.nio.ByteBuffer;\n+import javax.net.ssl.*;\n+import javax.net.ssl.SSLEngineResult.*;\n+import java.io.*;\n+import java.nio.*;\n@@ -33,2 +29,0 @@\n-import java.security.PEMDecoder;\n-import java.security.PEMRecord;\n@@ -36,0 +30,1 @@\n+import java.security.KeyFactory;\n@@ -37,3 +32,3 @@\n-import java.security.cert.X509Certificate;\n-import java.security.interfaces.ECPrivateKey;\n-import java.security.interfaces.RSAPrivateKey;\n+import java.security.cert.CertificateFactory;\n+import java.security.spec.*;\n+import java.util.Base64;\n@@ -146,1 +141,0 @@\n-        \"-----BEGIN PRIVATE KEY-----\\n\" +\n@@ -149,2 +143,1 @@\n-        \"Ay6zUapMW9ydE84KGXyy5my+Sw7QKlmoveGNeZVf12nUVX+tQEYujVob\\n\" +\n-        \"-----END PRIVATE KEY-----\",\n+        \"Ay6zUapMW9ydE84KGXyy5my+Sw7QKlmoveGNeZVf12nUVX+tQEYujVob\",\n@@ -155,1 +148,0 @@\n-        \"-----BEGIN PRIVATE KEY-----\\n\" +\n@@ -181,3 +173,2 @@\n-        \"dKUqlw5BPHdbxoWB\/JpSHGCV\\n\" +\n-        \"-----END PRIVATE KEY-----\"\n-    };\n+        \"dKUqlw5BPHdbxoWB\/JpSHGCV\"\n+        };\n@@ -191,2 +182,0 @@\n-    private static final PEMDecoder pemDecoder = PEMDecoder.of();\n-\n@@ -265,1 +254,4 @@\n-        char[] passphrase = \"passphrase\".toCharArray();\n+        char passphrase[] = \"passphrase\".toCharArray();\n+\n+        \/\/ Generate certificate from cert string.\n+        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n@@ -268,0 +260,1 @@\n+        ByteArrayInputStream is;\n@@ -276,2 +269,7 @@\n-                \/\/ Generate certificate from cert string.\n-                trustedCert[i] = pemDecoder.decode(trustedCertStr, X509Certificate.class);\n+\n+                is = new ByteArrayInputStream(trustedCertStr.getBytes());\n+                try {\n+                    trustedCert[i] = cf.generateCertificate(is);\n+                } finally {\n+                    is.close();\n+                }\n@@ -300,5 +298,5 @@\n-                PrivateKey priKey = switch (keyMaterialKeyAlgs[i]) {\n-                    case \"RSA\" -> pemDecoder.decode(keyMaterialKeys[i], RSAPrivateKey.class);\n-                    case \"EC\" -> pemDecoder.decode(keyMaterialKeys[i], ECPrivateKey.class);\n-                    default -> pemDecoder.decode(keyMaterialKeys[i], PrivateKey.class);\n-                };\n+                PKCS8EncodedKeySpec priKeySpec = new PKCS8EncodedKeySpec(\n+                    Base64.getMimeDecoder().decode(keyMaterialKeys[i]));\n+                KeyFactory kf =\n+                    KeyFactory.getInstance(keyMaterialKeyAlgs[i]);\n+                PrivateKey priKey = kf.generatePrivate(priKeySpec);\n@@ -307,1 +305,8 @@\n-                Certificate keyCert  = pemDecoder.decode(keyCertStr, X509Certificate.class);\n+                is = new ByteArrayInputStream(keyCertStr.getBytes());\n+                Certificate keyCert = null;\n+                try {\n+                    keyCert = cf.generateCertificate(is);\n+                } finally {\n+                    is.close();\n+                }\n+\n","filename":"test\/jdk\/javax\/net\/ssl\/interop\/ClientHelloInterOp.java","additions":37,"deletions":32,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2016, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @bug 4234761\n@@ -28,0 +27,1 @@\n+ * @bug 4234761\n@@ -29,3 +29,1 @@\n- * @library \/test\/lib\n- * @build jtreg.SkippedException\n- * @run main Test4234761\n+ * @author Oleg Mokhovikov\n@@ -40,3 +38,0 @@\n-import javax.swing.UIManager;\n-\n-import jtreg.SkippedException;\n@@ -48,3 +43,0 @@\n-        if (UIManager.getLookAndFeel().getName().contains(\"GTK\")) {\n-            throw new SkippedException(\"Test skipped for GTK\");\n-        }\n","filename":"test\/jdk\/javax\/swing\/JColorChooser\/Test4234761.java","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -51,2 +51,2 @@\n-    private static volatile boolean upFail;\n-    private static volatile boolean downFail;\n+    private static boolean upFail;\n+    private static boolean downFail;\n@@ -73,2 +73,0 @@\n-            r.keyRelease(KeyEvent.VK_PAGE_UP);\n-\n@@ -81,1 +79,0 @@\n-\n@@ -86,1 +83,0 @@\n-\n@@ -88,2 +84,0 @@\n-            r.keyRelease(KeyEvent.VK_PAGE_DOWN);\n-\n@@ -96,1 +90,0 @@\n-\n","filename":"test\/jdk\/javax\/swing\/JSlider\/bug4382876.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,1 @@\n-                    frame = new JFrame(\"JSpinnerButtonFocusTest\");\n+                    frame = new JFrame();\n@@ -75,9 +75,0 @@\n-                    editor1.getTextField().addFocusListener(new FocusAdapter() {\n-                        @Override\n-                        public void focusGained(FocusEvent e) {\n-                            super.focusGained(e);\n-                            robot.keyPress(KeyEvent.VK_TAB);\n-                            robot.keyRelease(KeyEvent.VK_TAB);\n-                            latch1.countDown();\n-                        }\n-                    });\n@@ -96,2 +87,1 @@\n-                    frame.setSize(100, 100);\n-                    frame.setLocationRelativeTo(null);\n+                    frame.pack();\n@@ -101,1 +91,10 @@\n-                robot.delay(1000);\n+\n+                editor1.getTextField().addFocusListener(new FocusAdapter() {\n+                    @Override\n+                    public void focusGained(FocusEvent e) {\n+                        super.focusGained(e);\n+                        robot.keyPress(KeyEvent.VK_TAB);\n+                        robot.keyRelease(KeyEvent.VK_TAB);\n+                        latch1.countDown();\n+                    }\n+                });\n@@ -107,1 +106,1 @@\n-                if (!latch1.await(1, TimeUnit.MINUTES)) {\n+                if (!latch1.await(15, TimeUnit.MINUTES)) {\n","filename":"test\/jdk\/javax\/swing\/JSpinner\/8223788\/JSpinnerButtonFocusTest.java","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @requires (os.family != \"mac\")\n@@ -30,0 +29,4 @@\n+ * @author Oleg Mokhovikov\n+ * @library \/test\/lib\n+ * @library ..\/..\/regtesthelpers\n+ * @build Util jdk.test.lib.Platform\n@@ -32,3 +35,4 @@\n-\n-import java.awt.BorderLayout;\n-import java.awt.Robot;\n+import javax.swing.*;\n+import javax.swing.event.ChangeEvent;\n+import javax.swing.event.ChangeListener;\n+import java.awt.*;\n@@ -39,7 +43,1 @@\n-import javax.swing.JButton;\n-import javax.swing.JFrame;\n-import javax.swing.JTabbedPane;\n-import javax.swing.JTextField;\n-import javax.swing.SwingUtilities;\n-import javax.swing.event.ChangeEvent;\n-import javax.swing.event.ChangeListener;\n+import jdk.test.lib.Platform;\n@@ -48,0 +46,1 @@\n+\n@@ -75,1 +74,7 @@\n-            SwingUtilities.invokeAndWait(() -> createAndShowGUI());\n+            SwingUtilities.invokeAndWait(new Runnable() {\n+\n+                public void run() {\n+                    createAndShowGUI();\n+                }\n+            });\n+\n@@ -77,1 +82,8 @@\n-            SwingUtilities.invokeAndWait(() -> txtField.requestFocus());\n+\n+            SwingUtilities.invokeAndWait(new Runnable() {\n+\n+                public void run() {\n+                    txtField.requestFocus();\n+                }\n+            });\n+\n@@ -84,3 +96,6 @@\n-            SwingUtilities.invokeAndWait(() -> {\n-                tab.addChangeListener((ChangeListener) listener);\n-                txtField.removeFocusListener((FocusListener) listener);\n+            SwingUtilities.invokeAndWait(new Runnable() {\n+\n+                public void run() {\n+                    tab.addChangeListener((ChangeListener) listener);\n+                    txtField.removeFocusListener((FocusListener) listener);\n+                }\n@@ -91,4 +106,5 @@\n-            robot.keyPress(KeyEvent.VK_ALT);\n-            robot.keyPress(KeyEvent.VK_B);\n-            robot.keyRelease(KeyEvent.VK_B);\n-            robot.keyRelease(KeyEvent.VK_ALT);\n+            if (Platform.isOSX()) {\n+                Util.hitKeys(robot, KeyEvent.VK_CONTROL, KeyEvent.VK_ALT, KeyEvent.VK_B);\n+            } else {\n+                Util.hitKeys(robot, KeyEvent.VK_ALT, KeyEvent.VK_B);\n+            }\n@@ -99,2 +115,1 @@\n-                throw new RuntimeException(\"JTabbedPane mnemonics don't \" +\n-                        \"work from outside the tabbed pane\");\n+                throw new RuntimeException(\"JTabbedPane mnemonics don't work from outside the tabbed pane\");\n@@ -103,5 +118,1 @@\n-            SwingUtilities.invokeAndWait(() -> {\n-                if (frame != null) {\n-                    frame.dispose();\n-                }\n-            });\n+            if (frame != null) SwingUtilities.invokeAndWait(() ->  frame.dispose());\n","filename":"test\/jdk\/javax\/swing\/JTabbedPane\/4624207\/bug4624207.java","additions":39,"deletions":28,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-import javax.swing.UIManager;\n@@ -40,2 +39,1 @@\n-    public static void main(String[] args) throws Exception {\n-        UIManager.setLookAndFeel(\"com.sun.java.swing.plaf.motif.MotifLookAndFeel\");\n+    public static void main(String[] args) {\n","filename":"test\/jdk\/javax\/swing\/plaf\/motif\/bug4150591.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.lang.reflect.Constructor;\n@@ -27,0 +28,1 @@\n+import java.lang.reflect.InvocationTargetException;\n@@ -38,2 +40,0 @@\n-import jdk.test.lib.thread.VThreadScheduler;\n-\n@@ -49,1 +49,0 @@\n- * @library \/test\/lib\n@@ -143,1 +142,1 @@\n-            ThreadFactory factory = VThreadScheduler.virtualThreadBuilder(pool)\n+            ThreadFactory factory = virtualThreadBuilder(pool)\n@@ -206,0 +205,20 @@\n+\n+    \/**\n+     * Returns a builder to create virtual threads that use the given scheduler.\n+     *\/\n+    static Thread.Builder.OfVirtual virtualThreadBuilder(Executor scheduler) {\n+        try {\n+            Class<?> clazz = Class.forName(\"java.lang.ThreadBuilders$VirtualThreadBuilder\");\n+            Constructor<?> ctor = clazz.getDeclaredConstructor(Executor.class);\n+            ctor.setAccessible(true);\n+            return (Thread.Builder.OfVirtual) ctor.newInstance(scheduler);\n+        } catch (InvocationTargetException e) {\n+            Throwable cause = e.getCause();\n+            if (cause instanceof RuntimeException re) {\n+                throw re;\n+            }\n+            throw new RuntimeException(e);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/internal\/misc\/TerminatingThreadLocal\/TestTerminatingThreadLocal.java","additions":23,"deletions":4,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,1 +73,1 @@\n-            System.out.println(\"No swap memory limits. Ignoring test!\");\n+            System.out.println(\"No swap memory limits, test case skipped\");\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/MetricsMemoryTester.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import jtreg.SkippedException;\n@@ -116,5 +115,1 @@\n-        \/\/ 'java -Xms{mem-limit} -Xmx{mem-limit} -XX:+AlwaysPreTouch -version'\n-        \/\/ would fail due to swap space size being 0. Note that when swap is\n-        \/\/ properly enabled on the system the container gets the same amount\n-        \/\/ of swap as is configured for memory. Thus, 2x{mem-limit} is the actual\n-        \/\/ memory and swap bound for this pre-test.\n+        \/\/ 'java -Xms{mem-limit} -Xmx{mem-limit} -version' would fail due to swap space size being 0.\n@@ -125,1 +120,0 @@\n-                .addJavaOpts(\"-XX:+AlwaysPreTouch\")\n@@ -131,1 +125,2 @@\n-            throw new SkippedException(\"Swapping doesn't work for this test.\");\n+            System.out.println(\"Swapping doesn't work for this test.\");\n+            return;\n@@ -145,1 +140,2 @@\n-            throw new SkippedException(\"Ignored by the tester\");\n+            System.out.println(\"Ignored by the tester\");\n+            return;\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestDockerMemoryMetrics.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @requires test.thread.factory == null\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/Scoped.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,601 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.awt.BasicStroke;\n-import java.awt.Color;\n-import java.awt.Dimension;\n-import java.awt.Graphics;\n-import java.awt.Graphics2D;\n-import java.awt.RenderingHints;\n-import java.awt.Stroke;\n-import java.awt.geom.AffineTransform;\n-import java.awt.geom.CubicCurve2D;\n-import java.awt.geom.Point2D;\n-import java.awt.geom.Rectangle2D;\n-import java.awt.image.BufferedImage;\n-import java.awt.image.Raster;\n-import java.io.File;\n-import java.io.IOException;\n-import java.lang.reflect.InvocationTargetException;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Locale;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.logging.Handler;\n-import java.util.logging.LogRecord;\n-import java.util.logging.Logger;\n-\n-import javax.imageio.ImageIO;\n-import javax.swing.JFrame;\n-import javax.swing.JPanel;\n-import javax.swing.SwingUtilities;\n-import javax.swing.Timer;\n-\n-import static java.lang.System.out;\n-\n-\/**\n- * @test\n- * @bug 8341381\n- * @summary fix cubic offsetting issue (numerical accuracy)\n- * @run main\/othervm\/timeout=20 Bug8341381\n- * @modules java.desktop\/sun.java2d.marlin\n- *\/\n-public final class Bug8341381 {\n-\n-    static final boolean SHOW_GUI = false;\n-\n-    static final boolean CHECK_PIXELS = true;\n-    static final boolean TRACE_ALL = false;\n-    static final boolean TRACE_CHECK_PIXELS = false;\n-\n-    static final boolean SAVE_IMAGE = false;\n-\n-    static final boolean INTENSIVE = false;\n-\n-    static final double DPI = 96;\n-    static final float STROKE_WIDTH = 15f;\n-\n-    \/\/ delay is 1 frame at 60hz\n-    static final int DELAY = 16;\n-    \/\/ off-screen test step (1.0 by default)\n-    static final double STEP = (INTENSIVE) ? 1.0 \/ 117 : 1.0;\n-\n-    \/\/ stats:\n-    static int N_TEST = 0;\n-    static int N_FAIL = 0;\n-\n-    static final AtomicBoolean isMarlin = new AtomicBoolean();\n-    static final CountDownLatch latch = new CountDownLatch(1);\n-\n-    public static void main(final String[] args) {\n-        Locale.setDefault(Locale.US);\n-\n-        \/\/ FIRST: Get Marlin runtime state from its log:\n-\n-        \/\/ initialize j.u.l Logger:\n-        final Logger log = Logger.getLogger(\"sun.java2d.marlin\");\n-        log.addHandler(new Handler() {\n-            @Override\n-            public void publish(LogRecord record) {\n-                final String msg = record.getMessage();\n-                if (msg != null) {\n-                    \/\/ last space to avoid matching other settings:\n-                    if (msg.startsWith(\"sun.java2d.renderer \")) {\n-                        isMarlin.set(msg.contains(\"DMarlinRenderingEngine\"));\n-                    }\n-                }\n-\n-                final Throwable th = record.getThrown();\n-                \/\/ detect any Throwable:\n-                if (th != null) {\n-                    out.println(\"Test failed:\\n\" + record.getMessage());\n-                    th.printStackTrace(out);\n-                    throw new RuntimeException(\"Test failed: \", th);\n-                }\n-            }\n-\n-            @Override\n-            public void flush() {\n-            }\n-\n-            @Override\n-            public void close() throws SecurityException {\n-            }\n-        });\n-\n-        out.println(\"Bug8341381: start\");\n-        final long startTime = System.currentTimeMillis();\n-\n-        \/\/ enable Marlin logging & internal checks:\n-        System.setProperty(\"sun.java2d.renderer.log\", \"true\");\n-        System.setProperty(\"sun.java2d.renderer.useLogger\", \"true\");\n-\n-        try {\n-            startTest();\n-\n-            out.println(\"WAITING ...\");\n-            latch.await(15, TimeUnit.SECONDS); \/\/ 2s typically\n-\n-            if (isMarlin.get()) {\n-                out.println(\"Marlin renderer used at runtime.\");\n-            } else {\n-                throw new RuntimeException(\"Marlin renderer NOT used at runtime !\");\n-            }\n-\n-            \/\/ show test report:\n-            out.println(\"TESTS: \" + N_TEST + \" FAILS: \" + N_FAIL);\n-\n-            if (N_FAIL > 0) {\n-                throw new RuntimeException(\"Bug8341381: \" + N_FAIL + \" \/ \" + N_TEST + \" test(s) failed !\");\n-            }\n-\n-        } catch (InterruptedException ie) {\n-            throw new RuntimeException(ie);\n-        } catch (InvocationTargetException ite) {\n-            throw new RuntimeException(ite);\n-        } finally {\n-            final double elapsed = (System.currentTimeMillis() - startTime) \/ 1000.0;\n-            out.println(\"Bug8341381: end (\" + elapsed + \" s)\");\n-        }\n-    }\n-\n-    private static void startTest() throws InterruptedException, InvocationTargetException {\n-        if (SHOW_GUI) {\n-            SwingUtilities.invokeAndWait(new Runnable() {\n-                @Override\n-                public void run() {\n-                    final JFrame viewer = new JFrame();\n-                    viewer.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n-                    viewer.setContentPane(new CanvasPanel(viewer));\n-                    viewer.pack();\n-                    viewer.setVisible(true);\n-                }\n-            });\n-            return;\n-        } else {\n-            out.println(\"STEP: \" + STEP);\n-            new Thread(new Runnable() {\n-                @Override\n-                public void run() {\n-                    final Context ctx = new Context();\n-                    final Dimension initialDim = ctx.bugDisplay.getSize(DPI);\n-\n-                    double w = initialDim.width;\n-                    double h = initialDim.height;\n-                    do {\n-                        ctx.shouldScale(w, h);\n-                        ctx.paintImage();\n-\n-                        \/\/ resize component:\n-                        w -= STEP;\n-                        h -= STEP;\n-\n-                    } while (ctx.iterate());\n-                }\n-            }).start();\n-        }\n-    }\n-\n-    static final class Context {\n-\n-        final BugDisplay bugDisplay = new BugDisplay();\n-        double width = 0.0, height = 0.0;\n-\n-        BufferedImage bimg = null;\n-\n-        boolean shouldScale(final double w, final double h) {\n-            if ((w != width) || (h != height) || !bugDisplay.isScaled) {\n-                width = w;\n-                height = h;\n-                bugDisplay.scale(width, height);\n-                N_TEST++;\n-                return true;\n-            }\n-            return false;\n-        }\n-\n-        void paintImage() {\n-            final int w = bugDisplay.canvasWidth;\n-            final int h = bugDisplay.canvasHeight;\n-\n-            if ((bimg == null) || (w > bimg.getWidth()) || (h > bimg.getHeight())) {\n-                bimg = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB_PRE);\n-            }\n-            final Graphics gi = bimg.getGraphics();\n-            try {\n-                bugDisplay.paint(gi);\n-            } finally {\n-                gi.dispose();\n-            }\n-            if (!bugDisplay.checkImage(bimg)) {\n-                N_FAIL++;\n-            }\n-        }\n-\n-        boolean iterate() {\n-            if ((bugDisplay.canvasWidth > 10) || (bugDisplay.canvasHeight > 10)) {\n-                \/\/ continue:\n-                return true;\n-            }\n-            out.println(\"Stop\");\n-            latch.countDown();\n-            return false;\n-        }\n-    }\n-\n-    static final class CanvasPanel extends JPanel {\n-        private static final long serialVersionUID = 1L;\n-\n-        private final Context ctx = new Context();\n-        private boolean resized = false;\n-        private Timer timer = null;\n-\n-        public CanvasPanel(final JFrame frame) {\n-            timer = new Timer(DELAY, e -> {\n-                if (resized) {\n-                    resized = false;\n-\n-                    if (ctx.iterate()) {\n-                        \/\/ resize component:\n-                        setSize((int) Math.round(ctx.width - 1), (int) Math.round(ctx.height - 1));\n-                    } else {\n-                        timer.stop();\n-                        if (frame != null) {\n-                            frame.setVisible(false);\n-                        }\n-                    }\n-                }\n-            });\n-            timer.setCoalesce(true);\n-            timer.setRepeats(true);\n-            timer.start();\n-        }\n-\n-        @Override\n-        public void paint(final Graphics g) {\n-            final Dimension dim = getSize();\n-            if (ctx.shouldScale(dim.width, dim.height)) {\n-                this.resized = true;\n-            }\n-            super.paint(g);\n-\n-            \/\/ paint on buffered image:\n-            if (CHECK_PIXELS) {\n-                final int w = ctx.bugDisplay.canvasWidth;\n-                final int h = ctx.bugDisplay.canvasHeight;\n-                if (this.resized) {\n-                    ctx.paintImage();\n-                }\n-                g.drawImage(ctx.bimg.getSubimage(0, 0, w, h), 0, 0, null);\n-            } else {\n-                ctx.bugDisplay.paint(g);\n-            }\n-        }\n-\n-        @Override\n-        public Dimension getPreferredSize() {\n-            return ctx.bugDisplay.getSize(DPI);\n-        }\n-    }\n-\n-    static final class BugDisplay {\n-\n-        boolean isScaled = false;\n-        int canvasWidth;\n-        int canvasHeight;\n-\n-        private final static java.util.List<CubicCurve2D> curves1 = Arrays.asList(\n-                new CubicCurve2D.Double(2191.0, 7621.0, 2191.0, 7619.0, 2191.0, 7618.0, 2191.0, 7617.0),\n-                new CubicCurve2D.Double(2191.0, 7617.0, 2191.0, 7617.0, 2191.0, 7616.0, 2191.0, 7615.0),\n-                new CubicCurve2D.Double(2198.0, 7602.0, 2200.0, 7599.0, 2203.0, 7595.0, 2205.0, 7590.0),\n-                new CubicCurve2D.Double(2205.0, 7590.0, 2212.0, 7580.0, 2220.0, 7571.0, 2228.0, 7563.0),\n-                new CubicCurve2D.Double(2228.0, 7563.0, 2233.0, 7557.0, 2239.0, 7551.0, 2245.0, 7546.0),\n-                new CubicCurve2D.Double(2245.0, 7546.0, 2252.0, 7540.0, 2260.0, 7534.0, 2267.0, 7528.0),\n-                new CubicCurve2D.Double(2267.0, 7528.0, 2271.0, 7526.0, 2275.0, 7524.0, 2279.0, 7521.0),\n-                new CubicCurve2D.Double(2279.0, 7521.0, 2279.0, 7520.0, 2280.0, 7520.0, 2281.0, 7519.0)\n-        );\n-        private final static java.util.List<CubicCurve2D> curves2 = Arrays.asList(\n-                new CubicCurve2D.Double(2281.0, 7519.0, 2282.0, 7518.0, 2282.0, 7517.0, 2283.0, 7516.0),\n-                new CubicCurve2D.Double(2283.0, 7516.0, 2284.0, 7515.0, 2284.0, 7515.0, 2285.0, 7514.0),\n-                new CubicCurve2D.Double(2291.0, 7496.0, 2292.0, 7495.0, 2292.0, 7494.0, 2291.0, 7493.0),\n-                new CubicCurve2D.Double(2291.0, 7493.0, 2290.0, 7492.0, 2290.0, 7492.0, 2289.0, 7492.0),\n-                new CubicCurve2D.Double(2289.0, 7492.0, 2288.0, 7491.0, 2286.0, 7492.0, 2285.0, 7492.0),\n-                new CubicCurve2D.Double(2262.0, 7496.0, 2260.0, 7497.0, 2259.0, 7497.0, 2257.0, 7498.0),\n-                new CubicCurve2D.Double(2257.0, 7498.0, 2254.0, 7498.0, 2251.0, 7499.0, 2248.0, 7501.0),\n-                new CubicCurve2D.Double(2248.0, 7501.0, 2247.0, 7501.0, 2245.0, 7502.0, 2244.0, 7503.0),\n-                new CubicCurve2D.Double(2207.0, 7523.0, 2203.0, 7525.0, 2199.0, 7528.0, 2195.0, 7530.0),\n-                new CubicCurve2D.Double(2195.0, 7530.0, 2191.0, 7534.0, 2186.0, 7538.0, 2182.0, 7541.0)\n-        );\n-        private final static java.util.List<CubicCurve2D> curves3 = Arrays.asList(\n-                new CubicCurve2D.Double(2182.0, 7541.0, 2178.0, 7544.0, 2174.0, 7547.0, 2170.0, 7551.0),\n-                new CubicCurve2D.Double(2170.0, 7551.0, 2164.0, 7556.0, 2158.0, 7563.0, 2152.0, 7569.0),\n-                new CubicCurve2D.Double(2152.0, 7569.0, 2148.0, 7573.0, 2145.0, 7577.0, 2141.0, 7582.0),\n-                new CubicCurve2D.Double(2141.0, 7582.0, 2138.0, 7588.0, 2134.0, 7595.0, 2132.0, 7602.0),\n-                new CubicCurve2D.Double(2132.0, 7602.0, 2132.0, 7605.0, 2131.0, 7608.0, 2131.0, 7617.0),\n-                new CubicCurve2D.Double(2131.0, 7617.0, 2131.0, 7620.0, 2131.0, 7622.0, 2131.0, 7624.0),\n-                new CubicCurve2D.Double(2131.0, 7624.0, 2131.0, 7630.0, 2132.0, 7636.0, 2135.0, 7641.0),\n-                new CubicCurve2D.Double(2135.0, 7641.0, 2136.0, 7644.0, 2137.0, 7647.0, 2139.0, 7650.0),\n-                new CubicCurve2D.Double(2139.0, 7650.0, 2143.0, 7658.0, 2149.0, 7664.0, 2155.0, 7670.0),\n-                new CubicCurve2D.Double(2155.0, 7670.0, 2160.0, 7676.0, 2165.0, 7681.0, 2171.0, 7686.0)\n-        );\n-        private final static java.util.List<CubicCurve2D> curves4 = Arrays.asList(\n-                new CubicCurve2D.Double(2171.0, 7686.0, 2174.0, 7689.0, 2177.0, 7692.0, 2180.0, 7694.0),\n-                new CubicCurve2D.Double(2180.0, 7694.0, 2185.0, 7698.0, 2191.0, 7702.0, 2196.0, 7706.0),\n-                new CubicCurve2D.Double(2196.0, 7706.0, 2199.0, 7708.0, 2203.0, 7711.0, 2207.0, 7713.0),\n-                new CubicCurve2D.Double(2244.0, 7734.0, 2245.0, 7734.0, 2247.0, 7735.0, 2248.0, 7736.0),\n-                new CubicCurve2D.Double(2248.0, 7736.0, 2251.0, 7738.0, 2254.0, 7739.0, 2257.0, 7739.0),\n-                new CubicCurve2D.Double(2257.0, 7739.0, 2259.0, 7739.0, 2260.0, 7739.0, 2262.0, 7740.0),\n-                new CubicCurve2D.Double(2285.0, 7745.0, 2286.0, 7745.0, 2288.0, 7745.0, 2289.0, 7745.0),\n-                new CubicCurve2D.Double(2289.0, 7745.0, 2290.0, 7745.0, 2290.0, 7744.0, 2291.0, 7743.0),\n-                new CubicCurve2D.Double(2291.0, 7743.0, 2292.0, 7742.0, 2292.0, 7741.0, 2291.0, 7740.0),\n-                new CubicCurve2D.Double(2285.0, 7722.0, 2284.0, 7721.0, 2284.0, 7721.0, 2283.0, 7720.0),\n-                new CubicCurve2D.Double(2283.0, 7720.0, 2282.0, 7719.0, 2282.0, 7719.0, 2281.0, 7718.0),\n-                new CubicCurve2D.Double(2281.0, 7718.0, 2280.0, 7717.0, 2279.0, 7716.0, 2279.0, 7716.0),\n-                new CubicCurve2D.Double(2279.0, 7716.0, 2275.0, 7712.0, 2271.0, 7710.0, 2267.0, 7708.0),\n-                new CubicCurve2D.Double(2267.0, 7708.0, 2260.0, 7702.0, 2252.0, 7697.0, 2245.0, 7691.0),\n-                new CubicCurve2D.Double(2245.0, 7691.0, 2239.0, 7685.0, 2233.0, 7679.0, 2228.0, 7673.0),\n-                new CubicCurve2D.Double(2228.0, 7673.0, 2220.0, 7665.0, 2212.0, 7656.0, 2205.0, 7646.0),\n-                new CubicCurve2D.Double(2205.0, 7646.0, 2203.0, 7641.0, 2200.0, 7637.0, 2198.0, 7634.0)\n-        );\n-\n-        private final static Point2D.Double[] extent = {new Point2D.Double(0.0, 0.0), new Point2D.Double(7777.0, 10005.0)};\n-\n-        private final static Stroke STROKE = new BasicStroke(STROKE_WIDTH);\n-        private final static Stroke STROKE_DASHED = new BasicStroke(STROKE_WIDTH, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL,\n-                10.0f, new float[] {100f, 0f}, 0.0f);\n-\n-        \/\/ members:\n-        private final java.util.List<CubicCurve2D> allCurves = new ArrayList<>();\n-        private final Rectangle2D bboxAllCurves = new Rectangle2D.Double();\n-\n-        BugDisplay() {\n-            allCurves.addAll(curves1);\n-            allCurves.addAll(curves2);\n-            allCurves.addAll(curves3);\n-            allCurves.addAll(curves4);\n-\n-            \/\/ initialize bounding box:\n-            double x1 = Double.POSITIVE_INFINITY;\n-            double y1 = Double.POSITIVE_INFINITY;\n-            double x2 = Double.NEGATIVE_INFINITY;\n-            double y2 = Double.NEGATIVE_INFINITY;\n-\n-            for (final CubicCurve2D c : allCurves) {\n-                final Rectangle2D r = c.getBounds2D();\n-                if (r.getMinX() < x1) {\n-                    x1 = r.getMinX();\n-                }\n-                if (r.getMinY() < y1) {\n-                    y1 = r.getMinY();\n-                }\n-                if (r.getMaxX() > x2) {\n-                    x2 = r.getMaxX();\n-                }\n-                if (r.getMaxY() > y2) {\n-                    y2 = r.getMaxY();\n-                }\n-            }\n-            \/\/ add margin of 10%:\n-            final double m = 1.1 * STROKE_WIDTH;\n-            bboxAllCurves.setFrameFromDiagonal(x1 - m, y1 - m, x2 + m, y2 + m);\n-        }\n-\n-        public void paint(final Graphics g) {\n-            final Graphics2D g2d = (Graphics2D) g;\n-            g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);\n-            g2d.setColor(Color.WHITE);\n-            g2d.fillRect(0, 0, this.canvasWidth, this.canvasHeight);\n-\n-            \/\/ ------ scale\n-            final AffineTransform tx_orig = g2d.getTransform();\n-            final AffineTransform tx = getDrawTransform();\n-            g2d.transform(tx);\n-\n-            \/\/ draw bbox:\n-            if (!CHECK_PIXELS) {\n-                g2d.setColor(Color.RED);\n-                g2d.setStroke(STROKE);\n-                g2d.draw(bboxAllCurves);\n-            }\n-            \/\/ draw curves:\n-            g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n-            g2d.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_NORMALIZE);\n-            g2d.setColor(Color.BLACK);\n-\n-            \/\/ dasher + stroker:\n-            g2d.setStroke(STROKE_DASHED);\n-            this.allCurves.forEach(g2d::draw);\n-\n-            \/\/ reset\n-            g2d.setTransform(tx_orig);\n-        }\n-\n-        private AffineTransform getDrawTransform() {\n-            \/\/ ------ scale\n-            double minX = extent[0].x, maxX = extent[1].x;\n-            double minY = extent[0].y, maxY = extent[1].y;\n-\n-            \/\/ we're scaling and respecting the proportions, check which scale to use\n-            double sx = this.canvasWidth \/ Math.abs(maxX - minX);\n-            double sy = this.canvasHeight \/ Math.abs(maxY - minY);\n-            double s = Math.min(sx, sy);\n-\n-            double m00, m11, m02, m12;\n-            if (minX < maxX) {\n-                m00 = s;\n-                m02 = -s * minX;\n-            } else {\n-                \/\/ inverted X axis\n-                m00 = -s;\n-                m02 = this.canvasWidth + s * maxX;\n-            }\n-            if (minY < maxY) {\n-                m11 = s;\n-                m12 = -s * minY;\n-            } else {\n-                \/\/ inverted Y axis\n-                m11 = -s;\n-                m12 = this.canvasHeight + s * maxY;\n-            }\n-\n-            \/\/ scale to the available view port\n-            AffineTransform scaleTransform = new AffineTransform(m00, 0, 0, m11, m02, m12);\n-\n-            \/\/ invert the Y axis since (0, 0) is at top left for AWT\n-            AffineTransform invertY = new AffineTransform(1, 0, 0, -1, 0, this.canvasHeight);\n-            invertY.concatenate(scaleTransform);\n-\n-            return invertY;\n-        }\n-\n-        public Dimension getSize(double dpi) {\n-            double metricScalingFactor = 0.02539999969303608;\n-            \/\/ 1 inch = 25,4 millimeter\n-            final double factor = dpi * metricScalingFactor \/ 25.4;\n-\n-            int width = (int) Math.ceil(Math.abs(extent[1].x - extent[0].x) * factor);\n-            int height = (int) Math.ceil(Math.abs(extent[1].y - extent[0].y) * factor);\n-\n-            return new Dimension(width, height);\n-        }\n-\n-        public void scale(double w, double h) {\n-            double extentWidth = Math.abs(extent[1].x - extent[0].x);\n-            double extentHeight = Math.abs(extent[1].y - extent[0].y);\n-\n-            double fx = w \/ extentWidth;\n-            if (fx * extentHeight > h) {\n-                fx = h \/ extentHeight;\n-            }\n-            this.canvasWidth = (int) Math.round(fx * extentWidth);\n-            this.canvasHeight = (int) Math.round(fx * extentHeight);\n-\n-            \/\/ out.println(\"canvas scaled (\" + canvasWidth + \" x \" + canvasHeight + \")\");\n-\n-            this.isScaled = true;\n-        }\n-\n-        protected boolean checkImage(BufferedImage image) {\n-            final AffineTransform tx = getDrawTransform();\n-\n-            final Point2D pMin = new Point2D.Double(bboxAllCurves.getMinX(), bboxAllCurves.getMinY());\n-            final Point2D pMax = new Point2D.Double(bboxAllCurves.getMaxX(), bboxAllCurves.getMaxY());\n-\n-            final Point2D tMin = tx.transform(pMin, null);\n-            final Point2D tMax = tx.transform(pMax, null);\n-\n-            int xMin = (int) tMin.getX();\n-            int xMax = (int) tMax.getX();\n-            if (xMin > xMax) {\n-                int t = xMin;\n-                xMin = xMax;\n-                xMax = t;\n-            }\n-\n-            int yMin = (int) tMin.getY();\n-            int yMax = (int) tMax.getY();\n-            if (yMin > yMax) {\n-                int t = yMin;\n-                yMin = yMax;\n-                yMax = t;\n-            }\n-            \/\/ add pixel margin (AA):\n-            xMin -= 3;\n-            xMax += 4;\n-            yMin -= 3;\n-            yMax += 4;\n-\n-            if (xMin < 0 || xMax > image.getWidth()\n-                    || yMin < 0 || yMax > image.getHeight()) {\n-                return true;\n-            }\n-\n-            \/\/ out.println(\"Checking rectangle: \" + tMin + \" to \" + tMax);\n-            \/\/ out.println(\"X min: \" + xMin + \" - max: \" + xMax);\n-            \/\/ out.println(\"Y min: \" + yMin + \" - max: \" + yMax);\n-\n-            final Raster raster = image.getData();\n-            final int expected = Color.WHITE.getRGB();\n-            int nBadPixels = 0;\n-\n-            \/\/ horizontal lines:\n-            for (int x = xMin; x <= xMax; x++) {\n-                if (!checkPixel(raster, x, yMin, expected)) {\n-                    nBadPixels++;\n-                }\n-                if (!checkPixel(raster, x, yMax, expected)) {\n-                    nBadPixels++;\n-                }\n-            }\n-\n-            \/\/ vertical lines:\n-            for (int y = yMin; y <= yMax; y++) {\n-                if (!checkPixel(raster, xMin, y, expected)) {\n-                    nBadPixels++;\n-                }\n-                if (!checkPixel(raster, xMax, y, expected)) {\n-                    nBadPixels++;\n-                }\n-            }\n-\n-            if (nBadPixels != 0) {\n-                out.println(\"(\" + canvasWidth + \" x \" + canvasHeight + \") BAD pixels = \" + nBadPixels);\n-\n-                if (SAVE_IMAGE) {\n-                    try {\n-                        final File file = new File(\"Bug8341381-\" + canvasWidth + \"-\" + canvasHeight + \".png\");\n-\n-                        out.println(\"Writing file: \" + file.getAbsolutePath());\n-                        ImageIO.write(image.getSubimage(0, 0, canvasWidth, canvasHeight), \"PNG\", file);\n-                    } catch (IOException ioe) {\n-                        ioe.printStackTrace();\n-                    }\n-                }\n-                return false;\n-            } else if (TRACE_ALL) {\n-                out.println(\"(\" + canvasWidth + \" x \" + canvasHeight + \") OK\");\n-            }\n-            return true;\n-        }\n-\n-        private final static int[] TMP_RGB = new int[1];\n-\n-        private static boolean checkPixel(final Raster raster,\n-                                          final int x, final int y,\n-                                          final int expected) {\n-\n-            final int[] rgb = (int[]) raster.getDataElements(x, y, TMP_RGB);\n-\n-            if (rgb[0] != expected) {\n-                if (TRACE_CHECK_PIXELS) {\n-                    out.println(\"bad pixel at (\" + x + \", \" + y + \") = \" + rgb[0]\n-                            + \" expected = \" + expected);\n-                }\n-                return false;\n-            }\n-            return true;\n-        }\n-    }\n-}\n","filename":"test\/jdk\/sun\/java2d\/marlin\/Bug8341381.java","additions":0,"deletions":601,"binary":false,"changes":601,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main\/manual\/native\/timeout=180 TestDynamicStore\n+ * @run main\/manual\/native TestDynamicStore\n@@ -37,2 +37,0 @@\n-import javax.swing.JOptionPane;\n-\n@@ -61,11 +59,0 @@\n-        \/\/ Show a popup to remind to run this test as sudo user\n-        \/\/ this will only trigger if sudo (root) user is not detected\n-        if (!\"root\".equals(System.getProperty(\"user.name\"))) {\n-\n-            JOptionPane.showMessageDialog(null, \"\"\"\n-                            This test MUST be run as ROOT.\\s\n-                            Please close and RESTART the test.\"\"\");\n-\n-            Asserts.assertFalse(true, \"This test must be run as ROOT\");\n-        }\n-\n","filename":"test\/jdk\/sun\/security\/krb5\/config\/native\/TestDynamicStore.java","additions":2,"deletions":15,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -324,2 +324,1 @@\n-            System.out.println(\"Exception occured using \" + p.getName()\n-                    + \" version \" + p.getVersionStr());\n+            System.out.println(\"Exception occured using \" + p.getName() + \" version \" + p.getVersionStr());\n@@ -328,1 +327,1 @@\n-                Version ver = getNSSInfo(\"nss\");\n+                double ver = getNSSInfo(\"nss\");\n@@ -330,4 +329,1 @@\n-\n-                if (osName.equals(\"Linux\") &&\n-                        ver.major() == 3 && ver.minor() < 15\n-                        && (ver.minor() > 13 && ver.patch() >= 9)) {\n+                if (ver > 3.139 && ver < 3.15 && osName.equals(\"Linux\")) {\n@@ -335,2 +331,1 @@\n-                    System.out.println(\"Warning: old NSS \" + ver\n-                            + \" might be problematic, consider upgrading it\");\n+                    System.out.println(\"Warning: old NSS \" + ver + \" might be problematic, consider upgrading it\");\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestKATForGCM.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,8 +119,5 @@\n-        if (isNSS(provider) && expected.getAlgorithm().equals(\"AES\")) {\n-            Version version = getNSSVersion();\n-            if (version.major() == 3 && version.minor() == 12\n-                    && version.patch() <= 2) {\n-                System.out.println(\"NSS 3.12 bug returns incorrect AES key \" +\n-                        \"length breaking key storage. Aborting...\");\n-                return true;\n-            }\n+        if (isNSS(provider) && expected.getAlgorithm().equals(\"AES\") &&\n+                (getNSSVersion() >= 3.12 && getNSSVersion() <= 3.122)) {\n+            System.out.println(\"NSS 3.12 bug returns incorrect AES key \"+\n+                    \"length breaking key storage. Aborting...\");\n+            return true;\n@@ -174,1 +171,1 @@\n-                (!getLibsoftokn3Version().equals(getLibnss3Version()))) {\n+                (getLibsoftokn3Version() != getLibnss3Version())) {\n","filename":"test\/jdk\/sun\/security\/pkcs11\/KeyStore\/SecretKeysBasic.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-    static Version nss_version = null;\n+    static double nss_version = -1;\n@@ -96,2 +96,2 @@\n-    static Version softoken3_version = null;\n-    static Version nss3_version = null;\n+    static double softoken3_version = -1;\n+    static double nss3_version = -1;\n@@ -272,6 +272,5 @@\n-        Version nssVersion = getNSSVersion();\n-        if (isNSS(p)) {\n-            \/\/ bad version is just between [3.11,3.12)\n-            return nssVersion.major == 3 && 11 == nssVersion.minor;\n-        } else {\n-            return false;\n+        double nssVersion = getNSSVersion();\n+        if (isNSS(p) && nssVersion >= 3.11 && nssVersion < 3.12) {\n+            System.out.println(\"NSS 3.11 has a DER issue that recent \" +\n+                    \"version do not, skipping\");\n+            return true;\n@@ -279,16 +278,1 @@\n-    }\n-\n-    public record Version(int major, int minor, int patch) {}\n-\n-    protected static Version parseVersionString(String version) {\n-        String [] parts = version.split(\"\\\\.\");\n-        int major = Integer.parseInt(parts[0]);\n-        int minor = 0;\n-        int patch = 0;\n-        if (parts.length >= 2) {\n-            minor = Integer.parseInt(parts[1]);\n-        }\n-        if (parts.length >= 3) {\n-            patch = Integer.parseInt(parts[2]);\n-        }\n-        return new Version(major, minor, patch);\n+        return false;\n@@ -323,2 +307,2 @@\n-    static Version getNSSVersion() {\n-        if (nss_version == null)\n+    static double getNSSVersion() {\n+        if (nss_version == -1)\n@@ -330,1 +314,1 @@\n-        if (nss_version == null)\n+        if (nss_version == -1)\n@@ -335,2 +319,2 @@\n-    public static Version getLibsoftokn3Version() {\n-        if (softoken3_version == null)\n+    public static double getLibsoftokn3Version() {\n+        if (softoken3_version == -1)\n@@ -341,2 +325,2 @@\n-    public static Version getLibnss3Version() {\n-        if (nss3_version == null)\n+    public static double getLibnss3Version() {\n+        if (nss3_version == -1)\n@@ -357,1 +341,1 @@\n-    static Version getNSSInfo(String library) {\n+    static double getNSSInfo(String library) {\n@@ -366,1 +350,1 @@\n-        if (library.compareTo(\"softokn3\") == 0 && softoken3_version != null)\n+        if (library.compareTo(\"softokn3\") == 0 && softoken3_version > -1)\n@@ -368,1 +352,1 @@\n-        if (library.compareTo(\"nss3\") == 0 && nss3_version != null)\n+        if (library.compareTo(\"nss3\") == 0 && nss3_version > -1)\n@@ -374,1 +358,1 @@\n-                return parseVersionString(\"0.0\");\n+                return 0.0;\n@@ -410,1 +394,1 @@\n-            nss_version = parseVersionString(\"0.0\");\n+            nss_version = 0.0;\n@@ -423,1 +407,20 @@\n-        nss_version = parseVersionString(version.toString());\n+        \/\/ If a \"dot dot\" release, strip the extra dots for double parsing\n+        String[] dot = version.toString().split(\"\\\\.\");\n+        if (dot.length > 2) {\n+            version = new StringBuilder(dot[0] + \".\" + dot[1]);\n+            for (int j = 2; dot.length > j; j++) {\n+                version.append(dot[j]);\n+            }\n+        }\n+\n+        \/\/ Convert to double for easier version value checking\n+        try {\n+            nss_version = Double.parseDouble(version.toString());\n+        } catch (NumberFormatException e) {\n+            System.out.println(\"===== Content start =====\");\n+            System.out.println(s);\n+            System.out.println(\"===== Content end =====\");\n+            System.out.println(\"Failed to parse lib\" + library +\n+                    \" version. Set to 0.0\");\n+            e.printStackTrace();\n+        }\n","filename":"test\/jdk\/sun\/security\/pkcs11\/PKCS11Test.java","additions":41,"deletions":38,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,4 +124,4 @@\n-        Version nssVersion = getNSSVersion();\n-        if (p.getName().equalsIgnoreCase(\"SunPKCS11-NSSKeyStore\")) {\n-            return nssVersion.major() == 3 &&\n-                    (nssVersion.minor() >= 28 && nssVersion.minor() < 35);\n+        double nssVersion = getNSSVersion();\n+        if (p.getName().equalsIgnoreCase(\"SunPKCS11-NSSKeyStore\")\n+                && nssVersion >= 3.28 && nssVersion < 3.35) {\n+            return true;\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Secmod\/AddTrustedCert.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,9 +50,7 @@\n-        if (isNSS(provider)) {\n-            Version version = getNSSVersion();\n-            if (version == null) {\n-                return true;\n-            }\n-            if (version.major() >= 3 && version.minor() >= 14){\n-                System.out.println(\"Skip testing NSS \" + version);\n-                return true;\n-            }\n+        double version = getNSSVersion();\n+        String[] versionStrs = Double.toString(version).split(\"\\\\.\");\n+        int major = Integer.parseInt(versionStrs[0]);\n+        int minor = Integer.parseInt(versionStrs[1]);\n+        if (isNSS(provider) && (version == 0.0 || (major >= 3 && minor >= 14))) {\n+            System.out.println(\"Skip testing NSS \" + version);\n+            return true;\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Signature\/TestDSAKeyLength.java","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -114,1 +114,0 @@\n-        System.out.println(\"Testing provider \" + p.getName());\n","filename":"test\/jdk\/sun\/security\/pkcs11\/ec\/TestECDH.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2012, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n- * @enablePreview\n@@ -39,2 +38,3 @@\n-import java.io.ByteArrayInputStream;\n-import java.security.PEMDecoder;\n+import java.io.*;\n+import java.net.SocketException;\n+import java.util.*;\n@@ -42,16 +42,2 @@\n-import java.security.cert.CertPath;\n-import java.security.cert.CertPathValidator;\n-import java.security.cert.CertPathValidatorException;\n-import java.security.cert.CertPathValidatorException.BasicReason;\n-import java.security.cert.Certificate;\n-import java.security.cert.CertificateException;\n-import java.security.cert.CertificateFactory;\n-import java.security.cert.PKIXParameters;\n-import java.security.cert.TrustAnchor;\n-import java.security.cert.X509Certificate;\n-import java.util.Arrays;\n-import java.util.Calendar;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.List;\n-import java.util.Set;\n+import java.security.cert.*;\n+import java.security.cert.CertPathValidatorException.*;\n@@ -61,2 +47,0 @@\n-    private static final PEMDecoder pemDecoder = java.security.PEMDecoder.of();\n-\n@@ -123,1 +107,1 @@\n-\n+        \/\/ generate certificate from cert strings\n@@ -126,2 +110,4 @@\n-        \/\/ generate certificate from cert strings\n-        Certificate selfSignedCert = pemDecoder.decode(selfSignedCertStr, X509Certificate.class);\n+        ByteArrayInputStream is;\n+\n+        is = new ByteArrayInputStream(selfSignedCertStr.getBytes());\n+        Certificate selfSignedCert = cf.generateCertificate(is);\n@@ -130,1 +116,2 @@\n-        List<Certificate> list = Collections.singletonList(selfSignedCert);\n+        List<Certificate> list = Arrays.asList(new Certificate[] {\n+                        selfSignedCert});\n@@ -135,2 +122,2 @@\n-    private static Set<TrustAnchor> generateTrustAnchors() {\n-\n+    private static Set<TrustAnchor> generateTrustAnchors()\n+            throws CertificateException {\n@@ -138,1 +125,5 @@\n-        X509Certificate selfSignedCert = pemDecoder.decode(selfSignedCertStr, X509Certificate.class);\n+        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+\n+        ByteArrayInputStream is =\n+                    new ByteArrayInputStream(selfSignedCertStr.getBytes());\n+        Certificate selfSignedCert = cf.generateCertificate(is);\n@@ -142,1 +133,1 @@\n-            new TrustAnchor(selfSignedCert, null);\n+            new TrustAnchor((X509Certificate)selfSignedCert, null);\n@@ -176,1 +167,1 @@\n-            throws Exception {\n+            throws CertPathValidatorException, Exception {\n@@ -188,5 +179,1 @@\n-        final Calendar calendar = Calendar.getInstance();\n-        calendar.set(Calendar.YEAR, 2009);\n-        calendar.set(Calendar.MONTH, 9);\n-        calendar.set(Calendar.DATE, 1);\n-        params.setDate(calendar.getTime());   \/\/ 2009-09-01\n+        params.setDate(new Date(109, 9, 1));   \/\/ 2009-09-01\n","filename":"test\/jdk\/sun\/security\/provider\/certpath\/DisabledAlgorithms\/CPValidatorTrustAnchor.java","additions":23,"deletions":36,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -30,1 +29,2 @@\n-import java.security.PEMDecoder;\n+import java.io.InputStream;\n+import java.io.ByteArrayInputStream;\n@@ -32,0 +32,1 @@\n+import java.security.cert.CertificateFactory;\n@@ -34,1 +35,0 @@\n-import java.security.cert.X509Certificate;\n@@ -90,3 +90,3 @@\n-    public static void main(String[] args) throws Exception {\n-        final PEMDecoder pemDecoder = PEMDecoder.of();\n-        Certificate signer = pemDecoder.decode(signerCertStr, X509Certificate.class);\n+    public static void main(String args[]) throws Exception {\n+\n+        Certificate signer = generate(signerCertStr);\n@@ -95,1 +95,1 @@\n-        Certificate normal = pemDecoder.decode(normalCertStr, X509Certificate.class);\n+        Certificate normal = generate(normalCertStr);\n@@ -97,1 +97,1 @@\n-        Certificate longer = pemDecoder.decode(longerCertStr, X509Certificate.class);\n+        Certificate longer = generate(longerCertStr);\n@@ -99,1 +99,1 @@\n-        Certificate shorter = pemDecoder.decode(shorterCertStr, X509Certificate.class);\n+        Certificate shorter = generate(shorterCertStr);\n@@ -108,0 +108,13 @@\n+    private static Certificate generate(String certStr) throws Exception {\n+        InputStream is = null;\n+        try {\n+            CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+            is = new ByteArrayInputStream(certStr.getBytes());\n+            return cf.generateCertificate(is);\n+        } finally {\n+            if (is != null) {\n+                is.close();\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/sun\/security\/rsa\/InvalidBitString.java","additions":23,"deletions":10,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2017, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n- * @enablePreview\n@@ -201,3 +200,2 @@\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.security.PEMDecoder;\n+import java.io.*;\n+import java.net.*;\n@@ -208,7 +206,4 @@\n-import javax.net.ssl.KeyManagerFactory;\n-import javax.net.ssl.SSLContext;\n-import javax.net.ssl.SSLServerSocket;\n-import javax.net.ssl.SSLServerSocketFactory;\n-import javax.net.ssl.SSLSocket;\n-import javax.net.ssl.SSLSocketFactory;\n-import javax.net.ssl.TrustManagerFactory;\n+import java.security.cert.CertificateFactory;\n+import java.security.spec.*;\n+import java.security.interfaces.*;\n+import javax.net.ssl.*;\n@@ -216,3 +211,0 @@\n-import java.security.cert.X509Certificate;\n-import java.security.interfaces.RSAPrivateKey;\n-import java.security.spec.RSAPrivateKeySpec;\n@@ -323,1 +315,1 @@\n-    static boolean debug = Boolean.getBoolean(\"test.debug\");\n+    static boolean debug = false;\n@@ -397,1 +389,1 @@\n-            String[] enabledSuites = {\n+            String enabledSuites[] = {\n@@ -482,12 +474,14 @@\n-            serverThread = new Thread(() -> {\n-                try {\n-                    doServerSide();\n-                } catch (Exception e) {\n-                    \/*\n-                     * Our server thread just died.\n-                     *\n-                     * Release the client, if not active already...\n-                     *\/\n-                    System.err.println(\"Server died...\" + e);\n-                    serverReady = true;\n-                    serverException = e;\n+            serverThread = new Thread() {\n+                public void run() {\n+                    try {\n+                        doServerSide();\n+                    } catch (Exception e) {\n+                        \/*\n+                         * Our server thread just died.\n+                         *\n+                         * Release the client, if not active already...\n+                         *\/\n+                        System.err.println(\"Server died...\" + e);\n+                        serverReady = true;\n+                        serverException = e;\n+                    }\n@@ -495,1 +489,1 @@\n-            });\n+            };\n@@ -504,9 +498,11 @@\n-            clientThread = new Thread(() -> {\n-                try {\n-                    doClientSide();\n-                } catch (Exception e) {\n-                    \/*\n-                     * Our client thread just died.\n-                     *\/\n-                    System.err.println(\"Client died...\");\n-                    clientException = e;\n+            clientThread = new Thread() {\n+                public void run() {\n+                    try {\n+                        doClientSide();\n+                    } catch (Exception e) {\n+                        \/*\n+                         * Our client thread just died.\n+                         *\/\n+                        System.err.println(\"Client died...\");\n+                        clientException = e;\n+                    }\n@@ -514,1 +510,1 @@\n-            });\n+            };\n@@ -524,0 +520,1 @@\n+        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n@@ -525,3 +522,3 @@\n-        final PEMDecoder pemDecoder = PEMDecoder.of();\n-\n-        Certificate trustedCert = pemDecoder.decode(trusedCertStr, X509Certificate.class);\n+        ByteArrayInputStream is =\n+                    new ByteArrayInputStream(trusedCertStr.getBytes());\n+        Certificate trustedCert = cf.generateCertificate(is);\n@@ -546,1 +543,2 @@\n-            Certificate serverCert = pemDecoder.decode(serverCertStr, X509Certificate.class);\n+            is = new ByteArrayInputStream(serverCertStr.getBytes());\n+            Certificate serverCert = cf.generateCertificate(is);\n","filename":"test\/jdk\/sun\/security\/ssl\/ClientHandshaker\/RSAExport.java","additions":42,"deletions":44,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n- * @enablePreview\n@@ -39,18 +38,3 @@\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.security.PEMDecoder;\n-import java.security.cert.CertPath;\n-import java.security.cert.CertPathValidator;\n-import java.security.cert.Certificate;\n-import java.security.cert.CertificateFactory;\n-import java.security.cert.PKIXParameters;\n-import java.security.cert.X509Certificate;\n-import java.security.interfaces.RSAPrivateKey;\n-import java.security.spec.PKCS8EncodedKeySpec;\n-import javax.net.ssl.KeyManagerFactory;\n-import javax.net.ssl.SSLContext;\n-import javax.net.ssl.SSLServerSocket;\n-import javax.net.ssl.SSLServerSocketFactory;\n-import javax.net.ssl.SSLSocket;\n-import javax.net.ssl.SSLSocketFactory;\n-import javax.net.ssl.TrustManagerFactory;\n+import java.util.*;\n+import java.io.*;\n+import javax.net.ssl.*;\n@@ -59,0 +43,3 @@\n+import java.security.cert.*;\n+import java.security.spec.*;\n+import java.security.interfaces.*;\n@@ -60,1 +47,1 @@\n-import java.util.Arrays;\n+import java.util.Base64;\n@@ -112,0 +99,27 @@\n+    static String trustedPrivateKey = \/\/ Private key in the format of PKCS#8\n+        \"MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQDUJ3hT\/9jY\/i8i\\n\" +\n+        \"70EEaL6mbrhhdg\/Ys1E0r97n+dZaY0olqkIBhh1r8UkKWtvOkj8WBFQ0sz0HhSjT\\n\" +\n+        \"rkVEisGLW+7zPJiDBPtQrRawvCDpnzUofnQ98zQKUTHji1OqhxgNzsKCy9vIh5Mh\\n\" +\n+        \"tX0CdGUScEDXlYUkAkxMKCVo2V5dRn34D+1rNGEeWxGnQ5vyPi0IwlpEOkYxhPLV\\n\" +\n+        \"dsb5aoLzBc\/rdrrdzCM+svm7O38LhbVuA0F9NHAgdJRKE2F91ztkk1KvY0U9zCh1\\n\" +\n+        \"3u5WV7kl481qDujKGM4UURoEarbV2Xr+jNVGSpJZYCLU\/sxFrL15iPeYtmJlovo2\\n\" +\n+        \"VbFed\/NXAgMBAAECggEAUZvlQ5q1VbNhenTCc+m+\/NK2hncd3WQNJtFIU7\/dXuO2\\n\" +\n+        \"0ApQXbmzc6RbTmppB2tmbRe5NJSGM3BbpiHxb05Y6TyyDEsQ98Vgz0Xl5pJXrsaZ\\n\" +\n+        \"cjxChtoY+KcHI9qikoRpElaoqBu3LcpJJLxlnB4eCxu3NbbEgneH1fvTeCO1kvcp\\n\" +\n+        \"i3DDdyfY7WB9RW1yWAveiuqvtnbsPfJJLKEhFvZL2ArYCRTm\/oIw64yukNe\/QLR5\\n\" +\n+        \"bGzEJMT2ZNQMld1f+CW9tOrUKrnnPCGfMa351T5we+8B6sujWfftPutgEVx5TmHs\\n\" +\n+        \"AOW1SntMapbgg46K9EC\/C5YQa5D1aNOH9ZTEMkgUMQKBgQDrpPQIHFozeeyZ0iiq\\n\" +\n+        \"HtReLPcqpkwr\/9ELc3SjgUypSvpu0l\/m++um0yLinlXMn25km\/BP6Mv3t\/+1uzAc\\n\" +\n+        \"qpopkcyek8X1hzNRhDkWuMv4KDOKk5c6qLx8FGSm6q8PYm5KbsiyeCM7CJoeoqJ5\\n\" +\n+        \"74IZjOIw7UrYLckCb6W8xGQLIwKBgQDmew3vGRR3JmCCSumtJQOqhF6bBYrNb6Qc\\n\" +\n+        \"r4vrng+QhNIquwGqHKPorAI1J8J1jOS+dkDWTxSz2xQKQ83nsOspzVPskpDh5mWL\\n\" +\n+        \"gGk5QCkX87jFsXfhvZFLksZMbIdpWze997Zs2fe\/PWfPaH6o3erqo2zAhQV0eA9q\\n\" +\n+        \"C7tfImREPQKBgQDi2Xq\/8CN52M9IScQx+dnyC5Gqckt0NCKXxn8sBIa7l129oDMI\\n\" +\n+        \"187FXA8CYPEyOu14V5KiKvdos66s0daAUlB04lI8+v+g3ZYuzH50\/FQHwxPTPUBi\\n\" +\n+        \"DRzeyncXJWiAA\/8vErWM8hDgfOh5w5Fsl4EEfdcmyNm7gWA4Qyknr1ysRwKBgQDC\\n\" +\n+        \"JSPepUy09VHUTxA59nT5HRmoEeoTFRizxTfi2LkZrphuwCotxoRXiRUu+3f1lyJU\\n\" +\n+        \"Qb5qCCFTQ5bE8squgTwGcVxhajC66V3ePePlAuPatkWN2ek28X1DoLaDR+Rk3h69\\n\" +\n+        \"Wb2EQbNMl4grkUUoMA8jaVhBb4vhyQSK+qjyAUFerQKBgQDXZPuflfsjH\/d\/O2yw\\n\" +\n+        \"qZbssKe9AKORjv795teblAc3vmsSlNwwVnPdS2aq1LHyoNbetc\/OaZV151hTQ\/9z\\n\" +\n+        \"bsA48oOojgrDD07Ovg3uDcNEIufxR0aGeSSvqhElp1r7wAYj8bAr6W\/RH6MS16WW\\n\" +\n+        \"dRd+PH6hsap8BD2RlVCnrT3vIQ==\";\n@@ -145,0 +159,27 @@\n+    static String caSignerPrivateKey = \/\/ Private key in the format of PKCS#8\n+        \"MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQDAvGeLKlW1ljae\\n\" +\n+        \"eu8NvDCjfW5BNK2c0C4ry7Is+1mM4PC7FA4bRpMaQHKIjLsZ5D1hoA9183cv3p1a\\n\" +\n+        \"P75\/ZYMOyx1id\/hXmbd3jp8BR0wbvrKxa53+4lO0S5AL5dOpU2AVhcdeQ7+DwoL6\\n\" +\n+        \"iAuHqNcABg3CijrIcFeZHcPMwaZMd9YxJG6YrnNHMWjbXTGKpma02NMB1UnRxsdN\\n\" +\n+        \"phqfRt2gkUs18l6697sSJ7eblvSWEWw1Bmtrg9No28UUsiF8q0m9i\/G0QzYOrS6v\\n\" +\n+        \"ghum5bpHAixxfA9Z\/ozHrN8gf8gNDTRnG6phDwVb1Uj9nO2f9yTArx7Kz5EtRNmD\\n\" +\n+        \"x9SNMS9rAgMBAAECggEAZk6cF\/8s5+sIqy9OXdgbaW1XbT1tOuQ23gCOX9o8Os\/c\\n\" +\n+        \"eTG4GzpnM3QqV9l8J85D1uKD0nSeO8bLd\/CGSlG0M9IVkwNjy\/xIqyoFtUQHXmLn\\n\" +\n+        \"r84UXAv\/qqDBoc8pf6RGSKZuodcMfgBuTlaQ6D3zgou0GiQN9\/\/KP\/jQyouwnr3A\\n\" +\n+        \"LyXQekxriwPuSYAPak8s5XLfugOebbSRm2UdGEgX3yrT9FVu9rtgeMKdRaCOU8T4\\n\" +\n+        \"G2UdpGaiDfm5yrR+2XEIv4oaH3WFxmmfQCxVcOFJ1iRvfKBbLb1UCgtJuCBD067y\\n\" +\n+        \"dq5PrwUTeAvd7hwZd0lxCSnWY7VvYFNr7iJfyElowQKBgQD8eosot+Th03hpkYDs\\n\" +\n+        \"BIVsw7oqhJmcrPV1bSZ+aQwqqrOGypNmb7nLGTC8Cj1sT+EzfGs7GqxiLOEn4NXr\\n\" +\n+        \"TYV\/\/RUPBSEXVp2y+2dot1a9oq0BJ8FwGTYL0qSwJrIXJfkQFrYhVVz3JLIWJbwV\\n\" +\n+        \"cy4YCQr094BhXTS7joJOUDRsYwKBgQDDbI3Lv+bBK8lLfIBll1RY1k5Gqy\/H+qxp\\n\" +\n+        \"sMN8FmadmIGzHhe9xml6b5EfAZphAUF4vZJhQXloT5Wm+NNIAf6X6dRjvzyw7N9B\\n\" +\n+        \"d48EFJF4ChqNGBocsQRNr2wPRzQ+k2caw9YyYMIjbhktDzO1U\/FJGYW6\/Vgr2v4K\\n\" +\n+        \"siROnXfLWQKBgBOVAZQP5z2opC8z7NbhZuPPrnG7xRpEw+jupUyqoxnwEWqD7bjF\\n\" +\n+        \"M5jQBFqhRLBQ5buTi9GSuQoIRxJLuuu8IH2TyH1YvX9M5YBLRXL2vVCJ\/HcZeURT\\n\" +\n+        \"gECcfs92wNtQw6d+y3N8ZnB4tSNIm\/Th8RJGKUZkp91lWECvxeWDDP3XAoGASfNq\\n\" +\n+        \"NRAJYlAPfGFAtTDu2i8+r79X9XUGiXg6gVp4umpbqkxY75eFkq9lWzZgFRVEkUwr\\n\" +\n+        \"eGIubyquluDSEw2uKg5yMMzNSqZYVY3IsOKXqbUpFvtn5jOWTU90tNNdEdD100sI\\n\" +\n+        \"Y0f6Ly4amNKH3rZFOERQNtJn6zCTsbh3xMgR7QECgYBhQTqxLU5eIu38MKobzRue\\n\" +\n+        \"RoUkMcoY3DePkKPSYjilFhkUDozIXf\/xUGnB8kERZKO+44wUkuPGljiFL1\/P\/RO9\\n\" +\n+        \"zhHAV94Kw2ddtfxy05GVtUZ99miBmsMb2m8vumGJqfR8h2xpfc1Ra0zfrsPgLNru\\n\" +\n+        \"xDTDW+bNbM7XyPvg9mOf7Q==\";\n@@ -178,0 +219,27 @@\n+    static String certIssuerPrivateKey = \/\/ Private key in the format of PKCS#8\n+        \"MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQC1lDVpzmzwbKOL\\n\" +\n+        \"yFWkjPjqtX9xLMq7SVqobvhBv+VChMGGjQbNQPbtczOcXNOcuMFyXxY++eXY7c37\\n\" +\n+        \"MzhbdZHv4Y4aWEn+A3EiX2\/fTAbxx165qxKiHbD2EmlKk\/Q6yIvi9M9EXXr\/viEC\\n\" +\n+        \"Y4\/Sdtd4KYtfETa0FpfF5\/ZpZMYQo8I9RqBQOmhfvXL1l\/Lodla5elZtvIUyp5k2\\n\" +\n+        \"nRQe58AxeP5hrilbIgfmEySf9mOkaTalRf2epBE\/wRNA7Qi5Sr2O4pY2x3PPdmMy\\n\" +\n+        \"NL4cZaOJTgdyeDYbEMSW6vpiJW26ma\/qeFgPIXZ8COFJZLSOEu310M4QOdSR1Y2c\\n\" +\n+        \"l3\/V2E0VAgMBAAECggEBAJjfVrjl2kHwtSCSYchQB6FTfSBDnctgTrtP8iMo9FO0\\n\" +\n+        \"gVpOkVNtRndTbjhOzro7smIgPBJ5QlIIpErBLMmTinJza7gybNk2\/KD7yKwuzgnw\\n\" +\n+        \"2IdoyB9E8B+8EHmBZzW2ck953KaqLUvzPsdMG2IOPAomr\/gx\/eRQwScVzBefiEGo\\n\" +\n+        \"sN+rGfUt\/RNAHwWje1KuNDj21S84agQhN6hdYUnIMsvJLu\/9mOwUb9ff+AzTUfFr\\n\" +\n+        \"zyx2MJL4Cx59DkUUMESCfinlHUc21llQjFWmX\/zOoGY0X0qV\/YM\/GRsv1ZDFHw9o\\n\" +\n+        \"hQ6m8Ov7D9wB3TKZBI97sCyggjBfSeuYQlNbs99KWQECgYEA7IKNL0ME7FuIrKYu\\n\" +\n+        \"FCQ\/Duz1N3oQXLzrTGKUSU1qSbrU2Jwk4SfJ8ZYCW1TP6vZkaQsTXmXun3yyCAqZ\\n\" +\n+        \"hcOtDBhI+b7Wpmmyf6nb83oYJtzHMRQZ5qS+9vOBfV9Uf1za8XI4p90EqkFHByCF\\n\" +\n+        \"tHfjVbjK39zN4CvaO3tqpOaYtL0CgYEAxIrTAhGWy9nBsxf8QeqDou0rV5Cw50Kl\\n\" +\n+        \"kQsE7KLmjvrMaFFpUc5lgWoC+pm\/69VpNBUuN\/38YozwxVjVi\/nMJuuK150mhdWI\\n\" +\n+        \"B28FI7ORnFmVeSvTrP4mBX1ct2Tny9zpchXn3rpHR5NZUs7oBhjudHSfRMrHxeBs\\n\" +\n+        \"Kv2pr2s6uzkCgYAtrEh3iAm7WzHZpX3ghd9nknsIa5odTp5h8eeRAFI2Ss4vxneY\\n\" +\n+        \"w4ZMERwDZy1\/wnVBk9H5uNWMFxiKVQGww0j3vPjawe\/R0zeVT8gaDMn9N0WARNF7\\n\" +\n+        \"qPT3265196LptZTSa6xlPllYR6LfzXgEkeJk+3qyIIHheJZ8RikiDyYOQQKBgQC\/\\n\" +\n+        \"rxlegiMNC4KDldf7vanGxAKqcz5lPbXWQOX7mGC+f9HNx+Cs3VxYHDltiXgJnOju\\n\" +\n+        \"191s1HRK9WR5REt5KhY2uzB9WxJQItJ5VYiwqhhQYXqLY\/gdVv1kC0DayDndtMWk\\n\" +\n+        \"88JhklGkeAv83DikgbpGr9sJr6+oyFkWkLDmmfD82QKBgQCMgkZJzrdSNNlB0n5x\\n\" +\n+        \"xC3MzlsQ5aBJuUctnMfuyDi+11yLAuP1oLzGEJ7qEfFoGRO0V8zJWmHAfNhmVYEX\\n\" +\n+        \"ow5g0WbPT16GoRCiOAzq+ewH+TEELMF6HWqnDuTnCg28Jg0dw2kdVTqeyzKOQlLG\\n\" +\n+        \"ua9c2DY3PUTXQPNqLVhz+XxZKA==\";\n@@ -212,1 +280,0 @@\n-        \"-----BEGIN PRIVATE KEY-----\\n\" +\n@@ -238,2 +305,1 @@\n-        \"TiSXLpQ1Q9GvDpzngDzJzzY=\\n\" +\n-        \"-----END PRIVATE KEY-----\";\n+        \"TiSXLpQ1Q9GvDpzngDzJzzY=\";\n@@ -274,1 +340,0 @@\n-        \"-----BEGIN PRIVATE KEY-----\\n\" +\n@@ -300,2 +365,1 @@\n-        \"i1pnyMPaloBOhz3Y07sWXxCz\\n\" +\n-        \"-----END PRIVATE KEY-----\";\n+        \"i1pnyMPaloBOhz3Y07sWXxCz\";\n@@ -303,1 +367,1 @@\n-    static char[] passphrase = \"passphrase\".toCharArray();\n+    static char passphrase[] = \"passphrase\".toCharArray();\n@@ -313,1 +377,1 @@\n-    static boolean debug = Boolean.getBoolean(\"test.debug\");\n+    static boolean debug = false;\n@@ -386,1 +450,2 @@\n-        final PEMDecoder pemDecoder = PEMDecoder.of();\n+        \/\/ generate certificate from cert string\n+        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n@@ -392,4 +457,0 @@\n-        \/\/ generate certificate from cert string\n-\n-        Certificate trusedCert = pemDecoder.decode(trusedCertStr, X509Certificate.class);\n-\n@@ -397,0 +458,5 @@\n+        ByteArrayInputStream is =\n+            new ByteArrayInputStream(trusedCertStr.getBytes());\n+        Certificate trusedCert = cf.generateCertificate(is);\n+        is.close();\n+\n@@ -402,1 +468,3 @@\n-        Certificate caSignerCert =pemDecoder.decode(caSignerStr, X509Certificate.class);\n+        is = new ByteArrayInputStream(caSignerStr.getBytes());\n+        Certificate caSignerCert = cf.generateCertificate(is);\n+        is.close();\n@@ -405,1 +473,3 @@\n-        Certificate certIssuerCert =pemDecoder.decode(certIssuerStr, X509Certificate.class);\n+        is = new ByteArrayInputStream(certIssuerStr.getBytes());\n+        Certificate certIssuerCert = cf.generateCertificate(is);\n+        is.close();\n@@ -408,2 +478,1 @@\n-        PKCS8EncodedKeySpec priKeySpec;\n-        Certificate keyCert;\n+        PKCS8EncodedKeySpec priKeySpec = null;\n@@ -411,2 +480,3 @@\n-            priKeySpec =pemDecoder.decode(serverPrivateKey, PKCS8EncodedKeySpec.class);\n-            keyCert = pemDecoder.decode(serverCertStr, X509Certificate.class);\n+            priKeySpec = new PKCS8EncodedKeySpec(\n+                            Base64.getMimeDecoder().decode(serverPrivateKey));\n+            is = new ByteArrayInputStream(serverCertStr.getBytes());\n@@ -414,2 +484,3 @@\n-            priKeySpec = pemDecoder.decode(clientPrivateKey, PKCS8EncodedKeySpec.class);\n-            keyCert = pemDecoder.decode(clientCertStr, X509Certificate.class);\n+            priKeySpec = new PKCS8EncodedKeySpec(\n+                            Base64.getMimeDecoder().decode(clientPrivateKey));\n+            is = new ByteArrayInputStream(clientCertStr.getBytes());\n@@ -419,0 +490,2 @@\n+        Certificate keyCert = cf.generateCertificate(is);\n+        is.close();\n@@ -426,2 +499,1 @@\n-        CertPath path = CertificateFactory.getInstance(\"X.509\")\n-                .generateCertPath(Arrays.asList(chain));\n+        CertPath path = cf.generateCertPath(Arrays.asList(chain));\n@@ -462,1 +534,1 @@\n-    public static void main(String[] args) throws Exception {\n+    public static void main(String args[]) throws Exception {\n@@ -517,12 +589,14 @@\n-            serverThread = new Thread(() -> {\n-                try {\n-                    doServerSide();\n-                } catch (Exception e) {\n-                    \/*\n-                     * Our server thread just died.\n-                     *\n-                     * Release the client, if not active already...\n-                     *\/\n-                    System.err.println(\"Server died...\");\n-                    serverReady = true;\n-                    serverException = e;\n+            serverThread = new Thread() {\n+                public void run() {\n+                    try {\n+                        doServerSide();\n+                    } catch (Exception e) {\n+                        \/*\n+                         * Our server thread just died.\n+                         *\n+                         * Release the client, if not active already...\n+                         *\/\n+                        System.err.println(\"Server died...\");\n+                        serverReady = true;\n+                        serverException = e;\n+                    }\n@@ -530,1 +604,1 @@\n-            });\n+            };\n@@ -539,9 +613,11 @@\n-            clientThread = new Thread(() -> {\n-                try {\n-                    doClientSide();\n-                } catch (Exception e) {\n-                    \/*\n-                     * Our client thread just died.\n-                     *\/\n-                    System.err.println(\"Client died...\");\n-                    clientException = e;\n+            clientThread = new Thread() {\n+                public void run() {\n+                    try {\n+                        doClientSide();\n+                    } catch (Exception e) {\n+                        \/*\n+                         * Our client thread just died.\n+                         *\/\n+                        System.err.println(\"Client died...\");\n+                        clientException = e;\n+                    }\n@@ -549,1 +625,1 @@\n-            });\n+            };\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/BasicConstraints.java","additions":144,"deletions":68,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @enablePreview\n@@ -33,2 +32,4 @@\n-import javax.net.ssl.TrustManagerFactory;\n-import javax.net.ssl.X509TrustManager;\n+import java.net.*;\n+import java.util.*;\n+import java.io.*;\n+import javax.net.ssl.*;\n@@ -36,1 +37,0 @@\n-import java.security.PEMDecoder;\n@@ -38,0 +38,1 @@\n+import java.security.cert.CertificateFactory;\n@@ -40,0 +41,2 @@\n+import java.security.spec.*;\n+import java.security.interfaces.*;\n@@ -213,2 +216,0 @@\n-    private static final PEMDecoder pemDecoder = PEMDecoder.of();\n-\n@@ -255,0 +256,2 @@\n+        \/\/ generate certificate from cert string\n+        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n@@ -260,2 +263,0 @@\n-        \/\/ generate certificate from cert string\n-        Certificate trustedCert = pemDecoder.decode(trustedCertStr, X509Certificate.class);\n@@ -263,1 +264,5 @@\n-        ks.setCertificateEntry(\"RSA Export Signer\", trustedCert);\n+        try (ByteArrayInputStream is =\n+                new ByteArrayInputStream(trustedCertStr.getBytes())) {\n+            Certificate trustedCert = cf.generateCertificate(is);\n+            ks.setCertificateEntry(\"RSA Export Signer\", trustedCert);\n+        }\n@@ -274,0 +279,2 @@\n+        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+\n@@ -275,4 +282,19 @@\n-        chain[0] = pemDecoder.decode(targetCertStr, X509Certificate.class);\n-        chain[1] = pemDecoder.decode(intermediateCertStr, X509Certificate.class);\n-        chain[2] = pemDecoder.decode(compromisedCertStr, X509Certificate.class);\n-        chain[3] = pemDecoder.decode(untrustedCrossCertStr, X509Certificate.class);\n+        try (ByteArrayInputStream is =\n+                new ByteArrayInputStream(targetCertStr.getBytes())) {\n+            chain[0] = (X509Certificate)cf.generateCertificate(is);\n+        }\n+\n+        try (ByteArrayInputStream is =\n+                new ByteArrayInputStream(intermediateCertStr.getBytes())) {\n+            chain[1] = (X509Certificate)cf.generateCertificate(is);\n+        }\n+\n+        try (ByteArrayInputStream is =\n+                new ByteArrayInputStream(compromisedCertStr.getBytes())) {\n+            chain[2] = (X509Certificate)cf.generateCertificate(is);\n+        }\n+\n+        try (ByteArrayInputStream is =\n+                new ByteArrayInputStream(untrustedCrossCertStr.getBytes())) {\n+            chain[3] = (X509Certificate)cf.generateCertificate(is);\n+        }\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/ComodoHacker.java","additions":36,"deletions":14,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n- * @run main\/timeout=300 EC\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/EC.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,1 @@\n- * @bug 4170635 8258247 8367008\n- * @library \/test\/lib\n+ * @bug 4170635 8258247\n@@ -33,1 +32,1 @@\n-import java.io.IOException;\n+import java.io.*;\n@@ -38,2 +37,0 @@\n-import jdk.test.lib.Asserts;\n-\n@@ -103,15 +100,0 @@\n-\n-        \/\/ Construct an AlgorithmId with explicit DER NULL parameters\n-        DerValue explicitNullParams = new DerValue(DerValue.tag_Null, new byte[0]);\n-        AlgorithmId aiNullParams = new AlgorithmId(AlgorithmId.SHA256_oid,\n-                explicitNullParams);\n-        \/\/ The constructor should canonicalize this to \"no parameters\"\n-        Asserts.assertTrue(aiNullParams.getEncodedParams() == null);\n-        AlgorithmId aiNormal = AlgorithmId.get(\"SHA-256\");\n-        Asserts.assertEquals(aiNullParams, aiNormal);\n-        Asserts.assertEquals(aiNullParams.hashCode(), aiNormal.hashCode());\n-\n-        \/\/ Test invalid ASN.1 NULL (non-zero length)\n-        DerValue invalidNull = new DerValue(DerValue.tag_Null, new byte[]{0x00});\n-        Asserts.assertThrows(IOException.class,\n-                () -> new AlgorithmId(AlgorithmId.SHA256_oid, invalidNull));\n","filename":"test\/jdk\/sun\/security\/x509\/AlgorithmId\/AlgorithmIdEqualsHashCode.java","additions":3,"deletions":21,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,7 +70,0 @@\n-        test(\"HmacSHA1\", true);\n-        test(\"HmacSHA224\", true);\n-        test(\"HmacSHA256\", true);\n-        test(\"HmacSHA384\", true);\n-        test(\"HmacSHA512\", true);\n-        test(\"HmacSHA512\/224\", true);\n-        test(\"HmacSHA512\/256\", true);\n@@ -93,0 +86,1 @@\n+        test(\"HmacSHA1\", false);\n","filename":"test\/jdk\/sun\/security\/x509\/AlgorithmId\/NullParams.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @enablePreview\n@@ -31,10 +30,3 @@\n-import java.security.InvalidKeyException;\n-import java.security.NoSuchAlgorithmException;\n-import java.security.PEMDecoder;\n-import java.security.Provider;\n-import java.security.PublicKey;\n-import java.security.Security;\n-import java.security.SignatureException;\n-import java.security.cert.CRLException;\n-import java.security.cert.X509CRL;\n-import java.security.cert.X509Certificate;\n+import java.io.ByteArrayInputStream;\n+import java.security.*;\n+import java.security.cert.*;\n@@ -155,1 +147,2 @@\n-    private static void setup() {\n+    private static void setup() throws CertificateException, CRLException {\n+        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n@@ -157,1 +150,0 @@\n-        final PEMDecoder pemDecoder = PEMDecoder.of();\n@@ -159,1 +151,3 @@\n-        crl = pemDecoder.decode(crlStr, X509CRL.class);\n+        ByteArrayInputStream inputStream =\n+                new ByteArrayInputStream(crlStr.getBytes());\n+        crl = (X509CRL)cf.generateCRL(inputStream);\n@@ -162,3 +156,4 @@\n-        crlIssuerCertPubKey = pemDecoder.decode(crlIssuerCertStr, X509Certificate.class)\n-                .getPublicKey();\n-\n+        inputStream = new ByteArrayInputStream(crlIssuerCertStr.getBytes());\n+        X509Certificate cert\n+                = (X509Certificate)cf.generateCertificate(inputStream);\n+        crlIssuerCertPubKey = cert.getPublicKey();\n@@ -167,3 +162,2 @@\n-        selfSignedCertPubKey = pemDecoder.decode(selfSignedCertStr, X509Certificate.class)\n-                .getPublicKey();\n-\n+        inputStream = new ByteArrayInputStream(selfSignedCertStr.getBytes());\n+        selfSignedCertPubKey = cf.generateCertificate(inputStream).getPublicKey();\n","filename":"test\/jdk\/sun\/security\/x509\/X509CRLImpl\/Verify.java","additions":15,"deletions":21,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -72,1 +72,0 @@\n-                        .sorted()\n","filename":"test\/jdk\/tools\/jpackage\/apps\/PrintEnv.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -123,1 +123,2 @@\n-      -e 's|\/jdk.jpackage[0-9]\\{1,\\}\/|\/jdk.jpackage\/|' \\\n+      -e 's|\"\/.*\/jdk.jpackage[0-9]\\{1,\\}\/|\"\/jdk.jpackage\/|' \\\n+      -e 's|\"file:\/\/\/.*\/jdk.jpackage[0-9]\\{1,\\}\/|\"file:\/\/\/jdk.jpackage\/|' \\\n","filename":"test\/jdk\/tools\/jpackage\/clean_stashed_files.sh","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -59,3 +59,0 @@\n-      # Strip variable part of temporary directory name `jdk.jpackage.test217379316521032539`\n-      -e 's|\\([\\\/]\\)jdk\\.jpackage\\.test[0-9]\\{1,\\}\\b|\\1jdk.jpackage.test|g'\n-\n@@ -82,35 +79,0 @@\n-\n-      # Whipe out entire output of \/usr\/bin\/hdiutil command.\n-      # It is of little to no interest and contains too many variable parts to deal with individually.\n-      -e '\/^Running \\\/usr\\\/bin\\\/hdiutil\/,\/^Returned:\/{\n-            \/\/,\/^Output:\/!d\n-          }'\n-\n-      # Zip stack traces.\n-      -e $'\/^\\tat \/{\n-            :a\n-            g\n-            N\n-            s\/.*\\\\n\/\/\n-            \/^\\tat \/ba\n-            s\/\\\\(^\\t... \\\\)[0-9]\\\\{1,\\\\}\\\\( more\\\\)\/\\\\1N\\\\2\/\n-            s\/\\(.*\\)\/\\tat <stacktrace>\\\\n\\\\1\/\n-            P\n-            D\n-          }'\n-\n-      # Convert PID value in `taskkill \/F \/PID 5640`\n-      -e 's|taskkill \/F \/PID [0-9]\\{1,\\}|taskkill \/F \/PID <pid>|'\n-\n-      # Convert PID value in `The process with PID 5640 has been terminated`\n-      -e 's|\\(The process with PID \\)[0-9]\\{1,\\}\\( has been terminated\\)|\\1<pid>\\2|'\n-\n-      # Convert timeout value in `Check timeout value 57182ms is positive`\n-      -e 's|\\(Check timeout value \\)[0-9]\\{1,\\}\\(ms is positive\\)|\\1<timeout>\\2|'\n-\n-      # Convert variable part of \/usr\/bin\/osascript output `jdk.jpackage\/config\/SigningRuntimeImagePackageTest-dmg-setup.scpt:455:497: execution error: Finder got an error: Can’t set 1 to icon view. (-10006)`\n-      -e 's|\\(-dmg-setup.scpt:\\)[0-9]\\{1,\\}:[0-9]\\{1,\\}\\(: execution error: \\)|\\1<N:M>\\2|'\n-\n-      # Use the same name for all exceptions.\n-      -e 's|[^ ]\\{1,\\}\\.[^ ]\\{1,\\}\\Exception:|<Exception>:|g'\n-      -e 's|[^ ]\\{1,\\}\\.[^ ]\\{1,\\}\\ExceptionBox:|<Exception>:|g'\n","filename":"test\/jdk\/tools\/jpackage\/clean_test_output.sh","additions":0,"deletions":38,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -98,12 +98,0 @@\n-        enum Tack {\n-            STARBOARD,\n-            PORTSIDE;\n-        }\n-\n-        @Test\n-        @Parameter({\"STARBOARD\"})\n-        @Parameter({\"PORTSIDE\", \"STARBOARD\"})\n-        public void testEnumVarArg(Tack ... cource) {\n-            recordTestCase((Object[]) cource);\n-        }\n-\n@@ -133,2 +121,0 @@\n-                    \"().testEnumVarArg(STARBOARD)\",\n-                    \"().testEnumVarArg(PORTSIDE, STARBOARD)\",\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/AnnotationsTest.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.test;\n-\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertThrows;\n-\n-import java.util.Map;\n-import org.junit.jupiter.api.Test;\n-\n-public class JUnitUtilsTest {\n-\n-    @Test\n-    public void test_assertArrayEquals() {\n-        JUnitUtils.assertArrayEquals(new int[] {1, 2, 3}, new int[] {1, 2, 3});\n-        JUnitUtils.assertArrayEquals(new long[] {1, 2, 3}, new long[] {1, 2, 3});\n-        JUnitUtils.assertArrayEquals(new boolean[] {true, true}, new boolean[] {true, true});\n-    }\n-\n-    @Test\n-    public void test_assertArrayEquals_negative() {\n-        assertThrows(AssertionError.class, () -> {\n-            JUnitUtils.assertArrayEquals(new int[] {1, 2, 3}, new int[] {2, 3});\n-        });\n-    }\n-\n-    @Test\n-    public void test_exceptionAsPropertyMapWithMessageWithoutCause() {\n-\n-        var ex = new Exception(\"foo\");\n-\n-        var map = JUnitUtils.exceptionAsPropertyMap(ex);\n-\n-        assertEquals(Map.of(\"getClass\", Exception.class.getName(), \"getMessage\", \"foo\"), map);\n-    }\n-}\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/JUnitUtilsTest.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -1,731 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.test;\n-\n-import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertNotEquals;\n-import static org.junit.jupiter.api.Assertions.assertNull;\n-import static org.junit.jupiter.api.Assertions.assertSame;\n-import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n-\n-import java.lang.reflect.InvocationHandler;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Proxy;\n-import java.math.BigInteger;\n-import java.nio.file.Path;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.UUID;\n-import java.util.function.BiConsumer;\n-import java.util.function.BiFunction;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-import java.util.function.Predicate;\n-import java.util.function.Supplier;\n-import org.junit.jupiter.api.Test;\n-\n-public class ObjectMapperTest {\n-\n-    @Test\n-    public void test_String() {\n-        var om = ObjectMapper.blank().create();\n-\n-        var map = om.map(\"foo\");\n-\n-        assertEquals(\"foo\", map);\n-    }\n-\n-    @Test\n-    public void test_int() {\n-        var om = ObjectMapper.blank().create();\n-\n-        var map = om.map(100);\n-\n-        assertEquals(100, map);\n-    }\n-\n-    @Test\n-    public void test_null() {\n-        var om = ObjectMapper.blank().create();\n-\n-        var map = om.map(null);\n-\n-        assertNull(map);\n-    }\n-\n-    @Test\n-    public void test_Object() {\n-        var obj = new Object();\n-        assertSame(obj, ObjectMapper.blank().create().map(obj));\n-        assertSame(obj, ObjectMapper.standard().create().map(obj));\n-    }\n-\n-    @Test\n-    public void test_Path() {\n-        var obj = Path.of(\"foo\/bar\");\n-\n-        assertSame(obj, ObjectMapper.standard().create().map(obj));\n-    }\n-\n-    @Test\n-    public void test_UUID() {\n-        var obj = UUID.randomUUID();\n-\n-        assertSame(obj, ObjectMapper.standard().create().map(obj));\n-    }\n-\n-    @Test\n-    public void test_BigInteger() {\n-        var obj = BigInteger.TEN;\n-\n-        assertSame(obj, ObjectMapper.standard().create().map(obj));\n-    }\n-\n-    @Test\n-    public void test_Enum() {\n-\n-        var expected = Map.of(\n-                \"name\", TestEnum.BAR.name(),\n-                \"ordinal\", TestEnum.BAR.ordinal(),\n-                \"a\", \"A\",\n-                \"b\", 123,\n-                \"num\", 100\n-        );\n-\n-        assertEquals(expected, ObjectMapper.standard().create().map(TestEnum.BAR));\n-    }\n-\n-    @Test\n-    public void test_array_int() {\n-\n-        var obj = new int[] { 1, 4, 5 };\n-\n-        assertSame(obj, ObjectMapper.standard().create().map(obj));\n-    }\n-\n-    @Test\n-    public void test_array_String() {\n-\n-        var obj = new String[] { \"Hello\", \"Bye\" };\n-\n-        assertSame(obj, ObjectMapper.standard().create().map(obj));\n-    }\n-\n-    @Test\n-    public void test_array_empty() {\n-\n-        var obj = new Thread[0];\n-\n-        assertSame(obj, ObjectMapper.standard().create().map(obj));\n-    }\n-\n-    @Test\n-    public void test_array_nulls() {\n-\n-        var obj = new Thread[10];\n-\n-        assertSame(obj, ObjectMapper.standard().create().map(obj));\n-    }\n-\n-    @Test\n-    public void test_array_Path() {\n-\n-        var obj = new Path[] { Path.of(\"foo\/bar\"), null, Path.of(\"\").toAbsolutePath() };\n-\n-        assertSame(obj, ObjectMapper.standard().create().map(obj));\n-    }\n-\n-    @Test\n-    public void test_array_Object() {\n-\n-        var obj = new Object[] { Path.of(\"foo\/bar\"), null, 145, new Simple.Stub(\"Hello\", 738), \"foo\" };\n-\n-        var expected = new Object[] { Path.of(\"foo\/bar\"), null, 145, Map.of(\"a\", \"Hello\", \"b\", 738), \"foo\" };\n-\n-        assertArrayEquals(expected, (Object[])ObjectMapper.standard().create().map(obj));\n-    }\n-\n-    @Test\n-    public void test_functional() {\n-        assertWrappedIdentity(new Function<Object, Integer>() {\n-\n-            @Override\n-            public Integer apply(Object o) {\n-                throw new AssertionError();\n-            }\n-\n-        });\n-\n-        assertWrappedIdentity(new BiFunction<Object, String, Integer>() {\n-\n-            @Override\n-            public Integer apply(Object a, String b) {\n-                throw new AssertionError();\n-            }\n-\n-        });\n-\n-        assertWrappedIdentity(new Consumer<>() {\n-\n-            @Override\n-            public void accept(Object o) {\n-                throw new AssertionError();\n-            }\n-\n-        });\n-\n-        assertWrappedIdentity(new BiConsumer<>() {\n-\n-            @Override\n-            public void accept(Object a, Object b) {\n-                throw new AssertionError();\n-            }\n-\n-        });\n-\n-        assertWrappedIdentity(new Predicate<>() {\n-\n-            @Override\n-            public boolean test(Object o) {\n-                throw new AssertionError();\n-            }\n-\n-        });\n-\n-        assertWrappedIdentity(new Supplier<>() {\n-\n-            @Override\n-            public Object get() {\n-                throw new AssertionError();\n-            }\n-\n-        });\n-\n-        assertWrappedIdentity(new Runnable() {\n-\n-            @Override\n-            public void run() {\n-                throw new AssertionError();\n-            }\n-\n-        });\n-    }\n-\n-    @Test\n-    public void testIdentityWrapper() {\n-        var om = ObjectMapper.standard().create();\n-\n-        var a = new Object() {};\n-        var b = new Object() {};\n-\n-        var amap = om.map(a);\n-        var amap2 = om.map(a);\n-\n-        assertEquals(amap, amap2);\n-        assertEquals(ObjectMapper.wrapIdentity(a), amap);\n-\n-        var bmap = om.map(b);\n-\n-        assertNotEquals(amap, bmap);\n-        assertEquals(ObjectMapper.wrapIdentity(b), bmap);\n-    }\n-\n-    @Test\n-    public void test_wrapIdentity() {\n-\n-        assertThrowsExactly(NullPointerException.class, () -> ObjectMapper.wrapIdentity(null));\n-\n-        var iw = ObjectMapper.wrapIdentity(new Object());\n-\n-        assertSame(iw, ObjectMapper.wrapIdentity(iw));\n-\n-        var simpleStubA = new Simple.Stub(\"Hello\", 77);\n-        var simpleStubB = new Simple.Stub(\"Hello\", 77);\n-\n-        assertEquals(simpleStubA, simpleStubB);\n-        assertNotEquals(ObjectMapper.wrapIdentity(simpleStubA), ObjectMapper.wrapIdentity(simpleStubB));\n-        assertEquals(ObjectMapper.wrapIdentity(simpleStubA), ObjectMapper.wrapIdentity(simpleStubA));\n-    }\n-\n-    @Test\n-    public void test_empty_List() {\n-        var om = ObjectMapper.blank().create();\n-\n-        var map = om.map(List.of());\n-\n-        assertEquals(List.of(), map);\n-    }\n-\n-    @Test\n-    public void test_List() {\n-        var om = ObjectMapper.blank().create();\n-\n-        var map = om.map(List.of(100, \"foo\"));\n-\n-        assertEquals(List.of(100, \"foo\"), map);\n-    }\n-\n-    @Test\n-    public void test_empty_Map() {\n-        var om = ObjectMapper.blank().create();\n-\n-        var map = om.map(Map.of());\n-\n-        assertEquals(Map.of(), map);\n-    }\n-\n-    @Test\n-    public void test_Map() {\n-        var om = ObjectMapper.blank().create();\n-\n-        var map = om.map(Map.of(100, \"foo\"));\n-\n-        assertEquals(Map.of(100, \"foo\"), map);\n-    }\n-\n-    @Test\n-    public void test_MapSimple() {\n-        var om = ObjectMapper.standard().create();\n-\n-        var map = om.map(Map.of(123, \"foo\", 321, new Simple.Stub(\"Hello\", 567)));\n-\n-        assertEquals(Map.of(123, \"foo\", 321, Map.of(\"a\", \"Hello\", \"b\", 567)), map);\n-    }\n-\n-    @Test\n-    public void test_ListSimple() {\n-        var om = ObjectMapper.standard().create();\n-\n-        var map = om.map(List.of(100, new Simple.Stub(\"Hello\", 567), \"bar\", new Simple() {}));\n-\n-        assertEquals(List.of(100, Map.of(\"a\", \"Hello\", \"b\", 567), \"bar\", Map.of(\"a\", \"foo\", \"b\", 123)), map);\n-    }\n-\n-    @Test\n-    public void test_Simple() {\n-        var om = ObjectMapper.standard().create();\n-\n-        var map = om.map(new Simple() {});\n-\n-        assertEquals(Map.of(\"a\", \"foo\", \"b\", 123), map);\n-    }\n-\n-    @Test\n-    public void test_Proxy() {\n-        var om = ObjectMapper.standard().create();\n-\n-        var map = om.map(Proxy.newProxyInstance(Simple.class.getClassLoader(), new Class<?>[] { Simple.class }, new InvocationHandler() {\n-\n-            @Override\n-            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n-                switch (method.getName()) {\n-                    case \"a\" -> {\n-                        return \"Bye\";\n-                    }\n-                    case \"b\" -> {\n-                        return 335;\n-                    }\n-                    default -> {\n-                        throw new UnsupportedOperationException();\n-                    }\n-                }\n-            }\n-\n-        }));\n-\n-        assertEquals(Map.of(\"a\", \"Bye\", \"b\", 335), map);\n-    }\n-\n-    @Test\n-    public void test_Simple_null_property() {\n-        var om = ObjectMapper.standard().create();\n-\n-        var map = om.map(new Simple.Stub(null, 123));\n-\n-        assertEquals(Map.of(\"b\", 123, \"a\", ObjectMapper.NULL), map);\n-    }\n-\n-    @Test\n-    public void test_Optional_String() {\n-        var om = ObjectMapper.standard().create();\n-\n-        var map = om.map(Optional.of(\"foo\"));\n-\n-        assertEquals(Map.of(\"get\", \"foo\"), map);\n-    }\n-\n-    @Test\n-    public void test_Optional_empty() {\n-        var om = ObjectMapper.standard().create();\n-\n-        var map = om.map(Optional.empty());\n-\n-        assertEquals(Map.of(\"get\", ObjectMapper.NULL), map);\n-    }\n-\n-    @Test\n-    public void test_toMap() {\n-        var om = ObjectMapper.standard().create();\n-\n-        assertNull(om.toMap(null));\n-        assertEquals(Map.of(\"value\", \"Hello\"), om.toMap(\"Hello\"));\n-        assertEquals(Map.of(\"a\", \"foo\", \"b\", 123), om.toMap(new Simple() {}));\n-    }\n-\n-    @Test\n-    public void test_getter_throws() {\n-        var om = ObjectMapper.blank()\n-                .mutate(ObjectMapper.configureObject())\n-                .mutate(ObjectMapper.configureLeafClasses())\n-                .mutate(ObjectMapper.configureException())\n-                .create();\n-\n-        var expected = Map.of(\"get\", om.toMap(new UnsupportedOperationException(\"Not for you!\")));\n-\n-        var actual = om.toMap(new Supplier<>() {\n-            @Override\n-            public Object get() {\n-                throw new UnsupportedOperationException(\"Not for you!\");\n-            }\n-        });\n-\n-        assertEquals(expected, actual);\n-    }\n-\n-    @Test\n-    public void test_exception_with_message_with_cause() {\n-\n-        var ex = new Exception(\"foo\", new IllegalArgumentException(\"Cause\", new RuntimeException(\"Ops!\")));\n-\n-        var om = ObjectMapper.standard().create();\n-\n-        var map = om.toMap(ex);\n-\n-        assertEquals(Map.of(\n-                \"getClass\", Exception.class.getName(),\n-                \"getMessage\", \"foo\",\n-                \"getCause\", Map.of(\n-                        \"getClass\", IllegalArgumentException.class.getName(),\n-                        \"getMessage\", \"Cause\",\n-                        \"getCause\", Map.of(\n-                                \"getClass\", RuntimeException.class.getName(),\n-                                \"getMessage\", \"Ops!\"\n-                        )\n-                )\n-        ), map);\n-    }\n-\n-    @Test\n-    public void test_exception_without_message_with_cause() {\n-\n-        var ex = new RuntimeException(null, new UnknownError(\"Ops!\"));\n-\n-        var om = ObjectMapper.standard().create();\n-\n-        var map = om.toMap(ex);\n-\n-        assertEquals(Map.of(\n-                \"getClass\", RuntimeException.class.getName(),\n-                \"getCause\", Map.of(\n-                        \"getMessage\", \"Ops!\",\n-                        \"getCause\", ObjectMapper.NULL\n-                )\n-        ), map);\n-    }\n-\n-    @Test\n-    public void test_exception_without_message_without_cause() {\n-\n-        var ex = new UnsupportedOperationException();\n-\n-        var om = ObjectMapper.standard().create();\n-\n-        var map = om.toMap(ex);\n-\n-        assertEquals(Map.of(\"getClass\", UnsupportedOperationException.class.getName()), map);\n-    }\n-\n-    @Test\n-    public void test_exception_CustomException() {\n-\n-        var ex = new CustomException(\"Hello\", Path.of(\"\"), Optional.empty(), null);\n-\n-        var om = ObjectMapper.standard().create();\n-\n-        var map = om.toMap(ex);\n-\n-        assertEquals(Map.of(\n-                \"getClass\", CustomException.class.getName(),\n-                \"getMessage\", \"Hello\",\n-                \"op\", Map.of(\"get\", ObjectMapper.NULL),\n-                \"path2\", Path.of(\"\")\n-        ), map);\n-    }\n-\n-    @Test\n-    public void test_Builder_accessPackageMethods() {\n-\n-        var obj = new TestType().foo(\"Hello\").bar(81);\n-\n-        var map = ObjectMapper.standard().create().toMap(obj);\n-\n-        assertEquals(Map.of(\"foo\", \"Hello\"), map);\n-\n-        map = ObjectMapper.standard().accessPackageMethods(TestType.class.getPackage()).create().toMap(obj);\n-\n-        assertEquals(Map.of(\"foo\", \"Hello\", \"bar\", 81), map);\n-    }\n-\n-    @Test\n-    public void test_Builder_methods_Simple() {\n-\n-        var om = ObjectMapper.standard().exceptSomeMethods(Simple.class).add(\"a\").apply().create();\n-\n-        assertEquals(Map.of(\"b\", 123), om.toMap(new Simple() {}));\n-        assertEquals(Map.of(\"b\", 345), om.toMap(new Simple.Stub(\"Hello\", 345)));\n-        assertEquals(Map.of(\"b\", 123), om.toMap(new Simple.Default(\"Hello\")));\n-        assertEquals(Map.of(\"b\", 345 + 10), om.toMap(new Simple.DefaultExt(\"Hello\", 345)));\n-\n-        om = ObjectMapper.standard().exceptSomeMethods(Simple.class).add(\"b\").apply().create();\n-\n-        assertEquals(Map.of(\"a\", \"foo\"), om.toMap(new Simple() {}));\n-        assertEquals(Map.of(\"a\", \"Hello\"), om.toMap(new Simple.Stub(\"Hello\", 345)));\n-        assertEquals(Map.of(\"a\", \"Hello\"), om.toMap(new Simple.Default(\"Hello\")));\n-        assertEquals(Map.of(\"a\", \"[Hello]\"), om.toMap(new Simple.DefaultExt(\"Hello\", 345)));\n-    }\n-\n-    @Test\n-    public void test_Builder_methods_SimpleStub() {\n-\n-        var om = ObjectMapper.standard().exceptSomeMethods(Simple.Stub.class).add(\"a\").apply().create();\n-\n-        assertEquals(Map.of(\"a\", \"foo\", \"b\", 123), om.toMap(new Simple() {}));\n-        assertEquals(Map.of(\"b\", 345), om.toMap(new Simple.Stub(\"Hello\", 345)));\n-        assertEquals(Map.of(\"a\", \"Hello\", \"b\", 123), om.toMap(new Simple.Default(\"Hello\")));\n-        assertEquals(Map.of(\"a\", \"[Hello]\", \"b\", 345 + 10), om.toMap(new Simple.DefaultExt(\"Hello\", 345)));\n-\n-        om = ObjectMapper.standard().exceptSomeMethods(Simple.Stub.class).add(\"b\").apply().create();\n-\n-        assertEquals(Map.of(\"a\", \"foo\", \"b\", 123), om.toMap(new Simple() {}));\n-        assertEquals(Map.of(\"a\", \"Hello\"), om.toMap(new Simple.Stub(\"Hello\", 345)));\n-        assertEquals(Map.of(\"a\", \"Hello\", \"b\", 123), om.toMap(new Simple.Default(\"Hello\")));\n-        assertEquals(Map.of(\"a\", \"[Hello]\", \"b\", 345 + 10), om.toMap(new Simple.DefaultExt(\"Hello\", 345)));\n-    }\n-\n-    @Test\n-    public void test_Builder_methods_SimpleDefault() {\n-\n-        var om = ObjectMapper.standard().exceptSomeMethods(Simple.Default.class).add(\"a\").apply().create();\n-\n-        assertEquals(Map.of(\"a\", \"foo\", \"b\", 123), om.toMap(new Simple() {}));\n-        assertEquals(Map.of(\"a\", \"Hello\", \"b\", 345), om.toMap(new Simple.Stub(\"Hello\", 345)));\n-        assertEquals(Map.of(\"b\", 123), om.toMap(new Simple.Default(\"Hello\")));\n-        assertEquals(Map.of(\"b\", 345 + 10), om.toMap(new Simple.DefaultExt(\"Hello\", 345)));\n-\n-        om = ObjectMapper.standard().exceptSomeMethods(Simple.Default.class).add(\"b\").apply().create();\n-\n-        assertEquals(Map.of(\"a\", \"foo\"), om.toMap(new Simple() {}));\n-        assertEquals(Map.of(\"a\", \"Hello\"), om.toMap(new Simple.Stub(\"Hello\", 345)));\n-        assertEquals(Map.of(\"a\", \"Hello\"), om.toMap(new Simple.Default(\"Hello\")));\n-        assertEquals(Map.of(\"a\", \"[Hello]\"), om.toMap(new Simple.DefaultExt(\"Hello\", 345)));\n-    }\n-\n-    @Test\n-    public void test_Builder_methods_SimpleDefaultExt() {\n-\n-        var om = ObjectMapper.standard().exceptSomeMethods(Simple.DefaultExt.class).add(\"a\").apply().create();\n-\n-        assertEquals(Map.of(\"a\", \"foo\", \"b\", 123), om.toMap(new Simple() {}));\n-        assertEquals(Map.of(\"a\", \"Hello\", \"b\", 345), om.toMap(new Simple.Stub(\"Hello\", 345)));\n-        assertEquals(Map.of(\"a\", \"Hello\", \"b\", 123), om.toMap(new Simple.Default(\"Hello\")));\n-        assertEquals(Map.of(\"b\", 345 + 10), om.toMap(new Simple.DefaultExt(\"Hello\", 345)));\n-\n-        om = ObjectMapper.standard().exceptSomeMethods(Simple.DefaultExt.class).add(\"b\").apply().create();\n-\n-        assertEquals(Map.of(\"a\", \"foo\", \"b\", 123), om.toMap(new Simple() {}));\n-        assertEquals(Map.of(\"a\", \"Hello\", \"b\", 345), om.toMap(new Simple.Stub(\"Hello\", 345)));\n-        assertEquals(Map.of(\"a\", \"Hello\", \"b\", 123), om.toMap(new Simple.Default(\"Hello\")));\n-        assertEquals(Map.of(\"a\", \"[Hello]\"), om.toMap(new Simple.DefaultExt(\"Hello\", 345)));\n-    }\n-\n-    @Test\n-    public void test_Builder_methods_SimpleStub_and_SimpleDefault() {\n-\n-        var om = ObjectMapper.standard()\n-                .exceptSomeMethods(Simple.Stub.class).add(\"a\").apply()\n-                .exceptSomeMethods(Simple.Default.class).add(\"a\").apply()\n-                .create();\n-\n-        assertEquals(Map.of(\"a\", \"foo\", \"b\", 123), om.toMap(new Simple() {}));\n-        assertEquals(Map.of(\"b\", 345), om.toMap(new Simple.Stub(\"Hello\", 345)));\n-        assertEquals(Map.of(\"b\", 123), om.toMap(new Simple.Default(\"Hello\")));\n-        assertEquals(Map.of(\"b\", 345 + 10), om.toMap(new Simple.DefaultExt(\"Hello\", 345)));\n-\n-        om = ObjectMapper.standard()\n-                .exceptSomeMethods(Simple.Stub.class).add(\"b\").apply()\n-                .exceptSomeMethods(Simple.Default.class).add(\"b\").apply()\n-                .create();\n-\n-        assertEquals(Map.of(\"a\", \"foo\"), om.toMap(new Simple() {}));\n-        assertEquals(Map.of(\"a\", \"Hello\"), om.toMap(new Simple.Stub(\"Hello\", 345)));\n-        assertEquals(Map.of(\"a\", \"Hello\"), om.toMap(new Simple.Default(\"Hello\")));\n-        assertEquals(Map.of(\"a\", \"[Hello]\"), om.toMap(new Simple.DefaultExt(\"Hello\", 345)));\n-    }\n-\n-    @Test\n-    public void test_Builder_methods_all_excluded() {\n-\n-        var om = ObjectMapper.standard()\n-                .exceptSomeMethods(Simple.class).add(\"a\").apply()\n-                .exceptSomeMethods(Simple.Stub.class).add(\"b\").apply()\n-                .create();\n-\n-        var obj = new Simple.Stub(\"Hello\", 345);\n-\n-        assertEquals(ObjectMapper.wrapIdentity(obj), om.map(obj));\n-    }\n-\n-    interface Simple {\n-        default String a() {\n-            return \"foo\";\n-        }\n-\n-        default int b() {\n-            return 123;\n-        }\n-\n-        record Stub(String a, int b) implements Simple {}\n-\n-        static class Default implements Simple {\n-            Default(String a) {\n-                this.a = a;\n-            }\n-\n-            @Override\n-            public String a() {\n-                return a;\n-            }\n-\n-            private final String a;\n-        }\n-\n-        static class DefaultExt extends Default {\n-            DefaultExt(String a, int b) {\n-                super(a);\n-                this.b = b;\n-            }\n-\n-            @Override\n-            public String a() {\n-                return \"[\" + super.a() + \"]\";\n-            }\n-\n-            @Override\n-            public int b() {\n-                return 10 + b;\n-            }\n-\n-            private final int b;\n-        }\n-    }\n-\n-    final class TestType {\n-\n-        public String foo() {\n-            return foo;\n-        }\n-\n-        public TestType foo(String v) {\n-            foo = v;\n-            return this;\n-        }\n-\n-        int bar() {\n-            return bar;\n-        }\n-\n-        TestType bar(int v) {\n-            bar = v;\n-            return this;\n-        }\n-\n-        private String foo;\n-        private int bar;\n-    }\n-\n-    enum TestEnum implements Simple {\n-        FOO,\n-        BAR;\n-\n-        public int num() {\n-            return 100;\n-        }\n-\n-        public int num(int v) {\n-            return v;\n-        }\n-\n-        @Override\n-        public String a() {\n-            return \"A\";\n-        }\n-    }\n-\n-    static final class CustomException extends Exception {\n-\n-        CustomException(String message, Path path, Optional<Object> optional, Throwable cause) {\n-            super(message, cause);\n-            this.path = path;\n-            this.optional = optional;\n-        }\n-\n-        Path path() {\n-            return path;\n-        }\n-\n-        public Path path2() {\n-            return path;\n-        }\n-\n-        public Optional<Object> op() {\n-            return optional;\n-        }\n-\n-        private final Path path;\n-        private final Optional<Object> optional;\n-\n-        private static final long serialVersionUID = 1L;\n-\n-    }\n-\n-    private static void assertWrappedIdentity(ObjectMapper om, Object obj) {\n-        var map = om.toMap(obj);\n-        assertEquals(Map.of(\"value\", ObjectMapper.wrapIdentity(obj)), map);\n-    }\n-\n-    private static void assertWrappedIdentity(Object obj) {\n-        assertWrappedIdentity(ObjectMapper.standard().create(), obj);\n-    }\n-}\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/ObjectMapperTest.java","additions":0,"deletions":731,"binary":false,"changes":731,"status":"deleted"},{"patch":"@@ -344,1 +344,1 @@\n-                    JPackageCommand runStandardAsserts() {\n+                    JPackageCommand assertAppLayout() {\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/PackageTestTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -201,1 +201,1 @@\n-    public static PropertyFile getAdditionalLauncherProperties(\n+    static PropertyFile getAdditionalLauncherProperties(\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/AdditionalLauncher.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -101,7 +101,1 @@\n-    public static ApplicationLayout platformJavaRuntime() {\n-        Path runtime = Path.of(\"\");\n-        Path runtimeHome = runtime;\n-        if (TKit.isOSX()) {\n-            runtimeHome = Path.of(\"Contents\/Home\");\n-        }\n-\n+    public static ApplicationLayout javaRuntime() {\n@@ -111,2 +105,2 @@\n-                runtime,\n-                runtimeHome,\n+                Path.of(\"\"),\n+                null,\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/ApplicationLayout.java","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -377,8 +377,2 @@\n-            \/\/ Use absolute path as jpackage can be executed in another directory.\n-            \/\/ Some tests expect a specific last argument, don't interfere with them\n-            \/\/ and insert the argument at the beginning of the command line.\n-            List<String> args = new ArrayList<>();\n-            args.add(argName);\n-            args.add(TKit.createTempDirectory(\"stash-script-resource-dir\").toAbsolutePath().toString());\n-            args.addAll(cmd.getAllArguments());\n-            cmd.clearArguments().addArguments(args);\n+            \/\/ Use absolute path as jpackage can be executed in another directory\n+            cmd.setArgumentValue(argName, TKit.createTempDirectory(\"stash-script-resource-dir\").toAbsolutePath());\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/ConfigFilesStasher.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,89 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.test;\n-\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.function.Consumer;\n-\n-\/**\n- * Provides uniform way to configure {@code JPackageCommand} and\n- * {@code PackageTest} instances.\n- *\/\n-public record ConfigurationTarget(Optional<JPackageCommand> cmd, Optional<PackageTest> test) {\n-\n-    public ConfigurationTarget {\n-        Objects.requireNonNull(cmd);\n-        Objects.requireNonNull(test);\n-        if (cmd.isEmpty() == test.isEmpty()) {\n-            throw new IllegalArgumentException();\n-        }\n-    }\n-\n-    public ConfigurationTarget(JPackageCommand target) {\n-        this(Optional.of(target), Optional.empty());\n-    }\n-\n-    public ConfigurationTarget(PackageTest target) {\n-        this(Optional.empty(), Optional.of(target));\n-    }\n-\n-    public ConfigurationTarget apply(Consumer<JPackageCommand> a, Consumer<PackageTest> b) {\n-        cmd.ifPresent(Objects.requireNonNull(a));\n-        test.ifPresent(Objects.requireNonNull(b));\n-        return this;\n-    }\n-\n-    public ConfigurationTarget addInitializer(Consumer<JPackageCommand> initializer) {\n-        cmd.ifPresent(Objects.requireNonNull(initializer));\n-        test.ifPresent(v -> {\n-            v.addInitializer(initializer::accept);\n-        });\n-        return this;\n-    }\n-\n-    public ConfigurationTarget addInstallVerifier(Consumer<JPackageCommand> verifier) {\n-        cmd.ifPresent(Objects.requireNonNull(verifier));\n-        test.ifPresent(v -> {\n-            v.addInstallVerifier(verifier::accept);\n-        });\n-        return this;\n-    }\n-\n-    public ConfigurationTarget addRunOnceInitializer(Consumer<ConfigurationTarget> initializer) {\n-        Objects.requireNonNull(initializer);\n-        cmd.ifPresent(_ -> {\n-            initializer.accept(this);\n-        });\n-        test.ifPresent(v -> {\n-            v.addRunOnceInitializer(() -> {\n-                initializer.accept(this);\n-            });\n-        });\n-        return this;\n-    }\n-\n-    public ConfigurationTarget add(AdditionalLauncher addLauncher) {\n-        return apply(addLauncher::applyTo, addLauncher::applyTo);\n-    }\n-}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/ConfigurationTarget.java","additions":0,"deletions":89,"binary":false,"changes":89,"status":"deleted"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.HashMap;\n@@ -34,1 +35,1 @@\n-import java.util.TreeMap;\n+import java.util.stream.Stream;\n@@ -46,1 +47,1 @@\n-        Map<String, String> entries = new TreeMap<>(Map.of(\n+        Map<String, String> entries = new HashMap<>(Map.of(\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/FileAssociations.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -128,2 +128,0 @@\n-        \/\/ Use an old release number to make test app classes runnable on older runtimes.\n-        builder.setRelease(11);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/HelloApp.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.util.HashMap;\n@@ -70,1 +71,0 @@\n-    @SuppressWarnings(\"this-escape\")\n@@ -74,1 +74,0 @@\n-        excludeStandardAsserts(StandardAssert.MAIN_LAUNCHER_DESCRIPTION);\n@@ -90,1 +89,1 @@\n-        standardAsserts = cmd.standardAsserts;\n+        appLayoutAsserts = cmd.appLayoutAsserts;\n@@ -206,11 +205,0 @@\n-    public JPackageCommand mutate(Consumer<JPackageCommand> mutator) {\n-        return mutate(List.of(mutator));\n-    }\n-\n-    public JPackageCommand mutate(Iterable<Consumer<JPackageCommand>> mutators) {\n-        for (var mutator : mutators) {\n-            mutator.accept(this);\n-        }\n-        return this;\n-    }\n-\n@@ -475,1 +463,1 @@\n-            layout = ApplicationLayout.platformJavaRuntime();\n+            layout = ApplicationLayout.javaRuntime();\n@@ -706,1 +694,1 @@\n-        defaultToolProvider.set(Optional.of(jpackageToolProvider));\n+        defaultToolProvider = Optional.of(jpackageToolProvider);\n@@ -714,1 +702,1 @@\n-        defaultToolProvider.set(Optional.empty());\n+        defaultToolProvider = Optional.empty();\n@@ -823,3 +811,1 @@\n-        return Optional.ofNullable(withToolProvider).orElseGet(() -> {\n-            return defaultToolProvider.get().isPresent();\n-        });\n+        return Optional.ofNullable(withToolProvider).orElseGet(defaultToolProvider::isPresent);\n@@ -841,1 +827,1 @@\n-            exec.setToolProvider(defaultToolProvider.get().orElseGet(JavaTool.JPACKAGE::asToolProvider));\n+            exec.setToolProvider(defaultToolProvider.orElseGet(JavaTool.JPACKAGE::asToolProvider));\n@@ -949,1 +935,1 @@\n-        runStandardAsserts();\n+        assertAppLayout();\n@@ -992,4 +978,4 @@\n-                final var snapshotGroup = snapshots.get(a);\n-                final var newSnapshotGroup = newSnapshots.get(a);\n-                for (int i = 0; i < snapshotGroup.size(); i++) {\n-                    snapshotGroup.get(i).assertEquals(newSnapshotGroup.get(i),\n+                final var snapshopGroup = snapshots.get(a);\n+                final var newSnapshopGroup = newSnapshots.get(a);\n+                for (int i = 0; i < snapshopGroup.size(); i++) {\n+                    TKit.PathSnapshot.assertEquals(snapshopGroup.get(i), newSnapshopGroup.get(i),\n@@ -1110,1 +1096,1 @@\n-    public static enum StandardAssert {\n+    public static enum AppLayoutAssert {\n@@ -1130,5 +1116,0 @@\n-        MAIN_LAUNCHER_DESCRIPTION(cmd -> {\n-            if (!cmd.isRuntime()) {\n-                new LauncherVerifier(cmd).verify(cmd, LauncherVerifier.Action.VERIFY_DESCRIPTION);\n-            }\n-        }),\n@@ -1152,5 +1133,0 @@\n-        MAC_BUNDLE_UNSIGNED_SIGNATURE(cmd -> {\n-            if (TKit.isOSX() && !MacHelper.appImageSigned(cmd)) {\n-                MacHelper.verifyUnsignedBundleSignature(cmd);\n-            }\n-        }),\n@@ -1159,1 +1135,1 @@\n-        StandardAssert(Consumer<JPackageCommand> action) {\n+        AppLayoutAssert(Consumer<JPackageCommand> action) {\n@@ -1177,1 +1153,1 @@\n-    public JPackageCommand setStandardAsserts(StandardAssert ... asserts) {\n+    public JPackageCommand setAppLayoutAsserts(AppLayoutAssert ... asserts) {\n@@ -1179,1 +1155,1 @@\n-        standardAsserts = Set.of(asserts);\n+        appLayoutAsserts = Set.of(asserts);\n@@ -1183,1 +1159,1 @@\n-    public JPackageCommand excludeStandardAsserts(StandardAssert... asserts) {\n+    public JPackageCommand excludeAppLayoutAsserts(AppLayoutAssert... asserts) {\n@@ -1185,2 +1161,2 @@\n-        return setStandardAsserts(standardAsserts.stream().filter(Predicate.not(\n-                asSet::contains)).toArray(StandardAssert[]::new));\n+        return setAppLayoutAsserts(appLayoutAsserts.stream().filter(Predicate.not(\n+                asSet::contains)).toArray(AppLayoutAssert[]::new));\n@@ -1189,3 +1165,3 @@\n-    JPackageCommand runStandardAsserts() {\n-        for (var standardAssert : standardAsserts.stream().sorted().toList()) {\n-            standardAssert.action.accept(this);\n+    JPackageCommand assertAppLayout() {\n+        for (var appLayoutAssert : appLayoutAsserts.stream().sorted().toList()) {\n+            appLayoutAssert.action.accept(this);\n@@ -1283,1 +1259,4 @@\n-            if (expectedPath.isAbsolute() || !expectedPath.getFileName().equals(filename.getFileName())) {\n+            if (expectedPath.isAbsolute()) {\n+                throw new IllegalArgumentException();\n+            }\n+            if (!expectedPath.getFileName().equals(filename.getFileName())) {\n@@ -1369,1 +1348,1 @@\n-        if (!hasArgument(\"--verbose\") && TKit.verboseJPackage() && !ignoreDefaultVerbose) {\n+        if (!hasArgument(\"--verbose\") && TKit.VERBOSE_JPACKAGE && !ignoreDefaultVerbose) {\n@@ -1393,1 +1372,5 @@\n-                if ((TKit.isLinux() && typesSet.equals(PackageType.LINUX)) || (TKit.isWindows() && typesSet.equals(PackageType.WINDOWS))) {\n+                if (TKit.isLinux() && typesSet.equals(PackageType.LINUX)) {\n+                    return;\n+                }\n+\n+                if (TKit.isWindows() && typesSet.equals(PackageType.WINDOWS)) {\n@@ -1541,1 +1524,1 @@\n-    private Set<StandardAssert> standardAsserts = Set.of(StandardAssert.values());\n+    private Set<AppLayoutAssert> appLayoutAsserts = Set.of(AppLayoutAssert.values());\n@@ -1543,8 +1526,1 @@\n-    private static InheritableThreadLocal<Optional<ToolProvider>> defaultToolProvider = new InheritableThreadLocal<>() {\n-        @Override\n-        protected Optional<ToolProvider> initialValue() {\n-            return Optional.empty();\n-        }\n-    };\n-\n-    private static final Map<String, PackageType> PACKAGE_TYPES = Stream.of(PackageType.values()).collect(toMap(PackageType::getType, x -> x));\n+    private static Optional<ToolProvider> defaultToolProvider = Optional.empty();\n@@ -1552,6 +1528,21 @@\n-    \/\/ Set the property to the path of run-time image to speed up\n-    \/\/ building app images and platform bundles by avoiding running jlink.\n-    \/\/ The value of the property will be automatically appended to\n-    \/\/ jpackage command line if the command line doesn't have\n-    \/\/ `--runtime-image` parameter set.\n-    public static final Path DEFAULT_RUNTIME_IMAGE = Optional.ofNullable(TKit.getConfigProperty(\"runtime-image\")).map(Path::of).orElse(null);\n+    private static final Map<String, PackageType> PACKAGE_TYPES = Functional.identity(\n+            () -> {\n+                Map<String, PackageType> reply = new HashMap<>();\n+                for (PackageType type : PackageType.values()) {\n+                    reply.put(type.getType(), type);\n+                }\n+                return reply;\n+            }).get();\n+\n+    public static final Path DEFAULT_RUNTIME_IMAGE = Functional.identity(() -> {\n+        \/\/ Set the property to the path of run-time image to speed up\n+        \/\/ building app images and platform bundles by avoiding running jlink\n+        \/\/ The value of the property will be automativcally appended to\n+        \/\/ jpackage command line if the command line doesn't have\n+        \/\/ `--runtime-image` parameter set.\n+        String val = TKit.getConfigProperty(\"runtime-image\");\n+        if (val != null) {\n+            return Path.of(val);\n+        }\n+        return null;\n+    }).get();\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":55,"deletions":64,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.util.Optional;\n@@ -52,5 +51,0 @@\n-    public JarBuilder setRelease(int v) {\n-        release = v;\n-        return this;\n-    }\n-\n@@ -70,1 +64,1 @@\n-                var exec = new Executor()\n+                new Executor()\n@@ -72,7 +66,3 @@\n-                        .addArguments(\"-d\", workDir.toString());\n-\n-                Optional.ofNullable(release).ifPresent(r -> {\n-                    exec.addArguments(\"--release\", r.toString());\n-                });\n-\n-                exec.addPathArguments(sourceFiles).execute();\n+                        .addArguments(\"-d\", workDir.toString())\n+                        .addPathArguments(sourceFiles)\n+                        .execute();\n@@ -105,1 +95,0 @@\n-    private Integer release;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JarBuilder.java","additions":5,"deletions":16,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.nio.file.Files;\n@@ -28,1 +29,0 @@\n-import java.util.Optional;\n@@ -41,1 +41,0 @@\n-        expectedDefault = false;\n@@ -46,1 +45,0 @@\n-        expectedIcon = null;\n@@ -51,4 +49,0 @@\n-    public LauncherIconVerifier setExpectedNoIcon() {\n-        return setExpectedIcon(null);\n-    }\n-\n@@ -60,8 +54,0 @@\n-    public boolean expectDefaultIcon() {\n-        return expectedDefault;\n-    }\n-\n-    public Optional<Path> expectIcon() {\n-        return Optional.ofNullable(expectedIcon);\n-    }\n-\n@@ -88,1 +74,1 @@\n-            TKit.assertFileExists(iconPath);\n+            TKit.assertPathExists(iconPath, true);\n@@ -94,1 +80,1 @@\n-                TKit.assertSameFileContent(expectedIcon, iconPath,\n+                TKit.assertTrue(-1 == Files.mismatch(expectedIcon, iconPath),\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherIconVerifier.java","additions":3,"deletions":17,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -342,11 +342,0 @@\n-        var customFile = Optional.ofNullable(cmd.getArgumentValue(\"--mac-entitlements\")).map(Path::of);\n-        if (customFile.isEmpty()) {\n-            \/\/ Try from the resource dir.\n-            var resourceDirFile = Optional.ofNullable(cmd.getArgumentValue(\"--resource-dir\")).map(Path::of).map(resourceDir -> {\n-                return resourceDir.resolve(cmd.name() + \".entitlements\");\n-            }).filter(Files::exists);\n-            if (resourceDirFile.isPresent()) {\n-                customFile = resourceDirFile;\n-            }\n-        }\n-\n@@ -354,2 +343,2 @@\n-        if (customFile.isPresent()) {\n-            expected = new PListReader(Files.readAllBytes(customFile.orElseThrow())).toMap(true);\n+        if (cmd.hasArgument(\"--mac-entitlements\")) {\n+            expected = new PListReader(Files.readAllBytes(Path.of(cmd.getArgumentValue(\"--mac-entitlements\")))).toMap(true);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherVerifier.java","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -25,6 +25,0 @@\n-import static jdk.jpackage.test.AdditionalLauncher.getAdditionalLauncherProperties;\n-import static java.util.Collections.unmodifiableSortedSet;\n-import static java.util.stream.Collectors.joining;\n-import static java.util.stream.Collectors.toMap;\n-import static java.util.stream.Collectors.toSet;\n-\n@@ -41,0 +35,1 @@\n+import java.util.HashSet;\n@@ -46,2 +41,0 @@\n-import java.util.TreeMap;\n-import java.util.TreeSet;\n@@ -52,0 +45,1 @@\n+import java.util.stream.Collectors;\n@@ -170,1 +164,2 @@\n-                        \"Depends\").split(\",\")).map(String::strip).toList();\n+                        \"Depends\").split(\",\")).map(String::strip).collect(\n+                        Collectors.toList());\n@@ -331,1 +326,1 @@\n-                    runtimeDir::resolve).collect(toSet());\n+                    runtimeDir::resolve).collect(Collectors.toSet());\n@@ -333,1 +328,2 @@\n-                    expectedCriticalRuntimePaths::contains).collect(toSet());\n+                    expectedCriticalRuntimePaths::contains).collect(\n+                            Collectors.toSet());\n@@ -379,1 +375,2 @@\n-                Set<String> words = Stream.of(line.split(\"\\\\s+\")).collect(toSet());\n+                Set<String> words = Stream.of(line.split(\"\\\\s+\")).collect(\n+                        Collectors.toSet());\n@@ -395,1 +392,2 @@\n-                var requiredScriptlets = Stream.of(Scriptlet.values()).sorted().toList();\n+                Set<Scriptlet> requiredScriptlets = Stream.of(Scriptlet.values()).sorted().collect(\n+                        Collectors.toSet());\n@@ -457,1 +455,0 @@\n-\n@@ -459,16 +456,0 @@\n-\n-        return relativePackageFilesInSubdirectory(cmd, ApplicationLayout::desktopIntegrationDirectory)\n-                .filter(path -> {\n-                    return path.getNameCount() == 1;\n-                })\n-                .filter(path -> {\n-                    return \".desktop\".equals(PathUtils.getSuffix(path));\n-                })\n-                .map(unpackedDir::resolve)\n-                .toList();\n-    }\n-\n-    private static Stream<Path> relativePackageFilesInSubdirectory(\n-            JPackageCommand cmd, Function<ApplicationLayout, Path> subdirFunc) {\n-\n-        var unpackedDir = subdirFunc.apply(cmd.appLayout());\n@@ -476,1 +457,0 @@\n-\n@@ -478,2 +458,2 @@\n-            return path.startsWith(packageDir);\n-        }).map(packageDir::relativize);\n+            return packageDir.equals(path.getParent()) && path.getFileName().toString().endsWith(\".desktop\");\n+        }).map(Path::getFileName).map(unpackedDir::resolve).toList();\n@@ -511,1 +491,1 @@\n-        final Set<String> mandatoryKeys = new TreeSet<>(Set.of(\"Name\", \"Comment\",\n+        final Set<String> mandatoryKeys = new HashSet<>(Set.of(\"Name\", \"Comment\",\n@@ -517,14 +497,1 @@\n-        final String launcherDescription;\n-        if (cmd.name().equals(launcherName) || predefinedAppImage.isPresent()) {\n-            launcherDescription = Optional.ofNullable(cmd.getArgumentValue(\"--description\")).orElseGet(cmd::name);\n-        } else {\n-            launcherDescription = getAdditionalLauncherProperties(cmd, launcherName).findProperty(\"description\").or(() -> {\n-                return Optional.ofNullable(cmd.getArgumentValue(\"--description\"));\n-            }).orElseGet(cmd::name);\n-        }\n-\n-        for (var e : List.of(\n-                Map.entry(\"Type\", \"Application\"),\n-                Map.entry(\"Terminal\", \"false\"),\n-                Map.entry(\"Comment\", launcherDescription)\n-        )) {\n+        for (var e : Map.of(\"Type\", \"Application\", \"Terminal\", \"false\").entrySet()) {\n@@ -746,1 +713,1 @@\n-        Map<Scriptlet, List<String>> result = new TreeMap<>();\n+        Map<Scriptlet, List<String>> result = new HashMap<>();\n@@ -768,1 +735,1 @@\n-        Map<Scriptlet, List<String>> result = new TreeMap<>();\n+        Map<Scriptlet, List<String>> result = new HashMap<>();\n@@ -802,1 +769,1 @@\n-                        v -> v.rpm).collect(joining(\"|\"))));\n+                        v -> v.rpm).collect(Collectors.joining(\"|\"))));\n@@ -805,1 +772,1 @@\n-                toMap(v -> v.rpm, v -> v));\n+                Collectors.toMap(v -> v.rpm, v -> v));\n@@ -882,1 +849,1 @@\n-                }).collect(toMap(Map.Entry::getKey, Map.Entry::getValue));\n+                }).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n@@ -923,2 +890,1 @@\n-    private static final Set<Integer> XDG_CMD_VALID_ICON_SIZES = unmodifiableSortedSet(\n-            new TreeSet<>(List.of(16, 22, 32, 48, 64, 128)));\n+    private static final Set<Integer> XDG_CMD_VALID_ICON_SIZES = Set.of(16, 22, 32, 48, 64, 128);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LinuxHelper.java","additions":21,"deletions":55,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-import java.util.function.BiConsumer;\n@@ -57,1 +56,0 @@\n-import java.util.function.Consumer;\n@@ -71,1 +69,0 @@\n-import jdk.jpackage.test.MacSign.CertificateRequest;\n@@ -235,10 +232,0 @@\n-    \/**\n-     * Returns {@code true} if the given jpackage command line is configured to sign\n-     * predefined app image in place.\n-     * <p>\n-     * jpackage will not create a new app image or a native bundle.\n-     *\n-     * @param cmd the jpackage command to examine\n-     * @return {@code true} if the given jpackage command line is configured to sign\n-     *         predefined app image in place and {@code false} otherwise.\n-     *\/\n@@ -250,1 +237,1 @@\n-        return cmd.hasArgument(\"--mac-sign\") && cmd.hasArgument(\"--app-image\") && cmd.isImagePackageType();\n+        return cmd.hasArgument(\"--mac-sign\") && cmd.hasArgument(\"--app-image\");\n@@ -253,12 +240,0 @@\n-    \/**\n-     * Returns {@code true} if the given jpackage command line is configured such\n-     * that the app image it will produce will be signed.\n-     * <p>\n-     * If the jpackage command line is bundling a native package, the function\n-     * returns {@code true} if the bundled app image will be signed.\n-     *\n-     * @param cmd the jpackage command to examine\n-     * @return {@code true} if the given jpackage command line is configured such\n-     *         that the app image it will produce will be signed and {@code false}\n-     *         otherwise.\n-     *\/\n@@ -271,7 +246,1 @@\n-        var runtimeImage = Optional.ofNullable(cmd.getArgumentValue(\"--runtime-image\")).map(Path::of);\n-        var appImage = Optional.ofNullable(cmd.getArgumentValue(\"--app-image\")).map(Path::of);\n-\n-        if (cmd.isRuntime() && Files.isDirectory(runtimeImage.orElseThrow().resolve(\"Contents\/_CodeSignature\"))) {\n-            \/\/ If the predefined runtime is a signed bundle, bundled image should be signed too.\n-            return true;\n-        } else if (appImage.map(AppImageFile::load).map(AppImageFile::macSigned).orElse(false)) {\n+        if (Optional.ofNullable(cmd.getArgumentValue(\"--app-image\")).map(Path::of).map(AppImageFile::load).map(AppImageFile::macSigned).orElse(false)) {\n@@ -282,8 +251,0 @@\n-        if (!cmd.isImagePackageType() && appImage.isPresent()) {\n-            \/\/ Building a \".pkg\" or a \".dmg\" bundle from the predefined app image.\n-            \/\/ The predefined app image is unsigned, so the app image bundled\n-            \/\/ in the output native package will be unsigned too\n-            \/\/ (even if the \".pkg\" file may be signed itself, and we never sign \".dmg\" files).\n-            return false;\n-        }\n-\n@@ -374,104 +335,0 @@\n-    public static Consumer<JPackageCommand> useKeychain(MacSign.ResolvedKeychain keychain) {\n-        return useKeychain(keychain.spec().keychain());\n-    }\n-\n-    public static Consumer<JPackageCommand> useKeychain(MacSign.Keychain keychain) {\n-        return cmd -> {\n-            useKeychain(cmd, keychain);\n-        };\n-    }\n-\n-    public static JPackageCommand useKeychain(JPackageCommand cmd, MacSign.ResolvedKeychain keychain) {\n-        return useKeychain(cmd, keychain.spec().keychain());\n-    }\n-\n-    public static JPackageCommand useKeychain(JPackageCommand cmd, MacSign.Keychain keychain) {\n-        return sign(cmd).addArguments(\"--mac-signing-keychain\", keychain.name());\n-    }\n-\n-    public static JPackageCommand sign(JPackageCommand cmd) {\n-        if (!cmd.hasArgument(\"--mac-sign\")) {\n-            cmd.addArgument(\"--mac-sign\");\n-        }\n-        return cmd;\n-    }\n-\n-    public record SignKeyOption(Type type, CertificateRequest certRequest) {\n-\n-        public SignKeyOption {\n-            Objects.requireNonNull(type);\n-            Objects.requireNonNull(certRequest);\n-        }\n-\n-        public enum Type {\n-            SIGN_KEY_USER_NAME,\n-            SIGN_KEY_IDENTITY,\n-            ;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            var sb = new StringBuffer();\n-            applyTo((optionName, _) -> {\n-                sb.append(String.format(\"{%s: %s}\", optionName, certRequest));\n-            });\n-            return sb.toString();\n-        }\n-\n-        public JPackageCommand addTo(JPackageCommand cmd) {\n-            applyTo(cmd::addArguments);\n-            return sign(cmd);\n-        }\n-\n-        public JPackageCommand setTo(JPackageCommand cmd) {\n-            applyTo(cmd::setArgumentValue);\n-            return sign(cmd);\n-        }\n-\n-        private void applyTo(BiConsumer<String, String> sink) {\n-            switch (certRequest.type()) {\n-                case INSTALLER -> {\n-                    switch (type) {\n-                        case SIGN_KEY_IDENTITY -> {\n-                            sink.accept(\"--mac-installer-sign-identity\", certRequest.name());\n-                            return;\n-                        }\n-                        case SIGN_KEY_USER_NAME -> {\n-                            sink.accept(\"--mac-signing-key-user-name\", certRequest.shortName());\n-                            return;\n-                        }\n-                    }\n-                }\n-                case CODE_SIGN -> {\n-                    switch (type) {\n-                        case SIGN_KEY_IDENTITY -> {\n-                            sink.accept(\"--mac-app-image-sign-identity\", certRequest.name());\n-                            return;\n-                        }\n-                        case SIGN_KEY_USER_NAME -> {\n-                            sink.accept(\"--mac-signing-key-user-name\", certRequest.shortName());\n-                            return;\n-                        }\n-                    }\n-                }\n-            }\n-\n-            throw new AssertionError();\n-        }\n-    }\n-\n-    static void verifyUnsignedBundleSignature(JPackageCommand cmd) {\n-        if (!cmd.isImagePackageType()) {\n-            MacSignVerify.assertUnsigned(cmd.outputBundle());\n-        }\n-\n-        final Path bundleRoot;\n-        if (cmd.isImagePackageType()) {\n-            bundleRoot = cmd.outputBundle();\n-        } else {\n-            bundleRoot = cmd.pathToUnpackedPackageFile(cmd.appInstallationDirectory());\n-        }\n-\n-        MacSignVerify.assertAdhocSigned(bundleRoot);\n-    }\n-\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacHelper.java","additions":2,"deletions":145,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-import java.util.function.Consumer;\n@@ -355,46 +354,0 @@\n-        public static final class UsageBuilder {\n-\n-            UsageBuilder(Collection<Keychain> keychains) {\n-                this.keychains = List.copyOf(keychains);\n-            }\n-\n-            public void run(Runnable runnable) {\n-                Objects.requireNonNull(runnable);\n-\n-                final Optional<List<Path>> oldKeychains;\n-                if (addToSearchList) {\n-                    oldKeychains = Optional.ofNullable(activeKeychainFiles());\n-                    Keychain.addToSearchList(keychains);\n-                } else {\n-                    oldKeychains = Optional.empty();\n-                }\n-\n-                try {\n-                    \/\/ Ensure keychains to be used for signing are unlocked.\n-                    \/\/ When the codesign command operates on a locked keychain in a ssh session\n-                    \/\/ it emits cryptic \"errSecInternalComponent\" error without other details.\n-                    keychains.forEach(Keychain::unlock);\n-                    runnable.run();\n-                } finally {\n-                    oldKeychains.ifPresent(restoreKeychains -> {\n-                        security(\"list-keychains\", \"-d\", \"user\", \"-s\")\n-                                .addArguments(restoreKeychains.stream().map(Path::toString).toList())\n-                                .execute();\n-                    });\n-                }\n-            }\n-\n-            public UsageBuilder addToSearchList(boolean v) {\n-                addToSearchList = v;\n-                return this;\n-            }\n-\n-            public UsageBuilder addToSearchList() {\n-                return addToSearchList(true);\n-            }\n-\n-            private final Collection<Keychain> keychains;\n-            private boolean addToSearchList;\n-        }\n-\n-\n@@ -465,1 +418,1 @@\n-        static void addToSearchList(Collection<Keychain> keychains) {\n+        public static void addToSearchList(Collection<Keychain> keychains) {\n@@ -471,0 +424,12 @@\n+        public static void withAddedKeychains(Collection<Keychain> keychains, Runnable runnable) {\n+            final var curKeychains = activeKeychainFiles();\n+            addToSearchList(keychains);\n+            try {\n+                runnable.run();\n+            } finally {\n+                security(\"list-keychains\", \"-d\", \"user\", \"-s\")\n+                        .addArguments(curKeychains.stream().map(Path::toString).toList())\n+                        .execute();\n+            }\n+        }\n+\n@@ -1075,41 +1040,0 @@\n-    public static Keychain.UsageBuilder withKeychains(KeychainWithCertsSpec... keychains) {\n-        return withKeychains(Stream.of(keychains).map(KeychainWithCertsSpec::keychain).toArray(Keychain[]::new));\n-    }\n-\n-    public static Keychain.UsageBuilder withKeychains(Keychain... keychains) {\n-        return new Keychain.UsageBuilder(List.of(keychains));\n-    }\n-\n-    public static void withKeychains(Runnable runnable, Consumer<Keychain.UsageBuilder> mutator, Keychain... keychains) {\n-        Objects.requireNonNull(runnable);\n-        var builder = withKeychains(keychains);\n-        mutator.accept(builder);\n-        builder.run(runnable);\n-    }\n-\n-    public static void withKeychains(Runnable runnable, Keychain... keychains) {\n-        withKeychains(runnable, _ -> {}, keychains);\n-    }\n-\n-    public static void withKeychain(Consumer<Keychain> consumer, Consumer<Keychain.UsageBuilder> mutator, Keychain keychain) {\n-        Objects.requireNonNull(consumer);\n-        withKeychains(() -> {\n-            consumer.accept(keychain);\n-        }, mutator, keychain);\n-    }\n-\n-    public static void withKeychain(Consumer<Keychain> consumer, Keychain keychain) {\n-        withKeychain(consumer, _ -> {}, keychain);\n-    }\n-\n-    public static void withKeychain(Consumer<ResolvedKeychain> consumer, Consumer<Keychain.UsageBuilder> mutator, ResolvedKeychain keychain) {\n-        Objects.requireNonNull(consumer);\n-        withKeychains(() -> {\n-            consumer.accept(keychain);\n-        }, mutator, keychain.spec().keychain());\n-    }\n-\n-    public static void withKeychain(Consumer<ResolvedKeychain> consumer, ResolvedKeychain keychain) {\n-        withKeychain(consumer, _ -> {}, keychain);\n-    }\n-\n@@ -1125,4 +1049,0 @@\n-        public String name() {\n-            return spec.keychain().name();\n-        }\n-\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacSign.java","additions":13,"deletions":93,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -47,37 +47,0 @@\n-    public static void verifyAppImageSigned(\n-            JPackageCommand cmd, CertificateRequest certRequest, MacSign.ResolvedKeychain keychain) {\n-\n-        cmd.verifyIsOfType(PackageType.MAC);\n-        Objects.requireNonNull(certRequest);\n-        Objects.requireNonNull(keychain);\n-\n-        final Path bundleRoot;\n-        if (cmd.isImagePackageType()) {\n-            bundleRoot = cmd.outputBundle();\n-        } else {\n-            bundleRoot = cmd.pathToUnpackedPackageFile(\n-                    cmd.appInstallationDirectory());\n-        }\n-\n-        assertSigned(bundleRoot, certRequest);\n-\n-        if (!cmd.isRuntime()) {\n-            cmd.addLauncherNames().stream().map(cmd::appLauncherPath).forEach(launcherPath -> {\n-                assertSigned(launcherPath, certRequest);\n-            });\n-        }\n-\n-        \/\/ Set to \"null\" if the sign origin is not found, instead of bailing out with an exception.\n-        \/\/ Let is fail in the following TKit.assertEquals() call with a proper log message.\n-        var signOrigin = findSpctlSignOrigin(SpctlType.EXEC, bundleRoot).orElse(null);\n-\n-        TKit.assertEquals(certRequest.name(), signOrigin,\n-                String.format(\"Check [%s] has sign origin as expected\", bundleRoot));\n-    }\n-\n-    public static void verifyPkgSigned(JPackageCommand cmd, CertificateRequest certRequest, MacSign.ResolvedKeychain keychain) {\n-        cmd.verifyIsOfType(PackageType.MAC_PKG);\n-        assertPkgSigned(cmd.outputBundle(), certRequest,\n-                Objects.requireNonNull(keychain.mapCertificateRequests().get(certRequest)));\n-    }\n-\n@@ -154,2 +117,2 @@\n-        final var exec = Executor.of(\"\/usr\/bin\/codesign\", \"--display\", \"--verbose=4\", path.toString());\n-        final var result = exec.saveOutput().executeWithoutExitCodeCheck();\n+        final var exec = Executor.of(\"\/usr\/bin\/codesign\", \"--display\", \"--verbose=4\", path.toString()).saveOutput();\n+        final var result = exec.executeWithoutExitCodeCheck();\n@@ -184,28 +147,6 @@\n-        assertSigned(path, false);\n-    }\n-\n-    private static void assertSigned(Path path, boolean sudo) {\n-        final Executor exec;\n-        if (sudo) {\n-            exec = Executor.of(\"sudo\", \"\/usr\/bin\/codesign\");\n-        } else {\n-            exec = Executor.of(\"\/usr\/bin\/codesign\");\n-        }\n-        exec.addArguments(\"--verify\", \"--deep\", \"--strict\", \"--verbose=2\", path.toString());\n-        final var result = exec.saveOutput().executeWithoutExitCodeCheck();\n-        if (result.getExitCode() == 0) {\n-            TKit.TextStreamVerifier.group()\n-                    .add(TKit.assertTextStream(\": valid on disk\").predicate(String::endsWith))\n-                    .add(TKit.assertTextStream(\": satisfies its Designated Requirement\").predicate(String::endsWith))\n-                    .create().accept(result.getOutput().iterator());\n-        } else if (!sudo && result.getOutput().stream().findFirst().filter(str -> {\n-            \/\/ By some reason \/usr\/bin\/codesign command fails for some installed bundles.\n-            \/\/ It is known to fail for some AppContentTest test cases and all FileAssociationsTest test cases.\n-            \/\/ Rerunning the command with \"sudo\" works, though.\n-            return str.equals(String.format(\"%s: Permission denied\", path));\n-        }).isPresent()) {\n-                TKit.trace(\"Try \/usr\/bin\/codesign again with `sudo`\");\n-                assertSigned(path, true);\n-        } else {\n-            reportUnexpectedCommandOutcome(exec.getPrintableCommandLine(), result);\n-        }\n+        final var verifier = TKit.TextStreamVerifier.group()\n+                .add(TKit.assertTextStream(\": valid on disk\").predicate(String::endsWith))\n+                .add(TKit.assertTextStream(\": satisfies its Designated Requirement\").predicate(String::endsWith))\n+                .create();\n+        verifier.accept(Executor.of(\"\/usr\/bin\/codesign\", \"--verify\", \"--deep\",\n+                \"--strict\", \"--verbose=2\", path.toString()).executeAndGetOutput().iterator());\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacSignVerify.java","additions":8,"deletions":67,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    public static void main(String... args) throws Throwable {\n+    public static void main(String args[]) throws Throwable {\n@@ -48,1 +48,1 @@\n-    public static void main(TestBuilder.Builder builder, String... args) throws Throwable {\n+    public static void main(TestBuilder.Builder builder, String args[]) throws Throwable {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/Main.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,780 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.test;\n-\n-import static java.util.stream.Collectors.groupingBy;\n-import static java.util.stream.Collectors.toSet;\n-import static jdk.jpackage.internal.util.function.ExceptionBox.rethrowUnchecked;\n-import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n-import static jdk.jpackage.internal.util.function.ThrowingRunnable.toRunnable;\n-import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n-\n-import java.lang.reflect.Array;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.math.BigInteger;\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Comparator;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.UUID;\n-import java.util.function.BiConsumer;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-import java.util.function.IntPredicate;\n-import java.util.function.Predicate;\n-import java.util.function.Supplier;\n-import java.util.stream.Collector;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-import javax.xml.stream.XMLStreamWriter;\n-import jdk.jpackage.internal.util.IdentityWrapper;\n-\n-public final class ObjectMapper {\n-\n-    private ObjectMapper(\n-            Predicate<String> classFilter,\n-            Predicate<List<String>> methodFilter,\n-            Predicate<String> leafClassFilter,\n-            Map<Method, Function<?, Object>> substitutes,\n-            Map<Class<?>, BiConsumer<Object, Map<String, Object>>> mutators,\n-            Set<String> accessPackageMethods) {\n-\n-        this.classFilter = Objects.requireNonNull(classFilter);\n-        this.methodFilter = Objects.requireNonNull(methodFilter);\n-        this.leafClassFilter = Objects.requireNonNull(leafClassFilter);\n-        this.substitutes = Objects.requireNonNull(substitutes);\n-        this.mutators = Objects.requireNonNull(mutators);\n-        this.accessPackageMethods = accessPackageMethods;\n-    }\n-\n-    public static Builder blank() {\n-        return new Builder().allowAllLeafClasses(false).exceptLeafClasses().add(Stream.of(\n-                Object.class,\n-                String.class, String[].class,\n-                boolean.class, Boolean.class, boolean[].class, Boolean[].class,\n-                byte.class, Byte.class, byte[].class, Byte[].class,\n-                char.class, Character.class, char[].class, Character[].class,\n-                short.class, Short.class, short[].class, Short[].class,\n-                int.class, Integer.class, int[].class, Integer[].class,\n-                long.class, Long.class, long[].class, Long[].class,\n-                float.class, Float.class, float[].class, Float[].class,\n-                double.class, Double.class, double[].class, Double[].class,\n-                void.class, Void.class, Void[].class\n-        ).map(Class::getName).toList()).apply();\n-    }\n-\n-    public static Builder standard() {\n-        return blank()\n-                .mutate(configureObject())\n-                .mutate(configureLeafClasses())\n-                .mutate(configureOptional())\n-                .mutate(configureFunctionalTypes())\n-                .mutate(configureEnum())\n-                .mutate(configureException());\n-    }\n-\n-    public static Consumer<Builder> configureObject() {\n-        \/\/ Exclude all method of Object class.\n-        return builder -> {\n-            builder.exceptMethods().add(OBJECT_METHODS).apply();\n-        };\n-    }\n-\n-    public static Consumer<Builder> configureLeafClasses() {\n-        return builder -> {\n-            builder.exceptLeafClasses().add(Stream.of(\n-                    IdentityWrapper.class,\n-                    Class.class,\n-                    Path.class,\n-                    Path.of(\"\").getClass(),\n-                    UUID.class,\n-                    BigInteger.class\n-            ).map(Class::getName).toList()).apply();\n-        };\n-    }\n-\n-    public static Consumer<Builder> configureOptional() {\n-        return builder -> {\n-            \/\/ Filter out all but \"get()\" methods of \"Optional\" class.\n-            builder.exceptAllMethods(Optional.class).remove(\"get\").apply();\n-            \/\/ Substitute \"Optional.get()\" with the function that will return \"null\" if the value is \"null\".\n-            builder.subst(Optional.class, \"get\", opt -> {\n-                if (opt.isPresent()) {\n-                    return opt.get();\n-                } else {\n-                    return null;\n-                }\n-            });\n-        };\n-    }\n-\n-    public static Consumer<Builder> configureFunctionalTypes() {\n-        \/\/ Remove all getters from the standard functional types.\n-        return builder -> {\n-            builder.exceptAllMethods(Predicate.class).apply();\n-            builder.exceptAllMethods(Supplier.class).apply();\n-        };\n-    }\n-\n-    public static Consumer<Builder> configureEnum() {\n-        return builder -> {\n-            \/\/ Filter out \"getDeclaringClass()\" and \"describeConstable()\" methods of \"Enum\" class.\n-            builder.exceptSomeMethods(Enum.class).add(\"getDeclaringClass\", \"describeConstable\").apply();\n-        };\n-    }\n-\n-    public static Consumer<Builder> configureException() {\n-        return builder -> {\n-            \/\/ Include only \"getMessage()\" and \"getCause()\" methods of \"Exception\" class.\n-            builder.exceptAllMethods(Exception.class).remove(\"getMessage\", \"getCause\").apply();\n-            builder.mutator(Exception.class, (ex, map) -> {\n-                var eit = map.entrySet().iterator();\n-                while (eit.hasNext()) {\n-                    var e = eit.next();\n-                    if (e.getValue() == NULL) {\n-                        \/\/ Remove property with the \"null\" value.\n-                        eit.remove();\n-                    }\n-                }\n-                map.put(\"getClass\", ex.getClass().getName());\n-            });\n-        };\n-    }\n-\n-    public static String lookupFullMethodName(Method m) {\n-        return lookupFullMethodName(m.getDeclaringClass(), m.getName());\n-    }\n-\n-    public static String lookupFullMethodName(Class<?> c, String m) {\n-        return Objects.requireNonNull(c).getName() + lookupMethodName(m);\n-    }\n-\n-    public static String lookupMethodName(Method m) {\n-        return lookupMethodName(m.getName());\n-    }\n-\n-    public static String lookupMethodName(String m) {\n-        return \"#\" + Objects.requireNonNull(m);\n-    }\n-\n-    public static Object wrapIdentity(Object v) {\n-        if (v instanceof IdentityWrapper<?> wrapper) {\n-            return wrapper;\n-        } else {\n-            return new IdentityWrapper<Object>(v);\n-        }\n-    }\n-\n-    public static void store(Map<String, Object> map, XMLStreamWriter xml) {\n-        XmlWriter.writePropertyMap(map, xml);\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public static <T> Optional<T> findNonNullProperty(Map<String, Object> map, String propertyName) {\n-        Objects.requireNonNull(propertyName);\n-        Objects.requireNonNull(map);\n-\n-        return Optional.ofNullable(map.get(propertyName)).filter(Predicate.not(NULL::equals)).map(v -> {\n-            return (T)v;\n-        });\n-    }\n-\n-    public Object map(Object obj) {\n-        if (obj != null) {\n-            return mapObject(obj).orElseGet(Map::of);\n-        } else {\n-            return null;\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public Map<String, Object> toMap(Object obj) {\n-        if (obj == null) {\n-            return null;\n-        } else {\n-            var mappedObj = map(obj);\n-            if (mappedObj instanceof Map<?, ?> m) {\n-                return (Map<String, Object>)m;\n-            } else {\n-                return Map.of(\"value\", mappedObj);\n-            }\n-        }\n-    }\n-\n-    public Optional<Object> mapObject(Object obj) {\n-        if (obj == null) {\n-            return Optional.empty();\n-        }\n-\n-        if (leafClassFilter.test(obj.getClass().getName())) {\n-            return Optional.of(obj);\n-        }\n-\n-        if (!filter(obj.getClass())) {\n-            return Optional.empty();\n-        }\n-\n-        if (obj instanceof Iterable<?> col) {\n-            return Optional.of(mapIterable(col));\n-        }\n-\n-        if (obj instanceof Map<?, ?> map) {\n-            return Optional.of(mapMap(map));\n-        }\n-\n-        if (obj.getClass().isArray()) {\n-            return Optional.of(mapArray(obj));\n-        }\n-\n-        var theMap = getMethods(obj).map(m -> {\n-            final Object propertyValue;\n-            final var subst = substitutes.get(m);\n-            if (subst != null) {\n-                propertyValue = applyGetter(obj, subst);\n-            } else {\n-                propertyValue = invoke(m, obj);\n-            }\n-            return Map.entry(m.getName(), mapObject(propertyValue).orElse(NULL));\n-        }).collect(toMutableMap(Map.Entry::getKey, Map.Entry::getValue));\n-\n-        mutators.entrySet().stream().filter(m -> {\n-            return m.getKey().isInstance(obj);\n-        }).findFirst().ifPresent(m -> {\n-            m.getValue().accept(obj, theMap);\n-        });\n-\n-        if (theMap.isEmpty()) {\n-            return Optional.of(wrapIdentity(obj));\n-        }\n-\n-        return Optional.of(theMap);\n-    }\n-\n-    private Object invoke(Method m, Object obj) {\n-        try {\n-            return m.invoke(obj);\n-        } catch (IllegalAccessException ex) {\n-            throw rethrowUnchecked(ex);\n-        } catch (InvocationTargetException ex) {\n-            return map(ex.getTargetException());\n-        }\n-    }\n-\n-    private Collection<Object> mapIterable(Iterable<?> col) {\n-        final List<Object> list = new ArrayList<>();\n-        for (var obj : col) {\n-            list.add(mapObject(obj).orElse(NULL));\n-        }\n-        return list;\n-    }\n-\n-    private Map<Object, Object> mapMap(Map<?, ?> map) {\n-        return map.entrySet().stream().collect(toMutableMap(e -> {\n-            return mapObject(e.getKey()).orElse(NULL);\n-        }, e -> {\n-            return mapObject(e.getValue()).orElse(NULL);\n-        }));\n-    }\n-\n-    private Object mapArray(Object arr) {\n-        final var len = Array.getLength(arr);\n-\n-        if (len == 0) {\n-            return arr;\n-        }\n-\n-        Object[] buf = null;\n-\n-        for (int i = 0; i != len; i++) {\n-            var from = Array.get(arr, i);\n-            if (from != null) {\n-                var to = mapObject(from).orElseThrow();\n-                if (from != to || buf != null) {\n-                    if (buf == null) {\n-                        buf = (Object[])Array.newInstance(Object.class, len);\n-                        System.arraycopy(arr, 0, buf, 0, i);\n-                    }\n-                    buf[i] = to;\n-                }\n-            }\n-        }\n-\n-        return Optional.ofNullable((Object)buf).orElse(arr);\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static <T> Object applyGetter(Object obj, Function<T, Object> getter) {\n-        return getter.apply((T)obj);\n-    }\n-\n-    private boolean filter(Class<?> type) {\n-        return classFilter.test(type.getName());\n-    }\n-\n-    private boolean filter(Method m) {\n-        return methodFilter.test(List.of(lookupMethodName(m), lookupFullMethodName(m)));\n-    }\n-\n-    private Stream<Method> getMethods(Object obj) {\n-        return MethodGroups.create(obj.getClass(), accessPackageMethods).filter(this::filter).map(MethodGroup::callable);\n-    }\n-\n-    private static boolean defaultFilter(Method m) {\n-        if (Modifier.isStatic(m.getModifiers()) || (m.getParameterCount() > 0) || void.class.equals(m.getReturnType())) {\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    private static <T, K, U>\n-    Collector<T, ?, Map<K,U>> toMutableMap(Function<? super T, ? extends K> keyMapper,\n-            Function<? super T, ? extends U> valueMapper) {\n-        return Collectors.toMap(keyMapper, valueMapper, (x , y) -> {\n-            throw new UnsupportedOperationException(\n-                    String.format(\"Entries with the same key and different values [%s] and [%s]\", x, y));\n-        }, HashMap::new);\n-    }\n-\n-    public static final class Builder {\n-\n-        private Builder() {\n-            allowAllClasses();\n-            allowAllLeafClasses();\n-            allowAllMethods();\n-        }\n-\n-        public ObjectMapper create() {\n-            return new ObjectMapper(\n-                    classFilter.createPredicate(),\n-                    methodFilter.createMultiPredicate(),\n-                    leafClassFilter.createPredicate(),\n-                    Map.copyOf(substitutes),\n-                    Map.copyOf(mutators),\n-                    accessPackageMethods);\n-        }\n-\n-\n-        public final class NamePredicateBuilder {\n-\n-            NamePredicateBuilder(Filter sink) {\n-                this.sink = Objects.requireNonNull(sink);\n-            }\n-\n-            public Builder apply() {\n-                sink.addAll(items);\n-                return Builder.this;\n-            }\n-\n-            public NamePredicateBuilder add(String... v) {\n-                return add(List.of(v));\n-            }\n-\n-            public NamePredicateBuilder add(Collection<String> v) {\n-                items.addAll(v);\n-                return this;\n-            }\n-\n-            private final Filter sink;\n-            private final Set<String> items = new HashSet<>();\n-        }\n-\n-\n-        public final class AllMethodPredicateBuilder {\n-\n-            AllMethodPredicateBuilder(Class<?> type) {\n-                impl = new MethodPredicateBuilder(type, false);\n-            }\n-\n-            public AllMethodPredicateBuilder remove(String... v) {\n-                return remove(List.of(v));\n-            }\n-\n-            public AllMethodPredicateBuilder remove(Collection<String> v) {\n-                impl.add(v);\n-                return this;\n-            }\n-\n-            public Builder apply() {\n-                return impl.apply();\n-            }\n-\n-            private final MethodPredicateBuilder impl;\n-        }\n-\n-\n-        public final class SomeMethodPredicateBuilder {\n-\n-            SomeMethodPredicateBuilder(Class<?> type) {\n-                impl = new MethodPredicateBuilder(type, true);\n-            }\n-\n-            public SomeMethodPredicateBuilder add(String... v) {\n-                return add(List.of(v));\n-            }\n-\n-            public SomeMethodPredicateBuilder add(Collection<String> v) {\n-                impl.add(v);\n-                return this;\n-            }\n-\n-            public Builder apply() {\n-                return impl.apply();\n-            }\n-\n-            private final MethodPredicateBuilder impl;\n-        }\n-\n-\n-        public Builder allowAllClasses(boolean v) {\n-            classFilter.negate(v);\n-            return this;\n-        }\n-\n-        public Builder allowAllClasses() {\n-            return allowAllClasses(true);\n-        }\n-\n-        public Builder allowAllMethods(boolean v) {\n-            methodFilter.negate(v);\n-            return this;\n-        }\n-\n-        public Builder allowAllMethods() {\n-            return allowAllMethods(true);\n-        }\n-\n-        public Builder allowAllLeafClasses(boolean v) {\n-            leafClassFilter.negate(v);\n-            return this;\n-        }\n-\n-        public Builder allowAllLeafClasses() {\n-            return allowAllLeafClasses(true);\n-        }\n-\n-        public NamePredicateBuilder exceptClasses() {\n-            return new NamePredicateBuilder(classFilter);\n-        }\n-\n-        public AllMethodPredicateBuilder exceptAllMethods(Class<?> type) {\n-            return new AllMethodPredicateBuilder(type);\n-        }\n-\n-        public SomeMethodPredicateBuilder exceptSomeMethods(Class<?> type) {\n-            return new SomeMethodPredicateBuilder(type);\n-        }\n-\n-        public NamePredicateBuilder exceptMethods() {\n-            return new NamePredicateBuilder(methodFilter);\n-        }\n-\n-        public NamePredicateBuilder exceptLeafClasses() {\n-            return new NamePredicateBuilder(leafClassFilter);\n-        }\n-\n-        public Builder subst(Method target, Function<?, Object> substitute) {\n-            substitutes.put(Objects.requireNonNull(target), Objects.requireNonNull(substitute));\n-            return this;\n-        }\n-\n-        public <T> Builder subst(Class<? extends T> targetClass, String targetMethodName, Function<T, Object> substitute) {\n-            var method = toSupplier(() -> targetClass.getMethod(targetMethodName)).get();\n-            return subst(method, substitute);\n-        }\n-\n-        public Builder mutator(Class<?> targetClass, BiConsumer<Object, Map<String, Object>> mutator) {\n-            mutators.put(Objects.requireNonNull(targetClass), Objects.requireNonNull(mutator));\n-            return this;\n-        }\n-\n-        public Builder mutate(Consumer<Builder> mutator) {\n-            mutator.accept(this);\n-            return this;\n-        }\n-\n-        public Builder accessPackageMethods(Package... packages) {\n-            Stream.of(packages).map(Package::getName).forEach(accessPackageMethods::add);\n-            return this;\n-        }\n-\n-\n-        private final class MethodPredicateBuilder {\n-\n-            MethodPredicateBuilder(Class<?> type, boolean negate) {\n-                this.type = Objects.requireNonNull(type);\n-                buffer.negate(negate);\n-            }\n-\n-            void add(Collection<String> v) {\n-                buffer.addAll(v);\n-            }\n-\n-            Builder apply() {\n-                var pred = buffer.createPredicate();\n-\n-                var items = MethodGroups.create(type, accessPackageMethods).groups().stream().map(MethodGroup::primary).filter(m -> {\n-                    return !OBJECT_METHODS.contains(ObjectMapper.lookupMethodName(m));\n-                }).filter(m -> {\n-                    return !pred.test(m.getName());\n-                }).map(ObjectMapper::lookupFullMethodName).toList();\n-\n-                return exceptMethods().add(items).apply();\n-            }\n-\n-            private final Class<?> type;\n-            private final Filter buffer = new Filter();\n-        }\n-\n-\n-        private static final class Filter {\n-            Predicate<List<String>> createMultiPredicate() {\n-                if (items.isEmpty()) {\n-                    var match = negate;\n-                    return v -> match;\n-                } else if (negate) {\n-                    return v -> {\n-                        return v.stream().noneMatch(Set.copyOf(items)::contains);\n-                    };\n-                } else {\n-                    return v -> {\n-                        return v.stream().anyMatch(Set.copyOf(items)::contains);\n-                    };\n-                }\n-            }\n-\n-            Predicate<String> createPredicate() {\n-                if (items.isEmpty()) {\n-                    var match = negate;\n-                    return v -> match;\n-                } else if (negate) {\n-                    return Predicate.not(Set.copyOf(items)::contains);\n-                } else {\n-                    return Set.copyOf(items)::contains;\n-                }\n-            }\n-\n-            void addAll(Collection<String> v) {\n-                items.addAll(v);\n-            }\n-\n-            void negate(boolean v) {\n-                negate = v;\n-            }\n-\n-            private boolean negate;\n-            private final Set<String> items = new HashSet<>();\n-        }\n-\n-\n-        private final Filter classFilter = new Filter();\n-        private final Filter methodFilter = new Filter();\n-        private final Filter leafClassFilter = new Filter();\n-        private final Map<Method, Function<?, Object>> substitutes = new HashMap<>();\n-        private final Map<Class<?>, BiConsumer<Object, Map<String, Object>>> mutators = new HashMap<>();\n-        private final Set<String> accessPackageMethods = new HashSet<>();\n-    }\n-\n-\n-    private record MethodGroup(List<Method> methods) {\n-\n-        MethodGroup {\n-            Objects.requireNonNull(methods);\n-\n-            if (methods.isEmpty()) {\n-                throw new IllegalArgumentException();\n-            }\n-\n-            methods.stream().map(Method::getName).reduce((a, b) -> {\n-                if (!a.equals(b)) {\n-                    throw new IllegalArgumentException();\n-                } else {\n-                    return a;\n-                }\n-            });\n-        }\n-\n-        Method callable() {\n-            var primary = primary();\n-            if (!primary.getDeclaringClass().isInterface()) {\n-                primary = methods.stream().filter(m -> {\n-                    return m.getDeclaringClass().isInterface();\n-                }).findFirst().orElse(primary);\n-            }\n-            return primary;\n-        }\n-\n-        Method primary() {\n-            return methods.getFirst();\n-        }\n-\n-        boolean match(Predicate<Method> predicate) {\n-            Objects.requireNonNull(predicate);\n-            return methods.stream().allMatch(predicate);\n-        }\n-    }\n-\n-\n-    private record MethodGroups(Collection<MethodGroup> groups) {\n-\n-        MethodGroups {\n-            Objects.requireNonNull(groups);\n-        }\n-\n-        Stream<MethodGroup> filter(Predicate<Method> predicate) {\n-            Objects.requireNonNull(predicate);\n-\n-            return groups.stream().filter(g -> {\n-                return g.match(predicate);\n-            });\n-        }\n-\n-        static MethodGroups create(Class<?> type, Set<String> accessPackageMethods) {\n-            List<Class<?>> types = new ArrayList<>();\n-\n-            collectSuperclassAndInterfaces(type, types::add);\n-\n-            final var methodGroups = types.stream()\n-                    .map(c -> {\n-                        if (accessPackageMethods.contains(c.getPackageName())) {\n-                            return PUBLIC_AND_PACKAGE_METHODS_GETTER.apply(c);\n-                        } else {\n-                            return PUBLIC_METHODS_GETTER.apply(c);\n-                        }\n-                    })\n-                    .flatMap(x -> x)\n-                    .filter(ObjectMapper::defaultFilter)\n-                    .collect(groupingBy(Method::getName));\n-\n-            return new MethodGroups(methodGroups.values().stream().distinct().map(MethodGroup::new).toList());\n-        }\n-\n-        private static void collectSuperclassAndInterfaces(Class<?> type, Consumer<Class<?>> sink) {\n-            Objects.requireNonNull(type);\n-            Objects.requireNonNull(sink);\n-\n-            for (; type != null; type = type.getSuperclass()) {\n-                sink.accept(type);\n-                for (var i : type.getInterfaces()) {\n-                    collectSuperclassAndInterfaces(i, sink);\n-                }\n-            }\n-        }\n-    }\n-\n-\n-    private static final class XmlWriter {\n-        static void write(Object obj,  XMLStreamWriter xml) {\n-            if (obj instanceof Map<?, ?> map) {\n-                writePropertyMap(map, xml);\n-            } else if (obj instanceof Collection<?> col) {\n-                writeCollection(col, xml);\n-            } else if (obj.getClass().isArray()) {\n-                writeArray(obj, xml);\n-            } else {\n-                toRunnable(() -> xml.writeCharacters(obj.toString())).run();\n-            }\n-        }\n-\n-        private static void writePropertyMap(Map<?, ?> map, XMLStreamWriter xml) {\n-            map.entrySet().stream().sorted(Comparator.comparing(e -> e.getKey().toString())).forEach(toConsumer(e -> {\n-                xml.writeStartElement(\"property\");\n-                xml.writeAttribute(\"name\", e.getKey().toString());\n-                write(e.getValue(), xml);\n-                xml.writeEndElement();\n-            }));\n-        }\n-\n-        private static void writeCollection(Collection<?> col, XMLStreamWriter xml) {\n-            try {\n-                xml.writeStartElement(\"collection\");\n-                xml.writeAttribute(\"size\", Integer.toString(col.size()));\n-                for (var item : col) {\n-                    xml.writeStartElement(\"item\");\n-                    write(item, xml);\n-                    xml.writeEndElement();\n-                }\n-                xml.writeEndElement();\n-            } catch (Exception ex) {\n-                rethrowUnchecked(ex);\n-            }\n-        }\n-\n-        private static void writeArray(Object arr, XMLStreamWriter xml) {\n-            var len = Array.getLength(arr);\n-            try {\n-                xml.writeStartElement(\"array\");\n-                xml.writeAttribute(\"size\", Integer.toString(len));\n-                for (int i = 0; i != len; i++) {\n-                    xml.writeStartElement(\"item\");\n-                    write(Array.get(arr, i), xml);\n-                    xml.writeEndElement();\n-                }\n-                xml.writeEndElement();\n-            } catch (Exception ex) {\n-                rethrowUnchecked(ex);\n-            }\n-        }\n-    }\n-\n-\n-    private final Predicate<String> classFilter;\n-    private final Predicate<List<String>> methodFilter;\n-    private final Predicate<String> leafClassFilter;\n-    private final Map<Method, Function<?, Object>> substitutes;\n-    private final Map<Class<?>, BiConsumer<Object, Map<String, Object>>> mutators;\n-    private final Set<String> accessPackageMethods;\n-\n-    static final Object NULL = new Object() {\n-        @Override\n-        public String toString() {\n-            return \"<null>\";\n-        }\n-    };\n-\n-    private static final Set<String> OBJECT_METHODS =\n-            Stream.of(Object.class.getMethods()).map(ObjectMapper::lookupMethodName).collect(toSet());\n-\n-    private static final Function<Class<?>, Stream<Method>> PUBLIC_METHODS_GETTER = type -> {\n-        return Stream.of(type.getMethods());\n-    };\n-\n-    private static final Function<Class<?>, Stream<Method>> PUBLIC_AND_PACKAGE_METHODS_GETTER = type -> {\n-        return Stream.of(type.getDeclaredMethods()).filter(m -> {\n-            return Stream.<IntPredicate>of(Modifier::isPrivate, Modifier::isProtected).map(p -> {\n-                return p.test(m.getModifiers());\n-            }).allMatch(v -> !v);\n-        }).map(m -> {\n-            m.setAccessible(true);\n-            return m;\n-        });\n-    };\n-}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/ObjectMapper.java","additions":0,"deletions":780,"binary":false,"changes":780,"status":"deleted"},{"patch":"@@ -42,0 +42,1 @@\n+import java.util.Collections;\n@@ -320,5 +321,0 @@\n-    public PackageTest mutate(Consumer<PackageTest> mutator) {\n-        mutator.accept(this);\n-        return this;\n-    }\n-\n@@ -341,5 +337,1 @@\n-        return forTypes(List.of(type), action);\n-    }\n-\n-    public PackageTest forTypes(Collection<PackageType> types, Consumer<PackageTest> action) {\n-        return forTypes(types, () -> action.accept(this));\n+        return forTypes(List.of(type), () -> action.accept(this));\n@@ -359,5 +351,1 @@\n-        return notForTypes(List.of(type), action);\n-    }\n-\n-    public PackageTest notForTypes(Collection<PackageType> types, Consumer<PackageTest> action) {\n-        return notForTypes(types, () -> action.accept(this));\n+        return notForTypes(List.of(type), () -> action.accept(this));\n@@ -795,1 +783,1 @@\n-            cmd.runStandardAsserts();\n+            cmd.assertAppLayout();\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/PackageTest.java","additions":4,"deletions":16,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import static jdk.jpackage.internal.util.function.ThrowingBiFunction.toBiFunction;\n-import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n@@ -33,0 +31,1 @@\n+import java.io.FileOutputStream;\n@@ -42,1 +41,0 @@\n-import java.nio.file.StandardOpenOption;\n@@ -114,1 +112,1 @@\n-        if (state().extraLogStream != null) {\n+        if (extraLogStream != null) {\n@@ -124,33 +122,1 @@\n-        withNewState(action, stateBuilder -> {\n-            stateBuilder.extraLogStream(logStream);\n-        });\n-    }\n-\n-    public static void withMainLogStream(ThrowingRunnable action, PrintStream logStream) {\n-        withNewState(action, stateBuilder -> {\n-            stateBuilder.mainLogStream(logStream);\n-        });\n-    }\n-\n-    public static void withStackTraceStream(ThrowingRunnable action, PrintStream logStream) {\n-        withNewState(action, stateBuilder -> {\n-            stateBuilder.stackTraceStream(logStream);\n-        });\n-    }\n-\n-    public static State state() {\n-        return STATE.get();\n-    }\n-\n-    public static void state(State v) {\n-        STATE.set(Objects.requireNonNull(v));\n-    }\n-\n-    private static void withNewState(ThrowingRunnable action, Consumer<State.Builder> stateBuilderMutator) {\n-        Objects.requireNonNull(action);\n-        Objects.requireNonNull(stateBuilderMutator);\n-\n-        var oldState = state();\n-        var builder = oldState.buildCopy();\n-        stateBuilderMutator.accept(builder);\n-        var newState = builder.create();\n+        var oldExtraLogStream = extraLogStream;\n@@ -158,1 +124,1 @@\n-            state(newState);\n+            extraLogStream = logStream;\n@@ -161,1 +127,1 @@\n-            state(oldState);\n+            extraLogStream = oldExtraLogStream;\n@@ -178,2 +144,3 @@\n-        if (currentTest() != null) {\n-            throw new IllegalStateException(\"Unexpected nested Test.run() call\");\n+        if (currentTest != null) {\n+            throw new IllegalStateException(\n+                    \"Unexpected nested or concurrent Test.run() call\");\n@@ -184,9 +151,11 @@\n-                withNewState(() -> {\n-                    try {\n-                        if (modes.contains(RunTestMode.FAIL_FAST)) {\n-                            test.run();\n-                        } else {\n-                            ignoreExceptions(test).run();\n-                        }\n-                    } finally {\n-                        Optional.ofNullable(state().extraLogStream).ifPresent(PrintStream::flush);\n+                currentTest = test;\n+                try {\n+                    if (modes.contains(RunTestMode.FAIL_FAST)) {\n+                        ThrowingRunnable.toRunnable(test::run).run();\n+                    } else {\n+                        ignoreExceptions(test).run();\n+                    }\n+                } finally {\n+                    currentTest = null;\n+                    if (extraLogStream != null) {\n+                        extraLogStream.flush();\n@@ -194,3 +163,1 @@\n-                }, stateBuilder -> {\n-                    stateBuilder.currentTest(test);\n-                });\n+                }\n@@ -253,1 +220,1 @@\n-        return currentTest().workDir();\n+        return currentTest.workDir();\n@@ -260,1 +227,1 @@\n-        String appNamePrefix = currentTest().functionName();\n+        String appNamePrefix = currentTest.functionName();\n@@ -264,1 +231,1 @@\n-        return Stream.of(appNamePrefix, currentTest().baseName()).filter(\n+        return Stream.of(appNamePrefix, currentTest.baseName()).filter(\n@@ -292,4 +259,3 @@\n-        var state = state();\n-        state.mainLogStream.println(v);\n-        if (state.extraLogStream != null) {\n-            state.extraLogStream.println(v);\n+        System.out.println(v);\n+        if (extraLogStream != null) {\n+            extraLogStream.println(v);\n@@ -345,1 +311,1 @@\n-        if (state().trace) {\n+        if (TRACE) {\n@@ -351,1 +317,1 @@\n-        if (state().traceAsserts) {\n+        if (TRACE_ASSERTS) {\n@@ -612,1 +578,1 @@\n-        currentTest().notifySkipped(ex);\n+        currentTest.notifySkipped(ex);\n@@ -616,4 +582,0 @@\n-    public static boolean isSkippedException(Throwable t) {\n-        return JtregSkippedExceptionClass.INSTANCE.isInstance(t);\n-    }\n-\n@@ -694,3 +656,4 @@\n-        var state = state();\n-        Optional.ofNullable(state.extraLogStream).ifPresent(throwable::printStackTrace);\n-        throwable.printStackTrace(state.stackTraceStream);\n+        if (extraLogStream != null) {\n+            throwable.printStackTrace(extraLogStream);\n+        }\n+        throwable.printStackTrace();\n@@ -707,1 +670,1 @@\n-        currentTest().notifyAssert();\n+        currentTest.notifyAssert();\n@@ -718,1 +681,1 @@\n-        currentTest().notifyAssert();\n+        currentTest.notifyAssert();\n@@ -729,1 +692,1 @@\n-        currentTest().notifyAssert();\n+        currentTest.notifyAssert();\n@@ -740,1 +703,1 @@\n-        currentTest().notifyAssert();\n+        currentTest.notifyAssert();\n@@ -752,1 +715,1 @@\n-        currentTest().notifyAssert();\n+        currentTest.notifyAssert();\n@@ -764,1 +727,1 @@\n-        currentTest().notifyAssert();\n+        currentTest.notifyAssert();\n@@ -777,1 +740,1 @@\n-        currentTest().notifyAssert();\n+        currentTest.notifyAssert();\n@@ -787,1 +750,1 @@\n-        currentTest().notifyAssert();\n+        currentTest.notifyAssert();\n@@ -804,1 +767,1 @@\n-        currentTest().notifyAssert();\n+        currentTest.notifyAssert();\n@@ -816,1 +779,1 @@\n-        currentTest().notifyAssert();\n+        currentTest.notifyAssert();\n@@ -837,29 +800,0 @@\n-    public static void assertMismatchFileContent(Path a, Path b) {\n-        assertFilesMismatch(a, b, true, Optional.empty());\n-    }\n-\n-    public static void assertMismatchFileContent(Path a, Path b, String msg) {\n-        assertFilesMismatch(a, b, true, Optional.of(msg));\n-    }\n-\n-    public static void assertSameFileContent(Path a, Path b) {\n-        assertFilesMismatch(a, b, false, Optional.empty());\n-    }\n-\n-    public static void assertSameFileContent(Path a, Path b, String msg) {\n-        assertFilesMismatch(a, b, false, Optional.of(msg));\n-    }\n-\n-    public static void assertFilesMismatch(Path a, Path b, boolean expectMismatch, Optional<String> msg) {\n-        var mismatch = toBiFunction(Files::mismatch).apply(a, b) != -1;\n-        if (expectMismatch) {\n-            assertTrue(mismatch, msg.orElseGet(() -> {\n-                return String.format(\"Check the content of [%s] and [%s] files mismatch\", a, b);\n-            }));\n-        } else {\n-            assertTrue(!mismatch, msg.orElseGet(() -> {\n-                return String.format(\"Check the content of [%s] and [%s] files is the same\", a, b);\n-            }));\n-        }\n-    }\n-\n@@ -900,8 +834,1 @@\n-                (\"Check [%s] is a symbolic link\", Objects.requireNonNull(path)));\n-    }\n-\n-    public static void assertSymbolicLinkTarget(Path symlinkPath, Path expectedTargetPath) {\n-        assertSymbolicLinkExists(symlinkPath);\n-        var targetPath = toFunction(Files::readSymbolicLink).apply(symlinkPath);\n-        assertEquals(expectedTargetPath, targetPath,\n-                String.format(\"Check the target of the symbolic link [%s]\", symlinkPath));\n+                (\"Check [%s] is a symbolic link\", path));\n@@ -929,1 +856,1 @@\n-        currentTest().notifyAssert();\n+        currentTest.notifyAssert();\n@@ -955,1 +882,1 @@\n-            currentTest().notifyAssert();\n+            currentTest.notifyAssert();\n@@ -982,1 +909,1 @@\n-            currentTest().notifyAssert();\n+            currentTest.notifyAssert();\n@@ -1027,1 +954,1 @@\n-        currentTest().notifyAssert();\n+        currentTest.notifyAssert();\n@@ -1253,7 +1180,6 @@\n-        return state().logFile.map(logfile -> {\n-            try {\n-                return Files.newOutputStream(logfile, StandardOpenOption.CREATE, StandardOpenOption.APPEND);\n-            } catch (IOException ex) {\n-                throw new UncheckedIOException(ex);\n-            }\n-        }).map(PrintStream::new).orElse(null);\n+        if (LOG_FILE == null) {\n+            return null;\n+        }\n+\n+        return ThrowingSupplier.toSupplier(() -> new PrintStream(\n+                new FileOutputStream(LOG_FILE.toFile(), true))).get();\n@@ -1271,2 +1197,2 @@\n-        public void assertEquals(PathSnapshot other, String msg) {\n-            assertStringListEquals(contentHashes(), other.contentHashes(), msg);\n+        public static void assertEquals(PathSnapshot a, PathSnapshot b, String msg) {\n+            assertStringListEquals(a.contentHashes(), b.contentHashes(), msg);\n@@ -1303,0 +1229,9 @@\n+    private static TestInstance currentTest;\n+    private static PrintStream extraLogStream;\n+\n+    private static final boolean TRACE;\n+    private static final boolean TRACE_ASSERTS;\n+\n+    static final boolean VERBOSE_JPACKAGE;\n+    static final boolean VERBOSE_TEST_SETUP;\n+\n@@ -1330,3 +1265,7 @@\n-    private static TestInstance currentTest() {\n-        return state().currentTest;\n-    }\n+    static final Path LOG_FILE = Functional.identity(() -> {\n+        String val = getConfigProperty(\"logfile\");\n+        if (val == null) {\n+            return null;\n+        }\n+        return Path.of(val);\n+    }).get();\n@@ -1334,3 +1273,16 @@\n-    static boolean verboseJPackage() {\n-        return state().verboseJPackage;\n-    }\n+    static {\n+        Set<String> logOptions = tokenizeConfigProperty(\"suppress-logging\");\n+        if (logOptions == null) {\n+            TRACE = true;\n+            TRACE_ASSERTS = true;\n+            VERBOSE_JPACKAGE = true;\n+            VERBOSE_TEST_SETUP = true;\n+        } else if (logOptions.contains(\"all\")) {\n+            TRACE = false;\n+            TRACE_ASSERTS = false;\n+            VERBOSE_JPACKAGE = false;\n+            VERBOSE_TEST_SETUP = false;\n+        } else {\n+            Predicate<Set<String>> isNonOf = options -> {\n+                return Collections.disjoint(logOptions, options);\n+            };\n@@ -1338,2 +1290,5 @@\n-    static boolean verboseTestSetup() {\n-        return state().verboseTestSetup;\n+            TRACE = isNonOf.test(Set.of(\"trace\", \"t\"));\n+            TRACE_ASSERTS = isNonOf.test(Set.of(\"assert\", \"a\"));\n+            VERBOSE_JPACKAGE = isNonOf.test(Set.of(\"jpackage\", \"jp\"));\n+            VERBOSE_TEST_SETUP = isNonOf.test(Set.of(\"init\", \"i\"));\n+        }\n@@ -1342,1 +1297,0 @@\n-\n@@ -1368,155 +1322,0 @@\n-\n-\n-    public static final class State {\n-\n-        private State(\n-                Optional<Path> logFile,\n-                TestInstance currentTest,\n-                PrintStream mainLogStream,\n-                PrintStream stackTraceStream,\n-                PrintStream extraLogStream,\n-                boolean trace,\n-                boolean traceAsserts,\n-                boolean verboseJPackage,\n-                boolean verboseTestSetup) {\n-\n-            Objects.requireNonNull(logFile);\n-            Objects.requireNonNull(mainLogStream);\n-            Objects.requireNonNull(stackTraceStream);\n-\n-            this.logFile = logFile;\n-            this.currentTest = currentTest;\n-            this.mainLogStream = mainLogStream;\n-            this.stackTraceStream = stackTraceStream;\n-            this.extraLogStream = extraLogStream;\n-\n-            this.trace = trace;\n-            this.traceAsserts = traceAsserts;\n-\n-            this.verboseJPackage = verboseJPackage;\n-            this.verboseTestSetup = verboseTestSetup;\n-        }\n-\n-\n-        Builder buildCopy() {\n-            return build().initFrom(this);\n-        }\n-\n-        static Builder build() {\n-            return new Builder();\n-        }\n-\n-\n-        static final class Builder {\n-\n-            Builder initDefaults() {\n-                logFile = Optional.ofNullable(getConfigProperty(\"logfile\")).map(Path::of);\n-                currentTest = null;\n-                mainLogStream = System.out;\n-                stackTraceStream = System.err;\n-                extraLogStream = null;\n-\n-                var logOptions = tokenizeConfigProperty(\"suppress-logging\");\n-                if (logOptions == null) {\n-                    trace = true;\n-                    traceAsserts = true;\n-                    verboseJPackage = true;\n-                    verboseTestSetup = true;\n-                } else if (logOptions.contains(\"all\")) {\n-                    trace = false;\n-                    traceAsserts = false;\n-                    verboseJPackage = false;\n-                    verboseTestSetup = false;\n-                } else {\n-                    Predicate<Set<String>> isNonOf = options -> {\n-                        return Collections.disjoint(logOptions, options);\n-                    };\n-\n-                    trace = isNonOf.test(Set.of(\"trace\", \"t\"));\n-                    traceAsserts = isNonOf.test(Set.of(\"assert\", \"a\"));\n-                    verboseJPackage = isNonOf.test(Set.of(\"jpackage\", \"jp\"));\n-                    verboseTestSetup = isNonOf.test(Set.of(\"init\", \"i\"));\n-                }\n-\n-                return this;\n-            }\n-\n-            Builder initFrom(State state) {\n-                logFile = state.logFile;\n-                currentTest = state.currentTest;\n-                mainLogStream = state.mainLogStream;\n-                stackTraceStream = state.stackTraceStream;\n-                extraLogStream = state.extraLogStream;\n-\n-                trace = state.trace;\n-                traceAsserts = state.traceAsserts;\n-\n-                verboseJPackage = state.verboseJPackage;\n-                verboseTestSetup = state.verboseTestSetup;\n-\n-                return this;\n-            }\n-\n-            Builder logFile(Optional<Path> v) {\n-                logFile = v;\n-                return this;\n-            }\n-\n-            Builder currentTest(TestInstance v) {\n-                currentTest = v;\n-                return this;\n-            }\n-\n-            Builder mainLogStream(PrintStream v) {\n-                mainLogStream = v;\n-                return this;\n-            }\n-\n-            Builder stackTraceStream(PrintStream v) {\n-                stackTraceStream = v;\n-                return this;\n-            }\n-\n-            Builder extraLogStream(PrintStream v) {\n-                extraLogStream = v;\n-                return this;\n-            }\n-\n-            State create() {\n-                return new State(logFile, currentTest, mainLogStream, stackTraceStream, extraLogStream, trace, traceAsserts, verboseJPackage, verboseTestSetup);\n-            }\n-\n-            private Optional<Path> logFile;\n-            private TestInstance currentTest;\n-            private PrintStream mainLogStream;\n-            private PrintStream stackTraceStream;\n-            private PrintStream extraLogStream;\n-\n-            private boolean trace;\n-            private boolean traceAsserts;\n-\n-            private boolean verboseJPackage;\n-            private boolean verboseTestSetup;\n-        }\n-\n-\n-        private final Optional<Path> logFile;\n-        private final TestInstance currentTest;\n-        private final PrintStream mainLogStream;\n-        private final PrintStream stackTraceStream;\n-        private final PrintStream extraLogStream;\n-\n-        private final boolean trace;\n-        private final boolean traceAsserts;\n-\n-        private final boolean verboseJPackage;\n-        private final boolean verboseTestSetup;\n-    }\n-\n-\n-    private static final InheritableThreadLocal<State> STATE = new InheritableThreadLocal<>() {\n-        @Override\n-        protected State initialValue() {\n-            return State.build().initDefaults().create();\n-        }\n-    };\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TKit.java","additions":93,"deletions":294,"binary":false,"changes":387,"status":"modified"},{"patch":"@@ -372,1 +372,1 @@\n-        if (TKit.verboseTestSetup()) {\n+        if (TKit.VERBOSE_TEST_SETUP) {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TestBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -412,1 +412,1 @@\n-        if (TKit.verboseTestSetup()) {\n+        if (TKit.VERBOSE_TEST_SETUP) {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TestMethodSupplier.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,157 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal.util;\n-\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n-import static org.junit.jupiter.api.Assertions.assertNotEquals;\n-import static org.junit.jupiter.api.Assertions.assertThrows;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import org.junit.jupiter.api.Test;\n-\n-\n-public class IdentityWrapperTest {\n-\n-    @Test\n-    public void test_null() {\n-        assertThrows(NullPointerException.class, () -> identityOf(null));\n-    }\n-\n-    @Test\n-    public void test_equals() {\n-        var obj = new TestRecord(10);\n-        assertEquals(identityOf(obj), identityOf(obj));\n-    }\n-\n-    @Test\n-    public void test_not_equals() {\n-        var identity = identityOf(new TestRecord(10));\n-        var identity2 = identityOf(new TestRecord(10));\n-        assertNotEquals(identity, identity2);\n-        assertEquals(identity.value(), identity2.value());\n-    }\n-\n-    @Test\n-    public void test_Foo() {\n-        var foo = new Foo(10);\n-        assertFalse(foo.accessed());\n-\n-        foo.hashCode();\n-        assertTrue(foo.accessed());\n-        assertTrue(foo.hashCodeCalled());\n-        assertFalse(foo.equalsCalled());\n-\n-        foo = new Foo(1);\n-        foo.equals(null);\n-        assertTrue(foo.accessed());\n-        assertFalse(foo.hashCodeCalled());\n-        assertTrue(foo.equalsCalled());\n-    }\n-\n-    @Test\n-    public void test_wrappedValue_not_accessed() {\n-        var identity = identityOf(new Foo(10));\n-        var identity2 = identityOf(new Foo(10));\n-        assertNotEquals(identity, identity2);\n-\n-        assertFalse(identity.value().accessed());\n-        assertFalse(identity2.value().accessed());\n-\n-        assertEquals(identity.value(), identity2.value());\n-        assertEquals(identity2.value(), identity.value());\n-\n-        assertTrue(identity.value().accessed());\n-        assertTrue(identity2.value().accessed());\n-    }\n-\n-    @Test\n-    public void test_wrappedValue_not_accessed_in_set() {\n-        var identitySet = Set.of(identityOf(new Foo(10)), identityOf(new Foo(10)), identityOf(new Foo(10)));\n-        assertEquals(3, identitySet.size());\n-\n-        var valueSet = identitySet.stream().peek(identity -> {\n-            assertFalse(identity.value().accessed());\n-        }).map(IdentityWrapper::value).collect(Collectors.toSet());\n-\n-        assertEquals(1, valueSet.size());\n-    }\n-\n-    private static <T> IdentityWrapper<T> identityOf(T obj) {\n-        return new IdentityWrapper<>(obj);\n-    }\n-\n-    private record TestRecord(int v) {}\n-\n-    private final static class Foo {\n-\n-        Foo(int v) {\n-            this.v = v;\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            try {\n-                return Objects.hash(v);\n-            } finally {\n-                hashCodeCalled = true;\n-            }\n-        }\n-\n-        @Override\n-        public boolean equals(Object obj) {\n-            try {\n-                if (this == obj)\n-                    return true;\n-                if (obj == null)\n-                    return false;\n-                if (getClass() != obj.getClass())\n-                    return false;\n-                Foo other = (Foo) obj;\n-                return v == other.v;\n-            } finally {\n-                equalsCalled = true;\n-            }\n-        }\n-\n-        boolean equalsCalled() {\n-            return equalsCalled;\n-        }\n-\n-        boolean hashCodeCalled() {\n-            return hashCodeCalled;\n-        }\n-\n-        boolean accessed() {\n-            return equalsCalled() || hashCodeCalled();\n-        }\n-\n-        private final int v;\n-        private boolean equalsCalled;\n-        private boolean hashCodeCalled;\n-    }\n-}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/util\/IdentityWrapperTest.java","additions":0,"deletions":157,"binary":false,"changes":157,"status":"deleted"},{"patch":"@@ -1,139 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.test;\n-\n-import java.util.Map;\n-import java.util.Objects;\n-import org.junit.jupiter.api.Assertions;\n-\n-\n-public final class JUnitUtils {\n-\n-    \/**\n-     * Convenience adapter for {@link Assertions#assertArrayEquals(byte[], byte[])},\n-     * {@link Assertions#assertArrayEquals(int[], int[])},\n-     * {@link Assertions#assertArrayEquals(Object[], Object[])}, etc. methods.\n-     *\n-     * @param expected the expected array to test for equality\n-     * @param actual   the actual array to test for equality\n-     *\/\n-    public static void assertArrayEquals(Object expected, Object actual) {\n-        ARRAY_ASSERTERS.getOrDefault(expected.getClass().componentType(), OBJECT_ARRAY_ASSERTER).acceptUnchecked(expected, actual);\n-    }\n-\n-    \/**\n-     * Converts the given exception object to a property map.\n-     * <p>\n-     * Values returned by public getters are added to the map. Names of getters are\n-     * the keys in the returned map. The values are property map representations of\n-     * the objects returned by the getters. Only {@link Throwable#getMessage()} and\n-     * {@link Throwable#getCause()} getters are picked for the property map by\n-     * default. If the exception class has additional getters, they will be added to\n-     * the map. {@code null} is permitted.\n-     *\n-     * @param ex the exception to convert into a property map\n-     * @return the property map view of the given exception object\n-     *\/\n-    public static Map<String, Object> exceptionAsPropertyMap(Exception ex) {\n-        return EXCEPTION_OM.toMap(ex);\n-    }\n-\n-\n-    public static final class ExceptionPattern {\n-\n-        public ExceptionPattern() {\n-        }\n-\n-        public boolean match(Exception ex) {\n-            Objects.requireNonNull(ex);\n-\n-            if (expectedType != null && !expectedType.isInstance(ex)) {\n-                return false;\n-            }\n-\n-            if (expectedMessage != null && !expectedMessage.equals(ex.getMessage())) {\n-                return false;\n-            }\n-\n-            if (expectedCauseType != null && !expectedCauseType.isInstance(ex.getCause())) {\n-                return false;\n-            }\n-\n-            return true;\n-        }\n-\n-        public ExceptionPattern hasMessage(String v) {\n-            expectedMessage = v;\n-            return this;\n-        }\n-\n-        public ExceptionPattern isInstanceOf(Class<? extends Exception> v) {\n-            expectedType = v;\n-            return this;\n-        }\n-\n-        public ExceptionPattern isCauseInstanceOf(Class<? extends Throwable> v) {\n-            expectedCauseType = v;\n-            return this;\n-        }\n-\n-        public ExceptionPattern hasCause(boolean v) {\n-            return isCauseInstanceOf(v ? Exception.class : null);\n-        }\n-\n-        public ExceptionPattern hasCause() {\n-            return hasCause(true);\n-        }\n-\n-        private String expectedMessage;\n-        private Class<? extends Exception> expectedType;\n-        private Class<? extends Throwable> expectedCauseType;\n-    }\n-\n-\n-    @FunctionalInterface\n-    private interface ArrayEqualsAsserter<T> {\n-        void accept(T expected, T actual);\n-\n-        @SuppressWarnings(\"unchecked\")\n-        default void acceptUnchecked(Object expected, Object actual) {\n-            accept((T)expected, (T)actual);\n-        }\n-    }\n-\n-\n-    private static final Map<Class<?>, ArrayEqualsAsserter<?>> ARRAY_ASSERTERS = Map.of(\n-            boolean.class, (ArrayEqualsAsserter<boolean[]>)Assertions::assertArrayEquals,\n-            byte.class, (ArrayEqualsAsserter<byte[]>)Assertions::assertArrayEquals,\n-            char.class, (ArrayEqualsAsserter<char[]>)Assertions::assertArrayEquals,\n-            double.class, (ArrayEqualsAsserter<double[]>)Assertions::assertArrayEquals,\n-            float.class, (ArrayEqualsAsserter<float[]>)Assertions::assertArrayEquals,\n-            int.class, (ArrayEqualsAsserter<int[]>)Assertions::assertArrayEquals,\n-            long.class, (ArrayEqualsAsserter<long[]>)Assertions::assertArrayEquals,\n-            short.class, (ArrayEqualsAsserter<short[]>)Assertions::assertArrayEquals\n-    );\n-\n-    private static final ArrayEqualsAsserter<Object[]> OBJECT_ARRAY_ASSERTER = Assertions::assertArrayEquals;\n-\n-    private static final ObjectMapper EXCEPTION_OM = ObjectMapper.standard().create();\n-}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/tools\/jdk\/jpackage\/test\/JUnitUtils.java","additions":0,"deletions":139,"binary":false,"changes":139,"status":"deleted"},{"patch":"@@ -167,1 +167,1 @@\n-                            \"Comment=APPLICATION_DESCRIPTION\",\n+                            \"Comment=\",\n","filename":"test\/jdk\/tools\/jpackage\/linux\/ShortcutHintTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,0 @@\n-import static java.util.Collections.unmodifiableSortedSet;\n@@ -44,1 +43,0 @@\n-import java.util.TreeSet;\n@@ -147,1 +145,0 @@\n-            customPLists = unmodifiableSortedSet(new TreeSet<>(customPLists));\n@@ -153,0 +150,1 @@\n+                    .sorted(Comparator.comparing(CustomPListType::role))\n@@ -160,1 +158,1 @@\n-                final var props = List.of(\n+                var map = Map.ofEntries(\n@@ -165,1 +163,1 @@\n-                TKit.createPropertiesFile(propFile, props);\n+                TKit.createPropertiesFile(propFile, map);\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/CustomInfoPListTest.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,154 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import static jdk.jpackage.internal.util.PListWriter.writeBoolean;\n-import static jdk.jpackage.internal.util.PListWriter.writeDict;\n-import static jdk.jpackage.internal.util.PListWriter.writePList;\n-import static jdk.jpackage.internal.util.XmlUtils.createXml;\n-import static jdk.jpackage.internal.util.XmlUtils.toXmlConsumer;\n-import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n-\n-import java.io.IOException;\n-import java.nio.file.Path;\n-import java.util.function.Consumer;\n-import java.util.stream.Stream;\n-import jdk.jpackage.internal.util.function.ThrowingConsumer;\n-import jdk.jpackage.test.AdditionalLauncher;\n-import jdk.jpackage.test.Annotations.Parameter;\n-import jdk.jpackage.test.Annotations.Test;\n-import jdk.jpackage.test.JPackageCommand;\n-import jdk.jpackage.test.MacHelper;\n-import jdk.jpackage.test.MacHelper.SignKeyOption;\n-import jdk.jpackage.test.MacSign;\n-import jdk.jpackage.test.TKit;\n-\n-\/*\n- * Test generates signed app-image with custom entitlements file from the\n- * \"--mac-entitlements\" parameter and the resource directory. Following cases\n- * are covered:\n- * - Custom entitlements file in the resource directory.\n- * - Custom entitlements file specified with the \"--mac-entitlements\" parameter.\n- * - Custom entitlements file in the resource directory and specified with the\n- * \"--mac-entitlements\" parameter.\n- *\/\n-\n-\/*\n- * @test\n- * @summary jpackage with --type app-image \"--mac-entitlements\" parameter\n- * @library \/test\/jdk\/tools\/jpackage\/helpers\n- * @library base\n- * @build SigningBase\n- * @build jdk.jpackage.test.*\n- * @build EntitlementsTest\n- * @requires (jpackage.test.MacSignTests == \"run\")\n- * @run main\/othervm\/timeout=720 -Xmx512m jdk.jpackage.test.Main\n- *  --jpt-run=EntitlementsTest\n- *  --jpt-before-run=SigningBase.verifySignTestEnvReady\n- *\/\n-public class EntitlementsTest {\n-\n-    private static void createEntitlementsFile(Path file, boolean microphone) throws IOException {\n-        createXml(file, xml -> {\n-            writePList(xml, toXmlConsumer(() -> {\n-                writeDict(xml, toXmlConsumer(() -> {\n-                    writeBoolean(xml, \"com.apple.security.cs.allow-jit\", true);\n-                    writeBoolean(xml, \"com.apple.security.cs.allow-unsigned-executable-memory\", true);\n-                    writeBoolean(xml, \"com.apple.security.cs.disable-library-validation\", true);\n-                    writeBoolean(xml, \"com.apple.security.cs.allow-dyld-environment-variables\", true);\n-                    writeBoolean(xml, \"com.apple.security.cs.debugger\", true);\n-                    writeBoolean(xml, \"com.apple.security.device.audio-input\", true);\n-                    writeBoolean(xml, \"com.apple.security.device.microphone\", microphone);\n-                }));\n-            }));\n-        });\n-    }\n-\n-    public enum EntitlementsSource implements Consumer<JPackageCommand> {\n-        CMDLINE(cmd -> {\n-            var macEntitlementsFile = TKit.createTempFile(\"foo.plist\");\n-            createEntitlementsFile(macEntitlementsFile, true);\n-            cmd.addArguments(\"--mac-entitlements\", macEntitlementsFile);\n-        }),\n-        RESOURCE_DIR(cmd -> {\n-            if (!cmd.hasArgument(\"--resource-dir\")) {\n-                cmd.setArgumentValue(\"--resource-dir\", TKit.createTempDirectory(\"resources\"));\n-            }\n-\n-            var resourcesDir = Path.of(cmd.getArgumentValue(\"--resource-dir\"));\n-            createEntitlementsFile(resourcesDir.resolve(cmd.name() + \".entitlements\"), false);\n-        }),\n-        ;\n-\n-        EntitlementsSource(ThrowingConsumer<JPackageCommand> initializer) {\n-            this.initializer = toConsumer(initializer);\n-        }\n-\n-        @Override\n-        public void accept(JPackageCommand cmd) {\n-            initializer.accept(cmd);\n-        }\n-\n-        private final Consumer<JPackageCommand> initializer;\n-    }\n-\n-    @Test\n-    @Parameter({\"CMDLINE\"})\n-    @Parameter({\"RESOURCE_DIR\"})\n-    @Parameter({\"CMDLINE\", \"RESOURCE_DIR\"})\n-    public static void test(EntitlementsSource... entitlementsSources) {\n-        MacSign.withKeychain(toConsumer(keychain -> {\n-            test(keychain, Stream.of(entitlementsSources));\n-        }), SigningBase.StandardKeychain.MAIN.keychain());\n-    }\n-\n-    @Test\n-    @Parameter({\"CMDLINE\"})\n-    @Parameter({\"RESOURCE_DIR\"})\n-    @Parameter({\"CMDLINE\", \"RESOURCE_DIR\"})\n-    public static void testAppStore(EntitlementsSource... entitlementsSources) {\n-        MacSign.withKeychain(toConsumer(keychain -> {\n-            test(keychain, Stream.concat(Stream.of(cmd -> {\n-                cmd.addArguments(\"--mac-app-store\");\n-                \/\/ Ignore externally supplied runtime as it may have the \"bin\"\n-                \/\/ directory that will cause jpackage to bail out.\n-                cmd.ignoreDefaultRuntime(true);\n-            }), Stream.of(entitlementsSources)));\n-        }), SigningBase.StandardKeychain.MAIN.keychain());\n-    }\n-\n-    private static void test(MacSign.ResolvedKeychain keychain, Stream<Consumer<JPackageCommand>> mutators) {\n-\n-        var cmd = JPackageCommand.helloAppImage();\n-\n-        cmd.mutate(MacHelper.useKeychain(keychain)).mutate(new SignKeyOption(\n-                SignKeyOption.Type.SIGN_KEY_IDENTITY,\n-                SigningBase.StandardCertificateRequest.CODESIGN.spec()\n-        )::addTo);\n-\n-        cmd.mutate(new AdditionalLauncher(\"x\")::applyTo);\n-\n-        mutators.forEach(cmd::mutate);\n-\n-        cmd.executeAndAssertHelloAppImageCreated();\n-    }\n-}\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/EntitlementsTest.java","additions":0,"deletions":154,"binary":false,"changes":154,"status":"deleted"},{"patch":"@@ -35,1 +35,0 @@\n-import java.util.List;\n@@ -65,1 +64,1 @@\n-        final var props = List.of(\n+        Map<String, String> map = Map.ofEntries(\n@@ -77,1 +76,1 @@\n-        TKit.createPropertiesFile(propFile, props);\n+        TKit.createPropertiesFile(propFile, map);\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/MacFileAssociationsTest.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -73,2 +73,0 @@\n-        expectedStrings.add(JPackageStringBundle.MAIN.cannedFormattedString(\"error.tool.failed.with.output\", \"codesign\"));\n-\n@@ -80,1 +78,3 @@\n-        MacSign.withKeychain(keychain -> {\n+        final var keychain = SigningBase.StandardKeychain.EXPIRED.spec().keychain();\n+\n+        MacSign.Keychain.withAddedKeychains(List.of(keychain), () -> {\n@@ -89,0 +89,2 @@\n+                    .addArguments(\"--mac-sign\")\n+                    .addArguments(\"--mac-signing-keychain\", keychain.name())\n@@ -96,30 +98,2 @@\n-            MacHelper.useKeychain(cmd, keychain).execute(1);\n-        }, MacSign.Keychain.UsageBuilder::addToSearchList, SigningBase.StandardKeychain.MAIN.keychain());\n-    }\n-\n-    @Test\n-    public static void testCodesignUnspecifiedFailure() throws IOException {\n-\n-        var appImageCmd = JPackageCommand.helloAppImage().setFakeRuntime();\n-\n-        appImageCmd.executeIgnoreExitCode().assertExitCodeIsZero();\n-\n-        \/\/ This test expects jpackage to respond in a specific way on a codesign failure.\n-        \/\/ The simplest option to trigger codesign failure is to request the signing of an invalid bundle.\n-        \/\/ Create app content directory with the name known to fail signing.\n-        final var appContent = appImageCmd.appLayout().contentDirectory().resolve(\"foo.1\");\n-        Files.createDirectory(appContent);\n-        Files.createFile(appContent.resolve(\"file\"));\n-\n-        final List<CannedFormattedString> expectedStrings = new ArrayList<>();\n-        expectedStrings.add(JPackageStringBundle.MAIN.cannedFormattedString(\"error.tool.failed.with.output\", \"codesign\"));\n-\n-        MacSign.withKeychain(keychain -> {\n-            final var cmd = new JPackageCommand().setPackageType(PackageType.IMAGE)\n-                    .ignoreDefaultVerbose(true)\n-                    .validateOutput(expectedStrings.toArray(CannedFormattedString[]::new))\n-                    .addArguments(\"--app-image\", appImageCmd.outputBundle())\n-                    .addArguments(\"--mac-app-image-sign-identity\", SigningBase.StandardCertificateRequest.CODESIGN.spec().name());\n-\n-            MacHelper.useKeychain(cmd, keychain).execute(1);\n-        }, MacSign.Keychain.UsageBuilder::addToSearchList, SigningBase.StandardKeychain.MAIN.keychain());\n+            cmd.execute(1);\n+        });\n@@ -145,2 +119,4 @@\n-        MacSign.withKeychain(keychain -> {\n-            final var cmd = MacHelper.useKeychain(JPackageCommand.helloAppImage(), keychain)\n+        final var keychain = SigningBase.StandardKeychain.EXPIRED.spec().keychain();\n+\n+        MacSign.Keychain.withAddedKeychains(List.of(keychain), () -> {\n+            final var cmd = JPackageCommand.helloAppImage()\n@@ -148,0 +124,2 @@\n+                    .addArguments(\"--mac-sign\")\n+                    .addArguments(\"--mac-signing-keychain\", keychain.name())\n@@ -154,1 +132,1 @@\n-        }, MacSign.Keychain.UsageBuilder::addToSearchList, SigningBase.StandardKeychain.EXPIRED.keychain());\n+        });\n@@ -173,2 +151,4 @@\n-        MacSign.withKeychain(keychain -> {\n-            final var cmd = MacHelper.useKeychain(JPackageCommand.helloAppImage(), keychain)\n+        final var keychain = SigningBase.StandardKeychain.DUPLICATE.spec().keychain();\n+\n+        MacSign.Keychain.withAddedKeychains(List.of(keychain), () -> {\n+            final var cmd = JPackageCommand.helloAppImage()\n@@ -176,0 +156,2 @@\n+                    .addArguments(\"--mac-sign\")\n+                    .addArguments(\"--mac-signing-keychain\", keychain.name())\n@@ -182,1 +164,1 @@\n-        }, MacSign.Keychain.UsageBuilder::addToSearchList, SigningBase.StandardKeychain.DUPLICATE.keychain());\n+        });\n@@ -189,2 +171,4 @@\n-        MacSign.withKeychain(keychain -> {\n-            final var cmd = MacHelper.useKeychain(JPackageCommand.helloAppImage(), keychain)\n+        final var keychain = SigningBase.StandardKeychain.MAIN.spec().keychain();\n+\n+        MacSign.Keychain.withAddedKeychains(List.of(keychain), () -> {\n+            final var cmd = JPackageCommand.helloAppImage()\n@@ -192,0 +176,2 @@\n+                    .addArguments(\"--mac-sign\")\n+                    .addArguments(\"--mac-signing-keychain\", keychain.name())\n@@ -197,1 +183,1 @@\n-        }, MacSign.Keychain.UsageBuilder::addToSearchList, SigningBase.StandardKeychain.MAIN.keychain());\n+        });\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/MacSignTest.java","additions":28,"deletions":42,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -24,2 +24,0 @@\n-import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n-\n@@ -27,3 +25,1 @@\n-import jdk.jpackage.test.AdditionalLauncher;\n-import jdk.jpackage.test.Annotations.Parameter;\n-import jdk.jpackage.test.Annotations.Test;\n+\n@@ -31,1 +27,3 @@\n-import jdk.jpackage.test.MacSign;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.AdditionalLauncher;\n@@ -73,6 +71,0 @@\n-        MacSign.withKeychain(toConsumer(keychain -> {\n-            test(keychain, doSign, signingKey, certEnum);\n-        }), SigningBase.StandardKeychain.MAIN.keychain());\n-    }\n-\n-    private void test(MacSign.ResolvedKeychain keychain, boolean doSign, boolean signingKey, SigningBase.CertIndex certEnum) throws Exception {\n@@ -85,1 +77,1 @@\n-                    keychain.name());\n+                    SigningBase.getKeyChain());\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningAppImageTest.java","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +24,0 @@\n-import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n-\n@@ -27,3 +25,1 @@\n-import jdk.jpackage.test.AdditionalLauncher;\n-import jdk.jpackage.test.Annotations.Parameter;\n-import jdk.jpackage.test.Annotations.Test;\n+\n@@ -31,2 +27,0 @@\n-import jdk.jpackage.test.MacSign;\n-import jdk.jpackage.test.PackageType;\n@@ -34,0 +28,4 @@\n+import jdk.jpackage.test.PackageType;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.AdditionalLauncher;\n@@ -72,6 +70,0 @@\n-        MacSign.withKeychain(toConsumer(keychain -> {\n-            test(keychain, signAppImage, signingKey);\n-        }), SigningBase.StandardKeychain.MAIN.keychain());\n-    }\n-\n-    private static void test(MacSign.ResolvedKeychain keychain, boolean signAppImage, boolean signingKey) throws Exception {\n@@ -89,1 +81,1 @@\n-                    keychain.name());\n+                    SigningBase.getKeyChain());\n@@ -114,1 +106,1 @@\n-            .addArguments(\"--mac-signing-keychain\", keychain.name());\n+            .addArguments(\"--mac-signing-keychain\", SigningBase.getKeyChain());\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningAppImageTwoStepsTest.java","additions":8,"deletions":16,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +24,0 @@\n-import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n-\n@@ -27,2 +25,0 @@\n-import jdk.jpackage.test.Annotations.Parameter;\n-import jdk.jpackage.test.Annotations.Test;\n@@ -31,2 +27,1 @@\n-import jdk.jpackage.test.MacHelper;\n-import jdk.jpackage.test.MacSign;\n+import jdk.jpackage.test.TKit;\n@@ -35,1 +30,3 @@\n-import jdk.jpackage.test.TKit;\n+import jdk.jpackage.test.MacHelper;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.Annotations.Parameter;\n@@ -108,6 +105,0 @@\n-        MacSign.withKeychain(toConsumer(keychain -> {\n-            test(keychain, signAppImage, signingKey);\n-        }), SigningBase.StandardKeychain.MAIN.keychain());\n-    }\n-\n-    private void test(MacSign.ResolvedKeychain keychain, boolean signAppImage, boolean signingKey) throws Exception {\n@@ -124,1 +115,1 @@\n-                    \"--mac-signing-keychain\", keychain.name());\n+                    \"--mac-signing-keychain\", SigningBase.getKeyChain());\n@@ -145,1 +136,1 @@\n-            .addArguments(\"--mac-signing-keychain\", keychain.name());\n+            .addArguments(\"--mac-signing-keychain\", SigningBase.getKeyChain());\n@@ -166,1 +157,1 @@\n-                                keychain.name());\n+                                SigningBase.getKeyChain());\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningPackageFromTwoStepAppImageTest.java","additions":8,"deletions":17,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -24,2 +24,0 @@\n-import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n-\n@@ -27,2 +25,0 @@\n-import jdk.jpackage.test.Annotations.Parameter;\n-import jdk.jpackage.test.Annotations.Test;\n@@ -31,2 +27,0 @@\n-import jdk.jpackage.test.MacHelper;\n-import jdk.jpackage.test.MacSign;\n@@ -35,0 +29,3 @@\n+import jdk.jpackage.test.MacHelper;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.Annotations.Parameter;\n@@ -150,6 +147,0 @@\n-        MacSign.withKeychain(toConsumer(keychain -> {\n-            test(keychain, signingKey, signAppImage, signPKG, certEnum);\n-        }), SigningBase.StandardKeychain.MAIN.keychain());\n-    }\n-\n-    private static void test(MacSign.ResolvedKeychain keychain, boolean signingKey, boolean signAppImage, boolean signPKG, SigningBase.CertIndex certEnum) throws Exception {\n@@ -163,1 +154,1 @@\n-                            \"--mac-signing-keychain\", keychain.name());\n+                            \"--mac-signing-keychain\", SigningBase.getKeyChain());\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningPackageTest.java","additions":4,"deletions":13,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +24,0 @@\n-import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n-\n@@ -27,12 +25,1 @@\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.SortedMap;\n-import java.util.TreeMap;\n-import java.util.stream.Stream;\n-import jdk.jpackage.test.Annotations.ParameterSupplier;\n-import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.ApplicationLayout;\n@@ -40,6 +27,1 @@\n-import jdk.jpackage.test.JPackageStringBundle;\n-import jdk.jpackage.test.MacHelper;\n-import jdk.jpackage.test.MacHelper.SignKeyOption;\n-import jdk.jpackage.test.MacSign;\n-import jdk.jpackage.test.MacSignVerify;\n-import jdk.jpackage.test.PackageFile;\n+import jdk.jpackage.test.TKit;\n@@ -48,1 +30,3 @@\n-import jdk.jpackage.test.TKit;\n+import jdk.jpackage.test.MacHelper;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.Annotations.Parameter;\n@@ -51,6 +35,14 @@\n- * Tests packaging of a signed\/unsigned predefined app image into a\n- * signed\/unsigned .pkg or .dmg package.\n- *\n- * <p>\n- * Prerequisites: A keychain with self-signed certificates as specified in\n- * {@link SigningBase.StandardKeychain#MAIN}.\n+ * Note: Testing unsgined app image is done to verify support for per-user\n+ * configuration by checking for PackageFile.\n+ * Tests generation of dmg and pkg from signed or unsigned predefined app image.\n+ * Test will generate pkg and verifies its signature. It verifies that dmg\n+ * is not signed, but app image inside dmg is signed or unsigned. This test\n+ * requires that the machine is configured with test certificate for\n+ * \"Developer ID Installer: jpackage.openjdk.java.net\" in\n+ * jpackagerTest keychain with\n+ * always allowed access to this keychain for user which runs test.\n+ * note:\n+ * \"jpackage.openjdk.java.net\" can be over-ridden by system property\n+ * \"jpackage.mac.signing.key.user.name\", and\n+ * \"jpackagerTest\" can be over-ridden by system property\n+ * \"jpackage.mac.signing.keychain\"\n@@ -75,23 +67,3 @@\n-    @Test\n-    @ParameterSupplier\n-    public static void test(TestSpec spec) {\n-        MacSign.withKeychain(toConsumer(keychain -> {\n-            spec.test(keychain);\n-        }), SigningBase.StandardKeychain.MAIN.keychain());\n-    }\n-\n-    public record TestSpec(Optional<SignKeyOption> signAppImage, Map<PackageType, SignKeyOption> signPackage) {\n-\n-        public TestSpec {\n-            Objects.requireNonNull(signAppImage);\n-            Objects.requireNonNull(signPackage);\n-\n-            if ((signAppImage.isEmpty() && signPackage.isEmpty()) || !PackageType.MAC.containsAll(signPackage.keySet())) {\n-                \/\/ Unexpected package types.\n-                throw new IllegalArgumentException();\n-            }\n-\n-            \/\/ Ensure stable result of toString() call.\n-            if (!SortedMap.class.isInstance(signPackage)) {\n-                signPackage = new TreeMap<>(signPackage);\n-            }\n+    private static void verifyPKG(JPackageCommand cmd) {\n+        if (!cmd.hasArgument(\"--mac-sign\")) {\n+            return; \/\/ Nothing to check if not signed\n@@ -100,51 +72,4 @@\n-        @Override\n-        public String toString() {\n-            var sb = new StringBuilder();\n-\n-            signAppImage.ifPresent(signOption -> {\n-                sb.append(String.format(\"app-image=%s\", signOption));\n-            });\n-\n-            if (!sb.isEmpty() && !signPackage.isEmpty()) {\n-                sb.append(\"; \");\n-            }\n-\n-            if (!signPackage.isEmpty()) {\n-                sb.append(signPackage);\n-            }\n-\n-            return sb.toString();\n-        }\n-\n-        boolean signNativeBundle() {\n-            return signPackage.isEmpty();\n-        }\n-\n-        static Builder build() {\n-            return new Builder();\n-        }\n-\n-        static class Builder {\n-\n-            TestSpec create() {\n-                return new TestSpec(Optional.ofNullable(signAppImage), signPackage);\n-            }\n-\n-            Builder certRequest(SigningBase.StandardCertificateRequest v) {\n-                return certRequest(v.spec());\n-            }\n-\n-            Builder certRequest(MacSign.CertificateRequest v) {\n-                certRequest = Objects.requireNonNull(v);\n-                return this;\n-            }\n-\n-            Builder signIdentityType(SignKeyOption.Type v) {\n-                signIdentityType = Objects.requireNonNull(v);\n-                return this;\n-            }\n-\n-            Builder signAppImage() {\n-                signAppImage = createSignKeyOption();\n-                return this;\n-            }\n+        Path outputBundle = cmd.outputBundle();\n+        SigningBase.verifyPkgutil(outputBundle, true, SigningBase.DEFAULT_INDEX);\n+        SigningBase.verifySpctl(outputBundle, \"install\", SigningBase.DEFAULT_INDEX);\n+    }\n@@ -152,5 +77,5 @@\n-            Builder signPackage(PackageType type) {\n-                Objects.requireNonNull(type);\n-                signPackage.put(type, createSignKeyOption());\n-                return this;\n-            }\n+    private static void verifyDMG(JPackageCommand cmd) {\n+        \/\/ DMG always unsigned, so we will check it\n+        Path outputBundle = cmd.outputBundle();\n+        SigningBase.verifyDMG(outputBundle);\n+    }\n@@ -158,3 +83,13 @@\n-            Builder signPackage() {\n-                PackageType.MAC.forEach(this::signPackage);\n-                return this;\n+    private static void verifyAppImageInDMG(JPackageCommand cmd) {\n+        MacHelper.withExplodedDmg(cmd, dmgImage -> {\n+            \/\/ We will be called with all folders in DMG since JDK-8263155, but\n+            \/\/ we only need to verify app.\n+            if (dmgImage.endsWith(cmd.name() + \".app\")) {\n+                boolean isSigned = cmd.hasArgument(\"--mac-sign\");\n+                Path launcherPath = ApplicationLayout.platformAppImage()\n+                    .resolveAt(dmgImage).launchersDirectory().resolve(cmd.name());\n+                SigningBase.verifyCodesign(launcherPath, isSigned, SigningBase.DEFAULT_INDEX);\n+                SigningBase.verifyCodesign(dmgImage, isSigned, SigningBase.DEFAULT_INDEX);\n+                if (isSigned) {\n+                    SigningBase.verifySpctl(dmgImage, \"exec\", SigningBase.DEFAULT_INDEX);\n+                }\n@@ -162,0 +97,2 @@\n+        });\n+    }\n@@ -163,2 +100,23 @@\n-            private SignKeyOption createSignKeyOption() {\n-                return new SignKeyOption(signIdentityType, certRequest);\n+    @Test\n+    \/\/ (Signed, \"signing-key or sign-identity\"})\n+    \/\/ Signed and signing-key\n+    @Parameter({\"true\", \"true\"})\n+    \/\/ Signed and signing-identity\n+    @Parameter({\"true\", \"false\"})\n+    \/\/ Unsigned\n+    @Parameter({\"false\", \"true\"})\n+    public static void test(boolean signAppImage, boolean signingKey) throws Exception {\n+        Path appimageOutput = TKit.createTempDirectory(\"appimage\");\n+\n+        JPackageCommand appImageCmd = JPackageCommand.helloAppImage()\n+                .setArgumentValue(\"--dest\", appimageOutput);\n+        if (signAppImage) {\n+            appImageCmd.addArguments(\"--mac-sign\")\n+                       .addArguments(\"--mac-signing-keychain\",\n+                                     SigningBase.getKeyChain());\n+            if (signingKey) {\n+                appImageCmd.addArguments(\"--mac-signing-key-user-name\",\n+                                SigningBase.getDevName(SigningBase.DEFAULT_INDEX));\n+            } else {\n+                appImageCmd.addArguments(\"--mac-app-image-sign-identity\",\n+                                SigningBase.getAppCert(SigningBase.DEFAULT_INDEX));\n@@ -166,6 +124,0 @@\n-\n-            private MacSign.CertificateRequest certRequest = SigningBase.StandardCertificateRequest.CODESIGN.spec();\n-            private SignKeyOption.Type signIdentityType = SignKeyOption.Type.SIGN_KEY_IDENTITY;\n-\n-            private SignKeyOption signAppImage;\n-            private Map<PackageType, SignKeyOption> signPackage = new HashMap<>();\n@@ -174,76 +126,36 @@\n-        void test(MacSign.ResolvedKeychain keychain) {\n-\n-            var appImageCmd = JPackageCommand.helloAppImage().setFakeRuntime();\n-            MacHelper.useKeychain(appImageCmd, keychain);\n-            signAppImage.ifPresent(signOption -> {\n-                signOption.setTo(appImageCmd);\n-            });\n-\n-            var test = new PackageTest();\n-\n-            signAppImage.map(SignKeyOption::certRequest).ifPresent(certRequest -> {\n-                \/\/ The predefined app image is signed, verify bundled app image is signed too.\n-                test.addInstallVerifier(cmd -> {\n-                    MacSignVerify.verifyAppImageSigned(cmd, certRequest, keychain);\n-                });\n-            });\n-\n-            Optional.ofNullable(signPackage.get(PackageType.MAC_PKG)).map(SignKeyOption::certRequest).ifPresent(certRequest -> {\n-                test.forTypes(PackageType.MAC_PKG, () -> {\n-                    test.addBundleVerifier(cmd -> {\n-                        MacSignVerify.verifyPkgSigned(cmd, certRequest, keychain);\n-                    });\n-                });\n-            });\n-\n-            test.forTypes(signPackage.keySet()).addRunOnceInitializer(() -> {\n-                appImageCmd.setArgumentValue(\"--dest\", TKit.createTempDirectory(\"appimage\")).execute(0);\n-            }).addInitializer(cmd -> {\n-                MacHelper.useKeychain(cmd, keychain);\n-                cmd.addArguments(\"--app-image\", appImageCmd.outputBundle());\n-                cmd.removeArgumentWithValue(\"--input\");\n-                Optional.ofNullable(signPackage.get(cmd.packageType())).ifPresent(signOption -> {\n-                    signOption.setTo(cmd);\n-                });\n-\n-                if (signAppImage.isPresent()) {\n-                    \/\/ Predefined app image is signed. Expect a warning.\n-                    cmd.validateOutput(JPackageStringBundle.MAIN.cannedFormattedString(\n-                            \"warning.per.user.app.image.signed\",\n-                            PackageFile.getPathInAppImage(Path.of(\"\"))));\n-                } else if (cmd.packageType() == PackageType.MAC_PKG && signPackage.containsKey(cmd.packageType())) {\n-                    \/\/ Create signed \".pkg\" bundle from the unsigned predefined app image. Expect a warning.\n-                    cmd.validateOutput(JPackageStringBundle.MAIN.cannedFormattedString(\"warning.unsigned.app.image\", \"pkg\"));\n-                }\n-            })\n-            .run();\n-        }\n-    }\n-\n-    public static Collection<Object[]> test() {\n-\n-        List<TestSpec.Builder> data = new ArrayList<>();\n-\n-        Stream.of(SignKeyOption.Type.values()).flatMap(signIdentityType -> {\n-            return Stream.of(\n-                    \/\/ Sign both predefined app image and native package.\n-                    TestSpec.build().signIdentityType(signIdentityType)\n-                            .signAppImage()\n-                            .signPackage()\n-                            .certRequest(SigningBase.StandardCertificateRequest.PKG)\n-                            .signPackage(PackageType.MAC_PKG),\n-\n-                    \/\/ Don't sign predefined app image, sign native package.\n-                    TestSpec.build().signIdentityType(signIdentityType)\n-                            .signPackage()\n-                            .certRequest(SigningBase.StandardCertificateRequest.PKG)\n-                            .signPackage(PackageType.MAC_PKG),\n-\n-                    \/\/ Sign predefined app image, don't sign native package.\n-                    TestSpec.build().signIdentityType(signIdentityType).signAppImage()\n-            );\n-        }).forEach(data::add);\n-\n-        return data.stream().map(TestSpec.Builder::create).map(v -> {\n-            return new Object[] {v};\n-        }).toList();\n+        new PackageTest()\n+                .addRunOnceInitializer(() -> appImageCmd.execute())\n+                .forTypes(PackageType.MAC)\n+                .addInitializer(cmd -> {\n+                    cmd.addArguments(\"--app-image\", appImageCmd.outputBundle());\n+                    cmd.removeArgumentWithValue(\"--input\");\n+                    if (signAppImage) {\n+                        cmd.addArguments(\"--mac-sign\",\n+                                \"--mac-signing-keychain\",\n+                                SigningBase.getKeyChain());\n+                        if (signingKey) {\n+                            cmd.addArguments(\"--mac-signing-key-user-name\",\n+                                    SigningBase.getDevName(SigningBase.DEFAULT_INDEX));\n+                        } else {\n+                            cmd.addArguments(\"--mac-installer-sign-identity\",\n+                                    SigningBase.getInstallerCert(SigningBase.DEFAULT_INDEX));\n+                        }\n+                    }\n+                })\n+                .forTypes(PackageType.MAC_PKG)\n+                .addBundleVerifier(SigningPackageTwoStepTest::verifyPKG)\n+                .forTypes(PackageType.MAC_DMG)\n+                .addInitializer(cmd -> {\n+                    if (signAppImage && !signingKey) {\n+                        \/\/ jpackage throws expected error with\n+                        \/\/ --mac-installer-sign-identity and DMG type\n+                        cmd.removeArgumentWithValue(\"--mac-installer-sign-identity\");\n+                        \/\/ It will do nothing, but it signals test that app\n+                        \/\/ image itself is signed for verification.\n+                        cmd.addArguments(\"--mac-app-image-sign-identity\",\n+                                SigningBase.getAppCert(SigningBase.DEFAULT_INDEX));\n+                    }\n+                })\n+                .addBundleVerifier(SigningPackageTwoStepTest::verifyDMG)\n+                .addBundleVerifier(SigningPackageTwoStepTest::verifyAppImageInDMG)\n+                .run();\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningPackageTwoStepTest.java","additions":106,"deletions":194,"binary":false,"changes":300,"status":"modified"},{"patch":"@@ -24,2 +24,0 @@\n-import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n-\n@@ -30,0 +28,1 @@\n+\n@@ -35,1 +34,0 @@\n-import jdk.jpackage.test.MacSign;\n@@ -41,3 +39,3 @@\n- * Tests generation of dmg and pkg with --mac-sign and related arguments. Test\n- * will generate pkg and verifies its signature. It verifies that dmg is not\n- * signed, but runtime image inside dmg is signed.\n+ * Tests generation of dmg and pkg with --mac-sign and related arguments.\n+ * Test will generate pkg and verifies its signature. It verifies that dmg\n+ * is not signed, but runtime image inside dmg is signed.\n@@ -45,3 +43,2 @@\n- * <p>\n- * Note: Specific UNICODE signing is not tested, since it is shared code with\n- * app image signing and it will be covered by SigningPackageTest.\n+ * Note: Specific UNICODE signing is not tested, since it is shared code\n+ * with app image signing and it will be covered by SigningPackageTest.\n@@ -49,1 +46,0 @@\n- * <p>\n@@ -51,2 +47,1 @@\n- * <ol>\n- * <li>\"--runtime-image\" points to unsigned JDK bundle and --mac-sign is not\n+ * 1) \"--runtime-image\" points to unsigned JDK bundle and --mac-sign is not\n@@ -54,1 +49,1 @@\n- * <li>\"--runtime-image\" points to unsigned JDK bundle and --mac-sign is\n+ * 2) \"--runtime-image\" points to unsigned JDK bundle and --mac-sign is\n@@ -56,1 +51,1 @@\n- * <li>\"--runtime-image\" points to signed JDK bundle and --mac-sign is not\n+ * 3) \"--runtime-image\" points to signed JDK bundle and --mac-sign is not\n@@ -58,1 +53,1 @@\n- * <li>\"--runtime-image\" points to signed JDK bundle and --mac-sign is provided.\n+ * 4) \"--runtime-image\" points to signed JDK bundle and --mac-sign is provided.\n@@ -60,1 +55,1 @@\n- * <li>\"--runtime-image\" points to JDK image and --mac-sign is not provided.\n+ * 5) \"--runtime-image\" points to JDK image and --mac-sign is not provided.\n@@ -62,1 +57,1 @@\n- * <li>\"--runtime-image\" points to JDK image and --mac-sign is provided.\n+ * 6) \"--runtime-image\" points to JDK image and --mac-sign is provided.\n@@ -64,1 +59,0 @@\n- * <\/ol>\n@@ -67,2 +61,4 @@\n- * \"Developer ID Installer: jpackage.openjdk.java.net\" in jpackagerTest keychain\n- * with always allowed access to this keychain for user which runs test. note:\n+ * \"Developer ID Installer: jpackage.openjdk.java.net\" in\n+ * jpackagerTest keychain with\n+ * always allowed access to this keychain for user which runs test.\n+ * note:\n@@ -70,1 +66,3 @@\n- * \"jpackage.mac.signing.key.user.name\"\n+ * \"jpackage.mac.signing.key.user.name\", and\n+ * \"jpackagerTest\" can be over-ridden by system property\n+ * \"jpackage.mac.signing.keychain\"\n@@ -89,1 +87,1 @@\n-    private static JPackageCommand addSignOptions(JPackageCommand cmd, MacSign.ResolvedKeychain keychain, int certIndex) {\n+    private static JPackageCommand addSignOptions(JPackageCommand cmd, int certIndex) {\n@@ -93,1 +91,1 @@\n-                    \"--mac-signing-keychain\", keychain.name(),\n+                    \"--mac-signing-keychain\", SigningBase.getKeyChain(),\n@@ -99,1 +97,1 @@\n-    private static Path createInputRuntimeBundle(MacSign.ResolvedKeychain keychain, int certIndex) throws IOException {\n+    private static Path createInputRuntimeBundle(int certIndex) throws IOException {\n@@ -116,1 +114,1 @@\n-        addSignOptions(cmd, keychain, certIndex);\n+        addSignOptions(cmd, certIndex);\n@@ -152,8 +150,0 @@\n-        MacSign.withKeychain(toConsumer(keychain -> {\n-            test(keychain, useJDKBundle, jdkBundleCert, signCert);\n-        }), SigningBase.StandardKeychain.MAIN.keychain());\n-    }\n-\n-    private static void test(MacSign.ResolvedKeychain keychain, boolean useJDKBundle,\n-            SigningBase.CertIndex jdkBundleCert,\n-            SigningBase.CertIndex signCert) throws Exception {\n@@ -166,1 +156,1 @@\n-                        inputRuntime[0] = createInputRuntimeBundle(keychain, jdkBundleCert.value());\n+                        inputRuntime[0] = createInputRuntimeBundle(jdkBundleCert.value());\n@@ -177,1 +167,1 @@\n-                    addSignOptions(cmd, keychain, signCert.value());\n+                    addSignOptions(cmd, signCert.value());\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningRuntimeImagePackageTest.java","additions":25,"deletions":35,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -93,3 +93,0 @@\n-    \/**\n-     * Standard keychains used in signing tests.\n-     *\/\n@@ -97,4 +94,1 @@\n-        \/**\n-         * The primary keychain with good certificates.\n-         *\/\n-        MAIN(\"jpackagerTest.keychain\",\n+        MAIN(DEFAULT_KEYCHAIN,\n@@ -105,3 +99,0 @@\n-        \/**\n-         * A keychain with some good and some expired certificates.\n-         *\/\n@@ -113,3 +104,0 @@\n-        \/**\n-         * A keychain with duplicated certificates.\n-         *\/\n@@ -129,1 +117,1 @@\n-            this.keychain = new ResolvedKeychain(builder.create());\n+            this.spec = new ResolvedKeychain(builder.create());\n@@ -132,2 +120,2 @@\n-        public ResolvedKeychain keychain() {\n-            return keychain;\n+        public KeychainWithCertsSpec spec() {\n+            return spec.spec();\n@@ -137,1 +125,1 @@\n-            return Objects.requireNonNull(keychain.mapCertificateRequests().get(certRequest));\n+            return Objects.requireNonNull(spec.mapCertificateRequests().get(certRequest));\n@@ -144,0 +132,4 @@\n+        private static CertificateRequest.Builder cert() {\n+            return new CertificateRequest.Builder();\n+        }\n+\n@@ -145,1 +137,1 @@\n-            return Stream.of(values()).map(StandardKeychain::keychain).map(ResolvedKeychain::spec).toList();\n+            return Stream.of(values()).map(StandardKeychain::spec).toList();\n@@ -148,1 +140,1 @@\n-        private final ResolvedKeychain keychain;\n+        private final ResolvedKeychain spec;\n@@ -190,0 +182,1 @@\n+    private static String DEFAULT_KEYCHAIN = \"jpackagerTest.keychain\";\n@@ -205,0 +198,10 @@\n+    \/\/ Returns 'true' if dev name from DEV_NAMES\n+    public static boolean isDevNameDefault() {\n+        String value = System.getProperty(\"jpackage.mac.signing.key.user.name\");\n+        if (value != null) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n@@ -213,0 +216,10 @@\n+    public static String getKeyChain() {\n+        \/\/ Always use values from system properties if set\n+        String value = System.getProperty(\"jpackage.mac.signing.keychain\");\n+        if (value != null) {\n+            return value;\n+        }\n+\n+        return DEFAULT_KEYCHAIN;\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/base\/SigningBase.java","additions":32,"deletions":19,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -121,6 +121,0 @@\n-        if (RunnablePackageTest.hasAction(RunnablePackageTest.Action.INSTALL)) {\n-            \/\/ Ensure launchers are executable because the output bundle will be installed\n-            \/\/ and launchers will be attempted to be executed through their shortcuts.\n-            packageTest.addInitializer(JPackageCommand::ignoreFakeRuntime);\n-        }\n-\n","filename":"test\/jdk\/tools\/jpackage\/share\/AddLShortcutTest.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -24,1 +24,0 @@\n-import java.lang.invoke.MethodHandles;\n@@ -26,7 +25,3 @@\n-import java.util.function.Consumer;\n-import jdk.internal.util.OperatingSystem;\n-import jdk.jpackage.test.AdditionalLauncher;\n-import jdk.jpackage.test.Annotations.Parameter;\n-import jdk.jpackage.test.Annotations.Test;\n-import jdk.jpackage.test.CfgFile;\n-import jdk.jpackage.test.ConfigurationTarget;\n+import java.util.Map;\n+import java.lang.invoke.MethodHandles;\n+import jdk.jpackage.test.PackageTest;\n@@ -34,0 +29,1 @@\n+import jdk.jpackage.test.AdditionalLauncher;\n@@ -36,3 +32,0 @@\n-import jdk.jpackage.test.PackageTest;\n-import jdk.jpackage.test.PackageType;\n-import jdk.jpackage.test.RunnablePackageTest.Action;\n@@ -40,0 +33,3 @@\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.CfgFile;\n@@ -240,55 +236,0 @@\n-    \/**\n-     * Test --description option\n-     *\/\n-    @Test(ifNotOS = OperatingSystem.MACOS) \/\/ Don't run on macOS as launcher description is ignored on this platform\n-    @Parameter(\"true\")\n-    @Parameter(\"fase\")\n-    public void testDescription(boolean withPredefinedAppImage) {\n-\n-        ConfigurationTarget target;\n-        if (TKit.isWindows() || withPredefinedAppImage) {\n-            target = new ConfigurationTarget(JPackageCommand.helloAppImage());\n-        } else {\n-            target = new ConfigurationTarget(new PackageTest().configureHelloApp());\n-        }\n-\n-        target.addInitializer(cmd -> {\n-            cmd.setArgumentValue(\"--name\", \"Foo\").setArgumentValue(\"--description\", \"Hello\");\n-            cmd.setFakeRuntime();\n-            cmd.setStandardAsserts(JPackageCommand.StandardAssert.MAIN_LAUNCHER_DESCRIPTION);\n-        });\n-\n-        target.add(new AdditionalLauncher(\"x\"));\n-        target.add(new AdditionalLauncher(\"bye\").setProperty(\"description\", \"Bye\"));\n-\n-        target.test().ifPresent(test -> {\n-            \/\/ Make all launchers have shortcuts and thus .desktop files.\n-            \/\/ Launcher description is recorded in a desktop file and verified automatically.\n-            test.mutate(addLinuxShortcuts());\n-        });\n-\n-        target.cmd().ifPresent(withPredefinedAppImage ? JPackageCommand::execute : JPackageCommand::executeAndAssertImageCreated);\n-        target.test().ifPresent(test -> {\n-            test.run(Action.CREATE_AND_UNPACK);\n-        });\n-\n-        if (withPredefinedAppImage) {\n-            new PackageTest().addInitializer(cmd -> {\n-                cmd.setArgumentValue(\"--name\", \"Bar\");\n-                \/\/ Should not have impact of launcher descriptions, but it does.\n-                cmd.setArgumentValue(\"--description\", \"Installer\");\n-                cmd.removeArgumentWithValue(\"--input\").setArgumentValue(\"--app-image\", target.cmd().orElseThrow().outputBundle());\n-            }).mutate(addLinuxShortcuts()).run(Action.CREATE_AND_UNPACK);\n-        }\n-    }\n-\n-    private static Consumer<PackageTest> addLinuxShortcuts() {\n-        return test -> {\n-            test.forTypes(PackageType.LINUX, () -> {\n-                test.addInitializer(cmd -> {\n-                    cmd.addArgument(\"--linux-shortcut\");\n-                });\n-            });\n-        };\n-    }\n-\n","filename":"test\/jdk\/tools\/jpackage\/share\/AddLauncherTest.java","additions":7,"deletions":66,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -24,3 +24,1 @@\n-import static java.util.Map.entry;\n-import static java.util.stream.Collectors.joining;\n-import static java.util.stream.Collectors.toMap;\n+import static jdk.internal.util.OperatingSystem.LINUX;\n@@ -28,2 +26,1 @@\n-import static jdk.internal.util.OperatingSystem.WINDOWS;\n-import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n+import static java.util.stream.Collectors.joining;\n@@ -32,1 +29,0 @@\n-import java.io.UncheckedIOException;\n@@ -34,1 +30,0 @@\n-import java.nio.file.NoSuchFileException;\n@@ -36,3 +31,5 @@\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.HashSet;\n+import jdk.jpackage.test.PackageTest;\n+import jdk.jpackage.test.TKit;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.Annotations.Parameter;\n+import java.util.Arrays;\n@@ -40,7 +37,0 @@\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.TreeMap;\n-import java.util.function.Predicate;\n-import java.util.function.Supplier;\n@@ -48,1 +38,0 @@\n-import java.util.stream.StreamSupport;\n@@ -50,6 +39,1 @@\n-import jdk.jpackage.internal.util.IdentityWrapper;\n-import jdk.jpackage.internal.util.function.ThrowingSupplier;\n-import jdk.jpackage.test.Annotations.Parameter;\n-import jdk.jpackage.test.Annotations.ParameterSupplier;\n-import jdk.jpackage.test.Annotations.Test;\n-import jdk.jpackage.test.ConfigurationTarget;\n+import jdk.jpackage.internal.util.function.ThrowingFunction;\n@@ -58,3 +42,0 @@\n-import jdk.jpackage.test.PackageTest;\n-import jdk.jpackage.test.PackageType;\n-import jdk.jpackage.test.TKit;\n@@ -79,6 +60,16 @@\n-    @Test\n-    @ParameterSupplier\n-    @ParameterSupplier(value=\"testSymlink\", ifNotOS = WINDOWS)\n-    public void test(TestSpec testSpec) throws Exception {\n-        testSpec.test(new ConfigurationTarget(new PackageTest().configureHelloApp()));\n-    }\n+    private static final String TEST_JAVA = \"apps\/PrintEnv.java\";\n+    private static final String TEST_DUKE = \"apps\/dukeplug.png\";\n+    private static final String TEST_DUKE_LINK = \"dukeplugLink.txt\";\n+    private static final String TEST_DIR = \"apps\";\n+    private static final String TEST_BAD = \"non-existant\";\n+\n+    \/\/ On OSX `--app-content` paths will be copied into the \"Contents\" folder\n+    \/\/ of the output app image.\n+    \/\/ \"codesign\" imposes restrictions on the directory structure of \"Contents\" folder.\n+    \/\/ In particular, random files should be placed in \"Contents\/Resources\" folder\n+    \/\/ otherwise \"codesign\" will fail to sign.\n+    \/\/ Need to prepare arguments for `--app-content` accordingly.\n+    private static final boolean copyInResources = TKit.isOSX();\n+\n+    private static final String RESOURCES_DIR = \"Resources\";\n+    private static final String LINKS_DIR = \"Links\";\n@@ -87,4 +78,39 @@\n-    @ParameterSupplier(\"test\")\n-    @ParameterSupplier(value=\"testSymlink\", ifNotOS = WINDOWS)\n-    public void testAppImage(TestSpec testSpec) throws Exception {\n-        testSpec.test(new ConfigurationTarget(JPackageCommand.helloAppImage()));\n+    \/\/ include two files in two options\n+    @Parameter({TEST_JAVA, TEST_DUKE})\n+    \/\/ try to include non-existant content\n+    @Parameter({TEST_JAVA, TEST_BAD})\n+     \/\/ two files in one option and a dir tree in another option.\n+    @Parameter({TEST_JAVA + \",\" + TEST_DUKE, TEST_DIR})\n+     \/\/ include one file and one link to the file\n+    @Parameter(value = {TEST_JAVA, TEST_DUKE_LINK}, ifOS = {MACOS,LINUX})\n+    public void test(String... args) throws Exception {\n+        final List<String> testPathArgs = List.of(args);\n+        final int expectedJPackageExitCode;\n+        if (testPathArgs.contains(TEST_BAD)) {\n+            expectedJPackageExitCode = 1;\n+        } else {\n+            expectedJPackageExitCode = 0;\n+        }\n+\n+        var appContentInitializer = new AppContentInitializer(testPathArgs);\n+\n+        new PackageTest().configureHelloApp()\n+            .addRunOnceInitializer(appContentInitializer::initAppContent)\n+            .addInitializer(appContentInitializer::applyTo)\n+            .addInstallVerifier(cmd -> {\n+                for (String arg : testPathArgs) {\n+                    List<String> paths = Arrays.asList(arg.split(\",\"));\n+                    for (String p : paths) {\n+                        Path name = Path.of(p).getFileName();\n+                        if (isSymlinkPath(name)) {\n+                            TKit.assertSymbolicLinkExists(getAppContentRoot(cmd)\n+                                .resolve(LINKS_DIR).resolve(name));\n+                        } else {\n+                            TKit.assertPathExists(getAppContentRoot(cmd)\n+                                .resolve(name), true);\n+                        }\n+                    }\n+                }\n+            })\n+            .setExpectedExitCode(expectedJPackageExitCode)\n+            .run();\n@@ -94,2 +120,2 @@\n-    @Parameter({\"apps\", \"warning.non.standard.contents.sub.dir\"})\n-    @Parameter({\"apps\/dukeplug.png\", \"warning.app.content.is.not.dir\"})\n+    @Parameter({TEST_DIR, \"warning.non.standard.contents.sub.dir\"})\n+    @Parameter({TEST_DUKE, \"warning.app.content.is.not.dir\"})\n@@ -103,1 +129,0 @@\n-            .setFakeRuntime()\n@@ -108,196 +133,0 @@\n-    public static Collection<Object[]> test() {\n-        return Stream.of(\n-                build().add(TEST_JAVA).add(TEST_DUKE),\n-                build().add(TEST_JAVA).add(TEST_BAD),\n-                build().startGroup().add(TEST_JAVA).add(TEST_DUKE).endGroup().add(TEST_DIR),\n-                \/\/ Same directory specified multiple times.\n-                build().add(TEST_DIR).add(TEST_DIR),\n-                \/\/ Same file specified multiple times.\n-                build().add(TEST_JAVA).add(TEST_JAVA),\n-                \/\/ Two files with the same name but different content.\n-                build()\n-                        .add(createTextFileContent(\"welcome.txt\", \"Welcome\"))\n-                        .add(createTextFileContent(\"welcome.txt\", \"Benvenuti\")),\n-                \/\/ Same name: one is a directory, another is a file.\n-                build().add(createTextFileContent(\"a\/b\/c\/d\", \"Foo\")).add(createTextFileContent(\"a\", \"Bar\")),\n-                \/\/ Same name: one is a file, another is a directory.\n-                build().add(createTextFileContent(\"a\", \"Bar\")).add(createTextFileContent(\"a\/b\/c\/d\", \"Foo\"))\n-        ).map(TestSpec.Builder::create).map(v -> {\n-            return new Object[] {v};\n-        }).toList();\n-    }\n-\n-    public static Collection<Object[]> testSymlink() {\n-        return Stream.of(\n-                build().add(TEST_JAVA)\n-                        .add(new SymlinkContentFactory(\"Links\", \"duke-link\", \"duke-target\"))\n-                        .add(new SymlinkContentFactory(\"\", \"a\/b\/foo-link\", \"c\/bar-target\"))\n-        ).map(TestSpec.Builder::create).map(v -> {\n-            return new Object[] {v};\n-        }).toList();\n-    }\n-\n-    public record TestSpec(List<List<ContentFactory>> contentFactories) {\n-        public TestSpec {\n-            contentFactories.stream().flatMap(List::stream).forEach(Objects::requireNonNull);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return contentFactories.stream().map(group -> {\n-                return group.stream().map(ContentFactory::toString).collect(joining(\",\"));\n-            }).collect(joining(\"; \"));\n-        }\n-\n-        void test(ConfigurationTarget target) {\n-            final int expectedJPackageExitCode;\n-            if (contentFactories.stream().flatMap(List::stream).anyMatch(TEST_BAD::equals)) {\n-                expectedJPackageExitCode = 1;\n-            } else {\n-                expectedJPackageExitCode = 0;\n-            }\n-\n-            final List<List<Content>> allContent = new ArrayList<>();\n-\n-            target.addInitializer(JPackageCommand::setFakeRuntime)\n-            .addRunOnceInitializer(_ -> {\n-                contentFactories.stream().map(group -> {\n-                    return group.stream().map(ContentFactory::create).toList();\n-                }).forEach(allContent::add);\n-            }).addInitializer(cmd -> {\n-                allContent.stream().map(group -> {\n-                    return Stream.of(\"--app-content\", group.stream()\n-                            .map(Content::paths)\n-                            .flatMap(List::stream)\n-                            .map(appContentArg -> {\n-                                if (COPY_IN_RESOURCES && Optional.ofNullable(appContentArg.getParent())\n-                                        .map(Path::getFileName)\n-                                        .map(RESOURCES_DIR::equals)\n-                                        .orElse(false)) {\n-                                    return appContentArg.getParent();\n-                                } else {\n-                                    return appContentArg;\n-                                }\n-                            })\n-                            .map(Path::toString)\n-                            .collect(joining(\",\")));\n-                    }).flatMap(x -> x).forEachOrdered(cmd::addArgument);\n-            });\n-\n-            target.cmd().ifPresent(cmd -> {\n-                if (expectedJPackageExitCode == 0) {\n-                    cmd.executeAndAssertImageCreated();\n-                } else {\n-                    cmd.execute(expectedJPackageExitCode);\n-                }\n-            });\n-\n-            target.addInstallVerifier(cmd -> {\n-                var appContentRoot = getAppContentRoot(cmd);\n-\n-                Set<PathVerifier> disabledVerifiers = new HashSet<>();\n-\n-                var verifiers = allContent.stream().flatMap(List::stream).flatMap(content -> {\n-                    return StreamSupport.stream(content.verifiers(appContentRoot).spliterator(), false).map(verifier -> {\n-                        return new PathVerifierWithOrigin(verifier, content);\n-                    });\n-                }).collect(toMap(PathVerifierWithOrigin::path, x -> x, (first, second) -> {\n-                    \/\/ The same file in the content directory is sourced from multiple origins.\n-                    \/\/ jpackage will handle this case such that the following origins overwrite preceding origins.\n-                    \/\/ Scratch all path verifiers affected by overrides.\n-                    first.getNestedVerifiers(appContentRoot, first.path()).forEach(disabledVerifiers::add);\n-                    return second;\n-                }, TreeMap::new)).values().stream()\n-                        .map(PathVerifierWithOrigin::verifier)\n-                        .filter(Predicate.not(disabledVerifiers::contains))\n-                        .filter(verifier -> {\n-                            if (!(verifier instanceof DirectoryVerifier dirVerifier)) {\n-                                return true;\n-                            } else {\n-                                try {\n-                                    \/\/ Run the directory verifier if the directory is empty.\n-                                    \/\/ Otherwise, it just pollutes the test log.\n-                                    return isDirectoryEmpty(verifier.path());\n-                                } catch (NoSuchFileException ex) {\n-                                    \/\/ If an MSI contains an empty directory, it will be installed but not created when the MSI is unpacked.\n-                                    \/\/ In the latter the control flow will reach this point.\n-                                    if (dirVerifier.isEmpty()\n-                                            && PackageType.WINDOWS.contains(cmd.packageType())\n-                                            && cmd.isPackageUnpacked(String.format(\n-                                                    \"Expected empty directory [%s] is missing\", verifier.path()))) {\n-                                        return false;\n-                                    }\n-                                    throw new UncheckedIOException(ex);\n-                                } catch (IOException ex) {\n-                                    throw new UncheckedIOException(ex);\n-                                }\n-                            }\n-                        })\n-                        .toList();\n-\n-                verifiers.forEach(PathVerifier::verify);\n-            });\n-\n-            target.test().ifPresent(test -> {\n-                test.setExpectedExitCode(expectedJPackageExitCode).run();\n-            });\n-        }\n-\n-        static final class Builder {\n-            TestSpec create() {\n-                return new TestSpec(groups);\n-            }\n-\n-            final class GroupBuilder {\n-                GroupBuilder add(ContentFactory cf) {\n-                    group.add(Objects.requireNonNull(cf));\n-                    return this;\n-                }\n-\n-                Builder endGroup() {\n-                    if (!group.isEmpty()) {\n-                        groups.add(group);\n-                    }\n-                    return Builder.this;\n-                }\n-\n-                private final List<ContentFactory> group = new ArrayList<>();\n-            }\n-\n-            Builder add(ContentFactory cf) {\n-                return startGroup().add(cf).endGroup();\n-            }\n-\n-            GroupBuilder startGroup() {\n-                return new GroupBuilder();\n-            }\n-\n-            private final List<List<ContentFactory>> groups = new ArrayList<>();\n-        }\n-\n-        private record PathVerifierWithOrigin(PathVerifier verifier, Content origin) {\n-            PathVerifierWithOrigin {\n-                Objects.requireNonNull(verifier);\n-                Objects.requireNonNull(origin);\n-            }\n-\n-            Path path() {\n-                return verifier.path();\n-            }\n-\n-            Stream<PathVerifier> getNestedVerifiers(Path appContentRoot, Path path) {\n-                if (!path.startsWith(appContentRoot)) {\n-                    throw new IllegalArgumentException();\n-                }\n-\n-                return StreamSupport.stream(origin.verifiers(appContentRoot).spliterator(), false).filter(v -> {\n-                    return v.path().getNameCount() > path.getNameCount() && v.path().startsWith(path);\n-                });\n-            }\n-        }\n-    }\n-\n-    private static TestSpec.Builder build() {\n-        return new TestSpec.Builder();\n-    }\n-\n@@ -305,2 +134,2 @@\n-        final Path contentDir = cmd.appLayout().contentDirectory();\n-        if (COPY_IN_RESOURCES) {\n+        Path contentDir = cmd.appLayout().contentDirectory();\n+        if (copyInResources) {\n@@ -313,48 +142,2 @@\n-    private static Path createAppContentRoot() {\n-        if (COPY_IN_RESOURCES) {\n-            return TKit.createTempDirectory(\"app-content\").resolve(RESOURCES_DIR);\n-        } else {\n-            return TKit.createTempDirectory(\"app-content\");\n-        }\n-    }\n-\n-    private static boolean isDirectoryEmpty(Path path) throws IOException {\n-        if (Files.exists(path) && !Files.isDirectory(path)) {\n-            throw new IllegalArgumentException();\n-        }\n-\n-        try (var files = Files.list(path)) {\n-            return files.findAny().isEmpty();\n-        }\n-    }\n-\n-    @FunctionalInterface\n-    private interface ContentFactory {\n-        Content create();\n-    }\n-\n-    private interface Content {\n-        List<Path> paths();\n-        Iterable<PathVerifier> verifiers(Path appContentRoot);\n-    }\n-\n-    private sealed interface PathVerifier permits\n-            RegularFileVerifier,\n-            DirectoryVerifier,\n-            SymlinkTargetVerifier,\n-            NoPathVerifier {\n-\n-        Path path();\n-        void verify();\n-    }\n-\n-    private record RegularFileVerifier(Path path, Path srcFile) implements PathVerifier {\n-        RegularFileVerifier {\n-            Objects.requireNonNull(path);\n-            Objects.requireNonNull(srcFile);\n-        }\n-\n-        @Override\n-        public void verify() {\n-            TKit.assertSameFileContent(srcFile, path);\n-        }\n+    private static boolean isSymlinkPath(Path v) {\n+        return v.getFileName().toString().contains(\"Link\");\n@@ -363,3 +146,5 @@\n-    private record DirectoryVerifier(Path path, boolean isEmpty, IdentityWrapper<Content> origin) implements PathVerifier {\n-        DirectoryVerifier {\n-            Objects.requireNonNull(path);\n+    private static final class AppContentInitializer {\n+        AppContentInitializer(List<String> appContentArgs) {\n+            appContentPathGroups = appContentArgs.stream().map(arg -> {\n+                return Stream.of(arg.split(\",\")).map(Path::of).toList();\n+            }).toList();\n@@ -368,7 +153,9 @@\n-        @Override\n-        public void verify() {\n-            if (isEmpty) {\n-                TKit.assertDirectoryEmpty(path);\n-            } else {\n-                TKit.assertDirectoryExists(path);\n-            }\n+        void initAppContent() {\n+            jpackageArgs = appContentPathGroups.stream()\n+                    .map(AppContentInitializer::initAppContentPaths)\n+                    .<String>mapMulti((appContentPaths, consumer) -> {\n+                        consumer.accept(\"--app-content\");\n+                        consumer.accept(\n+                        appContentPaths.stream().map(Path::toString).collect(\n+                                joining(\",\")));\n+                    }).toList();\n@@ -376,1 +163,0 @@\n-    }\n@@ -378,4 +164,2 @@\n-    private record SymlinkTargetVerifier(Path path, Path targetPath) implements PathVerifier {\n-        SymlinkTargetVerifier {\n-            Objects.requireNonNull(path);\n-            Objects.requireNonNull(targetPath);\n+        void applyTo(JPackageCommand cmd) {\n+            cmd.addArguments(jpackageArgs);\n@@ -384,3 +168,6 @@\n-        @Override\n-        public void verify() {\n-            TKit.assertSymbolicLinkTarget(path, targetPath);\n+        private static Path copyAppContentPath(Path appContentPath) throws IOException {\n+            var appContentArg = TKit.createTempDirectory(\"app-content\").resolve(RESOURCES_DIR);\n+            var srcPath = TKit.TEST_SRC_ROOT.resolve(appContentPath);\n+            var dstPath = appContentArg.resolve(srcPath.getFileName());\n+            FileUtils.copyRecursive(srcPath, dstPath);\n+            return appContentArg;\n@@ -388,260 +175,0 @@\n-    }\n-\n-    private record NoPathVerifier(Path path) implements PathVerifier {\n-        NoPathVerifier {\n-            Objects.requireNonNull(path);\n-        }\n-\n-        @Override\n-        public void verify() {\n-            TKit.assertPathExists(path, false);\n-        }\n-    }\n-\n-    private record FileContent(Path path, int level) implements Content {\n-\n-        FileContent {\n-            Objects.requireNonNull(path);\n-            if ((level < 0) || (path.getNameCount() <= level)) {\n-                throw new IllegalArgumentException();\n-            }\n-        }\n-\n-        @Override\n-        public List<Path> paths() {\n-            return List.of(appContentOptionValue());\n-        }\n-\n-        @Override\n-        public Iterable<PathVerifier> verifiers(Path appContentRoot) {\n-            List<PathVerifier> verifiers = new ArrayList<>();\n-\n-            var appContentPath = appContentRoot.resolve(pathInAppContentRoot());\n-\n-            if (Files.isDirectory(path)) {\n-                try (var walk = Files.walk(path)) {\n-                    verifiers.addAll(walk.map(srcFile -> {\n-                        var dstFile = appContentPath.resolve(path.relativize(srcFile));\n-                        if (Files.isRegularFile(srcFile)) {\n-                            return new RegularFileVerifier(dstFile, srcFile);\n-                        } else {\n-                            return new DirectoryVerifier(dstFile,\n-                                    toFunction(AppContentTest::isDirectoryEmpty).apply(srcFile),\n-                                    new IdentityWrapper<>(this));\n-                        }\n-                    }).toList());\n-                } catch (IOException ex) {\n-                    throw new UncheckedIOException(ex);\n-                }\n-            } else if (Files.isRegularFile(path)) {\n-                verifiers.add(new RegularFileVerifier(appContentPath, path));\n-            } else {\n-                verifiers.add(new NoPathVerifier(appContentPath));\n-            }\n-\n-            if (level > 0) {\n-                var cur = appContentPath;\n-                for (int i = 0; i != level; i++) {\n-                    cur = cur.getParent();\n-                    verifiers.add(new DirectoryVerifier(cur, false, new IdentityWrapper<>(this)));\n-                }\n-            }\n-\n-            return verifiers;\n-        }\n-\n-        private Path appContentOptionValue() {\n-            var cur = path;\n-            for (int i = 0; i != level; i++) {\n-                cur = cur.getParent();\n-            }\n-            return cur;\n-        }\n-\n-        private Path pathInAppContentRoot() {\n-            return StreamSupport.stream(path.spliterator(), false)\n-                    .skip(path.getNameCount() - level - 1)\n-                    .reduce(Path::resolve).orElseThrow();\n-        }\n-    }\n-\n-    \/**\n-     * Non-existing content.\n-     *\/\n-    private static final class NonExistantPath implements ContentFactory {\n-        @Override\n-        public Content create() {\n-            var nonExistant = TKit.createTempFile(\"non-existant\");\n-            try {\n-                TKit.deleteIfExists(nonExistant);\n-            } catch (IOException ex) {\n-                throw new UncheckedIOException(ex);\n-            }\n-            return new FileContent(nonExistant, 0);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"*non-existant*\";\n-        }\n-    }\n-\n-    \/**\n-     * Creates a content from a directory tree.\n-     *\n-     * @param path name of directory where to create a directory tree\n-     *\/\n-    private static ContentFactory createDirTreeContent(Path path) {\n-        if (path.isAbsolute()) {\n-            throw new IllegalArgumentException();\n-        }\n-\n-        return new FileContentFactory(() -> {\n-            var basedir = TKit.createTempDirectory(\"content\").resolve(path);\n-\n-            for (var textFile : Map.ofEntries(\n-                    entry(\"woods\/moose\", \"The moose\"),\n-                    entry(\"woods\/bear\", \"The bear\"),\n-                    entry(\"woods\/trees\/jay\", \"The gray jay\")\n-            ).entrySet()) {\n-                var src = basedir.resolve(textFile.getKey());\n-                Files.createDirectories(src.getParent());\n-                TKit.createTextFile(src, Stream.of(textFile.getValue()));\n-            }\n-\n-            for (var emptyDir : List.of(\"sky\")) {\n-                Files.createDirectories(basedir.resolve(emptyDir));\n-            }\n-\n-            return basedir;\n-        }, path);\n-    }\n-\n-    private static ContentFactory createDirTreeContent(String path) {\n-        return createDirTreeContent(Path.of(path));\n-    }\n-\n-    \/**\n-     * Creates a content from a text file.\n-     *\n-     * @param path the path where to copy the text file in app image's content directory\n-     * @param lines the content of the source text file\n-     *\/\n-    private static ContentFactory createTextFileContent(Path path, String ... lines) {\n-        if (path.isAbsolute()) {\n-            throw new IllegalArgumentException();\n-        }\n-\n-        return new FileContentFactory(() -> {\n-            var srcPath = TKit.createTempDirectory(\"content\").resolve(path);\n-            Files.createDirectories(srcPath.getParent());\n-            TKit.createTextFile(srcPath, Stream.of(lines));\n-            return srcPath;\n-        }, path);\n-    }\n-\n-    private static ContentFactory createTextFileContent(String path, String ... lines) {\n-        return createTextFileContent(Path.of(path), lines);\n-    }\n-\n-    \/**\n-     * Symlink content factory.\n-     *\n-     * @path basedir the directory where to write the content in app image's content\n-     *       directory\n-     * @param symlink   the path to the symlink relative to {@code basedir} path\n-     * @param symlinked the path to the source file for the symlink\n-     *\/\n-    private record SymlinkContentFactory(Path basedir, Path symlink, Path symlinked) implements ContentFactory {\n-        SymlinkContentFactory {\n-            for (final var path : List.of(basedir, symlink, symlinked)) {\n-                if (path.isAbsolute()) {\n-                    throw new IllegalArgumentException();\n-                }\n-            }\n-        }\n-\n-        SymlinkContentFactory(String basedir, String symlink, String symlinked) {\n-            this(Path.of(basedir), Path.of(symlink), Path.of(symlinked));\n-        }\n-\n-        @Override\n-        public Content create() {\n-            final var appContentRoot = createAppContentRoot();\n-\n-            final var symlinkPath = appContentRoot.resolve(symlinkPath());\n-            final var symlinkedPath = appContentRoot.resolve(symlinkedPath());\n-            try {\n-                Files.createDirectories(symlinkPath.getParent());\n-                Files.createDirectories(symlinkedPath.getParent());\n-                \/\/ Create the target file for the link.\n-                Files.writeString(symlinkedPath, symlinkedPath().toString());\n-                \/\/ Create the link.\n-                Files.createSymbolicLink(symlinkPath, symlinkTarget());\n-            } catch (IOException ex) {\n-                throw new UncheckedIOException(ex);\n-            }\n-\n-            List<Path> contentPaths;\n-            if (COPY_IN_RESOURCES) {\n-                contentPaths = List.of(appContentRoot);\n-            } else if (basedir.equals(Path.of(\"\"))) {\n-                contentPaths = Stream.of(symlinkPath(), symlinkedPath()).map(path -> {\n-                    return path.getName(0);\n-                }).map(appContentRoot::resolve).toList();\n-            } else {\n-                contentPaths = List.of(appContentRoot.resolve(basedir));\n-            }\n-\n-            return new Content() {\n-                @Override\n-                public List<Path> paths() {\n-                    return contentPaths;\n-                }\n-\n-                @Override\n-                public Iterable<PathVerifier> verifiers(Path appContentRoot) {\n-                    return List.of(\n-                            new RegularFileVerifier(appContentRoot.resolve(symlinkedPath()), symlinkedPath),\n-                            new SymlinkTargetVerifier(appContentRoot.resolve(symlinkPath()), symlinkTarget())\n-                    );\n-                }\n-            };\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return String.format(\"symlink:[%s]->[%s][%s]\", symlinkPath(), symlinkedPath(), symlinkTarget());\n-        }\n-\n-        private Path symlinkPath() {\n-            return basedir.resolve(symlink);\n-        }\n-\n-        private Path symlinkedPath() {\n-            return basedir.resolve(symlinked);\n-        }\n-\n-        private Path symlinkTarget() {\n-            return Optional.ofNullable(symlinkPath().getParent()).map(dir -> {\n-                return dir.relativize(symlinkedPath());\n-            }).orElseGet(this::symlinkedPath);\n-        }\n-    }\n-\n-    private static final class FileContentFactory implements ContentFactory {\n-\n-        FileContentFactory(ThrowingSupplier<Path> factory, Path pathInAppContentRoot) {\n-            this.factory = ThrowingSupplier.toSupplier(factory);\n-            this.pathInAppContentRoot = pathInAppContentRoot;\n-            if (pathInAppContentRoot.isAbsolute()) {\n-                throw new IllegalArgumentException();\n-            }\n-        }\n-\n-        @Override\n-        public Content create() {\n-            Path srcPath = factory.get();\n-            if (!srcPath.endsWith(pathInAppContentRoot)) {\n-                throw new IllegalArgumentException();\n-            }\n@@ -649,0 +176,2 @@\n+        private static Path createAppContentLink(Path appContentPath) throws IOException {\n+            var appContentArg = TKit.createTempDirectory(\"app-content\");\n@@ -650,2 +179,4 @@\n-            if (!COPY_IN_RESOURCES) {\n-                dstPath = srcPath;\n+            if (copyInResources) {\n+                appContentArg = appContentArg.resolve(RESOURCES_DIR);\n+                dstPath = appContentArg.resolve(LINKS_DIR)\n+                                       .resolve(appContentPath.getFileName());\n@@ -653,6 +184,30 @@\n-                var contentDir = createAppContentRoot();\n-                dstPath = contentDir.resolve(pathInAppContentRoot);\n-                try {\n-                    FileUtils.copyRecursive(srcPath, dstPath);\n-                } catch (IOException ex) {\n-                    throw new UncheckedIOException(ex);\n+                appContentArg = appContentArg.resolve(LINKS_DIR);\n+                dstPath = appContentArg.resolve(appContentPath.getFileName());\n+            }\n+\n+            Files.createDirectories(dstPath.getParent());\n+\n+            \/\/ Create target file for a link\n+            String tagetName = dstPath.getFileName().toString().replace(\"Link\", \"\");\n+            Path targetPath = dstPath.getParent().resolve(tagetName);\n+            Files.write(targetPath, \"foo\".getBytes());\n+            \/\/ Create link\n+            Files.createSymbolicLink(dstPath, targetPath.getFileName());\n+\n+            return appContentArg;\n+        }\n+\n+        private static List<Path> initAppContentPaths(List<Path> appContentPaths) {\n+            return appContentPaths.stream().map(appContentPath -> {\n+                if (appContentPath.endsWith(TEST_BAD)) {\n+                    return appContentPath;\n+                } else if (isSymlinkPath(appContentPath)) {\n+                    return ThrowingFunction.toFunction(\n+                            AppContentInitializer::createAppContentLink).apply(\n+                                    appContentPath);\n+                } else if (copyInResources) {\n+                    return ThrowingFunction.toFunction(\n+                            AppContentInitializer::copyAppContentPath).apply(\n+                                    appContentPath);\n+                } else {\n+                    return TKit.TEST_SRC_ROOT.resolve(appContentPath);\n@@ -660,7 +215,1 @@\n-            }\n-            return new FileContent(dstPath, pathInAppContentRoot.getNameCount() - 1);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return pathInAppContentRoot.toString();\n+            }).toList();\n@@ -669,2 +218,2 @@\n-        private final Supplier<Path> factory;\n-        private final Path pathInAppContentRoot;\n+        private List<String> jpackageArgs;\n+        private final List<List<Path>> appContentPathGroups;\n@@ -672,15 +221,0 @@\n-\n-    private static final ContentFactory TEST_JAVA = createTextFileContent(\"apps\/PrintEnv.java\", \"Not what someone would expect\");\n-    private static final ContentFactory TEST_DUKE = createTextFileContent(\"duke.txt\", \"Hi Duke!\");\n-    private static final ContentFactory TEST_DIR = createDirTreeContent(\"apps\");\n-    private static final ContentFactory TEST_BAD = new NonExistantPath();\n-\n-    \/\/ On OSX `--app-content` paths will be copied into the \"Contents\" folder\n-    \/\/ of the output app image.\n-    \/\/ \"codesign\" imposes restrictions on the directory structure of \"Contents\" folder.\n-    \/\/ In particular, random files should be placed in \"Contents\/Resources\" folder\n-    \/\/ otherwise \"codesign\" will fail to sign.\n-    \/\/ Need to prepare arguments for `--app-content` accordingly.\n-    private static final boolean COPY_IN_RESOURCES = TKit.isOSX();\n-\n-    private static final Path RESOURCES_DIR = Path.of(\"Resources\");\n","filename":"test\/jdk\/tools\/jpackage\/share\/AppContentTest.java","additions":130,"deletions":596,"binary":false,"changes":726,"status":"modified"},{"patch":"@@ -1,359 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import static java.util.stream.Collectors.toMap;\n-\n-import java.io.IOException;\n-import java.io.UncheckedIOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.Collection;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.TreeMap;\n-import java.util.function.BiFunction;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-import java.util.stream.Stream;\n-import jdk.jpackage.test.Annotations.Parameter;\n-import jdk.jpackage.test.Annotations.ParameterSupplier;\n-import jdk.jpackage.test.Annotations.Test;\n-import jdk.jpackage.test.AppImageFile;\n-import jdk.jpackage.test.ApplicationLayout;\n-import jdk.jpackage.test.JPackageCommand;\n-import jdk.jpackage.test.TKit;\n-\n-\/*\n- * @test\n- * @summary test order in which jpackage fills app image\n- * @library \/test\/jdk\/tools\/jpackage\/helpers\n- * @build jdk.jpackage.test.*\n- * @compile -Xlint:all -Werror AppImageFillOrderTest.java\n- * @run main\/othervm\/timeout=1440 -Xmx512m\n- *  jdk.jpackage.test.Main\n- *  --jpt-run=AppImageFillOrderTest\n- *\/\n-\n-\/**\n- * Test order in which overlapping items are added to the app image. jpackage\n- * defaults should go first to let user-provided content override them.\n- *\n- * <p>\n- * Custom content comes from:\n- * <ul>\n- * <li>input directory (--input)\n- * <li>app content (--app-content)\n- * <ul>\n- *\/\n-public class AppImageFillOrderTest {\n-\n-    @Test\n-    @ParameterSupplier\n-    public void test(AppImageOverlay overlays[]) {\n-        test(createJPackage().setFakeRuntime(), overlays);\n-    }\n-\n-    \/**\n-     * Test they can override a file in the runtime.\n-     * @param jlink\n-     *\/\n-    @Test\n-    @Parameter(\"true\")\n-    @Parameter(\"false\")\n-    public void testRuntime(boolean jlink) {\n-        var cmd = createJPackage();\n-        if (jlink) {\n-            cmd.ignoreDefaultRuntime(true);\n-        } else {\n-            \/\/ Configure fake runtime and create it.\n-            cmd.setFakeRuntime().executePrerequisiteActions();\n-\n-            var runtimeDir = Path.of(cmd.getArgumentValue(\"--runtime-image\"));\n-            if (!runtimeDir.toAbsolutePath().normalize().startsWith(TKit.workDir().toAbsolutePath().normalize())) {\n-                throw new IllegalStateException(String.format(\n-                        \"Fake runtime [%s] created outside of the test work directory [%s]\",\n-                        runtimeDir, TKit.workDir()));\n-            }\n-\n-            TKit.createTextFile(runtimeDir.resolve(RUNTIME_RELEASE_FILE), List.of(\"Foo release\"));\n-        }\n-\n-        test(cmd, AppImageAppContentOverlay.APP_CONTENT_RUNTIME_RELEASE_FILE);\n-    }\n-\n-    \/**\n-     * Test they can not override .jpackage.xml file.\n-     * @throws IOException\n-     *\/\n-    @Test\n-    public void testAppImageFile() throws IOException {\n-\n-        var cmd = createJPackage().setFakeRuntime();\n-\n-        var outputBundle = cmd.outputBundle();\n-\n-        buildOverlay(cmd, TKit.createTempDirectory(\"app-content\"), AppImageFile.getPathInAppImage(outputBundle))\n-                .textContent(\"This is not a valid XML content\")\n-                .configureCmdOptions().createOverlayFile();\n-\n-        \/\/ Run jpackage and verify it created valid .jpackage.xml file ignoring the overlay.\n-        cmd.executeAndAssertImageCreated();\n-\n-        TKit.trace(String.format(\"Parse [%s] file...\", AppImageFile.getPathInAppImage(outputBundle)));\n-        AppImageFile.load(outputBundle);\n-    }\n-\n-    private static void test(JPackageCommand cmd, AppImageOverlay... overlays) {\n-        if (overlays.length == 0) {\n-            throw new IllegalArgumentException();\n-        }\n-\n-        final var outputDir = Path.of(cmd.getArgumentValue(\"--dest\"));\n-        final var noOverlaysOutputDir = Path.of(outputDir.toString() + \"-no-overlay\");\n-        cmd.setArgumentValue(\"--dest\", noOverlaysOutputDir);\n-\n-        \/\/ Run the command without overlays with redirected output directory.\n-        cmd.execute();\n-\n-        final Optional<Path> appContentRoot;\n-        if (Stream.of(overlays).anyMatch(AppImageAppContentOverlay.class::isInstance)) {\n-            appContentRoot = Optional.of(TKit.createTempDirectory(\"app-content\"));\n-        } else {\n-            appContentRoot = Optional.empty();\n-        }\n-\n-        \/\/ Apply overlays to the command.\n-        var fileCopies = Stream.of(overlays).map(overlay -> {\n-            switch (overlay) {\n-                case AppImageDefaultOverlay v -> {\n-                    return v.addOverlay(cmd);\n-                }\n-                case AppImageAppContentOverlay v -> {\n-                    return v.addOverlay(cmd, appContentRoot.orElseThrow());\n-                }\n-            }\n-        }).flatMap(Collection::stream).collect(toMap(FileCopy::out, x -> x, (a, b) -> {\n-            return b;\n-        }, TreeMap::new)).values().stream().toList();\n-\n-        \/\/ Collect paths in the app image that will be affected by overlays.\n-        var noOverlayOutputPaths = fileCopies.stream().map(FileCopy::out).toList();\n-\n-        fileCopies = fileCopies.stream().map(v -> {\n-            return new FileCopy(v.in(), outputDir.resolve(noOverlaysOutputDir.relativize(v.out())));\n-        }).toList();\n-\n-        \/\/ Restore the original output directory for the command and execute it.\n-        cmd.setArgumentValue(\"--dest\", outputDir).execute();\n-\n-        for (var i = 0; i != fileCopies.size(); i++) {\n-            var noOverlayPath = noOverlayOutputPaths.get(i);\n-            var fc = fileCopies.get(i);\n-            TKit.assertSameFileContent(fc.in(), fc.out());\n-            TKit.assertMismatchFileContent(noOverlayPath, fc.out());\n-        }\n-    }\n-\n-    public static Collection<Object[]> test() {\n-        return Stream.of(\n-\n-                \/\/ Overwrite main launcher .cfg file from the input dir.\n-                List.of(AppImageDefaultOverlay.INPUT_MAIN_LAUNCHER_CFG),\n-\n-                \/\/ Overwrite main launcher .cfg file from the app content dir.\n-                List.of(AppImageAppContentOverlay.APP_CONTENT_MAIN_LAUNCHER_CFG),\n-\n-                \/\/ Overwrite main launcher .cfg file from the input dir and from the app content dir.\n-                \/\/ The one from app content should win.\n-                List.<AppImageOverlay>of(\n-                        AppImageDefaultOverlay.INPUT_MAIN_LAUNCHER_CFG,\n-                        AppImageAppContentOverlay.APP_CONTENT_MAIN_LAUNCHER_CFG\n-                ),\n-\n-                \/\/ Overwrite main jar from the app content dir.\n-                List.of(AppImageAppContentOverlay.APP_CONTENT_MAIN_JAR)\n-        ).map(args -> {\n-            return args.toArray(AppImageOverlay[]::new);\n-        }).map(args -> {\n-            return new Object[] {args};\n-        }).toList();\n-    }\n-\n-\n-    public sealed interface AppImageOverlay {\n-    }\n-\n-\n-    private enum AppImageDefaultOverlay implements AppImageOverlay {\n-        INPUT_MAIN_LAUNCHER_CFG(AppImageFillOrderTest::replaceMainLauncherCfgFile),\n-        ;\n-\n-        AppImageDefaultOverlay(Function<JPackageCommand, FileCopy> func) {\n-            Objects.requireNonNull(func);\n-            this.func = cmd -> {\n-                return List.of(func.apply(cmd));\n-            };\n-        }\n-\n-        Collection<FileCopy> addOverlay(JPackageCommand cmd) {\n-            return func.apply(cmd);\n-        }\n-\n-        private final Function<JPackageCommand, Collection<FileCopy>> func;\n-    }\n-\n-\n-    private enum AppImageAppContentOverlay implements AppImageOverlay {\n-        \/\/ Replace the standard main launcher .cfg file with the custom one from the app content.\n-        APP_CONTENT_MAIN_LAUNCHER_CFG((cmd, appContentRoot) -> {\n-            return buildOverlay(cmd, appContentRoot, cmd.appLauncherCfgPath(null))\n-                    .textContent(\"!Olleh\")\n-                    .configureCmdOptions().createOverlayFile();\n-        }),\n-\n-        \/\/ Replace the jar file that jpackage will pick up from the input directory with the custom one.\n-        APP_CONTENT_MAIN_JAR((cmd, appContentRoot) -> {\n-            return buildOverlay(cmd, appContentRoot, cmd.appLayout().appDirectory().resolve(cmd.getArgumentValue(\"--main-jar\")))\n-                    .textContent(\"Surprise!\")\n-                    .configureCmdOptions().createOverlayFile();\n-        }),\n-\n-        \/\/ Replace \"release\" file in the runtime directory.\n-        APP_CONTENT_RUNTIME_RELEASE_FILE((cmd, appContentRoot) -> {\n-            return buildOverlay(cmd, appContentRoot, cmd.appLayout().runtimeHomeDirectory().resolve(\"release\"))\n-                    .textContent(\"blob\")\n-                    .configureCmdOptions().createOverlayFile();\n-        }),\n-        ;\n-\n-        AppImageAppContentOverlay(BiFunction<JPackageCommand, Path, FileCopy> func) {\n-            Objects.requireNonNull(func);\n-            this.func = (cmd, appContentRoot) -> {\n-                return List.of(func.apply(cmd, appContentRoot));\n-            };\n-        }\n-\n-        Collection<FileCopy> addOverlay(JPackageCommand cmd, Path appContentRoot) {\n-            return func.apply(cmd, appContentRoot);\n-        }\n-\n-        private final BiFunction<JPackageCommand, Path, Collection<FileCopy>> func;\n-    }\n-\n-\n-    private record FileCopy(Path in, Path out) {\n-        FileCopy {\n-            Objects.requireNonNull(in);\n-            Objects.requireNonNull(out);\n-        }\n-    }\n-\n-\n-    private static FileCopy replaceMainLauncherCfgFile(JPackageCommand cmd) {\n-        \/\/ Replace the standard main launcher .cfg file with the custom one from the input dir.\n-        final var outputFile = cmd.appLauncherCfgPath(null);\n-\n-        final var inputDir = Path.of(cmd.getArgumentValue(\"--input\"));\n-\n-        final var file = inputDir.resolve(outputFile.getFileName());\n-\n-        TKit.createTextFile(file, List.of(\"Hello!\"));\n-\n-        return new FileCopy(file, outputFile);\n-    }\n-\n-    private static AppContentOverlayFileBuilder buildOverlay(JPackageCommand cmd, Path appContentRoot, Path outputFile) {\n-        return new AppContentOverlayFileBuilder(cmd, appContentRoot, outputFile);\n-    }\n-\n-\n-    private static final class AppContentOverlayFileBuilder {\n-\n-        AppContentOverlayFileBuilder(JPackageCommand cmd, Path appContentRoot, Path outputFile) {\n-            if (outputFile.isAbsolute()) {\n-                throw new IllegalArgumentException();\n-            }\n-\n-            if (!outputFile.startsWith(cmd.outputBundle())) {\n-                throw new IllegalArgumentException();\n-            }\n-\n-            this.cmd = Objects.requireNonNull(cmd);\n-            this.outputFile = Objects.requireNonNull(outputFile);\n-            this.appContentRoot = Objects.requireNonNull(appContentRoot);\n-        }\n-\n-        FileCopy createOverlayFile() {\n-            final var file = appContentRoot.resolve(pathInAppContentDirectory());\n-\n-            try {\n-                Files.createDirectories(file.getParent());\n-            } catch (IOException ex) {\n-                throw new UncheckedIOException(ex);\n-            }\n-            fileContentInitializer.accept(file);\n-\n-            return new FileCopy(file, outputFile);\n-        }\n-\n-        AppContentOverlayFileBuilder configureCmdOptions() {\n-            cmd.addArguments(\"--app-content\", appContentRoot.resolve(pathInAppContentDirectory().getName(0)));\n-            return this;\n-        }\n-\n-        AppContentOverlayFileBuilder content(Consumer<Path> v) {\n-            fileContentInitializer = v;\n-            return this;\n-        }\n-\n-        AppContentOverlayFileBuilder textContent(String... lines) {\n-            return content(path -> {\n-                TKit.createTextFile(path, List.of(lines));\n-            });\n-        }\n-\n-        private Path pathInAppContentDirectory() {\n-            return APP_IMAGE_LAYOUT.resolveAt(cmd.outputBundle()).contentDirectory().relativize(outputFile);\n-        }\n-\n-        private Consumer<Path> fileContentInitializer;\n-        private final JPackageCommand cmd;\n-        private final Path outputFile;\n-        private final Path appContentRoot;\n-    }\n-\n-\n-    private static JPackageCommand createJPackage() {\n-        \/\/ With short name.\n-        var cmd = JPackageCommand.helloAppImage().setArgumentValue(\"--name\", \"Foo\");\n-\n-        \/\/ Clean leftovers in the input dir from the previous test run if any.\n-        TKit.deleteDirectoryContentsRecursive(cmd.inputDir());\n-\n-        return cmd;\n-    }\n-\n-    private static final ApplicationLayout APP_IMAGE_LAYOUT = ApplicationLayout.platformAppImage();\n-    private static final Path RUNTIME_RELEASE_FILE = Path.of(\"release\");\n-}\n","filename":"test\/jdk\/tools\/jpackage\/share\/AppImageFillOrderTest.java","additions":0,"deletions":359,"binary":false,"changes":359,"status":"deleted"},{"patch":"@@ -24,2 +24,0 @@\n-import java.io.IOException;\n-import java.nio.file.Files;\n@@ -27,1 +25,3 @@\n-import java.util.function.Predicate;\n+import java.nio.file.Files;\n+import java.io.IOException;\n+import java.util.List;\n@@ -29,2 +29,0 @@\n-import jdk.jpackage.test.Annotations.Parameter;\n-import jdk.jpackage.test.Annotations.Test;\n@@ -32,0 +30,1 @@\n+import jdk.jpackage.test.Annotations.Parameter;\n@@ -33,0 +32,1 @@\n+import jdk.jpackage.test.TKit;\n@@ -34,1 +34,0 @@\n-import jdk.jpackage.test.JPackageCommand.StandardAssert;\n@@ -38,1 +37,1 @@\n-import jdk.jpackage.test.TKit;\n+import jdk.jpackage.test.Annotations.Test;\n@@ -59,3 +58,0 @@\n-    \/**\n-     * Create a native bundle from a valid predefined app image produced by jpackage.\n-     *\/\n@@ -64,0 +60,1 @@\n+        Path appimageOutput = TKit.workDir().resolve(\"appimage\");\n@@ -65,2 +62,2 @@\n-        var appImageCmd = JPackageCommand.helloAppImage()\n-                .setArgumentValue(\"--dest\", TKit.createTempDirectory(\"appimage\"));\n+        JPackageCommand appImageCmd = JPackageCommand.helloAppImage()\n+                .setArgumentValue(\"--dest\", appimageOutput);\n@@ -69,1 +66,1 @@\n-        .addRunOnceInitializer(appImageCmd::execute)\n+        .addRunOnceInitializer(() -> appImageCmd.execute())\n@@ -76,7 +73,0 @@\n-    \/**\n-     * Create a native bundle from a predefined app image not produced by jpackage\n-     * but having a valid \".jpackage.xml\" file.\n-     *\n-     * @param withIcon {@code true} if jpackage command line should have \"--icon\"\n-     *                 option\n-     *\/\n@@ -87,0 +77,3 @@\n+        final String name = \"EmptyAppImagePackageTest\";\n+        final String imageName = name + (TKit.isOSX() ? \".app\" : \"\");\n+        Path appImageDir = TKit.createTempDirectory(\"appimage\").resolve(imageName);\n@@ -88,4 +81,4 @@\n-        var appImageCmd = JPackageCommand.helloAppImage()\n-                .setFakeRuntime()\n-                .setArgumentValue(\"--name\", \"EmptyAppImagePackageTest\")\n-                .setArgumentValue(\"--dest\", TKit.createTempDirectory(\"appimage\"));\n+        Files.createDirectories(appImageDir.resolve(\"bin\"));\n+        Path libDir = Files.createDirectories(appImageDir.resolve(\"lib\"));\n+        TKit.createTextFile(libDir.resolve(\"README\"),\n+                List.of(\"This is some arbitrary text for the README file\\n\"));\n@@ -94,25 +87,0 @@\n-        .addRunOnceInitializer(appImageCmd::execute)\n-        .addRunOnceInitializer(() -> {\n-            var layout = appImageCmd.appLayout();\n-            if (!TKit.isOSX()) {\n-                \/\/ Delete the launcher if not on macOS.\n-                \/\/ On macOS, deleting the launcher will render the app bundle invalid.\n-                TKit.deleteIfExists(appImageCmd.appLauncherPath());\n-            }\n-            \/\/ Delete the runtime.\n-            TKit.deleteDirectoryRecursive(layout.runtimeDirectory());\n-            \/\/ Delete the \"app\" dir.\n-            TKit.deleteDirectoryRecursive(layout.appDirectory());\n-\n-            new AppImageFile(appImageCmd.name(), \"PhonyMainClass\").save(appImageCmd.outputBundle());\n-            var appImageDir = appImageCmd.outputBundle();\n-\n-            TKit.trace(String.format(\"Files in [%s] app image:\", appImageDir));\n-            try (var files = Files.walk(appImageDir)) {\n-                files.sequential()\n-                        .filter(Predicate.isEqual(appImageDir).negate())\n-                        .map(path -> String.format(\"[%s]\", appImageDir.relativize(path)))\n-                        .forEachOrdered(TKit::trace);\n-                TKit.trace(\"Done\");\n-            }\n-        })\n@@ -120,1 +88,1 @@\n-            cmd.addArguments(\"--app-image\", appImageCmd.outputBundle());\n+            cmd.addArguments(\"--app-image\", appImageDir);\n@@ -125,0 +93,1 @@\n+            new AppImageFile(\"EmptyAppImagePackageTest\", \"Hello\").save(appImageDir);\n@@ -126,5 +95,5 @@\n-            cmd.excludeStandardAsserts(\n-                    StandardAssert.MAIN_JAR_FILE,\n-                    StandardAssert.MAIN_LAUNCHER_FILES,\n-                    StandardAssert.MAC_BUNDLE_STRUCTURE,\n-                    StandardAssert.RUNTIME_DIRECTORY);\n+            \/\/ on mac, with --app-image and without --mac-package-identifier,\n+            \/\/ will try to infer it from the image, so foreign image needs it.\n+            if (TKit.isOSX()) {\n+                cmd.addArguments(\"--mac-package-identifier\", name);\n+            }\n@@ -132,1 +101,5 @@\n-        .run(Action.CREATE_AND_UNPACK);\n+        \/\/ On macOS we always signing app image and signing will fail, since\n+        \/\/ test produces invalid app bundle.\n+        .setExpectedExitCode(TKit.isOSX() ? 1 : 0)\n+        .run(Action.CREATE, Action.UNPACK);\n+        \/\/ default: {CREATE, UNPACK, VERIFY}, but we can't verify foreign image\n@@ -135,4 +108,0 @@\n-    \/**\n-     * Bad predefined app image - not an output of jpackage.\n-     * jpackage command using the bad predefined app image doesn't have \"--name\" option.\n-     *\/\n@@ -148,3 +117,0 @@\n-    \/**\n-     * Bad predefined app image - not an output of jpackage.\n-     *\/\n@@ -158,3 +124,0 @@\n-    \/**\n-     * Bad predefined app image - valid app image missing \".jpackage.xml\" file.\n-     *\/\n@@ -162,1 +125,1 @@\n-    public static void testBadAppImage3() {\n+    public static void testBadAppImage3() throws IOException {\n@@ -174,3 +137,0 @@\n-    \/**\n-     * Bad predefined app image - valid app image with invalid \".jpackage.xml\" file.\n-     *\/\n@@ -178,1 +138,1 @@\n-    public static void testBadAppImageFile() {\n+    public static void testBadAppImageFile() throws IOException {\n","filename":"test\/jdk\/tools\/jpackage\/share\/AppImagePackageTest.java","additions":31,"deletions":71,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -24,1 +24,0 @@\n-import static java.util.Map.entry;\n@@ -28,1 +27,0 @@\n-import java.util.List;\n@@ -30,1 +28,0 @@\n-import java.util.TreeMap;\n@@ -120,3 +117,3 @@\n-            TKit.createPropertiesFile(propFile, List.of(\n-                    entry(\"extension\", \"foo\"),\n-                    entry(\"description\", \"bar\")\n+            TKit.createPropertiesFile(propFile, Map.of(\n+                \"extension\", \"foo\",\n+                \"description\", \"bar\"\n@@ -137,4 +134,4 @@\n-            TKit.createPropertiesFile(propFile, List.of(\n-                    entry(\"mime-type\", \"application\/x-jpackage-foo, application\/x-jpackage-bar\"),\n-                    entry(\"extension\", \"foo\"),\n-                    entry(\"description\", \"bar\")\n+            TKit.createPropertiesFile(propFile, Map.of(\n+                \"mime-type\", \"application\/x-jpackage-foo, application\/x-jpackage-bar\",\n+                \"extension\", \"foo\",\n+                \"description\", \"bar\"\n","filename":"test\/jdk\/tools\/jpackage\/share\/FileAssociationsTest.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -24,2 +24,0 @@\n-import static jdk.jpackage.test.AdditionalLauncher.getAdditionalLauncherProperties;\n-\n@@ -27,1 +25,3 @@\n-import java.io.UncheckedIOException;\n+import java.util.stream.Stream;\n+import java.util.stream.Collectors;\n+import java.util.function.Consumer;\n@@ -35,1 +35,0 @@\n-import java.util.Objects;\n@@ -38,11 +37,1 @@\n-import java.util.TreeMap;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-import jdk.jpackage.internal.util.function.ThrowingBiConsumer;\n-import jdk.jpackage.internal.util.function.ThrowingConsumer;\n-import jdk.jpackage.test.AdditionalLauncher;\n-import jdk.jpackage.test.Annotations.Parameters;\n-import jdk.jpackage.test.Annotations.Test;\n-import jdk.jpackage.test.CannedFormattedString;\n-import jdk.jpackage.test.ConfigurationTarget;\n-import jdk.jpackage.test.Executor;\n+import jdk.jpackage.test.TKit;\n@@ -50,1 +39,0 @@\n-import jdk.jpackage.test.JPackageStringBundle;\n@@ -52,1 +40,0 @@\n-import jdk.jpackage.test.LinuxHelper;\n@@ -54,1 +41,7 @@\n-import jdk.jpackage.test.TKit;\n+import jdk.jpackage.test.Executor;\n+import jdk.jpackage.test.LinuxHelper;\n+import jdk.jpackage.test.AdditionalLauncher;\n+import jdk.jpackage.internal.util.function.ThrowingConsumer;\n+import jdk.jpackage.internal.util.function.ThrowingBiConsumer;\n+import jdk.jpackage.test.Annotations.Parameters;\n+import jdk.jpackage.test.Annotations.Test;\n@@ -102,1 +95,1 @@\n-        config = new TreeMap<>(Map.of(\n+        config = Map.of(\n@@ -104,1 +97,1 @@\n-                Launcher.Additional, additionalLauncherIconType));\n+                Launcher.Additional, additionalLauncherIconType);\n@@ -111,1 +104,1 @@\n-        config = new TreeMap<>(Map.of(\n+        config = Map.of(\n@@ -113,1 +106,1 @@\n-                Launcher.Additional, additionalLauncherIconType));\n+                Launcher.Additional, additionalLauncherIconType);\n@@ -168,2 +161,0 @@\n-\n-        final ConfigurationTarget target;\n@@ -171,1 +162,4 @@\n-            target = new ConfigurationTarget(JPackageCommand.helloAppImage());\n+            JPackageCommand cmd = initAppImageTest();\n+            var result = cmd.executeAndAssertImageCreated();\n+            ThrowingConsumer.toConsumer(createInstallVerifier()).accept(cmd);\n+            ThrowingBiConsumer.toBiConsumer(createBundleVerifier()).accept(cmd, result);\n@@ -173,7 +167,3 @@\n-            target = new ConfigurationTarget(new PackageTest().configureHelloApp());\n-        }\n-\n-        initTest(target);\n-\n-        var installVerifier = createInstallVerifier();\n-        var bundleVerifier = createBundleVerifier();\n+            PackageTest test = initPackageTest();\n+            test.addInstallVerifier(createInstallVerifier());\n+            test.addBundleVerifier(createBundleVerifier());\n@@ -181,8 +171,0 @@\n-        var cmdResult = target.cmd().map(JPackageCommand::executeAndAssertImageCreated);\n-\n-        target.apply(ThrowingConsumer.toConsumer(installVerifier), test -> {\n-            test.addInstallVerifier(installVerifier);\n-        }).apply(cmd -> {\n-            ThrowingBiConsumer.toBiConsumer(bundleVerifier).accept(cmd, cmdResult.orElseThrow());\n-        }, test -> {\n-            test.addBundleVerifier(bundleVerifier);\n@@ -191,1 +173,0 @@\n-        });\n@@ -193,3 +174,2 @@\n-        target.test().ifPresent(v -> {\n-            v.run(PackageTest.Action.CREATE_AND_UNPACK);\n-        });\n+            test.run(PackageTest.Action.CREATE_AND_UNPACK);\n+        }\n@@ -199,0 +179,3 @@\n+        if (appImage) {\n+            return false;\n+        }\n@@ -208,2 +191,11 @@\n-            Stream.of(Launcher.Main, Launcher.Additional).filter(config::containsKey).forEach(launcher -> {\n-                createConsoleOutputVerifier(cmd, launcher).ifPresent(verifier -> {\n+            var verifier = createConsoleOutputVerifier(cmd.name(), config.get(\n+                    Launcher.Main), null);\n+            if (verifier != null) {\n+                verifier.apply(result.getOutput());\n+            }\n+\n+            if (config.containsKey(Launcher.Additional)) {\n+                verifier = createConsoleOutputVerifier(\n+                        Launcher.Additional.launcherName, config.get(\n+                                Launcher.Additional), config.get(Launcher.Main));\n+                if (verifier != null) {\n@@ -211,2 +203,2 @@\n-                });\n-            });\n+                }\n+            }\n@@ -216,14 +208,4 @@\n-    private Optional<TKit.TextStreamVerifier> createConsoleOutputVerifier(\n-            JPackageCommand cmd, Launcher launcher) {\n-\n-        var launcherName = Optional.ofNullable(launcher.launcherName).orElseGet(cmd::name);\n-        var resourceName = launcherName;\n-        Optional<Path> customIcon;\n-\n-        if (launcherName.equals(cmd.name())) {\n-            customIcon = Optional.ofNullable(cmd.getArgumentValue(\"--icon\")).map(Path::of);\n-        } else if (config.get(launcher) == IconType.DefaultIcon) {\n-            resourceName = cmd.name();\n-            customIcon = Optional.ofNullable(cmd.getArgumentValue(\"--icon\")).map(Path::of);\n-        } else {\n-            customIcon = getAdditionalLauncherProperties(cmd, launcherName).findProperty(\"icon\").map(Path::of);\n+    private TKit.TextStreamVerifier createConsoleOutputVerifier(\n+            String launcherName, IconType iconType, IconType mainIconType) {\n+        if (iconType == IconType.DefaultIcon && mainIconType != null) {\n+            iconType = mainIconType;\n@@ -231,6 +213,1 @@\n-\n-        return createConsoleOutputVerifier(\n-                getBundleIconType(cmd, launcher),\n-                launcherName,\n-                resourceName,\n-                customIcon);\n+        return createConsoleOutputVerifier(launcherName, iconType);\n@@ -239,9 +216,3 @@\n-    private static Optional<TKit.TextStreamVerifier> createConsoleOutputVerifier(\n-            IconType iconType, String launcherName, String resourceName, Optional<Path> customIcon) {\n-\n-        Objects.requireNonNull(launcherName);\n-        Objects.requireNonNull(resourceName);\n-        Objects.requireNonNull(customIcon);\n-\n-        CannedFormattedString lookupString;\n-\n+    private static TKit.TextStreamVerifier createConsoleOutputVerifier(\n+            String launcherName, IconType iconType) {\n+        String lookupString = null;\n@@ -250,2 +221,2 @@\n-                lookupString = JPackageStringBundle.MAIN.cannedFormattedString(\n-                        \"message.using-default-resource\",\n+                lookupString = String.format(\n+                        \"Using default package resource %s [icon] (add %s%s to the resource-dir to customize)\",\n@@ -253,2 +224,1 @@\n-                        \"[icon]\",\n-                        launcherName + TKit.ICON_SUFFIX);\n+                        launcherName, TKit.ICON_SUFFIX);\n@@ -258,4 +228,3 @@\n-                lookupString = JPackageStringBundle.MAIN.cannedFormattedString(\n-                        \"message.using-custom-resource\",\n-                        \"[icon]\",\n-                        resourceName + TKit.ICON_SUFFIX);\n+                lookupString = String.format(\n+                        \"Using custom package resource [icon] (loaded from %s%s)\",\n+                        launcherName, TKit.ICON_SUFFIX);\n@@ -266,4 +235,1 @@\n-                lookupString = JPackageStringBundle.MAIN.cannedFormattedString(\n-                        \"message.using-custom-resource-from-file\",\n-                        \"[icon]\",\n-                        customIcon.orElseThrow());\n+                lookupString = \"Using custom package resource [icon] (loaded from file\";\n@@ -273,1 +239,1 @@\n-                return Optional.empty();\n+                return null;\n@@ -276,1 +242,1 @@\n-        return Optional.of(TKit.assertTextStream(lookupString.getValue()));\n+        return TKit.assertTextStream(lookupString);\n@@ -280,9 +246,5 @@\n-        return cmd -> {\n-            var verifier = new LauncherIconVerifier();\n-\n-            var bundleIconType = getBundleIconType(cmd, Launcher.Main);\n-\n-            switch (bundleIconType) {\n-                case NoIcon:\n-                    verifier.setExpectedNoIcon();\n-                    break;\n+        LauncherIconVerifier verifier = new LauncherIconVerifier();\n+        switch (config.get(Launcher.Main)) {\n+            case NoIcon:\n+                verifier.setExpectedIcon(null);\n+                break;\n@@ -290,3 +252,3 @@\n-                case DefaultIcon:\n-                    verifier.setExpectedDefaultIcon();\n-                    break;\n+            case DefaultIcon:\n+                verifier.setExpectedDefaultIcon();\n+                break;\n@@ -294,3 +256,3 @@\n-                case CustomIcon:\n-                    verifier.setExpectedIcon(Launcher.Main.cmdlineIcon);\n-                    break;\n+            case CustomIcon:\n+                verifier.setExpectedIcon(Launcher.Main.cmdlineIcon);\n+                break;\n@@ -298,3 +260,3 @@\n-                case ResourceDirIcon:\n-                    verifier.setExpectedIcon(Launcher.Main.resourceDirIcon);\n-                    break;\n+            case ResourceDirIcon:\n+                verifier.setExpectedIcon(Launcher.Main.resourceDirIcon);\n+                break;\n@@ -302,4 +264,4 @@\n-                case CustomWithResourceDirIcon:\n-                    verifier.setExpectedIcon(Launcher.Main2.cmdlineIcon);\n-                    break;\n-            }\n+            case CustomWithResourceDirIcon:\n+                verifier.setExpectedIcon(Launcher.Main2.cmdlineIcon);\n+                break;\n+        }\n@@ -307,0 +269,1 @@\n+        return cmd -> {\n@@ -308,1 +271,0 @@\n-\n@@ -311,1 +273,1 @@\n-                if (isWithDesktopIntegration(bundleIconType)) {\n+                if (isWithDesktopIntegration(config.get(Launcher.Main))) {\n@@ -320,1 +282,1 @@\n-    private void initTest(ConfigurationTarget target) {\n+    private void initTest(JPackageCommand cmd, PackageTest test) {\n@@ -322,1 +284,1 @@\n-            initTest(entry.getKey(), entry.getValue(), target);\n+            initTest(entry.getKey(), entry.getValue(), cmd, test);\n@@ -325,5 +287,11 @@\n-        target.addInitializer(cmd -> {\n-            cmd.saveConsoleOutput(true);\n-            cmd.setFakeRuntime();\n-            cmd.addArguments(extraJPackageArgs);\n-        });\n+        ThrowingConsumer<JPackageCommand> initializer = testCmd -> {\n+            testCmd.saveConsoleOutput(true);\n+            testCmd.setFakeRuntime();\n+            testCmd.addArguments(extraJPackageArgs);\n+        };\n+\n+        if (test != null) {\n+            test.addInitializer(initializer);\n+        } else {\n+            ThrowingConsumer.toConsumer(initializer).accept(cmd);\n+        }\n@@ -333,1 +301,8 @@\n-            ConfigurationTarget target) throws IOException {\n+            JPackageCommand cmd, PackageTest test) throws IOException {\n+        Consumer<AdditionalLauncher> addLauncher = v -> {\n+            if (test != null) {\n+                v.applyTo(test);\n+            } else {\n+                v.applyTo(cmd);\n+            }\n+        };\n@@ -337,2 +312,3 @@\n-                Optional.ofNullable(cfg.launcherName).map(AdditionalLauncher::new)\n-                        .ifPresent(target::add);\n+                if (cfg.launcherName != null) {\n+                    addLauncher.accept(new AdditionalLauncher(cfg.launcherName));\n+                }\n@@ -342,3 +318,4 @@\n-                Optional.ofNullable(cfg.launcherName).map(AdditionalLauncher::new)\n-                        .map(AdditionalLauncher::setNoIcon)\n-                        .ifPresent(target::add);\n+                if (cfg.launcherName != null) {\n+                    addLauncher.accept(\n+                            new AdditionalLauncher(cfg.launcherName).setNoIcon());\n+                }\n@@ -348,1 +325,5 @@\n-                addCustomIcon(target, cfg.launcherName, cfg.cmdlineIcon);\n+                if (test != null) {\n+                    addCustomIcon(null, test, cfg.launcherName, cfg.cmdlineIcon);\n+                } else {\n+                    addCustomIcon(cmd, null, cfg.launcherName, cfg.cmdlineIcon);\n+                }\n@@ -352,3 +333,10 @@\n-                if (Launcher.PRIMARY.contains(cfg)) {\n-                    Optional.ofNullable(cfg.launcherName).map(AdditionalLauncher::new)\n-                            .ifPresent(target::add);\n+                if (Launcher.PRIMARY.contains(cfg) && cfg.launcherName != null) {\n+                    addLauncher.accept(new AdditionalLauncher(cfg.launcherName));\n+                }\n+                if (test != null) {\n+                    test.addInitializer(testCmd -> {\n+                        addResourceDirIcon(testCmd, cfg.launcherName,\n+                                cfg.resourceDirIcon);\n+                    });\n+                } else {\n+                    addResourceDirIcon(cmd, cfg.launcherName, cfg.resourceDirIcon);\n@@ -356,7 +344,0 @@\n-                target.addInitializer(cmd -> {\n-                    try {\n-                        addResourceDirIcon(cmd, cfg.launcherName, cfg.resourceDirIcon);\n-                    } catch (IOException ex) {\n-                        throw new UncheckedIOException(ex);\n-                    }\n-                });\n@@ -368,2 +349,2 @@\n-                        initTest(Launcher.Main2, IconType.CustomIcon, target);\n-                        initTest(Launcher.Main2, IconType.ResourceDirIcon, target);\n+                        initTest(Launcher.Main2, IconType.CustomIcon, cmd, test);\n+                        initTest(Launcher.Main2, IconType.ResourceDirIcon, cmd, test);\n@@ -373,2 +354,2 @@\n-                        initTest(Launcher.Additional2, IconType.CustomIcon, target);\n-                        initTest(Launcher.Additional2, IconType.ResourceDirIcon, target);\n+                        initTest(Launcher.Additional2, IconType.CustomIcon, cmd, test);\n+                        initTest(Launcher.Additional2, IconType.ResourceDirIcon, cmd, test);\n@@ -384,2 +365,4 @@\n-    private IconType getBundleIconType(JPackageCommand cmd, Launcher launcher) {\n-        return getBundleIconType(cmd, config.get(Launcher.Main), launcher, config.get(launcher));\n+    private JPackageCommand initAppImageTest() {\n+        JPackageCommand cmd = JPackageCommand.helloAppImage();\n+        initTest(cmd, null);\n+        return cmd;\n@@ -388,25 +371,4 @@\n-    \/**\n-     * Returns the expected icon type of the given launcher in the output bundle\n-     * that the given jpackage command line will output based on the icon type\n-     * configured for the launcher.\n-     *\n-     * @param cmd                  jpackage command line\n-     * @param mainLauncherIconType the icon type configured for the main launcher\n-     * @param launcher             the launcher\n-     * @param iconType             the icon type configured for the specified\n-     *                             launcher\n-     * @return the type of of an icon of the given launcher in the output bundle\n-     *\/\n-    private static IconType getBundleIconType(JPackageCommand cmd,\n-            IconType mainLauncherIconType, Launcher launcher, IconType iconType) {\n-\n-        Objects.requireNonNull(cmd);\n-        Objects.requireNonNull(mainLauncherIconType);\n-        Objects.requireNonNull(launcher);\n-        Objects.requireNonNull(iconType);\n-\n-        if (iconType == IconType.DefaultIcon) {\n-            iconType = mainLauncherIconType;\n-        }\n-\n-        return iconType;\n+    private PackageTest initPackageTest() {\n+        PackageTest test = new PackageTest().configureHelloApp();\n+        initTest(null, test);\n+        return test;\n@@ -417,5 +379,6 @@\n-        var resourceDir = Optional.ofNullable(cmd.getArgumentValue(\"--resource-dir\")).map(Path::of).orElseGet(() -> {\n-            return TKit.createTempDirectory(\"resources\");\n-        });\n-\n-        cmd.addArguments(\"--resource-dir\", resourceDir);\n+        Path resourceDir = cmd.getArgumentValue(\"--resource-dir\", () -> null,\n+                Path::of);\n+        if (resourceDir == null) {\n+            resourceDir = TKit.createTempDirectory(\"resources\");\n+            cmd.addArguments(\"--resource-dir\", resourceDir);\n+        }\n@@ -423,1 +386,2 @@\n-        String dstIconFileName = Optional.ofNullable(launcherName).orElseGet(cmd::name) + TKit.ICON_SUFFIX;\n+        String dstIconFileName = Optional.ofNullable(launcherName).orElseGet(\n+                () -> cmd.name()) + TKit.ICON_SUFFIX;\n@@ -431,2 +395,2 @@\n-    private static void addCustomIcon(ConfigurationTarget target,\n-            String launcherName, Path iconPath) {\n+    private static void addCustomIcon(JPackageCommand cmd, PackageTest test,\n+            String launcherName, Path iconPath) throws IOException {\n@@ -435,5 +399,10 @@\n-            var al = new AdditionalLauncher(launcherName).setIcon(iconPath);\n-            target.apply(al::applyTo, al::applyTo);\n-        } else {\n-            target.addInitializer(cmd -> {\n-                cmd.addArguments(\"--icon\", iconPath);\n+            AdditionalLauncher al = new AdditionalLauncher(launcherName).setIcon(\n+                    iconPath);\n+            if (test != null) {\n+                al.applyTo(test);\n+            } else {\n+                al.applyTo(cmd);\n+            }\n+        } else if (test != null) {\n+            test.addInitializer(testCmd -> {\n+                testCmd.addArguments(\"--icon\", iconPath);\n@@ -441,0 +410,2 @@\n+        } else {\n+            cmd.addArguments(\"--icon\", iconPath);\n","filename":"test\/jdk\/tools\/jpackage\/share\/IconTest.java","additions":154,"deletions":183,"binary":false,"changes":337,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-import jdk.jpackage.test.JPackageCommand.StandardAssert;\n+import jdk.jpackage.test.JPackageCommand.AppLayoutAssert;\n@@ -180,1 +180,1 @@\n-                cmd.excludeStandardAsserts(StandardAssert.APP_IMAGE_FILE);\n+                cmd.excludeAppLayoutAsserts(AppLayoutAssert.APP_IMAGE_FILE);\n","filename":"test\/jdk\/tools\/jpackage\/share\/InOutPathTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -211,1 +211,1 @@\n-                expectedLicensePath)).findFirst().isPresent(),\n+                expectedLicensePath)).findFirst().orElse(null) != null,\n","filename":"test\/jdk\/tools\/jpackage\/share\/LicenseTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -138,1 +138,5 @@\n-            var dest = cmd.appLayout().runtimeHomeDirectory();\n+            Path dest = cmd.appRuntimeDirectory();\n+            if (TKit.isOSX()) {\n+                dest = dest.resolve(\"Contents\/Home\");\n+            }\n+\n","filename":"test\/jdk\/tools\/jpackage\/share\/RuntimePackageTest.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -24,2 +24,0 @@\n-import static jdk.jpackage.test.WindowsHelper.killAppLauncherProcess;\n-\n@@ -29,0 +27,3 @@\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import jdk.jpackage.test.JPackageCommand;\n@@ -32,1 +33,1 @@\n-import jdk.jpackage.test.JPackageCommand;\n+import static jdk.jpackage.test.WindowsHelper.killAppLauncherProcess;\n@@ -95,4 +96,5 @@\n-            \/\/ Launch the app in a separate thread\n-            new Thread(() -> {\n-                HelloApp.executeLauncher(cmd);\n-            }).start();\n+            try ( \/\/ Launch the app in a separate thread\n+                ExecutorService exec = Executors.newSingleThreadExecutor()) {\n+                exec.execute(() -> {\n+                    HelloApp.executeLauncher(cmd);\n+                });\n@@ -100,2 +102,2 @@\n-            \/\/ Wait a bit to let the app start\n-            Thread.sleep(Duration.ofSeconds(10));\n+                \/\/ Wait a bit to let the app start\n+                Thread.sleep(Duration.ofSeconds(10));\n@@ -103,2 +105,3 @@\n-            \/\/ Find the main app launcher process and kill it\n-            killAppLauncherProcess(cmd, null, expectedNoRestarted ? 1 : 2);\n+                \/\/ Find the main app launcher process and kill it\n+                killAppLauncherProcess(cmd, null, expectedNoRestarted ? 1 : 2);\n+            }\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinNoRestartTest.java","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2017, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+ * @author Joseph D. Darcy, ksrini\n","filename":"test\/jdk\/tools\/launcher\/ChangeDataModel.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+ * @author Joseph D. Darcy, Kumar Srinivasan\n","filename":"test\/jdk\/tools\/launcher\/I18NTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2012, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+ * @author Joseph D. Darcy, ksrini\n","filename":"test\/jdk\/tools\/launcher\/UnresolvedExceptions.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -152,1 +152,0 @@\n-        vmOptFinalIntxFlags(map);\n@@ -393,20 +392,0 @@\n-    \/**\n-     * Selected final flag of type intx.\n-     *\n-     * @param map - property-value pairs\n-     * @param flagName - flag name\n-     *\/\n-    private void vmOptFinalIntxFlag(SafeMap map, String flagName) {\n-        map.put(\"vm.opt.final.\" + flagName,\n-                () -> String.valueOf(WB.getIntxVMFlag(flagName)));\n-    }\n-\n-    \/**\n-     * Selected sets of final flags of type intx.\n-     *\n-     * @param map - property-value pairs\n-     *\/\n-    protected void vmOptFinalIntxFlags(SafeMap map) {\n-        vmOptFinalIntxFlag(map, \"MaxVectorSize\");\n-    }\n-\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -218,1 +218,0 @@\n-            \"resource-files\/sort-a-z.svg\",\n@@ -269,0 +268,1 @@\n+\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/api\/basic\/APITest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-                    .executionEngine(Presets.TEST_JDI_EXECUTION)\n+                    .executionEngine(\"jdi\")\n","filename":"test\/langtools\/jdk\/jshell\/JdiBadOptionListenExecutionControlTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-        setUp(builder -> builder.executionEngine(Presets.TEST_JDI_EXECUTION));\n+        setUp(builder -> builder.executionEngine(\"jdi\"));\n","filename":"test\/langtools\/jdk\/jshell\/JdiListeningExecutionControlTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-    private static final int TEST_TIMEOUT = 20_000;\n-\n@@ -32,1 +30,0 @@\n-    public static final String TEST_JDI_EXECUTION;\n@@ -38,3 +35,1 @@\n-                                 \"1(jdi:launch(true)),\" +\n-                                 \"2(jdi:timeout(\" + TEST_TIMEOUT + \")),\" +\n-                                 \"3(local)\";\n+                                 \"1(jdi:launch(true)), 2(jdi), 3(local)\";\n@@ -42,3 +37,1 @@\n-                                  \"1(jdi:launch(true)),\" +\n-                                  \"2(jdi:timeout(\" + TEST_TIMEOUT + \"))\";\n-        TEST_JDI_EXECUTION = \"jdi:timeout(\" + TEST_TIMEOUT + \")\";\n+                                  \"1(jdi:launch(true)), 2(jdi)\";\n","filename":"test\/langtools\/jdk\/jshell\/Presets.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -451,1 +450,1 @@\n-        if (newVal < oldVal) {\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n@@ -457,1 +456,1 @@\n-        if (newVal < oldVal) {\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/cgroup\/MetricsTesterCgroupV2.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-import sun.security.x509.X500Name;\n@@ -94,1 +93,1 @@\n-    private X500Name subjectName = null;\n+    private X500Principal subjectName = null;\n@@ -203,1 +202,1 @@\n-        subjectName = X500Name.asX500Name(name);\n+        subjectName = name;\n@@ -213,17 +212,1 @@\n-        try {\n-            subjectName = new X500Name(name);\n-        } catch (IOException ioe) {\n-            throw new IllegalArgumentException(ioe);\n-        }\n-        return this;\n-    }\n-\n-    \/**\n-     * Set the subject name for the certificate. This method is useful when\n-     * you need more control over the contents of the subject name.\n-     *\n-     * @param name an {@code X500Name} to be used as the subject name\n-     * on this certificate\n-     *\/\n-    public CertificateBuilder setSubjectName(X500Name name) {\n-        subjectName = name;\n+        subjectName = new X500Principal(name);\n","filename":"test\/lib\/jdk\/test\/lib\/security\/CertificateBuilder.java","additions":3,"deletions":20,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1,104 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2025, Alibaba Group Holding Limited. All Rights Reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.java.lang;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-import java.util.Random;\n-import java.util.concurrent.TimeUnit;\n-\n-\/**\n- * Tests for sun.misc.FloatingDecimal. Performs floating point number to String conversions.\n- *\/\n-@BenchmarkMode(Mode.AverageTime)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@State(Scope.Thread)\n-@Warmup(iterations = 10, time = 1)\n-@Measurement(iterations = 5, time = 2)\n-@Fork(3)\n-public class Doubles {\n-\n-    private double[] randomArray, twoDecimalsArray, integerArray;\n-    private static final int TESTSIZE = 1000;\n-\n-    @Setup\n-    public void setup() {\n-        Random r = new Random(1123);\n-        randomArray = new double[TESTSIZE];\n-        twoDecimalsArray = new double[TESTSIZE];\n-        integerArray = new double[TESTSIZE];\n-        for (int i = 0; i < TESTSIZE; i++) {\n-            randomArray[i] = r.nextDouble() * 10000.0D;\n-            twoDecimalsArray[i] = ((double) (10000 - r.nextInt(20000))) \/ 100;\n-            integerArray[i] = (double) (100 - r.nextInt(200));\n-        }\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(TESTSIZE)\n-    public void toHexString(Blackhole bh) {\n-        for (double d : randomArray) {\n-            bh.consume(Double.toHexString(d));\n-        }\n-    }\n-\n-    \/** Tests Double.toString on double values generated from Random.nextDouble() *\/\n-    @Benchmark\n-    @OperationsPerInvocation(TESTSIZE)\n-    public void randomDoubleToString(Blackhole bh) {\n-        for (double d : randomArray) {\n-            bh.consume(Double.toString(d));\n-        }\n-    }\n-\n-    \/** Tests Double.toString on double values that are integers between -100 and 100. *\/\n-    @Benchmark\n-    @OperationsPerInvocation(TESTSIZE)\n-    public void integerDoubleToString(Blackhole bh) {\n-        for (double d : integerArray) {\n-            bh.consume(Double.toString(d));\n-        }\n-    }\n-\n-    \/** Tests Double.toString on double values that are between -100 and 100 and have two decimal digits. *\/\n-    @Benchmark\n-    @OperationsPerInvocation(TESTSIZE)\n-    public void twoDecimalsDoubleToString(Blackhole bh) {\n-        for (double d : twoDecimalsArray) {\n-            bh.consume(Double.toString(d));\n-        }\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/Doubles.java","additions":0,"deletions":104,"binary":false,"changes":104,"status":"deleted"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Tests for sun.misc.FloatingDecimal. Performs floating point number to String conversions.\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 10, time = 1)\n+@Measurement(iterations = 5, time = 2)\n+@Fork(3)\n+public class FloatingDecimal {\n+\n+    private double[] randomArray, twoDecimalsArray, integerArray;\n+    private static final int TESTSIZE = 1000;\n+\n+    @Setup\n+    public void setup() {\n+        Random r = new Random(1123);\n+        randomArray = new double[TESTSIZE];\n+        twoDecimalsArray = new double[TESTSIZE];\n+        integerArray = new double[TESTSIZE];\n+        for (int i = 0; i < TESTSIZE; i++) {\n+            randomArray[i] = r.nextDouble() * 10000.0D;\n+            twoDecimalsArray[i] = ((double) (10000 - r.nextInt(20000))) \/ 100;\n+            integerArray[i] = (double) (100 - r.nextInt(200));\n+        }\n+    }\n+\n+    \/** Tests Double.toString on double values generated from Random.nextDouble() *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void randomDoubleToString(Blackhole bh) {\n+        for (double d : randomArray) {\n+            bh.consume(Double.toString(d));\n+        }\n+    }\n+\n+    \/** Tests Double.toString on double values that are integers between -100 and 100. *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void integerDoubleToString(Blackhole bh) {\n+        for (double d : integerArray) {\n+            bh.consume(Double.toString(d));\n+        }\n+    }\n+\n+    \/** Tests Double.toString on double values that are between -100 and 100 and have two decimal digits. *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void twoDecimalsDoubleToString(Blackhole bh) {\n+        for (double d : twoDecimalsArray) {\n+            bh.consume(Double.toString(d));\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/FloatingDecimal.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -1,171 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.openjdk.bench.java.lang.runtime;\n-\n-import java.util.Objects;\n-import java.util.concurrent.TimeUnit;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-\/\/\/ Tests the generated equals and hashCode for records.\n-\/\/\/ There are 4 types of methods:\n-\/\/\/  - distinct: distinct sites for type profiling\n-\/\/\/  - polluted: megamorphic site that blocks type profiling\n-\/\/\/  - generated: actual body generated by ObjectMethods::bootstrap\n-\/\/\/  - specialized: generated body for non-extensible types\n-\/\/\/ The result of generated compared to the other distinct\/polluted shows\n-\/\/\/ whether the generated code could perform type profiling.\n-\/\/\/ Specialized is the result of distinct without trap, should be even faster.\n-@Fork(3)\n-@Warmup(iterations = 10, time = 1)\n-@Measurement(iterations = 5, time = 2)\n-@OutputTimeUnit(TimeUnit.MICROSECONDS)\n-@BenchmarkMode(Mode.Throughput)\n-public class RecordMethodsBenchmark {\n-\n-    record One(int a) {}\n-\n-    @State(Scope.Thread)\n-    public static class BenchmarkState {\n-        Key k1 = new Key(new One(1), \"a\");\n-        Key k2 = new Key(new One(1), new String(\"a\"));\n-        SpecializedKey sk1 = new SpecializedKey(new One(1), \"a\");\n-        SpecializedKey sk2 = new SpecializedKey(new One(1), new String(\"a\"));\n-    }\n-\n-    @Benchmark\n-    public int hashCodeDistinct(BenchmarkState state) {\n-        return state.k1.hashCodeDistinct();\n-    }\n-\n-    @Benchmark\n-    public int hashCodePolluted(BenchmarkState state) {\n-        return state.k1.hashCodePolluted();\n-    }\n-\n-    @Benchmark\n-    public int hashCodeGenerated(BenchmarkState state) {\n-        return state.k1.hashCode();\n-    }\n-\n-    @Benchmark\n-    public int hashCodeSpecial(BenchmarkState state) {\n-        return state.sk1.hashCode();\n-    }\n-\n-    @Benchmark\n-    public boolean equalsDistinct(BenchmarkState state) {\n-        return state.k1.equalsDistinct(state.k2);\n-    }\n-\n-    @Benchmark\n-    public boolean equalsPolluted(BenchmarkState state) {\n-        return state.k1.equalsPolluted(state.k2);\n-    }\n-\n-    @Benchmark\n-    public boolean equalsGenerated(BenchmarkState state) {\n-        return state.k1.equals(state.k2);\n-    }\n-\n-    @Benchmark\n-    public boolean equalsSpecial(BenchmarkState state) {\n-        return state.sk1.equals(state.sk2);\n-    }\n-\n-    \/\/\/ A key object.\n-    \/\/\/\n-    \/\/\/ Having both field as Object pollutes Object.equals for record object\n-    \/\/\/ method MH tree.  We must verify the leaf Object.equals calls don't\n-    \/\/\/ share the same profile in generated code.\n-    record Key(Object key1, Object key2) {\n-        \/\/\/ A hashCode method which has distinct hashCode invocations\n-        \/\/\/ in bytecode for each field for type profiling.\n-        public int hashCodeDistinct() {\n-            final int prime = 31;\n-            int result = 1;\n-            result = prime * result + ((key1 == null) ? 0 : key1.hashCode());\n-            result = prime * result + ((key2 == null) ? 0 : key2.hashCode());\n-            return result;\n-        }\n-\n-        \/\/\/ A hashCode method which uses a megamorphic polluted\n-        \/\/\/ Object.hashCode virtual invocation in Objects.hashCode.\n-        public int hashCodePolluted() {\n-            final int prime = 31;\n-            int result = 1;\n-            result = prime * result + Objects.hashCode(key1);\n-            result = prime * result + Objects.hashCode(key2);\n-            return result;\n-        }\n-\n-        \/\/\/ An equals method which has distinct equals invocations\n-        \/\/\/ in bytecode for each field for type profiling.\n-        public boolean equalsDistinct(Object obj) {\n-            if (this == obj)\n-                return true;\n-            if (obj == null)\n-                return false;\n-            if (getClass() != obj.getClass())\n-                return false;\n-            Key other = (Key) obj;\n-            if (key1 == null) {\n-                if (other.key1 != null)\n-                    return false;\n-            }\n-            else if (!key1.equals(other.key1))\n-                return false;\n-            if (key2 == null) {\n-                if (other.key2 != null)\n-                    return false;\n-            }\n-            else if (!key2.equals(other.key2))\n-                return false;\n-            return true;\n-        }\n-\n-        \/\/\/ An equals method which uses a megamorphic polluted\n-        \/\/\/ Object.equals virtual invocation in Objects.equals.\n-        public boolean equalsPolluted(Object obj) {\n-            if (this == obj)\n-                return true;\n-            if (obj == null)\n-                return false;\n-            if (getClass() != obj.getClass())\n-                return false;\n-            Key other = (Key) obj;\n-            return Objects.equals(key1, other.key1) && Objects.equals(key2, other.key2);\n-        }\n-    }\n-\n-    record SpecializedKey(One key1, String key2) {}\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/runtime\/RecordMethodsBenchmark.java","additions":0,"deletions":171,"binary":false,"changes":171,"status":"deleted"},{"patch":"@@ -1,84 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.javax.crypto;\n-\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-\n-import javax.crypto.Cipher;\n-import javax.crypto.spec.IvParameterSpec;\n-import javax.crypto.spec.SecretKeySpec;\n-import java.util.Random;\n-import java.util.concurrent.TimeUnit;\n-\n-@OutputTimeUnit(TimeUnit.SECONDS)\n-@State(Scope.Thread)\n-public class AESDecrypt {\n-\n-    @Param(\"10000000\")\n-    private int count;\n-\n-    private Cipher cipher;\n-    private byte[] src;\n-    private byte[] ct;\n-\n-    @Setup\n-    public void setup() throws Exception {\n-        SecretKeySpec keySpec = new SecretKeySpec(new byte[]{-80, -103, -1, 68, -29, -94, 61, -52, 93, -59, -128, 105, 110, 88, 44, 105}, \"AES\");\n-        IvParameterSpec iv = new IvParameterSpec(new byte[]{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00});\n-\n-        cipher = Cipher.getInstance(\"AES\/CBC\/PKCS5Padding\");\n-        cipher.init(Cipher.ENCRYPT_MODE, keySpec, iv);\n-\n-        src = new byte[count];\n-        new Random(1).nextBytes(src);\n-\n-        ct = cipher.doFinal(src);\n-\n-        cipher.init(Cipher.DECRYPT_MODE, keySpec, iv);\n-    }\n-\n-    @Benchmark\n-    @Fork(jvmArgs = {\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:-UseAES\", \"-XX:-UseAESIntrinsics\"})\n-    public byte[] testBaseline() throws Exception {\n-        return cipher.doFinal(ct);\n-    }\n-\n-    @Benchmark\n-    @Fork(jvmArgs = {\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+UseAES\", \"-XX:-UseAESIntrinsics\"})\n-    public byte[] testUseAes() throws Exception {\n-        return cipher.doFinal(ct);\n-    }\n-\n-    @Benchmark\n-    @Fork(jvmArgs = {\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+UseAES\", \"-XX:+UseAESIntrinsics\"})\n-    public byte[] testUseAesIntrinsics() throws Exception {\n-        return cipher.doFinal(ct);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/AESDecrypt.java","additions":0,"deletions":84,"binary":false,"changes":84,"status":"deleted"}]}