{"files":[{"patch":"@@ -5343,0 +5343,29 @@\n+static Register pick_different_tmp(Register dst, Register src) {\n+  auto tmps = RegSet::of(r0, r1, r2) - RegSet::of(src, dst);\n+  return *tmps.begin();\n+}\n+\n+void MacroAssembler::encode_klass_not_null_for_aot(Register dst, Register src) {\n+  \/\/ we have to load the klass base from the AOT constants area but\n+  \/\/ not the shift because it is not allowed to change\n+  int shift = CompressedKlassPointers::shift();\n+  assert(shift >= 0 && shift < 4, \"unexpected compressd klass shift!\");\n+  if (dst != src) {\n+    \/\/ we can load the base into dst, subtract it formthe src and shift down\n+    lea(dst, ExternalAddress(CompressedKlassPointers::base_addr()));\n+    ldr(dst, dst);\n+    sub(dst, src, dst);\n+    lsr(dst, dst, shift);\n+  } else {\n+    \/\/ we need an extra register in order to load the coop base\n+    Register tmp = pick_different_tmp(dst, src);\n+    RegSet regs = RegSet::of(tmp);\n+    push(regs, sp);\n+    lea(tmp, ExternalAddress(CompressedKlassPointers::base_addr()));\n+    ldr(tmp, tmp);\n+    sub(dst, src, tmp);\n+    lsr(dst, dst, shift);\n+    pop(regs, sp);\n+  }\n+}\n+\n@@ -5344,0 +5373,5 @@\n+  if (AOTCodeCache::is_on_for_dump()) {\n+    encode_klass_not_null_for_aot(dst, src);\n+    return;\n+  }\n+\n@@ -5380,0 +5414,22 @@\n+void MacroAssembler::decode_klass_not_null_for_aot(Register dst, Register src) {\n+  \/\/ we have to load the klass base from the AOT constants area but\n+  \/\/ not the shift because it is not allowed to change\n+  int shift = CompressedKlassPointers::shift();\n+  assert(shift >= 0 && shift < 4, \"unexpected compressd klass shift!\");\n+  if (dst != src) {\n+    \/\/ we can load the base into dst then add the offset with a suitable shift\n+    lea(dst, ExternalAddress(CompressedKlassPointers::base_addr()));\n+    ldr(dst, dst);\n+    add(dst, dst, src, LSL,  shift);\n+  } else {\n+    \/\/ we need an extra register in order to load the coop base\n+    Register tmp = pick_different_tmp(dst, src);\n+    RegSet regs = RegSet::of(tmp);\n+    push(regs, sp);\n+    lea(tmp, ExternalAddress(CompressedKlassPointers::base_addr()));\n+    ldr(tmp, tmp);\n+    add(dst, tmp,  src, LSL,  shift);\n+    pop(regs, sp);\n+  }\n+}\n+\n@@ -5383,0 +5439,5 @@\n+  if (AOTCodeCache::is_on_for_dump()) {\n+    decode_klass_not_null_for_aot(dst, src);\n+    return;\n+  }\n+\n@@ -6657,1 +6718,1 @@\n-  mov(lr, CAST_FROM_FN_PTR(address, JavaThread::aarch64_get_thread_helper));\n+  mov(lr, ExternalAddress(CAST_FROM_FN_PTR(address, JavaThread::aarch64_get_thread_helper)));\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":62,"deletions":1,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -938,0 +938,2 @@\n+  void decode_klass_not_null_for_aot(Register dst, Register src);\n+  void encode_klass_not_null_for_aot(Register dst, Register src);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -63,0 +64,6 @@\n+  const char* name = OptoRuntime::stub_name(OptoStubId::uncommon_trap_id);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::C2Blob, (uint)OptoStubId::uncommon_trap_id, name);\n+  if (blob != nullptr) {\n+    return blob->as_uncommon_trap_blob();\n+  }\n+\n@@ -66,1 +73,0 @@\n-  const char* name = OptoRuntime::stub_name(OptoStubId::uncommon_trap_id);\n@@ -249,2 +255,4 @@\n-  return UncommonTrapBlob::create(&buffer, oop_maps,\n-                                                 SimpleRuntimeFrame::framesize >> 1);\n+  UncommonTrapBlob *ut_blob = UncommonTrapBlob::create(&buffer, oop_maps,\n+                                                       SimpleRuntimeFrame::framesize >> 1);\n+  AOTCodeCache::store_code_blob(*ut_blob, AOTCodeEntry::C2Blob, (uint)OptoStubId::uncommon_trap_id, name);\n+  return ut_blob;\n@@ -286,0 +294,6 @@\n+  const char* name = OptoRuntime::stub_name(OptoStubId::exception_id);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::C2Blob, (uint)OptoStubId::exception_id, name);\n+  if (blob != nullptr) {\n+    return blob->as_exception_blob();\n+  }\n+\n@@ -289,1 +303,0 @@\n-  const char* name = OptoRuntime::stub_name(OptoStubId::exception_id);\n@@ -387,1 +400,3 @@\n-  return ExceptionBlob::create(&buffer, oop_maps, SimpleRuntimeFrame::framesize >> 1);\n+  ExceptionBlob* ex_blob = ExceptionBlob::create(&buffer, oop_maps, SimpleRuntimeFrame::framesize >> 1);\n+  AOTCodeCache::store_code_blob(*ex_blob, AOTCodeEntry::C2Blob, (uint)OptoStubId::exception_id, name);\n+  return ex_blob;\n","filename":"src\/hotspot\/cpu\/aarch64\/runtime_aarch64.cpp","additions":20,"deletions":5,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -2187,0 +2188,6 @@\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, (uint)SharedStubId::deopt_id, name);\n+  if (blob != nullptr) {\n+    _deopt_blob = blob->as_deoptimization_blob();\n+    return;\n+  }\n+\n@@ -2550,0 +2557,2 @@\n+\n+  AOTCodeCache::store_code_blob(*_deopt_blob, AOTCodeEntry::SharedBlob, (uint)SharedStubId::deopt_id, name);\n@@ -2578,0 +2587,7 @@\n+  \/\/ Allocate space for the code.  Setup code generation tools.\n+  const char* name = SharedRuntime::stub_name(id);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, (uint)id, name);\n+  if (blob != nullptr) {\n+    return blob->as_safepoint_blob();\n+  }\n+\n@@ -2581,3 +2597,0 @@\n-\n-  \/\/ Allocate space for the code.  Setup code generation tools.\n-  const char* name = SharedRuntime::stub_name(id);\n@@ -2692,1 +2705,4 @@\n-  return SafepointBlob::create(&buffer, oop_maps, frame_size_in_words);\n+  SafepointBlob* sp_blob = SafepointBlob::create(&buffer, oop_maps, frame_size_in_words);\n+\n+  AOTCodeCache::store_code_blob(*sp_blob, AOTCodeEntry::SharedBlob, (uint)id, name);\n+  return sp_blob;\n@@ -2707,0 +2723,6 @@\n+  const char* name = SharedRuntime::stub_name(id);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, (uint)id, name);\n+  if (blob != nullptr) {\n+    return blob->as_runtime_stub();\n+  }\n+\n@@ -2709,2 +2731,0 @@\n-\n-  const char* name = SharedRuntime::stub_name(id);\n@@ -2783,1 +2803,4 @@\n-  return RuntimeStub::new_runtime_stub(name, &buffer, frame_complete, frame_size_in_words, oop_maps, true);\n+  RuntimeStub* rs_blob = RuntimeStub::new_runtime_stub(name, &buffer, frame_complete, frame_size_in_words, oop_maps, true);\n+\n+  AOTCodeCache::store_code_blob(*rs_blob, AOTCodeEntry::SharedBlob, (uint)id, name);\n+  return rs_blob;\n@@ -2823,1 +2846,0 @@\n-  ResourceMark rm;\n@@ -2827,0 +2849,6 @@\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, (uint)id, name);\n+  if (blob != nullptr) {\n+    return blob->as_runtime_stub();\n+  }\n+\n+  ResourceMark rm;\n@@ -2853,1 +2881,1 @@\n-  __ mov(rscratch1, runtime_entry);\n+  __ lea(rscratch1, RuntimeAddress(runtime_entry));\n@@ -2886,0 +2914,2 @@\n+  AOTCodeCache::store_code_blob(*stub, AOTCodeEntry::SharedBlob, (uint)id, name);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":39,"deletions":9,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -5407,1 +5407,5 @@\n-    mov64(tmp, (int64_t)CompressedKlassPointers::base());\n+    if (AOTCodeCache::is_on_for_dump()) {\n+      movptr(tmp, ExternalAddress(CompressedKlassPointers::base_addr()));\n+    } else {\n+      mov64(tmp, (int64_t)CompressedKlassPointers::base());\n+    }\n@@ -5439,1 +5443,5 @@\n-    mov64(tmp, (int64_t)CompressedKlassPointers::base());\n+    if (AOTCodeCache::is_on_for_dump()) {\n+      movptr(tmp, ExternalAddress(CompressedKlassPointers::base_addr()));\n+    } else {\n+      mov64(tmp, (int64_t)CompressedKlassPointers::base());\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -59,0 +60,6 @@\n+  const char* name = OptoRuntime::stub_name(OptoStubId::uncommon_trap_id);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::C2Blob, (uint)OptoStubId::uncommon_trap_id, name);\n+  if (blob != nullptr) {\n+    return blob->as_uncommon_trap_blob();\n+  }\n+\n@@ -62,1 +69,0 @@\n-  const char* name = OptoRuntime::stub_name(OptoStubId::uncommon_trap_id);\n@@ -231,2 +237,4 @@\n-  return UncommonTrapBlob::create(&buffer, oop_maps,\n-                                                 SimpleRuntimeFrame::framesize >> 1);\n+  UncommonTrapBlob *ut_blob = UncommonTrapBlob::create(&buffer, oop_maps,\n+                                                       SimpleRuntimeFrame::framesize >> 1);\n+  AOTCodeCache::store_code_blob(*ut_blob, AOTCodeEntry::C2Blob, (uint)OptoStubId::uncommon_trap_id, name);\n+  return ut_blob;\n@@ -268,0 +276,6 @@\n+  const char* name = OptoRuntime::stub_name(OptoStubId::exception_id);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::C2Blob, (uint)OptoStubId::exception_id, name);\n+  if (blob != nullptr) {\n+    return blob->as_exception_blob();\n+  }\n+\n@@ -271,1 +285,0 @@\n-  const char* name = OptoRuntime::stub_name(OptoStubId::exception_id);\n@@ -366,1 +379,3 @@\n-  return ExceptionBlob::create(&buffer, oop_maps, SimpleRuntimeFrame::framesize >> 1);\n+  ExceptionBlob* ex_blob = ExceptionBlob::create(&buffer, oop_maps, SimpleRuntimeFrame::framesize >> 1);\n+  AOTCodeCache::store_code_blob(*ex_blob, AOTCodeEntry::C2Blob, (uint)OptoStubId::exception_id, name);\n+  return ex_blob;\n","filename":"src\/hotspot\/cpu\/x86\/runtime_x86_64.cpp","additions":20,"deletions":5,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -2603,0 +2604,6 @@\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, (uint)SharedStubId::deopt_id, name);\n+  if (blob != nullptr) {\n+    _deopt_blob = blob->as_deoptimization_blob();\n+    return;\n+  }\n+\n@@ -2954,0 +2961,2 @@\n+\n+  AOTCodeCache::store_code_blob(*_deopt_blob, AOTCodeEntry::SharedBlob, (uint)SharedStubId::deopt_id, name);\n@@ -2966,0 +2975,7 @@\n+  \/\/ Allocate space for the code.  Setup code generation tools.\n+  const char* name = SharedRuntime::stub_name(id);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, (uint)id, name);\n+  if (blob != nullptr) {\n+    return blob->as_safepoint_blob();\n+  }\n+\n@@ -2969,3 +2985,0 @@\n-\n-  \/\/ Allocate space for the code.  Setup code generation tools.\n-  const char* name = SharedRuntime::stub_name(id);\n@@ -3131,1 +3144,4 @@\n-  return SafepointBlob::create(&buffer, oop_maps, frame_size_in_words);\n+  SafepointBlob* sp_blob = SafepointBlob::create(&buffer, oop_maps, frame_size_in_words);\n+\n+  AOTCodeCache::store_code_blob(*sp_blob, AOTCodeEntry::SharedBlob, (uint)id, name);\n+  return sp_blob;\n@@ -3146,0 +3162,6 @@\n+  const char* name = SharedRuntime::stub_name(id);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, (uint)id, name);\n+  if (blob != nullptr) {\n+    return blob->as_runtime_stub();\n+  }\n+\n@@ -3148,2 +3170,0 @@\n-\n-  const char* name = SharedRuntime::stub_name(id);\n@@ -3218,1 +3238,4 @@\n-  return RuntimeStub::new_runtime_stub(name, &buffer, frame_complete, frame_size_in_words, oop_maps, true);\n+  RuntimeStub* rs_blob = RuntimeStub::new_runtime_stub(name, &buffer, frame_complete, frame_size_in_words, oop_maps, true);\n+\n+  AOTCodeCache::store_code_blob(*rs_blob, AOTCodeEntry::SharedBlob, (uint)id, name);\n+  return rs_blob;\n@@ -3256,1 +3279,0 @@\n-  ResourceMark rm;\n@@ -3260,0 +3282,6 @@\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, (uint)id, name);\n+  if (blob != nullptr) {\n+    return blob->as_runtime_stub();\n+  }\n+\n+  ResourceMark rm;\n@@ -3317,0 +3345,2 @@\n+  AOTCodeCache::store_code_blob(*stub, AOTCodeEntry::SharedBlob, (uint)id, name);\n+\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":38,"deletions":8,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -1862,2 +1862,1 @@\n-    \/\/ No relocation needed\n-    __ mov64(r10, (int64_t) $meth$$method);\n+    __ lea(r10, RuntimeAddress((address)$meth$$method));\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -1090,98 +1091,4 @@\n-\/\/ ----- CHeapString -----------------------------------------------------------\n-\n-class CHeapString : public CHeapObj<mtCode> {\n- public:\n-  CHeapString(const char* str) : _string(os::strdup(str)) {}\n- ~CHeapString() {\n-    os::free((void*)_string);\n-    _string = nullptr;\n-  }\n-  const char* string() const { return _string; }\n-\n- private:\n-  const char* _string;\n-};\n-\n-\/\/ ----- AsmRemarkCollection ---------------------------------------------------\n-\n-class AsmRemarkCollection : public CHeapObj<mtCode> {\n- public:\n-  AsmRemarkCollection() : _ref_cnt(1), _remarks(nullptr), _next(nullptr) {}\n- ~AsmRemarkCollection() {\n-    assert(is_empty(), \"Must 'clear()' before deleting!\");\n-    assert(_ref_cnt == 0, \"No uses must remain when deleting!\");\n-  }\n-  AsmRemarkCollection* reuse() {\n-    precond(_ref_cnt > 0);\n-    return _ref_cnt++, this;\n-  }\n-\n-  const char* insert(uint offset, const char* remark);\n-  const char* lookup(uint offset) const;\n-  const char* next(uint offset) const;\n-\n-  bool is_empty() const { return _remarks == nullptr; }\n-  uint clear();\n-\n- private:\n-  struct Cell : CHeapString {\n-    Cell(const char* remark, uint offset) :\n-        CHeapString(remark), offset(offset), prev(nullptr), next(nullptr) {}\n-    void push_back(Cell* cell) {\n-      Cell* head = this;\n-      Cell* tail = prev;\n-      tail->next = cell;\n-      cell->next = head;\n-      cell->prev = tail;\n-      prev = cell;\n-    }\n-    uint offset;\n-    Cell* prev;\n-    Cell* next;\n-  };\n-  uint  _ref_cnt;\n-  Cell* _remarks;\n-  \/\/ Using a 'mutable' iteration pointer to allow 'const' on lookup\/next (that\n-  \/\/ does not change the state of the list per se), supportig a simplistic\n-  \/\/ iteration scheme.\n-  mutable Cell* _next;\n-};\n-\n-\/\/ ----- DbgStringCollection ---------------------------------------------------\n-\n-class DbgStringCollection : public CHeapObj<mtCode> {\n- public:\n-  DbgStringCollection() : _ref_cnt(1), _strings(nullptr) {}\n- ~DbgStringCollection() {\n-    assert(is_empty(), \"Must 'clear()' before deleting!\");\n-    assert(_ref_cnt == 0, \"No uses must remain when deleting!\");\n-  }\n-  DbgStringCollection* reuse() {\n-    precond(_ref_cnt > 0);\n-    return _ref_cnt++, this;\n-  }\n-\n-  const char* insert(const char* str);\n-  const char* lookup(const char* str) const;\n-\n-  bool is_empty() const { return _strings == nullptr; }\n-  uint clear();\n-\n- private:\n-  struct Cell : CHeapString {\n-    Cell(const char* dbgstr) :\n-        CHeapString(dbgstr), prev(nullptr), next(nullptr) {}\n-    void push_back(Cell* cell) {\n-      Cell* head = this;\n-      Cell* tail = prev;\n-      tail->next = cell;\n-      cell->next = head;\n-      cell->prev = tail;\n-      prev = cell;\n-    }\n-    Cell* prev;\n-    Cell* next;\n-  };\n-  uint  _ref_cnt;\n-  Cell* _strings;\n-};\n+CHeapString::~CHeapString() {\n+  os::free((void*)_string);\n+  _string = nullptr;\n+}\n@@ -1213,1 +1120,1 @@\n-  precond(is_empty());\n+  precond(_remarks == nullptr || is_empty());\n@@ -1219,1 +1126,1 @@\n-  if (_remarks->clear() == 0) {\n+  if (_remarks != nullptr && _remarks->clear() == 0) {\n@@ -1265,1 +1172,1 @@\n-  precond(is_empty());\n+  precond(_strings == nullptr || is_empty());\n@@ -1271,1 +1178,1 @@\n-  if (_strings->clear() == 0) {\n+  if (_strings != nullptr && _strings->clear() == 0) {\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.cpp","additions":9,"deletions":102,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/os.hpp\"\n@@ -294,2 +295,123 @@\n-class AsmRemarkCollection;\n-class DbgStringCollection;\n+\/\/ ----- CHeapString -----------------------------------------------------------\n+\n+class CHeapString : public CHeapObj<mtCode> {\n+ public:\n+  CHeapString(const char* str) : _string(os::strdup(str)) {}\n+  ~CHeapString();\n+  const char* string() const { return _string; }\n+\n+ private:\n+  const char* _string;\n+};\n+\n+\/\/ ----- AsmRemarkCollection ---------------------------------------------------\n+\n+class AsmRemarkCollection : public CHeapObj<mtCode> {\n+ public:\n+  AsmRemarkCollection() : _ref_cnt(1), _remarks(nullptr), _next(nullptr) {}\n+ ~AsmRemarkCollection() {\n+    assert(is_empty(), \"Must 'clear()' before deleting!\");\n+    assert(_ref_cnt == 0, \"No uses must remain when deleting!\");\n+  }\n+  AsmRemarkCollection* reuse() {\n+    precond(_ref_cnt > 0);\n+    return _ref_cnt++, this;\n+  }\n+\n+  const char* insert(uint offset, const char* remark);\n+  const char* lookup(uint offset) const;\n+  const char* next(uint offset) const;\n+\n+  bool is_empty() const { return _remarks == nullptr; }\n+  uint clear();\n+\n+  template<typename Function>\n+  bool iterate(Function function) const { \/\/ lambda enabled API\n+    if (_remarks != nullptr) {\n+      Cell* tmp = _remarks;\n+      do {\n+        if(!function(tmp->offset, tmp->string())) {\n+          return false;\n+        }\n+        tmp = tmp->next;\n+      } while (tmp != _remarks);\n+    }\n+    return true;\n+  }\n+\n+ private:\n+  struct Cell : CHeapString {\n+    Cell(const char* remark, uint offset) :\n+        CHeapString(remark), offset(offset), prev(nullptr), next(nullptr) {}\n+    void push_back(Cell* cell) {\n+      Cell* head = this;\n+      Cell* tail = prev;\n+      tail->next = cell;\n+      cell->next = head;\n+      cell->prev = tail;\n+      prev = cell;\n+    }\n+    uint offset;\n+    Cell* prev;\n+    Cell* next;\n+  };\n+  uint  _ref_cnt;\n+  Cell* _remarks;\n+  \/\/ Using a 'mutable' iteration pointer to allow 'const' on lookup\/next (that\n+  \/\/ does not change the state of the list per se), supportig a simplistic\n+  \/\/ iteration scheme.\n+  mutable Cell* _next;\n+};\n+\n+\/\/ ----- DbgStringCollection ---------------------------------------------------\n+\n+class DbgStringCollection : public CHeapObj<mtCode> {\n+ public:\n+  DbgStringCollection() : _ref_cnt(1), _strings(nullptr) {}\n+ ~DbgStringCollection() {\n+    assert(is_empty(), \"Must 'clear()' before deleting!\");\n+    assert(_ref_cnt == 0, \"No uses must remain when deleting!\");\n+  }\n+  DbgStringCollection* reuse() {\n+    precond(_ref_cnt > 0);\n+    return _ref_cnt++, this;\n+  }\n+\n+  const char* insert(const char* str);\n+  const char* lookup(const char* str) const;\n+\n+  bool is_empty() const { return _strings == nullptr; }\n+  uint clear();\n+\n+  template<typename Function>\n+  bool iterate(Function function) const { \/\/ lambda enabled API\n+    if (_strings != nullptr) {\n+      Cell* tmp = _strings;\n+      do {\n+        if (!function(tmp->string())) {\n+          return false;\n+        }\n+        tmp = tmp->next;\n+      } while (tmp != _strings);\n+    }\n+    return true;\n+  }\n+\n+ private:\n+  struct Cell : CHeapString {\n+    Cell(const char* dbgstr) :\n+        CHeapString(dbgstr), prev(nullptr), next(nullptr) {}\n+    void push_back(Cell* cell) {\n+      Cell* head = this;\n+      Cell* tail = prev;\n+      tail->next = cell;\n+      cell->next = head;\n+      cell->prev = tail;\n+      prev = cell;\n+    }\n+    Cell* prev;\n+    Cell* next;\n+  };\n+  uint  _ref_cnt;\n+  Cell* _strings;\n+};\n@@ -318,0 +440,3 @@\n+  template<typename Function>\n+  inline bool iterate(Function function) const { return _remarks->iterate(function); }\n+\n@@ -340,0 +465,3 @@\n+  template<typename Function>\n+  bool iterate(Function function) const { return _strings->iterate(function); }\n+\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":130,"deletions":2,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -201,0 +202,7 @@\n+  if ((int)id >= 0) {\n+    CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::C1Blob, (uint)id, name, 0, nullptr);\n+    if (blob != nullptr) {\n+      return blob;\n+    }\n+  }\n+\n@@ -234,0 +242,3 @@\n+  if (blob != nullptr && (int)id >= 0) {\n+    AOTCodeCache::store_code_blob(*blob, AOTCodeEntry::C1Blob, (uint)id, name, 0, nullptr);\n+  }\n@@ -268,1 +279,7 @@\n-  for (int id = 0; id < limit; id++) {\n+  for (int id = 0; id <= (int)C1StubId::forward_exception_id; id++) {\n+    if (!generate_blob_for(blob, (C1StubId) id)) {\n+      return false;\n+    }\n+  }\n+  AOTCodeCache::init_early_c1_table();\n+  for (int id = (int)C1StubId::forward_exception_id+1; id < limit; id++) {\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+  friend class AOTCodeAddressTable;\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -408,0 +408,3 @@\n+  if (FLAG_IS_DEFAULT(AOTCache) && AOTStubCaching) {\n+    log_debug(aot,codecache,init)(\"AOTCache is not specified - AOTStubCaching is ignored\");\n+  }\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -135,0 +135,3 @@\n+  product(bool, AOTStubCaching, false, DIAGNOSTIC,                          \\\n+          \"Enable saving and restoring stubs and code blobs in AOT cache\")  \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/cds\/cds_globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+\n@@ -37,0 +38,1 @@\n+#include \"runtime\/deoptimization.hpp\"\n@@ -45,0 +47,3 @@\n+#ifdef COMPILER1\n+#include \"c1\/c1_Runtime1.hpp\"\n+#endif\n@@ -61,0 +66,6 @@\n+const char* aot_code_entry_kind_name[] = {\n+#define DECL_KIND_STRING(kind) XSTR(kind),\n+  DO_AOTCODEENTRY_KIND(DECL_KIND_STRING)\n+#undef DECL_KIND_STRING\n+};\n+\n@@ -67,0 +78,1 @@\n+  AOTStubCaching = false;\n@@ -76,0 +88,1 @@\n+  AOTStubCaching = false;\n@@ -86,0 +99,24 @@\n+bool AOTCodeCache::is_dumping_stubs() {\n+  return AOTStubCaching && is_on_for_dump();\n+}\n+\n+bool AOTCodeCache::is_using_stubs()   {\n+  return AOTStubCaching && is_on_for_use();\n+}\n+\n+static uint32_t encode_id(AOTCodeEntry::Kind kind, int id) {\n+  assert(AOTCodeEntry::is_valid_entry_kind(kind), \"invalid AOTCodeEntry kind %d\", (int)kind);\n+  \/\/ There can be a conflict of id between an Adapter and *Blob, but that should not cause any functional issue\n+  \/\/ becasue both id and kind are used to find an entry, and that combination should be unique\n+  if (kind == AOTCodeEntry::Adapter) {\n+    return id;\n+  } else if (kind == AOTCodeEntry::SharedBlob) {\n+    return id;\n+  } else if (kind == AOTCodeEntry::C1Blob) {\n+    return (int)SharedStubId::NUM_STUBIDS + id;\n+  } else {\n+    \/\/ kind must be AOTCodeEntry::C2Blob\n+    return (int)SharedStubId::NUM_STUBIDS + COMPILER1_PRESENT((int)C1StubId::NUM_STUBIDS) + id;\n+  }\n+}\n+\n@@ -101,0 +138,1 @@\n+    FLAG_SET_ERGO_IF_DEFAULT(AOTStubCaching, true);\n@@ -104,0 +142,1 @@\n+    FLAG_SET_ERGO_IF_DEFAULT(AOTStubCaching, true);\n@@ -109,1 +148,1 @@\n-  if (!AOTAdapterCaching) {\n+  if (!AOTAdapterCaching && !AOTStubCaching) {\n@@ -146,0 +185,1 @@\n+\n@@ -149,0 +189,1 @@\n+  init_early_stubs_table();\n@@ -221,1 +262,3 @@\n-    log_debug(aot, codecache, init)(\"  All Blobs: total=%u\", _load_header->blobs_count());\n+    log_debug(aot, codecache, init)(\"  Shared Blobs: total=%u\", _load_header->shared_blobs_count());\n+    log_debug(aot, codecache, init)(\"  C1 Blobs: total=%u\", _load_header->C1_blobs_count());\n+    log_debug(aot, codecache, init)(\"  C2 Blobs: total=%u\", _load_header->C2_blobs_count());\n@@ -244,0 +287,7 @@\n+void AOTCodeCache::init_early_stubs_table() {\n+  AOTCodeAddressTable* table = addr_table();\n+  if (table != nullptr) {\n+    table->init_early_stubs();\n+  }\n+}\n+\n@@ -251,0 +301,7 @@\n+void AOTCodeCache::init_early_c1_table() {\n+  AOTCodeAddressTable* table = addr_table();\n+  if (table != nullptr) {\n+    table->init_early_c1();\n+  }\n+}\n+\n@@ -301,0 +358,1 @@\n+  _compressedOopBase     = CompressedOops::base();\n@@ -353,1 +411,1 @@\n-    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with CompressedOops::shift() = %d vs current %d\", _compressedOopShift, CompressedOops::shift());\n+    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with different CompressedOops::shift(): %d vs current %d\", _compressedOopShift, CompressedOops::shift());\n@@ -368,0 +426,7 @@\n+\n+  \/\/ This should be the last check as it only disables AOTStubCaching\n+  if ((_compressedOopBase == nullptr || CompressedOops::base() == nullptr) && (_compressedOopBase != CompressedOops::base())) {\n+    log_debug(aot, codecache, init)(\"AOTStubCaching is disabled: incompatible CompressedOops::base(): %p vs current %p\", _compressedOopBase, CompressedOops::base());\n+    AOTStubCaching = false;\n+  }\n+\n@@ -535,0 +600,25 @@\n+      \/\/ Linear search around to handle id collission\n+      for (int i = mid - 1; i >= l; i--) { \/\/ search back\n+        ix = i * 2;\n+        is = _search_entries[ix];\n+        if (is != id) {\n+          break;\n+        }\n+        index = _search_entries[ix + 1];\n+        AOTCodeEntry* entry = &(_load_entries[index]);\n+        if (check_entry(kind, id, entry)) {\n+          return entry; \/\/ Found\n+        }\n+      }\n+      for (int i = mid + 1; i <= h; i++) { \/\/ search forward\n+        ix = i * 2;\n+        is = _search_entries[ix];\n+        if (is != id) {\n+          break;\n+        }\n+        index = _search_entries[ix + 1];\n+        AOTCodeEntry* entry = &(_load_entries[index]);\n+        if (check_entry(kind, id, entry)) {\n+          return entry; \/\/ Found\n+        }\n+      }\n@@ -591,1 +681,3 @@\n-    uint blobs_count = 0;\n+    uint shared_blobs_count = 0;\n+    uint C1_blobs_count = 0;\n+    uint C2_blobs_count = 0;\n@@ -615,2 +707,6 @@\n-      } else if (kind == AOTCodeEntry::Blob) {\n-        blobs_count++;\n+      } else if (kind == AOTCodeEntry::SharedBlob) {\n+        shared_blobs_count++;\n+      } else if (kind == AOTCodeEntry::C1Blob) {\n+        C1_blobs_count++;\n+      } else if (kind == AOTCodeEntry::C2Blob) {\n+        C2_blobs_count++;\n@@ -648,1 +744,3 @@\n-    log_debug(aot, codecache, exit)(\"  All Blobs: total=%u\", blobs_count);\n+    log_debug(aot, codecache, exit)(\"  Shared Blobs:  total=%d\", shared_blobs_count);\n+    log_debug(aot, codecache, exit)(\"  C1 Blobs:      total=%d\", C1_blobs_count);\n+    log_debug(aot, codecache, exit)(\"  C2 Blobs:      total=%d\", C2_blobs_count);\n@@ -655,1 +753,2 @@\n-                 adapters_count, blobs_count);\n+                 adapters_count, shared_blobs_count,\n+                 C1_blobs_count, C2_blobs_count);\n@@ -671,1 +770,4 @@\n-  if ((entry_kind == AOTCodeEntry::Adapter) && !AOTAdapterCaching) {\n+  if (AOTCodeEntry::is_adapter(entry_kind) && !is_dumping_adapters()) {\n+    return false;\n+  }\n+  if (AOTCodeEntry::is_blob(entry_kind) && !is_dumping_stubs()) {\n@@ -674,1 +776,1 @@\n-  log_debug(aot, codecache, stubs)(\"Writing blob '%s' to AOT Code Cache\", name);\n+  log_debug(aot, codecache, stubs)(\"Writing blob '%s' (id=%u, kind=%s) to AOT Code Cache\", name, id, aot_code_entry_kind_name[entry_kind]);\n@@ -724,0 +826,10 @@\n+#ifndef PRODUCT\n+  \/\/ Write asm remarks\n+  if (!cache->write_asm_remarks(blob)) {\n+    return false;\n+  }\n+  if (!cache->write_dbg_strings(blob)) {\n+    return false;\n+  }\n+#endif \/* PRODUCT *\/\n+\n@@ -741,1 +853,1 @@\n-  AOTCodeEntry* entry = new(cache) AOTCodeEntry(entry_kind, id,\n+  AOTCodeEntry* entry = new(cache) AOTCodeEntry(entry_kind, encode_id(entry_kind, id),\n@@ -744,1 +856,1 @@\n-  log_debug(aot, codecache, stubs)(\"Wrote code blob '%s(id=%d)' to AOT Code Cache\", name, id);\n+  log_debug(aot, codecache, stubs)(\"Wrote code blob '%s' (id=%u, kind=%s) to AOT Code Cache\", name, id, aot_code_entry_kind_name[entry_kind]);\n@@ -755,1 +867,4 @@\n-  if ((entry_kind == AOTCodeEntry::Adapter) && !AOTAdapterCaching) {\n+  if (AOTCodeEntry::is_adapter(entry_kind) && !is_using_adapters()) {\n+    return nullptr;\n+  }\n+  if (AOTCodeEntry::is_blob(entry_kind) && !is_using_stubs()) {\n@@ -758,1 +873,1 @@\n-  log_debug(aot, codecache, stubs)(\"Reading blob '%s' from AOT Code Cache\", name);\n+  log_debug(aot, codecache, stubs)(\"Reading blob '%s' (id=%u, kind=%s) from AOT Code Cache\", name, id, aot_code_entry_kind_name[entry_kind]);\n@@ -760,1 +875,1 @@\n-  AOTCodeEntry* entry = cache->find_entry(entry_kind, id);\n+  AOTCodeEntry* entry = cache->find_entry(entry_kind, encode_id(entry_kind, id));\n@@ -765,1 +880,4 @@\n-  return reader.compile_code_blob(name, entry_offset_count, entry_offsets);\n+  CodeBlob* blob = reader.compile_code_blob(name, entry_offset_count, entry_offsets);\n+\n+  log_debug(aot, codecache, stubs)(\"Read blob '%s' (id=%u, kind=%s) from AOT Code Cache\", name, id, aot_code_entry_kind_name[entry_kind]);\n+  return blob;\n@@ -798,1 +916,16 @@\n-  CodeBlob* code_blob = CodeBlob::create(archived_blob, stored_name, reloc_data, oop_maps);\n+#ifndef PRODUCT\n+  AsmRemarks asm_remarks;\n+  read_asm_remarks(asm_remarks);\n+  DbgStrings dbg_strings;\n+  read_dbg_strings(dbg_strings);\n+#endif \/\/ PRODUCT\n+\n+  CodeBlob* code_blob = CodeBlob::create(archived_blob,\n+                                         stored_name,\n+                                         reloc_data,\n+                                         oop_maps\n+#ifndef PRODUCT\n+                                         , asm_remarks\n+                                         , dbg_strings\n+#endif\n+                                        );\n@@ -820,1 +953,0 @@\n-  log_debug(aot, codecache, stubs)(\"Read blob '%s' from AOT Code Cache\", name);\n@@ -865,0 +997,2 @@\n+      case relocInfo::post_call_nop_type:\n+        break;\n@@ -938,0 +1072,2 @@\n+      case relocInfo::post_call_nop_type:\n+        break;\n@@ -973,0 +1109,82 @@\n+#ifndef PRODUCT\n+bool AOTCodeCache::write_asm_remarks(CodeBlob& cb) {\n+  \/\/ Write asm remarks\n+  uint* count_ptr = (uint *)reserve_bytes(sizeof(uint));\n+  if (count_ptr == nullptr) {\n+    return false;\n+  }\n+  uint count = 0;\n+  bool result = cb.asm_remarks().iterate([&] (uint offset, const char* str) -> bool {\n+    log_trace(aot, codecache, stubs)(\"asm remark offset=%d, str='%s'\", offset, str);\n+    uint n = write_bytes(&offset, sizeof(uint));\n+    if (n != sizeof(uint)) {\n+      return false;\n+    }\n+    const char* cstr = add_C_string(str);\n+    int id = _table->id_for_C_string((address)cstr);\n+    assert(id != -1, \"asm remark string '%s' not found in AOTCodeAddressTable\", str);\n+    n = write_bytes(&id, sizeof(int));\n+    if (n != sizeof(int)) {\n+      return false;\n+    }\n+    count += 1;\n+    return true;\n+  });\n+  *count_ptr = count;\n+  return result;\n+}\n+\n+void AOTCodeReader::read_asm_remarks(AsmRemarks& asm_remarks) {\n+  \/\/ Read asm remarks\n+  uint offset = read_position();\n+  uint count = *(uint *)addr(offset);\n+  offset += sizeof(uint);\n+  for (uint i = 0; i < count; i++) {\n+    uint remark_offset = *(uint *)addr(offset);\n+    offset += sizeof(uint);\n+    int remark_string_id = *(uint *)addr(offset);\n+    offset += sizeof(int);\n+    const char* remark = (const char*)_cache->address_for_C_string(remark_string_id);\n+    asm_remarks.insert(remark_offset, remark);\n+  }\n+  set_read_position(offset);\n+}\n+\n+bool AOTCodeCache::write_dbg_strings(CodeBlob& cb) {\n+  \/\/ Write dbg strings\n+  uint* count_ptr = (uint *)reserve_bytes(sizeof(uint));\n+  if (count_ptr == nullptr) {\n+    return false;\n+  }\n+  uint count = 0;\n+  bool result = cb.dbg_strings().iterate([&] (const char* str) -> bool {\n+    log_trace(aot, codecache, stubs)(\"dbg string=%s\", str);\n+    const char* cstr = add_C_string(str);\n+    int id = _table->id_for_C_string((address)cstr);\n+    assert(id != -1, \"db string '%s' not found in AOTCodeAddressTable\", str);\n+    uint n = write_bytes(&id, sizeof(int));\n+    if (n != sizeof(int)) {\n+      return false;\n+    }\n+    count += 1;\n+    return true;\n+  });\n+  *count_ptr = count;\n+  return result;\n+}\n+\n+void AOTCodeReader::read_dbg_strings(DbgStrings& dbg_strings) {\n+  \/\/ Read dbg strings\n+  uint offset = read_position();\n+  uint count = *(uint *)addr(offset);\n+  offset += sizeof(uint);\n+  for (uint i = 0; i < count; i++) {\n+    int string_id = *(uint *)addr(offset);\n+    offset += sizeof(int);\n+    const char* str = (const char*)_cache->address_for_C_string(string_id);\n+    dbg_strings.insert(str);\n+  }\n+  set_read_position(offset);\n+}\n+#endif \/\/ PRODUCT\n+\n@@ -982,3 +1200,0 @@\n-#define _extrs_max 13\n-#define _blobs_max 10\n-#define _all_max   23\n@@ -986,3 +1201,2 @@\n-#define _extrs_base 0\n-#define _blobs_base (_extrs_base + _extrs_max)\n-#define _blobs_end  (_blobs_base + _blobs_max)\n+#define _extrs_max 100\n+#define _stubs_max 3\n@@ -990,3 +1204,10 @@\n-#if (_blobs_end > _all_max)\n-#error AOTCodeAddress table ranges need adjusting\n-#endif\n+#define _shared_blobs_max 20\n+#define _C1_blobs_max 10\n+#define _blobs_max (_shared_blobs_max+_C1_blobs_max)\n+#define _all_max (_extrs_max+_stubs_max+_blobs_max)\n+\n+#define _extrs_base 0\n+#define _stubs_base (_extrs_base + _extrs_max)\n+#define _shared_blobs_base (_stubs_base + _stubs_max)\n+#define _C1_blobs_base (_shared_blobs_base + _shared_blobs_max)\n+#define _blobs_end  (_shared_blobs_base + _blobs_max)\n@@ -1004,0 +1225,3 @@\n+\n+  assert(_blobs_end <= _all_max, \"AOTCodeAddress table ranges need adjusting\");\n+\n@@ -1009,1 +1233,1 @@\n-  \/\/ Recored addresses of VM runtime methods\n+  \/\/ Record addresses of VM runtime methods\n@@ -1014,0 +1238,87 @@\n+#if defined(AARCH64)\n+  SET_ADDRESS(_extrs, JavaThread::aarch64_get_thread_helper);\n+#endif\n+  {\n+    \/\/ Required by Shared blobs\n+    SET_ADDRESS(_extrs, Deoptimization::fetch_unroll_info);\n+    SET_ADDRESS(_extrs, Deoptimization::unpack_frames);\n+    SET_ADDRESS(_extrs, SafepointSynchronize::handle_polling_page_exception);\n+    SET_ADDRESS(_extrs, SharedRuntime::resolve_opt_virtual_call_C);\n+    SET_ADDRESS(_extrs, SharedRuntime::resolve_virtual_call_C);\n+    SET_ADDRESS(_extrs, SharedRuntime::resolve_static_call_C);\n+    SET_ADDRESS(_extrs, SharedRuntime::throw_delayed_StackOverflowError);\n+    SET_ADDRESS(_extrs, SharedRuntime::throw_AbstractMethodError);\n+    SET_ADDRESS(_extrs, SharedRuntime::throw_IncompatibleClassChangeError);\n+    SET_ADDRESS(_extrs, SharedRuntime::throw_NullPointerException_at_call);\n+  }\n+\n+#ifdef COMPILER1\n+  {\n+    \/\/ Required by C1 blobs\n+    SET_ADDRESS(_extrs, static_cast<int (*)(oopDesc*)>(SharedRuntime::dtrace_object_alloc));\n+    SET_ADDRESS(_extrs, SharedRuntime::exception_handler_for_return_address);\n+    SET_ADDRESS(_extrs, SharedRuntime::register_finalizer);\n+    SET_ADDRESS(_extrs, Runtime1::is_instance_of);\n+    SET_ADDRESS(_extrs, Runtime1::exception_handler_for_pc);\n+    SET_ADDRESS(_extrs, Runtime1::check_abort_on_vm_exception);\n+    SET_ADDRESS(_extrs, Runtime1::new_instance);\n+    SET_ADDRESS(_extrs, Runtime1::counter_overflow);\n+    SET_ADDRESS(_extrs, Runtime1::new_type_array);\n+    SET_ADDRESS(_extrs, Runtime1::new_object_array);\n+    SET_ADDRESS(_extrs, Runtime1::new_multi_array);\n+    SET_ADDRESS(_extrs, Runtime1::throw_range_check_exception);\n+    SET_ADDRESS(_extrs, Runtime1::throw_index_exception);\n+    SET_ADDRESS(_extrs, Runtime1::throw_div0_exception);\n+    SET_ADDRESS(_extrs, Runtime1::throw_null_pointer_exception);\n+    SET_ADDRESS(_extrs, Runtime1::throw_array_store_exception);\n+    SET_ADDRESS(_extrs, Runtime1::throw_class_cast_exception);\n+    SET_ADDRESS(_extrs, Runtime1::throw_incompatible_class_change_error);\n+    SET_ADDRESS(_extrs, Runtime1::is_instance_of);\n+    SET_ADDRESS(_extrs, Runtime1::monitorenter);\n+    SET_ADDRESS(_extrs, Runtime1::monitorexit);\n+    SET_ADDRESS(_extrs, Runtime1::deoptimize);\n+    SET_ADDRESS(_extrs, Runtime1::access_field_patching);\n+    SET_ADDRESS(_extrs, Runtime1::move_klass_patching);\n+    SET_ADDRESS(_extrs, Runtime1::move_mirror_patching);\n+    SET_ADDRESS(_extrs, Runtime1::move_appendix_patching);\n+    SET_ADDRESS(_extrs, Runtime1::predicate_failed_trap);\n+    SET_ADDRESS(_extrs, Runtime1::unimplemented_entry);\n+    SET_ADDRESS(_extrs, Thread::current);\n+    SET_ADDRESS(_extrs, CompressedKlassPointers::base_addr());\n+#ifndef PRODUCT\n+    SET_ADDRESS(_extrs, os::breakpoint);\n+#endif\n+  }\n+#endif\n+\n+#ifdef COMPILER2\n+  {\n+    \/\/ Required by C2 blobs\n+    SET_ADDRESS(_extrs, Deoptimization::uncommon_trap);\n+    SET_ADDRESS(_extrs, OptoRuntime::handle_exception_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::new_instance_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::new_array_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::new_array_nozero_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::multianewarray2_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::multianewarray3_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::multianewarray4_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::multianewarray5_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::multianewarrayN_C);\n+#if INCLUDE_JVMTI\n+    SET_ADDRESS(_extrs, SharedRuntime::notify_jvmti_vthread_start);\n+    SET_ADDRESS(_extrs, SharedRuntime::notify_jvmti_vthread_end);\n+    SET_ADDRESS(_extrs, SharedRuntime::notify_jvmti_vthread_mount);\n+    SET_ADDRESS(_extrs, SharedRuntime::notify_jvmti_vthread_unmount);\n+#endif\n+    SET_ADDRESS(_extrs, OptoRuntime::complete_monitor_locking_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::monitor_notify_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::monitor_notifyAll_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::rethrow_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::slow_arraycopy_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::register_finalizer_C);\n+#if defined(AARCH64)\n+    SET_ADDRESS(_extrs, JavaThread::verify_cross_modify_fence_failure);\n+#endif \/\/ AARCH64\n+  }\n+#endif \/\/ COMPILER2\n+\n@@ -1029,3 +1340,0 @@\n-#ifdef COMPILER2\n-  SET_ADDRESS(_extrs, OptoRuntime::handle_exception_C);\n-#endif\n@@ -1042,0 +1350,21 @@\n+static bool initializing_early_stubs = false;\n+\n+void AOTCodeAddressTable::init_early_stubs() {\n+  if (_complete || initializing_early_stubs) return; \/\/ Done already\n+  initializing_early_stubs = true;\n+  _stubs_addr = NEW_C_HEAP_ARRAY(address, _stubs_max, mtCode);\n+  _stubs_length = 0;\n+  SET_ADDRESS(_stubs, StubRoutines::forward_exception_entry());\n+\n+  {\n+    \/\/ Required by C1 blobs\n+#if defined(AMD64) && !defined(ZERO)\n+    SET_ADDRESS(_stubs, StubRoutines::x86::double_sign_flip());\n+    SET_ADDRESS(_stubs, StubRoutines::x86::d2l_fixup());\n+#endif \/\/ AMD64\n+  }\n+\n+  _early_stubs_complete = true;\n+  log_info(aot, codecache, init)(\"Early stubs recorded\");\n+}\n+\n@@ -1047,7 +1376,21 @@\n-  _blobs_addr = NEW_C_HEAP_ARRAY(address, _blobs_max, mtCode);\n-\n-  _blobs_length = 0;       \/\/ for shared blobs\n-\n-  \/\/ Recored addresses of generated code blobs\n-  SET_ADDRESS(_blobs, SharedRuntime::get_handle_wrong_method_stub());\n-  SET_ADDRESS(_blobs, SharedRuntime::get_ic_miss_stub());\n+  address* blobs_addr = NEW_C_HEAP_ARRAY(address, _blobs_max, mtCode);\n+  _shared_blobs_addr = blobs_addr;\n+  _C1_blobs_addr = _shared_blobs_addr + _shared_blobs_max;\n+  _shared_blobs_length = _C1_blobs_length = 0;\n+\n+  \/\/ clear the address table\n+  memset(blobs_addr, 0, sizeof(address)* _blobs_max);\n+\n+  \/\/ Record addresses of generated code blobs\n+  SET_ADDRESS(_shared_blobs, SharedRuntime::get_handle_wrong_method_stub());\n+  SET_ADDRESS(_shared_blobs, SharedRuntime::get_ic_miss_stub());\n+  SET_ADDRESS(_shared_blobs, SharedRuntime::deopt_blob()->unpack());\n+  SET_ADDRESS(_shared_blobs, SharedRuntime::deopt_blob()->unpack_with_exception());\n+  SET_ADDRESS(_shared_blobs, SharedRuntime::deopt_blob()->unpack_with_reexecution());\n+  SET_ADDRESS(_shared_blobs, SharedRuntime::deopt_blob()->unpack_with_exception_in_tls());\n+#if INCLUDE_JVMCI\n+  if (EnableJVMCI) {\n+    SET_ADDRESS(_shared_blobs, SharedRuntime::deopt_blob()->uncommon_trap());\n+    SET_ADDRESS(_shared_blobs, SharedRuntime::deopt_blob()->implicit_exception_uncommon_trap());\n+  }\n+#endif\n@@ -1060,0 +1403,21 @@\n+void AOTCodeAddressTable::init_early_c1() {\n+#ifdef COMPILER1\n+  \/\/ Runtime1 Blobs\n+  for (int i = 0; i <= (int)C1StubId::forward_exception_id; i++) {\n+    C1StubId id = (C1StubId)i;\n+    if (Runtime1::blob_for(id) == nullptr) {\n+      log_info(aot, codecache, init)(\"C1 blob %s is missing\", Runtime1::name_for(id));\n+      continue;\n+    }\n+    if (Runtime1::entry_for(id) == nullptr) {\n+      log_info(aot, codecache, init)(\"C1 blob %s is missing entry\", Runtime1::name_for(id));\n+      continue;\n+    }\n+    address entry = Runtime1::entry_for(id);\n+    SET_ADDRESS(_C1_blobs, entry);\n+  }\n+#endif \/\/ COMPILER1\n+  assert(_C1_blobs_length <= _C1_blobs_max, \"increase _C1_blobs_max to %d\", _C1_blobs_length);\n+  _early_c1_complete = true;\n+}\n+\n@@ -1066,2 +1430,2 @@\n-  if (_blobs_addr != nullptr) {\n-    FREE_C_HEAP_ARRAY(address, _blobs_addr);\n+  if (_shared_blobs_addr != nullptr) {\n+    FREE_C_HEAP_ARRAY(address, _shared_blobs_addr);\n@@ -1077,1 +1441,1 @@\n-#define _c_str_base _all_max\n+static const int _c_str_base = _all_max;\n@@ -1233,2 +1597,8 @@\n-  if (id >= _blobs_base && id < _blobs_base + _blobs_length) {\n-    return _blobs_addr[id - _blobs_base];\n+  if (id >= _stubs_base && id < _stubs_base + _stubs_length) {\n+    return _stubs_addr[id - _stubs_base];\n+  }\n+  if (id >= _shared_blobs_base && id < _shared_blobs_base + _shared_blobs_length) {\n+    return _shared_blobs_addr[id - _shared_blobs_base];\n+  }\n+  if (id >= _C1_blobs_base && id < _C1_blobs_base + _C1_blobs_length) {\n+    return _C1_blobs_addr[id - _C1_blobs_base];\n@@ -1258,3 +1628,10 @@\n-    StubCodeDesc* desc = StubCodeDesc::desc_for(addr);\n-    if (desc == nullptr) {\n-      desc = StubCodeDesc::desc_for(addr + frame::pc_return_offset);\n+    id = search_address(addr, _stubs_addr, _stubs_length);\n+    if (id < 0) {\n+      StubCodeDesc* desc = StubCodeDesc::desc_for(addr);\n+      if (desc == nullptr) {\n+        desc = StubCodeDesc::desc_for(addr + frame::pc_return_offset);\n+      }\n+      const char* sub_name = (desc != nullptr) ? desc->name() : \"<unknown>\";\n+      fatal(\"Address \" INTPTR_FORMAT \" for Stub:%s is missing in AOT Code Cache addresses table\", p2i(addr), sub_name);\n+    } else {\n+      return id + _stubs_base;\n@@ -1262,2 +1639,0 @@\n-    const char* sub_name = (desc != nullptr) ? desc->name() : \"<unknown>\";\n-    fatal(\"Address \" INTPTR_FORMAT \" for Stub:%s is missing in AOT Code Cache addresses table\", p2i(addr), sub_name);\n@@ -1268,2 +1643,2 @@\n-      int id_base = _blobs_base;\n-      id = search_address(addr, _blobs_addr, _blobs_length);\n+      int id_base = _shared_blobs_base;\n+      id = search_address(addr, _shared_blobs_addr, _blobs_max);\n@@ -1334,1 +1709,0 @@\n-\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.cpp","additions":425,"deletions":51,"binary":false,"changes":476,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+class AsmRemarks;\n+class DbgStrings;\n@@ -45,0 +47,7 @@\n+#define DO_AOTCODEENTRY_KIND(Fn) \\\n+  Fn(None) \\\n+  Fn(Adapter) \\\n+  Fn(SharedBlob) \\\n+  Fn(C1Blob) \\\n+  Fn(C2Blob) \\\n+\n@@ -48,4 +57,5 @@\n-  enum Kind {\n-    None    = 0,\n-    Adapter = 1,\n-    Blob    = 2\n+  enum Kind : s1 {\n+#define DECL_KIND_ENUM(kind) kind,\n+    DO_AOTCODEENTRY_KIND(DECL_KIND_ENUM)\n+#undef DECL_KIND_ENUM\n+    Kind_count\n@@ -103,1 +113,3 @@\n-  static bool is_valid_entry_kind(Kind kind) { return kind == Adapter || kind == Blob; }\n+  static bool is_valid_entry_kind(Kind kind) { return kind > None && kind < Kind_count; }\n+  static bool is_blob(Kind kind) { return kind == SharedBlob || kind == C1Blob || kind == C2Blob; }\n+  static bool is_adapter(Kind kind) { return kind == Adapter; }\n@@ -110,1 +122,3 @@\n-  address* _blobs_addr;\n+  address* _stubs_addr;\n+  address* _shared_blobs_addr;\n+  address* _C1_blobs_addr;\n@@ -112,1 +126,3 @@\n-  uint     _blobs_length;\n+  uint     _stubs_length;\n+  uint     _shared_blobs_length;\n+  uint     _C1_blobs_length;\n@@ -115,0 +131,1 @@\n+  bool _early_stubs_complete;\n@@ -116,0 +133,1 @@\n+  bool _early_c1_complete;\n@@ -121,1 +139,2 @@\n-    _blobs_addr(nullptr),\n+    _shared_blobs_addr(nullptr),\n+    _C1_blobs_addr(nullptr),\n@@ -123,1 +142,3 @@\n-    _blobs_length(0),\n+    _stubs_length(0),\n+    _shared_blobs_length(0),\n+    _C1_blobs_length(0),\n@@ -125,0 +146,1 @@\n+    _early_stubs_complete(false),\n@@ -126,0 +148,1 @@\n+    _early_c1_complete(false),\n@@ -130,0 +153,1 @@\n+  void init_early_stubs();\n@@ -131,0 +155,1 @@\n+  void init_early_c1();\n@@ -144,0 +169,1 @@\n+    address _compressedOopBase;\n@@ -178,1 +204,3 @@\n-    uint   _blobs_count;\n+    uint   _shared_blobs_count;\n+    uint   _C1_blobs_count;\n+    uint   _C2_blobs_count;\n@@ -185,1 +213,2 @@\n-              uint adapters_count, uint blobs_count) {\n+              uint adapters_count, uint shared_blobs_count,\n+              uint C1_blobs_count, uint C2_blobs_count) {\n@@ -193,2 +222,3 @@\n-      _blobs_count    = blobs_count;\n-\n+      _shared_blobs_count = shared_blobs_count;\n+      _C1_blobs_count = C1_blobs_count;\n+      _C2_blobs_count = C2_blobs_count;\n@@ -205,1 +235,3 @@\n-    uint blobs_count()    const { return _blobs_count; }\n+    uint shared_blobs_count()    const { return _shared_blobs_count; }\n+    uint C1_blobs_count() const { return _C1_blobs_count; }\n+    uint C2_blobs_count() const { return _C2_blobs_count; }\n@@ -270,0 +302,1 @@\n+  static void init_early_stubs_table() NOT_CDS_RETURN;\n@@ -271,0 +304,1 @@\n+  static void init_early_c1_table() NOT_CDS_RETURN;\n@@ -272,0 +306,1 @@\n+  address address_for_C_string(int idx) const { return _table->address_for_C_string(idx); }\n@@ -291,0 +326,4 @@\n+#ifndef PRODUCT\n+  bool write_asm_remarks(CodeBlob& cb);\n+  bool write_dbg_strings(CodeBlob& cb);\n+#endif \/\/ PRODUCT\n@@ -295,2 +334,2 @@\n-                              int entry_offset_count,\n-                              int* entry_offsets) NOT_CDS_RETURN_(false);\n+                              int entry_offset_count = 0,\n+                              int* entry_offsets = nullptr) NOT_CDS_RETURN_(false);\n@@ -300,2 +339,2 @@\n-                                  int entry_offset_count,\n-                                  int* entry_offsets) NOT_CDS_RETURN_(nullptr);\n+                                  int entry_offset_count = 0,\n+                                  int* entry_offsets = nullptr) NOT_CDS_RETURN_(nullptr);\n@@ -334,0 +373,3 @@\n+  static bool is_dumping_stubs() NOT_CDS_RETURN_(false);\n+  static bool is_using_stubs() NOT_CDS_RETURN_(false);\n+\n@@ -364,0 +406,4 @@\n+#ifndef PRODUCT\n+  void read_asm_remarks(AsmRemarks& asm_remarks);\n+  void read_dbg_strings(DbgStrings& dbg_strings);\n+#endif \/\/ PRODUCT\n@@ -365,1 +411,2 @@\n-#endif \/\/ SHARE_CODE_AOTCODECACH_HPP\n+\n+#endif \/\/ SHARE_CODE_AOTCODECACHE_HPP\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.hpp","additions":66,"deletions":19,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -267,1 +267,5 @@\n-CodeBlob* CodeBlob::restore(address code_cache_buffer, const char* name, address archived_reloc_data, ImmutableOopMapSet* archived_oop_maps) {\n+CodeBlob* CodeBlob::restore(address code_cache_buffer,\n+                            const char* name,\n+                            address archived_reloc_data,\n+                            ImmutableOopMapSet* archived_oop_maps)\n+{\n@@ -276,1 +280,10 @@\n-CodeBlob* CodeBlob::create(CodeBlob* archived_blob, const char* name, address archived_reloc_data, ImmutableOopMapSet* archived_oop_maps) {\n+CodeBlob* CodeBlob::create(CodeBlob* archived_blob,\n+                           const char* name,\n+                           address archived_reloc_data,\n+                           ImmutableOopMapSet* archived_oop_maps\n+#ifndef PRODUCT\n+                           , AsmRemarks& archived_asm_remarks\n+                           , DbgStrings& archived_dbg_strings\n+#endif \/\/ PRODUCT\n+                          )\n+{\n@@ -287,1 +300,11 @@\n-      blob = archived_blob->restore(code_cache_buffer, name, archived_reloc_data, archived_oop_maps);\n+      blob = archived_blob->restore(code_cache_buffer,\n+                                    name,\n+                                    archived_reloc_data,\n+                                    archived_oop_maps);\n+#ifndef PRODUCT\n+      blob->use_remarks(archived_asm_remarks);\n+      archived_asm_remarks.clear();\n+      blob->use_strings(archived_dbg_strings);\n+      archived_dbg_strings.clear();\n+#endif \/\/ PRODUCT\n+\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":26,"deletions":3,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -102,0 +102,3 @@\n+class DeoptimizationBlob;\n+class SafepointBlob;\n+class UncommonTrapBlob;\n@@ -208,0 +211,3 @@\n+  ExceptionBlob* as_exception_blob() const    { assert(is_exception_stub(), \"must be exception stub\"); return (ExceptionBlob*) this; }\n+  DeoptimizationBlob* as_deoptimization_blob() const { assert(is_deoptimization_stub(), \"must be deopt stub\"); return (DeoptimizationBlob*) this; }\n+  SafepointBlob* as_safepoint_blob() const    { assert(is_safepoint_stub(), \"must be safepoint stub\"); return (SafepointBlob*) this; }\n@@ -210,0 +216,1 @@\n+  UncommonTrapBlob* as_uncommon_trap_blob() const { assert(is_uncommon_trap_stub(), \"must be uncommon trap stub\"); return (UncommonTrapBlob*) this; }\n@@ -311,1 +318,9 @@\n-  static CodeBlob* create(CodeBlob* archived_blob, const char* name, address archived_reloc_data, ImmutableOopMapSet* archived_oop_maps);\n+  static CodeBlob* create(CodeBlob* archived_blob,\n+                          const char* name,\n+                          address archived_reloc_data,\n+                          ImmutableOopMapSet* archived_oop_maps\n+#ifndef PRODUCT\n+                          , AsmRemarks& archived_asm_remarks\n+                          , DbgStrings& archived_dbg_strings\n+#endif \/\/ PRODUCT\n+                         );\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -216,0 +216,1 @@\n+  static address  base_addr()        { return  (address)&_base; }\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -633,0 +634,1 @@\n+      _stub_id(-1),\n@@ -902,0 +904,1 @@\n+                 int stub_id,\n@@ -913,0 +916,1 @@\n+      _stub_id(stub_id),\n@@ -964,0 +968,10 @@\n+  \/\/ try to reuse an existing stub\n+  {\n+    CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::C2Blob, _stub_id, stub_name);\n+    if (blob != nullptr) {\n+      RuntimeStub* rs = blob->as_runtime_stub();\n+      _stub_entry_point = rs->entry_point();\n+      return;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -311,0 +311,1 @@\n+  int                   _stub_id;               \/\/ unique id for stub or -1\n@@ -573,0 +574,1 @@\n+  int               stub_id() const             { return _stub_id; }\n@@ -1143,1 +1145,1 @@\n-          int is_fancy_jump, bool pass_tls,\n+          int stub_id, int is_fancy_jump, bool pass_tls,\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -3490,0 +3491,1 @@\n+        AOTCodeCache::store_code_blob(*rs, AOTCodeEntry::C2Blob, C->stub_id(), stub_name);\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+#define C2_STUB_ID(name) OptoStubId::name ## _id\n@@ -156,1 +157,1 @@\n-    generate_stub(env,                                                  \\\n+    generate_stub(env,                                                \\\n@@ -160,3 +161,4 @@\n-                  fancy_jump,                                           \\\n-                  pass_tls,                                             \\\n-                  pass_retpc);                                          \\\n+                  (int)C2_STUB_ID(name),                              \\\n+                  fancy_jump,                                         \\\n+                  pass_tls,                                           \\\n+                  pass_retpc);                                        \\\n@@ -168,3 +170,3 @@\n-  STUB_FIELD_NAME(name) =                                               \\\n-    generate_stub(env,                                                  \\\n-                  notify_jvmti_vthread_Type,                            \\\n+  STUB_FIELD_NAME(name) =                                             \\\n+    generate_stub(env,                                                \\\n+                  notify_jvmti_vthread_Type,                          \\\n@@ -173,4 +175,5 @@\n-                  0,                                                    \\\n-                  true,                                                 \\\n-                  false);                                               \\\n-  if (STUB_FIELD_NAME(name) == nullptr) { return false; }               \\\n+                  (int)C2_STUB_ID(name),                              \\\n+                  0,                                                  \\\n+                  true,                                               \\\n+                  false);                                             \\\n+  if (STUB_FIELD_NAME(name) == nullptr) { return false; }             \\\n@@ -280,2 +283,2 @@\n-                                   const char *name, int is_fancy_jump,\n-                                   bool pass_tls,\n+                                   const char *name, int stub_id,\n+                                   int is_fancy_jump, bool pass_tls,\n@@ -288,1 +291,1 @@\n-  Compile C(env, gen, C_function, name, is_fancy_jump, pass_tls, return_pc, directive);\n+  Compile C(env, gen, C_function, name, stub_id, is_fancy_jump, pass_tls, return_pc, directive);\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":17,"deletions":14,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -220,1 +220,1 @@\n-  static address generate_stub(ciEnv* ci_env, TypeFunc_generator gen, address C_function, const char* name, int is_fancy_jump, bool pass_tls, bool return_pc);\n+  static address generate_stub(ciEnv* ci_env, TypeFunc_generator gen, address C_function, const char* name, int stub_id, int is_fancy_jump, bool pass_tls, bool return_pc);\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,163 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Sanity test of AOT Code Cache with compressed oops configurations\n+ * @requires vm.cds\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @requires vm.flagless\n+ * @requires !vm.jvmci.enabled\n+ * @library \/test\/lib \/test\/setup_aot\n+ * @build AOTCodeCompressedOopsTest JavacBenchApp\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar\n+ *             JavacBenchApp\n+ *             JavacBenchApp$ClassFile\n+ *             JavacBenchApp$FileManager\n+ *             JavacBenchApp$SourceFile\n+ * @run driver AOTCodeCompressedOopsTest\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import jdk.test.lib.cds.CDSAppTester;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class AOTCodeCompressedOopsTest {\n+    public static void main(String... args) throws Exception {\n+        {\n+            Tester t = new Tester();\n+            t.setHeapConfig(Tester.RunMode.ASSEMBLY, true, true);\n+            t.runAOTAssemblyWorkflow();\n+            t.setHeapConfig(Tester.RunMode.PRODUCTION, true, true);\n+            t.productionRun();\n+            t.setHeapConfig(Tester.RunMode.PRODUCTION, true, false);\n+            t.productionRun();\n+            t.setHeapConfig(Tester.RunMode.PRODUCTION, false, false);\n+            t.productionRun();\n+        }\n+        {\n+            Tester t = new Tester();\n+            t.setHeapConfig(Tester.RunMode.ASSEMBLY, true, false);\n+            t.runAOTAssemblyWorkflow();\n+            t.setHeapConfig(Tester.RunMode.PRODUCTION, true, true);\n+            t.productionRun();\n+            t.setHeapConfig(Tester.RunMode.PRODUCTION, true, false);\n+            t.productionRun();\n+            t.setHeapConfig(Tester.RunMode.PRODUCTION, false, false);\n+            t.productionRun();\n+        }\n+        {\n+            Tester t = new Tester();\n+            t.setHeapConfig(Tester.RunMode.ASSEMBLY, false, false);\n+            t.runAOTAssemblyWorkflow();\n+            t.setHeapConfig(Tester.RunMode.PRODUCTION, true, true);\n+            t.productionRun();\n+            t.setHeapConfig(Tester.RunMode.PRODUCTION, true, false);\n+            t.productionRun();\n+            t.setHeapConfig(Tester.RunMode.PRODUCTION, false, false);\n+            t.productionRun();\n+        }\n+    }\n+    static class Tester extends CDSAppTester {\n+        boolean zeroBaseInAsmPhase, zeroBaseInProdPhase;\n+        boolean zeroShiftInAsmPhase, zeroShiftInProdPhase;\n+\n+        public Tester() {\n+            super(\"AOTCodeCompressedOopsTest\");\n+        }\n+\n+        public void setHeapConfig(RunMode runMode, boolean isBaseZero, boolean isShiftZero) {\n+            if (runMode == RunMode.ASSEMBLY) {\n+                zeroBaseInAsmPhase = isBaseZero;\n+                zeroShiftInAsmPhase = isShiftZero;\n+            } else if (runMode == RunMode.PRODUCTION) {\n+                zeroBaseInProdPhase = isBaseZero;\n+                zeroShiftInProdPhase = isShiftZero;\n+            }\n+        }\n+\n+        @Override\n+        public String classpath(RunMode runMode) {\n+            return \"app.jar\";\n+        }\n+\n+        List<String> getVMArgsForHeapConfig(boolean isBaseZero, boolean isShiftZero) {\n+            List<String> list = new ArrayList<String>();\n+            if (isBaseZero && isShiftZero) {\n+                list.add(\"-Xmx1g\"); \/\/ Set max heap < 4G\n+            } else if (isBaseZero && !isShiftZero) {\n+                list.add(\"-Xmx6g\"); \/\/ Set max heap > 4G\n+            } else if (!isBaseZero && !isShiftZero) {\n+                list.add(\"-Xmx6g\");\n+                list.add(\"-XX:HeapBaseMinAddress=32g\");\n+            }\n+            return list;\n+       }\n+\n+        @Override\n+        public String[] vmArgs(RunMode runMode) {\n+            switch (runMode) {\n+            case RunMode.ASSEMBLY: {\n+                    List<String> args = getVMArgsForHeapConfig(zeroBaseInAsmPhase, zeroShiftInAsmPhase);\n+                    args.addAll(List.of(\"-XX:+UnlockDiagnosticVMOptions\",\n+                                        \"-Xlog:cds=info\",\n+                                        \"-Xlog:aot+codecache+init=debug\",\n+                                        \"-Xlog:aot+codecache+exit=debug\"));\n+                    return args.toArray(new String[0]);\n+                }\n+            case RunMode.PRODUCTION: {\n+                    List<String> args = getVMArgsForHeapConfig(zeroBaseInProdPhase, zeroShiftInProdPhase);\n+                    args.addAll(List.of(\"-XX:+UnlockDiagnosticVMOptions\",\n+                                        \"-Xlog:cds=info\",\n+                                        \"-Xlog:aot+codecache+init=debug\",\n+                                        \"-Xlog:aot+codecache+exit=debug\"));\n+                    return args.toArray(new String[0]);\n+                }\n+            }\n+            return new String[] {};\n+        }\n+\n+        @Override\n+        public String[] appCommandLine(RunMode runMode) {\n+            return new String[] {\n+                \"JavacBenchApp\", \"10\"\n+            };\n+        }\n+\n+        @Override\n+        public void checkExecution(OutputAnalyzer out, RunMode runMode) throws Exception {\n+            if (runMode == RunMode.PRODUCTION) {\n+                 if (zeroShiftInAsmPhase != zeroShiftInProdPhase) {\n+                     out.shouldContain(\"AOT Code Cache disabled: it was created with different CompressedOops::shift()\");\n+                 } else if (zeroBaseInAsmPhase != zeroBaseInProdPhase) {\n+                     out.shouldContain(\"AOTStubCaching is disabled: incompatible CompressedOops::base()\");\n+                 } else {\n+                     out.shouldMatch(\"Read \\\\d+ entries table at offset \\\\d+ from AOT Code Cache\");\n+                 }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCode\/AOTCodeCompressedOopsTest.java","additions":163,"deletions":0,"binary":false,"changes":163,"status":"added"},{"patch":"@@ -43,0 +43,3 @@\n+import java.util.ArrayList;\n+import java.util.List;\n+\n@@ -47,1 +50,0 @@\n-    public static int flag_sign = 0;\n@@ -50,2 +52,2 @@\n-        for (int i = 0; i < 2; i++) {\n-            flag_sign = i;\n+        for (int mode = 0; mode < 3; mode++) {\n+            t.setTestMode(mode);\n@@ -56,0 +58,2 @@\n+        private int testMode;\n+\n@@ -57,1 +61,21 @@\n-            super(\"AOTCodeFlags\" + flag_sign);\n+            super(\"AOTCodeFlags\");\n+            testMode = 0;\n+        }\n+\n+        boolean isAdapterCachingOn() {\n+            return (testMode & 0x1) != 0;\n+        }\n+\n+        boolean isStubCachingOn() {\n+            return (testMode & 0x2) != 0;\n+        }\n+\n+        public void setTestMode(int mode) {\n+            testMode = mode;\n+        }\n+\n+        public List<String> getVMArgsForTestMode() {\n+            List<String> list = new ArrayList<String>();\n+            list.add(isAdapterCachingOn() ? \"-XX:+AOTAdapterCaching\" : \"-XX:-AOTAdapterCaching\");\n+            list.add(isStubCachingOn() ? \"-XX:+AOTStubCaching\" : \"-XX:-AOTStubCaching\");\n+            return list;\n@@ -69,7 +93,7 @@\n-            case RunMode.PRODUCTION:\n-                return new String[] {\n-                    \"-XX:+UnlockDiagnosticVMOptions\",\n-                    \"-XX:\" + (flag_sign == 0 ? \"-\" : \"+\") + \"AOTAdapterCaching\",\n-                    \"-Xlog:aot+codecache+init=debug\",\n-                    \"-Xlog:aot+codecache+exit=debug\",\n-                };\n+            case RunMode.PRODUCTION: {\n+                    List<String> args = getVMArgsForTestMode();\n+                    args.addAll(List.of(\"-XX:+UnlockDiagnosticVMOptions\",\n+                                        \"-Xlog:aot+codecache+init=debug\",\n+                                        \"-Xlog:aot+codecache+exit=debug\"));\n+                    return args.toArray(new String[0]);\n+                }\n@@ -89,1 +113,1 @@\n-            if (flag_sign == 0) {\n+            if (!isAdapterCachingOn() && !isStubCachingOn()) { \/\/ this is equivalent to completely disable AOT code cache\n@@ -93,1 +117,4 @@\n-                    out.shouldNotContain(\"Adapters:  total\");\n+                    out.shouldNotMatch(\"Adapters:\\\\s+total\");\n+                    out.shouldNotMatch(\"Shared Blobs:\\\\s+total\");\n+                    out.shouldNotMatch(\"C1 Blobs:\\\\s+total\");\n+                    out.shouldNotMatch(\"C2 Blobs:\\\\s+total\");\n@@ -96,1 +123,0 @@\n-\n@@ -98,5 +124,37 @@\n-                switch (runMode) {\n-                case RunMode.ASSEMBLY:\n-                case RunMode.PRODUCTION:\n-                    out.shouldContain(\"Adapters:  total\");\n-                    break;\n+                if (isAdapterCachingOn()) {\n+                    switch (runMode) {\n+                    case RunMode.ASSEMBLY:\n+                    case RunMode.PRODUCTION:\n+                        \/\/ AOTAdapterCaching is on, non-zero adapters should be stored\/loaded\n+                        out.shouldMatch(\"Adapters:\\\\s+total=[1-9][0-9]+\");\n+                        break;\n+                    }\n+                } else {\n+                    switch (runMode) {\n+                    case RunMode.ASSEMBLY:\n+                    case RunMode.PRODUCTION:\n+                        \/\/ AOTAdapterCaching is off, no adapters should be stored\/loaded\n+                        out.shouldMatch(\"Adapters:\\\\s+total=0\");\n+                        break;\n+                    }\n+                }\n+                if (isStubCachingOn()) {\n+                    switch (runMode) {\n+                    case RunMode.ASSEMBLY:\n+                    case RunMode.PRODUCTION:\n+                        \/\/ AOTStubCaching is on, non-zero stubs should be stored\/loaded\n+                        out.shouldMatch(\"Shared Blobs:\\\\s+total=[1-9][0-9]+\");\n+                        out.shouldMatch(\"C1 Blobs:\\\\s+total=[1-9][0-9]+\");\n+                        out.shouldMatch(\"C2 Blobs:\\\\s+total=[1-9][0-9]+\");\n+                        break;\n+                    }\n+                } else {\n+                    switch (runMode) {\n+                    case RunMode.ASSEMBLY:\n+                    case RunMode.PRODUCTION:\n+                        \/\/ AOTStubCaching is off, no stubs should be stored\/loaded\n+                        out.shouldMatch(\"Shared Blobs:\\\\s+total=0\");\n+                        out.shouldMatch(\"C1 Blobs:\\\\s+total=0\");\n+                        out.shouldMatch(\"C2 Blobs:\\\\s+total=0\");\n+                        break;\n+                    }\n@@ -106,1 +164,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCode\/AOTCodeFlags.java","additions":77,"deletions":20,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -350,1 +350,1 @@\n-    private OutputAnalyzer productionRun() throws Exception {\n+    public OutputAnalyzer productionRun() throws Exception {\n@@ -434,0 +434,7 @@\n+\n+    \/\/ See JEP 483; stop at the assembly run; do not execute production run\n+    public void runAOTAssemblyWorkflow() throws Exception {\n+        this.workflow = Workflow.AOT;\n+        recordAOTConfiguration();\n+        createAOTCache();\n+    }\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSAppTester.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"}]}