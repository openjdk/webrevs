{"files":[{"patch":"@@ -6657,1 +6657,1 @@\n-  mov(lr, CAST_FROM_FN_PTR(address, JavaThread::aarch64_get_thread_helper));\n+  mov(lr, ExternalAddress(CAST_FROM_FN_PTR(address, JavaThread::aarch64_get_thread_helper)));\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -63,0 +64,6 @@\n+  const char* name = OptoRuntime::stub_name(OptoStubId::uncommon_trap_id);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::C2Blob, (uint)OptoStubId::uncommon_trap_id, name);\n+  if (blob != nullptr) {\n+    return blob->as_uncommon_trap_blob();\n+  }\n+\n@@ -66,1 +73,0 @@\n-  const char* name = OptoRuntime::stub_name(OptoStubId::uncommon_trap_id);\n@@ -249,2 +255,4 @@\n-  return UncommonTrapBlob::create(&buffer, oop_maps,\n-                                                 SimpleRuntimeFrame::framesize >> 1);\n+  UncommonTrapBlob *ut_blob = UncommonTrapBlob::create(&buffer, oop_maps,\n+                                                       SimpleRuntimeFrame::framesize >> 1);\n+  AOTCodeCache::store_code_blob(*ut_blob, AOTCodeEntry::C2Blob, (uint)OptoStubId::uncommon_trap_id, name);\n+  return ut_blob;\n@@ -286,0 +294,6 @@\n+  const char* name = OptoRuntime::stub_name(OptoStubId::exception_id);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::C2Blob, (uint)OptoStubId::exception_id, name);\n+  if (blob != nullptr) {\n+    return blob->as_exception_blob();\n+  }\n+\n@@ -289,1 +303,0 @@\n-  const char* name = OptoRuntime::stub_name(OptoStubId::exception_id);\n@@ -387,1 +400,3 @@\n-  return ExceptionBlob::create(&buffer, oop_maps, SimpleRuntimeFrame::framesize >> 1);\n+  ExceptionBlob* ex_blob = ExceptionBlob::create(&buffer, oop_maps, SimpleRuntimeFrame::framesize >> 1);\n+  AOTCodeCache::store_code_blob(*ex_blob, AOTCodeEntry::C2Blob, (uint)OptoStubId::exception_id, name);\n+  return ex_blob;\n","filename":"src\/hotspot\/cpu\/aarch64\/runtime_aarch64.cpp","additions":20,"deletions":5,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -2187,0 +2188,6 @@\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, (uint)SharedStubId::deopt_id, name);\n+  if (blob != nullptr) {\n+    _deopt_blob = blob->as_deoptimization_blob();\n+    return;\n+  }\n+\n@@ -2550,0 +2557,2 @@\n+\n+  AOTCodeCache::store_code_blob(*_deopt_blob, AOTCodeEntry::SharedBlob, (uint)SharedStubId::deopt_id, name);\n@@ -2578,0 +2587,7 @@\n+  \/\/ Allocate space for the code.  Setup code generation tools.\n+  const char* name = SharedRuntime::stub_name(id);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, (uint)id, name);\n+  if (blob != nullptr) {\n+    return blob->as_safepoint_blob();\n+  }\n+\n@@ -2581,3 +2597,0 @@\n-\n-  \/\/ Allocate space for the code.  Setup code generation tools.\n-  const char* name = SharedRuntime::stub_name(id);\n@@ -2692,1 +2705,4 @@\n-  return SafepointBlob::create(&buffer, oop_maps, frame_size_in_words);\n+  SafepointBlob* sp_blob = SafepointBlob::create(&buffer, oop_maps, frame_size_in_words);\n+\n+  AOTCodeCache::store_code_blob(*sp_blob, AOTCodeEntry::SharedBlob, (uint)id, name);\n+  return sp_blob;\n@@ -2707,0 +2723,6 @@\n+  const char* name = SharedRuntime::stub_name(id);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, (uint)id, name);\n+  if (blob != nullptr) {\n+    return blob->as_runtime_stub();\n+  }\n+\n@@ -2709,2 +2731,0 @@\n-\n-  const char* name = SharedRuntime::stub_name(id);\n@@ -2783,1 +2803,4 @@\n-  return RuntimeStub::new_runtime_stub(name, &buffer, frame_complete, frame_size_in_words, oop_maps, true);\n+  RuntimeStub* rs_blob = RuntimeStub::new_runtime_stub(name, &buffer, frame_complete, frame_size_in_words, oop_maps, true);\n+\n+  AOTCodeCache::store_code_blob(*rs_blob, AOTCodeEntry::SharedBlob, (uint)id, name);\n+  return rs_blob;\n@@ -2823,1 +2846,0 @@\n-  ResourceMark rm;\n@@ -2827,0 +2849,6 @@\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, (uint)id, name);\n+  if (blob != nullptr) {\n+    return blob->as_runtime_stub();\n+  }\n+\n+  ResourceMark rm;\n@@ -2886,0 +2914,2 @@\n+  AOTCodeCache::store_code_blob(*stub, AOTCodeEntry::SharedBlob, (uint)id, name);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":38,"deletions":8,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -59,0 +60,6 @@\n+  const char* name = OptoRuntime::stub_name(OptoStubId::uncommon_trap_id);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::C2Blob, (uint)OptoStubId::uncommon_trap_id, name);\n+  if (blob != nullptr) {\n+    return blob->as_uncommon_trap_blob();\n+  }\n+\n@@ -62,1 +69,0 @@\n-  const char* name = OptoRuntime::stub_name(OptoStubId::uncommon_trap_id);\n@@ -231,2 +237,4 @@\n-  return UncommonTrapBlob::create(&buffer, oop_maps,\n-                                                 SimpleRuntimeFrame::framesize >> 1);\n+  UncommonTrapBlob *ut_blob = UncommonTrapBlob::create(&buffer, oop_maps,\n+                                                       SimpleRuntimeFrame::framesize >> 1);\n+  AOTCodeCache::store_code_blob(*ut_blob, AOTCodeEntry::C2Blob, (uint)OptoStubId::uncommon_trap_id, name);\n+  return ut_blob;\n@@ -268,0 +276,6 @@\n+  const char* name = OptoRuntime::stub_name(OptoStubId::exception_id);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::C2Blob, (uint)OptoStubId::exception_id, name);\n+  if (blob != nullptr) {\n+    return blob->as_exception_blob();\n+  }\n+\n@@ -271,1 +285,0 @@\n-  const char* name = OptoRuntime::stub_name(OptoStubId::exception_id);\n@@ -366,1 +379,3 @@\n-  return ExceptionBlob::create(&buffer, oop_maps, SimpleRuntimeFrame::framesize >> 1);\n+  ExceptionBlob* ex_blob = ExceptionBlob::create(&buffer, oop_maps, SimpleRuntimeFrame::framesize >> 1);\n+  AOTCodeCache::store_code_blob(*ex_blob, AOTCodeEntry::C2Blob, (uint)OptoStubId::exception_id, name);\n+  return ex_blob;\n","filename":"src\/hotspot\/cpu\/x86\/runtime_x86_64.cpp","additions":20,"deletions":5,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -2603,0 +2604,6 @@\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, (uint)SharedStubId::deopt_id, name);\n+  if (blob != nullptr) {\n+    _deopt_blob = blob->as_deoptimization_blob();\n+    return;\n+  }\n+\n@@ -2954,0 +2961,2 @@\n+\n+  AOTCodeCache::store_code_blob(*_deopt_blob, AOTCodeEntry::SharedBlob, (uint)SharedStubId::deopt_id, name);\n@@ -2966,0 +2975,7 @@\n+  \/\/ Allocate space for the code.  Setup code generation tools.\n+  const char* name = SharedRuntime::stub_name(id);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, (uint)id, name);\n+  if (blob != nullptr) {\n+    return blob->as_safepoint_blob();\n+  }\n+\n@@ -2969,3 +2985,0 @@\n-\n-  \/\/ Allocate space for the code.  Setup code generation tools.\n-  const char* name = SharedRuntime::stub_name(id);\n@@ -3131,1 +3144,4 @@\n-  return SafepointBlob::create(&buffer, oop_maps, frame_size_in_words);\n+  SafepointBlob* sp_blob = SafepointBlob::create(&buffer, oop_maps, frame_size_in_words);\n+\n+  AOTCodeCache::store_code_blob(*sp_blob, AOTCodeEntry::SharedBlob, (uint)id, name);\n+  return sp_blob;\n@@ -3146,0 +3162,6 @@\n+  const char* name = SharedRuntime::stub_name(id);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, (uint)id, name);\n+  if (blob != nullptr) {\n+    return blob->as_runtime_stub();\n+  }\n+\n@@ -3148,2 +3170,0 @@\n-\n-  const char* name = SharedRuntime::stub_name(id);\n@@ -3218,1 +3238,4 @@\n-  return RuntimeStub::new_runtime_stub(name, &buffer, frame_complete, frame_size_in_words, oop_maps, true);\n+  RuntimeStub* rs_blob = RuntimeStub::new_runtime_stub(name, &buffer, frame_complete, frame_size_in_words, oop_maps, true);\n+\n+  AOTCodeCache::store_code_blob(*rs_blob, AOTCodeEntry::SharedBlob, (uint)id, name);\n+  return rs_blob;\n@@ -3256,1 +3279,0 @@\n-  ResourceMark rm;\n@@ -3260,0 +3282,6 @@\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, (uint)id, name);\n+  if (blob != nullptr) {\n+    return blob->as_runtime_stub();\n+  }\n+\n+  ResourceMark rm;\n@@ -3317,0 +3345,2 @@\n+  AOTCodeCache::store_code_blob(*stub, AOTCodeEntry::SharedBlob, (uint)id, name);\n+\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":38,"deletions":8,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -424,0 +424,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -1862,2 +1863,6 @@\n-    \/\/ No relocation needed\n-    __ mov64(r10, (int64_t) $meth$$method);\n+    if (AOTCodeCache::is_on_for_dump()) {\n+      \/\/ Created runtime_call_type relocation when caching code\n+      __ lea(r10, RuntimeAddress((address)$meth$$method));\n+    } else {\n+      __ mov64(r10, (int64_t) $meth$$method);\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1090,99 +1090,0 @@\n-\/\/ ----- CHeapString -----------------------------------------------------------\n-\n-class CHeapString : public CHeapObj<mtCode> {\n- public:\n-  CHeapString(const char* str) : _string(os::strdup(str)) {}\n- ~CHeapString() {\n-    os::free((void*)_string);\n-    _string = nullptr;\n-  }\n-  const char* string() const { return _string; }\n-\n- private:\n-  const char* _string;\n-};\n-\n-\/\/ ----- AsmRemarkCollection ---------------------------------------------------\n-\n-class AsmRemarkCollection : public CHeapObj<mtCode> {\n- public:\n-  AsmRemarkCollection() : _ref_cnt(1), _remarks(nullptr), _next(nullptr) {}\n- ~AsmRemarkCollection() {\n-    assert(is_empty(), \"Must 'clear()' before deleting!\");\n-    assert(_ref_cnt == 0, \"No uses must remain when deleting!\");\n-  }\n-  AsmRemarkCollection* reuse() {\n-    precond(_ref_cnt > 0);\n-    return _ref_cnt++, this;\n-  }\n-\n-  const char* insert(uint offset, const char* remark);\n-  const char* lookup(uint offset) const;\n-  const char* next(uint offset) const;\n-\n-  bool is_empty() const { return _remarks == nullptr; }\n-  uint clear();\n-\n- private:\n-  struct Cell : CHeapString {\n-    Cell(const char* remark, uint offset) :\n-        CHeapString(remark), offset(offset), prev(nullptr), next(nullptr) {}\n-    void push_back(Cell* cell) {\n-      Cell* head = this;\n-      Cell* tail = prev;\n-      tail->next = cell;\n-      cell->next = head;\n-      cell->prev = tail;\n-      prev = cell;\n-    }\n-    uint offset;\n-    Cell* prev;\n-    Cell* next;\n-  };\n-  uint  _ref_cnt;\n-  Cell* _remarks;\n-  \/\/ Using a 'mutable' iteration pointer to allow 'const' on lookup\/next (that\n-  \/\/ does not change the state of the list per se), supportig a simplistic\n-  \/\/ iteration scheme.\n-  mutable Cell* _next;\n-};\n-\n-\/\/ ----- DbgStringCollection ---------------------------------------------------\n-\n-class DbgStringCollection : public CHeapObj<mtCode> {\n- public:\n-  DbgStringCollection() : _ref_cnt(1), _strings(nullptr) {}\n- ~DbgStringCollection() {\n-    assert(is_empty(), \"Must 'clear()' before deleting!\");\n-    assert(_ref_cnt == 0, \"No uses must remain when deleting!\");\n-  }\n-  DbgStringCollection* reuse() {\n-    precond(_ref_cnt > 0);\n-    return _ref_cnt++, this;\n-  }\n-\n-  const char* insert(const char* str);\n-  const char* lookup(const char* str) const;\n-\n-  bool is_empty() const { return _strings == nullptr; }\n-  uint clear();\n-\n- private:\n-  struct Cell : CHeapString {\n-    Cell(const char* dbgstr) :\n-        CHeapString(dbgstr), prev(nullptr), next(nullptr) {}\n-    void push_back(Cell* cell) {\n-      Cell* head = this;\n-      Cell* tail = prev;\n-      tail->next = cell;\n-      cell->next = head;\n-      cell->prev = tail;\n-      prev = cell;\n-    }\n-    Cell* prev;\n-    Cell* next;\n-  };\n-  uint  _ref_cnt;\n-  Cell* _strings;\n-};\n-\n@@ -1213,1 +1114,1 @@\n-  precond(is_empty());\n+  precond(_remarks == nullptr || is_empty());\n@@ -1219,1 +1120,1 @@\n-  if (_remarks->clear() == 0) {\n+  if (_remarks != nullptr && _remarks->clear() == 0) {\n@@ -1265,1 +1166,1 @@\n-  precond(is_empty());\n+  precond(_strings == nullptr || is_empty());\n@@ -1271,1 +1172,1 @@\n-  if (_strings->clear() == 0) {\n+  if (_strings != nullptr && _strings->clear() == 0) {\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.cpp","additions":4,"deletions":103,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/os.hpp\"\n@@ -294,2 +295,126 @@\n-class AsmRemarkCollection;\n-class DbgStringCollection;\n+\/\/ ----- CHeapString -----------------------------------------------------------\n+\n+class CHeapString : public CHeapObj<mtCode> {\n+ public:\n+  CHeapString(const char* str) : _string(os::strdup(str)) {}\n+ ~CHeapString() {\n+    os::free((void*)_string);\n+    _string = nullptr;\n+  }\n+  const char* string() const { return _string; }\n+\n+ private:\n+  const char* _string;\n+};\n+\n+\/\/ ----- AsmRemarkCollection ---------------------------------------------------\n+\n+class AsmRemarkCollection : public CHeapObj<mtCode> {\n+ public:\n+  AsmRemarkCollection() : _ref_cnt(1), _remarks(nullptr), _next(nullptr) {}\n+ ~AsmRemarkCollection() {\n+    assert(is_empty(), \"Must 'clear()' before deleting!\");\n+    assert(_ref_cnt == 0, \"No uses must remain when deleting!\");\n+  }\n+  AsmRemarkCollection* reuse() {\n+    precond(_ref_cnt > 0);\n+    return _ref_cnt++, this;\n+  }\n+\n+  const char* insert(uint offset, const char* remark);\n+  const char* lookup(uint offset) const;\n+  const char* next(uint offset) const;\n+\n+  bool is_empty() const { return _remarks == nullptr; }\n+  uint clear();\n+\n+  template<typename Function>\n+  bool iterate(Function function) const { \/\/ lambda enabled API\n+    if (_remarks != nullptr) {\n+      Cell* tmp = _remarks;\n+      do {\n+        if(!function(tmp->offset, tmp->string())) {\n+          return false;\n+        }\n+        tmp = tmp->next;\n+      } while (tmp != _remarks);\n+    }\n+    return true;\n+  }\n+\n+ private:\n+  struct Cell : CHeapString {\n+    Cell(const char* remark, uint offset) :\n+        CHeapString(remark), offset(offset), prev(nullptr), next(nullptr) {}\n+    void push_back(Cell* cell) {\n+      Cell* head = this;\n+      Cell* tail = prev;\n+      tail->next = cell;\n+      cell->next = head;\n+      cell->prev = tail;\n+      prev = cell;\n+    }\n+    uint offset;\n+    Cell* prev;\n+    Cell* next;\n+  };\n+  uint  _ref_cnt;\n+  Cell* _remarks;\n+  \/\/ Using a 'mutable' iteration pointer to allow 'const' on lookup\/next (that\n+  \/\/ does not change the state of the list per se), supportig a simplistic\n+  \/\/ iteration scheme.\n+  mutable Cell* _next;\n+};\n+\n+\/\/ ----- DbgStringCollection ---------------------------------------------------\n+\n+class DbgStringCollection : public CHeapObj<mtCode> {\n+ public:\n+  DbgStringCollection() : _ref_cnt(1), _strings(nullptr) {}\n+ ~DbgStringCollection() {\n+    assert(is_empty(), \"Must 'clear()' before deleting!\");\n+    assert(_ref_cnt == 0, \"No uses must remain when deleting!\");\n+  }\n+  DbgStringCollection* reuse() {\n+    precond(_ref_cnt > 0);\n+    return _ref_cnt++, this;\n+  }\n+\n+  const char* insert(const char* str);\n+  const char* lookup(const char* str) const;\n+\n+  bool is_empty() const { return _strings == nullptr; }\n+  uint clear();\n+\n+  template<typename Function>\n+  bool iterate(Function function) const { \/\/ lambda enabled API\n+    if (_strings != nullptr) {\n+      Cell* tmp = _strings;\n+      do {\n+        if (!function(tmp->string())) {\n+          return false;\n+        }\n+        tmp = tmp->next;\n+      } while (tmp != _strings);\n+    }\n+    return true;\n+  }\n+\n+ private:\n+  struct Cell : CHeapString {\n+    Cell(const char* dbgstr) :\n+        CHeapString(dbgstr), prev(nullptr), next(nullptr) {}\n+    void push_back(Cell* cell) {\n+      Cell* head = this;\n+      Cell* tail = prev;\n+      tail->next = cell;\n+      cell->next = head;\n+      cell->prev = tail;\n+      prev = cell;\n+    }\n+    Cell* prev;\n+    Cell* next;\n+  };\n+  uint  _ref_cnt;\n+  Cell* _strings;\n+};\n@@ -318,0 +443,3 @@\n+  template<typename Function>\n+  inline bool iterate(Function function) const { return _remarks->iterate(function); }\n+\n@@ -340,0 +468,3 @@\n+  template<typename Function>\n+  bool iterate(Function function) const { return _strings->iterate(function); }\n+\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":133,"deletions":2,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -201,0 +202,7 @@\n+  if ((int)id >= 0) {\n+    CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::C1Blob, (uint)id, name, 0, nullptr);\n+    if (blob != nullptr) {\n+      return blob;\n+    }\n+  }\n+\n@@ -234,0 +242,3 @@\n+  if (blob != nullptr && (int)id >= 0) {\n+    AOTCodeCache::store_code_blob(*blob, AOTCodeEntry::C1Blob, (uint)id, name, 0, nullptr);\n+  }\n@@ -268,1 +279,7 @@\n-  for (int id = 0; id < limit; id++) {\n+  for (int id = 0; id <= (int)C1StubId::forward_exception_id; id++) {\n+    if (!generate_blob_for(blob, (C1StubId) id)) {\n+      return false;\n+    }\n+  }\n+  AOTCodeCache::init_early_c1_table();\n+  for (int id = (int)C1StubId::forward_exception_id+1; id < limit; id++) {\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+  friend class AOTCodeAddressTable;\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -408,0 +408,3 @@\n+  if (FLAG_IS_DEFAULT(AOTCache) && AOTStubCaching) {\n+    log_debug(aot,codecache,init)(\"AOTCache is not specified - AOTStubCaching is ignored\");\n+  }\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -135,0 +135,3 @@\n+  product(bool, AOTStubCaching, false, DIAGNOSTIC,                          \\\n+          \"Enable saving and restoring stubs and code blobs in AOT cache\")  \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/cds\/cds_globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,0 +25,3 @@\n+#ifdef COMPILER1\n+#include \"c1\/c1_Runtime1.hpp\"\n+#endif\n@@ -36,0 +39,4 @@\n+#ifdef COMPILER2\n+#include \"opto\/runtime.hpp\"\n+#endif\n+#include \"runtime\/deoptimization.hpp\"\n@@ -43,3 +50,0 @@\n-#ifdef COMPILER2\n-#include \"opto\/runtime.hpp\"\n-#endif\n@@ -62,0 +66,1 @@\n+  AOTStubCaching = false;\n@@ -71,0 +76,1 @@\n+  AOTStubCaching = false;\n@@ -81,0 +87,32 @@\n+bool AOTCodeCache::is_dumping_stubs() {\n+  return AOTStubCaching && is_on_for_dump();\n+}\n+\n+bool AOTCodeCache::is_using_stubs()   {\n+  return AOTStubCaching && is_on_for_use();\n+}\n+\n+static uint32_t encode_id(AOTCodeEntry::Kind kind, int id) {\n+  assert(AOTCodeEntry::is_valid_entry_kind(kind), \"invalid AOTCodeEntry kind %d\", (int)kind);\n+  \/\/ There can be a conflict of id between an Adapter and *Blob, but that should not cause any functional issue\n+  \/\/ becasue both id and kind are used to find an entry, and that combination should be unique\n+  if (kind == AOTCodeEntry::Adapter) {\n+    return id;\n+  } else if (kind == AOTCodeEntry::SharedBlob) {\n+    return id;\n+  } else if (kind == AOTCodeEntry::C1Blob) {\n+    return (int)SharedStubId::NUM_STUBIDS + id;\n+  } else {\n+    \/\/ kind must be AOTCodeEntry::C2Blob\n+    return (int)SharedStubId::NUM_STUBIDS + COMPILER1_PRESENT((int)C1StubId::NUM_STUBIDS) + id;\n+  }\n+}\n+\n+const char* AOTCodeEntry::_kind_string[] = {\n+  \"None\",\n+  \"Adapter\",\n+  \"SharedBlob\",\n+  \"C1Blob\",\n+  \"C2Blob\"\n+};\n+\n@@ -96,0 +134,1 @@\n+    FLAG_SET_ERGO_IF_DEFAULT(AOTStubCaching, true);\n@@ -99,0 +138,1 @@\n+    FLAG_SET_ERGO_IF_DEFAULT(AOTStubCaching, true);\n@@ -104,1 +144,1 @@\n-  if (!AOTAdapterCaching) {\n+  if (!AOTAdapterCaching && !AOTStubCaching) {\n@@ -141,0 +181,1 @@\n+\n@@ -144,0 +185,1 @@\n+  init_early_stubs_table();\n@@ -216,1 +258,3 @@\n-    log_debug(aot, codecache, init)(\"  All Blobs: total=%u\", _load_header->blobs_count());\n+    log_debug(aot, codecache, init)(\"  Shared Blobs: total=%u\", _load_header->shared_blobs_count());\n+    log_debug(aot, codecache, init)(\"  C1 Blobs: total=%u\", _load_header->C1_blobs_count());\n+    log_debug(aot, codecache, init)(\"  C2 Blobs: total=%u\", _load_header->C2_blobs_count());\n@@ -239,0 +283,7 @@\n+void AOTCodeCache::init_early_stubs_table() {\n+  AOTCodeAddressTable* table = addr_table();\n+  if (table != nullptr) {\n+    table->init_early_stubs();\n+  }\n+}\n+\n@@ -246,0 +297,7 @@\n+void AOTCodeCache::init_early_c1_table() {\n+  AOTCodeAddressTable* table = addr_table();\n+  if (table != nullptr) {\n+    table->init_early_c1();\n+  }\n+}\n+\n@@ -296,0 +354,1 @@\n+  _compressedOopBase     = CompressedOops::base();\n@@ -297,0 +356,1 @@\n+  _compressedKlassBase   = CompressedKlassPointers::base();\n@@ -351,0 +411,4 @@\n+  if (_compressedOopBase != CompressedOops::base()) {\n+    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with CompressedOops::base() = %p vs current %p\", _compressedOopBase, CompressedOops::base());\n+    return false;\n+  }\n@@ -355,0 +419,4 @@\n+  if (_compressedKlassBase != CompressedKlassPointers::base()) {\n+    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with CompressedKlassPointers::base() = %p vs current %p\", _compressedKlassBase, CompressedKlassPointers::base());\n+    return false;\n+  }\n@@ -530,0 +598,25 @@\n+      \/\/ Linear search around to handle id collission\n+      for (int i = mid - 1; i >= l; i--) { \/\/ search back\n+        ix = i * 2;\n+        is = _search_entries[ix];\n+        if (is != id) {\n+          break;\n+        }\n+        index = _search_entries[ix + 1];\n+        AOTCodeEntry* entry = &(_load_entries[index]);\n+        if (check_entry(kind, id, entry)) {\n+          return entry; \/\/ Found\n+        }\n+      }\n+      for (int i = mid + 1; i <= h; i++) { \/\/ search forward\n+        ix = i * 2;\n+        is = _search_entries[ix];\n+        if (is != id) {\n+          break;\n+        }\n+        index = _search_entries[ix + 1];\n+        AOTCodeEntry* entry = &(_load_entries[index]);\n+        if (check_entry(kind, id, entry)) {\n+          return entry; \/\/ Found\n+        }\n+      }\n@@ -586,1 +679,3 @@\n-    uint blobs_count = 0;\n+    uint shared_blobs_count = 0;\n+    uint C1_blobs_count = 0;\n+    uint C2_blobs_count = 0;\n@@ -610,2 +705,6 @@\n-      } else if (kind == AOTCodeEntry::Blob) {\n-        blobs_count++;\n+      } else if (kind == AOTCodeEntry::SharedBlob) {\n+        shared_blobs_count++;\n+      } else if (kind == AOTCodeEntry::C1Blob) {\n+        C1_blobs_count++;\n+      } else if (kind == AOTCodeEntry::C2Blob) {\n+        C2_blobs_count++;\n@@ -643,1 +742,3 @@\n-    log_debug(aot, codecache, exit)(\"  All Blobs: total=%u\", blobs_count);\n+    log_debug(aot, codecache, exit)(\"  Shared Blobs:  total=%d\", shared_blobs_count);\n+    log_debug(aot, codecache, exit)(\"  C1 Blobs:      total=%d\", C1_blobs_count);\n+    log_debug(aot, codecache, exit)(\"  C2 Blobs:      total=%d\", C2_blobs_count);\n@@ -650,1 +751,2 @@\n-                 adapters_count, blobs_count);\n+                 adapters_count, shared_blobs_count,\n+                 C1_blobs_count, C2_blobs_count);\n@@ -666,1 +768,4 @@\n-  if ((entry_kind == AOTCodeEntry::Adapter) && !AOTAdapterCaching) {\n+  if (AOTCodeEntry::is_adapter(entry_kind) && !AOTAdapterCaching) {\n+    return false;\n+  }\n+  if (AOTCodeEntry::is_blob(entry_kind) && !AOTStubCaching) {\n@@ -669,1 +774,1 @@\n-  log_debug(aot, codecache, stubs)(\"Writing blob '%s' to AOT Code Cache\", name);\n+  log_info(aot, codecache, stubs)(\"Writing blob '%s' (id=%u, kind=%s) to AOT Code Cache\", name, id, AOTCodeEntry::kind_string(entry_kind));\n@@ -719,0 +824,10 @@\n+#ifndef PRODUCT\n+  \/\/ Write asm remarks\n+  if (!cache->write_asm_remarks(blob)) {\n+    return false;\n+  }\n+  if (!cache->write_dbg_strings(blob)) {\n+    return false;\n+  }\n+#endif \/* PRODUCT *\/\n+\n@@ -736,1 +851,1 @@\n-  AOTCodeEntry* entry = new(cache) AOTCodeEntry(entry_kind, id,\n+  AOTCodeEntry* entry = new(cache) AOTCodeEntry(entry_kind, encode_id(entry_kind, id),\n@@ -739,1 +854,1 @@\n-  log_debug(aot, codecache, stubs)(\"Wrote code blob '%s(id=%d)' to AOT Code Cache\", name, id);\n+  log_info(aot, codecache, stubs)(\"Wrote code blob '%s' (id=%u, kind=%s) to AOT Code Cache\", name, id, AOTCodeEntry::kind_string(entry_kind));\n@@ -750,1 +865,4 @@\n-  if ((entry_kind == AOTCodeEntry::Adapter) && !AOTAdapterCaching) {\n+  if (AOTCodeEntry::is_adapter(entry_kind) && !AOTAdapterCaching) {\n+    return nullptr;\n+  }\n+  if (AOTCodeEntry::is_blob(entry_kind) && !AOTStubCaching) {\n@@ -753,1 +871,1 @@\n-  log_debug(aot, codecache, stubs)(\"Reading blob '%s' from AOT Code Cache\", name);\n+  log_debug(aot, codecache, stubs)(\"Reading blob '%s' (id=%u, kind=%s) from AOT Code Cache\", name, id, AOTCodeEntry::kind_string(entry_kind));\n@@ -755,1 +873,1 @@\n-  AOTCodeEntry* entry = cache->find_entry(entry_kind, id);\n+  AOTCodeEntry* entry = cache->find_entry(entry_kind, encode_id(entry_kind, id));\n@@ -760,1 +878,4 @@\n-  return reader.compile_code_blob(name, entry_offset_count, entry_offsets);\n+  CodeBlob* blob = reader.compile_code_blob(name, entry_offset_count, entry_offsets);\n+\n+  log_info(aot, codecache, stubs)(\"Read blob '%s' (id=%u, kind=%s) from AOT Code Cache\", name, id, AOTCodeEntry::kind_string(entry_kind));\n+  return blob;\n@@ -793,1 +914,16 @@\n-  CodeBlob* code_blob = CodeBlob::create(archived_blob, stored_name, reloc_data, oop_maps);\n+#ifndef PRODUCT\n+  AsmRemarks asm_remarks;\n+  read_asm_remarks(asm_remarks);\n+  DbgStrings dbg_strings;\n+  read_dbg_strings(dbg_strings);\n+#endif \/\/ PRODUCT\n+\n+  CodeBlob* code_blob = CodeBlob::create(archived_blob,\n+                                         stored_name,\n+                                         reloc_data,\n+                                         oop_maps\n+#ifndef PRODUCT\n+                                         , asm_remarks\n+                                         , dbg_strings\n+#endif\n+                                        );\n@@ -815,1 +951,0 @@\n-  log_debug(aot, codecache, stubs)(\"Read blob '%s' from AOT Code Cache\", name);\n@@ -860,0 +995,2 @@\n+      case relocInfo::post_call_nop_type:\n+        break;\n@@ -933,0 +1070,2 @@\n+      case relocInfo::post_call_nop_type:\n+        break;\n@@ -968,0 +1107,76 @@\n+#ifndef PRODUCT\n+bool AOTCodeCache::write_asm_remarks(CodeBlob& cb) {\n+  \/\/ Write asm remarks\n+  uint* count_ptr = (uint *)reserve_bytes(sizeof(uint));\n+  if (count_ptr == nullptr) {\n+    return false;\n+  }\n+  uint count = 0;\n+  bool result = cb.asm_remarks().iterate([&] (uint offset, const char* str) -> bool {\n+    log_trace(aot, codecache, stubs)(\"asm remark offset=%d, str='%s'\", offset, str);\n+    uint n = write_bytes(&offset, sizeof(uint));\n+    if (n != sizeof(uint)) {\n+      return false;\n+    }\n+    uint len = (uint)strlen(str) + 1; \/\/ including '\\0' char\n+    n = write_bytes(str, len);\n+    if (n != len) {\n+      return false;\n+    }\n+    count += 1;\n+    return true;\n+  });\n+  *count_ptr = count;\n+  return result;\n+}\n+\n+void AOTCodeReader::read_asm_remarks(AsmRemarks& asm_remarks) {\n+  \/\/ Read asm remarks\n+  uint offset = read_position();\n+  uint count = *(uint *)addr(offset);\n+  offset += sizeof(uint);\n+  for (uint i = 0; i < count; i++) {\n+    uint remark_offset = *(uint *)addr(offset);\n+    offset += sizeof(uint);\n+    const char* remark = (const char*)addr(offset);\n+    offset += (uint)strlen(remark)+1;\n+    asm_remarks.insert(remark_offset, remark);\n+  }\n+  set_read_position(offset);\n+}\n+\n+bool AOTCodeCache::write_dbg_strings(CodeBlob& cb) {\n+  \/\/ Write dbg strings\n+  uint* count_ptr = (uint *)reserve_bytes(sizeof(uint));\n+  if (count_ptr == nullptr) {\n+    return false;\n+  }\n+  uint count = 0;\n+  bool result = cb.dbg_strings().iterate([&] (const char* str) -> bool {\n+    log_trace(aot, codecache, stubs)(\"dbg string=%s\", str);\n+    uint len = (uint)strlen(str) + 1; \/\/ including '\\0' char\n+    uint n = write_bytes(str, len);\n+    if (n != len) {\n+      return false;\n+    }\n+    count += 1;\n+    return true;\n+  });\n+  *count_ptr = count;\n+  return result;\n+}\n+\n+void AOTCodeReader::read_dbg_strings(DbgStrings& dbg_strings) {\n+  \/\/ Read dbg strings\n+  uint offset = read_position();\n+  uint count = *(uint *)addr(offset);\n+  offset += sizeof(uint);\n+  for (uint i = 0; i < count; i++) {\n+    const char* str = (const char*)addr(offset);\n+    offset += (uint)strlen(str)+1;\n+    dbg_strings.insert(str);\n+  }\n+  set_read_position(offset);\n+}\n+#endif \/\/ PRODUCT\n+\n@@ -977,3 +1192,0 @@\n-#define _extrs_max 10\n-#define _blobs_max 10\n-#define _all_max   20\n@@ -981,3 +1193,2 @@\n-#define _extrs_base 0\n-#define _blobs_base (_extrs_base + _extrs_max)\n-#define _blobs_end  (_blobs_base + _blobs_max)\n+#define _extrs_max 100\n+#define _stubs_max 3\n@@ -985,3 +1196,10 @@\n-#if (_blobs_end > _all_max)\n-#error AOTCodeAddress table ranges need adjusting\n-#endif\n+#define _shared_blobs_max 20\n+#define _C1_blobs_max 10\n+#define _blobs_max (_shared_blobs_max+_C1_blobs_max)\n+#define _all_max (_extrs_max+_stubs_max+_blobs_max)\n+\n+#define _extrs_base 0\n+#define _stubs_base (_extrs_base + _extrs_max)\n+#define _shared_blobs_base (_stubs_base + _stubs_max)\n+#define _C1_blobs_base (_shared_blobs_base + _shared_blobs_max)\n+#define _blobs_end  (_shared_blobs_base + _blobs_max)\n@@ -999,0 +1217,3 @@\n+\n+  assert(_blobs_end <= _all_max, \"AOTCodeAddress table ranges need adjusting\");\n+\n@@ -1004,1 +1225,1 @@\n-  \/\/ Recored addresses of VM runtime methods\n+  \/\/ Record addresses of VM runtime methods\n@@ -1009,0 +1230,86 @@\n+#if defined(AARCH64)\n+  SET_ADDRESS(_extrs, JavaThread::aarch64_get_thread_helper);\n+#endif\n+  {\n+    \/\/ Required by Shared blobs\n+    SET_ADDRESS(_extrs, Deoptimization::fetch_unroll_info);\n+    SET_ADDRESS(_extrs, Deoptimization::unpack_frames);\n+    SET_ADDRESS(_extrs, SafepointSynchronize::handle_polling_page_exception);\n+    SET_ADDRESS(_extrs, SharedRuntime::resolve_opt_virtual_call_C);\n+    SET_ADDRESS(_extrs, SharedRuntime::resolve_virtual_call_C);\n+    SET_ADDRESS(_extrs, SharedRuntime::resolve_static_call_C);\n+    SET_ADDRESS(_extrs, SharedRuntime::throw_delayed_StackOverflowError);\n+    SET_ADDRESS(_extrs, SharedRuntime::throw_AbstractMethodError);\n+    SET_ADDRESS(_extrs, SharedRuntime::throw_IncompatibleClassChangeError);\n+    SET_ADDRESS(_extrs, SharedRuntime::throw_NullPointerException_at_call);\n+  }\n+\n+#ifdef COMPILER1\n+  {\n+    \/\/ Required by C1 blobs\n+    SET_ADDRESS(_extrs, static_cast<int (*)(oopDesc*)>(SharedRuntime::dtrace_object_alloc));\n+    SET_ADDRESS(_extrs, SharedRuntime::exception_handler_for_return_address);\n+    SET_ADDRESS(_extrs, SharedRuntime::register_finalizer);\n+    SET_ADDRESS(_extrs, Runtime1::is_instance_of);\n+    SET_ADDRESS(_extrs, Runtime1::exception_handler_for_pc);\n+    SET_ADDRESS(_extrs, Runtime1::check_abort_on_vm_exception);\n+    SET_ADDRESS(_extrs, Runtime1::new_instance);\n+    SET_ADDRESS(_extrs, Runtime1::counter_overflow);\n+    SET_ADDRESS(_extrs, Runtime1::new_type_array);\n+    SET_ADDRESS(_extrs, Runtime1::new_object_array);\n+    SET_ADDRESS(_extrs, Runtime1::new_multi_array);\n+    SET_ADDRESS(_extrs, Runtime1::throw_range_check_exception);\n+    SET_ADDRESS(_extrs, Runtime1::throw_index_exception);\n+    SET_ADDRESS(_extrs, Runtime1::throw_div0_exception);\n+    SET_ADDRESS(_extrs, Runtime1::throw_null_pointer_exception);\n+    SET_ADDRESS(_extrs, Runtime1::throw_array_store_exception);\n+    SET_ADDRESS(_extrs, Runtime1::throw_class_cast_exception);\n+    SET_ADDRESS(_extrs, Runtime1::throw_incompatible_class_change_error);\n+    SET_ADDRESS(_extrs, Runtime1::is_instance_of);\n+    SET_ADDRESS(_extrs, Runtime1::monitorenter);\n+    SET_ADDRESS(_extrs, Runtime1::monitorexit);\n+    SET_ADDRESS(_extrs, Runtime1::deoptimize);\n+    SET_ADDRESS(_extrs, Runtime1::access_field_patching);\n+    SET_ADDRESS(_extrs, Runtime1::move_klass_patching);\n+    SET_ADDRESS(_extrs, Runtime1::move_mirror_patching);\n+    SET_ADDRESS(_extrs, Runtime1::move_appendix_patching);\n+    SET_ADDRESS(_extrs, Runtime1::predicate_failed_trap);\n+    SET_ADDRESS(_extrs, Runtime1::unimplemented_entry);\n+    SET_ADDRESS(_extrs, Thread::current);\n+#ifndef PRODUCT\n+    SET_ADDRESS(_extrs, os::breakpoint);\n+#endif\n+  }\n+#endif\n+\n+#ifdef COMPILER2\n+  {\n+    \/\/ Required by C2 blobs\n+    SET_ADDRESS(_extrs, Deoptimization::uncommon_trap);\n+    SET_ADDRESS(_extrs, OptoRuntime::handle_exception_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::new_instance_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::new_array_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::new_array_nozero_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::multianewarray2_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::multianewarray3_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::multianewarray4_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::multianewarray5_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::multianewarrayN_C);\n+#if INCLUDE_JVMTI\n+    SET_ADDRESS(_extrs, SharedRuntime::notify_jvmti_vthread_start);\n+    SET_ADDRESS(_extrs, SharedRuntime::notify_jvmti_vthread_end);\n+    SET_ADDRESS(_extrs, SharedRuntime::notify_jvmti_vthread_mount);\n+    SET_ADDRESS(_extrs, SharedRuntime::notify_jvmti_vthread_unmount);\n+#endif\n+    SET_ADDRESS(_extrs, OptoRuntime::complete_monitor_locking_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::monitor_notify_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::monitor_notifyAll_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::rethrow_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::slow_arraycopy_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::register_finalizer_C);\n+#if defined(AARCH64)\n+    SET_ADDRESS(_extrs, JavaThread::verify_cross_modify_fence_failure);\n+#endif \/\/ AARCH64\n+  }\n+#endif \/\/ COMPILER2\n+\n@@ -1019,3 +1326,0 @@\n-#ifdef COMPILER2\n-  SET_ADDRESS(_extrs, OptoRuntime::handle_exception_C);\n-#endif\n@@ -1032,0 +1336,21 @@\n+static bool initializing_early_stubs = false;\n+\n+void AOTCodeAddressTable::init_early_stubs() {\n+  if (_complete || initializing_early_stubs) return; \/\/ Done already\n+  initializing_early_stubs = true;\n+  _stubs_addr = NEW_C_HEAP_ARRAY(address, _stubs_max, mtCode);\n+  _stubs_length = 0;\n+  SET_ADDRESS(_stubs, StubRoutines::forward_exception_entry());\n+\n+  {\n+    \/\/ Required by C1 blobs\n+#if defined(AMD64) && !defined(ZERO)\n+    SET_ADDRESS(_stubs, StubRoutines::x86::double_sign_flip());\n+    SET_ADDRESS(_stubs, StubRoutines::x86::d2l_fixup());\n+#endif \/\/ AMD64\n+  }\n+\n+  _early_stubs_complete = true;\n+  log_info(aot, codecache, init)(\"Early stubs recorded\");\n+}\n+\n@@ -1037,7 +1362,21 @@\n-  _blobs_addr = NEW_C_HEAP_ARRAY(address, _blobs_max, mtCode);\n-\n-  _blobs_length = 0;       \/\/ for shared blobs\n-\n-  \/\/ Recored addresses of generated code blobs\n-  SET_ADDRESS(_blobs, SharedRuntime::get_handle_wrong_method_stub());\n-  SET_ADDRESS(_blobs, SharedRuntime::get_ic_miss_stub());\n+  address* blobs_addr = NEW_C_HEAP_ARRAY(address, _blobs_max, mtCode);\n+  _shared_blobs_addr = blobs_addr;\n+  _C1_blobs_addr = _shared_blobs_addr + _shared_blobs_max;\n+  _shared_blobs_length = _C1_blobs_length = 0;\n+\n+  \/\/ clear the address table\n+  memset(blobs_addr, 0, sizeof(address)* _blobs_max);\n+\n+  \/\/ Record addresses of generated code blobs\n+  SET_ADDRESS(_shared_blobs, SharedRuntime::get_handle_wrong_method_stub());\n+  SET_ADDRESS(_shared_blobs, SharedRuntime::get_ic_miss_stub());\n+  SET_ADDRESS(_shared_blobs, SharedRuntime::deopt_blob()->unpack());\n+  SET_ADDRESS(_shared_blobs, SharedRuntime::deopt_blob()->unpack_with_exception());\n+  SET_ADDRESS(_shared_blobs, SharedRuntime::deopt_blob()->unpack_with_reexecution());\n+  SET_ADDRESS(_shared_blobs, SharedRuntime::deopt_blob()->unpack_with_exception_in_tls());\n+#if INCLUDE_JVMCI\n+  if (EnableJVMCI) {\n+    SET_ADDRESS(_shared_blobs, SharedRuntime::deopt_blob()->uncommon_trap());\n+    SET_ADDRESS(_shared_blobs, SharedRuntime::deopt_blob()->implicit_exception_uncommon_trap());\n+  }\n+#endif\n@@ -1050,0 +1389,21 @@\n+void AOTCodeAddressTable::init_early_c1() {\n+#ifdef COMPILER1\n+  \/\/ Runtime1 Blobs\n+  for (int i = 0; i <= (int)C1StubId::forward_exception_id; i++) {\n+    C1StubId id = (C1StubId)i;\n+    if (Runtime1::blob_for(id) == nullptr) {\n+      log_info(aot, codecache, init)(\"C1 blob %s is missing\", Runtime1::name_for(id));\n+      continue;\n+    }\n+    if (Runtime1::entry_for(id) == nullptr) {\n+      log_info(aot, codecache, init)(\"C1 blob %s is missing entry\", Runtime1::name_for(id));\n+      continue;\n+    }\n+    address entry = Runtime1::entry_for(id);\n+    SET_ADDRESS(_C1_blobs, entry);\n+  }\n+#endif \/\/ COMPILER1\n+  assert(_C1_blobs_length <= _C1_blobs_max, \"increase _C1_blobs_max to %d\", _C1_blobs_length);\n+  _early_c1_complete = true;\n+}\n+\n@@ -1056,2 +1416,2 @@\n-  if (_blobs_addr != nullptr) {\n-    FREE_C_HEAP_ARRAY(address, _blobs_addr);\n+  if (_shared_blobs_addr != nullptr) {\n+    FREE_C_HEAP_ARRAY(address, _shared_blobs_addr);\n@@ -1067,1 +1427,1 @@\n-#define _c_str_base _all_max\n+static const int _c_str_base = _all_max;\n@@ -1223,2 +1583,8 @@\n-  if (id >= _blobs_base && id < _blobs_base + _blobs_length) {\n-    return _blobs_addr[id - _blobs_base];\n+  if (id >= _stubs_base && id < _stubs_base + _stubs_length) {\n+    return _stubs_addr[id - _stubs_base];\n+  }\n+  if (id >= _shared_blobs_base && id < _shared_blobs_base + _shared_blobs_length) {\n+    return _shared_blobs_addr[id - _shared_blobs_base];\n+  }\n+  if (id >= _C1_blobs_base && id < _C1_blobs_base + _C1_blobs_length) {\n+    return _C1_blobs_addr[id - _C1_blobs_base];\n@@ -1248,3 +1614,10 @@\n-    StubCodeDesc* desc = StubCodeDesc::desc_for(addr);\n-    if (desc == nullptr) {\n-      desc = StubCodeDesc::desc_for(addr + frame::pc_return_offset);\n+    id = search_address(addr, _stubs_addr, _stubs_length);\n+    if (id < 0) {\n+      StubCodeDesc* desc = StubCodeDesc::desc_for(addr);\n+      if (desc == nullptr) {\n+        desc = StubCodeDesc::desc_for(addr + frame::pc_return_offset);\n+      }\n+      const char* sub_name = (desc != nullptr) ? desc->name() : \"<unknown>\";\n+      fatal(\"Address \" INTPTR_FORMAT \" for Stub:%s is missing in AOT Code Cache addresses table\", p2i(addr), sub_name);\n+    } else {\n+      return id + _stubs_base;\n@@ -1252,2 +1625,0 @@\n-    const char* sub_name = (desc != nullptr) ? desc->name() : \"<unknown>\";\n-    fatal(\"Address \" INTPTR_FORMAT \" for Stub:%s is missing in AOT Code Cache addresses table\", p2i(addr), sub_name);\n@@ -1258,2 +1629,2 @@\n-      int id_base = _blobs_base;\n-      id = search_address(addr, _blobs_addr, _blobs_length);\n+      int id_base = _shared_blobs_base;\n+      id = search_address(addr, _shared_blobs_addr, _blobs_max);\n@@ -1324,1 +1695,0 @@\n-\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.cpp","additions":423,"deletions":53,"binary":false,"changes":476,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+class AsmRemarks;\n+class DbgStrings;\n@@ -50,0 +52,1 @@\n+    First_kind = 1,\n@@ -51,1 +54,4 @@\n-    Blob    = 2\n+    SharedBlob = 2,\n+    C1Blob = 3,\n+    C2Blob = 4,\n+    Last_kind = 4\n@@ -55,0 +61,2 @@\n+  static const char* _kind_string[Last_kind+1];\n+\n@@ -103,1 +111,4 @@\n-  static bool is_valid_entry_kind(Kind kind) { return kind == Adapter || kind == Blob; }\n+  static const char* kind_string(Kind kind) { return _kind_string[(int)kind]; }\n+  static bool is_valid_entry_kind(Kind kind) { return kind >= First_kind && kind <= Last_kind; }\n+  static bool is_blob(Kind kind) { return kind == SharedBlob || kind == C1Blob || kind == C2Blob; }\n+  static bool is_adapter(Kind kind) { return kind == Adapter; }\n@@ -110,1 +121,3 @@\n-  address* _blobs_addr;\n+  address* _stubs_addr;\n+  address* _shared_blobs_addr;\n+  address* _C1_blobs_addr;\n@@ -112,1 +125,3 @@\n-  uint     _blobs_length;\n+  uint     _stubs_length;\n+  uint     _shared_blobs_length;\n+  uint     _C1_blobs_length;\n@@ -115,0 +130,1 @@\n+  bool _early_stubs_complete;\n@@ -116,0 +132,1 @@\n+  bool _early_c1_complete;\n@@ -121,1 +138,2 @@\n-    _blobs_addr(nullptr),\n+    _shared_blobs_addr(nullptr),\n+    _C1_blobs_addr(nullptr),\n@@ -123,1 +141,3 @@\n-    _blobs_length(0),\n+    _stubs_length(0),\n+    _shared_blobs_length(0),\n+    _C1_blobs_length(0),\n@@ -125,0 +145,1 @@\n+    _early_stubs_complete(false),\n@@ -126,0 +147,1 @@\n+    _early_c1_complete(false),\n@@ -130,0 +152,1 @@\n+  void init_early_stubs();\n@@ -131,0 +154,1 @@\n+  void init_early_c1();\n@@ -144,0 +168,1 @@\n+    address _compressedOopBase;\n@@ -145,0 +170,1 @@\n+    address _compressedKlassBase;\n@@ -178,1 +204,3 @@\n-    uint   _blobs_count;\n+    uint   _shared_blobs_count;\n+    uint   _C1_blobs_count;\n+    uint   _C2_blobs_count;\n@@ -185,1 +213,2 @@\n-              uint adapters_count, uint blobs_count) {\n+              uint adapters_count, uint shared_blobs_count,\n+              uint C1_blobs_count, uint C2_blobs_count) {\n@@ -193,2 +222,3 @@\n-      _blobs_count    = blobs_count;\n-\n+      _shared_blobs_count = shared_blobs_count;\n+      _C1_blobs_count = C1_blobs_count;\n+      _C2_blobs_count = C2_blobs_count;\n@@ -205,1 +235,3 @@\n-    uint blobs_count()    const { return _blobs_count; }\n+    uint shared_blobs_count()    const { return _shared_blobs_count; }\n+    uint C1_blobs_count() const { return _C1_blobs_count; }\n+    uint C2_blobs_count() const { return _C2_blobs_count; }\n@@ -270,0 +302,1 @@\n+  static void init_early_stubs_table() NOT_CDS_RETURN;\n@@ -271,0 +304,1 @@\n+  static void init_early_c1_table() NOT_CDS_RETURN;\n@@ -291,0 +325,4 @@\n+#ifndef PRODUCT\n+  bool write_asm_remarks(CodeBlob& cb);\n+  bool write_dbg_strings(CodeBlob& cb);\n+#endif \/\/ PRODUCT\n@@ -295,2 +333,2 @@\n-                              int entry_offset_count,\n-                              int* entry_offsets) NOT_CDS_RETURN_(false);\n+                              int entry_offset_count = 0,\n+                              int* entry_offsets = nullptr) NOT_CDS_RETURN_(false);\n@@ -300,2 +338,2 @@\n-                                  int entry_offset_count,\n-                                  int* entry_offsets) NOT_CDS_RETURN_(nullptr);\n+                                  int entry_offset_count = 0,\n+                                  int* entry_offsets = nullptr) NOT_CDS_RETURN_(nullptr);\n@@ -334,0 +372,3 @@\n+  static bool is_dumping_stubs() NOT_CDS_RETURN_(false);\n+  static bool is_using_stubs() NOT_CDS_RETURN_(false);\n+\n@@ -364,0 +405,4 @@\n+#ifndef PRODUCT\n+  void read_asm_remarks(AsmRemarks& asm_remarks);\n+  void read_dbg_strings(DbgStrings& dbg_strings);\n+#endif \/\/ PRODUCT\n@@ -365,1 +410,2 @@\n-#endif \/\/ SHARE_CODE_AOTCODECACH_HPP\n+\n+#endif \/\/ SHARE_CODE_AOTCODECACHE_HPP\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.hpp","additions":62,"deletions":16,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -267,1 +267,5 @@\n-CodeBlob* CodeBlob::restore(address code_cache_buffer, const char* name, address archived_reloc_data, ImmutableOopMapSet* archived_oop_maps) {\n+CodeBlob* CodeBlob::restore(address code_cache_buffer,\n+                            const char* name,\n+                            address archived_reloc_data,\n+                            ImmutableOopMapSet* archived_oop_maps)\n+{\n@@ -276,1 +280,10 @@\n-CodeBlob* CodeBlob::create(CodeBlob* archived_blob, const char* name, address archived_reloc_data, ImmutableOopMapSet* archived_oop_maps) {\n+CodeBlob* CodeBlob::create(CodeBlob* archived_blob,\n+                           const char* name,\n+                           address archived_reloc_data,\n+                           ImmutableOopMapSet* archived_oop_maps\n+#ifndef PRODUCT\n+                           , AsmRemarks& archived_asm_remarks\n+                           , DbgStrings& archived_dbg_strings\n+#endif \/\/ PRODUCT\n+                          )\n+{\n@@ -287,1 +300,11 @@\n-      blob = archived_blob->restore(code_cache_buffer, name, archived_reloc_data, archived_oop_maps);\n+      blob = archived_blob->restore(code_cache_buffer,\n+                                    name,\n+                                    archived_reloc_data,\n+                                    archived_oop_maps);\n+#ifndef PRODUCT\n+      blob->use_remarks(archived_asm_remarks);\n+      archived_asm_remarks.clear();\n+      blob->use_strings(archived_dbg_strings);\n+      archived_dbg_strings.clear();\n+#endif \/\/ PRODUCT\n+\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":26,"deletions":3,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -102,0 +102,3 @@\n+class DeoptimizationBlob;\n+class SafepointBlob;\n+class UncommonTrapBlob;\n@@ -208,0 +211,3 @@\n+  ExceptionBlob* as_exception_blob() const    { assert(is_exception_stub(), \"must be exception stub\"); return (ExceptionBlob*) this; }\n+  DeoptimizationBlob* as_deoptimization_blob() const { assert(is_deoptimization_stub(), \"must be deopt stub\"); return (DeoptimizationBlob*) this; }\n+  SafepointBlob* as_safepoint_blob() const    { assert(is_safepoint_stub(), \"must be safepoint stub\"); return (SafepointBlob*) this; }\n@@ -210,0 +216,1 @@\n+  UncommonTrapBlob* as_uncommon_trap_blob() const { assert(is_uncommon_trap_stub(), \"must be uncommon trap stub\"); return (UncommonTrapBlob*) this; }\n@@ -311,1 +318,9 @@\n-  static CodeBlob* create(CodeBlob* archived_blob, const char* name, address archived_reloc_data, ImmutableOopMapSet* archived_oop_maps);\n+  static CodeBlob* create(CodeBlob* archived_blob,\n+                          const char* name,\n+                          address archived_reloc_data,\n+                          ImmutableOopMapSet* archived_oop_maps\n+#ifndef PRODUCT\n+                          , AsmRemarks& archived_asm_remarks\n+                          , DbgStrings& archived_dbg_strings\n+#endif \/\/ PRODUCT\n+                         );\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -633,0 +634,1 @@\n+      _stub_id(-1),\n@@ -902,0 +904,1 @@\n+                 int stub_id,\n@@ -913,0 +916,1 @@\n+      _stub_id(stub_id),\n@@ -964,0 +968,10 @@\n+  \/\/ try to reuse an existing stub\n+  {\n+    CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::C2Blob, _stub_id, stub_name);\n+    if (blob != nullptr) {\n+      RuntimeStub* rs = blob->as_runtime_stub();\n+      _stub_entry_point = rs->entry_point();\n+      return;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -311,0 +311,1 @@\n+  int                   _stub_id;               \/\/ unique id for stub or -1\n@@ -573,0 +574,1 @@\n+  int               stub_id() const             { return _stub_id; }\n@@ -1143,1 +1145,1 @@\n-          int is_fancy_jump, bool pass_tls,\n+          int stub_id, int is_fancy_jump, bool pass_tls,\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -3490,0 +3491,1 @@\n+        AOTCodeCache::store_code_blob(*rs, AOTCodeEntry::C2Blob, C->stub_id(), stub_name);\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+#define C2_STUB_ID(name) OptoStubId::name ## _id\n@@ -160,0 +161,1 @@\n+                  (int)C2_STUB_ID(name),                                   \\\n@@ -173,0 +175,1 @@\n+                  (int)C2_STUB_ID(name),                                     \\\n@@ -280,2 +283,2 @@\n-                                   const char *name, int is_fancy_jump,\n-                                   bool pass_tls,\n+                                   const char *name, int stub_id,\n+                                   int is_fancy_jump, bool pass_tls,\n@@ -288,1 +291,1 @@\n-  Compile C(env, gen, C_function, name, is_fancy_jump, pass_tls, return_pc, directive);\n+  Compile C(env, gen, C_function, name, stub_id, is_fancy_jump, pass_tls, return_pc, directive);\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -220,1 +220,1 @@\n-  static address generate_stub(ciEnv* ci_env, TypeFunc_generator gen, address C_function, const char* name, int is_fancy_jump, bool pass_tls, bool return_pc);\n+  static address generate_stub(ciEnv* ci_env, TypeFunc_generator gen, address C_function, const char* name, int stub_id, int is_fancy_jump, bool pass_tls, bool return_pc);\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,0 +43,3 @@\n+import java.util.ArrayList;\n+import java.util.List;\n+\n@@ -47,1 +50,0 @@\n-    public static int flag_sign = 0;\n@@ -50,2 +52,2 @@\n-        for (int i = 0; i < 2; i++) {\n-            flag_sign = i;\n+        for (int mode = 0; mode < 3; mode++) {\n+            t.setTestMode(mode);\n@@ -56,0 +58,2 @@\n+        private int testMode;\n+\n@@ -57,1 +61,21 @@\n-            super(\"AOTCodeFlags\" + flag_sign);\n+            super(\"AOTCodeFlags\");\n+            testMode = 0;\n+        }\n+\n+        boolean isAdapterCachingOn() {\n+            return (testMode & 0x1) != 0;\n+        }\n+\n+        boolean isStubCachingOn() {\n+            return (testMode & 0x2) != 0;\n+        }\n+\n+        public void setTestMode(int mode) {\n+            testMode = mode;\n+        }\n+\n+        public List<String> getVMArgsForTestMode() {\n+            List<String> list = new ArrayList<String>();\n+            list.add(isAdapterCachingOn() ? \"-XX:+AOTAdapterCaching\" : \"-XX:-AOTAdapterCaching\");\n+            list.add(isStubCachingOn() ? \"-XX:+AOTStubCaching\" : \"-XX:-AOTStubCaching\");\n+            return list;\n@@ -69,7 +93,7 @@\n-            case RunMode.PRODUCTION:\n-                return new String[] {\n-                    \"-XX:+UnlockDiagnosticVMOptions\",\n-                    \"-XX:\" + (flag_sign == 0 ? \"-\" : \"+\") + \"AOTAdapterCaching\",\n-                    \"-Xlog:aot+codecache+init=debug\",\n-                    \"-Xlog:aot+codecache+exit=debug\",\n-                };\n+            case RunMode.PRODUCTION: {\n+                    List<String> args = getVMArgsForTestMode();\n+                    args.addAll(List.of(\"-XX:+UnlockDiagnosticVMOptions\",\n+                                        \"-Xlog:aot+codecache+init=debug\",\n+                                        \"-Xlog:aot+codecache+exit=debug\"));\n+                    return args.toArray(new String[0]);\n+                }\n@@ -89,1 +113,1 @@\n-            if (flag_sign == 0) {\n+            if (!isAdapterCachingOn() && !isStubCachingOn()) { \/\/ this is equivalent to completely disable AOT code cache\n@@ -93,1 +117,4 @@\n-                    out.shouldNotContain(\"Adapters:  total\");\n+                    out.shouldNotMatch(\"Adapters:\\\\s+total\");\n+                    out.shouldNotMatch(\"Shared Blobs:\\\\s+total\");\n+                    out.shouldNotMatch(\"C1 Blobs:\\\\s+total\");\n+                    out.shouldNotMatch(\"C2 Blobs:\\\\s+total\");\n@@ -96,1 +123,0 @@\n-\n@@ -98,5 +124,37 @@\n-                switch (runMode) {\n-                case RunMode.ASSEMBLY:\n-                case RunMode.PRODUCTION:\n-                    out.shouldContain(\"Adapters:  total\");\n-                    break;\n+                if (isAdapterCachingOn()) {\n+                    switch (runMode) {\n+                    case RunMode.ASSEMBLY:\n+                    case RunMode.PRODUCTION:\n+                        \/\/ AOTAdapterCaching is on, non-zero adapters should be stored\/loaded\n+                        out.shouldMatch(\"Adapters:\\\\s+total=[1-9][0-9]+\");\n+                        break;\n+                    }\n+                } else {\n+                    switch (runMode) {\n+                    case RunMode.ASSEMBLY:\n+                    case RunMode.PRODUCTION:\n+                        \/\/ AOTAdapterCaching is off, no adapters should be stored\/loaded\n+                        out.shouldMatch(\"Adapters:\\\\s+total=0\");\n+                        break;\n+                    }\n+                }\n+                if (isStubCachingOn()) {\n+                    switch (runMode) {\n+                    case RunMode.ASSEMBLY:\n+                    case RunMode.PRODUCTION:\n+                        \/\/ AOTStubCaching is on, non-zero stubs should be stored\/loaded\n+                        out.shouldMatch(\"Shared Blobs:\\\\s+total=[1-9][0-9]+\");\n+                        out.shouldMatch(\"C1 Blobs:\\\\s+total=[1-9][0-9]+\");\n+                        out.shouldMatch(\"C2 Blobs:\\\\s+total=[1-9][0-9]+\");\n+                        break;\n+                    }\n+                } else {\n+                    switch (runMode) {\n+                    case RunMode.ASSEMBLY:\n+                    case RunMode.PRODUCTION:\n+                        \/\/ AOTStubCaching is off, no stubs should be stored\/loaded\n+                        out.shouldMatch(\"Shared Blobs:\\\\s+total=0\");\n+                        out.shouldMatch(\"C1 Blobs:\\\\s+total=0\");\n+                        out.shouldMatch(\"C2 Blobs:\\\\s+total=0\");\n+                        break;\n+                    }\n@@ -106,1 +164,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCode\/AOTCodeFlags.java","additions":77,"deletions":20,"binary":false,"changes":97,"status":"modified"}]}