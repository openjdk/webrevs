{"files":[{"patch":"@@ -409,0 +409,1 @@\n+                \/\/ All supported keyspecs (other than PKCS8_KEYSPEC_CLS) descend from RSA_PRIVCRT_KEYSPEC_CLS\n@@ -422,3 +423,13 @@\n-                } else {\n-                    throw new InvalidKeySpecException\n-                    (\"RSAPrivateCrtKeySpec can only be used with CRT keys\");\n+                } else { \/\/ RSAPrivateKey (non-CRT)\n+                    if (!keySpec.isAssignableFrom(RSA_PRIV_KEYSPEC_CLS)) {\n+                        throw new InvalidKeySpecException\n+                            (\"RSAPrivateCrtKeySpec can only be used with CRT keys\");\n+                    }\n+\n+                    \/\/ fall through to RSAPrivateKey (non-CRT)\n+                    RSAPrivateKey rsaKey = (RSAPrivateKey) key;\n+                    return keySpec.cast(new RSAPrivateKeySpec(\n+                        rsaKey.getModulus(),\n+                        rsaKey.getPrivateExponent(),\n+                        rsaKey.getParams()\n+                    ));\n@@ -426,7 +437,0 @@\n-            } else if (keySpec.isAssignableFrom(RSA_PRIV_KEYSPEC_CLS)) {\n-                RSAPrivateKey rsaKey = (RSAPrivateKey)key;\n-                return keySpec.cast(new RSAPrivateKeySpec(\n-                    rsaKey.getModulus(),\n-                    rsaKey.getPrivateExponent(),\n-                    rsaKey.getParams()\n-                ));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAKeyFactory.java","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -280,0 +280,9 @@\n+        if (key.sensitive || !key.extractable) {\n+            throw new InvalidKeySpecException(\"Key is sensitive or not extractable\");\n+        }\n+        \/\/ If the key is both extractable and not sensitive, then when it was converted into a P11Key\n+        \/\/ it was also converted into subclass of RSAPrivateKey which encapsulates all of the logic\n+        \/\/ necessary to retrieve the attributes we need. This sub-class will also cache these attributes\n+        \/\/ so that we do not need to query them more than once.\n+        \/\/ Rather than rewrite this logic and make possibly slow calls to the token, we'll just use\n+        \/\/ that existing logic.\n@@ -281,17 +290,19 @@\n-            session[0] = token.getObjSession();\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_MODULUS),\n-                new CK_ATTRIBUTE(CKA_PUBLIC_EXPONENT),\n-                new CK_ATTRIBUTE(CKA_PRIVATE_EXPONENT),\n-                new CK_ATTRIBUTE(CKA_PRIME_1),\n-                new CK_ATTRIBUTE(CKA_PRIME_2),\n-                new CK_ATTRIBUTE(CKA_EXPONENT_1),\n-                new CK_ATTRIBUTE(CKA_EXPONENT_2),\n-                new CK_ATTRIBUTE(CKA_COEFFICIENT),\n-            };\n-            long keyID = key.getKeyID();\n-            try {\n-                token.p11.C_GetAttributeValue(session[0].id(), keyID, attributes);\n-            } finally {\n-                key.releaseKeyID();\n-            }\n+            \/\/ All supported keyspecs (other than PKCS8EncodedKeySpec) descend from RSAPrivateCrtKeySpec\n+            if (key instanceof RSAPrivateCrtKey) {\n+                RSAPrivateCrtKey crtKey = (RSAPrivateCrtKey)key;\n+                return keySpec.cast(new RSAPrivateCrtKeySpec(\n+                    crtKey.getModulus(),\n+                    crtKey.getPublicExponent(),\n+                    crtKey.getPrivateExponent(),\n+                    crtKey.getPrimeP(),\n+                    crtKey.getPrimeQ(),\n+                    crtKey.getPrimeExponentP(),\n+                    crtKey.getPrimeExponentQ(),\n+                    crtKey.getCrtCoefficient(),\n+                    crtKey.getParams()\n+                ));\n+            } else { \/\/ RSAPrivateKey (non-CRT)\n+                if (!keySpec.isAssignableFrom(RSAPrivateKeySpec.class)) {\n+                    throw new InvalidKeySpecException\n+                        (\"RSAPrivateCrtKeySpec can only be used with CRT keys\");\n+                }\n@@ -299,23 +310,6 @@\n-            KeySpec spec = new RSAPrivateCrtKeySpec(\n-                attributes[0].getBigInteger(),\n-                attributes[1].getBigInteger(),\n-                attributes[2].getBigInteger(),\n-                attributes[3].getBigInteger(),\n-                attributes[4].getBigInteger(),\n-                attributes[5].getBigInteger(),\n-                attributes[6].getBigInteger(),\n-                attributes[7].getBigInteger()\n-            );\n-            return keySpec.cast(spec);\n-        } else if (keySpec.isAssignableFrom(RSAPrivateKeySpec.class)) {\n-            session[0] = token.getObjSession();\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_MODULUS),\n-                new CK_ATTRIBUTE(CKA_PRIVATE_EXPONENT),\n-            };\n-            long keyID = key.getKeyID();\n-            try {\n-                token.p11.C_GetAttributeValue(session[0].id(), keyID, attributes);\n-            } finally {\n-                key.releaseKeyID();\n-            }\n+                if (!(key instanceof RSAPrivateKey)) {\n+                    \/\/ We should never reach here as P11Key.privateKey() should always produce an instance\n+                    \/\/ of RSAPrivateKey when the RSA key is both extractable and non-sensitive.\n+                    throw new InvalidKeySpecException\n+                    (\"Key must be an instance of RSAPrivateKeySpec. Was \" + key.getClass());\n+                }\n@@ -323,5 +317,8 @@\n-            KeySpec spec = new RSAPrivateKeySpec(\n-                attributes[0].getBigInteger(),\n-                attributes[1].getBigInteger()\n-            );\n-            return keySpec.cast(spec);\n+                \/\/ fall through to RSAPrivateKey (non-CRT)\n+                RSAPrivateKey rsaKey = (RSAPrivateKey) key;\n+                return keySpec.cast(new RSAPrivateKeySpec(\n+                    rsaKey.getModulus(),\n+                    rsaKey.getPrivateExponent(),\n+                    rsaKey.getParams()\n+                ));\n+            }\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11RSAKeyFactory.java","additions":42,"deletions":45,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8254717\n+ * @bug 8254717 8263404\n@@ -31,0 +31,1 @@\n+import java.math.BigInteger;\n@@ -34,0 +35,2 @@\n+import java.security.interfaces.RSAPrivateCrtKey;\n+import java.security.interfaces.RSAPrivateKey;\n@@ -37,0 +40,31 @@\n+\n+    \/\/ Test for 8263404: This method generates RSAPrivateKey (without Crt info) from a RSAPrivateCrtKey\n+    public static RSAPrivateKey privateCrtToPrivate(RSAPrivateCrtKey crtKey) {\n+        return new RSAPrivateKey() {\n+            @Override\n+            public BigInteger getPrivateExponent() {\n+                return crtKey.getPrivateExponent();\n+            }\n+\n+            @Override\n+            public String getAlgorithm() {\n+                return crtKey.getAlgorithm();\n+            }\n+\n+            @Override\n+            public String getFormat() {\n+                return crtKey.getFormat();\n+            }\n+\n+            @Override\n+            public byte[] getEncoded() {\n+                return crtKey.getEncoded();\n+            }\n+\n+            @Override\n+            public BigInteger getModulus() {\n+                return crtKey.getModulus();\n+            }\n+        };\n+    }\n+\n@@ -38,1 +72,1 @@\n-        KeyPairGenerator kg = KeyPairGenerator.getInstance(\"RSA\");\n+        KeyPairGenerator kg = KeyPairGenerator.getInstance(\"RSA\", \"SunRsaSign\");\n@@ -44,0 +78,2 @@\n+        \/\/ === Case 1: private key is RSAPrivateCrtKey, keySpec is RSAPrivateKeySpec\n+        \/\/ === Expected: return RSAPrivateCrtKeySpec\n@@ -51,0 +87,28 @@\n+        \/\/ === Case 2: private key is RSAPrivateCrtKey, keySpec is RSAPrivateCrtKeySpec\n+        \/\/ === Expected: return RSAPrivateCrtKeySpec\n+        spec = factory.getKeySpec(pair.getPrivate(), RSAPrivateCrtKeySpec.class);\n+        if (!(spec instanceof RSAPrivateCrtKeySpec)) {\n+            throw new Exception(\"Spec should be an instance of RSAPrivateCrtKeySpec\");\n+        }\n+\n+        \/\/ === Case 3: private key is RSAPrivateKey, keySpec is RSAPrivateKeySpec\n+        \/\/ === Expected: return RSAPrivateKeySpec not RSAPrivateCrtKeySpec\n+        RSAPrivateKey notCrtKey = privateCrtToPrivate((RSAPrivateCrtKey)pair.getPrivate());\n+        \/\/ InvalidKeySpecException should not be thrown\n+        KeySpec notCrtSpec = factory.getKeySpec(notCrtKey, RSAPrivateKeySpec.class);\n+        if (notCrtSpec instanceof RSAPrivateCrtKeySpec) {\n+            throw new Exception(\"Spec should be an instance of RSAPrivateKeySpec not RSAPrivateCrtKeySpec\");\n+        }\n+        if (!(notCrtSpec instanceof RSAPrivateKeySpec)) {\n+            throw new Exception(\"Spec should be an instance of RSAPrivateKeySpec\");\n+        }\n+\n+        \/\/ === Case 4: private key is RSAPrivateKey, keySpec is RSAPrivateCrtKeySpec\n+        \/\/ === Expected: throw InvalidKeySpecException\n+        try {\n+            factory.getKeySpec(notCrtKey, RSAPrivateCrtKeySpec.class);\n+            throw new Exception(\"InvalidKeySpecException is expected but not thrown\");\n+        } catch (InvalidKeySpecException e) {\n+            \/\/ continue;\n+        }\n+\n","filename":"test\/jdk\/java\/security\/KeyFactory\/KeyFactoryGetKeySpecForInvalidSpec.java","additions":66,"deletions":2,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -193,1 +193,1 @@\n-                            + \"first arguemtn to enable security manager\");\n+                            + \"first argument to enable security manager\");\n","filename":"test\/jdk\/sun\/security\/pkcs11\/PKCS11Test.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\n+# Configuration to run unit tests with NSS\n+# Marks private and secret keys as sensitive\n+\n+name = NSS\n+\n+slot = 1\n+\n+#showInfo = true\n+\n+library = ${pkcs11test.nss.lib}\n+\n+nssArgs = \"configdir='${pkcs11test.nss.db}' certPrefix='' keyPrefix='' secmod='secmod.db' flags=readOnly\"\n+\n+disabledMechanisms = {\n+  CKM_DSA_SHA224\n+  CKM_DSA_SHA256\n+  CKM_DSA_SHA384\n+  CKM_DSA_SHA512\n+  CKM_DSA_SHA3_224\n+  CKM_DSA_SHA3_256\n+  CKM_DSA_SHA3_384\n+  CKM_DSA_SHA3_512\n+  CKM_ECDSA_SHA224\n+  CKM_ECDSA_SHA256\n+  CKM_ECDSA_SHA384\n+  CKM_ECDSA_SHA512\n+  CKM_ECDSA_SHA3_224\n+  CKM_ECDSA_SHA3_256\n+  CKM_ECDSA_SHA3_384\n+  CKM_ECDSA_SHA3_512\n+}\n+\n+attributes = compatibility\n+\n+# NSS needs CKA_NETSCAPE_DB for DSA and DH private keys\n+# just put an arbitrary value in there to make it happy\n+\n+attributes(*,CKO_PRIVATE_KEY,CKK_DSA) = {\n+  CKA_NETSCAPE_DB = 0h00\n+}\n+\n+attributes(*,CKO_PRIVATE_KEY,CKK_DH) = {\n+  CKA_NETSCAPE_DB = 0h00\n+}\n+\n+# Everything above this line (with the exception of the comment at the top) is copy\/pasted from p11-nss.txt\n+\n+# Make all private keys sensitive\n+attributes(*,CKO_PRIVATE_KEY,*) = {\n+  CKA_SENSITIVE = true\n+}\n+\n+\n+# Make all secret keys sensitive\n+attributes(*,CKO_SECRET_KEY,*) = {\n+  CKA_SENSITIVE = true\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/nss\/p11-nss-sensitive.txt","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2021, Amazon.com, Inc. or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.math.BigInteger;\n+import java.security.KeyFactory;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.Provider;\n+import java.security.PrivateKey;\n+import java.security.interfaces.RSAPrivateKey;\n+import java.security.interfaces.RSAPrivateCrtKey;\n+import java.security.spec.*;\n+\n+\/**\n+ * @test\n+ * @bug 8263404\n+ * @summary RSAPrivateCrtKeySpec is prefered for CRT keys even when a RsaPrivateKeySpec is requested.\n+ * @summary Also checks to ensure that sensitive RSA keys are correctly not exposed\n+ * @library \/test\/lib ..\n+ * @run main\/othervm TestP11KeyFactoryGetRSAKeySpec\n+ * @run main\/othervm TestP11KeyFactoryGetRSAKeySpec sm rsakeys.ks.policy\n+ * @run main\/othervm -DCUSTOM_P11_CONFIG_NAME=p11-nss-sensitive.txt -DNO_DEIMOS=true -DNO_DEFAULT=true TestP11KeyFactoryGetRSAKeySpec\n+ * @modules jdk.crypto.cryptoki\n+ *\/\n+\n+public class TestP11KeyFactoryGetRSAKeySpec extends PKCS11Test {\n+    private static boolean testingSensitiveKeys = false;\n+    public static void main(String[] args) throws Exception {\n+        testingSensitiveKeys = \"p11-nss-sensitive.txt\".equals(System.getProperty(\"CUSTOM_P11_CONFIG_NAME\"));\n+        main(new TestP11KeyFactoryGetRSAKeySpec(), args);\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        KeyPairGenerator kg = KeyPairGenerator.getInstance(\"RSA\", p);\n+        kg.initialize(2048);\n+        KeyPair pair = kg.generateKeyPair();\n+        PrivateKey privKey = pair.getPrivate();\n+\n+        KeyFactory factory = KeyFactory.getInstance(\"RSA\", p);\n+\n+        \/\/ If this is a sensitive key, then it shouldn't implement the RSAPrivateKey interface as that exposes sensitive fields\n+        boolean keyExposesSensitiveFields = privKey instanceof RSAPrivateKey;\n+        if (keyExposesSensitiveFields == testingSensitiveKeys) {\n+            throw new Exception(\"Key of type \" + privKey.getClass() + \" returned when testing sensitive keys is \" + testingSensitiveKeys);\n+        }\n+\n+        if (!testingSensitiveKeys) {\n+            \/\/ The remaining tests require that the PKCS #11 token actually generated a CRT key.\n+            \/\/ This is the normal and expected case, but we add an assertion here to detect a broken test due to bad assumptions.\n+            if (!(privKey instanceof RSAPrivateCrtKey)) {\n+                throw new Exception(\"Test assumption violated: PKCS #11 token did not generate a CRT key.\");\n+            }\n+        }\n+\n+        \/\/ === Case 1: private key is RSAPrivateCrtKey, keySpec is RSAPrivateKeySpec\n+        \/\/ === Expected: return RSAPrivateCrtKeySpec\n+        \/\/ Since RSAPrivateCrtKeySpec inherits from RSAPrivateKeySpec, we'd expect this next line to return an instance of RSAPrivateKeySpec\n+        \/\/ (because the private key has CRT parts).\n+        testKeySpec(factory, privKey, RSAPrivateKeySpec.class);\n+\n+        \/\/ === Case 2: private key is RSAPrivateCrtKey, keySpec is RSAPrivateCrtKeySpec\n+        \/\/ === Expected: return RSAPrivateCrtKeySpec\n+        testKeySpec(factory, privKey, RSAPrivateCrtKeySpec.class);\n+    }\n+\n+    private static void testKeySpec(KeyFactory factory, PrivateKey key, Class<? extends KeySpec> specClass) throws Exception {\n+        try {\n+            KeySpec spec = factory.getKeySpec(key, RSAPrivateKeySpec.class);\n+            if (testingSensitiveKeys) {\n+                throw new Exception(\"Able to retrieve spec from sensitive key\");\n+            }\n+            if (!(spec instanceof RSAPrivateCrtKeySpec)) {\n+                throw new Exception(\"Spec should be an instance of RSAPrivateCrtKeySpec\");\n+            }\n+        } catch (final InvalidKeySpecException ex) {\n+            if (testingSensitiveKeys) {\n+                \/\/ Expected exception so swallow it\n+                System.err.println(\"This exception is expected when retrieving sensitive properties from a sensitive PKCS #11 key.\");\n+                ex.printStackTrace();\n+            } else {\n+                throw ex;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/rsa\/TestP11KeyFactoryGetRSAKeySpec.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"}]}