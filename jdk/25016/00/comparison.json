{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.security.AlgorithmConstraints;\n@@ -48,1 +49,0 @@\n-import javax.net.ssl.X509ExtendedKeyManager;\n@@ -80,1 +80,0 @@\n- *\n@@ -82,1 +81,2 @@\n-final class SunX509KeyManagerImpl extends X509ExtendedKeyManager {\n+\n+final class SunX509KeyManagerImpl extends X509KeyManagerConstraints {\n@@ -90,1 +90,1 @@\n-    private final Map<String,X509Credentials> credentialsMap;\n+    private final Map<String, X509Credentials> credentialsMap;\n@@ -99,1 +99,1 @@\n-    private final Map<String,String[]> serverAliasCache;\n+    private final Map<String, String[]> serverAliasCache;\n@@ -105,0 +105,1 @@\n+\n@@ -127,1 +128,0 @@\n-\n@@ -136,1 +136,1 @@\n-                                        aliases.hasMoreElements(); ) {\n+                aliases.hasMoreElements(); ) {\n@@ -156,2 +156,2 @@\n-            X509Credentials cred = new X509Credentials((PrivateKey)key,\n-                (X509Certificate[])certs);\n+            X509Credentials cred = new X509Credentials((PrivateKey) key,\n+                    (X509Certificate[]) certs);\n@@ -160,1 +160,1 @@\n-                SSLLogger.fine(\"found key for : \" + alias, (Object[])certs);\n+                SSLLogger.fine(\"found key for : \" + alias, (Object[]) certs);\n@@ -208,18 +208,2 @@\n-        \/*\n-         * We currently don't do anything with socket, but\n-         * someday we might.  It might be a useful hint for\n-         * selecting one of the aliases we get back from\n-         * getClientAliases().\n-         *\/\n-\n-        if (keyTypes == null) {\n-            return null;\n-        }\n-\n-        for (int i = 0; i < keyTypes.length; i++) {\n-            String[] aliases = getClientAliases(keyTypes[i], issuers);\n-            if ((aliases != null) && (aliases.length > 0)) {\n-                return aliases[0];\n-            }\n-        }\n-        return null;\n+        return chooseClientAlias(keyTypes, issuers,\n+                getAlgorithmConstraints(socket));\n@@ -239,5 +223,21 @@\n-        \/*\n-         * If we ever start using socket as a selection criteria,\n-         * we'll need to adjust this.\n-         *\/\n-        return chooseClientAlias(keyType, issuers, null);\n+        return chooseClientAlias(\n+                keyType, issuers, getAlgorithmConstraints(engine));\n+    }\n+\n+    private String chooseClientAlias(String[] keyTypes, Principal[] issuers,\n+            AlgorithmConstraints constraints) {\n+\n+        if (keyTypes == null) {\n+            return null;\n+        }\n+\n+        for (String keyType : keyTypes) {\n+            String[] aliases = getAliases(\n+                    keyType, issuers, CheckType.CLIENT, constraints);\n+\n+            if ((aliases != null) && (aliases.length > 0)) {\n+                return aliases[0];\n+            }\n+        }\n+\n+        return null;\n@@ -254,6 +254,22 @@\n-        \/*\n-         * We currently don't do anything with socket, but\n-         * someday we might.  It might be a useful hint for\n-         * selecting one of the aliases we get back from\n-         * getServerAliases().\n-         *\/\n+        return chooseServerAlias(\n+                keyType, issuers, getAlgorithmConstraints(socket));\n+    }\n+\n+    \/*\n+     * Choose an alias to authenticate the server side of an\n+     * <code>SSLEngine<\/code> connection given the public key type\n+     * and the list of certificate issuer authorities recognized by\n+     * the peer (if any).\n+     *\n+     * @since 1.5\n+     *\/\n+    @Override\n+    public String chooseEngineServerAlias(String keyType,\n+            Principal[] issuers, SSLEngine engine) {\n+        return chooseServerAlias(\n+                keyType, issuers, getAlgorithmConstraints(engine));\n+    }\n+\n+    private String chooseServerAlias(String keyType,\n+            Principal[] issuers, AlgorithmConstraints constraints) {\n+\n@@ -269,1 +285,2 @@\n-                aliases = getServerAliases(keyType, issuers);\n+                aliases = getAliases(keyType, issuers,\n+                        CheckType.SERVER, constraints);\n@@ -279,0 +296,1 @@\n+\n@@ -282,2 +300,0 @@\n-        return null;\n-    }\n@@ -285,16 +301,1 @@\n-    \/*\n-     * Choose an alias to authenticate the server side of an\n-     * <code>SSLEngine<\/code> connection given the public key type\n-     * and the list of certificate issuer authorities recognized by\n-     * the peer (if any).\n-     *\n-     * @since 1.5\n-     *\/\n-    @Override\n-    public String chooseEngineServerAlias(String keyType,\n-            Principal[] issuers, SSLEngine engine) {\n-        \/*\n-         * If we ever start using socket as a selection criteria,\n-         * we'll need to adjust this.\n-         *\/\n-        return chooseServerAlias(keyType, issuers, null);\n+        return null;\n@@ -310,1 +311,1 @@\n-        return getAliases(keyType, issuers);\n+        return getAliases(keyType, issuers, CheckType.CLIENT, null);\n@@ -320,1 +321,1 @@\n-        return getAliases(keyType, issuers);\n+        return getAliases(keyType, issuers, CheckType.SERVER, null);\n@@ -330,1 +331,2 @@\n-    private String[] getAliases(String keyType, Principal[] issuers) {\n+    private String[] getAliases(String keyType, Principal[] issuers,\n+            CheckType checkType, AlgorithmConstraints constraints) {\n@@ -350,1 +352,1 @@\n-        X500Principal[] x500Issuers = (X500Principal[])issuers;\n+        X500Principal[] x500Issuers = (X500Principal[]) issuers;\n@@ -354,2 +356,2 @@\n-        for (Map.Entry<String,X509Credentials> entry :\n-                                                credentialsMap.entrySet()) {\n+        for (Map.Entry<String, X509Credentials> entry :\n+                credentialsMap.entrySet()) {\n@@ -364,0 +366,1 @@\n+\n@@ -375,1 +378,2 @@\n-                        certs[0].getSigAlgName().toUpperCase(Locale.ENGLISH);\n+                            certs[0].getSigAlgName()\n+                                    .toUpperCase(Locale.ENGLISH);\n@@ -377,1 +381,1 @@\n-                        sigType.toUpperCase(Locale.ENGLISH);\n+                            sigType.toUpperCase(Locale.ENGLISH);\n@@ -384,0 +388,14 @@\n+            \/\/ check the algorithm constraints\n+            if (constraints != null &&\n+                    !conformsToAlgorithmConstraints(constraints, certs,\n+                            checkType.getValidator())) {\n+\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n+                    SSLLogger.fine(\"Ignore alias \" + alias +\n+                            \": certificate list does not conform to \" +\n+                            \"algorithm constraints\");\n+                }\n+\n+                continue;\n+            }\n+\n@@ -392,1 +410,1 @@\n-                                        credentials.getIssuerX500Principals();\n+                        credentials.getIssuerX500Principals();\n@@ -418,1 +436,1 @@\n-                list.add((X500Principal)p);\n+                list.add((X500Principal) p);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SunX509KeyManagerImpl.java","additions":87,"deletions":69,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -0,0 +1,356 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.ssl;\n+\n+import java.net.Socket;\n+import java.security.AlgorithmConstraints;\n+import java.security.cert.CertPathValidatorException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.net.ssl.ExtendedSSLSession;\n+import javax.net.ssl.SNIHostName;\n+import javax.net.ssl.SNIServerName;\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.SSLSession;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.StandardConstants;\n+import javax.net.ssl.X509ExtendedKeyManager;\n+import sun.security.provider.certpath.AlgorithmChecker;\n+import sun.security.util.KnownOIDs;\n+import sun.security.validator.Validator;\n+\n+\/**\n+ * Layer that adds algorithm constraints functionality and certificate\n+ * key usage check to a key manager. Algorithm constraints check can be\n+ * disabled by setting \"jdk.tls.keymanager.disableConstraintsChecking\"\n+ * system property to \"true\".\n+ *\/\n+\n+abstract class X509KeyManagerConstraints extends X509ExtendedKeyManager {\n+\n+    private static final String PROPERTY_KEYMANAGER_DISABLE_CONSTRAINTS =\n+            \"jdk.tls.keymanager.disableConstraintsChecking\";\n+\n+    \/\/ Indicates whether we should skip the constraints check.\n+    private final boolean constraintsDisabled;\n+\n+    protected X509KeyManagerConstraints() {\n+        constraintsDisabled = isConstraintsDisabled();\n+    }\n+\n+    \/\/ Gets algorithm constraints of the socket.\n+    protected AlgorithmConstraints getAlgorithmConstraints(Socket socket) {\n+\n+        if (constraintsDisabled) {\n+            return null;\n+        }\n+\n+        if (socket != null && socket.isConnected() &&\n+                socket instanceof SSLSocket sslSocket) {\n+\n+            SSLSession session = sslSocket.getHandshakeSession();\n+\n+            if (session != null) {\n+                if (ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {\n+                    String[] peerSupportedSignAlgs = null;\n+\n+                    if (session instanceof ExtendedSSLSession extSession) {\n+                        peerSupportedSignAlgs =\n+                                extSession.getPeerSupportedSignatureAlgorithms();\n+                    }\n+\n+                    return SSLAlgorithmConstraints.forSocket(\n+                            sslSocket, peerSupportedSignAlgs, true);\n+                }\n+            }\n+\n+            return SSLAlgorithmConstraints.forSocket(sslSocket, true);\n+        }\n+\n+        return SSLAlgorithmConstraints.DEFAULT;\n+    }\n+\n+    \/\/ Gets algorithm constraints of the engine.\n+    protected AlgorithmConstraints getAlgorithmConstraints(SSLEngine engine) {\n+\n+        if (constraintsDisabled) {\n+            return null;\n+        }\n+\n+        if (engine != null) {\n+            SSLSession session = engine.getHandshakeSession();\n+            if (session != null) {\n+                if (ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {\n+                    String[] peerSupportedSignAlgs = null;\n+\n+                    if (session instanceof ExtendedSSLSession extSession) {\n+                        peerSupportedSignAlgs =\n+                                extSession.getPeerSupportedSignatureAlgorithms();\n+                    }\n+\n+                    return SSLAlgorithmConstraints.forEngine(\n+                            engine, peerSupportedSignAlgs, true);\n+                }\n+            }\n+        }\n+\n+        return SSLAlgorithmConstraints.forEngine(engine, true);\n+    }\n+\n+    protected boolean conformsToAlgorithmConstraints(\n+            AlgorithmConstraints constraints, Certificate[] chain,\n+            String variant) {\n+\n+        if (constraintsDisabled) {\n+            return true;\n+        }\n+\n+        AlgorithmChecker checker = new AlgorithmChecker(constraints, variant);\n+        try {\n+            checker.init(false);\n+        } catch (CertPathValidatorException cpve) {\n+            \/\/ unlikely to happen\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n+                SSLLogger.fine(\n+                        \"Cannot initialize algorithm constraints checker\",\n+                        cpve);\n+            }\n+\n+            return false;\n+        }\n+\n+        \/\/ It is a forward checker, so we need to check from trust to target.\n+        for (int i = chain.length - 1; i >= 0; i--) {\n+            Certificate cert = chain[i];\n+            try {\n+                \/\/ We don't care about the unresolved critical extensions.\n+                checker.check(cert, Collections.emptySet());\n+            } catch (CertPathValidatorException cpve) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n+                    SSLLogger.fine(\"Certificate does not conform to \" +\n+                            \"algorithm constraints\", cert, cpve);\n+                }\n+\n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    protected boolean isConstraintsDisabled() {\n+        return \"true\".equals(System.getProperty(\n+                PROPERTY_KEYMANAGER_DISABLE_CONSTRAINTS));\n+    }\n+\n+    \/\/ enum for the result of the extension check\n+    \/\/ NOTE: the order of the constants is important as they are used\n+    \/\/ for sorting, i.e. OK is best, followed by EXPIRED and EXTENSION_MISMATCH\n+    enum CheckResult {\n+        OK,                     \/\/ ok or not checked\n+        INSENSITIVE,            \/\/ server name indication insensitive\n+        EXPIRED,                \/\/ extensions valid but cert expired\n+        EXTENSION_MISMATCH,     \/\/ extensions invalid (expiration not checked)\n+    }\n+\n+    \/\/ enum for the type of certificate check we want to perform\n+    \/\/ (client or server)\n+    \/\/ also includes the check code itself\n+    enum CheckType {\n+\n+        \/\/ enum constant for \"no check\" (currently not used)\n+        NONE(Collections.emptySet()),\n+\n+        \/\/ enum constant for \"tls client\" check\n+        \/\/ valid EKU for TLS client: any, tls_client\n+        CLIENT(new HashSet<>(List.of(\n+                KnownOIDs.anyExtendedKeyUsage.value(),\n+                KnownOIDs.clientAuth.value()\n+        ))),\n+\n+        \/\/ enum constant for \"tls server\" check\n+        \/\/ valid EKU for TLS server: any, tls_server, ns_sgc, ms_sgc\n+        SERVER(new HashSet<>(List.of(\n+                KnownOIDs.anyExtendedKeyUsage.value(),\n+                KnownOIDs.serverAuth.value(),\n+                KnownOIDs.NETSCAPE_ExportApproved.value(),\n+                KnownOIDs.MICROSOFT_ExportApproved.value()\n+        )));\n+\n+        \/\/ set of valid EKU values for this type\n+        final Set<String> validEku;\n+\n+        CheckType(Set<String> validEku) {\n+            this.validEku = validEku;\n+        }\n+\n+        private static boolean getBit(boolean[] keyUsage, int bit) {\n+            return (bit < keyUsage.length) && keyUsage[bit];\n+        }\n+\n+        \/\/ Check if this certificate is appropriate for this type of use\n+        \/\/ first check extensions, if they match, check expiration.\n+        \/\/\n+        \/\/ Note: we may want to move this code into the sun.security.validator\n+        \/\/ package\n+        CheckResult check(X509Certificate cert, Date date,\n+                List<SNIServerName> serverNames, String idAlgorithm) {\n+\n+            if (this == NONE) {\n+                return CheckResult.OK;\n+            }\n+\n+            \/\/ check extensions\n+            try {\n+                \/\/ check extended key usage\n+                List<String> certEku = cert.getExtendedKeyUsage();\n+                if ((certEku != null) &&\n+                        Collections.disjoint(validEku, certEku)) {\n+                    \/\/ if extension is present and does not contain any of\n+                    \/\/ the valid EKU OIDs, return extension_mismatch\n+                    return CheckResult.EXTENSION_MISMATCH;\n+                }\n+\n+                \/\/ check key usage\n+                boolean[] ku = cert.getKeyUsage();\n+                if (ku != null) {\n+                    String algorithm = cert.getPublicKey().getAlgorithm();\n+                    boolean supportsDigitalSignature = getBit(ku, 0);\n+                    switch (algorithm) {\n+                        case \"RSA\":\n+                            \/\/ require either signature bit\n+                            \/\/ or if server also allow key encipherment bit\n+                            if (!supportsDigitalSignature) {\n+                                if (this == CLIENT || !getBit(ku, 2)) {\n+                                    return CheckResult.EXTENSION_MISMATCH;\n+                                }\n+                            }\n+                            break;\n+                        case \"RSASSA-PSS\":\n+                            if (!supportsDigitalSignature && (this == SERVER)) {\n+                                return CheckResult.EXTENSION_MISMATCH;\n+                            }\n+                            break;\n+                        case \"DSA\":\n+                            \/\/ require signature bit\n+                            if (!supportsDigitalSignature) {\n+                                return CheckResult.EXTENSION_MISMATCH;\n+                            }\n+                            break;\n+                        case \"DH\":\n+                            \/\/ require keyagreement bit\n+                            if (!getBit(ku, 4)) {\n+                                return CheckResult.EXTENSION_MISMATCH;\n+                            }\n+                            break;\n+                        case \"EC\":\n+                            \/\/ require signature bit\n+                            if (!supportsDigitalSignature) {\n+                                return CheckResult.EXTENSION_MISMATCH;\n+                            }\n+                            \/\/ For servers, also require key agreement.\n+                            \/\/ This is not totally accurate as the keyAgreement\n+                            \/\/ bit is only necessary for static ECDH key\n+                            \/\/ exchange and not ephemeral ECDH. We leave it in\n+                            \/\/ for now until there are signs that this check\n+                            \/\/ causes problems for real world EC certificates.\n+                            if (this == SERVER && !getBit(ku, 4)) {\n+                                return CheckResult.EXTENSION_MISMATCH;\n+                            }\n+                            break;\n+                    }\n+                }\n+            } catch (CertificateException e) {\n+                \/\/ extensions unparseable, return failure\n+                return CheckResult.EXTENSION_MISMATCH;\n+            }\n+\n+            try {\n+                cert.checkValidity(date);\n+            } catch (CertificateException e) {\n+                return CheckResult.EXPIRED;\n+            }\n+\n+            if (serverNames != null && !serverNames.isEmpty()) {\n+                for (SNIServerName serverName : serverNames) {\n+                    if (serverName.getType() ==\n+                            StandardConstants.SNI_HOST_NAME) {\n+                        if (!(serverName instanceof SNIHostName)) {\n+                            try {\n+                                serverName =\n+                                        new SNIHostName(serverName.getEncoded());\n+                            } catch (IllegalArgumentException iae) {\n+                                \/\/ unlikely to happen, just in case ...\n+                                if (SSLLogger.isOn &&\n+                                        SSLLogger.isOn(\"keymanager\")) {\n+                                    SSLLogger.fine(\n+                                            \"Illegal server name: \" + serverName);\n+                                }\n+\n+                                return CheckResult.INSENSITIVE;\n+                            }\n+                        }\n+                        String hostname =\n+                                ((SNIHostName)serverName).getAsciiName();\n+\n+                        try {\n+                            X509TrustManagerImpl.checkIdentity(hostname,\n+                                    cert, idAlgorithm);\n+                        } catch (CertificateException e) {\n+                            if (SSLLogger.isOn &&\n+                                    SSLLogger.isOn(\"keymanager\")) {\n+                                SSLLogger.fine(\n+                                        \"Certificate identity does not match \" +\n+                                                \"Server Name Indication (SNI): \" +\n+                                                hostname);\n+                            }\n+                            return CheckResult.INSENSITIVE;\n+                        }\n+\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            return CheckResult.OK;\n+        }\n+\n+        public String getValidator() {\n+            if (this == CLIENT) {\n+                return Validator.VAR_TLS_CLIENT;\n+            } else if (this == SERVER) {\n+                return Validator.VAR_TLS_SERVER;\n+            }\n+            return Validator.VAR_GENERIC;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/X509KeyManagerConstraints.java","additions":356,"deletions":0,"binary":false,"changes":356,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-import java.security.cert.CertPathValidatorException;\n@@ -39,1 +38,0 @@\n-import java.security.cert.CertificateException;\n@@ -44,3 +42,0 @@\n-import sun.security.provider.certpath.AlgorithmChecker;\n-import sun.security.validator.Validator;\n-import sun.security.util.KnownOIDs;\n@@ -65,2 +60,2 @@\n-final class X509KeyManagerImpl extends X509ExtendedKeyManager\n-        implements X509KeyManager {\n+\n+final class X509KeyManagerImpl extends X509KeyManagerConstraints {\n@@ -183,49 +178,0 @@\n-    \/\/ Gets algorithm constraints of the socket.\n-    private AlgorithmConstraints getAlgorithmConstraints(Socket socket) {\n-        if (socket != null && socket.isConnected() &&\n-                socket instanceof SSLSocket sslSocket) {\n-\n-            SSLSession session = sslSocket.getHandshakeSession();\n-\n-            if (session != null) {\n-                if (ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {\n-                    String[] peerSupportedSignAlgs = null;\n-\n-                    if (session instanceof ExtendedSSLSession extSession) {\n-                        peerSupportedSignAlgs =\n-                            extSession.getPeerSupportedSignatureAlgorithms();\n-                    }\n-\n-                    return SSLAlgorithmConstraints.forSocket(\n-                        sslSocket, peerSupportedSignAlgs, true);\n-                }\n-            }\n-\n-            return SSLAlgorithmConstraints.forSocket(sslSocket, true);\n-        }\n-\n-        return SSLAlgorithmConstraints.DEFAULT;\n-    }\n-\n-    \/\/ Gets algorithm constraints of the engine.\n-    private AlgorithmConstraints getAlgorithmConstraints(SSLEngine engine) {\n-        if (engine != null) {\n-            SSLSession session = engine.getHandshakeSession();\n-            if (session != null) {\n-                if (ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {\n-                    String[] peerSupportedSignAlgs = null;\n-\n-                    if (session instanceof ExtendedSSLSession extSession) {\n-                        peerSupportedSignAlgs =\n-                            extSession.getPeerSupportedSignatureAlgorithms();\n-                    }\n-\n-                    return SSLAlgorithmConstraints.forEngine(\n-                        engine, peerSupportedSignAlgs, true);\n-                }\n-            }\n-        }\n-\n-        return SSLAlgorithmConstraints.forEngine(engine, true);\n-    }\n-\n@@ -509,182 +455,0 @@\n-    \/\/ enum for the type of certificate check we want to perform\n-    \/\/ (client or server)\n-    \/\/ also includes the check code itself\n-    private enum CheckType {\n-\n-        \/\/ enum constant for \"no check\" (currently not used)\n-        NONE(Collections.emptySet()),\n-\n-        \/\/ enum constant for \"tls client\" check\n-        \/\/ valid EKU for TLS client: any, tls_client\n-        CLIENT(new HashSet<>(List.of(\n-                KnownOIDs.anyExtendedKeyUsage.value(),\n-                KnownOIDs.clientAuth.value()\n-        ))),\n-\n-        \/\/ enum constant for \"tls server\" check\n-        \/\/ valid EKU for TLS server: any, tls_server, ns_sgc, ms_sgc\n-        SERVER(new HashSet<>(List.of(\n-                KnownOIDs.anyExtendedKeyUsage.value(),\n-                KnownOIDs.serverAuth.value(),\n-                KnownOIDs.NETSCAPE_ExportApproved.value(),\n-                KnownOIDs.MICROSOFT_ExportApproved.value()\n-        )));\n-\n-        \/\/ set of valid EKU values for this type\n-        final Set<String> validEku;\n-\n-        CheckType(Set<String> validEku) {\n-            this.validEku = validEku;\n-        }\n-\n-        private static boolean getBit(boolean[] keyUsage, int bit) {\n-            return (bit < keyUsage.length) && keyUsage[bit];\n-        }\n-\n-        \/\/ Check if this certificate is appropriate for this type of use\n-        \/\/ first check extensions, if they match, check expiration.\n-        \/\/\n-        \/\/ Note: we may want to move this code into the sun.security.validator\n-        \/\/ package\n-        CheckResult check(X509Certificate cert, Date date,\n-                List<SNIServerName> serverNames, String idAlgorithm) {\n-\n-            if (this == NONE) {\n-                return CheckResult.OK;\n-            }\n-\n-            \/\/ check extensions\n-            try {\n-                \/\/ check extended key usage\n-                List<String> certEku = cert.getExtendedKeyUsage();\n-                if ((certEku != null) &&\n-                        Collections.disjoint(validEku, certEku)) {\n-                    \/\/ if extension is present and does not contain any of\n-                    \/\/ the valid EKU OIDs, return extension_mismatch\n-                    return CheckResult.EXTENSION_MISMATCH;\n-                }\n-\n-                \/\/ check key usage\n-                boolean[] ku = cert.getKeyUsage();\n-                if (ku != null) {\n-                    String algorithm = cert.getPublicKey().getAlgorithm();\n-                    boolean supportsDigitalSignature = getBit(ku, 0);\n-                    switch (algorithm) {\n-                        case \"RSA\":\n-                            \/\/ require either signature bit\n-                            \/\/ or if server also allow key encipherment bit\n-                            if (!supportsDigitalSignature) {\n-                                if (this == CLIENT || !getBit(ku, 2)) {\n-                                    return CheckResult.EXTENSION_MISMATCH;\n-                                }\n-                            }\n-                            break;\n-                        case \"RSASSA-PSS\":\n-                            if (!supportsDigitalSignature && (this == SERVER)) {\n-                                return CheckResult.EXTENSION_MISMATCH;\n-                            }\n-                            break;\n-                        case \"DSA\":\n-                            \/\/ require signature bit\n-                            if (!supportsDigitalSignature) {\n-                                return CheckResult.EXTENSION_MISMATCH;\n-                            }\n-                            break;\n-                        case \"DH\":\n-                            \/\/ require keyagreement bit\n-                            if (!getBit(ku, 4)) {\n-                                return CheckResult.EXTENSION_MISMATCH;\n-                            }\n-                            break;\n-                        case \"EC\":\n-                            \/\/ require signature bit\n-                            if (!supportsDigitalSignature) {\n-                                return CheckResult.EXTENSION_MISMATCH;\n-                            }\n-                            \/\/ For servers, also require key agreement.\n-                            \/\/ This is not totally accurate as the keyAgreement\n-                            \/\/ bit is only necessary for static ECDH key\n-                            \/\/ exchange and not ephemeral ECDH. We leave it in\n-                            \/\/ for now until there are signs that this check\n-                            \/\/ causes problems for real world EC certificates.\n-                            if (this == SERVER && !getBit(ku, 4)) {\n-                                return CheckResult.EXTENSION_MISMATCH;\n-                            }\n-                            break;\n-                    }\n-                }\n-            } catch (CertificateException e) {\n-                \/\/ extensions unparseable, return failure\n-                return CheckResult.EXTENSION_MISMATCH;\n-            }\n-\n-            try {\n-                cert.checkValidity(date);\n-            } catch (CertificateException e) {\n-                return CheckResult.EXPIRED;\n-            }\n-\n-            if (serverNames != null && !serverNames.isEmpty()) {\n-                for (SNIServerName serverName : serverNames) {\n-                    if (serverName.getType() ==\n-                                StandardConstants.SNI_HOST_NAME) {\n-                        if (!(serverName instanceof SNIHostName)) {\n-                            try {\n-                                serverName =\n-                                    new SNIHostName(serverName.getEncoded());\n-                            } catch (IllegalArgumentException iae) {\n-                                \/\/ unlikely to happen, just in case ...\n-                                if (SSLLogger.isOn &&\n-                                        SSLLogger.isOn(\"keymanager\")) {\n-                                    SSLLogger.fine(\n-                                       \"Illegal server name: \" + serverName);\n-                                }\n-\n-                                return CheckResult.INSENSITIVE;\n-                            }\n-                        }\n-                        String hostname =\n-                                ((SNIHostName)serverName).getAsciiName();\n-\n-                        try {\n-                            X509TrustManagerImpl.checkIdentity(hostname,\n-                                                        cert, idAlgorithm);\n-                        } catch (CertificateException e) {\n-                            if (SSLLogger.isOn &&\n-                                    SSLLogger.isOn(\"keymanager\")) {\n-                                SSLLogger.fine(\n-                                    \"Certificate identity does not match \" +\n-                                    \"Server Name Indication (SNI): \" +\n-                                    hostname);\n-                            }\n-                            return CheckResult.INSENSITIVE;\n-                        }\n-\n-                        break;\n-                    }\n-                }\n-            }\n-\n-            return CheckResult.OK;\n-        }\n-\n-        public String getValidator() {\n-            if (this == CLIENT) {\n-                return Validator.VAR_TLS_CLIENT;\n-            } else if (this == SERVER) {\n-                return Validator.VAR_TLS_SERVER;\n-            }\n-            return Validator.VAR_GENERIC;\n-        }\n-    }\n-\n-    \/\/ enum for the result of the extension check\n-    \/\/ NOTE: the order of the constants is important as they are used\n-    \/\/ for sorting, i.e. OK is best, followed by EXPIRED and EXTENSION_MISMATCH\n-    private enum CheckResult {\n-        OK,                     \/\/ ok or not checked\n-        INSENSITIVE,            \/\/ server name indication insensitive\n-        EXPIRED,                \/\/ extensions valid but cert expired\n-        EXTENSION_MISMATCH,     \/\/ extensions invalid (expiration not checked)\n-    }\n-\n@@ -829,36 +593,0 @@\n-\n-    private static boolean conformsToAlgorithmConstraints(\n-            AlgorithmConstraints constraints, Certificate[] chain,\n-            String variant) {\n-\n-        AlgorithmChecker checker = new AlgorithmChecker(constraints, variant);\n-        try {\n-            checker.init(false);\n-        } catch (CertPathValidatorException cpve) {\n-            \/\/ unlikely to happen\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n-                SSLLogger.fine(\n-                    \"Cannot initialize algorithm constraints checker\", cpve);\n-            }\n-\n-            return false;\n-        }\n-\n-        \/\/ It is a forward checker, so we need to check from trust to target.\n-        for (int i = chain.length - 1; i >= 0; i--) {\n-            Certificate cert = chain[i];\n-            try {\n-                \/\/ We don't care about the unresolved critical extensions.\n-                checker.check(cert, Collections.emptySet());\n-            } catch (CertPathValidatorException cpve) {\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n-                    SSLLogger.fine(\"Certificate does not conform to \" +\n-                            \"algorithm constraints\", cert, cpve);\n-                }\n-\n-                return false;\n-            }\n-        }\n-\n-        return true;\n-    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/X509KeyManagerImpl.java","additions":3,"deletions":275,"binary":false,"changes":278,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,2 @@\n- * @library \/test\/lib\/\n+ * @library \/javax\/net\/ssl\/templates\n+ *          \/test\/lib\/\n@@ -39,2 +40,0 @@\n-import java.io.IOException;\n-import java.io.File;\n@@ -52,1 +51,5 @@\n-public class SSLSocketParametersTest implements Serializable {\n+public class SSLSocketParametersTest extends SSLContextTemplate {\n+\n+    public SSLSocketParametersTest() throws Exception {\n+        SSLContext.setDefault(createServerSSLContext());\n+    }\n@@ -58,1 +61,1 @@\n-    public class HelloImpl implements Hello {\n+    public static class HelloImpl implements Hello {\n@@ -137,16 +140,0 @@\n-        \/\/ Set keystore properties (server-side)\n-        \/\/\n-        final String keystore = System.getProperty(\"test.src\") +\n-                File.separator + \"keystore\";\n-        System.out.println(\"KeyStore = \" + keystore);\n-        System.setProperty(\"javax.net.ssl.keyStore\", keystore);\n-        System.setProperty(\"javax.net.ssl.keyStorePassword\", \"password\");\n-\n-        \/\/ Set truststore properties (client-side)\n-        \/\/\n-        final String truststore = System.getProperty(\"test.src\") +\n-                File.separator + \"truststore\";\n-        System.out.println(\"TrustStore = \" + truststore);\n-        System.setProperty(\"javax.net.ssl.trustStore\", truststore);\n-        System.setProperty(\"javax.net.ssl.trustStorePassword\", \"trustword\");\n-\n@@ -156,1 +143,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/jdk\/javax\/rmi\/ssl\/SSLSocketParametersTest.java","additions":10,"deletions":23,"binary":false,"changes":33,"status":"modified"},{"filename":"test\/jdk\/javax\/rmi\/ssl\/keystore","binary":true,"status":"deleted"},{"filename":"test\/jdk\/javax\/rmi\/ssl\/truststore","binary":true,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+ * @modules java.base\/sun.security.x509\n+ *          java.base\/sun.security.util\n@@ -35,2 +37,3 @@\n- * @run main\/othervm ServerIdentityTest dnsstore localhost\n- * @run main\/othervm ServerIdentityTest ipstore 127.0.0.1\n+ *          \/test\/lib\n+ * @run main\/othervm ServerIdentityTest dns localhost\n+ * @run main\/othervm ServerIdentityTest ip 127.0.0.1\n@@ -41,1 +44,2 @@\n-import java.io.InputStream;\n+import static jdk.test.lib.Asserts.fail;\n+\n@@ -43,0 +47,2 @@\n+import java.io.IOException;\n+import java.io.InputStream;\n@@ -44,0 +50,1 @@\n+import java.math.BigInteger;\n@@ -49,1 +56,13 @@\n-\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.KeyStore;\n+import java.security.PrivateKey;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Date;\n+import java.util.List;\n@@ -51,0 +70,1 @@\n+import javax.net.ssl.KeyManagerFactory;\n@@ -53,0 +73,8 @@\n+import javax.net.ssl.TrustManagerFactory;\n+import jdk.test.lib.security.CertificateBuilder;\n+import sun.security.x509.AuthorityKeyIdentifierExtension;\n+import sun.security.x509.GeneralName;\n+import sun.security.x509.GeneralNames;\n+import sun.security.x509.KeyIdentifier;\n+import sun.security.x509.SerialNumber;\n+import sun.security.x509.X500Name;\n@@ -56,1 +84,0 @@\n-    private static String keystore;\n@@ -58,1 +85,1 @@\n-    private static SSLContext context;\n+    private static SSLContext serverContext;\n@@ -67,1 +94,1 @@\n-        (new ServerIdentityTest()).run();\n+        new ServerIdentityTest().run();\n@@ -98,1 +125,1 @@\n-            urlc = (HttpURLConnection)url.openConnection(Proxy.NO_PROXY);\n+            urlc = (HttpURLConnection) url.openConnection(Proxy.NO_PROXY);\n@@ -112,6 +139,1 @@\n-        return context;\n-    }\n-\n-    @Override\n-    protected SSLContext createClientSSLContext() throws Exception {\n-        return context;\n+        return serverContext;\n@@ -121,1 +143,1 @@\n-        keystore = args[0];\n+        String mode = args[0];\n@@ -124,5 +146,9 @@\n-        String password = \"changeit\";\n-        String keyFilename =\n-                System.getProperty(\"test.src\", \".\") + \"\/\" + keystore;\n-        String trustFilename =\n-                System.getProperty(\"test.src\", \".\") + \"\/\" + keystore;\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\n+        KeyPair caKeys = kpg.generateKeyPair();\n+        KeyPair serverKeys = kpg.generateKeyPair();\n+        KeyPair clientKeys = kpg.generateKeyPair();\n+\n+        CertificateBuilder serverCertificateBuilder = customCertificateBuilder(\n+                \"CN=server, O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                serverKeys.getPublic(), caKeys.getPublic())\n+                .addBasicConstraintsExt(false, false, -1);\n@@ -130,4 +156,24 @@\n-        System.setProperty(\"javax.net.ssl.keyStore\", keyFilename);\n-        System.setProperty(\"javax.net.ssl.keyStorePassword\", password);\n-        System.setProperty(\"javax.net.ssl.trustStore\", trustFilename);\n-        System.setProperty(\"javax.net.ssl.trustStorePassword\", password);\n+        if (mode.equalsIgnoreCase(\"dns\")) {\n+            serverCertificateBuilder.addSubjectAltNameDNSExt(List.of(hostname));\n+        } else if (mode.equalsIgnoreCase(\"ip\")) {\n+            serverCertificateBuilder.addSubjectAltNameIPExt(List.of(hostname));\n+        } else {\n+            fail(\"Unknown mode: \" + mode);\n+        }\n+\n+        X509Certificate trustedCert = createTrustedCert(caKeys);\n+\n+        X509Certificate serverCert = serverCertificateBuilder.build(\n+                trustedCert, caKeys.getPrivate(), \"SHA256WithRSA\");\n+\n+        X509Certificate clientCert = customCertificateBuilder(\n+                \"CN=localhost, OU=SSL-Client, O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                clientKeys.getPublic(), caKeys.getPublic())\n+                .addBasicConstraintsExt(false, false, -1)\n+                .build(trustedCert, caKeys.getPrivate(), \"SHA256WithRSA\");\n+\n+        serverContext = getSSLContext(\n+                trustedCert, serverCert, serverKeys.getPrivate());\n+\n+        SSLContext clientContext = getSSLContext(\n+                trustedCert, clientCert, clientKeys.getPrivate());\n@@ -135,1 +181,0 @@\n-        context = SSLContext.getDefault();\n@@ -137,1 +182,1 @@\n-                context.getSocketFactory());\n+                clientContext.getSocketFactory());\n@@ -139,0 +184,78 @@\n+\n+    private static SSLContext getSSLContext(\n+            X509Certificate trustedCertificate, X509Certificate keyCertificate,\n+            PrivateKey privateKey)\n+            throws Exception {\n+\n+        \/\/ create a key store\n+        KeyStore ks = KeyStore.getInstance(\"PKCS12\");\n+        ks.load(null, null);\n+\n+        \/\/ import the trusted cert\n+        ks.setCertificateEntry(\"TLS Signer\", trustedCertificate);\n+\n+        \/\/ generate certificate chain\n+        Certificate[] chain = new Certificate[2];\n+        chain[0] = keyCertificate;\n+        chain[1] = trustedCertificate;\n+\n+        \/\/ import the key entry.\n+        final char[] passphrase = \"passphrase\".toCharArray();\n+        ks.setKeyEntry(\"Whatever\", privateKey, passphrase, chain);\n+\n+        \/\/ Using PKIX TrustManager\n+        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"PKIX\");\n+        tmf.init(ks);\n+\n+        \/\/ Using PKIX KeyManager\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"PKIX\");\n+\n+        \/\/ create SSL context\n+        SSLContext ctx = SSLContext.getInstance(\"TLS\");\n+        kmf.init(ks, passphrase);\n+        ctx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n+        return ctx;\n+    }\n+\n+    private static X509Certificate createTrustedCert(KeyPair caKeys)\n+            throws Exception {\n+        SecureRandom random = new SecureRandom();\n+\n+        KeyIdentifier kid = new KeyIdentifier(caKeys.getPublic());\n+        GeneralNames gns = new GeneralNames();\n+        GeneralName name = new GeneralName(new X500Name(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\"));\n+        gns.add(name);\n+        BigInteger serialNumber = BigInteger.valueOf(\n+                random.nextLong(1000000) + 1);\n+        return customCertificateBuilder(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                caKeys.getPublic(), caKeys.getPublic())\n+                .setSerialNumber(serialNumber)\n+                .addExtension(new AuthorityKeyIdentifierExtension(kid, gns,\n+                        new SerialNumber(serialNumber)))\n+                .addBasicConstraintsExt(true, true, -1)\n+                .build(null, caKeys.getPrivate(), \"SHA256WithRSA\");\n+    }\n+\n+    private static CertificateBuilder customCertificateBuilder(\n+            String subjectName, PublicKey publicKey, PublicKey caKey)\n+            throws CertificateException, IOException {\n+        SecureRandom random = new SecureRandom();\n+\n+        CertificateBuilder builder = new CertificateBuilder()\n+                .setSubjectName(subjectName)\n+                .setPublicKey(publicKey)\n+                .setNotAfter(\n+                        Date.from(Instant.now().minus(1, ChronoUnit.HOURS)))\n+                .setNotAfter(Date.from(Instant.now().plus(1, ChronoUnit.HOURS)))\n+                .setSerialNumber(\n+                        BigInteger.valueOf(random.nextLong(1000000) + 1))\n+                .addSubjectKeyIdExt(publicKey)\n+                .addAuthorityKeyIdExt(caKey);\n+        builder.addKeyUsageExt(\n+                new boolean[]{true, true, true, true, true, true});\n+\n+        return builder;\n+    }\n+\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpsClient\/ServerIdentityTest.java","additions":150,"deletions":27,"binary":false,"changes":177,"status":"modified"},{"filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpsClient\/dnsstore","binary":true,"status":"deleted"},{"filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpsClient\/ipstore","binary":true,"status":"deleted"},{"patch":"@@ -236,0 +236,4 @@\n+        \/\/ Disable KeyManager's algorithm constraints checking.\n+        System.setProperty(\n+                \"jdk.tls.keymanager.disableConstraintsChecking\", \"true\");\n+\n","filename":"test\/jdk\/sun\/security\/mscapi\/ShortRSAKeyWithinTLS.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -153,2 +153,2 @@\n-        \/\/ Using \"SunX509\" which doesn't check peer supported signature\n-        \/\/ algorithms, so we check against local supported signature\n+        \/\/ Disable KeyManager's algorithm constraints checking,\n+        \/\/ so we check against local supported signature\n@@ -156,1 +156,4 @@\n-        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n+        System.setProperty(\n+                \"jdk.tls.keymanager.disableConstraintsChecking\", \"true\");\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\n+                KeyManagerFactory.getDefaultAlgorithm());\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/MD5NotAllowedInTLS13CertificateSignature.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,186 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertNull;\n+\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.KeyStore;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.Security;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Date;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.X509KeyManager;\n+import jdk.test.lib.security.CertificateBuilder;\n+import sun.security.x509.AuthorityKeyIdentifierExtension;\n+import sun.security.x509.GeneralName;\n+import sun.security.x509.GeneralNames;\n+import sun.security.x509.KeyIdentifier;\n+import sun.security.x509.SerialNumber;\n+import sun.security.x509.X500Name;\n+\n+\/*\n+ * @test\n+ * @bug 8353113\n+ * @summary Peer supported certificate signature algorithms are not being\n+ *          checked with default SunX509 key manager\n+ * @modules java.base\/sun.security.x509\n+ *          java.base\/sun.security.util\n+ * @library \/test\/lib\n+ * @run main\/othervm AlgorithmConstraintsCheck false SunX509 SHA256withRSA\n+ * @run main\/othervm AlgorithmConstraintsCheck true SunX509 SHA256withRSA\n+ * @run main\/othervm AlgorithmConstraintsCheck false PKIX SHA256withRSA\n+ * @run main\/othervm AlgorithmConstraintsCheck true PKIX SHA256withRSA\n+ *\/\n+\n+public class AlgorithmConstraintsCheck {\n+\n+    private static final String CERT_ALIAS = \"testalias\";\n+    private static final String KEY_TYPE = \"RSA\";\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 3) {\n+            throw new RuntimeException(\"Wrong number of arguments\");\n+        }\n+\n+        String disabled = args[0];\n+        String kmAlg = args[1];\n+        String certSignatureAlg = args[2];\n+\n+        System.setProperty(\n+                \"jdk.tls.keymanager.disableConstraintsChecking\", disabled);\n+        Security.setProperty(\"jdk.tls.disabledAlgorithms\",\n+                certSignatureAlg);\n+\n+        X509KeyManager km = getKeyManager(kmAlg, certSignatureAlg);\n+        String serverAlias = km.chooseServerAlias(KEY_TYPE, null, null);\n+        String clientAlias = km.chooseClientAlias(\n+                new String[]{KEY_TYPE}, null, null);\n+\n+        \/\/ PKIX KeyManager adds a cache prefix to an alias.\n+        String serverAliasPrefix = kmAlg.equalsIgnoreCase(\"PKIX\") ? \"1.0.\" : \"\";\n+        String clientAliasPrefix = kmAlg.equalsIgnoreCase(\"PKIX\") ? \"2.0.\" : \"\";\n+\n+        if (\"false\".equals(disabled)) {\n+            assertNull(serverAlias);\n+            assertNull(clientAlias);\n+        } else {\n+            assertEquals(serverAliasPrefix + CERT_ALIAS, serverAlias);\n+            assertEquals(clientAliasPrefix + CERT_ALIAS, clientAlias);\n+        }\n+    }\n+\n+    private static X509KeyManager getKeyManager(String kmAlg,\n+            String certSignatureAlg)\n+            throws Exception {\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(KEY_TYPE);\n+        KeyPair caKeys = kpg.generateKeyPair();\n+        KeyPair endpointKeys = kpg.generateKeyPair();\n+\n+        X509Certificate trustedCert = createTrustedCert(caKeys,\n+                certSignatureAlg);\n+\n+        X509Certificate endpointCert = customCertificateBuilder(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                endpointKeys.getPublic(), caKeys.getPublic())\n+                .addBasicConstraintsExt(false, false, -1)\n+                .build(trustedCert, caKeys.getPrivate(), certSignatureAlg);\n+\n+        \/\/ create a key store\n+        KeyStore ks = KeyStore.getInstance(\"PKCS12\");\n+        ks.load(null, null);\n+\n+        \/\/ import the trusted cert\n+        ks.setCertificateEntry(\"TLS Signer\", trustedCert);\n+\n+        \/\/ generate certificate chain\n+        Certificate[] chain = new Certificate[2];\n+        chain[0] = endpointCert;\n+        chain[1] = trustedCert;\n+\n+        \/\/ import the key entry.\n+        final char[] passphrase = \"passphrase\".toCharArray();\n+        ks.setKeyEntry(CERT_ALIAS, endpointKeys.getPrivate(), passphrase,\n+                chain);\n+\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(kmAlg);\n+        kmf.init(ks, passphrase);\n+\n+        return (X509KeyManager) kmf.getKeyManagers()[0];\n+    }\n+\n+    \/\/ Certificate-building helper methods.\n+\n+    private static X509Certificate createTrustedCert(KeyPair caKeys,\n+            String certSignatureAlg)\n+            throws Exception {\n+        SecureRandom random = new SecureRandom();\n+\n+        KeyIdentifier kid = new KeyIdentifier(caKeys.getPublic());\n+        GeneralNames gns = new GeneralNames();\n+        GeneralName name = new GeneralName(new X500Name(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\"));\n+        gns.add(name);\n+        BigInteger serialNumber = BigInteger.valueOf(\n+                random.nextLong(1000000) + 1);\n+        return customCertificateBuilder(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                caKeys.getPublic(), caKeys.getPublic())\n+                .setSerialNumber(serialNumber)\n+                .addExtension(new AuthorityKeyIdentifierExtension(kid, gns,\n+                        new SerialNumber(serialNumber)))\n+                .addBasicConstraintsExt(true, true, -1)\n+                .build(null, caKeys.getPrivate(), certSignatureAlg);\n+    }\n+\n+    private static CertificateBuilder customCertificateBuilder(\n+            String subjectName, PublicKey publicKey, PublicKey caKey)\n+            throws CertificateException, IOException {\n+        SecureRandom random = new SecureRandom();\n+\n+        CertificateBuilder builder = new CertificateBuilder()\n+                .setSubjectName(subjectName)\n+                .setPublicKey(publicKey)\n+                .setNotAfter(\n+                        Date.from(Instant.now().minus(1, ChronoUnit.HOURS)))\n+                .setNotAfter(Date.from(Instant.now().plus(1, ChronoUnit.HOURS)))\n+                .setSerialNumber(\n+                        BigInteger.valueOf(random.nextLong(1000000) + 1))\n+                .addSubjectKeyIdExt(publicKey)\n+                .addAuthorityKeyIdExt(caKey);\n+        builder.addKeyUsageExt(\n+                new boolean[]{true, true, true, true, true, true});\n+\n+        return builder;\n+    }\n+\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/X509KeyManager\/AlgorithmConstraintsCheck.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1117,0 +1117,5 @@\n+        \/\/ Disable KeyManager's algorithm constraints checking as this test\n+        \/\/ is about TrustManager's constraints check.\n+        System.setProperty(\n+                \"jdk.tls.keymanager.disableConstraintsChecking\", \"true\");\n+\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/PKIXExtendedTM.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+import java.security.Security;\n@@ -51,0 +52,4 @@\n+        \/\/ Disable KeyManager's algorithm constraints checking.\n+        System.setProperty(\n+                \"jdk.tls.keymanager.disableConstraintsChecking\", \"true\");\n+\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/PrintSSL.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import sun.security.x509.IPAddressName;\n@@ -236,0 +237,20 @@\n+    \/**\n+     * Helper method to add IPAddress types for the SAN extension\n+     *\n+     * @param IPAddresses A {@code List} of names to add as IPAddress\n+     *         types\n+     * @throws IOException if an encoding error occurs.\n+     *\/\n+    public CertificateBuilder addSubjectAltNameIPExt(List<String> IPAddresses)\n+            throws IOException {\n+        if (!IPAddresses.isEmpty()) {\n+            GeneralNames gNames = new GeneralNames();\n+            for (String name : IPAddresses) {\n+                gNames.add(new GeneralName(new IPAddressName(name)));\n+            }\n+            addExtension(new SubjectAlternativeNameExtension(false,\n+                    gNames));\n+        }\n+        return this;\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/security\/CertificateBuilder.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"}]}