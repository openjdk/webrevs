{"files":[{"patch":"@@ -172,1 +172,0 @@\n-        kpg.initialize(1024);\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/MD5NotAllowedInTLS13CertificateSignature.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import jdk.test.lib.security.SecurityUtils;\n@@ -81,2 +82,1 @@\n-        Security.setProperty(\"jdk.tls.disabledAlgorithms\",\n-                certSignatureAlg);\n+        SecurityUtils.addToDisabledTlsAlgs(certSignatureAlg);\n@@ -93,4 +93,1 @@\n-        if (\"false\".equals(disabled)) {\n-            assertNull(serverAlias);\n-            assertNull(clientAlias);\n-        } else {\n+        if (\"true\".equals(disabled)) {\n@@ -99,0 +96,4 @@\n+        } else {\n+            assertNull(serverAlias);\n+            assertNull(clientAlias);\n+\n","filename":"test\/jdk\/sun\/security\/ssl\/X509KeyManager\/AlgorithmConstraintsCheck.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,272 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertTrue;\n+import static jdk.test.lib.Utils.runAndCheckException;\n+\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.net.Socket;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.KeyStore;\n+import java.security.PrivateKey;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Date;\n+import java.util.List;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.X509ExtendedTrustManager;\n+import javax.net.ssl.X509TrustManager;\n+import jdk.test.lib.security.CertificateBuilder;\n+import jdk.test.lib.security.SecurityUtils;\n+import sun.security.x509.AuthorityKeyIdentifierExtension;\n+import sun.security.x509.GeneralName;\n+import sun.security.x509.GeneralNames;\n+import sun.security.x509.KeyIdentifier;\n+import sun.security.x509.SerialNumber;\n+import sun.security.x509.X500Name;\n+\n+\/*\n+ * @test\n+ * @bug 8353113\n+ * @summary Peer supported certificate signature algorithms are not being\n+ *          checked with default SunX509 key manager\n+ * @modules java.base\/sun.security.x509\n+ *          java.base\/sun.security.util\n+ * @library \/javax\/net\/ssl\/templates\n+ *          \/test\/lib\n+ * @run main\/othervm PeerConstraintsCheck false SunX509\n+ * @run main\/othervm PeerConstraintsCheck true SunX509\n+ * @run main\/othervm PeerConstraintsCheck false PKIX\n+ * @run main\/othervm PeerConstraintsCheck true PKIX\n+ *\/\n+\n+public class PeerConstraintsCheck extends SSLSocketTemplate {\n+\n+    private static final String CLIENT_CERT_SIG_ALG = \"SHA384withRSA\";\n+    private static final String SERVER_CERT_SIG_ALG = \"SHA256withRSA\";\n+    private static final String TRUSTED_CERT_SIG_ALG = \"SHA512withRSA\";\n+\n+    private final String kmAlg;\n+    private X509Certificate trustedCert;\n+    private X509Certificate serverCert;\n+    private X509Certificate clientCert;\n+    private KeyPair serverKeys;\n+    private KeyPair clientKeys;\n+\n+    protected PeerConstraintsCheck(String kmAlg) throws Exception {\n+        super();\n+        this.kmAlg = kmAlg;\n+        setupCertificates();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Make sure only server's certificate signature algorithm is disabled.\n+        SecurityUtils.removeFromDisabledAlgs(\"jdk.certpath.disabledAlgorithms\",\n+                List.of(CLIENT_CERT_SIG_ALG, TRUSTED_CERT_SIG_ALG));\n+\n+        SecurityUtils.removeFromDisabledAlgs(\"jdk.tls.disabledAlgorithms\",\n+                List.of(CLIENT_CERT_SIG_ALG, TRUSTED_CERT_SIG_ALG));\n+\n+        SecurityUtils.addToDisabledTlsAlgs(SERVER_CERT_SIG_ALG);\n+\n+        String disabled = args[0];\n+        String kmAlg = args[1];\n+\n+        System.setProperty(\n+                \"jdk.tls.keymanager.disableConstraintsChecking\", disabled);\n+\n+        if (\"true\".equals(disabled)) {\n+            new PeerConstraintsCheck(kmAlg).run();\n+        } else {\n+            runAndCheckException(\n+                    () -> new PeerConstraintsCheck(kmAlg).run(),\n+                    ex -> {\n+                        assertTrue(ex instanceof javax.net.ssl.SSLHandshakeException);\n+                        assertEquals(ex.getMessage(), \"(handshake_failure) \"\n+                                + \"No available authentication scheme\");\n+                    }\n+            );\n+        }\n+    }\n+\n+    @Override\n+    public SSLContext createServerSSLContext() throws Exception {\n+        return getSSLContext(\n+                trustedCert, serverCert, serverKeys.getPrivate(), kmAlg);\n+    }\n+\n+    @Override\n+    public SSLContext createClientSSLContext() throws Exception {\n+        return getSSLContext(\n+                trustedCert, clientCert, clientKeys.getPrivate(), kmAlg);\n+    }\n+\n+    private static SSLContext getSSLContext(\n+            X509Certificate trustedCertificate, X509Certificate keyCertificate,\n+            PrivateKey privateKey, String kmAlg)\n+            throws Exception {\n+\n+        \/\/ create a key store\n+        KeyStore ks = KeyStore.getInstance(\"PKCS12\");\n+        ks.load(null, null);\n+\n+        \/\/ import the trusted cert\n+        ks.setCertificateEntry(\"TLS Signer\", trustedCertificate);\n+\n+        \/\/ generate certificate chain\n+        Certificate[] chain = new Certificate[2];\n+        chain[0] = keyCertificate;\n+        chain[1] = trustedCertificate;\n+\n+        \/\/ import the key entry.\n+        final char[] passphrase = \"passphrase\".toCharArray();\n+        ks.setKeyEntry(\"Whatever\", privateKey, passphrase, chain);\n+\n+        \/\/ create SSL context\n+        SSLContext ctx = SSLContext.getInstance(\"TLS\");\n+\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(kmAlg);\n+        kmf.init(ks, passphrase);\n+\n+        \/\/ Use custom trust-all TrustManager so we perform only KeyManager's\n+        \/\/ constraints check.\n+        X509ExtendedTrustManager[] trustAll = new X509ExtendedTrustManager[]{\n+                new X509ExtendedTrustManager() {\n+                    @Override\n+                    public void checkClientTrusted(X509Certificate[] chain,\n+                            String authType, Socket socket)\n+                            throws CertificateException {\n+                    }\n+\n+                    @Override\n+                    public void checkServerTrusted(X509Certificate[] chain,\n+                            String authType, Socket socket)\n+                            throws CertificateException {\n+                    }\n+\n+                    @Override\n+                    public void checkClientTrusted(X509Certificate[] chain,\n+                            String authType, SSLEngine engine)\n+                            throws CertificateException {\n+                    }\n+\n+                    @Override\n+                    public void checkServerTrusted(X509Certificate[] chain,\n+                            String authType, SSLEngine engine)\n+                            throws CertificateException {\n+                    }\n+\n+                    public void checkClientTrusted(X509Certificate[] chain,\n+                            String authType) throws CertificateException {\n+                    }\n+\n+                    public void checkServerTrusted(X509Certificate[] chain,\n+                            String authType) throws CertificateException {\n+                    }\n+\n+                    public X509Certificate[] getAcceptedIssuers() {\n+                        return new X509Certificate[0];\n+                    }\n+                }\n+        };\n+\n+        ctx.init(kmf.getKeyManagers(), trustAll, null);\n+\n+        return ctx;\n+    }\n+\n+    \/\/ Certificate-building helper methods.\n+\n+    private void setupCertificates() throws Exception {\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\n+        KeyPair caKeys = kpg.generateKeyPair();\n+        this.serverKeys = kpg.generateKeyPair();\n+        this.clientKeys = kpg.generateKeyPair();\n+\n+        this.trustedCert = createTrustedCert(caKeys);\n+\n+        this.serverCert = customCertificateBuilder(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                serverKeys.getPublic(), caKeys.getPublic())\n+                .addBasicConstraintsExt(false, false, -1)\n+                .build(trustedCert, caKeys.getPrivate(), SERVER_CERT_SIG_ALG);\n+\n+        this.clientCert = customCertificateBuilder(\n+                \"CN=localhost, OU=SSL-Client, O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                clientKeys.getPublic(), caKeys.getPublic())\n+                .addBasicConstraintsExt(false, false, -1)\n+                .build(trustedCert, caKeys.getPrivate(), CLIENT_CERT_SIG_ALG);\n+    }\n+\n+    private static X509Certificate createTrustedCert(KeyPair caKeys)\n+            throws Exception {\n+        SecureRandom random = new SecureRandom();\n+\n+        KeyIdentifier kid = new KeyIdentifier(caKeys.getPublic());\n+        GeneralNames gns = new GeneralNames();\n+        GeneralName name = new GeneralName(new X500Name(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\"));\n+        gns.add(name);\n+        BigInteger serialNumber = BigInteger.valueOf(\n+                random.nextLong(1000000) + 1);\n+        return customCertificateBuilder(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                caKeys.getPublic(), caKeys.getPublic())\n+                .setSerialNumber(serialNumber)\n+                .addExtension(new AuthorityKeyIdentifierExtension(kid, gns,\n+                        new SerialNumber(serialNumber)))\n+                .addBasicConstraintsExt(true, true, -1)\n+                .build(null, caKeys.getPrivate(), TRUSTED_CERT_SIG_ALG);\n+    }\n+\n+    private static CertificateBuilder customCertificateBuilder(\n+            String subjectName, PublicKey publicKey, PublicKey caKey)\n+            throws CertificateException, IOException {\n+        SecureRandom random = new SecureRandom();\n+\n+        CertificateBuilder builder = new CertificateBuilder()\n+                .setSubjectName(subjectName)\n+                .setPublicKey(publicKey)\n+                .setNotAfter(\n+                        Date.from(Instant.now().minus(1, ChronoUnit.HOURS)))\n+                .setNotAfter(Date.from(Instant.now().plus(1, ChronoUnit.HOURS)))\n+                .setSerialNumber(\n+                        BigInteger.valueOf(random.nextLong(1000000) + 1))\n+                .addSubjectKeyIdExt(publicKey)\n+                .addAuthorityKeyIdExt(caKey);\n+        builder.addKeyUsageExt(\n+                new boolean[]{true, true, true, true, true, true});\n+\n+        return builder;\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/X509KeyManager\/PeerConstraintsCheck.java","additions":272,"deletions":0,"binary":false,"changes":272,"status":"added"}]}