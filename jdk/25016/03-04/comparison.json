{"files":[{"patch":"@@ -43,1 +43,0 @@\n-import java.util.HashSet;\n@@ -45,1 +44,0 @@\n-import java.util.Locale;\n@@ -48,0 +46,1 @@\n+import javax.net.ssl.SNIServerName;\n@@ -64,16 +63,0 @@\n- * The JSSE handshake code currently calls into this class via\n- * chooseClientAlias() and chooseServerAlias() to find the certificates to\n- * use. As implemented here, both always return the first alias returned by\n- * getClientAliases() and getServerAliases(). In turn, these methods are\n- * implemented by calling getAliases(), which performs the actual lookup.\n- *\n- * Note that this class currently implements no checking of the local\n- * certificates. In particular, it is *not* guaranteed that:\n- *  . the certificates are within their validity period and not revoked\n- *  . the signatures verify\n- *  . they form a PKIX compliant chain.\n- *  . the certificate extensions allow the certificate to be used for\n- *    the desired purpose.\n- *\n- * Chains that fail any of these criteria will probably be rejected by\n- * the remote peer.\n@@ -82,3 +65,1 @@\n-final class SunX509KeyManagerImpl extends X509KeyManagerConstraints {\n-\n-    private static final String[] STRING0 = new String[0];\n+final class SunX509KeyManagerImpl extends X509KeyManagerCertChecking {\n@@ -92,9 +73,0 @@\n-    \/*\n-     * Cached server aliases for the case issuers == null.\n-     * (in the current JSSE implementation, issuers are always null for\n-     * server certs). See chooseServerAlias() for details.\n-     *\n-     * Map: String(keyType) -> String[](alias)\n-     *\/\n-    private final Map<String, String[]> serverAliasCache;\n-\n@@ -108,1 +80,0 @@\n-        private final Set<X500Principal> issuerX500Principals;\n@@ -114,8 +85,0 @@\n-            this.issuerX500Principals = HashSet.newHashSet(certificates.length);\n-            for (X509Certificate certificate : certificates) {\n-                issuerX500Principals.add(certificate.getIssuerX500Principal());\n-            }\n-        }\n-\n-        Set<X500Principal> getIssuerX500Principals() {\n-            return issuerX500Principals;\n@@ -128,0 +91,1 @@\n+\n@@ -129,2 +93,1 @@\n-        serverAliasCache = Collections.synchronizedMap(\n-                new HashMap<>());\n+\n@@ -208,2 +171,2 @@\n-        return chooseClientAlias(keyTypes, issuers,\n-                getAlgorithmConstraints(socket));\n+        return chooseAlias(getKeyTypes(keyTypes), issuers, CheckType.CLIENT,\n+                getAlgorithmConstraints(socket), null, null);\n@@ -217,2 +180,0 @@\n-     *\n-     * @since 1.5\n@@ -221,1 +182,1 @@\n-    public String chooseEngineClientAlias(String[] keyType,\n+    public String chooseEngineClientAlias(String[] keyTypes,\n@@ -223,21 +184,2 @@\n-        return chooseClientAlias(\n-                keyType, issuers, getAlgorithmConstraints(engine));\n-    }\n-\n-    private String chooseClientAlias(String[] keyTypes, Principal[] issuers,\n-            AlgorithmConstraints constraints) {\n-\n-        if (keyTypes == null) {\n-            return null;\n-        }\n-\n-        for (String keyType : keyTypes) {\n-            String[] aliases = getAliases(\n-                    keyType, issuers, CheckType.CLIENT, constraints);\n-\n-            if ((aliases != null) && (aliases.length > 0)) {\n-                return aliases[0];\n-            }\n-        }\n-\n-        return null;\n+        return chooseAlias(getKeyTypes(keyTypes), issuers, CheckType.CLIENT,\n+                getAlgorithmConstraints(engine), null, null);\n@@ -254,2 +196,3 @@\n-        return chooseServerAlias(\n-                keyType, issuers, getAlgorithmConstraints(socket));\n+        return chooseAlias(getKeyTypes(keyType), issuers, CheckType.SERVER,\n+                getAlgorithmConstraints(socket),\n+                X509TrustManagerImpl.getRequestedServerNames(socket), \"HTTPS\");\n@@ -263,2 +206,0 @@\n-     *\n-     * @since 1.5\n@@ -269,33 +210,3 @@\n-        return chooseServerAlias(\n-                keyType, issuers, getAlgorithmConstraints(engine));\n-    }\n-\n-    private String chooseServerAlias(String keyType,\n-            Principal[] issuers, AlgorithmConstraints constraints) {\n-\n-        if (keyType == null) {\n-            return null;\n-        }\n-\n-        String[] aliases;\n-\n-        if (issuers == null || issuers.length == 0) {\n-            aliases = serverAliasCache.get(keyType);\n-            if (aliases == null) {\n-                aliases = getAliases(keyType, issuers,\n-                        CheckType.SERVER, constraints);\n-                \/\/ Cache the result (positive and negative lookups)\n-                if (aliases == null) {\n-                    aliases = STRING0;\n-                }\n-                serverAliasCache.put(keyType, aliases);\n-            }\n-        } else {\n-            aliases = getServerAliases(keyType, issuers);\n-        }\n-\n-        if ((aliases != null) && (aliases.length > 0)) {\n-            return aliases[0];\n-        }\n-\n-        return null;\n+        return chooseAlias(getKeyTypes(keyType), issuers, CheckType.SERVER,\n+                getAlgorithmConstraints(engine),\n+                X509TrustManagerImpl.getRequestedServerNames(engine), \"HTTPS\");\n@@ -311,1 +222,2 @@\n-        return getAliases(keyType, issuers, CheckType.CLIENT, null);\n+        return getAliases(getKeyTypes(keyType), issuers, CheckType.CLIENT,\n+                null, null, null);\n@@ -321,1 +233,21 @@\n-        return getAliases(keyType, issuers, CheckType.SERVER, null);\n+        return getAliases(getKeyTypes(keyType), issuers, CheckType.SERVER,\n+                null, null, null);\n+    }\n+\n+    private String chooseAlias(List<KeyType> keyTypes, Principal[] issuers,\n+            CheckType checkType, AlgorithmConstraints constraints,\n+            List<SNIServerName> requestedServerNames, String idAlgorithm) {\n+\n+        if (keyTypes == null) {\n+            return null;\n+        }\n+\n+        String[] aliases = getAliases(\n+                keyTypes, issuers, checkType,\n+                constraints, requestedServerNames, idAlgorithm);\n+\n+        if (aliases != null && aliases.length > 0) {\n+            return aliases[0];\n+        }\n+\n+        return null;\n@@ -331,3 +263,6 @@\n-    private String[] getAliases(String keyType, Principal[] issuers,\n-            CheckType checkType, AlgorithmConstraints constraints) {\n-        if (keyType == null) {\n+    private String[] getAliases(List<KeyType> keyTypes, Principal[] issuers,\n+            CheckType checkType, AlgorithmConstraints constraints,\n+            List<SNIServerName> requestedServerNames,\n+            String idAlgorithm) {\n+\n+        if (keyTypes == null || keyTypes.isEmpty()) {\n@@ -336,0 +271,1 @@\n+\n@@ -339,0 +275,1 @@\n+\n@@ -343,8 +280,0 @@\n-        String sigType;\n-        if (keyType.contains(\"_\")) {\n-            int k = keyType.indexOf('_');\n-            sigType = keyType.substring(k + 1);\n-            keyType = keyType.substring(0, k);\n-        } else {\n-            sigType = null;\n-        }\n@@ -352,3 +281,2 @@\n-        X500Principal[] x500Issuers = (X500Principal[]) issuers;\n-        \/\/ the algorithm below does not produce duplicates, so avoid Set\n-        List<String> aliases = new ArrayList<>();\n+        Set<Principal> issuerSet = getIssuerSet(issuers);\n+        List<EntryStatus> results = null;\n@@ -359,3 +287,4 @@\n-            String alias = entry.getKey();\n-            X509Credentials credentials = entry.getValue();\n-            X509Certificate[] certs = credentials.certificates;\n+            EntryStatus status = checkAlias(0, entry.getKey(),\n+                    entry.getValue().certificates,\n+                    null, keyTypes, issuerSet, checkType,\n+                    constraints, requestedServerNames, idAlgorithm);\n@@ -363,1 +292,1 @@\n-            if (!keyType.equals(certs[0].getPublicKey().getAlgorithm())) {\n+            if (status == null) {\n@@ -367,19 +296,2 @@\n-            if (sigType != null) {\n-                if (certs.length > 1) {\n-                    \/\/ if possible, check the public key in the issuer cert\n-                    if (!sigType.equals(\n-                            certs[1].getPublicKey().getAlgorithm())) {\n-                        continue;\n-                    }\n-                } else {\n-                    \/\/ Check the signature algorithm of the certificate itself.\n-                    \/\/ Look for the \"withRSA\" in \"SHA1withRSA\", etc.\n-                    String sigAlgName =\n-                            certs[0].getSigAlgName()\n-                                    .toUpperCase(Locale.ENGLISH);\n-                    String pattern = \"WITH\" +\n-                            sigType.toUpperCase(Locale.ENGLISH);\n-                    if (!sigAlgName.contains(pattern)) {\n-                        continue;\n-                    }\n-                }\n+            if (results == null) {\n+                results = new ArrayList<>();\n@@ -388,13 +300,2 @@\n-            \/\/ check the algorithm constraints\n-            if (constraints != null &&\n-                    !conformsToAlgorithmConstraints(constraints, certs,\n-                            checkType.getValidator())) {\n-\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n-                    SSLLogger.fine(\"Ignore alias \" + alias +\n-                            \": certificate list does not conform to \" +\n-                            \"algorithm constraints\");\n-                }\n-\n-                continue;\n-            }\n+            results.add(status);\n+        }\n@@ -402,18 +303,3 @@\n-            if (issuers.length == 0) {\n-                \/\/ no issuer specified, match all\n-                aliases.add(alias);\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n-                    SSLLogger.fine(\"matching alias: \" + alias);\n-                }\n-            } else {\n-                Set<X500Principal> certIssuers =\n-                        credentials.getIssuerX500Principals();\n-                for (int i = 0; i < x500Issuers.length; i++) {\n-                    if (certIssuers.contains(issuers[i])) {\n-                        aliases.add(alias);\n-                        if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n-                            SSLLogger.fine(\"matching alias: \" + alias);\n-                        }\n-                        break;\n-                    }\n-                }\n+        if (results == null) {\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n+                SSLLogger.fine(\"KeyMgr: no matching key found\");\n@@ -421,0 +307,1 @@\n+            return null;\n@@ -423,2 +310,3 @@\n-        String[] aliasStrings = aliases.toArray(STRING0);\n-        return ((aliasStrings.length == 0) ? null : aliasStrings);\n+        \/\/ Sort results in order of alias preference.\n+        Collections.sort(results);\n+        return results.stream().map(r -> r.alias).toArray(String[]::new);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SunX509KeyManagerImpl.java","additions":64,"deletions":176,"binary":false,"changes":240,"status":"modified"},{"patch":"@@ -0,0 +1,551 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.ssl;\n+\n+import java.net.Socket;\n+import java.security.AlgorithmConstraints;\n+import java.security.Principal;\n+import java.security.cert.CertPathValidatorException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+import javax.net.ssl.ExtendedSSLSession;\n+import javax.net.ssl.SNIHostName;\n+import javax.net.ssl.SNIServerName;\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.SSLSession;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.StandardConstants;\n+import javax.net.ssl.X509ExtendedKeyManager;\n+import sun.security.provider.certpath.AlgorithmChecker;\n+import sun.security.util.KnownOIDs;\n+import sun.security.validator.Validator;\n+\n+\/*\n+ * Layer that adds algorithm constraints and certificate\n+ * checking to a key manager. Checks can be disabled by setting\n+ * \"jdk.tls.keymanager.disableCertChecking\" system property to \"true\"\n+ * before creating a KeyManager object.\n+ *\/\n+\n+abstract class X509KeyManagerCertChecking extends X509ExtendedKeyManager {\n+\n+    \/\/ Indicates whether we should skip the certificate checks.\n+    private final boolean checksDisabled;\n+\n+    protected X509KeyManagerCertChecking() {\n+        checksDisabled = \"true\".equals(System.getProperty(\n+                \"jdk.tls.keymanager.disableCertChecking\"));\n+    }\n+\n+    \/\/ Gets algorithm constraints of the socket.\n+    protected AlgorithmConstraints getAlgorithmConstraints(Socket socket) {\n+\n+        if (checksDisabled) {\n+            return null;\n+        }\n+\n+        if (socket != null && socket.isConnected() &&\n+                socket instanceof SSLSocket sslSocket) {\n+\n+            SSLSession session = sslSocket.getHandshakeSession();\n+\n+            if (session != null) {\n+                if (ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {\n+                    String[] peerSupportedSignAlgs = null;\n+\n+                    if (session instanceof ExtendedSSLSession extSession) {\n+                        peerSupportedSignAlgs =\n+                                extSession.getPeerSupportedSignatureAlgorithms();\n+                    }\n+\n+                    return SSLAlgorithmConstraints.forSocket(\n+                            sslSocket, peerSupportedSignAlgs, true);\n+                }\n+            }\n+\n+            return SSLAlgorithmConstraints.forSocket(sslSocket, true);\n+        }\n+\n+        return SSLAlgorithmConstraints.DEFAULT;\n+    }\n+\n+    \/\/ Gets algorithm constraints of the engine.\n+    protected AlgorithmConstraints getAlgorithmConstraints(SSLEngine engine) {\n+\n+        if (checksDisabled) {\n+            return null;\n+        }\n+\n+        if (engine != null) {\n+            SSLSession session = engine.getHandshakeSession();\n+            if (session != null) {\n+                if (ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {\n+                    String[] peerSupportedSignAlgs = null;\n+\n+                    if (session instanceof ExtendedSSLSession extSession) {\n+                        peerSupportedSignAlgs =\n+                                extSession.getPeerSupportedSignatureAlgorithms();\n+                    }\n+\n+                    return SSLAlgorithmConstraints.forEngine(\n+                            engine, peerSupportedSignAlgs, true);\n+                }\n+            }\n+        }\n+\n+        return SSLAlgorithmConstraints.forEngine(engine, true);\n+    }\n+\n+    \/\/ Algorithm constraints check.\n+    protected boolean conformsToAlgorithmConstraints(\n+            AlgorithmConstraints constraints, Certificate[] chain,\n+            String variant) {\n+\n+        if (checksDisabled) {\n+            return true;\n+        }\n+\n+        AlgorithmChecker checker = new AlgorithmChecker(constraints, variant);\n+        try {\n+            checker.init(false);\n+        } catch (CertPathValidatorException cpve) {\n+            \/\/ unlikely to happen\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n+                SSLLogger.fine(\n+                        \"Cannot initialize algorithm constraints checker\",\n+                        cpve);\n+            }\n+\n+            return false;\n+        }\n+\n+        \/\/ It is a forward checker, so we need to check from trust to target.\n+        for (int i = chain.length - 1; i >= 0; i--) {\n+            Certificate cert = chain[i];\n+            try {\n+                \/\/ We don't care about the unresolved critical extensions.\n+                checker.check(cert, Collections.emptySet());\n+            } catch (CertPathValidatorException cpve) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n+                    SSLLogger.fine(\"Certificate does not conform to \" +\n+                            \"algorithm constraints\", cert, cpve);\n+                }\n+\n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    protected CheckResult certificateCheck(\n+            CheckType checkType, X509Certificate cert, Date date,\n+            List<SNIServerName> serverNames, String idAlgorithm) {\n+        return checksDisabled ? CheckResult.OK\n+                : checkType.check(cert, date, serverNames, idAlgorithm);\n+    }\n+\n+    \/\/ enum for the result of the extension check\n+    \/\/ NOTE: the order of the constants is important as they are used\n+    \/\/ for sorting, i.e. OK is best, followed by EXPIRED and EXTENSION_MISMATCH\n+    enum CheckResult {\n+        OK,                     \/\/ ok or not checked\n+        INSENSITIVE,            \/\/ server name indication insensitive\n+        EXPIRED,                \/\/ extensions valid but cert expired\n+        EXTENSION_MISMATCH,     \/\/ extensions invalid (expiration not checked)\n+    }\n+\n+    \/\/ enum for the type of certificate check we want to perform\n+    \/\/ (client or server)\n+    \/\/ also includes the check code itself\n+    enum CheckType {\n+\n+        \/\/ enum constant for \"no check\" (currently not used)\n+        NONE(Collections.emptySet()),\n+\n+        \/\/ enum constant for \"tls client\" check\n+        \/\/ valid EKU for TLS client: any, tls_client\n+        CLIENT(new HashSet<>(List.of(\n+                KnownOIDs.anyExtendedKeyUsage.value(),\n+                KnownOIDs.clientAuth.value()\n+        ))),\n+\n+        \/\/ enum constant for \"tls server\" check\n+        \/\/ valid EKU for TLS server: any, tls_server, ns_sgc, ms_sgc\n+        SERVER(new HashSet<>(List.of(\n+                KnownOIDs.anyExtendedKeyUsage.value(),\n+                KnownOIDs.serverAuth.value(),\n+                KnownOIDs.NETSCAPE_ExportApproved.value(),\n+                KnownOIDs.MICROSOFT_ExportApproved.value()\n+        )));\n+\n+        \/\/ set of valid EKU values for this type\n+        final Set<String> validEku;\n+\n+        CheckType(Set<String> validEku) {\n+            this.validEku = validEku;\n+        }\n+\n+        private static boolean getBit(boolean[] keyUsage, int bit) {\n+            return (bit < keyUsage.length) && keyUsage[bit];\n+        }\n+\n+        \/\/ Check if this certificate is appropriate for this type of use\n+        \/\/ first check extensions, if they match, check expiration.\n+        \/\/ NOTE: `conformsToAlgorithmConstraints` call above also does some\n+        \/\/ basic keyUsage checks.\n+        CheckResult check(X509Certificate cert, Date date,\n+                List<SNIServerName> serverNames, String idAlgorithm) {\n+\n+            if (this == NONE) {\n+                return CheckResult.OK;\n+            }\n+\n+            \/\/ check extensions\n+            try {\n+                \/\/ check extended key usage\n+                List<String> certEku = cert.getExtendedKeyUsage();\n+                if ((certEku != null) &&\n+                        Collections.disjoint(validEku, certEku)) {\n+                    \/\/ if extension is present and does not contain any of\n+                    \/\/ the valid EKU OIDs, return extension_mismatch\n+                    return CheckResult.EXTENSION_MISMATCH;\n+                }\n+\n+                \/\/ check key usage\n+                boolean[] ku = cert.getKeyUsage();\n+                if (ku != null) {\n+                    String algorithm = cert.getPublicKey().getAlgorithm();\n+                    boolean supportsDigitalSignature = getBit(ku, 0);\n+                    switch (algorithm) {\n+                        case \"RSA\":\n+                            \/\/ require either signature bit\n+                            \/\/ or if server also allow key encipherment bit\n+                            if (!supportsDigitalSignature) {\n+                                if (this == CLIENT || !getBit(ku, 2)) {\n+                                    return CheckResult.EXTENSION_MISMATCH;\n+                                }\n+                            }\n+                            break;\n+                        case \"RSASSA-PSS\":\n+                            if (!supportsDigitalSignature && (this == SERVER)) {\n+                                return CheckResult.EXTENSION_MISMATCH;\n+                            }\n+                            break;\n+                        case \"DSA\":\n+                            \/\/ require signature bit\n+                            if (!supportsDigitalSignature) {\n+                                return CheckResult.EXTENSION_MISMATCH;\n+                            }\n+                            break;\n+                        case \"DH\":\n+                            \/\/ require key agreement bit\n+                            if (!getBit(ku, 4)) {\n+                                return CheckResult.EXTENSION_MISMATCH;\n+                            }\n+                            break;\n+                        case \"EC\":\n+                            \/\/ require signature bit\n+                            if (!supportsDigitalSignature) {\n+                                return CheckResult.EXTENSION_MISMATCH;\n+                            }\n+                            \/\/ For servers, also require key agreement.\n+                            \/\/ This is not totally accurate as the keyAgreement\n+                            \/\/ bit is only necessary for static ECDH key\n+                            \/\/ exchange and not ephemeral ECDH. We leave it in\n+                            \/\/ for now until there are signs that this check\n+                            \/\/ causes problems for real world EC certificates.\n+                            if (this == SERVER && !getBit(ku, 4)) {\n+                                return CheckResult.EXTENSION_MISMATCH;\n+                            }\n+                            break;\n+                    }\n+                }\n+            } catch (CertificateException e) {\n+                \/\/ extensions unparseable, return failure\n+                return CheckResult.EXTENSION_MISMATCH;\n+            }\n+\n+            try {\n+                cert.checkValidity(date);\n+            } catch (CertificateException e) {\n+                return CheckResult.EXPIRED;\n+            }\n+\n+            if (serverNames != null && !serverNames.isEmpty()) {\n+                for (SNIServerName serverName : serverNames) {\n+                    if (serverName.getType() ==\n+                            StandardConstants.SNI_HOST_NAME) {\n+                        if (!(serverName instanceof SNIHostName)) {\n+                            try {\n+                                serverName = new SNIHostName(\n+                                        serverName.getEncoded());\n+                            } catch (IllegalArgumentException iae) {\n+                                \/\/ unlikely to happen, just in case ...\n+                                if (SSLLogger.isOn &&\n+                                        SSLLogger.isOn(\"keymanager\")) {\n+                                    SSLLogger.fine(\"Illegal server name: \"\n+                                            + serverName);\n+                                }\n+\n+                                return CheckResult.INSENSITIVE;\n+                            }\n+                        }\n+                        String hostname =\n+                                ((SNIHostName) serverName).getAsciiName();\n+\n+                        try {\n+                            X509TrustManagerImpl.checkIdentity(hostname,\n+                                    cert, idAlgorithm);\n+                        } catch (CertificateException e) {\n+                            if (SSLLogger.isOn &&\n+                                    SSLLogger.isOn(\"keymanager\")) {\n+                                SSLLogger.fine(\n+                                        \"Certificate identity does not match \"\n+                                                + \"Server Name Indication (SNI): \"\n+                                                + hostname);\n+                            }\n+                            return CheckResult.INSENSITIVE;\n+                        }\n+\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            return CheckResult.OK;\n+        }\n+\n+        String getValidator() {\n+            if (this == CLIENT) {\n+                return Validator.VAR_TLS_CLIENT;\n+            } else if (this == SERVER) {\n+                return Validator.VAR_TLS_SERVER;\n+            }\n+            return Validator.VAR_GENERIC;\n+        }\n+    }\n+\n+    \/\/ A candidate match\n+    \/\/ identifies the entry by builder and alias\n+    \/\/ and includes the result of the certificate check\n+    protected static class EntryStatus implements Comparable<EntryStatus> {\n+\n+        final int keyStoreIndex;\n+        final int keyIndex;\n+        final String alias;\n+        final CheckResult checkResult;\n+\n+        EntryStatus(int keyStoreIndex, int keyIndex, String alias,\n+                Certificate[] chain, CheckResult checkResult) {\n+            this.keyStoreIndex = keyStoreIndex;\n+            this.keyIndex = keyIndex;\n+            this.alias = alias;\n+            this.checkResult = checkResult;\n+        }\n+\n+        @Override\n+        public int compareTo(EntryStatus other) {\n+            int result = this.checkResult.compareTo(other.checkResult);\n+            return (result == 0) ? (this.keyIndex - other.keyIndex) : result;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String s = alias + \" (verified: \" + checkResult + \")\";\n+            if (keyStoreIndex == 0) {\n+                return s;\n+            } else {\n+                return \"KeyStore #\" + keyStoreIndex + \", alias: \" + s;\n+            }\n+        }\n+    }\n+\n+    \/\/ Class to help verify that the public key algorithm (and optionally\n+    \/\/ the signature algorithm) of a certificate matches what we need.\n+    protected static class KeyType {\n+\n+        final String keyAlgorithm;\n+\n+        \/\/ In TLS 1.2, the signature algorithm  has been obsoleted by the\n+        \/\/ supported_signature_algorithms, and the certificate type no longer\n+        \/\/ restricts the algorithm used to sign the certificate.\n+        \/\/\n+        \/\/ However, because we don't support certificate type checking other\n+        \/\/ than rsa_sign, dss_sign and ecdsa_sign, we don't have to check the\n+        \/\/ protocol version here.\n+        final String sigKeyAlgorithm;\n+\n+        KeyType(String algorithm) {\n+            int k = algorithm.indexOf('_');\n+            if (k == -1) {\n+                keyAlgorithm = algorithm;\n+                sigKeyAlgorithm = null;\n+            } else {\n+                keyAlgorithm = algorithm.substring(0, k);\n+                sigKeyAlgorithm = algorithm.substring(k + 1);\n+            }\n+        }\n+\n+        boolean matches(Certificate[] chain) {\n+            if (!chain[0].getPublicKey().getAlgorithm().equals(keyAlgorithm)) {\n+                return false;\n+            }\n+            if (sigKeyAlgorithm == null) {\n+                return true;\n+            }\n+            if (chain.length > 1) {\n+                \/\/ if possible, check the public key in the issuer cert\n+                return sigKeyAlgorithm.equals(\n+                        chain[1].getPublicKey().getAlgorithm());\n+            } else {\n+                \/\/ Check the signature algorithm of the certificate itself.\n+                \/\/ Look for the \"withRSA\" in \"SHA1withRSA\", etc.\n+                X509Certificate issuer = (X509Certificate) chain[0];\n+                String sigAlgName =\n+                        issuer.getSigAlgName().toUpperCase(Locale.ENGLISH);\n+                String pattern =\n+                        \"WITH\" + sigKeyAlgorithm.toUpperCase(Locale.ENGLISH);\n+                return sigAlgName.contains(pattern);\n+            }\n+        }\n+    }\n+\n+    protected static List<KeyType> getKeyTypes(String... keyTypes) {\n+        if ((keyTypes == null) ||\n+                (keyTypes.length == 0) || (keyTypes[0] == null)) {\n+            return null;\n+        }\n+        List<KeyType> list = new ArrayList<>(keyTypes.length);\n+        for (String keyType : keyTypes) {\n+            list.add(new KeyType(keyType));\n+        }\n+        return list;\n+    }\n+\n+    \/\/ Make a Set out of the array\n+    protected Set<Principal> getIssuerSet(Principal[] issuers) {\n+        if ((issuers != null) && (issuers.length != 0)) {\n+            return new HashSet<>(Arrays.asList(issuers));\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    protected EntryStatus checkAlias(int keyStoreIndex, String alias,\n+            Certificate[] chain, Date verificationDate, List<KeyType> keyTypes,\n+            Set<Principal> issuerSet, CheckType checkType,\n+            AlgorithmConstraints constraints,\n+            List<SNIServerName> requestedServerNames, String idAlgorithm) {\n+\n+        \/\/ --- Mandatory checks ---\n+\n+        if ((chain == null) || (chain.length == 0)) {\n+            \/\/ Must be secret key entry, ignore\n+            return null;\n+        }\n+\n+        for (Certificate cert : chain) {\n+            if (!(cert instanceof X509Certificate)) {\n+                \/\/ Not an X509Certificate, ignore this alias\n+                return null;\n+            }\n+        }\n+\n+        \/\/ Check keytype\n+        int keyIndex = -1;\n+        int j = 0;\n+\n+        for (KeyType keyType : keyTypes) {\n+            if (keyType.matches(chain)) {\n+                keyIndex = j;\n+                break;\n+            }\n+            j++;\n+        }\n+\n+        if (keyIndex == -1) {\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n+                SSLLogger.fine(\"Ignore alias \" + alias\n+                        + \": key algorithm does not match\");\n+            }\n+            return null;\n+        }\n+\n+        \/\/ Check issuers\n+        if (issuerSet != null) {\n+            boolean found = false;\n+            for (Certificate cert : chain) {\n+                X509Certificate xcert = (X509Certificate) cert;\n+                if (issuerSet.contains(xcert.getIssuerX500Principal())) {\n+                    found = true;\n+                    break;\n+                }\n+            }\n+            if (!found) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n+                    SSLLogger.fine(\n+                            \"Ignore alias \" + alias\n+                                    + \": issuers do not match\");\n+                }\n+                return null;\n+            }\n+        }\n+\n+        \/\/ --- Optional checks, depending on \"checksDisabled\" toggle ---\n+\n+        \/\/ Check the algorithm constraints\n+        if (constraints != null &&\n+                !conformsToAlgorithmConstraints(constraints, chain,\n+                        checkType.getValidator())) {\n+\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n+                SSLLogger.fine(\"Ignore alias \" + alias +\n+                        \": certificate chain does not conform to \" +\n+                        \"algorithm constraints\");\n+            }\n+            return null;\n+        }\n+\n+        \/\/ Endpoint certificate check\n+        CheckResult checkResult = certificateCheck(checkType,\n+                (X509Certificate) chain[0],\n+                verificationDate == null ? new Date() : verificationDate,\n+                requestedServerNames, idAlgorithm);\n+\n+        return new EntryStatus(\n+                keyStoreIndex, keyIndex, alias, chain, checkResult);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/X509KeyManagerCertChecking.java","additions":551,"deletions":0,"binary":false,"changes":551,"status":"added"},{"patch":"@@ -1,356 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.security.ssl;\n-\n-import java.net.Socket;\n-import java.security.AlgorithmConstraints;\n-import java.security.cert.CertPathValidatorException;\n-import java.security.cert.Certificate;\n-import java.security.cert.CertificateException;\n-import java.security.cert.X509Certificate;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Set;\n-import javax.net.ssl.ExtendedSSLSession;\n-import javax.net.ssl.SNIHostName;\n-import javax.net.ssl.SNIServerName;\n-import javax.net.ssl.SSLEngine;\n-import javax.net.ssl.SSLSession;\n-import javax.net.ssl.SSLSocket;\n-import javax.net.ssl.StandardConstants;\n-import javax.net.ssl.X509ExtendedKeyManager;\n-import sun.security.provider.certpath.AlgorithmChecker;\n-import sun.security.util.KnownOIDs;\n-import sun.security.validator.Validator;\n-\n-\/**\n- * Layer that adds algorithm constraints functionality and certificate\n- * key usage check to a key manager. Algorithm constraints check can be\n- * disabled by setting \"jdk.tls.keymanager.disableConstraintsChecking\"\n- * system property to \"true\".\n- *\/\n-\n-abstract class X509KeyManagerConstraints extends X509ExtendedKeyManager {\n-\n-    private static final String PROPERTY_KEYMANAGER_DISABLE_CONSTRAINTS =\n-            \"jdk.tls.keymanager.disableConstraintsChecking\";\n-\n-    \/\/ Indicates whether we should skip the constraints check.\n-    private final boolean constraintsDisabled;\n-\n-    protected X509KeyManagerConstraints() {\n-        constraintsDisabled = isConstraintsDisabled();\n-    }\n-\n-    \/\/ Gets algorithm constraints of the socket.\n-    protected AlgorithmConstraints getAlgorithmConstraints(Socket socket) {\n-\n-        if (constraintsDisabled) {\n-            return null;\n-        }\n-\n-        if (socket != null && socket.isConnected() &&\n-                socket instanceof SSLSocket sslSocket) {\n-\n-            SSLSession session = sslSocket.getHandshakeSession();\n-\n-            if (session != null) {\n-                if (ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {\n-                    String[] peerSupportedSignAlgs = null;\n-\n-                    if (session instanceof ExtendedSSLSession extSession) {\n-                        peerSupportedSignAlgs =\n-                                extSession.getPeerSupportedSignatureAlgorithms();\n-                    }\n-\n-                    return SSLAlgorithmConstraints.forSocket(\n-                            sslSocket, peerSupportedSignAlgs, true);\n-                }\n-            }\n-\n-            return SSLAlgorithmConstraints.forSocket(sslSocket, true);\n-        }\n-\n-        return SSLAlgorithmConstraints.DEFAULT;\n-    }\n-\n-    \/\/ Gets algorithm constraints of the engine.\n-    protected AlgorithmConstraints getAlgorithmConstraints(SSLEngine engine) {\n-\n-        if (constraintsDisabled) {\n-            return null;\n-        }\n-\n-        if (engine != null) {\n-            SSLSession session = engine.getHandshakeSession();\n-            if (session != null) {\n-                if (ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {\n-                    String[] peerSupportedSignAlgs = null;\n-\n-                    if (session instanceof ExtendedSSLSession extSession) {\n-                        peerSupportedSignAlgs =\n-                                extSession.getPeerSupportedSignatureAlgorithms();\n-                    }\n-\n-                    return SSLAlgorithmConstraints.forEngine(\n-                            engine, peerSupportedSignAlgs, true);\n-                }\n-            }\n-        }\n-\n-        return SSLAlgorithmConstraints.forEngine(engine, true);\n-    }\n-\n-    protected boolean conformsToAlgorithmConstraints(\n-            AlgorithmConstraints constraints, Certificate[] chain,\n-            String variant) {\n-\n-        if (constraintsDisabled) {\n-            return true;\n-        }\n-\n-        AlgorithmChecker checker = new AlgorithmChecker(constraints, variant);\n-        try {\n-            checker.init(false);\n-        } catch (CertPathValidatorException cpve) {\n-            \/\/ unlikely to happen\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n-                SSLLogger.fine(\n-                        \"Cannot initialize algorithm constraints checker\",\n-                        cpve);\n-            }\n-\n-            return false;\n-        }\n-\n-        \/\/ It is a forward checker, so we need to check from trust to target.\n-        for (int i = chain.length - 1; i >= 0; i--) {\n-            Certificate cert = chain[i];\n-            try {\n-                \/\/ We don't care about the unresolved critical extensions.\n-                checker.check(cert, Collections.emptySet());\n-            } catch (CertPathValidatorException cpve) {\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n-                    SSLLogger.fine(\"Certificate does not conform to \" +\n-                            \"algorithm constraints\", cert, cpve);\n-                }\n-\n-                return false;\n-            }\n-        }\n-\n-        return true;\n-    }\n-\n-    protected boolean isConstraintsDisabled() {\n-        return \"true\".equals(System.getProperty(\n-                PROPERTY_KEYMANAGER_DISABLE_CONSTRAINTS));\n-    }\n-\n-    \/\/ enum for the result of the extension check\n-    \/\/ NOTE: the order of the constants is important as they are used\n-    \/\/ for sorting, i.e. OK is best, followed by EXPIRED and EXTENSION_MISMATCH\n-    enum CheckResult {\n-        OK,                     \/\/ ok or not checked\n-        INSENSITIVE,            \/\/ server name indication insensitive\n-        EXPIRED,                \/\/ extensions valid but cert expired\n-        EXTENSION_MISMATCH,     \/\/ extensions invalid (expiration not checked)\n-    }\n-\n-    \/\/ enum for the type of certificate check we want to perform\n-    \/\/ (client or server)\n-    \/\/ also includes the check code itself\n-    enum CheckType {\n-\n-        \/\/ enum constant for \"no check\" (currently not used)\n-        NONE(Collections.emptySet()),\n-\n-        \/\/ enum constant for \"tls client\" check\n-        \/\/ valid EKU for TLS client: any, tls_client\n-        CLIENT(new HashSet<>(List.of(\n-                KnownOIDs.anyExtendedKeyUsage.value(),\n-                KnownOIDs.clientAuth.value()\n-        ))),\n-\n-        \/\/ enum constant for \"tls server\" check\n-        \/\/ valid EKU for TLS server: any, tls_server, ns_sgc, ms_sgc\n-        SERVER(new HashSet<>(List.of(\n-                KnownOIDs.anyExtendedKeyUsage.value(),\n-                KnownOIDs.serverAuth.value(),\n-                KnownOIDs.NETSCAPE_ExportApproved.value(),\n-                KnownOIDs.MICROSOFT_ExportApproved.value()\n-        )));\n-\n-        \/\/ set of valid EKU values for this type\n-        final Set<String> validEku;\n-\n-        CheckType(Set<String> validEku) {\n-            this.validEku = validEku;\n-        }\n-\n-        private static boolean getBit(boolean[] keyUsage, int bit) {\n-            return (bit < keyUsage.length) && keyUsage[bit];\n-        }\n-\n-        \/\/ Check if this certificate is appropriate for this type of use\n-        \/\/ first check extensions, if they match, check expiration.\n-        \/\/\n-        \/\/ Note: we may want to move this code into the sun.security.validator\n-        \/\/ package\n-        CheckResult check(X509Certificate cert, Date date,\n-                List<SNIServerName> serverNames, String idAlgorithm) {\n-\n-            if (this == NONE) {\n-                return CheckResult.OK;\n-            }\n-\n-            \/\/ check extensions\n-            try {\n-                \/\/ check extended key usage\n-                List<String> certEku = cert.getExtendedKeyUsage();\n-                if ((certEku != null) &&\n-                        Collections.disjoint(validEku, certEku)) {\n-                    \/\/ if extension is present and does not contain any of\n-                    \/\/ the valid EKU OIDs, return extension_mismatch\n-                    return CheckResult.EXTENSION_MISMATCH;\n-                }\n-\n-                \/\/ check key usage\n-                boolean[] ku = cert.getKeyUsage();\n-                if (ku != null) {\n-                    String algorithm = cert.getPublicKey().getAlgorithm();\n-                    boolean supportsDigitalSignature = getBit(ku, 0);\n-                    switch (algorithm) {\n-                        case \"RSA\":\n-                            \/\/ require either signature bit\n-                            \/\/ or if server also allow key encipherment bit\n-                            if (!supportsDigitalSignature) {\n-                                if (this == CLIENT || !getBit(ku, 2)) {\n-                                    return CheckResult.EXTENSION_MISMATCH;\n-                                }\n-                            }\n-                            break;\n-                        case \"RSASSA-PSS\":\n-                            if (!supportsDigitalSignature && (this == SERVER)) {\n-                                return CheckResult.EXTENSION_MISMATCH;\n-                            }\n-                            break;\n-                        case \"DSA\":\n-                            \/\/ require signature bit\n-                            if (!supportsDigitalSignature) {\n-                                return CheckResult.EXTENSION_MISMATCH;\n-                            }\n-                            break;\n-                        case \"DH\":\n-                            \/\/ require keyagreement bit\n-                            if (!getBit(ku, 4)) {\n-                                return CheckResult.EXTENSION_MISMATCH;\n-                            }\n-                            break;\n-                        case \"EC\":\n-                            \/\/ require signature bit\n-                            if (!supportsDigitalSignature) {\n-                                return CheckResult.EXTENSION_MISMATCH;\n-                            }\n-                            \/\/ For servers, also require key agreement.\n-                            \/\/ This is not totally accurate as the keyAgreement\n-                            \/\/ bit is only necessary for static ECDH key\n-                            \/\/ exchange and not ephemeral ECDH. We leave it in\n-                            \/\/ for now until there are signs that this check\n-                            \/\/ causes problems for real world EC certificates.\n-                            if (this == SERVER && !getBit(ku, 4)) {\n-                                return CheckResult.EXTENSION_MISMATCH;\n-                            }\n-                            break;\n-                    }\n-                }\n-            } catch (CertificateException e) {\n-                \/\/ extensions unparseable, return failure\n-                return CheckResult.EXTENSION_MISMATCH;\n-            }\n-\n-            try {\n-                cert.checkValidity(date);\n-            } catch (CertificateException e) {\n-                return CheckResult.EXPIRED;\n-            }\n-\n-            if (serverNames != null && !serverNames.isEmpty()) {\n-                for (SNIServerName serverName : serverNames) {\n-                    if (serverName.getType() ==\n-                            StandardConstants.SNI_HOST_NAME) {\n-                        if (!(serverName instanceof SNIHostName)) {\n-                            try {\n-                                serverName =\n-                                        new SNIHostName(serverName.getEncoded());\n-                            } catch (IllegalArgumentException iae) {\n-                                \/\/ unlikely to happen, just in case ...\n-                                if (SSLLogger.isOn &&\n-                                        SSLLogger.isOn(\"keymanager\")) {\n-                                    SSLLogger.fine(\n-                                            \"Illegal server name: \" + serverName);\n-                                }\n-\n-                                return CheckResult.INSENSITIVE;\n-                            }\n-                        }\n-                        String hostname =\n-                                ((SNIHostName)serverName).getAsciiName();\n-\n-                        try {\n-                            X509TrustManagerImpl.checkIdentity(hostname,\n-                                    cert, idAlgorithm);\n-                        } catch (CertificateException e) {\n-                            if (SSLLogger.isOn &&\n-                                    SSLLogger.isOn(\"keymanager\")) {\n-                                SSLLogger.fine(\n-                                        \"Certificate identity does not match \" +\n-                                                \"Server Name Indication (SNI): \" +\n-                                                hostname);\n-                            }\n-                            return CheckResult.INSENSITIVE;\n-                        }\n-\n-                        break;\n-                    }\n-                }\n-            }\n-\n-            return CheckResult.OK;\n-        }\n-\n-        public String getValidator() {\n-            if (this == CLIENT) {\n-                return Validator.VAR_TLS_CLIENT;\n-            } else if (this == SERVER) {\n-                return Validator.VAR_TLS_SERVER;\n-            }\n-            return Validator.VAR_GENERIC;\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/X509KeyManagerConstraints.java","additions":0,"deletions":356,"binary":false,"changes":356,"status":"deleted"},{"patch":"@@ -37,1 +37,0 @@\n-import java.security.cert.Certificate;\n@@ -40,0 +39,1 @@\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -61,1 +61,1 @@\n-final class X509KeyManagerImpl extends X509KeyManagerConstraints {\n+final class X509KeyManagerImpl extends X509KeyManagerCertChecking {\n@@ -82,2 +82,1 @@\n-        entryCacheMap = Collections.synchronizedMap\n-                        (new SizedMap<>());\n+        entryCacheMap = new ConcurrentHashMap<>();\n@@ -118,1 +117,1 @@\n-                        getAlgorithmConstraints(socket));\n+                getAlgorithmConstraints(socket), null, null);\n@@ -125,1 +124,1 @@\n-                        getAlgorithmConstraints(engine));\n+                getAlgorithmConstraints(engine), null, null);\n@@ -166,1 +165,1 @@\n-        return getAliases(keyType, issuers, CheckType.CLIENT, null);\n+        return getAliases(keyType, issuers, CheckType.CLIENT);\n@@ -171,1 +170,1 @@\n-        return getAliases(keyType, issuers, CheckType.SERVER, null);\n+        return getAliases(keyType, issuers, CheckType.SERVER);\n@@ -183,1 +182,1 @@\n-        return uidCounter.incrementAndGet() + \".\" + entry.builderIndex + \".\"\n+        return uidCounter.incrementAndGet() + \".\" + entry.keyStoreIndex + \".\"\n@@ -228,62 +227,0 @@\n-    \/\/ Class to help verify that the public key algorithm (and optionally\n-    \/\/ the signature algorithm) of a certificate matches what we need.\n-    private static class KeyType {\n-\n-        final String keyAlgorithm;\n-\n-        \/\/ In TLS 1.2, the signature algorithm  has been obsoleted by the\n-        \/\/ supported_signature_algorithms, and the certificate type no longer\n-        \/\/ restricts the algorithm used to sign the certificate.\n-        \/\/\n-        \/\/ However, because we don't support certificate type checking other\n-        \/\/ than rsa_sign, dss_sign and ecdsa_sign, we don't have to check the\n-        \/\/ protocol version here.\n-        final String sigKeyAlgorithm;\n-\n-        KeyType(String algorithm) {\n-            int k = algorithm.indexOf('_');\n-            if (k == -1) {\n-                keyAlgorithm = algorithm;\n-                sigKeyAlgorithm = null;\n-            } else {\n-                keyAlgorithm = algorithm.substring(0, k);\n-                sigKeyAlgorithm = algorithm.substring(k + 1);\n-            }\n-        }\n-\n-        boolean matches(Certificate[] chain) {\n-            if (!chain[0].getPublicKey().getAlgorithm().equals(keyAlgorithm)) {\n-                return false;\n-            }\n-            if (sigKeyAlgorithm == null) {\n-                return true;\n-            }\n-            if (chain.length > 1) {\n-                \/\/ if possible, check the public key in the issuer cert\n-                return sigKeyAlgorithm.equals(\n-                        chain[1].getPublicKey().getAlgorithm());\n-            } else {\n-                \/\/ Check the signature algorithm of the certificate itself.\n-                \/\/ Look for the \"withRSA\" in \"SHA1withRSA\", etc.\n-                X509Certificate issuer = (X509Certificate)chain[0];\n-                String sigAlgName =\n-                        issuer.getSigAlgName().toUpperCase(Locale.ENGLISH);\n-                String pattern =\n-                        \"WITH\" + sigKeyAlgorithm.toUpperCase(Locale.ENGLISH);\n-                return sigAlgName.contains(pattern);\n-            }\n-        }\n-    }\n-\n-    private static List<KeyType> getKeyTypes(String ... keyTypes) {\n-        if ((keyTypes == null) ||\n-                (keyTypes.length == 0) || (keyTypes[0] == null)) {\n-            return null;\n-        }\n-        List<KeyType> list = new ArrayList<>(keyTypes.length);\n-        for (String keyType : keyTypes) {\n-            list.add(new KeyType(keyType));\n-        }\n-        return list;\n-    }\n-\n@@ -303,7 +240,0 @@\n-    private String chooseAlias(List<KeyType> keyTypeList, Principal[] issuers,\n-            CheckType checkType, AlgorithmConstraints constraints) {\n-\n-        return chooseAlias(keyTypeList, issuers,\n-                                    checkType, constraints, null, null);\n-    }\n-\n@@ -364,2 +294,2 @@\n-    public String[] getAliases(String keyType, Principal[] issuers,\n-            CheckType checkType, AlgorithmConstraints constraints) {\n+    private String[] getAliases(\n+            String keyType, Principal[] issuers, CheckType checkType) {\n@@ -376,2 +306,1 @@\n-                                    issuerSet, true, checkType, constraints,\n-                                    null, null);\n+                        issuerSet, true, checkType, null, null, null);\n@@ -411,44 +340,0 @@\n-    \/\/ make a Set out of the array\n-    private Set<Principal> getIssuerSet(Principal[] issuers) {\n-        if ((issuers != null) && (issuers.length != 0)) {\n-            return new HashSet<>(Arrays.asList(issuers));\n-        } else {\n-            return null;\n-        }\n-    }\n-\n-    \/\/ a candidate match\n-    \/\/ identifies the entry by builder and alias\n-    \/\/ and includes the result of the certificate check\n-    private static class EntryStatus implements Comparable<EntryStatus> {\n-\n-        final int builderIndex;\n-        final int keyIndex;\n-        final String alias;\n-        final CheckResult checkResult;\n-\n-        EntryStatus(int builderIndex, int keyIndex, String alias,\n-                Certificate[] chain, CheckResult checkResult) {\n-            this.builderIndex = builderIndex;\n-            this.keyIndex = keyIndex;\n-            this.alias = alias;\n-            this.checkResult = checkResult;\n-        }\n-\n-        @Override\n-        public int compareTo(EntryStatus other) {\n-            int result = this.checkResult.compareTo(other.checkResult);\n-            return (result == 0) ? (this.keyIndex - other.keyIndex) : result;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            String s = alias + \" (verified: \" + checkResult + \")\";\n-            if (builderIndex == 0) {\n-                return s;\n-            } else {\n-                return \"Builder #\" + builderIndex + \", alias: \" + s;\n-            }\n-        }\n-    }\n-\n@@ -491,1 +376,0 @@\n-        Date date = verificationDate;\n@@ -493,0 +377,1 @@\n+\n@@ -494,0 +379,1 @@\n+\n@@ -495,0 +381,1 @@\n+\n@@ -500,5 +387,4 @@\n-            Certificate[] chain = ks.getCertificateChain(alias);\n-            if ((chain == null) || (chain.length == 0)) {\n-                \/\/ must be secret key entry, ignore\n-                continue;\n-            }\n+            EntryStatus status = checkAlias(builderIndex, alias,\n+                    ks.getCertificateChain(alias),\n+                    verificationDate, keyTypes, issuerSet, checkType,\n+                    constraints, requestedServerNames, idAlgorithm);\n@@ -506,9 +392,1 @@\n-            boolean incompatible = false;\n-            for (Certificate cert : chain) {\n-                if (!(cert instanceof X509Certificate)) {\n-                    \/\/ not an X509Certificate, ignore this alias\n-                    incompatible = true;\n-                    break;\n-                }\n-            }\n-            if (incompatible) {\n+            if (status == null) {\n@@ -518,60 +396,2 @@\n-            \/\/ check keytype\n-            int keyIndex = -1;\n-            int j = 0;\n-            for (KeyType keyType : keyTypes) {\n-                if (keyType.matches(chain)) {\n-                    keyIndex = j;\n-                    break;\n-                }\n-                j++;\n-            }\n-            if (keyIndex == -1) {\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n-                    SSLLogger.fine(\"Ignore alias \" + alias\n-                                + \": key algorithm does not match\");\n-                }\n-                continue;\n-            }\n-            \/\/ check issuers\n-            if (issuerSet != null) {\n-                boolean found = false;\n-                for (Certificate cert : chain) {\n-                    X509Certificate xcert = (X509Certificate)cert;\n-                    if (issuerSet.contains(xcert.getIssuerX500Principal())) {\n-                        found = true;\n-                        break;\n-                    }\n-                }\n-                if (!found) {\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n-                        SSLLogger.fine(\n-                                \"Ignore alias \" + alias\n-                                + \": issuers do not match\");\n-                    }\n-                    continue;\n-                }\n-            }\n-\n-            \/\/ check the algorithm constraints\n-            if (constraints != null &&\n-                    !conformsToAlgorithmConstraints(constraints, chain,\n-                            checkType.getValidator())) {\n-\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n-                    SSLLogger.fine(\"Ignore alias \" + alias +\n-                            \": certificate list does not conform to \" +\n-                            \"algorithm constraints\");\n-                }\n-                continue;\n-            }\n-\n-            if (date == null) {\n-                date = new Date();\n-            }\n-            CheckResult checkResult =\n-                    checkType.check((X509Certificate)chain[0], date,\n-                                    requestedServerNames, idAlgorithm);\n-            EntryStatus status =\n-                    new EntryStatus(builderIndex, keyIndex,\n-                                        alias, chain, checkResult);\n-            if (!preferred && checkResult == CheckResult.OK && keyIndex == 0) {\n+            if (!preferred && status.checkResult == CheckResult.OK\n+                    && status.keyIndex == 0) {\n@@ -580,0 +400,1 @@\n+\n@@ -581,1 +402,1 @@\n-                \/\/ if we have a good match and do not need all matches,\n+                \/\/ If we have a good match and do not need all matches,\n@@ -591,0 +412,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/X509KeyManagerImpl.java","additions":24,"deletions":202,"binary":false,"changes":226,"status":"modified"},{"patch":"@@ -249,1 +249,1 @@\n-                .setNotAfter(\n+                .setNotBefore(\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpsClient\/ServerIdentityTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -238,1 +238,1 @@\n-                \"jdk.tls.keymanager.disableConstraintsChecking\", \"true\");\n+                \"jdk.tls.keymanager.disableCertChecking\", \"true\");\n","filename":"test\/jdk\/sun\/security\/mscapi\/ShortRSAKeyWithinTLS.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -157,1 +157,1 @@\n-                \"jdk.tls.keymanager.disableConstraintsChecking\", \"true\");\n+                \"jdk.tls.keymanager.disableCertChecking\", \"true\");\n@@ -220,1 +220,1 @@\n-                .setNotAfter(\n+                .setNotBefore(\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/MD5NotAllowedInTLS13CertificateSignature.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.security.Security;\n@@ -54,3 +53,2 @@\n- * @bug 8353113\n- * @summary Peer supported certificate signature algorithms are not being\n- *          checked with default SunX509 key manager\n+ * @bug 8170706\n+ * @summary Support algorithm constraints in SunX509 key manager\n@@ -81,1 +79,1 @@\n-                \"jdk.tls.keymanager.disableConstraintsChecking\", disabled);\n+                \"jdk.tls.keymanager.disableCertChecking\", disabled);\n@@ -172,1 +170,1 @@\n-                .setNotAfter(\n+                .setNotBefore(\n@@ -184,1 +182,0 @@\n-\n","filename":"test\/jdk\/sun\/security\/ssl\/X509KeyManager\/AlgorithmConstraintsCheck.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,396 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertNull;\n+\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.KeyStore;\n+import java.security.Principal;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Date;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.X509KeyManager;\n+import javax.security.auth.x500.X500Principal;\n+import jdk.test.lib.security.CertificateBuilder;\n+import sun.security.x509.AuthorityKeyIdentifierExtension;\n+import sun.security.x509.GeneralName;\n+import sun.security.x509.GeneralNames;\n+import sun.security.x509.KeyIdentifier;\n+import sun.security.x509.SerialNumber;\n+import sun.security.x509.X500Name;\n+\n+\/*\n+ * @test\n+ * @bug 8359069\n+ * @summary Support certificate checks in SunX509 key manager\n+ * @modules java.base\/sun.security.x509\n+ *          java.base\/sun.security.util\n+ * @library \/test\/lib\n+ * @run main\/othervm CertChecking false SunX509\n+ * @run main\/othervm CertChecking true SunX509\n+ * @run main\/othervm CertChecking false PKIX\n+ * @run main\/othervm CertChecking true PKIX\n+ *\/\n+\n+\/*\n+ * This class tests against the certificate's expiration, key usage and issuers.\n+ *\/\n+\n+public class CertChecking {\n+\n+    private static final String PREFERRED_ALIAS = \"preferred-alias\";\n+    private static final String EXPIRED_ALIAS = \"expired-alias\";\n+    private static final String USAGE_MISMATCH_ALIAS = \"usage-mismatch-alias\";\n+    private static final String CA_KEY_TYPE = \"RSA\";\n+    private static final String CERT_SIG_ALG = \"SHA256withRSA\";\n+    private static final String CA_ISSUER_STRING =\n+            \"O=TrustedCert, L=Some-City, ST=Some-State, C=US\";\n+    private static final String EE_ISSUER_STRING =\n+            \"O=EndpointCert, L=Some-City, ST=Some-State, C=US\";\n+    private static final String UNKNOWN_ISSUER_STRING =\n+            \"O=UnknownCert, L=Some-City, ST=Some-State, C=US\";\n+\n+    \/*\n+     * Certificate KeyUsage reference:\n+     *\n+     *     digitalSignature        (0),\n+     *     nonRepudiation          (1),\n+     *     keyEncipherment         (2),\n+     *     dataEncipherment        (3),\n+     *     keyAgreement            (4),\n+     *     keyCertSign             (5),\n+     *     cRLSign                 (6),\n+     *     encipherOnly            (7),\n+     *     decipherOnly            (8)\n+     *\/\n+\n+    private static final boolean[] DEFAULT_KEY_USAGES =\n+            new boolean[]{true, true, true, true, true, true};\n+    private static final boolean[] NONE_KEY_USAGES =\n+            new boolean[]{false, false, false, false, false, false};\n+    private static final boolean[] NO_DG_USAGE =\n+            new boolean[]{false, true, true, true, true, true};\n+    private static final boolean[] NO_DG_NO_KE_USAGE =\n+            new boolean[]{false, true, false, true, true, true};\n+    private static final boolean[] NO_KA_USAGE =\n+            new boolean[]{true, true, true, true, false, true};\n+\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 2) {\n+            throw new RuntimeException(\"Wrong number of arguments\");\n+        }\n+\n+        String disabled = args[0];\n+        String kmAlg = args[1];\n+\n+        System.setProperty(\n+                \"jdk.tls.keymanager.disableCertChecking\", disabled);\n+\n+        \/\/ --- Usage and expired test cases --\n+\n+        \/\/ Both should fail with no usages at all\n+        usageTestCase(disabled, kmAlg, \"RSA\", NONE_KEY_USAGES, true, true);\n+\n+        \/\/ Only client should fail with RSA algorithm and\n+        \/\/ no digital signature bit set\n+        usageTestCase(disabled, kmAlg, \"RSA\", NO_DG_USAGE, false, true);\n+\n+        \/\/ Only server should fail with RSA algorithm and\n+        \/\/ no digital signature bit set\n+        usageTestCase(disabled, kmAlg, \"RSASSA-PSS\", NO_DG_USAGE, true, false);\n+\n+        \/\/ Both should fail with DSA algorithm and no digital signature bit set\n+        usageTestCase(disabled, kmAlg, \"DSA\", NO_DG_USAGE, true, true);\n+\n+        \/\/ Both should fail with EC algorithm and no digital signature bit set\n+        usageTestCase(disabled, kmAlg, \"EC\", NO_DG_USAGE, true, true);\n+\n+        \/\/ Both should fail with RSA algorithm and missing digital signature and\n+        \/\/ key encipherment bits.\n+        usageTestCase(disabled, kmAlg, \"RSA\", NO_DG_NO_KE_USAGE, true, true);\n+\n+        \/\/ Both should fail with DH algorithm and no key agreement bit set.\n+        usageTestCase(disabled, kmAlg, \"DH\", NO_KA_USAGE, true, true);\n+\n+        \/\/ Only server should fail with EC algorithm and\n+        \/\/ no digital signature bit set\n+        usageTestCase(disabled, kmAlg, \"EC\", NO_KA_USAGE, true, false);\n+\n+        \/\/ --- Issuer match test cases ---\n+\n+        \/\/ Check CA issuer match\n+        issuerTestCase(disabled, kmAlg, \"RSA\",\n+                new Principal[]{new X500Principal(CA_ISSUER_STRING)}, true);\n+\n+        \/\/ Issuer that is not in the chain should not match.\n+        issuerTestCase(disabled, kmAlg, \"RSA\",\n+                new Principal[]{new X500Principal(UNKNOWN_ISSUER_STRING)}, false);\n+    }\n+\n+    private static void usageTestCase(String disabled, String kmAlg,\n+            String keyAlg, boolean[] certKeyUsages, boolean checkServer,\n+            boolean checkClient) throws Exception {\n+\n+        X509KeyManager km = getKeyManager(\n+                kmAlg, keyAlg, certKeyUsages);\n+\n+        String chosenServerAlias = km.chooseServerAlias(keyAlg, null, null);\n+        String chosenClientAlias = km.chooseClientAlias(\n+                new String[]{keyAlg}, null, null);\n+\n+        String[] allServerAliases = km.getServerAliases(keyAlg, null);\n+        String[] allClientAliases = km.getClientAliases(keyAlg, null);\n+\n+        if (\"true\".equals(disabled)) {\n+            \/\/ Initial order alias returned\n+            assertEquals(USAGE_MISMATCH_ALIAS,\n+                    normalizeAlias(chosenServerAlias));\n+            assertEquals(USAGE_MISMATCH_ALIAS,\n+                    normalizeAlias(chosenClientAlias));\n+\n+            \/\/ Assert the initial order of all aliases.\n+            assertEquals(USAGE_MISMATCH_ALIAS,\n+                    normalizeAlias(allServerAliases[0]));\n+            assertEquals(USAGE_MISMATCH_ALIAS,\n+                    normalizeAlias(allClientAliases[0]));\n+            assertEquals(PREFERRED_ALIAS, normalizeAlias(allServerAliases[1]));\n+            assertEquals(PREFERRED_ALIAS, normalizeAlias(allClientAliases[1]));\n+            assertEquals(EXPIRED_ALIAS, normalizeAlias(allServerAliases[2]));\n+            assertEquals(EXPIRED_ALIAS, normalizeAlias(allClientAliases[2]));\n+\n+        } else {\n+            if (checkServer) {\n+                \/\/ Preferred alias returned\n+                assertEquals(PREFERRED_ALIAS,\n+                        normalizeAlias(chosenServerAlias));\n+\n+                \/\/ Assert the correct sorted order of all aliases.\n+                assertEquals(PREFERRED_ALIAS,\n+                        normalizeAlias(allServerAliases[0]));\n+                assertEquals(EXPIRED_ALIAS,\n+                        normalizeAlias(allServerAliases[1]));\n+                assertEquals(USAGE_MISMATCH_ALIAS,\n+                        normalizeAlias(allServerAliases[2]));\n+            }\n+\n+            if (checkClient) {\n+                \/\/ Preferred alias returned\n+                assertEquals(PREFERRED_ALIAS,\n+                        normalizeAlias(chosenClientAlias));\n+\n+                \/\/ Assert the correct sorted order of all aliases.\n+                assertEquals(PREFERRED_ALIAS,\n+                        normalizeAlias(allClientAliases[0]));\n+                assertEquals(EXPIRED_ALIAS,\n+                        normalizeAlias(allClientAliases[1]));\n+                assertEquals(USAGE_MISMATCH_ALIAS,\n+                        normalizeAlias(allClientAliases[2]));\n+            }\n+        }\n+    }\n+\n+    private static void issuerTestCase(String disabled, String kmAlg,\n+            String keyAlg, Principal[] issuers, boolean found) throws Exception {\n+\n+        X509KeyManager km = getKeyManager(\n+                kmAlg, keyAlg, NONE_KEY_USAGES);\n+\n+        String chosenServerAlias = km.chooseServerAlias(keyAlg, issuers, null);\n+        String chosenClientAlias = km.chooseClientAlias(\n+                new String[]{keyAlg}, issuers, null);\n+\n+        String[] allServerAliases = km.getServerAliases(keyAlg, issuers);\n+        String[] allClientAliases = km.getClientAliases(keyAlg, issuers);\n+\n+        if (found) {\n+            if (\"true\".equals(disabled)) {\n+                assertEquals(USAGE_MISMATCH_ALIAS, normalizeAlias(chosenServerAlias));\n+                assertEquals(USAGE_MISMATCH_ALIAS, normalizeAlias(chosenClientAlias));\n+\n+                \/\/ Assert the initial order of all aliases.\n+                assertEquals(USAGE_MISMATCH_ALIAS,\n+                        normalizeAlias(allServerAliases[0]));\n+                assertEquals(USAGE_MISMATCH_ALIAS,\n+                        normalizeAlias(allClientAliases[0]));\n+                assertEquals(PREFERRED_ALIAS, normalizeAlias(allServerAliases[1]));\n+                assertEquals(PREFERRED_ALIAS, normalizeAlias(allClientAliases[1]));\n+                assertEquals(EXPIRED_ALIAS, normalizeAlias(allServerAliases[2]));\n+                assertEquals(EXPIRED_ALIAS, normalizeAlias(allClientAliases[2]));\n+            } else {\n+                assertEquals(PREFERRED_ALIAS, normalizeAlias(chosenServerAlias));\n+                assertEquals(PREFERRED_ALIAS, normalizeAlias(chosenClientAlias));\n+\n+                \/\/ Assert the correct sorted order of all aliases.\n+                assertEquals(PREFERRED_ALIAS,\n+                        normalizeAlias(allServerAliases[0]));\n+                assertEquals(EXPIRED_ALIAS,\n+                        normalizeAlias(allServerAliases[1]));\n+                assertEquals(USAGE_MISMATCH_ALIAS,\n+                        normalizeAlias(allServerAliases[2]));\n+            }\n+        } else {\n+            assertNull(chosenServerAlias);\n+            assertNull(chosenClientAlias);\n+            assertNull(allServerAliases);\n+            assertNull(allClientAliases);\n+        }\n+    }\n+\n+\n+        \/\/ PKIX KeyManager adds a cache prefix to an alias.\n+    private static String normalizeAlias(String alias) {\n+        return alias.substring(alias.lastIndexOf(\".\") + 1);\n+\n+    }\n+\n+    private static X509KeyManager getKeyManager(String kmAlg,\n+            String keyAlg, boolean[] certKeyUsages)\n+            throws Exception {\n+\n+        \/\/ Create a key store.\n+        KeyStore ks = KeyStore.getInstance(\"PKCS12\");\n+        ks.load(null, null);\n+\n+        \/\/ Generate and set the trusted cert.\n+        KeyPair caKeys = KeyPairGenerator.getInstance(CA_KEY_TYPE)\n+                .generateKeyPair();\n+        X509Certificate trustedCert = createTrustedCert(caKeys);\n+        ks.setCertificateEntry(\"CA entry\", trustedCert);\n+\n+        \/\/ Generate valid certificate chain.\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(keyAlg);\n+        KeyPair validEndpointKeys = kpg.generateKeyPair();\n+\n+        X509Certificate validEndpointCert = customCertificateBuilder(\n+                EE_ISSUER_STRING,\n+                validEndpointKeys.getPublic(), caKeys.getPublic(),\n+                Instant.now(), DEFAULT_KEY_USAGES)\n+                .addBasicConstraintsExt(false, false, -1)\n+                .build(trustedCert, caKeys.getPrivate(), CERT_SIG_ALG);\n+\n+        Certificate[] validChain = new Certificate[2];\n+        validChain[0] = validEndpointCert;\n+        validChain[1] = trustedCert;\n+\n+        \/\/ Generate expired certificate chain.\n+        KeyPair expiredEndpointKeys = kpg.generateKeyPair();\n+\n+        X509Certificate expiredEndpointCert = customCertificateBuilder(\n+                EE_ISSUER_STRING,\n+                expiredEndpointKeys.getPublic(), caKeys.getPublic(),\n+                Instant.now().minus(1, ChronoUnit.DAYS), DEFAULT_KEY_USAGES)\n+                .addBasicConstraintsExt(false, false, -1)\n+                .build(trustedCert, caKeys.getPrivate(), CERT_SIG_ALG);\n+\n+        Certificate[] expiredChain = new Certificate[2];\n+        expiredChain[0] = expiredEndpointCert;\n+        expiredChain[1] = trustedCert;\n+\n+        \/\/ Generate usage mismatch certificate chain.\n+        KeyPair usageMismatchEndpointKeys = kpg.generateKeyPair();\n+\n+        X509Certificate usageMismatchEndpointCert = customCertificateBuilder(\n+                EE_ISSUER_STRING,\n+                usageMismatchEndpointKeys.getPublic(), caKeys.getPublic(),\n+                Instant.now(), certKeyUsages)\n+                .addBasicConstraintsExt(false, false, -1)\n+                .build(trustedCert, caKeys.getPrivate(), CERT_SIG_ALG);\n+\n+        Certificate[] usageMismatchChain = new Certificate[2];\n+        usageMismatchChain[0] = usageMismatchEndpointCert;\n+        usageMismatchChain[1] = trustedCert;\n+\n+        \/\/ Import the key entries, order matters.\n+        final char[] passphrase = \"passphrase\".toCharArray();\n+        ks.setKeyEntry(USAGE_MISMATCH_ALIAS,\n+                usageMismatchEndpointKeys.getPrivate(), passphrase,\n+                usageMismatchChain);\n+        ks.setKeyEntry(PREFERRED_ALIAS, validEndpointKeys.getPrivate(),\n+                passphrase,\n+                validChain);\n+        ks.setKeyEntry(EXPIRED_ALIAS, expiredEndpointKeys.getPrivate(),\n+                passphrase,\n+                expiredChain);\n+\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(kmAlg);\n+        kmf.init(ks, passphrase);\n+\n+        return (X509KeyManager) kmf.getKeyManagers()[0];\n+    }\n+\n+    \/\/ Certificate-building helper methods.\n+\n+    private static X509Certificate createTrustedCert(KeyPair caKeys)\n+            throws Exception {\n+        SecureRandom random = new SecureRandom();\n+\n+        KeyIdentifier kid = new KeyIdentifier(caKeys.getPublic());\n+        GeneralNames gns = new GeneralNames();\n+        GeneralName name = new GeneralName(new X500Name(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\"));\n+        gns.add(name);\n+        BigInteger serialNumber = BigInteger.valueOf(\n+                random.nextLong(1000000) + 1);\n+        return customCertificateBuilder(\n+                CA_ISSUER_STRING,\n+                caKeys.getPublic(), caKeys.getPublic(), Instant.now(),\n+                DEFAULT_KEY_USAGES)\n+                .setSerialNumber(serialNumber)\n+                .addExtension(new AuthorityKeyIdentifierExtension(kid, gns,\n+                        new SerialNumber(serialNumber)))\n+                .addBasicConstraintsExt(true, true, -1)\n+                .build(null, caKeys.getPrivate(), CERT_SIG_ALG);\n+    }\n+\n+    private static CertificateBuilder customCertificateBuilder(\n+            String subjectName, PublicKey publicKey, PublicKey caKey,\n+            Instant certDate, boolean[] certKeyUsages)\n+            throws CertificateException, IOException {\n+        SecureRandom random = new SecureRandom();\n+\n+        CertificateBuilder builder = new CertificateBuilder()\n+                .setSubjectName(subjectName)\n+                .setPublicKey(publicKey)\n+                .setNotBefore(\n+                        Date.from(certDate.minus(1, ChronoUnit.HOURS)))\n+                .setNotAfter(Date.from(certDate.plus(1, ChronoUnit.HOURS)))\n+                .setSerialNumber(\n+                        BigInteger.valueOf(random.nextLong(1000000) + 1))\n+                .addSubjectKeyIdExt(publicKey)\n+                .addAuthorityKeyIdExt(caKey);\n+        builder.addKeyUsageExt(certKeyUsages);\n+\n+        return builder;\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/X509KeyManager\/CertChecking.java","additions":396,"deletions":0,"binary":false,"changes":396,"status":"added"},{"patch":"@@ -71,0 +71,5 @@\n+\/*\n+ * This class tests against the peer supported certificate signatures sent in\n+ * \"signature_algorithms_cert\" extension.\n+ *\/\n+\n@@ -105,1 +110,1 @@\n-                \"jdk.tls.keymanager.disableConstraintsChecking\", disabled);\n+                \"jdk.tls.keymanager.disableCertChecking\", disabled);\n@@ -257,1 +262,1 @@\n-                .setNotAfter(\n+                .setNotBefore(\n","filename":"test\/jdk\/sun\/security\/ssl\/X509KeyManager\/PeerConstraintsCheck.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -33,2 +33,0 @@\n- * @run main\/othervm PKIXExtendedTM 0\n- * @run main\/othervm PKIXExtendedTM 1\n@@ -36,1 +34,0 @@\n- * @run main\/othervm PKIXExtendedTM 3\n@@ -1120,1 +1117,1 @@\n-                \"jdk.tls.keymanager.disableConstraintsChecking\", \"true\");\n+                \"jdk.tls.keymanager.disableCertChecking\", \"true\");\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/PKIXExtendedTM.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-                \"jdk.tls.keymanager.disableConstraintsChecking\", \"true\");\n+                \"jdk.tls.keymanager.disableCertChecking\", \"true\");\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/PrintSSL.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -240,1 +240,1 @@\n-     * @param IPAddresses A {@code List} of names to add as IPAddress\n+     * @param ipAddresses A {@code List} of names to add as IPAddress\n@@ -244,1 +244,1 @@\n-    public CertificateBuilder addSubjectAltNameIPExt(List<String> IPAddresses)\n+    public CertificateBuilder addSubjectAltNameIPExt(List<String> ipAddresses)\n@@ -246,1 +246,1 @@\n-        if (!IPAddresses.isEmpty()) {\n+        if (!ipAddresses.isEmpty()) {\n@@ -248,1 +248,1 @@\n-            for (String name : IPAddresses) {\n+            for (String name : ipAddresses) {\n","filename":"test\/lib\/jdk\/test\/lib\/security\/CertificateBuilder.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}