{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.security.AlgorithmConstraints;\n@@ -42,1 +43,0 @@\n-import java.util.HashSet;\n@@ -44,1 +44,0 @@\n-import java.util.Locale;\n@@ -47,0 +46,1 @@\n+import javax.net.ssl.SNIServerName;\n@@ -48,1 +48,0 @@\n-import javax.net.ssl.X509ExtendedKeyManager;\n@@ -54,1 +53,1 @@\n- *\n+ * <p>\n@@ -60,1 +59,1 @@\n- *\n+ * <p>\n@@ -63,17 +62,4 @@\n- *\n- * The JSSE handshake code currently calls into this class via\n- * chooseClientAlias() and chooseServerAlias() to find the certificates to\n- * use. As implemented here, both always return the first alias returned by\n- * getClientAliases() and getServerAliases(). In turn, these methods are\n- * implemented by calling getAliases(), which performs the actual lookup.\n- *\n- * Note that this class currently implements no checking of the local\n- * certificates. In particular, it is *not* guaranteed that:\n- *  . the certificates are within their validity period and not revoked\n- *  . the signatures verify\n- *  . they form a PKIX compliant chain.\n- *  . the certificate extensions allow the certificate to be used for\n- *    the desired purpose.\n- *\n- * Chains that fail any of these criteria will probably be rejected by\n- * the remote peer.\n+ * <p>\n+ * Algorithm constraints and certificate checks can be disabled by setting\n+ * \"jdk.tls.SunX509KeyManager.certChecking\" system property to \"false\"\n+ * before calling a class constructor.\n@@ -82,1 +68,0 @@\n-final class SunX509KeyManagerImpl extends X509ExtendedKeyManager {\n@@ -84,1 +69,1 @@\n-    private static final String[] STRING0 = new String[0];\n+final class SunX509KeyManagerImpl extends X509KeyManagerCertChecking {\n@@ -90,1 +75,1 @@\n-    private final Map<String,X509Credentials> credentialsMap;\n+    private final Map<String, X509Credentials> credentialsMap;\n@@ -92,8 +77,5 @@\n-    \/*\n-     * Cached server aliases for the case issuers == null.\n-     * (in the current JSSE implementation, issuers are always null for\n-     * server certs). See chooseServerAlias() for details.\n-     *\n-     * Map: String(keyType) -> String[](alias)\n-     *\/\n-    private final Map<String,String[]> serverAliasCache;\n+    @Override\n+    protected boolean isCheckingDisabled() {\n+        return \"false\".equalsIgnoreCase(System.getProperty(\n+                \"jdk.tls.SunX509KeyManager.certChecking\", \"true\"));\n+    }\n@@ -105,0 +87,1 @@\n+\n@@ -107,1 +90,0 @@\n-        private final Set<X500Principal> issuerX500Principals;\n@@ -113,8 +95,0 @@\n-            this.issuerX500Principals = HashSet.newHashSet(certificates.length);\n-            for (X509Certificate certificate : certificates) {\n-                issuerX500Principals.add(certificate.getIssuerX500Principal());\n-            }\n-        }\n-\n-        Set<X500Principal> getIssuerX500Principals() {\n-            return issuerX500Principals;\n@@ -129,2 +103,1 @@\n-        serverAliasCache = Collections.synchronizedMap(\n-                new HashMap<>());\n+\n@@ -136,1 +109,1 @@\n-                                        aliases.hasMoreElements(); ) {\n+                aliases.hasMoreElements(); ) {\n@@ -156,2 +129,2 @@\n-            X509Credentials cred = new X509Credentials((PrivateKey)key,\n-                (X509Certificate[])certs);\n+            X509Credentials cred = new X509Credentials((PrivateKey) key,\n+                    (X509Certificate[]) certs);\n@@ -160,1 +133,1 @@\n-                SSLLogger.fine(\"found key for : \" + alias, (Object[])certs);\n+                SSLLogger.fine(\"found key for : \" + alias, (Object[]) certs);\n@@ -208,18 +181,2 @@\n-        \/*\n-         * We currently don't do anything with socket, but\n-         * someday we might.  It might be a useful hint for\n-         * selecting one of the aliases we get back from\n-         * getClientAliases().\n-         *\/\n-\n-        if (keyTypes == null) {\n-            return null;\n-        }\n-\n-        for (int i = 0; i < keyTypes.length; i++) {\n-            String[] aliases = getClientAliases(keyTypes[i], issuers);\n-            if ((aliases != null) && (aliases.length > 0)) {\n-                return aliases[0];\n-            }\n-        }\n-        return null;\n+        return chooseAlias(getKeyTypes(keyTypes), issuers, CheckType.CLIENT,\n+                getAlgorithmConstraints(socket), null, null);\n@@ -233,2 +190,0 @@\n-     *\n-     * @since 1.5\n@@ -237,1 +192,1 @@\n-    public String chooseEngineClientAlias(String[] keyType,\n+    public String chooseEngineClientAlias(String[] keyTypes,\n@@ -239,5 +194,2 @@\n-        \/*\n-         * If we ever start using socket as a selection criteria,\n-         * we'll need to adjust this.\n-         *\/\n-        return chooseClientAlias(keyType, issuers, null);\n+        return chooseAlias(getKeyTypes(keyTypes), issuers, CheckType.CLIENT,\n+                getAlgorithmConstraints(engine), null, null);\n@@ -254,29 +206,3 @@\n-        \/*\n-         * We currently don't do anything with socket, but\n-         * someday we might.  It might be a useful hint for\n-         * selecting one of the aliases we get back from\n-         * getServerAliases().\n-         *\/\n-        if (keyType == null) {\n-            return null;\n-        }\n-\n-        String[] aliases;\n-\n-        if (issuers == null || issuers.length == 0) {\n-            aliases = serverAliasCache.get(keyType);\n-            if (aliases == null) {\n-                aliases = getServerAliases(keyType, issuers);\n-                \/\/ Cache the result (positive and negative lookups)\n-                if (aliases == null) {\n-                    aliases = STRING0;\n-                }\n-                serverAliasCache.put(keyType, aliases);\n-            }\n-        } else {\n-            aliases = getServerAliases(keyType, issuers);\n-        }\n-        if ((aliases != null) && (aliases.length > 0)) {\n-            return aliases[0];\n-        }\n-        return null;\n+        return chooseAlias(getKeyTypes(keyType), issuers, CheckType.SERVER,\n+                getAlgorithmConstraints(socket),\n+                X509TrustManagerImpl.getRequestedServerNames(socket), \"HTTPS\");\n@@ -290,2 +216,0 @@\n-     *\n-     * @since 1.5\n@@ -296,5 +220,3 @@\n-        \/*\n-         * If we ever start using socket as a selection criteria,\n-         * we'll need to adjust this.\n-         *\/\n-        return chooseServerAlias(keyType, issuers, null);\n+        return chooseAlias(getKeyTypes(keyType), issuers, CheckType.SERVER,\n+                getAlgorithmConstraints(engine),\n+                X509TrustManagerImpl.getRequestedServerNames(engine), \"HTTPS\");\n@@ -310,1 +232,2 @@\n-        return getAliases(keyType, issuers);\n+        return getAliases(getKeyTypes(keyType), issuers, CheckType.CLIENT,\n+                null, null, null);\n@@ -320,1 +243,17 @@\n-        return getAliases(keyType, issuers);\n+        return getAliases(getKeyTypes(keyType), issuers, CheckType.SERVER,\n+                null, null, null);\n+    }\n+\n+    private String chooseAlias(List<KeyType> keyTypes, Principal[] issuers,\n+            CheckType checkType, AlgorithmConstraints constraints,\n+            List<SNIServerName> requestedServerNames, String idAlgorithm) {\n+\n+        String[] aliases = getAliases(\n+                keyTypes, issuers, checkType,\n+                constraints, requestedServerNames, idAlgorithm);\n+\n+        if (aliases != null && aliases.length > 0) {\n+            return aliases[0];\n+        }\n+\n+        return null;\n@@ -330,2 +269,6 @@\n-    private String[] getAliases(String keyType, Principal[] issuers) {\n-        if (keyType == null) {\n+    private String[] getAliases(List<KeyType> keyTypes, Principal[] issuers,\n+            CheckType checkType, AlgorithmConstraints constraints,\n+            List<SNIServerName> requestedServerNames,\n+            String idAlgorithm) {\n+\n+        if (keyTypes == null || keyTypes.isEmpty()) {\n@@ -334,15 +277,0 @@\n-        if (issuers == null) {\n-            issuers = new X500Principal[0];\n-        }\n-        if (!(issuers instanceof X500Principal[])) {\n-            \/\/ normally, this will never happen but try to recover if it does\n-            issuers = convertPrincipals(issuers);\n-        }\n-        String sigType;\n-        if (keyType.contains(\"_\")) {\n-            int k = keyType.indexOf('_');\n-            sigType = keyType.substring(k + 1);\n-            keyType = keyType.substring(0, k);\n-        } else {\n-            sigType = null;\n-        }\n@@ -350,3 +278,2 @@\n-        X500Principal[] x500Issuers = (X500Principal[])issuers;\n-        \/\/ the algorithm below does not produce duplicates, so avoid Set\n-        List<String> aliases = new ArrayList<>();\n+        Set<X500Principal> issuerSet = getIssuerSet(issuers);\n+        List<EntryStatus> results = null;\n@@ -354,2 +281,2 @@\n-        for (Map.Entry<String,X509Credentials> entry :\n-                                                credentialsMap.entrySet()) {\n+        for (Map.Entry<String, X509Credentials> entry :\n+                credentialsMap.entrySet()) {\n@@ -357,3 +284,4 @@\n-            String alias = entry.getKey();\n-            X509Credentials credentials = entry.getValue();\n-            X509Certificate[] certs = credentials.certificates;\n+            EntryStatus status = checkAlias(0, entry.getKey(),\n+                    entry.getValue().certificates,\n+                    null, keyTypes, issuerSet, checkType,\n+                    constraints, requestedServerNames, idAlgorithm);\n@@ -361,1 +289,1 @@\n-            if (!keyType.equals(certs[0].getPublicKey().getAlgorithm())) {\n+            if (status == null) {\n@@ -364,19 +292,0 @@\n-            if (sigType != null) {\n-                if (certs.length > 1) {\n-                    \/\/ if possible, check the public key in the issuer cert\n-                    if (!sigType.equals(\n-                            certs[1].getPublicKey().getAlgorithm())) {\n-                        continue;\n-                    }\n-                } else {\n-                    \/\/ Check the signature algorithm of the certificate itself.\n-                    \/\/ Look for the \"withRSA\" in \"SHA1withRSA\", etc.\n-                    String sigAlgName =\n-                        certs[0].getSigAlgName().toUpperCase(Locale.ENGLISH);\n-                    String pattern = \"WITH\" +\n-                        sigType.toUpperCase(Locale.ENGLISH);\n-                    if (!sigAlgName.contains(pattern)) {\n-                        continue;\n-                    }\n-                }\n-            }\n@@ -384,18 +293,2 @@\n-            if (issuers.length == 0) {\n-                \/\/ no issuer specified, match all\n-                aliases.add(alias);\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n-                    SSLLogger.fine(\"matching alias: \" + alias);\n-                }\n-            } else {\n-                Set<X500Principal> certIssuers =\n-                                        credentials.getIssuerX500Principals();\n-                for (int i = 0; i < x500Issuers.length; i++) {\n-                    if (certIssuers.contains(issuers[i])) {\n-                        aliases.add(alias);\n-                        if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n-                            SSLLogger.fine(\"matching alias: \" + alias);\n-                        }\n-                        break;\n-                    }\n-                }\n+            if (results == null) {\n+                results = new ArrayList<>();\n@@ -403,1 +296,0 @@\n-        }\n@@ -405,3 +297,2 @@\n-        String[] aliasStrings = aliases.toArray(STRING0);\n-        return ((aliasStrings.length == 0) ? null : aliasStrings);\n-    }\n+            results.add(status);\n+        }\n@@ -409,16 +300,3 @@\n-    \/*\n-     * Convert an array of Principals to an array of X500Principals, if\n-     * possible. Principals that cannot be converted are ignored.\n-     *\/\n-    private static X500Principal[] convertPrincipals(Principal[] principals) {\n-        List<X500Principal> list = new ArrayList<>(principals.length);\n-        for (int i = 0; i < principals.length; i++) {\n-            Principal p = principals[i];\n-            if (p instanceof X500Principal) {\n-                list.add((X500Principal)p);\n-            } else {\n-                try {\n-                    list.add(new X500Principal(p.getName()));\n-                } catch (IllegalArgumentException e) {\n-                    \/\/ ignore\n-                }\n+        if (results == null) {\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n+                SSLLogger.fine(\"KeyMgr: no matching key found\");\n@@ -426,0 +304,1 @@\n+            return null;\n@@ -427,1 +306,4 @@\n-        return list.toArray(new X500Principal[0]);\n+\n+        \/\/ Sort results in order of alias preference.\n+        Collections.sort(results);\n+        return results.stream().map(r -> r.alias).toArray(String[]::new);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SunX509KeyManagerImpl.java","additions":79,"deletions":197,"binary":false,"changes":276,"status":"modified"},{"patch":"@@ -0,0 +1,579 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.ssl;\n+\n+import java.net.Socket;\n+import java.security.AlgorithmConstraints;\n+import java.security.Principal;\n+import java.security.cert.CertPathValidatorException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+import javax.net.ssl.ExtendedSSLSession;\n+import javax.net.ssl.SNIHostName;\n+import javax.net.ssl.SNIServerName;\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.SSLSession;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.StandardConstants;\n+import javax.net.ssl.X509ExtendedKeyManager;\n+import javax.security.auth.x500.X500Principal;\n+import sun.security.provider.certpath.AlgorithmChecker;\n+import sun.security.util.KnownOIDs;\n+import sun.security.validator.Validator;\n+\n+\/*\n+ * Layer that adds algorithm constraints and certificate checking functionality\n+ * to a key manager:\n+ * 1) Check against peer supported certificate signature algorithms (sent with\n+ *    \"signature_algorithms_cert\" TLS extension).\n+ * 2) Check against local TLS algorithm constraints (\"java.security\" config\n+ *    file).\n+ * 3) Mark alias results based on validity period and certificate extensions,\n+ *    so results can be sorted to find the best match. See \"CheckResult\" and\n+ *    \"EntryStatus\" for details.\n+ *\/\n+\n+abstract class X509KeyManagerCertChecking extends X509ExtendedKeyManager {\n+\n+    \/\/ Indicates whether we should skip the certificate checks.\n+    private final boolean checksDisabled;\n+\n+    protected X509KeyManagerCertChecking() {\n+        checksDisabled = isCheckingDisabled();\n+    }\n+\n+    abstract boolean isCheckingDisabled();\n+\n+    \/\/ Entry point to do all certificate checks.\n+    protected EntryStatus checkAlias(int keyStoreIndex, String alias,\n+            Certificate[] chain, Date verificationDate, List<KeyType> keyTypes,\n+            Set<X500Principal> issuerSet, CheckType checkType,\n+            AlgorithmConstraints constraints,\n+            List<SNIServerName> requestedServerNames, String idAlgorithm) {\n+\n+        \/\/ --- Mandatory checks ---\n+\n+        if ((chain == null) || (chain.length == 0)) {\n+            return null;\n+        }\n+\n+        for (Certificate cert : chain) {\n+            if (!(cert instanceof X509Certificate)) {\n+                \/\/ Not an X509Certificate, ignore this alias\n+                return null;\n+            }\n+        }\n+\n+        \/\/ Check key type, get key type index.\n+        int keyIndex = -1;\n+        int j = 0;\n+\n+        for (KeyType keyType : keyTypes) {\n+            if (keyType.matches(chain)) {\n+                keyIndex = j;\n+                break;\n+            }\n+            j++;\n+        }\n+\n+        if (keyIndex == -1) {\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n+                SSLLogger.fine(\"Ignore alias \" + alias\n+                        + \": key algorithm does not match\");\n+            }\n+            return null;\n+        }\n+\n+        \/\/ Check issuers\n+        if (issuerSet != null && !issuerSet.isEmpty()) {\n+            boolean found = false;\n+            for (Certificate cert : chain) {\n+                X509Certificate xcert = (X509Certificate) cert;\n+                if (issuerSet.contains(xcert.getIssuerX500Principal())) {\n+                    found = true;\n+                    break;\n+                }\n+            }\n+            if (!found) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n+                    SSLLogger.fine(\n+                            \"Ignore alias \" + alias\n+                                    + \": issuers do not match\");\n+                }\n+                return null;\n+            }\n+        }\n+\n+        \/\/ --- Optional checks, depending on \"checksDisabled\" toggle ---\n+\n+        \/\/ Check the algorithm constraints\n+        if (constraints != null &&\n+                !conformsToAlgorithmConstraints(constraints, chain,\n+                        checkType.getValidator())) {\n+\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n+                SSLLogger.fine(\"Ignore alias \" + alias +\n+                        \": certificate chain does not conform to \" +\n+                        \"algorithm constraints\");\n+            }\n+            return null;\n+        }\n+\n+        \/\/ Endpoint certificate check\n+        CheckResult checkResult = certificateCheck(checkType,\n+                (X509Certificate) chain[0],\n+                verificationDate == null ? new Date() : verificationDate,\n+                requestedServerNames, idAlgorithm);\n+\n+        return new EntryStatus(\n+                keyStoreIndex, keyIndex, alias, chain, checkResult);\n+    }\n+\n+    \/\/ Gets algorithm constraints of the socket.\n+    protected AlgorithmConstraints getAlgorithmConstraints(Socket socket) {\n+\n+        if (checksDisabled) {\n+            return null;\n+        }\n+\n+        if (socket != null && socket.isConnected() &&\n+                socket instanceof SSLSocket sslSocket) {\n+\n+            SSLSession session = sslSocket.getHandshakeSession();\n+\n+            if (session != null) {\n+                if (ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {\n+                    String[] peerSupportedSignAlgs = null;\n+\n+                    if (session instanceof ExtendedSSLSession extSession) {\n+                        \/\/ Peer supported certificate signature algorithms\n+                        \/\/ sent with \"signature_algorithms_cert\" TLS extension.\n+                        peerSupportedSignAlgs =\n+                                extSession.getPeerSupportedSignatureAlgorithms();\n+                    }\n+\n+                    return SSLAlgorithmConstraints.forSocket(\n+                            sslSocket, peerSupportedSignAlgs, true);\n+                }\n+            }\n+\n+            return SSLAlgorithmConstraints.forSocket(sslSocket, true);\n+        }\n+\n+        return SSLAlgorithmConstraints.DEFAULT;\n+    }\n+\n+    \/\/ Gets algorithm constraints of the engine.\n+    protected AlgorithmConstraints getAlgorithmConstraints(SSLEngine engine) {\n+\n+        if (checksDisabled) {\n+            return null;\n+        }\n+\n+        if (engine != null) {\n+            SSLSession session = engine.getHandshakeSession();\n+            if (session != null) {\n+                if (ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {\n+                    String[] peerSupportedSignAlgs = null;\n+\n+                    if (session instanceof ExtendedSSLSession extSession) {\n+                        \/\/ Peer supported certificate signature algorithms\n+                        \/\/ sent with \"signature_algorithms_cert\" TLS extension.\n+                        peerSupportedSignAlgs =\n+                                extSession.getPeerSupportedSignatureAlgorithms();\n+                    }\n+\n+                    return SSLAlgorithmConstraints.forEngine(\n+                            engine, peerSupportedSignAlgs, true);\n+                }\n+            }\n+        }\n+\n+        return SSLAlgorithmConstraints.forEngine(engine, true);\n+    }\n+\n+    \/\/ Algorithm constraints check.\n+    private boolean conformsToAlgorithmConstraints(\n+            AlgorithmConstraints constraints, Certificate[] chain,\n+            String variant) {\n+\n+        if (checksDisabled) {\n+            return true;\n+        }\n+\n+        AlgorithmChecker checker = new AlgorithmChecker(constraints, variant);\n+        try {\n+            checker.init(false);\n+        } catch (CertPathValidatorException cpve) {\n+            \/\/ unlikely to happen\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n+                SSLLogger.fine(\n+                        \"Cannot initialize algorithm constraints checker\",\n+                        cpve);\n+            }\n+\n+            return false;\n+        }\n+\n+        \/\/ It is a forward checker, so we need to check from trust to target.\n+        for (int i = chain.length - 1; i >= 0; i--) {\n+            Certificate cert = chain[i];\n+            try {\n+                \/\/ We don't care about the unresolved critical extensions.\n+                checker.check(cert, Collections.emptySet());\n+            } catch (CertPathValidatorException cpve) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n+                    SSLLogger.fine(\"Certificate does not conform to \" +\n+                            \"algorithm constraints\", cert, cpve);\n+                }\n+\n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    \/\/ Certificate check.\n+    private CheckResult certificateCheck(\n+            CheckType checkType, X509Certificate cert, Date date,\n+            List<SNIServerName> serverNames, String idAlgorithm) {\n+        return checksDisabled ? CheckResult.OK\n+                : checkType.check(cert, date, serverNames, idAlgorithm);\n+    }\n+\n+    \/\/ enum for the result of the extension check\n+    \/\/ NOTE: the order of the constants is important as they are used\n+    \/\/ for sorting, i.e. OK is best, followed by EXPIRED and EXTENSION_MISMATCH\n+    enum CheckResult {\n+        OK,                     \/\/ ok or not checked\n+        INSENSITIVE,            \/\/ server name indication insensitive\n+        EXPIRED,                \/\/ extensions valid but cert expired\n+        EXTENSION_MISMATCH,     \/\/ extensions invalid (expiration not checked)\n+    }\n+\n+    \/\/ enum for the type of certificate check we want to perform\n+    \/\/ (client or server)\n+    \/\/ also includes the check code itself\n+    enum CheckType {\n+\n+        \/\/ enum constant for \"no check\" (currently not used)\n+        NONE(Collections.emptySet()),\n+\n+        \/\/ enum constant for \"tls client\" check\n+        \/\/ valid EKU for TLS client: any, tls_client\n+        CLIENT(new HashSet<>(List.of(\n+                KnownOIDs.anyExtendedKeyUsage.value(),\n+                KnownOIDs.clientAuth.value()\n+        ))),\n+\n+        \/\/ enum constant for \"tls server\" check\n+        \/\/ valid EKU for TLS server: any, tls_server, ns_sgc, ms_sgc\n+        SERVER(new HashSet<>(List.of(\n+                KnownOIDs.anyExtendedKeyUsage.value(),\n+                KnownOIDs.serverAuth.value(),\n+                KnownOIDs.NETSCAPE_ExportApproved.value(),\n+                KnownOIDs.MICROSOFT_ExportApproved.value()\n+        )));\n+\n+        \/\/ set of valid EKU values for this type\n+        final Set<String> validEku;\n+\n+        CheckType(Set<String> validEku) {\n+            this.validEku = validEku;\n+        }\n+\n+        private static boolean getBit(boolean[] keyUsage, int bit) {\n+            return (bit < keyUsage.length) && keyUsage[bit];\n+        }\n+\n+        \/\/ Check if this certificate is appropriate for this type of use.\n+        \/\/ First check extensions, if they match then check expiration.\n+        \/\/ NOTE: `conformsToAlgorithmConstraints` call above also does some\n+        \/\/ basic keyUsage checks.\n+        CheckResult check(X509Certificate cert, Date date,\n+                List<SNIServerName> serverNames, String idAlgorithm) {\n+\n+            if (this == NONE) {\n+                return CheckResult.OK;\n+            }\n+\n+            \/\/ check extensions\n+            try {\n+                \/\/ check extended key usage\n+                List<String> certEku = cert.getExtendedKeyUsage();\n+                if ((certEku != null) &&\n+                        Collections.disjoint(validEku, certEku)) {\n+                    \/\/ if extension is present and does not contain any of\n+                    \/\/ the valid EKU OIDs, return extension_mismatch\n+                    return CheckResult.EXTENSION_MISMATCH;\n+                }\n+\n+                \/\/ check key usage\n+                boolean[] ku = cert.getKeyUsage();\n+                if (ku != null) {\n+                    String algorithm = cert.getPublicKey().getAlgorithm();\n+                    boolean supportsDigitalSignature = getBit(ku, 0);\n+                    switch (algorithm) {\n+                        case \"RSA\":\n+                            \/\/ require either signature bit\n+                            \/\/ or if server also allow key encipherment bit\n+                            if (!supportsDigitalSignature) {\n+                                if (this == CLIENT || !getBit(ku, 2)) {\n+                                    return CheckResult.EXTENSION_MISMATCH;\n+                                }\n+                            }\n+                            break;\n+                        case \"RSASSA-PSS\":\n+                            if (!supportsDigitalSignature && (this == SERVER)) {\n+                                return CheckResult.EXTENSION_MISMATCH;\n+                            }\n+                            break;\n+                        case \"DSA\":\n+                            \/\/ require signature bit\n+                            if (!supportsDigitalSignature) {\n+                                return CheckResult.EXTENSION_MISMATCH;\n+                            }\n+                            break;\n+                        case \"DH\":\n+                            \/\/ require key agreement bit\n+                            if (!getBit(ku, 4)) {\n+                                return CheckResult.EXTENSION_MISMATCH;\n+                            }\n+                            break;\n+                        case \"EC\":\n+                            \/\/ require signature bit\n+                            if (!supportsDigitalSignature) {\n+                                return CheckResult.EXTENSION_MISMATCH;\n+                            }\n+                            \/\/ For servers, also require key agreement.\n+                            \/\/ This is not totally accurate as the keyAgreement\n+                            \/\/ bit is only necessary for static ECDH key\n+                            \/\/ exchange and not ephemeral ECDH. We leave it in\n+                            \/\/ for now until there are signs that this check\n+                            \/\/ causes problems for real world EC certificates.\n+                            if (this == SERVER && !getBit(ku, 4)) {\n+                                return CheckResult.EXTENSION_MISMATCH;\n+                            }\n+                            break;\n+                    }\n+                }\n+            } catch (CertificateException e) {\n+                \/\/ extensions unparseable, return failure\n+                return CheckResult.EXTENSION_MISMATCH;\n+            }\n+\n+            try {\n+                cert.checkValidity(date);\n+            } catch (CertificateException e) {\n+                return CheckResult.EXPIRED;\n+            }\n+\n+            if (serverNames != null && !serverNames.isEmpty()) {\n+                for (SNIServerName serverName : serverNames) {\n+                    if (serverName.getType() ==\n+                            StandardConstants.SNI_HOST_NAME) {\n+                        if (!(serverName instanceof SNIHostName)) {\n+                            try {\n+                                serverName = new SNIHostName(\n+                                        serverName.getEncoded());\n+                            } catch (IllegalArgumentException iae) {\n+                                \/\/ unlikely to happen, just in case ...\n+                                if (SSLLogger.isOn &&\n+                                        SSLLogger.isOn(\"keymanager\")) {\n+                                    SSLLogger.fine(\"Illegal server name: \"\n+                                            + serverName);\n+                                }\n+\n+                                return CheckResult.INSENSITIVE;\n+                            }\n+                        }\n+                        String hostname =\n+                                ((SNIHostName) serverName).getAsciiName();\n+\n+                        try {\n+                            X509TrustManagerImpl.checkIdentity(hostname,\n+                                    cert, idAlgorithm);\n+                        } catch (CertificateException e) {\n+                            if (SSLLogger.isOn &&\n+                                    SSLLogger.isOn(\"keymanager\")) {\n+                                SSLLogger.fine(\n+                                        \"Certificate identity does not match \"\n+                                                + \"Server Name Indication (SNI): \"\n+                                                + hostname);\n+                            }\n+                            return CheckResult.INSENSITIVE;\n+                        }\n+\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            return CheckResult.OK;\n+        }\n+\n+        String getValidator() {\n+            if (this == CLIENT) {\n+                return Validator.VAR_TLS_CLIENT;\n+            } else if (this == SERVER) {\n+                return Validator.VAR_TLS_SERVER;\n+            }\n+            return Validator.VAR_GENERIC;\n+        }\n+    }\n+\n+    \/\/ A candidate match.\n+    \/\/ Identifies the entry by key store index and alias\n+    \/\/ and includes the result of the certificate check.\n+    protected static class EntryStatus implements Comparable<EntryStatus> {\n+\n+        final int keyStoreIndex;\n+        final int keyIndex;\n+        final String alias;\n+        final CheckResult checkResult;\n+\n+        EntryStatus(int keyStoreIndex, int keyIndex, String alias,\n+                Certificate[] chain, CheckResult checkResult) {\n+            this.keyStoreIndex = keyStoreIndex;\n+            this.keyIndex = keyIndex;\n+            this.alias = alias;\n+            this.checkResult = checkResult;\n+        }\n+\n+        @Override\n+        public int compareTo(EntryStatus other) {\n+            int result = this.checkResult.compareTo(other.checkResult);\n+            return (result == 0) ? (this.keyIndex - other.keyIndex) : result;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String s = alias + \" (verified: \" + checkResult + \")\";\n+            if (keyStoreIndex == 0) {\n+                return s;\n+            } else {\n+                return \"KeyStore #\" + keyStoreIndex + \", alias: \" + s;\n+            }\n+        }\n+    }\n+\n+    \/\/ Class to help verify that the public key algorithm (and optionally\n+    \/\/ the signature algorithm) of a certificate matches what we need.\n+    protected static class KeyType {\n+\n+        final String keyAlgorithm;\n+\n+        \/\/ In TLS 1.2, the signature algorithm  has been obsoleted by the\n+        \/\/ supported_signature_algorithms, and the certificate type no longer\n+        \/\/ restricts the algorithm used to sign the certificate.\n+        \/\/\n+        \/\/ However, because we don't support certificate type checking other\n+        \/\/ than rsa_sign, dss_sign and ecdsa_sign, we don't have to check the\n+        \/\/ protocol version here.\n+        final String sigKeyAlgorithm;\n+\n+        KeyType(String algorithm) {\n+            int k = algorithm.indexOf('_');\n+            if (k == -1) {\n+                keyAlgorithm = algorithm;\n+                sigKeyAlgorithm = null;\n+            } else {\n+                keyAlgorithm = algorithm.substring(0, k);\n+                sigKeyAlgorithm = algorithm.substring(k + 1);\n+            }\n+        }\n+\n+        boolean matches(Certificate[] chain) {\n+            if (!chain[0].getPublicKey().getAlgorithm().equals(keyAlgorithm)) {\n+                return false;\n+            }\n+            if (sigKeyAlgorithm == null) {\n+                return true;\n+            }\n+            if (chain.length > 1) {\n+                \/\/ if possible, check the public key in the issuer cert\n+                return sigKeyAlgorithm.equals(\n+                        chain[1].getPublicKey().getAlgorithm());\n+            } else {\n+                \/\/ Check the signature algorithm of the certificate itself.\n+                \/\/ Look for the \"withRSA\" in \"SHA1withRSA\", etc.\n+                X509Certificate issuer = (X509Certificate) chain[0];\n+                String sigAlgName =\n+                        issuer.getSigAlgName().toUpperCase(Locale.ENGLISH);\n+                String pattern =\n+                        \"WITH\" + sigKeyAlgorithm.toUpperCase(Locale.ENGLISH);\n+                return sigAlgName.endsWith(pattern);\n+            }\n+        }\n+    }\n+\n+    \/\/ Make a list of key types.\n+    protected static List<KeyType> getKeyTypes(String... keyTypes) {\n+        if ((keyTypes == null) ||\n+                (keyTypes.length == 0) || (keyTypes[0] == null)) {\n+            return null;\n+        }\n+        List<KeyType> list = new ArrayList<>(keyTypes.length);\n+        for (String keyType : keyTypes) {\n+            list.add(new KeyType(keyType));\n+        }\n+        return list;\n+    }\n+\n+    \/\/ Make a set out of the array.\n+    protected static Set<X500Principal> getIssuerSet(Principal[] issuers) {\n+\n+        if (issuers != null && issuers.length != 0) {\n+            Set<X500Principal> ret = new HashSet<>(issuers.length);\n+\n+            for (Principal p : issuers) {\n+                if (p instanceof X500Principal) {\n+                    ret.add((X500Principal) p);\n+                } else {\n+                    \/\/ Normally, this will never happen but try to recover if\n+                    \/\/ it does.\n+                    try {\n+                        ret.add(new X500Principal(p.getName()));\n+                    } catch (Exception e) {\n+                        \/\/ ignore\n+                    }\n+                }\n+            }\n+            return ret.isEmpty() ? null : ret;\n+        } else {\n+            return null;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/X509KeyManagerCertChecking.java","additions":579,"deletions":0,"binary":false,"changes":579,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import java.security.KeyStoreException;\n@@ -37,3 +38,0 @@\n-import java.security.cert.CertPathValidatorException;\n-import java.security.cert.Certificate;\n-import java.security.cert.CertificateException;\n@@ -44,3 +42,1 @@\n-import sun.security.provider.certpath.AlgorithmChecker;\n-import sun.security.validator.Validator;\n-import sun.security.util.KnownOIDs;\n+import javax.security.auth.x500.X500Principal;\n@@ -65,2 +61,2 @@\n-final class X509KeyManagerImpl extends X509ExtendedKeyManager\n-        implements X509KeyManager {\n+\n+final class X509KeyManagerImpl extends X509KeyManagerCertChecking {\n@@ -87,2 +83,1 @@\n-        entryCacheMap = Collections.synchronizedMap\n-                        (new SizedMap<>());\n+        entryCacheMap = Collections.synchronizedMap(new SizedMap<>());\n@@ -91,2 +86,6 @@\n-    \/\/ LinkedHashMap with a max size of 10\n-    \/\/ see LinkedHashMap JavaDocs\n+    @Override\n+    protected boolean isCheckingDisabled() {\n+        return false;\n+    }\n+\n+    \/\/ LinkedHashMap with a max size of 10, see LinkedHashMap JavaDocs\n@@ -123,1 +122,1 @@\n-                        getAlgorithmConstraints(socket));\n+                getAlgorithmConstraints(socket), null, null);\n@@ -130,1 +129,1 @@\n-                        getAlgorithmConstraints(engine));\n+                getAlgorithmConstraints(engine), null, null);\n@@ -171,1 +170,1 @@\n-        return getAliases(keyType, issuers, CheckType.CLIENT, null);\n+        return getAliases(keyType, issuers, CheckType.CLIENT);\n@@ -176,1 +175,1 @@\n-        return getAliases(keyType, issuers, CheckType.SERVER, null);\n+        return getAliases(keyType, issuers, CheckType.SERVER);\n@@ -183,49 +182,0 @@\n-    \/\/ Gets algorithm constraints of the socket.\n-    private AlgorithmConstraints getAlgorithmConstraints(Socket socket) {\n-        if (socket != null && socket.isConnected() &&\n-                socket instanceof SSLSocket sslSocket) {\n-\n-            SSLSession session = sslSocket.getHandshakeSession();\n-\n-            if (session != null) {\n-                if (ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {\n-                    String[] peerSupportedSignAlgs = null;\n-\n-                    if (session instanceof ExtendedSSLSession extSession) {\n-                        peerSupportedSignAlgs =\n-                            extSession.getPeerSupportedSignatureAlgorithms();\n-                    }\n-\n-                    return SSLAlgorithmConstraints.forSocket(\n-                        sslSocket, peerSupportedSignAlgs, true);\n-                }\n-            }\n-\n-            return SSLAlgorithmConstraints.forSocket(sslSocket, true);\n-        }\n-\n-        return SSLAlgorithmConstraints.DEFAULT;\n-    }\n-\n-    \/\/ Gets algorithm constraints of the engine.\n-    private AlgorithmConstraints getAlgorithmConstraints(SSLEngine engine) {\n-        if (engine != null) {\n-            SSLSession session = engine.getHandshakeSession();\n-            if (session != null) {\n-                if (ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {\n-                    String[] peerSupportedSignAlgs = null;\n-\n-                    if (session instanceof ExtendedSSLSession extSession) {\n-                        peerSupportedSignAlgs =\n-                            extSession.getPeerSupportedSignatureAlgorithms();\n-                    }\n-\n-                    return SSLAlgorithmConstraints.forEngine(\n-                        engine, peerSupportedSignAlgs, true);\n-                }\n-            }\n-        }\n-\n-        return SSLAlgorithmConstraints.forEngine(engine, true);\n-    }\n-\n@@ -237,1 +187,1 @@\n-        return uidCounter.incrementAndGet() + \".\" + entry.builderIndex + \".\"\n+        return uidCounter.incrementAndGet() + \".\" + entry.keyStoreIndex + \".\"\n@@ -282,62 +232,0 @@\n-    \/\/ Class to help verify that the public key algorithm (and optionally\n-    \/\/ the signature algorithm) of a certificate matches what we need.\n-    private static class KeyType {\n-\n-        final String keyAlgorithm;\n-\n-        \/\/ In TLS 1.2, the signature algorithm  has been obsoleted by the\n-        \/\/ supported_signature_algorithms, and the certificate type no longer\n-        \/\/ restricts the algorithm used to sign the certificate.\n-        \/\/\n-        \/\/ However, because we don't support certificate type checking other\n-        \/\/ than rsa_sign, dss_sign and ecdsa_sign, we don't have to check the\n-        \/\/ protocol version here.\n-        final String sigKeyAlgorithm;\n-\n-        KeyType(String algorithm) {\n-            int k = algorithm.indexOf('_');\n-            if (k == -1) {\n-                keyAlgorithm = algorithm;\n-                sigKeyAlgorithm = null;\n-            } else {\n-                keyAlgorithm = algorithm.substring(0, k);\n-                sigKeyAlgorithm = algorithm.substring(k + 1);\n-            }\n-        }\n-\n-        boolean matches(Certificate[] chain) {\n-            if (!chain[0].getPublicKey().getAlgorithm().equals(keyAlgorithm)) {\n-                return false;\n-            }\n-            if (sigKeyAlgorithm == null) {\n-                return true;\n-            }\n-            if (chain.length > 1) {\n-                \/\/ if possible, check the public key in the issuer cert\n-                return sigKeyAlgorithm.equals(\n-                        chain[1].getPublicKey().getAlgorithm());\n-            } else {\n-                \/\/ Check the signature algorithm of the certificate itself.\n-                \/\/ Look for the \"withRSA\" in \"SHA1withRSA\", etc.\n-                X509Certificate issuer = (X509Certificate)chain[0];\n-                String sigAlgName =\n-                        issuer.getSigAlgName().toUpperCase(Locale.ENGLISH);\n-                String pattern =\n-                        \"WITH\" + sigKeyAlgorithm.toUpperCase(Locale.ENGLISH);\n-                return sigAlgName.contains(pattern);\n-            }\n-        }\n-    }\n-\n-    private static List<KeyType> getKeyTypes(String ... keyTypes) {\n-        if ((keyTypes == null) ||\n-                (keyTypes.length == 0) || (keyTypes[0] == null)) {\n-            return null;\n-        }\n-        List<KeyType> list = new ArrayList<>(keyTypes.length);\n-        for (String keyType : keyTypes) {\n-            list.add(new KeyType(keyType));\n-        }\n-        return list;\n-    }\n-\n@@ -357,7 +245,0 @@\n-    private String chooseAlias(List<KeyType> keyTypeList, Principal[] issuers,\n-            CheckType checkType, AlgorithmConstraints constraints) {\n-\n-        return chooseAlias(keyTypeList, issuers,\n-                                    checkType, constraints, null, null);\n-    }\n-\n@@ -372,1 +253,1 @@\n-        Set<Principal> issuerSet = getIssuerSet(issuers);\n+        Set<X500Principal> issuerSet = getIssuerSet(issuers);\n@@ -374,0 +255,1 @@\n+\n@@ -393,1 +275,1 @@\n-            } catch (Exception e) {\n+            } catch (KeyStoreException e) {\n@@ -418,2 +300,3 @@\n-    public String[] getAliases(String keyType, Principal[] issuers,\n-            CheckType checkType, AlgorithmConstraints constraints) {\n+    private String[] getAliases(\n+            String keyType, Principal[] issuers, CheckType checkType) {\n+\n@@ -424,1 +307,1 @@\n-        Set<Principal> issuerSet = getIssuerSet(issuers);\n+        Set<X500Principal> issuerSet = getIssuerSet(issuers);\n@@ -427,0 +310,1 @@\n+\n@@ -430,2 +314,1 @@\n-                                    issuerSet, true, checkType, constraints,\n-                                    null, null);\n+                        issuerSet, true, checkType, null, null, null);\n@@ -438,1 +321,1 @@\n-            } catch (Exception e) {\n+            } catch (KeyStoreException e) {\n@@ -465,226 +348,0 @@\n-    \/\/ make a Set out of the array\n-    private Set<Principal> getIssuerSet(Principal[] issuers) {\n-        if ((issuers != null) && (issuers.length != 0)) {\n-            return new HashSet<>(Arrays.asList(issuers));\n-        } else {\n-            return null;\n-        }\n-    }\n-\n-    \/\/ a candidate match\n-    \/\/ identifies the entry by builder and alias\n-    \/\/ and includes the result of the certificate check\n-    private static class EntryStatus implements Comparable<EntryStatus> {\n-\n-        final int builderIndex;\n-        final int keyIndex;\n-        final String alias;\n-        final CheckResult checkResult;\n-\n-        EntryStatus(int builderIndex, int keyIndex, String alias,\n-                Certificate[] chain, CheckResult checkResult) {\n-            this.builderIndex = builderIndex;\n-            this.keyIndex = keyIndex;\n-            this.alias = alias;\n-            this.checkResult = checkResult;\n-        }\n-\n-        @Override\n-        public int compareTo(EntryStatus other) {\n-            int result = this.checkResult.compareTo(other.checkResult);\n-            return (result == 0) ? (this.keyIndex - other.keyIndex) : result;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            String s = alias + \" (verified: \" + checkResult + \")\";\n-            if (builderIndex == 0) {\n-                return s;\n-            } else {\n-                return \"Builder #\" + builderIndex + \", alias: \" + s;\n-            }\n-        }\n-    }\n-\n-    \/\/ enum for the type of certificate check we want to perform\n-    \/\/ (client or server)\n-    \/\/ also includes the check code itself\n-    private enum CheckType {\n-\n-        \/\/ enum constant for \"no check\" (currently not used)\n-        NONE(Collections.emptySet()),\n-\n-        \/\/ enum constant for \"tls client\" check\n-        \/\/ valid EKU for TLS client: any, tls_client\n-        CLIENT(new HashSet<>(List.of(\n-                KnownOIDs.anyExtendedKeyUsage.value(),\n-                KnownOIDs.clientAuth.value()\n-        ))),\n-\n-        \/\/ enum constant for \"tls server\" check\n-        \/\/ valid EKU for TLS server: any, tls_server, ns_sgc, ms_sgc\n-        SERVER(new HashSet<>(List.of(\n-                KnownOIDs.anyExtendedKeyUsage.value(),\n-                KnownOIDs.serverAuth.value(),\n-                KnownOIDs.NETSCAPE_ExportApproved.value(),\n-                KnownOIDs.MICROSOFT_ExportApproved.value()\n-        )));\n-\n-        \/\/ set of valid EKU values for this type\n-        final Set<String> validEku;\n-\n-        CheckType(Set<String> validEku) {\n-            this.validEku = validEku;\n-        }\n-\n-        private static boolean getBit(boolean[] keyUsage, int bit) {\n-            return (bit < keyUsage.length) && keyUsage[bit];\n-        }\n-\n-        \/\/ Check if this certificate is appropriate for this type of use\n-        \/\/ first check extensions, if they match, check expiration.\n-        \/\/\n-        \/\/ Note: we may want to move this code into the sun.security.validator\n-        \/\/ package\n-        CheckResult check(X509Certificate cert, Date date,\n-                List<SNIServerName> serverNames, String idAlgorithm) {\n-\n-            if (this == NONE) {\n-                return CheckResult.OK;\n-            }\n-\n-            \/\/ check extensions\n-            try {\n-                \/\/ check extended key usage\n-                List<String> certEku = cert.getExtendedKeyUsage();\n-                if ((certEku != null) &&\n-                        Collections.disjoint(validEku, certEku)) {\n-                    \/\/ if extension is present and does not contain any of\n-                    \/\/ the valid EKU OIDs, return extension_mismatch\n-                    return CheckResult.EXTENSION_MISMATCH;\n-                }\n-\n-                \/\/ check key usage\n-                boolean[] ku = cert.getKeyUsage();\n-                if (ku != null) {\n-                    String algorithm = cert.getPublicKey().getAlgorithm();\n-                    boolean supportsDigitalSignature = getBit(ku, 0);\n-                    switch (algorithm) {\n-                        case \"RSA\":\n-                            \/\/ require either signature bit\n-                            \/\/ or if server also allow key encipherment bit\n-                            if (!supportsDigitalSignature) {\n-                                if (this == CLIENT || !getBit(ku, 2)) {\n-                                    return CheckResult.EXTENSION_MISMATCH;\n-                                }\n-                            }\n-                            break;\n-                        case \"RSASSA-PSS\":\n-                            if (!supportsDigitalSignature && (this == SERVER)) {\n-                                return CheckResult.EXTENSION_MISMATCH;\n-                            }\n-                            break;\n-                        case \"DSA\":\n-                            \/\/ require signature bit\n-                            if (!supportsDigitalSignature) {\n-                                return CheckResult.EXTENSION_MISMATCH;\n-                            }\n-                            break;\n-                        case \"DH\":\n-                            \/\/ require keyagreement bit\n-                            if (!getBit(ku, 4)) {\n-                                return CheckResult.EXTENSION_MISMATCH;\n-                            }\n-                            break;\n-                        case \"EC\":\n-                            \/\/ require signature bit\n-                            if (!supportsDigitalSignature) {\n-                                return CheckResult.EXTENSION_MISMATCH;\n-                            }\n-                            \/\/ For servers, also require key agreement.\n-                            \/\/ This is not totally accurate as the keyAgreement\n-                            \/\/ bit is only necessary for static ECDH key\n-                            \/\/ exchange and not ephemeral ECDH. We leave it in\n-                            \/\/ for now until there are signs that this check\n-                            \/\/ causes problems for real world EC certificates.\n-                            if (this == SERVER && !getBit(ku, 4)) {\n-                                return CheckResult.EXTENSION_MISMATCH;\n-                            }\n-                            break;\n-                    }\n-                }\n-            } catch (CertificateException e) {\n-                \/\/ extensions unparseable, return failure\n-                return CheckResult.EXTENSION_MISMATCH;\n-            }\n-\n-            try {\n-                cert.checkValidity(date);\n-            } catch (CertificateException e) {\n-                return CheckResult.EXPIRED;\n-            }\n-\n-            if (serverNames != null && !serverNames.isEmpty()) {\n-                for (SNIServerName serverName : serverNames) {\n-                    if (serverName.getType() ==\n-                                StandardConstants.SNI_HOST_NAME) {\n-                        if (!(serverName instanceof SNIHostName)) {\n-                            try {\n-                                serverName =\n-                                    new SNIHostName(serverName.getEncoded());\n-                            } catch (IllegalArgumentException iae) {\n-                                \/\/ unlikely to happen, just in case ...\n-                                if (SSLLogger.isOn &&\n-                                        SSLLogger.isOn(\"keymanager\")) {\n-                                    SSLLogger.fine(\n-                                       \"Illegal server name: \" + serverName);\n-                                }\n-\n-                                return CheckResult.INSENSITIVE;\n-                            }\n-                        }\n-                        String hostname =\n-                                ((SNIHostName)serverName).getAsciiName();\n-\n-                        try {\n-                            X509TrustManagerImpl.checkIdentity(hostname,\n-                                                        cert, idAlgorithm);\n-                        } catch (CertificateException e) {\n-                            if (SSLLogger.isOn &&\n-                                    SSLLogger.isOn(\"keymanager\")) {\n-                                SSLLogger.fine(\n-                                    \"Certificate identity does not match \" +\n-                                    \"Server Name Indication (SNI): \" +\n-                                    hostname);\n-                            }\n-                            return CheckResult.INSENSITIVE;\n-                        }\n-\n-                        break;\n-                    }\n-                }\n-            }\n-\n-            return CheckResult.OK;\n-        }\n-\n-        public String getValidator() {\n-            if (this == CLIENT) {\n-                return Validator.VAR_TLS_CLIENT;\n-            } else if (this == SERVER) {\n-                return Validator.VAR_TLS_SERVER;\n-            }\n-            return Validator.VAR_GENERIC;\n-        }\n-    }\n-\n-    \/\/ enum for the result of the extension check\n-    \/\/ NOTE: the order of the constants is important as they are used\n-    \/\/ for sorting, i.e. OK is best, followed by EXPIRED and EXTENSION_MISMATCH\n-    private enum CheckResult {\n-        OK,                     \/\/ ok or not checked\n-        INSENSITIVE,            \/\/ server name indication insensitive\n-        EXPIRED,                \/\/ extensions valid but cert expired\n-        EXTENSION_MISMATCH,     \/\/ extensions invalid (expiration not checked)\n-    }\n-\n@@ -718,1 +375,1 @@\n-            List<KeyType> keyTypes, Set<Principal> issuerSet,\n+            List<KeyType> keyTypes, Set<X500Principal> issuerSet,\n@@ -722,1 +379,1 @@\n-            String idAlgorithm) throws Exception {\n+            String idAlgorithm) throws KeyStoreException {\n@@ -727,1 +384,0 @@\n-        Date date = verificationDate;\n@@ -729,0 +385,1 @@\n+\n@@ -730,0 +387,1 @@\n+\n@@ -731,0 +389,1 @@\n+\n@@ -736,59 +395,4 @@\n-            Certificate[] chain = ks.getCertificateChain(alias);\n-            if ((chain == null) || (chain.length == 0)) {\n-                \/\/ must be secret key entry, ignore\n-                continue;\n-            }\n-\n-            boolean incompatible = false;\n-            for (Certificate cert : chain) {\n-                if (!(cert instanceof X509Certificate)) {\n-                    \/\/ not an X509Certificate, ignore this alias\n-                    incompatible = true;\n-                    break;\n-                }\n-            }\n-            if (incompatible) {\n-                continue;\n-            }\n-\n-            \/\/ check keytype\n-            int keyIndex = -1;\n-            int j = 0;\n-            for (KeyType keyType : keyTypes) {\n-                if (keyType.matches(chain)) {\n-                    keyIndex = j;\n-                    break;\n-                }\n-                j++;\n-            }\n-            if (keyIndex == -1) {\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n-                    SSLLogger.fine(\"Ignore alias \" + alias\n-                                + \": key algorithm does not match\");\n-                }\n-                continue;\n-            }\n-            \/\/ check issuers\n-            if (issuerSet != null) {\n-                boolean found = false;\n-                for (Certificate cert : chain) {\n-                    X509Certificate xcert = (X509Certificate)cert;\n-                    if (issuerSet.contains(xcert.getIssuerX500Principal())) {\n-                        found = true;\n-                        break;\n-                    }\n-                }\n-                if (!found) {\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n-                        SSLLogger.fine(\n-                                \"Ignore alias \" + alias\n-                                + \": issuers do not match\");\n-                    }\n-                    continue;\n-                }\n-            }\n-\n-            \/\/ check the algorithm constraints\n-            if (constraints != null &&\n-                    !conformsToAlgorithmConstraints(constraints, chain,\n-                            checkType.getValidator())) {\n+            EntryStatus status = checkAlias(builderIndex, alias,\n+                    ks.getCertificateChain(alias),\n+                    verificationDate, keyTypes, issuerSet, checkType,\n+                    constraints, requestedServerNames, idAlgorithm);\n@@ -796,5 +400,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n-                    SSLLogger.fine(\"Ignore alias \" + alias +\n-                            \": certificate list does not conform to \" +\n-                            \"algorithm constraints\");\n-                }\n+            if (status == null) {\n@@ -804,10 +404,2 @@\n-            if (date == null) {\n-                date = new Date();\n-            }\n-            CheckResult checkResult =\n-                    checkType.check((X509Certificate)chain[0], date,\n-                                    requestedServerNames, idAlgorithm);\n-            EntryStatus status =\n-                    new EntryStatus(builderIndex, keyIndex,\n-                                        alias, chain, checkResult);\n-            if (!preferred && checkResult == CheckResult.OK && keyIndex == 0) {\n+            if (!preferred && status.checkResult == CheckResult.OK\n+                    && status.keyIndex == 0) {\n@@ -816,0 +408,1 @@\n+\n@@ -817,1 +410,1 @@\n-                \/\/ if we have a good match and do not need all matches,\n+                \/\/ If we have a good match and do not need all matches,\n@@ -827,2 +420,0 @@\n-        return results;\n-    }\n@@ -830,34 +421,1 @@\n-    private static boolean conformsToAlgorithmConstraints(\n-            AlgorithmConstraints constraints, Certificate[] chain,\n-            String variant) {\n-\n-        AlgorithmChecker checker = new AlgorithmChecker(constraints, variant);\n-        try {\n-            checker.init(false);\n-        } catch (CertPathValidatorException cpve) {\n-            \/\/ unlikely to happen\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n-                SSLLogger.fine(\n-                    \"Cannot initialize algorithm constraints checker\", cpve);\n-            }\n-\n-            return false;\n-        }\n-\n-        \/\/ It is a forward checker, so we need to check from trust to target.\n-        for (int i = chain.length - 1; i >= 0; i--) {\n-            Certificate cert = chain[i];\n-            try {\n-                \/\/ We don't care about the unresolved critical extensions.\n-                checker.check(cert, Collections.emptySet());\n-            } catch (CertPathValidatorException cpve) {\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n-                    SSLLogger.fine(\"Certificate does not conform to \" +\n-                            \"algorithm constraints\", cert, cpve);\n-                }\n-\n-                return false;\n-            }\n-        }\n-\n-        return true;\n+        return results;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/X509KeyManagerImpl.java","additions":42,"deletions":484,"binary":false,"changes":526,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,2 @@\n- * @library \/test\/lib\/\n+ * @library \/javax\/net\/ssl\/templates\n+ *          \/test\/lib\/\n@@ -39,2 +40,0 @@\n-import java.io.IOException;\n-import java.io.File;\n@@ -52,1 +51,5 @@\n-public class SSLSocketParametersTest implements Serializable {\n+public class SSLSocketParametersTest extends SSLContextTemplate {\n+\n+    public SSLSocketParametersTest() throws Exception {\n+        SSLContext.setDefault(createServerSSLContext());\n+    }\n@@ -58,1 +61,1 @@\n-    public class HelloImpl implements Hello {\n+    public static class HelloImpl implements Hello {\n@@ -137,16 +140,0 @@\n-        \/\/ Set keystore properties (server-side)\n-        \/\/\n-        final String keystore = System.getProperty(\"test.src\") +\n-                File.separator + \"keystore\";\n-        System.out.println(\"KeyStore = \" + keystore);\n-        System.setProperty(\"javax.net.ssl.keyStore\", keystore);\n-        System.setProperty(\"javax.net.ssl.keyStorePassword\", \"password\");\n-\n-        \/\/ Set truststore properties (client-side)\n-        \/\/\n-        final String truststore = System.getProperty(\"test.src\") +\n-                File.separator + \"truststore\";\n-        System.out.println(\"TrustStore = \" + truststore);\n-        System.setProperty(\"javax.net.ssl.trustStore\", truststore);\n-        System.setProperty(\"javax.net.ssl.trustStorePassword\", \"trustword\");\n-\n@@ -156,1 +143,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/jdk\/javax\/rmi\/ssl\/SSLSocketParametersTest.java","additions":10,"deletions":23,"binary":false,"changes":33,"status":"modified"},{"filename":"test\/jdk\/javax\/rmi\/ssl\/keystore","binary":true,"status":"deleted"},{"filename":"test\/jdk\/javax\/rmi\/ssl\/truststore","binary":true,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+ * @modules java.base\/sun.security.x509\n+ *          java.base\/sun.security.util\n@@ -35,2 +37,3 @@\n- * @run main\/othervm ServerIdentityTest dnsstore localhost\n- * @run main\/othervm ServerIdentityTest ipstore 127.0.0.1\n+ *          \/test\/lib\n+ * @run main\/othervm ServerIdentityTest dns localhost\n+ * @run main\/othervm ServerIdentityTest ip 127.0.0.1\n@@ -41,1 +44,2 @@\n-import java.io.InputStream;\n+import static jdk.test.lib.Asserts.fail;\n+\n@@ -43,0 +47,2 @@\n+import java.io.IOException;\n+import java.io.InputStream;\n@@ -44,0 +50,1 @@\n+import java.math.BigInteger;\n@@ -49,1 +56,13 @@\n-\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.KeyStore;\n+import java.security.PrivateKey;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Date;\n+import java.util.List;\n@@ -51,0 +70,1 @@\n+import javax.net.ssl.KeyManagerFactory;\n@@ -53,0 +73,8 @@\n+import javax.net.ssl.TrustManagerFactory;\n+import jdk.test.lib.security.CertificateBuilder;\n+import sun.security.x509.AuthorityKeyIdentifierExtension;\n+import sun.security.x509.GeneralName;\n+import sun.security.x509.GeneralNames;\n+import sun.security.x509.KeyIdentifier;\n+import sun.security.x509.SerialNumber;\n+import sun.security.x509.X500Name;\n@@ -56,1 +84,0 @@\n-    private static String keystore;\n@@ -58,1 +85,1 @@\n-    private static SSLContext context;\n+    private static SSLContext serverContext;\n@@ -67,1 +94,1 @@\n-        (new ServerIdentityTest()).run();\n+        new ServerIdentityTest().run();\n@@ -98,1 +125,1 @@\n-            urlc = (HttpURLConnection)url.openConnection(Proxy.NO_PROXY);\n+            urlc = (HttpURLConnection) url.openConnection(Proxy.NO_PROXY);\n@@ -112,6 +139,1 @@\n-        return context;\n-    }\n-\n-    @Override\n-    protected SSLContext createClientSSLContext() throws Exception {\n-        return context;\n+        return serverContext;\n@@ -121,1 +143,1 @@\n-        keystore = args[0];\n+        String mode = args[0];\n@@ -124,5 +146,9 @@\n-        String password = \"changeit\";\n-        String keyFilename =\n-                System.getProperty(\"test.src\", \".\") + \"\/\" + keystore;\n-        String trustFilename =\n-                System.getProperty(\"test.src\", \".\") + \"\/\" + keystore;\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\n+        KeyPair caKeys = kpg.generateKeyPair();\n+        KeyPair serverKeys = kpg.generateKeyPair();\n+        KeyPair clientKeys = kpg.generateKeyPair();\n+\n+        CertificateBuilder serverCertificateBuilder = customCertificateBuilder(\n+                \"CN=server, O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                serverKeys.getPublic(), caKeys.getPublic())\n+                .addBasicConstraintsExt(false, false, -1);\n@@ -130,4 +156,24 @@\n-        System.setProperty(\"javax.net.ssl.keyStore\", keyFilename);\n-        System.setProperty(\"javax.net.ssl.keyStorePassword\", password);\n-        System.setProperty(\"javax.net.ssl.trustStore\", trustFilename);\n-        System.setProperty(\"javax.net.ssl.trustStorePassword\", password);\n+        if (mode.equalsIgnoreCase(\"dns\")) {\n+            serverCertificateBuilder.addSubjectAltNameDNSExt(List.of(hostname));\n+        } else if (mode.equalsIgnoreCase(\"ip\")) {\n+            serverCertificateBuilder.addSubjectAltNameIPExt(List.of(hostname));\n+        } else {\n+            fail(\"Unknown mode: \" + mode);\n+        }\n+\n+        X509Certificate trustedCert = createTrustedCert(caKeys);\n+\n+        X509Certificate serverCert = serverCertificateBuilder.build(\n+                trustedCert, caKeys.getPrivate(), \"SHA256WithRSA\");\n+\n+        X509Certificate clientCert = customCertificateBuilder(\n+                \"CN=localhost, OU=SSL-Client, O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                clientKeys.getPublic(), caKeys.getPublic())\n+                .addBasicConstraintsExt(false, false, -1)\n+                .build(trustedCert, caKeys.getPrivate(), \"SHA256WithRSA\");\n+\n+        serverContext = getSSLContext(\n+                trustedCert, serverCert, serverKeys.getPrivate());\n+\n+        SSLContext clientContext = getSSLContext(\n+                trustedCert, clientCert, clientKeys.getPrivate());\n@@ -135,1 +181,0 @@\n-        context = SSLContext.getDefault();\n@@ -137,1 +182,1 @@\n-                context.getSocketFactory());\n+                clientContext.getSocketFactory());\n@@ -139,0 +184,78 @@\n+\n+    private static SSLContext getSSLContext(\n+            X509Certificate trustedCertificate, X509Certificate keyCertificate,\n+            PrivateKey privateKey)\n+            throws Exception {\n+\n+        \/\/ create a key store\n+        KeyStore ks = KeyStore.getInstance(\"PKCS12\");\n+        ks.load(null, null);\n+\n+        \/\/ import the trusted cert\n+        ks.setCertificateEntry(\"TLS Signer\", trustedCertificate);\n+\n+        \/\/ generate certificate chain\n+        Certificate[] chain = new Certificate[2];\n+        chain[0] = keyCertificate;\n+        chain[1] = trustedCertificate;\n+\n+        \/\/ import the key entry.\n+        final char[] passphrase = \"passphrase\".toCharArray();\n+        ks.setKeyEntry(\"Whatever\", privateKey, passphrase, chain);\n+\n+        \/\/ Using PKIX TrustManager\n+        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"PKIX\");\n+        tmf.init(ks);\n+\n+        \/\/ Using PKIX KeyManager\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"PKIX\");\n+\n+        \/\/ create SSL context\n+        SSLContext ctx = SSLContext.getInstance(\"TLS\");\n+        kmf.init(ks, passphrase);\n+        ctx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n+        return ctx;\n+    }\n+\n+    private static X509Certificate createTrustedCert(KeyPair caKeys)\n+            throws Exception {\n+        SecureRandom random = new SecureRandom();\n+\n+        KeyIdentifier kid = new KeyIdentifier(caKeys.getPublic());\n+        GeneralNames gns = new GeneralNames();\n+        GeneralName name = new GeneralName(new X500Name(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\"));\n+        gns.add(name);\n+        BigInteger serialNumber = BigInteger.valueOf(\n+                random.nextLong(1000000) + 1);\n+        return customCertificateBuilder(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                caKeys.getPublic(), caKeys.getPublic())\n+                .setSerialNumber(serialNumber)\n+                .addExtension(new AuthorityKeyIdentifierExtension(kid, gns,\n+                        new SerialNumber(serialNumber)))\n+                .addBasicConstraintsExt(true, true, -1)\n+                .build(null, caKeys.getPrivate(), \"SHA256WithRSA\");\n+    }\n+\n+    private static CertificateBuilder customCertificateBuilder(\n+            String subjectName, PublicKey publicKey, PublicKey caKey)\n+            throws CertificateException, IOException {\n+        SecureRandom random = new SecureRandom();\n+\n+        CertificateBuilder builder = new CertificateBuilder()\n+                .setSubjectName(subjectName)\n+                .setPublicKey(publicKey)\n+                .setNotBefore(\n+                        Date.from(Instant.now().minus(1, ChronoUnit.HOURS)))\n+                .setNotAfter(Date.from(Instant.now().plus(1, ChronoUnit.HOURS)))\n+                .setSerialNumber(\n+                        BigInteger.valueOf(random.nextLong(1000000) + 1))\n+                .addSubjectKeyIdExt(publicKey)\n+                .addAuthorityKeyIdExt(caKey);\n+        builder.addKeyUsageExt(\n+                new boolean[]{true, true, true, true, true, true});\n+\n+        return builder;\n+    }\n+\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpsClient\/ServerIdentityTest.java","additions":150,"deletions":27,"binary":false,"changes":177,"status":"modified"},{"filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpsClient\/dnsstore","binary":true,"status":"deleted"},{"filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpsClient\/ipstore","binary":true,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+ * @library \/test\/lib\n@@ -45,0 +46,1 @@\n+import jdk.test.lib.security.SecurityUtils;\n@@ -236,0 +238,4 @@\n+        \/\/ Make sure we don't block the key on algorithm constraints check.\n+        SecurityUtils.removeFromDisabledAlgs(\"jdk.certpath.disabledAlgorithms\",\n+                List.of(\"RSA keySize < 1024\"));\n+\n","filename":"test\/jdk\/sun\/security\/mscapi\/ShortRSAKeyWithinTLS.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -153,2 +153,2 @@\n-        \/\/ Using \"SunX509\" which doesn't check peer supported signature\n-        \/\/ algorithms, so we check against local supported signature\n+        \/\/ Disable KeyManager's algorithm constraints checking,\n+        \/\/ so we check against local supported signature\n@@ -156,0 +156,2 @@\n+        System.setProperty(\n+                \"jdk.tls.SunX509KeyManager.certChecking\", \"false\");\n@@ -169,1 +171,0 @@\n-        kpg.initialize(1024);\n@@ -218,1 +219,1 @@\n-                .setNotAfter(\n+                .setNotBefore(\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/MD5NotAllowedInTLS13CertificateSignature.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,197 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertNull;\n+\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.KeyStore;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Date;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.X509ExtendedKeyManager;\n+import javax.net.ssl.X509KeyManager;\n+import jdk.test.lib.security.CertificateBuilder;\n+import jdk.test.lib.security.SecurityUtils;\n+import sun.security.x509.AuthorityKeyIdentifierExtension;\n+import sun.security.x509.GeneralName;\n+import sun.security.x509.GeneralNames;\n+import sun.security.x509.KeyIdentifier;\n+import sun.security.x509.SerialNumber;\n+import sun.security.x509.X500Name;\n+\n+\/*\n+ * @test\n+ * @bug 8359956\n+ * @summary Support algorithm constraints and certificate checks in SunX509\n+ *          key manager\n+ * @modules java.base\/sun.security.x509\n+ *          java.base\/sun.security.util\n+ * @library \/test\/lib\n+ * @run main\/othervm AlgorithmConstraintsCheck false SunX509 SHA256withRSA\n+ * @run main\/othervm AlgorithmConstraintsCheck true SunX509 SHA256withRSA\n+ * @run main\/othervm AlgorithmConstraintsCheck false PKIX SHA256withRSA\n+ * @run main\/othervm AlgorithmConstraintsCheck true PKIX SHA256withRSA\n+ *\/\n+\n+public class AlgorithmConstraintsCheck {\n+\n+    private static final String CERT_ALIAS = \"testalias\";\n+    private static final String KEY_TYPE = \"RSA\";\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 3) {\n+            throw new RuntimeException(\"Wrong number of arguments\");\n+        }\n+\n+        String enabled = args[0];\n+        String kmAlg = args[1];\n+        String certSignatureAlg = args[2];\n+\n+        System.setProperty(\"jdk.tls.SunX509KeyManager.certChecking\", enabled);\n+        SecurityUtils.addToDisabledTlsAlgs(certSignatureAlg);\n+\n+        X509ExtendedKeyManager km = (X509ExtendedKeyManager) getKeyManager(\n+                kmAlg, certSignatureAlg);\n+        String serverAlias = km.chooseServerAlias(KEY_TYPE, null, null);\n+        String engineServerAlias = km.chooseEngineServerAlias(\n+                KEY_TYPE, null, null);\n+        String clientAlias = km.chooseClientAlias(\n+                new String[]{KEY_TYPE}, null, null);\n+        String engineClientAlias = km.chooseEngineClientAlias(\n+                new String[]{KEY_TYPE}, null, null);\n+\n+        \/\/ PKIX KeyManager adds a cache prefix to an alias.\n+        String serverAliasPrefix = kmAlg.equalsIgnoreCase(\"PKIX\") ? \"1.0.\" : \"\";\n+        String clientAliasPrefix = kmAlg.equalsIgnoreCase(\"PKIX\") ? \"2.0.\" : \"\";\n+\n+        if (\"false\".equals(enabled) && kmAlg.equals(\"SunX509\")) {\n+            assertEquals(CERT_ALIAS, normalizeAlias(serverAlias));\n+            assertEquals(CERT_ALIAS, normalizeAlias(engineServerAlias));\n+            assertEquals(CERT_ALIAS, normalizeAlias(clientAlias));\n+            assertEquals(CERT_ALIAS, normalizeAlias(engineClientAlias));\n+        } else {\n+            assertNull(serverAlias);\n+            assertNull(engineServerAlias);\n+            assertNull(clientAlias);\n+            assertNull(engineClientAlias);\n+        }\n+    }\n+\n+    \/\/ PKIX KeyManager adds a cache prefix to an alias.\n+    private static String normalizeAlias(String alias) {\n+        return alias.substring(alias.lastIndexOf(\".\") + 1);\n+    }\n+\n+    private static X509KeyManager getKeyManager(String kmAlg,\n+            String certSignatureAlg) throws Exception {\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(KEY_TYPE);\n+        KeyPair caKeys = kpg.generateKeyPair();\n+        KeyPair endpointKeys = kpg.generateKeyPair();\n+\n+        X509Certificate trustedCert = createTrustedCert(caKeys,\n+                certSignatureAlg);\n+\n+        X509Certificate endpointCert = customCertificateBuilder(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                endpointKeys.getPublic(), caKeys.getPublic())\n+                .addBasicConstraintsExt(false, false, -1)\n+                .build(trustedCert, caKeys.getPrivate(), certSignatureAlg);\n+\n+        \/\/ create a key store\n+        KeyStore ks = KeyStore.getInstance(\"PKCS12\");\n+        ks.load(null, null);\n+\n+        \/\/ import the trusted cert\n+        ks.setCertificateEntry(\"TLS Signer\", trustedCert);\n+\n+        \/\/ generate certificate chain\n+        Certificate[] chain = new Certificate[2];\n+        chain[0] = endpointCert;\n+        chain[1] = trustedCert;\n+\n+        \/\/ import the key entry.\n+        final char[] passphrase = \"passphrase\".toCharArray();\n+        ks.setKeyEntry(CERT_ALIAS, endpointKeys.getPrivate(), passphrase,\n+                chain);\n+\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(kmAlg);\n+        kmf.init(ks, passphrase);\n+\n+        return (X509KeyManager) kmf.getKeyManagers()[0];\n+    }\n+\n+    \/\/ Certificate-building helper methods.\n+\n+    private static X509Certificate createTrustedCert(KeyPair caKeys,\n+            String certSignatureAlg)\n+            throws Exception {\n+        SecureRandom random = new SecureRandom();\n+\n+        KeyIdentifier kid = new KeyIdentifier(caKeys.getPublic());\n+        GeneralNames gns = new GeneralNames();\n+        GeneralName name = new GeneralName(new X500Name(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\"));\n+        gns.add(name);\n+        BigInteger serialNumber = BigInteger.valueOf(\n+                random.nextLong(1000000) + 1);\n+        return customCertificateBuilder(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                caKeys.getPublic(), caKeys.getPublic())\n+                .setSerialNumber(serialNumber)\n+                .addExtension(new AuthorityKeyIdentifierExtension(kid, gns,\n+                        new SerialNumber(serialNumber)))\n+                .addBasicConstraintsExt(true, true, -1)\n+                .build(null, caKeys.getPrivate(), certSignatureAlg);\n+    }\n+\n+    private static CertificateBuilder customCertificateBuilder(\n+            String subjectName, PublicKey publicKey, PublicKey caKey)\n+            throws CertificateException, IOException {\n+        SecureRandom random = new SecureRandom();\n+\n+        CertificateBuilder builder = new CertificateBuilder()\n+                .setSubjectName(subjectName)\n+                .setPublicKey(publicKey)\n+                .setNotBefore(\n+                        Date.from(Instant.now().minus(1, ChronoUnit.HOURS)))\n+                .setNotAfter(Date.from(Instant.now().plus(1, ChronoUnit.HOURS)))\n+                .setSerialNumber(\n+                        BigInteger.valueOf(random.nextLong(1000000) + 1))\n+                .addSubjectKeyIdExt(publicKey)\n+                .addAuthorityKeyIdExt(caKey);\n+        builder.addKeyUsageExt(\n+                new boolean[]{true, true, true, true, true, true});\n+\n+        return builder;\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/X509KeyManager\/AlgorithmConstraintsCheck.java","additions":197,"deletions":0,"binary":false,"changes":197,"status":"added"},{"patch":"@@ -0,0 +1,472 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertNull;\n+\n+import com.sun.security.auth.UserPrincipal;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.KeyStore;\n+import java.security.Principal;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.X509ExtendedKeyManager;\n+import javax.net.ssl.X509KeyManager;\n+import javax.security.auth.x500.X500Principal;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.security.CertificateBuilder;\n+import sun.security.x509.AuthorityKeyIdentifierExtension;\n+import sun.security.x509.GeneralName;\n+import sun.security.x509.GeneralNames;\n+import sun.security.x509.KeyIdentifier;\n+import sun.security.x509.SerialNumber;\n+import sun.security.x509.X500Name;\n+\n+\/*\n+ * @test\n+ * @bug 8359956\n+ * @summary Support algorithm constraints and certificate checks in SunX509\n+ *          key manager\n+ * @modules java.base\/sun.security.x509\n+ *          java.base\/sun.security.util\n+ * @library \/test\/lib\n+ * @run main\/othervm CertChecking false SunX509\n+ * @run main\/othervm CertChecking true SunX509\n+ * @run main\/othervm CertChecking false PKIX\n+ * @run main\/othervm CertChecking true PKIX\n+ *\/\n+\n+\/*\n+ * This class tests against the certificate's expiration, key usage, key type\n+ * and issuers.\n+ *\/\n+\n+public class CertChecking {\n+\n+    private static final String PREFERRED_ALIAS = \"preferred-alias\";\n+    private static final String EXPIRED_ALIAS = \"expired-alias\";\n+    private static final String USAGE_MISMATCH_ALIAS = \"usage-mismatch-alias\";\n+    private static final String CA_KEY_TYPE = \"RSA\";\n+    private static final String CERT_SIG_ALG = \"SHA256withRSA\";\n+    private static final String CA_ISSUER_STRING =\n+            \"O=TrustedCert, L=Some-City, ST=Some-State, C=US\";\n+    private static final String EE_ISSUER_STRING =\n+            \"O=EndpointCert, L=Some-City, ST=Some-State, C=US\";\n+    private static final String UNKNOWN_ISSUER_STRING =\n+            \"O=UnknownCert, L=Some-City, ST=Some-State, C=US\";\n+\n+    \/*\n+     * Certificate KeyUsage reference:\n+     *\n+     *     digitalSignature        (0),\n+     *     nonRepudiation          (1),\n+     *     keyEncipherment         (2),\n+     *     dataEncipherment        (3),\n+     *     keyAgreement            (4),\n+     *     keyCertSign             (5),\n+     *     cRLSign                 (6),\n+     *     encipherOnly            (7),\n+     *     decipherOnly            (8)\n+     *\/\n+\n+    private static final boolean[] DEFAULT_KEY_USAGES =\n+            new boolean[]{true, true, true, true, true, true};\n+    private static final boolean[] NONE_KEY_USAGES =\n+            new boolean[]{false, false, false, false, false, false};\n+    private static final boolean[] NO_DS_USAGE =\n+            new boolean[]{false, true, true, true, true, true};\n+    private static final boolean[] NO_DS_NO_KE_USAGE =\n+            new boolean[]{false, true, false, true, true, true};\n+    private static final boolean[] NO_KA_USAGE =\n+            new boolean[]{true, true, true, true, false, true};\n+\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 2) {\n+            throw new RuntimeException(\"Wrong number of arguments\");\n+        }\n+\n+        String enabled = args[0];\n+        String kmAlg = args[1];\n+\n+        System.setProperty(\"jdk.tls.SunX509KeyManager.certChecking\", enabled);\n+\n+        \/\/ --- Usage and expired test cases --\n+\n+        \/\/ Both client and server should be checked with no usages at all\n+        usageTestCase(enabled, kmAlg, \"RSA\", NONE_KEY_USAGES, true, true);\n+\n+        \/\/ Only client should be checked with RSA algorithm and\n+        \/\/ no digital signature bit set\n+        usageTestCase(enabled, kmAlg, \"RSA\", NO_DS_USAGE, false, true);\n+\n+        \/\/ Only server should be checked with RSA algorithm and\n+        \/\/ no digital signature bit set\n+        usageTestCase(enabled, kmAlg, \"RSASSA-PSS\", NO_DS_USAGE, true, false);\n+\n+        \/\/ Both client and server should be checked with DSA algorithm and no\n+        \/\/ digital signature bit set\n+        usageTestCase(enabled, kmAlg, \"DSA\", NO_DS_USAGE, true, true);\n+\n+        \/\/ Both client and server should be checked with EC algorithm and no\n+        \/\/ digital signature bit set\n+        usageTestCase(enabled, kmAlg, \"EC\", NO_DS_USAGE, true, true);\n+\n+        \/\/ Both client and server should be checked with RSA algorithm and\n+        \/\/ missing digital signature and key encipherment bits.\n+        usageTestCase(enabled, kmAlg, \"RSA\", NO_DS_NO_KE_USAGE, true, true);\n+\n+        \/\/ Both client and server should be checked with DH algorithm and no\n+        \/\/ key agreement bit set.\n+        usageTestCase(enabled, kmAlg, \"DH\", NO_KA_USAGE, true, true);\n+\n+        \/\/ Only server should be checked with EC algorithm and\n+        \/\/ no digital signature bit set\n+        usageTestCase(enabled, kmAlg, \"EC\", NO_KA_USAGE, true, false);\n+\n+        \/\/ --- Issuer match test cases ---\n+\n+        \/\/ Check CA issuer match\n+        issuerAndKeyTypeTestCase(enabled, kmAlg, \"RSA\", \"RSA\",\n+                new Principal[]{new X500Principal(CA_ISSUER_STRING)}, true);\n+\n+        \/\/ Check CA issuer match with non-X500 principal\n+        issuerAndKeyTypeTestCase(enabled, kmAlg, \"RSA\", \"RSA\",\n+                new Principal[]{new UserPrincipal(CA_ISSUER_STRING)}, true);\n+\n+        \/\/ Non-convertable principal should match all\n+        issuerAndKeyTypeTestCase(enabled, kmAlg, \"RSA\", \"RSA\",\n+                new Principal[]{new InvalidPrincipal()}, true);\n+\n+        \/\/ Empty issuer array should match all\n+        issuerAndKeyTypeTestCase(enabled, kmAlg, \"RSA\", \"RSA\",\n+                new Principal[]{}, true);\n+\n+        \/\/ Null issuer array should match all\n+        issuerAndKeyTypeTestCase(enabled, kmAlg, \"RSA\", \"RSA\", null, true);\n+\n+        \/\/ Issuer that is not in the chain should not match.\n+        issuerAndKeyTypeTestCase(enabled, kmAlg, \"RSA\", \"RSA\",\n+                new Principal[]{new X500Principal(UNKNOWN_ISSUER_STRING)},\n+                false);\n+\n+        \/\/ --- Key Type match test cases ---\n+\n+        \/\/ Exact key type match.\n+        issuerAndKeyTypeTestCase(enabled, kmAlg, \"EC\", \"EC\", null, true);\n+\n+        \/\/ Key type with a signature algorithm match.\n+        issuerAndKeyTypeTestCase(\n+                enabled, kmAlg, \"EC\", \"EC_\" + CA_KEY_TYPE, null, true);\n+\n+        \/\/ Null KeyType should not match.\n+        issuerAndKeyTypeTestCase(enabled, kmAlg, \"RSA\", null, null, false);\n+\n+        \/\/ Wrong KeyType should not match.\n+        issuerAndKeyTypeTestCase(enabled, kmAlg, \"RSA\", \"EC\", null, false);\n+\n+        \/\/ Wrong signature algorithm should not match.\n+        issuerAndKeyTypeTestCase(enabled, kmAlg, \"RSA\", \"RSA_EC\", null, false);\n+\n+        \/\/ Correct signature algorithm but incorrect key algorithm\n+        \/\/ should not match.\n+        issuerAndKeyTypeTestCase(\n+                enabled, kmAlg, \"RSA\", \"EC_\" + CA_KEY_TYPE, null, false);\n+    }\n+\n+    private static void usageTestCase(String enabled, String kmAlg,\n+            String keyAlg, boolean[] certKeyUsages, boolean checkServer,\n+            boolean checkClient) throws Exception {\n+\n+        X509ExtendedKeyManager km = (X509ExtendedKeyManager) getKeyManager(\n+                kmAlg, keyAlg, certKeyUsages);\n+\n+        String chosenServerAlias = km.chooseServerAlias(keyAlg, null, null);\n+        String chosenEngineServerAlias = km.chooseEngineServerAlias(\n+                keyAlg, null, null);\n+        String chosenClientAlias = km.chooseClientAlias(\n+                new String[]{keyAlg}, null, null);\n+        String chosenEngineClientAlias = km.chooseEngineClientAlias(\n+                new String[]{keyAlg}, null, null);\n+\n+        String[] allServerAliases = km.getServerAliases(keyAlg, null);\n+        String[] allClientAliases = km.getClientAliases(keyAlg, null);\n+\n+        if (\"false\".equals(enabled) && kmAlg.equals(\"SunX509\")) {\n+            \/\/ Initial order alias returned\n+            assertEquals(USAGE_MISMATCH_ALIAS,\n+                    normalizeAlias(chosenServerAlias));\n+            assertEquals(USAGE_MISMATCH_ALIAS,\n+                    normalizeAlias(chosenClientAlias));\n+            assertEquals(USAGE_MISMATCH_ALIAS,\n+                    normalizeAlias(chosenEngineServerAlias));\n+            assertEquals(USAGE_MISMATCH_ALIAS,\n+                    normalizeAlias(chosenEngineClientAlias));\n+\n+            \/\/ Assert the initial order of all aliases.\n+            assertEquals(USAGE_MISMATCH_ALIAS,\n+                    normalizeAlias(allServerAliases[0]));\n+            assertEquals(USAGE_MISMATCH_ALIAS,\n+                    normalizeAlias(allClientAliases[0]));\n+            assertEquals(PREFERRED_ALIAS, normalizeAlias(allServerAliases[1]));\n+            assertEquals(PREFERRED_ALIAS, normalizeAlias(allClientAliases[1]));\n+            assertEquals(EXPIRED_ALIAS, normalizeAlias(allServerAliases[2]));\n+            assertEquals(EXPIRED_ALIAS, normalizeAlias(allClientAliases[2]));\n+\n+        } else {\n+            if (checkServer) {\n+                \/\/ Preferred alias returned\n+                assertEquals(PREFERRED_ALIAS,\n+                        normalizeAlias(chosenServerAlias));\n+                assertEquals(PREFERRED_ALIAS,\n+                        normalizeAlias(chosenEngineServerAlias));\n+\n+                \/\/ Assert the correct sorted order of all aliases.\n+                assertEquals(PREFERRED_ALIAS,\n+                        normalizeAlias(allServerAliases[0]));\n+                assertEquals(EXPIRED_ALIAS,\n+                        normalizeAlias(allServerAliases[1]));\n+                assertEquals(USAGE_MISMATCH_ALIAS,\n+                        normalizeAlias(allServerAliases[2]));\n+            }\n+\n+            if (checkClient) {\n+                \/\/ Preferred alias returned\n+                assertEquals(PREFERRED_ALIAS,\n+                        normalizeAlias(chosenClientAlias));\n+                assertEquals(PREFERRED_ALIAS,\n+                        normalizeAlias(chosenEngineClientAlias));\n+\n+                \/\/ Assert the correct sorted order of all aliases.\n+                assertEquals(PREFERRED_ALIAS,\n+                        normalizeAlias(allClientAliases[0]));\n+                assertEquals(EXPIRED_ALIAS,\n+                        normalizeAlias(allClientAliases[1]));\n+                assertEquals(USAGE_MISMATCH_ALIAS,\n+                        normalizeAlias(allClientAliases[2]));\n+            }\n+        }\n+    }\n+\n+    private static void issuerAndKeyTypeTestCase(String enabled, String kmAlg,\n+            String keyAlg, String keyType, Principal[] issuers, boolean found)\n+            throws Exception {\n+\n+        X509ExtendedKeyManager km = (X509ExtendedKeyManager) getKeyManager(\n+                kmAlg, keyAlg, NONE_KEY_USAGES);\n+\n+        List<String> chosenAliases = new ArrayList<>(4);\n+\n+        chosenAliases.add(km.chooseServerAlias(keyType, issuers, null));\n+        chosenAliases.add(km.chooseEngineServerAlias(keyType, issuers, null));\n+        chosenAliases.add(\n+                km.chooseClientAlias(new String[]{keyType}, issuers, null));\n+        chosenAliases.add(km.chooseEngineClientAlias(\n+                new String[]{keyType}, issuers, null));\n+\n+        String[] allServerAliases = km.getServerAliases(keyType, issuers);\n+        String[] allClientAliases = km.getClientAliases(keyType, issuers);\n+\n+        if (found) {\n+            if (\"false\".equals(enabled) && kmAlg.equals(\"SunX509\")) {\n+                chosenAliases.forEach(a ->\n+                        assertEquals(USAGE_MISMATCH_ALIAS, normalizeAlias(a)));\n+\n+                \/\/ Assert the initial order of all aliases.\n+                assertEquals(USAGE_MISMATCH_ALIAS,\n+                        normalizeAlias(allServerAliases[0]));\n+                assertEquals(USAGE_MISMATCH_ALIAS,\n+                        normalizeAlias(allClientAliases[0]));\n+                assertEquals(PREFERRED_ALIAS,\n+                        normalizeAlias(allServerAliases[1]));\n+                assertEquals(PREFERRED_ALIAS,\n+                        normalizeAlias(allClientAliases[1]));\n+                assertEquals(EXPIRED_ALIAS,\n+                        normalizeAlias(allServerAliases[2]));\n+                assertEquals(EXPIRED_ALIAS,\n+                        normalizeAlias(allClientAliases[2]));\n+            } else {\n+                chosenAliases.forEach(a ->\n+                        assertEquals(PREFERRED_ALIAS, normalizeAlias(a)));\n+\n+                \/\/ Assert the correct sorted order of all aliases.\n+                assertEquals(PREFERRED_ALIAS,\n+                        normalizeAlias(allServerAliases[0]));\n+                assertEquals(EXPIRED_ALIAS,\n+                        normalizeAlias(allServerAliases[1]));\n+                assertEquals(USAGE_MISMATCH_ALIAS,\n+                        normalizeAlias(allServerAliases[2]));\n+            }\n+        } else {\n+            chosenAliases.forEach(Asserts::assertNull);\n+            assertNull(allServerAliases);\n+            assertNull(allClientAliases);\n+        }\n+    }\n+\n+    \/\/ PKIX KeyManager adds a cache prefix to an alias.\n+    private static String normalizeAlias(String alias) {\n+        return alias.substring(alias.lastIndexOf(\".\") + 1);\n+\n+    }\n+\n+    private static class InvalidPrincipal implements Principal {\n+\n+        @Override\n+        public String getName() {\n+            return null;\n+        }\n+    }\n+\n+    private static X509KeyManager getKeyManager(String kmAlg,\n+            String keyAlg, boolean[] certKeyUsages)\n+            throws Exception {\n+\n+        \/\/ Create a key store.\n+        KeyStore ks = KeyStore.getInstance(\"PKCS12\");\n+        ks.load(null, null);\n+\n+        \/\/ Generate and set the trusted cert.\n+        KeyPair caKeys = KeyPairGenerator.getInstance(CA_KEY_TYPE)\n+                .generateKeyPair();\n+        X509Certificate trustedCert = createTrustedCert(caKeys);\n+        ks.setCertificateEntry(\"CA entry\", trustedCert);\n+\n+        \/\/ Generate valid certificate chain.\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(keyAlg);\n+        KeyPair validEndpointKeys = kpg.generateKeyPair();\n+\n+        X509Certificate validEndpointCert = customCertificateBuilder(\n+                EE_ISSUER_STRING,\n+                validEndpointKeys.getPublic(), caKeys.getPublic(),\n+                Instant.now(), DEFAULT_KEY_USAGES)\n+                .addBasicConstraintsExt(false, false, -1)\n+                .build(trustedCert, caKeys.getPrivate(), CERT_SIG_ALG);\n+\n+        Certificate[] validChain = new Certificate[2];\n+        validChain[0] = validEndpointCert;\n+        validChain[1] = trustedCert;\n+\n+        \/\/ Generate expired certificate chain.\n+        KeyPair expiredEndpointKeys = kpg.generateKeyPair();\n+\n+        X509Certificate expiredEndpointCert = customCertificateBuilder(\n+                EE_ISSUER_STRING,\n+                expiredEndpointKeys.getPublic(), caKeys.getPublic(),\n+                Instant.now().minus(1, ChronoUnit.DAYS), DEFAULT_KEY_USAGES)\n+                .addBasicConstraintsExt(false, false, -1)\n+                .build(trustedCert, caKeys.getPrivate(), CERT_SIG_ALG);\n+\n+        Certificate[] expiredChain = new Certificate[2];\n+        expiredChain[0] = expiredEndpointCert;\n+        expiredChain[1] = trustedCert;\n+\n+        \/\/ Generate usage mismatch certificate chain.\n+        KeyPair usageMismatchEndpointKeys = kpg.generateKeyPair();\n+\n+        X509Certificate usageMismatchEndpointCert = customCertificateBuilder(\n+                EE_ISSUER_STRING,\n+                usageMismatchEndpointKeys.getPublic(), caKeys.getPublic(),\n+                Instant.now(), certKeyUsages)\n+                .addBasicConstraintsExt(false, false, -1)\n+                .build(trustedCert, caKeys.getPrivate(), CERT_SIG_ALG);\n+\n+        Certificate[] usageMismatchChain = new Certificate[2];\n+        usageMismatchChain[0] = usageMismatchEndpointCert;\n+        usageMismatchChain[1] = trustedCert;\n+\n+        \/\/ Import the key entries, order matters.\n+        final char[] passphrase = \"passphrase\".toCharArray();\n+        ks.setKeyEntry(USAGE_MISMATCH_ALIAS,\n+                usageMismatchEndpointKeys.getPrivate(), passphrase,\n+                usageMismatchChain);\n+        ks.setKeyEntry(PREFERRED_ALIAS, validEndpointKeys.getPrivate(),\n+                passphrase,\n+                validChain);\n+        ks.setKeyEntry(EXPIRED_ALIAS, expiredEndpointKeys.getPrivate(),\n+                passphrase,\n+                expiredChain);\n+\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(kmAlg);\n+        kmf.init(ks, passphrase);\n+\n+        return (X509KeyManager) kmf.getKeyManagers()[0];\n+    }\n+\n+    \/\/ Certificate-building helper methods.\n+\n+    private static X509Certificate createTrustedCert(KeyPair caKeys)\n+            throws Exception {\n+        SecureRandom random = new SecureRandom();\n+\n+        KeyIdentifier kid = new KeyIdentifier(caKeys.getPublic());\n+        GeneralNames gns = new GeneralNames();\n+        GeneralName name = new GeneralName(new X500Name(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\"));\n+        gns.add(name);\n+        BigInteger serialNumber = BigInteger.valueOf(\n+                random.nextLong(1000000) + 1);\n+        return customCertificateBuilder(\n+                CA_ISSUER_STRING,\n+                caKeys.getPublic(), caKeys.getPublic(), Instant.now(),\n+                DEFAULT_KEY_USAGES)\n+                .setSerialNumber(serialNumber)\n+                .addExtension(new AuthorityKeyIdentifierExtension(kid, gns,\n+                        new SerialNumber(serialNumber)))\n+                .addBasicConstraintsExt(true, true, -1)\n+                .build(null, caKeys.getPrivate(), CERT_SIG_ALG);\n+    }\n+\n+    private static CertificateBuilder customCertificateBuilder(\n+            String subjectName, PublicKey publicKey, PublicKey caKey,\n+            Instant certDate, boolean[] certKeyUsages)\n+            throws CertificateException, IOException {\n+        SecureRandom random = new SecureRandom();\n+\n+        CertificateBuilder builder = new CertificateBuilder()\n+                .setSubjectName(subjectName)\n+                .setPublicKey(publicKey)\n+                .setNotBefore(\n+                        Date.from(certDate.minus(1, ChronoUnit.HOURS)))\n+                .setNotAfter(Date.from(certDate.plus(1, ChronoUnit.HOURS)))\n+                .setSerialNumber(\n+                        BigInteger.valueOf(random.nextLong(1000000) + 1))\n+                .addSubjectKeyIdExt(publicKey)\n+                .addAuthorityKeyIdExt(caKey);\n+        builder.addKeyUsageExt(certKeyUsages);\n+\n+        return builder;\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/X509KeyManager\/CertChecking.java","additions":472,"deletions":0,"binary":false,"changes":472,"status":"added"},{"patch":"@@ -0,0 +1,280 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertTrue;\n+import static jdk.test.lib.Utils.runAndCheckException;\n+\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.net.Socket;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.KeyStore;\n+import java.security.PrivateKey;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Date;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.SSLHandshakeException;\n+import javax.net.ssl.X509ExtendedTrustManager;\n+import jdk.test.lib.security.CertificateBuilder;\n+import sun.security.x509.AuthorityKeyIdentifierExtension;\n+import sun.security.x509.GeneralName;\n+import sun.security.x509.GeneralNames;\n+import sun.security.x509.KeyIdentifier;\n+import sun.security.x509.SerialNumber;\n+import sun.security.x509.X500Name;\n+\n+\/*\n+ * @test\n+ * @bug 8359956\n+ * @summary Support algorithm constraints and certificate checks in SunX509\n+ *          key manager\n+ * @modules java.base\/sun.security.x509\n+ *          java.base\/sun.security.util\n+ * @library \/javax\/net\/ssl\/templates\n+ *          \/test\/lib\n+ * @run main\/othervm PeerConstraintsCheck false SunX509\n+ * @run main\/othervm PeerConstraintsCheck true SunX509\n+ * @run main\/othervm PeerConstraintsCheck false PKIX\n+ * @run main\/othervm PeerConstraintsCheck true PKIX\n+ *\/\n+\n+\/*\n+ * This class tests against the peer supported certificate signatures sent in\n+ * \"signature_algorithms_cert\" extension.\n+ *\/\n+\n+public class PeerConstraintsCheck extends SSLSocketTemplate {\n+\n+    private static final String KEY_ALGORITHM = \"EC\";\n+    private static final String CLIENT_CERT_SIG_SCHEME =\n+            \"ecdsa_secp384r1_sha384\";\n+    private static final String CLIENT_CERT_SIG_ALG = \"SHA384withECDSA\";\n+    private static final String SERVER_CERT_SIG_ALG = \"SHA256withECDSA\";\n+    private static final String TRUSTED_CERT_SIG_ALG = \"SHA512withECDSA\";\n+\n+    private final String kmAlg;\n+    private X509Certificate trustedCert;\n+    private X509Certificate serverCert;\n+    private X509Certificate clientCert;\n+    private KeyPair serverKeys;\n+    private KeyPair clientKeys;\n+\n+    protected PeerConstraintsCheck(String kmAlg) throws Exception {\n+        super();\n+        this.kmAlg = kmAlg;\n+        setupCertificates();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Make sure both client and server support client's signature scheme,\n+        \/\/ so the exception happens later during KeyManager's algorithm check.\n+        System.setProperty(\n+                \"jdk.tls.client.SignatureSchemes\", CLIENT_CERT_SIG_SCHEME);\n+        System.setProperty(\n+                \"jdk.tls.server.SignatureSchemes\", CLIENT_CERT_SIG_SCHEME);\n+\n+        String enabled = args[0];\n+        String kmAlg = args[1];\n+\n+        System.setProperty(\"jdk.tls.SunX509KeyManager.certChecking\", enabled);\n+\n+        if (\"false\".equals(enabled) && kmAlg.equals(\"SunX509\")) {\n+            new PeerConstraintsCheck(kmAlg).run();\n+        } else {\n+            \/\/ \"jdk.tls.client.SignatureSchemes\" and\n+            \/\/ \"jdk.tls.server.SignatureSchemes\" system properties set\n+            \/\/ signature schemes for both \"signature_algorithms\" and\n+            \/\/ \"signature_algorithms_cert\" extensions. Then we fail because\n+            \/\/ server's certificate is signed with \"SHA256withECDSA\" while\n+            \/\/ \"signature_algorithms_cert\" extension only contains an\n+            \/\/ \"ecdsa_secp384r1_sha384\" signature scheme corresponding to\n+            \/\/ \"SHA384withECDSA\" certificate signature.\n+            runAndCheckException(\n+                    () -> new PeerConstraintsCheck(kmAlg).run(),\n+                    ex -> {\n+                        assertTrue(ex instanceof SSLHandshakeException);\n+                        assertEquals(ex.getMessage(), \"(handshake_failure) \"\n+                                + \"No available authentication scheme\");\n+                    }\n+            );\n+        }\n+    }\n+\n+    @Override\n+    public SSLContext createServerSSLContext() throws Exception {\n+        return getSSLContext(\n+                trustedCert, serverCert, serverKeys.getPrivate(), kmAlg);\n+    }\n+\n+    @Override\n+    public SSLContext createClientSSLContext() throws Exception {\n+        return getSSLContext(\n+                trustedCert, clientCert, clientKeys.getPrivate(), kmAlg);\n+    }\n+\n+    private static SSLContext getSSLContext(X509Certificate trustedCertificate,\n+            X509Certificate keyCertificate, PrivateKey privateKey, String kmAlg)\n+            throws Exception {\n+\n+        \/\/ create a key store\n+        KeyStore ks = KeyStore.getInstance(\"PKCS12\");\n+        ks.load(null, null);\n+\n+        \/\/ import the trusted cert\n+        ks.setCertificateEntry(\"TLS Signer\", trustedCertificate);\n+\n+        \/\/ generate certificate chain\n+        Certificate[] chain = new Certificate[2];\n+        chain[0] = keyCertificate;\n+        chain[1] = trustedCertificate;\n+\n+        \/\/ import the key entry.\n+        final char[] passphrase = \"passphrase\".toCharArray();\n+        ks.setKeyEntry(\"Whatever\", privateKey, passphrase, chain);\n+\n+        SSLContext ctx = SSLContext.getInstance(\"TLS\");\n+\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(kmAlg);\n+        kmf.init(ks, passphrase);\n+\n+        \/\/ Use custom trust-all TrustManager so we perform only KeyManager's\n+        \/\/ constraints check.\n+        X509ExtendedTrustManager[] trustAll = new X509ExtendedTrustManager[]{\n+                new X509ExtendedTrustManager() {\n+                    @Override\n+                    public void checkClientTrusted(X509Certificate[] chain,\n+                            String authType, Socket socket)\n+                            throws CertificateException {\n+                    }\n+\n+                    @Override\n+                    public void checkServerTrusted(X509Certificate[] chain,\n+                            String authType, Socket socket)\n+                            throws CertificateException {\n+                    }\n+\n+                    @Override\n+                    public void checkClientTrusted(X509Certificate[] chain,\n+                            String authType, SSLEngine engine)\n+                            throws CertificateException {\n+                    }\n+\n+                    @Override\n+                    public void checkServerTrusted(X509Certificate[] chain,\n+                            String authType, SSLEngine engine)\n+                            throws CertificateException {\n+                    }\n+\n+                    public void checkClientTrusted(X509Certificate[] chain,\n+                            String authType) throws CertificateException {\n+                    }\n+\n+                    public void checkServerTrusted(X509Certificate[] chain,\n+                            String authType) throws CertificateException {\n+                    }\n+\n+                    public X509Certificate[] getAcceptedIssuers() {\n+                        return new X509Certificate[0];\n+                    }\n+                }\n+        };\n+\n+        ctx.init(kmf.getKeyManagers(), trustAll, null);\n+        return ctx;\n+    }\n+\n+    \/\/ Certificate-building helper methods.\n+\n+    private void setupCertificates() throws Exception {\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(KEY_ALGORITHM);\n+        KeyPair caKeys = kpg.generateKeyPair();\n+        this.serverKeys = kpg.generateKeyPair();\n+        this.clientKeys = kpg.generateKeyPair();\n+\n+        this.trustedCert = createTrustedCert(caKeys);\n+\n+        this.serverCert = customCertificateBuilder(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                serverKeys.getPublic(), caKeys.getPublic())\n+                .addBasicConstraintsExt(false, false, -1)\n+                .build(trustedCert, caKeys.getPrivate(), SERVER_CERT_SIG_ALG);\n+\n+        this.clientCert = customCertificateBuilder(\n+                \"CN=localhost, OU=SSL-Client, O=Some-Org, L=Some-City,\"\n+                        + \" ST=Some-State, C=US\",\n+                clientKeys.getPublic(), caKeys.getPublic())\n+                .addBasicConstraintsExt(false, false, -1)\n+                .build(trustedCert, caKeys.getPrivate(), CLIENT_CERT_SIG_ALG);\n+    }\n+\n+    private static X509Certificate createTrustedCert(KeyPair caKeys)\n+            throws Exception {\n+        SecureRandom random = new SecureRandom();\n+        KeyIdentifier kid = new KeyIdentifier(caKeys.getPublic());\n+        GeneralNames gns = new GeneralNames();\n+        GeneralName name = new GeneralName(new X500Name(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\"));\n+        gns.add(name);\n+        BigInteger serialNumber = BigInteger.valueOf(\n+                random.nextLong(1000000) + 1);\n+        return customCertificateBuilder(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                caKeys.getPublic(), caKeys.getPublic())\n+                .setSerialNumber(serialNumber)\n+                .addExtension(new AuthorityKeyIdentifierExtension(kid, gns,\n+                        new SerialNumber(serialNumber)))\n+                .addBasicConstraintsExt(true, true, -1)\n+                .build(null, caKeys.getPrivate(), TRUSTED_CERT_SIG_ALG);\n+    }\n+\n+    private static CertificateBuilder customCertificateBuilder(\n+            String subjectName, PublicKey publicKey, PublicKey caKey)\n+            throws CertificateException, IOException {\n+        SecureRandom random = new SecureRandom();\n+\n+        CertificateBuilder builder = new CertificateBuilder()\n+                .setSubjectName(subjectName)\n+                .setPublicKey(publicKey)\n+                .setNotBefore(\n+                        Date.from(Instant.now().minus(1, ChronoUnit.HOURS)))\n+                .setNotAfter(Date.from(Instant.now().plus(1, ChronoUnit.HOURS)))\n+                .setSerialNumber(\n+                        BigInteger.valueOf(random.nextLong(1000000) + 1))\n+                .addSubjectKeyIdExt(publicKey)\n+                .addAuthorityKeyIdExt(caKey);\n+        builder.addKeyUsageExt(\n+                new boolean[]{true, true, true, true, true, true});\n+\n+        return builder;\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/X509KeyManager\/PeerConstraintsCheck.java","additions":280,"deletions":0,"binary":false,"changes":280,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,2 +39,0 @@\n-import java.net.*;\n-import java.util.*;\n@@ -1117,0 +1115,4 @@\n+        \/\/ Disable KeyManager's algorithm constraints checking as this test\n+        \/\/ is about TrustManager's constraints check.\n+        System.setProperty(\"jdk.tls.SunX509KeyManager.certChecking\", \"false\");\n+\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/PKIXExtendedTM.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,6 @@\n+        \/\/ Disable KeyManager's algorithm constraints checking,\n+        \/\/ so we can make keytool print certificate with weak\n+        \/\/ MD5withRSA signature algorithm.\n+        System.setProperty(\n+                \"jdk.tls.SunX509KeyManager.certChecking\", \"false\");\n+\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/PrintSSL.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import sun.security.x509.IPAddressName;\n@@ -236,0 +237,20 @@\n+    \/**\n+     * Helper method to add IPAddress types for the SAN extension\n+     *\n+     * @param ipAddresses A {@code List} of names to add as IPAddress\n+     *         types\n+     * @throws IOException if an encoding error occurs.\n+     *\/\n+    public CertificateBuilder addSubjectAltNameIPExt(List<String> ipAddresses)\n+            throws IOException {\n+        if (!ipAddresses.isEmpty()) {\n+            GeneralNames gNames = new GeneralNames();\n+            for (String name : ipAddresses) {\n+                gNames.add(new GeneralName(new IPAddressName(name)));\n+            }\n+            addExtension(new SubjectAlternativeNameExtension(false,\n+                    gNames));\n+        }\n+        return this;\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/security\/CertificateBuilder.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"}]}