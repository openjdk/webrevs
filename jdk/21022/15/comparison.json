{"files":[{"patch":"@@ -0,0 +1,464 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.tools.jlink.internal;\n+\n+import java.lang.classfile.ClassBuilder;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Objects;\n+\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n+import java.lang.classfile.TypeKind;\n+import java.lang.constant.ConstantDesc;\n+import static java.lang.constant.ConstantDescs.CD_Integer;\n+import static java.lang.constant.ConstantDescs.CD_Object;\n+import static java.lang.constant.ConstantDescs.CD_Set;\n+import static java.lang.constant.ConstantDescs.CD_int;\n+import java.util.function.Function;\n+\n+public class Snippets {\n+    \/**\n+     * Snippet of bytecodes\n+     *\/\n+    @FunctionalInterface\n+    public interface Snippet {\n+        \/**\n+         * Emit the bytecode snippet to the CodeBuilder.\n+         *\n+         * @param cob  The CodeBuilder\n+         *\/\n+        void emit(CodeBuilder cob);\n+\n+        \/**\n+         * Load a constant onto the operand stack.\n+         *\/\n+        static <T extends ConstantDesc> Snippet loadConstant(T v) {\n+            return cob -> cob.loadConstant(v);\n+        }\n+\n+        \/**\n+         * Load an enum constant onto the operand stack.\n+         *\/\n+        static Snippet loadEnum(Enum<?> e) {\n+            var classDesc = e.getClass().describeConstable().get();\n+            return cob -> cob.getstatic(classDesc, e.name(), classDesc);\n+        }\n+\n+        \/**\n+         * Load an Integer, boxed int value onto the operand stack.\n+         *\/\n+        static Snippet loadInteger(int value) {\n+            return cob ->\n+                    cob.loadConstant(value)\n+                       .invokestatic(CD_Integer, \"valueOf\", MethodTypeDesc.of(CD_Integer, CD_int));\n+        }\n+\n+        \/**\n+         * Build snippets each to process the corresponding element.\n+         * @param elements The elements to be processed\n+         * @param fn The snippet building function for a given element\n+         * @return Snippets\n+         *\/\n+        static <T> Snippet[] buildAll(Collection<T> elements, Function<T, Snippet> fn) {\n+            return elements.stream()\n+                    .map(fn)\n+                    .toArray(Snippet[]::new);\n+        }\n+    }\n+\n+    \/**\n+     * Describe an operand that can be load onto the operand stack.\n+     * For example, an array of string can be described as a Loadable.\n+     *\n+     * @param classDesc The type of the operand\n+     * @param load The snippet to load the operand onto the operand stack\n+     *\/\n+    public record Loadable(ClassDesc classDesc, Snippet load) implements Snippet {\n+        \/**\n+         * Generate the bytecode to load the Loadable onto the operand stack.\n+         * @param cob  The CodeBuilder to add the bytecode for loading\n+         *\/\n+        @Override\n+        public void emit(CodeBuilder cob) {\n+            load.emit(cob);\n+        }\n+    }\n+\n+    \/**\n+     * Build a snippet for an element with a given index. Typically used for elements in a\n+     * collection to identify the specific element.\n+     *\/\n+    @FunctionalInterface\n+    public interface IndexedElementSnippetBuilder<T> {\n+        \/**\n+         * Build a snippet for the element at the index.\n+         * @param element  The element\n+         * @param index  The index of the element in the containing collection\n+         * @return A snippet of bytecodes to process the element\n+         *\/\n+        Snippet build(T element, int index);\n+\n+        default Snippet[] buildAll(Collection<T> elements) {\n+            var loadElementSnippets = new ArrayList<Snippet>(elements.size());\n+            for (var element: elements) {\n+                loadElementSnippets.add(build(element, loadElementSnippets.size()));\n+            }\n+\n+            assert(loadElementSnippets.size() == elements.size());\n+            return loadElementSnippets.toArray(Snippet[]::new);\n+        }\n+    }\n+\n+    \/**\n+     * Some basic information about pagination.\n+     * @param total The total count of elements\n+     * @param pageSize the number or elements to be included in a page\n+     *\/\n+    public static record PagingContext(int total, int pageSize) {\n+        \/**\n+         * If the last page has less elements than given page size.\n+         *\/\n+        public boolean isLastPagePartial() {\n+            return (total % pageSize) != 0;\n+        }\n+\n+        \/**\n+         * The number of pages.\n+         *\/\n+        public int pageCount() {\n+            var pages = total \/ pageSize;\n+            return isLastPagePartial() ? pages + 1 : pages;\n+        }\n+\n+        \/**\n+         * The number of elements in the last page.\n+         *\/\n+        public int lastPageSize() {\n+            if (total == 0) return 0;\n+            var remaining = total % pageSize;\n+            return remaining == 0 ? pageSize : remaining;\n+        }\n+    }\n+\n+    \/**\n+     * Generate bytecodes for loading a collection of elements, support using pagination to avoid\n+     * overloading the 64k code limit.\n+     *\/\n+    public static abstract class CollectionSnippetBuilder {\n+        \/**\n+         * Default page size of string array\n+         *\/\n+        public static final int STRING_PAGE_SIZE = 8000;\n+\n+        \/**\n+         * Default page size of enum array\n+         *\/\n+        public static final int ENUM_PAGE_SIZE = 5000;\n+\n+        \/**\n+         * Good enough for average ~30 bytes per element\n+         *\/\n+        public static final int DEFAULT_PAGE_SIZE = 2000;\n+\n+        \/**\n+         * Default threshold based on 15K code size on ~30 bytes per element\n+         *\/\n+        protected static final int DEFAULT_THRESHOLD = 512;\n+\n+        protected ClassDesc elementType;\n+        protected ClassDesc ownerClassDesc;\n+        protected ClassBuilder clb;\n+\n+        \/\/ Default values, disable pagination by default\n+        protected String methodNamePrefix = null;\n+        protected int activatePagingThreshold = -1;\n+        protected int pageSize = DEFAULT_PAGE_SIZE;\n+\n+        \/**\n+         * @param elementType The element type\n+         *\/\n+        protected CollectionSnippetBuilder(ClassDesc elementType) {\n+            this.elementType = Objects.requireNonNull(elementType);\n+        }\n+\n+        \/**\n+         * Enable pagination if the count of elements is larger than the given threshold.\n+         *\n+         * @param methodNamePrefix The method name prefix for generated paging helper methods\n+         * @param pageSize         The page size\n+         * @param threshold        The element count to actiave the pagination\n+         *\/\n+        public CollectionSnippetBuilder enablePagination(String methodNamePrefix, int pageSize, int threshold) {\n+            return this.pageSize(pageSize)\n+                       .activatePagingThreshold(threshold)\n+                       .methodNamePrefix(methodNamePrefix);\n+        }\n+\n+        \/**\n+         * Enable pagination if the count of elements is larger than pageSize or DEFAULT_THRESHOLD\n+         *\/\n+        public CollectionSnippetBuilder enablePagination(String methodNamePrefix, int pageSize) {\n+            return enablePagination(methodNamePrefix, pageSize, Math.min(pageSize, DEFAULT_THRESHOLD));\n+        }\n+\n+        \/**\n+         * Enable pagination if the count of elements is larger than pageSize or DEFAULT_THRESHOLD\n+         * with page size DEFAULT_PAGE_SIZE.\n+         *\/\n+        public CollectionSnippetBuilder enablePagination(String methodNamePrefix) {\n+            return enablePagination(methodNamePrefix, DEFAULT_PAGE_SIZE, DEFAULT_THRESHOLD);\n+        }\n+\n+        \/**\n+         * Disable pagination. Generated bytecode will always try to construct the collection inline.\n+         *\/\n+        public CollectionSnippetBuilder disablePagination() {\n+            this.activatePagingThreshold = -1;\n+            this.methodNamePrefix = null;\n+            return this;\n+        }\n+\n+        \/**\n+         * Set the threshold of element count to enable pagination.\n+         *\n+         * @param activatePagingThreshold  Use pagination methods if the count of elements is larger\n+         *                                 than the given value\n+         *\/\n+        public CollectionSnippetBuilder activatePagingThreshold(int activatePagingThreshold) {\n+            if (activatePagingThreshold <= 0) {\n+                throw new IllegalArgumentException();\n+            }\n+            this.activatePagingThreshold = activatePagingThreshold;\n+            return this;\n+        }\n+\n+        \/**\n+         * Set the owner class host the pagination methods.\n+         *\n+         * @param ownerClassDesc  The owner class for the pagination methods\n+         *\/\n+        public CollectionSnippetBuilder ownerClassDesc(ClassDesc ownerClassDesc) {\n+            this.ownerClassDesc = Objects.requireNonNull(ownerClassDesc);\n+            return this;\n+        }\n+\n+        \/**\n+         * Set the method name prefix for the pagination methods.\n+         * @param methodNamePrefix  The method name prefix. Generated method will have the name of\n+         *                          this value appended with page number\n+         *\/\n+        public CollectionSnippetBuilder methodNamePrefix(String methodNamePrefix) {\n+            this.methodNamePrefix = Objects.requireNonNull(methodNamePrefix);\n+            if (methodNamePrefix.isBlank()) {\n+                throw new IllegalArgumentException();\n+            }\n+            return this;\n+        }\n+\n+        \/**\n+         * Set the page size. The max page size is STRING_PAGE_SIZE.\n+         * @param pageSize  The count of elements per page*\n+         *\/\n+        public CollectionSnippetBuilder pageSize(int pageSize) {\n+            \/\/ ldc is likely the smallest element snippet\n+            if (pageSize <= 0  || pageSize > STRING_PAGE_SIZE) {\n+                throw new IllegalArgumentException();\n+            }\n+\n+            this.pageSize = pageSize;\n+            return this;\n+        }\n+\n+        \/**\n+         * Set the class builder used to generate the pagination methods.\n+         *\n+         * This value must be set if pagination is needed, otherwise the build\n+         * would lead to NullPointerException.\n+         *\/\n+        public CollectionSnippetBuilder classBuilder(ClassBuilder clb) {\n+            this.clb = Objects.requireNonNull(clb);\n+            return this;\n+        }\n+\n+        protected boolean shouldPaginate(int length) {\n+            return methodNamePrefix != null && activatePagingThreshold > 0 && length > activatePagingThreshold;\n+        }\n+\n+        \/**\n+         * Build the Loadable snippet to load the collection of elements onto\n+         * the operand stack. When pagination is enabled and needed as the total\n+         * count of elements is larger than the given threshold, missing\n+         * required field will lead to NullPointerException.\n+         *\n+         * @param loadElementSnippets The array of Snippets used to load individual\n+         *                            element in the collection.\n+         * @return The Loadable snippet\n+         * @throws NullPointerException\n+         *\/\n+        abstract public Loadable build(Snippet[] loadElementSnippets);\n+    }\n+\n+    \/**\n+     * Generate bytecode to load an array of the given referene type onto the operand stack.\n+     *\n+     * The generated code will create an array inline, and then populate the array either inline or\n+     * by invoking the first pagination method if pagination is activated.\n+     *\n+     * If pagination is activated, pagination methods are generated with the given ClassBuilder\n+     * with method name formatted with the methodNamePrefix appended with page numberand.\n+     * Each pagination method will assign value to the corresponding page and chain calling next page.\n+     *\n+     * Effectively as\n+     *   methodNamePrefix_0(new T[elements.size()]);\n+     *\n+     * where\n+     *   T[] methodNamePrefix_0(T[] ar) {\n+     *      ar[0] = elements[0];\n+     *      ar[1] = elements[1];\n+     *      ...\n+     *      ar[pageSize-1] = elements[pageSize - 1];\n+     *      methodNamePrefix_1(ar);\n+     *      return ar;\n+     *   }\n+     * and the last page will stop the chain and can be partial instead of full page size.\n+     *\/\n+    public static class ArraySnippetBuilder extends CollectionSnippetBuilder {\n+        final MethodTypeDesc MTD_PageHelper;\n+        final ClassDesc classDesc;\n+        Snippet[] loadElementSnippets;\n+\n+        public ArraySnippetBuilder(ClassDesc elementType) {\n+            super(elementType);\n+            classDesc = elementType.arrayType();\n+            MTD_PageHelper = MethodTypeDesc.of(classDesc, classDesc);\n+        }\n+\n+        protected void fill(CodeBuilder cob, int fromIndex, int toIndex) {\n+            for (var index = fromIndex; index < toIndex; index++) {\n+                cob.dup()    \/\/ arrayref\n+                   .loadConstant(index);\n+                loadElementSnippets[index].emit(cob);  \/\/ value\n+                cob.aastore();\n+            }\n+        }\n+\n+        private void invokePageHelper(CodeBuilder cob) {\n+            \/\/ Invoke the first page, which will call next page until fulfilled\n+            cob.loadConstant(loadElementSnippets.length)\n+               .anewarray(elementType)\n+               .invokestatic(ownerClassDesc, methodNamePrefix + \"_0\", MTD_PageHelper);\n+        }\n+\n+        private void newArray(CodeBuilder cob) {\n+            cob.loadConstant(loadElementSnippets.length)\n+               .anewarray(elementType);\n+            fill(cob, 0, loadElementSnippets.length);\n+        }\n+\n+        \/**\n+         * Generate helper methods to fill each page\n+         *\/\n+        private void setupHelpers() {\n+            Objects.requireNonNull(clb);\n+            Objects.requireNonNull(methodNamePrefix);\n+            Objects.requireNonNull(ownerClassDesc);\n+            var lastPageNo = new PagingContext(loadElementSnippets.length, pageSize).pageCount() - 1;\n+            for (int pageNo = 0; pageNo <= lastPageNo; pageNo++) {\n+                genFillPageHelper(pageNo, pageNo < lastPageNo);\n+            }\n+        }\n+\n+        \/\/ each helper function is T[] methodNamePrefix_{pageNo}(T[])\n+        \/\/ fill the page portion and chain calling to fill next page\n+        private void genFillPageHelper(int pageNo, boolean hasNextPage) {\n+            var fromIndex = pageSize * pageNo;\n+            var toIndex = hasNextPage ? (fromIndex + pageSize) : loadElementSnippets.length;\n+            clb.withMethodBody(methodNamePrefix + \"_\" + pageNo,\n+                    MTD_PageHelper,\n+                    ACC_STATIC,\n+                    cob -> {\n+                        cob.aload(0); \/\/ arrayref\n+                        fill(cob, fromIndex, toIndex);\n+                        if (hasNextPage) {\n+                            cob.invokestatic(\n+                                    ownerClassDesc,\n+                                    methodNamePrefix + \"_\" + (pageNo + 1),\n+                                    MTD_PageHelper);\n+                        }\n+                        cob.return_(TypeKind.from(classDesc));\n+                    });\n+        }\n+\n+        @Override\n+        public Loadable build(Snippet[] loadElementSnippets) {\n+            this.loadElementSnippets = Objects.requireNonNull(loadElementSnippets);\n+            if (shouldPaginate(loadElementSnippets.length)) {\n+                setupHelpers();\n+                return new Loadable(classDesc, this::invokePageHelper);\n+            } else {\n+                return new Loadable(classDesc, this::newArray);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Generate bytecodes to load a set onto the operand stack.\n+     *\n+     * The Set is constructed with Set::of method. When there are more than 2\n+     * elements in the set, an array is constructed.\n+     *\/\n+    public static class SetSnippetBuilder extends ArraySnippetBuilder {\n+        public SetSnippetBuilder(ClassDesc elementType) {\n+            super(elementType);\n+        }\n+\n+        private void buildTinySet(CodeBuilder cob) {\n+            for (var snippet: loadElementSnippets) {\n+                snippet.emit(cob);\n+            }\n+            var mtdArgs = new ClassDesc[loadElementSnippets.length];\n+            Arrays.fill(mtdArgs, CD_Object);\n+            cob.invokestatic(CD_Set, \"of\", MethodTypeDesc.of(CD_Set, mtdArgs), true);\n+        }\n+\n+        @Override\n+        public Loadable build(Snippet[] loadElementSnippets) {\n+            if (loadElementSnippets.length <= 2) {\n+                this.loadElementSnippets = loadElementSnippets;\n+                return new Loadable(CD_Set, this::buildTinySet);\n+            } else {\n+                var array = super.build(loadElementSnippets);\n+                return new Loadable(CD_Set, cob -> {\n+                    array.emit(cob);\n+                    cob.invokestatic(CD_Set, \"of\", MethodTypeDesc.of(CD_Set, CD_Object.arrayType()), true);\n+                });\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/Snippets.java","additions":464,"deletions":0,"binary":false,"changes":464,"status":"added"},{"patch":"@@ -0,0 +1,389 @@\n+\/*\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.tools.jlink.internal.plugins;\n+\n+import java.lang.classfile.ClassBuilder;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.constant.ClassDesc;\n+import static java.lang.constant.ConstantDescs.*;\n+\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.module.ModuleDescriptor;\n+import java.lang.module.ModuleDescriptor.Exports;\n+import java.lang.module.ModuleDescriptor.Opens;\n+import java.lang.module.ModuleDescriptor.Provides;\n+import java.lang.module.ModuleDescriptor.Requires;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+\n+import static jdk.tools.jlink.internal.Snippets.*;\n+import static jdk.tools.jlink.internal.Snippets.CollectionSnippetBuilder.STRING_PAGE_SIZE;\n+\n+import jdk.tools.jlink.internal.plugins.SystemModulesPlugin.ModuleInfo;\n+import jdk.tools.jlink.internal.plugins.SystemModulesPlugin.SystemModulesClassGenerator.DedupSnippets;\n+\n+\/**\n+ * Build a Snippet to load a ModuleDescriptor onto the operand stack.\n+ *\/\n+class ModuleDescriptorBuilder implements IndexedElementSnippetBuilder<ModuleInfo> {\n+    private static final ClassDesc CD_MODULE_DESCRIPTOR =\n+        ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor\");\n+    private static final ClassDesc CD_MODULE_BUILDER =\n+        ClassDesc.ofInternalName(\"jdk\/internal\/module\/Builder\");\n+\n+    private final DedupSnippets dedupSnippets;\n+    private final ClassDesc ownerClassDesc;\n+    private final ClassBuilder clb;\n+\n+    ModuleDescriptorBuilder(ClassBuilder clb, DedupSnippets dedupSnippets, ClassDesc ownerClassDesc) {\n+        this.clb = clb;\n+        this.dedupSnippets = dedupSnippets;\n+        this.ownerClassDesc = ownerClassDesc;\n+    }\n+\n+    @Override\n+    public Snippet build(ModuleInfo moduleInfo, int index) {\n+        return new ModuleDescriptorSnippet(clb, moduleInfo.descriptor(), moduleInfo.packages(), index);\n+    }\n+\n+    class ModuleDescriptorSnippet implements Snippet {\n+        static final ClassDesc CD_EXPORTS =\n+            ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Exports\");\n+        static final ClassDesc CD_OPENS =\n+            ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Opens\");\n+        static final ClassDesc CD_PROVIDES =\n+            ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Provides\");\n+        static final ClassDesc CD_REQUIRES =\n+            ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Requires\");\n+\n+        \/\/ method signature for static Builder::newExports, newOpens,\n+        \/\/ newProvides, newRequires methods\n+        static final MethodTypeDesc MTD_EXPORTS_MODIFIER_SET_STRING_SET =\n+            MethodTypeDesc.of(CD_EXPORTS, CD_Set, CD_String, CD_Set);\n+        static final MethodTypeDesc MTD_EXPORTS_MODIFIER_SET_STRING =\n+            MethodTypeDesc.of(CD_EXPORTS, CD_Set, CD_String);\n+        static final MethodTypeDesc MTD_OPENS_MODIFIER_SET_STRING_SET =\n+            MethodTypeDesc.of(CD_OPENS, CD_Set, CD_String, CD_Set);\n+        static final MethodTypeDesc MTD_OPENS_MODIFIER_SET_STRING =\n+            MethodTypeDesc.of(CD_OPENS, CD_Set, CD_String);\n+        static final MethodTypeDesc MTD_PROVIDES_STRING_LIST =\n+            MethodTypeDesc.of(CD_PROVIDES, CD_String, CD_List);\n+        static final MethodTypeDesc MTD_REQUIRES_SET_STRING =\n+            MethodTypeDesc.of(CD_REQUIRES, CD_Set, CD_String);\n+        static final MethodTypeDesc MTD_REQUIRES_SET_STRING_STRING =\n+            MethodTypeDesc.of(CD_REQUIRES, CD_Set, CD_String, CD_String);\n+\n+        \/\/ method signature for Builder instance methods that\n+        \/\/ return this Builder instance\n+        static final MethodTypeDesc MTD_EXPORTS_ARRAY =\n+            MethodTypeDesc.of(CD_MODULE_BUILDER, CD_EXPORTS.arrayType());\n+        static final MethodTypeDesc MTD_OPENS_ARRAY =\n+            MethodTypeDesc.of(CD_MODULE_BUILDER, CD_OPENS.arrayType());\n+        static final MethodTypeDesc MTD_PROVIDES_ARRAY =\n+            MethodTypeDesc.of(CD_MODULE_BUILDER, CD_PROVIDES.arrayType());\n+        static final MethodTypeDesc MTD_REQUIRES_ARRAY =\n+            MethodTypeDesc.of(CD_MODULE_BUILDER, CD_REQUIRES.arrayType());\n+        static final MethodTypeDesc MTD_SET = MethodTypeDesc.of(CD_MODULE_BUILDER, CD_Set);\n+        static final MethodTypeDesc MTD_STRING = MethodTypeDesc.of(CD_MODULE_BUILDER, CD_String);\n+        static final MethodTypeDesc MTD_BOOLEAN = MethodTypeDesc.of(CD_MODULE_BUILDER, CD_boolean);\n+        static final MethodTypeDesc MTD_void_String = MethodTypeDesc.of(CD_void, CD_String);\n+        static final MethodTypeDesc MTD_ModuleDescriptor_int = MethodTypeDesc.of(CD_MODULE_DESCRIPTOR, CD_int);\n+        static final MethodTypeDesc MTD_List_ObjectArray = MethodTypeDesc.of(CD_List, CD_Object.arrayType());\n+\n+        final ModuleDescriptor md;\n+        final int index;\n+        final Snippet requiresArray;\n+        final Snippet exportsArray;\n+        final Snippet opensArray;\n+        final Snippet providesArray;\n+        final Snippet packagesSet;\n+\n+        ModuleDescriptorSnippet(ClassBuilder clb, ModuleDescriptor md, Set<String> packages, int index) {\n+            if (md.isAutomatic()) {\n+                throw new InternalError(\"linking automatic module is not supported\");\n+            }\n+\n+            this.md = md;\n+            this.index = index;\n+            requiresArray = buildRequiresArray(clb);\n+            exportsArray = buildExportsArray(clb);\n+            opensArray = buildOpensArray(clb);\n+            providesArray = buildProvidesArray(clb);\n+            packagesSet = buildPackagesSet(clb, packages);\n+        }\n+\n+        \/*\n+         * Invoke Builder.newRequires(Set<Modifier> mods, String mn, String compiledVersion)\n+         *\n+         * Set<Modifier> mods = ...\n+         * Builder.newRequires(mods, mn, compiledVersion);\n+         *\/\n+        Snippet loadRequire(Requires require) {\n+            return cob -> {\n+                dedupSnippets.requiresModifiersSets().get(require.modifiers()).emit(cob);\n+                cob.loadConstant(require.name());\n+                if (require.compiledVersion().isPresent()) {\n+                    cob.loadConstant(require.compiledVersion().get().toString())\n+                    .invokestatic(CD_MODULE_BUILDER,\n+                                    \"newRequires\",\n+                                    MTD_REQUIRES_SET_STRING_STRING);\n+                } else {\n+                    cob.invokestatic(CD_MODULE_BUILDER,\n+                                    \"newRequires\",\n+                                    MTD_REQUIRES_SET_STRING);\n+                }\n+            };\n+        }\n+\n+        private Snippet buildRequiresArray(ClassBuilder clb) {\n+            return new ArraySnippetBuilder(CD_REQUIRES)\n+                    .enablePagination(\"module\" + index + \"Requires\")\n+                    .classBuilder(clb)\n+                    .ownerClassDesc(ownerClassDesc)\n+                    .build(Snippet.buildAll(sorted(md.requires()), this::loadRequire));\n+        }\n+\n+        \/*\n+         * Invoke\n+         *     Builder.newExports(Set<Exports.Modifier> ms, String pn,\n+         *                        Set<String> targets)\n+         * or\n+         *     Builder.newExports(Set<Exports.Modifier> ms, String pn)\n+         *\n+         * ms = export.modifiers()\n+         * pn = export.source()\n+         * targets = export.targets()\n+         *\/\n+        Snippet loadExports(Exports export) {\n+            return cob -> {\n+                dedupSnippets.exportsModifiersSets().get(export.modifiers()).emit(cob);\n+                cob.loadConstant(export.source());\n+                var targets = export.targets();\n+                if (!targets.isEmpty()) {\n+                    dedupSnippets.stringSets().get(targets).emit(cob);\n+                    cob.invokestatic(CD_MODULE_BUILDER,\n+                                    \"newExports\",\n+                                    MTD_EXPORTS_MODIFIER_SET_STRING_SET);\n+                } else {\n+                    cob.invokestatic(CD_MODULE_BUILDER,\n+                                    \"newExports\",\n+                                    MTD_EXPORTS_MODIFIER_SET_STRING);\n+                }\n+            };\n+        }\n+\n+        private Snippet buildExportsArray(ClassBuilder clb) {\n+            return new ArraySnippetBuilder(CD_EXPORTS)\n+                    .classBuilder(clb)\n+                    .ownerClassDesc(ownerClassDesc)\n+                    .enablePagination(\"module\" + index + \"Exports\")\n+                    .build(Snippet.buildAll(sorted(md.exports()), this::loadExports));\n+        }\n+\n+        \/*\n+         * Invoke\n+         *     Builder.newOpens(Set<Opens.Modifier> ms, String pn,\n+         *                        Set<String> targets)\n+         * or\n+         *     Builder.newOpens(Set<Opens.Modifier> ms, String pn)\n+         *\n+         * ms = open.modifiers()\n+         * pn = open.source()\n+         * targets = open.targets()\n+         * Builder.newOpens(mods, pn, targets);\n+         *\/\n+        Snippet loadOpens(Opens open) {\n+            return cob -> {\n+                dedupSnippets.opensModifiersSets().get(open.modifiers()).emit(cob);\n+                cob.loadConstant(open.source());\n+                var targets = open.targets();\n+                if (!targets.isEmpty()) {\n+                    dedupSnippets.stringSets().get(targets).emit(cob);\n+                    cob.invokestatic(CD_MODULE_BUILDER,\n+                                    \"newOpens\",\n+                                    MTD_OPENS_MODIFIER_SET_STRING_SET);\n+                } else {\n+                    cob.invokestatic(CD_MODULE_BUILDER,\n+                                    \"newOpens\",\n+                                    MTD_OPENS_MODIFIER_SET_STRING);\n+                }\n+            };\n+        }\n+\n+        private Snippet buildOpensArray(ClassBuilder clb) {\n+            return new ArraySnippetBuilder(CD_OPENS)\n+                    .classBuilder(clb)\n+                    .ownerClassDesc(ownerClassDesc)\n+                    .enablePagination(\"module\" + index + \"Opens\")\n+                    .build(Snippet.buildAll(sorted(md.opens()), this::loadOpens));\n+        }\n+\n+        \/*\n+         * Invoke Builder.newProvides(String service, List<String> providers)\n+         *\n+         * service = provide.service()\n+         * providers = List.of(new String[] { provide.providers() }\n+         * Builder.newProvides(service, providers);\n+         *\/\n+        private Snippet loadProvides(ClassBuilder clb, Provides provide, int offset) {\n+            return cob -> {\n+                var providersArray = new ArraySnippetBuilder(CD_String)\n+                        .classBuilder(clb)\n+                        .ownerClassDesc(ownerClassDesc)\n+                        .enablePagination(\"module\" + index + \"Provider\" + offset)\n+                        .pageSize(STRING_PAGE_SIZE)\n+                        .build(Snippet.buildAll(provide.providers(), Snippet::loadConstant));\n+\n+                cob.loadConstant(provide.service());\n+                providersArray.emit(cob);\n+                cob.invokestatic(CD_List,\n+                                \"of\",\n+                                MTD_List_ObjectArray,\n+                                true)\n+                .invokestatic(CD_MODULE_BUILDER,\n+                                \"newProvides\",\n+                                MTD_PROVIDES_STRING_LIST);\n+            };\n+        }\n+\n+        private Snippet buildProvidesArray(ClassBuilder clb) {\n+            IndexedElementSnippetBuilder<Provides> builder = (e, i) -> loadProvides(clb, e, i);\n+            return new ArraySnippetBuilder(CD_PROVIDES)\n+                    .classBuilder(clb)\n+                    .ownerClassDesc(ownerClassDesc)\n+                    .enablePagination(\"module\" + index + \"Provides\")\n+                    .build(builder.buildAll(md.provides()));\n+        }\n+\n+        private Snippet buildPackagesSet(ClassBuilder clb, Collection<String> packages) {\n+            return new SetSnippetBuilder(CD_String)\n+                    .classBuilder(clb)\n+                    .ownerClassDesc(ownerClassDesc)\n+                    .enablePagination(\"module\" + index + \"Packages\")\n+                    .pageSize(STRING_PAGE_SIZE)\n+                    .build(Snippet.buildAll(sorted(packages), Snippet::loadConstant));\n+        }\n+\n+        @Override\n+        public void emit(CodeBuilder cob) {\n+            \/\/ new jdk.internal.module.Builder\n+            cob.new_(CD_MODULE_BUILDER)\n+               .dup()\n+               .loadConstant(md.name())\n+               .invokespecial(CD_MODULE_BUILDER,\n+                              INIT_NAME,\n+                              MTD_void_String);\n+            if (md.isOpen()) {\n+                setModuleBit(cob, \"open\", true);\n+            }\n+            if (md.modifiers().contains(ModuleDescriptor.Modifier.SYNTHETIC)) {\n+                setModuleBit(cob, \"synthetic\", true);\n+            }\n+            if (md.modifiers().contains(ModuleDescriptor.Modifier.MANDATED)) {\n+                setModuleBit(cob, \"mandated\", true);\n+            }\n+\n+            \/\/ requires\n+            requiresArray.emit(cob);\n+            cob.invokevirtual(CD_MODULE_BUILDER,\n+                              \"requires\",\n+                              MTD_REQUIRES_ARRAY);\n+\n+            \/\/ exports\n+            exportsArray.emit(cob);\n+            cob.invokevirtual(CD_MODULE_BUILDER,\n+                    \"exports\",\n+                    MTD_EXPORTS_ARRAY);\n+\n+            \/\/ opens\n+            opensArray.emit(cob);\n+            cob.invokevirtual(CD_MODULE_BUILDER,\n+                              \"opens\",\n+                              MTD_OPENS_ARRAY);\n+\n+            \/\/ uses\n+            dedupSnippets.stringSets().get(md.uses()).emit(cob);\n+            cob.invokevirtual(CD_MODULE_BUILDER,\n+                              \"uses\",\n+                              MTD_SET);\n+\n+            \/\/ provides\n+            providesArray.emit(cob);\n+            cob.invokevirtual(CD_MODULE_BUILDER,\n+                              \"provides\",\n+                              MTD_PROVIDES_ARRAY);\n+\n+            \/\/ all packages\n+            packagesSet.emit(cob);\n+            cob.invokevirtual(CD_MODULE_BUILDER,\n+                              \"packages\",\n+                              MTD_SET);\n+\n+            \/\/ version\n+            md.version().ifPresent(v -> setModuleProperty(cob, \"version\", v.toString()));\n+\n+            \/\/ main class\n+            md.mainClass().ifPresent(cn -> setModuleProperty(cob, \"mainClass\", cn));\n+\n+            cob.loadConstant(md.hashCode())\n+               .invokevirtual(CD_MODULE_BUILDER,\n+                              \"build\",\n+                              MTD_ModuleDescriptor_int);\n+        }\n+\n+        \/*\n+         * Invoke Builder.<methodName>(boolean value)\n+         *\/\n+        void setModuleBit(CodeBuilder cob, String methodName, boolean value) {\n+            cob.loadConstant(value ? 1 : 0)\n+               .invokevirtual(CD_MODULE_BUILDER,\n+                              methodName,\n+                              MTD_BOOLEAN);\n+        }\n+\n+        void setModuleProperty(CodeBuilder cob, String methodName, String value) {\n+            cob.loadConstant(value)\n+               .invokevirtual(CD_MODULE_BUILDER,\n+                              methodName,\n+                              MTD_STRING);\n+        }\n+    }\n+\n+    \/**\n+     * Returns a sorted copy of a collection.\n+     *\n+     * This is useful to ensure a deterministic iteration order.\n+     *\n+     * @return a sorted copy of the given collection.\n+     *\/\n+    private static <T extends Comparable<T>> List<T> sorted(Collection<T> c) {\n+        var l = new ArrayList<>(c);\n+        Collections.sort(l);\n+        return l;\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/ModuleDescriptorBuilder.java","additions":389,"deletions":0,"binary":false,"changes":389,"status":"added"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.constant.ConstantDesc;\n@@ -41,1 +40,0 @@\n-import java.lang.module.ModuleDescriptor.Version;\n@@ -49,1 +47,0 @@\n-import java.util.Arrays;\n@@ -63,1 +60,0 @@\n-import java.util.function.IntSupplier;\n@@ -81,1 +77,0 @@\n-import static java.lang.classfile.ClassFile.*;\n@@ -84,0 +79,3 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n@@ -90,0 +88,5 @@\n+import static java.lang.classfile.ClassFile.*;\n+import static jdk.tools.jlink.internal.Snippets.*;\n+import static jdk.tools.jlink.internal.Snippets.CollectionSnippetBuilder.ENUM_PAGE_SIZE;\n+import static jdk.tools.jlink.internal.Snippets.CollectionSnippetBuilder.STRING_PAGE_SIZE;\n+\n@@ -332,0 +335,11 @@\n+        \/\/ Diagnosis help, can be removed\n+        if (Boolean.parseBoolean(System.getProperty(\"jlink.dumpSystemModuleClass\", \"false\"))) {\n+            try {\n+                var filePath = Path.of(className + \".class\").toAbsolutePath();\n+                System.err.println(\"Write \" + filePath.toString());\n+                Files.createDirectories(filePath.getParent());\n+                Files.write(filePath, bytes);\n+            } catch (IOException ioe) {\n+                ioe.printStackTrace(System.err);\n+            }\n+        }\n@@ -516,8 +530,0 @@\n-        private static final ClassDesc CD_MODULE_BUILDER =\n-            ClassDesc.ofInternalName(\"jdk\/internal\/module\/Builder\");\n-        private static final ClassDesc CD_REQUIRES_MODIFIER =\n-            ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Requires$Modifier\");\n-        private static final ClassDesc CD_EXPORTS_MODIFIER =\n-            ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Exports$Modifier\");\n-        private static final ClassDesc CD_OPENS_MODIFIER =\n-            ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Opens$Modifier\");\n@@ -541,1 +547,0 @@\n-        private static final MethodTypeDesc MTD_Set_ObjectArray = MethodTypeDesc.of(CD_Set, CD_Object.arrayType());\n@@ -545,1 +550,0 @@\n-        private final int MD_VAR         = 1;  \/\/ variable for ModuleDescriptor\n@@ -548,3 +552,1 @@\n-        private final int DEDUP_LIST_VAR = 2;\n-        private final int BUILDER_VAR    = 3;\n-        private int nextLocalVar         = 4;  \/\/ index to next local variable\n+        private final int BUILDER_VAR    = 2;\n@@ -563,2 +565,2 @@\n-        private final DedupSetBuilder dedupSetBuilder\n-            = new DedupSetBuilder(this::getNextLocalVar);\n+        private final DedupSetBuilder dedupSetBuilder;\n+        private final ArrayList<Snippet> clinitSnippets = new ArrayList<>();\n@@ -572,0 +574,1 @@\n+            this.dedupSetBuilder = new DedupSetBuilder(this.classDesc);\n@@ -575,4 +578,0 @@\n-        private int getNextLocalVar() {\n-            return nextLocalVar++;\n-        }\n-\n@@ -639,0 +638,3 @@\n+\n+                        \/\/ generate static initializer\n+                        genClassInitializer(clb);\n@@ -657,0 +659,13 @@\n+        private void genClassInitializer(ClassBuilder clb) {\n+            if (!clinitSnippets.isEmpty()) {\n+                clb.withMethodBody(\n+                        CLASS_INIT_NAME,\n+                        MTD_void,\n+                        ACC_STATIC,\n+                        cob -> {\n+                            clinitSnippets.forEach(s -> s.emit(cob));\n+                            cob.return_();\n+                        });\n+            }\n+        }\n+\n@@ -697,23 +712,2 @@\n-            if (moduleInfos.size() <= moduleDescriptorsPerMethod) {\n-                clb.withMethodBody(\n-                        \"moduleDescriptors\",\n-                        MTD_ModuleDescriptorArray,\n-                        ACC_PUBLIC,\n-                        cob -> {\n-                            cob.loadConstant(moduleInfos.size())\n-                               .anewarray(CD_MODULE_DESCRIPTOR)\n-                               .astore(MD_VAR);\n-\n-                            for (int index = 0; index < moduleInfos.size(); index++) {\n-                                ModuleInfo minfo = moduleInfos.get(index);\n-                                new ModuleDescriptorBuilder(cob,\n-                                                            minfo.descriptor(),\n-                                                            minfo.packages(),\n-                                                            index).build();\n-                            }\n-                            cob.aload(MD_VAR)\n-                               .areturn();\n-                        });\n-                return;\n-            }\n-\n+            var dedupSets = dedupSetBuilder.build(clb);\n+            dedupSets.cacheSetupSnippet().ifPresent(clinitSnippets::add);\n@@ -721,40 +715,7 @@\n-            \/\/ Split the module descriptors be created by multiple helper methods.\n-            \/\/ Each helper method \"subi\" creates the maximum N number of module descriptors\n-            \/\/     mi, m{i+1} ...\n-            \/\/ to avoid exceeding the 64kb limit of method length.  Then it will call\n-            \/\/ \"sub{i+1}\" to creates the next batch of module descriptors m{i+n}, m{i+n+1}...\n-            \/\/ and so on.  During the construction of the module descriptors, the string sets and\n-            \/\/ modifier sets are deduplicated (see SystemModulesClassGenerator.DedupSetBuilder)\n-            \/\/ and cached in the locals. These locals are saved in an array list so\n-            \/\/ that the helper method can restore the local variables that may be\n-            \/\/ referenced by the bytecode generated for creating module descriptors.\n-            \/\/ Pseudo code looks like this:\n-            \/\/\n-            \/\/ void subi(ModuleDescriptor[] mdescs, ArrayList<Object> localvars) {\n-            \/\/      \/\/ assign localvars to local variables\n-            \/\/      var l3 = localvars.get(0);\n-            \/\/      var l4 = localvars.get(1);\n-            \/\/        :\n-            \/\/      \/\/ fill mdescs[i] to mdescs[i+n-1]\n-            \/\/      mdescs[i] = ...\n-            \/\/      mdescs[i+1] = ...\n-            \/\/        :\n-            \/\/      \/\/ save new local variables added\n-            \/\/      localvars.add(lx)\n-            \/\/      localvars.add(l{x+1})\n-            \/\/        :\n-            \/\/      sub{i+i}(mdescs, localvars);\n-            \/\/ }\n-\n-            List<List<ModuleInfo>> splitModuleInfos = new ArrayList<>();\n-            List<ModuleInfo> currentModuleInfos = null;\n-            for (int index = 0; index < moduleInfos.size(); index++) {\n-                if (index % moduleDescriptorsPerMethod == 0) {\n-                    currentModuleInfos = new ArrayList<>();\n-                    splitModuleInfos.add(currentModuleInfos);\n-                }\n-                currentModuleInfos.add(moduleInfos.get(index));\n-            }\n-\n-            String helperMethodNamePrefix = \"sub\";\n-            ClassDesc arrayListClassDesc = ClassDesc.ofInternalName(\"java\/util\/ArrayList\");\n+            var converter = new ModuleDescriptorBuilder(clb, dedupSets, classDesc);\n+            var elementSnippets = converter.buildAll(moduleInfos);\n+            var moduleDescriptors = new ArraySnippetBuilder(CD_MODULE_DESCRIPTOR)\n+                    .classBuilder(clb)\n+                    .ownerClassDesc(classDesc)\n+                    .enablePagination(\"sub\", moduleDescriptorsPerMethod)\n+                    .build(elementSnippets);\n@@ -767,18 +728,2 @@\n-                        cob.loadConstant(moduleInfos.size())\n-                           .anewarray(CD_MODULE_DESCRIPTOR)\n-                           .dup()\n-                           .astore(MD_VAR);\n-                        cob.new_(arrayListClassDesc)\n-                           .dup()\n-                           .loadConstant(moduleInfos.size())\n-                           .invokespecial(arrayListClassDesc, INIT_NAME, MethodTypeDesc.of(CD_void, CD_int))\n-                           .astore(DEDUP_LIST_VAR);\n-                        cob.aload(0)\n-                           .aload(MD_VAR)\n-                           .aload(DEDUP_LIST_VAR)\n-                           .invokevirtual(\n-                                   this.classDesc,\n-                                   helperMethodNamePrefix + \"0\",\n-                                   MethodTypeDesc.of(CD_void, CD_MODULE_DESCRIPTOR.arrayType(), arrayListClassDesc)\n-                           )\n-                           .areturn();\n+                        moduleDescriptors.emit(cob);\n+                        cob.areturn();\n@@ -786,51 +731,0 @@\n-\n-            int dedupVarStart = nextLocalVar;\n-            for (int n = 0, count = 0; n < splitModuleInfos.size(); count += splitModuleInfos.get(n).size(), n++) {\n-                int index = n;       \/\/ the index of which ModuleInfo being processed in the current batch\n-                int start = count;   \/\/ the start index to the return ModuleDescriptor array for the current batch\n-                int curDedupVar = nextLocalVar;\n-                clb.withMethodBody(\n-                        helperMethodNamePrefix + index,\n-                        MethodTypeDesc.of(CD_void, CD_MODULE_DESCRIPTOR.arrayType(), arrayListClassDesc),\n-                        ACC_PUBLIC,\n-                        cob -> {\n-                            if (curDedupVar > dedupVarStart) {\n-                                for (int i = dedupVarStart; i < curDedupVar; i++) {\n-                                    cob.aload(DEDUP_LIST_VAR)\n-                                       .loadConstant(i - dedupVarStart)\n-                                       .invokevirtual(arrayListClassDesc, \"get\", MethodTypeDesc.of(CD_Object, CD_int))\n-                                       .astore(i);\n-                                }\n-                            }\n-\n-                            List<ModuleInfo> currentBatch = splitModuleInfos.get(index);\n-                            for (int j = 0; j < currentBatch.size(); j++) {\n-                                ModuleInfo minfo = currentBatch.get(j);\n-                                new ModuleDescriptorBuilder(cob,\n-                                                            minfo.descriptor(),\n-                                                            minfo.packages(),\n-                                                            start + j).build();\n-                            }\n-\n-                            if (index < splitModuleInfos.size() - 1) {\n-                                if (nextLocalVar > curDedupVar) {\n-                                    for (int i = curDedupVar; i < nextLocalVar; i++) {\n-                                        cob.aload(DEDUP_LIST_VAR)\n-                                           .aload(i)\n-                                           .invokevirtual(arrayListClassDesc, \"add\", MethodTypeDesc.of(CD_boolean, CD_Object))\n-                                           .pop();\n-                                    }\n-                                }\n-                                cob.aload(0)\n-                                   .aload(MD_VAR)\n-                                   .aload(DEDUP_LIST_VAR)\n-                                   .invokevirtual(\n-                                           this.classDesc,\n-                                           helperMethodNamePrefix + (index+1),\n-                                           MethodTypeDesc.of(CD_void, CD_MODULE_DESCRIPTOR.arrayType(), arrayListClassDesc)\n-                                   );\n-                            }\n-\n-                            cob.return_();\n-                        });\n-            }\n@@ -980,0 +874,1 @@\n+                        int setBuilt = 0;\n@@ -991,1 +886,1 @@\n-                                genImmutableSet(cob, s);\n+                                genImmutableSet(clb, cob, s, methodName + setBuilt++);\n@@ -1018,1 +913,1 @@\n-                                genImmutableSet(cob, s);\n+                                genImmutableSet(clb, cob, s, methodName + setBuilt++);\n@@ -1043,443 +938,8 @@\n-        private void genImmutableSet(CodeBuilder cob, Set<String> set) {\n-            int size = set.size();\n-\n-            \/\/ use Set.of(Object[]) when there are more than 2 elements\n-            \/\/ use Set.of(Object) or Set.of(Object, Object) when fewer\n-            if (size > 2) {\n-                cob.loadConstant(size)\n-                   .anewarray(CD_String);\n-                int i = 0;\n-                for (String element : sorted(set)) {\n-                    cob.dup()\n-                       .loadConstant(i)\n-                       .loadConstant(element)\n-                       .aastore();\n-                    i++;\n-                }\n-                cob.invokestatic(CD_Set,\n-                                 \"of\",\n-                                 MTD_Set_ObjectArray,\n-                                 true);\n-            } else {\n-                for (String element : sorted(set)) {\n-                    cob.loadConstant(element);\n-                }\n-                var mtdArgs = new ClassDesc[size];\n-                Arrays.fill(mtdArgs, CD_Object);\n-                cob.invokestatic(CD_Set,\n-                                 \"of\",\n-                                 MethodTypeDesc.of(CD_Set, mtdArgs),\n-                                 true);\n-            }\n-        }\n-\n-        class ModuleDescriptorBuilder {\n-            static final ClassDesc CD_EXPORTS =\n-                ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Exports\");\n-            static final ClassDesc CD_OPENS =\n-                ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Opens\");\n-            static final ClassDesc CD_PROVIDES =\n-                ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Provides\");\n-            static final ClassDesc CD_REQUIRES =\n-                ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Requires\");\n-\n-            \/\/ method signature for static Builder::newExports, newOpens,\n-            \/\/ newProvides, newRequires methods\n-            static final MethodTypeDesc MTD_EXPORTS_MODIFIER_SET_STRING_SET =\n-                MethodTypeDesc.of(CD_EXPORTS, CD_Set, CD_String, CD_Set);\n-            static final MethodTypeDesc MTD_EXPORTS_MODIFIER_SET_STRING =\n-                MethodTypeDesc.of(CD_EXPORTS, CD_Set, CD_String);\n-            static final MethodTypeDesc MTD_OPENS_MODIFIER_SET_STRING_SET =\n-                MethodTypeDesc.of(CD_OPENS, CD_Set, CD_String, CD_Set);\n-            static final MethodTypeDesc MTD_OPENS_MODIFIER_SET_STRING =\n-                MethodTypeDesc.of(CD_OPENS, CD_Set, CD_String);\n-            static final MethodTypeDesc MTD_PROVIDES_STRING_LIST =\n-                MethodTypeDesc.of(CD_PROVIDES, CD_String, CD_List);\n-            static final MethodTypeDesc MTD_REQUIRES_SET_STRING =\n-                MethodTypeDesc.of(CD_REQUIRES, CD_Set, CD_String);\n-            static final MethodTypeDesc MTD_REQUIRES_SET_STRING_STRING =\n-                MethodTypeDesc.of(CD_REQUIRES, CD_Set, CD_String, CD_String);\n-\n-            \/\/ method signature for Builder instance methods that\n-            \/\/ return this Builder instance\n-            static final MethodTypeDesc MTD_EXPORTS_ARRAY =\n-                MethodTypeDesc.of(CD_MODULE_BUILDER, CD_EXPORTS.arrayType());\n-            static final MethodTypeDesc MTD_OPENS_ARRAY =\n-                MethodTypeDesc.of(CD_MODULE_BUILDER, CD_OPENS.arrayType());\n-            static final MethodTypeDesc MTD_PROVIDES_ARRAY =\n-                MethodTypeDesc.of(CD_MODULE_BUILDER, CD_PROVIDES.arrayType());\n-            static final MethodTypeDesc MTD_REQUIRES_ARRAY =\n-                MethodTypeDesc.of(CD_MODULE_BUILDER, CD_REQUIRES.arrayType());\n-            static final MethodTypeDesc MTD_SET = MethodTypeDesc.of(CD_MODULE_BUILDER, CD_Set);\n-            static final MethodTypeDesc MTD_STRING = MethodTypeDesc.of(CD_MODULE_BUILDER, CD_String);\n-            static final MethodTypeDesc MTD_BOOLEAN = MethodTypeDesc.of(CD_MODULE_BUILDER, CD_boolean);\n-            static final MethodTypeDesc MTD_void_String = MethodTypeDesc.of(CD_void, CD_String);\n-            static final MethodTypeDesc MTD_ModuleDescriptor_int = MethodTypeDesc.of(CD_MODULE_DESCRIPTOR, CD_int);\n-            static final MethodTypeDesc MTD_List_ObjectArray = MethodTypeDesc.of(CD_List, CD_Object.arrayType());\n-\n-            final CodeBuilder cob;\n-            final ModuleDescriptor md;\n-            final Set<String> packages;\n-            final int index;\n-\n-            ModuleDescriptorBuilder(CodeBuilder cob, ModuleDescriptor md, Set<String> packages, int index) {\n-                if (md.isAutomatic()) {\n-                    throw new InternalError(\"linking automatic module is not supported\");\n-                }\n-                this.cob = cob;\n-                this.md = md;\n-                this.packages = packages;\n-                this.index = index;\n-            }\n-\n-            void build() {\n-                \/\/ new jdk.internal.module.Builder\n-                newBuilder();\n-\n-                \/\/ requires\n-                requires(md.requires());\n-\n-                \/\/ exports\n-                exports(md.exports());\n-\n-                \/\/ opens\n-                opens(md.opens());\n-\n-                \/\/ uses\n-                uses(md.uses());\n-\n-                \/\/ provides\n-                provides(md.provides());\n-\n-                \/\/ all packages\n-                packages(packages);\n-\n-                \/\/ version\n-                md.version().ifPresent(this::version);\n-\n-                \/\/ main class\n-                md.mainClass().ifPresent(this::mainClass);\n-\n-                putModuleDescriptor();\n-            }\n-\n-            void newBuilder() {\n-                cob.new_(CD_MODULE_BUILDER)\n-                   .dup()\n-                   .loadConstant(md.name())\n-                   .invokespecial(CD_MODULE_BUILDER,\n-                                  INIT_NAME,\n-                                  MTD_void_String)\n-                   .astore(BUILDER_VAR);\n-\n-                if (md.isOpen()) {\n-                    setModuleBit(\"open\", true);\n-                }\n-                if (md.modifiers().contains(ModuleDescriptor.Modifier.SYNTHETIC)) {\n-                    setModuleBit(\"synthetic\", true);\n-                }\n-                if (md.modifiers().contains(ModuleDescriptor.Modifier.MANDATED)) {\n-                    setModuleBit(\"mandated\", true);\n-                }\n-            }\n-\n-            \/*\n-             * Invoke Builder.<methodName>(boolean value)\n-             *\/\n-            void setModuleBit(String methodName, boolean value) {\n-                cob.aload(BUILDER_VAR)\n-                   .loadConstant(value ? 1 : 0)\n-                   .invokevirtual(CD_MODULE_BUILDER,\n-                                  methodName,\n-                                  MTD_BOOLEAN)\n-                   .pop();\n-            }\n-\n-            \/*\n-             * Put ModuleDescriptor into the modules array\n-             *\/\n-            void putModuleDescriptor() {\n-                cob.aload(MD_VAR)\n-                   .loadConstant(index)\n-                   .aload(BUILDER_VAR)\n-                   .loadConstant(md.hashCode())\n-                   .invokevirtual(CD_MODULE_BUILDER,\n-                                  \"build\",\n-                                  MTD_ModuleDescriptor_int)\n-                   .aastore();\n-            }\n-\n-            \/*\n-             * Call Builder::newRequires to create Requires instances and\n-             * then pass it to the builder by calling:\n-             *      Builder.requires(Requires[])\n-             *\n-             *\/\n-            void requires(Set<Requires> requires) {\n-                cob.aload(BUILDER_VAR)\n-                   .loadConstant(requires.size())\n-                   .anewarray(CD_REQUIRES);\n-                int arrayIndex = 0;\n-                for (Requires require : sorted(requires)) {\n-                    String compiledVersion = null;\n-                    if (require.compiledVersion().isPresent()) {\n-                        compiledVersion = require.compiledVersion().get().toString();\n-                    }\n-\n-                    cob.dup()               \/\/ arrayref\n-                       .loadConstant(arrayIndex++);\n-                    newRequires(require.modifiers(), require.name(), compiledVersion);\n-                    cob.aastore();\n-                }\n-                cob.invokevirtual(CD_MODULE_BUILDER,\n-                                  \"requires\",\n-                                  MTD_REQUIRES_ARRAY)\n-                    .pop();\n-            }\n-\n-            \/*\n-             * Invoke Builder.newRequires(Set<Modifier> mods, String mn, String compiledVersion)\n-             *\n-             * Set<Modifier> mods = ...\n-             * Builder.newRequires(mods, mn, compiledVersion);\n-             *\/\n-            void newRequires(Set<Requires.Modifier> mods, String name, String compiledVersion) {\n-                int varIndex = dedupSetBuilder.indexOfRequiresModifiers(cob, mods);\n-                cob.aload(varIndex)\n-                   .loadConstant(name);\n-                if (compiledVersion != null) {\n-                    cob.loadConstant(compiledVersion)\n-                       .invokestatic(CD_MODULE_BUILDER,\n-                                     \"newRequires\",\n-                                     MTD_REQUIRES_SET_STRING_STRING);\n-                } else {\n-                    cob.invokestatic(CD_MODULE_BUILDER,\n-                                     \"newRequires\",\n-                                     MTD_REQUIRES_SET_STRING);\n-                }\n-            }\n-\n-            \/*\n-             * Call Builder::newExports to create Exports instances and\n-             * then pass it to the builder by calling:\n-             *      Builder.exports(Exports[])\n-             *\n-             *\/\n-            void exports(Set<Exports> exports) {\n-                cob.aload(BUILDER_VAR)\n-                   .loadConstant(exports.size())\n-                   .anewarray(CD_EXPORTS);\n-                int arrayIndex = 0;\n-                for (Exports export : sorted(exports)) {\n-                    cob.dup()    \/\/ arrayref\n-                       .loadConstant(arrayIndex++);\n-                    newExports(export.modifiers(), export.source(), export.targets());\n-                    cob.aastore();\n-                }\n-                cob.invokevirtual(CD_MODULE_BUILDER,\n-                                  \"exports\",\n-                                  MTD_EXPORTS_ARRAY)\n-                    .pop();\n-            }\n-\n-            \/*\n-             * Invoke\n-             *     Builder.newExports(Set<Exports.Modifier> ms, String pn,\n-             *                        Set<String> targets)\n-             * or\n-             *     Builder.newExports(Set<Exports.Modifier> ms, String pn)\n-             *\n-             * Set<String> targets = new HashSet<>();\n-             * targets.add(t);\n-             * :\n-             * :\n-             *\n-             * Set<Modifier> mods = ...\n-             * Builder.newExports(mods, pn, targets);\n-             *\/\n-            void newExports(Set<Exports.Modifier> ms, String pn, Set<String> targets) {\n-                int modifiersSetIndex = dedupSetBuilder.indexOfExportsModifiers(cob, ms);\n-                if (!targets.isEmpty()) {\n-                    int stringSetIndex = dedupSetBuilder.indexOfStringSet(cob, targets);\n-                    cob.aload(modifiersSetIndex)\n-                       .loadConstant(pn)\n-                       .aload(stringSetIndex)\n-                       .invokestatic(CD_MODULE_BUILDER,\n-                                     \"newExports\",\n-                                     MTD_EXPORTS_MODIFIER_SET_STRING_SET);\n-                } else {\n-                    cob.aload(modifiersSetIndex)\n-                       .loadConstant(pn)\n-                       .invokestatic(CD_MODULE_BUILDER,\n-                                     \"newExports\",\n-                                     MTD_EXPORTS_MODIFIER_SET_STRING);\n-                }\n-            }\n-\n-\n-            \/**\n-             * Call Builder::newOpens to create Opens instances and\n-             * then pass it to the builder by calling:\n-             * Builder.opens(Opens[])\n-             *\/\n-            void opens(Set<Opens> opens) {\n-                cob.aload(BUILDER_VAR)\n-                   .loadConstant(opens.size())\n-                   .anewarray(CD_OPENS);\n-                int arrayIndex = 0;\n-                for (Opens open : sorted(opens)) {\n-                    cob.dup()    \/\/ arrayref\n-                       .loadConstant(arrayIndex++);\n-                    newOpens(open.modifiers(), open.source(), open.targets());\n-                    cob.aastore();\n-                }\n-                cob.invokevirtual(CD_MODULE_BUILDER,\n-                                  \"opens\",\n-                                  MTD_OPENS_ARRAY)\n-                    .pop();\n-            }\n-\n-            \/*\n-             * Invoke\n-             *     Builder.newOpens(Set<Opens.Modifier> ms, String pn,\n-             *                        Set<String> targets)\n-             * or\n-             *     Builder.newOpens(Set<Opens.Modifier> ms, String pn)\n-             *\n-             * Set<String> targets = new HashSet<>();\n-             * targets.add(t);\n-             * :\n-             * :\n-             *\n-             * Set<Modifier> mods = ...\n-             * Builder.newOpens(mods, pn, targets);\n-             *\/\n-            void newOpens(Set<Opens.Modifier> ms, String pn, Set<String> targets) {\n-                int modifiersSetIndex = dedupSetBuilder.indexOfOpensModifiers(cob, ms);\n-                if (!targets.isEmpty()) {\n-                    int stringSetIndex = dedupSetBuilder.indexOfStringSet(cob, targets);\n-                    cob.aload(modifiersSetIndex)\n-                       .loadConstant(pn)\n-                       .aload(stringSetIndex)\n-                       .invokestatic(CD_MODULE_BUILDER,\n-                                     \"newOpens\",\n-                                     MTD_OPENS_MODIFIER_SET_STRING_SET);\n-                } else {\n-                    cob.aload(modifiersSetIndex)\n-                       .loadConstant(pn)\n-                       .invokestatic(CD_MODULE_BUILDER,\n-                                     \"newOpens\",\n-                                     MTD_OPENS_MODIFIER_SET_STRING);\n-                }\n-            }\n-\n-            \/*\n-             * Invoke Builder.uses(Set<String> uses)\n-             *\/\n-            void uses(Set<String> uses) {\n-                int varIndex = dedupSetBuilder.indexOfStringSet(cob, uses);\n-                cob.aload(BUILDER_VAR)\n-                   .aload(varIndex)\n-                   .invokevirtual(CD_MODULE_BUILDER,\n-                                  \"uses\",\n-                                  MTD_SET)\n-                   .pop();\n-            }\n-\n-            \/*\n-            * Call Builder::newProvides to create Provides instances and\n-            * then pass it to the builder by calling:\n-            *      Builder.provides(Provides[] provides)\n-            *\n-            *\/\n-            void provides(Collection<Provides> provides) {\n-                cob.aload(BUILDER_VAR)\n-                   .loadConstant(provides.size())\n-                   .anewarray(CD_PROVIDES);\n-                int arrayIndex = 0;\n-                for (Provides provide : sorted(provides)) {\n-                    cob.dup()    \/\/ arrayref\n-                       .loadConstant(arrayIndex++);\n-                    newProvides(provide.service(), provide.providers());\n-                    cob.aastore();\n-                }\n-                cob.invokevirtual(CD_MODULE_BUILDER,\n-                                  \"provides\",\n-                                  MTD_PROVIDES_ARRAY)\n-                    .pop();\n-            }\n-\n-            \/*\n-             * Invoke Builder.newProvides(String service, Set<String> providers)\n-             *\n-             * Set<String> providers = new HashSet<>();\n-             * providers.add(impl);\n-             * :\n-             * :\n-             * Builder.newProvides(service, providers);\n-             *\/\n-            void newProvides(String service, List<String> providers) {\n-                cob.loadConstant(service)\n-                   .loadConstant(providers.size())\n-                   .anewarray(CD_String);\n-                int arrayIndex = 0;\n-                for (String provider : providers) {\n-                    cob.dup()    \/\/ arrayref\n-                       .loadConstant(arrayIndex++)\n-                       .loadConstant(provider)\n-                       .aastore();\n-                }\n-                cob.invokestatic(CD_List,\n-                                 \"of\",\n-                                 MTD_List_ObjectArray,\n-                                 true)\n-                   .invokestatic(CD_MODULE_BUILDER,\n-                                 \"newProvides\",\n-                                 MTD_PROVIDES_STRING_LIST);\n-            }\n-\n-            \/*\n-             * Invoke Builder.packages(String pn)\n-             *\/\n-            void packages(Set<String> packages) {\n-                int varIndex = dedupSetBuilder.newStringSet(cob, packages);\n-                cob.aload(BUILDER_VAR)\n-                   .aload(varIndex)\n-                   .invokevirtual(CD_MODULE_BUILDER,\n-                                  \"packages\",\n-                                  MTD_SET)\n-                   .pop();\n-            }\n-\n-            \/*\n-             * Invoke Builder.mainClass(String cn)\n-             *\/\n-            void mainClass(String cn) {\n-                cob.aload(BUILDER_VAR)\n-                   .loadConstant(cn)\n-                   .invokevirtual(CD_MODULE_BUILDER,\n-                                  \"mainClass\",\n-                                  MTD_STRING)\n-                   .pop();\n-            }\n-\n-            \/*\n-             * Invoke Builder.version(Version v);\n-             *\/\n-            void version(Version v) {\n-                cob.aload(BUILDER_VAR)\n-                   .loadConstant(v.toString())\n-                   .invokevirtual(CD_MODULE_BUILDER,\n-                                  \"version\",\n-                                  MTD_STRING)\n-                   .pop();\n-            }\n-\n-            void invokeBuilderMethod(String methodName, String value) {\n-                cob.aload(BUILDER_VAR)\n-                   .loadConstant(value)\n-                   .invokevirtual(CD_MODULE_BUILDER,\n-                                  methodName,\n-                                  MTD_STRING)\n-                   .pop();\n-            }\n+        private void genImmutableSet(ClassBuilder clb, CodeBuilder cob, Set<String> set, String methodNamePrefix) {\n+            var snippets = Snippet.buildAll(sorted(set), Snippet::loadConstant);\n+            new SetSnippetBuilder(CD_String)\n+                    .classBuilder(clb)\n+                    .ownerClassDesc(classDesc)\n+                    .enablePagination(methodNamePrefix, STRING_PAGE_SIZE)\n+                    .build(snippets)\n+                    .emit(cob);\n@@ -1580,0 +1040,11 @@\n+        \/*\n+         * Snippets to load the deduplicated set onto the operand stack.\n+         * Set referenced more than once will be read from the cache, cacheSetupSnippet contains\n+         * the bytecode to populate that cache.\n+         *\/\n+        static record DedupSnippets(Map<Set<String>, Snippet> stringSets,\n+                                    Map<Set<Requires.Modifier>, Snippet> requiresModifiersSets,\n+                                    Map<Set<Opens.Modifier>, Snippet> opensModifiersSets,\n+                                    Map<Set<Exports.Modifier>, Snippet> exportsModifiersSets,\n+                                    Optional<Snippet> cacheSetupSnippet) {};\n+\n@@ -1584,7 +1055,2 @@\n-            \/\/ map Set<String> to a specialized builder to allow them to be\n-            \/\/ deduplicated as they are requested\n-            final Map<Set<String>, SetBuilder<String>> stringSets = new HashMap<>();\n-\n-            \/\/ map Set<Requires.Modifier> to a specialized builder to allow them to be\n-            \/\/ deduplicated as they are requested\n-            final Map<Set<Requires.Modifier>, EnumSetBuilder<Requires.Modifier>>\n+            final Map<Set<String>, RefCounter<String>> stringSets = new HashMap<>();\n+            final Map<Set<Requires.Modifier>, RefCounter<Requires.Modifier>>\n@@ -1592,4 +1058,1 @@\n-\n-            \/\/ map Set<Exports.Modifier> to a specialized builder to allow them to be\n-            \/\/ deduplicated as they are requested\n-            final Map<Set<Exports.Modifier>, EnumSetBuilder<Exports.Modifier>>\n+            final Map<Set<Exports.Modifier>, RefCounter<Exports.Modifier>>\n@@ -1597,4 +1060,1 @@\n-\n-            \/\/ map Set<Opens.Modifier> to a specialized builder to allow them to be\n-            \/\/ deduplicated as they are requested\n-            final Map<Set<Opens.Modifier>, EnumSetBuilder<Opens.Modifier>>\n+            final Map<Set<Opens.Modifier>, RefCounter<Opens.Modifier>>\n@@ -1603,3 +1063,3 @@\n-            private final int stringSetVar;\n-            private final int enumSetVar;\n-            private final IntSupplier localVarSupplier;\n+            final ClassDesc owner;\n+            final CacheBuilder cacheBuilder = new CacheBuilder();\n+            int setBuilt = 0;\n@@ -1607,4 +1067,2 @@\n-            DedupSetBuilder(IntSupplier localVarSupplier) {\n-                this.stringSetVar = localVarSupplier.getAsInt();\n-                this.enumSetVar = localVarSupplier.getAsInt();\n-                this.localVarSupplier = localVarSupplier;\n+            DedupSetBuilder(ClassDesc owner) {\n+                this.owner = owner;\n@@ -1617,3 +1075,1 @@\n-                stringSets.computeIfAbsent(strings,\n-                    s -> new SetBuilder<>(s, stringSetVar, localVarSupplier)\n-                ).increment();\n+                stringSets.computeIfAbsent(strings, RefCounter<String>::new).increment();\n@@ -1626,4 +1082,1 @@\n-                exportsModifiersSets.computeIfAbsent(mods, s ->\n-                                new EnumSetBuilder<>(s, CD_EXPORTS_MODIFIER,\n-                                        enumSetVar, localVarSupplier)\n-                ).increment();\n+                exportsModifiersSets.computeIfAbsent(mods, RefCounter<Exports.Modifier>::new).increment();\n@@ -1636,4 +1089,1 @@\n-                opensModifiersSets.computeIfAbsent(mods, s ->\n-                                new EnumSetBuilder<>(s, CD_OPENS_MODIFIER,\n-                                        enumSetVar, localVarSupplier)\n-                ).increment();\n+                opensModifiersSets.computeIfAbsent(mods, RefCounter::new).increment();\n@@ -1646,4 +1096,1 @@\n-                requiresModifiersSets.computeIfAbsent(mods, s ->\n-                    new EnumSetBuilder<>(s, CD_REQUIRES_MODIFIER,\n-                                         enumSetVar, localVarSupplier)\n-                ).increment();\n+                requiresModifiersSets.computeIfAbsent(mods, RefCounter::new).increment();\n@@ -1653,2 +1100,2 @@\n-             * Retrieve the index to the given set of Strings. Emit code to\n-             * generate it when SetBuilder::build is called.\n+             * Generate bytecode to load a set onto the operand stack.\n+             * Use cache if the set is referenced more than once.\n@@ -1656,2 +1103,7 @@\n-            int indexOfStringSet(CodeBuilder cob, Set<String> names) {\n-                return stringSets.get(names).build(cob);\n+            private Snippet buildStringSet(ClassBuilder clb, RefCounter<String> setRef) {\n+                return cacheBuilder.transform(setRef,\n+                        new SetSnippetBuilder(CD_String)\n+                                .classBuilder(clb)\n+                                .ownerClassDesc(owner)\n+                                .enablePagination(\"dedupSet\" + setBuilt++, STRING_PAGE_SIZE)\n+                                .build(Snippet.buildAll(setRef.sortedList(), Snippet::loadConstant)));\n@@ -1661,2 +1113,2 @@\n-             * Retrieve the index to the given set of Exports.Modifier.\n-             * Emit code to generate it when EnumSetBuilder::build is called.\n+             * Generate the mapping from a set to the bytecode loading the set onto the operand stack.\n+             * Ordering the sets to ensure same generated bytecode.\n@@ -1664,2 +1116,6 @@\n-            int indexOfExportsModifiers(CodeBuilder cob, Set<Exports.Modifier> mods) {\n-                return exportsModifiersSets.get(mods).build(cob);\n+            private Map<Set<String>, Snippet> buildStringSets(ClassBuilder clb, Map<Set<String>, RefCounter<String>> map) {\n+                Map<Set<String>, Snippet> snippets = new HashMap<>(map.size());\n+                map.entrySet().stream()\n+                        .sorted(Map.Entry.comparingByValue())\n+                        .forEach(e -> snippets.put(e.getKey(), buildStringSet(clb, e.getValue())));\n+                return snippets;\n@@ -1668,3 +1124,2 @@\n-            \/**\n-             * Retrieve the index to the given set of Opens.Modifier.\n-             * Emit code to generate it when EnumSetBuilder::build is called.\n+            \/*\n+             * Enum set support\n@@ -1672,2 +1127,7 @@\n-            int indexOfOpensModifiers(CodeBuilder cob, Set<Opens.Modifier> mods) {\n-                return opensModifiersSets.get(mods).build(cob);\n+            private <T extends Enum<T>> Snippet buildEnumSet(ClassBuilder clb, RefCounter<T> setRef) {\n+                return cacheBuilder.transform(setRef,\n+                        new SetSnippetBuilder(CD_Object)\n+                                .classBuilder(clb)\n+                                .ownerClassDesc(owner)\n+                                .enablePagination(\"dedupSet\" + setBuilt++, ENUM_PAGE_SIZE)\n+                                .build(Snippet.buildAll(setRef.sortedList(), Snippet::loadEnum)));\n@@ -1676,0 +1136,7 @@\n+            private <T extends Enum<T>> Map<Set<T>, Snippet> buildEnumSets(ClassBuilder clb, Map<Set<T>, RefCounter<T>> map) {\n+                Map<Set<T>, Snippet> snippets = new HashMap<>(map.size());\n+                map.entrySet().stream()\n+                        .sorted(Map.Entry.comparingByValue())\n+                        .forEach(e -> snippets.put(e.getKey(), buildEnumSet(clb, e.getValue())));\n+                return snippets;\n+            }\n@@ -1678,2 +1145,1 @@\n-             * Retrieve the index to the given set of Requires.Modifier.\n-             * Emit code to generate it when EnumSetBuilder::build is called.\n+             * Build snippets for all sets and optionally the cache.\n@@ -1681,2 +1147,8 @@\n-            int indexOfRequiresModifiers(CodeBuilder cob, Set<Requires.Modifier> mods) {\n-                return requiresModifiersSets.get(mods).build(cob);\n+            DedupSnippets build(ClassBuilder clb) {\n+                return new DedupSnippets(\n+                    buildStringSets(clb, stringSets),\n+                    buildEnumSets(clb, requiresModifiersSets),\n+                    buildEnumSets(clb, opensModifiersSets),\n+                    buildEnumSets(clb, exportsModifiersSets),\n+                    cacheBuilder.build(clb)\n+                );\n@@ -1686,1 +1158,3 @@\n-             * Build a new string set without any attempt to deduplicate it.\n+             * RefCounter count references to the set, and keeps sorted elements to ensure\n+             * generate same bytecode for a given set.\n+             * RefCounter itself needs ordering to ensure generate same bytecode for the cache.\n@@ -1688,6 +1162,4 @@\n-            int newStringSet(CodeBuilder cob, Set<String> names) {\n-                int index = new SetBuilder<>(names, stringSetVar, localVarSupplier).build(cob);\n-                assert index == stringSetVar;\n-                return index;\n-            }\n-        }\n+            class RefCounter<T extends Comparable<T>> implements Comparable<RefCounter<T>> {\n+                \/\/ sorted elements of the set to ensure same generated code\n+                private final List<T> elements;\n+                private int refCount;\n@@ -1695,24 +1167,3 @@\n-        \/*\n-         * SetBuilder generates bytecode to create one single instance of Set\n-         * for a given set of elements and assign to a local variable slot.\n-         * When there is only one single reference to a Set<T>,\n-         * it will reuse defaultVarIndex.  For a Set with multiple references,\n-         * it will use a new local variable retrieved from the nextLocalVar\n-         *\/\n-        static class SetBuilder<T extends Comparable<T>> {\n-            private static final MethodTypeDesc MTD_Set_ObjectArray = MethodTypeDesc.of(\n-                    CD_Set, CD_Object.arrayType());\n-\n-            private final Set<T> elements;\n-            private final int defaultVarIndex;\n-            private final IntSupplier nextLocalVar;\n-            private int refCount;\n-            private int localVarIndex;\n-\n-            SetBuilder(Set<T> elements,\n-                       int defaultVarIndex,\n-                       IntSupplier nextLocalVar) {\n-                this.elements = elements;\n-                this.defaultVarIndex = defaultVarIndex;\n-                this.nextLocalVar = nextLocalVar;\n-            }\n+                RefCounter(Set<T> elements) {\n+                    this.elements = sorted(elements);\n+                }\n@@ -1720,5 +1171,31 @@\n-            \/*\n-             * Increments the number of references to this particular set.\n-             *\/\n-            final void increment() {\n-                refCount++;\n+                int increment() {\n+                    return ++refCount;\n+                }\n+\n+                int refCount() {\n+                    return refCount;\n+                }\n+\n+                List<T> sortedList() {\n+                    return elements;\n+                }\n+\n+                @Override\n+                public int compareTo(RefCounter<T> o) {\n+                    if (o == this) {\n+                        return 0;\n+                    }\n+                    if (elements.size() == o.elements.size()) {\n+                        var a1 = elements;\n+                        var a2 = o.elements;\n+                        for (int i = 0; i < elements.size(); i++) {\n+                            var r = a1.get(i).compareTo(a2.get(i));\n+                            if (r != 0) {\n+                                return r;\n+                            }\n+                        }\n+                        return 0;\n+                    } else {\n+                        return elements.size() - o.elements.size();\n+                    }\n+                }\n@@ -1728,2 +1205,2 @@\n-             * Generate the appropriate instructions to load an object reference\n-             * to the element onto the stack.\n+             * Build an array to host sets referenced more than once so a given set will only be constructed once.\n+             * Transform the bytecode for loading the set onto the operand stack as needed.\n@@ -1731,3 +1208,13 @@\n-            void visitElement(T element, CodeBuilder cob) {\n-                cob.loadConstant((ConstantDesc)element);\n-            }\n+            class CacheBuilder {\n+                private static final String VALUES_ARRAY = \"dedupSetValues\";\n+                final ArrayList<Snippet> cachedValues = new ArrayList<>();\n+\n+                \/\/ Load the set from the cache to the operand stack\n+                \/\/   dedupSetValues[index]\n+                private Snippet loadFromCache(int index) {\n+                    assert index >= 0;\n+                    return cob ->\n+                        cob.getstatic(owner, VALUES_ARRAY, CD_Set.arrayType())\n+                           .loadConstant(index)\n+                           .aaload();\n+                }\n@@ -1735,16 +1222,8 @@\n-            \/*\n-             * Build bytecode for the Set represented by this builder,\n-             * or get the local variable index of a previously generated set\n-             * (in the local scope).\n-             *\n-             * @return local variable index of the generated set.\n-             *\/\n-            final int build(CodeBuilder cob) {\n-                int index = localVarIndex;\n-                if (localVarIndex == 0) {\n-                    \/\/ if non-empty and more than one set reference this builder,\n-                    \/\/ emit to a unique local\n-                    index = refCount <= 1 ? defaultVarIndex\n-                                          : nextLocalVar.getAsInt();\n-                    if (index < MAX_LOCAL_VARS) {\n-                        localVarIndex = index;\n+                \/**\n+                 * Transform the bytecode for loading the set onto the operand stack.\n+                 * @param loadSnippet The origin snippet to load the set onto the operand stack.\n+                 *\/\n+                Snippet transform(RefCounter<?> setRef, Snippet loadSnippet) {\n+                    if (setRef.refCount() > 1) {\n+                        cachedValues.add(loadSnippet);\n+                        return loadFromCache(cachedValues.size() - 1);\n@@ -1752,2 +1231,1 @@\n-                        \/\/ overflow: disable optimization by using localVarIndex = 0\n-                        index = defaultVarIndex;\n+                        return loadSnippet;\n@@ -1755,2 +1233,0 @@\n-\n-                    generateSetOf(cob, index);\n@@ -1758,2 +1234,0 @@\n-                return index;\n-            }\n@@ -1761,5 +1235,18 @@\n-            private void generateSetOf(CodeBuilder cob, int index) {\n-                if (elements.size() <= 10) {\n-                    \/\/ call Set.of(e1, e2, ...)\n-                    for (T t : sorted(elements)) {\n-                        visitElement(t, cob);\n+                \/*\n+                 * Returns a snippet that populates the cached values in <clinit>.\n+                 *\n+                 * The generated cache is essentially as the following:\n+                 *\n+                 * static final Set[] dedupSetValues;\n+                 *\n+                 * static {\n+                 *     dedupSetValues = new Set[countOfStoredValues];\n+                 *     dedupSetValues[0] = Set.of(elements); \/\/ for inline set\n+                 *     dedupSetValues[1] = dedupSet<setIndex>_0(); \/\/ for paginated set\n+                 *     ...\n+                 *     dedupSetValues[countOfStoredValues - 1] = ...\n+                 * }\n+                 *\/\n+                Optional<Snippet> build(ClassBuilder clb) {\n+                    if (cachedValues.isEmpty()) {\n+                        return Optional.empty();\n@@ -1767,26 +1254,0 @@\n-                    var mtdArgs = new ClassDesc[elements.size()];\n-                    Arrays.fill(mtdArgs, CD_Object);\n-                    cob.invokestatic(CD_Set,\n-                                     \"of\",\n-                                     MethodTypeDesc.of(CD_Set, mtdArgs),\n-                                     true);\n-                } else {\n-                    \/\/ call Set.of(E... elements)\n-                    cob.loadConstant(elements.size())\n-                       .anewarray(CD_String);\n-                    int arrayIndex = 0;\n-                    for (T t : sorted(elements)) {\n-                        cob.dup()    \/\/ arrayref\n-                           .loadConstant(arrayIndex);\n-                        visitElement(t, cob);  \/\/ value\n-                        cob.aastore();\n-                        arrayIndex++;\n-                    }\n-                    cob.invokestatic(CD_Set,\n-                                     \"of\",\n-                                     MTD_Set_ObjectArray,\n-                                     true);\n-                }\n-                cob.astore(index);\n-            }\n-        }\n@@ -1794,13 +1255,5 @@\n-        \/*\n-         * Generates bytecode to create one single instance of EnumSet\n-         * for a given set of modifiers and assign to a local variable slot.\n-         *\/\n-        static class EnumSetBuilder<T extends Comparable<T>> extends SetBuilder<T> {\n-            private final ClassDesc classDesc;\n-\n-            EnumSetBuilder(Set<T> modifiers, ClassDesc classDesc,\n-                           int defaultVarIndex,\n-                           IntSupplier nextLocalVar) {\n-                super(modifiers, defaultVarIndex, nextLocalVar);\n-                this.classDesc = classDesc;\n-            }\n+                    var cacheValuesArray = new ArraySnippetBuilder(CD_Set)\n+                            .classBuilder(clb)\n+                            .ownerClassDesc(owner)\n+                            .enablePagination(VALUES_ARRAY)\n+                            .build(cachedValues.toArray(Snippet[]::new));\n@@ -1808,6 +1261,7 @@\n-            \/**\n-             * Loads an Enum field.\n-             *\/\n-            @Override\n-            void visitElement(T t, CodeBuilder cob) {\n-                cob.getstatic(classDesc, t.toString(), classDesc);\n+                    clb.withField(VALUES_ARRAY, CD_Set.arrayType(), ACC_STATIC | ACC_FINAL);\n+\n+                    return Optional.of(cob -> {\n+                            cacheValuesArray.emit(cob);\n+                            cob.putstatic(owner, VALUES_ARRAY, CD_Set.arrayType());\n+                    });\n+                }\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/SystemModulesPlugin.java","additions":222,"deletions":768,"binary":false,"changes":990,"status":"modified"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.StringJoiner;\n+import java.util.spi.ToolProvider;\n+\n+import tests.JImageGenerator;\n+\n+\/*\n+ * @test\n+ * @summary Make sure that ~20000 packages in a uber jar can be linked using jlink. Now that\n+ *          pagination is in place, the limitation is on the constant pool size, not number\n+ *          of packages.\n+ * @bug 8321413\n+ * @library ..\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jmod\n+ *          jdk.jlink\/jdk.tools.jimage\n+ *          jdk.compiler\n+ * @build tests.*\n+ * @run main\/othervm -Xmx1g -Xlog:init=debug -XX:+UnlockDiagnosticVMOptions -XX:+BytecodeVerificationLocal JLink20000Packages\n+ *\/\n+public class JLink20000Packages {\n+    private static final ToolProvider JAVAC_TOOL = ToolProvider.findFirst(\"javac\")\n+            .orElseThrow(() -> new RuntimeException(\"javac tool not found\"));\n+\n+    static void report(String command, String[] args) {\n+        System.out.println(command + \" \" + String.join(\" \", Arrays.asList(args)));\n+    }\n+\n+    static void javac(String[] args) {\n+        report(\"javac\", args);\n+        JAVAC_TOOL.run(System.out, System.err, args);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Path src = Paths.get(\"bug8321413\");\n+        Path imageDir = src.resolve(\"out-jlink\");\n+        Path mainModulePath = src.resolve(\"bug8321413x\");\n+\n+        StringJoiner mainModuleInfoContent = new StringJoiner(\";\\n  exports \", \"module bug8321413x {\\n  exports \", \";\\n}\");\n+\n+        for (int i = 0; i < 20000; i++) {\n+            String packageName = \"p\" + i;\n+            String className = \"C\" + i;\n+\n+            Path packagePath = Files.createDirectories(mainModulePath.resolve(packageName));\n+\n+            StringBuilder classContent = new StringBuilder(\"package \");\n+            classContent.append(packageName).append(\";\\n\");\n+            classContent.append(\"class \").append(className).append(\" {}\\n\");\n+            Files.writeString(packagePath.resolve(className + \".java\"), classContent.toString());\n+\n+            mainModuleInfoContent.add(packageName);\n+        }\n+\n+        \/\/ create module reading the generated modules\n+        Path mainModuleInfo = mainModulePath.resolve(\"module-info.java\");\n+        Files.writeString(mainModuleInfo, mainModuleInfoContent.toString());\n+\n+        Path mainClassDir = mainModulePath.resolve(\"testpackage\");\n+        Files.createDirectories(mainClassDir);\n+\n+        Files.writeString(mainClassDir.resolve(\"JLink20000PackagesTest.java\"), \"\"\"\n+                package testpackage;\n+\n+                public class JLink20000PackagesTest {\n+                    public static void main(String[] args) throws Exception {\n+                        System.out.println(\"JLink20000PackagesTest started.\");\n+                    }\n+                }\n+                \"\"\");\n+\n+        String out = src.resolve(\"out\").toString();\n+        javac(new String[]{\n+                \"-d\", out,\n+                \"--module-source-path\", src.toString(),\n+                \"--module\", \"bug8321413x\"\n+        });\n+\n+        JImageGenerator.getJLinkTask()\n+                .modulePath(out)\n+                .output(imageDir)\n+                .addMods(\"bug8321413x\")\n+                .call()\n+                .assertSuccess();\n+\n+        Path binDir = imageDir.resolve(\"bin\").toAbsolutePath();\n+        Path bin = binDir.resolve(\"java\");\n+\n+        ProcessBuilder processBuilder = new ProcessBuilder(bin.toString(),\n+                \"-XX:+UnlockDiagnosticVMOptions\",\n+                \"-XX:+BytecodeVerificationLocal\",\n+                \"-m\", \"bug8321413x\/testpackage.JLink20000PackagesTest\");\n+        processBuilder.inheritIO();\n+        processBuilder.directory(binDir.toFile());\n+        Process process = processBuilder.start();\n+        int exitCode = process.waitFor();\n+        if (exitCode != 0)\n+             throw new AssertionError(\"JLink20000PackagesTest failed to launch\");\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/JLink20000Packages.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,271 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.lang.classfile.ClassBuilder;\n+import java.lang.classfile.ClassFile;\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+import java.lang.constant.ClassDesc;\n+import static java.lang.constant.ConstantDescs.CD_Integer;\n+import static java.lang.constant.ConstantDescs.CD_Object;\n+import static java.lang.constant.ConstantDescs.CD_String;\n+import static java.lang.constant.ConstantDescs.INIT_NAME;\n+import static java.lang.constant.ConstantDescs.MTD_void;\n+import java.lang.constant.MethodTypeDesc;\n+import static java.lang.invoke.MethodHandles.lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.module.ModuleDescriptor;\n+import java.lang.reflect.AccessFlag;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.*;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.IntStream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import jdk.tools.jlink.internal.Snippets.*;\n+\n+\/*\n+ * @test\n+ * @summary Test snippets generation for array and set.\n+ * @bug 8321413\n+ * @enablePreview\n+ * @modules jdk.jlink\/jdk.tools.jlink.internal\n+ * @run junit SnippetsTest\n+ *\/\n+public class SnippetsTest {\n+    private static final boolean WRITE_CLASS_FILE = Boolean.parseBoolean(System.getProperty(\"DumpArraySnippetsTestClasses\", \"false\"));\n+\n+    @ParameterizedTest\n+    @ValueSource(ints = { 10, 75, 90, 120, 200, 399, 400, 401})\n+    void testLoad400StringsArray(int pageSize) {\n+        testPaginatedArray(400, pageSize);\n+    }\n+\n+    @Test\n+    void testStringArrayLimitsWithPagination() {\n+        \/\/ Each string takes 2 constant pool slot, one for String, another for Utf8\n+        testPaginatedArray(31_000, 8000);\n+        try {\n+            testPaginatedArray(32_000, 8000);\n+        } catch (IllegalArgumentException iae) {\n+            \/\/ expected constant pool explode\n+        }\n+    }\n+\n+    @Test\n+    void testStringArrayLimitsWithoutPagination() {\n+        \/\/ each string array assignment takes ~8 bytes\n+        testSimpleArray(8200);\n+        try {\n+            testSimpleArray(8300);\n+            fail();\n+        } catch (IllegalArgumentException iae) {\n+            \/\/ expected code size explode\n+        }\n+    }\n+\n+    @Test\n+    void testLoadableEnum() {\n+        Enum<?>[] enums = {\n+            AccessFlag.FINAL,\n+            ModuleDescriptor.Requires.Modifier.MANDATED,\n+            ModuleDescriptor.Opens.Modifier.SYNTHETIC,\n+            ModuleDescriptor.Requires.Modifier.TRANSITIVE\n+        };\n+\n+        Snippet[] elementSnippets = Snippet.buildAll(Arrays.asList(enums), Snippet::loadEnum);\n+\n+        var loadable = new ArraySnippetBuilder(Enum.class.describeConstable().get())\n+                .build(elementSnippets);\n+\n+        Supplier<Enum<?>[]> supplier = generateSupplier(\"LoadableEnumTest\", clb -> loadable);\n+        assertArrayEquals(enums, supplier.get());\n+    }\n+\n+    @Test\n+    void testArraySnippetBuilder() {\n+        Integer[] expected = IntStream.range(0, 200)\n+                                .boxed()\n+                                .toArray(Integer[]::new);\n+        var className = \"LoadableArrayOf200Paged\";\n+        var elementSnippets = Snippet.buildAll(Arrays.asList(expected), Snippet::loadInteger);\n+        var instance = new ArraySnippetBuilder(CD_Integer)\n+                .ownerClassDesc(ClassDesc.of(className))\n+                .enablePagination(\"page\", 100);\n+\n+        try {\n+            instance.build(elementSnippets);\n+            fail(\"Should throw NPE without ClassBuilder\");\n+        } catch (NullPointerException npe) {\n+            \/\/ expected\n+        }\n+\n+        Supplier<Integer[]> supplier = generateSupplier(className, clb -> instance.classBuilder(clb).build(elementSnippets));\n+        verifyPaginationMethods(supplier.getClass(), Integer.class, \"page\", 2);\n+        assertArrayEquals(expected, supplier.get());\n+\n+        var loadable = instance.disablePagination()\n+                .ownerClassDesc(ClassDesc.of(\"LoadableArrayOf200NotPaged\"))\n+                .build(elementSnippets);\n+\n+        \/\/ SimpleArray generate bytecode inline, so can be generated in any class\n+        supplier = generateSupplier(\"TestLoadableArrayFactory\", clb -> loadable);\n+        verifyPaginationMethods(supplier.getClass(), Integer.class, \"page\", 0);\n+        assertArrayEquals(expected, supplier.get());\n+    }\n+\n+    @Test\n+    void testSetSnippetBuilder() {\n+        String[] data = IntStream.range(0, 100)\n+                                 .mapToObj(i -> \"SetData\" + i)\n+                                 .toArray(String[]::new);\n+\n+        var tiny = Set.of(data[0], data[1], data[2]);\n+        var all = Set.of(data);\n+        var setBuilder = new SetSnippetBuilder(CD_String);\n+\n+        Supplier<Set<String>> supplier = generateSupplier(\"TinySetTest\", clb ->\n+                setBuilder.build(Snippet.buildAll(tiny, Snippet::loadConstant)));\n+        \/\/ Set does not guarantee ordering, so not assertIterableEquals\n+        assertEquals(tiny, supplier.get());\n+\n+        var allSnippets = Snippet.buildAll(all, Snippet::loadConstant);\n+\n+        supplier = generateSupplier(\"AllSetTestNoPage\", clb ->\n+                setBuilder.build(allSnippets));\n+        assertEquals(all, supplier.get());\n+\n+        var className = \"AllSetTestPageNotActivated\";\n+        var methodNamePrefix = \"page\";\n+        var loadable = setBuilder.disablePagination()\n+                .ownerClassDesc(ClassDesc.of(className))\n+                .build(allSnippets);\n+        supplier = generateSupplier(className, clb -> loadable);\n+        assertEquals(all, supplier.get());\n+\n+        className = \"AllSetTestPageSize20\";\n+        setBuilder.ownerClassDesc(ClassDesc.of(className));\n+        supplier = generateSupplier(className, clb -> setBuilder.classBuilder(clb)\n+                .enablePagination(methodNamePrefix, 20)\n+                .build(allSnippets));\n+        verifyPaginationMethods(supplier.getClass(), String.class, methodNamePrefix, 5);\n+        assertEquals(all, supplier.get());\n+    }\n+\n+    void testPaginatedArray(int elementCount, int pageSize) {\n+        String[] expected = IntStream.range(0, elementCount)\n+                                 .mapToObj(i -> \"Package\" + i)\n+                                 .toArray(String[]::new);\n+        var className = String.format(\"SnippetArrayProviderTest%dPagedBy%d\", elementCount, pageSize);\n+        ClassDesc testClassDesc = ClassDesc.of(className);\n+        var builder = new ArraySnippetBuilder(CD_String)\n+                .enablePagination(\"ArrayPage\", pageSize, 1)\n+                .ownerClassDesc(testClassDesc);\n+        var snippets = Snippet.buildAll(Arrays.asList(expected), Snippet::loadConstant);\n+        var pagingContext = new PagingContext(expected.length, pageSize);\n+\n+        Supplier<String[]> supplier = generateSupplier(className, clb -> builder.classBuilder(clb).build(snippets));\n+        verifyPaginationMethods(supplier.getClass(), String.class, \"ArrayPage\", pagingContext.pageCount());\n+        assertEquals((elementCount % pageSize) != 0, pagingContext.isLastPagePartial());\n+        assertArrayEquals(expected, supplier.get());\n+    }\n+\n+    void testSimpleArray(int elementCount) {\n+        String[] expected = IntStream.range(0, elementCount)\n+                                 .mapToObj(i -> \"NoPage\" + i)\n+                                 .toArray(String[]::new);\n+        String className = \"SnippetArrayProviderTest\" + elementCount;\n+        var array = new ArraySnippetBuilder(CD_String)\n+                .disablePagination()\n+                .build(Snippet.buildAll(Arrays.asList(expected), Snippet::loadConstant));\n+\n+        Supplier<String[]> supplier = generateSupplier(className, clb -> array);\n+        verifyPaginationMethods(supplier.getClass(), String.class, \"page\", 0);\n+        assertArrayEquals(expected, supplier.get());\n+    }\n+\n+    <T> Supplier<T> generateSupplier(String className, Function<ClassBuilder, Loadable> builder) {\n+        var testClassDesc = ClassDesc.of(className);\n+        byte[] classBytes = generateSupplierClass(testClassDesc, builder);\n+        try {\n+            writeClassFile(className, classBytes);\n+            var testClass = lookup().defineClass(classBytes);\n+            lookup().findVirtual(testClass, \"get\", MethodType.methodType(Object.class));\n+            return (Supplier<T>) testClass.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    void verifyPaginationMethods(Class<?> testClass, Class<?> elementType, String methodNamePrefix, int pageCount) {\n+        var methodType = MethodType.methodType(elementType.arrayType(), elementType.arrayType());\n+        if (pageCount <= 0) {\n+            try {\n+                lookup().findStatic(testClass, methodNamePrefix + \"_0\", methodType);\n+                fail(\"Unexpected paginate helper function\");\n+            } catch (Exception ex) {}\n+        }\n+\n+        for (int i = 0; i < pageCount; i++) {\n+            try {\n+                lookup().findStatic(testClass, methodNamePrefix + \"_\" + i, methodType);\n+            } catch (Exception ex) {\n+                throw new RuntimeException(ex);\n+            }\n+        }\n+    }\n+\n+    byte[] generateSupplierClass(ClassDesc testClassDesc, Function<ClassBuilder, Loadable> builder) {\n+        return ClassFile.of().build(testClassDesc,\n+                clb -> {\n+                    clb.withSuperclass(CD_Object);\n+                    clb.withInterfaceSymbols(ClassDesc.ofInternalName(\"java\/util\/function\/Supplier\"));\n+                    clb.withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC, cob -> {\n+                        cob.aload(0);\n+                        cob.invokespecial(CD_Object, INIT_NAME, MTD_void);\n+                        cob.return_();\n+                    });\n+\n+                    var loadable = builder.apply(clb);\n+\n+                    clb.withMethodBody(\"get\", MethodTypeDesc.of(CD_Object), ACC_PUBLIC, cob -> {\n+                        loadable.emit(cob);\n+                        cob.areturn();\n+                    });\n+                });\n+    }\n+\n+    void writeClassFile(String className, byte[] classBytes) throws IOException {\n+        if (WRITE_CLASS_FILE) {\n+            Files.write(Path.of(className + \".class\"), classBytes);\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/tools\/jlink\/SnippetsTest.java","additions":271,"deletions":0,"binary":false,"changes":271,"status":"added"}]}