{"files":[{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2024, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.tools.jlink.internal;\n+\n+import java.lang.classfile.ClassBuilder;\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.constant.ClassDesc;\n+import static java.lang.constant.ConstantDescs.CD_Object;\n+import static java.lang.constant.ConstantDescs.CD_Set;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.function.BiConsumer;\n+\n+public class Snippets {\n+    \/**\n+     * Return a snippet builder that loads an enum onto the operand stack using\n+     * the enum name static final field\n+     *\/\n+    public static <T extends Enum<T>> BiConsumer<CodeBuilder, T> getEnumLoader(ClassDesc enumClassDesc) {\n+        return (cob, element) -> cob.getstatic(enumClassDesc, element.name(), enumClassDesc);\n+    }\n+\n+    \/**\n+     * Generate bytecode to create an array and load onto the operand stack.\n+     * Effectively like following pseudo code:\n+     *   new T[] { elements }\n+     *\n+     * @param cob The code builder to add the snipper\n+     * @param elementType The class descriptor of the element type T\n+     * @param elements The elements to be in the array\n+     * @param elementLoader A snippet generator to load an element T onto the operand stack.\n+     *\/\n+    public static <T> void loadArray(CodeBuilder cob,\n+                                     ClassDesc elementType,\n+                                     Collection<T> elements,\n+                                     BiConsumer<CodeBuilder, T> elementLoader) {\n+        cob.loadConstant(elements.size())\n+           .anewarray(elementType);\n+        int arrayIndex = 0;\n+        for (T t : elements) {\n+            cob.dup()    \/\/ arrayref\n+               .loadConstant(arrayIndex);\n+            elementLoader.accept(cob, t);  \/\/ value\n+            cob.aastore();\n+            arrayIndex++;\n+        }\n+    }\n+\n+    \/**\n+     * Generates bytecode to load a set onto the operand stack.\n+     * Effectively like following pseudo code:\n+     *   Set.of(elements)\n+     * @param cob The code builder to add the snippet\n+     * @param elements The set to be created\n+     * @param elementLoader Snippet generator to load an element onto the operand stack\n+     *\/\n+    public static <T> void loadImmutableSet(CodeBuilder cob,\n+                                            Collection<T> elements,\n+                                            BiConsumer<CodeBuilder, T> elementLoader) {\n+        if (elements.size() <= 10) {\n+            \/\/ call Set.of(e1, e2, ...)\n+            for (T t : elements) {\n+                elementLoader.accept(cob, t);\n+            }\n+            var mtdArgs = new ClassDesc[elements.size()];\n+            Arrays.fill(mtdArgs, CD_Object);\n+            cob.invokestatic(CD_Set, \"of\", MethodTypeDesc.of(CD_Set, mtdArgs), true);\n+        } else {\n+            \/\/ call Set.of(E... elements)\n+            loadArray(cob, CD_Object, elements, elementLoader);\n+            cob.invokestatic(CD_Set, \"of\", MethodTypeDesc.of(CD_Set, CD_Object.arrayType()), true);\n+        }\n+    }\n+\n+    \/\/ Generate a method with pseudo code looks like this\n+    \/\/ static Set<T> methodName() {\n+    \/\/     return Set.of(elements);\n+    \/\/ }\n+    public static <T> void genImmutableSetProvider(ClassBuilder clb,\n+                                                   String methodName,\n+                                                   Collection<T> elements,\n+                                                   BiConsumer<CodeBuilder, T> elementLoader) {\n+        clb.withMethodBody(\n+                methodName,\n+                MethodTypeDesc.of(CD_Set),\n+                ACC_STATIC,\n+                cob -> {\n+                    loadImmutableSet(cob, elements, elementLoader);\n+                    cob.areturn();\n+                });\n+    }\n+\n+    \/\/ Generate a method with pseudo code looks like this\n+    \/\/ static T[] methodName() {\n+    \/\/     return new T[] { elements };\n+    \/\/ }\n+    public static <T> void genArrayProvider(ClassBuilder clb,\n+                                            String methodName,\n+                                            ClassDesc elementType,\n+                                            Collection<T> elements,\n+                                            BiConsumer<CodeBuilder, T> elementLoader) {\n+        clb.withMethodBody(\n+                methodName,\n+                MethodTypeDesc.of(elementType.arrayType()),\n+                ACC_STATIC,\n+                cob -> {\n+                    loadArray(cob, elementType, elements, elementLoader);\n+                    cob.areturn();\n+                });\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/Snippets.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.constant.ConstantDesc;\n@@ -49,1 +48,0 @@\n-import java.util.Arrays;\n@@ -63,1 +61,2 @@\n-import java.util.function.IntSupplier;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n@@ -81,1 +80,0 @@\n-import static java.lang.classfile.ClassFile.*;\n@@ -90,0 +88,8 @@\n+import static java.lang.classfile.ClassFile.*;\n+\n+import static jdk.tools.jlink.internal.Snippets.genArrayProvider;\n+import static jdk.tools.jlink.internal.Snippets.genImmutableSetProvider;\n+import static jdk.tools.jlink.internal.Snippets.getEnumLoader;\n+import static jdk.tools.jlink.internal.Snippets.loadArray;\n+import static jdk.tools.jlink.internal.Snippets.loadImmutableSet;\n+\n@@ -541,1 +547,1 @@\n-        private static final MethodTypeDesc MTD_Set_ObjectArray = MethodTypeDesc.of(CD_Set, CD_Object.arrayType());\n+\n@@ -548,3 +554,1 @@\n-        private final int DEDUP_LIST_VAR = 2;\n-        private final int BUILDER_VAR    = 3;\n-        private int nextLocalVar         = 4;  \/\/ index to next local variable\n+        private final int BUILDER_VAR    = 2;\n@@ -560,0 +564,2 @@\n+        private final ArrayList<Consumer<ClassBuilder>> amendments = new ArrayList<>();\n+\n@@ -563,2 +569,1 @@\n-        private final DedupSetBuilder dedupSetBuilder\n-            = new DedupSetBuilder(this::getNextLocalVar);\n+        private final DedupSetBuilder dedupSetBuilder;\n@@ -572,0 +577,1 @@\n+            this.dedupSetBuilder = new DedupSetBuilder(this.classDesc);\n@@ -575,4 +581,0 @@\n-        private int getNextLocalVar() {\n-            return nextLocalVar++;\n-        }\n-\n@@ -619,0 +621,3 @@\n+                        \/\/ generate dedup set fields and provider methods\n+                        genConstants(clb);\n+\n@@ -639,0 +644,3 @@\n+\n+                        \/\/ generate module helpers\n+                        amendments.forEach(amendment -> amendment.accept(clb));\n@@ -642,0 +650,4 @@\n+        private void addModuleHelpers(Consumer<ClassBuilder> amendment) {\n+            amendments.add(amendment);\n+        }\n+\n@@ -657,0 +669,15 @@\n+        private void genConstants(ClassBuilder clb) {\n+            var clinitSnippets = dedupSetBuilder.buildConstants(clb);\n+            if (!clinitSnippets.isEmpty()) {\n+                clb.withMethodBody(\n+                        CLASS_INIT_NAME,\n+                        MTD_void,\n+                        ACC_STATIC,\n+                        cob -> {\n+                            clinitSnippets.forEach(snippet -> snippet.accept(cob));\n+                            cob.pop()\n+                               .return_();\n+                        });\n+            }\n+        }\n+\n@@ -726,23 +753,1 @@\n-            \/\/ and so on.  During the construction of the module descriptors, the string sets and\n-            \/\/ modifier sets are deduplicated (see SystemModulesClassGenerator.DedupSetBuilder)\n-            \/\/ and cached in the locals. These locals are saved in an array list so\n-            \/\/ that the helper method can restore the local variables that may be\n-            \/\/ referenced by the bytecode generated for creating module descriptors.\n-            \/\/ Pseudo code looks like this:\n-            \/\/\n-            \/\/ void subi(ModuleDescriptor[] mdescs, ArrayList<Object> localvars) {\n-            \/\/      \/\/ assign localvars to local variables\n-            \/\/      var l3 = localvars.get(0);\n-            \/\/      var l4 = localvars.get(1);\n-            \/\/        :\n-            \/\/      \/\/ fill mdescs[i] to mdescs[i+n-1]\n-            \/\/      mdescs[i] = ...\n-            \/\/      mdescs[i+1] = ...\n-            \/\/        :\n-            \/\/      \/\/ save new local variables added\n-            \/\/      localvars.add(lx)\n-            \/\/      localvars.add(l{x+1})\n-            \/\/        :\n-            \/\/      sub{i+i}(mdescs, localvars);\n-            \/\/ }\n-\n+            \/\/ and so on.\n@@ -760,1 +765,0 @@\n-            ClassDesc arrayListClassDesc = ClassDesc.ofInternalName(\"java\/util\/ArrayList\");\n@@ -771,5 +775,0 @@\n-                        cob.new_(arrayListClassDesc)\n-                           .dup()\n-                           .loadConstant(moduleInfos.size())\n-                           .invokespecial(arrayListClassDesc, INIT_NAME, MethodTypeDesc.of(CD_void, CD_int))\n-                           .astore(DEDUP_LIST_VAR);\n@@ -778,1 +777,0 @@\n-                           .aload(DEDUP_LIST_VAR)\n@@ -782,1 +780,1 @@\n-                                   MethodTypeDesc.of(CD_void, CD_MODULE_DESCRIPTOR.arrayType(), arrayListClassDesc)\n+                                   MethodTypeDesc.of(CD_void, CD_MODULE_DESCRIPTOR.arrayType())\n@@ -787,1 +785,0 @@\n-            int dedupVarStart = nextLocalVar;\n@@ -791,1 +788,0 @@\n-                int curDedupVar = nextLocalVar;\n@@ -794,1 +790,1 @@\n-                        MethodTypeDesc.of(CD_void, CD_MODULE_DESCRIPTOR.arrayType(), arrayListClassDesc),\n+                        MethodTypeDesc.of(CD_void, CD_MODULE_DESCRIPTOR.arrayType()),\n@@ -797,9 +793,0 @@\n-                            if (curDedupVar > dedupVarStart) {\n-                                for (int i = dedupVarStart; i < curDedupVar; i++) {\n-                                    cob.aload(DEDUP_LIST_VAR)\n-                                       .loadConstant(i - dedupVarStart)\n-                                       .invokevirtual(arrayListClassDesc, \"get\", MethodTypeDesc.of(CD_Object, CD_int))\n-                                       .astore(i);\n-                                }\n-                            }\n-\n@@ -816,8 +803,0 @@\n-                                if (nextLocalVar > curDedupVar) {\n-                                    for (int i = curDedupVar; i < nextLocalVar; i++) {\n-                                        cob.aload(DEDUP_LIST_VAR)\n-                                           .aload(i)\n-                                           .invokevirtual(arrayListClassDesc, \"add\", MethodTypeDesc.of(CD_boolean, CD_Object))\n-                                           .pop();\n-                                    }\n-                                }\n@@ -826,1 +805,0 @@\n-                                   .aload(DEDUP_LIST_VAR)\n@@ -830,1 +808,1 @@\n-                                           MethodTypeDesc.of(CD_void, CD_MODULE_DESCRIPTOR.arrayType(), arrayListClassDesc)\n+                                           MethodTypeDesc.of(CD_void, CD_MODULE_DESCRIPTOR.arrayType())\n@@ -1044,30 +1022,1 @@\n-            int size = set.size();\n-\n-            \/\/ use Set.of(Object[]) when there are more than 2 elements\n-            \/\/ use Set.of(Object) or Set.of(Object, Object) when fewer\n-            if (size > 2) {\n-                cob.loadConstant(size)\n-                   .anewarray(CD_String);\n-                int i = 0;\n-                for (String element : sorted(set)) {\n-                    cob.dup()\n-                       .loadConstant(i)\n-                       .loadConstant(element)\n-                       .aastore();\n-                    i++;\n-                }\n-                cob.invokestatic(CD_Set,\n-                                 \"of\",\n-                                 MTD_Set_ObjectArray,\n-                                 true);\n-            } else {\n-                for (String element : sorted(set)) {\n-                    cob.loadConstant(element);\n-                }\n-                var mtdArgs = new ClassDesc[size];\n-                Arrays.fill(mtdArgs, CD_Object);\n-                cob.invokestatic(CD_Set,\n-                                 \"of\",\n-                                 MethodTypeDesc.of(CD_Set, mtdArgs),\n-                                 true);\n-            }\n+            loadImmutableSet(cob, sorted(set), CodeBuilder::loadConstant);\n@@ -1120,0 +1069,2 @@\n+            static final int SET_SIZE_THRESHOLD = 512; \/\/ An arbitrary number as this likely generate minimum ~4K code\n+\n@@ -1247,3 +1198,2 @@\n-                int varIndex = dedupSetBuilder.indexOfRequiresModifiers(cob, mods);\n-                cob.aload(varIndex)\n-                   .loadConstant(name);\n+                dedupSetBuilder.loadRequiresModifiers(cob, mods);\n+                cob.loadConstant(name);\n@@ -1269,10 +1219,2 @@\n-                cob.aload(BUILDER_VAR)\n-                   .loadConstant(exports.size())\n-                   .anewarray(CD_EXPORTS);\n-                int arrayIndex = 0;\n-                for (Exports export : sorted(exports)) {\n-                    cob.dup()    \/\/ arrayref\n-                       .loadConstant(arrayIndex++);\n-                    newExports(export.modifiers(), export.source(), export.targets());\n-                    cob.aastore();\n-                }\n+                cob.aload(BUILDER_VAR);\n+                loadExportsArray(exports);\n@@ -1280,3 +1222,17 @@\n-                                  \"exports\",\n-                                  MTD_EXPORTS_ARRAY)\n-                    .pop();\n+                        \"exports\",\n+                        MTD_EXPORTS_ARRAY)\n+                        .pop();\n+            }\n+\n+            void loadExportsArray(Set<Exports> exports) {\n+                if (exports.size() > SET_SIZE_THRESHOLD) {\n+                    String methodName = \"module\" + index + \"Exports\";\n+                    addModuleHelpers(clb -> genArrayProvider(clb,\n+                            methodName,\n+                            CD_EXPORTS,\n+                            sorted(exports),\n+                            this::loadExports));\n+                    cob.invokestatic(classDesc, methodName, MethodTypeDesc.of(CD_EXPORTS.arrayType()));\n+                } else {\n+                    loadArray(cob, CD_EXPORTS, sorted(exports), this::loadExports);\n+                }\n@@ -1292,7 +1248,3 @@\n-             * Set<String> targets = new HashSet<>();\n-             * targets.add(t);\n-             * :\n-             * :\n-             *\n-             * Set<Modifier> mods = ...\n-             * Builder.newExports(mods, pn, targets);\n+             * ms = export.modifiers()\n+             * pn = export.source()\n+             * targets = export.targets()\n@@ -1300,2 +1252,4 @@\n-            void newExports(Set<Exports.Modifier> ms, String pn, Set<String> targets) {\n-                int modifiersSetIndex = dedupSetBuilder.indexOfExportsModifiers(cob, ms);\n+            void loadExports(CodeBuilder cb, Exports export) {\n+                dedupSetBuilder.loadExportsModifiers(cb, export.modifiers());\n+                cb.loadConstant(export.source());\n+                var targets = export.targets();\n@@ -1303,7 +1257,4 @@\n-                    int stringSetIndex = dedupSetBuilder.indexOfStringSet(cob, targets);\n-                    cob.aload(modifiersSetIndex)\n-                       .loadConstant(pn)\n-                       .aload(stringSetIndex)\n-                       .invokestatic(CD_MODULE_BUILDER,\n-                                     \"newExports\",\n-                                     MTD_EXPORTS_MODIFIER_SET_STRING_SET);\n+                    dedupSetBuilder.loadStringSet(cb, targets);\n+                    cb.invokestatic(CD_MODULE_BUILDER,\n+                                    \"newExports\",\n+                                    MTD_EXPORTS_MODIFIER_SET_STRING_SET);\n@@ -1311,5 +1262,3 @@\n-                    cob.aload(modifiersSetIndex)\n-                       .loadConstant(pn)\n-                       .invokestatic(CD_MODULE_BUILDER,\n-                                     \"newExports\",\n-                                     MTD_EXPORTS_MODIFIER_SET_STRING);\n+                    cb.invokestatic(CD_MODULE_BUILDER,\n+                                    \"newExports\",\n+                                    MTD_EXPORTS_MODIFIER_SET_STRING);\n@@ -1326,10 +1275,2 @@\n-                cob.aload(BUILDER_VAR)\n-                   .loadConstant(opens.size())\n-                   .anewarray(CD_OPENS);\n-                int arrayIndex = 0;\n-                for (Opens open : sorted(opens)) {\n-                    cob.dup()    \/\/ arrayref\n-                       .loadConstant(arrayIndex++);\n-                    newOpens(open.modifiers(), open.source(), open.targets());\n-                    cob.aastore();\n-                }\n+                cob.aload(BUILDER_VAR);\n+                loadArray(cob, CD_OPENS, sorted(opens), this::newOpens);\n@@ -1349,6 +1290,3 @@\n-             * Set<String> targets = new HashSet<>();\n-             * targets.add(t);\n-             * :\n-             * :\n-             *\n-             * Set<Modifier> mods = ...\n+             * ms = open.modifiers()\n+             * pn = open.source()\n+             * targets = open.targets()\n@@ -1357,2 +1295,4 @@\n-            void newOpens(Set<Opens.Modifier> ms, String pn, Set<String> targets) {\n-                int modifiersSetIndex = dedupSetBuilder.indexOfOpensModifiers(cob, ms);\n+            void newOpens(CodeBuilder cb, Opens open) {\n+                dedupSetBuilder.loadOpensModifiers(cb, open.modifiers());\n+                cb.loadConstant(open.source());\n+                var targets = open.targets();\n@@ -1360,5 +1300,2 @@\n-                    int stringSetIndex = dedupSetBuilder.indexOfStringSet(cob, targets);\n-                    cob.aload(modifiersSetIndex)\n-                       .loadConstant(pn)\n-                       .aload(stringSetIndex)\n-                       .invokestatic(CD_MODULE_BUILDER,\n+                    dedupSetBuilder.loadStringSet(cb, targets);\n+                    cb.invokestatic(CD_MODULE_BUILDER,\n@@ -1368,3 +1305,1 @@\n-                    cob.aload(modifiersSetIndex)\n-                       .loadConstant(pn)\n-                       .invokestatic(CD_MODULE_BUILDER,\n+                    cb.invokestatic(CD_MODULE_BUILDER,\n@@ -1380,4 +1315,3 @@\n-                int varIndex = dedupSetBuilder.indexOfStringSet(cob, uses);\n-                cob.aload(BUILDER_VAR)\n-                   .aload(varIndex)\n-                   .invokevirtual(CD_MODULE_BUILDER,\n+                cob.aload(BUILDER_VAR);\n+                dedupSetBuilder.loadStringSet(cob, uses);\n+                cob.invokevirtual(CD_MODULE_BUILDER,\n@@ -1396,10 +1330,2 @@\n-                cob.aload(BUILDER_VAR)\n-                   .loadConstant(provides.size())\n-                   .anewarray(CD_PROVIDES);\n-                int arrayIndex = 0;\n-                for (Provides provide : sorted(provides)) {\n-                    cob.dup()    \/\/ arrayref\n-                       .loadConstant(arrayIndex++);\n-                    newProvides(provide.service(), provide.providers());\n-                    cob.aastore();\n-                }\n+                cob.aload(BUILDER_VAR);\n+                loadArray(cob, CD_PROVIDES, sorted(provides), this::newProvides);\n@@ -1413,1 +1339,1 @@\n-             * Invoke Builder.newProvides(String service, Set<String> providers)\n+             * Invoke Builder.newProvides(String service, List<String> providers)\n@@ -1415,4 +1341,2 @@\n-             * Set<String> providers = new HashSet<>();\n-             * providers.add(impl);\n-             * :\n-             * :\n+             * service = provide.service()\n+             * providers = List.of(new String[] { provide.providers() }\n@@ -1421,11 +1345,3 @@\n-            void newProvides(String service, List<String> providers) {\n-                cob.loadConstant(service)\n-                   .loadConstant(providers.size())\n-                   .anewarray(CD_String);\n-                int arrayIndex = 0;\n-                for (String provider : providers) {\n-                    cob.dup()    \/\/ arrayref\n-                       .loadConstant(arrayIndex++)\n-                       .loadConstant(provider)\n-                       .aastore();\n-                }\n+            void newProvides(CodeBuilder cb, Provides provide) {\n+                cb.loadConstant(provide.service());\n+                loadArray(cb, CD_String, provide.providers(), CodeBuilder::loadConstant);\n@@ -1442,1 +1358,5 @@\n-             * Invoke Builder.packages(String pn)\n+             * Invoke Builder.packages(Set<String> packages)\n+             * with packages either from invoke provider method\n+             *   module<index>Packages()\n+             * or construct inline with\n+             *   Set.of(packages)\n@@ -1445,4 +1365,9 @@\n-                int varIndex = dedupSetBuilder.newStringSet(cob, packages);\n-                cob.aload(BUILDER_VAR)\n-                   .aload(varIndex)\n-                   .invokevirtual(CD_MODULE_BUILDER,\n+                cob.aload(BUILDER_VAR);\n+                if (packages.size() > SET_SIZE_THRESHOLD) {\n+                    var methodName = \"module\" + index + \"Packages\";\n+                    addModuleHelpers(clb -> genImmutableSetProvider(clb, methodName, sorted(packages), CodeBuilder::loadConstant));\n+                    cob.invokestatic(classDesc, methodName, MethodTypeDesc.of(CD_Set));\n+                } else {\n+                    loadImmutableSet(cob, sorted(packages), CodeBuilder::loadConstant);\n+                }\n+                cob.invokevirtual(CD_MODULE_BUILDER,\n@@ -1586,1 +1511,1 @@\n-            final Map<Set<String>, SetBuilder<String>> stringSets = new HashMap<>();\n+            final Map<Set<String>, SetReference<String>> stringSets = new HashMap<>();\n@@ -1590,1 +1515,1 @@\n-            final Map<Set<Requires.Modifier>, EnumSetBuilder<Requires.Modifier>>\n+            final Map<Set<Requires.Modifier>, SetReference<Requires.Modifier>>\n@@ -1595,1 +1520,1 @@\n-            final Map<Set<Exports.Modifier>, EnumSetBuilder<Exports.Modifier>>\n+            final Map<Set<Exports.Modifier>, SetReference<Exports.Modifier>>\n@@ -1600,1 +1525,1 @@\n-            final Map<Set<Opens.Modifier>, EnumSetBuilder<Opens.Modifier>>\n+            final Map<Set<Opens.Modifier>, SetReference<Opens.Modifier>>\n@@ -1603,3 +1528,4 @@\n-            private final int stringSetVar;\n-            private final int enumSetVar;\n-            private final IntSupplier localVarSupplier;\n+            private static final String VALUES_ARRAY = \"dedupSetValues\";\n+\n+            final ClassDesc owner;\n+            int countOfStoredValues = 0;\n@@ -1607,4 +1533,6 @@\n-            DedupSetBuilder(IntSupplier localVarSupplier) {\n-                this.stringSetVar = localVarSupplier.getAsInt();\n-                this.enumSetVar = localVarSupplier.getAsInt();\n-                this.localVarSupplier = localVarSupplier;\n+            DedupSetBuilder(ClassDesc owner) {\n+                this.owner = owner;\n+            }\n+\n+            int requestValueStorage() {\n+                return countOfStoredValues++;\n@@ -1618,1 +1546,1 @@\n-                    s -> new SetBuilder<>(s, stringSetVar, localVarSupplier)\n+                    s -> new SetReference<>(s, CodeBuilder::loadConstant)\n@@ -1627,2 +1555,1 @@\n-                                new EnumSetBuilder<>(s, CD_EXPORTS_MODIFIER,\n-                                        enumSetVar, localVarSupplier)\n+                        new SetReference<>(s, getEnumLoader(CD_EXPORTS_MODIFIER))\n@@ -1637,2 +1564,1 @@\n-                                new EnumSetBuilder<>(s, CD_OPENS_MODIFIER,\n-                                        enumSetVar, localVarSupplier)\n+                        new SetReference<>(s, getEnumLoader(CD_OPENS_MODIFIER))\n@@ -1647,2 +1573,1 @@\n-                    new EnumSetBuilder<>(s, CD_REQUIRES_MODIFIER,\n-                                         enumSetVar, localVarSupplier)\n+                        new SetReference<>(s, getEnumLoader(CD_REQUIRES_MODIFIER))\n@@ -1653,2 +1578,1 @@\n-             * Retrieve the index to the given set of Strings. Emit code to\n-             * generate it when SetBuilder::build is called.\n+             * Load the given set to the top of operand stack.\n@@ -1656,2 +1580,2 @@\n-            int indexOfStringSet(CodeBuilder cob, Set<String> names) {\n-                return stringSets.get(names).build(cob);\n+            void loadStringSet(CodeBuilder cob, Set<String> names) {\n+                stringSets.get(names).load(cob);\n@@ -1661,2 +1585,1 @@\n-             * Retrieve the index to the given set of Exports.Modifier.\n-             * Emit code to generate it when EnumSetBuilder::build is called.\n+             * Load the given set to the top of operand stack.\n@@ -1664,2 +1587,2 @@\n-            int indexOfExportsModifiers(CodeBuilder cob, Set<Exports.Modifier> mods) {\n-                return exportsModifiersSets.get(mods).build(cob);\n+            void loadExportsModifiers(CodeBuilder cob, Set<Exports.Modifier> mods) {\n+                exportsModifiersSets.get(mods).load(cob);\n@@ -1668,3 +1591,2 @@\n-            \/**\n-             * Retrieve the index to the given set of Opens.Modifier.\n-             * Emit code to generate it when EnumSetBuilder::build is called.\n+            \/*\n+             * Load the given set to the top of operand stack.\n@@ -1672,2 +1594,2 @@\n-            int indexOfOpensModifiers(CodeBuilder cob, Set<Opens.Modifier> mods) {\n-                return opensModifiersSets.get(mods).build(cob);\n+            void loadOpensModifiers(CodeBuilder cob, Set<Opens.Modifier> mods) {\n+                opensModifiersSets.get(mods).load(cob);\n@@ -1678,2 +1600,1 @@\n-             * Retrieve the index to the given set of Requires.Modifier.\n-             * Emit code to generate it when EnumSetBuilder::build is called.\n+             * Load the given set to the top of operand stack.\n@@ -1681,2 +1602,2 @@\n-            int indexOfRequiresModifiers(CodeBuilder cob, Set<Requires.Modifier> mods) {\n-                return requiresModifiersSets.get(mods).build(cob);\n+            void loadRequiresModifiers(CodeBuilder cob, Set<Requires.Modifier> mods) {\n+                requiresModifiersSets.get(mods).load(cob);\n@@ -1686,1 +1607,15 @@\n-             * Build a new string set without any attempt to deduplicate it.\n+             * Adding provider methods to the class. For those set used more than once, built\n+             * once and keep the reference for later access.\n+             * Return a list of snippet to be used in <clinit>.\n+             *\n+             * The returned snippet would set up the set referenced more than once,\n+             *\n+             * static final Set[] dedupSetValues;\n+             *\n+             * static {\n+             *     dedupSetValues = new Set[countOfStoredValues];\n+             *     dedupSetValues[0] = Set.of(elements); \/\/ elements no more than SET_SIZE_THRESHOLD\n+             *     dedupSetValues[1] = dedup<setWithIndex>Provider(); \/\/ set elements more than SET_SIZE_THRESHOLD\n+             *     ...\n+             *     dedupSetValues[countOfStoredValues - 1] = ...\n+             * }\n@@ -1688,6 +1623,20 @@\n-            int newStringSet(CodeBuilder cob, Set<String> names) {\n-                int index = new SetBuilder<>(names, stringSetVar, localVarSupplier).build(cob);\n-                assert index == stringSetVar;\n-                return index;\n-            }\n-        }\n+            Collection<Consumer<CodeBuilder>> buildConstants(ClassBuilder clb) {\n+                var index = 0;\n+                ArrayList<Consumer<CodeBuilder>> setValueBuilders = new ArrayList<>();\n+                \/\/ The SetReferences need to be sorted to reproduce same result.\n+                for (var ref : sorted(stringSets.values())) {\n+                    index++;\n+                    ref.generateConstant(clb, \"dedupStringSet\" + index).ifPresent(setValueBuilders::add);\n+                }\n+                for (var ref: sorted(opensModifiersSets.values())) {\n+                    index++;\n+                    ref.generateConstant(clb, \"dedupOpensSet\" + index).ifPresent(setValueBuilders::add);\n+                }\n+                for (var ref: sorted(exportsModifiersSets.values())) {\n+                    index++;\n+                    ref.generateConstant(clb, \"dedupExportsSet\" + index).ifPresent(setValueBuilders::add);\n+                }\n+                for (var ref: sorted(requiresModifiersSets.values())) {\n+                    index++;\n+                    ref.generateConstant(clb, \"dedupRequiresSet\" + index).ifPresent(setValueBuilders::add);\n+                }\n@@ -1695,23 +1644,12 @@\n-        \/*\n-         * SetBuilder generates bytecode to create one single instance of Set\n-         * for a given set of elements and assign to a local variable slot.\n-         * When there is only one single reference to a Set<T>,\n-         * it will reuse defaultVarIndex.  For a Set with multiple references,\n-         * it will use a new local variable retrieved from the nextLocalVar\n-         *\/\n-        static class SetBuilder<T extends Comparable<T>> {\n-            private static final MethodTypeDesc MTD_Set_ObjectArray = MethodTypeDesc.of(\n-                    CD_Set, CD_Object.arrayType());\n-\n-            private final Set<T> elements;\n-            private final int defaultVarIndex;\n-            private final IntSupplier nextLocalVar;\n-            private int refCount;\n-            private int localVarIndex;\n-\n-            SetBuilder(Set<T> elements,\n-                       int defaultVarIndex,\n-                       IntSupplier nextLocalVar) {\n-                this.elements = elements;\n-                this.defaultVarIndex = defaultVarIndex;\n-                this.nextLocalVar = nextLocalVar;\n+                if (countOfStoredValues > 0) {\n+                    \/\/ The request cache slots each should have an initial value\n+                    assert setValueBuilders.size() == countOfStoredValues;\n+                    clb.withField(VALUES_ARRAY, CD_Set.arrayType(), ACC_STATIC | ACC_FINAL);\n+                    \/\/ Allocate array before assign values\n+                    setValueBuilders.addFirst(cob ->\n+                            cob.loadConstant(countOfStoredValues)\n+                               .anewarray(CD_Set)\n+                               .dup()\n+                               .putstatic(owner, VALUES_ARRAY, CD_Set.arrayType()));\n+                }\n+                return setValueBuilders;\n@@ -1721,1 +1659,12 @@\n-             * Increments the number of references to this particular set.\n+             * SetReference count references to the set, and use an element loader, which is\n+             * a CodeBuilder that generate bytecode snippet to load an element onto the operand\n+             * stack, to generate bytecode to support loading the set onto operand stack.\n+             *\n+             * When a set size is over SET_SIZE_THRESHOLD, a provider function is generated\n+             * to build the set rather than inline to avoid method size overflow.\n+             *\n+             * When a set is referenced more than once, the set value is to be built once\n+             * and cached in an array to be load later.\n+             *\n+             * generateConstant method should be called to setup the provider methods and cache array.\n+             * load method can then be called to load the set onto the operand stack.\n@@ -1723,3 +1672,15 @@\n-            final void increment() {\n-                refCount++;\n-            }\n+            class SetReference<T extends Comparable<T>> implements Comparable<SetReference<T>> {\n+                \/\/ sorted elements of the set to ensure same generated code\n+                private final List<T> elements;\n+                private final BiConsumer<CodeBuilder, T> elementLoader;\n+\n+                private int refCount;\n+                \/\/ The index for this set value in the cache array\n+                private int index = -1;\n+                \/\/ The provider method name, null if ths set is small enough for inline generation\n+                private String methodName;\n+\n+                SetReference(Set<T> elements, BiConsumer<CodeBuilder, T> elementLoader) {\n+                    this.elements = sorted(elements);\n+                    this.elementLoader = elementLoader;\n+                }\n@@ -1727,7 +1688,3 @@\n-            \/**\n-             * Generate the appropriate instructions to load an object reference\n-             * to the element onto the stack.\n-             *\/\n-            void visitElement(T element, CodeBuilder cob) {\n-                cob.loadConstant((ConstantDesc)element);\n-            }\n+                int increment() {\n+                    return ++refCount;\n+                }\n@@ -1735,16 +1692,14 @@\n-            \/*\n-             * Build bytecode for the Set represented by this builder,\n-             * or get the local variable index of a previously generated set\n-             * (in the local scope).\n-             *\n-             * @return local variable index of the generated set.\n-             *\/\n-            final int build(CodeBuilder cob) {\n-                int index = localVarIndex;\n-                if (localVarIndex == 0) {\n-                    \/\/ if non-empty and more than one set reference this builder,\n-                    \/\/ emit to a unique local\n-                    index = refCount <= 1 ? defaultVarIndex\n-                                          : nextLocalVar.getAsInt();\n-                    if (index < MAX_LOCAL_VARS) {\n-                        localVarIndex = index;\n+                \/\/ Load the set to the operand stack.\n+                \/\/ When referenced more than once, the value is pre-built with static initialzer\n+                \/\/ and is load from the cache array with\n+                \/\/   dedupSetValues[index]\n+                \/\/ Otherwise, built the set in place with either\n+                \/\/   Set.of(elements)\n+                \/\/ or invoke the generated provider method\n+                \/\/   methodName()\n+                void load(CodeBuilder cob) {\n+                    if (refCount > 1) {\n+                        assert index >= 0;\n+                        cob.getstatic(owner, VALUES_ARRAY, CD_Set.arrayType());\n+                        cob.loadConstant(index);\n+                        cob.aaload();\n@@ -1752,2 +1707,1 @@\n-                        \/\/ overflow: disable optimization by using localVarIndex = 0\n-                        index = defaultVarIndex;\n+                        build(cob);\n@@ -1755,0 +1709,1 @@\n+                }\n@@ -1756,1 +1711,12 @@\n-                    generateSetOf(cob, index);\n+                \/\/ Build the set value and store the reference.\n+                \/\/ Generate either\n+                \/\/   dedupSetValues[index] = Set.of(elements);\n+                \/\/ or\n+                \/\/   dedupSetValues[index] = methodName();\n+                void store(CodeBuilder cob) {\n+                    assert index >= 0;\n+                    \/\/ array should be on top of the operands for this generate code in clinit\n+                    cob.dup()\n+                       .loadConstant(index);\n+                    build(cob);\n+                    cob.aastore();\n@@ -1758,2 +1724,0 @@\n-                return index;\n-            }\n@@ -1761,23 +1725,10 @@\n-            private void generateSetOf(CodeBuilder cob, int index) {\n-                if (elements.size() <= 10) {\n-                    \/\/ call Set.of(e1, e2, ...)\n-                    for (T t : sorted(elements)) {\n-                        visitElement(t, cob);\n-                    }\n-                    var mtdArgs = new ClassDesc[elements.size()];\n-                    Arrays.fill(mtdArgs, CD_Object);\n-                    cob.invokestatic(CD_Set,\n-                                     \"of\",\n-                                     MethodTypeDesc.of(CD_Set, mtdArgs),\n-                                     true);\n-                } else {\n-                    \/\/ call Set.of(E... elements)\n-                    cob.loadConstant(elements.size())\n-                       .anewarray(CD_String);\n-                    int arrayIndex = 0;\n-                    for (T t : sorted(elements)) {\n-                        cob.dup()    \/\/ arrayref\n-                           .loadConstant(arrayIndex);\n-                        visitElement(t, cob);  \/\/ value\n-                        cob.aastore();\n-                        arrayIndex++;\n+                \/\/ Build the set and leave the reference at top of the operand stack.\n+                \/\/ Generate either\n+                \/\/   Set.of(elements)\n+                \/\/ or invoke the provider method\n+                \/\/   methodName()\n+                private void build(CodeBuilder cob) {\n+                    if (methodName != null) {\n+                        cob.invokestatic(owner, methodName, MethodTypeDesc.of(CD_Set));\n+                    } else {\n+                        loadImmutableSet(cob, elements, elementLoader);\n@@ -1785,4 +1736,0 @@\n-                    cob.invokestatic(CD_Set,\n-                                     \"of\",\n-                                     MTD_Set_ObjectArray,\n-                                     true);\n@@ -1790,3 +1737,0 @@\n-                cob.astore(index);\n-            }\n-        }\n@@ -1794,13 +1738,10 @@\n-        \/*\n-         * Generates bytecode to create one single instance of EnumSet\n-         * for a given set of modifiers and assign to a local variable slot.\n-         *\/\n-        static class EnumSetBuilder<T extends Comparable<T>> extends SetBuilder<T> {\n-            private final ClassDesc classDesc;\n-\n-            EnumSetBuilder(Set<T> modifiers, ClassDesc classDesc,\n-                           int defaultVarIndex,\n-                           IntSupplier nextLocalVar) {\n-                super(modifiers, defaultVarIndex, nextLocalVar);\n-                this.classDesc = classDesc;\n-            }\n+                \/**\n+                 * Generate provider method if the set size is over threshold to avoid overload\n+                 * bytecode limitation per method.\n+                 * Return a snippet builder that generates code to store the reference of the set value.\n+                 *\/\n+                Optional<Consumer<CodeBuilder>> generateConstant(ClassBuilder clb, String name) {\n+                    if (elements.size() > ModuleDescriptorBuilder.SET_SIZE_THRESHOLD) {\n+                        methodName = name + \"Provider\";\n+                        genImmutableSetProvider(clb, methodName, elements, elementLoader);\n+                    }\n@@ -1808,6 +1749,27 @@\n-            \/**\n-             * Loads an Enum field.\n-             *\/\n-            @Override\n-            void visitElement(T t, CodeBuilder cob) {\n-                cob.getstatic(classDesc, t.toString(), classDesc);\n+                    if (refCount <= 1) {\n+                        return Optional.empty();\n+                    } else {\n+                        index = requestValueStorage();\n+                        return Optional.of(this::store);\n+                    }\n+                }\n+\n+                @Override\n+                public int compareTo(SetReference<T> o) {\n+                    if (o == this) {\n+                        return 0;\n+                    }\n+                    if (elements.size() == o.elements.size()) {\n+                        var a1 = elements;\n+                        var a2 = o.elements;\n+                        for (int i = 0; i < elements.size(); i++) {\n+                            var r = a1.get(i).compareTo(a2.get(i));\n+                            if (r != 0) {\n+                                return r;\n+                            }\n+                        }\n+                        return 0;\n+                    } else {\n+                        return elements.size() - o.elements.size();\n+                    }\n+                }\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/SystemModulesPlugin.java","additions":303,"deletions":341,"binary":false,"changes":644,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.StringJoiner;\n+import java.util.spi.ToolProvider;\n+\n+import tests.JImageGenerator;\n+\n+\/*\n+ * @test\n+ * @summary Make sure that ~3500 packages in a uber jar can be linked using jlink. Depends on the\n+ *          packages, this is almost hit the 64K limitation as each plain export could take\n+ *          ~17 bytecodes.\n+ * @bug 8321413\n+ * @library ..\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jmod\n+ *          jdk.jlink\/jdk.tools.jimage\n+ *          jdk.compiler\n+ * @build tests.*\n+ * @run main\/othervm -Xmx1g -Xlog:init=debug -XX:+UnlockDiagnosticVMOptions -XX:+BytecodeVerificationLocal JLink3500Packages\n+ *\/\n+public class JLink3500Packages {\n+    private static final ToolProvider JAVAC_TOOL = ToolProvider.findFirst(\"javac\")\n+            .orElseThrow(() -> new RuntimeException(\"javac tool not found\"));\n+\n+    static void report(String command, String[] args) {\n+        System.out.println(command + \" \" + String.join(\" \", Arrays.asList(args)));\n+    }\n+\n+    static void javac(String[] args) {\n+        report(\"javac\", args);\n+        JAVAC_TOOL.run(System.out, System.err, args);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Path src = Paths.get(\"bug8321413\");\n+        Path mainModulePath = src.resolve(\"bug8321413x\");\n+\n+        StringJoiner mainModuleInfoContent = new StringJoiner(\";\\n  exports \", \"module bug8321413x {\\n  exports \", \";\\n}\");\n+\n+        for (int i = 0; i < 3500; i++) {\n+            String packageName = \"p\" + i;\n+            String className = \"C\" + i;\n+\n+            Path packagePath = Files.createDirectories(mainModulePath.resolve(packageName));\n+\n+            StringBuilder classContent = new StringBuilder(\"package \");\n+            classContent.append(packageName).append(\";\\n\");\n+            classContent.append(\"class \").append(className).append(\" {}\\n\");\n+            Files.writeString(packagePath.resolve(className + \".java\"), classContent.toString());\n+\n+            mainModuleInfoContent.add(packageName);\n+        }\n+\n+        \/\/ create module reading the generated modules\n+        Path mainModuleInfo = mainModulePath.resolve(\"module-info.java\");\n+        Files.writeString(mainModuleInfo, mainModuleInfoContent.toString());\n+\n+        Path mainClassDir = mainModulePath.resolve(\"testpackage\");\n+        Files.createDirectories(mainClassDir);\n+\n+        Files.writeString(mainClassDir.resolve(\"JLink3500PackagesTest.java\"), \"\"\"\n+                package testpackage;\n+\n+                public class JLink3500PackagesTest {\n+                    public static void main(String[] args) throws Exception {\n+                        System.out.println(\"JLink3500PackagesTest started.\");\n+                    }\n+                }\n+                \"\"\");\n+\n+        String out = src.resolve(\"out\").toString();\n+        javac(new String[]{\n+                \"-d\", out,\n+                \"--module-source-path\", src.toString(),\n+                \"--module\", \"bug8321413x\"\n+        });\n+\n+        JImageGenerator.getJLinkTask()\n+                .modulePath(out)\n+                .output(src.resolve(\"out-jlink\"))\n+                .addMods(\"bug8321413x\")\n+                .call()\n+                .assertSuccess();\n+\n+        Path binDir = src.resolve(\"out-jlink\").resolve(\"bin\").toAbsolutePath();\n+        Path bin = binDir.resolve(\"java\");\n+\n+        ProcessBuilder processBuilder = new ProcessBuilder(bin.toString(),\n+                \"-XX:+UnlockDiagnosticVMOptions\",\n+                \"-XX:+BytecodeVerificationLocal\",\n+                \"-m\", \"bug8321413x\/testpackage.JLink3500PackagesTest\");\n+        processBuilder.inheritIO();\n+        processBuilder.directory(binDir.toFile());\n+        Process process = processBuilder.start();\n+        int exitCode = process.waitFor();\n+        if (exitCode != 0)\n+             throw new AssertionError(\"JLink3500PackagesTest failed to launch\");\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/JLink3500Packages.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"}]}