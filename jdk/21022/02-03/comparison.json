{"files":[{"patch":"@@ -558,1 +558,1 @@\n-        private final ArrayList<Consumer<ClassBuilder>> amendaments = new ArrayList<>();\n+        private final ArrayList<Consumer<ClassBuilder>> amendments = new ArrayList<>();\n@@ -640,1 +640,1 @@\n-                        amendaments.forEach(amendament -> amendament.accept(clb));\n+                        amendments.forEach(amendment -> amendment.accept(clb));\n@@ -644,2 +644,2 @@\n-        private void addModuleHelpers(Consumer<ClassBuilder> amendament) {\n-            amendaments.add(amendament);\n+        private void addModuleHelpers(Consumer<ClassBuilder> amendment) {\n+            amendments.add(amendment);\n@@ -664,2 +664,2 @@\n-            var cinitSnippets = dedupSetBuilder.buildConstants(clb);\n-            if (!cinitSnippets.isEmpty()) {\n+            var clinitSnippets = dedupSetBuilder.buildConstants(clb);\n+            if (!clinitSnippets.isEmpty()) {\n@@ -671,1 +671,1 @@\n-                            cinitSnippets.forEach(snippet -> snippet.accept(cob));\n+                            clinitSnippets.forEach(snippet -> snippet.accept(cob));\n@@ -746,23 +746,1 @@\n-            \/\/ and so on.  During the construction of the module descriptors, the string sets and\n-            \/\/ modifier sets are deduplicated (see SystemModulesClassGenerator.DedupSetBuilder)\n-            \/\/ and cached in the locals. These locals are saved in an array list so\n-            \/\/ that the helper method can restore the local variables that may be\n-            \/\/ referenced by the bytecode generated for creating module descriptors.\n-            \/\/ Pseudo code looks like this:\n-            \/\/\n-            \/\/ void subi(ModuleDescriptor[] mdescs, ArrayList<Object> localvars) {\n-            \/\/      \/\/ assign localvars to local variables\n-            \/\/      var l3 = localvars.get(0);\n-            \/\/      var l4 = localvars.get(1);\n-            \/\/        :\n-            \/\/      \/\/ fill mdescs[i] to mdescs[i+n-1]\n-            \/\/      mdescs[i] = ...\n-            \/\/      mdescs[i+1] = ...\n-            \/\/        :\n-            \/\/      \/\/ save new local variables added\n-            \/\/      localvars.add(lx)\n-            \/\/      localvars.add(l{x+1})\n-            \/\/        :\n-            \/\/      sub{i+i}(mdescs, localvars);\n-            \/\/ }\n-\n+            \/\/ and so on.\n@@ -1598,1 +1576,1 @@\n-            int counterStoredValues = 0;\n+            int countOfStoredValues = 0;\n@@ -1605,1 +1583,1 @@\n-                return counterStoredValues++;\n+                return countOfStoredValues++;\n@@ -1676,1 +1654,1 @@\n-             * Return a list of snippet to be used in <cinit>.\n+             * Return a list of snippet to be used in <clinit>.\n@@ -1681,1 +1659,1 @@\n-\n+                \/\/ The SetReferences need to be sorted to reproduce same result.\n@@ -1699,2 +1677,2 @@\n-                if (counterStoredValues > 0) {\n-                    assert setValueBuilders.size() == counterStoredValues;\n+                if (countOfStoredValues > 0) {\n+                    assert setValueBuilders.size() == countOfStoredValues;\n@@ -1702,0 +1680,1 @@\n+                    \/\/ Allocate array before assign values\n@@ -1703,1 +1682,1 @@\n-                            cob.loadConstant(counterStoredValues)\n+                            cob.loadConstant(countOfStoredValues)\n@@ -1714,0 +1693,14 @@\n+            \/*\n+             * SetReference count references to the set, and use a CodeBuilder that\n+             * generate bytecode to load an element onto the operand stack to generate bytecode\n+             * to support loading the set onto operand stack.\n+             *\n+             * When a set size is over SET_SIZE_THRESHOLD, a provider function is generated\n+             * to build the set rather than inline to avoid method size overflow.\n+             *\n+             * When a set is referenced more than once, the set value is to be built once\n+             * and cached in an array to be load later.\n+             *\n+             * generateConstant method should be called to setup the provider methods and cache array.\n+             * load method can then be called to load the set onto the operand stack.\n+             *\/\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/SystemModulesPlugin.java","additions":30,"deletions":37,"binary":false,"changes":67,"status":"modified"}]}