{"files":[{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.constant.ConstantDesc;\n@@ -63,1 +62,2 @@\n-import java.util.function.IntSupplier;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n@@ -548,3 +548,1 @@\n-        private final int DEDUP_LIST_VAR = 2;\n-        private final int BUILDER_VAR    = 3;\n-        private int nextLocalVar         = 4;  \/\/ index to next local variable\n+        private final int BUILDER_VAR    = 2;\n@@ -560,0 +558,2 @@\n+        private final ArrayList<Consumer<ClassBuilder>> amendaments = new ArrayList<>();\n+\n@@ -563,2 +563,1 @@\n-        private final DedupSetBuilder dedupSetBuilder\n-            = new DedupSetBuilder(this::getNextLocalVar);\n+        private final DedupSetBuilder dedupSetBuilder;\n@@ -572,0 +571,1 @@\n+            this.dedupSetBuilder = new DedupSetBuilder(this.classDesc);\n@@ -575,4 +575,0 @@\n-        private int getNextLocalVar() {\n-            return nextLocalVar++;\n-        }\n-\n@@ -619,0 +615,3 @@\n+                        \/\/ generate dedup set fields and provider methods\n+                        genConstants(clb);\n+\n@@ -639,0 +638,3 @@\n+\n+                        \/\/ generate module helpers\n+                        amendaments.forEach(amendament -> amendament.accept(clb));\n@@ -642,0 +644,4 @@\n+        private void addModuleHelpers(Consumer<ClassBuilder> amendament) {\n+            amendaments.add(amendament);\n+        }\n+\n@@ -657,0 +663,14 @@\n+        private void genConstants(ClassBuilder clb) {\n+            var cinitSnippets = dedupSetBuilder.buildConstants(clb);\n+            if (!cinitSnippets.isEmpty()) {\n+                clb.withMethodBody(\n+                        CLASS_INIT_NAME,\n+                        MTD_void,\n+                        ACC_STATIC,\n+                        cob -> {\n+                            cinitSnippets.forEach(snippet -> snippet.accept(cob));\n+                            cob.return_();\n+                        });\n+            }\n+        }\n+\n@@ -760,1 +780,0 @@\n-            ClassDesc arrayListClassDesc = ClassDesc.ofInternalName(\"java\/util\/ArrayList\");\n@@ -771,5 +790,0 @@\n-                        cob.new_(arrayListClassDesc)\n-                           .dup()\n-                           .loadConstant(moduleInfos.size())\n-                           .invokespecial(arrayListClassDesc, INIT_NAME, MethodTypeDesc.of(CD_void, CD_int))\n-                           .astore(DEDUP_LIST_VAR);\n@@ -778,1 +792,0 @@\n-                           .aload(DEDUP_LIST_VAR)\n@@ -782,1 +795,1 @@\n-                                   MethodTypeDesc.of(CD_void, CD_MODULE_DESCRIPTOR.arrayType(), arrayListClassDesc)\n+                                   MethodTypeDesc.of(CD_void, CD_MODULE_DESCRIPTOR.arrayType())\n@@ -787,1 +800,0 @@\n-            int dedupVarStart = nextLocalVar;\n@@ -791,1 +803,0 @@\n-                int curDedupVar = nextLocalVar;\n@@ -794,1 +805,1 @@\n-                        MethodTypeDesc.of(CD_void, CD_MODULE_DESCRIPTOR.arrayType(), arrayListClassDesc),\n+                        MethodTypeDesc.of(CD_void, CD_MODULE_DESCRIPTOR.arrayType()),\n@@ -797,9 +808,0 @@\n-                            if (curDedupVar > dedupVarStart) {\n-                                for (int i = dedupVarStart; i < curDedupVar; i++) {\n-                                    cob.aload(DEDUP_LIST_VAR)\n-                                       .loadConstant(i - dedupVarStart)\n-                                       .invokevirtual(arrayListClassDesc, \"get\", MethodTypeDesc.of(CD_Object, CD_int))\n-                                       .astore(i);\n-                                }\n-                            }\n-\n@@ -816,8 +818,0 @@\n-                                if (nextLocalVar > curDedupVar) {\n-                                    for (int i = curDedupVar; i < nextLocalVar; i++) {\n-                                        cob.aload(DEDUP_LIST_VAR)\n-                                           .aload(i)\n-                                           .invokevirtual(arrayListClassDesc, \"add\", MethodTypeDesc.of(CD_boolean, CD_Object))\n-                                           .pop();\n-                                    }\n-                                }\n@@ -826,1 +820,0 @@\n-                                   .aload(DEDUP_LIST_VAR)\n@@ -830,1 +823,1 @@\n-                                           MethodTypeDesc.of(CD_void, CD_MODULE_DESCRIPTOR.arrayType(), arrayListClassDesc)\n+                                           MethodTypeDesc.of(CD_void, CD_MODULE_DESCRIPTOR.arrayType())\n@@ -1044,30 +1037,1 @@\n-            int size = set.size();\n-\n-            \/\/ use Set.of(Object[]) when there are more than 2 elements\n-            \/\/ use Set.of(Object) or Set.of(Object, Object) when fewer\n-            if (size > 2) {\n-                cob.loadConstant(size)\n-                   .anewarray(CD_String);\n-                int i = 0;\n-                for (String element : sorted(set)) {\n-                    cob.dup()\n-                       .loadConstant(i)\n-                       .loadConstant(element)\n-                       .aastore();\n-                    i++;\n-                }\n-                cob.invokestatic(CD_Set,\n-                                 \"of\",\n-                                 MTD_Set_ObjectArray,\n-                                 true);\n-            } else {\n-                for (String element : sorted(set)) {\n-                    cob.loadConstant(element);\n-                }\n-                var mtdArgs = new ClassDesc[size];\n-                Arrays.fill(mtdArgs, CD_Object);\n-                cob.invokestatic(CD_Set,\n-                                 \"of\",\n-                                 MethodTypeDesc.of(CD_Set, mtdArgs),\n-                                 true);\n-            }\n+            loadImmutableSet(cob, set, CodeBuilder::loadConstant);\n@@ -1120,0 +1084,2 @@\n+            static final int SET_SIZE_THRESHOLD = 512; \/\/ An arbitrary number as this likely generate minimum ~4K code\n+\n@@ -1247,3 +1213,2 @@\n-                int varIndex = dedupSetBuilder.indexOfRequiresModifiers(cob, mods);\n-                cob.aload(varIndex)\n-                   .loadConstant(name);\n+                dedupSetBuilder.loadRequiresModifiers(cob, mods);\n+                cob.loadConstant(name);\n@@ -1269,3 +1234,28 @@\n-                cob.aload(BUILDER_VAR)\n-                   .loadConstant(exports.size())\n-                   .anewarray(CD_EXPORTS);\n+                cob.aload(BUILDER_VAR);\n+                loadExportsArray(exports);\n+                cob.invokevirtual(CD_MODULE_BUILDER,\n+                        \"exports\",\n+                        MTD_EXPORTS_ARRAY)\n+                        .pop();\n+            }\n+\n+            void loadExportsArray(Set<Exports> exports) {\n+                if (exports.size() > SET_SIZE_THRESHOLD) {\n+                    String methodName = \"module\" + index + \"Exports\";\n+                    addModuleHelpers(clb -> clb.withMethodBody(\n+                            methodName,\n+                            MethodTypeDesc.of(CD_EXPORTS.arrayType()),\n+                            ACC_STATIC,\n+                            mcob -> {\n+                                genExportSet(mcob, exports);\n+                                mcob.areturn();\n+                            }));\n+                    cob.invokestatic(classDesc, methodName, MethodTypeDesc.of(CD_EXPORTS.arrayType()));\n+                } else {\n+                    genExportSet(cob, exports);\n+                }\n+            }\n+\n+            void genExportSet(CodeBuilder cb, Set<Exports> exports) {\n+                cb.loadConstant(exports.size())\n+                  .anewarray(CD_EXPORTS);\n@@ -1273,0 +1263,1 @@\n+\n@@ -1274,4 +1265,4 @@\n-                    cob.dup()    \/\/ arrayref\n-                       .loadConstant(arrayIndex++);\n-                    newExports(export.modifiers(), export.source(), export.targets());\n-                    cob.aastore();\n+                    cb.dup() \/\/ arrayref\n+                      .loadConstant(arrayIndex++);\n+                    newExports(cb, export.modifiers(), export.source(), export.targets());\n+                    cb.aastore();\n@@ -1279,4 +1270,0 @@\n-                cob.invokevirtual(CD_MODULE_BUILDER,\n-                                  \"exports\",\n-                                  MTD_EXPORTS_ARRAY)\n-                    .pop();\n@@ -1300,2 +1287,3 @@\n-            void newExports(Set<Exports.Modifier> ms, String pn, Set<String> targets) {\n-                int modifiersSetIndex = dedupSetBuilder.indexOfExportsModifiers(cob, ms);\n+            void newExports(CodeBuilder cb, Set<Exports.Modifier> ms, String pn, Set<String> targets) {\n+                dedupSetBuilder.loadExportsModifiers(cb, ms);\n+                cb.loadConstant(pn);\n@@ -1303,7 +1291,4 @@\n-                    int stringSetIndex = dedupSetBuilder.indexOfStringSet(cob, targets);\n-                    cob.aload(modifiersSetIndex)\n-                       .loadConstant(pn)\n-                       .aload(stringSetIndex)\n-                       .invokestatic(CD_MODULE_BUILDER,\n-                                     \"newExports\",\n-                                     MTD_EXPORTS_MODIFIER_SET_STRING_SET);\n+                    dedupSetBuilder.loadStringSet(cb, targets);\n+                    cb.invokestatic(CD_MODULE_BUILDER,\n+                                    \"newExports\",\n+                                    MTD_EXPORTS_MODIFIER_SET_STRING_SET);\n@@ -1311,3 +1296,1 @@\n-                    cob.aload(modifiersSetIndex)\n-                       .loadConstant(pn)\n-                       .invokestatic(CD_MODULE_BUILDER,\n+                    cb.invokestatic(CD_MODULE_BUILDER,\n@@ -1358,1 +1341,2 @@\n-                int modifiersSetIndex = dedupSetBuilder.indexOfOpensModifiers(cob, ms);\n+                dedupSetBuilder.loadOpensModifiers(cob, ms);\n+                cob.loadConstant(pn);\n@@ -1360,5 +1344,2 @@\n-                    int stringSetIndex = dedupSetBuilder.indexOfStringSet(cob, targets);\n-                    cob.aload(modifiersSetIndex)\n-                       .loadConstant(pn)\n-                       .aload(stringSetIndex)\n-                       .invokestatic(CD_MODULE_BUILDER,\n+                    dedupSetBuilder.loadStringSet(cob, targets);\n+                    cob.invokestatic(CD_MODULE_BUILDER,\n@@ -1368,3 +1349,1 @@\n-                    cob.aload(modifiersSetIndex)\n-                       .loadConstant(pn)\n-                       .invokestatic(CD_MODULE_BUILDER,\n+                    cob.invokestatic(CD_MODULE_BUILDER,\n@@ -1380,4 +1359,3 @@\n-                int varIndex = dedupSetBuilder.indexOfStringSet(cob, uses);\n-                cob.aload(BUILDER_VAR)\n-                   .aload(varIndex)\n-                   .invokevirtual(CD_MODULE_BUILDER,\n+                cob.aload(BUILDER_VAR);\n+                dedupSetBuilder.loadStringSet(cob, uses);\n+                cob.invokevirtual(CD_MODULE_BUILDER,\n@@ -1445,4 +1423,18 @@\n-                int varIndex = dedupSetBuilder.newStringSet(cob, packages);\n-                cob.aload(BUILDER_VAR)\n-                   .aload(varIndex)\n-                   .invokevirtual(CD_MODULE_BUILDER,\n+                cob.aload(BUILDER_VAR);\n+                if (packages.size() > SET_SIZE_THRESHOLD) {\n+                    var methodName = \"module\" + index + \"Packages\";\n+                    addModuleHelpers(clb -> {\n+                            clb.withMethodBody(\n+                                methodName,\n+                                MethodTypeDesc.of(CD_Set),\n+                                ACC_STATIC,\n+                                cob -> {\n+                                    genImmutableSet(cob, packages);\n+                                    cob.areturn();\n+                                });\n+                            });\n+                    cob.invokestatic(classDesc, methodName, MethodTypeDesc.of(CD_Set));\n+                } else {\n+                    genImmutableSet(cob, packages);\n+                }\n+                cob.invokevirtual(CD_MODULE_BUILDER,\n@@ -1586,1 +1578,1 @@\n-            final Map<Set<String>, SetBuilder<String>> stringSets = new HashMap<>();\n+            final Map<Set<String>, SetReference<String>> stringSets = new HashMap<>();\n@@ -1590,1 +1582,1 @@\n-            final Map<Set<Requires.Modifier>, EnumSetBuilder<Requires.Modifier>>\n+            final Map<Set<Requires.Modifier>, SetReference<Requires.Modifier>>\n@@ -1595,1 +1587,1 @@\n-            final Map<Set<Exports.Modifier>, EnumSetBuilder<Exports.Modifier>>\n+            final Map<Set<Exports.Modifier>, SetReference<Exports.Modifier>>\n@@ -1600,1 +1592,1 @@\n-            final Map<Set<Opens.Modifier>, EnumSetBuilder<Opens.Modifier>>\n+            final Map<Set<Opens.Modifier>, SetReference<Opens.Modifier>>\n@@ -1603,3 +1595,8 @@\n-            private final int stringSetVar;\n-            private final int enumSetVar;\n-            private final IntSupplier localVarSupplier;\n+            private static final String VALUES_ARRAY = \"dedupSetValues\";\n+\n+            final ClassDesc owner;\n+            int counterStoredValues = 0;\n+\n+            DedupSetBuilder(ClassDesc owner) {\n+                this.owner = owner;\n+            }\n@@ -1607,4 +1604,2 @@\n-            DedupSetBuilder(IntSupplier localVarSupplier) {\n-                this.stringSetVar = localVarSupplier.getAsInt();\n-                this.enumSetVar = localVarSupplier.getAsInt();\n-                this.localVarSupplier = localVarSupplier;\n+            int requestValueStorage() {\n+                return counterStoredValues++;\n@@ -1618,1 +1613,1 @@\n-                    s -> new SetBuilder<>(s, stringSetVar, localVarSupplier)\n+                    s -> new SetReference<>(s, CodeBuilder::loadConstant)\n@@ -1627,2 +1622,1 @@\n-                                new EnumSetBuilder<>(s, CD_EXPORTS_MODIFIER,\n-                                        enumSetVar, localVarSupplier)\n+                        new SetReference<>(s, getEnumLoader(CD_EXPORTS_MODIFIER))\n@@ -1637,2 +1631,1 @@\n-                                new EnumSetBuilder<>(s, CD_OPENS_MODIFIER,\n-                                        enumSetVar, localVarSupplier)\n+                        new SetReference<>(s, getEnumLoader(CD_OPENS_MODIFIER))\n@@ -1647,2 +1640,1 @@\n-                    new EnumSetBuilder<>(s, CD_REQUIRES_MODIFIER,\n-                                         enumSetVar, localVarSupplier)\n+                        new SetReference<>(s, getEnumLoader(CD_REQUIRES_MODIFIER))\n@@ -1653,2 +1645,1 @@\n-             * Retrieve the index to the given set of Strings. Emit code to\n-             * generate it when SetBuilder::build is called.\n+             * Load the given set to the top of operand stack.\n@@ -1656,2 +1647,2 @@\n-            int indexOfStringSet(CodeBuilder cob, Set<String> names) {\n-                return stringSets.get(names).build(cob);\n+            void loadStringSet(CodeBuilder cob, Set<String> names) {\n+                stringSets.get(names).load(cob);\n@@ -1661,2 +1652,1 @@\n-             * Retrieve the index to the given set of Exports.Modifier.\n-             * Emit code to generate it when EnumSetBuilder::build is called.\n+             * Load the given set to the top of operand stack.\n@@ -1664,2 +1654,2 @@\n-            int indexOfExportsModifiers(CodeBuilder cob, Set<Exports.Modifier> mods) {\n-                return exportsModifiersSets.get(mods).build(cob);\n+            void loadExportsModifiers(CodeBuilder cob, Set<Exports.Modifier> mods) {\n+                exportsModifiersSets.get(mods).load(cob);\n@@ -1668,3 +1658,2 @@\n-            \/**\n-             * Retrieve the index to the given set of Opens.Modifier.\n-             * Emit code to generate it when EnumSetBuilder::build is called.\n+            \/*\n+             * Load the given set to the top of operand stack.\n@@ -1672,2 +1661,2 @@\n-            int indexOfOpensModifiers(CodeBuilder cob, Set<Opens.Modifier> mods) {\n-                return opensModifiersSets.get(mods).build(cob);\n+            void loadOpensModifiers(CodeBuilder cob, Set<Opens.Modifier> mods) {\n+                opensModifiersSets.get(mods).load(cob);\n@@ -1678,2 +1667,1 @@\n-             * Retrieve the index to the given set of Requires.Modifier.\n-             * Emit code to generate it when EnumSetBuilder::build is called.\n+             * Load the given set to the top of operand stack.\n@@ -1681,2 +1669,2 @@\n-            int indexOfRequiresModifiers(CodeBuilder cob, Set<Requires.Modifier> mods) {\n-                return requiresModifiersSets.get(mods).build(cob);\n+            void loadRequiresModifiers(CodeBuilder cob, Set<Requires.Modifier> mods) {\n+                requiresModifiersSets.get(mods).load(cob);\n@@ -1686,1 +1674,3 @@\n-             * Build a new string set without any attempt to deduplicate it.\n+             * Adding provider methods to the class. For those set used more than once, built\n+             * once and keep the reference for later access.\n+             * Return a list of snippet to be used in <cinit>.\n@@ -1688,17 +1678,3 @@\n-            int newStringSet(CodeBuilder cob, Set<String> names) {\n-                int index = new SetBuilder<>(names, stringSetVar, localVarSupplier).build(cob);\n-                assert index == stringSetVar;\n-                return index;\n-            }\n-        }\n-\n-        \/*\n-         * SetBuilder generates bytecode to create one single instance of Set\n-         * for a given set of elements and assign to a local variable slot.\n-         * When there is only one single reference to a Set<T>,\n-         * it will reuse defaultVarIndex.  For a Set with multiple references,\n-         * it will use a new local variable retrieved from the nextLocalVar\n-         *\/\n-        static class SetBuilder<T extends Comparable<T>> {\n-            private static final MethodTypeDesc MTD_Set_ObjectArray = MethodTypeDesc.of(\n-                    CD_Set, CD_Object.arrayType());\n+            Collection<Consumer<CodeBuilder>> buildConstants(ClassBuilder clb) {\n+                var index = 0;\n+                ArrayList<Consumer<CodeBuilder>> setValueBuilders = new ArrayList<>();\n@@ -1706,5 +1682,16 @@\n-            private final Set<T> elements;\n-            private final int defaultVarIndex;\n-            private final IntSupplier nextLocalVar;\n-            private int refCount;\n-            private int localVarIndex;\n+                for (var ref : sorted(stringSets.values())) {\n+                    index++;\n+                    ref.generateConstant(clb, \"dedupStringSet\" + index).ifPresent(setValueBuilders::add);\n+                }\n+                for (var ref: sorted(opensModifiersSets.values())) {\n+                    index++;\n+                    ref.generateConstant(clb, \"dedupOpensSet\" + index).ifPresent(setValueBuilders::add);\n+                }\n+                for (var ref: sorted(exportsModifiersSets.values())) {\n+                    index++;\n+                    ref.generateConstant(clb, \"dedupExportsSet\" + index).ifPresent(setValueBuilders::add);\n+                }\n+                for (var ref: sorted(requiresModifiersSets.values())) {\n+                    index++;\n+                    ref.generateConstant(clb, \"dedupRequiresSet\" + index).ifPresent(setValueBuilders::add);\n+                }\n@@ -1712,6 +1699,9 @@\n-            SetBuilder(Set<T> elements,\n-                       int defaultVarIndex,\n-                       IntSupplier nextLocalVar) {\n-                this.elements = elements;\n-                this.defaultVarIndex = defaultVarIndex;\n-                this.nextLocalVar = nextLocalVar;\n+                if (counterStoredValues > 0) {\n+                    assert setValueBuilders.size() == counterStoredValues;\n+                    clb.withField(VALUES_ARRAY, CD_Set.arrayType(), ACC_STATIC | ACC_FINAL);\n+                    setValueBuilders.addFirst(cob ->\n+                            cob.loadConstant(counterStoredValues)\n+                               .anewarray(CD_Set)\n+                               .putstatic(owner, VALUES_ARRAY, CD_Set.arrayType()));\n+                }\n+                return setValueBuilders;\n@@ -1720,5 +1710,2 @@\n-            \/*\n-             * Increments the number of references to this particular set.\n-             *\/\n-            final void increment() {\n-                refCount++;\n+            void loadValuesArray(CodeBuilder cob) {\n+                cob.getstatic(owner, VALUES_ARRAY, CD_Set.arrayType());\n@@ -1727,7 +1714,3 @@\n-            \/**\n-             * Generate the appropriate instructions to load an object reference\n-             * to the element onto the stack.\n-             *\/\n-            void visitElement(T element, CodeBuilder cob) {\n-                cob.loadConstant((ConstantDesc)element);\n-            }\n+            class SetReference<T extends Comparable<T>> implements Comparable<SetReference<T>> {\n+                private final Set<T> elements;\n+                private final BiConsumer<CodeBuilder, T> elementLoader;\n@@ -1735,16 +1718,21 @@\n-            \/*\n-             * Build bytecode for the Set represented by this builder,\n-             * or get the local variable index of a previously generated set\n-             * (in the local scope).\n-             *\n-             * @return local variable index of the generated set.\n-             *\/\n-            final int build(CodeBuilder cob) {\n-                int index = localVarIndex;\n-                if (localVarIndex == 0) {\n-                    \/\/ if non-empty and more than one set reference this builder,\n-                    \/\/ emit to a unique local\n-                    index = refCount <= 1 ? defaultVarIndex\n-                                          : nextLocalVar.getAsInt();\n-                    if (index < MAX_LOCAL_VARS) {\n-                        localVarIndex = index;\n+                private int refCount;\n+                private int index = -1;\n+                private String methodName;\n+\n+                SetReference(Set<T> elements, BiConsumer<CodeBuilder, T> elementLoader) {\n+                    this.elements = elements;\n+                    this.elementLoader = elementLoader;\n+                }\n+\n+                int increment() {\n+                    return ++refCount;\n+                }\n+\n+\n+                \/\/ Load the set to the operand stack\n+                void load(CodeBuilder cob) {\n+                    if (refCount > 1) {\n+                        assert index >= 0;\n+                        loadValuesArray(cob);\n+                        cob.loadConstant(index);\n+                        cob.aaload();\n@@ -1752,2 +1740,1 @@\n-                        \/\/ overflow: disable optimization by using localVarIndex = 0\n-                        index = defaultVarIndex;\n+                        build(cob);\n@@ -1755,0 +1742,1 @@\n+                }\n@@ -1756,1 +1744,7 @@\n-                    generateSetOf(cob, index);\n+                \/\/ Build the set value and store the reference\n+                void store(CodeBuilder cob) {\n+                    assert index >= 0;\n+                    loadValuesArray(cob);\n+                    cob.loadConstant(index);\n+                    build(cob);\n+                    cob.aastore();\n@@ -1758,2 +1752,0 @@\n-                return index;\n-            }\n@@ -1761,5 +1753,6 @@\n-            private void generateSetOf(CodeBuilder cob, int index) {\n-                if (elements.size() <= 10) {\n-                    \/\/ call Set.of(e1, e2, ...)\n-                    for (T t : sorted(elements)) {\n-                        visitElement(t, cob);\n+                \/\/ build the set and leave the reference at top of the operand stack\n+                private void build(CodeBuilder cob) {\n+                    if (methodName != null) {\n+                        cob.invokestatic(owner, methodName, MethodTypeDesc.of(CD_Set));\n+                    } else {\n+                        loadImmutableSet(cob, elements, elementLoader);\n@@ -1767,17 +1760,38 @@\n-                    var mtdArgs = new ClassDesc[elements.size()];\n-                    Arrays.fill(mtdArgs, CD_Object);\n-                    cob.invokestatic(CD_Set,\n-                                     \"of\",\n-                                     MethodTypeDesc.of(CD_Set, mtdArgs),\n-                                     true);\n-                } else {\n-                    \/\/ call Set.of(E... elements)\n-                    cob.loadConstant(elements.size())\n-                       .anewarray(CD_String);\n-                    int arrayIndex = 0;\n-                    for (T t : sorted(elements)) {\n-                        cob.dup()    \/\/ arrayref\n-                           .loadConstant(arrayIndex);\n-                        visitElement(t, cob);  \/\/ value\n-                        cob.aastore();\n-                        arrayIndex++;\n+                }\n+\n+                \/**\n+                 * Generate provider method if the set size is over threshold to avoid overload\n+                 * bytecode limitation per method.\n+                 * Return a snippet builder that generates code to store the reference of the set value.\n+                 *\/\n+                Optional<Consumer<CodeBuilder>> generateConstant(ClassBuilder clb, String name) {\n+                    if (elements.size() > ModuleDescriptorBuilder.SET_SIZE_THRESHOLD) {\n+                        methodName = name + \"Provider\";\n+                        genImmutableSetProvider(clb, methodName, elements, elementLoader);\n+                    }\n+\n+                    if (refCount <= 1) {\n+                        return Optional.empty();\n+                    } else {\n+                        index = requestValueStorage();\n+                        return Optional.of(this::store);\n+                    }\n+                }\n+\n+                @Override\n+                public int compareTo(SetReference<T> o) {\n+                    if (o == this) {\n+                        return 0;\n+                    }\n+                    if (elements.size() == o.elements.size()) {\n+                        var a1 = sorted(elements);\n+                        var a2 = sorted(o.elements);\n+                        for (int i = 0; i < elements.size(); i++) {\n+                            var r = a1.get(i).compareTo(a2.get(i));\n+                            if (r != 0) {\n+                                return r;\n+                            }\n+                        }\n+                        return 0;\n+                    } else {\n+                        return elements.size() - o.elements.size();\n@@ -1785,4 +1799,0 @@\n-                    cob.invokestatic(CD_Set,\n-                                     \"of\",\n-                                     MTD_Set_ObjectArray,\n-                                     true);\n@@ -1790,1 +1800,0 @@\n-                cob.astore(index);\n@@ -1794,6 +1803,3 @@\n-        \/*\n-         * Generates bytecode to create one single instance of EnumSet\n-         * for a given set of modifiers and assign to a local variable slot.\n-         *\/\n-        static class EnumSetBuilder<T extends Comparable<T>> extends SetBuilder<T> {\n-            private final ClassDesc classDesc;\n+        static <T extends Enum<T>> BiConsumer<CodeBuilder, T> getEnumLoader(ClassDesc enumClassDesc) {\n+            return (cob, element) -> cob.getstatic(enumClassDesc, element.name(), enumClassDesc);\n+        }\n@@ -1801,5 +1807,24 @@\n-            EnumSetBuilder(Set<T> modifiers, ClassDesc classDesc,\n-                           int defaultVarIndex,\n-                           IntSupplier nextLocalVar) {\n-                super(modifiers, defaultVarIndex, nextLocalVar);\n-                this.classDesc = classDesc;\n+        static <T extends Comparable<T>> void loadImmutableSet(CodeBuilder cob,\n+                                                               Set<T> elements,\n+                                                               BiConsumer<CodeBuilder, T> elementLoader) {\n+            if (elements.size() <= 10) {\n+                \/\/ call Set.of(e1, e2, ...)\n+                for (T t : sorted(elements)) {\n+                    elementLoader.accept(cob, t);\n+                }\n+                var mtdArgs = new ClassDesc[elements.size()];\n+                Arrays.fill(mtdArgs, CD_Object);\n+                cob.invokestatic(CD_Set, \"of\", MethodTypeDesc.of(CD_Set, mtdArgs), true);\n+            } else {\n+                \/\/ call Set.of(E... elements)\n+                cob.loadConstant(elements.size())\n+                   .anewarray(CD_String);\n+                int arrayIndex = 0;\n+                for (T t : sorted(elements)) {\n+                    cob.dup()    \/\/ arrayref\n+                       .loadConstant(arrayIndex);\n+                    elementLoader.accept(cob, t);  \/\/ value\n+                    cob.aastore();\n+                    arrayIndex++;\n+                }\n+                cob.invokestatic(CD_Set, \"of\", MTD_Set_ObjectArray, true);\n@@ -1807,0 +1832,1 @@\n+        }\n@@ -1808,7 +1834,12 @@\n-            \/**\n-             * Loads an Enum field.\n-             *\/\n-            @Override\n-            void visitElement(T t, CodeBuilder cob) {\n-                cob.getstatic(classDesc, t.toString(), classDesc);\n-            }\n+        static <T extends Comparable<T>> void genImmutableSetProvider(ClassBuilder clb,\n+                                                                      String methodName,\n+                                                                      Set<T> elements,\n+                                                                      BiConsumer<CodeBuilder, T> elementLoader) {\n+            clb.withMethodBody(\n+                methodName,\n+                MethodTypeDesc.of(CD_Set),\n+                ACC_STATIC,\n+                cob -> {\n+                    loadImmutableSet(cob, elements, elementLoader);\n+                    cob.areturn();\n+                });\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/SystemModulesPlugin.java","additions":287,"deletions":256,"binary":false,"changes":543,"status":"modified"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.StringJoiner;\n+import java.util.spi.ToolProvider;\n+\n+import tests.JImageGenerator;\n+\n+\/*\n+ * @test\n+ * @summary Make sure that 4000 packages in a uber jar can be linked using jlink.\n+ * @bug 8321413\n+ * @library ..\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jmod\n+ *          jdk.jlink\/jdk.tools.jimage\n+ *          jdk.compiler\n+ * @build tests.*\n+ * @run main\/othervm -Xmx1g -Xlog:init=debug -XX:+UnlockDiagnosticVMOptions -XX:+BytecodeVerificationLocal JLink3500Packages\n+ *\/\n+public class JLink3500Packages {\n+    private static final ToolProvider JAVAC_TOOL = ToolProvider.findFirst(\"javac\")\n+            .orElseThrow(() -> new RuntimeException(\"javac tool not found\"));\n+\n+    static void report(String command, String[] args) {\n+        System.out.println(command + \" \" + String.join(\" \", Arrays.asList(args)));\n+    }\n+\n+    static void javac(String[] args) {\n+        report(\"javac\", args);\n+        JAVAC_TOOL.run(System.out, System.err, args);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Path src = Paths.get(\"bug8321413\");\n+        Path mainModulePath = src.resolve(\"bug8321413x\");\n+\n+        StringJoiner mainModuleInfoContent = new StringJoiner(\";\\n  exports \", \"module bug8321413x {\\n  exports \", \";\\n}\");\n+\n+        for (int i = 0; i < 3500; i++) {\n+            String packageName = \"p\" + i;\n+            String className = \"C\" + i;\n+\n+            Path packagePath = Files.createDirectories(mainModulePath.resolve(packageName));\n+\n+            StringBuilder classContent = new StringBuilder(\"package \");\n+            classContent.append(packageName).append(\";\\n\");\n+            classContent.append(\"class \").append(className).append(\" {}\\n\");\n+            Files.writeString(packagePath.resolve(className + \".java\"), classContent.toString());\n+\n+            mainModuleInfoContent.add(packageName);\n+        }\n+\n+        \/\/ create module reading the generated modules\n+        Path mainModuleInfo = mainModulePath.resolve(\"module-info.java\");\n+        Files.writeString(mainModuleInfo, mainModuleInfoContent.toString());\n+\n+        Path mainClassDir = mainModulePath.resolve(\"testpackage\");\n+        Files.createDirectories(mainClassDir);\n+\n+        Files.writeString(mainClassDir.resolve(\"JLink3500PackagesTest.java\"), \"\"\"\n+                package testpackage;\n+\n+                public class JLink3500PackagesTest {\n+                    public static void main(String[] args) throws Exception {\n+                        System.out.println(\"JLink3500PackagesTest started.\");\n+                    }\n+                }\n+                \"\"\");\n+\n+        String out = src.resolve(\"out\").toString();\n+        javac(new String[]{\n+                \"-d\", out,\n+                \"--module-source-path\", src.toString(),\n+                \"--module\", \"bug8321413x\"\n+        });\n+\n+        JImageGenerator.getJLinkTask()\n+                .modulePath(out)\n+                .output(src.resolve(\"out-jlink\"))\n+                .addMods(\"bug8321413x\")\n+                .call()\n+                .assertSuccess();\n+\n+        Path binDir = src.resolve(\"out-jlink\").resolve(\"bin\").toAbsolutePath();\n+        Path bin = binDir.resolve(\"java\");\n+\n+        ProcessBuilder processBuilder = new ProcessBuilder(bin.toString(),\n+                \"-XX:+UnlockDiagnosticVMOptions\",\n+                \"-XX:+BytecodeVerificationLocal\",\n+                \"-m\", \"bug8321413x\/testpackage.JLink3500PackagesTest\");\n+        processBuilder.inheritIO();\n+        processBuilder.directory(binDir.toFile());\n+        Process process = processBuilder.start();\n+        int exitCode = process.waitFor();\n+        if (exitCode != 0)\n+             throw new AssertionError(\"JLink3500PackagesTest failed to launch\");\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/JLink3500Packages.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"}]}