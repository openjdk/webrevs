{"files":[{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.constant.ConstantDesc;\n@@ -63,1 +62,2 @@\n-import java.util.function.IntSupplier;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n@@ -548,3 +548,1 @@\n-        private final int DEDUP_LIST_VAR = 2;\n-        private final int BUILDER_VAR    = 3;\n-        private int nextLocalVar         = 4;  \/\/ index to next local variable\n+        private final int BUILDER_VAR    = 2;\n@@ -560,0 +558,2 @@\n+        private final ArrayList<Consumer<ClassBuilder>> amendments = new ArrayList<>();\n+\n@@ -563,2 +563,1 @@\n-        private final DedupSetBuilder dedupSetBuilder\n-            = new DedupSetBuilder(this::getNextLocalVar);\n+        private final DedupSetBuilder dedupSetBuilder;\n@@ -572,0 +571,1 @@\n+            this.dedupSetBuilder = new DedupSetBuilder(this.classDesc);\n@@ -575,4 +575,0 @@\n-        private int getNextLocalVar() {\n-            return nextLocalVar++;\n-        }\n-\n@@ -619,0 +615,3 @@\n+                        \/\/ generate dedup set fields and provider methods\n+                        genConstants(clb);\n+\n@@ -639,0 +638,3 @@\n+\n+                        \/\/ generate module helpers\n+                        amendments.forEach(amendment -> amendment.accept(clb));\n@@ -642,0 +644,4 @@\n+        private void addModuleHelpers(Consumer<ClassBuilder> amendment) {\n+            amendments.add(amendment);\n+        }\n+\n@@ -657,0 +663,14 @@\n+        private void genConstants(ClassBuilder clb) {\n+            var clinitSnippets = dedupSetBuilder.buildConstants(clb);\n+            if (!clinitSnippets.isEmpty()) {\n+                clb.withMethodBody(\n+                        CLASS_INIT_NAME,\n+                        MTD_void,\n+                        ACC_STATIC,\n+                        cob -> {\n+                            clinitSnippets.forEach(snippet -> snippet.accept(cob));\n+                            cob.return_();\n+                        });\n+            }\n+        }\n+\n@@ -726,23 +746,1 @@\n-            \/\/ and so on.  During the construction of the module descriptors, the string sets and\n-            \/\/ modifier sets are deduplicated (see SystemModulesClassGenerator.DedupSetBuilder)\n-            \/\/ and cached in the locals. These locals are saved in an array list so\n-            \/\/ that the helper method can restore the local variables that may be\n-            \/\/ referenced by the bytecode generated for creating module descriptors.\n-            \/\/ Pseudo code looks like this:\n-            \/\/\n-            \/\/ void subi(ModuleDescriptor[] mdescs, ArrayList<Object> localvars) {\n-            \/\/      \/\/ assign localvars to local variables\n-            \/\/      var l3 = localvars.get(0);\n-            \/\/      var l4 = localvars.get(1);\n-            \/\/        :\n-            \/\/      \/\/ fill mdescs[i] to mdescs[i+n-1]\n-            \/\/      mdescs[i] = ...\n-            \/\/      mdescs[i+1] = ...\n-            \/\/        :\n-            \/\/      \/\/ save new local variables added\n-            \/\/      localvars.add(lx)\n-            \/\/      localvars.add(l{x+1})\n-            \/\/        :\n-            \/\/      sub{i+i}(mdescs, localvars);\n-            \/\/ }\n-\n+            \/\/ and so on.\n@@ -760,1 +758,0 @@\n-            ClassDesc arrayListClassDesc = ClassDesc.ofInternalName(\"java\/util\/ArrayList\");\n@@ -771,5 +768,0 @@\n-                        cob.new_(arrayListClassDesc)\n-                           .dup()\n-                           .loadConstant(moduleInfos.size())\n-                           .invokespecial(arrayListClassDesc, INIT_NAME, MethodTypeDesc.of(CD_void, CD_int))\n-                           .astore(DEDUP_LIST_VAR);\n@@ -778,1 +770,0 @@\n-                           .aload(DEDUP_LIST_VAR)\n@@ -782,1 +773,1 @@\n-                                   MethodTypeDesc.of(CD_void, CD_MODULE_DESCRIPTOR.arrayType(), arrayListClassDesc)\n+                                   MethodTypeDesc.of(CD_void, CD_MODULE_DESCRIPTOR.arrayType())\n@@ -787,1 +778,0 @@\n-            int dedupVarStart = nextLocalVar;\n@@ -791,1 +781,0 @@\n-                int curDedupVar = nextLocalVar;\n@@ -794,1 +783,1 @@\n-                        MethodTypeDesc.of(CD_void, CD_MODULE_DESCRIPTOR.arrayType(), arrayListClassDesc),\n+                        MethodTypeDesc.of(CD_void, CD_MODULE_DESCRIPTOR.arrayType()),\n@@ -797,9 +786,0 @@\n-                            if (curDedupVar > dedupVarStart) {\n-                                for (int i = dedupVarStart; i < curDedupVar; i++) {\n-                                    cob.aload(DEDUP_LIST_VAR)\n-                                       .loadConstant(i - dedupVarStart)\n-                                       .invokevirtual(arrayListClassDesc, \"get\", MethodTypeDesc.of(CD_Object, CD_int))\n-                                       .astore(i);\n-                                }\n-                            }\n-\n@@ -816,8 +796,0 @@\n-                                if (nextLocalVar > curDedupVar) {\n-                                    for (int i = curDedupVar; i < nextLocalVar; i++) {\n-                                        cob.aload(DEDUP_LIST_VAR)\n-                                           .aload(i)\n-                                           .invokevirtual(arrayListClassDesc, \"add\", MethodTypeDesc.of(CD_boolean, CD_Object))\n-                                           .pop();\n-                                    }\n-                                }\n@@ -826,1 +798,0 @@\n-                                   .aload(DEDUP_LIST_VAR)\n@@ -830,1 +801,1 @@\n-                                           MethodTypeDesc.of(CD_void, CD_MODULE_DESCRIPTOR.arrayType(), arrayListClassDesc)\n+                                           MethodTypeDesc.of(CD_void, CD_MODULE_DESCRIPTOR.arrayType())\n@@ -1044,30 +1015,1 @@\n-            int size = set.size();\n-\n-            \/\/ use Set.of(Object[]) when there are more than 2 elements\n-            \/\/ use Set.of(Object) or Set.of(Object, Object) when fewer\n-            if (size > 2) {\n-                cob.loadConstant(size)\n-                   .anewarray(CD_String);\n-                int i = 0;\n-                for (String element : sorted(set)) {\n-                    cob.dup()\n-                       .loadConstant(i)\n-                       .loadConstant(element)\n-                       .aastore();\n-                    i++;\n-                }\n-                cob.invokestatic(CD_Set,\n-                                 \"of\",\n-                                 MTD_Set_ObjectArray,\n-                                 true);\n-            } else {\n-                for (String element : sorted(set)) {\n-                    cob.loadConstant(element);\n-                }\n-                var mtdArgs = new ClassDesc[size];\n-                Arrays.fill(mtdArgs, CD_Object);\n-                cob.invokestatic(CD_Set,\n-                                 \"of\",\n-                                 MethodTypeDesc.of(CD_Set, mtdArgs),\n-                                 true);\n-            }\n+            loadImmutableSet(cob, set, CodeBuilder::loadConstant);\n@@ -1120,0 +1062,2 @@\n+            static final int SET_SIZE_THRESHOLD = 512; \/\/ An arbitrary number as this likely generate minimum ~4K code\n+\n@@ -1247,3 +1191,2 @@\n-                int varIndex = dedupSetBuilder.indexOfRequiresModifiers(cob, mods);\n-                cob.aload(varIndex)\n-                   .loadConstant(name);\n+                dedupSetBuilder.loadRequiresModifiers(cob, mods);\n+                cob.loadConstant(name);\n@@ -1269,3 +1212,28 @@\n-                cob.aload(BUILDER_VAR)\n-                   .loadConstant(exports.size())\n-                   .anewarray(CD_EXPORTS);\n+                cob.aload(BUILDER_VAR);\n+                loadExportsArray(exports);\n+                cob.invokevirtual(CD_MODULE_BUILDER,\n+                        \"exports\",\n+                        MTD_EXPORTS_ARRAY)\n+                        .pop();\n+            }\n+\n+            void loadExportsArray(Set<Exports> exports) {\n+                if (exports.size() > SET_SIZE_THRESHOLD) {\n+                    String methodName = \"module\" + index + \"Exports\";\n+                    addModuleHelpers(clb -> clb.withMethodBody(\n+                            methodName,\n+                            MethodTypeDesc.of(CD_EXPORTS.arrayType()),\n+                            ACC_STATIC,\n+                            mcob -> {\n+                                genExportSet(mcob, exports);\n+                                mcob.areturn();\n+                            }));\n+                    cob.invokestatic(classDesc, methodName, MethodTypeDesc.of(CD_EXPORTS.arrayType()));\n+                } else {\n+                    genExportSet(cob, exports);\n+                }\n+            }\n+\n+            void genExportSet(CodeBuilder cb, Set<Exports> exports) {\n+                cb.loadConstant(exports.size())\n+                  .anewarray(CD_EXPORTS);\n@@ -1273,0 +1241,1 @@\n+\n@@ -1274,4 +1243,4 @@\n-                    cob.dup()    \/\/ arrayref\n-                       .loadConstant(arrayIndex++);\n-                    newExports(export.modifiers(), export.source(), export.targets());\n-                    cob.aastore();\n+                    cb.dup() \/\/ arrayref\n+                      .loadConstant(arrayIndex++);\n+                    newExports(cb, export.modifiers(), export.source(), export.targets());\n+                    cb.aastore();\n@@ -1279,4 +1248,0 @@\n-                cob.invokevirtual(CD_MODULE_BUILDER,\n-                                  \"exports\",\n-                                  MTD_EXPORTS_ARRAY)\n-                    .pop();\n@@ -1300,2 +1265,3 @@\n-            void newExports(Set<Exports.Modifier> ms, String pn, Set<String> targets) {\n-                int modifiersSetIndex = dedupSetBuilder.indexOfExportsModifiers(cob, ms);\n+            void newExports(CodeBuilder cb, Set<Exports.Modifier> ms, String pn, Set<String> targets) {\n+                dedupSetBuilder.loadExportsModifiers(cb, ms);\n+                cb.loadConstant(pn);\n@@ -1303,7 +1269,4 @@\n-                    int stringSetIndex = dedupSetBuilder.indexOfStringSet(cob, targets);\n-                    cob.aload(modifiersSetIndex)\n-                       .loadConstant(pn)\n-                       .aload(stringSetIndex)\n-                       .invokestatic(CD_MODULE_BUILDER,\n-                                     \"newExports\",\n-                                     MTD_EXPORTS_MODIFIER_SET_STRING_SET);\n+                    dedupSetBuilder.loadStringSet(cb, targets);\n+                    cb.invokestatic(CD_MODULE_BUILDER,\n+                                    \"newExports\",\n+                                    MTD_EXPORTS_MODIFIER_SET_STRING_SET);\n@@ -1311,3 +1274,1 @@\n-                    cob.aload(modifiersSetIndex)\n-                       .loadConstant(pn)\n-                       .invokestatic(CD_MODULE_BUILDER,\n+                    cb.invokestatic(CD_MODULE_BUILDER,\n@@ -1358,1 +1319,2 @@\n-                int modifiersSetIndex = dedupSetBuilder.indexOfOpensModifiers(cob, ms);\n+                dedupSetBuilder.loadOpensModifiers(cob, ms);\n+                cob.loadConstant(pn);\n@@ -1360,5 +1322,2 @@\n-                    int stringSetIndex = dedupSetBuilder.indexOfStringSet(cob, targets);\n-                    cob.aload(modifiersSetIndex)\n-                       .loadConstant(pn)\n-                       .aload(stringSetIndex)\n-                       .invokestatic(CD_MODULE_BUILDER,\n+                    dedupSetBuilder.loadStringSet(cob, targets);\n+                    cob.invokestatic(CD_MODULE_BUILDER,\n@@ -1368,3 +1327,1 @@\n-                    cob.aload(modifiersSetIndex)\n-                       .loadConstant(pn)\n-                       .invokestatic(CD_MODULE_BUILDER,\n+                    cob.invokestatic(CD_MODULE_BUILDER,\n@@ -1380,4 +1337,3 @@\n-                int varIndex = dedupSetBuilder.indexOfStringSet(cob, uses);\n-                cob.aload(BUILDER_VAR)\n-                   .aload(varIndex)\n-                   .invokevirtual(CD_MODULE_BUILDER,\n+                cob.aload(BUILDER_VAR);\n+                dedupSetBuilder.loadStringSet(cob, uses);\n+                cob.invokevirtual(CD_MODULE_BUILDER,\n@@ -1445,4 +1401,18 @@\n-                int varIndex = dedupSetBuilder.newStringSet(cob, packages);\n-                cob.aload(BUILDER_VAR)\n-                   .aload(varIndex)\n-                   .invokevirtual(CD_MODULE_BUILDER,\n+                cob.aload(BUILDER_VAR);\n+                if (packages.size() > SET_SIZE_THRESHOLD) {\n+                    var methodName = \"module\" + index + \"Packages\";\n+                    addModuleHelpers(clb -> {\n+                            clb.withMethodBody(\n+                                methodName,\n+                                MethodTypeDesc.of(CD_Set),\n+                                ACC_STATIC,\n+                                cob -> {\n+                                    genImmutableSet(cob, packages);\n+                                    cob.areturn();\n+                                });\n+                            });\n+                    cob.invokestatic(classDesc, methodName, MethodTypeDesc.of(CD_Set));\n+                } else {\n+                    genImmutableSet(cob, packages);\n+                }\n+                cob.invokevirtual(CD_MODULE_BUILDER,\n@@ -1586,1 +1556,1 @@\n-            final Map<Set<String>, SetBuilder<String>> stringSets = new HashMap<>();\n+            final Map<Set<String>, SetReference<String>> stringSets = new HashMap<>();\n@@ -1590,1 +1560,1 @@\n-            final Map<Set<Requires.Modifier>, EnumSetBuilder<Requires.Modifier>>\n+            final Map<Set<Requires.Modifier>, SetReference<Requires.Modifier>>\n@@ -1595,1 +1565,1 @@\n-            final Map<Set<Exports.Modifier>, EnumSetBuilder<Exports.Modifier>>\n+            final Map<Set<Exports.Modifier>, SetReference<Exports.Modifier>>\n@@ -1600,1 +1570,1 @@\n-            final Map<Set<Opens.Modifier>, EnumSetBuilder<Opens.Modifier>>\n+            final Map<Set<Opens.Modifier>, SetReference<Opens.Modifier>>\n@@ -1603,3 +1573,8 @@\n-            private final int stringSetVar;\n-            private final int enumSetVar;\n-            private final IntSupplier localVarSupplier;\n+            private static final String VALUES_ARRAY = \"dedupSetValues\";\n+\n+            final ClassDesc owner;\n+            int countOfStoredValues = 0;\n+\n+            DedupSetBuilder(ClassDesc owner) {\n+                this.owner = owner;\n+            }\n@@ -1607,4 +1582,2 @@\n-            DedupSetBuilder(IntSupplier localVarSupplier) {\n-                this.stringSetVar = localVarSupplier.getAsInt();\n-                this.enumSetVar = localVarSupplier.getAsInt();\n-                this.localVarSupplier = localVarSupplier;\n+            int requestValueStorage() {\n+                return countOfStoredValues++;\n@@ -1618,1 +1591,1 @@\n-                    s -> new SetBuilder<>(s, stringSetVar, localVarSupplier)\n+                    s -> new SetReference<>(s, CodeBuilder::loadConstant)\n@@ -1627,2 +1600,1 @@\n-                                new EnumSetBuilder<>(s, CD_EXPORTS_MODIFIER,\n-                                        enumSetVar, localVarSupplier)\n+                        new SetReference<>(s, getEnumLoader(CD_EXPORTS_MODIFIER))\n@@ -1637,2 +1609,1 @@\n-                                new EnumSetBuilder<>(s, CD_OPENS_MODIFIER,\n-                                        enumSetVar, localVarSupplier)\n+                        new SetReference<>(s, getEnumLoader(CD_OPENS_MODIFIER))\n@@ -1647,2 +1618,1 @@\n-                    new EnumSetBuilder<>(s, CD_REQUIRES_MODIFIER,\n-                                         enumSetVar, localVarSupplier)\n+                        new SetReference<>(s, getEnumLoader(CD_REQUIRES_MODIFIER))\n@@ -1653,2 +1623,1 @@\n-             * Retrieve the index to the given set of Strings. Emit code to\n-             * generate it when SetBuilder::build is called.\n+             * Load the given set to the top of operand stack.\n@@ -1656,2 +1625,2 @@\n-            int indexOfStringSet(CodeBuilder cob, Set<String> names) {\n-                return stringSets.get(names).build(cob);\n+            void loadStringSet(CodeBuilder cob, Set<String> names) {\n+                stringSets.get(names).load(cob);\n@@ -1661,2 +1630,1 @@\n-             * Retrieve the index to the given set of Exports.Modifier.\n-             * Emit code to generate it when EnumSetBuilder::build is called.\n+             * Load the given set to the top of operand stack.\n@@ -1664,2 +1632,2 @@\n-            int indexOfExportsModifiers(CodeBuilder cob, Set<Exports.Modifier> mods) {\n-                return exportsModifiersSets.get(mods).build(cob);\n+            void loadExportsModifiers(CodeBuilder cob, Set<Exports.Modifier> mods) {\n+                exportsModifiersSets.get(mods).load(cob);\n@@ -1668,3 +1636,2 @@\n-            \/**\n-             * Retrieve the index to the given set of Opens.Modifier.\n-             * Emit code to generate it when EnumSetBuilder::build is called.\n+            \/*\n+             * Load the given set to the top of operand stack.\n@@ -1672,2 +1639,2 @@\n-            int indexOfOpensModifiers(CodeBuilder cob, Set<Opens.Modifier> mods) {\n-                return opensModifiersSets.get(mods).build(cob);\n+            void loadOpensModifiers(CodeBuilder cob, Set<Opens.Modifier> mods) {\n+                opensModifiersSets.get(mods).load(cob);\n@@ -1678,2 +1645,1 @@\n-             * Retrieve the index to the given set of Requires.Modifier.\n-             * Emit code to generate it when EnumSetBuilder::build is called.\n+             * Load the given set to the top of operand stack.\n@@ -1681,2 +1647,2 @@\n-            int indexOfRequiresModifiers(CodeBuilder cob, Set<Requires.Modifier> mods) {\n-                return requiresModifiersSets.get(mods).build(cob);\n+            void loadRequiresModifiers(CodeBuilder cob, Set<Requires.Modifier> mods) {\n+                requiresModifiersSets.get(mods).load(cob);\n@@ -1686,1 +1652,3 @@\n-             * Build a new string set without any attempt to deduplicate it.\n+             * Adding provider methods to the class. For those set used more than once, built\n+             * once and keep the reference for later access.\n+             * Return a list of snippet to be used in <clinit>.\n@@ -1688,31 +1656,20 @@\n-            int newStringSet(CodeBuilder cob, Set<String> names) {\n-                int index = new SetBuilder<>(names, stringSetVar, localVarSupplier).build(cob);\n-                assert index == stringSetVar;\n-                return index;\n-            }\n-        }\n-\n-        \/*\n-         * SetBuilder generates bytecode to create one single instance of Set\n-         * for a given set of elements and assign to a local variable slot.\n-         * When there is only one single reference to a Set<T>,\n-         * it will reuse defaultVarIndex.  For a Set with multiple references,\n-         * it will use a new local variable retrieved from the nextLocalVar\n-         *\/\n-        static class SetBuilder<T extends Comparable<T>> {\n-            private static final MethodTypeDesc MTD_Set_ObjectArray = MethodTypeDesc.of(\n-                    CD_Set, CD_Object.arrayType());\n-\n-            private final Set<T> elements;\n-            private final int defaultVarIndex;\n-            private final IntSupplier nextLocalVar;\n-            private int refCount;\n-            private int localVarIndex;\n-\n-            SetBuilder(Set<T> elements,\n-                       int defaultVarIndex,\n-                       IntSupplier nextLocalVar) {\n-                this.elements = elements;\n-                this.defaultVarIndex = defaultVarIndex;\n-                this.nextLocalVar = nextLocalVar;\n-            }\n+            Collection<Consumer<CodeBuilder>> buildConstants(ClassBuilder clb) {\n+                var index = 0;\n+                ArrayList<Consumer<CodeBuilder>> setValueBuilders = new ArrayList<>();\n+                \/\/ The SetReferences need to be sorted to reproduce same result.\n+                for (var ref : sorted(stringSets.values())) {\n+                    index++;\n+                    ref.generateConstant(clb, \"dedupStringSet\" + index).ifPresent(setValueBuilders::add);\n+                }\n+                for (var ref: sorted(opensModifiersSets.values())) {\n+                    index++;\n+                    ref.generateConstant(clb, \"dedupOpensSet\" + index).ifPresent(setValueBuilders::add);\n+                }\n+                for (var ref: sorted(exportsModifiersSets.values())) {\n+                    index++;\n+                    ref.generateConstant(clb, \"dedupExportsSet\" + index).ifPresent(setValueBuilders::add);\n+                }\n+                for (var ref: sorted(requiresModifiersSets.values())) {\n+                    index++;\n+                    ref.generateConstant(clb, \"dedupRequiresSet\" + index).ifPresent(setValueBuilders::add);\n+                }\n@@ -1720,5 +1677,10 @@\n-            \/*\n-             * Increments the number of references to this particular set.\n-             *\/\n-            final void increment() {\n-                refCount++;\n+                if (countOfStoredValues > 0) {\n+                    assert setValueBuilders.size() == countOfStoredValues;\n+                    clb.withField(VALUES_ARRAY, CD_Set.arrayType(), ACC_STATIC | ACC_FINAL);\n+                    \/\/ Allocate array before assign values\n+                    setValueBuilders.addFirst(cob ->\n+                            cob.loadConstant(countOfStoredValues)\n+                               .anewarray(CD_Set)\n+                               .putstatic(owner, VALUES_ARRAY, CD_Set.arrayType()));\n+                }\n+                return setValueBuilders;\n@@ -1727,6 +1689,2 @@\n-            \/**\n-             * Generate the appropriate instructions to load an object reference\n-             * to the element onto the stack.\n-             *\/\n-            void visitElement(T element, CodeBuilder cob) {\n-                cob.loadConstant((ConstantDesc)element);\n+            void loadValuesArray(CodeBuilder cob) {\n+                cob.getstatic(owner, VALUES_ARRAY, CD_Set.arrayType());\n@@ -1736,3 +1694,6 @@\n-             * Build bytecode for the Set represented by this builder,\n-             * or get the local variable index of a previously generated set\n-             * (in the local scope).\n+             * SetReference count references to the set, and use a CodeBuilder that\n+             * generate bytecode to load an element onto the operand stack to generate bytecode\n+             * to support loading the set onto operand stack.\n+             *\n+             * When a set size is over SET_SIZE_THRESHOLD, a provider function is generated\n+             * to build the set rather than inline to avoid method size overflow.\n@@ -1740,1 +1701,5 @@\n-             * @return local variable index of the generated set.\n+             * When a set is referenced more than once, the set value is to be built once\n+             * and cached in an array to be load later.\n+             *\n+             * generateConstant method should be called to setup the provider methods and cache array.\n+             * load method can then be called to load the set onto the operand stack.\n@@ -1742,9 +1707,25 @@\n-            final int build(CodeBuilder cob) {\n-                int index = localVarIndex;\n-                if (localVarIndex == 0) {\n-                    \/\/ if non-empty and more than one set reference this builder,\n-                    \/\/ emit to a unique local\n-                    index = refCount <= 1 ? defaultVarIndex\n-                                          : nextLocalVar.getAsInt();\n-                    if (index < MAX_LOCAL_VARS) {\n-                        localVarIndex = index;\n+            class SetReference<T extends Comparable<T>> implements Comparable<SetReference<T>> {\n+                private final Set<T> elements;\n+                private final BiConsumer<CodeBuilder, T> elementLoader;\n+\n+                private int refCount;\n+                private int index = -1;\n+                private String methodName;\n+\n+                SetReference(Set<T> elements, BiConsumer<CodeBuilder, T> elementLoader) {\n+                    this.elements = elements;\n+                    this.elementLoader = elementLoader;\n+                }\n+\n+                int increment() {\n+                    return ++refCount;\n+                }\n+\n+\n+                \/\/ Load the set to the operand stack\n+                void load(CodeBuilder cob) {\n+                    if (refCount > 1) {\n+                        assert index >= 0;\n+                        loadValuesArray(cob);\n+                        cob.loadConstant(index);\n+                        cob.aaload();\n@@ -1752,2 +1733,1 @@\n-                        \/\/ overflow: disable optimization by using localVarIndex = 0\n-                        index = defaultVarIndex;\n+                        build(cob);\n@@ -1755,0 +1735,1 @@\n+                }\n@@ -1756,1 +1737,7 @@\n-                    generateSetOf(cob, index);\n+                \/\/ Build the set value and store the reference\n+                void store(CodeBuilder cob) {\n+                    assert index >= 0;\n+                    loadValuesArray(cob);\n+                    cob.loadConstant(index);\n+                    build(cob);\n+                    cob.aastore();\n@@ -1758,2 +1745,0 @@\n-                return index;\n-            }\n@@ -1761,5 +1746,6 @@\n-            private void generateSetOf(CodeBuilder cob, int index) {\n-                if (elements.size() <= 10) {\n-                    \/\/ call Set.of(e1, e2, ...)\n-                    for (T t : sorted(elements)) {\n-                        visitElement(t, cob);\n+                \/\/ build the set and leave the reference at top of the operand stack\n+                private void build(CodeBuilder cob) {\n+                    if (methodName != null) {\n+                        cob.invokestatic(owner, methodName, MethodTypeDesc.of(CD_Set));\n+                    } else {\n+                        loadImmutableSet(cob, elements, elementLoader);\n@@ -1767,17 +1753,38 @@\n-                    var mtdArgs = new ClassDesc[elements.size()];\n-                    Arrays.fill(mtdArgs, CD_Object);\n-                    cob.invokestatic(CD_Set,\n-                                     \"of\",\n-                                     MethodTypeDesc.of(CD_Set, mtdArgs),\n-                                     true);\n-                } else {\n-                    \/\/ call Set.of(E... elements)\n-                    cob.loadConstant(elements.size())\n-                       .anewarray(CD_String);\n-                    int arrayIndex = 0;\n-                    for (T t : sorted(elements)) {\n-                        cob.dup()    \/\/ arrayref\n-                           .loadConstant(arrayIndex);\n-                        visitElement(t, cob);  \/\/ value\n-                        cob.aastore();\n-                        arrayIndex++;\n+                }\n+\n+                \/**\n+                 * Generate provider method if the set size is over threshold to avoid overload\n+                 * bytecode limitation per method.\n+                 * Return a snippet builder that generates code to store the reference of the set value.\n+                 *\/\n+                Optional<Consumer<CodeBuilder>> generateConstant(ClassBuilder clb, String name) {\n+                    if (elements.size() > ModuleDescriptorBuilder.SET_SIZE_THRESHOLD) {\n+                        methodName = name + \"Provider\";\n+                        genImmutableSetProvider(clb, methodName, elements, elementLoader);\n+                    }\n+\n+                    if (refCount <= 1) {\n+                        return Optional.empty();\n+                    } else {\n+                        index = requestValueStorage();\n+                        return Optional.of(this::store);\n+                    }\n+                }\n+\n+                @Override\n+                public int compareTo(SetReference<T> o) {\n+                    if (o == this) {\n+                        return 0;\n+                    }\n+                    if (elements.size() == o.elements.size()) {\n+                        var a1 = sorted(elements);\n+                        var a2 = sorted(o.elements);\n+                        for (int i = 0; i < elements.size(); i++) {\n+                            var r = a1.get(i).compareTo(a2.get(i));\n+                            if (r != 0) {\n+                                return r;\n+                            }\n+                        }\n+                        return 0;\n+                    } else {\n+                        return elements.size() - o.elements.size();\n@@ -1785,4 +1792,0 @@\n-                    cob.invokestatic(CD_Set,\n-                                     \"of\",\n-                                     MTD_Set_ObjectArray,\n-                                     true);\n@@ -1790,1 +1793,0 @@\n-                cob.astore(index);\n@@ -1794,6 +1796,3 @@\n-        \/*\n-         * Generates bytecode to create one single instance of EnumSet\n-         * for a given set of modifiers and assign to a local variable slot.\n-         *\/\n-        static class EnumSetBuilder<T extends Comparable<T>> extends SetBuilder<T> {\n-            private final ClassDesc classDesc;\n+        static <T extends Enum<T>> BiConsumer<CodeBuilder, T> getEnumLoader(ClassDesc enumClassDesc) {\n+            return (cob, element) -> cob.getstatic(enumClassDesc, element.name(), enumClassDesc);\n+        }\n@@ -1801,5 +1800,24 @@\n-            EnumSetBuilder(Set<T> modifiers, ClassDesc classDesc,\n-                           int defaultVarIndex,\n-                           IntSupplier nextLocalVar) {\n-                super(modifiers, defaultVarIndex, nextLocalVar);\n-                this.classDesc = classDesc;\n+        static <T extends Comparable<T>> void loadImmutableSet(CodeBuilder cob,\n+                                                               Set<T> elements,\n+                                                               BiConsumer<CodeBuilder, T> elementLoader) {\n+            if (elements.size() <= 10) {\n+                \/\/ call Set.of(e1, e2, ...)\n+                for (T t : sorted(elements)) {\n+                    elementLoader.accept(cob, t);\n+                }\n+                var mtdArgs = new ClassDesc[elements.size()];\n+                Arrays.fill(mtdArgs, CD_Object);\n+                cob.invokestatic(CD_Set, \"of\", MethodTypeDesc.of(CD_Set, mtdArgs), true);\n+            } else {\n+                \/\/ call Set.of(E... elements)\n+                cob.loadConstant(elements.size())\n+                   .anewarray(CD_String);\n+                int arrayIndex = 0;\n+                for (T t : sorted(elements)) {\n+                    cob.dup()    \/\/ arrayref\n+                       .loadConstant(arrayIndex);\n+                    elementLoader.accept(cob, t);  \/\/ value\n+                    cob.aastore();\n+                    arrayIndex++;\n+                }\n+                cob.invokestatic(CD_Set, \"of\", MTD_Set_ObjectArray, true);\n@@ -1807,0 +1825,1 @@\n+        }\n@@ -1808,7 +1827,12 @@\n-            \/**\n-             * Loads an Enum field.\n-             *\/\n-            @Override\n-            void visitElement(T t, CodeBuilder cob) {\n-                cob.getstatic(classDesc, t.toString(), classDesc);\n-            }\n+        static <T extends Comparable<T>> void genImmutableSetProvider(ClassBuilder clb,\n+                                                                      String methodName,\n+                                                                      Set<T> elements,\n+                                                                      BiConsumer<CodeBuilder, T> elementLoader) {\n+            clb.withMethodBody(\n+                methodName,\n+                MethodTypeDesc.of(CD_Set),\n+                ACC_STATIC,\n+                cob -> {\n+                    loadImmutableSet(cob, elements, elementLoader);\n+                    cob.areturn();\n+                });\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/SystemModulesPlugin.java","additions":302,"deletions":278,"binary":false,"changes":580,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.StringJoiner;\n+import java.util.spi.ToolProvider;\n+\n+import tests.JImageGenerator;\n+\n+\/*\n+ * @test\n+ * @summary Make sure that ~3500 packages in a uber jar can be linked using jlink. Depends on the\n+ *          packages, this is almost hit the 64K limitation as each plain export could take\n+ *          ~17 bytecodes.\n+ * @bug 8321413\n+ * @library ..\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jmod\n+ *          jdk.jlink\/jdk.tools.jimage\n+ *          jdk.compiler\n+ * @build tests.*\n+ * @run main\/othervm -Xmx1g -Xlog:init=debug -XX:+UnlockDiagnosticVMOptions -XX:+BytecodeVerificationLocal JLink3500Packages\n+ *\/\n+public class JLink3500Packages {\n+    private static final ToolProvider JAVAC_TOOL = ToolProvider.findFirst(\"javac\")\n+            .orElseThrow(() -> new RuntimeException(\"javac tool not found\"));\n+\n+    static void report(String command, String[] args) {\n+        System.out.println(command + \" \" + String.join(\" \", Arrays.asList(args)));\n+    }\n+\n+    static void javac(String[] args) {\n+        report(\"javac\", args);\n+        JAVAC_TOOL.run(System.out, System.err, args);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Path src = Paths.get(\"bug8321413\");\n+        Path mainModulePath = src.resolve(\"bug8321413x\");\n+\n+        StringJoiner mainModuleInfoContent = new StringJoiner(\";\\n  exports \", \"module bug8321413x {\\n  exports \", \";\\n}\");\n+\n+        for (int i = 0; i < 3500; i++) {\n+            String packageName = \"p\" + i;\n+            String className = \"C\" + i;\n+\n+            Path packagePath = Files.createDirectories(mainModulePath.resolve(packageName));\n+\n+            StringBuilder classContent = new StringBuilder(\"package \");\n+            classContent.append(packageName).append(\";\\n\");\n+            classContent.append(\"class \").append(className).append(\" {}\\n\");\n+            Files.writeString(packagePath.resolve(className + \".java\"), classContent.toString());\n+\n+            mainModuleInfoContent.add(packageName);\n+        }\n+\n+        \/\/ create module reading the generated modules\n+        Path mainModuleInfo = mainModulePath.resolve(\"module-info.java\");\n+        Files.writeString(mainModuleInfo, mainModuleInfoContent.toString());\n+\n+        Path mainClassDir = mainModulePath.resolve(\"testpackage\");\n+        Files.createDirectories(mainClassDir);\n+\n+        Files.writeString(mainClassDir.resolve(\"JLink3500PackagesTest.java\"), \"\"\"\n+                package testpackage;\n+\n+                public class JLink3500PackagesTest {\n+                    public static void main(String[] args) throws Exception {\n+                        System.out.println(\"JLink3500PackagesTest started.\");\n+                    }\n+                }\n+                \"\"\");\n+\n+        String out = src.resolve(\"out\").toString();\n+        javac(new String[]{\n+                \"-d\", out,\n+                \"--module-source-path\", src.toString(),\n+                \"--module\", \"bug8321413x\"\n+        });\n+\n+        JImageGenerator.getJLinkTask()\n+                .modulePath(out)\n+                .output(src.resolve(\"out-jlink\"))\n+                .addMods(\"bug8321413x\")\n+                .call()\n+                .assertSuccess();\n+\n+        Path binDir = src.resolve(\"out-jlink\").resolve(\"bin\").toAbsolutePath();\n+        Path bin = binDir.resolve(\"java\");\n+\n+        ProcessBuilder processBuilder = new ProcessBuilder(bin.toString(),\n+                \"-XX:+UnlockDiagnosticVMOptions\",\n+                \"-XX:+BytecodeVerificationLocal\",\n+                \"-m\", \"bug8321413x\/testpackage.JLink3500PackagesTest\");\n+        processBuilder.inheritIO();\n+        processBuilder.directory(binDir.toFile());\n+        Process process = processBuilder.start();\n+        int exitCode = process.waitFor();\n+        if (exitCode != 0)\n+             throw new AssertionError(\"JLink3500PackagesTest failed to launch\");\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/JLink3500Packages.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"}]}