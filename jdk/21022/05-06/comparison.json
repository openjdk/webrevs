{"files":[{"patch":"@@ -27,1 +27,0 @@\n-import java.lang.annotation.Target;\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/Snippets.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,514 @@\n+\/*\n+ * Copyright (c) 2024, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.tools.jlink.internal.plugins;\n+\n+import java.lang.classfile.ClassBuilder;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.constant.ClassDesc;\n+import static java.lang.constant.ConstantDescs.*;\n+\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.module.ModuleDescriptor;\n+import java.lang.module.ModuleDescriptor.Exports;\n+import java.lang.module.ModuleDescriptor.Opens;\n+import java.lang.module.ModuleDescriptor.Provides;\n+import java.lang.module.ModuleDescriptor.Requires;\n+import java.lang.module.ModuleDescriptor.Version;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+\n+import jdk.tools.jlink.internal.Snippets.ElementLoader;\n+import jdk.tools.jlink.internal.Snippets.Loadable;\n+import jdk.tools.jlink.internal.Snippets.LoadableArray;\n+import jdk.tools.jlink.internal.Snippets.LoadableSet;\n+import static jdk.tools.jlink.internal.Snippets.STRING_LOADER;\n+import static jdk.tools.jlink.internal.Snippets.STRING_PAGE_SIZE;\n+\n+import jdk.tools.jlink.internal.plugins.SystemModulesPlugin.ModuleInfo;\n+import jdk.tools.jlink.internal.plugins.SystemModulesPlugin.SystemModulesClassGenerator.DedupSetBuilder;\n+\n+class ModuleInfoLoader implements ElementLoader<ModuleInfo> {\n+    private static final ClassDesc CD_MODULE_DESCRIPTOR =\n+        ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor\");\n+    private static final ClassDesc CD_MODULE_BUILDER =\n+        ClassDesc.ofInternalName(\"jdk\/internal\/module\/Builder\");\n+\n+    private static final int PAGING_THRESHOLD = 512;\n+    private final DedupSetBuilder dedupSetBuilder;\n+    private final ClassDesc ownerClassDesc;\n+\n+    ModuleInfoLoader(DedupSetBuilder dedupSetBuilder, ClassDesc ownerClassDesc) {\n+        this.dedupSetBuilder = dedupSetBuilder;\n+        this.ownerClassDesc = ownerClassDesc;\n+    }\n+\n+    @Override\n+    public void load(CodeBuilder cob, ModuleInfo moduleInfo, int index) {\n+        var mdBuilder = new ModuleDescriptorBuilder(cob, moduleInfo.descriptor(), moduleInfo.packages(), index);\n+        mdBuilder.load();\n+    }\n+\n+    class ModuleDescriptorBuilder {\n+        static final ClassDesc CD_EXPORTS =\n+            ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Exports\");\n+        static final ClassDesc CD_OPENS =\n+            ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Opens\");\n+        static final ClassDesc CD_PROVIDES =\n+            ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Provides\");\n+        static final ClassDesc CD_REQUIRES =\n+            ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Requires\");\n+\n+        \/\/ method signature for static Builder::newExports, newOpens,\n+        \/\/ newProvides, newRequires methods\n+        static final MethodTypeDesc MTD_EXPORTS_MODIFIER_SET_STRING_SET =\n+            MethodTypeDesc.of(CD_EXPORTS, CD_Set, CD_String, CD_Set);\n+        static final MethodTypeDesc MTD_EXPORTS_MODIFIER_SET_STRING =\n+            MethodTypeDesc.of(CD_EXPORTS, CD_Set, CD_String);\n+        static final MethodTypeDesc MTD_OPENS_MODIFIER_SET_STRING_SET =\n+            MethodTypeDesc.of(CD_OPENS, CD_Set, CD_String, CD_Set);\n+        static final MethodTypeDesc MTD_OPENS_MODIFIER_SET_STRING =\n+            MethodTypeDesc.of(CD_OPENS, CD_Set, CD_String);\n+        static final MethodTypeDesc MTD_PROVIDES_STRING_LIST =\n+            MethodTypeDesc.of(CD_PROVIDES, CD_String, CD_List);\n+        static final MethodTypeDesc MTD_REQUIRES_SET_STRING =\n+            MethodTypeDesc.of(CD_REQUIRES, CD_Set, CD_String);\n+        static final MethodTypeDesc MTD_REQUIRES_SET_STRING_STRING =\n+            MethodTypeDesc.of(CD_REQUIRES, CD_Set, CD_String, CD_String);\n+\n+        \/\/ method signature for Builder instance methods that\n+        \/\/ return this Builder instance\n+        static final MethodTypeDesc MTD_EXPORTS_ARRAY =\n+            MethodTypeDesc.of(CD_MODULE_BUILDER, CD_EXPORTS.arrayType());\n+        static final MethodTypeDesc MTD_OPENS_ARRAY =\n+            MethodTypeDesc.of(CD_MODULE_BUILDER, CD_OPENS.arrayType());\n+        static final MethodTypeDesc MTD_PROVIDES_ARRAY =\n+            MethodTypeDesc.of(CD_MODULE_BUILDER, CD_PROVIDES.arrayType());\n+        static final MethodTypeDesc MTD_REQUIRES_ARRAY =\n+            MethodTypeDesc.of(CD_MODULE_BUILDER, CD_REQUIRES.arrayType());\n+        static final MethodTypeDesc MTD_SET = MethodTypeDesc.of(CD_MODULE_BUILDER, CD_Set);\n+        static final MethodTypeDesc MTD_STRING = MethodTypeDesc.of(CD_MODULE_BUILDER, CD_String);\n+        static final MethodTypeDesc MTD_BOOLEAN = MethodTypeDesc.of(CD_MODULE_BUILDER, CD_boolean);\n+        static final MethodTypeDesc MTD_void_String = MethodTypeDesc.of(CD_void, CD_String);\n+        static final MethodTypeDesc MTD_ModuleDescriptor_int = MethodTypeDesc.of(CD_MODULE_DESCRIPTOR, CD_int);\n+        static final MethodTypeDesc MTD_List_ObjectArray = MethodTypeDesc.of(CD_List, CD_Object.arrayType());\n+\n+\n+        final CodeBuilder cob;\n+        final ModuleDescriptor md;\n+        final Set<String> packages;\n+        final int index;\n+        Consumer<ClassBuilder> amendment;\n+\n+        ModuleDescriptorBuilder(CodeBuilder cob, ModuleDescriptor md, Set<String> packages, int index) {\n+            if (md.isAutomatic()) {\n+                throw new InternalError(\"linking automatic module is not supported\");\n+            }\n+            this.cob = cob;\n+            this.md = md;\n+            this.packages = packages;\n+            this.index = index;\n+        }\n+\n+        private void setupLoadable(Loadable loadable) {\n+            if (amendment == null) {\n+                amendment = loadable::setup;\n+            } else {\n+                amendment = amendment.andThen(loadable::setup);\n+            }\n+        }\n+\n+        void setup(ClassBuilder clb) {\n+            amendment.accept(clb);\n+        }\n+\n+        void load() {\n+            \/\/ new jdk.internal.module.Builder\n+            newBuilder();\n+\n+            \/\/ requires\n+            requires(md.requires());\n+\n+            \/\/ exports\n+            exports(md.exports());\n+\n+            \/\/ opens\n+            opens(md.opens());\n+\n+            \/\/ uses\n+            uses(md.uses());\n+\n+            \/\/ provides\n+            provides(md.provides());\n+\n+            \/\/ all packages\n+            packages(packages);\n+\n+            \/\/ version\n+            md.version().ifPresent(this::version);\n+\n+            \/\/ main class\n+            md.mainClass().ifPresent(this::mainClass);\n+\n+            loadModuleDescriptor();\n+        }\n+\n+        void newBuilder() {\n+            cob.new_(CD_MODULE_BUILDER)\n+               .dup()\n+               .loadConstant(md.name())\n+               .invokespecial(CD_MODULE_BUILDER,\n+                              INIT_NAME,\n+                              MTD_void_String);\n+\n+            if (md.isOpen()) {\n+                setModuleBit(\"open\", true);\n+            }\n+            if (md.modifiers().contains(ModuleDescriptor.Modifier.SYNTHETIC)) {\n+                setModuleBit(\"synthetic\", true);\n+            }\n+            if (md.modifiers().contains(ModuleDescriptor.Modifier.MANDATED)) {\n+                setModuleBit(\"mandated\", true);\n+            }\n+        }\n+\n+        \/*\n+         * Invoke Builder.<methodName>(boolean value)\n+         *\/\n+        void setModuleBit(String methodName, boolean value) {\n+            cob.dup()\n+               .loadConstant(value ? 1 : 0)\n+               .invokevirtual(CD_MODULE_BUILDER,\n+                              methodName,\n+                              MTD_BOOLEAN)\n+               .pop();\n+        }\n+\n+        \/*\n+         * Put ModuleDescriptor into the modules array\n+         *\/\n+        void loadModuleDescriptor() {\n+            cob\n+               .loadConstant(md.hashCode())\n+               .invokevirtual(CD_MODULE_BUILDER,\n+                              \"build\",\n+                              MTD_ModuleDescriptor_int);\n+        }\n+\n+        \/*\n+         * Call Builder::newRequires to create Requires instances and\n+         * then pass it to the builder by calling:\n+         *      Builder.requires(Requires[])\n+         *\n+         *\/\n+        void requires(Set<Requires> requires) {\n+            cob.dup()\n+               .loadConstant(requires.size())\n+               .anewarray(CD_REQUIRES);\n+            int arrayIndex = 0;\n+            for (Requires require : sorted(requires)) {\n+                String compiledVersion = null;\n+                if (require.compiledVersion().isPresent()) {\n+                    compiledVersion = require.compiledVersion().get().toString();\n+                }\n+\n+                cob.dup()               \/\/ arrayref\n+                   .loadConstant(arrayIndex++);\n+                newRequires(require.modifiers(), require.name(), compiledVersion);\n+                cob.aastore();\n+            }\n+            cob.invokevirtual(CD_MODULE_BUILDER,\n+                              \"requires\",\n+                              MTD_REQUIRES_ARRAY)\n+                .pop();\n+        }\n+\n+        \/*\n+         * Invoke Builder.newRequires(Set<Modifier> mods, String mn, String compiledVersion)\n+         *\n+         * Set<Modifier> mods = ...\n+         * Builder.newRequires(mods, mn, compiledVersion);\n+         *\/\n+        void newRequires(Set<Requires.Modifier> mods, String name, String compiledVersion) {\n+            dedupSetBuilder.loadRequiresModifiers(cob, mods);\n+            cob.loadConstant(name);\n+            if (compiledVersion != null) {\n+                cob.loadConstant(compiledVersion)\n+                   .invokestatic(CD_MODULE_BUILDER,\n+                                 \"newRequires\",\n+                                 MTD_REQUIRES_SET_STRING_STRING);\n+            } else {\n+                cob.invokestatic(CD_MODULE_BUILDER,\n+                                 \"newRequires\",\n+                                 MTD_REQUIRES_SET_STRING);\n+            }\n+        }\n+\n+        \/*\n+         * Call Builder::newExports to create Exports instances and\n+         * then pass it to the builder by calling:\n+         *      Builder.exports(Exports[])\n+         *\n+         *\/\n+        void exports(Set<Exports> exports) {\n+            var exportArray = LoadableArray.of(\n+                    CD_EXPORTS,\n+                    sorted(exports),\n+                    this::loadExports,\n+                    PAGING_THRESHOLD,\n+                    ownerClassDesc,\n+                    \"module\" + index + \"Exports\",\n+                    \/\/ number safe for a single page helper under 64K size limit\n+                    2000);\n+\n+            setupLoadable(exportArray);\n+\n+            cob.dup();\n+            exportArray.load(cob);\n+            cob.invokevirtual(CD_MODULE_BUILDER,\n+                    \"exports\",\n+                    MTD_EXPORTS_ARRAY)\n+                    .pop();\n+        }\n+\n+        \/*\n+         * Invoke\n+         *     Builder.newExports(Set<Exports.Modifier> ms, String pn,\n+         *                        Set<String> targets)\n+         * or\n+         *     Builder.newExports(Set<Exports.Modifier> ms, String pn)\n+         *\n+         * ms = export.modifiers()\n+         * pn = export.source()\n+         * targets = export.targets()\n+         *\/\n+        void loadExports(CodeBuilder cb, Exports export, int unused) {\n+            dedupSetBuilder.loadExportsModifiers(cb, export.modifiers());\n+            cb.loadConstant(export.source());\n+            var targets = export.targets();\n+            if (!targets.isEmpty()) {\n+                dedupSetBuilder.loadStringSet(cb, targets);\n+                cb.invokestatic(CD_MODULE_BUILDER,\n+                                \"newExports\",\n+                                MTD_EXPORTS_MODIFIER_SET_STRING_SET);\n+            } else {\n+                cb.invokestatic(CD_MODULE_BUILDER,\n+                                \"newExports\",\n+                                MTD_EXPORTS_MODIFIER_SET_STRING);\n+            }\n+        }\n+\n+\n+        \/**\n+         * Call Builder::newOpens to create Opens instances and\n+         * then pass it to the builder by calling:\n+         * Builder.opens(Opens[])\n+         *\/\n+        void opens(Set<Opens> opens) {\n+            var opensArray = LoadableArray.of(\n+                    CD_OPENS,\n+                    sorted(opens),\n+                    this::newOpens,\n+                    PAGING_THRESHOLD,\n+                    ownerClassDesc,\n+                    \"module\" + index + \"Opens\",\n+                    \/\/ number safe for a single page helper under 64K size limit\n+                    2000);\n+\n+            setupLoadable(opensArray);\n+\n+            cob.dup();\n+            opensArray.load(cob);\n+            cob.invokevirtual(CD_MODULE_BUILDER,\n+                              \"opens\",\n+                              MTD_OPENS_ARRAY)\n+                .pop();\n+        }\n+\n+        \/*\n+         * Invoke\n+         *     Builder.newOpens(Set<Opens.Modifier> ms, String pn,\n+         *                        Set<String> targets)\n+         * or\n+         *     Builder.newOpens(Set<Opens.Modifier> ms, String pn)\n+         *\n+         * ms = open.modifiers()\n+         * pn = open.source()\n+         * targets = open.targets()\n+         * Builder.newOpens(mods, pn, targets);\n+         *\/\n+        void newOpens(CodeBuilder cb, Opens open, int unused) {\n+            dedupSetBuilder.loadOpensModifiers(cb, open.modifiers());\n+            cb.loadConstant(open.source());\n+            var targets = open.targets();\n+            if (!targets.isEmpty()) {\n+                dedupSetBuilder.loadStringSet(cb, targets);\n+                cb.invokestatic(CD_MODULE_BUILDER,\n+                                 \"newOpens\",\n+                                 MTD_OPENS_MODIFIER_SET_STRING_SET);\n+            } else {\n+                cb.invokestatic(CD_MODULE_BUILDER,\n+                                 \"newOpens\",\n+                                 MTD_OPENS_MODIFIER_SET_STRING);\n+            }\n+        }\n+\n+        \/*\n+         * Invoke Builder.uses(Set<String> uses)\n+         *\/\n+        void uses(Set<String> uses) {\n+            cob.dup();\n+            dedupSetBuilder.loadStringSet(cob, uses);\n+            cob.invokevirtual(CD_MODULE_BUILDER,\n+                              \"uses\",\n+                              MTD_SET)\n+               .pop();\n+        }\n+\n+        \/*\n+        * Call Builder::newProvides to create Provides instances and\n+        * then pass it to the builder by calling:\n+        *      Builder.provides(Provides[] provides)\n+        *\n+        *\/\n+        void provides(Collection<Provides> provides) {\n+            var providesArray = LoadableArray.of(\n+                    CD_PROVIDES,\n+                    sorted(provides),\n+                    this::newProvides,\n+                    PAGING_THRESHOLD,\n+                    ownerClassDesc,\n+                    \"module\" + index + \"Provides\",\n+                    \/\/ number safe for a single page helper under 64K size limit\n+                    2000);\n+\n+            setupLoadable(providesArray);\n+\n+            cob.dup();\n+            providesArray.load(cob);\n+            cob.invokevirtual(CD_MODULE_BUILDER,\n+                              \"provides\",\n+                              MTD_PROVIDES_ARRAY)\n+                .pop();\n+        }\n+\n+        \/*\n+         * Invoke Builder.newProvides(String service, List<String> providers)\n+         *\n+         * service = provide.service()\n+         * providers = List.of(new String[] { provide.providers() }\n+         * Builder.newProvides(service, providers);\n+         *\/\n+        void newProvides(CodeBuilder cb, Provides provide, int offset) {\n+            var providersArray = LoadableArray.of(\n+                    CD_String,\n+                    provide.providers(),\n+                    STRING_LOADER,\n+                    PAGING_THRESHOLD,\n+                    ownerClassDesc,\n+                    \"module\" + index + \"Provider\" + offset,\n+                    STRING_PAGE_SIZE);\n+\n+\n+            setupLoadable(providersArray);\n+\n+            cb.loadConstant(provide.service());\n+            providersArray.load(cb);\n+            cb.invokestatic(CD_List,\n+                             \"of\",\n+                             MTD_List_ObjectArray,\n+                             true)\n+               .invokestatic(CD_MODULE_BUILDER,\n+                             \"newProvides\",\n+                             MTD_PROVIDES_STRING_LIST);\n+        }\n+\n+        \/*\n+         * Invoke Builder.packages(Set<String> packages)\n+         * with packages either from invoke provider method\n+         *   module<index>Packages()\n+         * or construct inline with\n+         *   Set.of(packages)\n+         *\/\n+        void packages(Set<String> packages) {\n+            var packagesArray = LoadableSet.of(\n+                    sorted(packages),\n+                    STRING_LOADER,\n+                    PAGING_THRESHOLD,\n+                    ownerClassDesc,\n+                    \"module\" + index + \"Packages\",\n+                    STRING_PAGE_SIZE);\n+\n+            setupLoadable(packagesArray);\n+\n+            cob.dup();\n+            packagesArray.load(cob);\n+            cob.invokevirtual(CD_MODULE_BUILDER,\n+                              \"packages\",\n+                              MTD_SET)\n+               .pop();\n+        }\n+\n+        \/*\n+         * Invoke Builder.mainClass(String cn)\n+         *\/\n+        void mainClass(String cn) {\n+            cob.dup()\n+               .loadConstant(cn)\n+               .invokevirtual(CD_MODULE_BUILDER,\n+                              \"mainClass\",\n+                              MTD_STRING)\n+               .pop();\n+        }\n+\n+        \/*\n+         * Invoke Builder.version(Version v);\n+         *\/\n+        void version(Version v) {\n+            cob.dup()\n+               .loadConstant(v.toString())\n+               .invokevirtual(CD_MODULE_BUILDER,\n+                              \"version\",\n+                              MTD_STRING)\n+               .pop();\n+        }\n+    }\n+\n+    \/**\n+     * Returns a sorted copy of a collection.\n+     *\n+     * This is useful to ensure a deterministic iteration order.\n+     *\n+     * @return a sorted copy of the given collection.\n+     *\/\n+    private static <T extends Comparable<T>> List<T> sorted(Collection<T> c) {\n+        var l = new ArrayList<T>(c);\n+        Collections.sort(l);\n+        return l;\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/ModuleInfoLoader.java","additions":514,"deletions":0,"binary":false,"changes":514,"status":"added"},{"patch":"@@ -40,1 +40,0 @@\n-import java.lang.module.ModuleDescriptor.Version;\n@@ -61,1 +60,0 @@\n-import java.util.function.BiConsumer;\n@@ -82,0 +80,3 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n@@ -335,0 +336,11 @@\n+        \/\/ Diagnosis help, can be removed\n+        if (Boolean.parseBoolean(System.getProperty(\"JlinkDumpSystemModuleClass\", \"false\"))) {\n+            try {\n+                var filePath = Path.of(className + \".class\").toAbsolutePath();\n+                System.err.println(\"Write \" + filePath.toString());\n+                Files.createDirectories(filePath.getParent());\n+                Files.write(filePath, bytes);\n+            } catch (IOException ioe) {\n+                ioe.printStackTrace(System.err);\n+            }\n+        }\n@@ -519,2 +531,0 @@\n-        private static final ClassDesc CD_MODULE_BUILDER =\n-            ClassDesc.ofInternalName(\"jdk\/internal\/module\/Builder\");\n@@ -545,0 +555,1 @@\n+        static final int PAGING_THRESHOLD = 512; \/\/ An arbitrary number as this likely generate minimum ~4K code\n@@ -548,1 +559,0 @@\n-        private final int MD_VAR         = 1;  \/\/ variable for ModuleDescriptor\n@@ -561,2 +571,0 @@\n-        private final ArrayList<Consumer<ClassBuilder>> amendments = new ArrayList<>();\n-\n@@ -641,3 +649,0 @@\n-\n-                        \/\/ generate module helpers\n-                        amendments.forEach(amendment -> amendment.accept(clb));\n@@ -647,6 +652,0 @@\n-        private void setupLoadable(Loadable loadable) {\n-            if (loadable.doesRequireSetup()) {\n-                amendments.add(loadable::setup);\n-            }\n-        }\n-\n@@ -718,3 +717,0 @@\n-        \/**\n-         * Generate bytecode for moduleDescriptors method\n-         *\/\n@@ -722,22 +718,8 @@\n-            if (moduleInfos.size() <= moduleDescriptorsPerMethod) {\n-                clb.withMethodBody(\n-                        \"moduleDescriptors\",\n-                        MTD_ModuleDescriptorArray,\n-                        ACC_PUBLIC,\n-                        cob -> {\n-                            cob.loadConstant(moduleInfos.size())\n-                               .anewarray(CD_MODULE_DESCRIPTOR)\n-                               .astore(MD_VAR);\n-\n-                            for (int index = 0; index < moduleInfos.size(); index++) {\n-                                ModuleInfo minfo = moduleInfos.get(index);\n-                                new ModuleDescriptorBuilder(cob,\n-                                                            minfo.descriptor(),\n-                                                            minfo.packages(),\n-                                                            index).build();\n-                            }\n-                            cob.aload(MD_VAR)\n-                               .areturn();\n-                        });\n-                return;\n-            }\n+            var moduleDescriptors = LoadableArray.of(\n+                    CD_MODULE_DESCRIPTOR,\n+                    moduleInfos,\n+                    new ModuleInfoLoader(dedupSetBuilder, classDesc),\n+                    moduleDescriptorsPerMethod,\n+                    classDesc,\n+                    \"sub\",\n+                    moduleDescriptorsPerMethod);\n@@ -745,18 +727,1 @@\n-\n-            \/\/ Split the module descriptors be created by multiple helper methods.\n-            \/\/ Each helper method \"subi\" creates the maximum N number of module descriptors\n-            \/\/     mi, m{i+1} ...\n-            \/\/ to avoid exceeding the 64kb limit of method length.  Then it will call\n-            \/\/ \"sub{i+1}\" to creates the next batch of module descriptors m{i+n}, m{i+n+1}...\n-            \/\/ and so on.\n-            List<List<ModuleInfo>> splitModuleInfos = new ArrayList<>();\n-            List<ModuleInfo> currentModuleInfos = null;\n-            for (int index = 0; index < moduleInfos.size(); index++) {\n-                if (index % moduleDescriptorsPerMethod == 0) {\n-                    currentModuleInfos = new ArrayList<>();\n-                    splitModuleInfos.add(currentModuleInfos);\n-                }\n-                currentModuleInfos.add(moduleInfos.get(index));\n-            }\n-\n-            String helperMethodNamePrefix = \"sub\";\n+            moduleDescriptors.setup(clb);\n@@ -769,12 +734,2 @@\n-                        cob.loadConstant(moduleInfos.size())\n-                           .anewarray(CD_MODULE_DESCRIPTOR)\n-                           .dup()\n-                           .astore(MD_VAR);\n-                        cob.aload(0)\n-                           .aload(MD_VAR)\n-                           .invokevirtual(\n-                                   this.classDesc,\n-                                   helperMethodNamePrefix + \"0\",\n-                                   MethodTypeDesc.of(CD_void, CD_MODULE_DESCRIPTOR.arrayType())\n-                           )\n-                           .areturn();\n+                            moduleDescriptors.load(cob);\n+                            cob.areturn();\n@@ -782,31 +737,0 @@\n-\n-            for (int n = 0, count = 0; n < splitModuleInfos.size(); count += splitModuleInfos.get(n).size(), n++) {\n-                int index = n;       \/\/ the index of which ModuleInfo being processed in the current batch\n-                int start = count;   \/\/ the start index to the return ModuleDescriptor array for the current batch\n-                clb.withMethodBody(\n-                        helperMethodNamePrefix + index,\n-                        MethodTypeDesc.of(CD_void, CD_MODULE_DESCRIPTOR.arrayType()),\n-                        ACC_PUBLIC,\n-                        cob -> {\n-                            List<ModuleInfo> currentBatch = splitModuleInfos.get(index);\n-                            for (int j = 0; j < currentBatch.size(); j++) {\n-                                ModuleInfo minfo = currentBatch.get(j);\n-                                new ModuleDescriptorBuilder(cob,\n-                                                            minfo.descriptor(),\n-                                                            minfo.packages(),\n-                                                            start + j).build();\n-                            }\n-\n-                            if (index < splitModuleInfos.size() - 1) {\n-                                cob.aload(0)\n-                                   .aload(MD_VAR)\n-                                   .invokevirtual(\n-                                           this.classDesc,\n-                                           helperMethodNamePrefix + (index+1),\n-                                           MethodTypeDesc.of(CD_void, CD_MODULE_DESCRIPTOR.arrayType())\n-                                   );\n-                            }\n-\n-                            cob.return_();\n-                        });\n-            }\n@@ -1024,417 +948,0 @@\n-        class ModuleDescriptorBuilder {\n-            static final ClassDesc CD_EXPORTS =\n-                ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Exports\");\n-            static final ClassDesc CD_OPENS =\n-                ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Opens\");\n-            static final ClassDesc CD_PROVIDES =\n-                ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Provides\");\n-            static final ClassDesc CD_REQUIRES =\n-                ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Requires\");\n-\n-            \/\/ method signature for static Builder::newExports, newOpens,\n-            \/\/ newProvides, newRequires methods\n-            static final MethodTypeDesc MTD_EXPORTS_MODIFIER_SET_STRING_SET =\n-                MethodTypeDesc.of(CD_EXPORTS, CD_Set, CD_String, CD_Set);\n-            static final MethodTypeDesc MTD_EXPORTS_MODIFIER_SET_STRING =\n-                MethodTypeDesc.of(CD_EXPORTS, CD_Set, CD_String);\n-            static final MethodTypeDesc MTD_OPENS_MODIFIER_SET_STRING_SET =\n-                MethodTypeDesc.of(CD_OPENS, CD_Set, CD_String, CD_Set);\n-            static final MethodTypeDesc MTD_OPENS_MODIFIER_SET_STRING =\n-                MethodTypeDesc.of(CD_OPENS, CD_Set, CD_String);\n-            static final MethodTypeDesc MTD_PROVIDES_STRING_LIST =\n-                MethodTypeDesc.of(CD_PROVIDES, CD_String, CD_List);\n-            static final MethodTypeDesc MTD_REQUIRES_SET_STRING =\n-                MethodTypeDesc.of(CD_REQUIRES, CD_Set, CD_String);\n-            static final MethodTypeDesc MTD_REQUIRES_SET_STRING_STRING =\n-                MethodTypeDesc.of(CD_REQUIRES, CD_Set, CD_String, CD_String);\n-\n-            \/\/ method signature for Builder instance methods that\n-            \/\/ return this Builder instance\n-            static final MethodTypeDesc MTD_EXPORTS_ARRAY =\n-                MethodTypeDesc.of(CD_MODULE_BUILDER, CD_EXPORTS.arrayType());\n-            static final MethodTypeDesc MTD_OPENS_ARRAY =\n-                MethodTypeDesc.of(CD_MODULE_BUILDER, CD_OPENS.arrayType());\n-            static final MethodTypeDesc MTD_PROVIDES_ARRAY =\n-                MethodTypeDesc.of(CD_MODULE_BUILDER, CD_PROVIDES.arrayType());\n-            static final MethodTypeDesc MTD_REQUIRES_ARRAY =\n-                MethodTypeDesc.of(CD_MODULE_BUILDER, CD_REQUIRES.arrayType());\n-            static final MethodTypeDesc MTD_SET = MethodTypeDesc.of(CD_MODULE_BUILDER, CD_Set);\n-            static final MethodTypeDesc MTD_STRING = MethodTypeDesc.of(CD_MODULE_BUILDER, CD_String);\n-            static final MethodTypeDesc MTD_BOOLEAN = MethodTypeDesc.of(CD_MODULE_BUILDER, CD_boolean);\n-            static final MethodTypeDesc MTD_void_String = MethodTypeDesc.of(CD_void, CD_String);\n-            static final MethodTypeDesc MTD_ModuleDescriptor_int = MethodTypeDesc.of(CD_MODULE_DESCRIPTOR, CD_int);\n-            static final MethodTypeDesc MTD_List_ObjectArray = MethodTypeDesc.of(CD_List, CD_Object.arrayType());\n-\n-            static final int PAGING_THRESHOLD = 512; \/\/ An arbitrary number as this likely generate minimum ~4K code\n-\n-            final CodeBuilder cob;\n-            final ModuleDescriptor md;\n-            final Set<String> packages;\n-            final int index;\n-\n-            ModuleDescriptorBuilder(CodeBuilder cob, ModuleDescriptor md, Set<String> packages, int index) {\n-                if (md.isAutomatic()) {\n-                    throw new InternalError(\"linking automatic module is not supported\");\n-                }\n-                this.cob = cob;\n-                this.md = md;\n-                this.packages = packages;\n-                this.index = index;\n-            }\n-\n-            void build() {\n-                \/\/ new jdk.internal.module.Builder\n-                newBuilder();\n-\n-                \/\/ requires\n-                requires(md.requires());\n-\n-                \/\/ exports\n-                exports(md.exports());\n-\n-                \/\/ opens\n-                opens(md.opens());\n-\n-                \/\/ uses\n-                uses(md.uses());\n-\n-                \/\/ provides\n-                provides(md.provides());\n-\n-                \/\/ all packages\n-                packages(packages);\n-\n-                \/\/ version\n-                md.version().ifPresent(this::version);\n-\n-                \/\/ main class\n-                md.mainClass().ifPresent(this::mainClass);\n-\n-                putModuleDescriptor();\n-            }\n-\n-            void newBuilder() {\n-                cob.new_(CD_MODULE_BUILDER)\n-                   .dup()\n-                   .loadConstant(md.name())\n-                   .invokespecial(CD_MODULE_BUILDER,\n-                                  INIT_NAME,\n-                                  MTD_void_String)\n-                   .astore(BUILDER_VAR);\n-\n-                if (md.isOpen()) {\n-                    setModuleBit(\"open\", true);\n-                }\n-                if (md.modifiers().contains(ModuleDescriptor.Modifier.SYNTHETIC)) {\n-                    setModuleBit(\"synthetic\", true);\n-                }\n-                if (md.modifiers().contains(ModuleDescriptor.Modifier.MANDATED)) {\n-                    setModuleBit(\"mandated\", true);\n-                }\n-            }\n-\n-            \/*\n-             * Invoke Builder.<methodName>(boolean value)\n-             *\/\n-            void setModuleBit(String methodName, boolean value) {\n-                cob.aload(BUILDER_VAR)\n-                   .loadConstant(value ? 1 : 0)\n-                   .invokevirtual(CD_MODULE_BUILDER,\n-                                  methodName,\n-                                  MTD_BOOLEAN)\n-                   .pop();\n-            }\n-\n-            \/*\n-             * Put ModuleDescriptor into the modules array\n-             *\/\n-            void putModuleDescriptor() {\n-                cob.aload(MD_VAR)\n-                   .loadConstant(index)\n-                   .aload(BUILDER_VAR)\n-                   .loadConstant(md.hashCode())\n-                   .invokevirtual(CD_MODULE_BUILDER,\n-                                  \"build\",\n-                                  MTD_ModuleDescriptor_int)\n-                   .aastore();\n-            }\n-\n-            \/*\n-             * Call Builder::newRequires to create Requires instances and\n-             * then pass it to the builder by calling:\n-             *      Builder.requires(Requires[])\n-             *\n-             *\/\n-            void requires(Set<Requires> requires) {\n-                cob.aload(BUILDER_VAR)\n-                   .loadConstant(requires.size())\n-                   .anewarray(CD_REQUIRES);\n-                int arrayIndex = 0;\n-                for (Requires require : sorted(requires)) {\n-                    String compiledVersion = null;\n-                    if (require.compiledVersion().isPresent()) {\n-                        compiledVersion = require.compiledVersion().get().toString();\n-                    }\n-\n-                    cob.dup()               \/\/ arrayref\n-                       .loadConstant(arrayIndex++);\n-                    newRequires(require.modifiers(), require.name(), compiledVersion);\n-                    cob.aastore();\n-                }\n-                cob.invokevirtual(CD_MODULE_BUILDER,\n-                                  \"requires\",\n-                                  MTD_REQUIRES_ARRAY)\n-                    .pop();\n-            }\n-\n-            \/*\n-             * Invoke Builder.newRequires(Set<Modifier> mods, String mn, String compiledVersion)\n-             *\n-             * Set<Modifier> mods = ...\n-             * Builder.newRequires(mods, mn, compiledVersion);\n-             *\/\n-            void newRequires(Set<Requires.Modifier> mods, String name, String compiledVersion) {\n-                dedupSetBuilder.loadRequiresModifiers(cob, mods);\n-                cob.loadConstant(name);\n-                if (compiledVersion != null) {\n-                    cob.loadConstant(compiledVersion)\n-                       .invokestatic(CD_MODULE_BUILDER,\n-                                     \"newRequires\",\n-                                     MTD_REQUIRES_SET_STRING_STRING);\n-                } else {\n-                    cob.invokestatic(CD_MODULE_BUILDER,\n-                                     \"newRequires\",\n-                                     MTD_REQUIRES_SET_STRING);\n-                }\n-            }\n-\n-            \/*\n-             * Call Builder::newExports to create Exports instances and\n-             * then pass it to the builder by calling:\n-             *      Builder.exports(Exports[])\n-             *\n-             *\/\n-            void exports(Set<Exports> exports) {\n-                var exportArray = LoadableArray.of(\n-                        CD_EXPORTS,\n-                        sorted(exports),\n-                        this::loadExports,\n-                        PAGING_THRESHOLD,\n-                        classDesc,\n-                        \"module\" + index + \"Exports\",\n-                        \/\/ number safe for a single page helper under 64K size limit\n-                        2000);\n-\n-                setupLoadable(exportArray);\n-\n-                cob.aload(BUILDER_VAR);\n-                exportArray.load(cob);\n-                cob.invokevirtual(CD_MODULE_BUILDER,\n-                        \"exports\",\n-                        MTD_EXPORTS_ARRAY)\n-                        .pop();\n-            }\n-\n-            \/*\n-             * Invoke\n-             *     Builder.newExports(Set<Exports.Modifier> ms, String pn,\n-             *                        Set<String> targets)\n-             * or\n-             *     Builder.newExports(Set<Exports.Modifier> ms, String pn)\n-             *\n-             * ms = export.modifiers()\n-             * pn = export.source()\n-             * targets = export.targets()\n-             *\/\n-            void loadExports(CodeBuilder cb, Exports export, int unused) {\n-                dedupSetBuilder.loadExportsModifiers(cb, export.modifiers());\n-                cb.loadConstant(export.source());\n-                var targets = export.targets();\n-                if (!targets.isEmpty()) {\n-                    dedupSetBuilder.loadStringSet(cb, targets);\n-                    cb.invokestatic(CD_MODULE_BUILDER,\n-                                    \"newExports\",\n-                                    MTD_EXPORTS_MODIFIER_SET_STRING_SET);\n-                } else {\n-                    cb.invokestatic(CD_MODULE_BUILDER,\n-                                    \"newExports\",\n-                                    MTD_EXPORTS_MODIFIER_SET_STRING);\n-                }\n-            }\n-\n-\n-            \/**\n-             * Call Builder::newOpens to create Opens instances and\n-             * then pass it to the builder by calling:\n-             * Builder.opens(Opens[])\n-             *\/\n-            void opens(Set<Opens> opens) {\n-                var opensArray = LoadableArray.of(\n-                        CD_OPENS,\n-                        sorted(opens),\n-                        this::newOpens,\n-                        PAGING_THRESHOLD,\n-                        classDesc,\n-                        \"module\" + index + \"Opens\",\n-                        \/\/ number safe for a single page helper under 64K size limit\n-                        2000);\n-\n-                setupLoadable(opensArray);\n-\n-                cob.aload(BUILDER_VAR);\n-                opensArray.load(cob);\n-                cob.invokevirtual(CD_MODULE_BUILDER,\n-                                  \"opens\",\n-                                  MTD_OPENS_ARRAY)\n-                    .pop();\n-            }\n-\n-            \/*\n-             * Invoke\n-             *     Builder.newOpens(Set<Opens.Modifier> ms, String pn,\n-             *                        Set<String> targets)\n-             * or\n-             *     Builder.newOpens(Set<Opens.Modifier> ms, String pn)\n-             *\n-             * ms = open.modifiers()\n-             * pn = open.source()\n-             * targets = open.targets()\n-             * Builder.newOpens(mods, pn, targets);\n-             *\/\n-            void newOpens(CodeBuilder cb, Opens open, int unused) {\n-                dedupSetBuilder.loadOpensModifiers(cb, open.modifiers());\n-                cb.loadConstant(open.source());\n-                var targets = open.targets();\n-                if (!targets.isEmpty()) {\n-                    dedupSetBuilder.loadStringSet(cb, targets);\n-                    cb.invokestatic(CD_MODULE_BUILDER,\n-                                     \"newOpens\",\n-                                     MTD_OPENS_MODIFIER_SET_STRING_SET);\n-                } else {\n-                    cb.invokestatic(CD_MODULE_BUILDER,\n-                                     \"newOpens\",\n-                                     MTD_OPENS_MODIFIER_SET_STRING);\n-                }\n-            }\n-\n-            \/*\n-             * Invoke Builder.uses(Set<String> uses)\n-             *\/\n-            void uses(Set<String> uses) {\n-                cob.aload(BUILDER_VAR);\n-                dedupSetBuilder.loadStringSet(cob, uses);\n-                cob.invokevirtual(CD_MODULE_BUILDER,\n-                                  \"uses\",\n-                                  MTD_SET)\n-                   .pop();\n-            }\n-\n-            \/*\n-            * Call Builder::newProvides to create Provides instances and\n-            * then pass it to the builder by calling:\n-            *      Builder.provides(Provides[] provides)\n-            *\n-            *\/\n-            void provides(Collection<Provides> provides) {\n-                var providesArray = LoadableArray.of(\n-                        CD_PROVIDES,\n-                        sorted(provides),\n-                        this::newProvides,\n-                        PAGING_THRESHOLD,\n-                        classDesc,\n-                        \"module\" + index + \"Provides\",\n-                        \/\/ number safe for a single page helper under 64K size limit\n-                        2000);\n-\n-                setupLoadable(providesArray);\n-\n-                cob.aload(BUILDER_VAR);\n-                providesArray.load(cob);\n-                cob.invokevirtual(CD_MODULE_BUILDER,\n-                                  \"provides\",\n-                                  MTD_PROVIDES_ARRAY)\n-                    .pop();\n-            }\n-\n-            \/*\n-             * Invoke Builder.newProvides(String service, List<String> providers)\n-             *\n-             * service = provide.service()\n-             * providers = List.of(new String[] { provide.providers() }\n-             * Builder.newProvides(service, providers);\n-             *\/\n-            void newProvides(CodeBuilder cb, Provides provide, int offset) {\n-                var providersArray = LoadableArray.of(\n-                        CD_String,\n-                        provide.providers(),\n-                        STRING_LOADER,\n-                        PAGING_THRESHOLD,\n-                        classDesc,\n-                        \"module\" + index + \"Provider\" + offset,\n-                        STRING_PAGE_SIZE);\n-\n-\n-                setupLoadable(providersArray);\n-\n-                cb.loadConstant(provide.service());\n-                providersArray.load(cb);\n-                cb.invokestatic(CD_List,\n-                                 \"of\",\n-                                 MTD_List_ObjectArray,\n-                                 true)\n-                   .invokestatic(CD_MODULE_BUILDER,\n-                                 \"newProvides\",\n-                                 MTD_PROVIDES_STRING_LIST);\n-            }\n-\n-            \/*\n-             * Invoke Builder.packages(Set<String> packages)\n-             * with packages either from invoke provider method\n-             *   module<index>Packages()\n-             * or construct inline with\n-             *   Set.of(packages)\n-             *\/\n-            void packages(Set<String> packages) {\n-                var packagesArray = LoadableSet.of(\n-                        sorted(packages),\n-                        STRING_LOADER,\n-                        PAGING_THRESHOLD,\n-                        classDesc,\n-                        \"module\" + index + \"Packages\",\n-                        STRING_PAGE_SIZE);\n-\n-                setupLoadable(packagesArray);\n-\n-                cob.aload(BUILDER_VAR);\n-                packagesArray.load(cob);\n-                cob.invokevirtual(CD_MODULE_BUILDER,\n-                                  \"packages\",\n-                                  MTD_SET)\n-                   .pop();\n-            }\n-\n-            \/*\n-             * Invoke Builder.mainClass(String cn)\n-             *\/\n-            void mainClass(String cn) {\n-                cob.aload(BUILDER_VAR)\n-                   .loadConstant(cn)\n-                   .invokevirtual(CD_MODULE_BUILDER,\n-                                  \"mainClass\",\n-                                  MTD_STRING)\n-                   .pop();\n-            }\n-\n-            \/*\n-             * Invoke Builder.version(Version v);\n-             *\/\n-            void version(Version v) {\n-                cob.aload(BUILDER_VAR)\n-                   .loadConstant(v.toString())\n-                   .invokevirtual(CD_MODULE_BUILDER,\n-                                  \"version\",\n-                                  MTD_STRING)\n-                   .pop();\n-            }\n-        }\n-\n@@ -1568,1 +1075,1 @@\n-                                                 ModuleDescriptorBuilder.PAGING_THRESHOLD,\n+                                                 PAGING_THRESHOLD,\n@@ -1687,1 +1194,1 @@\n-                        ModuleDescriptorBuilder.PAGING_THRESHOLD,\n+                        PAGING_THRESHOLD,\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/SystemModulesPlugin.java","additions":28,"deletions":521,"binary":false,"changes":549,"status":"modified"}]}