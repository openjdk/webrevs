{"files":[{"patch":"@@ -37,0 +37,1 @@\n+import java.lang.classfile.TypeKind;\n@@ -45,4 +46,0 @@\n-    \/\/ Tested page size of string array\n-    public static final int STRING_PAGE_SIZE = 8000;\n-    \/\/ Tested page size of enum array\n-    public static final int ENUM_PAGE_SIZE = 5000;\n@@ -57,2 +54,1 @@\n-         * @param cob  The CodeBuilder the bytecode snippet.\n-         * @throws IllegalStateException If the snippet is not setup properly.\n+         * @param cob  The CodeBuilder\n@@ -62,0 +58,3 @@\n+        \/**\n+         * Load a constant onto the operand stack.\n+         *\/\n@@ -66,0 +65,3 @@\n+        \/**\n+         * Load an enum constant onto the operand stack.\n+         *\/\n@@ -71,0 +73,3 @@\n+        \/**\n+         * Load an Integer, boxed int value onto the operand stack.\n+         *\/\n@@ -74,1 +79,1 @@\n-                       .invokestatic(ClassDesc.ofInternalName(\"java\/lang\/Integer\"), \"valueOf\", MethodTypeDesc.of(CD_Integer, CD_int));\n+                       .invokestatic(CD_Integer, \"valueOf\", MethodTypeDesc.of(CD_Integer, CD_int));\n@@ -77,0 +82,6 @@\n+        \/**\n+         * Build snippets each to process the corresponding element.\n+         * @param elements The elements to be processed\n+         * @param fn The snippet building function for a given element\n+         * @return Snippets\n+         *\/\n@@ -85,1 +96,1 @@\n-     * Describe a reference that can be load onto the operand stack.\n+     * Describe a operand that can be load onto the operand stack.\n@@ -87,0 +98,3 @@\n+     *\n+     * @param classDesc The type of the operand\n+     * @param load The snippet to load the operand onto the operand stack\n@@ -99,0 +113,4 @@\n+    \/**\n+     * Build a snippet for an element with a given index. Typically used for elements in a\n+     * collection to identify the specific element.\n+     *\/\n@@ -120,0 +138,5 @@\n+    \/**\n+     * Some basic information about pagination.\n+     * @param total The total count of elements\n+     * @param pageSize the number or elements to be included in a page\n+     *\/\n@@ -121,0 +144,3 @@\n+        \/**\n+         * If the last page has less elements than given page size.\n+         *\/\n@@ -125,0 +151,3 @@\n+        \/**\n+         * The number of pages.\n+         *\/\n@@ -130,0 +159,3 @@\n+        \/**\n+         * The number of elements in the last page.\n+         *\/\n@@ -137,0 +169,4 @@\n+    \/**\n+     * Generate bytecodes for loading a collection of elements, support using pagination to avoid\n+     * overloading the 64k code limit.\n+     *\/\n@@ -138,0 +174,20 @@\n+        \/**\n+         * Tested page size of string array\n+         *\/\n+        public static final int STRING_PAGE_SIZE = 8000;\n+\n+        \/**\n+         * Tested page size of enum array\n+         *\/\n+        public static final int ENUM_PAGE_SIZE = 5000;\n+\n+        \/**\n+         * Good enough for average ~30 bytes per element\n+         *\/\n+        public static final int DEFAULT_PAGE_SIZE = 2000;\n+\n+        \/**\n+         * Arbitary default values based on 15K code size on ~30 bytes per element\n+         *\/\n+        protected static final int DEFAULT_THRESHOLD = 512;\n+\n@@ -139,1 +195,0 @@\n-        protected int activatePagingThreshold;\n@@ -141,2 +196,0 @@\n-        protected String methodNamePrefix;\n-        protected int pageSize;\n@@ -145,0 +198,8 @@\n+        \/\/ Default values enable pagination by default\n+        protected String methodNamePrefix = \"csb\" + Integer.toHexString(hashCode()) + \"Page\";\n+        protected int activatePagingThreshold = DEFAULT_THRESHOLD;\n+        protected int pageSize = DEFAULT_PAGE_SIZE;\n+\n+        \/**\n+         * @param elementType The element type\n+         *\/\n@@ -150,0 +211,39 @@\n+         * Enable pagination if the count of elements is larger than the given threshold.\n+         *\n+         * @param methodNamePrefix The method name prefix for generated paging helper methods\n+         * @param pageSize         The page size\n+         * @param threshold        The element count to actiave the pagination\n+         *\/\n+        public CollectionSnippetBuilder enablePagination(String methodNamePrefix, int pageSize, int threshold) {\n+            return this.pageSize(pageSize)\n+                       .activatePagingThreshold(threshold)\n+                       .methodNamePrefix(methodNamePrefix);\n+        }\n+\n+        \/**\n+         * Enable pagination if the count of elements is larger than pageSize or DEFAULT_THRESHOLD\n+         *\/\n+        public CollectionSnippetBuilder enablePagination(String methodNamePrefix, int pageSize) {\n+            return enablePagination(methodNamePrefix, pageSize, Math.min(pageSize, DEFAULT_THRESHOLD));\n+        }\n+\n+        \/**\n+         * Enable pagination if the count of elements is larger than pageSize or DEFAULT_THRESHOLD\n+         * with page size DEFAULT_PAGE_SIZE.\n+         *\/\n+        public CollectionSnippetBuilder enablePagination(String methodNamePrefix) {\n+            return enablePagination(methodNamePrefix, DEFAULT_PAGE_SIZE, DEFAULT_THRESHOLD);\n+        }\n+\n+        \/**\n+         * Disable pagination. Generated bytecode will always try to construct the collection inline.\n+         *\/\n+        public CollectionSnippetBuilder disablePagination() {\n+            this.activatePagingThreshold = -1;\n+            this.methodNamePrefix = null;\n+            return this;\n+        }\n+\n+        \/**\n+         * Set the threshold of element count to enable pagination.\n+         *\n@@ -154,0 +254,3 @@\n+            if (activatePagingThreshold <= 0) {\n+                throw new IllegalArgumentException();\n+            }\n@@ -159,1 +262,3 @@\n-         * @param ownerClassDesc  The owner class for the paginattion methods\n+         * Set the owner class host the pagination methods.\n+         *\n+         * @param ownerClassDesc  The owner class for the pagination methods\n@@ -162,1 +267,1 @@\n-            this.ownerClassDesc = ownerClassDesc;\n+            this.ownerClassDesc = Objects.requireNonNull(ownerClassDesc);\n@@ -167,0 +272,1 @@\n+         * Set the method name prefix for the pagination methods.\n@@ -171,1 +277,1 @@\n-            this.methodNamePrefix = methodNamePrefix;\n+            this.methodNamePrefix = Objects.requireNonNull(methodNamePrefix);\n@@ -176,0 +282,1 @@\n+         * Set the page size. The max page size is STRING_PAGE_SIZE.\n@@ -179,0 +286,5 @@\n+            \/\/ ldc is likely the smallest element snippet\n+            if (pageSize <= 0  || pageSize > STRING_PAGE_SIZE) {\n+                throw new IllegalArgumentException();\n+            }\n+\n@@ -183,0 +295,6 @@\n+        \/**\n+         * Set the class builder used to generate the pagination methods.\n+         *\n+         * This value must be set if pagination is needed, otherwise the build\n+         * would lead to NullPointerException.\n+         *\/\n@@ -184,1 +302,1 @@\n-            this.clb = clb;\n+            this.clb = Objects.requireNonNull(clb);\n@@ -189,1 +307,1 @@\n-            return activatePagingThreshold != 0 && length > activatePagingThreshold;\n+            return activatePagingThreshold > 0 && length > activatePagingThreshold;\n@@ -192,0 +310,11 @@\n+        \/**\n+         * Build the Loadable snippet to load the collection of elements onto\n+         * the operand stack. When pagination is enabled and needed as the total\n+         * count of elements is larger than the given threshold, missing\n+         * required field will lead to NullPointerException.\n+         *\n+         * @param loadElementSnippets The array of Snippets used to load individual\n+         *                            element in the collection.\n+         * @return The Loadable snippet\n+         * @throws NullPointerException\n+         *\/\n@@ -196,5 +325,8 @@\n-     * Generate bytecode for pagination methods, then create the array inline and invoke the first page method to assign\n-     * values to the array. Each pagination method will assign value to the corresponding page and chain calling next\n-     * page.\n-     * {@code setup} must be called to generate the pagination methods in the owner class. Otherwise, {@code load} will\n-     * lead to {@link java.lang.NoSuchMethodException}\n+     * Generate bytecode to load an array of the given referene type onto the operand stack.\n+     *\n+     * The generated code will create an array inline, and then populate the array either inline or\n+     * by invoking the first pagination method if pagination is activated.\n+     *\n+     * If pagination is activated, pagination methods are generated with the given ClassBuilder\n+     * with method name formatted with the methodNamePrefix appended with page numberand.\n+     * Each pagination method will assign value to the corresponding page and chain calling next page.\n@@ -254,0 +386,2 @@\n+            Objects.requireNonNull(methodNamePrefix);\n+            Objects.requireNonNull(ownerClassDesc);\n@@ -268,3 +402,3 @@\n-                    mcob -> {\n-                        mcob.aload(0); \/\/ arrayref\n-                        fill(mcob, fromIndex, toIndex);\n+                    cob -> {\n+                        cob.aload(0); \/\/ arrayref\n+                        fill(cob, fromIndex, toIndex);\n@@ -272,1 +406,1 @@\n-                            mcob.invokestatic(\n+                            cob.invokestatic(\n@@ -277,1 +411,1 @@\n-                        mcob.areturn();\n+                        cob.return_(TypeKind.from(classDesc));\n@@ -281,1 +415,0 @@\n-\n@@ -294,1 +427,6 @@\n-    \/\/ Set support\n+    \/**\n+     * Generate bytecodes to load a set onto the operand stack.\n+     *\n+     * The Set is constructed with Set::of method. When there are more than 2\n+     * elements in the set, an array is constructed.\n+     *\/\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/Snippets.java","additions":166,"deletions":28,"binary":false,"changes":194,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import static jdk.tools.jlink.internal.Snippets.CollectionSnippetBuilder.STRING_PAGE_SIZE;\n@@ -49,0 +50,3 @@\n+\/**\n+ * Build a Snippet to load a ModuleDescriptor onto the operand stack.\n+ *\/\n@@ -55,1 +59,0 @@\n-    private static final int PAGING_THRESHOLD = 512;\n@@ -162,0 +165,1 @@\n+                    .enablePagination(\"module\" + index + \"Requires\")\n@@ -163,1 +167,0 @@\n-                    .activatePagingThreshold(PAGING_THRESHOLD)\n@@ -165,2 +168,0 @@\n-                    .methodNamePrefix(\"module\" + index + \"Requires\")\n-                    .pageSize(2000) \/\/ number safe for a single page helper under 64K size limit\n@@ -202,1 +203,0 @@\n-                    .activatePagingThreshold(PAGING_THRESHOLD)\n@@ -204,2 +204,1 @@\n-                    .methodNamePrefix(\"module\" + index + \"Exports\")\n-                    .pageSize(2000) \/\/ number safe for a single page helper under 64K size limit\n+                    .enablePagination(\"module\" + index + \"Exports\")\n@@ -242,1 +241,0 @@\n-                    .activatePagingThreshold(PAGING_THRESHOLD)\n@@ -244,2 +242,1 @@\n-                    .methodNamePrefix(\"module\" + index + \"Opens\")\n-                    .pageSize(2000) \/\/ number safe for a single page helper under 64K size limit\n+                    .enablePagination(\"module\" + index + \"Opens\")\n@@ -260,1 +257,0 @@\n-                        .activatePagingThreshold(PAGING_THRESHOLD)\n@@ -262,1 +258,1 @@\n-                        .methodNamePrefix(\"module\" + index + \"Provider\" + offset)\n+                        .enablePagination(\"module\" + index + \"Provider\" + offset)\n@@ -282,1 +278,0 @@\n-                    .activatePagingThreshold(PAGING_THRESHOLD)\n@@ -284,2 +279,1 @@\n-                    .methodNamePrefix(\"module\" + index + \"Provides\")\n-                    .pageSize(2000) \/\/ number safe for a single page helper under 64K size limit\n+                    .enablePagination(\"module\" + index + \"Provides\")\n@@ -292,1 +286,0 @@\n-                    .activatePagingThreshold(PAGING_THRESHOLD)\n@@ -294,1 +287,1 @@\n-                    .methodNamePrefix(\"module\" + index + \"Packages\")\n+                    .enablePagination(\"module\" + index + \"Packages\")\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/ModuleDescriptorBuilder.java","additions":10,"deletions":17,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -90,0 +90,2 @@\n+import static jdk.tools.jlink.internal.Snippets.CollectionSnippetBuilder.ENUM_PAGE_SIZE;\n+import static jdk.tools.jlink.internal.Snippets.CollectionSnippetBuilder.STRING_PAGE_SIZE;\n@@ -334,1 +336,1 @@\n-        if (Boolean.parseBoolean(System.getProperty(\"JlinkDumpSystemModuleClass\", \"false\"))) {\n+        if (Boolean.parseBoolean(System.getProperty(\"jlink.dumpSystemModuleClass\", \"false\"))) {\n@@ -546,2 +548,0 @@\n-        static final int PAGING_THRESHOLD = 512; \/\/ An arbitrary number as this likely generate minimum ~4K code\n-\n@@ -566,0 +566,1 @@\n+        private final ArrayList<Snippet> clinitSnippets = new ArrayList<>();\n@@ -584,1 +585,1 @@\n-            for (Exports e : sorted(md.exports())) {\n+            for (Exports e : md.exports()) {\n@@ -590,1 +591,1 @@\n-            for (Opens opens : sorted(md.opens())) {\n+            for (Opens opens : md.opens()) {\n@@ -596,1 +597,1 @@\n-            for (Requires r : sorted(md.requires())) {\n+            for (Requires r : md.requires()) {\n@@ -617,3 +618,0 @@\n-                        \/\/ generate dedup set fields and provider methods\n-                        var dedupSets = genConstants(clb);\n-\n@@ -627,1 +625,1 @@\n-                        genModuleDescriptorsMethod(clb, dedupSets);\n+                        genModuleDescriptorsMethod(clb);\n@@ -640,0 +638,3 @@\n+\n+                        \/\/ generate static initializer\n+                        genClassInitializer(clb);\n@@ -658,4 +659,2 @@\n-        private DedupSet genConstants(ClassBuilder clb) {\n-            var dedupSet = dedupSetBuilder.build(clb);\n-            var clinitSnippet = dedupSet.cacheSetupSnippet();\n-            if (!clinitSnippet.isEmpty()) {\n+        private void genClassInitializer(ClassBuilder clb) {\n+            if (!clinitSnippets.isEmpty()) {\n@@ -667,1 +666,1 @@\n-                            clinitSnippet.get().emit(cob);\n+                            clinitSnippets.forEach(s -> s.emit(cob));\n@@ -671,1 +670,0 @@\n-            return dedupSet;\n@@ -710,1 +708,7 @@\n-        private void genModuleDescriptorsMethod(ClassBuilder clb, DedupSet dedupSets) {\n+        \/**\n+         * Generate bytecode for moduleDescriptors method\n+         *\/\n+        private void genModuleDescriptorsMethod(ClassBuilder clb) {\n+            var dedupSets = dedupSetBuilder.build(clb);\n+            dedupSets.cacheSetupSnippet().ifPresent(clinitSnippets::add);\n+\n@@ -715,1 +719,0 @@\n-                    .activatePagingThreshold(moduleDescriptorsPerMethod)\n@@ -717,2 +720,1 @@\n-                    .methodNamePrefix(\"sub\")\n-                    .pageSize(moduleDescriptorsPerMethod)\n+                    .enablePagination(\"sub\", moduleDescriptorsPerMethod)\n@@ -872,0 +874,1 @@\n+                        int setBuilt = 0;\n@@ -883,1 +886,1 @@\n-                                genImmutableSet(cob, s);\n+                                genImmutableSet(clb, cob, s, methodName + setBuilt++);\n@@ -910,1 +913,1 @@\n-                                genImmutableSet(cob, s);\n+                                genImmutableSet(clb, cob, s, methodName + setBuilt++);\n@@ -935,1 +938,1 @@\n-        private void genImmutableSet(CodeBuilder cob, Set<String> set) {\n+        private void genImmutableSet(ClassBuilder clb, CodeBuilder cob, Set<String> set, String methodNamePrefix) {\n@@ -938,0 +941,3 @@\n+                    .classBuilder(clb)\n+                    .ownerClassDesc(classDesc)\n+                    .enablePagination(methodNamePrefix, STRING_PAGE_SIZE)\n@@ -1035,1 +1041,3 @@\n-         * Wraps set creation, ensuring identical sets are properly deduplicated.\n+         * Snippets to load the deduplicated set onto the operand stack.\n+         * Set referenced more than once will be read from the cache, cacheSetupSnippet contains\n+         * the bytecode to populate that cache.\n@@ -1043,0 +1051,3 @@\n+        \/*\n+         * Wraps set creation, ensuring identical sets are properly deduplicated.\n+         *\/\n@@ -1061,2 +1072,2 @@\n-            * Add the given set of strings to this builder.\n-            *\/\n+             * Add the given set of strings to this builder.\n+             *\/\n@@ -1068,2 +1079,2 @@\n-            * Add the given set of Exports.Modifiers\n-            *\/\n+             * Add the given set of Exports.Modifiers\n+             *\/\n@@ -1075,2 +1086,2 @@\n-            * Add the given set of Opens.Modifiers\n-            *\/\n+             * Add the given set of Opens.Modifiers\n+             *\/\n@@ -1082,2 +1093,2 @@\n-            * Add the given set of Requires.Modifiers\n-            *\/\n+             * Add the given set of Requires.Modifiers\n+             *\/\n@@ -1088,0 +1099,4 @@\n+            \/*\n+             * Generate bytecode to load a set onto the operand stack.\n+             * Use cache if the set is references more than once.\n+             *\/\n@@ -1092,1 +1107,0 @@\n-                                .activatePagingThreshold(PAGING_THRESHOLD)\n@@ -1094,2 +1108,1 @@\n-                                .methodNamePrefix(\"dedupSet\" + setBuilt++)\n-                                .pageSize(STRING_PAGE_SIZE)\n+                                .enablePagination(\"dedupSet\" + setBuilt++, STRING_PAGE_SIZE)\n@@ -1099,0 +1112,15 @@\n+            \/*\n+             * Generate the mapping from a set to the bytecode loading the set onto the operand stack.\n+             * Ordering the sets to ensure same generated bytecode.\n+             *\/\n+            private Map<Set<String>, Snippet> buildStringSets(ClassBuilder clb, Map<Set<String>, SetReference<String>> map) {\n+                Map<Set<String>, Snippet> snippets = new HashMap<>(map.size());\n+                map.entrySet().stream()\n+                        .sorted(Map.Entry.comparingByValue())\n+                        .forEach(e -> snippets.put(e.getKey(), buildStringSet(clb, e.getValue())));\n+                return snippets;\n+            }\n+\n+            \/*\n+             * Enum set support\n+             *\/\n@@ -1103,1 +1131,0 @@\n-                                .activatePagingThreshold(PAGING_THRESHOLD)\n@@ -1105,2 +1132,1 @@\n-                                .methodNamePrefix(\"dedupSet\" + setBuilt++)\n-                                .pageSize(ENUM_PAGE_SIZE)\n+                                .enablePagination(\"dedupSet\" + setBuilt++, ENUM_PAGE_SIZE)\n@@ -1110,7 +1136,0 @@\n-            private Map<Set<String>, Snippet> buildStringSets(ClassBuilder clb, Map<Set<String>, SetReference<String>> map) {\n-                Map<Set<String>, Snippet> snippets = new HashMap<>(map.size());\n-                map.entrySet().forEach(entry -> snippets.put(entry.getKey(),\n-                        buildStringSet(clb, entry.getValue())));\n-                return snippets;\n-            }\n-\n@@ -1119,2 +1138,3 @@\n-                map.entrySet().forEach(entry -> snippets.put(entry.getKey(),\n-                        buildEnumSet(clb, entry.getValue())));\n+                map.entrySet().stream()\n+                        .sorted(Map.Entry.comparingByValue())\n+                        .forEach(e -> snippets.put(e.getKey(), buildEnumSet(clb, e.getValue())));\n@@ -1124,0 +1144,3 @@\n+            \/*\n+             * Build snippets for all sets and optionally the cache.\n+             *\/\n@@ -1135,5 +1158,3 @@\n-             * SetReference count references to the set, and use LoadableSet under the hood to\n-             * support paginiation as needed.\n-             * For sets referenced more than once, a cache is used to store the pre-built result\n-             * and load from there. Otherwise, the set is built in place and load onto the operand\n-             * stack.\n+             * SetReference count references to the set, and keeps sorted elements to ensure\n+             * generate same bytecode for a given set.\n+             * SetReference itself needs ordering to ensure generate same bytecode for the cache.\n@@ -1141,1 +1162,1 @@\n-            class SetReference<T extends Comparable<T>> {\n+            class SetReference<T extends Comparable<T>> implements Comparable<SetReference<T>> {\n@@ -1161,0 +1182,20 @@\n+\n+                @Override\n+                public int compareTo(SetReference<T> o) {\n+                    if (o == this) {\n+                        return 0;\n+                    }\n+                    if (elements.size() == o.elements.size()) {\n+                        var a1 = elements;\n+                        var a2 = o.elements;\n+                        for (int i = 0; i < elements.size(); i++) {\n+                            var r = a1.get(i).compareTo(a2.get(i));\n+                            if (r != 0) {\n+                                return r;\n+                            }\n+                        }\n+                        return 0;\n+                    } else {\n+                        return elements.size() - o.elements.size();\n+                    }\n+                }\n@@ -1163,0 +1204,4 @@\n+            \/**\n+             * Build an array to host sets referenced more than once so a given set will only be constructed once.\n+             * Transform the bytecode for loading the set onto the operand stack as needed.\n+             *\/\n@@ -1180,0 +1225,4 @@\n+                \/**\n+                 * Transform the bytecode for loading the set onto the operand stack.\n+                 * @param loadSnippet The origin snippet to load the set onto the operand stack.\n+                 *\/\n@@ -1190,16 +1239,14 @@\n-                * Adding provider methods to the class. For those set used more than once, built\n-                * once and keep the reference for later access.\n-                * Return a snippet to setup the cache <clinit>.\n-                *\n-                * The returned snippet would set up the set referenced more than once,\n-                *\n-                * static final Set[] dedupSetValues;\n-                *\n-                * static {\n-                *     dedupSetValues = new Set[countOfStoredValues];\n-                *     dedupSetValues[0] = Set.of(elements); \/\/ elements no more than SET_SIZE_THRESHOLD\n-                *     dedupSetValues[1] = dedup<setWithIndex>Provider(); \/\/ set elements more than SET_SIZE_THRESHOLD\n-                *     ...\n-                *     dedupSetValues[countOfStoredValues - 1] = ...\n-                * }\n-                *\/\n+                 * Facilitate the cache in the class. Return a snippet to populate the cache in <clinit>.\n+                 *\n+                 * The generated cache is essentially as the following:\n+                 *\n+                 * static final Set[] dedupSetValues;\n+                 *\n+                 * static {\n+                 *     dedupSetValues = new Set[countOfStoredValues];\n+                 *     dedupSetValues[0] = Set.of(elements); \/\/ for inline set\n+                 *     dedupSetValues[1] = dedupSet<setIndex>0(); \/\/ for paginated set\n+                 *     ...\n+                 *     dedupSetValues[countOfStoredValues - 1] = ...\n+                 * }\n+                 *\/\n@@ -1213,1 +1260,0 @@\n-                            .activatePagingThreshold(PAGING_THRESHOLD)\n@@ -1215,2 +1261,1 @@\n-                            .methodNamePrefix(VALUES_ARRAY)\n-                            .pageSize(2000)\n+                            .enablePagination(VALUES_ARRAY)\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/SystemModulesPlugin.java","additions":117,"deletions":72,"binary":false,"changes":189,"status":"modified"},{"patch":"@@ -121,1 +121,0 @@\n-                .activatePagingThreshold(expected.length - 1)\n@@ -123,2 +122,8 @@\n-                .methodNamePrefix(\"page\")\n-                .pageSize(100);\n+                .enablePagination(\"page\", 100);\n+\n+        try {\n+            instance.build(elementSnippets);\n+            fail(\"Should throw NPE without ClassBuilder\");\n+        } catch (NullPointerException npe) {\n+            \/\/ expected\n+        }\n@@ -130,1 +135,1 @@\n-        var loadable = instance.activatePagingThreshold(expected.length)\n+        var loadable = instance.disablePagination()\n@@ -132,2 +137,0 @@\n-                .methodNamePrefix(\"page\")\n-                .pageSize(100)\n@@ -165,1 +168,1 @@\n-        var loadable = setBuilder.activatePagingThreshold(all.size())\n+        var loadable = setBuilder.disablePagination()\n@@ -167,2 +170,0 @@\n-                .methodNamePrefix(methodNamePrefix)\n-                .pageSize(10)\n@@ -176,2 +177,1 @@\n-                .activatePagingThreshold(all.size() - 1)\n-                .pageSize(20)\n+                .enablePagination(methodNamePrefix, 20)\n@@ -190,4 +190,2 @@\n-                .activatePagingThreshold(1)\n-                .ownerClassDesc(testClassDesc)\n-                .methodNamePrefix(\"ArrayPage\")\n-                .pageSize(pageSize);\n+                .enablePagination(\"ArrayPage\", pageSize, 1)\n+                .ownerClassDesc(testClassDesc);\n@@ -209,0 +207,1 @@\n+                .disablePagination()\n@@ -212,0 +211,1 @@\n+        verifyPaginationMethods(supplier.getClass(), String.class, \"page\", 0);\n","filename":"test\/jdk\/tools\/jlink\/SnippetsTest.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"}]}