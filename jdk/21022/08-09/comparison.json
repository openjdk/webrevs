{"files":[{"patch":"@@ -28,2 +28,0 @@\n-import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n-import static java.lang.classfile.ClassFile.ACC_STATIC;\n@@ -32,4 +30,1 @@\n-import static java.lang.constant.ConstantDescs.CD_Integer;\n-import static java.lang.constant.ConstantDescs.CD_Object;\n-import static java.lang.constant.ConstantDescs.CD_Set;\n-import static java.lang.constant.ConstantDescs.CD_int;\n+import java.lang.constant.ConstantDesc;\n@@ -40,3 +35,0 @@\n-import java.util.function.BiConsumer;\n-\n-import jdk.tools.jlink.internal.Snippets.ElementLoader;\n@@ -44,0 +36,6 @@\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n+import static java.lang.constant.ConstantDescs.CD_Integer;\n+import static java.lang.constant.ConstantDescs.CD_Object;\n+import static java.lang.constant.ConstantDescs.CD_Set;\n+import static java.lang.constant.ConstantDescs.CD_int;\n@@ -48,2 +46,3 @@\n-    public static final ElementLoader<String> STRING_LOADER = ElementLoader.of(CodeBuilder::loadConstant);\n-    public static final ElementLoader<Integer> INTEGER_LOADER = (cob, value, index) -> {\n+    public static final CollectionElementBuilder<String> STRING_LOADER = (value, index) -> new Constant<>(value);\n+\n+    public static final CollectionElementBuilder<Integer> INTEGER_LOADER = (value, index) -> cob -> {\n@@ -52,1 +51,1 @@\n-        .invokestatic(ClassDesc.ofInternalName(\"java\/lang\/Integer\"), \"valueOf\", MethodTypeDesc.of(CD_Integer, CD_int));\n+           .invokestatic(ClassDesc.ofInternalName(\"java\/lang\/Integer\"), \"valueOf\", MethodTypeDesc.of(CD_Integer, CD_int));\n@@ -54,1 +53,23 @@\n-    public static final ElementLoader<Loadable> LOADABLE_LOADER = (cob, loadable, index) -> loadable.load(cob);\n+\n+    public static final CollectionElementBuilder<Loadable> LOADABLE_LOADER = (loadable, index) -> loadable;\n+\n+    \/**\n+     * Snippet of bytecodes\n+     *\/\n+    @FunctionalInterface\n+    public interface Snippet {\n+        \/**\n+         * Emit the bytecode snippet to the CodeBuilder.\n+         *\n+         * @param cob  The CodeBuilder the bytecode snippet.\n+         * @throws IllegalStateException If the snippet is not setup properly.\n+         *\/\n+        void emit(CodeBuilder cob);\n+\n+        \/**\n+         * Perpare a snippet needs some extra support like field or methods from the class.\n+         *\n+         * @param clb  The ClassBuilder to setup the helpers.\n+         *\/\n+        default void setup(ClassBuilder clb) {};\n+    }\n@@ -59,1 +80,1 @@\n-     * The {@link load} method\n+     * The {@link load#emit} method\n@@ -61,1 +82,1 @@\n-    public sealed interface Loadable {\n+    public sealed interface Loadable extends Snippet {\n@@ -66,1 +87,2 @@\n-        void load(CodeBuilder cob);\n+        @Override\n+        void emit(CodeBuilder cob);\n@@ -72,0 +94,1 @@\n+    }\n@@ -73,5 +96,6 @@\n-        \/**\n-         * Generate fields or methods needed to support the load of the Loadable.\n-         * @param clb  The ClassBuilder to setup the helpers.\n-         *\/\n-        default void setup(ClassBuilder clb) {};\n+    public record Constant<T extends ConstantDesc>(T value) implements Snippet {\n+        @Override\n+        public void emit(CodeBuilder cob) {\n+            cob.loadConstant(value);\n+        }\n+    }\n@@ -79,4 +103,10 @@\n-        \/**\n-         * Whether {@link setup} must be called to {@link load} properly.\n-         *\/\n-        default boolean doesRequireSetup() { return false; }\n+    public final record EnumConstant(Enum<?> o) implements Loadable {\n+        @Override\n+        public void emit(CodeBuilder cob) {\n+            cob.getstatic(classDesc(), o.name(), classDesc());\n+        }\n+\n+        @Override\n+        public ClassDesc classDesc() {\n+            return o.getClass().describeConstable().get();\n+        }\n@@ -95,3 +125,3 @@\n-    public record WrappedLoadable(Loadable value, ClassDesc ownerClass, String methodName, boolean isStatic) implements Loadable {\n-        public WrappedLoadable {\n-            if (value instanceof WrappedLoadable) {\n+    public final record LoadableProvider(Loadable value, ClassDesc ownerClass, String methodName, boolean isStatic) implements Loadable {\n+        public LoadableProvider {\n+            if (value instanceof LoadableProvider) {\n@@ -103,1 +133,1 @@\n-        public void load(CodeBuilder cob) {\n+        public void emit(CodeBuilder cob) {\n@@ -117,2 +147,1 @@\n-            clb.withMethodBody(\n-                    methodName,\n+            clb.withMethodBody(methodName,\n@@ -122,1 +151,1 @@\n-                        value.load(cob);\n+                        value.emit(cob);\n@@ -132,5 +161,0 @@\n-        @Override\n-        public boolean doesRequireSetup() {\n-            return true;\n-        }\n-\n@@ -145,39 +169,9 @@\n-    public record LoadableEnum(Enum<?> o) implements Loadable {\n-        @Override\n-        public void load(CodeBuilder cob) {\n-            cob.getstatic(classDesc(), o.name(), classDesc());\n-        }\n-\n-        @Override\n-        public ClassDesc classDesc() {\n-            return o.getClass().describeConstable().get();\n-        }\n-    }\n-\n-    \/**\n-     * A function to load an element of type {@code T} onto the operand stack.\n-     * @param cob  The {@link CodeBuilder} to generate load code.\n-     * @param element  The element to be load.\n-     * @param index  The index of the element in the containing collection.\n-     *\/\n-    public interface ElementLoader<T> {\n-        void load(CodeBuilder cob, T element, int index);\n-\n-        static <T> ElementLoader<T> of(BiConsumer<CodeBuilder, T> ignoreIndex) {\n-            return (cob, element, _) -> {\n-                ignoreIndex.accept(cob, element);\n-            };\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")\n-        static <T extends Loadable> ElementLoader<T> selfLoader() {\n-            return (ElementLoader<T>) LOADABLE_LOADER;\n-        }\n-    }\n-\n-    \/**\n-     * Return a snippet builder that loads an enum onto the operand stack using\n-     * the enum name static final field\n-     *\/\n-    public static <T extends Enum<T>> ElementLoader<T> getEnumLoader(ClassDesc enumClassDesc) {\n-        return (cob, element, _) -> cob.getstatic(enumClassDesc, element.name(), enumClassDesc);\n+    @FunctionalInterface\n+    public interface CollectionElementBuilder<T> {\n+        \/**\n+         * Build a snippet to load the element onto the operand stack.\n+         * @param element  The element to be load.\n+         * @param index  The index of the element in the containing collection.\n+         * @return A snippet of bytecodes to load the element onto the operand stack.\n+         *\/\n+        Snippet build(T element, int index);\n@@ -195,2 +189,2 @@\n-         * @param elementLoader  The loader function to load a single element onto operand stack to\n-         *                       be stored at given index\n+         * @param elementLoader  The snippet builder to generate bytecodes to load an element onto\n+         *                       the operand stack\n@@ -208,1 +202,1 @@\n-                                    ElementLoader<T> elementLoader,\n+                                    CollectionElementBuilder<T> elementLoader,\n@@ -226,2 +220,1 @@\n-        protected final Collection<T> elements;\n-        protected final ElementLoader<T> elementLoader;\n+        protected final ArrayList<Snippet> loadElementSnippets;\n@@ -229,1 +222,1 @@\n-        public AbstractLoadableArray(ClassDesc elementType, Collection<T> elements, ElementLoader<T> elementLoader) {\n+        public AbstractLoadableArray(ClassDesc elementType, Collection<T> elements, CollectionElementBuilder<T> elementLoader) {\n@@ -231,2 +224,6 @@\n-            this.elements = elements;\n-            this.elementLoader = elementLoader;\n+            loadElementSnippets = new ArrayList<>(elements.size());\n+            for (var element: elements) {\n+                loadElementSnippets.add(elementLoader.build(element, loadElementSnippets.size()));\n+            }\n+\n+            assert(loadElementSnippets.size() == elements.size());\n@@ -240,2 +237,7 @@\n-        protected void fill(CodeBuilder cob, Iterable<T> elements, int offset) {\n-            for (T t : elements) {\n+        @Override\n+        public void setup(ClassBuilder clb) {\n+            loadElementSnippets.forEach(s -> s.setup(clb));\n+        }\n+\n+        protected void fill(CodeBuilder cob, int fromIndex, int toIndex) {\n+            for (var index = fromIndex; index < toIndex; index++) {\n@@ -243,2 +245,2 @@\n-                   .loadConstant(offset);\n-                elementLoader.load(cob, t, offset);  \/\/ value\n+                   .loadConstant(index);\n+                loadElementSnippets.get(index).emit(cob);  \/\/ value\n@@ -246,1 +248,0 @@\n-                offset++;\n@@ -256,1 +257,1 @@\n-        public SimpleArray(ClassDesc elementType, T[] elements, ElementLoader<T> elementLoader) {\n+        public SimpleArray(ClassDesc elementType, T[] elements, CollectionElementBuilder<T> elementLoader) {\n@@ -260,1 +261,1 @@\n-        public SimpleArray(ClassDesc elementType, Collection<T> elements, ElementLoader<T> elementLoader) {\n+        public SimpleArray(ClassDesc elementType, Collection<T> elements, CollectionElementBuilder<T> elementLoader) {\n@@ -265,2 +266,2 @@\n-        public void load(CodeBuilder cob) {\n-            cob.loadConstant(elements.size())\n+        public void emit(CodeBuilder cob) {\n+            cob.loadConstant(loadElementSnippets.size())\n@@ -268,1 +269,1 @@\n-            fill(cob, elements, 0);\n+            fill(cob, 0, loadElementSnippets.size());\n@@ -301,1 +302,1 @@\n-                              ElementLoader<T> elementLoader,\n+                              CollectionElementBuilder<T> elementLoader,\n@@ -315,1 +316,1 @@\n-                              ElementLoader<T> elementLoader,\n+                              CollectionElementBuilder<T> elementLoader,\n@@ -327,1 +328,1 @@\n-        public void load(CodeBuilder cob) {\n+        public void emit(CodeBuilder cob) {\n@@ -329,1 +330,1 @@\n-            cob.loadConstant(elements.size())\n+            cob.loadConstant(loadElementSnippets.size())\n@@ -334,0 +335,3 @@\n+        \/**\n+         * Generate helper methods to fill each page\n+         *\/\n@@ -336,5 +340,2 @@\n-            var pages = paginate(elements, pageSize);\n-\n-            assert(pages.size() == pageCount());\n-\n-            var lastPageNo = pages.size() - 1;\n+            super.setup(clb);\n+            var lastPageNo = pageCount() - 1;\n@@ -342,1 +343,1 @@\n-                genFillPageHelper(clb, pages.get(pageNo), pageNo, pageNo < lastPageNo);\n+                genFillPageHelper(clb, pageNo, pageNo < lastPageNo);\n@@ -346,3 +347,0 @@\n-        @Override\n-        public boolean doesRequireSetup() { return true; }\n-\n@@ -351,4 +349,4 @@\n-        private void genFillPageHelper(ClassBuilder clb, Collection<T> pageElements, int pageNo, boolean hasNextPage) {\n-            var offset = pageSize * pageNo;\n-            clb.withMethodBody(\n-                    methodNamePrefix + pageNo,\n+        private void genFillPageHelper(ClassBuilder clb, int pageNo, boolean hasNextPage) {\n+            var fromIndex = pageSize * pageNo;\n+            var toIndex = hasNextPage ? (fromIndex + pageSize) : loadElementSnippets.size();\n+            clb.withMethodBody(methodNamePrefix + pageNo,\n@@ -359,1 +357,1 @@\n-                        fill(mcob, pageElements, offset);\n+                        fill(mcob, fromIndex, toIndex);\n@@ -371,1 +369,1 @@\n-            return (elements.size() % pageSize) != 0;\n+            return (loadElementSnippets.size() % pageSize) != 0;\n@@ -375,1 +373,1 @@\n-            var pages = elements.size() \/ pageSize;\n+            var pages = loadElementSnippets.size() \/ pageSize;\n@@ -385,1 +383,1 @@\n-        static <T> LoadableSet of(Collection<T> elements, ElementLoader<T> loader) {\n+        static <T> LoadableSet of(Collection<T> elements, CollectionElementBuilder<T> loader) {\n@@ -399,1 +397,1 @@\n-                                  ElementLoader<T> loader,\n+                                  CollectionElementBuilder<T> loader,\n@@ -425,2 +423,1 @@\n-        Collection<T> elements;\n-        ElementLoader<T> loader;\n+        ArrayList<Snippet> loadElementSnippets;\n@@ -428,1 +425,1 @@\n-        TinySet(Collection<T> elements, ElementLoader<T> loader) {\n+        TinySet(Collection<T> elements, CollectionElementBuilder<T> loader) {\n@@ -433,2 +430,4 @@\n-            this.elements = elements;\n-            this.loader = loader;\n+            loadElementSnippets = new ArrayList<>(elements.size());\n+            for (T e: elements) {\n+                loadElementSnippets.add(loader.build(e, loadElementSnippets.size()));\n+            }\n@@ -438,4 +437,3 @@\n-        public void load(CodeBuilder cob) {\n-            var index = 0;\n-            for (T t : elements) {\n-                loader.load(cob, t, index++);\n+        public void emit(CodeBuilder cob) {\n+            for (var snippet: loadElementSnippets) {\n+                snippet.emit(cob);\n@@ -443,1 +441,1 @@\n-            var mtdArgs = new ClassDesc[elements.size()];\n+            var mtdArgs = new ClassDesc[loadElementSnippets.size()];\n@@ -447,0 +445,7 @@\n+\n+        @Override\n+        public void setup(ClassBuilder clb) {\n+            for (var snippet: loadElementSnippets) {\n+                snippet.setup(clb);\n+            }\n+        }\n@@ -457,2 +462,2 @@\n-        public void load(CodeBuilder cob) {\n-            elements.load(cob);\n+        public void emit(CodeBuilder cob) {\n+            elements.emit(cob);\n@@ -462,5 +467,0 @@\n-        @Override\n-        public boolean doesRequireSetup() {\n-            return elements.doesRequireSetup();\n-        }\n-\n@@ -472,17 +472,0 @@\n-\n-    \/\/ utilities\n-    private static <T> ArrayList<ArrayList<T>> paginate(Iterable<T> elements, int pageSize) {\n-        ArrayList<ArrayList<T>> pages = new ArrayList<>(pageSize);\n-        ArrayList<T> currentPage = null;\n-        var index = 0;\n-        for (T element: elements) {\n-            if (index % pageSize == 0) {\n-                currentPage = new ArrayList<>();\n-                pages.add(currentPage);\n-            }\n-            currentPage.add(element);\n-            index++;\n-        }\n-\n-        return pages;\n-    }\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/Snippets.java","additions":133,"deletions":150,"binary":false,"changes":283,"status":"modified"},{"patch":"@@ -0,0 +1,416 @@\n+\/*\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.tools.jlink.internal.plugins;\n+\n+import java.lang.classfile.ClassBuilder;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.constant.ClassDesc;\n+import static java.lang.constant.ConstantDescs.*;\n+\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.module.ModuleDescriptor;\n+import java.lang.module.ModuleDescriptor.Exports;\n+import java.lang.module.ModuleDescriptor.Opens;\n+import java.lang.module.ModuleDescriptor.Provides;\n+import java.lang.module.ModuleDescriptor.Requires;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+\n+import jdk.tools.jlink.internal.Snippets.LoadableArray;\n+import jdk.tools.jlink.internal.Snippets.LoadableSet;\n+import static jdk.tools.jlink.internal.Snippets.STRING_LOADER;\n+import static jdk.tools.jlink.internal.Snippets.STRING_PAGE_SIZE;\n+import jdk.tools.jlink.internal.Snippets.Snippet;\n+\n+import jdk.tools.jlink.internal.plugins.SystemModulesPlugin.ModuleInfo;\n+import jdk.tools.jlink.internal.plugins.SystemModulesPlugin.SystemModulesClassGenerator.DedupSetBuilder;\n+\n+class ModuleDescriptorBuilder {\n+    private static final ClassDesc CD_MODULE_DESCRIPTOR =\n+        ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor\");\n+    private static final ClassDesc CD_MODULE_BUILDER =\n+        ClassDesc.ofInternalName(\"jdk\/internal\/module\/Builder\");\n+\n+    private static final int PAGING_THRESHOLD = 512;\n+    private final DedupSetBuilder dedupSetBuilder;\n+    private final ClassDesc ownerClassDesc;\n+\n+    ModuleDescriptorBuilder(DedupSetBuilder dedupSetBuilder, ClassDesc ownerClassDesc) {\n+        this.dedupSetBuilder = dedupSetBuilder;\n+        this.ownerClassDesc = ownerClassDesc;\n+    }\n+\n+    public Snippet build(ModuleInfo moduleInfo, int index) {\n+        return new ModuleDescriptorSnippet(moduleInfo.descriptor(), moduleInfo.packages(), index);\n+    }\n+\n+    class ModuleDescriptorSnippet implements Snippet {\n+        static final ClassDesc CD_EXPORTS =\n+            ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Exports\");\n+        static final ClassDesc CD_OPENS =\n+            ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Opens\");\n+        static final ClassDesc CD_PROVIDES =\n+            ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Provides\");\n+        static final ClassDesc CD_REQUIRES =\n+            ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Requires\");\n+\n+        \/\/ method signature for static Builder::newExports, newOpens,\n+        \/\/ newProvides, newRequires methods\n+        static final MethodTypeDesc MTD_EXPORTS_MODIFIER_SET_STRING_SET =\n+            MethodTypeDesc.of(CD_EXPORTS, CD_Set, CD_String, CD_Set);\n+        static final MethodTypeDesc MTD_EXPORTS_MODIFIER_SET_STRING =\n+            MethodTypeDesc.of(CD_EXPORTS, CD_Set, CD_String);\n+        static final MethodTypeDesc MTD_OPENS_MODIFIER_SET_STRING_SET =\n+            MethodTypeDesc.of(CD_OPENS, CD_Set, CD_String, CD_Set);\n+        static final MethodTypeDesc MTD_OPENS_MODIFIER_SET_STRING =\n+            MethodTypeDesc.of(CD_OPENS, CD_Set, CD_String);\n+        static final MethodTypeDesc MTD_PROVIDES_STRING_LIST =\n+            MethodTypeDesc.of(CD_PROVIDES, CD_String, CD_List);\n+        static final MethodTypeDesc MTD_REQUIRES_SET_STRING =\n+            MethodTypeDesc.of(CD_REQUIRES, CD_Set, CD_String);\n+        static final MethodTypeDesc MTD_REQUIRES_SET_STRING_STRING =\n+            MethodTypeDesc.of(CD_REQUIRES, CD_Set, CD_String, CD_String);\n+\n+        \/\/ method signature for Builder instance methods that\n+        \/\/ return this Builder instance\n+        static final MethodTypeDesc MTD_EXPORTS_ARRAY =\n+            MethodTypeDesc.of(CD_MODULE_BUILDER, CD_EXPORTS.arrayType());\n+        static final MethodTypeDesc MTD_OPENS_ARRAY =\n+            MethodTypeDesc.of(CD_MODULE_BUILDER, CD_OPENS.arrayType());\n+        static final MethodTypeDesc MTD_PROVIDES_ARRAY =\n+            MethodTypeDesc.of(CD_MODULE_BUILDER, CD_PROVIDES.arrayType());\n+        static final MethodTypeDesc MTD_REQUIRES_ARRAY =\n+            MethodTypeDesc.of(CD_MODULE_BUILDER, CD_REQUIRES.arrayType());\n+        static final MethodTypeDesc MTD_SET = MethodTypeDesc.of(CD_MODULE_BUILDER, CD_Set);\n+        static final MethodTypeDesc MTD_STRING = MethodTypeDesc.of(CD_MODULE_BUILDER, CD_String);\n+        static final MethodTypeDesc MTD_BOOLEAN = MethodTypeDesc.of(CD_MODULE_BUILDER, CD_boolean);\n+        static final MethodTypeDesc MTD_void_String = MethodTypeDesc.of(CD_void, CD_String);\n+        static final MethodTypeDesc MTD_ModuleDescriptor_int = MethodTypeDesc.of(CD_MODULE_DESCRIPTOR, CD_int);\n+        static final MethodTypeDesc MTD_List_ObjectArray = MethodTypeDesc.of(CD_List, CD_Object.arrayType());\n+\n+        final ModuleDescriptor md;\n+        final Set<String> packages;\n+        final int index;\n+        final Snippet requiresArray;\n+        final Snippet exportsArray;\n+        final Snippet opensArray;\n+        final Snippet providesArray;\n+        final Snippet packagesSet;\n+\n+        ModuleDescriptorSnippet(ModuleDescriptor md, Set<String> packages, int index) {\n+            if (md.isAutomatic()) {\n+                throw new InternalError(\"linking automatic module is not supported\");\n+            }\n+\n+            this.md = md;\n+            this.packages = packages;\n+            this.index = index;\n+            requiresArray = buildRequiresArray();\n+            exportsArray = buildExportsArray();\n+            opensArray = buildOpensArray();\n+            providesArray = buildProvidesArray();\n+            packagesSet = buildPackagesSet();\n+        }\n+\n+        \/*\n+         * Invoke Builder.newRequires(Set<Modifier> mods, String mn, String compiledVersion)\n+         *\n+         * Set<Modifier> mods = ...\n+         * Builder.newRequires(mods, mn, compiledVersion);\n+         *\/\n+        Snippet loadRequire(Requires require, int unused) {\n+            return cob -> {\n+                dedupSetBuilder.loadRequiresModifiers(cob, require.modifiers());\n+                cob.loadConstant(require.name());\n+                if (require.compiledVersion().isPresent()) {\n+                    cob.loadConstant(require.compiledVersion().get().toString())\n+                    .invokestatic(CD_MODULE_BUILDER,\n+                                    \"newRequires\",\n+                                    MTD_REQUIRES_SET_STRING_STRING);\n+                } else {\n+                    cob.invokestatic(CD_MODULE_BUILDER,\n+                                    \"newRequires\",\n+                                    MTD_REQUIRES_SET_STRING);\n+                }\n+            };\n+        }\n+\n+        private LoadableArray buildRequiresArray() {\n+            return LoadableArray.of(\n+                    CD_REQUIRES,\n+                    sorted(md.requires()),\n+                    this::loadRequire,\n+                    PAGING_THRESHOLD,\n+                    ownerClassDesc,\n+                    \"module\" + index + \"Requires\",\n+                    \/\/ number safe for a single page helper under 64K size limit\n+                    2000);\n+        }\n+\n+        \/*\n+         * Invoke\n+         *     Builder.newExports(Set<Exports.Modifier> ms, String pn,\n+         *                        Set<String> targets)\n+         * or\n+         *     Builder.newExports(Set<Exports.Modifier> ms, String pn)\n+         *\n+         * ms = export.modifiers()\n+         * pn = export.source()\n+         * targets = export.targets()\n+         *\/\n+        Snippet loadExports(Exports export, int unused) {\n+            return cob -> {\n+                dedupSetBuilder.loadExportsModifiers(cob, export.modifiers());\n+                cob.loadConstant(export.source());\n+                var targets = export.targets();\n+                if (!targets.isEmpty()) {\n+                    dedupSetBuilder.loadStringSet(cob, targets);\n+                    cob.invokestatic(CD_MODULE_BUILDER,\n+                                    \"newExports\",\n+                                    MTD_EXPORTS_MODIFIER_SET_STRING_SET);\n+                } else {\n+                    cob.invokestatic(CD_MODULE_BUILDER,\n+                                    \"newExports\",\n+                                    MTD_EXPORTS_MODIFIER_SET_STRING);\n+                }\n+            };\n+        }\n+\n+        private LoadableArray buildExportsArray() {\n+            return LoadableArray.of(\n+                    CD_EXPORTS,\n+                    sorted(md.exports()),\n+                    this::loadExports,\n+                    PAGING_THRESHOLD,\n+                    ownerClassDesc,\n+                    \"module\" + index + \"Exports\",\n+                    \/\/ number safe for a single page helper under 64K size limit\n+                    2000);\n+        }\n+\n+        \/*\n+         * Invoke\n+         *     Builder.newOpens(Set<Opens.Modifier> ms, String pn,\n+         *                        Set<String> targets)\n+         * or\n+         *     Builder.newOpens(Set<Opens.Modifier> ms, String pn)\n+         *\n+         * ms = open.modifiers()\n+         * pn = open.source()\n+         * targets = open.targets()\n+         * Builder.newOpens(mods, pn, targets);\n+         *\/\n+        Snippet loadOpens(Opens open, int unused) {\n+            return cob -> {\n+                dedupSetBuilder.loadOpensModifiers(cob, open.modifiers());\n+                cob.loadConstant(open.source());\n+                var targets = open.targets();\n+                if (!targets.isEmpty()) {\n+                    dedupSetBuilder.loadStringSet(cob, targets);\n+                    cob.invokestatic(CD_MODULE_BUILDER,\n+                                    \"newOpens\",\n+                                    MTD_OPENS_MODIFIER_SET_STRING_SET);\n+                } else {\n+                    cob.invokestatic(CD_MODULE_BUILDER,\n+                                    \"newOpens\",\n+                                    MTD_OPENS_MODIFIER_SET_STRING);\n+                }\n+            };\n+        }\n+\n+        private LoadableArray buildOpensArray() {\n+            return LoadableArray.of(\n+                    CD_OPENS,\n+                    sorted(md.opens()),\n+                    this::loadOpens,\n+                    PAGING_THRESHOLD,\n+                    ownerClassDesc,\n+                    \"module\" + index + \"Opens\",\n+                    \/\/ number safe for a single page helper under 64K size limit\n+                    2000);\n+        }\n+\n+        \/*\n+         * Invoke Builder.newProvides(String service, List<String> providers)\n+         *\n+         * service = provide.service()\n+         * providers = List.of(new String[] { provide.providers() }\n+         * Builder.newProvides(service, providers);\n+         *\/\n+        private Snippet loadProvides(Provides provide, int offset) {\n+            return cob -> {\n+                var providersArray = LoadableArray.of(\n+                        CD_String,\n+                        provide.providers(),\n+                        STRING_LOADER,\n+                        PAGING_THRESHOLD,\n+                        ownerClassDesc,\n+                        \"module\" + index + \"Provider\" + offset,\n+                        STRING_PAGE_SIZE);\n+\n+                cob.loadConstant(provide.service());\n+                providersArray.emit(cob);\n+                cob.invokestatic(CD_List,\n+                                \"of\",\n+                                MTD_List_ObjectArray,\n+                                true)\n+                .invokestatic(CD_MODULE_BUILDER,\n+                                \"newProvides\",\n+                                MTD_PROVIDES_STRING_LIST);\n+            };\n+        }\n+\n+        private LoadableArray buildProvidesArray() {\n+            return LoadableArray.of(\n+                    CD_PROVIDES,\n+                    sorted(md.provides()),\n+                    this::loadProvides,\n+                    PAGING_THRESHOLD,\n+                    ownerClassDesc,\n+                    \"module\" + index + \"Provides\",\n+                    \/\/ number safe for a single page helper under 64K size limit\n+                    2000);\n+        }\n+\n+        private LoadableSet buildPackagesSet() {\n+            return LoadableSet.of(\n+                    sorted(packages),\n+                    STRING_LOADER,\n+                    PAGING_THRESHOLD,\n+                    ownerClassDesc,\n+                    \"module\" + index + \"Packages\",\n+                    STRING_PAGE_SIZE);\n+        }\n+\n+        @Override\n+        public void setup(ClassBuilder clb) {\n+            requiresArray.setup(clb);\n+            exportsArray.setup(clb);\n+            opensArray.setup(clb);\n+            providesArray.setup(clb);\n+            packagesSet.setup(clb);\n+        }\n+\n+        @Override\n+        public void emit(CodeBuilder cob) {\n+            \/\/ new jdk.internal.module.Builder\n+            cob.new_(CD_MODULE_BUILDER)\n+               .dup()\n+               .loadConstant(md.name())\n+               .invokespecial(CD_MODULE_BUILDER,\n+                              INIT_NAME,\n+                              MTD_void_String);\n+            if (md.isOpen()) {\n+                setModuleBit(cob, \"open\", true);\n+            }\n+            if (md.modifiers().contains(ModuleDescriptor.Modifier.SYNTHETIC)) {\n+                setModuleBit(cob, \"synthetic\", true);\n+            }\n+            if (md.modifiers().contains(ModuleDescriptor.Modifier.MANDATED)) {\n+                setModuleBit(cob, \"mandated\", true);\n+            }\n+\n+            \/\/ requires\n+            requiresArray.emit(cob);\n+            cob.invokevirtual(CD_MODULE_BUILDER,\n+                              \"requires\",\n+                              MTD_REQUIRES_ARRAY);\n+\n+            \/\/ exports\n+            exportsArray.emit(cob);\n+            cob.invokevirtual(CD_MODULE_BUILDER,\n+                    \"exports\",\n+                    MTD_EXPORTS_ARRAY);\n+\n+            \/\/ opens\n+            opensArray.emit(cob);\n+            cob.invokevirtual(CD_MODULE_BUILDER,\n+                              \"opens\",\n+                              MTD_OPENS_ARRAY);\n+\n+            \/\/ uses\n+            dedupSetBuilder.loadStringSet(cob, md.uses());\n+            cob.invokevirtual(CD_MODULE_BUILDER,\n+                              \"uses\",\n+                              MTD_SET);\n+\n+            \/\/ provides\n+            providesArray.emit(cob);\n+            cob.invokevirtual(CD_MODULE_BUILDER,\n+                              \"provides\",\n+                              MTD_PROVIDES_ARRAY);\n+\n+            \/\/ all packages\n+            packagesSet.emit(cob);\n+            cob.invokevirtual(CD_MODULE_BUILDER,\n+                              \"packages\",\n+                              MTD_SET);\n+\n+            \/\/ version\n+            md.version().ifPresent(v -> setModuleProperty(cob, \"version\", v.toString()));\n+\n+            \/\/ main class\n+            md.mainClass().ifPresent(cn -> setModuleProperty(cob, \"mainClass\", cn));\n+\n+            cob.loadConstant(md.hashCode())\n+               .invokevirtual(CD_MODULE_BUILDER,\n+                              \"build\",\n+                              MTD_ModuleDescriptor_int);\n+        }\n+\n+        \/*\n+         * Invoke Builder.<methodName>(boolean value)\n+         *\/\n+        void setModuleBit(CodeBuilder cob, String methodName, boolean value) {\n+            cob.loadConstant(value ? 1 : 0)\n+               .invokevirtual(CD_MODULE_BUILDER,\n+                              methodName,\n+                              MTD_BOOLEAN);\n+        }\n+\n+        void setModuleProperty(CodeBuilder cob, String methodName, String value) {\n+            cob.loadConstant(value)\n+               .invokevirtual(CD_MODULE_BUILDER,\n+                              methodName,\n+                              MTD_STRING);\n+        }\n+    }\n+\n+    \/**\n+     * Returns a sorted copy of a collection.\n+     *\n+     * This is useful to ensure a deterministic iteration order.\n+     *\n+     * @return a sorted copy of the given collection.\n+     *\/\n+    private static <T extends Comparable<T>> List<T> sorted(Collection<T> c) {\n+        var l = new ArrayList<>(c);\n+        Collections.sort(l);\n+        return l;\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/ModuleDescriptorBuilder.java","additions":416,"deletions":0,"binary":false,"changes":416,"status":"added"},{"patch":"@@ -1,437 +0,0 @@\n-\/*\n- * Copyright (c) 2024, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.tools.jlink.internal.plugins;\n-\n-import java.lang.classfile.ClassBuilder;\n-import java.lang.classfile.CodeBuilder;\n-import java.lang.constant.ClassDesc;\n-import static java.lang.constant.ConstantDescs.*;\n-\n-import java.lang.constant.MethodTypeDesc;\n-import java.lang.module.ModuleDescriptor;\n-import java.lang.module.ModuleDescriptor.Exports;\n-import java.lang.module.ModuleDescriptor.Opens;\n-import java.lang.module.ModuleDescriptor.Provides;\n-import java.lang.module.ModuleDescriptor.Requires;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.function.Consumer;\n-\n-import jdk.tools.jlink.internal.Snippets.ElementLoader;\n-import jdk.tools.jlink.internal.Snippets.Loadable;\n-import jdk.tools.jlink.internal.Snippets.LoadableArray;\n-import jdk.tools.jlink.internal.Snippets.LoadableSet;\n-import static jdk.tools.jlink.internal.Snippets.STRING_LOADER;\n-import static jdk.tools.jlink.internal.Snippets.STRING_PAGE_SIZE;\n-\n-import jdk.tools.jlink.internal.plugins.SystemModulesPlugin.ModuleInfo;\n-import jdk.tools.jlink.internal.plugins.SystemModulesPlugin.SystemModulesClassGenerator.DedupSetBuilder;\n-\n-class ModuleInfoLoader implements ElementLoader<ModuleInfo> {\n-    private static final ClassDesc CD_MODULE_DESCRIPTOR =\n-        ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor\");\n-    private static final ClassDesc CD_MODULE_BUILDER =\n-        ClassDesc.ofInternalName(\"jdk\/internal\/module\/Builder\");\n-\n-    private static final int PAGING_THRESHOLD = 512;\n-    private final DedupSetBuilder dedupSetBuilder;\n-    private final ClassDesc ownerClassDesc;\n-    private final ArrayList<Consumer<ClassBuilder>> amendments = new ArrayList<>();\n-\n-    ModuleInfoLoader(DedupSetBuilder dedupSetBuilder, ClassDesc ownerClassDesc) {\n-        this.dedupSetBuilder = dedupSetBuilder;\n-        this.ownerClassDesc = ownerClassDesc;\n-    }\n-\n-    @Override\n-    public void load(CodeBuilder cob, ModuleInfo moduleInfo, int index) {\n-        var mdBuilder = new ModuleDescriptorBuilder(moduleInfo.descriptor(), moduleInfo.packages(), index);\n-        mdBuilder.load(cob);\n-        if (mdBuilder.doesRequireSetup()) {\n-            amendments.add(mdBuilder::setup);\n-        }\n-    }\n-\n-    public void finish(ClassBuilder clb) {\n-        amendments.forEach(a -> a.accept(clb));\n-    }\n-\n-    class ModuleDescriptorBuilder {\n-        static final ClassDesc CD_EXPORTS =\n-            ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Exports\");\n-        static final ClassDesc CD_OPENS =\n-            ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Opens\");\n-        static final ClassDesc CD_PROVIDES =\n-            ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Provides\");\n-        static final ClassDesc CD_REQUIRES =\n-            ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Requires\");\n-\n-        \/\/ method signature for static Builder::newExports, newOpens,\n-        \/\/ newProvides, newRequires methods\n-        static final MethodTypeDesc MTD_EXPORTS_MODIFIER_SET_STRING_SET =\n-            MethodTypeDesc.of(CD_EXPORTS, CD_Set, CD_String, CD_Set);\n-        static final MethodTypeDesc MTD_EXPORTS_MODIFIER_SET_STRING =\n-            MethodTypeDesc.of(CD_EXPORTS, CD_Set, CD_String);\n-        static final MethodTypeDesc MTD_OPENS_MODIFIER_SET_STRING_SET =\n-            MethodTypeDesc.of(CD_OPENS, CD_Set, CD_String, CD_Set);\n-        static final MethodTypeDesc MTD_OPENS_MODIFIER_SET_STRING =\n-            MethodTypeDesc.of(CD_OPENS, CD_Set, CD_String);\n-        static final MethodTypeDesc MTD_PROVIDES_STRING_LIST =\n-            MethodTypeDesc.of(CD_PROVIDES, CD_String, CD_List);\n-        static final MethodTypeDesc MTD_REQUIRES_SET_STRING =\n-            MethodTypeDesc.of(CD_REQUIRES, CD_Set, CD_String);\n-        static final MethodTypeDesc MTD_REQUIRES_SET_STRING_STRING =\n-            MethodTypeDesc.of(CD_REQUIRES, CD_Set, CD_String, CD_String);\n-\n-        \/\/ method signature for Builder instance methods that\n-        \/\/ return this Builder instance\n-        static final MethodTypeDesc MTD_EXPORTS_ARRAY =\n-            MethodTypeDesc.of(CD_MODULE_BUILDER, CD_EXPORTS.arrayType());\n-        static final MethodTypeDesc MTD_OPENS_ARRAY =\n-            MethodTypeDesc.of(CD_MODULE_BUILDER, CD_OPENS.arrayType());\n-        static final MethodTypeDesc MTD_PROVIDES_ARRAY =\n-            MethodTypeDesc.of(CD_MODULE_BUILDER, CD_PROVIDES.arrayType());\n-        static final MethodTypeDesc MTD_REQUIRES_ARRAY =\n-            MethodTypeDesc.of(CD_MODULE_BUILDER, CD_REQUIRES.arrayType());\n-        static final MethodTypeDesc MTD_SET = MethodTypeDesc.of(CD_MODULE_BUILDER, CD_Set);\n-        static final MethodTypeDesc MTD_STRING = MethodTypeDesc.of(CD_MODULE_BUILDER, CD_String);\n-        static final MethodTypeDesc MTD_BOOLEAN = MethodTypeDesc.of(CD_MODULE_BUILDER, CD_boolean);\n-        static final MethodTypeDesc MTD_void_String = MethodTypeDesc.of(CD_void, CD_String);\n-        static final MethodTypeDesc MTD_ModuleDescriptor_int = MethodTypeDesc.of(CD_MODULE_DESCRIPTOR, CD_int);\n-        static final MethodTypeDesc MTD_List_ObjectArray = MethodTypeDesc.of(CD_List, CD_Object.arrayType());\n-\n-\n-        final ModuleDescriptor md;\n-        final Set<String> packages;\n-        final int index;\n-        Consumer<ClassBuilder> amendment;\n-\n-        ModuleDescriptorBuilder(ModuleDescriptor md, Set<String> packages, int index) {\n-            if (md.isAutomatic()) {\n-                throw new InternalError(\"linking automatic module is not supported\");\n-            }\n-\n-\n-            this.md = md;\n-            this.packages = packages;\n-            this.index = index;\n-        }\n-\n-        private LoadableArray requiresArray() {\n-            var requiresArray = LoadableArray.of(\n-                    CD_REQUIRES,\n-                    sorted(md.requires()),\n-                    this::newRequires,\n-                    PAGING_THRESHOLD,\n-                    ownerClassDesc,\n-                    \"module\" + index + \"Requires\",\n-                    \/\/ number safe for a single page helper under 64K size limit\n-                    2000);\n-\n-            setupLoadable(requiresArray);\n-            return requiresArray;\n-        }\n-\n-        private LoadableArray exportArray() {\n-            var exportArray = LoadableArray.of(\n-                    CD_EXPORTS,\n-                    sorted(md.exports()),\n-                    this::loadExports,\n-                    PAGING_THRESHOLD,\n-                    ownerClassDesc,\n-                    \"module\" + index + \"Exports\",\n-                    \/\/ number safe for a single page helper under 64K size limit\n-                    2000);\n-\n-            setupLoadable(exportArray);\n-            return exportArray;\n-        }\n-\n-        private LoadableArray opensArray() {\n-            var opensArray = LoadableArray.of(\n-                    CD_OPENS,\n-                    sorted(md.opens()),\n-                    this::newOpens,\n-                    PAGING_THRESHOLD,\n-                    ownerClassDesc,\n-                    \"module\" + index + \"Opens\",\n-                    \/\/ number safe for a single page helper under 64K size limit\n-                    2000);\n-\n-            setupLoadable(opensArray);\n-            return opensArray;\n-        }\n-\n-        private LoadableArray providesArray() {\n-            var providesArray = LoadableArray.of(\n-                    CD_PROVIDES,\n-                    sorted(md.provides()),\n-                    this::newProvides,\n-                    PAGING_THRESHOLD,\n-                    ownerClassDesc,\n-                    \"module\" + index + \"Provides\",\n-                    \/\/ number safe for a single page helper under 64K size limit\n-                    2000);\n-\n-            setupLoadable(providesArray);\n-            return providesArray;\n-        }\n-\n-        private LoadableSet packagesSet() {\n-            var packagesSet = LoadableSet.of(\n-                    sorted(packages),\n-                    STRING_LOADER,\n-                    PAGING_THRESHOLD,\n-                    ownerClassDesc,\n-                    \"module\" + index + \"Packages\",\n-                    STRING_PAGE_SIZE);\n-\n-            setupLoadable(packagesSet);\n-            return packagesSet;\n-        }\n-\n-        private void setupLoadable(Loadable loadable) {\n-            if (amendment == null) {\n-                amendment = loadable::setup;\n-            } else {\n-                amendment = amendment.andThen(loadable::setup);\n-            }\n-        }\n-\n-        boolean doesRequireSetup() {\n-            return amendment != null;\n-        }\n-\n-        void setup(ClassBuilder clb) {\n-            if (amendment != null) amendment.accept(clb);\n-        }\n-\n-        void load(CodeBuilder cob) {\n-            \/\/ new jdk.internal.module.Builder\n-            cob.new_(CD_MODULE_BUILDER)\n-               .dup()\n-               .loadConstant(md.name())\n-               .invokespecial(CD_MODULE_BUILDER,\n-                              INIT_NAME,\n-                              MTD_void_String);\n-            if (md.isOpen()) {\n-                setModuleBit(cob, \"open\", true);\n-            }\n-            if (md.modifiers().contains(ModuleDescriptor.Modifier.SYNTHETIC)) {\n-                setModuleBit(cob, \"synthetic\", true);\n-            }\n-            if (md.modifiers().contains(ModuleDescriptor.Modifier.MANDATED)) {\n-                setModuleBit(cob, \"mandated\", true);\n-            }\n-\n-            \/\/ requires\n-            requiresArray().load(cob);\n-            cob.invokevirtual(CD_MODULE_BUILDER,\n-                              \"requires\",\n-                              MTD_REQUIRES_ARRAY);\n-\n-            \/\/ exports\n-            exportArray().load(cob);\n-            cob.invokevirtual(CD_MODULE_BUILDER,\n-                    \"exports\",\n-                    MTD_EXPORTS_ARRAY);\n-\n-            \/\/ opens\n-            opensArray().load(cob);\n-            cob.invokevirtual(CD_MODULE_BUILDER,\n-                              \"opens\",\n-                              MTD_OPENS_ARRAY);\n-\n-            \/\/ uses\n-            dedupSetBuilder.loadStringSet(cob, md.uses());\n-            cob.invokevirtual(CD_MODULE_BUILDER,\n-                              \"uses\",\n-                              MTD_SET);\n-\n-            \/\/ provides\n-            providesArray().load(cob);\n-            cob.invokevirtual(CD_MODULE_BUILDER,\n-                              \"provides\",\n-                              MTD_PROVIDES_ARRAY);\n-\n-            \/\/ all packages\n-            packagesSet().load(cob);\n-            cob.invokevirtual(CD_MODULE_BUILDER,\n-                              \"packages\",\n-                              MTD_SET);\n-\n-            \/\/ version\n-            md.version().ifPresent(v -> setModuleProperty(cob, \"version\", v.toString()));\n-\n-            \/\/ main class\n-            md.mainClass().ifPresent(cn -> setModuleProperty(cob, \"mainClass\", cn));\n-\n-            cob.loadConstant(md.hashCode())\n-               .invokevirtual(CD_MODULE_BUILDER,\n-                              \"build\",\n-                              MTD_ModuleDescriptor_int);\n-        }\n-\n-        \/*\n-         * Invoke Builder.<methodName>(boolean value)\n-         *\/\n-        void setModuleBit(CodeBuilder cob, String methodName, boolean value) {\n-            cob.loadConstant(value ? 1 : 0)\n-               .invokevirtual(CD_MODULE_BUILDER,\n-                              methodName,\n-                              MTD_BOOLEAN);\n-        }\n-\n-        void setModuleProperty(CodeBuilder cob, String methodName, String value) {\n-            cob.loadConstant(value)\n-               .invokevirtual(CD_MODULE_BUILDER,\n-                              methodName,\n-                              MTD_STRING);\n-        }\n-\n-        \/*\n-         * Invoke Builder.newRequires(Set<Modifier> mods, String mn, String compiledVersion)\n-         *\n-         * Set<Modifier> mods = ...\n-         * Builder.newRequires(mods, mn, compiledVersion);\n-         *\/\n-        void newRequires(CodeBuilder cob, Requires require, int unused) {\n-            dedupSetBuilder.loadRequiresModifiers(cob, require.modifiers());\n-            cob.loadConstant(require.name());\n-            if (require.compiledVersion().isPresent()) {\n-                cob.loadConstant(require.compiledVersion().get().toString())\n-                   .invokestatic(CD_MODULE_BUILDER,\n-                                 \"newRequires\",\n-                                 MTD_REQUIRES_SET_STRING_STRING);\n-            } else {\n-                cob.invokestatic(CD_MODULE_BUILDER,\n-                                 \"newRequires\",\n-                                 MTD_REQUIRES_SET_STRING);\n-            }\n-        }\n-\n-        \/*\n-         * Invoke\n-         *     Builder.newExports(Set<Exports.Modifier> ms, String pn,\n-         *                        Set<String> targets)\n-         * or\n-         *     Builder.newExports(Set<Exports.Modifier> ms, String pn)\n-         *\n-         * ms = export.modifiers()\n-         * pn = export.source()\n-         * targets = export.targets()\n-         *\/\n-        void loadExports(CodeBuilder cb, Exports export, int unused) {\n-            dedupSetBuilder.loadExportsModifiers(cb, export.modifiers());\n-            cb.loadConstant(export.source());\n-            var targets = export.targets();\n-            if (!targets.isEmpty()) {\n-                dedupSetBuilder.loadStringSet(cb, targets);\n-                cb.invokestatic(CD_MODULE_BUILDER,\n-                                \"newExports\",\n-                                MTD_EXPORTS_MODIFIER_SET_STRING_SET);\n-            } else {\n-                cb.invokestatic(CD_MODULE_BUILDER,\n-                                \"newExports\",\n-                                MTD_EXPORTS_MODIFIER_SET_STRING);\n-            }\n-        }\n-\n-        \/*\n-         * Invoke\n-         *     Builder.newOpens(Set<Opens.Modifier> ms, String pn,\n-         *                        Set<String> targets)\n-         * or\n-         *     Builder.newOpens(Set<Opens.Modifier> ms, String pn)\n-         *\n-         * ms = open.modifiers()\n-         * pn = open.source()\n-         * targets = open.targets()\n-         * Builder.newOpens(mods, pn, targets);\n-         *\/\n-        void newOpens(CodeBuilder cb, Opens open, int unused) {\n-            dedupSetBuilder.loadOpensModifiers(cb, open.modifiers());\n-            cb.loadConstant(open.source());\n-            var targets = open.targets();\n-            if (!targets.isEmpty()) {\n-                dedupSetBuilder.loadStringSet(cb, targets);\n-                cb.invokestatic(CD_MODULE_BUILDER,\n-                                 \"newOpens\",\n-                                 MTD_OPENS_MODIFIER_SET_STRING_SET);\n-            } else {\n-                cb.invokestatic(CD_MODULE_BUILDER,\n-                                 \"newOpens\",\n-                                 MTD_OPENS_MODIFIER_SET_STRING);\n-            }\n-        }\n-\n-        \/*\n-         * Invoke Builder.newProvides(String service, List<String> providers)\n-         *\n-         * service = provide.service()\n-         * providers = List.of(new String[] { provide.providers() }\n-         * Builder.newProvides(service, providers);\n-         *\/\n-        void newProvides(CodeBuilder cb, Provides provide, int offset) {\n-            var providersArray = LoadableArray.of(\n-                    CD_String,\n-                    provide.providers(),\n-                    STRING_LOADER,\n-                    PAGING_THRESHOLD,\n-                    ownerClassDesc,\n-                    \"module\" + index + \"Provider\" + offset,\n-                    STRING_PAGE_SIZE);\n-\n-            setupLoadable(providersArray);\n-\n-            cb.loadConstant(provide.service());\n-            providersArray.load(cb);\n-            cb.invokestatic(CD_List,\n-                             \"of\",\n-                             MTD_List_ObjectArray,\n-                             true)\n-               .invokestatic(CD_MODULE_BUILDER,\n-                             \"newProvides\",\n-                             MTD_PROVIDES_STRING_LIST);\n-        }\n-    }\n-\n-    \/**\n-     * Returns a sorted copy of a collection.\n-     *\n-     * This is useful to ensure a deterministic iteration order.\n-     *\n-     * @return a sorted copy of the given collection.\n-     *\/\n-    private static <T extends Comparable<T>> List<T> sorted(Collection<T> c) {\n-        var l = new ArrayList<T>(c);\n-        Collections.sort(l);\n-        return l;\n-    }\n-}\n\\ No newline at end of file\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/ModuleInfoLoader.java","additions":0,"deletions":437,"binary":false,"changes":437,"status":"deleted"},{"patch":"@@ -718,3 +718,2 @@\n-            var moduleInfoLoader = new ModuleInfoLoader(dedupSetBuilder, classDesc);\n-            var moduleDescriptors = LoadableArray.of(\n-                    CD_MODULE_DESCRIPTOR,\n+            var converter = new ModuleDescriptorBuilder(dedupSetBuilder, classDesc);\n+            var moduleDescriptors = LoadableArray.of(CD_MODULE_DESCRIPTOR,\n@@ -722,1 +721,1 @@\n-                    moduleInfoLoader,\n+                    converter::build,\n@@ -737,2 +736,2 @@\n-                            moduleDescriptors.load(cob);\n-                            cob.areturn();\n+                        moduleDescriptors.emit(cob);\n+                        cob.areturn();\n@@ -740,3 +739,0 @@\n-\n-            \/\/ amend class with helpers needed by individual ModuleDescriptor\n-            moduleInfoLoader.finish(clb);\n@@ -951,1 +947,1 @@\n-            loadableSet.load(cob);\n+            loadableSet.emit(cob);\n@@ -1078,1 +1074,1 @@\n-            <T extends Comparable<T>> SetReference createLoadableSet(Set<T> elements, ElementLoader<T> elementLoader) {\n+            <T extends Comparable<T>> SetReference createLoadableSet(Set<T> elements, CollectionElementBuilder<T> elementLoader) {\n@@ -1105,1 +1101,1 @@\n-                        s -> createLoadableSet(s, getEnumLoader(CD_EXPORTS_MODIFIER))\n+                        s -> createLoadableSet(s, (export, _) -> new EnumConstant(export))\n@@ -1114,1 +1110,1 @@\n-                        s -> createLoadableSet(s, getEnumLoader(CD_OPENS_MODIFIER))\n+                        s -> createLoadableSet(s, (open, _) -> new EnumConstant(open))\n@@ -1123,1 +1119,1 @@\n-                        s -> createLoadableSet(s, getEnumLoader(CD_REQUIRES_MODIFIER))\n+                        s -> createLoadableSet(s, (require, _) -> new EnumConstant(require))\n@@ -1131,1 +1127,1 @@\n-                stringSets.get(names).load(cob);\n+                stringSets.get(names).emit(cob);\n@@ -1138,1 +1134,1 @@\n-                exportsModifiersSets.get(mods).load(cob);\n+                exportsModifiersSets.get(mods).emit(cob);\n@@ -1145,1 +1141,1 @@\n-                opensModifiersSets.get(mods).load(cob);\n+                opensModifiersSets.get(mods).emit(cob);\n@@ -1153,1 +1149,1 @@\n-                requiresModifiersSets.get(mods).load(cob);\n+                requiresModifiersSets.get(mods).emit(cob);\n@@ -1159,1 +1155,1 @@\n-             * Return a list of snippet to be used in <clinit>.\n+             * Return a snippet to setup the cache <clinit>.\n@@ -1177,1 +1173,1 @@\n-                    set.loadableSet().setup(clb);\n+                    set.setup(clb);\n@@ -1187,10 +1183,1 @@\n-                \/\/ This is called when the value is build for the cache\n-                \/\/ At that time, a slot in cache is assigned\n-                \/\/ The loader is called when building the static initializer\n-                \/\/ We need to ensure that happens before we access SetReference::load\n-                ElementLoader<SetReference> cacheLoader = (cob, setRef, index) -> {\n-                    setRef.assignTo(index);\n-                    setRef.loadableSet().load(cob);\n-                };\n-\n-                var loadableArray = LoadableArray.of(\n+                var cacheValuesArray = LoadableArray.of(\n@@ -1199,1 +1186,1 @@\n-                        cacheLoader,\n+                        SetReference::build,\n@@ -1205,1 +1192,1 @@\n-                loadableArray.setup(clb);\n+                cacheValuesArray.setup(clb);\n@@ -1207,0 +1194,1 @@\n+\n@@ -1208,1 +1196,1 @@\n-                        loadableArray.load(cob);\n+                        cacheValuesArray.emit(cob);\n@@ -1220,1 +1208,1 @@\n-            class SetReference {\n+            class SetReference implements Snippet {\n@@ -1240,8 +1228,0 @@\n-                LoadableSet loadableSet() {\n-                    return loadableSet;\n-                }\n-\n-                void assignTo(int index) {\n-                    this.index = index;\n-                }\n-\n@@ -1253,1 +1233,2 @@\n-                void load(CodeBuilder cob) {\n+                @Override\n+                public void emit(CodeBuilder cob) {\n@@ -1260,1 +1241,1 @@\n-                        loadableSet.load(cob);\n+                        loadableSet.emit(cob);\n@@ -1263,0 +1244,16 @@\n+\n+                @Override\n+                public void setup(ClassBuilder clb) {\n+                    loadableSet.setup(clb);\n+                }\n+\n+                \/**\n+                 * Build the snippet to load the set onto the operand stack for storing into cache\n+                 * to be later accessed by the SetReference::emit\n+                 *\/\n+                Snippet build(int index) {\n+                    return cob -> {\n+                        this.index = index;\n+                        loadableSet.emit(cob);\n+                    };\n+                }\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/SystemModulesPlugin.java","additions":41,"deletions":44,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-import jdk.tools.jlink.internal.Snippets.ElementLoader;\n@@ -95,9 +94,0 @@\n-    @Test\n-    void testEnumLoader() {\n-        ClassDesc CD_ACCESSFLAG = AccessFlag.class.describeConstable().get();\n-        var expected = AccessFlag.values();\n-        var loadable = new SimpleArray(CD_ACCESSFLAG, expected, getEnumLoader(CD_ACCESSFLAG));\n-        Supplier<AccessFlag[]> supplier = generateSupplier(\"TestEnumLoader\", loadable);\n-        assertArrayEquals(expected, supplier.get());\n-    }\n-\n@@ -106,1 +96,1 @@\n-    void testWrapperLoadable(boolean isStatic) throws NoSuchMethodException {\n+    void testLoadableProvider(boolean isStatic) throws NoSuchMethodException {\n@@ -119,2 +109,2 @@\n-        var wrapped = new WrappedLoadable(loadable, testClassDesc, \"wrapper\", isStatic);\n-        Supplier<String[]> supplier = generateSupplier(className, wrapped, loadable);\n+        var provider = new LoadableProvider(loadable, testClassDesc, \"wrapper\", isStatic);\n+        Supplier<String[]> supplier = generateSupplier(className, provider, loadable);\n@@ -127,1 +117,1 @@\n-            lookup().findStatic(supplier.getClass(), wrapped.methodName(), methodType);\n+            lookup().findStatic(supplier.getClass(), provider.methodName(), methodType);\n@@ -132,1 +122,1 @@\n-            lookup().findVirtual(supplier.getClass(), wrapped.methodName(), methodType);\n+            lookup().findVirtual(supplier.getClass(), provider.methodName(), methodType);\n@@ -147,1 +137,1 @@\n-        var loadable = new SimpleArray<LoadableEnum>(\n+        var loadable = new SimpleArray<EnumConstant>(\n@@ -149,2 +139,2 @@\n-                Arrays.stream(enums).map(LoadableEnum::new).toList(),\n-                ElementLoader.selfLoader());\n+                Arrays.stream(enums).map(EnumConstant::new).toList(),\n+                (enumConstant, _) -> enumConstant);\n@@ -283,3 +273,1 @@\n-                    if (loadable.doesRequireSetup()) {\n-                        loadable.setup(clb);\n-                    }\n+                    loadable.setup(clb);\n@@ -294,1 +282,1 @@\n-                        loadable.load(cob);\n+                        loadable.emit(cob);\n","filename":"test\/jdk\/tools\/jlink\/SnippetsTest.java","additions":10,"deletions":22,"binary":false,"changes":32,"status":"modified"}]}