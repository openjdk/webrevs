{"files":[{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.annotation.Target;\n@@ -28,0 +29,1 @@\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n@@ -31,0 +33,1 @@\n+import static java.lang.constant.ConstantDescs.CD_Integer;\n@@ -33,0 +36,1 @@\n+import static java.lang.constant.ConstantDescs.CD_int;\n@@ -34,0 +38,1 @@\n+import java.util.ArrayList;\n@@ -38,0 +43,2 @@\n+import jdk.tools.jlink.internal.Snippets.ElementLoader;\n+\n@@ -39,0 +46,133 @@\n+    \/\/ Tested page size of string array\n+    public static final int STRING_PAGE_SIZE = 8000;\n+\n+    public static final ElementLoader<String> STRING_LOADER = ElementLoader.of(CodeBuilder::loadConstant);\n+    public static final ElementLoader<Integer> INTEGER_LOADER = (cob, value, index) -> {\n+        \/\/ loadConstant will unbox\n+        cob.loadConstant(value)\n+        .invokestatic(ClassDesc.ofInternalName(\"java\/lang\/Integer\"), \"valueOf\", MethodTypeDesc.of(CD_Integer, CD_int));\n+    };\n+    public static final ElementLoader<Loadable> LOADABLE_LOADER = (cob, loadable, index) -> loadable.load(cob);\n+\n+    \/**\n+     * Describe a reference that can be load onto the operand stack.\n+     * For example, an array of string can be described as a Loadable.\n+     * The {@link load} method\n+     *\/\n+    public sealed interface Loadable {\n+        \/**\n+         * Generate the bytecode to load the Loadable onto the operand stack.\n+         * @param cob  The CodeBuilder to add the bytecode for loading\n+         *\/\n+        void load(CodeBuilder cob);\n+\n+        \/**\n+         * The type of the reference be loaded onto the operatnd stack.\n+         *\/\n+        ClassDesc classDesc();\n+\n+        \/**\n+         * Generate fields or methods needed to support the load of the Loadable.\n+         * @param clb  The ClassBuilder to setup the helpers.\n+         *\/\n+        default void setup(ClassBuilder clb) {};\n+\n+        \/**\n+         * Whether {@link setup} must be called to {@link load} properly.\n+         *\/\n+        default boolean doesRequireSetup() { return false; }\n+    }\n+\n+    \/**\n+     * Generate a provider method for the {@code Loadable}. The provided\n+     * Loadable should be ready for load. The caller is responsible to ensure\n+     * the given Loadable had being setup properly.\n+     * @param value  The actuall {@code Loadable} to be wrapped into a method\n+     * @param ownerClass  The class of the generated method\n+     * @param methodName  The method name\n+     * @param isStatic  Should the generated method be static or public\n+     * @throws IllegalArgumentException if the value is a {@code WrappedLoadable}\n+     *\/\n+    public record WrappedLoadable(Loadable value, ClassDesc ownerClass, String methodName, boolean isStatic) implements Loadable {\n+        public WrappedLoadable {\n+            if (value instanceof WrappedLoadable) {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        @Override\n+        public void load(CodeBuilder cob) {\n+            if (isStatic()) {\n+                cob.invokestatic(ownerClass, methodName, methodType());\n+            } else {\n+                cob.aload(0)\n+                   .invokevirtual(ownerClass, methodName, methodType());\n+            }\n+        }\n+\n+        @Override\n+        public void setup(ClassBuilder clb) {\n+            \/\/ TODO: decide whether we should call value.setup(clb)\n+            \/\/ Prefer to have creator be responsible, given value\n+            \/\/ is provided to constructor, it should be ready to use.\n+            clb.withMethodBody(\n+                    methodName,\n+                    methodType(),\n+                    isStatic ? ACC_STATIC : ACC_PUBLIC,\n+                    cob -> {\n+                        value.load(cob);\n+                        cob.areturn();\n+                    });\n+        }\n+\n+        @Override\n+        public ClassDesc classDesc() {\n+            return value.classDesc();\n+        }\n+\n+        @Override\n+        public boolean doesRequireSetup() {\n+            return true;\n+        }\n+\n+        \/**\n+         * Describe the method type of the generated provider method.\n+         *\/\n+        public MethodTypeDesc methodType() {\n+            return MethodTypeDesc.of(classDesc());\n+        }\n+    }\n+\n+    public record LoadableEnum(Enum<?> o) implements Loadable {\n+        @Override\n+        public void load(CodeBuilder cob) {\n+            cob.getstatic(classDesc(), o.name(), classDesc());\n+        }\n+\n+        @Override\n+        public ClassDesc classDesc() {\n+            return o.getClass().describeConstable().get();\n+        }\n+    }\n+\n+    \/**\n+     * A function to load an element of type {@code T} onto the operand stack.\n+     * @param cob  The {@link CodeBuilder} to generate load code.\n+     * @param element  The element to be load.\n+     * @param index  The index of the element in the containing collection.\n+     *\/\n+    public interface ElementLoader<T> {\n+        void load(CodeBuilder cob, T element, int index);\n+\n+        static <T> ElementLoader<T> of(BiConsumer<CodeBuilder, T> ignoreIndex) {\n+            return (cob, element, _) -> {\n+                ignoreIndex.accept(cob, element);\n+            };\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        static <T extends Loadable> ElementLoader<T> selfLoader() {\n+            return (ElementLoader<T>) LOADABLE_LOADER;\n+        }\n+    }\n+\n@@ -43,2 +183,37 @@\n-    public static <T extends Enum<T>> BiConsumer<CodeBuilder, T> getEnumLoader(ClassDesc enumClassDesc) {\n-        return (cob, element) -> cob.getstatic(enumClassDesc, element.name(), enumClassDesc);\n+    public static <T extends Enum<T>> ElementLoader<T> getEnumLoader(ClassDesc enumClassDesc) {\n+        return (cob, element, _) -> cob.getstatic(enumClassDesc, element.name(), enumClassDesc);\n+    }\n+\n+    \/\/ Array supports\n+    public sealed interface LoadableArray extends Loadable {\n+        \/**\n+         * Factory method to create a LoadableArray.\n+         * The bytecode generated varies based on the number of elements and can have supporting\n+         * methods for pagination, helps to overcome the code size limitation.\n+         *\n+         * @param elementType  The type of the array element\n+         * @param elements  The elements for the array\n+         * @param elementLoader  The loader function to load a single element onto operand stack to\n+         *                       be stored at given index\n+         * @param activatePagingThreshold  Use pagination methods if the count of elements is larger\n+         *                                 than the given value\n+         * @param ownerClassDesc  The owner class for the paginattion methods\n+         * @param methodNamePrefix  The method name prefix. Generated method will have the name of\n+         *                          this value appended with page number\n+         * @param pageSize  The count of elements per page\n+         *\n+         * @return A LoadableArray\n+         *\/\n+        static <T> LoadableArray of(ClassDesc elementType,\n+                                    Collection<T> elements,\n+                                    ElementLoader<T> elementLoader,\n+                                    int activatePagingThreshold,\n+                                    ClassDesc ownerClassDesc,\n+                                    String methodNamePrefix,\n+                                    int pageSize) {\n+            if (elements.size() > activatePagingThreshold) {\n+                return new PaginatedArray<>(elementType, elements, elementLoader, ownerClassDesc, methodNamePrefix, pageSize);\n+            } else {\n+                return new SimpleArray<>(elementType, elements, elementLoader);\n+            }\n+        }\n@@ -48,2 +223,31 @@\n-     * Generate bytecode to create an array and load onto the operand stack.\n-     * Effectively like following pseudo code:\n+     * Base class for all LoadableArray implementation.\n+     *\/\n+    private sealed static abstract class AbstractLoadableArray<T> implements LoadableArray {\n+        protected final ClassDesc elementType;\n+        protected final Collection<T> elements;\n+        protected final ElementLoader<T> elementLoader;\n+\n+        public AbstractLoadableArray(ClassDesc elementType, Collection<T> elements, ElementLoader<T> elementLoader) {\n+            this.elementType = elementType;\n+            this.elements = elements;\n+            this.elementLoader = elementLoader;\n+        }\n+\n+        @Override\n+        public ClassDesc classDesc() {\n+            return elementType.arrayType();\n+        }\n+\n+        protected void fill(CodeBuilder cob, Iterable<T> elements, int offset) {\n+            for (T t : elements) {\n+                cob.dup()    \/\/ arrayref\n+                   .loadConstant(offset);\n+                elementLoader.load(cob, t, offset);  \/\/ value\n+                cob.aastore();\n+                offset++;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Generate bytecode to create an array and assign values inline. Effectively as\n@@ -51,5 +255,0 @@\n-     *\n-     * @param cob The code builder to add the snipper\n-     * @param elementType The class descriptor of the element type T\n-     * @param elements The elements to be in the array\n-     * @param elementLoader A snippet generator to load an element T onto the operand stack.\n@@ -57,13 +256,14 @@\n-    public static <T> void loadArray(CodeBuilder cob,\n-                                     ClassDesc elementType,\n-                                     Collection<T> elements,\n-                                     BiConsumer<CodeBuilder, T> elementLoader) {\n-        cob.loadConstant(elements.size())\n-           .anewarray(elementType);\n-        int arrayIndex = 0;\n-        for (T t : elements) {\n-            cob.dup()    \/\/ arrayref\n-               .loadConstant(arrayIndex);\n-            elementLoader.accept(cob, t);  \/\/ value\n-            cob.aastore();\n-            arrayIndex++;\n+    public static final class SimpleArray<T> extends AbstractLoadableArray<T> {\n+        public SimpleArray(ClassDesc elementType, T[] elements, ElementLoader<T> elementLoader) {\n+            this(elementType, Arrays.asList(elements), elementLoader);\n+        }\n+\n+        public SimpleArray(ClassDesc elementType, Collection<T> elements, ElementLoader<T> elementLoader) {\n+            super(elementType, elements, elementLoader);\n+        }\n+\n+        @Override\n+        public void load(CodeBuilder cob) {\n+            cob.loadConstant(elements.size())\n+               .anewarray(elementType);\n+            fill(cob, elements, 0);\n@@ -74,6 +274,19 @@\n-     * Generates bytecode to load a set onto the operand stack.\n-     * Effectively like following pseudo code:\n-     *   Set.of(elements)\n-     * @param cob The code builder to add the snippet\n-     * @param elements The set to be created\n-     * @param elementLoader Snippet generator to load an element onto the operand stack\n+     * Generate bytecode for pagination methods, then create the array inline and invoke the first page method to assign\n+     * values to the array. Each pagination method will assign value to the corresponding page and chain calling next\n+     * page.\n+     * {@code setup} must be called to generate the pagination methods in the owner class. Otherwise, {@code load} will\n+     * lead to {@link java.lang.NoSuchMethodException}\n+     *\n+     * Effectively as\n+     *   methodNamePrefix0(new T[elements.size()]);\n+     *\n+     * where\n+     *   T[] methodNamePrefix0(T[] ar) {\n+     *      ar[0] = elements[0];\n+     *      ar[1] = elements[1];\n+     *      ...\n+     *      ar[pageSize-1] = elements[pageSize - 1];\n+     *      methodNamePrefix1(ar);\n+     *      return ar;\n+     *   }\n+     * and the last page will stop the chain and can be partial instead of full page size.\n@@ -81,5 +294,147 @@\n-    public static <T> void loadImmutableSet(CodeBuilder cob,\n-                                            Collection<T> elements,\n-                                            BiConsumer<CodeBuilder, T> elementLoader) {\n-        if (elements.size() <= 10) {\n-            \/\/ call Set.of(e1, e2, ...)\n+    public static final class PaginatedArray<T> extends AbstractLoadableArray<T> {\n+        final int pageSize;\n+        final ClassDesc ownerClassDesc;\n+        final String methodNamePrefix;\n+        final MethodTypeDesc MTD_PageHelper;\n+\n+        public PaginatedArray(ClassDesc elementType,\n+                              T[] elements,\n+                              ElementLoader<T> elementLoader,\n+                              ClassDesc ownerClassDesc,\n+                              String methodNamePrefix,\n+                              int pageSize) {\n+            this(elementType,\n+                 Arrays.asList(elements),\n+                 elementLoader,\n+                 ownerClassDesc,\n+                 methodNamePrefix,\n+                 pageSize);\n+        }\n+\n+        public PaginatedArray(ClassDesc elementType,\n+                              Collection<T> elements,\n+                              ElementLoader<T> elementLoader,\n+                              ClassDesc ownerClassDesc,\n+                              String methodNamePrefix,\n+                              int pageSize) {\n+            super(elementType, elements, elementLoader);\n+            this.ownerClassDesc = ownerClassDesc;\n+            this.methodNamePrefix = methodNamePrefix;\n+            this.pageSize = pageSize;\n+            MTD_PageHelper = MethodTypeDesc.of(classDesc(), classDesc());\n+        }\n+\n+        @Override\n+        public void load(CodeBuilder cob) {\n+            \/\/ Invoke the first page, which will call next page until fulfilled\n+            cob.loadConstant(elements.size())\n+               .anewarray(elementType)\n+               .invokestatic(ownerClassDesc, methodNamePrefix + \"0\", MTD_PageHelper);\n+        }\n+\n+        @Override\n+        public void setup(ClassBuilder clb) {\n+            var pages = paginate(elements, pageSize);\n+\n+            assert(pages.size() == pageCount());\n+\n+            var lastPageNo = pages.size() - 1;\n+            for (int pageNo = 0; pageNo <= lastPageNo; pageNo++) {\n+                genFillPageHelper(clb, pages.get(pageNo), pageNo, pageNo < lastPageNo);\n+            }\n+        }\n+\n+        @Override\n+        public boolean doesRequireSetup() { return true; }\n+\n+        \/\/ each helper function is T[] methodNamePrefix{pageNo}(T[])\n+        \/\/ fill the page portion and chain calling to fill next page\n+        private void genFillPageHelper(ClassBuilder clb, Collection<T> pageElements, int pageNo, boolean hasNextPage) {\n+            var offset = pageSize * pageNo;\n+            clb.withMethodBody(\n+                    methodNamePrefix + pageNo,\n+                    MTD_PageHelper,\n+                    ACC_STATIC,\n+                    mcob -> {\n+                        mcob.aload(0); \/\/ arrayref\n+                        fill(mcob, pageElements, offset);\n+                        if (hasNextPage) {\n+                            mcob.invokestatic(\n+                                    ownerClassDesc,\n+                                    methodNamePrefix + (pageNo + 1),\n+                                    MTD_PageHelper);\n+                        }\n+                        mcob.areturn();\n+                    });\n+        }\n+\n+        public boolean isLastPagePartial() {\n+            return (elements.size() % pageSize) != 0;\n+        }\n+\n+        public int pageCount() {\n+            var pages = elements.size() \/ pageSize;\n+            return isLastPagePartial() ? pages + 1 : pages;\n+        }\n+    }\n+\n+    \/\/ Set support\n+    public sealed interface LoadableSet extends Loadable {\n+        \/**\n+         * Factory method for LoadableSet without using pagination methods.\n+         *\/\n+        static <T> LoadableSet of(Collection<T> elements, ElementLoader<T> loader) {\n+            \/\/ Set::of implementation optimization with 2 elements\n+            if (elements.size() <= 2) {\n+                return new TinySet<>(elements, loader);\n+            } else {\n+                return new ArrayAsSet<>(new SimpleArray<>(CD_Object, elements, loader));\n+            }\n+        }\n+\n+        \/**\n+         * Factory method for LoadableSet pagination methods when element count is larger than\n+         * given threshold.\n+         *\/\n+        static <T> LoadableSet of(Collection<T> elements,\n+                                  ElementLoader<T> loader,\n+                                  int activatePagingThreshold,\n+                                  ClassDesc ownerClassDesc,\n+                                  String methodNamePrefix,\n+                                  int pageSize) {\n+            if (elements.size() > activatePagingThreshold) {\n+                return new ArrayAsSet<>(LoadableArray.of(\n+                        CD_Object,\n+                        elements,\n+                        loader,\n+                        activatePagingThreshold,\n+                        ownerClassDesc,\n+                        methodNamePrefix,\n+                        pageSize));\n+            } else {\n+                return LoadableSet.of(elements, loader);\n+            }\n+        }\n+\n+        @Override\n+        default ClassDesc classDesc() {\n+            return CD_Set;\n+        }\n+    }\n+\n+    private static final class TinySet<T> implements LoadableSet {\n+        Collection<T> elements;\n+        ElementLoader<T> loader;\n+\n+        TinySet(Collection<T> elements, ElementLoader<T> loader) {\n+            \/\/ The Set::of API supports up to 10 elements\n+            if (elements.size() > 10) {\n+                throw new IllegalArgumentException();\n+            }\n+            this.elements = elements;\n+            this.loader = loader;\n+        }\n+\n+        @Override\n+        public void load(CodeBuilder cob) {\n+            var index = 0;\n@@ -87,1 +442,1 @@\n-                elementLoader.accept(cob, t);\n+                loader.load(cob, t, index++);\n@@ -92,4 +447,0 @@\n-        } else {\n-            \/\/ call Set.of(E... elements)\n-            loadArray(cob, CD_Object, elements, elementLoader);\n-            cob.invokestatic(CD_Set, \"of\", MethodTypeDesc.of(CD_Set, CD_Object.arrayType()), true);\n@@ -99,16 +450,22 @@\n-    \/\/ Generate a method with pseudo code looks like this\n-    \/\/ static Set<T> methodName() {\n-    \/\/     return Set.of(elements);\n-    \/\/ }\n-    public static <T> void genImmutableSetProvider(ClassBuilder clb,\n-                                                   String methodName,\n-                                                   Collection<T> elements,\n-                                                   BiConsumer<CodeBuilder, T> elementLoader) {\n-        clb.withMethodBody(\n-                methodName,\n-                MethodTypeDesc.of(CD_Set),\n-                ACC_STATIC,\n-                cob -> {\n-                    loadImmutableSet(cob, elements, elementLoader);\n-                    cob.areturn();\n-                });\n+    private static final class ArrayAsSet<T> implements LoadableSet {\n+        final LoadableArray elements;\n+\n+        ArrayAsSet(LoadableArray elements) {\n+            this.elements = elements;\n+        }\n+\n+        @Override\n+        public void load(CodeBuilder cob) {\n+            elements.load(cob);\n+            cob.invokestatic(CD_Set, \"of\", MethodTypeDesc.of(CD_Set, CD_Object.arrayType()), true);\n+        }\n+\n+        @Override\n+        public boolean doesRequireSetup() {\n+            return elements.doesRequireSetup();\n+        }\n+\n+        @Override\n+        public void setup(ClassBuilder clb) {\n+            elements.setup(clb);\n+        }\n@@ -117,17 +474,15 @@\n-    \/\/ Generate a method with pseudo code looks like this\n-    \/\/ static T[] methodName() {\n-    \/\/     return new T[] { elements };\n-    \/\/ }\n-    public static <T> void genArrayProvider(ClassBuilder clb,\n-                                            String methodName,\n-                                            ClassDesc elementType,\n-                                            Collection<T> elements,\n-                                            BiConsumer<CodeBuilder, T> elementLoader) {\n-        clb.withMethodBody(\n-                methodName,\n-                MethodTypeDesc.of(elementType.arrayType()),\n-                ACC_STATIC,\n-                cob -> {\n-                    loadArray(cob, elementType, elements, elementLoader);\n-                    cob.areturn();\n-                });\n+    \/\/ utilities\n+    private static <T> ArrayList<ArrayList<T>> paginate(Iterable<T> elements, int pageSize) {\n+        ArrayList<ArrayList<T>> pages = new ArrayList<>(pageSize);\n+        ArrayList<T> currentPage = null;\n+        var index = 0;\n+        for (T element: elements) {\n+            if (index % pageSize == 0) {\n+                currentPage = new ArrayList<>();\n+                pages.add(currentPage);\n+            }\n+            currentPage.add(element);\n+            index++;\n+        }\n+\n+        return pages;\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/Snippets.java","additions":426,"deletions":71,"binary":false,"changes":497,"status":"modified"},{"patch":"@@ -90,5 +90,2 @@\n-import static jdk.tools.jlink.internal.Snippets.genArrayProvider;\n-import static jdk.tools.jlink.internal.Snippets.genImmutableSetProvider;\n-import static jdk.tools.jlink.internal.Snippets.getEnumLoader;\n-import static jdk.tools.jlink.internal.Snippets.loadArray;\n-import static jdk.tools.jlink.internal.Snippets.loadImmutableSet;\n+import static jdk.tools.jlink.internal.Snippets.*;\n+\n@@ -588,1 +585,1 @@\n-            for (Exports e : md.exports()) {\n+            for (Exports e : sorted(md.exports())) {\n@@ -594,1 +591,1 @@\n-            for (Opens opens : md.opens()) {\n+            for (Opens opens : sorted(md.opens())) {\n@@ -600,1 +597,1 @@\n-            for (Requires r : md.requires()) {\n+            for (Requires r : sorted(md.requires())) {\n@@ -650,2 +647,4 @@\n-        private void addModuleHelpers(Consumer<ClassBuilder> amendment) {\n-            amendments.add(amendment);\n+        private void setupLoadable(Loadable loadable) {\n+            if (loadable.doesRequireSetup()) {\n+                amendments.add(loadable::setup);\n+            }\n@@ -677,3 +676,2 @@\n-                            clinitSnippets.forEach(snippet -> snippet.accept(cob));\n-                            cob.pop()\n-                               .return_();\n+                            clinitSnippets.get().accept(cob);\n+                            cob.return_();\n@@ -1022,1 +1020,2 @@\n-            loadImmutableSet(cob, sorted(set), CodeBuilder::loadConstant);\n+            var loadableSet = LoadableSet.of(sorted(set), STRING_LOADER);\n+            loadableSet.load(cob);\n@@ -1069,1 +1068,1 @@\n-            static final int SET_SIZE_THRESHOLD = 512; \/\/ An arbitrary number as this likely generate minimum ~4K code\n+            static final int PAGING_THRESHOLD = 512; \/\/ An arbitrary number as this likely generate minimum ~4K code\n@@ -1219,0 +1218,12 @@\n+                var exportArray = LoadableArray.of(\n+                        CD_EXPORTS,\n+                        sorted(exports),\n+                        this::loadExports,\n+                        PAGING_THRESHOLD,\n+                        classDesc,\n+                        \"module\" + index + \"Exports\",\n+                        \/\/ number safe for a single page helper under 64K size limit\n+                        2000);\n+\n+                setupLoadable(exportArray);\n+\n@@ -1220,1 +1231,1 @@\n-                loadExportsArray(exports);\n+                exportArray.load(cob);\n@@ -1227,14 +1238,0 @@\n-            void loadExportsArray(Set<Exports> exports) {\n-                if (exports.size() > SET_SIZE_THRESHOLD) {\n-                    String methodName = \"module\" + index + \"Exports\";\n-                    addModuleHelpers(clb -> genArrayProvider(clb,\n-                            methodName,\n-                            CD_EXPORTS,\n-                            sorted(exports),\n-                            this::loadExports));\n-                    cob.invokestatic(classDesc, methodName, MethodTypeDesc.of(CD_EXPORTS.arrayType()));\n-                } else {\n-                    loadArray(cob, CD_EXPORTS, sorted(exports), this::loadExports);\n-                }\n-            }\n-\n@@ -1252,1 +1249,1 @@\n-            void loadExports(CodeBuilder cb, Exports export) {\n+            void loadExports(CodeBuilder cb, Exports export, int unused) {\n@@ -1275,0 +1272,12 @@\n+                var opensArray = LoadableArray.of(\n+                        CD_OPENS,\n+                        sorted(opens),\n+                        this::newOpens,\n+                        PAGING_THRESHOLD,\n+                        classDesc,\n+                        \"module\" + index + \"Opens\",\n+                        \/\/ number safe for a single page helper under 64K size limit\n+                        2000);\n+\n+                setupLoadable(opensArray);\n+\n@@ -1276,1 +1285,1 @@\n-                loadArray(cob, CD_OPENS, sorted(opens), this::newOpens);\n+                opensArray.load(cob);\n@@ -1295,1 +1304,1 @@\n-            void newOpens(CodeBuilder cb, Opens open) {\n+            void newOpens(CodeBuilder cb, Opens open, int unused) {\n@@ -1330,0 +1339,12 @@\n+                var providesArray = LoadableArray.of(\n+                        CD_PROVIDES,\n+                        sorted(provides),\n+                        this::newProvides,\n+                        PAGING_THRESHOLD,\n+                        classDesc,\n+                        \"module\" + index + \"Provides\",\n+                        \/\/ number safe for a single page helper under 64K size limit\n+                        2000);\n+\n+                setupLoadable(providesArray);\n+\n@@ -1331,1 +1352,1 @@\n-                loadArray(cob, CD_PROVIDES, sorted(provides), this::newProvides);\n+                providesArray.load(cob);\n@@ -1345,1 +1366,13 @@\n-            void newProvides(CodeBuilder cb, Provides provide) {\n+            void newProvides(CodeBuilder cb, Provides provide, int offset) {\n+                var providersArray = LoadableArray.of(\n+                        CD_String,\n+                        provide.providers(),\n+                        STRING_LOADER,\n+                        PAGING_THRESHOLD,\n+                        classDesc,\n+                        \"module\" + index + \"Provider\" + offset,\n+                        STRING_PAGE_SIZE);\n+\n+\n+                setupLoadable(providersArray);\n+\n@@ -1347,2 +1380,2 @@\n-                loadArray(cb, CD_String, provide.providers(), CodeBuilder::loadConstant);\n-                cob.invokestatic(CD_List,\n+                providersArray.load(cb);\n+                cb.invokestatic(CD_List,\n@@ -1365,0 +1398,10 @@\n+                var packagesArray = LoadableSet.of(\n+                        sorted(packages),\n+                        STRING_LOADER,\n+                        PAGING_THRESHOLD,\n+                        classDesc,\n+                        \"module\" + index + \"Packages\",\n+                        STRING_PAGE_SIZE);\n+\n+                setupLoadable(packagesArray);\n+\n@@ -1366,7 +1409,1 @@\n-                if (packages.size() > SET_SIZE_THRESHOLD) {\n-                    var methodName = \"module\" + index + \"Packages\";\n-                    addModuleHelpers(clb -> genImmutableSetProvider(clb, methodName, sorted(packages), CodeBuilder::loadConstant));\n-                    cob.invokestatic(classDesc, methodName, MethodTypeDesc.of(CD_Set));\n-                } else {\n-                    loadImmutableSet(cob, sorted(packages), CodeBuilder::loadConstant);\n-                }\n+                packagesArray.load(cob);\n@@ -1402,9 +1439,0 @@\n-\n-            void invokeBuilderMethod(String methodName, String value) {\n-                cob.aload(BUILDER_VAR)\n-                   .loadConstant(value)\n-                   .invokevirtual(CD_MODULE_BUILDER,\n-                                  methodName,\n-                                  MTD_STRING)\n-                   .pop();\n-            }\n@@ -1511,1 +1539,1 @@\n-            final Map<Set<String>, SetReference<String>> stringSets = new HashMap<>();\n+            final Map<Set<String>, SetReference> stringSets = new HashMap<>();\n@@ -1515,1 +1543,1 @@\n-            final Map<Set<Requires.Modifier>, SetReference<Requires.Modifier>>\n+            final Map<Set<Requires.Modifier>, SetReference>\n@@ -1520,1 +1548,1 @@\n-            final Map<Set<Exports.Modifier>, SetReference<Exports.Modifier>>\n+            final Map<Set<Exports.Modifier>, SetReference>\n@@ -1525,1 +1553,1 @@\n-            final Map<Set<Opens.Modifier>, SetReference<Opens.Modifier>>\n+            final Map<Set<Opens.Modifier>, SetReference>\n@@ -1531,1 +1559,1 @@\n-            int countOfStoredValues = 0;\n+            private final ArrayList<SetReference> values = new ArrayList<>();\n@@ -1537,2 +1565,11 @@\n-            int requestValueStorage() {\n-                return countOfStoredValues++;\n+            <T extends Comparable<T>> SetReference createLoadableSet(Set<T> elements, ElementLoader<T> elementLoader) {\n+                var loadableSet = LoadableSet.of(sorted(elements),\n+                                                 elementLoader,\n+                                                 ModuleDescriptorBuilder.PAGING_THRESHOLD,\n+                                                 owner,\n+                                                 \"dedupSet\" + values.size(),\n+                                                 \/\/ Safe for String and Enum within 64K\n+                                                 3000);\n+                var ref = new SetReference(loadableSet);\n+                values.add(ref);\n+                return ref;\n@@ -1546,1 +1583,1 @@\n-                    s -> new SetReference<>(s, CodeBuilder::loadConstant)\n+                        s -> createLoadableSet(s, STRING_LOADER)\n@@ -1554,2 +1591,2 @@\n-                exportsModifiersSets.computeIfAbsent(mods, s ->\n-                        new SetReference<>(s, getEnumLoader(CD_EXPORTS_MODIFIER))\n+                exportsModifiersSets.computeIfAbsent(mods,\n+                        s -> createLoadableSet(s, getEnumLoader(CD_EXPORTS_MODIFIER))\n@@ -1563,2 +1600,2 @@\n-                opensModifiersSets.computeIfAbsent(mods, s ->\n-                        new SetReference<>(s, getEnumLoader(CD_OPENS_MODIFIER))\n+                opensModifiersSets.computeIfAbsent(mods,\n+                        s -> createLoadableSet(s, getEnumLoader(CD_OPENS_MODIFIER))\n@@ -1572,2 +1609,2 @@\n-                requiresModifiersSets.computeIfAbsent(mods, s ->\n-                        new SetReference<>(s, getEnumLoader(CD_REQUIRES_MODIFIER))\n+                requiresModifiersSets.computeIfAbsent(mods,\n+                        s -> createLoadableSet(s, getEnumLoader(CD_REQUIRES_MODIFIER))\n@@ -1623,19 +1660,8 @@\n-            Collection<Consumer<CodeBuilder>> buildConstants(ClassBuilder clb) {\n-                var index = 0;\n-                ArrayList<Consumer<CodeBuilder>> setValueBuilders = new ArrayList<>();\n-                \/\/ The SetReferences need to be sorted to reproduce same result.\n-                for (var ref : sorted(stringSets.values())) {\n-                    index++;\n-                    ref.generateConstant(clb, \"dedupStringSet\" + index).ifPresent(setValueBuilders::add);\n-                }\n-                for (var ref: sorted(opensModifiersSets.values())) {\n-                    index++;\n-                    ref.generateConstant(clb, \"dedupOpensSet\" + index).ifPresent(setValueBuilders::add);\n-                }\n-                for (var ref: sorted(exportsModifiersSets.values())) {\n-                    index++;\n-                    ref.generateConstant(clb, \"dedupExportsSet\" + index).ifPresent(setValueBuilders::add);\n-                }\n-                for (var ref: sorted(requiresModifiersSets.values())) {\n-                    index++;\n-                    ref.generateConstant(clb, \"dedupRequiresSet\" + index).ifPresent(setValueBuilders::add);\n+            Optional<Consumer<CodeBuilder>> buildConstants(ClassBuilder clb) {\n+                var staticCache = new ArrayList<SetReference>();\n+\n+                for (var set: values) {\n+                    set.loadableSet().setup(clb);\n+                    if (set.refCount() > 1) {\n+                        staticCache.add(set);\n+                    }\n@@ -1644,10 +1670,2 @@\n-                if (countOfStoredValues > 0) {\n-                    \/\/ The request cache slots each should have an initial value\n-                    assert setValueBuilders.size() == countOfStoredValues;\n-                    clb.withField(VALUES_ARRAY, CD_Set.arrayType(), ACC_STATIC | ACC_FINAL);\n-                    \/\/ Allocate array before assign values\n-                    setValueBuilders.addFirst(cob ->\n-                            cob.loadConstant(countOfStoredValues)\n-                               .anewarray(CD_Set)\n-                               .dup()\n-                               .putstatic(owner, VALUES_ARRAY, CD_Set.arrayType()));\n+                if (staticCache.isEmpty()) {\n+                    return Optional.empty();\n@@ -1655,1 +1673,25 @@\n-                return setValueBuilders;\n+\n+                \/\/ This is called when the value is build for the cache\n+                \/\/ At that time, a slot in cache is assigned\n+                \/\/ The loader is called when building the static initializer\n+                \/\/ We need to ensure that happens before we access SetReference::load\n+                ElementLoader<SetReference> cacheLoader = (cob, setRef, index) -> {\n+                    setRef.assignTo(index);\n+                    setRef.loadableSet().load(cob);\n+                };\n+\n+                var loadableArray = LoadableArray.of(\n+                        CD_Set,\n+                        staticCache,\n+                        cacheLoader,\n+                        ModuleDescriptorBuilder.PAGING_THRESHOLD,\n+                        owner,\n+                        VALUES_ARRAY,\n+                        2000);\n+\n+                loadableArray.setup(clb);\n+                clb.withField(VALUES_ARRAY, CD_Set.arrayType(), ACC_STATIC | ACC_FINAL);\n+                return Optional.of(cob -> {\n+                        loadableArray.load(cob);\n+                        cob.putstatic(owner, VALUES_ARRAY, CD_Set.arrayType());\n+                });\n@@ -1672,1 +1714,1 @@\n-            class SetReference<T extends Comparable<T>> implements Comparable<SetReference<T>> {\n+            class SetReference {\n@@ -1674,2 +1716,1 @@\n-                private final List<T> elements;\n-                private final BiConsumer<CodeBuilder, T> elementLoader;\n+                private final LoadableSet loadableSet;\n@@ -1680,2 +1721,0 @@\n-                \/\/ The provider method name, null if ths set is small enough for inline generation\n-                private String methodName;\n@@ -1683,3 +1722,2 @@\n-                SetReference(Set<T> elements, BiConsumer<CodeBuilder, T> elementLoader) {\n-                    this.elements = sorted(elements);\n-                    this.elementLoader = elementLoader;\n+                SetReference(LoadableSet set) {\n+                    this.loadableSet = set;\n@@ -1692,0 +1730,12 @@\n+                int refCount() {\n+                    return refCount;\n+                }\n+\n+                LoadableSet loadableSet() {\n+                    return loadableSet;\n+                }\n+\n+                void assignTo(int index) {\n+                    this.index = index;\n+                }\n+\n@@ -1707,67 +1757,1 @@\n-                        build(cob);\n-                    }\n-                }\n-\n-                \/\/ Build the set value and store the reference.\n-                \/\/ Generate either\n-                \/\/   dedupSetValues[index] = Set.of(elements);\n-                \/\/ or\n-                \/\/   dedupSetValues[index] = methodName();\n-                void store(CodeBuilder cob) {\n-                    assert index >= 0;\n-                    \/\/ array should be on top of the operands for this generate code in clinit\n-                    cob.dup()\n-                       .loadConstant(index);\n-                    build(cob);\n-                    cob.aastore();\n-                }\n-\n-                \/\/ Build the set and leave the reference at top of the operand stack.\n-                \/\/ Generate either\n-                \/\/   Set.of(elements)\n-                \/\/ or invoke the provider method\n-                \/\/   methodName()\n-                private void build(CodeBuilder cob) {\n-                    if (methodName != null) {\n-                        cob.invokestatic(owner, methodName, MethodTypeDesc.of(CD_Set));\n-                    } else {\n-                        loadImmutableSet(cob, elements, elementLoader);\n-                    }\n-                }\n-\n-                \/**\n-                 * Generate provider method if the set size is over threshold to avoid overload\n-                 * bytecode limitation per method.\n-                 * Return a snippet builder that generates code to store the reference of the set value.\n-                 *\/\n-                Optional<Consumer<CodeBuilder>> generateConstant(ClassBuilder clb, String name) {\n-                    if (elements.size() > ModuleDescriptorBuilder.SET_SIZE_THRESHOLD) {\n-                        methodName = name + \"Provider\";\n-                        genImmutableSetProvider(clb, methodName, elements, elementLoader);\n-                    }\n-\n-                    if (refCount <= 1) {\n-                        return Optional.empty();\n-                    } else {\n-                        index = requestValueStorage();\n-                        return Optional.of(this::store);\n-                    }\n-                }\n-\n-                @Override\n-                public int compareTo(SetReference<T> o) {\n-                    if (o == this) {\n-                        return 0;\n-                    }\n-                    if (elements.size() == o.elements.size()) {\n-                        var a1 = elements;\n-                        var a2 = o.elements;\n-                        for (int i = 0; i < elements.size(); i++) {\n-                            var r = a1.get(i).compareTo(a2.get(i));\n-                            if (r != 0) {\n-                                return r;\n-                            }\n-                        }\n-                        return 0;\n-                    } else {\n-                        return elements.size() - o.elements.size();\n+                        loadableSet.load(cob);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/SystemModulesPlugin.java","additions":156,"deletions":172,"binary":false,"changes":328,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.StringJoiner;\n+import java.util.spi.ToolProvider;\n+\n+import tests.JImageGenerator;\n+\n+\/*\n+ * @test\n+ * @summary Make sure that ~20000 packages in a uber jar can be linked using jlink. Depends on the\n+ *          packages, this is almost hit the 64K limitation as each plain export could take\n+ *          ~17 bytecodes.\n+ * @bug 8321413\n+ * @library ..\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jmod\n+ *          jdk.jlink\/jdk.tools.jimage\n+ *          jdk.compiler\n+ * @build tests.*\n+ * @run main\/othervm -Xmx1g -Xlog:init=debug -XX:+UnlockDiagnosticVMOptions -XX:+BytecodeVerificationLocal JLink20000Packages\n+ *\/\n+public class JLink20000Packages {\n+    private static final ToolProvider JAVAC_TOOL = ToolProvider.findFirst(\"javac\")\n+            .orElseThrow(() -> new RuntimeException(\"javac tool not found\"));\n+\n+    static void report(String command, String[] args) {\n+        System.out.println(command + \" \" + String.join(\" \", Arrays.asList(args)));\n+    }\n+\n+    static void javac(String[] args) {\n+        report(\"javac\", args);\n+        JAVAC_TOOL.run(System.out, System.err, args);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Path src = Paths.get(\"bug8321413\");\n+        Path mainModulePath = src.resolve(\"bug8321413x\");\n+\n+        StringJoiner mainModuleInfoContent = new StringJoiner(\";\\n  exports \", \"module bug8321413x {\\n  exports \", \";\\n}\");\n+\n+        for (int i = 0; i < 20000; i++) {\n+            String packageName = \"p\" + i;\n+            String className = \"C\" + i;\n+\n+            Path packagePath = Files.createDirectories(mainModulePath.resolve(packageName));\n+\n+            StringBuilder classContent = new StringBuilder(\"package \");\n+            classContent.append(packageName).append(\";\\n\");\n+            classContent.append(\"class \").append(className).append(\" {}\\n\");\n+            Files.writeString(packagePath.resolve(className + \".java\"), classContent.toString());\n+\n+            mainModuleInfoContent.add(packageName);\n+        }\n+\n+        \/\/ create module reading the generated modules\n+        Path mainModuleInfo = mainModulePath.resolve(\"module-info.java\");\n+        Files.writeString(mainModuleInfo, mainModuleInfoContent.toString());\n+\n+        Path mainClassDir = mainModulePath.resolve(\"testpackage\");\n+        Files.createDirectories(mainClassDir);\n+\n+        Files.writeString(mainClassDir.resolve(\"JLink20000PackagesTest.java\"), \"\"\"\n+                package testpackage;\n+\n+                public class JLink20000PackagesTest {\n+                    public static void main(String[] args) throws Exception {\n+                        System.out.println(\"JLink20000PackagesTest started.\");\n+                    }\n+                }\n+                \"\"\");\n+\n+        String out = src.resolve(\"out\").toString();\n+        javac(new String[]{\n+                \"-d\", out,\n+                \"--module-source-path\", src.toString(),\n+                \"--module\", \"bug8321413x\"\n+        });\n+\n+        JImageGenerator.getJLinkTask()\n+                .modulePath(out)\n+                .output(src.resolve(\"out-jlink\"))\n+                .addMods(\"bug8321413x\")\n+                .call()\n+                .assertSuccess();\n+\n+        Path binDir = src.resolve(\"out-jlink\").resolve(\"bin\").toAbsolutePath();\n+        Path bin = binDir.resolve(\"java\");\n+\n+        ProcessBuilder processBuilder = new ProcessBuilder(bin.toString(),\n+                \"-XX:+UnlockDiagnosticVMOptions\",\n+                \"-XX:+BytecodeVerificationLocal\",\n+                \"-m\", \"bug8321413x\/testpackage.JLink20000PackagesTest\");\n+        processBuilder.inheritIO();\n+        processBuilder.directory(binDir.toFile());\n+        Process process = processBuilder.start();\n+        int exitCode = process.waitFor();\n+        if (exitCode != 0)\n+             throw new AssertionError(\"JLink20000PackagesTest failed to launch\");\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/JLink20000Packages.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -1,128 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.Arrays;\n-import java.util.StringJoiner;\n-import java.util.spi.ToolProvider;\n-\n-import tests.JImageGenerator;\n-\n-\/*\n- * @test\n- * @summary Make sure that ~3500 packages in a uber jar can be linked using jlink. Depends on the\n- *          packages, this is almost hit the 64K limitation as each plain export could take\n- *          ~17 bytecodes.\n- * @bug 8321413\n- * @library ..\/lib\n- * @enablePreview\n- * @modules java.base\/jdk.internal.jimage\n- *          jdk.jlink\/jdk.tools.jlink.internal\n- *          jdk.jlink\/jdk.tools.jlink.plugin\n- *          jdk.jlink\/jdk.tools.jmod\n- *          jdk.jlink\/jdk.tools.jimage\n- *          jdk.compiler\n- * @build tests.*\n- * @run main\/othervm -Xmx1g -Xlog:init=debug -XX:+UnlockDiagnosticVMOptions -XX:+BytecodeVerificationLocal JLink3500Packages\n- *\/\n-public class JLink3500Packages {\n-    private static final ToolProvider JAVAC_TOOL = ToolProvider.findFirst(\"javac\")\n-            .orElseThrow(() -> new RuntimeException(\"javac tool not found\"));\n-\n-    static void report(String command, String[] args) {\n-        System.out.println(command + \" \" + String.join(\" \", Arrays.asList(args)));\n-    }\n-\n-    static void javac(String[] args) {\n-        report(\"javac\", args);\n-        JAVAC_TOOL.run(System.out, System.err, args);\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        Path src = Paths.get(\"bug8321413\");\n-        Path mainModulePath = src.resolve(\"bug8321413x\");\n-\n-        StringJoiner mainModuleInfoContent = new StringJoiner(\";\\n  exports \", \"module bug8321413x {\\n  exports \", \";\\n}\");\n-\n-        for (int i = 0; i < 3500; i++) {\n-            String packageName = \"p\" + i;\n-            String className = \"C\" + i;\n-\n-            Path packagePath = Files.createDirectories(mainModulePath.resolve(packageName));\n-\n-            StringBuilder classContent = new StringBuilder(\"package \");\n-            classContent.append(packageName).append(\";\\n\");\n-            classContent.append(\"class \").append(className).append(\" {}\\n\");\n-            Files.writeString(packagePath.resolve(className + \".java\"), classContent.toString());\n-\n-            mainModuleInfoContent.add(packageName);\n-        }\n-\n-        \/\/ create module reading the generated modules\n-        Path mainModuleInfo = mainModulePath.resolve(\"module-info.java\");\n-        Files.writeString(mainModuleInfo, mainModuleInfoContent.toString());\n-\n-        Path mainClassDir = mainModulePath.resolve(\"testpackage\");\n-        Files.createDirectories(mainClassDir);\n-\n-        Files.writeString(mainClassDir.resolve(\"JLink3500PackagesTest.java\"), \"\"\"\n-                package testpackage;\n-\n-                public class JLink3500PackagesTest {\n-                    public static void main(String[] args) throws Exception {\n-                        System.out.println(\"JLink3500PackagesTest started.\");\n-                    }\n-                }\n-                \"\"\");\n-\n-        String out = src.resolve(\"out\").toString();\n-        javac(new String[]{\n-                \"-d\", out,\n-                \"--module-source-path\", src.toString(),\n-                \"--module\", \"bug8321413x\"\n-        });\n-\n-        JImageGenerator.getJLinkTask()\n-                .modulePath(out)\n-                .output(src.resolve(\"out-jlink\"))\n-                .addMods(\"bug8321413x\")\n-                .call()\n-                .assertSuccess();\n-\n-        Path binDir = src.resolve(\"out-jlink\").resolve(\"bin\").toAbsolutePath();\n-        Path bin = binDir.resolve(\"java\");\n-\n-        ProcessBuilder processBuilder = new ProcessBuilder(bin.toString(),\n-                \"-XX:+UnlockDiagnosticVMOptions\",\n-                \"-XX:+BytecodeVerificationLocal\",\n-                \"-m\", \"bug8321413x\/testpackage.JLink3500PackagesTest\");\n-        processBuilder.inheritIO();\n-        processBuilder.directory(binDir.toFile());\n-        Process process = processBuilder.start();\n-        int exitCode = process.waitFor();\n-        if (exitCode != 0)\n-             throw new AssertionError(\"JLink3500PackagesTest failed to launch\");\n-    }\n-}\n","filename":"test\/jdk\/tools\/jlink\/JLink3500Packages.java","additions":0,"deletions":128,"binary":false,"changes":128,"status":"deleted"},{"patch":"@@ -0,0 +1,305 @@\n+\/*\n+ * Copyright (c) 2024, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.lang.classfile.ClassFile;\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+import java.lang.constant.ClassDesc;\n+import static java.lang.constant.ConstantDescs.CD_Integer;\n+import static java.lang.constant.ConstantDescs.CD_Object;\n+import static java.lang.constant.ConstantDescs.CD_String;\n+import static java.lang.constant.ConstantDescs.INIT_NAME;\n+import static java.lang.constant.ConstantDescs.MTD_void;\n+import java.lang.constant.MethodTypeDesc;\n+import static java.lang.invoke.MethodHandles.lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.module.ModuleDescriptor;\n+import java.lang.reflect.AccessFlag;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.*;\n+import java.util.function.Supplier;\n+import java.util.stream.IntStream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import jdk.tools.jlink.internal.Snippets.*;\n+import static jdk.tools.jlink.internal.Snippets.*;\n+import jdk.tools.jlink.internal.Snippets.ElementLoader;\n+\n+\/*\n+ * @test\n+ * @summary Test snippets generation for array and set.\n+ * @bug 8321413\n+ * @enablePreview\n+ * @modules jdk.jlink\/jdk.tools.jlink.internal\n+ * @run junit SnippetsTest\n+ *\/\n+public class SnippetsTest {\n+    private static final boolean WRITE_CLASS_FILE = Boolean.parseBoolean(System.getProperty(\"DumpArraySnippetsTestClasses\", \"true\"));\n+\n+    @ParameterizedTest\n+    @ValueSource(ints = { 10, 75, 90, 120, 200, 399, 400, 401})\n+    void testLoad400StringsArray(int pageSize) {\n+        testPaginatedArray(400, pageSize);\n+    }\n+\n+    @Test\n+    void testStringArrayLimitsWithPagination() {\n+        \/\/ Each string takes 2 constant pool slot, one for String, another for Utf8\n+        testPaginatedArray(31_000, 8000);\n+        try {\n+            testPaginatedArray(32_000, 8000);\n+        } catch (IllegalArgumentException iae) {\n+            \/\/ expected constant pool explode\n+        }\n+    }\n+\n+    @Test\n+    void testStringArrayLimitsWithoutPagination() {\n+        \/\/ each string array assignment takes ~8 bytes\n+        testSimpleArray(8200);\n+        try {\n+            testSimpleArray(8300);\n+            fail();\n+        } catch (IllegalArgumentException iae) {\n+            \/\/ expected code size explode\n+        }\n+    }\n+\n+    @Test\n+    void testEnumLoader() {\n+        ClassDesc CD_ACCESSFLAG = AccessFlag.class.describeConstable().get();\n+        var expected = AccessFlag.values();\n+        var loadable = new SimpleArray(CD_ACCESSFLAG, expected, getEnumLoader(CD_ACCESSFLAG));\n+        Supplier<AccessFlag[]> supplier = generateSupplier(\"TestEnumLoader\", loadable);\n+        assertArrayEquals(expected, supplier.get());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testWrapperLoadable(boolean isStatic) throws NoSuchMethodException {\n+        var expected = IntStream.range(0, 1234)\n+                                 .mapToObj(i -> \"WrapperTestString\" + i)\n+                                 .toList();\n+        var className = \"WrapperLoadableTest\" + (isStatic ? \"Static\" : \"Public\");\n+        ClassDesc testClassDesc = ClassDesc.of(className);\n+\n+        var loadable = new PaginatedArray<>(\n+                CD_String, expected, STRING_LOADER, testClassDesc, \"page\", 100);\n+        \/\/ 1234 with 10 per page, should have 13 pages with last page 34 elements\n+        assertEquals(13, loadable.pageCount());\n+        assertTrue(loadable.isLastPagePartial());\n+\n+        var wrapped = new WrappedLoadable(loadable, testClassDesc, \"wrapper\", isStatic);\n+        Supplier<String[]> supplier = generateSupplier(className, wrapped, loadable);\n+        verifyPaginationMethods(supplier.getClass(), String.class, \"page\", 13);\n+        assertArrayEquals(expected.toArray(), supplier.get());\n+\n+        \/\/ check wrapper function\n+        var methodType = MethodType.methodType(String[].class);\n+        try {\n+            lookup().findStatic(supplier.getClass(), wrapped.methodName(), methodType);\n+        } catch (IllegalAccessException ex) {\n+            assertFalse(isStatic);\n+        }\n+        try {\n+            lookup().findVirtual(supplier.getClass(), wrapped.methodName(), methodType);\n+        } catch (IllegalAccessException ex) {\n+            assertTrue(isStatic);\n+        }\n+    }\n+\n+    @Test\n+    void testLoadableEnum() {\n+        Enum<?>[] enums = {\n+            AccessFlag.FINAL,\n+            ModuleDescriptor.Requires.Modifier.MANDATED,\n+            ModuleDescriptor.Opens.Modifier.SYNTHETIC,\n+            ModuleDescriptor.Requires.Modifier.TRANSITIVE\n+        };\n+\n+        var loadable = new SimpleArray<LoadableEnum>(\n+                Enum.class.describeConstable().get(),\n+                Arrays.stream(enums).map(LoadableEnum::new).toList(),\n+                ElementLoader.selfLoader());\n+\n+        Supplier<Enum<?>[]> supplier = generateSupplier(\"LoadableEnumTest\", loadable);\n+        assertArrayEquals(enums, supplier.get());\n+    }\n+\n+    @Test\n+    void testLoadableArrayOf() {\n+        Integer[] expected = IntStream.range(0, 200)\n+                                .boxed()\n+                                .toArray(Integer[]::new);\n+        var className = \"LoadableArrayOf200Paged\";\n+        var loadable = LoadableArray.of(CD_Integer,\n+                Arrays.asList(expected),\n+                INTEGER_LOADER,\n+                expected.length - 1,\n+                ClassDesc.of(className),\n+                \"page\",\n+                100);\n+        assertTrue(loadable instanceof PaginatedArray);\n+\n+        Supplier<Integer[]> supplier = generateSupplier(className, loadable);\n+        verifyPaginationMethods(supplier.getClass(), Integer.class, \"page\", 2);\n+        assertArrayEquals(expected, supplier.get());\n+\n+        loadable = LoadableArray.of(\n+                CD_Integer,\n+                Arrays.asList(expected),\n+                INTEGER_LOADER,\n+                expected.length,\n+                ClassDesc.of(\"LoadableArrayOf200NotPaged\"),\n+                \"page\",\n+                100);\n+        assertTrue(loadable instanceof SimpleArray);\n+\n+        \/\/ SimpleArray generate bytecode inline, so can be generated in any class\n+        supplier = generateSupplier(\"TestLoadableArrayFactory\", loadable);\n+        assertArrayEquals(expected, supplier.get());\n+    }\n+\n+    @Test\n+    void testLoadableSetOf() {\n+        String[] data = IntStream.range(0, 100)\n+                                 .mapToObj(i -> \"SetData\" + i)\n+                                 .toArray(String[]::new);\n+\n+        var tiny = Set.of(data[0], data[1], data[2]);\n+        var all = Set.of(data);\n+\n+        Supplier<Set<String>> supplier = generateSupplier(\"TinySetTest\", LoadableSet.of(tiny, STRING_LOADER));\n+        \/\/ Set does not guarantee ordering, so not assertIterableEquals\n+        assertEquals(tiny, supplier.get());\n+\n+        supplier = generateSupplier(\"AllSetTestNoPage\", LoadableSet.of(all, STRING_LOADER));\n+        assertEquals(all, supplier.get());\n+\n+        var className = \"AllSetTestPageNotActivated\";\n+        var methodNamePrefix = \"page\";\n+        var loadable = LoadableSet.of(all, STRING_LOADER, all.size(),\n+                ClassDesc.of(className), methodNamePrefix, 10);\n+        supplier = generateSupplier(className, loadable);\n+        assertEquals(all, supplier.get());\n+\n+        className = \"AllSetTestPageSize20\";\n+        loadable = LoadableSet.of(all, STRING_LOADER, all.size() - 1,\n+                ClassDesc.of(className), methodNamePrefix, 20);\n+        supplier = generateSupplier(className, loadable);\n+        \/\/ Set erased element type and use Object as element type\n+        verifyPaginationMethods(supplier.getClass(), Object.class, methodNamePrefix, 5);\n+        assertEquals(all, supplier.get());\n+    }\n+\n+    void testPaginatedArray(int elementCount, int pageSize) {\n+        String[] expected = IntStream.range(0, elementCount)\n+                                 .mapToObj(i -> \"Package\" + i)\n+                                 .toArray(String[]::new);\n+        var className = String.format(\"SnippetArrayProviderTest%dPagedBy%d\", elementCount, pageSize);\n+        ClassDesc testClassDesc = ClassDesc.of(className);\n+        var loadable = new PaginatedArray<>(CD_String, expected, STRING_LOADER,\n+                testClassDesc, \"ArrayPage\", pageSize);\n+\n+        Supplier<String[]> supplier = generateSupplier(className, loadable);\n+        verifyPaginationMethods(supplier.getClass(), String.class, \"ArrayPage\", loadable.pageCount());\n+        assertEquals((elementCount % pageSize) != 0, loadable.isLastPagePartial());\n+        assertArrayEquals(expected, supplier.get());\n+    }\n+\n+    void testSimpleArray(int elementCount) {\n+        String[] expected = IntStream.range(0, elementCount)\n+                                 .mapToObj(i -> \"NoPage\" + i)\n+                                 .toArray(String[]::new);\n+        String className = \"SnippetArrayProviderTest\" + elementCount;\n+        var array = new SimpleArray<>(CD_String, Arrays.asList(expected), STRING_LOADER);\n+\n+        Supplier<String[]> supplier = generateSupplier(className, array);\n+        assertArrayEquals(expected, supplier.get());\n+    }\n+\n+    <T> Supplier<T> generateSupplier(String className, Loadable loadable, Loadable... extra) {\n+        var testClassDesc = ClassDesc.of(className);\n+        byte[] classBytes = generateSupplierClass(testClassDesc, loadable, extra);\n+        try {\n+            writeClassFile(className, classBytes);\n+            var testClass = lookup().defineClass(classBytes);\n+            lookup().findVirtual(testClass, \"get\", MethodType.methodType(Object.class));\n+            return (Supplier<T>) testClass.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    void verifyPaginationMethods(Class<?> testClass, Class<?> elementType, String methodNamePrefix, int pageCount) {\n+        for (int i = 0; i < pageCount; i++) {\n+            try {\n+                lookup().findStatic(testClass, methodNamePrefix + i,\n+                        MethodType.methodType(elementType.arrayType(), elementType.arrayType()));\n+            } catch (Exception ex) {\n+                throw new RuntimeException(ex);\n+            }\n+        }\n+    }\n+\n+    byte[] generateSupplierClass(ClassDesc testClassDesc, Loadable loadable, Loadable... extra) {\n+        return ClassFile.of().build(testClassDesc,\n+                clb -> {\n+                    clb.withSuperclass(CD_Object);\n+                    clb.withInterfaceSymbols(ClassDesc.ofInternalName(\"java\/util\/function\/Supplier\"));\n+                    clb.withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC, cob -> {\n+                        cob.aload(0);\n+                        cob.invokespecial(CD_Object, INIT_NAME, MTD_void);\n+                        cob.return_();\n+                    });\n+\n+                    if (loadable.doesRequireSetup()) {\n+                        loadable.setup(clb);\n+                    }\n+\n+                    for (var e: extra) {\n+                        \/\/ always call setup should be no harm\n+                        \/\/ it suppose to be nop if not required.\n+                        e.setup(clb);\n+                    }\n+\n+                    clb.withMethodBody(\"get\", MethodTypeDesc.of(CD_Object), ACC_PUBLIC, cob -> {\n+                        loadable.load(cob);\n+                        cob.areturn();\n+                    });\n+                });\n+    }\n+\n+    void writeClassFile(String className, byte[] classBytes) throws IOException {\n+        if (WRITE_CLASS_FILE) {\n+            Files.write(Path.of(className + \".class\"), classBytes);\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/tools\/jlink\/SnippetsTest.java","additions":305,"deletions":0,"binary":false,"changes":305,"status":"added"}]}