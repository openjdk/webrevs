{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.lang.constant.ConstantDesc;\n@@ -35,0 +34,1 @@\n+import java.util.Objects;\n@@ -36,1 +36,0 @@\n-import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n@@ -38,0 +37,1 @@\n+import java.lang.constant.ConstantDesc;\n@@ -42,0 +42,2 @@\n+import java.util.function.Function;\n+\n@@ -45,11 +47,2 @@\n-\n-    public static final CollectionElementBuilder<String> STRING_LOADER = (value, index) -> new Constant<>(value);\n-\n-    public static final CollectionElementBuilder<Integer> INTEGER_LOADER = (value, index) -> cob -> {\n-        \/\/ loadConstant will unbox\n-        cob.loadConstant(value)\n-           .invokestatic(ClassDesc.ofInternalName(\"java\/lang\/Integer\"), \"valueOf\", MethodTypeDesc.of(CD_Integer, CD_int));\n-    };\n-\n-    public static final CollectionElementBuilder<Loadable> LOADABLE_LOADER = (loadable, index) -> loadable;\n-\n+    \/\/ Tested page size of enum array\n+    public static final int ENUM_PAGE_SIZE = 5000;\n@@ -69,6 +62,20 @@\n-        \/**\n-         * Perpare a snippet needs some extra support like field or methods from the class.\n-         *\n-         * @param clb  The ClassBuilder to setup the helpers.\n-         *\/\n-        default void setup(ClassBuilder clb) {};\n+        static <T extends ConstantDesc> Snippet loadConstant(T v) {\n+            return cob -> cob.loadConstant(v);\n+        }\n+\n+        static Snippet loadEnum(Enum<?> e) {\n+            var classDesc = e.getClass().describeConstable().get();\n+            return cob -> cob.getstatic(classDesc, e.name(), classDesc);\n+        }\n+\n+        static Snippet loadInteger(int value) {\n+            return cob ->\n+                    cob.loadConstant(value)\n+                       .invokestatic(ClassDesc.ofInternalName(\"java\/lang\/Integer\"), \"valueOf\", MethodTypeDesc.of(CD_Integer, CD_int));\n+        }\n+\n+        static <T> Snippet[] buildAll(Collection<T> elements, Function<T, Snippet> fn) {\n+            return elements.stream()\n+                    .map(fn)\n+                    .toArray(Snippet[]::new);\n+        }\n@@ -80,1 +87,0 @@\n-     * The {@link load#emit} method\n@@ -82,1 +88,1 @@\n-    public sealed interface Loadable extends Snippet {\n+    public record Loadable(ClassDesc classDesc, Snippet load) implements Snippet {\n@@ -88,10 +94,0 @@\n-        void emit(CodeBuilder cob);\n-\n-        \/**\n-         * The type of the reference be loaded onto the operand stack.\n-         *\/\n-        ClassDesc classDesc();\n-    }\n-\n-    public record Constant<T extends ConstantDesc>(T value) implements Snippet {\n-        @Override\n@@ -99,1 +95,1 @@\n-            cob.loadConstant(value);\n+            load.emit(cob);\n@@ -103,5 +99,9 @@\n-    public final record EnumConstant(Enum<?> o) implements Loadable {\n-        @Override\n-        public void emit(CodeBuilder cob) {\n-            cob.getstatic(classDesc(), o.name(), classDesc());\n-        }\n+    @FunctionalInterface\n+    public interface IndexedElementSnippetBuilder<T> {\n+        \/**\n+         * Build a snippet for the element at the index.\n+         * @param element  The element\n+         * @param index  The index of the element in the containing collection\n+         * @return A snippet of bytecodes to process the element\n+         *\/\n+        Snippet build(T element, int index);\n@@ -109,3 +109,8 @@\n-        @Override\n-        public ClassDesc classDesc() {\n-            return o.getClass().describeConstable().get();\n+        default Snippet[] buildAll(Collection<T> elements) {\n+            var loadElementSnippets = new ArrayList<Snippet>(elements.size());\n+            for (var element: elements) {\n+                loadElementSnippets.add(build(element, loadElementSnippets.size()));\n+            }\n+\n+            assert(loadElementSnippets.size() == elements.size());\n+            return loadElementSnippets.toArray(Snippet[]::new);\n@@ -115,15 +120,3 @@\n-    \/**\n-     * Generate a provider method for the {@code Loadable}. The provided\n-     * Loadable should be ready for load. The caller is responsible to ensure\n-     * the given Loadable had being setup properly.\n-     * @param value  The actuall {@code Loadable} to be wrapped into a method\n-     * @param ownerClass  The class of the generated method\n-     * @param methodName  The method name\n-     * @param isStatic  Should the generated method be static or public\n-     * @throws IllegalArgumentException if the value is a {@code WrappedLoadable}\n-     *\/\n-    public final record LoadableProvider(Loadable value, ClassDesc ownerClass, String methodName, boolean isStatic) implements Loadable {\n-        public LoadableProvider {\n-            if (value instanceof LoadableProvider) {\n-                throw new IllegalArgumentException();\n-            }\n+    public static record PagingContext(int total, int pageSize) {\n+        public boolean isLastPagePartial() {\n+            return (total % pageSize) != 0;\n@@ -132,8 +125,3 @@\n-        @Override\n-        public void emit(CodeBuilder cob) {\n-            if (isStatic()) {\n-                cob.invokestatic(ownerClass, methodName, methodType());\n-            } else {\n-                cob.aload(0)\n-                   .invokevirtual(ownerClass, methodName, methodType());\n-            }\n+        public int pageCount() {\n+            var pages = total \/ pageSize;\n+            return isLastPagePartial() ? pages + 1 : pages;\n@@ -142,12 +130,4 @@\n-        @Override\n-        public void setup(ClassBuilder clb) {\n-            \/\/ TODO: decide whether we should call value.setup(clb)\n-            \/\/ Prefer to have creator be responsible, given value\n-            \/\/ is provided to constructor, it should be ready to use.\n-            clb.withMethodBody(methodName,\n-                    methodType(),\n-                    isStatic ? ACC_STATIC : ACC_PUBLIC,\n-                    cob -> {\n-                        value.emit(cob);\n-                        cob.areturn();\n-                    });\n+        public int lastPageSize() {\n+            if (total == 0) return 0;\n+            var remaining = total % pageSize;\n+            return remaining == 0 ? pageSize : remaining;\n@@ -155,0 +135,1 @@\n+    }\n@@ -156,3 +137,10 @@\n-        @Override\n-        public ClassDesc classDesc() {\n-            return value.classDesc();\n+    public static abstract class CollectionSnippetBuilder {\n+        protected ClassDesc elementType;\n+        protected int activatePagingThreshold;\n+        protected ClassDesc ownerClassDesc;\n+        protected String methodNamePrefix;\n+        protected int pageSize;\n+        protected ClassBuilder clb;\n+\n+        protected CollectionSnippetBuilder(ClassDesc elementType) {\n+            this.elementType = Objects.requireNonNull(elementType);\n@@ -162,1 +150,2 @@\n-         * Describe the method type of the generated provider method.\n+         * @param activatePagingThreshold  Use pagination methods if the count of elements is larger\n+         *                                 than the given value\n@@ -164,2 +153,3 @@\n-        public MethodTypeDesc methodType() {\n-            return MethodTypeDesc.of(classDesc());\n+        public CollectionSnippetBuilder activatePagingThreshold(int activatePagingThreshold) {\n+            this.activatePagingThreshold = activatePagingThreshold;\n+            return this;\n@@ -167,1 +157,0 @@\n-    }\n@@ -169,2 +158,0 @@\n-    @FunctionalInterface\n-    public interface CollectionElementBuilder<T> {\n@@ -172,4 +159,1 @@\n-         * Build a snippet for the element at the index.\n-         * @param element  The element\n-         * @param index  The index of the element in the containing collection\n-         * @return A snippet of bytecodes to process the element\n+         * @param ownerClassDesc  The owner class for the paginattion methods\n@@ -177,2 +161,4 @@\n-        Snippet build(T element, int index);\n-    }\n+        public CollectionSnippetBuilder ownerClassDesc(ClassDesc ownerClassDesc) {\n+            this.ownerClassDesc = ownerClassDesc;\n+            return this;\n+        }\n@@ -180,2 +166,0 @@\n-    \/\/ Array supports\n-    public sealed interface LoadableArray extends Loadable {\n@@ -183,11 +167,0 @@\n-         * Factory method to create a LoadableArray.\n-         * The bytecode generated varies based on the number of elements and can have supporting\n-         * methods for pagination, helps to overcome the code size limitation.\n-         *\n-         * @param elementType  The type of the array element\n-         * @param elements  The elements for the array\n-         * @param elementLoader  The snippet builder to generate bytecodes to load an element onto\n-         *                       the operand stack\n-         * @param activatePagingThreshold  Use pagination methods if the count of elements is larger\n-         *                                 than the given value\n-         * @param ownerClassDesc  The owner class for the paginattion methods\n@@ -196,3 +169,0 @@\n-         * @param pageSize  The count of elements per page\n-         *\n-         * @return A LoadableArray\n@@ -200,35 +170,3 @@\n-        static <T> LoadableArray of(ClassDesc elementType,\n-                                    Collection<T> elements,\n-                                    CollectionElementBuilder<T> elementLoader,\n-                                    int activatePagingThreshold,\n-                                    ClassDesc ownerClassDesc,\n-                                    String methodNamePrefix,\n-                                    int pageSize) {\n-            if (elements.size() > activatePagingThreshold) {\n-                return new PaginatedArray<>(elementType, elements, elementLoader, ownerClassDesc, methodNamePrefix, pageSize);\n-            } else {\n-                return new SimpleArray<>(elementType, elements, elementLoader);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Base class for all LoadableArray implementation.\n-     *\/\n-    private sealed static abstract class AbstractLoadableArray<T> implements LoadableArray {\n-        protected final ClassDesc elementType;\n-        protected final ArrayList<Snippet> loadElementSnippets;\n-\n-        public AbstractLoadableArray(ClassDesc elementType, Collection<T> elements, CollectionElementBuilder<T> elementLoader) {\n-            this.elementType = elementType;\n-            loadElementSnippets = new ArrayList<>(elements.size());\n-            for (var element: elements) {\n-                loadElementSnippets.add(elementLoader.build(element, loadElementSnippets.size()));\n-            }\n-\n-            assert(loadElementSnippets.size() == elements.size());\n-        }\n-\n-        @Override\n-        public ClassDesc classDesc() {\n-            return elementType.arrayType();\n+        public CollectionSnippetBuilder methodNamePrefix(String methodNamePrefix) {\n+            this.methodNamePrefix = methodNamePrefix;\n+            return this;\n@@ -237,3 +175,6 @@\n-        @Override\n-        public void setup(ClassBuilder clb) {\n-            loadElementSnippets.forEach(s -> s.setup(clb));\n+        \/**\n+         * @param pageSize  The count of elements per page*\n+         *\/\n+        public CollectionSnippetBuilder pageSize(int pageSize) {\n+            this.pageSize = pageSize;\n+            return this;\n@@ -242,7 +183,3 @@\n-        protected void fill(CodeBuilder cob, int fromIndex, int toIndex) {\n-            for (var index = fromIndex; index < toIndex; index++) {\n-                cob.dup()    \/\/ arrayref\n-                   .loadConstant(index);\n-                loadElementSnippets.get(index).emit(cob);  \/\/ value\n-                cob.aastore();\n-            }\n+        public CollectionSnippetBuilder classBuilder(ClassBuilder clb) {\n+            this.clb = clb;\n+            return this;\n@@ -250,1 +187,0 @@\n-    }\n@@ -252,7 +188,2 @@\n-    \/**\n-     * Generate bytecode to create an array and assign values inline. Effectively as\n-     *   new T[] { elements }\n-     *\/\n-    public static final class SimpleArray<T> extends AbstractLoadableArray<T> {\n-        public SimpleArray(ClassDesc elementType, T[] elements, CollectionElementBuilder<T> elementLoader) {\n-            this(elementType, Arrays.asList(elements), elementLoader);\n+        protected boolean shouldPaginate(int length) {\n+            return activatePagingThreshold != 0 && length > activatePagingThreshold;\n@@ -261,10 +192,1 @@\n-        public SimpleArray(ClassDesc elementType, Collection<T> elements, CollectionElementBuilder<T> elementLoader) {\n-            super(elementType, elements, elementLoader);\n-        }\n-\n-        @Override\n-        public void emit(CodeBuilder cob) {\n-            cob.loadConstant(loadElementSnippets.size())\n-               .anewarray(elementType);\n-            fill(cob, 0, loadElementSnippets.size());\n-        }\n+        abstract public Loadable build(Snippet[] loadElementSnippets);\n@@ -294,4 +216,1 @@\n-    public static final class PaginatedArray<T> extends AbstractLoadableArray<T> {\n-        final int pageSize;\n-        final ClassDesc ownerClassDesc;\n-        final String methodNamePrefix;\n+    public static class ArraySnippetBuilder extends CollectionSnippetBuilder {\n@@ -299,0 +218,2 @@\n+        final ClassDesc classDesc;\n+        Snippet[] loadElementSnippets;\n@@ -300,12 +221,4 @@\n-        public PaginatedArray(ClassDesc elementType,\n-                              T[] elements,\n-                              CollectionElementBuilder<T> elementLoader,\n-                              ClassDesc ownerClassDesc,\n-                              String methodNamePrefix,\n-                              int pageSize) {\n-            this(elementType,\n-                 Arrays.asList(elements),\n-                 elementLoader,\n-                 ownerClassDesc,\n-                 methodNamePrefix,\n-                 pageSize);\n+        public ArraySnippetBuilder(ClassDesc elementType) {\n+            super(elementType);\n+            classDesc = elementType.arrayType();\n+            MTD_PageHelper = MethodTypeDesc.of(classDesc, classDesc);\n@@ -314,11 +227,7 @@\n-        public PaginatedArray(ClassDesc elementType,\n-                              Collection<T> elements,\n-                              CollectionElementBuilder<T> elementLoader,\n-                              ClassDesc ownerClassDesc,\n-                              String methodNamePrefix,\n-                              int pageSize) {\n-            super(elementType, elements, elementLoader);\n-            this.ownerClassDesc = ownerClassDesc;\n-            this.methodNamePrefix = methodNamePrefix;\n-            this.pageSize = pageSize;\n-            MTD_PageHelper = MethodTypeDesc.of(classDesc(), classDesc());\n+        protected void fill(CodeBuilder cob, int fromIndex, int toIndex) {\n+            for (var index = fromIndex; index < toIndex; index++) {\n+                cob.dup()    \/\/ arrayref\n+                   .loadConstant(index);\n+                loadElementSnippets[index].emit(cob);  \/\/ value\n+                cob.aastore();\n+            }\n@@ -327,2 +236,1 @@\n-        @Override\n-        public void emit(CodeBuilder cob) {\n+        private void invokePageHelper(CodeBuilder cob) {\n@@ -330,1 +238,1 @@\n-            cob.loadConstant(loadElementSnippets.size())\n+            cob.loadConstant(loadElementSnippets.length)\n@@ -335,0 +243,6 @@\n+        private void newArray(CodeBuilder cob) {\n+            cob.loadConstant(loadElementSnippets.length)\n+               .anewarray(elementType);\n+            fill(cob, 0, loadElementSnippets.length);\n+        }\n+\n@@ -338,4 +252,3 @@\n-        @Override\n-        public void setup(ClassBuilder clb) {\n-            super.setup(clb);\n-            var lastPageNo = pageCount() - 1;\n+        private void setupHelpers() {\n+            Objects.requireNonNull(clb);\n+            var lastPageNo = new PagingContext(loadElementSnippets.length, pageSize).pageCount() - 1;\n@@ -343,1 +256,1 @@\n-                genFillPageHelper(clb, pageNo, pageNo < lastPageNo);\n+                genFillPageHelper(pageNo, pageNo < lastPageNo);\n@@ -349,1 +262,1 @@\n-        private void genFillPageHelper(ClassBuilder clb, int pageNo, boolean hasNextPage) {\n+        private void genFillPageHelper(int pageNo, boolean hasNextPage) {\n@@ -351,1 +264,1 @@\n-            var toIndex = hasNextPage ? (fromIndex + pageSize) : loadElementSnippets.size();\n+            var toIndex = hasNextPage ? (fromIndex + pageSize) : loadElementSnippets.length;\n@@ -368,23 +281,0 @@\n-        public boolean isLastPagePartial() {\n-            return (loadElementSnippets.size() % pageSize) != 0;\n-        }\n-\n-        public int pageCount() {\n-            var pages = loadElementSnippets.size() \/ pageSize;\n-            return isLastPagePartial() ? pages + 1 : pages;\n-        }\n-    }\n-\n-    \/\/ Set support\n-    public sealed interface LoadableSet extends Loadable {\n-        \/**\n-         * Factory method for LoadableSet without using pagination methods.\n-         *\/\n-        static <T> LoadableSet of(Collection<T> elements, CollectionElementBuilder<T> loader) {\n-            \/\/ Set::of implementation optimization with 2 elements\n-            if (elements.size() <= 2) {\n-                return new TinySet<>(elements, loader);\n-            } else {\n-                return new ArrayAsSet<>(new SimpleArray<>(CD_Object, elements, loader));\n-            }\n-        }\n@@ -392,19 +282,6 @@\n-        \/**\n-         * Factory method for LoadableSet pagination methods when element count is larger than\n-         * given threshold.\n-         *\/\n-        static <T> LoadableSet of(Collection<T> elements,\n-                                  CollectionElementBuilder<T> loader,\n-                                  int activatePagingThreshold,\n-                                  ClassDesc ownerClassDesc,\n-                                  String methodNamePrefix,\n-                                  int pageSize) {\n-            if (elements.size() > activatePagingThreshold) {\n-                return new ArrayAsSet<>(LoadableArray.of(\n-                        CD_Object,\n-                        elements,\n-                        loader,\n-                        activatePagingThreshold,\n-                        ownerClassDesc,\n-                        methodNamePrefix,\n-                        pageSize));\n+        @Override\n+        public Loadable build(Snippet[] loadElementSnippets) {\n+            this.loadElementSnippets = Objects.requireNonNull(loadElementSnippets);\n+            if (shouldPaginate(loadElementSnippets.length)) {\n+                setupHelpers();\n+                return new Loadable(classDesc, this::invokePageHelper);\n@@ -412,1 +289,1 @@\n-                return LoadableSet.of(elements, loader);\n+                return new Loadable(classDesc, this::newArray);\n@@ -415,5 +292,0 @@\n-\n-        @Override\n-        default ClassDesc classDesc() {\n-            return CD_Set;\n-        }\n@@ -422,12 +294,4 @@\n-    private static final class TinySet<T> implements LoadableSet {\n-        ArrayList<Snippet> loadElementSnippets;\n-\n-        TinySet(Collection<T> elements, CollectionElementBuilder<T> loader) {\n-            \/\/ The Set::of API supports up to 10 elements\n-            if (elements.size() > 10) {\n-                throw new IllegalArgumentException();\n-            }\n-            loadElementSnippets = new ArrayList<>(elements.size());\n-            for (T e: elements) {\n-                loadElementSnippets.add(loader.build(e, loadElementSnippets.size()));\n-            }\n+    \/\/ Set support\n+    public static class SetSnippetBuilder extends ArraySnippetBuilder {\n+        public SetSnippetBuilder(ClassDesc elementType) {\n+            super(elementType);\n@@ -436,2 +300,1 @@\n-        @Override\n-        public void emit(CodeBuilder cob) {\n+        private void buildTinySet(CodeBuilder cob) {\n@@ -441,1 +304,1 @@\n-            var mtdArgs = new ClassDesc[loadElementSnippets.size()];\n+            var mtdArgs = new ClassDesc[loadElementSnippets.length];\n@@ -447,3 +310,10 @@\n-        public void setup(ClassBuilder clb) {\n-            for (var snippet: loadElementSnippets) {\n-                snippet.setup(clb);\n+        public Loadable build(Snippet[] loadElementSnippets) {\n+            if (loadElementSnippets.length <= 2) {\n+                this.loadElementSnippets = loadElementSnippets;\n+                return new Loadable(CD_Set, this::buildTinySet);\n+            } else {\n+                var array = super.build(loadElementSnippets);\n+                return new Loadable(CD_Set, cob -> {\n+                    array.emit(cob);\n+                    cob.invokestatic(CD_Set, \"of\", MethodTypeDesc.of(CD_Set, CD_Object.arrayType()), true);\n+                });\n@@ -453,19 +323,0 @@\n-\n-    private static final class ArrayAsSet<T> implements LoadableSet {\n-        final LoadableArray elements;\n-\n-        ArrayAsSet(LoadableArray elements) {\n-            this.elements = elements;\n-        }\n-\n-        @Override\n-        public void emit(CodeBuilder cob) {\n-            elements.emit(cob);\n-            cob.invokestatic(CD_Set, \"of\", MethodTypeDesc.of(CD_Set, CD_Object.arrayType()), true);\n-        }\n-\n-        @Override\n-        public void setup(ClassBuilder clb) {\n-            elements.setup(clb);\n-        }\n-    }\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/Snippets.java","additions":143,"deletions":292,"binary":false,"changes":435,"status":"modified"},{"patch":"@@ -44,5 +44,1 @@\n-import jdk.tools.jlink.internal.Snippets.LoadableArray;\n-import jdk.tools.jlink.internal.Snippets.LoadableSet;\n-import static jdk.tools.jlink.internal.Snippets.STRING_LOADER;\n-import static jdk.tools.jlink.internal.Snippets.STRING_PAGE_SIZE;\n-import jdk.tools.jlink.internal.Snippets.Snippet;\n+import static jdk.tools.jlink.internal.Snippets.*;\n@@ -51,1 +47,1 @@\n-import jdk.tools.jlink.internal.plugins.SystemModulesPlugin.SystemModulesClassGenerator.DedupSetBuilder;\n+import jdk.tools.jlink.internal.plugins.SystemModulesPlugin.SystemModulesClassGenerator.DedupSet;\n@@ -53,1 +49,1 @@\n-class ModuleDescriptorBuilder {\n+class ModuleDescriptorBuilder implements IndexedElementSnippetBuilder<ModuleInfo> {\n@@ -60,1 +56,1 @@\n-    private final DedupSetBuilder dedupSetBuilder;\n+    private final DedupSet dedupSet;\n@@ -62,0 +58,1 @@\n+    private final ClassBuilder clb;\n@@ -63,2 +60,3 @@\n-    ModuleDescriptorBuilder(DedupSetBuilder dedupSetBuilder, ClassDesc ownerClassDesc) {\n-        this.dedupSetBuilder = dedupSetBuilder;\n+    ModuleDescriptorBuilder(ClassBuilder clb, DedupSet dedupSet, ClassDesc ownerClassDesc) {\n+        this.clb = clb;\n+        this.dedupSet = dedupSet;\n@@ -68,0 +66,1 @@\n+    @Override\n@@ -69,1 +68,1 @@\n-        return new ModuleDescriptorSnippet(moduleInfo.descriptor(), moduleInfo.packages(), index);\n+        return new ModuleDescriptorSnippet(clb, moduleInfo.descriptor(), moduleInfo.packages(), index);\n@@ -124,1 +123,1 @@\n-        ModuleDescriptorSnippet(ModuleDescriptor md, Set<String> packages, int index) {\n+        ModuleDescriptorSnippet(ClassBuilder clb, ModuleDescriptor md, Set<String> packages, int index) {\n@@ -131,5 +130,5 @@\n-            requiresArray = buildRequiresArray();\n-            exportsArray = buildExportsArray();\n-            opensArray = buildOpensArray();\n-            providesArray = buildProvidesArray();\n-            packagesSet = buildPackagesSet(packages);\n+            requiresArray = buildRequiresArray(clb);\n+            exportsArray = buildExportsArray(clb);\n+            opensArray = buildOpensArray(clb);\n+            providesArray = buildProvidesArray(clb);\n+            packagesSet = buildPackagesSet(clb, packages);\n@@ -144,1 +143,1 @@\n-        Snippet loadRequire(Requires require, int unused) {\n+        Snippet loadRequire(Requires require) {\n@@ -146,1 +145,1 @@\n-                dedupSetBuilder.loadRequiresModifiers(cob, require.modifiers());\n+                dedupSet.requiresModifiersSets().get(require.modifiers()).emit(cob);\n@@ -161,10 +160,8 @@\n-        private LoadableArray buildRequiresArray() {\n-            return LoadableArray.of(\n-                    CD_REQUIRES,\n-                    sorted(md.requires()),\n-                    this::loadRequire,\n-                    PAGING_THRESHOLD,\n-                    ownerClassDesc,\n-                    \"module\" + index + \"Requires\",\n-                    \/\/ number safe for a single page helper under 64K size limit\n-                    2000);\n+        private Snippet buildRequiresArray(ClassBuilder clb) {\n+            return new ArraySnippetBuilder(CD_REQUIRES)\n+                    .classBuilder(clb)\n+                    .activatePagingThreshold(PAGING_THRESHOLD)\n+                    .ownerClassDesc(ownerClassDesc)\n+                    .methodNamePrefix(\"module\" + index + \"Requires\")\n+                    .pageSize(2000) \/\/ number safe for a single page helper under 64K size limit\n+                    .build(Snippet.buildAll(sorted(md.requires()), this::loadRequire));\n@@ -184,1 +181,1 @@\n-        Snippet loadExports(Exports export, int unused) {\n+        Snippet loadExports(Exports export) {\n@@ -186,1 +183,1 @@\n-                dedupSetBuilder.loadExportsModifiers(cob, export.modifiers());\n+                dedupSet.exportsModifiersSets().get(export.modifiers()).emit(cob);\n@@ -190,1 +187,1 @@\n-                    dedupSetBuilder.loadStringSet(cob, targets);\n+                    dedupSet.stringSets().get(targets).emit(cob);\n@@ -202,10 +199,8 @@\n-        private LoadableArray buildExportsArray() {\n-            return LoadableArray.of(\n-                    CD_EXPORTS,\n-                    sorted(md.exports()),\n-                    this::loadExports,\n-                    PAGING_THRESHOLD,\n-                    ownerClassDesc,\n-                    \"module\" + index + \"Exports\",\n-                    \/\/ number safe for a single page helper under 64K size limit\n-                    2000);\n+        private Snippet buildExportsArray(ClassBuilder clb) {\n+            return new ArraySnippetBuilder(CD_EXPORTS)\n+                    .classBuilder(clb)\n+                    .activatePagingThreshold(PAGING_THRESHOLD)\n+                    .ownerClassDesc(ownerClassDesc)\n+                    .methodNamePrefix(\"module\" + index + \"Exports\")\n+                    .pageSize(2000) \/\/ number safe for a single page helper under 64K size limit\n+                    .build(Snippet.buildAll(sorted(md.exports()), this::loadExports));\n@@ -226,1 +221,1 @@\n-        Snippet loadOpens(Opens open, int unused) {\n+        Snippet loadOpens(Opens open) {\n@@ -228,1 +223,1 @@\n-                dedupSetBuilder.loadOpensModifiers(cob, open.modifiers());\n+                dedupSet.opensModifiersSets().get(open.modifiers()).emit(cob);\n@@ -232,1 +227,1 @@\n-                    dedupSetBuilder.loadStringSet(cob, targets);\n+                    dedupSet.stringSets().get(targets).emit(cob);\n@@ -244,10 +239,8 @@\n-        private LoadableArray buildOpensArray() {\n-            return LoadableArray.of(\n-                    CD_OPENS,\n-                    sorted(md.opens()),\n-                    this::loadOpens,\n-                    PAGING_THRESHOLD,\n-                    ownerClassDesc,\n-                    \"module\" + index + \"Opens\",\n-                    \/\/ number safe for a single page helper under 64K size limit\n-                    2000);\n+        private Snippet buildOpensArray(ClassBuilder clb) {\n+            return new ArraySnippetBuilder(CD_OPENS)\n+                    .classBuilder(clb)\n+                    .activatePagingThreshold(PAGING_THRESHOLD)\n+                    .ownerClassDesc(ownerClassDesc)\n+                    .methodNamePrefix(\"module\" + index + \"Opens\")\n+                    .pageSize(2000) \/\/ number safe for a single page helper under 64K size limit\n+                    .build(Snippet.buildAll(sorted(md.opens()), this::loadOpens));\n@@ -263,1 +256,1 @@\n-        private Snippet loadProvides(Provides provide, int offset) {\n+        private Snippet loadProvides(ClassBuilder clb, Provides provide, int offset) {\n@@ -265,8 +258,7 @@\n-                var providersArray = LoadableArray.of(\n-                        CD_String,\n-                        provide.providers(),\n-                        STRING_LOADER,\n-                        PAGING_THRESHOLD,\n-                        ownerClassDesc,\n-                        \"module\" + index + \"Provider\" + offset,\n-                        STRING_PAGE_SIZE);\n+                var providersArray = new ArraySnippetBuilder(CD_String)\n+                        .classBuilder(clb)\n+                        .activatePagingThreshold(PAGING_THRESHOLD)\n+                        .ownerClassDesc(ownerClassDesc)\n+                        .methodNamePrefix(\"module\" + index + \"Provider\" + offset)\n+                        .pageSize(STRING_PAGE_SIZE)\n+                        .build(Snippet.buildAll(provide.providers(), Snippet::loadConstant));\n@@ -286,10 +278,9 @@\n-        private LoadableArray buildProvidesArray() {\n-            return LoadableArray.of(\n-                    CD_PROVIDES,\n-                    sorted(md.provides()),\n-                    this::loadProvides,\n-                    PAGING_THRESHOLD,\n-                    ownerClassDesc,\n-                    \"module\" + index + \"Provides\",\n-                    \/\/ number safe for a single page helper under 64K size limit\n-                    2000);\n+        private Snippet buildProvidesArray(ClassBuilder clb) {\n+            IndexedElementSnippetBuilder<Provides> builder = (e, i) -> loadProvides(clb, e, i);\n+            return new ArraySnippetBuilder(CD_PROVIDES)\n+                    .classBuilder(clb)\n+                    .activatePagingThreshold(PAGING_THRESHOLD)\n+                    .ownerClassDesc(ownerClassDesc)\n+                    .methodNamePrefix(\"module\" + index + \"Provides\")\n+                    .pageSize(2000) \/\/ number safe for a single page helper under 64K size limit\n+                    .build(builder.buildAll(md.provides()));\n@@ -298,17 +289,8 @@\n-        private LoadableSet buildPackagesSet(Collection<String> packages) {\n-            return LoadableSet.of(\n-                    sorted(packages),\n-                    STRING_LOADER,\n-                    PAGING_THRESHOLD,\n-                    ownerClassDesc,\n-                    \"module\" + index + \"Packages\",\n-                    STRING_PAGE_SIZE);\n-        }\n-\n-        @Override\n-        public void setup(ClassBuilder clb) {\n-            requiresArray.setup(clb);\n-            exportsArray.setup(clb);\n-            opensArray.setup(clb);\n-            providesArray.setup(clb);\n-            packagesSet.setup(clb);\n+        private Snippet buildPackagesSet(ClassBuilder clb, Collection<String> packages) {\n+            return new SetSnippetBuilder(CD_String)\n+                    .classBuilder(clb)\n+                    .activatePagingThreshold(PAGING_THRESHOLD)\n+                    .ownerClassDesc(ownerClassDesc)\n+                    .methodNamePrefix(\"module\" + index + \"Packages\")\n+                    .pageSize(STRING_PAGE_SIZE)\n+                    .build(Snippet.buildAll(sorted(packages), Snippet::loadConstant));\n@@ -355,1 +337,1 @@\n-            dedupSetBuilder.loadStringSet(cob, md.uses());\n+            dedupSet.stringSets().get(md.uses()).emit(cob);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/ModuleDescriptorBuilder.java","additions":74,"deletions":92,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-import java.util.function.Consumer;\n@@ -90,1 +89,0 @@\n-\n@@ -93,1 +91,0 @@\n-\n@@ -531,6 +528,0 @@\n-        private static final ClassDesc CD_REQUIRES_MODIFIER =\n-            ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Requires$Modifier\");\n-        private static final ClassDesc CD_EXPORTS_MODIFIER =\n-            ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Exports$Modifier\");\n-        private static final ClassDesc CD_OPENS_MODIFIER =\n-            ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Opens$Modifier\");\n@@ -627,1 +618,1 @@\n-                        genConstants(clb);\n+                        var dedupSets = genConstants(clb);\n@@ -636,1 +627,1 @@\n-                        genModuleDescriptorsMethod(clb);\n+                        genModuleDescriptorsMethod(clb, dedupSets);\n@@ -667,3 +658,4 @@\n-        private void genConstants(ClassBuilder clb) {\n-            var clinitSnippets = dedupSetBuilder.buildConstants(clb);\n-            if (!clinitSnippets.isEmpty()) {\n+        private DedupSet genConstants(ClassBuilder clb) {\n+            var dedupSet = dedupSetBuilder.build(clb);\n+            var clinitSnippet = dedupSet.cacheSetupSnippet();\n+            if (!clinitSnippet.isEmpty()) {\n@@ -675,1 +667,1 @@\n-                            clinitSnippets.get().accept(cob);\n+                            clinitSnippet.get().emit(cob);\n@@ -679,0 +671,1 @@\n+            return dedupSet;\n@@ -717,13 +710,10 @@\n-        private void genModuleDescriptorsMethod(ClassBuilder clb) {\n-            var converter = new ModuleDescriptorBuilder(dedupSetBuilder, classDesc);\n-            var moduleDescriptors = LoadableArray.of(CD_MODULE_DESCRIPTOR,\n-                    moduleInfos,\n-                    converter::build,\n-                    moduleDescriptorsPerMethod,\n-                    classDesc,\n-                    \"sub\",\n-                    moduleDescriptorsPerMethod);\n-\n-            \/\/ This setup helpers needed by the LoadableArray, but element loader is responsible\n-            \/\/ to setup elements.\n-            moduleDescriptors.setup(clb);\n+        private void genModuleDescriptorsMethod(ClassBuilder clb, DedupSet dedupSets) {\n+            var converter = new ModuleDescriptorBuilder(clb, dedupSets, classDesc);\n+            var elementSnippets = converter.buildAll(moduleInfos);\n+            var moduleDescriptors = new ArraySnippetBuilder(CD_MODULE_DESCRIPTOR)\n+                    .classBuilder(clb)\n+                    .activatePagingThreshold(moduleDescriptorsPerMethod)\n+                    .ownerClassDesc(classDesc)\n+                    .methodNamePrefix(\"sub\")\n+                    .pageSize(moduleDescriptorsPerMethod)\n+                    .build(elementSnippets);\n@@ -946,2 +936,4 @@\n-            var loadableSet = LoadableSet.of(sorted(set), STRING_LOADER);\n-            loadableSet.emit(cob);\n+            var snippets = Snippet.buildAll(sorted(set), Snippet::loadConstant);\n+            new SetSnippetBuilder(CD_String)\n+                    .build(snippets)\n+                    .emit(cob);\n@@ -1045,4 +1037,5 @@\n-        static class DedupSetBuilder {\n-            \/\/ map Set<String> to a specialized builder to allow them to be\n-            \/\/ deduplicated as they are requested\n-            final Map<Set<String>, SetReference> stringSets = new HashMap<>();\n+        static record DedupSet(Map<Set<String>, Snippet> stringSets,\n+                               Map<Set<Requires.Modifier>, Snippet> requiresModifiersSets,\n+                               Map<Set<Opens.Modifier>, Snippet> opensModifiersSets,\n+                               Map<Set<Exports.Modifier>, Snippet> exportsModifiersSets,\n+                               Optional<Snippet> cacheSetupSnippet) {};\n@@ -1050,3 +1043,3 @@\n-            \/\/ map Set<Requires.Modifier> to a specialized builder to allow them to be\n-            \/\/ deduplicated as they are requested\n-            final Map<Set<Requires.Modifier>, SetReference>\n+        static class DedupSetBuilder {\n+            final Map<Set<String>, SetReference<String>> stringSets = new HashMap<>();\n+            final Map<Set<Requires.Modifier>, SetReference<Requires.Modifier>>\n@@ -1054,4 +1047,1 @@\n-\n-            \/\/ map Set<Exports.Modifier> to a specialized builder to allow them to be\n-            \/\/ deduplicated as they are requested\n-            final Map<Set<Exports.Modifier>, SetReference>\n+            final Map<Set<Exports.Modifier>, SetReference<Exports.Modifier>>\n@@ -1059,4 +1049,1 @@\n-\n-            \/\/ map Set<Opens.Modifier> to a specialized builder to allow them to be\n-            \/\/ deduplicated as they are requested\n-            final Map<Set<Opens.Modifier>, SetReference>\n+            final Map<Set<Opens.Modifier>, SetReference<Opens.Modifier>>\n@@ -1065,2 +1052,0 @@\n-            private static final String VALUES_ARRAY = \"dedupSetValues\";\n-\n@@ -1068,1 +1053,2 @@\n-            private final ArrayList<SetReference> values = new ArrayList<>();\n+            final CacheBuilder cacheBuilder = new CacheBuilder();\n+            int setBuilt = 0;\n@@ -1074,13 +1060,0 @@\n-            <T extends Comparable<T>> SetReference createLoadableSet(Set<T> elements, CollectionElementBuilder<T> elementLoader) {\n-                var loadableSet = LoadableSet.of(sorted(elements),\n-                                                 elementLoader,\n-                                                 PAGING_THRESHOLD,\n-                                                 owner,\n-                                                 \"dedupSet\" + values.size(),\n-                                                 \/\/ Safe for String and Enum within 64K\n-                                                 3000);\n-                var ref = new SetReference(loadableSet);\n-                values.add(ref);\n-                return ref;\n-            }\n-\n@@ -1088,2 +1061,2 @@\n-             * Add the given set of strings to this builder.\n-             *\/\n+            * Add the given set of strings to this builder.\n+            *\/\n@@ -1091,3 +1064,1 @@\n-                stringSets.computeIfAbsent(strings,\n-                        s -> createLoadableSet(s, STRING_LOADER)\n-                ).increment();\n+                stringSets.computeIfAbsent(strings, SetReference<String>::new).increment();\n@@ -1097,2 +1068,2 @@\n-             * Add the given set of Exports.Modifiers\n-             *\/\n+            * Add the given set of Exports.Modifiers\n+            *\/\n@@ -1100,3 +1071,1 @@\n-                exportsModifiersSets.computeIfAbsent(mods,\n-                        s -> createLoadableSet(s, (export, _) -> new EnumConstant(export))\n-                ).increment();\n+                exportsModifiersSets.computeIfAbsent(mods, SetReference<Exports.Modifier>::new).increment();\n@@ -1106,2 +1075,2 @@\n-             * Add the given set of Opens.Modifiers\n-             *\/\n+            * Add the given set of Opens.Modifiers\n+            *\/\n@@ -1109,3 +1078,1 @@\n-                opensModifiersSets.computeIfAbsent(mods,\n-                        s -> createLoadableSet(s, (open, _) -> new EnumConstant(open))\n-                ).increment();\n+                opensModifiersSets.computeIfAbsent(mods, SetReference::new).increment();\n@@ -1115,2 +1082,2 @@\n-             * Add the given set of Requires.Modifiers\n-             *\/\n+            * Add the given set of Requires.Modifiers\n+            *\/\n@@ -1118,3 +1085,1 @@\n-                requiresModifiersSets.computeIfAbsent(mods,\n-                        s -> createLoadableSet(s, (require, _) -> new EnumConstant(require))\n-                ).increment();\n+                requiresModifiersSets.computeIfAbsent(mods, SetReference::new).increment();\n@@ -1123,5 +1088,9 @@\n-            \/*\n-             * Load the given set to the top of operand stack.\n-             *\/\n-            void loadStringSet(CodeBuilder cob, Set<String> names) {\n-                stringSets.get(names).emit(cob);\n+            private Snippet buildStringSet(ClassBuilder clb, SetReference<String> setRef) {\n+                return cacheBuilder.transform(setRef,\n+                        new SetSnippetBuilder(CD_String)\n+                                .classBuilder(clb)\n+                                .activatePagingThreshold(PAGING_THRESHOLD)\n+                                .ownerClassDesc(owner)\n+                                .methodNamePrefix(\"dedupSet\" + setBuilt++)\n+                                .pageSize(STRING_PAGE_SIZE)\n+                                .build(Snippet.buildAll(setRef.elements(), Snippet::loadConstant)));\n@@ -1130,5 +1099,9 @@\n-            \/*\n-             * Load the given set to the top of operand stack.\n-             *\/\n-            void loadExportsModifiers(CodeBuilder cob, Set<Exports.Modifier> mods) {\n-                exportsModifiersSets.get(mods).emit(cob);\n+            private <T extends Enum<T>> Snippet buildEnumSet(ClassBuilder clb, SetReference<T> setRef) {\n+                return cacheBuilder.transform(setRef,\n+                        new SetSnippetBuilder(CD_Object)\n+                                .classBuilder(clb)\n+                                .activatePagingThreshold(PAGING_THRESHOLD)\n+                                .ownerClassDesc(owner)\n+                                .methodNamePrefix(\"dedupSet\" + setBuilt++)\n+                                .pageSize(ENUM_PAGE_SIZE)\n+                                .build(Snippet.buildAll(setRef.elements(), Snippet::loadEnum)));\n@@ -1137,5 +1110,5 @@\n-            \/*\n-             * Load the given set to the top of operand stack.\n-             *\/\n-            void loadOpensModifiers(CodeBuilder cob, Set<Opens.Modifier> mods) {\n-                opensModifiersSets.get(mods).emit(cob);\n+            private Map<Set<String>, Snippet> buildStringSets(ClassBuilder clb, Map<Set<String>, SetReference<String>> map) {\n+                Map<Set<String>, Snippet> snippets = new HashMap<>(map.size());\n+                map.entrySet().forEach(entry -> snippets.put(entry.getKey(),\n+                        buildStringSet(clb, entry.getValue())));\n+                return snippets;\n@@ -1144,6 +1117,5 @@\n-\n-            \/*\n-             * Load the given set to the top of operand stack.\n-             *\/\n-            void loadRequiresModifiers(CodeBuilder cob, Set<Requires.Modifier> mods) {\n-                requiresModifiersSets.get(mods).emit(cob);\n+            private <T extends Enum<T>> Map<Set<T>, Snippet> buildEnumSets(ClassBuilder clb, Map<Set<T>, SetReference<T>> map) {\n+                Map<Set<T>, Snippet> snippets = new HashMap<>(map.size());\n+                map.entrySet().forEach(entry -> snippets.put(entry.getKey(),\n+                        buildEnumSet(clb, entry.getValue())));\n+                return snippets;\n@@ -1152,47 +1124,8 @@\n-            \/*\n-             * Adding provider methods to the class. For those set used more than once, built\n-             * once and keep the reference for later access.\n-             * Return a snippet to setup the cache <clinit>.\n-             *\n-             * The returned snippet would set up the set referenced more than once,\n-             *\n-             * static final Set[] dedupSetValues;\n-             *\n-             * static {\n-             *     dedupSetValues = new Set[countOfStoredValues];\n-             *     dedupSetValues[0] = Set.of(elements); \/\/ elements no more than SET_SIZE_THRESHOLD\n-             *     dedupSetValues[1] = dedup<setWithIndex>Provider(); \/\/ set elements more than SET_SIZE_THRESHOLD\n-             *     ...\n-             *     dedupSetValues[countOfStoredValues - 1] = ...\n-             * }\n-             *\/\n-            Optional<Consumer<CodeBuilder>> buildConstants(ClassBuilder clb) {\n-                var staticCache = new ArrayList<SetReference>();\n-\n-                for (var set: values) {\n-                    set.setup(clb);\n-                    if (set.refCount() > 1) {\n-                        staticCache.add(set);\n-                    }\n-                }\n-\n-                if (staticCache.isEmpty()) {\n-                    return Optional.empty();\n-                }\n-\n-                var cacheValuesArray = LoadableArray.of(\n-                        CD_Set,\n-                        staticCache,\n-                        SetReference::build,\n-                        PAGING_THRESHOLD,\n-                        owner,\n-                        VALUES_ARRAY,\n-                        2000);\n-\n-                cacheValuesArray.setup(clb);\n-                clb.withField(VALUES_ARRAY, CD_Set.arrayType(), ACC_STATIC | ACC_FINAL);\n-\n-                return Optional.of(cob -> {\n-                        cacheValuesArray.emit(cob);\n-                        cob.putstatic(owner, VALUES_ARRAY, CD_Set.arrayType());\n-                });\n+            DedupSet build(ClassBuilder clb) {\n+                return new DedupSet(\n+                    buildStringSets(clb, stringSets),\n+                    buildEnumSets(clb, requiresModifiersSets),\n+                    buildEnumSets(clb, opensModifiersSets),\n+                    buildEnumSets(clb, exportsModifiersSets),\n+                    cacheBuilder.build(clb)\n+                );\n@@ -1208,1 +1141,1 @@\n-            class SetReference implements Snippet {\n+            class SetReference<T extends Comparable<T>> {\n@@ -1210,2 +1143,1 @@\n-                private final LoadableSet loadableSet;\n-\n+                private final List<T> elements;\n@@ -1213,2 +1145,0 @@\n-                \/\/ The index for this set value in the cache array\n-                private int index = -1;\n@@ -1216,2 +1146,2 @@\n-                SetReference(LoadableSet set) {\n-                    this.loadableSet = set;\n+                SetReference(Set<T> elements) {\n+                    this.elements = sorted(elements);\n@@ -1228,0 +1158,9 @@\n+                List<T> elements() {\n+                    return elements;\n+                }\n+            }\n+\n+            class CacheBuilder {\n+                private static final String VALUES_ARRAY = \"dedupSetValues\";\n+                final ArrayList<Snippet> cachedValues = new ArrayList<>();\n+\n@@ -1233,7 +1172,12 @@\n-                @Override\n-                public void emit(CodeBuilder cob) {\n-                    if (refCount > 1) {\n-                        assert index >= 0;\n-                        cob.getstatic(owner, VALUES_ARRAY, CD_Set.arrayType());\n-                        cob.loadConstant(index);\n-                        cob.aaload();\n+                private Snippet loadFromCache(int index) {\n+                    assert index >= 0;\n+                    return cob ->\n+                        cob.getstatic(owner, VALUES_ARRAY, CD_Set.arrayType())\n+                           .loadConstant(index)\n+                           .aaload();\n+                }\n+\n+                Snippet transform(SetReference<?> setRef, Snippet loadSnippet) {\n+                    if (setRef.refCount() > 1) {\n+                        cachedValues.add(loadSnippet);\n+                        return loadFromCache(cachedValues.size() - 1);\n@@ -1241,1 +1185,1 @@\n-                        loadableSet.emit(cob);\n+                        return loadSnippet;\n@@ -1245,4 +1189,29 @@\n-                @Override\n-                public void setup(ClassBuilder clb) {\n-                    loadableSet.setup(clb);\n-                }\n+                \/*\n+                * Adding provider methods to the class. For those set used more than once, built\n+                * once and keep the reference for later access.\n+                * Return a snippet to setup the cache <clinit>.\n+                *\n+                * The returned snippet would set up the set referenced more than once,\n+                *\n+                * static final Set[] dedupSetValues;\n+                *\n+                * static {\n+                *     dedupSetValues = new Set[countOfStoredValues];\n+                *     dedupSetValues[0] = Set.of(elements); \/\/ elements no more than SET_SIZE_THRESHOLD\n+                *     dedupSetValues[1] = dedup<setWithIndex>Provider(); \/\/ set elements more than SET_SIZE_THRESHOLD\n+                *     ...\n+                *     dedupSetValues[countOfStoredValues - 1] = ...\n+                * }\n+                *\/\n+                Optional<Snippet> build(ClassBuilder clb) {\n+                    if (cachedValues.isEmpty()) {\n+                        return Optional.empty();\n+                    }\n+\n+                    var cacheValuesArray = new ArraySnippetBuilder(CD_Set)\n+                            .classBuilder(clb)\n+                            .activatePagingThreshold(PAGING_THRESHOLD)\n+                            .ownerClassDesc(owner)\n+                            .methodNamePrefix(VALUES_ARRAY)\n+                            .pageSize(2000)\n+                            .build(cachedValues.toArray(Snippet[]::new));\n@@ -1250,9 +1219,6 @@\n-                \/**\n-                 * Build the snippet to load the set onto the operand stack for storing into cache\n-                 * to be later accessed by the SetReference::emit\n-                 *\/\n-                Snippet build(int index) {\n-                    this.index = index;\n-                    return cob -> {\n-                        loadableSet.emit(cob);\n-                    };\n+                    clb.withField(VALUES_ARRAY, CD_Set.arrayType(), ACC_STATIC | ACC_FINAL);\n+\n+                    return Optional.of(cob -> {\n+                            cacheValuesArray.emit(cob);\n+                            cob.putstatic(owner, VALUES_ARRAY, CD_Set.arrayType());\n+                    });\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/SystemModulesPlugin.java","additions":143,"deletions":177,"binary":false,"changes":320,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.classfile.ClassBuilder;\n@@ -43,0 +44,1 @@\n+import java.util.function.Function;\n@@ -52,1 +54,0 @@\n-import static jdk.tools.jlink.internal.Snippets.*;\n@@ -94,34 +95,0 @@\n-    @ParameterizedTest\n-    @ValueSource(booleans = { true, false })\n-    void testLoadableProvider(boolean isStatic) throws NoSuchMethodException {\n-        var expected = IntStream.range(0, 1234)\n-                                 .mapToObj(i -> \"WrapperTestString\" + i)\n-                                 .toList();\n-        var className = \"WrapperLoadableTest\" + (isStatic ? \"Static\" : \"Public\");\n-        ClassDesc testClassDesc = ClassDesc.of(className);\n-\n-        var loadable = new PaginatedArray<>(\n-                CD_String, expected, STRING_LOADER, testClassDesc, \"page\", 100);\n-        \/\/ 1234 with 10 per page, should have 13 pages with last page 34 elements\n-        assertEquals(13, loadable.pageCount());\n-        assertTrue(loadable.isLastPagePartial());\n-\n-        var provider = new LoadableProvider(loadable, testClassDesc, \"wrapper\", isStatic);\n-        Supplier<String[]> supplier = generateSupplier(className, provider, loadable);\n-        verifyPaginationMethods(supplier.getClass(), String.class, \"page\", 13);\n-        assertArrayEquals(expected.toArray(), supplier.get());\n-\n-        \/\/ check wrapper function\n-        var methodType = MethodType.methodType(String[].class);\n-        try {\n-            lookup().findStatic(supplier.getClass(), provider.methodName(), methodType);\n-        } catch (IllegalAccessException ex) {\n-            assertFalse(isStatic);\n-        }\n-        try {\n-            lookup().findVirtual(supplier.getClass(), provider.methodName(), methodType);\n-        } catch (IllegalAccessException ex) {\n-            assertTrue(isStatic);\n-        }\n-    }\n-\n@@ -137,4 +104,4 @@\n-        var loadable = new SimpleArray<EnumConstant>(\n-                Enum.class.describeConstable().get(),\n-                Arrays.stream(enums).map(EnumConstant::new).toList(),\n-                (enumConstant, _) -> enumConstant);\n+        Snippet[] elementSnippets = Snippet.buildAll(Arrays.asList(enums), Snippet::loadEnum);\n+\n+        var loadable = new ArraySnippetBuilder(Enum.class.describeConstable().get())\n+                .build(elementSnippets);\n@@ -142,1 +109,1 @@\n-        Supplier<Enum<?>[]> supplier = generateSupplier(\"LoadableEnumTest\", loadable);\n+        Supplier<Enum<?>[]> supplier = generateSupplier(\"LoadableEnumTest\", clb -> loadable);\n@@ -147,1 +114,1 @@\n-    void testLoadableArrayOf() {\n+    void testArraySnippetBuilder() {\n@@ -152,10 +119,8 @@\n-        var loadable = LoadableArray.of(CD_Integer,\n-                Arrays.asList(expected),\n-                INTEGER_LOADER,\n-                expected.length - 1,\n-                ClassDesc.of(className),\n-                \"page\",\n-                100);\n-        assertTrue(loadable instanceof PaginatedArray);\n-\n-        Supplier<Integer[]> supplier = generateSupplier(className, loadable);\n+        var elementSnippets = Snippet.buildAll(Arrays.asList(expected), Snippet::loadInteger);\n+        var instance = new ArraySnippetBuilder(CD_Integer)\n+                .activatePagingThreshold(expected.length - 1)\n+                .ownerClassDesc(ClassDesc.of(className))\n+                .methodNamePrefix(\"page\")\n+                .pageSize(100);\n+\n+        Supplier<Integer[]> supplier = generateSupplier(className, clb -> instance.classBuilder(clb).build(elementSnippets));\n@@ -165,9 +130,5 @@\n-        loadable = LoadableArray.of(\n-                CD_Integer,\n-                Arrays.asList(expected),\n-                INTEGER_LOADER,\n-                expected.length,\n-                ClassDesc.of(\"LoadableArrayOf200NotPaged\"),\n-                \"page\",\n-                100);\n-        assertTrue(loadable instanceof SimpleArray);\n+        var loadable = instance.activatePagingThreshold(expected.length)\n+                .ownerClassDesc(ClassDesc.of(\"LoadableArrayOf200NotPaged\"))\n+                .methodNamePrefix(\"page\")\n+                .pageSize(100)\n+                .build(elementSnippets);\n@@ -176,1 +137,2 @@\n-        supplier = generateSupplier(\"TestLoadableArrayFactory\", loadable);\n+        supplier = generateSupplier(\"TestLoadableArrayFactory\", clb -> loadable);\n+        verifyPaginationMethods(supplier.getClass(), Integer.class, \"page\", 0);\n@@ -181,1 +143,1 @@\n-    void testLoadableSetOf() {\n+    void testSetSnippetBuilder() {\n@@ -188,0 +150,1 @@\n+        var setBuilder = new SetSnippetBuilder(CD_String);\n@@ -189,1 +152,2 @@\n-        Supplier<Set<String>> supplier = generateSupplier(\"TinySetTest\", LoadableSet.of(tiny, STRING_LOADER));\n+        Supplier<Set<String>> supplier = generateSupplier(\"TinySetTest\", clb ->\n+                setBuilder.build(Snippet.buildAll(tiny, Snippet::loadConstant)));\n@@ -193,1 +157,4 @@\n-        supplier = generateSupplier(\"AllSetTestNoPage\", LoadableSet.of(all, STRING_LOADER));\n+        var allSnippets = Snippet.buildAll(all, Snippet::loadConstant);\n+\n+        supplier = generateSupplier(\"AllSetTestNoPage\", clb ->\n+                setBuilder.build(allSnippets));\n@@ -198,3 +165,6 @@\n-        var loadable = LoadableSet.of(all, STRING_LOADER, all.size(),\n-                ClassDesc.of(className), methodNamePrefix, 10);\n-        supplier = generateSupplier(className, loadable);\n+        var loadable = setBuilder.activatePagingThreshold(all.size())\n+                .ownerClassDesc(ClassDesc.of(className))\n+                .methodNamePrefix(methodNamePrefix)\n+                .pageSize(10)\n+                .build(allSnippets);\n+        supplier = generateSupplier(className, clb -> loadable);\n@@ -204,5 +174,6 @@\n-        loadable = LoadableSet.of(all, STRING_LOADER, all.size() - 1,\n-                ClassDesc.of(className), methodNamePrefix, 20);\n-        supplier = generateSupplier(className, loadable);\n-        \/\/ Set erased element type and use Object as element type\n-        verifyPaginationMethods(supplier.getClass(), Object.class, methodNamePrefix, 5);\n+        setBuilder.ownerClassDesc(ClassDesc.of(className));\n+        supplier = generateSupplier(className, clb -> setBuilder.classBuilder(clb)\n+                .activatePagingThreshold(all.size() - 1)\n+                .pageSize(20)\n+                .build(allSnippets));\n+        verifyPaginationMethods(supplier.getClass(), String.class, methodNamePrefix, 5);\n@@ -218,6 +189,11 @@\n-        var loadable = new PaginatedArray<>(CD_String, expected, STRING_LOADER,\n-                testClassDesc, \"ArrayPage\", pageSize);\n-\n-        Supplier<String[]> supplier = generateSupplier(className, loadable);\n-        verifyPaginationMethods(supplier.getClass(), String.class, \"ArrayPage\", loadable.pageCount());\n-        assertEquals((elementCount % pageSize) != 0, loadable.isLastPagePartial());\n+        var builder = new ArraySnippetBuilder(CD_String)\n+                .activatePagingThreshold(1)\n+                .ownerClassDesc(testClassDesc)\n+                .methodNamePrefix(\"ArrayPage\")\n+                .pageSize(pageSize);\n+        var snippets = Snippet.buildAll(Arrays.asList(expected), Snippet::loadConstant);\n+        var pagingContext = new PagingContext(expected.length, pageSize);\n+\n+        Supplier<String[]> supplier = generateSupplier(className, clb -> builder.classBuilder(clb).build(snippets));\n+        verifyPaginationMethods(supplier.getClass(), String.class, \"ArrayPage\", pagingContext.pageCount());\n+        assertEquals((elementCount % pageSize) != 0, pagingContext.isLastPagePartial());\n@@ -232,1 +208,2 @@\n-        var array = new SimpleArray<>(CD_String, Arrays.asList(expected), STRING_LOADER);\n+        var array = new ArraySnippetBuilder(CD_String)\n+                .build(Snippet.buildAll(Arrays.asList(expected), Snippet::loadConstant));\n@@ -234,1 +211,1 @@\n-        Supplier<String[]> supplier = generateSupplier(className, array);\n+        Supplier<String[]> supplier = generateSupplier(className, clb -> array);\n@@ -238,1 +215,1 @@\n-    <T> Supplier<T> generateSupplier(String className, Loadable loadable, Loadable... extra) {\n+    <T> Supplier<T> generateSupplier(String className, Function<ClassBuilder, Loadable> builder) {\n@@ -240,1 +217,1 @@\n-        byte[] classBytes = generateSupplierClass(testClassDesc, loadable, extra);\n+        byte[] classBytes = generateSupplierClass(testClassDesc, builder);\n@@ -252,0 +229,8 @@\n+        var methodType = MethodType.methodType(elementType.arrayType(), elementType.arrayType());\n+        if (pageCount <= 0) {\n+            try {\n+                lookup().findStatic(testClass, methodNamePrefix + 0, methodType);\n+                fail(\"Unexpected paginate helper function\");\n+            } catch (Exception ex) {}\n+        }\n+\n@@ -254,2 +239,1 @@\n-                lookup().findStatic(testClass, methodNamePrefix + i,\n-                        MethodType.methodType(elementType.arrayType(), elementType.arrayType()));\n+                lookup().findStatic(testClass, methodNamePrefix + i, methodType);\n@@ -262,1 +246,1 @@\n-    byte[] generateSupplierClass(ClassDesc testClassDesc, Loadable loadable, Loadable... extra) {\n+    byte[] generateSupplierClass(ClassDesc testClassDesc, Function<ClassBuilder, Loadable> builder) {\n@@ -273,7 +257,1 @@\n-                    loadable.setup(clb);\n-\n-                    for (var e: extra) {\n-                        \/\/ always call setup should be no harm\n-                        \/\/ it suppose to be nop if not required.\n-                        e.setup(clb);\n-                    }\n+                    var loadable = builder.apply(clb);\n","filename":"test\/jdk\/tools\/jlink\/SnippetsTest.java","additions":70,"deletions":92,"binary":false,"changes":162,"status":"modified"}]}