{"files":[{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2024, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.tools.jlink.internal;\n+\n+import java.lang.classfile.ClassBuilder;\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.constant.ClassDesc;\n+import static java.lang.constant.ConstantDescs.CD_Object;\n+import static java.lang.constant.ConstantDescs.CD_Set;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.function.BiConsumer;\n+\n+public class Snippets {\n+    \/**\n+     * Return a snippet builder that loads an enum onto the operand stack using\n+     * the enum name static final field\n+     *\/\n+    public static <T extends Enum<T>> BiConsumer<CodeBuilder, T> getEnumLoader(ClassDesc enumClassDesc) {\n+        return (cob, element) -> cob.getstatic(enumClassDesc, element.name(), enumClassDesc);\n+    }\n+\n+    \/**\n+     * Generate bytecode to create an array and load onto the operand stack.\n+     * Effectively like following pseudo code:\n+     *   new T[] { elements }\n+     *\n+     * @param cob The code builder to add the snipper\n+     * @param elementType The class descriptor of the element type T\n+     * @param elements The elements to be in the array\n+     * @param elementLoader A snippet generator to load an element T onto the operand stack.\n+     *\/\n+    public static <T> void loadArray(CodeBuilder cob,\n+                                     ClassDesc elementType,\n+                                     Collection<T> elements,\n+                                     BiConsumer<CodeBuilder, T> elementLoader) {\n+        cob.loadConstant(elements.size())\n+           .anewarray(elementType);\n+        int arrayIndex = 0;\n+        for (T t : elements) {\n+            cob.dup()    \/\/ arrayref\n+               .loadConstant(arrayIndex);\n+            elementLoader.accept(cob, t);  \/\/ value\n+            cob.aastore();\n+            arrayIndex++;\n+        }\n+    }\n+\n+    \/**\n+     * Generates bytecode to load a set onto the operand stack.\n+     * Effectively like following pseudo code:\n+     *   Set.of(elements)\n+     * @param cob The code builder to add the snippet\n+     * @param elements The set to be created\n+     * @param elementLoader Snippet generator to load an element onto the operand stack\n+     *\/\n+    public static <T> void loadImmutableSet(CodeBuilder cob,\n+                                            Collection<T> elements,\n+                                            BiConsumer<CodeBuilder, T> elementLoader) {\n+        if (elements.size() <= 10) {\n+            \/\/ call Set.of(e1, e2, ...)\n+            for (T t : elements) {\n+                elementLoader.accept(cob, t);\n+            }\n+            var mtdArgs = new ClassDesc[elements.size()];\n+            Arrays.fill(mtdArgs, CD_Object);\n+            cob.invokestatic(CD_Set, \"of\", MethodTypeDesc.of(CD_Set, mtdArgs), true);\n+        } else {\n+            \/\/ call Set.of(E... elements)\n+            loadArray(cob, CD_Object, elements, elementLoader);\n+            cob.invokestatic(CD_Set, \"of\", MethodTypeDesc.of(CD_Set, CD_Object.arrayType()), true);\n+        }\n+    }\n+\n+    \/\/ Generate a method with pseudo code looks like this\n+    \/\/ static Set<T> methodName() {\n+    \/\/     return Set.of(elements);\n+    \/\/ }\n+    public static <T> void genImmutableSetProvider(ClassBuilder clb,\n+                                                   String methodName,\n+                                                   Collection<T> elements,\n+                                                   BiConsumer<CodeBuilder, T> elementLoader) {\n+        clb.withMethodBody(\n+                methodName,\n+                MethodTypeDesc.of(CD_Set),\n+                ACC_STATIC,\n+                cob -> {\n+                    loadImmutableSet(cob, elements, elementLoader);\n+                    cob.areturn();\n+                });\n+    }\n+\n+    \/\/ Generate a method with pseudo code looks like this\n+    \/\/ static T[] methodName() {\n+    \/\/     return new T[] { elements };\n+    \/\/ }\n+    public static <T> void genArrayProvider(ClassBuilder clb,\n+                                            String methodName,\n+                                            ClassDesc elementType,\n+                                            Collection<T> elements,\n+                                            BiConsumer<CodeBuilder, T> elementLoader) {\n+        clb.withMethodBody(\n+                methodName,\n+                MethodTypeDesc.of(elementType.arrayType()),\n+                ACC_STATIC,\n+                cob -> {\n+                    loadArray(cob, elementType, elements, elementLoader);\n+                    cob.areturn();\n+                });\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/Snippets.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -48,1 +48,0 @@\n-import java.util.Arrays;\n@@ -81,1 +80,0 @@\n-import static java.lang.classfile.ClassFile.*;\n@@ -90,0 +88,8 @@\n+import static java.lang.classfile.ClassFile.*;\n+\n+import static jdk.tools.jlink.internal.Snippets.genArrayProvider;\n+import static jdk.tools.jlink.internal.Snippets.genImmutableSetProvider;\n+import static jdk.tools.jlink.internal.Snippets.getEnumLoader;\n+import static jdk.tools.jlink.internal.Snippets.loadArray;\n+import static jdk.tools.jlink.internal.Snippets.loadImmutableSet;\n+\n@@ -541,1 +547,1 @@\n-        private static final MethodTypeDesc MTD_Set_ObjectArray = MethodTypeDesc.of(CD_Set, CD_Object.arrayType());\n+\n@@ -672,1 +678,2 @@\n-                            cob.return_();\n+                            cob.pop()\n+                               .return_();\n@@ -1015,1 +1022,1 @@\n-            loadImmutableSet(cob, set, CodeBuilder::loadConstant);\n+            loadImmutableSet(cob, sorted(set), CodeBuilder::loadConstant);\n@@ -1223,1 +1230,1 @@\n-                    addModuleHelpers(clb -> clb.withMethodBody(\n+                    addModuleHelpers(clb -> genArrayProvider(clb,\n@@ -1225,6 +1232,3 @@\n-                            MethodTypeDesc.of(CD_EXPORTS.arrayType()),\n-                            ACC_STATIC,\n-                            mcob -> {\n-                                genExportSet(mcob, exports);\n-                                mcob.areturn();\n-                            }));\n+                            CD_EXPORTS,\n+                            sorted(exports),\n+                            this::loadExports));\n@@ -1233,14 +1237,1 @@\n-                    genExportSet(cob, exports);\n-                }\n-            }\n-\n-            void genExportSet(CodeBuilder cb, Set<Exports> exports) {\n-                cb.loadConstant(exports.size())\n-                  .anewarray(CD_EXPORTS);\n-                int arrayIndex = 0;\n-\n-                for (Exports export : sorted(exports)) {\n-                    cb.dup() \/\/ arrayref\n-                      .loadConstant(arrayIndex++);\n-                    newExports(cb, export.modifiers(), export.source(), export.targets());\n-                    cb.aastore();\n+                    loadArray(cob, CD_EXPORTS, sorted(exports), this::loadExports);\n@@ -1257,7 +1248,3 @@\n-             * Set<String> targets = new HashSet<>();\n-             * targets.add(t);\n-             * :\n-             * :\n-             *\n-             * Set<Modifier> mods = ...\n-             * Builder.newExports(mods, pn, targets);\n+             * ms = export.modifiers()\n+             * pn = export.source()\n+             * targets = export.targets()\n@@ -1265,3 +1252,4 @@\n-            void newExports(CodeBuilder cb, Set<Exports.Modifier> ms, String pn, Set<String> targets) {\n-                dedupSetBuilder.loadExportsModifiers(cb, ms);\n-                cb.loadConstant(pn);\n+            void loadExports(CodeBuilder cb, Exports export) {\n+                dedupSetBuilder.loadExportsModifiers(cb, export.modifiers());\n+                cb.loadConstant(export.source());\n+                var targets = export.targets();\n@@ -1275,2 +1263,2 @@\n-                                     \"newExports\",\n-                                     MTD_EXPORTS_MODIFIER_SET_STRING);\n+                                    \"newExports\",\n+                                    MTD_EXPORTS_MODIFIER_SET_STRING);\n@@ -1287,10 +1275,2 @@\n-                cob.aload(BUILDER_VAR)\n-                   .loadConstant(opens.size())\n-                   .anewarray(CD_OPENS);\n-                int arrayIndex = 0;\n-                for (Opens open : sorted(opens)) {\n-                    cob.dup()    \/\/ arrayref\n-                       .loadConstant(arrayIndex++);\n-                    newOpens(open.modifiers(), open.source(), open.targets());\n-                    cob.aastore();\n-                }\n+                cob.aload(BUILDER_VAR);\n+                loadArray(cob, CD_OPENS, sorted(opens), this::newOpens);\n@@ -1310,6 +1290,3 @@\n-             * Set<String> targets = new HashSet<>();\n-             * targets.add(t);\n-             * :\n-             * :\n-             *\n-             * Set<Modifier> mods = ...\n+             * ms = open.modifiers()\n+             * pn = open.source()\n+             * targets = open.targets()\n@@ -1318,3 +1295,4 @@\n-            void newOpens(Set<Opens.Modifier> ms, String pn, Set<String> targets) {\n-                dedupSetBuilder.loadOpensModifiers(cob, ms);\n-                cob.loadConstant(pn);\n+            void newOpens(CodeBuilder cb, Opens open) {\n+                dedupSetBuilder.loadOpensModifiers(cb, open.modifiers());\n+                cb.loadConstant(open.source());\n+                var targets = open.targets();\n@@ -1322,2 +1300,2 @@\n-                    dedupSetBuilder.loadStringSet(cob, targets);\n-                    cob.invokestatic(CD_MODULE_BUILDER,\n+                    dedupSetBuilder.loadStringSet(cb, targets);\n+                    cb.invokestatic(CD_MODULE_BUILDER,\n@@ -1327,1 +1305,1 @@\n-                    cob.invokestatic(CD_MODULE_BUILDER,\n+                    cb.invokestatic(CD_MODULE_BUILDER,\n@@ -1352,10 +1330,2 @@\n-                cob.aload(BUILDER_VAR)\n-                   .loadConstant(provides.size())\n-                   .anewarray(CD_PROVIDES);\n-                int arrayIndex = 0;\n-                for (Provides provide : sorted(provides)) {\n-                    cob.dup()    \/\/ arrayref\n-                       .loadConstant(arrayIndex++);\n-                    newProvides(provide.service(), provide.providers());\n-                    cob.aastore();\n-                }\n+                cob.aload(BUILDER_VAR);\n+                loadArray(cob, CD_PROVIDES, sorted(provides), this::newProvides);\n@@ -1369,1 +1339,1 @@\n-             * Invoke Builder.newProvides(String service, Set<String> providers)\n+             * Invoke Builder.newProvides(String service, List<String> providers)\n@@ -1371,4 +1341,2 @@\n-             * Set<String> providers = new HashSet<>();\n-             * providers.add(impl);\n-             * :\n-             * :\n+             * service = provide.service()\n+             * providers = List.of(new String[] { provide.providers() }\n@@ -1377,11 +1345,3 @@\n-            void newProvides(String service, List<String> providers) {\n-                cob.loadConstant(service)\n-                   .loadConstant(providers.size())\n-                   .anewarray(CD_String);\n-                int arrayIndex = 0;\n-                for (String provider : providers) {\n-                    cob.dup()    \/\/ arrayref\n-                       .loadConstant(arrayIndex++)\n-                       .loadConstant(provider)\n-                       .aastore();\n-                }\n+            void newProvides(CodeBuilder cb, Provides provide) {\n+                cb.loadConstant(provide.service());\n+                loadArray(cb, CD_String, provide.providers(), CodeBuilder::loadConstant);\n@@ -1398,1 +1358,5 @@\n-             * Invoke Builder.packages(String pn)\n+             * Invoke Builder.packages(Set<String> packages)\n+             * with packages either from invoke provider method\n+             *   module<index>Packages()\n+             * or construct inline with\n+             *   Set.of(packages)\n@@ -1404,10 +1368,1 @@\n-                    addModuleHelpers(clb -> {\n-                            clb.withMethodBody(\n-                                methodName,\n-                                MethodTypeDesc.of(CD_Set),\n-                                ACC_STATIC,\n-                                cob -> {\n-                                    genImmutableSet(cob, packages);\n-                                    cob.areturn();\n-                                });\n-                            });\n+                    addModuleHelpers(clb -> genImmutableSetProvider(clb, methodName, sorted(packages), CodeBuilder::loadConstant));\n@@ -1416,1 +1371,1 @@\n-                    genImmutableSet(cob, packages);\n+                    loadImmutableSet(cob, sorted(packages), CodeBuilder::loadConstant);\n@@ -1655,0 +1610,12 @@\n+             *\n+             * The returned snippet would set up the set referenced more than once,\n+             *\n+             * static final Set[] dedupSetValues;\n+             *\n+             * static {\n+             *     dedupSetValues = new Set[countOfStoredValues];\n+             *     dedupSetValues[0] = Set.of(elements); \/\/ elements no more than SET_SIZE_THRESHOLD\n+             *     dedupSetValues[1] = dedup<setWithIndex>Provider(); \/\/ set elements more than SET_SIZE_THRESHOLD\n+             *     ...\n+             *     dedupSetValues[countOfStoredValues - 1] = ...\n+             * }\n@@ -1678,0 +1645,1 @@\n+                    \/\/ The request cache slots each should have an initial value\n@@ -1684,0 +1652,1 @@\n+                               .dup()\n@@ -1689,4 +1658,0 @@\n-            void loadValuesArray(CodeBuilder cob) {\n-                cob.getstatic(owner, VALUES_ARRAY, CD_Set.arrayType());\n-            }\n-\n@@ -1694,3 +1659,3 @@\n-             * SetReference count references to the set, and use a CodeBuilder that\n-             * generate bytecode to load an element onto the operand stack to generate bytecode\n-             * to support loading the set onto operand stack.\n+             * SetReference count references to the set, and use an element loader, which is\n+             * a CodeBuilder that generate bytecode snippet to load an element onto the operand\n+             * stack, to generate bytecode to support loading the set onto operand stack.\n@@ -1708,1 +1673,2 @@\n-                private final Set<T> elements;\n+                \/\/ sorted elements of the set to ensure same generated code\n+                private final List<T> elements;\n@@ -1712,0 +1678,1 @@\n+                \/\/ The index for this set value in the cache array\n@@ -1713,0 +1680,1 @@\n+                \/\/ The provider method name, null if ths set is small enough for inline generation\n@@ -1716,1 +1684,1 @@\n-                    this.elements = elements;\n+                    this.elements = sorted(elements);\n@@ -1724,2 +1692,8 @@\n-\n-                \/\/ Load the set to the operand stack\n+                \/\/ Load the set to the operand stack.\n+                \/\/ When referenced more than once, the value is pre-built with static initialzer\n+                \/\/ and is load from the cache array with\n+                \/\/   dedupSetValues[index]\n+                \/\/ Otherwise, built the set in place with either\n+                \/\/   Set.of(elements)\n+                \/\/ or invoke the generated provider method\n+                \/\/   methodName()\n@@ -1729,1 +1703,1 @@\n-                        loadValuesArray(cob);\n+                        cob.getstatic(owner, VALUES_ARRAY, CD_Set.arrayType());\n@@ -1737,1 +1711,5 @@\n-                \/\/ Build the set value and store the reference\n+                \/\/ Build the set value and store the reference.\n+                \/\/ Generate either\n+                \/\/   dedupSetValues[index] = Set.of(elements);\n+                \/\/ or\n+                \/\/   dedupSetValues[index] = methodName();\n@@ -1740,2 +1718,3 @@\n-                    loadValuesArray(cob);\n-                    cob.loadConstant(index);\n+                    \/\/ array should be on top of the operands for this generate code in clinit\n+                    cob.dup()\n+                       .loadConstant(index);\n@@ -1746,1 +1725,5 @@\n-                \/\/ build the set and leave the reference at top of the operand stack\n+                \/\/ Build the set and leave the reference at top of the operand stack.\n+                \/\/ Generate either\n+                \/\/   Set.of(elements)\n+                \/\/ or invoke the provider method\n+                \/\/   methodName()\n@@ -1780,2 +1763,2 @@\n-                        var a1 = sorted(elements);\n-                        var a2 = sorted(o.elements);\n+                        var a1 = elements;\n+                        var a2 = o.elements;\n@@ -1795,45 +1778,0 @@\n-\n-        static <T extends Enum<T>> BiConsumer<CodeBuilder, T> getEnumLoader(ClassDesc enumClassDesc) {\n-            return (cob, element) -> cob.getstatic(enumClassDesc, element.name(), enumClassDesc);\n-        }\n-\n-        static <T extends Comparable<T>> void loadImmutableSet(CodeBuilder cob,\n-                                                               Set<T> elements,\n-                                                               BiConsumer<CodeBuilder, T> elementLoader) {\n-            if (elements.size() <= 10) {\n-                \/\/ call Set.of(e1, e2, ...)\n-                for (T t : sorted(elements)) {\n-                    elementLoader.accept(cob, t);\n-                }\n-                var mtdArgs = new ClassDesc[elements.size()];\n-                Arrays.fill(mtdArgs, CD_Object);\n-                cob.invokestatic(CD_Set, \"of\", MethodTypeDesc.of(CD_Set, mtdArgs), true);\n-            } else {\n-                \/\/ call Set.of(E... elements)\n-                cob.loadConstant(elements.size())\n-                   .anewarray(CD_String);\n-                int arrayIndex = 0;\n-                for (T t : sorted(elements)) {\n-                    cob.dup()    \/\/ arrayref\n-                       .loadConstant(arrayIndex);\n-                    elementLoader.accept(cob, t);  \/\/ value\n-                    cob.aastore();\n-                    arrayIndex++;\n-                }\n-                cob.invokestatic(CD_Set, \"of\", MTD_Set_ObjectArray, true);\n-            }\n-        }\n-\n-        static <T extends Comparable<T>> void genImmutableSetProvider(ClassBuilder clb,\n-                                                                      String methodName,\n-                                                                      Set<T> elements,\n-                                                                      BiConsumer<CodeBuilder, T> elementLoader) {\n-            clb.withMethodBody(\n-                methodName,\n-                MethodTypeDesc.of(CD_Set),\n-                ACC_STATIC,\n-                cob -> {\n-                    loadImmutableSet(cob, elements, elementLoader);\n-                    cob.areturn();\n-                });\n-        }\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/SystemModulesPlugin.java","additions":99,"deletions":161,"binary":false,"changes":260,"status":"modified"}]}