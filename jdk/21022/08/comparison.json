{"files":[{"patch":"@@ -0,0 +1,489 @@\n+\/*\n+ * Copyright (c) 2024, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.tools.jlink.internal;\n+\n+import java.lang.classfile.ClassBuilder;\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.constant.ClassDesc;\n+import static java.lang.constant.ConstantDescs.CD_Integer;\n+import static java.lang.constant.ConstantDescs.CD_Object;\n+import static java.lang.constant.ConstantDescs.CD_Set;\n+import static java.lang.constant.ConstantDescs.CD_int;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.function.BiConsumer;\n+\n+import jdk.tools.jlink.internal.Snippets.ElementLoader;\n+\n+public class Snippets {\n+    \/\/ Tested page size of string array\n+    public static final int STRING_PAGE_SIZE = 8000;\n+\n+    public static final ElementLoader<String> STRING_LOADER = ElementLoader.of(CodeBuilder::loadConstant);\n+    public static final ElementLoader<Integer> INTEGER_LOADER = (cob, value, index) -> {\n+        \/\/ loadConstant will unbox\n+        cob.loadConstant(value)\n+        .invokestatic(ClassDesc.ofInternalName(\"java\/lang\/Integer\"), \"valueOf\", MethodTypeDesc.of(CD_Integer, CD_int));\n+    };\n+    public static final ElementLoader<Loadable> LOADABLE_LOADER = (cob, loadable, index) -> loadable.load(cob);\n+\n+    \/**\n+     * Describe a reference that can be load onto the operand stack.\n+     * For example, an array of string can be described as a Loadable.\n+     * The {@link load} method\n+     *\/\n+    public sealed interface Loadable {\n+        \/**\n+         * Generate the bytecode to load the Loadable onto the operand stack.\n+         * @param cob  The CodeBuilder to add the bytecode for loading\n+         *\/\n+        void load(CodeBuilder cob);\n+\n+        \/**\n+         * The type of the reference be loaded onto the operand stack.\n+         *\/\n+        ClassDesc classDesc();\n+\n+        \/**\n+         * Generate fields or methods needed to support the load of the Loadable.\n+         * @param clb  The ClassBuilder to setup the helpers.\n+         *\/\n+        default void setup(ClassBuilder clb) {};\n+\n+        \/**\n+         * Whether {@link setup} must be called to {@link load} properly.\n+         *\/\n+        default boolean doesRequireSetup() { return false; }\n+    }\n+\n+    \/**\n+     * Generate a provider method for the {@code Loadable}. The provided\n+     * Loadable should be ready for load. The caller is responsible to ensure\n+     * the given Loadable had being setup properly.\n+     * @param value  The actuall {@code Loadable} to be wrapped into a method\n+     * @param ownerClass  The class of the generated method\n+     * @param methodName  The method name\n+     * @param isStatic  Should the generated method be static or public\n+     * @throws IllegalArgumentException if the value is a {@code WrappedLoadable}\n+     *\/\n+    public record WrappedLoadable(Loadable value, ClassDesc ownerClass, String methodName, boolean isStatic) implements Loadable {\n+        public WrappedLoadable {\n+            if (value instanceof WrappedLoadable) {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        @Override\n+        public void load(CodeBuilder cob) {\n+            if (isStatic()) {\n+                cob.invokestatic(ownerClass, methodName, methodType());\n+            } else {\n+                cob.aload(0)\n+                   .invokevirtual(ownerClass, methodName, methodType());\n+            }\n+        }\n+\n+        @Override\n+        public void setup(ClassBuilder clb) {\n+            \/\/ TODO: decide whether we should call value.setup(clb)\n+            \/\/ Prefer to have creator be responsible, given value\n+            \/\/ is provided to constructor, it should be ready to use.\n+            clb.withMethodBody(\n+                    methodName,\n+                    methodType(),\n+                    isStatic ? ACC_STATIC : ACC_PUBLIC,\n+                    cob -> {\n+                        value.load(cob);\n+                        cob.areturn();\n+                    });\n+        }\n+\n+        @Override\n+        public ClassDesc classDesc() {\n+            return value.classDesc();\n+        }\n+\n+        @Override\n+        public boolean doesRequireSetup() {\n+            return true;\n+        }\n+\n+        \/**\n+         * Describe the method type of the generated provider method.\n+         *\/\n+        public MethodTypeDesc methodType() {\n+            return MethodTypeDesc.of(classDesc());\n+        }\n+    }\n+\n+    public record LoadableEnum(Enum<?> o) implements Loadable {\n+        @Override\n+        public void load(CodeBuilder cob) {\n+            cob.getstatic(classDesc(), o.name(), classDesc());\n+        }\n+\n+        @Override\n+        public ClassDesc classDesc() {\n+            return o.getClass().describeConstable().get();\n+        }\n+    }\n+\n+    \/**\n+     * A function to load an element of type {@code T} onto the operand stack.\n+     * @param cob  The {@link CodeBuilder} to generate load code.\n+     * @param element  The element to be load.\n+     * @param index  The index of the element in the containing collection.\n+     *\/\n+    public interface ElementLoader<T> {\n+        void load(CodeBuilder cob, T element, int index);\n+\n+        static <T> ElementLoader<T> of(BiConsumer<CodeBuilder, T> ignoreIndex) {\n+            return (cob, element, _) -> {\n+                ignoreIndex.accept(cob, element);\n+            };\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        static <T extends Loadable> ElementLoader<T> selfLoader() {\n+            return (ElementLoader<T>) LOADABLE_LOADER;\n+        }\n+    }\n+\n+    \/**\n+     * Return a snippet builder that loads an enum onto the operand stack using\n+     * the enum name static final field\n+     *\/\n+    public static <T extends Enum<T>> ElementLoader<T> getEnumLoader(ClassDesc enumClassDesc) {\n+        return (cob, element, _) -> cob.getstatic(enumClassDesc, element.name(), enumClassDesc);\n+    }\n+\n+    \/\/ Array supports\n+    public sealed interface LoadableArray extends Loadable {\n+        \/**\n+         * Factory method to create a LoadableArray.\n+         * The bytecode generated varies based on the number of elements and can have supporting\n+         * methods for pagination, helps to overcome the code size limitation.\n+         *\n+         * @param elementType  The type of the array element\n+         * @param elements  The elements for the array\n+         * @param elementLoader  The loader function to load a single element onto operand stack to\n+         *                       be stored at given index\n+         * @param activatePagingThreshold  Use pagination methods if the count of elements is larger\n+         *                                 than the given value\n+         * @param ownerClassDesc  The owner class for the paginattion methods\n+         * @param methodNamePrefix  The method name prefix. Generated method will have the name of\n+         *                          this value appended with page number\n+         * @param pageSize  The count of elements per page\n+         *\n+         * @return A LoadableArray\n+         *\/\n+        static <T> LoadableArray of(ClassDesc elementType,\n+                                    Collection<T> elements,\n+                                    ElementLoader<T> elementLoader,\n+                                    int activatePagingThreshold,\n+                                    ClassDesc ownerClassDesc,\n+                                    String methodNamePrefix,\n+                                    int pageSize) {\n+            if (elements.size() > activatePagingThreshold) {\n+                return new PaginatedArray<>(elementType, elements, elementLoader, ownerClassDesc, methodNamePrefix, pageSize);\n+            } else {\n+                return new SimpleArray<>(elementType, elements, elementLoader);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Base class for all LoadableArray implementation.\n+     *\/\n+    private sealed static abstract class AbstractLoadableArray<T> implements LoadableArray {\n+        protected final ClassDesc elementType;\n+        protected final Collection<T> elements;\n+        protected final ElementLoader<T> elementLoader;\n+\n+        public AbstractLoadableArray(ClassDesc elementType, Collection<T> elements, ElementLoader<T> elementLoader) {\n+            this.elementType = elementType;\n+            this.elements = elements;\n+            this.elementLoader = elementLoader;\n+        }\n+\n+        @Override\n+        public ClassDesc classDesc() {\n+            return elementType.arrayType();\n+        }\n+\n+        protected void fill(CodeBuilder cob, Iterable<T> elements, int offset) {\n+            for (T t : elements) {\n+                cob.dup()    \/\/ arrayref\n+                   .loadConstant(offset);\n+                elementLoader.load(cob, t, offset);  \/\/ value\n+                cob.aastore();\n+                offset++;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Generate bytecode to create an array and assign values inline. Effectively as\n+     *   new T[] { elements }\n+     *\/\n+    public static final class SimpleArray<T> extends AbstractLoadableArray<T> {\n+        public SimpleArray(ClassDesc elementType, T[] elements, ElementLoader<T> elementLoader) {\n+            this(elementType, Arrays.asList(elements), elementLoader);\n+        }\n+\n+        public SimpleArray(ClassDesc elementType, Collection<T> elements, ElementLoader<T> elementLoader) {\n+            super(elementType, elements, elementLoader);\n+        }\n+\n+        @Override\n+        public void load(CodeBuilder cob) {\n+            cob.loadConstant(elements.size())\n+               .anewarray(elementType);\n+            fill(cob, elements, 0);\n+        }\n+    }\n+\n+    \/**\n+     * Generate bytecode for pagination methods, then create the array inline and invoke the first page method to assign\n+     * values to the array. Each pagination method will assign value to the corresponding page and chain calling next\n+     * page.\n+     * {@code setup} must be called to generate the pagination methods in the owner class. Otherwise, {@code load} will\n+     * lead to {@link java.lang.NoSuchMethodException}\n+     *\n+     * Effectively as\n+     *   methodNamePrefix0(new T[elements.size()]);\n+     *\n+     * where\n+     *   T[] methodNamePrefix0(T[] ar) {\n+     *      ar[0] = elements[0];\n+     *      ar[1] = elements[1];\n+     *      ...\n+     *      ar[pageSize-1] = elements[pageSize - 1];\n+     *      methodNamePrefix1(ar);\n+     *      return ar;\n+     *   }\n+     * and the last page will stop the chain and can be partial instead of full page size.\n+     *\/\n+    public static final class PaginatedArray<T> extends AbstractLoadableArray<T> {\n+        final int pageSize;\n+        final ClassDesc ownerClassDesc;\n+        final String methodNamePrefix;\n+        final MethodTypeDesc MTD_PageHelper;\n+\n+        public PaginatedArray(ClassDesc elementType,\n+                              T[] elements,\n+                              ElementLoader<T> elementLoader,\n+                              ClassDesc ownerClassDesc,\n+                              String methodNamePrefix,\n+                              int pageSize) {\n+            this(elementType,\n+                 Arrays.asList(elements),\n+                 elementLoader,\n+                 ownerClassDesc,\n+                 methodNamePrefix,\n+                 pageSize);\n+        }\n+\n+        public PaginatedArray(ClassDesc elementType,\n+                              Collection<T> elements,\n+                              ElementLoader<T> elementLoader,\n+                              ClassDesc ownerClassDesc,\n+                              String methodNamePrefix,\n+                              int pageSize) {\n+            super(elementType, elements, elementLoader);\n+            this.ownerClassDesc = ownerClassDesc;\n+            this.methodNamePrefix = methodNamePrefix;\n+            this.pageSize = pageSize;\n+            MTD_PageHelper = MethodTypeDesc.of(classDesc(), classDesc());\n+        }\n+\n+        @Override\n+        public void load(CodeBuilder cob) {\n+            \/\/ Invoke the first page, which will call next page until fulfilled\n+            cob.loadConstant(elements.size())\n+               .anewarray(elementType)\n+               .invokestatic(ownerClassDesc, methodNamePrefix + \"0\", MTD_PageHelper);\n+        }\n+\n+        @Override\n+        public void setup(ClassBuilder clb) {\n+            var pages = paginate(elements, pageSize);\n+\n+            assert(pages.size() == pageCount());\n+\n+            var lastPageNo = pages.size() - 1;\n+            for (int pageNo = 0; pageNo <= lastPageNo; pageNo++) {\n+                genFillPageHelper(clb, pages.get(pageNo), pageNo, pageNo < lastPageNo);\n+            }\n+        }\n+\n+        @Override\n+        public boolean doesRequireSetup() { return true; }\n+\n+        \/\/ each helper function is T[] methodNamePrefix{pageNo}(T[])\n+        \/\/ fill the page portion and chain calling to fill next page\n+        private void genFillPageHelper(ClassBuilder clb, Collection<T> pageElements, int pageNo, boolean hasNextPage) {\n+            var offset = pageSize * pageNo;\n+            clb.withMethodBody(\n+                    methodNamePrefix + pageNo,\n+                    MTD_PageHelper,\n+                    ACC_STATIC,\n+                    mcob -> {\n+                        mcob.aload(0); \/\/ arrayref\n+                        fill(mcob, pageElements, offset);\n+                        if (hasNextPage) {\n+                            mcob.invokestatic(\n+                                    ownerClassDesc,\n+                                    methodNamePrefix + (pageNo + 1),\n+                                    MTD_PageHelper);\n+                        }\n+                        mcob.areturn();\n+                    });\n+        }\n+\n+        public boolean isLastPagePartial() {\n+            return (elements.size() % pageSize) != 0;\n+        }\n+\n+        public int pageCount() {\n+            var pages = elements.size() \/ pageSize;\n+            return isLastPagePartial() ? pages + 1 : pages;\n+        }\n+    }\n+\n+    \/\/ Set support\n+    public sealed interface LoadableSet extends Loadable {\n+        \/**\n+         * Factory method for LoadableSet without using pagination methods.\n+         *\/\n+        static <T> LoadableSet of(Collection<T> elements, ElementLoader<T> loader) {\n+            \/\/ Set::of implementation optimization with 2 elements\n+            if (elements.size() <= 2) {\n+                return new TinySet<>(elements, loader);\n+            } else {\n+                return new ArrayAsSet<>(new SimpleArray<>(CD_Object, elements, loader));\n+            }\n+        }\n+\n+        \/**\n+         * Factory method for LoadableSet pagination methods when element count is larger than\n+         * given threshold.\n+         *\/\n+        static <T> LoadableSet of(Collection<T> elements,\n+                                  ElementLoader<T> loader,\n+                                  int activatePagingThreshold,\n+                                  ClassDesc ownerClassDesc,\n+                                  String methodNamePrefix,\n+                                  int pageSize) {\n+            if (elements.size() > activatePagingThreshold) {\n+                return new ArrayAsSet<>(LoadableArray.of(\n+                        CD_Object,\n+                        elements,\n+                        loader,\n+                        activatePagingThreshold,\n+                        ownerClassDesc,\n+                        methodNamePrefix,\n+                        pageSize));\n+            } else {\n+                return LoadableSet.of(elements, loader);\n+            }\n+        }\n+\n+        @Override\n+        default ClassDesc classDesc() {\n+            return CD_Set;\n+        }\n+    }\n+\n+    private static final class TinySet<T> implements LoadableSet {\n+        Collection<T> elements;\n+        ElementLoader<T> loader;\n+\n+        TinySet(Collection<T> elements, ElementLoader<T> loader) {\n+            \/\/ The Set::of API supports up to 10 elements\n+            if (elements.size() > 10) {\n+                throw new IllegalArgumentException();\n+            }\n+            this.elements = elements;\n+            this.loader = loader;\n+        }\n+\n+        @Override\n+        public void load(CodeBuilder cob) {\n+            var index = 0;\n+            for (T t : elements) {\n+                loader.load(cob, t, index++);\n+            }\n+            var mtdArgs = new ClassDesc[elements.size()];\n+            Arrays.fill(mtdArgs, CD_Object);\n+            cob.invokestatic(CD_Set, \"of\", MethodTypeDesc.of(CD_Set, mtdArgs), true);\n+        }\n+    }\n+\n+    private static final class ArrayAsSet<T> implements LoadableSet {\n+        final LoadableArray elements;\n+\n+        ArrayAsSet(LoadableArray elements) {\n+            this.elements = elements;\n+        }\n+\n+        @Override\n+        public void load(CodeBuilder cob) {\n+            elements.load(cob);\n+            cob.invokestatic(CD_Set, \"of\", MethodTypeDesc.of(CD_Set, CD_Object.arrayType()), true);\n+        }\n+\n+        @Override\n+        public boolean doesRequireSetup() {\n+            return elements.doesRequireSetup();\n+        }\n+\n+        @Override\n+        public void setup(ClassBuilder clb) {\n+            elements.setup(clb);\n+        }\n+    }\n+\n+    \/\/ utilities\n+    private static <T> ArrayList<ArrayList<T>> paginate(Iterable<T> elements, int pageSize) {\n+        ArrayList<ArrayList<T>> pages = new ArrayList<>(pageSize);\n+        ArrayList<T> currentPage = null;\n+        var index = 0;\n+        for (T element: elements) {\n+            if (index % pageSize == 0) {\n+                currentPage = new ArrayList<>();\n+                pages.add(currentPage);\n+            }\n+            currentPage.add(element);\n+            index++;\n+        }\n+\n+        return pages;\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/Snippets.java","additions":489,"deletions":0,"binary":false,"changes":489,"status":"added"},{"patch":"@@ -0,0 +1,437 @@\n+\/*\n+ * Copyright (c) 2024, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.tools.jlink.internal.plugins;\n+\n+import java.lang.classfile.ClassBuilder;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.constant.ClassDesc;\n+import static java.lang.constant.ConstantDescs.*;\n+\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.module.ModuleDescriptor;\n+import java.lang.module.ModuleDescriptor.Exports;\n+import java.lang.module.ModuleDescriptor.Opens;\n+import java.lang.module.ModuleDescriptor.Provides;\n+import java.lang.module.ModuleDescriptor.Requires;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+\n+import jdk.tools.jlink.internal.Snippets.ElementLoader;\n+import jdk.tools.jlink.internal.Snippets.Loadable;\n+import jdk.tools.jlink.internal.Snippets.LoadableArray;\n+import jdk.tools.jlink.internal.Snippets.LoadableSet;\n+import static jdk.tools.jlink.internal.Snippets.STRING_LOADER;\n+import static jdk.tools.jlink.internal.Snippets.STRING_PAGE_SIZE;\n+\n+import jdk.tools.jlink.internal.plugins.SystemModulesPlugin.ModuleInfo;\n+import jdk.tools.jlink.internal.plugins.SystemModulesPlugin.SystemModulesClassGenerator.DedupSetBuilder;\n+\n+class ModuleInfoLoader implements ElementLoader<ModuleInfo> {\n+    private static final ClassDesc CD_MODULE_DESCRIPTOR =\n+        ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor\");\n+    private static final ClassDesc CD_MODULE_BUILDER =\n+        ClassDesc.ofInternalName(\"jdk\/internal\/module\/Builder\");\n+\n+    private static final int PAGING_THRESHOLD = 512;\n+    private final DedupSetBuilder dedupSetBuilder;\n+    private final ClassDesc ownerClassDesc;\n+    private final ArrayList<Consumer<ClassBuilder>> amendments = new ArrayList<>();\n+\n+    ModuleInfoLoader(DedupSetBuilder dedupSetBuilder, ClassDesc ownerClassDesc) {\n+        this.dedupSetBuilder = dedupSetBuilder;\n+        this.ownerClassDesc = ownerClassDesc;\n+    }\n+\n+    @Override\n+    public void load(CodeBuilder cob, ModuleInfo moduleInfo, int index) {\n+        var mdBuilder = new ModuleDescriptorBuilder(moduleInfo.descriptor(), moduleInfo.packages(), index);\n+        mdBuilder.load(cob);\n+        if (mdBuilder.doesRequireSetup()) {\n+            amendments.add(mdBuilder::setup);\n+        }\n+    }\n+\n+    public void finish(ClassBuilder clb) {\n+        amendments.forEach(a -> a.accept(clb));\n+    }\n+\n+    class ModuleDescriptorBuilder {\n+        static final ClassDesc CD_EXPORTS =\n+            ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Exports\");\n+        static final ClassDesc CD_OPENS =\n+            ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Opens\");\n+        static final ClassDesc CD_PROVIDES =\n+            ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Provides\");\n+        static final ClassDesc CD_REQUIRES =\n+            ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Requires\");\n+\n+        \/\/ method signature for static Builder::newExports, newOpens,\n+        \/\/ newProvides, newRequires methods\n+        static final MethodTypeDesc MTD_EXPORTS_MODIFIER_SET_STRING_SET =\n+            MethodTypeDesc.of(CD_EXPORTS, CD_Set, CD_String, CD_Set);\n+        static final MethodTypeDesc MTD_EXPORTS_MODIFIER_SET_STRING =\n+            MethodTypeDesc.of(CD_EXPORTS, CD_Set, CD_String);\n+        static final MethodTypeDesc MTD_OPENS_MODIFIER_SET_STRING_SET =\n+            MethodTypeDesc.of(CD_OPENS, CD_Set, CD_String, CD_Set);\n+        static final MethodTypeDesc MTD_OPENS_MODIFIER_SET_STRING =\n+            MethodTypeDesc.of(CD_OPENS, CD_Set, CD_String);\n+        static final MethodTypeDesc MTD_PROVIDES_STRING_LIST =\n+            MethodTypeDesc.of(CD_PROVIDES, CD_String, CD_List);\n+        static final MethodTypeDesc MTD_REQUIRES_SET_STRING =\n+            MethodTypeDesc.of(CD_REQUIRES, CD_Set, CD_String);\n+        static final MethodTypeDesc MTD_REQUIRES_SET_STRING_STRING =\n+            MethodTypeDesc.of(CD_REQUIRES, CD_Set, CD_String, CD_String);\n+\n+        \/\/ method signature for Builder instance methods that\n+        \/\/ return this Builder instance\n+        static final MethodTypeDesc MTD_EXPORTS_ARRAY =\n+            MethodTypeDesc.of(CD_MODULE_BUILDER, CD_EXPORTS.arrayType());\n+        static final MethodTypeDesc MTD_OPENS_ARRAY =\n+            MethodTypeDesc.of(CD_MODULE_BUILDER, CD_OPENS.arrayType());\n+        static final MethodTypeDesc MTD_PROVIDES_ARRAY =\n+            MethodTypeDesc.of(CD_MODULE_BUILDER, CD_PROVIDES.arrayType());\n+        static final MethodTypeDesc MTD_REQUIRES_ARRAY =\n+            MethodTypeDesc.of(CD_MODULE_BUILDER, CD_REQUIRES.arrayType());\n+        static final MethodTypeDesc MTD_SET = MethodTypeDesc.of(CD_MODULE_BUILDER, CD_Set);\n+        static final MethodTypeDesc MTD_STRING = MethodTypeDesc.of(CD_MODULE_BUILDER, CD_String);\n+        static final MethodTypeDesc MTD_BOOLEAN = MethodTypeDesc.of(CD_MODULE_BUILDER, CD_boolean);\n+        static final MethodTypeDesc MTD_void_String = MethodTypeDesc.of(CD_void, CD_String);\n+        static final MethodTypeDesc MTD_ModuleDescriptor_int = MethodTypeDesc.of(CD_MODULE_DESCRIPTOR, CD_int);\n+        static final MethodTypeDesc MTD_List_ObjectArray = MethodTypeDesc.of(CD_List, CD_Object.arrayType());\n+\n+\n+        final ModuleDescriptor md;\n+        final Set<String> packages;\n+        final int index;\n+        Consumer<ClassBuilder> amendment;\n+\n+        ModuleDescriptorBuilder(ModuleDescriptor md, Set<String> packages, int index) {\n+            if (md.isAutomatic()) {\n+                throw new InternalError(\"linking automatic module is not supported\");\n+            }\n+\n+\n+            this.md = md;\n+            this.packages = packages;\n+            this.index = index;\n+        }\n+\n+        private LoadableArray requiresArray() {\n+            var requiresArray = LoadableArray.of(\n+                    CD_REQUIRES,\n+                    sorted(md.requires()),\n+                    this::newRequires,\n+                    PAGING_THRESHOLD,\n+                    ownerClassDesc,\n+                    \"module\" + index + \"Requires\",\n+                    \/\/ number safe for a single page helper under 64K size limit\n+                    2000);\n+\n+            setupLoadable(requiresArray);\n+            return requiresArray;\n+        }\n+\n+        private LoadableArray exportArray() {\n+            var exportArray = LoadableArray.of(\n+                    CD_EXPORTS,\n+                    sorted(md.exports()),\n+                    this::loadExports,\n+                    PAGING_THRESHOLD,\n+                    ownerClassDesc,\n+                    \"module\" + index + \"Exports\",\n+                    \/\/ number safe for a single page helper under 64K size limit\n+                    2000);\n+\n+            setupLoadable(exportArray);\n+            return exportArray;\n+        }\n+\n+        private LoadableArray opensArray() {\n+            var opensArray = LoadableArray.of(\n+                    CD_OPENS,\n+                    sorted(md.opens()),\n+                    this::newOpens,\n+                    PAGING_THRESHOLD,\n+                    ownerClassDesc,\n+                    \"module\" + index + \"Opens\",\n+                    \/\/ number safe for a single page helper under 64K size limit\n+                    2000);\n+\n+            setupLoadable(opensArray);\n+            return opensArray;\n+        }\n+\n+        private LoadableArray providesArray() {\n+            var providesArray = LoadableArray.of(\n+                    CD_PROVIDES,\n+                    sorted(md.provides()),\n+                    this::newProvides,\n+                    PAGING_THRESHOLD,\n+                    ownerClassDesc,\n+                    \"module\" + index + \"Provides\",\n+                    \/\/ number safe for a single page helper under 64K size limit\n+                    2000);\n+\n+            setupLoadable(providesArray);\n+            return providesArray;\n+        }\n+\n+        private LoadableSet packagesSet() {\n+            var packagesSet = LoadableSet.of(\n+                    sorted(packages),\n+                    STRING_LOADER,\n+                    PAGING_THRESHOLD,\n+                    ownerClassDesc,\n+                    \"module\" + index + \"Packages\",\n+                    STRING_PAGE_SIZE);\n+\n+            setupLoadable(packagesSet);\n+            return packagesSet;\n+        }\n+\n+        private void setupLoadable(Loadable loadable) {\n+            if (amendment == null) {\n+                amendment = loadable::setup;\n+            } else {\n+                amendment = amendment.andThen(loadable::setup);\n+            }\n+        }\n+\n+        boolean doesRequireSetup() {\n+            return amendment != null;\n+        }\n+\n+        void setup(ClassBuilder clb) {\n+            if (amendment != null) amendment.accept(clb);\n+        }\n+\n+        void load(CodeBuilder cob) {\n+            \/\/ new jdk.internal.module.Builder\n+            cob.new_(CD_MODULE_BUILDER)\n+               .dup()\n+               .loadConstant(md.name())\n+               .invokespecial(CD_MODULE_BUILDER,\n+                              INIT_NAME,\n+                              MTD_void_String);\n+            if (md.isOpen()) {\n+                setModuleBit(cob, \"open\", true);\n+            }\n+            if (md.modifiers().contains(ModuleDescriptor.Modifier.SYNTHETIC)) {\n+                setModuleBit(cob, \"synthetic\", true);\n+            }\n+            if (md.modifiers().contains(ModuleDescriptor.Modifier.MANDATED)) {\n+                setModuleBit(cob, \"mandated\", true);\n+            }\n+\n+            \/\/ requires\n+            requiresArray().load(cob);\n+            cob.invokevirtual(CD_MODULE_BUILDER,\n+                              \"requires\",\n+                              MTD_REQUIRES_ARRAY);\n+\n+            \/\/ exports\n+            exportArray().load(cob);\n+            cob.invokevirtual(CD_MODULE_BUILDER,\n+                    \"exports\",\n+                    MTD_EXPORTS_ARRAY);\n+\n+            \/\/ opens\n+            opensArray().load(cob);\n+            cob.invokevirtual(CD_MODULE_BUILDER,\n+                              \"opens\",\n+                              MTD_OPENS_ARRAY);\n+\n+            \/\/ uses\n+            dedupSetBuilder.loadStringSet(cob, md.uses());\n+            cob.invokevirtual(CD_MODULE_BUILDER,\n+                              \"uses\",\n+                              MTD_SET);\n+\n+            \/\/ provides\n+            providesArray().load(cob);\n+            cob.invokevirtual(CD_MODULE_BUILDER,\n+                              \"provides\",\n+                              MTD_PROVIDES_ARRAY);\n+\n+            \/\/ all packages\n+            packagesSet().load(cob);\n+            cob.invokevirtual(CD_MODULE_BUILDER,\n+                              \"packages\",\n+                              MTD_SET);\n+\n+            \/\/ version\n+            md.version().ifPresent(v -> setModuleProperty(cob, \"version\", v.toString()));\n+\n+            \/\/ main class\n+            md.mainClass().ifPresent(cn -> setModuleProperty(cob, \"mainClass\", cn));\n+\n+            cob.loadConstant(md.hashCode())\n+               .invokevirtual(CD_MODULE_BUILDER,\n+                              \"build\",\n+                              MTD_ModuleDescriptor_int);\n+        }\n+\n+        \/*\n+         * Invoke Builder.<methodName>(boolean value)\n+         *\/\n+        void setModuleBit(CodeBuilder cob, String methodName, boolean value) {\n+            cob.loadConstant(value ? 1 : 0)\n+               .invokevirtual(CD_MODULE_BUILDER,\n+                              methodName,\n+                              MTD_BOOLEAN);\n+        }\n+\n+        void setModuleProperty(CodeBuilder cob, String methodName, String value) {\n+            cob.loadConstant(value)\n+               .invokevirtual(CD_MODULE_BUILDER,\n+                              methodName,\n+                              MTD_STRING);\n+        }\n+\n+        \/*\n+         * Invoke Builder.newRequires(Set<Modifier> mods, String mn, String compiledVersion)\n+         *\n+         * Set<Modifier> mods = ...\n+         * Builder.newRequires(mods, mn, compiledVersion);\n+         *\/\n+        void newRequires(CodeBuilder cob, Requires require, int unused) {\n+            dedupSetBuilder.loadRequiresModifiers(cob, require.modifiers());\n+            cob.loadConstant(require.name());\n+            if (require.compiledVersion().isPresent()) {\n+                cob.loadConstant(require.compiledVersion().get().toString())\n+                   .invokestatic(CD_MODULE_BUILDER,\n+                                 \"newRequires\",\n+                                 MTD_REQUIRES_SET_STRING_STRING);\n+            } else {\n+                cob.invokestatic(CD_MODULE_BUILDER,\n+                                 \"newRequires\",\n+                                 MTD_REQUIRES_SET_STRING);\n+            }\n+        }\n+\n+        \/*\n+         * Invoke\n+         *     Builder.newExports(Set<Exports.Modifier> ms, String pn,\n+         *                        Set<String> targets)\n+         * or\n+         *     Builder.newExports(Set<Exports.Modifier> ms, String pn)\n+         *\n+         * ms = export.modifiers()\n+         * pn = export.source()\n+         * targets = export.targets()\n+         *\/\n+        void loadExports(CodeBuilder cb, Exports export, int unused) {\n+            dedupSetBuilder.loadExportsModifiers(cb, export.modifiers());\n+            cb.loadConstant(export.source());\n+            var targets = export.targets();\n+            if (!targets.isEmpty()) {\n+                dedupSetBuilder.loadStringSet(cb, targets);\n+                cb.invokestatic(CD_MODULE_BUILDER,\n+                                \"newExports\",\n+                                MTD_EXPORTS_MODIFIER_SET_STRING_SET);\n+            } else {\n+                cb.invokestatic(CD_MODULE_BUILDER,\n+                                \"newExports\",\n+                                MTD_EXPORTS_MODIFIER_SET_STRING);\n+            }\n+        }\n+\n+        \/*\n+         * Invoke\n+         *     Builder.newOpens(Set<Opens.Modifier> ms, String pn,\n+         *                        Set<String> targets)\n+         * or\n+         *     Builder.newOpens(Set<Opens.Modifier> ms, String pn)\n+         *\n+         * ms = open.modifiers()\n+         * pn = open.source()\n+         * targets = open.targets()\n+         * Builder.newOpens(mods, pn, targets);\n+         *\/\n+        void newOpens(CodeBuilder cb, Opens open, int unused) {\n+            dedupSetBuilder.loadOpensModifiers(cb, open.modifiers());\n+            cb.loadConstant(open.source());\n+            var targets = open.targets();\n+            if (!targets.isEmpty()) {\n+                dedupSetBuilder.loadStringSet(cb, targets);\n+                cb.invokestatic(CD_MODULE_BUILDER,\n+                                 \"newOpens\",\n+                                 MTD_OPENS_MODIFIER_SET_STRING_SET);\n+            } else {\n+                cb.invokestatic(CD_MODULE_BUILDER,\n+                                 \"newOpens\",\n+                                 MTD_OPENS_MODIFIER_SET_STRING);\n+            }\n+        }\n+\n+        \/*\n+         * Invoke Builder.newProvides(String service, List<String> providers)\n+         *\n+         * service = provide.service()\n+         * providers = List.of(new String[] { provide.providers() }\n+         * Builder.newProvides(service, providers);\n+         *\/\n+        void newProvides(CodeBuilder cb, Provides provide, int offset) {\n+            var providersArray = LoadableArray.of(\n+                    CD_String,\n+                    provide.providers(),\n+                    STRING_LOADER,\n+                    PAGING_THRESHOLD,\n+                    ownerClassDesc,\n+                    \"module\" + index + \"Provider\" + offset,\n+                    STRING_PAGE_SIZE);\n+\n+            setupLoadable(providersArray);\n+\n+            cb.loadConstant(provide.service());\n+            providersArray.load(cb);\n+            cb.invokestatic(CD_List,\n+                             \"of\",\n+                             MTD_List_ObjectArray,\n+                             true)\n+               .invokestatic(CD_MODULE_BUILDER,\n+                             \"newProvides\",\n+                             MTD_PROVIDES_STRING_LIST);\n+        }\n+    }\n+\n+    \/**\n+     * Returns a sorted copy of a collection.\n+     *\n+     * This is useful to ensure a deterministic iteration order.\n+     *\n+     * @return a sorted copy of the given collection.\n+     *\/\n+    private static <T extends Comparable<T>> List<T> sorted(Collection<T> c) {\n+        var l = new ArrayList<T>(c);\n+        Collections.sort(l);\n+        return l;\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/ModuleInfoLoader.java","additions":437,"deletions":0,"binary":false,"changes":437,"status":"added"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.constant.ConstantDesc;\n@@ -41,1 +40,0 @@\n-import java.lang.module.ModuleDescriptor.Version;\n@@ -49,1 +47,0 @@\n-import java.util.Arrays;\n@@ -63,1 +60,1 @@\n-import java.util.function.IntSupplier;\n+import java.util.function.Consumer;\n@@ -81,1 +78,0 @@\n-import static java.lang.classfile.ClassFile.*;\n@@ -84,0 +80,3 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n@@ -90,0 +89,5 @@\n+import static java.lang.classfile.ClassFile.*;\n+\n+import static jdk.tools.jlink.internal.Snippets.*;\n+\n+\n@@ -332,0 +336,11 @@\n+        \/\/ Diagnosis help, can be removed\n+        if (Boolean.parseBoolean(System.getProperty(\"JlinkDumpSystemModuleClass\", \"false\"))) {\n+            try {\n+                var filePath = Path.of(className + \".class\").toAbsolutePath();\n+                System.err.println(\"Write \" + filePath.toString());\n+                Files.createDirectories(filePath.getParent());\n+                Files.write(filePath, bytes);\n+            } catch (IOException ioe) {\n+                ioe.printStackTrace(System.err);\n+            }\n+        }\n@@ -516,2 +531,0 @@\n-        private static final ClassDesc CD_MODULE_BUILDER =\n-            ClassDesc.ofInternalName(\"jdk\/internal\/module\/Builder\");\n@@ -541,1 +554,2 @@\n-        private static final MethodTypeDesc MTD_Set_ObjectArray = MethodTypeDesc.of(CD_Set, CD_Object.arrayType());\n+\n+        static final int PAGING_THRESHOLD = 512; \/\/ An arbitrary number as this likely generate minimum ~4K code\n@@ -545,1 +559,0 @@\n-        private final int MD_VAR         = 1;  \/\/ variable for ModuleDescriptor\n@@ -548,3 +561,1 @@\n-        private final int DEDUP_LIST_VAR = 2;\n-        private final int BUILDER_VAR    = 3;\n-        private int nextLocalVar         = 4;  \/\/ index to next local variable\n+        private final int BUILDER_VAR    = 2;\n@@ -563,2 +574,1 @@\n-        private final DedupSetBuilder dedupSetBuilder\n-            = new DedupSetBuilder(this::getNextLocalVar);\n+        private final DedupSetBuilder dedupSetBuilder;\n@@ -572,0 +582,1 @@\n+            this.dedupSetBuilder = new DedupSetBuilder(this.classDesc);\n@@ -575,4 +586,0 @@\n-        private int getNextLocalVar() {\n-            return nextLocalVar++;\n-        }\n-\n@@ -586,1 +593,1 @@\n-            for (Exports e : md.exports()) {\n+            for (Exports e : sorted(md.exports())) {\n@@ -592,1 +599,1 @@\n-            for (Opens opens : md.opens()) {\n+            for (Opens opens : sorted(md.opens())) {\n@@ -598,1 +605,1 @@\n-            for (Requires r : md.requires()) {\n+            for (Requires r : sorted(md.requires())) {\n@@ -619,0 +626,3 @@\n+                        \/\/ generate dedup set fields and provider methods\n+                        genConstants(clb);\n+\n@@ -657,0 +667,14 @@\n+        private void genConstants(ClassBuilder clb) {\n+            var clinitSnippets = dedupSetBuilder.buildConstants(clb);\n+            if (!clinitSnippets.isEmpty()) {\n+                clb.withMethodBody(\n+                        CLASS_INIT_NAME,\n+                        MTD_void,\n+                        ACC_STATIC,\n+                        cob -> {\n+                            clinitSnippets.get().accept(cob);\n+                            cob.return_();\n+                        });\n+            }\n+        }\n+\n@@ -693,3 +717,0 @@\n-        \/**\n-         * Generate bytecode for moduleDescriptors method\n-         *\/\n@@ -697,64 +718,13 @@\n-            if (moduleInfos.size() <= moduleDescriptorsPerMethod) {\n-                clb.withMethodBody(\n-                        \"moduleDescriptors\",\n-                        MTD_ModuleDescriptorArray,\n-                        ACC_PUBLIC,\n-                        cob -> {\n-                            cob.loadConstant(moduleInfos.size())\n-                               .anewarray(CD_MODULE_DESCRIPTOR)\n-                               .astore(MD_VAR);\n-\n-                            for (int index = 0; index < moduleInfos.size(); index++) {\n-                                ModuleInfo minfo = moduleInfos.get(index);\n-                                new ModuleDescriptorBuilder(cob,\n-                                                            minfo.descriptor(),\n-                                                            minfo.packages(),\n-                                                            index).build();\n-                            }\n-                            cob.aload(MD_VAR)\n-                               .areturn();\n-                        });\n-                return;\n-            }\n-\n-\n-            \/\/ Split the module descriptors be created by multiple helper methods.\n-            \/\/ Each helper method \"subi\" creates the maximum N number of module descriptors\n-            \/\/     mi, m{i+1} ...\n-            \/\/ to avoid exceeding the 64kb limit of method length.  Then it will call\n-            \/\/ \"sub{i+1}\" to creates the next batch of module descriptors m{i+n}, m{i+n+1}...\n-            \/\/ and so on.  During the construction of the module descriptors, the string sets and\n-            \/\/ modifier sets are deduplicated (see SystemModulesClassGenerator.DedupSetBuilder)\n-            \/\/ and cached in the locals. These locals are saved in an array list so\n-            \/\/ that the helper method can restore the local variables that may be\n-            \/\/ referenced by the bytecode generated for creating module descriptors.\n-            \/\/ Pseudo code looks like this:\n-            \/\/\n-            \/\/ void subi(ModuleDescriptor[] mdescs, ArrayList<Object> localvars) {\n-            \/\/      \/\/ assign localvars to local variables\n-            \/\/      var l3 = localvars.get(0);\n-            \/\/      var l4 = localvars.get(1);\n-            \/\/        :\n-            \/\/      \/\/ fill mdescs[i] to mdescs[i+n-1]\n-            \/\/      mdescs[i] = ...\n-            \/\/      mdescs[i+1] = ...\n-            \/\/        :\n-            \/\/      \/\/ save new local variables added\n-            \/\/      localvars.add(lx)\n-            \/\/      localvars.add(l{x+1})\n-            \/\/        :\n-            \/\/      sub{i+i}(mdescs, localvars);\n-            \/\/ }\n-\n-            List<List<ModuleInfo>> splitModuleInfos = new ArrayList<>();\n-            List<ModuleInfo> currentModuleInfos = null;\n-            for (int index = 0; index < moduleInfos.size(); index++) {\n-                if (index % moduleDescriptorsPerMethod == 0) {\n-                    currentModuleInfos = new ArrayList<>();\n-                    splitModuleInfos.add(currentModuleInfos);\n-                }\n-                currentModuleInfos.add(moduleInfos.get(index));\n-            }\n-\n-            String helperMethodNamePrefix = \"sub\";\n-            ClassDesc arrayListClassDesc = ClassDesc.ofInternalName(\"java\/util\/ArrayList\");\n+            var moduleInfoLoader = new ModuleInfoLoader(dedupSetBuilder, classDesc);\n+            var moduleDescriptors = LoadableArray.of(\n+                    CD_MODULE_DESCRIPTOR,\n+                    moduleInfos,\n+                    moduleInfoLoader,\n+                    moduleDescriptorsPerMethod,\n+                    classDesc,\n+                    \"sub\",\n+                    moduleDescriptorsPerMethod);\n+\n+            \/\/ This setup helpers needed by the LoadableArray, but element loader is responsible\n+            \/\/ to setup elements.\n+            moduleDescriptors.setup(clb);\n@@ -767,18 +737,2 @@\n-                        cob.loadConstant(moduleInfos.size())\n-                           .anewarray(CD_MODULE_DESCRIPTOR)\n-                           .dup()\n-                           .astore(MD_VAR);\n-                        cob.new_(arrayListClassDesc)\n-                           .dup()\n-                           .loadConstant(moduleInfos.size())\n-                           .invokespecial(arrayListClassDesc, INIT_NAME, MethodTypeDesc.of(CD_void, CD_int))\n-                           .astore(DEDUP_LIST_VAR);\n-                        cob.aload(0)\n-                           .aload(MD_VAR)\n-                           .aload(DEDUP_LIST_VAR)\n-                           .invokevirtual(\n-                                   this.classDesc,\n-                                   helperMethodNamePrefix + \"0\",\n-                                   MethodTypeDesc.of(CD_void, CD_MODULE_DESCRIPTOR.arrayType(), arrayListClassDesc)\n-                           )\n-                           .areturn();\n+                            moduleDescriptors.load(cob);\n+                            cob.areturn();\n@@ -787,50 +741,2 @@\n-            int dedupVarStart = nextLocalVar;\n-            for (int n = 0, count = 0; n < splitModuleInfos.size(); count += splitModuleInfos.get(n).size(), n++) {\n-                int index = n;       \/\/ the index of which ModuleInfo being processed in the current batch\n-                int start = count;   \/\/ the start index to the return ModuleDescriptor array for the current batch\n-                int curDedupVar = nextLocalVar;\n-                clb.withMethodBody(\n-                        helperMethodNamePrefix + index,\n-                        MethodTypeDesc.of(CD_void, CD_MODULE_DESCRIPTOR.arrayType(), arrayListClassDesc),\n-                        ACC_PUBLIC,\n-                        cob -> {\n-                            if (curDedupVar > dedupVarStart) {\n-                                for (int i = dedupVarStart; i < curDedupVar; i++) {\n-                                    cob.aload(DEDUP_LIST_VAR)\n-                                       .loadConstant(i - dedupVarStart)\n-                                       .invokevirtual(arrayListClassDesc, \"get\", MethodTypeDesc.of(CD_Object, CD_int))\n-                                       .astore(i);\n-                                }\n-                            }\n-\n-                            List<ModuleInfo> currentBatch = splitModuleInfos.get(index);\n-                            for (int j = 0; j < currentBatch.size(); j++) {\n-                                ModuleInfo minfo = currentBatch.get(j);\n-                                new ModuleDescriptorBuilder(cob,\n-                                                            minfo.descriptor(),\n-                                                            minfo.packages(),\n-                                                            start + j).build();\n-                            }\n-\n-                            if (index < splitModuleInfos.size() - 1) {\n-                                if (nextLocalVar > curDedupVar) {\n-                                    for (int i = curDedupVar; i < nextLocalVar; i++) {\n-                                        cob.aload(DEDUP_LIST_VAR)\n-                                           .aload(i)\n-                                           .invokevirtual(arrayListClassDesc, \"add\", MethodTypeDesc.of(CD_boolean, CD_Object))\n-                                           .pop();\n-                                    }\n-                                }\n-                                cob.aload(0)\n-                                   .aload(MD_VAR)\n-                                   .aload(DEDUP_LIST_VAR)\n-                                   .invokevirtual(\n-                                           this.classDesc,\n-                                           helperMethodNamePrefix + (index+1),\n-                                           MethodTypeDesc.of(CD_void, CD_MODULE_DESCRIPTOR.arrayType(), arrayListClassDesc)\n-                                   );\n-                            }\n-\n-                            cob.return_();\n-                        });\n-            }\n+            \/\/ amend class with helpers needed by individual ModuleDescriptor\n+            moduleInfoLoader.finish(clb);\n@@ -1044,442 +950,2 @@\n-            int size = set.size();\n-\n-            \/\/ use Set.of(Object[]) when there are more than 2 elements\n-            \/\/ use Set.of(Object) or Set.of(Object, Object) when fewer\n-            if (size > 2) {\n-                cob.loadConstant(size)\n-                   .anewarray(CD_String);\n-                int i = 0;\n-                for (String element : sorted(set)) {\n-                    cob.dup()\n-                       .loadConstant(i)\n-                       .loadConstant(element)\n-                       .aastore();\n-                    i++;\n-                }\n-                cob.invokestatic(CD_Set,\n-                                 \"of\",\n-                                 MTD_Set_ObjectArray,\n-                                 true);\n-            } else {\n-                for (String element : sorted(set)) {\n-                    cob.loadConstant(element);\n-                }\n-                var mtdArgs = new ClassDesc[size];\n-                Arrays.fill(mtdArgs, CD_Object);\n-                cob.invokestatic(CD_Set,\n-                                 \"of\",\n-                                 MethodTypeDesc.of(CD_Set, mtdArgs),\n-                                 true);\n-            }\n-        }\n-\n-        class ModuleDescriptorBuilder {\n-            static final ClassDesc CD_EXPORTS =\n-                ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Exports\");\n-            static final ClassDesc CD_OPENS =\n-                ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Opens\");\n-            static final ClassDesc CD_PROVIDES =\n-                ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Provides\");\n-            static final ClassDesc CD_REQUIRES =\n-                ClassDesc.ofInternalName(\"java\/lang\/module\/ModuleDescriptor$Requires\");\n-\n-            \/\/ method signature for static Builder::newExports, newOpens,\n-            \/\/ newProvides, newRequires methods\n-            static final MethodTypeDesc MTD_EXPORTS_MODIFIER_SET_STRING_SET =\n-                MethodTypeDesc.of(CD_EXPORTS, CD_Set, CD_String, CD_Set);\n-            static final MethodTypeDesc MTD_EXPORTS_MODIFIER_SET_STRING =\n-                MethodTypeDesc.of(CD_EXPORTS, CD_Set, CD_String);\n-            static final MethodTypeDesc MTD_OPENS_MODIFIER_SET_STRING_SET =\n-                MethodTypeDesc.of(CD_OPENS, CD_Set, CD_String, CD_Set);\n-            static final MethodTypeDesc MTD_OPENS_MODIFIER_SET_STRING =\n-                MethodTypeDesc.of(CD_OPENS, CD_Set, CD_String);\n-            static final MethodTypeDesc MTD_PROVIDES_STRING_LIST =\n-                MethodTypeDesc.of(CD_PROVIDES, CD_String, CD_List);\n-            static final MethodTypeDesc MTD_REQUIRES_SET_STRING =\n-                MethodTypeDesc.of(CD_REQUIRES, CD_Set, CD_String);\n-            static final MethodTypeDesc MTD_REQUIRES_SET_STRING_STRING =\n-                MethodTypeDesc.of(CD_REQUIRES, CD_Set, CD_String, CD_String);\n-\n-            \/\/ method signature for Builder instance methods that\n-            \/\/ return this Builder instance\n-            static final MethodTypeDesc MTD_EXPORTS_ARRAY =\n-                MethodTypeDesc.of(CD_MODULE_BUILDER, CD_EXPORTS.arrayType());\n-            static final MethodTypeDesc MTD_OPENS_ARRAY =\n-                MethodTypeDesc.of(CD_MODULE_BUILDER, CD_OPENS.arrayType());\n-            static final MethodTypeDesc MTD_PROVIDES_ARRAY =\n-                MethodTypeDesc.of(CD_MODULE_BUILDER, CD_PROVIDES.arrayType());\n-            static final MethodTypeDesc MTD_REQUIRES_ARRAY =\n-                MethodTypeDesc.of(CD_MODULE_BUILDER, CD_REQUIRES.arrayType());\n-            static final MethodTypeDesc MTD_SET = MethodTypeDesc.of(CD_MODULE_BUILDER, CD_Set);\n-            static final MethodTypeDesc MTD_STRING = MethodTypeDesc.of(CD_MODULE_BUILDER, CD_String);\n-            static final MethodTypeDesc MTD_BOOLEAN = MethodTypeDesc.of(CD_MODULE_BUILDER, CD_boolean);\n-            static final MethodTypeDesc MTD_void_String = MethodTypeDesc.of(CD_void, CD_String);\n-            static final MethodTypeDesc MTD_ModuleDescriptor_int = MethodTypeDesc.of(CD_MODULE_DESCRIPTOR, CD_int);\n-            static final MethodTypeDesc MTD_List_ObjectArray = MethodTypeDesc.of(CD_List, CD_Object.arrayType());\n-\n-            final CodeBuilder cob;\n-            final ModuleDescriptor md;\n-            final Set<String> packages;\n-            final int index;\n-\n-            ModuleDescriptorBuilder(CodeBuilder cob, ModuleDescriptor md, Set<String> packages, int index) {\n-                if (md.isAutomatic()) {\n-                    throw new InternalError(\"linking automatic module is not supported\");\n-                }\n-                this.cob = cob;\n-                this.md = md;\n-                this.packages = packages;\n-                this.index = index;\n-            }\n-\n-            void build() {\n-                \/\/ new jdk.internal.module.Builder\n-                newBuilder();\n-\n-                \/\/ requires\n-                requires(md.requires());\n-\n-                \/\/ exports\n-                exports(md.exports());\n-\n-                \/\/ opens\n-                opens(md.opens());\n-\n-                \/\/ uses\n-                uses(md.uses());\n-\n-                \/\/ provides\n-                provides(md.provides());\n-\n-                \/\/ all packages\n-                packages(packages);\n-\n-                \/\/ version\n-                md.version().ifPresent(this::version);\n-\n-                \/\/ main class\n-                md.mainClass().ifPresent(this::mainClass);\n-\n-                putModuleDescriptor();\n-            }\n-\n-            void newBuilder() {\n-                cob.new_(CD_MODULE_BUILDER)\n-                   .dup()\n-                   .loadConstant(md.name())\n-                   .invokespecial(CD_MODULE_BUILDER,\n-                                  INIT_NAME,\n-                                  MTD_void_String)\n-                   .astore(BUILDER_VAR);\n-\n-                if (md.isOpen()) {\n-                    setModuleBit(\"open\", true);\n-                }\n-                if (md.modifiers().contains(ModuleDescriptor.Modifier.SYNTHETIC)) {\n-                    setModuleBit(\"synthetic\", true);\n-                }\n-                if (md.modifiers().contains(ModuleDescriptor.Modifier.MANDATED)) {\n-                    setModuleBit(\"mandated\", true);\n-                }\n-            }\n-\n-            \/*\n-             * Invoke Builder.<methodName>(boolean value)\n-             *\/\n-            void setModuleBit(String methodName, boolean value) {\n-                cob.aload(BUILDER_VAR)\n-                   .loadConstant(value ? 1 : 0)\n-                   .invokevirtual(CD_MODULE_BUILDER,\n-                                  methodName,\n-                                  MTD_BOOLEAN)\n-                   .pop();\n-            }\n-\n-            \/*\n-             * Put ModuleDescriptor into the modules array\n-             *\/\n-            void putModuleDescriptor() {\n-                cob.aload(MD_VAR)\n-                   .loadConstant(index)\n-                   .aload(BUILDER_VAR)\n-                   .loadConstant(md.hashCode())\n-                   .invokevirtual(CD_MODULE_BUILDER,\n-                                  \"build\",\n-                                  MTD_ModuleDescriptor_int)\n-                   .aastore();\n-            }\n-\n-            \/*\n-             * Call Builder::newRequires to create Requires instances and\n-             * then pass it to the builder by calling:\n-             *      Builder.requires(Requires[])\n-             *\n-             *\/\n-            void requires(Set<Requires> requires) {\n-                cob.aload(BUILDER_VAR)\n-                   .loadConstant(requires.size())\n-                   .anewarray(CD_REQUIRES);\n-                int arrayIndex = 0;\n-                for (Requires require : sorted(requires)) {\n-                    String compiledVersion = null;\n-                    if (require.compiledVersion().isPresent()) {\n-                        compiledVersion = require.compiledVersion().get().toString();\n-                    }\n-\n-                    cob.dup()               \/\/ arrayref\n-                       .loadConstant(arrayIndex++);\n-                    newRequires(require.modifiers(), require.name(), compiledVersion);\n-                    cob.aastore();\n-                }\n-                cob.invokevirtual(CD_MODULE_BUILDER,\n-                                  \"requires\",\n-                                  MTD_REQUIRES_ARRAY)\n-                    .pop();\n-            }\n-\n-            \/*\n-             * Invoke Builder.newRequires(Set<Modifier> mods, String mn, String compiledVersion)\n-             *\n-             * Set<Modifier> mods = ...\n-             * Builder.newRequires(mods, mn, compiledVersion);\n-             *\/\n-            void newRequires(Set<Requires.Modifier> mods, String name, String compiledVersion) {\n-                int varIndex = dedupSetBuilder.indexOfRequiresModifiers(cob, mods);\n-                cob.aload(varIndex)\n-                   .loadConstant(name);\n-                if (compiledVersion != null) {\n-                    cob.loadConstant(compiledVersion)\n-                       .invokestatic(CD_MODULE_BUILDER,\n-                                     \"newRequires\",\n-                                     MTD_REQUIRES_SET_STRING_STRING);\n-                } else {\n-                    cob.invokestatic(CD_MODULE_BUILDER,\n-                                     \"newRequires\",\n-                                     MTD_REQUIRES_SET_STRING);\n-                }\n-            }\n-\n-            \/*\n-             * Call Builder::newExports to create Exports instances and\n-             * then pass it to the builder by calling:\n-             *      Builder.exports(Exports[])\n-             *\n-             *\/\n-            void exports(Set<Exports> exports) {\n-                cob.aload(BUILDER_VAR)\n-                   .loadConstant(exports.size())\n-                   .anewarray(CD_EXPORTS);\n-                int arrayIndex = 0;\n-                for (Exports export : sorted(exports)) {\n-                    cob.dup()    \/\/ arrayref\n-                       .loadConstant(arrayIndex++);\n-                    newExports(export.modifiers(), export.source(), export.targets());\n-                    cob.aastore();\n-                }\n-                cob.invokevirtual(CD_MODULE_BUILDER,\n-                                  \"exports\",\n-                                  MTD_EXPORTS_ARRAY)\n-                    .pop();\n-            }\n-\n-            \/*\n-             * Invoke\n-             *     Builder.newExports(Set<Exports.Modifier> ms, String pn,\n-             *                        Set<String> targets)\n-             * or\n-             *     Builder.newExports(Set<Exports.Modifier> ms, String pn)\n-             *\n-             * Set<String> targets = new HashSet<>();\n-             * targets.add(t);\n-             * :\n-             * :\n-             *\n-             * Set<Modifier> mods = ...\n-             * Builder.newExports(mods, pn, targets);\n-             *\/\n-            void newExports(Set<Exports.Modifier> ms, String pn, Set<String> targets) {\n-                int modifiersSetIndex = dedupSetBuilder.indexOfExportsModifiers(cob, ms);\n-                if (!targets.isEmpty()) {\n-                    int stringSetIndex = dedupSetBuilder.indexOfStringSet(cob, targets);\n-                    cob.aload(modifiersSetIndex)\n-                       .loadConstant(pn)\n-                       .aload(stringSetIndex)\n-                       .invokestatic(CD_MODULE_BUILDER,\n-                                     \"newExports\",\n-                                     MTD_EXPORTS_MODIFIER_SET_STRING_SET);\n-                } else {\n-                    cob.aload(modifiersSetIndex)\n-                       .loadConstant(pn)\n-                       .invokestatic(CD_MODULE_BUILDER,\n-                                     \"newExports\",\n-                                     MTD_EXPORTS_MODIFIER_SET_STRING);\n-                }\n-            }\n-\n-\n-            \/**\n-             * Call Builder::newOpens to create Opens instances and\n-             * then pass it to the builder by calling:\n-             * Builder.opens(Opens[])\n-             *\/\n-            void opens(Set<Opens> opens) {\n-                cob.aload(BUILDER_VAR)\n-                   .loadConstant(opens.size())\n-                   .anewarray(CD_OPENS);\n-                int arrayIndex = 0;\n-                for (Opens open : sorted(opens)) {\n-                    cob.dup()    \/\/ arrayref\n-                       .loadConstant(arrayIndex++);\n-                    newOpens(open.modifiers(), open.source(), open.targets());\n-                    cob.aastore();\n-                }\n-                cob.invokevirtual(CD_MODULE_BUILDER,\n-                                  \"opens\",\n-                                  MTD_OPENS_ARRAY)\n-                    .pop();\n-            }\n-\n-            \/*\n-             * Invoke\n-             *     Builder.newOpens(Set<Opens.Modifier> ms, String pn,\n-             *                        Set<String> targets)\n-             * or\n-             *     Builder.newOpens(Set<Opens.Modifier> ms, String pn)\n-             *\n-             * Set<String> targets = new HashSet<>();\n-             * targets.add(t);\n-             * :\n-             * :\n-             *\n-             * Set<Modifier> mods = ...\n-             * Builder.newOpens(mods, pn, targets);\n-             *\/\n-            void newOpens(Set<Opens.Modifier> ms, String pn, Set<String> targets) {\n-                int modifiersSetIndex = dedupSetBuilder.indexOfOpensModifiers(cob, ms);\n-                if (!targets.isEmpty()) {\n-                    int stringSetIndex = dedupSetBuilder.indexOfStringSet(cob, targets);\n-                    cob.aload(modifiersSetIndex)\n-                       .loadConstant(pn)\n-                       .aload(stringSetIndex)\n-                       .invokestatic(CD_MODULE_BUILDER,\n-                                     \"newOpens\",\n-                                     MTD_OPENS_MODIFIER_SET_STRING_SET);\n-                } else {\n-                    cob.aload(modifiersSetIndex)\n-                       .loadConstant(pn)\n-                       .invokestatic(CD_MODULE_BUILDER,\n-                                     \"newOpens\",\n-                                     MTD_OPENS_MODIFIER_SET_STRING);\n-                }\n-            }\n-\n-            \/*\n-             * Invoke Builder.uses(Set<String> uses)\n-             *\/\n-            void uses(Set<String> uses) {\n-                int varIndex = dedupSetBuilder.indexOfStringSet(cob, uses);\n-                cob.aload(BUILDER_VAR)\n-                   .aload(varIndex)\n-                   .invokevirtual(CD_MODULE_BUILDER,\n-                                  \"uses\",\n-                                  MTD_SET)\n-                   .pop();\n-            }\n-\n-            \/*\n-            * Call Builder::newProvides to create Provides instances and\n-            * then pass it to the builder by calling:\n-            *      Builder.provides(Provides[] provides)\n-            *\n-            *\/\n-            void provides(Collection<Provides> provides) {\n-                cob.aload(BUILDER_VAR)\n-                   .loadConstant(provides.size())\n-                   .anewarray(CD_PROVIDES);\n-                int arrayIndex = 0;\n-                for (Provides provide : sorted(provides)) {\n-                    cob.dup()    \/\/ arrayref\n-                       .loadConstant(arrayIndex++);\n-                    newProvides(provide.service(), provide.providers());\n-                    cob.aastore();\n-                }\n-                cob.invokevirtual(CD_MODULE_BUILDER,\n-                                  \"provides\",\n-                                  MTD_PROVIDES_ARRAY)\n-                    .pop();\n-            }\n-\n-            \/*\n-             * Invoke Builder.newProvides(String service, Set<String> providers)\n-             *\n-             * Set<String> providers = new HashSet<>();\n-             * providers.add(impl);\n-             * :\n-             * :\n-             * Builder.newProvides(service, providers);\n-             *\/\n-            void newProvides(String service, List<String> providers) {\n-                cob.loadConstant(service)\n-                   .loadConstant(providers.size())\n-                   .anewarray(CD_String);\n-                int arrayIndex = 0;\n-                for (String provider : providers) {\n-                    cob.dup()    \/\/ arrayref\n-                       .loadConstant(arrayIndex++)\n-                       .loadConstant(provider)\n-                       .aastore();\n-                }\n-                cob.invokestatic(CD_List,\n-                                 \"of\",\n-                                 MTD_List_ObjectArray,\n-                                 true)\n-                   .invokestatic(CD_MODULE_BUILDER,\n-                                 \"newProvides\",\n-                                 MTD_PROVIDES_STRING_LIST);\n-            }\n-\n-            \/*\n-             * Invoke Builder.packages(String pn)\n-             *\/\n-            void packages(Set<String> packages) {\n-                int varIndex = dedupSetBuilder.newStringSet(cob, packages);\n-                cob.aload(BUILDER_VAR)\n-                   .aload(varIndex)\n-                   .invokevirtual(CD_MODULE_BUILDER,\n-                                  \"packages\",\n-                                  MTD_SET)\n-                   .pop();\n-            }\n-\n-            \/*\n-             * Invoke Builder.mainClass(String cn)\n-             *\/\n-            void mainClass(String cn) {\n-                cob.aload(BUILDER_VAR)\n-                   .loadConstant(cn)\n-                   .invokevirtual(CD_MODULE_BUILDER,\n-                                  \"mainClass\",\n-                                  MTD_STRING)\n-                   .pop();\n-            }\n-\n-            \/*\n-             * Invoke Builder.version(Version v);\n-             *\/\n-            void version(Version v) {\n-                cob.aload(BUILDER_VAR)\n-                   .loadConstant(v.toString())\n-                   .invokevirtual(CD_MODULE_BUILDER,\n-                                  \"version\",\n-                                  MTD_STRING)\n-                   .pop();\n-            }\n-\n-            void invokeBuilderMethod(String methodName, String value) {\n-                cob.aload(BUILDER_VAR)\n-                   .loadConstant(value)\n-                   .invokevirtual(CD_MODULE_BUILDER,\n-                                  methodName,\n-                                  MTD_STRING)\n-                   .pop();\n-            }\n+            var loadableSet = LoadableSet.of(sorted(set), STRING_LOADER);\n+            loadableSet.load(cob);\n@@ -1586,1 +1052,1 @@\n-            final Map<Set<String>, SetBuilder<String>> stringSets = new HashMap<>();\n+            final Map<Set<String>, SetReference> stringSets = new HashMap<>();\n@@ -1590,1 +1056,1 @@\n-            final Map<Set<Requires.Modifier>, EnumSetBuilder<Requires.Modifier>>\n+            final Map<Set<Requires.Modifier>, SetReference>\n@@ -1595,1 +1061,1 @@\n-            final Map<Set<Exports.Modifier>, EnumSetBuilder<Exports.Modifier>>\n+            final Map<Set<Exports.Modifier>, SetReference>\n@@ -1600,1 +1066,1 @@\n-            final Map<Set<Opens.Modifier>, EnumSetBuilder<Opens.Modifier>>\n+            final Map<Set<Opens.Modifier>, SetReference>\n@@ -1603,3 +1069,8 @@\n-            private final int stringSetVar;\n-            private final int enumSetVar;\n-            private final IntSupplier localVarSupplier;\n+            private static final String VALUES_ARRAY = \"dedupSetValues\";\n+\n+            final ClassDesc owner;\n+            private final ArrayList<SetReference> values = new ArrayList<>();\n+\n+            DedupSetBuilder(ClassDesc owner) {\n+                this.owner = owner;\n+            }\n@@ -1607,4 +1078,11 @@\n-            DedupSetBuilder(IntSupplier localVarSupplier) {\n-                this.stringSetVar = localVarSupplier.getAsInt();\n-                this.enumSetVar = localVarSupplier.getAsInt();\n-                this.localVarSupplier = localVarSupplier;\n+            <T extends Comparable<T>> SetReference createLoadableSet(Set<T> elements, ElementLoader<T> elementLoader) {\n+                var loadableSet = LoadableSet.of(sorted(elements),\n+                                                 elementLoader,\n+                                                 PAGING_THRESHOLD,\n+                                                 owner,\n+                                                 \"dedupSet\" + values.size(),\n+                                                 \/\/ Safe for String and Enum within 64K\n+                                                 3000);\n+                var ref = new SetReference(loadableSet);\n+                values.add(ref);\n+                return ref;\n@@ -1618,1 +1096,1 @@\n-                    s -> new SetBuilder<>(s, stringSetVar, localVarSupplier)\n+                        s -> createLoadableSet(s, STRING_LOADER)\n@@ -1626,3 +1104,2 @@\n-                exportsModifiersSets.computeIfAbsent(mods, s ->\n-                                new EnumSetBuilder<>(s, CD_EXPORTS_MODIFIER,\n-                                        enumSetVar, localVarSupplier)\n+                exportsModifiersSets.computeIfAbsent(mods,\n+                        s -> createLoadableSet(s, getEnumLoader(CD_EXPORTS_MODIFIER))\n@@ -1636,3 +1113,2 @@\n-                opensModifiersSets.computeIfAbsent(mods, s ->\n-                                new EnumSetBuilder<>(s, CD_OPENS_MODIFIER,\n-                                        enumSetVar, localVarSupplier)\n+                opensModifiersSets.computeIfAbsent(mods,\n+                        s -> createLoadableSet(s, getEnumLoader(CD_OPENS_MODIFIER))\n@@ -1646,3 +1122,2 @@\n-                requiresModifiersSets.computeIfAbsent(mods, s ->\n-                    new EnumSetBuilder<>(s, CD_REQUIRES_MODIFIER,\n-                                         enumSetVar, localVarSupplier)\n+                requiresModifiersSets.computeIfAbsent(mods,\n+                        s -> createLoadableSet(s, getEnumLoader(CD_REQUIRES_MODIFIER))\n@@ -1653,2 +1128,1 @@\n-             * Retrieve the index to the given set of Strings. Emit code to\n-             * generate it when SetBuilder::build is called.\n+             * Load the given set to the top of operand stack.\n@@ -1656,2 +1130,2 @@\n-            int indexOfStringSet(CodeBuilder cob, Set<String> names) {\n-                return stringSets.get(names).build(cob);\n+            void loadStringSet(CodeBuilder cob, Set<String> names) {\n+                stringSets.get(names).load(cob);\n@@ -1661,2 +1135,1 @@\n-             * Retrieve the index to the given set of Exports.Modifier.\n-             * Emit code to generate it when EnumSetBuilder::build is called.\n+             * Load the given set to the top of operand stack.\n@@ -1664,2 +1137,2 @@\n-            int indexOfExportsModifiers(CodeBuilder cob, Set<Exports.Modifier> mods) {\n-                return exportsModifiersSets.get(mods).build(cob);\n+            void loadExportsModifiers(CodeBuilder cob, Set<Exports.Modifier> mods) {\n+                exportsModifiersSets.get(mods).load(cob);\n@@ -1668,3 +1141,2 @@\n-            \/**\n-             * Retrieve the index to the given set of Opens.Modifier.\n-             * Emit code to generate it when EnumSetBuilder::build is called.\n+            \/*\n+             * Load the given set to the top of operand stack.\n@@ -1672,2 +1144,2 @@\n-            int indexOfOpensModifiers(CodeBuilder cob, Set<Opens.Modifier> mods) {\n-                return opensModifiersSets.get(mods).build(cob);\n+            void loadOpensModifiers(CodeBuilder cob, Set<Opens.Modifier> mods) {\n+                opensModifiersSets.get(mods).load(cob);\n@@ -1678,2 +1150,1 @@\n-             * Retrieve the index to the given set of Requires.Modifier.\n-             * Emit code to generate it when EnumSetBuilder::build is called.\n+             * Load the given set to the top of operand stack.\n@@ -1681,2 +1152,2 @@\n-            int indexOfRequiresModifiers(CodeBuilder cob, Set<Requires.Modifier> mods) {\n-                return requiresModifiersSets.get(mods).build(cob);\n+            void loadRequiresModifiers(CodeBuilder cob, Set<Requires.Modifier> mods) {\n+                requiresModifiersSets.get(mods).load(cob);\n@@ -1686,1 +1157,15 @@\n-             * Build a new string set without any attempt to deduplicate it.\n+             * Adding provider methods to the class. For those set used more than once, built\n+             * once and keep the reference for later access.\n+             * Return a list of snippet to be used in <clinit>.\n+             *\n+             * The returned snippet would set up the set referenced more than once,\n+             *\n+             * static final Set[] dedupSetValues;\n+             *\n+             * static {\n+             *     dedupSetValues = new Set[countOfStoredValues];\n+             *     dedupSetValues[0] = Set.of(elements); \/\/ elements no more than SET_SIZE_THRESHOLD\n+             *     dedupSetValues[1] = dedup<setWithIndex>Provider(); \/\/ set elements more than SET_SIZE_THRESHOLD\n+             *     ...\n+             *     dedupSetValues[countOfStoredValues - 1] = ...\n+             * }\n@@ -1688,6 +1173,2 @@\n-            int newStringSet(CodeBuilder cob, Set<String> names) {\n-                int index = new SetBuilder<>(names, stringSetVar, localVarSupplier).build(cob);\n-                assert index == stringSetVar;\n-                return index;\n-            }\n-        }\n+            Optional<Consumer<CodeBuilder>> buildConstants(ClassBuilder clb) {\n+                var staticCache = new ArrayList<SetReference>();\n@@ -1695,24 +1176,6 @@\n-        \/*\n-         * SetBuilder generates bytecode to create one single instance of Set\n-         * for a given set of elements and assign to a local variable slot.\n-         * When there is only one single reference to a Set<T>,\n-         * it will reuse defaultVarIndex.  For a Set with multiple references,\n-         * it will use a new local variable retrieved from the nextLocalVar\n-         *\/\n-        static class SetBuilder<T extends Comparable<T>> {\n-            private static final MethodTypeDesc MTD_Set_ObjectArray = MethodTypeDesc.of(\n-                    CD_Set, CD_Object.arrayType());\n-\n-            private final Set<T> elements;\n-            private final int defaultVarIndex;\n-            private final IntSupplier nextLocalVar;\n-            private int refCount;\n-            private int localVarIndex;\n-\n-            SetBuilder(Set<T> elements,\n-                       int defaultVarIndex,\n-                       IntSupplier nextLocalVar) {\n-                this.elements = elements;\n-                this.defaultVarIndex = defaultVarIndex;\n-                this.nextLocalVar = nextLocalVar;\n-            }\n+                for (var set: values) {\n+                    set.loadableSet().setup(clb);\n+                    if (set.refCount() > 1) {\n+                        staticCache.add(set);\n+                    }\n+                }\n@@ -1720,6 +1183,3 @@\n-            \/*\n-             * Increments the number of references to this particular set.\n-             *\/\n-            final void increment() {\n-                refCount++;\n-            }\n+                if (staticCache.isEmpty()) {\n+                    return Optional.empty();\n+                }\n@@ -1727,6 +1187,24 @@\n-            \/**\n-             * Generate the appropriate instructions to load an object reference\n-             * to the element onto the stack.\n-             *\/\n-            void visitElement(T element, CodeBuilder cob) {\n-                cob.loadConstant((ConstantDesc)element);\n+                \/\/ This is called when the value is build for the cache\n+                \/\/ At that time, a slot in cache is assigned\n+                \/\/ The loader is called when building the static initializer\n+                \/\/ We need to ensure that happens before we access SetReference::load\n+                ElementLoader<SetReference> cacheLoader = (cob, setRef, index) -> {\n+                    setRef.assignTo(index);\n+                    setRef.loadableSet().load(cob);\n+                };\n+\n+                var loadableArray = LoadableArray.of(\n+                        CD_Set,\n+                        staticCache,\n+                        cacheLoader,\n+                        PAGING_THRESHOLD,\n+                        owner,\n+                        VALUES_ARRAY,\n+                        2000);\n+\n+                loadableArray.setup(clb);\n+                clb.withField(VALUES_ARRAY, CD_Set.arrayType(), ACC_STATIC | ACC_FINAL);\n+                return Optional.of(cob -> {\n+                        loadableArray.load(cob);\n+                        cob.putstatic(owner, VALUES_ARRAY, CD_Set.arrayType());\n+                });\n@@ -1736,5 +1214,5 @@\n-             * Build bytecode for the Set represented by this builder,\n-             * or get the local variable index of a previously generated set\n-             * (in the local scope).\n-             *\n-             * @return local variable index of the generated set.\n+             * SetReference count references to the set, and use LoadableSet under the hood to\n+             * support paginiation as needed.\n+             * For sets referenced more than once, a cache is used to store the pre-built result\n+             * and load from there. Otherwise, the set is built in place and load onto the operand\n+             * stack.\n@@ -1742,13 +1220,7 @@\n-            final int build(CodeBuilder cob) {\n-                int index = localVarIndex;\n-                if (localVarIndex == 0) {\n-                    \/\/ if non-empty and more than one set reference this builder,\n-                    \/\/ emit to a unique local\n-                    index = refCount <= 1 ? defaultVarIndex\n-                                          : nextLocalVar.getAsInt();\n-                    if (index < MAX_LOCAL_VARS) {\n-                        localVarIndex = index;\n-                    } else {\n-                        \/\/ overflow: disable optimization by using localVarIndex = 0\n-                        index = defaultVarIndex;\n-                    }\n+            class SetReference {\n+                \/\/ sorted elements of the set to ensure same generated code\n+                private final LoadableSet loadableSet;\n+\n+                private int refCount;\n+                \/\/ The index for this set value in the cache array\n+                private int index = -1;\n@@ -1756,1 +1228,2 @@\n-                    generateSetOf(cob, index);\n+                SetReference(LoadableSet set) {\n+                    this.loadableSet = set;\n@@ -1758,2 +1231,0 @@\n-                return index;\n-            }\n@@ -1761,28 +1232,2 @@\n-            private void generateSetOf(CodeBuilder cob, int index) {\n-                if (elements.size() <= 10) {\n-                    \/\/ call Set.of(e1, e2, ...)\n-                    for (T t : sorted(elements)) {\n-                        visitElement(t, cob);\n-                    }\n-                    var mtdArgs = new ClassDesc[elements.size()];\n-                    Arrays.fill(mtdArgs, CD_Object);\n-                    cob.invokestatic(CD_Set,\n-                                     \"of\",\n-                                     MethodTypeDesc.of(CD_Set, mtdArgs),\n-                                     true);\n-                } else {\n-                    \/\/ call Set.of(E... elements)\n-                    cob.loadConstant(elements.size())\n-                       .anewarray(CD_String);\n-                    int arrayIndex = 0;\n-                    for (T t : sorted(elements)) {\n-                        cob.dup()    \/\/ arrayref\n-                           .loadConstant(arrayIndex);\n-                        visitElement(t, cob);  \/\/ value\n-                        cob.aastore();\n-                        arrayIndex++;\n-                    }\n-                    cob.invokestatic(CD_Set,\n-                                     \"of\",\n-                                     MTD_Set_ObjectArray,\n-                                     true);\n+                int increment() {\n+                    return ++refCount;\n@@ -1790,3 +1235,0 @@\n-                cob.astore(index);\n-            }\n-        }\n@@ -1794,13 +1236,3 @@\n-        \/*\n-         * Generates bytecode to create one single instance of EnumSet\n-         * for a given set of modifiers and assign to a local variable slot.\n-         *\/\n-        static class EnumSetBuilder<T extends Comparable<T>> extends SetBuilder<T> {\n-            private final ClassDesc classDesc;\n-\n-            EnumSetBuilder(Set<T> modifiers, ClassDesc classDesc,\n-                           int defaultVarIndex,\n-                           IntSupplier nextLocalVar) {\n-                super(modifiers, defaultVarIndex, nextLocalVar);\n-                this.classDesc = classDesc;\n-            }\n+                int refCount() {\n+                    return refCount;\n+                }\n@@ -1808,6 +1240,23 @@\n-            \/**\n-             * Loads an Enum field.\n-             *\/\n-            @Override\n-            void visitElement(T t, CodeBuilder cob) {\n-                cob.getstatic(classDesc, t.toString(), classDesc);\n+                LoadableSet loadableSet() {\n+                    return loadableSet;\n+                }\n+\n+                void assignTo(int index) {\n+                    this.index = index;\n+                }\n+\n+                \/\/ Load the set to the operand stack.\n+                \/\/ When referenced more than once, the value is pre-built with static initialzer\n+                \/\/ and is load from the cache array with\n+                \/\/   dedupSetValues[index]\n+                \/\/ Otherwise, LoadableSet will load the set onto the operand stack.\n+                void load(CodeBuilder cob) {\n+                    if (refCount > 1) {\n+                        assert index >= 0;\n+                        cob.getstatic(owner, VALUES_ARRAY, CD_Set.arrayType());\n+                        cob.loadConstant(index);\n+                        cob.aaload();\n+                    } else {\n+                        loadableSet.load(cob);\n+                    }\n+                }\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/SystemModulesPlugin.java","additions":199,"deletions":750,"binary":false,"changes":949,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.StringJoiner;\n+import java.util.spi.ToolProvider;\n+\n+import tests.JImageGenerator;\n+\n+\/*\n+ * @test\n+ * @summary Make sure that ~20000 packages in a uber jar can be linked using jlink. Now that\n+ *          pagination is in place, the limitation is on the constant pool size, not number\n+ *          of packages.\n+ * @bug 8321413\n+ * @library ..\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ *          jdk.jlink\/jdk.tools.jmod\n+ *          jdk.jlink\/jdk.tools.jimage\n+ *          jdk.compiler\n+ * @build tests.*\n+ * @run main\/othervm -Xmx1g -Xlog:init=debug -XX:+UnlockDiagnosticVMOptions -XX:+BytecodeVerificationLocal JLink20000Packages\n+ *\/\n+public class JLink20000Packages {\n+    private static final ToolProvider JAVAC_TOOL = ToolProvider.findFirst(\"javac\")\n+            .orElseThrow(() -> new RuntimeException(\"javac tool not found\"));\n+\n+    static void report(String command, String[] args) {\n+        System.out.println(command + \" \" + String.join(\" \", Arrays.asList(args)));\n+    }\n+\n+    static void javac(String[] args) {\n+        report(\"javac\", args);\n+        JAVAC_TOOL.run(System.out, System.err, args);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Path src = Paths.get(\"bug8321413\");\n+        Path mainModulePath = src.resolve(\"bug8321413x\");\n+\n+        StringJoiner mainModuleInfoContent = new StringJoiner(\";\\n  exports \", \"module bug8321413x {\\n  exports \", \";\\n}\");\n+\n+        for (int i = 0; i < 20000; i++) {\n+            String packageName = \"p\" + i;\n+            String className = \"C\" + i;\n+\n+            Path packagePath = Files.createDirectories(mainModulePath.resolve(packageName));\n+\n+            StringBuilder classContent = new StringBuilder(\"package \");\n+            classContent.append(packageName).append(\";\\n\");\n+            classContent.append(\"class \").append(className).append(\" {}\\n\");\n+            Files.writeString(packagePath.resolve(className + \".java\"), classContent.toString());\n+\n+            mainModuleInfoContent.add(packageName);\n+        }\n+\n+        \/\/ create module reading the generated modules\n+        Path mainModuleInfo = mainModulePath.resolve(\"module-info.java\");\n+        Files.writeString(mainModuleInfo, mainModuleInfoContent.toString());\n+\n+        Path mainClassDir = mainModulePath.resolve(\"testpackage\");\n+        Files.createDirectories(mainClassDir);\n+\n+        Files.writeString(mainClassDir.resolve(\"JLink20000PackagesTest.java\"), \"\"\"\n+                package testpackage;\n+\n+                public class JLink20000PackagesTest {\n+                    public static void main(String[] args) throws Exception {\n+                        System.out.println(\"JLink20000PackagesTest started.\");\n+                    }\n+                }\n+                \"\"\");\n+\n+        String out = src.resolve(\"out\").toString();\n+        javac(new String[]{\n+                \"-d\", out,\n+                \"--module-source-path\", src.toString(),\n+                \"--module\", \"bug8321413x\"\n+        });\n+\n+        JImageGenerator.getJLinkTask()\n+                .modulePath(out)\n+                .output(src.resolve(\"out-jlink\"))\n+                .addMods(\"bug8321413x\")\n+                .call()\n+                .assertSuccess();\n+\n+        Path binDir = src.resolve(\"out-jlink\").resolve(\"bin\").toAbsolutePath();\n+        Path bin = binDir.resolve(\"java\");\n+\n+        ProcessBuilder processBuilder = new ProcessBuilder(bin.toString(),\n+                \"-XX:+UnlockDiagnosticVMOptions\",\n+                \"-XX:+BytecodeVerificationLocal\",\n+                \"-m\", \"bug8321413x\/testpackage.JLink20000PackagesTest\");\n+        processBuilder.inheritIO();\n+        processBuilder.directory(binDir.toFile());\n+        Process process = processBuilder.start();\n+        int exitCode = process.waitFor();\n+        if (exitCode != 0)\n+             throw new AssertionError(\"JLink20000PackagesTest failed to launch\");\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/JLink20000Packages.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,305 @@\n+\/*\n+ * Copyright (c) 2024, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.lang.classfile.ClassFile;\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+import java.lang.constant.ClassDesc;\n+import static java.lang.constant.ConstantDescs.CD_Integer;\n+import static java.lang.constant.ConstantDescs.CD_Object;\n+import static java.lang.constant.ConstantDescs.CD_String;\n+import static java.lang.constant.ConstantDescs.INIT_NAME;\n+import static java.lang.constant.ConstantDescs.MTD_void;\n+import java.lang.constant.MethodTypeDesc;\n+import static java.lang.invoke.MethodHandles.lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.module.ModuleDescriptor;\n+import java.lang.reflect.AccessFlag;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.*;\n+import java.util.function.Supplier;\n+import java.util.stream.IntStream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import jdk.tools.jlink.internal.Snippets.*;\n+import static jdk.tools.jlink.internal.Snippets.*;\n+import jdk.tools.jlink.internal.Snippets.ElementLoader;\n+\n+\/*\n+ * @test\n+ * @summary Test snippets generation for array and set.\n+ * @bug 8321413\n+ * @enablePreview\n+ * @modules jdk.jlink\/jdk.tools.jlink.internal\n+ * @run junit SnippetsTest\n+ *\/\n+public class SnippetsTest {\n+    private static final boolean WRITE_CLASS_FILE = Boolean.parseBoolean(System.getProperty(\"DumpArraySnippetsTestClasses\", \"true\"));\n+\n+    @ParameterizedTest\n+    @ValueSource(ints = { 10, 75, 90, 120, 200, 399, 400, 401})\n+    void testLoad400StringsArray(int pageSize) {\n+        testPaginatedArray(400, pageSize);\n+    }\n+\n+    @Test\n+    void testStringArrayLimitsWithPagination() {\n+        \/\/ Each string takes 2 constant pool slot, one for String, another for Utf8\n+        testPaginatedArray(31_000, 8000);\n+        try {\n+            testPaginatedArray(32_000, 8000);\n+        } catch (IllegalArgumentException iae) {\n+            \/\/ expected constant pool explode\n+        }\n+    }\n+\n+    @Test\n+    void testStringArrayLimitsWithoutPagination() {\n+        \/\/ each string array assignment takes ~8 bytes\n+        testSimpleArray(8200);\n+        try {\n+            testSimpleArray(8300);\n+            fail();\n+        } catch (IllegalArgumentException iae) {\n+            \/\/ expected code size explode\n+        }\n+    }\n+\n+    @Test\n+    void testEnumLoader() {\n+        ClassDesc CD_ACCESSFLAG = AccessFlag.class.describeConstable().get();\n+        var expected = AccessFlag.values();\n+        var loadable = new SimpleArray(CD_ACCESSFLAG, expected, getEnumLoader(CD_ACCESSFLAG));\n+        Supplier<AccessFlag[]> supplier = generateSupplier(\"TestEnumLoader\", loadable);\n+        assertArrayEquals(expected, supplier.get());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testWrapperLoadable(boolean isStatic) throws NoSuchMethodException {\n+        var expected = IntStream.range(0, 1234)\n+                                 .mapToObj(i -> \"WrapperTestString\" + i)\n+                                 .toList();\n+        var className = \"WrapperLoadableTest\" + (isStatic ? \"Static\" : \"Public\");\n+        ClassDesc testClassDesc = ClassDesc.of(className);\n+\n+        var loadable = new PaginatedArray<>(\n+                CD_String, expected, STRING_LOADER, testClassDesc, \"page\", 100);\n+        \/\/ 1234 with 10 per page, should have 13 pages with last page 34 elements\n+        assertEquals(13, loadable.pageCount());\n+        assertTrue(loadable.isLastPagePartial());\n+\n+        var wrapped = new WrappedLoadable(loadable, testClassDesc, \"wrapper\", isStatic);\n+        Supplier<String[]> supplier = generateSupplier(className, wrapped, loadable);\n+        verifyPaginationMethods(supplier.getClass(), String.class, \"page\", 13);\n+        assertArrayEquals(expected.toArray(), supplier.get());\n+\n+        \/\/ check wrapper function\n+        var methodType = MethodType.methodType(String[].class);\n+        try {\n+            lookup().findStatic(supplier.getClass(), wrapped.methodName(), methodType);\n+        } catch (IllegalAccessException ex) {\n+            assertFalse(isStatic);\n+        }\n+        try {\n+            lookup().findVirtual(supplier.getClass(), wrapped.methodName(), methodType);\n+        } catch (IllegalAccessException ex) {\n+            assertTrue(isStatic);\n+        }\n+    }\n+\n+    @Test\n+    void testLoadableEnum() {\n+        Enum<?>[] enums = {\n+            AccessFlag.FINAL,\n+            ModuleDescriptor.Requires.Modifier.MANDATED,\n+            ModuleDescriptor.Opens.Modifier.SYNTHETIC,\n+            ModuleDescriptor.Requires.Modifier.TRANSITIVE\n+        };\n+\n+        var loadable = new SimpleArray<LoadableEnum>(\n+                Enum.class.describeConstable().get(),\n+                Arrays.stream(enums).map(LoadableEnum::new).toList(),\n+                ElementLoader.selfLoader());\n+\n+        Supplier<Enum<?>[]> supplier = generateSupplier(\"LoadableEnumTest\", loadable);\n+        assertArrayEquals(enums, supplier.get());\n+    }\n+\n+    @Test\n+    void testLoadableArrayOf() {\n+        Integer[] expected = IntStream.range(0, 200)\n+                                .boxed()\n+                                .toArray(Integer[]::new);\n+        var className = \"LoadableArrayOf200Paged\";\n+        var loadable = LoadableArray.of(CD_Integer,\n+                Arrays.asList(expected),\n+                INTEGER_LOADER,\n+                expected.length - 1,\n+                ClassDesc.of(className),\n+                \"page\",\n+                100);\n+        assertTrue(loadable instanceof PaginatedArray);\n+\n+        Supplier<Integer[]> supplier = generateSupplier(className, loadable);\n+        verifyPaginationMethods(supplier.getClass(), Integer.class, \"page\", 2);\n+        assertArrayEquals(expected, supplier.get());\n+\n+        loadable = LoadableArray.of(\n+                CD_Integer,\n+                Arrays.asList(expected),\n+                INTEGER_LOADER,\n+                expected.length,\n+                ClassDesc.of(\"LoadableArrayOf200NotPaged\"),\n+                \"page\",\n+                100);\n+        assertTrue(loadable instanceof SimpleArray);\n+\n+        \/\/ SimpleArray generate bytecode inline, so can be generated in any class\n+        supplier = generateSupplier(\"TestLoadableArrayFactory\", loadable);\n+        assertArrayEquals(expected, supplier.get());\n+    }\n+\n+    @Test\n+    void testLoadableSetOf() {\n+        String[] data = IntStream.range(0, 100)\n+                                 .mapToObj(i -> \"SetData\" + i)\n+                                 .toArray(String[]::new);\n+\n+        var tiny = Set.of(data[0], data[1], data[2]);\n+        var all = Set.of(data);\n+\n+        Supplier<Set<String>> supplier = generateSupplier(\"TinySetTest\", LoadableSet.of(tiny, STRING_LOADER));\n+        \/\/ Set does not guarantee ordering, so not assertIterableEquals\n+        assertEquals(tiny, supplier.get());\n+\n+        supplier = generateSupplier(\"AllSetTestNoPage\", LoadableSet.of(all, STRING_LOADER));\n+        assertEquals(all, supplier.get());\n+\n+        var className = \"AllSetTestPageNotActivated\";\n+        var methodNamePrefix = \"page\";\n+        var loadable = LoadableSet.of(all, STRING_LOADER, all.size(),\n+                ClassDesc.of(className), methodNamePrefix, 10);\n+        supplier = generateSupplier(className, loadable);\n+        assertEquals(all, supplier.get());\n+\n+        className = \"AllSetTestPageSize20\";\n+        loadable = LoadableSet.of(all, STRING_LOADER, all.size() - 1,\n+                ClassDesc.of(className), methodNamePrefix, 20);\n+        supplier = generateSupplier(className, loadable);\n+        \/\/ Set erased element type and use Object as element type\n+        verifyPaginationMethods(supplier.getClass(), Object.class, methodNamePrefix, 5);\n+        assertEquals(all, supplier.get());\n+    }\n+\n+    void testPaginatedArray(int elementCount, int pageSize) {\n+        String[] expected = IntStream.range(0, elementCount)\n+                                 .mapToObj(i -> \"Package\" + i)\n+                                 .toArray(String[]::new);\n+        var className = String.format(\"SnippetArrayProviderTest%dPagedBy%d\", elementCount, pageSize);\n+        ClassDesc testClassDesc = ClassDesc.of(className);\n+        var loadable = new PaginatedArray<>(CD_String, expected, STRING_LOADER,\n+                testClassDesc, \"ArrayPage\", pageSize);\n+\n+        Supplier<String[]> supplier = generateSupplier(className, loadable);\n+        verifyPaginationMethods(supplier.getClass(), String.class, \"ArrayPage\", loadable.pageCount());\n+        assertEquals((elementCount % pageSize) != 0, loadable.isLastPagePartial());\n+        assertArrayEquals(expected, supplier.get());\n+    }\n+\n+    void testSimpleArray(int elementCount) {\n+        String[] expected = IntStream.range(0, elementCount)\n+                                 .mapToObj(i -> \"NoPage\" + i)\n+                                 .toArray(String[]::new);\n+        String className = \"SnippetArrayProviderTest\" + elementCount;\n+        var array = new SimpleArray<>(CD_String, Arrays.asList(expected), STRING_LOADER);\n+\n+        Supplier<String[]> supplier = generateSupplier(className, array);\n+        assertArrayEquals(expected, supplier.get());\n+    }\n+\n+    <T> Supplier<T> generateSupplier(String className, Loadable loadable, Loadable... extra) {\n+        var testClassDesc = ClassDesc.of(className);\n+        byte[] classBytes = generateSupplierClass(testClassDesc, loadable, extra);\n+        try {\n+            writeClassFile(className, classBytes);\n+            var testClass = lookup().defineClass(classBytes);\n+            lookup().findVirtual(testClass, \"get\", MethodType.methodType(Object.class));\n+            return (Supplier<T>) testClass.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    void verifyPaginationMethods(Class<?> testClass, Class<?> elementType, String methodNamePrefix, int pageCount) {\n+        for (int i = 0; i < pageCount; i++) {\n+            try {\n+                lookup().findStatic(testClass, methodNamePrefix + i,\n+                        MethodType.methodType(elementType.arrayType(), elementType.arrayType()));\n+            } catch (Exception ex) {\n+                throw new RuntimeException(ex);\n+            }\n+        }\n+    }\n+\n+    byte[] generateSupplierClass(ClassDesc testClassDesc, Loadable loadable, Loadable... extra) {\n+        return ClassFile.of().build(testClassDesc,\n+                clb -> {\n+                    clb.withSuperclass(CD_Object);\n+                    clb.withInterfaceSymbols(ClassDesc.ofInternalName(\"java\/util\/function\/Supplier\"));\n+                    clb.withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC, cob -> {\n+                        cob.aload(0);\n+                        cob.invokespecial(CD_Object, INIT_NAME, MTD_void);\n+                        cob.return_();\n+                    });\n+\n+                    if (loadable.doesRequireSetup()) {\n+                        loadable.setup(clb);\n+                    }\n+\n+                    for (var e: extra) {\n+                        \/\/ always call setup should be no harm\n+                        \/\/ it suppose to be nop if not required.\n+                        e.setup(clb);\n+                    }\n+\n+                    clb.withMethodBody(\"get\", MethodTypeDesc.of(CD_Object), ACC_PUBLIC, cob -> {\n+                        loadable.load(cob);\n+                        cob.areturn();\n+                    });\n+                });\n+    }\n+\n+    void writeClassFile(String className, byte[] classBytes) throws IOException {\n+        if (WRITE_CLASS_FILE) {\n+            Files.write(Path.of(className + \".class\"), classBytes);\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/tools\/jlink\/SnippetsTest.java","additions":305,"deletions":0,"binary":false,"changes":305,"status":"added"}]}