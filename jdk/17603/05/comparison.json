{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -495,0 +495,104 @@\n+\n+    \/**\n+     * {@return {@code true} if {@code a} and {@code b} produce equivalent values\n+     * when they are passed in as parameters to {@code first} and the functions of\n+     * {@code rest}, and {@code false} otherwise.}\n+     *\n+     * If {@code a}, {@code b}, or {@code first} are {@code null}, a\n+     * {@code NullPointerException} will be thrown. If {@code rest} (or any of\n+     * the functions inside of {@code rest}) are {@code null}, a\n+     * {@code NullPointerException} *may* be thrown, depending on\n+     * whether or not this function short-circuits prior to reaching {@code rest},\n+     * or the {@code null} function in {@code rest}.\n+     *\n+     * Here is an example.\n+     *\n+     * {@snippet :\n+     *\n+     * record Point3D(int x, int y, int z) {}\n+     *\n+     * final var a = new Point3D(1, 2, 3);\n+     * final var b = new Point3D(1, 24, 3);\n+     *\n+     * \/\/Always a NPE -- the first function can never be null!\n+     * System.out.println(equalsBy(a, b, null, Point3D::y, Point3D::z));\n+     *\n+     * \/\/NPE -- the first function returned an equivalent value, so we try\n+     * \/\/the second function, only to find out that it is null. So, NPE.\n+     * System.out.println(equalsBy(a, b, Point3D::x, null, Point3D::z));\n+     *\n+     * \/\/Returns false -- We short circuit early because, while Point3D::x\n+     * \/\/returned true, Point3D::y returned false. Therefore, no need to\n+     * \/\/apply the final function, thus avoiding the NPE.\n+     * System.out.println(equalsBy(a, b, Point3D::x, Point3D::y, null));\n+     *\n+     * final var c = new Point3D(2, 123, 123);\n+     *\n+     * \/\/Returns false -- We short circuit on first because Point3D::x\n+     * \/\/returned false. Therefore, no need to apply the null function in\n+     * \/\/rest, thus avoiding the NPE.\n+     * System.out.println(equalsBy(a, c, Point3D::x, null, Point3D::z));\n+     *\n+     * \/\/Returns false -- Same logic as the previous example, but this time,\n+     * \/\/rest itself is null.\n+     * System.out.println(equalsBy(a, c, Point3D::x, null));\n+     *\n+     * }\n+     *\n+     * Value equivalence is determined by calling {@link Objects#equals equals} on\n+     * the values produced by passing in {@code a} and {@code b} to the given\n+     * functions.\n+     *\n+     * <p>This method is useful for implementing {@link Object#equals()}.\n+     * Consider the following example.<\/p>\n+     *\n+     * {@snippet :\n+     * @Override public boolean equals(Object obj) {\n+     *\n+     *     \/\/Assume that we are writing an equals method for the Point3D from\n+     *     \/\/above (even though it doesn't need it since it is a record).\n+     *\n+     *     if (this == obj) {\n+     *         return true;\n+     *     }\n+     *\n+     *     return obj instanceof final Point3D other\n+     *             && Objects.equalsBy(this, other, Point3D::x, Point3D::y, Point3D::z);\n+     *\n+     * }\n+     * }\n+     *\n+     * @param <T> the type of the objects being checked for equality\n+     * @param a the first object to be checked for equality\n+     * @param b the second object to be checked for equality\n+     * @param first the first function to be applied to {@code a} and {@code b}\n+     * @param rest the rest of the functions to be applied to {@code a} and {@code b}\n+     * @throws NullPointerException if {@code a}, {@code b}, or {@code first} are {@code null} and (potentially) if {@code rest} is {@code null} or contains a {@code null}\n+     * @since 23\n+     *\/\n+    @SafeVarargs\n+    public static <T> boolean equalsBy(T a, T b, Function<? super T, ?> first, Function<? super T, ?>... rest) {\n+\n+        requireNonNull(a, \"Objects.equalsBy cannot execute because the first object being checked is null!\");\n+        requireNonNull(b, \"Objects.equalsBy cannot execute because the second object being checked is null!\");\n+        requireNonNull(first, \"Objects.equalsBy cannot execute because the first function being applied is null!\");\n+\n+        if (!equals(first.apply(a), first.apply(b))) {\n+            return false;\n+        }\n+\n+        requireNonNull(rest, \"Objects.equalsBy cannot iterate through a null array of functions!\");\n+\n+        for (final var function : rest) {\n+\n+            requireNonNull(function, \"Objects.equalsBy cannot apply a null function!\");\n+\n+            final var aValue = function.apply(a);\n+            final var bValue = function.apply(b);\n+\n+            if (!equals(aValue, bValue)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/Objects.java","additions":105,"deletions":1,"binary":false,"changes":106,"status":"modified"}]}