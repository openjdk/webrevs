{"files":[{"patch":"@@ -47,0 +47,3 @@\n+  else ifeq ($(call isTargetCpuArch, arm), true)\n+    CAPSTONE_ARCH := CS_ARCH_ARM\n+    CAPSTONE_MODE := CS_MODE_ARM\n","filename":"make\/Hsdis.gmk","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -462,1 +462,1 @@\n-  Address(Register base, RegisterOrConstant index, extend ext = lsl()) {\n+  Address(Register base, RegisterOrConstant index, extend ext = lsl(0)) {\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2597,2 +2597,3 @@\n-void LIR_Assembler::increment_profile_ctr(LIR_Opr step, LIR_Opr counter_addr, LIR_Opr dest, LIR_Opr temp_op,\n-                                          LIR_Opr freq_op,\n+void LIR_Assembler::increment_profile_ctr(LIR_Opr step, LIR_Opr dest_opr,\n+                                          LIR_Opr freq_opr,\n+                                          LIR_Opr md_reg, LIR_Opr md_opr, LIR_Opr md_offset_opr,\n@@ -2615,2 +2616,1 @@\n-  Register temp = temp_op->is_register() ? temp_op->as_register() : noreg;\n-  Address raw_dest_adr = as_Address(counter_addr->as_address_ptr());\n+  Register dest = as_reg(dest_opr);\n@@ -2618,2 +2618,2 @@\n-  auto lambda = [counter_stub, overflow_stub, freq_op, ratio_shift, step,\n-                 temp, dest, raw_dest_adr] (LIR_Assembler* ce, LIR_Op* op) {\n+  auto lambda = [counter_stub, overflow_stub, freq_opr, dest_opr, dest, ratio_shift, step,\n+                 md_reg, md_opr, md_offset_opr] (LIR_Assembler* ce, LIR_Op* op) {\n@@ -2625,0 +2625,1 @@\n+    Address counter_address;\n@@ -2628,0 +2629,14 @@\n+    if (md_opr->is_valid()) {\n+      if (md_opr->type() == T_METADATA) {\n+        __ mov_metadata(md_reg->as_register(),\n+                          md_opr->as_constant_ptr()->as_metadata());\n+      } else {\n+        __ mov(md_reg->as_pointer_register(),\n+               md_opr->as_constant_ptr()->as_pointer());\n+      }\n+      RegisterOrConstant offset =\n+        md_offset_opr->is_constant()\n+        ? RegisterOrConstant(md_offset_opr->as_constant_ptr()->as_jint())\n+        : as_reg(md_offset_opr);\n+      counter_address = Address(md_reg->as_pointer_register(), offset);\n+    }\n@@ -2629,1 +2644,1 @@\n-      Address dest_adr = __ legitimize_address(raw_dest_adr, sizeof (jint), rscratch2);\n+      Address dest_adr = __ legitimize_address(counter_address, sizeof (jint), rscratch2);\n@@ -2631,1 +2646,1 @@\n-      __ ldrw(temp, dest_adr);\n+      __ ldrw(dest, dest_adr);\n@@ -2635,3 +2650,2 @@\n-      __ addw(temp, temp, inc);\n-      __ strw(temp, dest_adr);\n-      if (dest->is_register())  __ mov(dest->as_register(), temp);\n+      __ addw(dest, dest, inc);\n+      __ strw(dest, dest_adr);\n@@ -2641,1 +2655,0 @@\n-      if (dest->is_register())  __ mov(dest->as_register(), temp);\n@@ -2644,1 +2657,1 @@\n-      switch (dest->type()) {\n+      switch (dest_opr->type()) {\n@@ -2646,1 +2659,1 @@\n-          Address dest_adr = __ legitimize_address(raw_dest_adr, sizeof (jint), rscratch2);\n+          Address dest_adr = __ legitimize_address(counter_address, sizeof (jint), rscratch2);\n@@ -2648,2 +2661,1 @@\n-          __ incrementw(dest_adr, inc, temp);\n-          if (dest->is_register())  __ movw(dest->as_register(), temp);\n+          __ incrementw(dest_adr, inc, dest);\n@@ -2654,1 +2666,1 @@\n-          Address dest_adr = __ legitimize_address(raw_dest_adr, sizeof (jlong), rscratch2);\n+          Address dest_adr = __ legitimize_address(counter_address, sizeof (jlong), rscratch2);\n@@ -2656,2 +2668,1 @@\n-          __ increment(dest_adr, inc, temp);\n-          if (dest->is_register())  __ mov(dest->as_register_lo(), temp);\n+          __ increment(dest_adr, inc, dest);\n@@ -2666,1 +2677,1 @@\n-        if (!freq_op->is_valid()) {\n+        if (!freq_opr->is_valid()) {\n@@ -2674,4 +2685,0 @@\n-          Register result =\n-            dest->type() == T_INT ? dest->as_register() :\n-            dest->type() == T_LONG ? dest->as_register_lo() :\n-            noreg;\n@@ -2681,2 +2688,2 @@\n-            __ mov(temp, InvocationCounter::count_increment * ProfileCaptureRatio);\n-            __ csel(result, result, temp, __ NE);\n+            __ mov(rscratch1, InvocationCounter::count_increment * ProfileCaptureRatio);\n+            __ csel(dest, dest, rscratch1, __ NE);\n@@ -2684,2 +2691,2 @@\n-          juint mask = freq_op->as_jint();\n-          __ andw(rscratch1, result,  mask);\n+          juint mask = freq_opr->as_jint();\n+          __ andw(rscratch1, dest,  mask);\n@@ -2703,1 +2710,1 @@\n-    __ step_random(r_profile_rng, temp);\n+    __ step_random(r_profile_rng, rscratch2);\n@@ -2728,0 +2735,5 @@\n+#ifndef PRODUCT\n+  if (CommentedAssembly) {\n+    __ block_comment(\"profile_call {\");\n+  }\n+#endif\n@@ -2842,0 +2854,6 @@\n+\n+#ifndef PRODUCT\n+  if (CommentedAssembly) {\n+    __ block_comment(\"} profile_call\");\n+  }\n+#endif\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":47,"deletions":29,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -98,1 +98,2 @@\n-    return range;\n+    int result = range - (ProfileCaptureRatio > 1);\n+    return align_down(result, 2);  \/\/ ouch\n","filename":"src\/hotspot\/cpu\/arm\/c1_FrameMap_arm.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2461,0 +2461,133 @@\n+void LIR_Assembler::increment_profile_ctr(LIR_Opr step, LIR_Opr dest_opr,\n+                                          LIR_Opr freq_opr,\n+                                          LIR_Opr md_reg, LIR_Opr md_opr, LIR_Opr md_offset_opr,\n+                                          CodeStub* overflow_stub) {\n+#ifndef PRODUCT\n+  if (CommentedAssembly) {\n+    __ block_comment(\"increment_event_counter {\");\n+  }\n+#endif\n+\n+  int profile_capture_ratio = ProfileCaptureRatio;\n+  int ratio_shift = exact_log2(profile_capture_ratio);\n+  uint64_t threshold = (UCONST64(1) << 32) >> ratio_shift;\n+\n+  assert(threshold > 0, \"must be\");\n+\n+  ProfileStub *counter_stub\n+    = profile_capture_ratio > 1 ? new ProfileStub() : nullptr;\n+\n+  Register dest = dest_opr->as_register();\n+\n+  auto lambda = [counter_stub, overflow_stub, freq_opr, dest_opr, dest, ratio_shift, step,\n+                 md_reg, md_opr, md_offset_opr] (LIR_Assembler* ce, LIR_Op* op) {\n+\n+#undef __\n+#define __ masm->\n+\n+    auto masm = ce->masm();\n+    Address counter_address;\n+\n+    if (counter_stub != nullptr)  __ bind(*counter_stub->entry());\n+\n+    if (md_opr->is_valid()) {\n+      if (md_opr->type() == T_METADATA) {\n+        __ mov_metadata(md_reg->as_register(),\n+\t\t\tmd_opr->as_constant_ptr()->as_metadata());\n+      } else {\n+        __ lea(md_reg->as_pointer_register(),\n+               ExternalAddress(md_opr->as_constant_ptr()->as_pointer()));\n+      }\n+      RegisterOrConstant offset =\n+        md_offset_opr->is_constant()\n+        ? RegisterOrConstant(md_offset_opr->as_constant_ptr()->as_jint())\n+        : md_offset_opr->as_register();\n+      counter_address = Address(md_reg->as_pointer_register(), offset);\n+    }\n+    if (step->is_register()) {\n+      Address dest_adr = counter_address;\n+      Register inc = step->as_register();\n+      if (ProfileCaptureRatio > 1) {\n+\t__ mov(inc, AsmOperand(inc, lsl, ratio_shift));\n+      }\n+      __ increment_mdp_data_at(dest_adr, dest, 1);\n+      if (ProfileCaptureRatio > 1) {\n+\t__ mov(inc, AsmOperand(inc, lsr, ratio_shift));\n+      }\n+    } else {\n+      jint inc = step->as_constant_ptr()->as_jint_bits();\n+      switch (dest_opr->type()) {\n+        case T_INT: {\n+          Address dest_adr = counter_address;\n+          inc *= ProfileCaptureRatio;\n+\t  __ increment_mdp_data_at(dest_adr, dest, 1);\n+\n+          break;\n+        }\n+        \/\/ case T_LONG: {\n+        \/\/   Address dest_adr = counter_address;\n+        \/\/   inc *= ProfileCaptureRatio;\n+        \/\/   __ increment(dest_adr, inc, dest);\n+\n+        \/\/   break;\n+        \/\/ }\n+        default:\n+          ShouldNotReachHere();\n+      }\n+\n+      if (step->is_valid() && overflow_stub) {\n+        if (!freq_opr->is_valid()) {\n+          if (!step->is_constant()) {\n+            __ cbz(step->as_register(), *overflow_stub->entry());\n+          } else {\n+            __ b(*overflow_stub->entry());\n+            return;\n+          }\n+        } else {\n+          if (!step->is_constant()) {\n+            \/\/ If step is 0, make sure the stub check below always fails\n+            __ cmp(step->as_register(), (u1)0);\n+            __ mov(Rtemp, InvocationCounter::count_increment * ProfileCaptureRatio);\n+            __ mov(dest, Rtemp, eq);\n+          }\n+          juint mask = freq_opr->as_jint();\n+\t  __ mov_slow(Rtemp, mask);\n+          __ tst(dest, Rtemp);\n+          __ b(*overflow_stub->entry(), eq);\n+        }\n+      }\n+    }\n+\n+    if (counter_stub != nullptr) {\n+      __ b(*counter_stub->continuation());\n+    }\n+\n+#undef __\n+#define __ _masm->\n+  };\n+\n+  if (counter_stub != nullptr) {\n+    __ mov(Rtemp, AsmOperand(r_profile_rng, lsr, 32 - ratio_shift));\n+    __ cmp(Rtemp, 0);\n+    __ b(*counter_stub->entry(), eq);\n+    __ bind(*counter_stub->continuation());\n+    __ step_random(r_profile_rng, Rtemp);\n+\n+    counter_stub->set_action(lambda, nullptr);\n+    counter_stub->set_name(\"IncrementEventCounter\");\n+    append_code_stub(counter_stub);\n+  } else {\n+    lambda(this, nullptr);\n+  }\n+\n+  if (overflow_stub != nullptr) {\n+    __ bind(*overflow_stub->continuation());\n+  }\n+\n+#ifndef PRODUCT\n+  if (CommentedAssembly) {\n+    __ block_comment(\"} increment_event_counter\");\n+  }\n+#endif\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":133,"deletions":0,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -740,0 +740,24 @@\n+\n+void LIRGenerator::arm_cas_long(LIR_Opr addr, LIRItem& cmp_value, LIRItem& new_value, LIR_Opr &result) {\n+  address func = StubRoutines::Arm::atomic_compareAndSet_long_entry();\n+\n+  BasicTypeList signature;\n+  signature.append(T_LONG);\n+  signature.append(T_LONG);\n+  signature.append(T_ADDRESS);\n+\n+  CallingConvention* cc = frame_map()->c_calling_convention(&signature);\n+  cmp_value.load_item_force(cc->at(0));\n+  new_value.load_item_force(cc->at(1));\n+  __ move(addr->as_address_ptr()->base(), cc->at(2));\n+  assert(addr->as_address_ptr()->disp() == 0, \"must be\");\n+\n+  LIR_OprList *args = new LIR_OprList(3);\n+  args->append(cmp_value.result());\n+  args->append(new_value.result());\n+  args->append(cc->at(2));\n+\n+  __ call_runtime_leaf(func, LIR_OprFact::illegalOpr, FrameMap::Int_result_opr, args);\n+  __ move(FrameMap::Int_result_opr, result);\n+}\n+\n@@ -741,1 +765,0 @@\n-  LIR_Opr ill = LIR_OprFact::illegalOpr;  \/\/ for convenience\n@@ -752,2 +775,8 @@\n-    tmp1 = new_register(T_LONG);\n-    __ cas_long(addr->as_address_ptr()->base(), cmp_value.result(), new_value.result(), tmp1, tmp2, result);\n+    if (ProfileCaptureRatio > 1) {\n+      \/\/ Call out to runtime because we don't have enough registers to\n+      \/\/ expand compareAndSet(long) inline.\n+      arm_cas_long(addr, cmp_value, new_value, result);\n+    } else {\n+      tmp1 = new_register(T_LONG);\n+      __ cas_long(addr->as_address_ptr()->base(), cmp_value.result(), new_value.result(), tmp1, tmp2, result);\n+    }\n@@ -1278,0 +1307,5 @@\n+  \/\/ If we're subsampling counter updates, then profiling code kills flags\n+  \/\/ if (ProfileCaptureRatio != 1)\n+    {\n+    __ cmp(lir_cond(cond), left, right);\n+  }\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRGenerator_arm.cpp","additions":37,"deletions":3,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+  void arm_cas_long(LIR_Opr addr, LIRItem& cmp_value, LIRItem& new_value, LIR_Opr &result);\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRGenerator_arm.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -225,0 +225,57 @@\n+\/\/ Increments mdp data. Sets bumped_count register to adjusted counter.\n+void C1_MacroAssembler::increment_mdp_data_at(Address data,\n+\t\t\t\t\t      Register bumped_count,\n+\t\t\t\t\t      int increment) {\n+  assert(ProfileInterpreter, \"must be profiling interpreter\");\n+  assert_different_registers(data.base(), Rtemp);\n+  assert(data.mode() == basic_offset, \"must be\");\n+\n+  int offset = data.disp();\n+  bool is_memoryI =  offset < 4096 && offset > -4096;\n+\n+  if (!is_memoryI) {\n+    block_comment(\"Move slow\");\n+    mov_slow(Rtemp, offset);\n+    data = Address(data.base(), Rtemp);\n+  }\n+  ldr(bumped_count, data);\n+  if (increment < 0) {\n+    sub(bumped_count, bumped_count, -increment);\n+  } else {\n+    add(bumped_count, bumped_count, increment);\n+  }\n+  str(bumped_count, data);\n+}\n+\n+\/\/ Randomized profile capture.\n+\n+void C1_MacroAssembler::step_random(Register state, Register temp, Register data) {\n+  \/\/ if (VM_Version::supports_crc32()) {\n+  \/\/   \/* CRC used as a psuedo-random-number generator *\/\n+  \/\/   \/\/ In effect, the CRC instruction is being used here for its\n+  \/\/   \/\/ linear feedback shift register. It's unbeatably fast, and\n+  \/\/   \/\/ plenty good enough for what we need.\n+  \/\/   crc32h(state, state, data);\n+  \/\/ } else\n+    {\n+    \/* LCG from glibc. *\/\n+    mov_slow(temp, 1103515245);\n+    mul(state, state, temp);\n+    \/\/ add(state, state, 12345);\n+    add(state, state, 251);\n+  }\n+}\n+\n+void C1_MacroAssembler::save_profile_rng() {\n+  if (ProfileCaptureRatio != 1) {\n+    str(r_profile_rng, Address(Rthread, JavaThread::profile_rng_offset()));\n+  }\n+}\n+\n+void C1_MacroAssembler::restore_profile_rng() {\n+  if (ProfileCaptureRatio != 1) {\n+    ldr(r_profile_rng, Address(Rthread, JavaThread::profile_rng_offset()));\n+  }\n+}\n+\n+\n","filename":"src\/hotspot\/cpu\/arm\/c1_MacroAssembler_arm.cpp","additions":57,"deletions":0,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -66,0 +66,9 @@\n+  \/\/ Randomized profile capture\n+  void step_random(Register state, Register temp, Register data = Rtemp);\n+  void save_profile_rng();\n+  void restore_profile_rng();\n+\n+  void increment_mdp_data_at(Address data,\n+\t\t\t     Register bumped_count,\n+\t\t\t     int increment);\n+\n","filename":"src\/hotspot\/cpu\/arm\/c1_MacroAssembler_arm.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -727,1 +727,0 @@\n-#ifdef __SOFTFP__\n@@ -730,0 +729,1 @@\n+#ifdef __SOFTFP__\n@@ -782,1 +782,3 @@\n-const char *Runtime1::pd_name_for_address(address entry) {\n+if (entry == StubRoutines::Arm::atomic_compareAndSet_long_entry()) {\n+    return \"StubRoutines::atomic_compareAndSet_long\";\n+  }\n@@ -784,1 +786,0 @@\n-}\n@@ -786,0 +787,1 @@\n+}\n","filename":"src\/hotspot\/cpu\/arm\/c1_Runtime1_arm.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,0 +31,3 @@\n+\/\/ State for randomized profile counters. Used by C1.\n+constexpr Register r_profile_rng = R9;\n+\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -66,0 +66,3 @@\n+  do_stub(compiler, atomic_compareAndSet_long)                          \\\n+  do_arch_entry(Arm, compiler, atomic_compareAndSet_long,               \\\n+                atomic_compareAndSet_long_entry, atomic_compareAndSet_long_entry)\n","filename":"src\/hotspot\/cpu\/arm\/stubDeclarations_arm.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -623,0 +623,1 @@\n+\n@@ -639,0 +640,54 @@\n+  \/\/ Support for jboolean jdk.internal.misc.Unsafe::compareAndSetLong\n+  \/\/ (jobject o, jlong offset, jlong compare_value, jlong exchange_value)\n+  \/\/ reordered before by a wrapper to\n+  \/\/ (jlong compare_value, jlong exchange_value, volatile jlong *dest)\n+  \/\/\n+  \/\/ Arguments :\n+  \/\/\n+  \/\/      compare_value:  R1 (High), R0 (Low)\n+  \/\/      exchange_value: R3 (High), R2 (Low)\n+  \/\/      dest:           SP+0\n+  \/\/\n+  \/\/ Results:\n+  \/\/\n+  \/\/      R0:     true if successful, otherwise false if the memory value\n+  \/\/              was not the same as the compare value.\n+  \/\/\n+  \/\/ Overwrites:\n+  \/\/\n+  address generate_atomic_compareAndSet_long() {\n+    address start;\n+\n+    StubId stub_id = StubId::stubgen_atomic_compareAndSet_long_id;\n+    StubCodeMark mark(this, stub_id);\n+    start = __ pc();\n+    Register cmp_lo      = R0;\n+    Register cmp_hi      = R1;\n+    Register newval_lo   = R2;\n+    Register newval_hi   = R3;\n+    Register addr        = Rtemp;  \/* After load from stack *\/\n+    Register temp_lo     = R4;\n+    Register temp_hi     = R5;\n+    Register temp_result = R8;\n+    assert_different_registers(cmp_lo, newval_lo, temp_lo, addr, temp_result, R7);\n+    assert_different_registers(cmp_hi, newval_hi, temp_hi, addr, temp_result, R7);\n+\n+    __ membar(MEMBAR_ATOMIC_OP_PRE, Rtemp); \/\/ Rtemp free (native ABI)\n+\n+    __ push(RegisterSet(temp_result) | RegisterSet(temp_lo, temp_hi));\n+    __ ldr(addr, Address(SP, 12));\n+\n+    \/\/ atomic_cas64 returns previous value in temp_lo, temp_hi\n+    \/\/ status in temp_result\n+    __ atomic_cas64(temp_lo, temp_hi, temp_result, cmp_lo, cmp_hi,\n+                    newval_lo, newval_hi, addr, 0);\n+    __ mov(R0, temp_result);\n+\n+    __ pop(RegisterSet(temp_result) | RegisterSet(temp_lo, temp_hi));\n+\n+    __ membar(MEMBAR_ATOMIC_OP_POST, Rtemp); \/\/ Rtemp free (native ABI)\n+    __ bx(LR);\n+\n+    return start;\n+  }\n+\n@@ -3195,0 +3250,1 @@\n+    StubRoutines::Arm::_atomic_compareAndSet_long_entry = generate_atomic_compareAndSet_long();\n@@ -3198,1 +3254,1 @@\n-    StubRoutines::Arm::_partial_subtype_check                = generate_partial_subtype_check();\n+    StubRoutines::Arm::_partial_subtype_check           = generate_partial_subtype_check();\n","filename":"src\/hotspot\/cpu\/arm\/stubGenerator_arm.cpp","additions":57,"deletions":1,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -204,0 +204,4 @@\n+static Register as_reg(LIR_Opr op) {\n+  return op->is_double_cpu() ? op->as_register_lo() : op->as_register();\n+}\n+\n@@ -2855,2 +2859,4 @@\n-void LIR_Assembler::increment_profile_ctr(LIR_Opr incr, LIR_Opr addr, LIR_Opr dest, LIR_Opr temp_op,\n-                                          LIR_Opr freq_op, CodeStub* overflow_stub) {\n+void LIR_Assembler::increment_profile_ctr(LIR_Opr step_opr, LIR_Opr dest_opr,\n+                                          LIR_Opr freq_opr,\n+                                          LIR_Opr md_reg, LIR_Opr md_opr, LIR_Opr md_offset_opr,\n+                                          CodeStub* overflow_stub) {\n@@ -2888,0 +2894,17 @@\n+      if (md_opr->type() == T_METADATA) {\n+        __ mov_metadata(md_reg->as_register(),\n+                          md_opr->as_constant_ptr()->as_metadata());\n+      } else {\n+        __ lea(md_reg->as_pointer_register(),\n+                  ExternalAddress(md_opr->as_constant_ptr()->as_pointer()));\n+      }\n+      RegisterOrConstant offset =\n+        md_offset_opr->is_constant()\n+        ? RegisterOrConstant(md_offset_opr->as_constant_ptr()->as_jint())\n+        : as_reg(md_offset_opr);\n+      counter_address = Address(md_reg->as_pointer_register(), offset);\n+    }\n+\n+    if (step_opr->is_register()) {\n+      Register inc = step_opr->as_register();\n+      __ movl(dest, counter_address);\n@@ -2891,3 +2914,2 @@\n-      __ lea(temp, Address(temp, inc, Address::times_1));\n-      __ movl(dest_adr, temp);\n-      __ movl(dest->as_register(), temp);\n+      __ lea(dest, Address(dest, inc, Address::times_1));\n+      __ movl(counter_address, dest);\n@@ -2898,2 +2920,2 @@\n-      jint inc = incr->as_constant_ptr()->as_jint_bits();\n-      switch (dest->type()) {\n+      jint inc = step_opr->as_constant_ptr()->as_jint_bits();\n+      switch (dest_opr->type()) {\n@@ -2902,1 +2924,1 @@\n-          __ movl(temp, dest_adr);\n+          __ movl(dest, counter_address);\n@@ -2904,5 +2926,2 @@\n-          __ lea(temp, Address(temp, inc, Address::times_1));\n-          __ movl(dest_adr, temp);\n-          if (dest->is_register()) {\n-            __ movl(dest->as_register(), temp);\n-          }\n+          __ lea(dest, Address(dest, inc, Address::times_1));\n+          __ movl(counter_address, dest);\n@@ -2913,1 +2932,1 @@\n-          __ movq(temp, dest_adr);\n+          __ movq(dest, counter_address);\n@@ -2915,6 +2934,2 @@\n-          __ lea(temp, Address(temp, inc, Address::times_1));\n-          __ movq(dest_adr, temp);\n-          if (dest->is_register()) {\n-            __ movq(dest->as_register_lo(), temp);\n-          }\n-\n+          __ lea(dest, Address(dest, inc, Address::times_1));\n+          __ movq(counter_address, dest);\n@@ -2927,4 +2942,4 @@\n-      if (incr->is_valid() && overflow_stub) {\n-        if (!freq_op->is_valid()) {\n-          if (!incr->is_constant()) {\n-            __ cmpl(incr->as_register(), 0);\n+      if (step_opr->is_valid() && overflow_stub) {\n+        if (!freq_opr->is_valid()) {\n+          if (!step_opr->is_constant()) {\n+            __ cmpl(step_opr->as_register(), 0);\n@@ -2937,9 +2952,6 @@\n-          Register result =\n-            dest->type() == T_INT ? dest->as_register() :\n-            dest->type() == T_LONG ? dest->as_register_lo() :\n-            noreg;\n-          if (!incr->is_constant()) {\n-            \/\/ If step is 0, make sure the stub check below always fails\n-            __ cmpl(incr->as_register(), 0);\n-            __ movl(temp, InvocationCounter::count_increment * ProfileCaptureRatio);\n-            __ cmovl(Assembler::notEqual, result, temp);\n+          if (!step_opr->is_constant()) {\n+            guarantee(dest != step_opr->as_register(), \"must be\");\n+            \/\/ If step_opr is 0, make sure the stub check below always fails\n+            __ cmpl(step_opr->as_register(), 0);\n+            __ movl(step_opr->as_register(), InvocationCounter::count_increment * ProfileCaptureRatio);\n+            __ cmovl(Assembler::notEqual, dest, step_opr->as_register());\n@@ -2947,1 +2959,1 @@\n-          __ andl(result, freq_op->as_jint());\n+          __ andl(dest, freq_opr->as_jint());\n@@ -2967,1 +2979,1 @@\n-    __ step_random(r_profile_rng, temp);\n+    __ step_random(r_profile_rng, dest);\n@@ -2989,0 +3001,5 @@\n+#ifndef PRODUCT\n+  if (CommentedAssembly) {\n+    __ block_comment(\"profile_call {\");\n+  }\n+#endif\n@@ -3098,0 +3115,6 @@\n+\n+#ifndef PRODUCT\n+  if (CommentedAssembly) {\n+    __ block_comment(\"} profile_call\");\n+  }\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":58,"deletions":35,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -293,1 +293,1 @@\n-    movl(temp, 1);\n+    movl(temp, 0);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -903,1 +903,0 @@\n-      do_input(opr->_counter_addr);        do_temp(opr->_counter_addr);\n@@ -905,2 +904,3 @@\n-      if (opr->_dest->is_valid())          { do_output(opr->_dest); }\n-      if (opr->_temp_op->is_valid())       do_temp(opr->_temp_op);\n+      if (opr->_result->is_valid()) {\n+        do_temp(opr->_result);             do_output(opr->_result);\n+      }\n@@ -908,1 +908,5 @@\n-\n+      if (opr->_md_reg->is_valid())        do_temp(opr->_md_reg);\n+      if (opr->_md_op->is_valid())         { do_input(opr->_md_op); }\n+      if (opr->_md_offset_op->is_valid()) {\n+        do_input(opr->_md_offset_op);      do_temp(opr->_md_offset_op);\n+      }\n@@ -1076,1 +1080,2 @@\n-    (_step, _counter_addr, _dest, _temp_op, _freq_op, _overflow_stub);\n+    (_step, _result, _freq_op,\n+     _md_reg, _md_op, _md_offset_op, _overflow_stub);\n@@ -1287,2 +1292,4 @@\n-void LIR_List::increment_counter(LIR_Opr step, LIR_Address* addr, LIR_Opr dest, LIR_Opr tmp,\n-                                 LIR_Opr freq, CodeStub* overflow, CodeEmitInfo* info) {\n+void LIR_List::increment_counter(LIR_Opr step, LIR_Opr dest,\n+                                 LIR_Opr freq,\n+                                 LIR_Opr md_reg, LIR_Opr md_op, LIR_Opr md_offset_op,\n+                                 CodeStub* overflow, CodeEmitInfo* info) {\n@@ -1291,1 +1298,0 @@\n-            LIR_OprFact::address(addr),\n@@ -1293,1 +1299,0 @@\n-            tmp,\n@@ -1295,0 +1300,3 @@\n+            md_reg,\n+            md_op,\n+            md_offset_op,\n@@ -1843,1 +1851,1 @@\n-\n+  result_opr()->print(out); out->print(\" \");\n@@ -1884,0 +1892,9 @@\n+  int n = _arguments->length();\n+  for (int i = 0; i < n; i++) {\n+    _arguments->at(i)->print(out);\n+    out->print(\" \");\n+  }\n+  if (_result->is_valid()) {\n+    _result->print(out);\n+    out->print(\" \");\n+  }\n@@ -2089,1 +2106,0 @@\n-  counter_addr()->print(out);  out->print(\" \");\n@@ -2091,1 +2107,1 @@\n-  temp_op()->print(out);       out->print(\" \");\n+  \/\/ temp_op()->print(out);       out->print(\" \");\n@@ -2093,0 +2109,3 @@\n+  md_reg()->print(out);        out->print(\" \");\n+  md_op()->print(out);         out->print(\" \");\n+  md_offset_op()->print(out);  out->print(\" \");\n@@ -2094,0 +2113,1 @@\n+\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":32,"deletions":12,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -449,1 +449,1 @@\n-  Register as_pointer_register() {\n+  Register as_pointer_register() const {\n@@ -1942,3 +1942,0 @@\n-  LIR_Opr _counter_addr;\n-  LIR_Opr _dest;\n-  LIR_Opr _temp_op;\n@@ -1946,0 +1943,3 @@\n+  LIR_Opr _md_reg;\n+  LIR_Opr _md_op;\n+  LIR_Opr _md_offset_op;\n@@ -1950,3 +1950,4 @@\n-  LIR_OpIncrementCounter(LIR_Opr step, LIR_Opr counter_addr, LIR_Opr dest, LIR_Opr temp_op,\n-                         LIR_Opr freq_op, CodeStub* overflow_stub, CodeEmitInfo *info)\n-    : LIR_Op(lir_increment_counter, LIR_OprFact::illegalOpr, info)\n+  LIR_OpIncrementCounter(LIR_Opr step, LIR_Opr dest,\n+                         LIR_Opr freq_op, LIR_Opr md_reg, LIR_Opr md_op, LIR_Opr md_offset_op,\n+                         CodeStub* overflow_stub, CodeEmitInfo *info)\n+    : LIR_Op(lir_increment_counter, dest, info)\n@@ -1954,3 +1955,0 @@\n-    , _counter_addr(counter_addr)\n-    , _dest(dest)\n-    , _temp_op(temp_op)\n@@ -1958,0 +1956,3 @@\n+    , _md_reg(md_reg)\n+    , _md_op(md_op)\n+    , _md_offset_op(md_offset_op)\n@@ -1961,3 +1962,1 @@\n-  LIR_Opr   counter_addr()  const            { return _counter_addr;  }\n-  LIR_Opr   dest()          const            { return _dest;          }\n-  LIR_Opr   temp_op()       const            { return _temp_op;       }\n+  LIR_Opr   dest()          const            { return result_opr();   }\n@@ -1965,0 +1964,4 @@\n+  LIR_Opr   md_reg()        const            { return _md_reg;        }\n+  LIR_Opr   md_op()         const            { return _md_op;         }\n+  LIR_Opr   md_offset_op()  const            { return _md_offset_op;  }\n+\n@@ -2274,3 +2277,24 @@\n-  void increment_counter(LIR_Opr src, LIR_Address* addr, LIR_Opr res, LIR_Opr tmp, LIR_Opr freq, CodeStub* overflow, CodeEmitInfo* info);\n-  void increment_counter(LIR_Opr src, LIR_Address* addr, LIR_Opr res, LIR_Opr tmp, CodeStub* overflow = nullptr) {\n-    increment_counter(src, addr, res, tmp, LIR_OprFact::illegalOpr, overflow, nullptr);\n+  void increment_counter(LIR_Opr src, LIR_Opr res,\n+                         LIR_Opr freq, LIR_Opr md_reg, LIR_Opr md_op, LIR_Opr md_offset,\n+                         CodeStub* overflow, CodeEmitInfo* info);\n+\n+  void increment_counter(LIR_Opr step, LIR_Opr dummy,\n+                         LIR_Opr md_reg, Metadata* md, LIR_Opr offset) {\n+    increment_counter(step, dummy,\n+                      \/*freq*\/LIR_OprFact::illegalOpr,\n+                      md_reg, LIR_OprFact::metadataConst(md),\n+                      offset,\n+                      \/*overflow*\/nullptr, \/*info*\/nullptr);\n+  }\n+  void increment_counter(LIR_Opr step, LIR_Opr dummy,\n+                         LIR_Opr md_reg, Metadata* md, int offset) {\n+    increment_counter(step, dummy, md_reg, md,\n+                      LIR_OprFact::intConst(offset));\n+  }\n+  void increment_counter(LIR_Opr step, LIR_Opr result, LIR_Opr freq,\n+                         LIR_Opr md_reg, LIR_Opr md, int offset,\n+                         CodeStub* overflow, CodeEmitInfo* info) {\n+    increment_counter(step, result,\n+                      freq,\n+                      md_reg, md, LIR_OprFact::intConst(offset),\n+                      overflow, info);\n@@ -2278,1 +2302,0 @@\n-\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":40,"deletions":17,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -238,1 +238,1 @@\n-  void increment_profile_ctr(LIR_Opr incr, LIR_Opr addr, LIR_Opr dest, LIR_Opr temp,\n+  void increment_profile_ctr(LIR_Opr incr, LIR_Opr dest,\n@@ -240,0 +240,1 @@\n+                             LIR_Opr md_reg, LIR_Opr md_op, LIR_Opr md_offset_op,\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -919,1 +919,0 @@\n-    __ metadata2reg(md->constant_encoding(), md_reg);\n@@ -929,1 +928,0 @@\n-    LIR_Address* data_addr = new LIR_Address(md_reg, data_offset_reg, data_reg->type());\n@@ -932,1 +930,2 @@\n-    __ increment_counter(step, data_addr, LIR_OprFact::intConst(0), tmp, nullptr);\n+    LIR_Opr dummy = LIR_OprFact::intConst(0);\n+    __ increment_counter(step, tmp, md_reg, md->constant_encoding(), data_offset_reg);\n@@ -2372,4 +2371,0 @@\n-    __ metadata2reg(md->constant_encoding(), md_reg);\n-\n-    LIR_Address *counter_addr = new LIR_Address(md_reg, offset,\n-                                           NOT_LP64(T_INT) LP64_ONLY(T_LONG));\n@@ -2377,1 +2372,1 @@\n-    LIR_Opr dummy = LIR_OprFact::intConst(0);\n+    LIR_Opr dummy = LIR_OprFact::intptrConst((intptr_t)0);\n@@ -2379,1 +2374,1 @@\n-    __ increment_counter(inc, counter_addr, dummy, tmp, nullptr);\n+    __ increment_counter(inc, tmp, md_reg, md->constant_encoding(), offset);\n@@ -3156,0 +3151,1 @@\n+  LIR_Opr counters_base;\n@@ -3163,1 +3159,0 @@\n-    __ move(LIR_OprFact::intptrConst(counters_adr), counter_holder);\n@@ -3166,0 +3161,1 @@\n+    counters_base = LIR_OprFact::intptrConst(counters_adr);\n@@ -3170,3 +3166,3 @@\n-    ciMethodData* md = method->method_data_or_null();\n-    assert(md != nullptr, \"Sanity\");\n-    __ metadata2reg(md->constant_encoding(), counter_holder);\n+    counters_base = LIR_OprFact::metadataConst\n+                     (method ->method_data_or_null()\n+                      ->constant_encoding());\n@@ -3176,1 +3172,0 @@\n-  LIR_Address* counter = new LIR_Address(counter_holder, offset, T_INT);\n@@ -3190,2 +3185,4 @@\n-    __ increment_counter(step, counter, result, tmp,\n-                         LIR_OprFact::intConst(freq), overflow, info);\n+    __ increment_counter(step, result,\n+                         LIR_OprFact::intConst(freq),\n+                         counter_holder, counters_base, offset,\n+                         overflow, info);\n@@ -3193,2 +3190,4 @@\n-    __ increment_counter(step, counter, result, tmp,\n-                             LIR_OprFact::illegalOpr, nullptr, info);\n+    __ increment_counter(step, result,\n+                         \/*freq*\/LIR_OprFact::illegalOpr,\n+                         counter_holder, counters_base, offset,\n+                         \/*overflow*\/nullptr, info);\n@@ -3344,1 +3343,0 @@\n-\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":17,"deletions":19,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -282,0 +282,2 @@\n+  LIR_Opr call_runtime(LIR_Opr arg1, LIR_Opr arg2, LIR_Opr arg3, LIR_Opr result,\n+                       address entry, ValueType* result_type, CodeEmitInfo* info);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+#undef arm\n@@ -166,1 +167,1 @@\n-      (*event_callback)(event_stream, \"insn\", (void*) insn[j].address);\n+      (*event_callback)(event_stream, \"insn\", (void*)(uintptr_t) insn[j].address);\n@@ -168,1 +169,1 @@\n-      (*event_callback)(event_stream, \"\/insn\", (void*) (insn[j].address + insn[j].size));\n+      (*event_callback)(event_stream, \"\/insn\", (void*)(uintptr_t) (insn[j].address + insn[j].size));\n","filename":"src\/utils\/hsdis\/capstone\/hsdis-capstone.c","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}