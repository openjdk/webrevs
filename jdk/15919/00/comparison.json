{"files":[{"patch":"@@ -111,6 +111,0 @@\n-\n-  # Because RISC-V only has word-sized atomics, it requires libatomic where\n-  # other common architectures do not, so link libatomic by default.\n-  if test \"x$OPENJDK_$1_OS\" = xlinux && test \"x$OPENJDK_$1_CPU\" = xriscv64; then\n-    BASIC_JVM_LIBS_$1=\"$BASIC_JVM_LIBS_$1 -latomic\"\n-  fi\n","filename":"make\/autoconf\/libraries.m4","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,0 +36,6 @@\n+#if defined(__clang_major__)\n+#define FULL_COMPILER_ATOMIC_SUPPORT\n+#elif (__GNUC__ > 13) || ((__GNUC__ == 13) && (__GNUC_MINOR__ >= 2))\n+#define FULL_COMPILER_ATOMIC_SUPPORT\n+#endif\n+\n@@ -40,0 +46,7 @@\n+\n+#ifndef FULL_COMPILER_ATOMIC_SUPPORT\n+    \/\/ If we add add and fetch for sub word and are using older compiler\n+    \/\/ it must be added here due to not using lib atomic.\n+    STATIC_ASSERT(byte_size >= 4);\n+#endif\n+\n@@ -58,0 +71,46 @@\n+#ifndef FULL_COMPILER_ATOMIC_SUPPORT\n+template<>\n+template<typename T>\n+inline T Atomic::PlatformCmpxchg<1>::operator()(T volatile* dest __attribute__((unused)),\n+                                                T compare_value,\n+                                                T exchange_value,\n+                                                atomic_memory_order order) const {\n+  STATIC_ASSERT(1 == sizeof(T));\n+\n+  if (order != memory_order_relaxed) {\n+    FULL_MEM_BARRIER;\n+  }\n+\n+  uint32_t volatile* aligned_dst = (uint32_t volatile*)(((uintptr_t)dest) & (~((uintptr_t)0x3)));\n+  int shift = 8 * (((uintptr_t)dest) - ((uintptr_t)aligned_dst)); \/\/ 0, 8, 16, 24\n+\n+  uint64_t mask = 0xfful << shift; \/\/ 0x00000000..FF..\n+  uint64_t remask = ~mask;         \/\/ 0xFFFFFFFF..00..\n+\n+  uint64_t w_cv = ((uint64_t)(unsigned char)compare_value) << shift;  \/\/ widen to 64-bit 0x00000000..CC..\n+  uint64_t w_ev = ((uint64_t)(unsigned char)exchange_value) << shift; \/\/ widen to 64-bit 0x00000000..EE..\n+\n+  uint64_t old_value;\n+  uint64_t rc_temp;\n+\n+  __asm__ __volatile__ (\n+    \"1:  lr.w      %0, %2      \\n\\t\"\n+    \"    and       %1, %0, %5  \\n\\t\" \/\/ ignore unrelated bytes and widen to 64-bit 0x00000000..XX..\n+    \"    bne       %1, %3, 2f  \\n\\t\" \/\/ compare 64-bit w_cv\n+    \"    and       %1, %0, %6  \\n\\t\" \/\/ remove old byte\n+    \"    or        %1, %1, %4  \\n\\t\" \/\/ add new byte\n+    \"    sc.w      %1, %1, %2  \\n\\t\" \/\/ store new word\n+    \"    bnez      %1, 1b      \\n\\t\"\n+    \"2:                        \\n\\t\"\n+    : \/*%0*\/\"=&r\" (old_value), \/*%1*\/\"=&r\" (rc_temp), \/*%2*\/\"+A\" (*aligned_dst)\n+    : \/*%3*\/\"r\" (w_cv), \/*%4*\/\"r\" (w_ev), \/*%5*\/\"r\" (mask), \/*%6*\/\"r\" (remask)\n+    : \"memory\" );\n+\n+  if (order != memory_order_relaxed) {\n+    FULL_MEM_BARRIER;\n+  }\n+\n+  return (T)((old_value & mask) >> shift);\n+}\n+#endif\n+\n@@ -63,0 +122,6 @@\n+#ifndef FULL_COMPILER_ATOMIC_SUPPORT\n+  \/\/ If we add xchg for sub word and are using older compiler\n+  \/\/ it must be added here due to not using lib atomic.\n+  STATIC_ASSERT(byte_size >= 4);\n+#endif\n+\n@@ -64,0 +129,1 @@\n+\n@@ -83,0 +149,5 @@\n+\n+#ifndef FULL_COMPILER_ATOMIC_SUPPORT\n+  STATIC_ASSERT(byte_size >= 4);\n+#endif\n+\n@@ -151,0 +222,2 @@\n+#undef FULL_COMPILER_ATOMIC_SUPPORT\n+\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/atomic_linux_riscv.hpp","additions":73,"deletions":0,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -149,0 +149,45 @@\n+struct AtomicCmpxchg1ByteStressSupport {\n+  char _default_val;\n+  int  _base;\n+  char _array[7+32+7];\n+\n+  AtomicCmpxchg1ByteStressSupport() : _default_val(0xaa), _base(7), _array{} {}\n+\n+  void validate(char val, char val2, int index) {\n+    for (int i = 0; i < 7; i++) {\n+      EXPECT_EQ(_array[i], _default_val);\n+    }\n+    for (int i = 7; i < (7+32); i++) {\n+      if (i == index) {\n+        EXPECT_EQ(_array[i], val2);\n+      } else {\n+        EXPECT_EQ(_array[i], val);\n+      }\n+    }\n+    for (int i = 0; i < 7; i++) {\n+      EXPECT_EQ(_array[i], _default_val);\n+    }\n+  }\n+\n+  void test_index(int index) {\n+    char one = 1;\n+    Atomic::cmpxchg(&_array[index], _default_val, one);\n+    validate(_default_val, one, index);\n+\n+    Atomic::cmpxchg(&_array[index], one, _default_val);\n+    validate(_default_val, _default_val, index);\n+  }\n+\n+  void test() {\n+    memset(_array, _default_val, sizeof(_array));\n+    for (int i = _base; i < (_base+32); i++) {\n+      test_index(i);\n+    }\n+  }\n+};\n+\n+TEST(AtomicCmpxchg1Byte, stress) {\n+  AtomicCmpxchg1ByteStressSupport support;\n+  support.test();\n+}\n+\n","filename":"test\/hotspot\/gtest\/runtime\/test_atomic.cpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"}]}