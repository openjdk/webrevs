{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,0 @@\n-import java.util.EnumSet;\n@@ -64,1 +63,0 @@\n-import java.util.stream.Collectors;\n@@ -330,1 +328,1 @@\n-                } catch (ProviderNotFoundException | SecurityException ex) {\n+                } catch (ProviderNotFoundException ex) {\n@@ -559,1 +557,1 @@\n-        public ArchiveContainer(Path archivePath) throws IOException, ProviderNotFoundException, SecurityException {\n+        public ArchiveContainer(Path archivePath) throws IOException, ProviderNotFoundException {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/JavacFileManager.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1763,7 +1763,1 @@\n-        long mod = 0;\n-        try {\n-            mod = filename.getLastModified();\n-        } catch (SecurityException e) {\n-            throw new AssertionError(\"CRT: couldn't get source file modification date: \" + e.getMessage());\n-        }\n-        return mod;\n+        return filename.getLastModified();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-import java.util.List;\n@@ -77,1 +76,0 @@\n-                    .checkSecurityManager()\n@@ -111,13 +109,0 @@\n-    \/**\n-     * Checks if a security manager is present and throws an exception if so.\n-     * @return this object\n-     * @throws Fault if a security manager is present\n-     *\/\n-    @SuppressWarnings(\"removal\")\n-    private SourceLauncher checkSecurityManager() throws Fault {\n-        if (System.getSecurityManager() != null) {\n-            throw new Fault(Errors.SecurityManager);\n-        }\n-        return this;\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/SourceLauncher.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -170,1 +170,0 @@\n-    private SecurityException processorLoaderException;\n@@ -271,12 +270,11 @@\n-        try {\n-            if (fileManager.hasLocation(ANNOTATION_PROCESSOR_MODULE_PATH)) {\n-                try {\n-                    serviceLoader = fileManager.getServiceLoader(ANNOTATION_PROCESSOR_MODULE_PATH, Processor.class);\n-                } catch (IOException e) {\n-                    throw new Abort(e);\n-                }\n-            } else {\n-                \/\/ If processorpath is not explicitly set, use the classpath.\n-                processorClassLoader = fileManager.hasLocation(ANNOTATION_PROCESSOR_PATH)\n-                    ? fileManager.getClassLoader(ANNOTATION_PROCESSOR_PATH)\n-                    : fileManager.getClassLoader(CLASS_PATH);\n+        if (fileManager.hasLocation(ANNOTATION_PROCESSOR_MODULE_PATH)) {\n+            try {\n+                serviceLoader = fileManager.getServiceLoader(ANNOTATION_PROCESSOR_MODULE_PATH, Processor.class);\n+            } catch (IOException e) {\n+                throw new Abort(e);\n+            }\n+        } else {\n+            \/\/ If processorpath is not explicitly set, use the classpath.\n+            processorClassLoader = fileManager.hasLocation(ANNOTATION_PROCESSOR_PATH)\n+                ? fileManager.getClassLoader(ANNOTATION_PROCESSOR_PATH)\n+                : fileManager.getClassLoader(CLASS_PATH);\n@@ -284,2 +282,2 @@\n-                if (options.isSet(\"accessInternalAPI\"))\n-                    ModuleHelper.addExports(getClass().getModule(), processorClassLoader.getUnnamedModule());\n+            if (options.isSet(\"accessInternalAPI\"))\n+                ModuleHelper.addExports(getClass().getModule(), processorClassLoader.getUnnamedModule());\n@@ -287,3 +285,2 @@\n-                if (processorClassLoader != null && processorClassLoader instanceof Closeable closeable) {\n-                    compiler.closeables = compiler.closeables.prepend(closeable);\n-                }\n+            if (processorClassLoader != null && processorClassLoader instanceof Closeable closeable) {\n+                compiler.closeables = compiler.closeables.prepend(closeable);\n@@ -291,2 +288,0 @@\n-        } catch (SecurityException e) {\n-            processorLoaderException = e;\n@@ -308,20 +303,16 @@\n-            if (processorLoaderException == null) {\n-                \/*\n-                 * If the \"-processor\" option is used, search the appropriate\n-                 * path for the named class.  Otherwise, use a service\n-                 * provider mechanism to create the processor iterator.\n-                 *\n-                 * Note: if an explicit processor path is not set,\n-                 * only the class path and _not_ the module path are\n-                 * searched for processors.\n-                 *\/\n-                String processorNames = options.get(Option.PROCESSOR);\n-                if (fileManager.hasLocation(ANNOTATION_PROCESSOR_MODULE_PATH)) {\n-                    processorIterator = (processorNames == null) ?\n-                            new ServiceIterator(serviceLoader, log) :\n-                            new NameServiceIterator(serviceLoader, log, processorNames);\n-                } else if (processorNames != null) {\n-                    processorIterator = new NameProcessIterator(processorNames, processorClassLoader, log);\n-                } else {\n-                    processorIterator = new ServiceIterator(processorClassLoader, log);\n-                }\n+            \/*\n+             * If the \"-processor\" option is used, search the appropriate\n+             * path for the named class.  Otherwise, use a service\n+             * provider mechanism to create the processor iterator.\n+             *\n+             * Note: if an explicit processor path is not set,\n+             * only the class path and _not_ the module path are\n+             * searched for processors.\n+             *\/\n+            String processorNames = options.get(Option.PROCESSOR);\n+            if (fileManager.hasLocation(ANNOTATION_PROCESSOR_MODULE_PATH)) {\n+                processorIterator = (processorNames == null) ?\n+                        new ServiceIterator(serviceLoader, log) :\n+                        new NameServiceIterator(serviceLoader, log, processorNames);\n+            } else if (processorNames != null) {\n+                processorIterator = new NameProcessIterator(processorNames, processorClassLoader, log);\n@@ -329,8 +320,1 @@\n-                \/*\n-                 * A security exception will occur if we can't create a classloader.\n-                 * Ignore the exception if, with hindsight, we didn't need it anyway\n-                 * (i.e. no processor was specified either explicitly, or implicitly,\n-                 * in service configuration file.) Otherwise, we cannot continue.\n-                 *\/\n-                processorIterator = handleServiceLoaderUnavailability(\"proc.cant.create.loader\",\n-                        processorLoaderException);\n+                processorIterator = new ServiceIterator(processorClassLoader, log);\n@@ -370,3 +354,1 @@\n-     * reason, either because a service loader class cannot be found\n-     * or because a security policy prevents class loaders from being\n-     * created.\n+     * reason, for example, because a service loader class cannot be found.\n@@ -394,1 +376,1 @@\n-     * Handle a security exception thrown during initializing the\n+     * Handle a exception thrown during initializing the\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":35,"deletions":53,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -87,3 +87,0 @@\n-launcher.err.security.manager=\\\n-    cannot use source-code launcher with a security manager enabled\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/launcher.properties","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"}]}