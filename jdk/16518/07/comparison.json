{"files":[{"patch":"@@ -38,3 +38,4 @@\n- * A value layout used to model the address of some region of memory. The carrier associated with an address layout is\n- * {@code MemorySegment.class}. The size and alignment of an address layout are platform-dependent\n- * (e.g. on a 64-bit platform, the size and alignment of an address layout are set to 8 bytes).\n+ * A value layout used to model the address of some region of memory. The carrier\n+ * associated with an address layout is {@code MemorySegment.class}. The size and\n+ * alignment of an address layout are platform-dependent (e.g. on a 64-bit platform,\n+ * the size and alignment of an address layout are set to 8 bytes).\n@@ -42,4 +43,6 @@\n- * An address layout may optionally feature a {@linkplain #targetLayout() target layout}. An address layout with\n- * target layout {@code T} can be used to model the address of a region of memory whose layout is {@code T}.\n- * For instance, an address layout with target layout {@link ValueLayout#JAVA_INT} can be used to model the address\n- * of a region of memory that is 4 bytes long. Specifying a target layout can be useful in the following situations:\n+ * An address layout may optionally feature a {@linkplain #targetLayout() target layout}.\n+ * An address layout with target layout {@code T} can be used to model the address of a\n+ * region of memory whose layout is {@code T}. For instance, an address layout with\n+ * target layout {@link ValueLayout#JAVA_INT} can be used to model the address of a\n+ * region of memory that is 4 bytes long. Specifying a target layout can be useful in\n+ * the following situations:\n@@ -47,2 +50,2 @@\n- *     <li>When accessing a memory segment that has been obtained by reading an address from another\n- *     memory segment, e.g. using {@link MemorySegment#getAtIndex(AddressLayout, long)};<\/li>\n+ *     <li>When accessing a memory segment that has been obtained by reading an address from\n+ *     another memory segment, e.g. using {@link MemorySegment#getAtIndex(AddressLayout, long)};<\/li>\n@@ -54,1 +57,2 @@\n- * Implementations of this interface are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ * Implementations of this interface are immutable, thread-safe and\n+ * <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n@@ -87,5 +91,7 @@\n-     * Returns an address layout with the same carrier, alignment constraint, name and order as this address layout,\n-     * but associated with the specified target layout. The returned address layout allows raw addresses to be accessed\n-     * as {@linkplain MemorySegment memory segments} whose size is set to the size of the specified layout. Moreover,\n-     * if the accessed raw address is not compatible with the alignment constraint in the provided layout,\n-     * {@linkplain IllegalArgumentException} will be thrown.\n+     * Returns an address layout with the same carrier, alignment constraint, name and\n+     * order as this address layout, but associated with the specified target layout.\n+     * The returned address layout allows raw addresses to be accessed as\n+     * {@linkplain MemorySegment memory segments} whose size is set to the size of the\n+     * specified layout. Moreover, if the accessed raw address is not compatible with\n+     * the alignment constraint in the provided layout, {@linkplain IllegalArgumentException}\n+     * will be thrown.\n@@ -93,3 +99,3 @@\n-     * This method can also be used to create an address layout which, when used, creates native memory\n-     * segments with maximal size (e.g. {@linkplain Long#MAX_VALUE}). This can be done by using a target sequence\n-     * layout with unspecified size, as follows:\n+     * This method can also be used to create an address layout which, when used, creates\n+     * native memory segments with maximal size (e.g. {@linkplain Long#MAX_VALUE}). This\n+     * can be done by using a target sequence layout with unspecified size, as follows:\n@@ -102,3 +108,5 @@\n-     * @param layout the target layout.\n-     * @return an address layout with same characteristics as this layout, but with the provided target layout.\n-     * @throws IllegalCallerException If the caller is in a module that does not have native access enabled\n+     * @param layout the target layout\n+     * @return an address layout with same characteristics as this layout, but with the\n+     *          provided target layout\n+     * @throws IllegalCallerException If the caller is in a module that does not have\n+     *         native access enabled\n@@ -112,2 +120,2 @@\n-     * Returns an address layout with the same carrier, alignment constraint, name and order as this address layout,\n-     * but with no target layout.\n+     * Returns an address layout with the same carrier, alignment constraint, name and\n+     * order as this address layout, but with no target layout.\n@@ -115,1 +123,2 @@\n-     * @apiNote This can be useful to compare two address layouts that have different target layouts, but are otherwise equal.\n+     * @apiNote This can be useful to compare two address layouts that have different\n+     *          target layouts, but are otherwise equal.\n@@ -117,1 +126,2 @@\n-     * @return an address layout with same characteristics as this layout, but with no target layout.\n+     * @return an address layout with same characteristics as this layout, but with no\n+     *         target layout\n@@ -123,1 +133,1 @@\n-     * {@return the target layout associated with this address layout (if any)}.\n+     * {@return the target layout associated with this address layout (if any)}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/AddressLayout.java","additions":36,"deletions":26,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -34,1 +34,2 @@\n- * An arena controls the lifecycle of native memory segments, providing both flexible allocation and timely deallocation.\n+ * An arena controls the lifecycle of native memory segments, providing both flexible\n+ * allocation and timely de-allocation.\n@@ -36,3 +37,3 @@\n- * An arena has a {@linkplain MemorySegment.Scope scope} - the <em>arena scope<\/em>. All the segments allocated\n- * by the arena are associated with the arena scope. As such, the arena determines the temporal bounds\n- * of all the memory segments allocated by it.\n+ * An arena has a {@linkplain MemorySegment.Scope scope} - the <em>arena scope<\/em>.\n+ * All the segments allocated by the arena are associated with the arena scope. As such,\n+ * the arena determines the temporal bounds of all the memory segments allocated by it.\n@@ -40,4 +41,4 @@\n- * Moreover, an arena also determines whether access to memory segments allocated by it should be\n- * {@linkplain MemorySegment#isAccessibleBy(Thread) restricted} to specific threads.\n- * An arena is a {@link SegmentAllocator} and features several allocation methods that can be used by clients\n- * to obtain native segments.\n+ * Moreover, an arena also determines whether access to memory segments allocated by it\n+ * should be {@linkplain MemorySegment#isAccessibleBy(Thread) restricted} to specific\n+ * threads. An arena is a {@link SegmentAllocator} and features several allocation\n+ * methods that can be used by clients to obtain native segments.\n@@ -46,4 +47,5 @@\n- * features an <em>unbounded lifetime<\/em>. The scope of the global arena is the global scope.\n- * As such, native segments allocated with the global arena are always accessible and their backing regions\n- * of memory are never deallocated.\n- * Moreover, memory segments allocated with the global arena can be {@linkplain MemorySegment#isAccessibleBy(Thread) accessed} from any thread.\n+ * features an <em>unbounded lifetime<\/em>. The scope of the global arena is the global\n+ * scope. As such, native segments allocated with the global arena are always accessible\n+ * and their backing regions of memory are never deallocated. Moreover, memory segments\n+ * allocated with the global arena can be {@linkplain MemorySegment#isAccessibleBy(Thread) accessed}\n+ * from any thread.\n@@ -56,6 +58,7 @@\n- * Alternatively, clients can obtain an {@linkplain Arena#ofAuto() automatic arena}, that is an arena\n- * which features a <em>bounded lifetime<\/em> that is managed, automatically, by the garbage collector. The scope\n- * of an automatic arena is an automatic scope. As such, the regions\n- * of memory backing memory segments allocated with the automatic arena are deallocated at some unspecified time\n- * <em>after<\/em> the automatic arena (and all the segments allocated by it) becomes\n- * <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>, as shown below:\n+ * Alternatively, clients can obtain an {@linkplain Arena#ofAuto() automatic arena}, that\n+ * is an arena which features a <em>bounded lifetime<\/em> that is managed, automatically,\n+ * by the garbage collector. The scope of an automatic arena is an automatic scope. As\n+ * such, the regions of memory backing memory segments allocated with the automatic arena\n+ * are deallocated at some unspecified time <em>after<\/em> the automatic arena (and all\n+ * the segments allocated by it) becomes <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>,\n+ * as shown below:\n@@ -67,1 +70,2 @@\n- * Memory segments allocated with an automatic arena can also be {@linkplain MemorySegment#isAccessibleBy(Thread) accessed} from any thread.\n+ * Memory segments allocated with an automatic arena can also be\n+ * {@linkplain MemorySegment#isAccessibleBy(Thread) accessed} from any thread.\n@@ -69,6 +73,8 @@\n- * Rather than leaving deallocation in the hands of the Java runtime, clients will often wish to exercise control over\n- * the timing of deallocation for regions of memory that back memory segments. Two kinds of arenas support this,\n- * namely {@linkplain #ofConfined() confined} and {@linkplain #ofShared() shared} arenas. They both feature\n- * bounded lifetimes that are managed manually. For instance, when a confined arena is {@linkplain #close() closed}\n- * successfully, its scope is {@linkplain Scope#isAlive() invalidated}. As a result, all the memory segments allocated\n- * by the arena can no longer be accessed, and their regions of memory are deallocated:\n+ * Rather than leaving de-allocation in the hands of the Java runtime, clients will often\n+ * wish to exercise control over the timing of de-allocation for regions of memory that\n+ * back memory segments. Two kinds of arenas support this, namely {@linkplain #ofConfined() confined}\n+ * and {@linkplain #ofShared() shared} arenas. They both feature bounded lifetimes that\n+ * are managed manually. For instance, when a confined arena is {@linkplain #close() closed}\n+ * successfully, its scope is {@linkplain Scope#isAlive() invalidated}. As a result, all\n+ * the memory segments allocated by the arena can no longer be accessed, and their\n+ * regions of memory are deallocated:\n@@ -85,3 +91,4 @@\n- * Memory segments allocated with a {@linkplain #ofConfined() confined arena} can only be accessed (and closed) by the\n- * thread that created the arena. If access to a memory segment from multiple threads is required, clients can allocate\n- * segments in a {@linkplain #ofShared() shared arena} instead.\n+ * Memory segments allocated with a {@linkplain #ofConfined() confined arena} can only be\n+ * accessed (and closed) by the thread that created the arena. If access to a memory\n+ * segment from multiple threads is required, clients can allocate segments in a\n+ * {@linkplain #ofShared() shared arena} instead.\n@@ -123,4 +130,5 @@\n- * Arenas provide strong temporal safety guarantees: a memory segment allocated by an arena cannot be accessed\n- * <em>after<\/em> the arena has been closed. The cost of providing this guarantee varies based on the\n- * number of threads that have access to the memory segments allocated by the arena. For instance, if an arena\n- * is always created and closed by one thread, and the memory segments allocated by the arena are always\n+ * Arenas provide strong temporal safety guarantees: a memory segment allocated by an\n+ * arena cannot be accessed <em>after<\/em> the arena has been closed. The cost of\n+ * providing this guarantee varies based on the number of threads that have access to the\n+ * memory segments allocated by the arena. For instance, if an arena is always created\n+ * and closed by one thread, and the memory segments allocated by the arena are always\n@@ -129,5 +137,7 @@\n- * Conversely, if an arena allocates segments that can be accessed by multiple threads, or if the arena can be closed\n- * by a thread other than the accessing thread, then ensuring correctness is much more complex. For example, a segment\n- * allocated with the arena might be accessed <em>while<\/em> another thread attempts, concurrently, to close the arena.\n- * To provide the strong temporal safety guarantee without forcing every client, even simple ones, to incur a performance\n- * impact, arenas are divided into <em>thread-confined<\/em> arenas, and <em>shared<\/em> arenas.\n+ * Conversely, if an arena allocates segments that can be accessed by multiple threads,\n+ * or if the arena can be closed by a thread other than the accessing thread, then\n+ * ensuring correctness is much more complex. For example, a segment allocated with the\n+ * arena might be accessed <em>while<\/em> another thread attempts, concurrently, to close\n+ * the arena. To provide the strong temporal safety guarantee without forcing every\n+ * client, even simple ones, to incur a performance impact, arenas are divided into\n+ * <em>thread-confined<\/em> arenas, and <em>shared<\/em> arenas.\n@@ -135,5 +145,6 @@\n- * Confined arenas, support strong thread-confinement guarantees. Upon creation, they are assigned an\n- * <em>owner thread<\/em>, typically the thread which initiated the creation operation.\n- * The segments created by a confined arena can only be {@linkplain MemorySegment#isAccessibleBy(Thread) accessed}\n- * by the owner thread. Moreover, any attempt to close the confined arena from a thread other than the owner thread will\n- * fail with {@link WrongThreadException}.\n+ * Confined arenas, support strong thread-confinement guarantees. Upon creation, they are\n+ * assigned an <em>owner thread<\/em>, typically the thread which initiated the creation\n+ * operation. The segments created by a confined arena can only be\n+ * {@linkplain MemorySegment#isAccessibleBy(Thread) accessed} by the owner thread.\n+ * Moreover, any attempt to close the confined arena from a thread other than the owner\n+ * thread will fail with a {@link WrongThreadException}.\n@@ -141,4 +152,5 @@\n- * Shared arenas, on the other hand, have no owner thread. The segments created by a shared arena\n- * can be {@linkplain MemorySegment#isAccessibleBy(Thread) accessed} by any thread. This might be useful when\n- * multiple threads need to access the same memory segment concurrently (e.g. in the case of parallel processing).\n- * Moreover, a shared arena can be closed by any thread.\n+ * Shared arenas, on the other hand, have no owner thread. The segments created by a\n+ * shared arena can be {@linkplain MemorySegment#isAccessibleBy(Thread) accessed} by\n+ * any thread. This might be useful when multiple threads need to access the same memory\n+ * segment concurrently (e.g. in the case of parallel processing). Moreover, a shared\n+ * arena can be closed by any thread.\n@@ -148,7 +160,9 @@\n- * Clients can define custom arenas to implement more efficient allocation strategies, or to have better control over\n- * when (and by whom) an arena can be closed. As an example, the following code defines a <em>slicing arena<\/em> that behaves\n- * like a confined arena (i.e., single-threaded access), but internally uses a\n- * {@linkplain SegmentAllocator#slicingAllocator(MemorySegment) slicing allocator} to respond to allocation requests.\n- * When the slicing arena is closed, the underlying confined arena is also closed; this will invalidate all segments\n- * allocated with the slicing arena (since the scope of the slicing arena is the same as that of the underlying\n- * confined arena):\n+ * Clients can define custom arenas to implement more efficient allocation strategies,\n+ * or to have better control over when (and by whom) an arena can be closed. As an\n+ * example, the following code defines a <em>slicing arena<\/em> that behaves like a\n+ * confined arena (i.e., single-threaded access), but internally uses a\n+ * {@linkplain SegmentAllocator#slicingAllocator(MemorySegment) slicing allocator} to\n+ * respond to allocation requests.\n+ * When the slicing arena is closed, the underlying confined arena is also closed; this\n+ * will invalidate all segments allocated with the slicing arena (since the scope of the\n+ * slicing arena is the same as that of the underlying confined arena):\n@@ -180,2 +194,3 @@\n- * In other words, a slicing arena provides a vastly more efficient and scalable allocation strategy, while still retaining\n- * the timely deallocation guarantee provided by the underlying confined arena:\n+ * In other words, a slicing arena provides a vastly more efficient and scalable\n+ * allocation strategy, while still retaining the timely de-allocation guarantee provided\n+ * by the underlying confined arena:\n@@ -207,1 +222,1 @@\n-     * @return a new arena that is managed, automatically, by the garbage collector.\n+     * @return a new arena that is managed, automatically, by the garbage collector\n@@ -214,5 +229,4 @@\n-     * Obtains the global arena. Segments allocated with the global arena can be\n-     * {@linkplain MemorySegment#isAccessibleBy(Thread) accessed} by any thread.\n-     * Calling {@link #close()} on the returned arena will result in an {@link UnsupportedOperationException}.\n-     *\n-     * @return the global arena.\n+     * {@return the global arena} Segments allocated with the global arena can be\n+     *          {@linkplain MemorySegment#isAccessibleBy(Thread) accessed} by any thread.\n+     *          Calling {@link #close()} on the returned arena will result in\n+     *          an {@link UnsupportedOperationException}.\n@@ -229,2 +243,2 @@\n-     * {@linkplain MemorySegment#isAccessibleBy(Thread) accessed} by the thread that created the arena,\n-     * the arena's <em>owner thread<\/em>.\n+     *          {@linkplain MemorySegment#isAccessibleBy(Thread) accessed} by the thread\n+     *          that created the arena, the arena's <em>owner thread<\/em>.\n@@ -238,1 +252,1 @@\n-     * {@linkplain MemorySegment#isAccessibleBy(Thread) accessed} by any thread.\n+     *          {@linkplain MemorySegment#isAccessibleBy(Thread) accessed} by any thread.\n@@ -245,1 +259,2 @@\n-     * Returns a native memory segment with the given size (in bytes) and alignment constraint (in bytes).\n+     * Returns a native memory segment with the given size (in bytes) and alignment\n+     * constraint (in bytes).\n@@ -247,2 +262,2 @@\n-     * The segment's {@link MemorySegment#address() address} is the starting address of the\n-     * allocated off-heap region of memory backing the segment, and the address is\n+     * The segment's {@link MemorySegment#address() address} is the starting address of\n+     * the allocated off-heap region of memory backing the segment, and the address is\n@@ -252,3 +267,4 @@\n-     * Implementations of this method must return a native segment featuring the requested size,\n-     * and that is compatible with the provided alignment constraint. Furthermore, for any two segments\n-     * {@code S1, S2} returned by this method, the following invariant must hold:\n+     * Implementations of this method must return a native segment featuring the\n+     * requested size, and that is compatible with the provided alignment constraint.\n+     * Furthermore, for any two segments {@code S1, S2} returned by this method, the\n+     * following invariant must hold:\n@@ -260,3 +276,5 @@\n-     * @param byteSize the size (in bytes) of the off-heap region of memory backing the native memory segment.\n-     * @param byteAlignment the alignment constraint (in bytes) of the off-heap region of memory backing the native memory segment.\n-     * @return a new native memory segment.\n+     * @param byteSize the size (in bytes) of the off-heap region of memory backing\n+     *                 the native memory segment\n+     * @param byteAlignment the alignment constraint (in bytes) of the off-heap region\n+     *                      of memory backing the native memory segment\n+     * @return a new native memory segment\n@@ -266,2 +284,2 @@\n-     * @throws WrongThreadException if this arena is confined, and this method is called from a thread\n-     *         other than the arena's owner thread\n+     * @throws WrongThreadException if this arena is confined, and this method is called\n+     *         from a thread other than the arena's owner thread\n@@ -278,2 +296,3 @@\n-     * Closes this arena. If this method completes normally, the arena scope is no longer {@linkplain Scope#isAlive() alive},\n-     * and all the memory segments associated with it can no longer be accessed. Furthermore, any off-heap region of memory backing the\n+     * Closes this arena. If this method completes normally, the arena scope is no longer\n+     * {@linkplain Scope#isAlive() alive}, and all the memory segments associated with it\n+     * can no longer be accessed. Furthermore, any off-heap region of memory backing the\n@@ -282,3 +301,4 @@\n-     * @apiNote This operation is not idempotent; that is, closing an already closed arena <em>always<\/em> results in an\n-     * exception being thrown. This reflects a deliberate design choice: failure to close an arena might reveal a bug\n-     * in the underlying application logic.\n+     * @apiNote This operation is not idempotent; that is, closing an already closed arena\n+     *          <em>always<\/em> results in an exception being thrown. This reflects a\n+     *          deliberate design choice: failure to close an arena might reveal a bug\n+     *          in the underlying application logic.\n@@ -286,3 +306,4 @@\n-     * @implSpec If this method completes normally, then {@code this.scope().isAlive() == false}.\n-     * Implementations are allowed to throw {@link UnsupportedOperationException} if an explicit close operation is\n-     * not supported.\n+     * @implSpec If this method completes normally, then\n+     *           {@code this.scope().isAlive() == false}.\n+     *           Implementations are allowed to throw {@link UnsupportedOperationException}\n+     *           if an explicit close operation is not supported.\n@@ -293,4 +314,5 @@\n-     * @throws IllegalStateException if a segment associated with this arena is being accessed concurrently, e.g.\n-     *         by a {@linkplain Linker#downcallHandle(FunctionDescriptor, Linker.Option...) downcall method handle}\n-     * @throws WrongThreadException if this arena is confined, and this method is called from a thread\n-     *         other than the arena's owner thread\n+     * @throws IllegalStateException if a segment associated with this arena is being\n+     *         accessed concurrently, e.g. by a\n+     *         {@linkplain Linker#downcallHandle(FunctionDescriptor, Linker.Option...) downcall method handle}\n+     * @throws WrongThreadException if this arena is confined, and this method is called\n+     *         from a thread other than the arena's owner thread\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Arena.java","additions":109,"deletions":87,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -37,3 +37,5 @@\n- * A function descriptor models the signature of a foreign function. A function descriptor is made up of zero or more\n- * argument layouts, and zero or one return layout. A function descriptor is used to create\n- * {@linkplain Linker#downcallHandle(MemorySegment, FunctionDescriptor, Linker.Option...) downcall method handles} and\n+ * A function descriptor models the signature of a foreign function. A function\n+ * descriptor is made up of zero or more argument layouts, and zero or one return layout.\n+ * A function descriptor is used to create\n+ * {@linkplain Linker#downcallHandle(MemorySegment, FunctionDescriptor, Linker.Option...) downcall method handles}\n+ * and\n@@ -43,1 +45,2 @@\n- * Implementing classes are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ * Implementing classes are immutable, thread-safe and\n+ * <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n@@ -56,1 +59,1 @@\n-     * {@return the argument layouts of this function descriptor (as an unmodifiable list)}.\n+     * {@return the argument layouts of this function descriptor (as an unmodifiable list)}\n@@ -61,5 +64,7 @@\n-     * Returns a function descriptor with the given argument layouts appended to the argument layouts\n-     * of this function descriptor.\n-     * @param addedLayouts the argument layouts to append.\n-     * @throws IllegalArgumentException if one of the layouts in {@code addedLayouts} is a padding layout\n-     * @return a new function descriptor, with the provided additional argument layouts.\n+     * Returns a function descriptor with the given argument layouts appended to the\n+     * argument layouts of this function descriptor.\n+     *\n+     * @param addedLayouts the argument layouts to append\n+     * @throws IllegalArgumentException if one of the layouts in {@code addedLayouts} is\n+     *         a padding layout\n+     * @return a new function descriptor, with the provided additional argument layouts\n@@ -70,2 +75,3 @@\n-     * Returns a function descriptor with the given argument layouts inserted at the given index, into the argument\n-     * layout array of this function descriptor.\n+     * Returns a function descriptor with the given argument layouts inserted at the\n+     * given index, into the argument layout array of this function descriptor.\n+     *\n@@ -73,3 +79,4 @@\n-     * @param addedLayouts the argument layouts to insert at given index.\n-     * @return a new function descriptor, with the provided additional argument layouts.\n-     * @throws IllegalArgumentException if one of the layouts in {@code addedLayouts} is a padding layout\n+     * @param addedLayouts the argument layouts to insert at given index\n+     * @return a new function descriptor, with the provided additional argument layouts\n+     * @throws IllegalArgumentException if one of the layouts in {@code addedLayouts}\n+     *         is a padding layout\n@@ -82,1 +89,1 @@\n-     * @param newReturn the new return layout.\n+     * @param newReturn the new return layout\n@@ -84,1 +91,1 @@\n-     * @return a new function descriptor, with the provided return layout.\n+     * @return a new function descriptor, with the provided return layout\n@@ -94,1 +101,2 @@\n-     * Returns the method type consisting of the carrier types of the layouts in this function descriptor.\n+     * Returns the method type consisting of the carrier types of the layouts in this\n+     * function descriptor.\n@@ -98,2 +106,4 @@\n-     * <li>If {@code L} is a {@link ValueLayout} the carrier type is determined through {@link ValueLayout#carrier()}.<\/li>\n-     * <li>If {@code L} is a {@link GroupLayout} or a {@link SequenceLayout}, the carrier type is {@link MemorySegment}.<\/li>\n+     * <li>If {@code L} is a {@link ValueLayout} the carrier type is\n+     *     determined through {@link ValueLayout#carrier()}.<\/li>\n+     * <li>If {@code L} is a {@link GroupLayout} or a {@link SequenceLayout},\n+     *     the carrier type is {@link MemorySegment}.<\/li>\n@@ -102,2 +112,3 @@\n-     * @apiNote A function descriptor cannot, by construction, contain any padding layouts. As such, it is not\n-     * necessary to specify how padding layout should be mapped to carrier types.\n+     * @apiNote A function descriptor cannot, by construction, contain any padding\n+     *          layouts. As such, it is not necessary to specify how padding layout\n+     *          should be mapped to carrier types.\n@@ -105,1 +116,2 @@\n-     * @return the method type consisting of the carrier types of the layouts in this function descriptor.\n+     * @return the method type consisting of the carrier types of the layouts in this\n+     *         function descriptor\n@@ -111,2 +123,3 @@\n-     * @param resLayout the return layout.\n-     * @param argLayouts the argument layouts.\n+     *\n+     * @param resLayout the return layout\n+     * @param argLayouts the argument layouts\n@@ -114,2 +127,3 @@\n-     * @throws IllegalArgumentException if one of the layouts in {@code argLayouts} is a padding layout\n-     * @return a new function descriptor with the provided return and argument layouts.\n+     * @throws IllegalArgumentException if one of the layouts in {@code argLayouts}\n+     *         is a padding layout\n+     * @return a new function descriptor with the provided return and argument layouts\n@@ -124,5 +138,7 @@\n-     * Creates a function descriptor with the given argument layouts and no return layout.  This is useful to model functions\n-     * that return no values.\n-     * @param argLayouts the argument layouts.\n-     * @throws IllegalArgumentException if one of the layouts in {@code argLayouts} is a padding layout\n-     * @return a new function descriptor with the provided argument layouts.\n+     * Creates a function descriptor with the given argument layouts and no return\n+     * layout. This is useful to model functions that return no values.\n+     *\n+     * @param argLayouts the argument layouts\n+     * @throws IllegalArgumentException if one of the layouts in {@code argLayouts}\n+     *         is a padding layout\n+     * @return a new function descriptor with the provided argument layouts\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/FunctionDescriptor.java","additions":48,"deletions":32,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -31,4 +31,6 @@\n- * A compound layout that is an aggregation of multiple, heterogeneous <em>member layouts<\/em>. There are two ways in which member layouts\n- * can be combined: if member layouts are laid out one after the other, the resulting group layout is a\n- * {@linkplain StructLayout struct layout}; conversely, if all member layouts are laid out at the same starting offset,\n- * the resulting group layout is a {@linkplain UnionLayout union layout}.\n+ * A compound layout that is an aggregation of multiple, heterogeneous\n+ * <em>member layouts<\/em>. There are two ways in which member layouts can be combined:\n+ * if member layouts are laid out one after the other, the resulting group layout is a\n+ * {@linkplain StructLayout struct layout}; conversely, if all member layouts are laid\n+ * out at the same starting offset, the resulting group layout is a\n+ * {@linkplain UnionLayout union layout}.\n@@ -37,1 +39,2 @@\n- * This class is immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ * This class is immutable, thread-safe and\n+ * <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n@@ -47,3 +50,4 @@\n-     * @apiNote the order in which member layouts are returned is the same order in which member layouts have\n-     * been passed to one of the group layout factory methods (see {@link MemoryLayout#structLayout(MemoryLayout...)},\n-     * {@link MemoryLayout#unionLayout(MemoryLayout...)}).\n+     * @apiNote the order in which member layouts are returned is the same order in which\n+     *          member layouts have been passed to one of the group layout factory methods\n+     *          (see {@link MemoryLayout#structLayout(MemoryLayout...)} and\n+     *          {@link MemoryLayout#unionLayout(MemoryLayout...)}).\n@@ -68,2 +72,3 @@\n-     * @throws IllegalArgumentException if {@code byteAlignment} is less than {@code M}, where {@code M} is\n-     *         the maximum alignment constraint in any of the member layouts associated with this group layout\n+     * @throws IllegalArgumentException if {@code byteAlignment} is less than {@code M},\n+     *         where {@code M} is the maximum alignment constraint in any of the\n+     *         member layouts associated with this group layout\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/GroupLayout.java","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -44,1 +44,2 @@\n- * A linker provides access to foreign functions from Java code, and access to Java code from foreign functions.\n+ * A linker provides access to foreign functions from Java code, and access to Java code\n+ * from foreign functions.\n@@ -46,4 +47,5 @@\n- * Foreign functions typically reside in libraries that can be loaded on-demand. Each library conforms to\n- * a specific ABI (Application Binary Interface). An ABI is a set of calling conventions and data types associated with\n- * the compiler, OS, and processor where the library was built. For example, a C compiler on Linux\/x64 usually\n- * builds libraries that conform to the SystemV ABI.\n+ * Foreign functions typically reside in libraries that can be loaded on-demand. Each\n+ * library conforms to a specific ABI (Application Binary Interface). An ABI is a set of\n+ * calling conventions and data types associated with the compiler, OS, and processor\n+ * where the library was built. For example, a C compiler on Linux\/x64 usually builds\n+ * libraries that conform to the SystemV ABI.\n@@ -51,3 +53,4 @@\n- * A linker has detailed knowledge of the calling conventions and data types used by a specific ABI.\n- * For any library which conforms to that ABI, the linker can mediate between Java code running\n- * in the JVM and foreign functions in the library. In particular:\n+ * A linker has detailed knowledge of the calling conventions and data types used by a\n+ * specific ABI. For any library which conforms to that ABI, the linker can mediate\n+ * between Java code running in the JVM and foreign functions in the library. In\n+ * particular:\n@@ -56,3 +59,4 @@\n- * {@linkplain #downcallHandle(MemorySegment, FunctionDescriptor, Option...) downcall method handles}; and<\/li>\n- * <li>A linker allows foreign functions to call Java method handles,\n- * via the generation of {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, Arena, Option...) upcall stubs}.<\/li>\n+ * {@linkplain #downcallHandle(MemorySegment, FunctionDescriptor, Option...) downcall method handles};\n+ * and<\/li>\n+ * <li>A linker allows foreign functions to call Java method handles, via the generation\n+ * of {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, Arena, Option...) upcall stubs}.<\/li>\n@@ -60,5 +64,6 @@\n- * A linker provides a way to look up the <em>canonical layouts<\/em> associated with the data types used by the ABI.\n- * For example, a linker implementing the C ABI might choose to provide a canonical layout for the C {@code size_t}\n- * type. On 64-bit platforms, this canonical layout might be equal to {@link ValueLayout#JAVA_LONG}. The canonical\n- * layouts supported by a linker are exposed via the {@link #canonicalLayouts()} method, which returns a map from\n- * type names to canonical layouts.\n+ * A linker provides a way to look up the <em>canonical layouts<\/em> associated with the\n+ * data types used by the ABI. For example, a linker implementing the C ABI might choose\n+ * to provide a canonical layout for the C {@code size_t} type. On 64-bit platforms,\n+ * this canonical layout might be equal to {@link ValueLayout#JAVA_LONG}. The canonical\n+ * layouts supported by a linker are exposed via the {@link #canonicalLayouts()} method,\n+ * which returns a map from type names to canonical layouts.\n@@ -66,4 +71,5 @@\n- * In addition, a linker provides a way to look up foreign functions in libraries that conform to the ABI. Each linker\n- * chooses a set of libraries that are commonly used on the OS and processor combination associated with the ABI.\n- * For example, a linker for Linux\/x64 might choose two libraries: {@code libc} and {@code libm}. The functions in these\n- * libraries are exposed via a {@linkplain #defaultLookup() symbol lookup}.\n+ * In addition, a linker provides a way to look up foreign functions in libraries that\n+ * conform to the ABI. Each linker chooses a set of libraries that are commonly used on\n+ * the OS and processor combination associated with the ABI. For example, a linker for\n+ * Linux\/x64 might choose two libraries: {@code libc} and {@code libm}. The functions in\n+ * these libraries are exposed via a {@linkplain #defaultLookup() symbol lookup}.\n@@ -74,2 +80,2 @@\n- * defined in C libraries (native functions). Suppose we wish to downcall from Java to the {@code strlen} function\n- * defined in the standard C library:\n+ * defined in C libraries (native functions). Suppose we wish to downcall from Java to\n+ * the {@code strlen} function defined in the standard C library:\n@@ -79,1 +85,2 @@\n- * A downcall method handle that exposes {@code strlen} is obtained, using the native linker, as follows:\n+ * A downcall method handle that exposes {@code strlen} is obtained, using the native\n+ * linker, as follows:\n@@ -90,6 +97,6 @@\n- * to the native functions defined by the C libraries loaded with the Java runtime. Above, the default lookup\n- * is used to search the address of the {@code strlen} native function. That address is then passed, along with\n- * a <em>platform-dependent description<\/em> of the signature of the function expressed as a\n- * {@link FunctionDescriptor} (more on that below) to the native linker's\n- * {@link #downcallHandle(MemorySegment, FunctionDescriptor, Option...)} method.\n- * The obtained downcall method handle is then invoked as follows:\n+ * to the native functions defined by the C libraries loaded with the Java runtime.\n+ * Above, the default lookup is used to search the address of the {@code strlen} native\n+ * function. That address is then passed, along with a <em>platform-dependent description<\/em>\n+ * of the signature of the function expressed as a {@link FunctionDescriptor} (more on\n+ * that below) to the native linker's {@link #downcallHandle(MemorySegment, FunctionDescriptor, Option...)}\n+ * method. The obtained downcall method handle is then invoked as follows:\n@@ -105,3 +112,4 @@\n- * When interacting with the native linker, clients must provide a platform-dependent description of the signature\n- * of the C function they wish to link against. This description, a {@link FunctionDescriptor function descriptor},\n- * defines the layouts associated with the parameter types and return type (if any) of the C function.\n+ * When interacting with the native linker, clients must provide a platform-dependent\n+ * description of the signature of the C function they wish to link against. This\n+ * description, a {@link FunctionDescriptor function descriptor}, defines the layouts\n+ * associated with the parameter types and return type (if any) of the C function.\n@@ -109,2 +117,3 @@\n- * Scalar C types such as {@code bool}, {@code int} are modelled as {@linkplain ValueLayout value layouts}\n- * of a suitable carrier. The {@linkplain #canonicalLayouts() mapping} between a scalar type and its corresponding\n+ * Scalar C types such as {@code bool}, {@code int} are modelled as\n+ * {@linkplain ValueLayout value layouts} of a suitable carrier. The\n+ * {@linkplain #canonicalLayouts() mapping} between a scalar type and its corresponding\n@@ -113,6 +122,8 @@\n- * Composite types are modelled as {@linkplain GroupLayout group layouts}. More specifically, a C {@code struct} type\n- * maps to a {@linkplain StructLayout struct layout}, whereas a C {@code union} type maps to a {@link UnionLayout union\n- * layout}. When defining a struct or union layout, clients must pay attention to the size and alignment constraint\n- * of the corresponding composite type definition in C. For instance, padding between two struct fields\n- * must be modelled explicitly, by adding an adequately sized {@linkplain PaddingLayout padding layout} member\n- * to the resulting struct layout.\n+ * Composite types are modelled as {@linkplain GroupLayout group layouts}. More\n+ * specifically, a C {@code struct} type maps to a {@linkplain StructLayout struct layout},\n+ * whereas a C {@code union} type maps to a {@link UnionLayout union layout}. When\n+ * defining a struct or union layout, clients must pay attention to the size and\n+ * alignment constraint of the corresponding composite type definition in C. For\n+ * instance, padding between two struct fields must be modelled explicitly, by adding\n+ * an adequately sized {@linkplain PaddingLayout padding layout} member to the resulting\n+ * struct layout.\n@@ -120,5 +131,7 @@\n- * Finally, pointer types such as {@code int**} and {@code int(*)(size_t*, size_t*)} are modelled as\n- * {@linkplain AddressLayout address layouts}. When the spatial bounds of the pointer type are known statically,\n- * the address layout can be associated with a {@linkplain AddressLayout#targetLayout() target layout}. For instance,\n- * a pointer that is known to point to a C {@code int[2]} array can be modelled as an address layout whose\n- * target layout is a sequence layout whose element count is 2, and whose element type is {@link ValueLayout#JAVA_INT}.\n+ * Finally, pointer types such as {@code int**} and {@code int(*)(size_t*, size_t*)} are\n+ * modelled as {@linkplain AddressLayout address layouts}. When the spatial bounds of\n+ * the pointer type are known statically, the address layout can be associated with a\n+ * {@linkplain AddressLayout#targetLayout() target layout}. For instance, a pointer that\n+ * is known to point to a C {@code int[2]} array can be modelled as an address layout\n+ * whose target layout is a sequence layout whose element count is 2, and whose element\n+ * type is {@link ValueLayout#JAVA_INT}.\n@@ -126,1 +139,2 @@\n- * All native linker implementations are guaranteed to provide canonical layouts for the following set of types:\n+ * All native linker implementations are guaranteed to provide canonical layouts for the\n+ * following set of types:\n@@ -140,5 +154,7 @@\n- * As noted above, the specific canonical layout associated with each type can vary, depending on the data model\n- * supported by a given ABI. For instance, the C type {@code long} maps to the layout constant {@link ValueLayout#JAVA_LONG}\n- * on Linux\/x64, but maps to the layout constant {@link ValueLayout#JAVA_INT} on Windows\/x64. Similarly, the C type\n- * {@code size_t} maps to the layout constant {@link ValueLayout#JAVA_LONG} on 64-bit platforms, but maps to the layout\n- * constant {@link ValueLayout#JAVA_INT} on 32-bit platforms.\n+ * As noted above, the specific canonical layout associated with each type can vary,\n+ * depending on the data model supported by a given ABI. For instance, the C type\n+ * {@code long} maps to the layout constant {@link ValueLayout#JAVA_LONG} on Linux\/x64,\n+ * but maps to the layout constant {@link ValueLayout#JAVA_INT} on Windows\/x64.\n+ * Similarly, the C type {@code size_t} maps to the layout constant\n+ * {@link ValueLayout#JAVA_LONG} on 64-bit platforms, but maps to the layout constant\n+ * {@link ValueLayout#JAVA_INT} on 32-bit platforms.\n@@ -146,3 +162,4 @@\n- * A native linker typically does not provide canonical layouts for C's unsigned integral types. Instead, they are\n- * modelled using the canonical layouts associated with their corresponding signed integral types. For instance,\n- * the C type {@code unsigned long} maps to the layout constant {@link ValueLayout#JAVA_LONG} on Linux\/x64, but maps to\n+ * A native linker typically does not provide canonical layouts for C's unsigned integral\n+ * types. Instead, they are modelled using the canonical layouts associated with their\n+ * corresponding signed integral types. For instance, the C type {@code unsigned long}\n+ * maps to the layout constant {@link ValueLayout#JAVA_LONG} on Linux\/x64, but maps to\n@@ -151,2 +168,3 @@\n- * The following table shows some examples of how C types are modelled in Linux\/x64 according to the\n- * \"System V Application Binary Interface\" (all the examples provided here will assume these platform-dependent mappings):\n+ * The following table shows some examples of how C types are modelled in Linux\/x64\n+ * according to the \"System V Application Binary Interface\" (all the examples provided\n+ * here will assume these platform-dependent mappings):\n@@ -233,1 +251,2 @@\n- * <li>the alignment constraint of {@code S} is set to its <a href=\"MemoryLayout.html#layout-align\">natural alignment<\/a>, and<\/li>\n+ * <li>the alignment constraint of {@code S} is set to its\n+ *     <a href=\"MemoryLayout.html#layout-align\">natural alignment<\/a>, and<\/li>\n@@ -239,1 +258,2 @@\n- * <li>the alignment constraint of {@code G} is set to its <a href=\"MemoryLayout.html#layout-align\">natural alignment<\/a>;<\/li>\n+ * <li>the alignment constraint of {@code G} is set to its\n+ *     <a href=\"MemoryLayout.html#layout-align\">natural alignment<\/a>;<\/li>\n@@ -241,2 +261,4 @@\n- * <li>each member layout in {@code G.memberLayouts()} is either a padding layout or a layout supported by {@code NL}, and<\/li>\n- * <li>{@code G} does not contain padding other than what is strictly required to align its non-padding layout elements, or to satisfy (2).<\/li>\n+ * <li>each member layout in {@code G.memberLayouts()} is either a padding layout or\n+ *     a layout supported by {@code NL}, and<\/li>\n+ * <li>{@code G} does not contain padding other than what is strictly required to align\n+ *      its non-padding layout elements, or to satisfy (2).<\/li>\n@@ -247,4 +269,5 @@\n- * Linker implementations may optionally support additional layouts, such as <em>packed<\/em> struct layouts.\n- * A packed struct is a struct in which there is at least one member layout {@code L} that has an alignment\n- * constraint less strict than its natural alignment. This allows avoiding padding between member layouts,\n- * as well as avoiding padding at the end of the struct layout. For example:\n+ * Linker implementations may optionally support additional layouts, such as\n+ * <em>packed<\/em> struct layouts. A packed struct is a struct in which there is at least\n+ * one member layout {@code L} that has an alignment constraint less strict than its\n+ * natural alignment. This allows avoiding padding between member layouts, as well as\n+ * avoiding padding at the end of the struct layout. For example:\n@@ -263,2 +286,2 @@\n- * A native linker only supports function descriptors whose argument\/return layouts are layouts supported by that linker\n- * and are not sequence layouts.\n+ * A native linker only supports function descriptors whose argument\/return layouts are\n+ * layouts supported by that linker and are not sequence layouts.\n@@ -268,3 +291,4 @@\n- * Sometimes, it is useful to pass Java code as a function pointer to some native function; this is achieved by using\n- * an {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, Arena, Option...) upcall stub}. To demonstrate this,\n- * let's consider the following function from the C standard library:\n+ * Sometimes, it is useful to pass Java code as a function pointer to some native\n+ * function; this is achieved by using an\n+ * {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, Arena, Option...) upcall stub}.\n+ * To demonstrate this, let's consider the following function from the C standard library:\n@@ -277,3 +301,4 @@\n- * The {@code qsort} function can be used to sort the contents of an array, using a custom comparator function which is\n- * passed as a function pointer (the {@code compar} parameter). To be able to call the {@code qsort} function from Java,\n- * we must first create a downcall method handle for it, as follows:\n+ * The {@code qsort} function can be used to sort the contents of an array, using a\n+ * custom comparator function which is passed as a function pointer\n+ * (the {@code compar} parameter). To be able to call the {@code qsort} function from\n+ * Java, we must first create a downcall method handle for it, as follows:\n@@ -289,2 +314,3 @@\n- * As before, we use {@link ValueLayout#JAVA_LONG} to map the C type {@code size_t} type, and {@link ValueLayout#ADDRESS}\n- * for both the first pointer parameter (the array pointer) and the last parameter (the function pointer).\n+ * As before, we use {@link ValueLayout#JAVA_LONG} to map the C type {@code size_t} type,\n+ * and {@link ValueLayout#ADDRESS} for both the first pointer parameter (the array\n+ * pointer) and the last parameter (the function pointer).\n@@ -292,3 +318,4 @@\n- * To invoke the {@code qsort} downcall handle obtained above, we need a function pointer to be passed as the last\n- * parameter. That is, we need to create a function pointer out of an existing method handle. First, let's write a\n- * Java method that can compare two int elements passed as pointers (i.e. as {@linkplain MemorySegment memory segments}):\n+ * To invoke the {@code qsort} downcall handle obtained above, we need a function pointer\n+ * to be passed as the last parameter. That is, we need to create a function pointer out\n+ * of an existing method handle. First, let's write a Java method that can compare two\n+ * int elements passed as pointers (i.e. as {@linkplain MemorySegment memory segments}):\n@@ -315,7 +342,10 @@\n- * First, we create a function descriptor for the function pointer type. Since we know that the parameters passed to\n- * the comparator method will be pointers to elements of a C {@code int[]} array, we can specify {@link ValueLayout#JAVA_INT}\n- * as the target layout for the address layouts of both parameters. This will allow the comparator method to access\n- * the contents of the array elements to be compared. We then {@linkplain FunctionDescriptor#toMethodType() turn}\n- * that function descriptor into a suitable {@linkplain java.lang.invoke.MethodType method type} which we then use to look up\n- * the comparator method handle. We can now create an upcall stub which points to that method, and pass it, as a function\n- * pointer, to the {@code qsort} downcall handle, as follows:\n+ * First, we create a function descriptor for the function pointer type. Since we know\n+ * that the parameters passed to the comparator method will be pointers to elements of a\n+ * C {@code int[]} array, we can specify {@link ValueLayout#JAVA_INT} as the target\n+ * layout for the address layouts of both parameters. This will allow the comparator\n+ * method to access the contents of the array elements to be compared. We then\n+ * {@linkplain FunctionDescriptor#toMethodType() turn} that function descriptor into a\n+ * suitable {@linkplain java.lang.invoke.MethodType method type} which we then use to\n+ * look up the comparator method handle. We can now create an upcall stub which points\n+ * to that method, and pass it, as a function pointer, to the {@code qsort} downcall\n+ * handle, as follows:\n@@ -332,4 +362,6 @@\n- * This code creates an off-heap array, copies the contents of a Java array into it, and then passes the array to the\n- * {@code qsort} method handle along with the comparator function we obtained from the native linker. After the invocation, the contents\n- * of the off-heap array will be sorted according to our comparator function, written in Java. We then extract a\n- * new Java array from the segment, which contains the sorted elements.\n+ * This code creates an off-heap array, copies the contents of a Java array into it, and\n+ * then passes the array to the {@code qsort} method handle along with the comparator\n+ * function we obtained from the native linker. After the invocation, the contents\n+ * of the off-heap array will be sorted according to our comparator function, written in\n+ * Java. We then extract a new Java array from the segment, which contains the sorted\n+ * elements.\n@@ -339,2 +371,3 @@\n- * When interacting with native functions, it is common for those functions to allocate a region of memory and return\n- * a pointer to that region. Let's consider the following function from the C standard library:\n+ * When interacting with native functions, it is common for those functions to allocate\n+ * a region of memory and return a pointer to that region. Let's consider the following\n+ * function from the C standard library:\n@@ -346,3 +379,3 @@\n- * The {@code malloc} function allocates a region of memory of given size,\n- * and returns a pointer to that region of memory, which is later deallocated using another function from\n- * the C standard library:\n+ * The {@code malloc} function allocates a region of memory of given size, and returns a\n+ * pointer to that region of memory, which is later deallocated using another function\n+ * from the C standard library:\n@@ -354,4 +387,5 @@\n- * The {@code free} function takes a pointer to a region of memory and deallocates that region. In this section we\n- * will show how to interact with these native functions, with the aim of providing a <em>safe<\/em> allocation\n- * API (the approach outlined below can of course be generalized to allocation functions other than {@code malloc}\n- * and {@code free}).\n+ * The {@code free} function takes a pointer to a region of memory and deallocates that\n+ * region. In this section we will show how to interact with these native functions,\n+ * with the aim of providing a <em>safe<\/em> allocation API (the approach outlined below\n+ * can of course be generalized to allocation functions other than {@code malloc} and\n+ * {@code free}).\n@@ -359,1 +393,2 @@\n- * First, we need to create the downcall method handles for {@code malloc} and {@code free}, as follows:\n+ * First, we need to create the downcall method handles for {@code malloc} and\n+ * {@code free}, as follows:\n@@ -375,2 +410,3 @@\n- * When a native function returning a pointer (such as {@code malloc}) is invoked using a downcall method handle,\n- * the Java runtime has no insight into the size or the lifetime of the returned pointer. Consider the following code:\n+ * When a native function returning a pointer (such as {@code malloc}) is invoked using\n+ * a downcall method handle, the Java runtime has no insight into the size or the\n+ * lifetime of the returned pointer. Consider the following code:\n@@ -385,5 +421,6 @@\n- * unsafely, resize the segment to the desired size (100, in this case). It might also be desirable to\n- * attach the segment to some existing {@linkplain Arena arena}, so that the lifetime of the region of memory\n- * backing the segment can be managed automatically, as for any other native segment created directly from Java code.\n- * Both of these operations are accomplished using the restricted method {@link MemorySegment#reinterpret(long, Arena, Consumer)},\n- * as follows:\n+ * unsafely, resize the segment to the desired size (100, in this case). It might also\n+ * be desirable to attach the segment to some existing {@linkplain Arena arena}, so that\n+ * the lifetime of the region of memory backing the segment can be managed automatically,\n+ * as for any other native segment created directly from Java code. Both of these\n+ * operations are accomplished using the restricted method\n+ * {@link MemorySegment#reinterpret(long, Arena, Consumer)}, as follows:\n@@ -404,6 +441,8 @@\n- * The {@code allocateMemory} method defined above accepts two parameters: a size and an arena. The method calls the\n- * {@code malloc} downcall method handle, and unsafely reinterprets the returned segment, by giving it a new size\n- * (the size passed to the {@code allocateMemory} method) and a new scope (the scope of the provided arena).\n- * The method also specifies a <em>cleanup action<\/em> to be executed when the provided arena is closed. Unsurprisingly,\n- * the cleanup action passes the segment to the {@code free} downcall method handle, to deallocate the underlying\n- * region of memory. We can use the {@code allocateMemory} method as follows:\n+ * The {@code allocateMemory} method defined above accepts two parameters: a size and an\n+ * arena. The method calls the {@code malloc} downcall method handle, and unsafely\n+ * reinterprets the returned segment, by giving it a new size (the size passed to the\n+ * {@code allocateMemory} method) and a new scope (the scope of the provided arena).\n+ * The method also specifies a <em>cleanup action<\/em> to be executed when the provided\n+ * arena is closed. Unsurprisingly, the cleanup action passes the segment to the\n+ * {@code free} downcall method handle, to deallocate the underlying region of memory.\n+ * We can use the {@code allocateMemory} method as follows:\n@@ -417,3 +456,5 @@\n- * Note how the segment obtained from {@code allocateMemory} acts as any other segment managed by the confined arena. More\n- * specifically, the obtained segment has the desired size, can only be accessed by a single thread (the thread which created\n- * the confined arena), and its lifetime is tied to the surrounding <em>try-with-resources<\/em> block.\n+ * Note how the segment obtained from {@code allocateMemory} acts as any other segment\n+ * managed by the confined arena. More specifically, the obtained segment has the\n+ * desired size, can only be accessed by a single thread (the thread which created the\n+ * confined arena), and its lifetime is tied to the surrounding <em>try-with-resources<\/em>\n+ * block.\n@@ -423,5 +464,7 @@\n- * Variadic functions are C functions which can accept a variable number and type of arguments. They are declared with a\n- * trailing ellipsis ({@code ...}) at the end of the formal parameter list, such as: {@code void foo(int x, ...);}\n- * The arguments passed in place of the ellipsis are called <em>variadic arguments<\/em>. Variadic functions are,\n- * essentially, templates that can be <em>specialized<\/em> into multiple non-variadic functions by replacing the\n- * {@code ...} with a list of <em>variadic parameters<\/em> of a fixed number and type.\n+ * Variadic functions are C functions which can accept a variable number and type of\n+ * arguments. They are declared with a trailing ellipsis ({@code ...}) at the end of the\n+ * formal parameter list, such as: {@code void foo(int x, ...);}. The arguments passed\n+ * in place of the ellipsis are called <em>variadic arguments<\/em>. Variadic functions\n+ * are, essentially, templates that can be <em>specialized<\/em> into multiple\n+ * non-variadic functions by replacing the {@code ...} with a list of\n+ * <em>variadic parameters<\/em> of a fixed number and type.\n@@ -429,2 +472,2 @@\n- * It should be noted that values passed as variadic arguments undergo default argument promotion in C. For instance, the\n- * following argument promotions are applied:\n+ * It should be noted that values passed as variadic arguments undergo default argument\n+ * promotion in C. For instance, the following argument promotions are applied:\n@@ -437,4 +480,5 @@\n- * whereby the signed-ness of the source type corresponds to the signed-ness of the promoted type. The complete process\n- * of default argument promotion is described in the C specification. In effect these promotions place limits on the\n- * types that can be used to replace the {@code ...}, as the variadic parameters of the specialized form of a variadic\n- * function will always have a promoted type.\n+ * whereby the signed-ness of the source type corresponds to the signed-ness of the\n+ * promoted type. The complete process of default argument promotion is described in the\n+ * C specification. In effect these promotions place limits on the types that can be\n+ * used to replace the {@code ...}, as the variadic parameters of the specialized form of\n+ * a variadic function will always have a promoted type.\n@@ -442,5 +486,7 @@\n- * The native linker only supports linking the specialized form of a variadic function. A variadic function in its specialized\n- * form can be linked using a function descriptor describing the specialized form. Additionally, the\n- * {@link Linker.Option#firstVariadicArg(int)} linker option must be provided to indicate the first variadic parameter in\n- * the parameter list. The corresponding argument layout (if any), and all following argument layouts in the specialized\n- * function descriptor, are called <em>variadic argument layouts<\/em>.\n+ * The native linker only supports linking the specialized form of a variadic function.\n+ * A variadic function in its specialized form can be linked using a function descriptor\n+ * describing the specialized form. Additionally, the {@link Linker.Option#firstVariadicArg(int)}\n+ * linker option must be provided to indicate the first variadic parameter in the\n+ * parameter list. The corresponding argument layout (if any), and all following\n+ * argument layouts in the specialized function descriptor, are called\n+ * <em>variadic argument layouts<\/em>.\n@@ -448,7 +494,10 @@\n- * The native linker does not automatically perform default argument promotions. However, since passing an argument of a\n- * non-promoted type as a variadic argument is not supported in C, the native linker will reject an attempt to link a\n- * specialized function descriptor with any variadic argument value layouts corresponding to a non-promoted C type.\n- * Since the size of the C {@code int} type is platform-specific, exactly which layouts will be rejected is\n- * platform-specific as well. As an example: on Linux\/x64 the layouts corresponding to the C types {@code _Bool},\n- * {@code (unsigned) char}, {@code (unsigned) short}, and {@code float} (among others), will be rejected by the linker.\n- * The {@link #canonicalLayouts()} method can be used to find which layout corresponds to a particular C type.\n+ * The native linker does not automatically perform default argument promotions. However,\n+ * since passing an argument of a non-promoted type as a variadic argument is not\n+ * supported in C, the native linker will reject an attempt to link a specialized\n+ * function descriptor with any variadic argument value layouts corresponding to a\n+ * non-promoted C type. Since the size of the C {@code int} type is platform-specific,\n+ * exactly which layouts will be rejected is platform-specific as well. As an example:\n+ * on Linux\/x64 the layouts corresponding to the C types {@code _Bool},\n+ * {@code (unsigned) char}, {@code (unsigned) short}, and {@code float} (among others),\n+ * will be rejected by the linker. The {@link #canonicalLayouts()} method can be used to\n+ * find which layout corresponds to a particular C type.\n@@ -456,1 +505,2 @@\n- * A well-known variadic function is the {@code printf} function, defined in the C standard library:\n+ * A well-known variadic function is the {@code printf} function, defined in the\n+ * C standard library:\n@@ -462,2 +512,3 @@\n- * This function takes a format string, and a number of additional arguments (the number of such arguments is\n- * dictated by the format string). Consider the following variadic call:\n+ * This function takes a format string, and a number of additional arguments (the number\n+ * of such arguments is dictated by the format string). Consider the following\n+ * variadic call:\n@@ -469,7 +520,10 @@\n- * To perform an equivalent call using a downcall method handle we must create a function descriptor which\n- * describes the specialized signature of the C function we want to call. This descriptor must include an additional layout\n- * for each variadic argument we intend to provide. In this case, the specialized signature of the C\n- * function is {@code (char*, int, int, int)} as the format string accepts three integer parameters. We then need to use\n- * a {@linkplain Linker.Option#firstVariadicArg(int) linker option} to specify the position of the first variadic layout\n- * in the provided function descriptor (starting from 0). In this case, since the first parameter is the format string\n- * (a non-variadic argument), the first variadic index needs to be set to 1, as follows:\n+ * To perform an equivalent call using a downcall method handle we must create a function\n+ * descriptor which describes the specialized signature of the C function we want to\n+ * call. This descriptor must include an additional layout for each variadic argument we\n+ * intend to provide. In this case, the specialized signature of the C function is\n+ * {@code (char*, int, int, int)} as the format string accepts three integer parameters.\n+ * We then need to use a {@linkplain Linker.Option#firstVariadicArg(int) linker option}\n+ * to specify the position of the first variadic layout in the provided function\n+ * descriptor (starting from 0). In this case, since the first parameter is the format\n+ * string (a non-variadic argument), the first variadic index needs to be set to 1, as\n+ * follows:\n@@ -490,1 +544,2 @@\n- *     int res = (int)printf.invokeExact(arena.allocateFrom(\"%d plus %d equals %d\"), 2, 2, 4); \/\/prints \"2 plus 2 equals 4\"\n+ *     \/\/prints \"2 plus 2 equals 4\"\n+ *     int res = (int)printf.invokeExact(arena.allocateFrom(\"%d plus %d equals %d\"), 2, 2, 4);\n@@ -496,5 +551,7 @@\n- * Creating a downcall method handle is intrinsically unsafe. A symbol in a foreign library does not, in general,\n- * contain enough signature information (e.g. arity and types of foreign function parameters). As a consequence,\n- * the linker runtime cannot validate linkage requests. When a client interacts with a downcall method handle obtained\n- * through an invalid linkage request (e.g. by specifying a function descriptor featuring too many argument layouts),\n- * the result of such interaction is unspecified and can lead to JVM crashes.\n+ * Creating a downcall method handle is intrinsically unsafe. A symbol in a foreign\n+ * library does not, in general, contain enough signature information (e.g. arity and\n+ * types of foreign function parameters). As a consequence, the linker runtime cannot\n+ * validate linkage requests. When a client interacts with a downcall method handle\n+ * obtained through an invalid linkage request (e.g. by specifying a function descriptor\n+ * featuring too many argument layouts), the result of such interaction is unspecified\n+ * and can lead to JVM crashes.\n@@ -502,6 +559,8 @@\n- * When an upcall stub is passed to a foreign function, a JVM crash might occur, if the foreign code casts the function pointer\n- * associated with the upcall stub to a type that is incompatible with the type of the upcall stub, and then attempts to\n- * invoke the function through the resulting function pointer. Moreover, if the method\n- * handle associated with an upcall stub returns a {@linkplain MemorySegment memory segment}, clients must ensure\n- * that this address cannot become invalid after the upcall completes. This can lead to unspecified behavior,\n- * and even JVM crashes, since an upcall is typically executed in the context of a downcall method handle invocation.\n+ * When an upcall stub is passed to a foreign function, a JVM crash might occur, if the\n+ * foreign code casts the function pointer associated with the upcall stub to a type that\n+ * is incompatible with the type of the upcall stub, and then attempts to invoke the\n+ * function through the resulting function pointer. Moreover, if the method handle\n+ * associated with an upcall stub returns a {@linkplain MemorySegment memory segment},\n+ * clients must ensure that this address cannot become invalid after the upcall\n+ * completes. This can lead to unspecified behavior, and even JVM crashes, since an\n+ * upcall is typically executed in the context of a downcall method handle invocation.\n@@ -510,1 +569,2 @@\n- * Implementations of this interface are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ * Implementations of this interface are immutable, thread-safe and\n+ * <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n@@ -517,2 +577,4 @@\n-     * {@return a linker for the ABI associated with the underlying native platform} The underlying native platform\n-     * is the combination of OS and processor where the Java runtime is currently executing.\n+     * {@return a linker for the ABI associated with the underlying native platform}\n+     * <p>\n+     * The underlying native platform is the combination of OS and processor where the\n+     * Java runtime is currently executing.\n@@ -520,6 +582,9 @@\n-     * @apiNote It is not currently possible to obtain a linker for a different combination of OS and processor.\n-     * @implSpec A native linker implementation is guaranteed to provide canonical layouts for\n-     * <a href=\"#describing-c-sigs\">basic C types<\/a>.\n-     * @implNote The libraries exposed by the {@linkplain #defaultLookup() default lookup} associated with the returned\n-     * linker are the native libraries loaded in the process where the Java runtime is currently executing. For example,\n-     * on Linux, these libraries typically include {@code libc}, {@code libm} and {@code libdl}.\n+     * @apiNote It is not currently possible to obtain a linker for a different\n+     *          combination of OS and processor.\n+     * @implSpec A native linker implementation is guaranteed to provide canonical\n+     *           layouts for <a href=\"#describing-c-sigs\">basic C types<\/a>.\n+     * @implNote The libraries exposed by the {@linkplain #defaultLookup() default lookup}\n+     *           associated with the returned linker are the native libraries loaded in\n+     *           the process where the Java runtime is currently executing. For example,\n+     *           on Linux, these libraries typically include {@code libc}, {@code libm}\n+     *           and {@code libdl}.\n@@ -532,1 +597,2 @@\n-     * Creates a method handle which is used to call a foreign function with the given signature and address.\n+     * Creates a method handle which is used to call a foreign function with the given\n+     * signature and address.\n@@ -539,9 +605,14 @@\n-     * @param address  the native memory segment whose {@linkplain MemorySegment#address() base address} is the\n-     *                 address of the target foreign function.\n-     * @param function the function descriptor of the target foreign function.\n-     * @param options  the linker options associated with this linkage request.\n-     * @return a downcall method handle.\n-     * @throws IllegalArgumentException if the provided function descriptor is not supported by this linker\n-     * @throws IllegalArgumentException if {@code !address.isNative()}, or if {@code address.equals(MemorySegment.NULL)}\n-     * @throws IllegalArgumentException if an invalid combination of linker options is given\n-     * @throws IllegalCallerException If the caller is in a module that does not have native access enabled\n+     * @param address  the native memory segment whose\n+     *                 {@linkplain MemorySegment#address() base address} is the address\n+     *                 of the target foreign function\n+     * @param function the function descriptor of the target foreign function\n+     * @param options  the linker options associated with this linkage request\n+     * @return a downcall method handle\n+     * @throws IllegalArgumentException if the provided function descriptor is not\n+     *         supported by this linker\n+     * @throws IllegalArgumentException if {@code !address.isNative()}, or if\n+     *         {@code address.equals(MemorySegment.NULL)}\n+     * @throws IllegalArgumentException if an invalid combination of linker options\n+     *         is given\n+     * @throws IllegalCallerException If the caller is in a module that does not have\n+     *         native access enabled\n@@ -556,1 +627,2 @@\n-     * Creates a method handle which is used to call a foreign function with the given signature.\n+     * Creates a method handle which is used to call a foreign function with the given\n+     * signature.\n@@ -558,6 +630,9 @@\n-     * The Java {@linkplain java.lang.invoke.MethodType method type} associated with the returned method handle is\n-     * {@linkplain FunctionDescriptor#toMethodType() derived} from the argument and return layouts in the function descriptor,\n-     * but features an additional leading parameter of type {@link MemorySegment}, from which the address of the target\n-     * foreign function is derived. Moreover, if the function descriptor's return layout is a group layout, the resulting\n-     * downcall method handle accepts an additional leading parameter of type {@link SegmentAllocator}, which is used by\n-     * the linker runtime to allocate the memory region associated with the struct returned by the downcall method handle.\n+     * The Java {@linkplain java.lang.invoke.MethodType method type} associated with the\n+     * returned method handle is {@linkplain FunctionDescriptor#toMethodType() derived}\n+     * from the argument and return layouts in the function descriptor, but features an\n+     * additional leading parameter of type {@link MemorySegment}, from which the address\n+     * of the target foreign function is derived. Moreover, if the function descriptor's\n+     * return layout is a group layout, the resulting downcall method handle accepts an\n+     * additional leading parameter of type {@link SegmentAllocator}, which is used by\n+     * the linker runtime to allocate the memory region associated with the struct\n+     * returned by the downcall method handle.\n@@ -565,2 +640,3 @@\n-     * Upon invoking a downcall method handle, the linker provides the following guarantees for any argument\n-     * {@code A} of type {@link MemorySegment} whose corresponding layout is an {@linkplain AddressLayout address layout}:\n+     * Upon invoking a downcall method handle, the linker provides the following\n+     * guarantees for any argument {@code A} of type {@link MemorySegment} whose\n+     * corresponding layout is an {@linkplain AddressLayout address layout}:\n@@ -568,6 +644,10 @@\n-     *     <li>{@code A.scope().isAlive() == true}. Otherwise, the invocation throws {@link IllegalStateException};<\/li>\n-     *     <li>The invocation occurs in a thread {@code T} such that {@code A.isAccessibleBy(T) == true}.\n-     *     Otherwise, the invocation throws {@link WrongThreadException}; and<\/li>\n-     *     <li>{@code A} is kept alive during the invocation. For instance, if {@code A} has been obtained using a\n-     *     {@linkplain Arena#ofShared() shared arena}, any attempt to {@linkplain Arena#close() close}\n-     *     the arena while the downcall method handle is still executing will result in an {@link IllegalStateException}.<\/li>\n+     *     <li>{@code A.scope().isAlive() == true}. Otherwise, the invocation\n+     *         throws {@link IllegalStateException};<\/li>\n+     *     <li>The invocation occurs in a thread {@code T} such that\n+     *         {@code A.isAccessibleBy(T) == true}.\n+     *         Otherwise, the invocation throws {@link WrongThreadException}; and<\/li>\n+     *     <li>{@code A} is kept alive during the invocation. For instance,\n+     *         if {@code A} has been obtained using a {@linkplain Arena#ofShared() shared arena},\n+     *         any attempt to {@linkplain Arena#close() close} the arena while the\n+     *         downcall method handle is still executing will result in an\n+     *         {@link IllegalStateException}.<\/li>\n@@ -576,5 +656,7 @@\n-     * Moreover, if the provided function descriptor's return layout is an {@linkplain AddressLayout address layout},\n-     * invoking the returned method handle will return a native segment associated with\n-     * the global scope. Under normal conditions, the size of the returned segment is {@code 0}.\n-     * However, if the function descriptor's return layout has a {@linkplain AddressLayout#targetLayout() target layout}\n-     * {@code T}, then the size of the returned segment is set to {@code T.byteSize()}.\n+     * Moreover, if the provided function descriptor's return layout is an\n+     * {@linkplain AddressLayout address layout}, invoking the returned method handle\n+     * will return a native segment associated with the global scope. Under normal\n+     * conditions, the size of the returned segment is {@code 0}. However, if the\n+     * function descriptor's return layout has a\n+     * {@linkplain AddressLayout#targetLayout() target layout} {@code T}, then the size\n+     * of the returned segment is set to {@code T.byteSize()}.\n@@ -582,8 +664,9 @@\n-     * The returned method handle will throw an {@link IllegalArgumentException} if the {@link MemorySegment}\n-     * representing the target address of the foreign function is the {@link MemorySegment#NULL} address. If an argument\n-     * is a {@link MemorySegment}, whose corresponding layout is a {@linkplain GroupLayout group layout}, the linker\n-     * might attempt to access the contents of the segment. As such, one of the exceptions specified by the\n-     * {@link MemorySegment#get(ValueLayout.OfByte, long)} or the\n-     * {@link MemorySegment#copy(MemorySegment, long, MemorySegment, long, long)} methods may be thrown.\n-     * The returned method handle will additionally throw {@link NullPointerException} if any argument\n-     * passed to it is {@code null}.\n+     * The returned method handle will throw an {@link IllegalArgumentException} if the\n+     * {@link MemorySegment} representing the target address of the foreign function is\n+     * the {@link MemorySegment#NULL} address. If an argument is a {@link MemorySegment},\n+     * whose corresponding layout is a {@linkplain GroupLayout group layout}, the linker\n+     * might attempt to access the contents of the segment. As such, one of the\n+     * exceptions specified by the {@link MemorySegment#get(ValueLayout.OfByte, long)} or\n+     * the {@link MemorySegment#copy(MemorySegment, long, MemorySegment, long, long)}\n+     * methods may be thrown. The returned method handle will additionally throw\n+     * {@link NullPointerException} if any argument passed to it is {@code null}.\n@@ -591,6 +674,9 @@\n-     * @param function the function descriptor of the target foreign function.\n-     * @param options  the linker options associated with this linkage request.\n-     * @return a downcall method handle.\n-     * @throws IllegalArgumentException if the provided function descriptor is not supported by this linker\n-     * @throws IllegalArgumentException if an invalid combination of linker options is given\n-     * @throws IllegalCallerException If the caller is in a module that does not have native access enabled\n+     * @param function the function descriptor of the target foreign function\n+     * @param options  the linker options associated with this linkage request\n+     * @return a downcall method handle\n+     * @throws IllegalArgumentException if the provided function descriptor is not\n+     *         supported by this linker\n+     * @throws IllegalArgumentException if an invalid combination of linker options\n+     *         is given\n+     * @throws IllegalCallerException If the caller is in a module that does not have\n+     *         native access enabled\n@@ -603,3 +689,4 @@\n-     * Creates an upcall stub which can be passed to other foreign functions as a function pointer, associated with the given\n-     * arena. Calling such a function pointer from foreign code will result in the execution of the provided\n-     * method handle.\n+     * Creates an upcall stub which can be passed to other foreign functions as a\n+     * function pointer, associated with the given arena. Calling such a function\n+     * pointer from foreign code will result in the execution of the provided method\n+     * handle.\n@@ -607,4 +694,5 @@\n-     * The returned memory segment's address points to the newly allocated upcall stub, and is associated with\n-     * the provided arena. As such, the lifetime of the returned upcall stub segment is controlled by the\n-     * provided arena. For instance, if the provided arena is a confined arena, the returned\n-     * upcall stub segment will be deallocated when the provided confined arena is {@linkplain Arena#close() closed}.\n+     * The returned memory segment's address points to the newly allocated upcall stub,\n+     * and is associated with the provided arena. As such, the lifetime of the returned\n+     * upcall stub segment is controlled by the provided arena. For instance, if the\n+     * provided arena is a confined arena, the returned upcall stub segment will be\n+     * deallocated when the provided confined arena is {@linkplain Arena#close() closed}.\n@@ -612,5 +700,6 @@\n-     * An upcall stub argument whose corresponding layout is an {@linkplain AddressLayout address layout}\n-     * is a native segment associated with the global scope.\n-     * Under normal conditions, the size of this segment argument is {@code 0}.\n-     * However, if the address layout has a {@linkplain AddressLayout#targetLayout() target layout} {@code T}, then the size of the\n-     * segment argument is set to {@code T.byteSize()}.\n+     * An upcall stub argument whose corresponding layout is an\n+     * {@linkplain AddressLayout address layout} is a native segment associated with the\n+     * global scope. Under normal conditions, the size of this segment argument is\n+     * {@code 0}. However, if the address layout has a\n+     * {@linkplain AddressLayout#targetLayout() target layout} {@code T}, then the size\n+     * of the segment argument is set to {@code T.byteSize()}.\n@@ -618,5 +707,7 @@\n-     * The target method handle should not throw any exceptions. If the target method handle does throw an exception,\n-     * the JVM will terminate abruptly. To avoid this, clients should wrap the code in the target method handle in a\n-     * try\/catch block to catch any unexpected exceptions. This can be done using the\n-     * {@link java.lang.invoke.MethodHandles#catchException(MethodHandle, Class, MethodHandle)} method handle combinator,\n-     * and handle exceptions as desired in the corresponding catch block.\n+     * The target method handle should not throw any exceptions. If the target method\n+     * handle does throw an exception, the JVM will terminate abruptly. To avoid this,\n+     * clients should wrap the code in the target method handle in a try\/catch block to\n+     * catch any unexpected exceptions. This can be done using the\n+     * {@link java.lang.invoke.MethodHandles#catchException(MethodHandle, Class, MethodHandle)}\n+     * method handle combinator, and handle exceptions as desired in the corresponding\n+     * catch block.\n@@ -624,9 +715,12 @@\n-     * @param target the target method handle.\n-     * @param function the upcall stub function descriptor.\n-     * @param arena the arena associated with the returned upcall stub segment.\n-     * @param options  the linker options associated with this linkage request.\n-     * @return a zero-length segment whose address is the address of the upcall stub.\n-     * @throws IllegalArgumentException if the provided function descriptor is not supported by this linker\n-     * @throws IllegalArgumentException if the type of {@code target} is incompatible with the\n-     *         type {@linkplain FunctionDescriptor#toMethodType() derived} from {@code function}\n-     * @throws IllegalArgumentException if it is determined that the target method handle can throw an exception\n+     * @param target the target method handle\n+     * @param function the upcall stub function descriptor\n+     * @param arena the arena associated with the returned upcall stub segment\n+     * @param options  the linker options associated with this linkage request\n+     * @return a zero-length segment whose address is the address of the upcall stub\n+     * @throws IllegalArgumentException if the provided function descriptor is not\n+     *         supported by this linker\n+     * @throws IllegalArgumentException if the type of {@code target} is incompatible\n+     *         with the type {@linkplain FunctionDescriptor#toMethodType() derived}\n+     *         from {@code function}\n+     * @throws IllegalArgumentException if it is determined that the target method handle\n+     *         can throw an exception\n@@ -634,3 +728,4 @@\n-     * @throws WrongThreadException if {@code arena} is a confined arena, and this method is called from a\n-     *         thread {@code T}, other than the arena's owner thread\n-     * @throws IllegalCallerException If the caller is in a module that does not have native access enabled\n+     * @throws WrongThreadException if {@code arena} is a confined arena, and this method\n+     *         is called from a thread {@code T}, other than the arena's owner thread\n+     * @throws IllegalCallerException If the caller is in a module that does not have\n+     *         native access enabled\n@@ -645,9 +740,16 @@\n-     * Each {@link Linker} is responsible for choosing libraries that are widely recognized as useful on the OS\n-     * and processor combination supported by the {@link Linker}. Accordingly, the precise set of symbols exposed by the\n-     * symbol lookup is unspecified; it varies from one {@link Linker} to another.\n-     * @implNote It is strongly recommended that the result of {@link #defaultLookup} exposes a set of symbols that is stable over time.\n-     * Clients of {@link #defaultLookup()} are likely to fail if a symbol that was previously exposed by the symbol lookup is no longer exposed.\n-     * <p>If an implementer provides {@link Linker} implementations for multiple OS and processor combinations, then it is strongly\n-     * recommended that the result of {@link #defaultLookup()} exposes, as much as possible, a consistent set of symbols\n-     * across all the OS and processor combinations.\n-     * @return a symbol lookup for symbols in a set of commonly used libraries.\n+     * Each {@link Linker} is responsible for choosing libraries that are widely\n+     * recognized as useful on the OS and processor combination supported by the\n+     * {@link Linker}. Accordingly, the precise set of symbols exposed by the symbol\n+     * lookup is unspecified; it varies from one {@link Linker} to another.\n+     *\n+     * @implNote It is strongly recommended that the result of {@link #defaultLookup}\n+     *           exposes a set of symbols that is stable over time. Clients of\n+     *           {@link #defaultLookup()} are likely to fail if a symbol that was\n+     *           previously exposed by the symbol lookup is no longer exposed.\n+     *           <p>If an implementer provides {@link Linker} implementations for\n+     *           multiple OS and processor combinations, then it is strongly\n+     *           recommended that the result of {@link #defaultLookup()} exposes, as much\n+     *           as possible, a consistent set of symbols across all the OS and processor\n+     *           combinations.\n+     *\n+     * @return a symbol lookup for symbols in a set of commonly used libraries\n@@ -658,2 +760,2 @@\n-     * {@return an unmodifiable mapping between the names of data types used by the ABI implemented by this linker and their\n-     * <em>canonical layouts<\/em>}\n+     * {@return an unmodifiable mapping between the names of data types used by the ABI\n+     *          implemented by this linker and their <em>canonical layouts<\/em>}\n@@ -661,9 +763,16 @@\n-     * Each {@link Linker} is responsible for choosing the data types that are widely recognized as useful on the OS\n-     * and processor combination supported by the {@link Linker}. Accordingly, the precise set of data type names\n-     * and canonical layouts exposed by the linker is unspecified; it varies from one {@link Linker} to another.\n-     * @implNote It is strongly recommended that the result of {@link #canonicalLayouts()} exposes a set of symbols that is stable over time.\n-     * Clients of {@link #canonicalLayouts()} are likely to fail if a data type that was previously exposed by the linker\n-     * is no longer exposed, or if its canonical layout is updated.\n-     * <p>If an implementer provides {@link Linker} implementations for multiple OS and processor combinations, then it is strongly\n-     * recommended that the result of {@link #canonicalLayouts()} exposes, as much as possible, a consistent set of symbols\n-     * across all the OS and processor combinations.\n+     * Each {@link Linker} is responsible for choosing the data types that are widely\n+     * recognized as useful on the OS and processor combination supported by the\n+     * {@link Linker}. Accordingly, the precise set of data type names and canonical\n+     * layouts exposed by the linker is unspecified; it varies from one {@link Linker} to\n+     * another.\n+     *\n+     * @implNote It is strongly recommended that the result of {@link #canonicalLayouts()}\n+     *           exposes a set of symbols that is stable over time. Clients of\n+     *           {@link #canonicalLayouts()} are likely to fail if a data type that was\n+     *           previously exposed by the linker is no longer exposed, or if its\n+     *           canonical layout is updated.\n+     *           <p>If an implementer provides {@link Linker} implementations for\n+     *           multiple OS and processor combinations, then it is strongly recommended\n+     *           that the result of {@link #canonicalLayouts()} exposes, as much as\n+     *           possible, a consistent set of symbols across all the OS and processor\n+     *           combinations.\n@@ -681,2 +790,3 @@\n-         * {@return a linker option used to denote the index indicating the start of the variadic arguments passed to the\n-         *          function described by the function descriptor associated with a downcall linkage request}\n+         * {@return a linker option used to denote the index indicating the start of the\n+         *          variadic arguments passed to the function described by the function\n+         *          descriptor associated with a downcall linkage request}\n@@ -684,2 +794,3 @@\n-         * The {@code index} value must conform to {@code 0 <= index <= N}, where {@code N} is the number of argument\n-         * layouts of the function descriptor used in conjunction with this linker option. When the {@code index} is:\n+         * The {@code index} value must conform to {@code 0 <= index <= N}, where\n+         * {@code N} is the number of argument layouts of the function descriptor used in\n+         * conjunction with this linker option. When the {@code index} is:\n@@ -687,3 +798,6 @@\n-         * <li>{@code 0}, all arguments passed to the function are passed as variadic arguments<\/li>\n-         * <li>{@code N}, none of the arguments passed to the function are passed as variadic arguments<\/li>\n-         * <li>{@code n}, where {@code 0 < m < N}, the arguments {@code m..N} are passed as variadic arguments<\/li>\n+         * <li>{@code 0}, all arguments passed to the function are passed as variadic\n+         *     arguments<\/li>\n+         * <li>{@code N}, none of the arguments passed to the function are passed as\n+         *     variadic arguments<\/li>\n+         * <li>{@code n}, where {@code 0 < m < N}, the arguments {@code m..N} are passed\n+         *     as variadic arguments<\/li>\n@@ -691,3 +805,4 @@\n-         * It is important to always use this linker option when linking a <a href=Linker.html#variadic-funcs>variadic\n-         * function<\/a>, even if no variadic argument is passed (the second case in the list\n-         * above), as this might still affect the calling convention on certain platforms.\n+         * It is important to always use this linker option when linking a\n+         * <a href=Linker.html#variadic-funcs>variadic function<\/a>, even if no variadic\n+         * argument is passed (the second case in the list above), as this might still\n+         * affect the calling convention on certain platforms.\n@@ -695,2 +810,3 @@\n-         * @implNote The index value is validated when making a linkage request, which is when the function descriptor\n-         *           against which the index is validated is available.\n+         * @implNote The index value is validated when making a linkage request, which is\n+         *           when the function descriptor against which the index is validated is\n+         *           available.\n@@ -698,2 +814,2 @@\n-         * @param index the index of the first variadic argument layout in the function descriptor associated\n-         *              with a downcall linkage request.\n+         * @param index the index of the first variadic argument layout in the function\n+         *             descriptor associated with a downcall linkage request\n@@ -706,3 +822,4 @@\n-         * {@return a linker option used to save portions of the execution state immediately after\n-         *          calling a foreign function associated with a downcall method handle,\n-         *          before it can be overwritten by the Java runtime, or read through conventional means}\n+         * {@return a linker option used to save portions of the execution state\n+         *          immediately after calling a foreign function associated with a\n+         *          downcall method handle, before it can be overwritten by the Java\n+         *          runtime, or read through conventional means}\n@@ -710,7 +827,7 @@\n-         * Execution state is captured by a downcall method handle on invocation, by writing it\n-         * to a native segment provided by the user to the downcall method handle.\n-         * For this purpose, a downcall method handle linked with this\n-         * option will feature an additional {@link MemorySegment} parameter directly\n-         * following the target address, and optional {@link SegmentAllocator} parameters.\n-         * This parameter, the <em>capture state segment<\/em>, represents the native segment into which\n-         * the captured state is written.\n+         * Execution state is captured by a downcall method handle on invocation, by\n+         * writing it to a native segment provided by the user to the downcall method\n+         * handle. For this purpose, a downcall method handle linked with this option\n+         * will feature an additional {@link MemorySegment} parameter directly following\n+         * the target address, and optional {@link SegmentAllocator} parameters. This\n+         * parameter, the <em>capture state segment<\/em>, represents the native segment\n+         * into which the captured state is written.\n@@ -718,3 +835,3 @@\n-         * The capture state segment must have size and alignment compatible with the layout returned by\n-         * {@linkplain #captureStateLayout}. This layout is a struct layout which has a named field for\n-         * each captured value.\n+         * The capture state segment must have size and alignment compatible with the\n+         * layout returned by {@linkplain #captureStateLayout}. This layout is a struct\n+         * layout which has a named field for each captured value.\n@@ -722,2 +839,2 @@\n-         * Captured state can be retrieved from the capture state segment by constructing var handles\n-         * from the {@linkplain #captureStateLayout capture state layout}.\n+         * Captured state can be retrieved from the capture state segment by constructing\n+         * var handles from the {@linkplain #captureStateLayout capture state layout}.\n@@ -743,3 +860,3 @@\n-         * @param capturedState the names of the values to save.\n-         * @throws IllegalArgumentException if at least one of the provided {@code capturedState} names\n-         *         is unsupported on the current platform\n+         * @param capturedState the names of the values to save\n+         * @throws IllegalArgumentException if at least one of the provided\n+         *         {@code capturedState} names is unsupported on the current platform\n@@ -757,2 +874,3 @@\n-         * {@return a struct layout that represents the layout of the capture state segment that is passed\n-         *          to a downcall handle linked with {@link #captureCallState(String...)}}\n+         * {@return a struct layout that represents the layout of the capture state\n+          *         segment that is passedto a downcall handle linked with\n+          *         {@link #captureCallState(String...)}}\n@@ -787,2 +905,3 @@\n-         * A critical function is a function that has an extremely short running time in all cases\n-         * (similar to calling an empty function), and does not call back into Java (e.g. using an upcall stub).\n+         * A critical function is a function that has an extremely short running time in\n+         * all cases (similar to calling an empty function), and does not call back into\n+         * Java (e.g. using an upcall stub).\n@@ -793,2 +912,2 @@\n-         * Using this linker option when linking non-critical functions is likely to have adverse effects,\n-         * such as loss of performance, or JVM crashes.\n+         * Using this linker option when linking non-critical functions is likely to have\n+         * adverse effects, such as loss of performance, or JVM crashes.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":418,"deletions":299,"binary":false,"changes":717,"status":"modified"},{"patch":"@@ -46,6 +46,9 @@\n- * There are two leaves in the layout hierarchy, {@linkplain ValueLayout value layouts}, which are used to represent values of given size and kind\n- * and {@linkplain PaddingLayout padding layouts} which are used, as the name suggests, to represent a portion of a memory\n- * segment whose contents should be ignored, and which are primarily present for alignment reasons.\n- * Some common value layout constants, such as {@link ValueLayout#JAVA_INT} and {@link ValueLayout#JAVA_FLOAT_UNALIGNED}\n- * are defined in the {@link ValueLayout} class. A special kind of value layout, namely an {@linkplain AddressLayout address layout},\n- * is used to model values that denote the address of a region of memory.\n+ * There are two leaves in the layout hierarchy, {@linkplain ValueLayout value layouts},\n+ * which are used to represent values of given size and kind and\n+ * {@linkplain PaddingLayout padding layouts} which are used, as the name suggests, to\n+ * represent a portion of a memory segment whose contents should be ignored, and which\n+ * are primarily present for alignment reasons. Some common value layout constants, such\n+ * as {@link ValueLayout#JAVA_INT} and {@link ValueLayout#JAVA_FLOAT_UNALIGNED} are\n+ * defined in the {@link ValueLayout} class. A special kind of value layout, namely an\n+ * {@linkplain AddressLayout address layout}, is used to model values that denote the\n+ * address of a region of memory.\n@@ -53,5 +56,7 @@\n- * More complex layouts can be derived from simpler ones: a {@linkplain SequenceLayout sequence layout} denotes a\n- * homogeneous repetition of zero or more occurrences of an element layout; a {@linkplain GroupLayout group layout}\n- * denotes a heterogeneous aggregation of zero or more member layouts. Group layouts come in two\n- * flavors: {@linkplain StructLayout struct layouts}, where member layouts are laid out one after the other, and\n- * {@linkplain UnionLayout union layouts} where member layouts are laid out at the same starting offset.\n+ * More complex layouts can be derived from simpler ones: a\n+ * {@linkplain SequenceLayout sequence layout} denotes a homogeneous repetition of zero\n+ * or more occurrences of an element layout; a {@linkplain GroupLayout group layout}\n+ * denotes a heterogeneous aggregation of zero or more member layouts. Group layouts\n+ * come in two flavors: {@linkplain StructLayout struct layouts}, where member layouts\n+ * are laid out one after the other, and {@linkplain UnionLayout union layouts} where\n+ * member layouts are laid out at the same starting offset.\n@@ -59,2 +64,2 @@\n- * Layouts can be optionally associated with a <em>name<\/em>. A layout name can be referred to when\n- * constructing <a href=\"MemoryLayout.html#layout-paths\"><em>layout paths<\/em><\/a>.\n+ * Layouts can be optionally associated with a <em>name<\/em>. A layout name can be\n+ * referred to when constructing <a href=\"MemoryLayout.html#layout-paths\"><em>layout paths<\/em><\/a>.\n@@ -88,10 +93,14 @@\n- *     associated with the value layout. That is, the constant {@link ValueLayout#JAVA_INT} has carrier {@code int}, and\n- *     size of 4 bytes;<\/li>\n- *     <li>The size of an address layout is platform-dependent. That is, the constant {@link ValueLayout#ADDRESS}\n- *     has size of 8 bytes on a 64-bit platform;<\/li>\n- *     <li>The size of a padding layout is always provided explicitly, on {@linkplain MemoryLayout#paddingLayout(long) construction};<\/li>\n- *     <li>The size of a sequence layout whose element layout is <em>E<\/em> and element count is <em>L<\/em>,\n- *     is the size of <em>E<\/em>, multiplied by <em>L<\/em>;<\/li>\n- *     <li>The size of a struct layout with member layouts <em>M1<\/em>, <em>M2<\/em>, ... <em>Mn<\/em> whose sizes are\n- *     <em>S1<\/em>, <em>S2<\/em>, ... <em>Sn<\/em>, respectively, is <em>S1 + S2 + ... + Sn<\/em>;<\/li>\n- *     <li>The size of a union layout <em>U<\/em> with member layouts <em>M1<\/em>, <em>M2<\/em>, ... <em>Mn<\/em> whose sizes are\n+ *     associated with the value layout. That is, the constant {@link ValueLayout#JAVA_INT}\n+ *     has carrier {@code int}, and size of 4 bytes;<\/li>\n+ *     <li>The size of an address layout is platform-dependent. That is, the constant\n+ *     {@link ValueLayout#ADDRESS} has size of 8 bytes on a 64-bit platform;<\/li>\n+ *     <li>The size of a padding layout is always provided explicitly, on\n+ *     {@linkplain MemoryLayout#paddingLayout(long) construction};<\/li>\n+ *     <li>The size of a sequence layout whose element layout is <em>E<\/em>\n+ *     and element count is <em>L<\/em>, is the size of <em>E<\/em>, multiplied by\n+ *     <em>L<\/em>;<\/li>\n+ *     <li>The size of a struct layout with member layouts <em>M1<\/em>, <em>M2<\/em>, ... <em>Mn<\/em>\n+ *     whose sizes are <em>S1<\/em>, <em>S2<\/em>, ... <em>Sn<\/em>, respectively, is\n+ *     <em>S1 + S2 + ... + Sn<\/em>;<\/li>\n+ *     <li>The size of a union layout <em>U<\/em> with member layouts\n+ *     <em>M1<\/em>, <em>M2<\/em>, ... <em>Mn<\/em> whose sizes are\n@@ -101,1 +110,2 @@\n- * Furthermore, all layouts have a <em>natural alignment<\/em> (expressed in bytes) which is defined as follows:\n+ * Furthermore, all layouts have a <em>natural alignment<\/em> (expressed in bytes) which\n+ * is defined as follows:\n@@ -104,4 +114,7 @@\n- *     <li>The natural alignment of a value layout whose size is <em>N<\/em> is <em>N<\/em>;<\/li>\n- *     <li>The natural alignment of a sequence layout whose element layout is <em>E<\/em> is the alignment of <em>E<\/em>;<\/li>\n- *     <li>The natural alignment of a group layout with member layouts <em>M1<\/em>, <em>M2<\/em>, ... <em>Mn<\/em> whose\n- *     alignments are <em>A1<\/em>, <em>A2<\/em>, ... <em>An<\/em>, respectively, is <em>max(A1, A2 ... An)<\/em>.<\/li>\n+ *     <li>The natural alignment of a value layout whose size is <em>N<\/em> is\n+ *     <em>N<\/em>;<\/li>\n+ *     <li>The natural alignment of a sequence layout whose element layout is\n+ *     <em>E<\/em> is the alignment of <em>E<\/em>;<\/li>\n+ *     <li>The natural alignment of a group layout with member layouts\n+ *     <em>M1<\/em>, <em>M2<\/em>, ... <em>Mn<\/em> whose alignments are\n+ *     <em>A1<\/em>, <em>A2<\/em>, ... <em>An<\/em>, respectively, is <em>max(A1, A2 ... An)<\/em>.<\/li>\n@@ -109,1 +122,2 @@\n- * A layout's alignment can be overridden if needed (see {@link MemoryLayout#withByteAlignment(long)}), which can be useful to describe\n+ * A layout's alignment can be overridden if needed\n+ * (see {@link MemoryLayout#withByteAlignment(long)}), which can be useful to describe\n@@ -114,3 +128,4 @@\n- * A <em>layout path<\/em> is used to unambiguously select a layout that is nested in some other layout.\n- * Layout paths are typically expressed as a sequence of one or more {@linkplain PathElement path elements}.\n- * (A more formal definition of layout paths is provided <a href=\"#well-formedness\">below<\/a>).\n+ * A <em>layout path<\/em> is used to unambiguously select a layout that is nested in some\n+ * other layout. Layout paths are typically expressed as a sequence of one or more\n+ * {@linkplain PathElement path elements}. (A more formal definition of layout paths is\n+ * provided <a href=\"#well-formedness\">below<\/a>).\n@@ -120,3 +135,4 @@\n- *     <li>obtain {@linkplain MemoryLayout#byteOffset(PathElement...) offsets} of arbitrarily nested layouts;<\/li>\n- *     <li>obtain a {@linkplain #varHandle(PathElement...) var handle} that can be used to access the value corresponding\n- *     to the selected layout;<\/li>\n+ *     <li>obtain {@linkplain MemoryLayout#byteOffset(PathElement...) offsets} of\n+ *     arbitrarily nested layouts;<\/li>\n+ *     <li>obtain a {@linkplain #varHandle(PathElement...) var handle} that can be used\n+ *     to access the value corresponding to the selected layout;<\/li>\n@@ -126,2 +142,3 @@\n- * For instance, given the {@code taggedValues} sequence layout constructed above, we can obtain the offset,\n- * in bytes, of the member layout named <code>value<\/code> in the <em>first<\/em> sequence element, as follows:\n+ * For instance, given the {@code taggedValues} sequence layout constructed above, we can\n+ * obtain the offset, in bytes, of the member layout named <code>value<\/code> in the\n+ * <em>first<\/em> sequence element, as follows:\n@@ -141,5 +158,7 @@\n- * Some layout path elements, said <em>open path elements<\/em>, can select multiple layouts at once. For instance,\n- * the open path elements {@link PathElement#sequenceElement()}, {@link PathElement#sequenceElement(long, long)} select\n- * an unspecified element in a sequence layout. A var handle derived from a layout path containing one or more\n- * open path element features additional coordinates of type {@code long}, which can be used by clients to <em>bind<\/em>\n- * the open elements in the path:\n+ * Some layout path elements, said <em>open path elements<\/em>, can select multiple\n+ * layouts at once. For instance, the open path elements\n+ * {@link PathElement#sequenceElement()}, {@link PathElement#sequenceElement(long, long)}\n+ * select an unspecified element in a sequence layout. A var handle derived from a\n+ * layout path containing one or more open path element features additional coordinates\n+ * of type {@code long}, which can be used by clients to <em>bind<\/em> the open elements\n+ * in the path:\n@@ -159,3 +178,4 @@\n- * {@linkplain #byteOffsetHandle(PathElement...) offset-computing method handles}. Each open path element becomes\n- * an additional {@code long} parameter in the obtained method handle. This parameter can be used to specify the index\n- * of the sequence element whose offset is to be computed:\n+ * {@linkplain #byteOffsetHandle(PathElement...) offset-computing method handles}. Each\n+ * open path element becomes an additional {@code long} parameter in the obtained method\n+ * handle. This parameter can be used to specify the index of the sequence element whose\n+ * offset is to be computed:\n@@ -172,2 +192,2 @@\n- * A special kind of path element, called <em>dereference path element<\/em>, allows var handles obtained from\n- * memory layouts to follow pointers. Consider the following layout:\n+ * A special kind of path element, called <em>dereference path element<\/em>, allows var\n+ * handles obtained from memory layouts to follow pointers. Consider the following layout:\n@@ -188,4 +208,6 @@\n- * This layout is a struct layout which describe a rectangle. It contains a single field, namely {@code points},\n- * an address layout whose {@linkplain AddressLayout#targetLayout() target layout} is a sequence layout of four\n- * struct layouts. Each struct layout describes a two-dimensional point, and is defined as a pair or\n- * {@link ValueLayout#JAVA_INT} coordinates, with names {@code x} and {@code y}, respectively.\n+ * This layout is a struct layout which describe a rectangle. It contains a single field,\n+ * namely {@code points}, an address layout whose\n+ * {@linkplain AddressLayout#targetLayout() target layout} is a sequence layout of four\n+ * struct layouts. Each struct layout describes a two-dimensional point, and is defined\n+ * as a pair or {@link ValueLayout#JAVA_INT} coordinates, with names {@code x} and\n+ * {@code y}, respectively.\n@@ -193,2 +215,2 @@\n- * With dereference path elements, we can obtain a var handle which accesses the {@code y} coordinate of one of the\n- * point in the rectangle, as follows:\n+ * With dereference path elements, we can obtain a var handle which accesses the\n+ * {@code y} coordinate of one of the point in the rectangle, as follows:\n@@ -213,5 +235,7 @@\n- * A layout path is applied to a layout {@code C_0}, also called the <em>initial layout<\/em>. Each path element in a\n- * layout path can be thought of as a function which updates the current layout {@code C_i-1} to some other layout\n- * {@code C_i}. That is, for each path element {@code E1, E2, ... En}, in a layout path {@code P}, we compute\n- * {@code C_i = f_i(C_i-1)}, where {@code f_i} is the selection function associated with the path element under consideration,\n- * denoted as {@code E_i}. The final layout {@code C_i} is also called the <em>selected layout<\/em>.\n+ * A layout path is applied to a layout {@code C_0}, also called the\n+ * <em>initial layout<\/em>. Each path element in a layout path can be thought of as a\n+ * function which updates the current layout {@code C_i-1} to some other layout\n+ * {@code C_i}. That is, for each path element {@code E1, E2, ... En}, in a layout path\n+ * {@code P}, we compute {@code C_i = f_i(C_i-1)}, where {@code f_i} is the selection\n+ * function associated with the path element under consideration, denoted as {@code E_i}.\n+ * The final layout {@code C_i} is also called the <em>selected layout<\/em>.\n@@ -219,3 +243,4 @@\n- * A layout path {@code P} is considered well-formed for an initial layout {@code C_0} if all its path elements\n- * {@code E1, E2, ... En} are well-formed for their corresponding input layouts {@code C_0, C_1, ... C_n-1}.\n- * A path element {@code E} is considered well-formed for a layout {@code L} if any of the following is true:\n+ * A layout path {@code P} is considered well-formed for an initial layout {@code C_0}\n+ * if all its path elements {@code E1, E2, ... En} are well-formed for their\n+ * corresponding input layouts {@code C_0, C_1, ... C_n-1}. A path element {@code E} is\n+ * considered well-formed for a layout {@code L} if any of the following is true:\n@@ -223,5 +248,8 @@\n- * <li>{@code L} is a sequence layout and {@code E} is a sequence path element (one of {@link PathElement#sequenceElement(long)},\n- * {@link PathElement#sequenceElement(long, long)} or {@link PathElement#sequenceElement()}). Moreover, if {@code E}\n- * contains one or more sequence indices, such indices have to be compatible with the sequence layout's element count;<\/li>\n- * <li>{@code L} is a group layout and {@code E} is a group path element (one of {@link PathElement#groupElement(String)}\n- * or {@link PathElement#groupElement(long)}). Moreover, the group path element must refer to a valid member layout in\n+ * <li>{@code L} is a sequence layout and {@code E} is a sequence path element\n+ * (one of {@link PathElement#sequenceElement(long)}, {@link PathElement#sequenceElement(long, long)}\n+ * or {@link PathElement#sequenceElement()}). Moreover, if {@code E} contains one or\n+ * more sequence indices, such indices have to be compatible with the sequence layout's\n+ * element count;<\/li>\n+ * <li>{@code L} is a group layout and {@code E} is a group path element (one of\n+ * {@link PathElement#groupElement(String)} or {@link PathElement#groupElement(long)}).\n+ * Moreover, the group path element must refer to a valid member layout in\n@@ -229,1 +257,2 @@\n- * <li>{@code L} is an address layout and {@code E} is a {@linkplain PathElement#dereferenceElement() dereference path element}.\n+ * <li>{@code L} is an address layout and {@code E} is a {@linkplain PathElement#dereferenceElement()\n+ * dereference path element}.\n@@ -232,2 +261,2 @@\n- * Any attempt to provide a layout path {@code P} that is not well-formed for an initial layout {@code C_0} will result\n- * in an {@link IllegalArgumentException}.\n+ * Any attempt to provide a layout path {@code P} that is not well-formed for an initial\n+ * layout {@code C_0} will result in an {@link IllegalArgumentException}.\n@@ -237,2 +266,3 @@\n- * A var handle returned by {@link #varHandle(PathElement...)} or {@link ValueLayout#varHandle()} features certain\n- * access characteristics, which are derived from the selected layout {@code L}:\n+ * A var handle returned by {@link #varHandle(PathElement...)} or\n+ * {@link ValueLayout#varHandle()} features certain access characteristics, which are\n+ * derived from the selected layout {@code L}:\n@@ -244,3 +274,5 @@\n- * Depending on the above characteristics, the returned var handle might feature certain <i>access mode restrictions<\/i>.\n- * We say that a var handle is <em>aligned<\/em> if its alignment constraint {@code A} is compatible with the access size\n- * {@code S}, that is if {@code A >= S}. An aligned var handle is guaranteed to support the following access modes:\n+ * Depending on the above characteristics, the returned var handle might feature certain\n+ * <i>access mode restrictions<\/i>. We say that a var handle is <em>aligned<\/em> if its\n+ * alignment constraint {@code A} is compatible with the access size {@code S}, that is\n+ * if {@code A >= S}. An aligned var handle is guaranteed to support the following\n+ * access modes:\n@@ -263,2 +295,3 @@\n- * If {@code T} is {@code float}, {@code double} or {@link MemorySegment} then atomic update access modes compare\n- * values using their bitwise representation (see {@link Float#floatToRawIntBits}, {@link Double#doubleToRawLongBits}\n+ * If {@code T} is {@code float}, {@code double} or {@link MemorySegment} then atomic\n+ * update access modes compare values using their bitwise representation\n+ * (see {@link Float#floatToRawIntBits}, {@link Double#doubleToRawLongBits}\n@@ -267,4 +300,6 @@\n- * Alternatively, a var handle is <em>unaligned<\/em> if its alignment constraint {@code A} is incompatible with the\n- * access size {@code S}, that is, if {@code A < S}. An unaligned var handle only supports the {@code get} and {@code set}\n- * access modes. All other access modes will result in {@link UnsupportedOperationException} being thrown. Moreover,\n- * while supported, access modes {@code get} and {@code set} might lead to word tearing.\n+ * Alternatively, a var handle is <em>unaligned<\/em> if its alignment constraint {@code A}\n+ * is incompatible with the access size {@code S}, that is, if {@code A < S}. An\n+ * unaligned var handle only supports the {@code get} and {@code set} access modes. All\n+ * other access modes will result in {@link UnsupportedOperationException} being thrown.\n+ * Moreover, while supported, access modes {@code get} and {@code set} might lead to\n+ * word tearing.\n@@ -274,2 +309,3 @@\n- * We have seen how sequence layouts are used to describe the contents of an array whose size is known <em>statically<\/em>.\n- * There are cases, however, where the array size is only known <em>dynamically<\/em>. We call such arrays <em>variable-length arrays<\/em>.\n+ * We have seen how sequence layouts are used to describe the contents of an array whose\n+ * size is known <em>statically<\/em>. There are cases, however, where the array size is\n+ * only known <em>dynamically<\/em>. We call such arrays <em>variable-length arrays<\/em>.\n@@ -278,2 +314,4 @@\n- *     <li>a <em>toplevel<\/em> variable-length array whose size depends on the value of some unrelated variable, or parameter;<\/li>\n- *     <li>an variable-length array <em>nested<\/em> in a struct, whose size depends on the value of some other field in the enclosing struct.<\/li>\n+ *     <li>a <em>toplevel<\/em> variable-length array whose size depends on the value of\n+ *     some unrelated variable, or parameter;<\/li>\n+ *     <li>an variable-length array <em>nested<\/em> in a struct, whose size depends on\n+ *     the value of some other field in the enclosing struct.<\/li>\n@@ -281,2 +319,3 @@\n- * While variable-length arrays cannot be modelled directly using sequence layouts, clients can still enjoy structured\n- * access to elements of variable-length arrays using var handles as demonstrated in the following sections.\n+ * While variable-length arrays cannot be modelled directly using sequence layouts,\n+ * clients can still enjoy structured access to elements of variable-length arrays using\n+ * var handles as demonstrated in the following sections.\n@@ -295,2 +334,2 @@\n- * In the above code, a point is modelled as two coordinates ({@code x} and {@code y} respectively). Now consider\n- * the following snippet of C code:\n+ * In the above code, a point is modelled as two coordinates ({@code x} and {@code y}\n+ * respectively). Now consider the following snippet of C code:\n@@ -306,2 +345,3 @@\n- * Here, we allocate an array of point ({@code points}). Crucially, the size of the array is dynamically bound to the value\n- * of the {@code size} variable. Inside the loop, the {@code x} coordinate of all the points in the array is accessed.\n+ * Here, we allocate an array of point ({@code points}). Crucially, the size of the array\n+ * is dynamically bound to the value of the {@code size} variable. Inside the loop, the\n+ * {@code x} coordinate of all the points in the array is accessed.\n@@ -309,1 +349,2 @@\n- * To model this code in Java, let's start by defining a layout for the {@code Point} struct, as follows:\n+ * To model this code in Java, let's start by defining a layout for the {@code Point}\n+ * struct, as follows:\n@@ -318,4 +359,6 @@\n- * Since we know we need to create and access an array of points, it would be tempting to create a sequence layout modelling\n- * the variable-length array, and then derive the necessary access var handles from the sequence layout. But this approach\n- * is problematic, as the size of the variable-length array is not known. Instead, a var handle that provides structured\n- * access to the elements of a variable-length array can be obtained directly from the layout describing the array elements\n+ * Since we know we need to create and access an array of points, it would be tempting to\n+ * create a sequence layout modelling the variable-length array, and then derive the\n+ * necessary access var handles from the sequence layout. But this approach is\n+ * problematic, as the size of the variable-length array is not known. Instead, a\n+ * var handle that provides structured access to the elements of a variable-length array\n+ * can be obtained directly from the layout describing the array elements\n@@ -334,4 +377,6 @@\n- * Here, the coordinate {@code x} of subsequent point in the array is accessed using the {@code POINT_ARR_X} var\n- * handle, which is obtained using the {@link #arrayElementVarHandle(PathElement...)} method. This var handle\n- * features two {@code long} coordinates: the first is a base offset (set to {@code 0L}), while the\n- * second is a logical index that can be used to stride over all the elements of the point array.\n+ * Here, the coordinate {@code x} of subsequent point in the array is accessed using the\n+ * {@code POINT_ARR_X} var handle, which is obtained using the\n+ * {@link #arrayElementVarHandle(PathElement...)} method. This var handle features two\n+ * {@code long} coordinates: the first is a base offset (set to {@code 0L}), while the\n+ * second is a logical index that can be used to stride over all the elements of the\n+ * point array.\n@@ -339,4 +384,6 @@\n- * The base offset coordinate allows clients to express complex access operations, by injecting additional offset\n- * computation into the var handle (we will see an example of that below). In cases where the base offset is constant\n- * (as in the previous example) clients can, if desired, drop the base offset parameter and make the access expression\n- * simpler. This is achieved using the {@link java.lang.invoke.MethodHandles#insertCoordinates(VarHandle, int, Object...)}\n+ * The base offset coordinate allows clients to express complex access operations, by\n+ * injecting additional offset computation into the var handle (we will see an example\n+ * of that below). In cases where the base offset is constant (as in the previous\n+ * example) clients can, if desired, drop the base offset parameter and make the access\n+ * expression simpler. This is achieved using the\n+ * {@link java.lang.invoke.MethodHandles#insertCoordinates(VarHandle, int, Object...)}\n@@ -356,4 +403,5 @@\n- * In the above code, a polygon is modelled as a size (the number of edges in the polygon) and an array of points\n- * (one for each vertex in the polygon). The number of vertices depends on the number of edges in the polygon. As such,\n- * the size of the {@code points} array is left <em>unspecified<\/em> in the C declaration, using a <em>Flexible Array Member<\/em>\n- * (a feature standardized in C99).\n+ * In the above code, a polygon is modelled as a size (the number of edges in the polygon)\n+ * and an array of points (one for each vertex in the polygon). The number of vertices\n+ * depends on the number of edges in the polygon. As such, the size of the\n+ * {@code points} array is left <em>unspecified<\/em> in the C declaration, using a\n+ * <em>Flexible Array Member<\/em> (a feature standardized in C99).\n@@ -361,2 +409,3 @@\n- * Again, clients can perform structured access to elements in the nested variable-length array using the\n- * {@link #arrayElementVarHandle(PathElement...)} method, as demonstrated below:\n+ * Again, clients can perform structured access to elements in the nested variable-length\n+ * array using the {@link #arrayElementVarHandle(PathElement...)} method, as demonstrated\n+ * below:\n@@ -374,4 +423,5 @@\n- * The {@code POLYGON} layout contains a sequence layout of size <em>zero<\/em>. The element layout of the sequence layout\n- * is the {@code POINT} layout, shown previously. The polygon layout is used to obtain a var handle\n- * that provides access to the polygon size, as well as an offset ({@code POINTS_OFFSET}) to the start of the\n- * variable-length {@code points} array.\n+ * The {@code POLYGON} layout contains a sequence layout of size <em>zero<\/em>. The\n+ * element layout of the sequence layout is the {@code POINT} layout, shown previously.\n+ * The polygon layout is used to obtain a var handle that provides access to the polygon\n+ * size, as well as an offset ({@code POINTS_OFFSET}) to the start of the variable-length\n+ * {@code points} array.\n@@ -379,1 +429,2 @@\n- * The {@code x} coordinates of all the points in a polygon can then be accessed as follows:\n+ * The {@code x} coordinates of all the points in a polygon can then be accessed as\n+ * follows:\n@@ -387,5 +438,6 @@\n- * Here, we first obtain the polygon size, using the {@code POLYGON_SIZE} var handle. Then, in a loop, we read\n- * the {@code x} coordinates of all the points in the polygon. This is done by providing a custom offset\n- * (namely, {@code POINTS_OFFSET}) to the offset coordinate of the {@code POINT_ARR_X} var handle. As before,\n- * the loop induction variable {@code i} is passed as the index of the {@code POINT_ARR_X} var handle,\n- * to stride over all the elements of the variable-length array.\n+ * Here, we first obtain the polygon size, using the {@code POLYGON_SIZE} var handle.\n+ * Then, in a loop, we read the {@code x} coordinates of all the points in the polygon.\n+ * This is done by providing a custom offset (namely, {@code POINTS_OFFSET}) to the\n+ * offset coordinate of the {@code POINT_ARR_X} var handle. As before, the loop\n+ * induction variable {@code i} is passed as the index of the {@code POINT_ARR_X}\n+ * var handle, to stride over all the elements of the variable-length array.\n@@ -394,1 +446,2 @@\n- * Implementations of this interface are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ * Implementations of this interface are immutable, thread-safe and\n+ * <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n@@ -413,1 +466,2 @@\n-     * {@return a memory layout with the same characteristics as this layout, but with the given name}\n+     * {@return a memory layout with the same characteristics as this layout, but with\n+     *          the given name}\n@@ -415,1 +469,1 @@\n-     * @param name the layout name.\n+     * @param name the layout name\n@@ -421,1 +475,2 @@\n-     * {@return a memory layout with the same characteristics as this layout, but with no name}\n+     * {@return a memory layout with the same characteristics as this layout, but with\n+     *          no name}\n@@ -423,1 +478,2 @@\n-     * @apiNote This can be useful to compare two layouts that have different names, but are otherwise equal.\n+     * @apiNote This can be useful to compare two layouts that have different names, but\n+     *          are otherwise equal.\n@@ -429,3 +485,5 @@\n-     * {@return the alignment constraint associated with this layout, expressed in bytes} Layout alignment defines a power\n-     * of two {@code A} which is the byte-wise alignment of the layout, where {@code A} is the number of bytes that must be aligned\n-     * for any pointer that correctly points to this layout. Thus:\n+     * {@return the alignment constraint associated with this layout, expressed in bytes}\n+     * <p>\n+     * Layout alignment defines a power of two {@code A} which is the byte-wise alignment\n+     * of the layout, where {@code A} is the number of bytes that must be aligned for any\n+     * pointer that correctly points to this layout. Thus:\n@@ -435,2 +493,4 @@\n-     * <li>{@code A=8} means word aligned (on LP64), {@code A=4} int aligned, {@code A=2} short aligned, etc.<\/li>\n-     * <li>{@code A=64} is the most strict alignment required by the x86\/SV ABI (for AVX-512 data).<\/li>\n+     * <li>{@code A=8} means word aligned (on LP64), {@code A=4} int aligned,\n+     * {@code A=2} short aligned, etc.<\/li>\n+     * <li>{@code A=64} is the most strict alignment required by the x86\/SV ABI\n+     * (for AVX-512 data).<\/li>\n@@ -439,2 +499,4 @@\n-     * If no explicit alignment constraint was set on this layout (see {@link #withByteAlignment(long)}),\n-     * then this method returns the <a href=\"#layout-align\">natural alignment<\/a> constraint (in bytes) associated with this layout.\n+     * If no explicit alignment constraint was set on this layout (\n+     * see {@link #withByteAlignment(long)}), then this method returns the\n+     * <a href=\"#layout-align\">natural alignment<\/a> constraint (in bytes) associated\n+     * with this layout.\n@@ -445,2 +507,2 @@\n-     * {@return a memory layout with the same characteristics as this layout, but with the given\n-     * alignment constraint (in bytes)}\n+     * {@return a memory layout with the same characteristics as this layout, but with\n+     *          the given alignment constraint (in bytes)}\n@@ -464,1 +526,2 @@\n-     *{@return a method handle that can be used to invoke {@link #scale(long, long)} on this layout}\n+     *{@return a method handle that can be used to invoke {@link #scale(long, long)}\n+     *         on this layout}\n@@ -469,8 +532,12 @@\n-     * Computes the offset, in bytes, of the layout selected by the given layout path, where the initial layout in the\n-     * path is this layout.\n-     *\n-     * @param elements the layout path elements.\n-     * @return The offset, in bytes, of the layout selected by the layout path in {@code elements}.\n-     * @throws IllegalArgumentException if the layout path is not <a href=\"#well-formedness\">well-formed<\/a> for this layout\n-     * @throws IllegalArgumentException if the layout path contains one or more <a href=#open-path-elements>open path elements<\/a>\n-     * @throws IllegalArgumentException if the layout path contains one or more <a href=#deref-path-elements>dereference path elements<\/a>\n+     * Computes the offset, in bytes, of the layout selected by the given layout path,\n+     * where the initial layout in the path is this layout.\n+     *\n+     * @param elements the layout path elements\n+     * @return The offset, in bytes, of the layout selected by the layout path in\n+     *         {@code elements}\n+     * @throws IllegalArgumentException if the layout path is not\n+     *         <a href=\"#well-formedness\">well-formed<\/a> for this layout\n+     * @throws IllegalArgumentException if the layout path contains one or more\n+     *         <a href=#open-path-elements>open path elements<\/a>\n+     * @throws IllegalArgumentException if the layout path contains one or more\n+     *         <a href=#deref-path-elements>dereference path elements<\/a>\n@@ -488,3 +555,4 @@\n-     *     <li>it has as zero or more trailing parameters of type {@code long}, one for each <a href=#open-path-elements>open path element<\/a>\n-     *     in the provided layout path. The order of these parameters corresponds to the order in which the open path\n-     *     elements occur in the provided layout path.\n+     *     <li>it has as zero or more trailing parameters of type {@code long}, one for\n+     *     each <a href=#open-path-elements>open path element<\/a> in the provided layout\n+     *     path. The order of these parameters corresponds to the order in which the\n+     *     open path elements occur in the provided layout path.\n@@ -499,5 +567,7 @@\n-     * where {@code b} represents the base offset provided as a <em>dynamic<\/em> {@code long} argument, {@code x_1}, {@code x_2},\n-     * ... {@code x_n} represent indices into sequences provided as <em>dynamic<\/em> {@code long} arguments, whereas\n-     * {@code s_1}, {@code s_2}, ... {@code s_n} are <em>static<\/em> stride constants derived from the size of the element\n-     * layout of a sequence, and {@code c_1}, {@code c_2}, ... {@code c_m} are other <em>static<\/em> offset constants\n-     * (such as field offsets) which are derived from the layout path.\n+     * where {@code b} represents the base offset provided as a <em>dynamic<\/em>\n+     * {@code long} argument, {@code x_1}, {@code x_2}, ... {@code x_n} represent indices\n+     * into sequences provided as <em>dynamic<\/em> {@code long} arguments, whereas\n+     * {@code s_1}, {@code s_2}, ... {@code s_n} are <em>static<\/em> stride constants\n+     * derived from the size of the element layout of a sequence, and\n+     * {@code c_1}, {@code c_2}, ... {@code c_m} are other <em>static<\/em> offset\n+     * constants (such as field offsets) which are derived from the layout path.\n@@ -505,2 +575,3 @@\n-     * @apiNote The returned method handle can be used to compute a layout offset, similarly to {@link #byteOffset(PathElement...)},\n-     * but more flexibly, as some indices can be specified when invoking the method handle.\n+     * @apiNote The returned method handle can be used to compute a layout offset,\n+     *          similarly to {@link #byteOffset(PathElement...)}, but more flexibly, as\n+     *          some indices can be specified when invoking the method handle.\n@@ -508,4 +579,7 @@\n-     * @param elements the layout path elements.\n-     * @return a method handle that computes the offset, in bytes, of the layout selected by the given layout path.\n-     * @throws IllegalArgumentException if the layout path is not <a href=\"#well-formedness\">well-formed<\/a> for this layout\n-     * @throws IllegalArgumentException if the layout path contains one or more <a href=#deref-path-elements>dereference path elements<\/a>\n+     * @param elements the layout path elements\n+     * @return a method handle that computes the offset, in bytes, of the layout selected\n+     *         by the given layout path\n+     * @throws IllegalArgumentException if the layout path is not\n+     *         <a href=\"#well-formedness\">well-formed<\/a> for this layout\n+     * @throws IllegalArgumentException if the layout path contains one or more\n+     *         <a href=#deref-path-elements>dereference path elements<\/a>\n@@ -516,2 +590,2 @@\n-     * Creates a var handle that accesses a memory segment at the offset selected by the given layout path,\n-     * where the initial layout in the path is this layout.\n+     * Creates a var handle that accesses a memory segment at the offset selected by the\n+     * given layout path, where the initial layout in the path is this layout.\n@@ -523,6 +597,9 @@\n-     *     <li>it has a leading parameter of type {@code MemorySegment} representing the accessed segment<\/li>\n-     *     <li>a following {@code long} parameter, corresponding to the base offset, denoted as {@code B};<\/li>\n-     *     <li>it has zero or more trailing access coordinates of type {@code long}, one for each\n-     *     <a href=#open-path-elements>open path element<\/a> in the provided layout path, denoted as\n-     *     {@code I1, I2, ... In}, respectively. The order of these access coordinates corresponds to the order\n-     *     in which the open path elements occur in the provided layout path.\n+     *     <li>it has a leading parameter of type {@code MemorySegment} representing the\n+     *     accessed segment<\/li>\n+     *     <li>a following {@code long} parameter, corresponding to the base offset,\n+     *     denoted as {@code B};<\/li>\n+     *     <li>it has zero or more trailing access coordinates of type {@code long},\n+     *     one for each <a href=#open-path-elements>open path element<\/a> in the provided\n+     *     layout path, denoted as {@code I1, I2, ... In}, respectively. The order of\n+     *     these access coordinates corresponds to the order in which the open path\n+     *     elements occur in the provided layout path.\n@@ -531,2 +608,2 @@\n-     * If the provided layout path {@code P} contains no dereference elements, then the offset {@code O} of the access\n-     * operation is computed as follows:\n+     * If the provided layout path {@code P} contains no dereference elements, then the\n+     * offset {@code O} of the access operation is computed as follows:\n@@ -538,1 +615,2 @@\n-     * Accessing a memory segment using the var handle returned by this method is subject to the following checks:\n+     * Accessing a memory segment using the var handle returned by this method is subject\n+     * to the following checks:\n@@ -540,12 +618,18 @@\n-     *     <li>The physical address of the accessed memory segment must be <a href=\"MemorySegment.html#segment-alignment\">aligned<\/a>\n-     * according to the {@linkplain #byteAlignment() alignment constraint} of the root layout (this layout), or\n-     * an {@link IllegalArgumentException} will be issued. Note that the alignment constraint of the root layout\n-     * can be more strict (but not less) than the alignment constraint of the selected value layout.<\/li>\n-     *     <li>The offset of the access operation (computed as above) must fall inside the spatial bounds of the\n-     * accessed memory segment, or an {@link IndexOutOfBoundsException} is thrown. This is the case when {@code O + A <= S},\n-     * where {@code O} is the accessed offset (computed as above), {@code A} is the size of the selected layout and {@code S}\n-     * is the size of the accessed memory segment.<\/li>\n-     *     <li>The accessed memory segment must be {@link MemorySegment#isAccessibleBy(Thread) accessible} from the\n-     * thread performing the access operation, or a {@link WrongThreadException} is thrown.<\/li>\n-     *     <li>The {@linkplain MemorySegment#scope() scope} associated with the accessed segment must be\n-     * {@linkplain MemorySegment.Scope#isAlive() alive}, or an {@link IllegalStateException} is thrown.<\/li>\n+     *     <li>The physical address of the accessed memory segment must be\n+     *     <a href=\"MemorySegment.html#segment-alignment\">aligned<\/a> according to the\n+     *     {@linkplain #byteAlignment() alignment constraint} of the root layout\n+     *     (this layout), or an {@link IllegalArgumentException} is thrown. Note\n+     *     that the alignment constraint of the root layout can be more strict\n+     *     (but not less) than the alignment constraint of the selected value layout.<\/li>\n+     *     <li>The offset of the access operation (computed as above) must fall inside\n+     *     the spatial bounds of the accessed memory segment, or an\n+     *     {@link IndexOutOfBoundsException} is thrown. This is the case when\n+     *     {@code O + A <= S}, where {@code O} is the accessed offset (computed as above),\n+     *     {@code A} is the size of the selected layout and {@code S} is the size of the\n+     *     accessed memory segment.<\/li>\n+     *     <li>The accessed memory segment must be\n+     *     {@link MemorySegment#isAccessibleBy(Thread) accessible} from the thread\n+     *     performing the access operation, or a {@link WrongThreadException} is thrown.<\/li>\n+     *     <li>The {@linkplain MemorySegment#scope() scope} associated with the accessed\n+     *     segment must be {@linkplain MemorySegment.Scope#isAlive() alive}, or an\n+     *     {@link IllegalStateException} is thrown.<\/li>\n@@ -554,3 +638,4 @@\n-     * If the selected layout is an {@linkplain AddressLayout address layout}, calling {@link VarHandle#get(Object...)}\n-     * on the returned var handle will return a new memory segment. The segment is associated with the global scope.\n-     * Moreover, the size of the segment depends on whether the address layout has a\n+     * If the selected layout is an {@linkplain AddressLayout address layout}, calling\n+     * {@link VarHandle#get(Object...)} on the returned var handle will return a new\n+     * memory segment. The segment is associated with the global scope. Moreover, the\n+     * size of the segment depends on whether the address layout has a\n@@ -559,4 +644,4 @@\n-     *     <li>If the address layout has a target layout {@code T}, then the size of the returned segment\n-     *     is {@code T.byteSize()};<\/li>\n-     *     <li>Otherwise, the address layout has no target layout, and the size of the returned segment\n-     *     is <a href=\"MemorySegment.html#wrapping-addresses\">zero<\/a>.<\/li>\n+     *     <li>If the address layout has a target layout {@code T}, then the size of the\n+     *     returned segment is {@code T.byteSize()};<\/li>\n+     *     <li>Otherwise, the address layout has no target layout, and the size of the\n+     *     returned segment is <a href=\"MemorySegment.html#wrapping-addresses\">zero<\/a>.<\/li>\n@@ -564,2 +649,3 @@\n-     * Moreover, if the selected layout is an {@linkplain AddressLayout address layout}, calling {@link VarHandle#set(Object...)}\n-     * can throw {@link IllegalArgumentException} if the memory segment representing the address to be written is not a\n+     * Moreover, if the selected layout is an {@linkplain AddressLayout address layout},\n+     * calling {@link VarHandle#set(Object...)} can throw {@link IllegalArgumentException}\n+     * if the memory segment representing the address to be written is not a\n@@ -568,4 +654,5 @@\n-     * If the provided layout path has size {@code m} and contains a dereference path element in position {@code k}\n-     * (where {@code k <= m}) then two layout paths {@code P} and {@code P'} are derived, where P contains all the path\n-     * elements from 0 to {@code k - 1} and {@code P'} contains all the path elements from {@code k + 1} to\n-     * {@code m} (if any). Then, the returned var handle is computed as follows:\n+     * If the provided layout path has size {@code m} and contains a dereference path\n+     * element in position {@code k} (where {@code k <= m}) then two layout paths\n+     * {@code P} and {@code P'} are derived, where P contains all the path elements from\n+     * 0 to {@code k - 1} and {@code P'} contains all the path elements from {@code k + 1}\n+     * to {@code m} (if any). Then, the returned var handle is computed as follows:\n@@ -582,2 +669,2 @@\n-     * (The above can be trivially generalized to cases where the provided layout path contains more than one dereference\n-     * path elements).\n+     * (The above can be trivially generalized to cases where the provided layout path\n+     * contains more than one dereference path elements).\n@@ -585,1 +672,2 @@\n-     * As an example, consider the memory layout expressed by a {@link GroupLayout} instance constructed as follows:\n+     * As an example, consider the memory layout expressed by a {@link GroupLayout}\n+     * instance constructed as follows:\n@@ -592,1 +680,2 @@\n-     * To access the member layout named {@code value}, we can construct a var handle as follows:\n+     * To access the member layout named {@code value}, we can construct a var handle as\n+     * follows:\n@@ -597,2 +686,3 @@\n-     * @apiNote The resulting var handle features certain <a href=\"#access-mode-restrictions\"><em>access mode restrictions<\/em><\/a>,\n-     * which are common to all var handles derived from memory layouts.\n+     * @apiNote The resulting var handle features certain\n+     * <a href=\"#access-mode-restrictions\"><em>access mode restrictions<\/em><\/a>, which\n+     * are common to all var handles derived from memory layouts.\n@@ -600,4 +690,7 @@\n-     * @param elements the layout path elements.\n-     * @return a var handle that accesses a memory segment at the offset selected by the given layout path.\n-     * @throws IllegalArgumentException if the layout path is not <a href=\"#well-formedness\">well-formed<\/a> for this layout\n-     * @throws IllegalArgumentException if the layout selected by the provided path is not a {@linkplain ValueLayout value layout}\n+     * @param elements the layout path elements\n+     * @return a var handle that accesses a memory segment at the offset selected by the\n+     *         given layout path\n+     * @throws IllegalArgumentException if the layout path is not\n+     *         <a href=\"#well-formedness\">well-formed<\/a> for this layout\n+     * @throws IllegalArgumentException if the layout selected by the provided path is not a\n+     *         {@linkplain ValueLayout value layout}\n@@ -608,2 +701,3 @@\n-     * Creates a var handle that accesses adjacent elements in a memory segment at offsets selected by the given layout path,\n-     * where the accessed elements have this layout, and where the initial layout in the path is this layout.\n+     * Creates a var handle that accesses adjacent elements in a memory segment at\n+     * offsets selected by the given layout path, where the accessed elements have this\n+     * layout, and where the initial layout in the path is this layout.\n@@ -615,8 +709,12 @@\n-     *     <li>it has a leading parameter of type {@code MemorySegment} representing the accessed segment<\/li>\n-     *     <li>a following {@code long} parameter, corresponding to the base offset, denoted as {@code B};<\/li>\n-     *     <li>a following {@code long} parameter, corresponding to the array index, denoted as {@code I0}. The array\n-     *     index is used to scale the accessed offset by this layout size;<\/li>\n-     *     <li>it has zero or more trailing access coordinates of type {@code long}, one for each\n-     *     <a href=#open-path-elements>open path element<\/a> in the provided layout path, denoted as\n-     *     {@code I1, I2, ... In}, respectively. The order of these access coordinates corresponds to the order\n-     *     in which the open path elements occur in the provided layout path.\n+     *     <li>it has a leading parameter of type {@code MemorySegment} representing\n+     *     the accessed segment<\/li>\n+     *     <li>a following {@code long} parameter, corresponding to the base offset,\n+     *     denoted as {@code B};<\/li>\n+     *     <li>a following {@code long} parameter, corresponding to the array index,\n+     *     denoted as {@code I0}. The array index is used to scale the accessed offset\n+     *     by this layout size;<\/li>\n+     *     <li>it has zero or more trailing access coordinates of type {@code long},\n+     *     one for each <a href=#open-path-elements>open path element<\/a> in the provided\n+     *     layout path, denoted as {@code I1, I2, ... In}, respectively. The order of\n+     *     these access coordinates corresponds to the order in which the open path\n+     *     elements occur in the provided layout path.\n@@ -625,2 +723,2 @@\n-     * If the provided layout path {@code P} contains no dereference elements, then the offset {@code O} of the access\n-     * operation is computed as follows:\n+     * If the provided layout path {@code P} contains no dereference elements, then the\n+     * offset {@code O} of the access operation is computed as follows:\n@@ -632,1 +730,2 @@\n-     * More formally, this method can be obtained from the {@link #varHandle(PathElement...)}, as follows:\n+     * More formally, this method can be obtained from the {@link #varHandle(PathElement...)},\n+     * as follows:\n@@ -638,9 +737,14 @@\n-     * As the leading index coordinate {@code I0} is not bound by any sequence layout, it can assume <em>any<\/em> non-negative\n-     * value - provided that the resulting offset computation does not overflow, or that the computed offset does not fall\n-     * outside the spatial bound of the accessed memory segment. As such, the var handles returned from this method can\n-     * be especially useful when accessing <a href=\"#variable-length\">variable-length arrays<\/a>.\n-     *\n-     * @param elements the layout path elements.\n-     * @return a var handle that accesses adjacent elements in a memory segment at offsets selected by the given layout path.\n-     * @throws IllegalArgumentException if the layout path is not <a href=\"#well-formedness\">well-formed<\/a> for this layout\n-     * @throws IllegalArgumentException if the layout selected by the provided path is not a {@linkplain ValueLayout value layout}\n+     * As the leading index coordinate {@code I0} is not bound by any sequence layout, it\n+     * can assume <em>any<\/em> non-negative value - provided that the resulting offset\n+     * computation does not overflow, or that the computed offset does not fall outside\n+     * the spatial bound of the accessed memory segment. As such, the var handles\n+     * returned from this method can be especially useful when accessing\n+     * <a href=\"#variable-length\">variable-length arrays<\/a>.\n+     *\n+     * @param elements the layout path elements\n+     * @return a var handle that accesses adjacent elements in a memory segment at\n+     *         offsets selected by the given layout path\n+     * @throws IllegalArgumentException if the layout path is not\n+     *         <a href=\"#well-formedness\">well-formed<\/a> for this layout\n+     * @throws IllegalArgumentException if the layout selected by the provided path is\n+     *         not a {@linkplain ValueLayout value layout}\n@@ -651,2 +755,4 @@\n-     * Creates a method handle which, given a memory segment, returns a {@linkplain MemorySegment#asSlice(long,long) slice}\n-     * corresponding to the layout selected by the given layout path, where the initial layout in the path is this layout.\n+     * Creates a method handle which, given a memory segment, returns a\n+     * {@linkplain MemorySegment#asSlice(long,long) slice} corresponding to the layout\n+     * selected by the given layout path, where the initial layout in the path is this\n+     * layout.\n@@ -657,1 +763,2 @@\n-     *     <li>it has a leading parameter of type {@code MemorySegment} corresponding to the memory segment to be sliced<\/li>\n+     *     <li>it has a leading parameter of type {@code MemorySegment} corresponding to\n+     *     the memory segment to be sliced<\/li>\n@@ -659,3 +766,4 @@\n-     *     <li>it has as zero or more trailing parameters of type {@code long}, one for each <a href=#open-path-elements>open path element<\/a>\n-     *     in the provided layout path. The order of these parameters corresponds to the order in which the open path\n-     *     elements occur in the provided layout path.\n+     *     <li>it has as zero or more trailing parameters of type {@code long}, one for\n+     *     each <a href=#open-path-elements>open path element<\/a> in the provided\n+     *     layout path. The order of these parameters corresponds to the order in which\n+     *     the open path elements occur in the provided layout path.\n@@ -665,1 +773,2 @@\n-     * {@linkplain #byteOffsetHandle(PathElement...) byte offset handle} constructed using the given path elements.\n+     * {@linkplain #byteOffsetHandle(PathElement...) byte offset handle} constructed\n+     * using the given path elements.\n@@ -667,1 +776,2 @@\n-     * Computing a slice of a memory segment using the method handle returned by this method is subject to the following checks:\n+     * Computing a slice of a memory segment using the method handle returned by this\n+     * method is subject to the following checks:\n@@ -669,8 +779,12 @@\n-     *     <li>The physical address of the accessed memory segment must be <a href=\"MemorySegment.html#segment-alignment\">aligned<\/a>\n-     * according to the {@linkplain #byteAlignment() alignment constraint} of the root layout (this layout), or\n-     * an {@link IllegalArgumentException} will be issued. Note that the alignment constraint of the root layout\n-     * can be more strict (but not less) than the alignment constraint of the selected layout.<\/li>\n-     *     <li>The start offset of the slicing operation (computed as above) must fall fall inside the spatial bounds of the\n-     * accessed memory segment, or an {@link IndexOutOfBoundsException} is thrown. This is the case when {@code O + A <= S},\n-     * where {@code O} is the start offset of the slicing operation (computed as above), {@code A} is the size of the\n-     * selected layout and {@code S} is the size of the accessed memory segment.<\/li>\n+     *     <li>The physical address of the accessed memory segment must be\n+     *     <a href=\"MemorySegment.html#segment-alignment\">aligned<\/a> according to the\n+     *     {@linkplain #byteAlignment() alignment constraint} of the root layout\n+     *     (this layout), or an {@link IllegalArgumentException} is thrown. Note\n+     *     that the alignment constraint of the root layout can be more strict\n+     *     (but not less) than the alignment constraint of the selected layout.<\/li>\n+     *     <li>The start offset of the slicing operation (computed as above) must fall\n+     *     fall inside the spatial bounds of the accessed memory segment, or an\n+     *     {@link IndexOutOfBoundsException} is thrown. This is the case when\n+     *     {@code O + A <= S}, where {@code O} is the start offset of the slicing\n+     *     operation (computed as above), {@code A} is the size of the selected layout\n+     *     and {@code S} is the size of the accessed memory segment.<\/li>\n@@ -679,2 +793,3 @@\n-     * @apiNote The returned method handle can be used to obtain a memory segment slice, similarly to {@link MemorySegment#asSlice(long, long)},\n-     * but more flexibly, as some indices can be specified when invoking the method handle.\n+     * @apiNote The returned method handle can be used to obtain a memory segment slice,\n+     *          similarly to {@link MemorySegment#asSlice(long, long)}, but more flexibly,\n+     *          as some indices can be specified when invoking the method handle.\n@@ -682,4 +797,7 @@\n-     * @param elements the layout path elements.\n-     * @return a method handle which is used to slice a memory segment at the offset selected by the given layout path.\n-     * @throws IllegalArgumentException if the layout path is not <a href=\"#well-formedness\">well-formed<\/a> for this layout\n-     * @throws IllegalArgumentException if the layout path contains one or more <a href=#deref-path-elements>dereference path elements<\/a>\n+     * @param elements the layout path elements\n+     * @return a method handle which is used to slice a memory segment at the offset\n+     *         selected by the given layout path\n+     * @throws IllegalArgumentException if the layout path is not\n+     *         <a href=\"#well-formedness\">well-formed<\/a> for this layout\n+     * @throws IllegalArgumentException if the layout path contains one or more\n+     *         <a href=#deref-path-elements>dereference path elements<\/a>\n@@ -690,8 +808,13 @@\n-     * Returns the layout selected from the provided path, where the initial layout in the path is this layout.\n-     *\n-     * @param elements the layout path elements.\n-     * @return the layout selected by the layout path in {@code elements}.\n-     * @throws IllegalArgumentException if the layout path is not <a href=\"#well-formedness\">well-formed<\/a> for this layout\n-     * @throws IllegalArgumentException if the layout path contains one or more <a href=#deref-path-elements>dereference path elements<\/a>\n-     * @throws IllegalArgumentException if the layout path contains one or more path elements that select one or more\n-     *         sequence element indices, such as {@link PathElement#sequenceElement(long)} and {@link PathElement#sequenceElement(long, long)})\n+     * Returns the layout selected from the provided path, where the initial layout in\n+     * the path is this layout.\n+     *\n+     * @param elements the layout path elements\n+     * @return the layout selected by the layout path in {@code elements}\n+     * @throws IllegalArgumentException if the layout path is not\n+     *         <a href=\"#well-formedness\">well-formed<\/a> for this layout\n+     * @throws IllegalArgumentException if the layout path contains one or more\n+     *         <a href=#deref-path-elements>dereference path elements<\/a>\n+     * @throws IllegalArgumentException if the layout path contains one or more path\n+     *         elements that select one or more sequence element indices, such as\n+     *         {@link PathElement#sequenceElement(long)} and\n+     *         {@link PathElement#sequenceElement(long, long)})\n@@ -702,2 +825,2 @@\n-     * An element in a <a href=\"MemoryLayout.html#layout-paths\"><em>layout path<\/em><\/a>. There\n-     * are three kinds of path elements:\n+     * An element in a <a href=\"MemoryLayout.html#layout-paths\"><em>layout path<\/em><\/a>.\n+     * There are three kinds of path elements:\n@@ -705,4 +828,7 @@\n-     *     <li><em>group path elements<\/em>, used to select a member layout within a {@link GroupLayout}, either by name or by index;<\/li>\n-     *     <li><em>sequence path elements<\/em>, used to select one or more sequence element layouts within a {@link SequenceLayout}; and<\/li>\n-     *     <li><em>dereference path elements<\/em>, used to <a href=\"MemoryLayout.html#deref-path-elements\">dereference<\/a>\n-     *     an address layout as its target layout.<\/li>\n+     *     <li><em>group path elements<\/em>, used to select a member layout within a\n+     *     {@link GroupLayout}, either by name or by index;<\/li>\n+     *     <li><em>sequence path elements<\/em>, used to select one or more\n+     *     sequence element layouts within a {@link SequenceLayout}; and<\/li>\n+     *     <li><em>dereference path elements<\/em>, used to\n+     *     <a href=\"MemoryLayout.html#deref-path-elements\">dereference<\/a> an address\n+     *     layout as its target layout.<\/li>\n@@ -714,1 +840,2 @@\n-     * Implementations of this interface are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+     * Implementations of this interface are immutable, thread-safe and\n+     * <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n@@ -721,1 +848,2 @@\n-         * Returns a path element which selects a member layout with the given name in a group layout.\n+         * Returns a path element which selects a member layout with the given name in a\n+         * group layout.\n@@ -723,3 +851,5 @@\n-         * @implSpec in case multiple group elements with a matching name exist, the path element returned by this\n-         * method will select the first one; that is, the group element with the lowest offset from current path is selected.\n-         * In such cases, using {@link #groupElement(long)} might be preferable.\n+         * @implSpec in case multiple group elements with a matching name exist, the path\n+         *           element returned by this method will select the first one; that is,\n+         *           the group element with the lowest offset from current path is\n+         *           selected. In such cases, using {@link #groupElement(long)} might be\n+         *           preferable.\n@@ -727,2 +857,3 @@\n-         * @param name the name of the member layout to be selected.\n-         * @return a path element which selects the group member layout with the given name.\n+         * @param name the name of the member layout to be selected\n+         * @return a path element which selects the group member layout with the\n+         *         given name\n@@ -737,1 +868,2 @@\n-         * Returns a path element which selects a member layout with the given index in a group layout.\n+         * Returns a path element which selects a member layout with the given index in a\n+         * group layout.\n@@ -739,2 +871,3 @@\n-         * @param index the index of the member layout element to be selected.\n-         * @return a path element which selects the group member layout with the given index.\n+         * @param index the index of the member layout element to be selected\n+         * @return a path element which selects the group member layout with the\n+         *         given index\n@@ -752,1 +885,2 @@\n-         * Returns a path element which selects the element layout at the specified position in a sequence layout.\n+         * Returns a path element which selects the element layout at the specified\n+         * position in a sequence layout.\n@@ -754,2 +888,3 @@\n-         * @param index the index of the sequence element to be selected.\n-         * @return a path element which selects the sequence element layout with the given index.\n+         * @param index the index of the sequence element to be selected\n+         * @return a path element which selects the sequence element layout with the\n+         *         given index\n@@ -767,3 +902,4 @@\n-         * Returns an <a href=\"MemoryLayout.html#open-path-elements\">open path element<\/a> which selects the element\n-         * layout in a <em>range<\/em> of positions in a sequence layout. The range is expressed as a pair of starting\n-         * index (inclusive) {@code S} and step factor (which can also be negative) {@code F}.\n+         * Returns an <a href=\"MemoryLayout.html#open-path-elements\">open path element<\/a>\n+         * which selects the element layout in a <em>range<\/em> of positions in a sequence\n+         * layout. The range is expressed as a pair of starting index (inclusive)\n+         * {@code S} and step factor (which can also be negative) {@code F}.\n@@ -771,2 +907,4 @@\n-         * The exact sequence element selected by this layout is expressed as an index {@code I}. If {@code C} is the\n-         * sequence element count, it follows that {@code 0 <= I < B}, where {@code B} is computed as follows:\n+         * The exact sequence element selected by this layout is expressed as an index\n+         * {@code I}. If {@code C} is the\n+         * sequence element count, it follows that {@code 0 <= I < B}, where {@code B}\n+         * is computed as follows:\n@@ -778,3 +916,5 @@\n-         * @param start the index of the first sequence element to be selected.\n-         * @param step the step factor at which subsequence sequence elements are to be selected.\n-         * @return a path element which selects the sequence element layout with the given index.\n+         * @param start the index of the first sequence element to be selected\n+         * @param step the step factor at which subsequence sequence elements are to be\n+         *             selected\n+         * @return a path element which selects the sequence element layout with the\n+         *         given index\n@@ -795,2 +935,2 @@\n-         * Returns an <a href=\"MemoryLayout.html#open-path-elements\">open path element<\/a> which selects an unspecified\n-         * element layout in a sequence layout.\n+         * Returns an <a href=\"MemoryLayout.html#open-path-elements\">open path element<\/a>\n+         * which selects an unspecified element layout in a sequence layout.\n@@ -798,2 +938,3 @@\n-         * The exact sequence element selected by this layout is expressed as an index {@code I}. If {@code C} is the\n-         * sequence element count, it follows that {@code 0 <= I < C}.\n+         * The exact sequence element selected by this layout is expressed as an index\n+         * {@code I}. If {@code C} is the sequence element count, it follows that\n+         * {@code 0 <= I < C}.\n@@ -801,1 +942,1 @@\n-         * @return a path element which selects an unspecified sequence element layout.\n+         * @return a path element which selects an unspecified sequence element layout\n@@ -812,1 +953,1 @@\n-         * @return a path element which dereferences an address layout.\n+         * @return a path element which dereferences an address layout\n@@ -821,4 +962,5 @@\n-     * Compares the specified object with this layout for equality. Returns {@code true} if and only if the specified\n-     * object is also a layout, and it is equal to this layout. Two layouts are considered equal if they are of\n-     * the same kind, have the same size, name and alignment constraint. Furthermore, depending on the layout kind, additional\n-     * conditions must be satisfied:\n+     * Compares the specified object with this layout for equality. Returns {@code true}\n+     * if and only if the specified object is also a layout, and it is equal to this\n+     * layout. Two layouts are considered equal if they are of the same kind, have the\n+     * same size, name and alignment constraint. Furthermore, depending on the\n+     * layout kind, additional conditions must be satisfied:\n@@ -826,7 +968,11 @@\n-     *     <li>two value layouts are considered equal if they have the same {@linkplain ValueLayout#order() order},\n-     *     and {@linkplain ValueLayout#carrier() carrier}. Additionally, two address layouts are considered equal if they\n-     *     also have the same {@linkplain AddressLayout#targetLayout() target layout};<\/li>\n-     *     <li>two sequence layouts are considered equal if they have the same element count (see {@link SequenceLayout#elementCount()}), and\n-     *     if their element layouts (see {@link SequenceLayout#elementLayout()}) are also equal;<\/li>\n-     *     <li>two group layouts are considered equal if they are of the same type (see {@link StructLayout},\n-     *     {@link UnionLayout}) and if their member layouts (see {@link GroupLayout#memberLayouts()}) are also equal.<\/li>\n+     *     <li>two value layouts are considered equal if they have the same\n+     *     {@linkplain ValueLayout#order() order}, and\n+     *     {@linkplain ValueLayout#carrier() carrier}. Additionally, two address\n+     *     layouts are considered equal if they also have the same\n+     *     {@linkplain AddressLayout#targetLayout() target layout};<\/li>\n+     *     <li>two sequence layouts are considered equal if they have the same element\n+     *     count (see {@link SequenceLayout#elementCount()}), and if their element\n+     *     layouts (see {@link SequenceLayout#elementLayout()}) are also equal;<\/li>\n+     *     <li>two group layouts are considered equal if they are of the same type\n+     *     (see {@link StructLayout}, {@link UnionLayout}) and if their member layouts\n+     *     (see {@link GroupLayout#memberLayouts()}) are also equal.<\/li>\n@@ -835,2 +981,2 @@\n-     * @param other the object to be compared for equality with this layout.\n-     * @return {@code true} if the specified object is equal to this layout.\n+     * @param other the object to be compared for equality with this layout\n+     * @return {@code true} if the specified object is equal to this layout\n@@ -852,4 +998,5 @@\n-     * Creates a padding layout with the given byte size. The alignment constraint of the returned layout\n-     * is 1. As such, regardless of its size, in the absence of an {@linkplain #withByteAlignment(long) explicit}\n-     * alignment constraint, a padding layout does not affect the natural alignment of the group or sequence layout\n-     * it is nested into.\n+     * Creates a padding layout with the given byte size. The alignment constraint of the\n+     * returned layout is 1. As such, regardless of its size, in the absence of an\n+     * {@linkplain #withByteAlignment(long) explicit} alignment constraint, a padding\n+     * layout does not affect the natural alignment of the group or sequence layout it is\n+     * nested into.\n@@ -857,2 +1004,2 @@\n-     * @param byteSize the padding size (expressed in bytes).\n-     * @return the new selector layout.\n+     * @param byteSize the padding size (expressed in bytes)\n+     * @return the new selector layout\n@@ -868,2 +1015,2 @@\n-     * @param elementCount the sequence element count.\n-     * @param elementLayout the sequence element layout.\n+     * @param elementCount the sequence element count\n+     * @param elementLayout the sequence element layout\n@@ -872,1 +1019,2 @@\n-     * @throws IllegalArgumentException if {@code elementLayout.byteSize() * elementCount} overflows\n+     * @throws IllegalArgumentException if {@code elementLayout.byteSize() * elementCount}\n+     *         overflows\n@@ -886,6 +1034,7 @@\n-     * @param elements The member layouts of the struct layout.\n-     * @return a struct layout with the given member layouts.\n-     * @throws IllegalArgumentException if the sum of the {@linkplain #byteSize() byte sizes} of the member\n-     *         layouts overflows\n-     * @throws IllegalArgumentException if a member layout in {@code elements} occurs at an offset\n-     *         (relative to the start of the struct layout) which is not compatible with its alignment constraint\n+     * @param elements The member layouts of the struct layout\n+     * @return a struct layout with the given member layouts\n+     * @throws IllegalArgumentException if the sum of the {@linkplain #byteSize() byte sizes}\n+     *         of the member layouts overflows\n+     * @throws IllegalArgumentException if a member layout in {@code elements} occurs at\n+     *         an offset (relative to the start of the struct layout) which is not\n+     *         compatible with its alignment constraint\n@@ -893,2 +1042,3 @@\n-     * @apiNote This factory does not automatically align element layouts, by inserting additional {@linkplain PaddingLayout\n-     * padding layout} elements. As such, the following struct layout creation will fail with an exception:\n+     * @apiNote This factory does not automatically align element layouts, by inserting\n+     *          additional {@linkplain PaddingLayout padding layout} elements. As such,\n+     *          the following struct layout creation will fail with an exception:\n@@ -900,1 +1050,2 @@\n-     * To avoid the exception, clients can either insert additional padding layout elements:\n+     * To avoid the exception, clients can either insert additional padding layout\n+     * elements:\n@@ -906,2 +1057,2 @@\n-     * Or, alternatively, they can use a member layout which features a smaller alignment constraint. This will result\n-     * in a <em>packed<\/em> struct layout:\n+     * Or, alternatively, they can use a member layout which features a smaller alignment\n+     * constraint. This will result in a <em>packed<\/em> struct layout:\n@@ -924,2 +1075,2 @@\n-     * @param elements The member layouts of the union layout.\n-     * @return a union layout with the given member layouts.\n+     * @param elements The member layouts of the union layout\n+     * @return a union layout with the given member layouts\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":473,"deletions":322,"binary":false,"changes":795,"status":"modified"},{"patch":"@@ -56,2 +56,4 @@\n- *     <li>A <em>heap segment<\/em> is backed by, and provides access to, a region of memory inside the Java heap (an \"on-heap\" region).<\/li>\n- *     <li>A <em>native segment<\/em> is backed by, and provides access to, a region of memory outside the Java heap (an \"off-heap\" region).<\/li>\n+ *     <li>A <em>heap segment<\/em> is backed by, and provides access to, a region of\n+ *     memory inside the Java heap (an \"on-heap\" region).<\/li>\n+ *     <li>A <em>native segment<\/em> is backed by, and provides access to, a region of\n+ *     memory outside the Java heap (an \"off-heap\" region).<\/li>\n@@ -59,2 +61,3 @@\n- * Heap segments can be obtained by calling one of the {@link MemorySegment#ofArray(int[])} factory methods.\n- * These methods return a memory segment backed by the on-heap region that holds the specified Java array.\n+ * Heap segments can be obtained by calling one of the {@link MemorySegment#ofArray(int[])}\n+ * factory methods. These methods return a memory segment backed by the on-heap region\n+ * that holds the specified Java array.\n@@ -63,6 +66,8 @@\n- * factory methods, which return a memory segment backed by a newly allocated off-heap region with the given size\n- * and aligned to the given alignment constraint. Alternatively, native segments can be obtained by\n- * {@link FileChannel#map(MapMode, long, long, Arena) mapping} a file into a new off-heap region\n- * (in some systems, this operation is sometimes referred to as {@code mmap}).\n- * Segments obtained in this way are called <em>mapped<\/em> segments, and their contents can be {@linkplain #force() persisted} and\n- * {@linkplain #load() loaded} to and from the underlying memory-mapped file.\n+ * factory methods, which return a memory segment backed by a newly allocated off-heap\n+ * region with the given size and aligned to the given alignment constraint.\n+ * Alternatively, native segments can be obtained by\n+ * {@link FileChannel#map(MapMode, long, long, Arena) mapping} a file into a new off-heap\n+ * region (in some systems, this operation is sometimes referred to as {@code mmap}).\n+ * Segments obtained in this way are called <em>mapped<\/em> segments, and their contents\n+ * can be {@linkplain #force() persisted} and {@linkplain #load() loaded} to and from the\n+ * underlying memory-mapped file.\n@@ -70,2 +75,4 @@\n- * Both kinds of segments are read and written using the same methods, known as <a href=\"#segment-deref\">access operations<\/a>.\n- * An access operation on a memory segment always and only provides access to the region for which the segment was obtained.\n+ * Both kinds of segments are read and written using the same methods, known as\n+ * <a href=\"#segment-deref\">access operations<\/a>. An access operation on a memory\n+ * segment always and only provides access to the region for which the segment was\n+ * obtained.\n@@ -75,2 +82,3 @@\n- * Every memory segment has an {@linkplain #address() address}, expressed as a {@code long} value.\n- * The nature of a segment's address depends on the kind of the segment:\n+ * Every memory segment has an {@linkplain #address() address}, expressed as a\n+ * {@code long} value. The nature of a segment's address depends on the kind of the\n+ * segment:\n@@ -78,3 +86,4 @@\n- * <li>The address of a heap segment is not a physical address, but rather an offset within the region of memory\n- * which backs the segment. The region is inside the Java heap, so garbage collection might cause the region to be\n- * relocated in physical memory over time, but this is not exposed to clients of the {@code MemorySegment} API who\n+ * <li>The address of a heap segment is not a physical address, but rather an offset\n+ * within the region of memory which backs the segment. The region is inside the Java\n+ * heap, so garbage collection might cause the region to be relocated in physical memory\n+ * over time, but this is not exposed to clients of the {@code MemorySegment} API who\n@@ -82,3 +91,4 @@\n- * A heap segment obtained from one of the {@link #ofArray(int[])} factory methods has an address of zero.<\/li>\n- * <li>The address of a native segment (including mapped segments) denotes the physical address of the region of\n- * memory which backs the segment.<\/li>\n+ * A heap segment obtained from one of the {@link #ofArray(int[])} factory methods has\n+ * an address of zero.<\/li>\n+ * <li>The address of a native segment (including mapped segments) denotes the physical\n+ * address of the region of memory which backs the segment.<\/li>\n@@ -87,3 +97,3 @@\n- * Every memory segment has a {@linkplain #byteSize() size}. The size of a heap segment is derived from the Java array\n- * from which it is obtained. This size is predictable across Java runtimes.\n- * The size of a native segment is either passed explicitly\n+ * Every memory segment has a {@linkplain #byteSize() size}. The size of a heap segment\n+ * is derived from the Java array from which it is obtained. This size is predictable\n+ * across Java runtimes. The size of a native segment is either passed explicitly\n@@ -94,3 +104,3 @@\n- * The address and size of a memory segment jointly ensure that access operations on the segment cannot fall\n- * <em>outside<\/em> the boundaries of the region of memory which backs the segment.\n- * That is, a memory segment has <em>spatial bounds<\/em>.\n+ * The address and size of a memory segment jointly ensure that access operations on the\n+ * segment cannot fall <em>outside<\/em> the boundaries of the region of memory which\n+ * backs the segment. That is, a memory segment has <em>spatial bounds<\/em>.\n@@ -98,4 +108,5 @@\n- * Every memory segment is associated with a {@linkplain Scope scope}. This ensures that access operations\n- * on a memory segment cannot occur when the region of memory which backs the memory segment is no longer available\n- * (e.g., after the scope associated with the accessed memory segment is no longer {@linkplain Scope#isAlive() alive}).\n- * That is, a memory segment has <em>temporal bounds<\/em>.\n+ * Every memory segment is associated with a {@linkplain Scope scope}. This ensures that\n+ * access operations on a memory segment cannot occur when the region of memory which\n+ * backs the memory segment is no longer available (e.g., after the scope associated with\n+ * the accessed memory segment is no longer {@linkplain Scope#isAlive() alive}). That is,\n+ * a memory segment has <em>temporal bounds<\/em>.\n@@ -103,3 +114,5 @@\n- * Finally, access operations on a memory segment can be subject to additional thread-confinement checks.\n- * Heap segments can be accessed from any thread. Conversely, native segments can only be accessed compatibly with the\n- * <a href=\"Arena.html#thread-confinement\">confinement characteristics<\/a> of the arena used to obtain them.\n+ * Finally, access operations on a memory segment can be subject to additiona\n+ * l thread-confinement checks. Heap segments can be accessed from any thread.\n+ * Conversely, native segments can only be accessed compatibly with the\n+ * <a href=\"Arena.html#thread-confinement\">confinement characteristics<\/a> of the arena\n+ * used to obtain them.\n@@ -109,4 +122,6 @@\n- * A memory segment can be read or written using various access operations provided in this class (e.g. {@link #get(ValueLayout.OfInt, long)}).\n- * Each access operation takes a {@linkplain ValueLayout value layout}, which specifies the size and shape of the value,\n- * and an offset, expressed in bytes.\n- * For instance, to read an int from a segment, using {@linkplain ByteOrder#nativeOrder() default endianness}, the following code can be used:\n+ * A memory segment can be read or written using various access operations provided in\n+ * this class (e.g. {@link #get(ValueLayout.OfInt, long)}). Each access operation takes\n+ * a {@linkplain ValueLayout value layout}, which specifies the size and shape of the\n+ * value, and an offset, expressed in bytes. For instance, to read an {@code int} from\n+ * a segment, using {@linkplain ByteOrder#nativeOrder() default endianness}, the\n+ * following code can be used:\n@@ -118,2 +133,2 @@\n- * If the value to be read is stored in memory using {@linkplain ByteOrder#BIG_ENDIAN big-endian} encoding, the access operation\n- * can be expressed as follows:\n+ * If the value to be read is stored in memory using {@linkplain ByteOrder#BIG_ENDIAN big-endian}\n+ * encoding, the access operation can be expressed as follows:\n@@ -124,3 +139,4 @@\n- * Access operations on memory segments are implemented using var handles. The {@link ValueLayout#varHandle()}\n- * method can be used to obtain a var handle that can be used to get\/set values represented by the given value layout\n- * on a memory segment at the given offset:\n+ * Access operations on memory segments are implemented using var handles. The\n+ * {@link ValueLayout#varHandle()} method can be used to obtain a var handle that can be\n+ * used to get\/set values represented by the given value layout on a memory segment at\n+ * the given offset:\n@@ -133,2 +149,2 @@\n- * Alternatively, a var handle that can be used to access an element of an {@code int} array at a given logical\n- * index can be created as follows:\n+ * Alternatively, a var handle that can be used to access an element of an {@code int}\n+ * array at a given logical index can be created as follows:\n@@ -143,2 +159,3 @@\n- * Clients can also drop the base offset parameter, in order to make the access expression simpler. This can be used to\n- * implement access operations such as {@link #getAtIndex(OfInt, long)}:\n+ * Clients can also drop the base offset parameter, in order to make the access\n+ * expression simpler. This can be used to implement access operations such as\n+ * {@link #getAtIndex(OfInt, long)}:\n@@ -152,2 +169,3 @@\n- * Var handles for more complex access expressions (e.g. struct field access, pointer dereference) can be created directly\n- * from memory layouts, using <a href=\"MemoryLayout.html#layout-paths\"><em>layout paths<\/em><\/a>.\n+ * Var handles for more complex access expressions (e.g. struct field access, pointer\n+ * dereference) can be created directly from memory layouts, using\n+ * <a href=\"MemoryLayout.html#layout-paths\"><em>layout paths<\/em><\/a>.\n@@ -157,5 +175,8 @@\n- * Memory segments support {@linkplain MemorySegment#asSlice(long, long) slicing}. Slicing a memory segment\n- * returns a new memory segment that is backed by the same region of memory as the original. The address of the sliced\n- * segment is derived from the address of the original segment, by adding an offset (expressed in bytes). The size of\n- * the sliced segment is either derived implicitly (by subtracting the specified offset from the size of the original segment),\n- * or provided explicitly. In other words, a sliced segment has <em>stricter<\/em> spatial bounds than those of the original segment:\n+ * Memory segments support {@linkplain MemorySegment#asSlice(long, long) slicing}.\n+ * Slicing a memory segment returns a new memory segment that is backed by the same\n+ * region of memory as the original. The address of the sliced segment is derived from\n+ * the address of the original segment, by adding an offset (expressed in bytes). The\n+ * size of the sliced segment is either derived implicitly (by subtracting the specified\n+ * offset from the size of the original segment), or provided explicitly. In other words,\n+ * a sliced segment has <em>stricter<\/em> spatial bounds than those of the original\n+ * segment:\n@@ -170,6 +191,8 @@\n- * The above code creates a native segment that is 100 bytes long; then, it creates a slice that starts at offset 50\n- * of {@code segment}, and is 10 bytes long. That is, the address of the {@code slice} is {@code segment.address() + 50},\n- * and its size is 10. As a result, attempting to read an int value at offset 20 of the\n- * {@code slice} segment will result in an exception. The {@linkplain Arena temporal bounds} of the original segment\n- * is inherited by its slices; that is, when the scope associated with {@code segment} is no longer {@linkplain Scope#isAlive() alive},\n- * {@code slice} will also be become inaccessible.\n+ * The above code creates a native segment that is 100 bytes long; then, it creates a\n+ * slice that starts at offset 50 of {@code segment}, and is 10 bytes long. That is, the\n+ * address of the {@code slice} is {@code segment.address() + 50}, and its size is 10.\n+ * As a result, attempting to read an int value at offset 20 of the {@code slice} segment\n+ * will result in an exception. The {@linkplain Arena temporal bounds} of the original\n+ * segment is inherited by its slices; that is, when the scope associated with\n+ * {@code segment} is no longer {@linkplain Scope#isAlive() alive}, {@code slice} will\n+ * also be become inaccessible.\n@@ -177,4 +200,5 @@\n- * A client might obtain a {@link Stream} from a segment, which can then be used to slice the segment (according to a given\n- * element layout) and even allow multiple threads to work in parallel on disjoint segment slices\n- * (to do this, the segment has to be {@linkplain MemorySegment#isAccessibleBy(Thread) accessible}\n- * from multiple threads). The following code can be used to sum all int values in a memory segment in parallel:\n+ * A client might obtain a {@link Stream} from a segment, which can then be used to slice\n+ * the segment (according to a given element layout) and even allow multiple threads to\n+ * work in parallel on disjoint segment slices (to do this, the segment has to be\n+ * {@linkplain MemorySegment#isAccessibleBy(Thread) accessible} from multiple threads).\n+ * The following code can be used to sum all int values in a memory segment in parallel:\n@@ -194,13 +218,18 @@\n- * Access operations on a memory segment are constrained not only by the spatial and temporal bounds of the segment,\n- * but also by the <em>alignment constraint<\/em> of the value layout specified to the operation. An access operation can\n- * access only those offsets in the segment that denote addresses in physical memory which are <em>aligned<\/em> according\n- * to the layout. An address in physical memory is <em>aligned<\/em> according to a layout if the address is an integer\n- * multiple of the layout's alignment constraint. For example, the address 1000 is aligned according to an 8-byte alignment\n- * constraint (because 1000 is an integer multiple of 8), and to a 4-byte alignment constraint, and to a 2-byte alignment\n- * constraint; in contrast, the address 1004 is aligned according to a 4-byte alignment constraint, and to a 2-byte alignment\n- * constraint, but not to an 8-byte alignment constraint.\n- * Access operations are required to respect alignment because it can impact the performance of access operations, and\n- * can also determine which access operations are available at a given physical address. For instance,\n- * {@linkplain java.lang.invoke.VarHandle#compareAndSet(Object...) atomic access operations} operations using\n- * {@link java.lang.invoke.VarHandle} are only permitted at aligned addresses. In addition, alignment\n- * applies to an access operation whether the segment being accessed is a native segment or a heap segment.\n+ * Access operations on a memory segment are constrained not only by the spatial and\n+ * temporal bounds of the segment, but also by the <em>alignment constraint<\/em> of the\n+ * value layout specified to the operation. An access operation can access only those\n+ * offsets in the segment that denote addresses in physical memory which are\n+ * <em>aligned<\/em> according to the layout. An address in physical memory is\n+ * <em>aligned<\/em> according to a layout if the address is an integer multiple of the\n+ * layout's alignment constraint. For example, the address 1000 is aligned according to\n+ * an 8-byte alignment constraint (because 1000 is an integer multiple of 8), and to a\n+ * 4-byte alignment constraint, and to a 2-byte alignment constraint; in contrast, the\n+ * address 1004 is aligned according to a 4-byte alignment constraint, and to a 2-byte\n+ * alignment constraint, but not to an 8-byte alignment constraint.\n+ * Access operations are required to respect alignment because it can impact the\n+ * performance of access operations, and can also determine which access operations are\n+ * available at a given physical address. For instance,\n+ * {@linkplain java.lang.invoke.VarHandle#compareAndSet(Object...) atomic access operations}\n+ * operations using {@link java.lang.invoke.VarHandle} are only permitted at aligned\n+ * addresses. In addition, alignment applies to an access operation whether the segment\n+ * being accessed is a native segment or a heap segment.\n@@ -208,2 +237,4 @@\n- * If the segment being accessed is a native segment, then its {@linkplain #address() address} in physical memory can be\n- * combined with the offset to obtain the <em>target address<\/em> in physical memory. The pseudo-function below demonstrates this:\n+ * If the segment being accessed is a native segment, then its\n+ * {@linkplain #address() address} in physical memory can be combined with the offset to\n+ * obtain the <em>target address<\/em> in physical memory. The pseudo-function below\n+ * demonstrates this:\n@@ -219,19 +250,28 @@\n- * <li>A native segment with address 1000 can be accessed at offsets 0, 8, 16, 24, etc under an 8-byte alignment constraint,\n- * because the target addresses (1000, 1008, 1016, 1024) are 8-byte aligned.\n- * Access at offsets 1-7 or 9-15 or 17-23 is disallowed because the target addresses would not be 8-byte aligned.<\/li>\n- * <li>A native segment with address 1000 can be accessed at offsets 0, 4, 8, 12, etc under a 4-byte alignment constraint,\n- * because the target addresses (1000, 1004, 1008, 1012) are 4-byte aligned.\n- * Access at offsets 1-3 or 5-7 or 9-11 is disallowed because the target addresses would not be 4-byte aligned.<\/li>\n- * <li>A native segment with address 1000 can be accessed at offsets 0, 2, 4, 6, etc under a 2-byte alignment constraint,\n- * because the target addresses (1000, 1002, 1004, 1006) are 2-byte aligned.\n- * Access at offsets 1 or 3 or 5 is disallowed because the target addresses would not be 2-byte aligned.<\/li>\n- * <li>A native segment with address 1004 can be accessed at offsets 0, 4, 8, 12, etc under a 4-byte alignment constraint,\n- * and at offsets 0, 2, 4, 6, etc under a 2-byte alignment constraint.\n- * Under an 8-byte alignment constraint, it can be accessed at offsets 4, 12, 20, 28, etc.<\/li>\n- * <li>A native segment with address 1006 can be accessed at offsets 0, 2, 4, 6, etc under a 2-byte alignment constraint.\n- * Under a 4-byte alignment constraint, it can be accessed at offsets 2, 6, 10, 14, etc.\n- * Under an 8-byte alignment constraint, it can be accessed at offsets 2, 10, 18, 26, etc.\n- * <li>A native segment with address 1007 can be accessed at offsets 0, 1, 2, 3, etc under a 1-byte alignment constraint.\n- * Under a 2-byte alignment constraint, it can be accessed at offsets 1, 3, 5, 7, etc.\n- * Under a 4-byte alignment constraint, it can be accessed at offsets 1, 5, 9, 13, etc.\n- * Under an 8-byte alignment constraint, it can be accessed at offsets 1, 9, 17, 25, etc.<\/li>\n+ * <li>A native segment with address 1000 can be accessed at offsets 0, 8, 16, 24, etc\n+ *     under an 8-byte alignment constraint, because the target addresses\n+ *     (1000, 1008, 1016, 1024) are 8-byte aligned.\n+ *     Access at offsets 1-7 or 9-15 or 17-23 is disallowed because the target addresses\n+ *     would not be 8-byte aligned.<\/li>\n+ * <li>A native segment with address 1000 can be accessed at offsets 0, 4, 8, 12, etc\n+ *     under a 4-byte alignment constraint, because the target addresses\n+ *     (1000, 1004, 1008, 1012) are 4-byte aligned.\n+ *     Access at offsets 1-3 or 5-7 or 9-11 is disallowed because the target addresses\n+ *     would not be 4-byte aligned.<\/li>\n+ * <li>A native segment with address 1000 can be accessed at offsets 0, 2, 4, 6, etc\n+ *     under a 2-byte alignment constraint, because the target addresses\n+ *     (1000, 1002, 1004, 1006) are 2-byte aligned.\n+ *     Access at offsets 1 or 3 or 5 is disallowed because the target addresses would\n+ *     not be 2-byte aligned.<\/li>\n+ * <li>A native segment with address 1004 can be accessed at offsets 0, 4, 8, 12, etc\n+ *     under a 4-byte alignment constraint, and at offsets 0, 2, 4, 6, etc\n+ *     under a 2-byte alignment constraint. Under an 8-byte alignment constraint,\n+ *     it can be accessed at offsets 4, 12, 20, 28, etc.<\/li>\n+ * <li>A native segment with address 1006 can be accessed at offsets 0, 2, 4, 6, etc\n+ *     under a 2-byte alignment constraint.\n+ *     Under a 4-byte alignment constraint, it can be accessed at offsets 2, 6, 10, 14, etc.\n+ *     Under an 8-byte alignment constraint, it can be accessed at offsets 2, 10, 18, 26, etc.\n+ * <li>A native segment with address 1007 can be accessed at offsets 0, 1, 2, 3, etc\n+ *     under a 1-byte alignment constraint.\n+ *     Under a 2-byte alignment constraint, it can be accessed at offsets 1, 3, 5, 7, etc.\n+ *     Under a 4-byte alignment constraint, it can be accessed at offsets 1, 5, 9, 13, etc.\n+ *     Under an 8-byte alignment constraint, it can be accessed at offsets 1, 9, 17, 25, etc.<\/li>\n@@ -240,6 +280,9 @@\n- * The alignment constraint used to access a segment is typically dictated by the shape of the data structure stored\n- * in the segment. For example, if the programmer wishes to store a sequence of 8-byte values in a native segment, then\n- * the segment should be allocated by specifying a 8-byte alignment constraint, either via {@link Arena#allocate(long, long)}\n- * or {@link Arena#allocate(MemoryLayout)}. These factories ensure that the off-heap region of memory backing\n- * the returned segment has a starting address that is 8-byte aligned. Subsequently, the programmer can access the\n- * segment at the offsets of interest -- 0, 8, 16, 24, etc -- in the knowledge that every such access is aligned.\n+ * The alignment constraint used to access a segment is typically dictated by the shape\n+ * of the data structure stored in the segment. For example, if the programmer wishes to\n+ * store a sequence of 8-byte values in a native segment, then the segment should be\n+ * allocated by specifying an 8-byte alignment constraint, either via\n+ * {@link Arena#allocate(long, long)} or {@link Arena#allocate(MemoryLayout)}. These\n+ * factories ensure that the off-heap region of memory backing the returned segment has\n+ * a starting address that is 8-byte aligned. Subsequently, the programmer can access the\n+ * segment at the offsets of interest -- 0, 8, 16, 24, etc -- in the knowledge that every\n+ * such access is aligned.\n@@ -247,11 +290,15 @@\n- * If the segment being accessed is a heap segment, then determining whether access is aligned is more complex.\n- * The address of the segment in physical memory is not known, and is not even fixed (it may change when the segment\n- * is relocated during garbage collection). This means that the address cannot be combined with the specified offset to\n- * determine a target address in physical memory. Since the alignment constraint <em>always<\/em> refers to alignment of\n- * addresses in physical memory, it is not possible in principle to determine if any offset in a heap segment is aligned.\n- * For example, suppose the programmer chooses a 8-byte alignment constraint and tries\n- * to access offset 16 in a heap segment. If the heap segment's address 0 corresponds to physical address 1000,\n- * then the target address (1016) would be aligned, but if address 0 corresponds to physical address 1004,\n- * then the target address (1020) would not be aligned. It is undesirable to allow access to target addresses that are\n- * aligned according to the programmer's chosen alignment constraint, but might not be predictably aligned in physical memory\n- * (e.g. because of platform considerations and\/or garbage collection behavior).\n+ * If the segment being accessed is a heap segment, then determining whether access\n+ * is aligned is more complex. The address of the segment in physical memory is not\n+ * known, and is not even fixed (it may change when the segment is relocated during\n+ * garbage collection). This means that the address cannot be combined with the\n+ * specified offset to determine a target address in physical memory. Since the\n+ * alignment constraint <em>always<\/em> refers to alignment of addresses in physical\n+ * memory, it is not possible in principle to determine if any offset in a heap segment\n+ * is aligned. For example, suppose the programmer chooses an 8-byte alignment\n+ * constraint and tries to access offset 16 in a heap segment. If the heap segment's\n+ * address 0 corresponds to physical address 1000, then the target address (1016) would\n+ * be aligned, but if address 0 corresponds to physical address 1004, then the target\n+ * address (1020) would not be aligned. It is undesirable to allow access to target\n+ * addresses that are aligned according to the programmer's chosen alignment constraint,\n+ * but might not be predictably aligned in physical memory (e.g. because of platform\n+ * considerations and\/or garbage collection behavior).\n@@ -259,5 +306,7 @@\n- * In practice, the Java runtime lays out arrays in memory so that each n-byte element occurs at an n-byte\n- * aligned physical address (except for {@code long[]} and {@code double[]}, where alignment is platform-dependent, as explained\n- * below). The runtime preserves this invariant even if the array is relocated during garbage collection.\n- * Access operations rely on this invariant to determine if the specified offset in a heap segment refers to an aligned\n- * address in physical memory. For example:\n+ * In practice, the Java runtime lays out arrays in memory so that each n-byte element\n+ * occurs at an n-byte aligned physical address (except for {@code long[]} and\n+ * {@code double[]}, where alignment is platform-dependent, as explained below). The\n+ * runtime preserves this invariant even if the array is relocated during garbage\n+ * collection. Access operations rely on this invariant to determine if the specified\n+ * offset in a heap segment refers to an aligned address in physical memory.\n+ * For example:\n@@ -265,20 +314,30 @@\n- * <li>The starting physical address of a {@code short[]} array will be 2-byte aligned (e.g. 1006) so that successive\n- * short elements occur at 2-byte aligned addresses (e.g. 1006, 1008, 1010, 1012, etc). A heap segment backed by a\n- * {@code short[]} array can be accessed at offsets 0, 2, 4, 6, etc under a 2-byte alignment constraint. The segment cannot\n- * be accessed at <em>any<\/em> offset under a 4-byte alignment constraint, because there is no guarantee that the target\n- * address would be 4-byte aligned, e.g., offset 0 would correspond to physical address 1006 while offset 1 would correspond\n- * to physical address 1007. Similarly, the segment cannot be accessed at any offset under an 8-byte alignment constraint,\n- * because because there is no guarantee that the target address would be 8-byte aligned, e.g., offset 2 would correspond\n- * to physical address 1008 but offset 4 would correspond to physical address 1010.<\/li>\n- * <li>The starting physical address of a {@code long[]} array will be 8-byte aligned (e.g. 1000) on 64-bit platforms,\n- * so that successive long elements occur at 8-byte aligned addresses (e.g., 1000, 1008, 1016, 1024, etc.) On 64-bit platforms,\n- * a heap segment backed by a {@code long[]} array can be accessed at offsets 0, 8, 16, 24, etc under an 8-byte alignment\n- * constraint. In addition, the segment can be accessed at offsets 0, 4, 8, 12, etc under a 4-byte alignment constraint,\n- * because the target addresses (1000, 1004, 1008, 1012) are 4-byte aligned. And, the segment can be accessed at offsets\n- * 0, 2, 4, 6, etc under a 2-byte alignment constraint, because the target addresses (e.g. 1000, 1002, 1004, 1006) are 2-byte aligned.<\/li>\n- * <li>The starting physical address of a {@code long[]} array will be 4-byte aligned (e.g. 1004) on 32-bit platforms,\n- * so that successive long elements occur at 4-byte aligned addresses (e.g., 1004, 1008, 1012, 1016, etc.) On 32-bit\n- * platforms, a heap segment backed by a {@code long[]} array can be accessed at offsets 0, 4, 8, 12, etc under a 4-byte\n- * alignment constraint, because the target addresses (1004, 1008, 1012, 1016) are 4-byte aligned. And, the segment\n- * can be accessed at offsets 0, 2, 4, 6, etc under a 2-byte alignment constraint, because the target addresses\n- * (e.g. 1000, 1002, 1004, 1006) are 2-byte aligned.<\/li>\n+ * <li>The starting physical address of a {@code short[]} array will be 2-byte aligned\n+ *     (e.g. 1006) so that successive short elements occur at 2-byte aligned addresses\n+ *     (e.g. 1006, 1008, 1010, 1012, etc). A heap segment backed by a {@code short[]}\n+ *     array can be accessed at offsets 0, 2, 4, 6, etc under a 2-byte alignment\n+ *     constraint. The segment cannot be accessed at <em>any<\/em> offset under a 4-byte\n+ *     alignment constraint, because there is no guarantee that the target address would\n+ *     be 4-byte aligned, e.g., offset 0 would correspond to physical address 1006 while\n+ *     offset 1 would correspond to physical address 1007. Similarly, the segment cannot\n+ *     be accessed at any offset under an 8-byte alignment constraint, because because\n+ *     there is no guarantee that the target address would be 8-byte aligned, e.g.,\n+ *     offset 2 would correspond to physical address 1008 but offset 4 would correspond\n+ *     to physical address 1010.<\/li>\n+ * <li>The starting physical address of a {@code long[]} array will be 8-byte aligned\n+ *     (e.g. 1000) on 64-bit platforms, so that successive long elements occur at 8-byte\n+ *     aligned addresses (e.g., 1000, 1008, 1016, 1024, etc.). On 64-bit platforms,\n+ *     a heap segment backed by a {@code long[]} array can be accessed at offsets\n+ *     0, 8, 16, 24, etc under an 8-byte alignment constraint. In addition, the segment\n+ *     can be accessed at offsets 0, 4, 8, 12, etc under a 4-byte alignment constraint,\n+ *     because the target addresses (1000, 1004, 1008, 1012) are 4-byte aligned. And,\n+ *     the segment can be accessed at offsets 0, 2, 4, 6, etc under a 2-byte alignment\n+ *     constraint, because the target addresses (e.g. 1000, 1002, 1004, 1006) are 2-byte\n+ *     aligned.<\/li>\n+ * <li>The starting physical address of a {@code long[]} array will be 4-byte aligned\n+ *     (e.g. 1004) on 32-bit platforms, so that successive long elements occur at 4-byte\n+ *     aligned addresses (e.g., 1004, 1008, 1012, 1016, etc.) On 32-bit\n+ *     platforms, a heap segment backed by a {@code long[]} array can be accessed at\n+ *     offsets 0, 4, 8, 12, etc under a 4-byte alignment constraint, because the target\n+ *     addresses (1004, 1008, 1012, 1016) are 4-byte aligned. And, the segment\n+ *     can be accessed at offsets 0, 2, 4, 6, etc under a 2-byte alignment constraint,\n+ *     because the target addresses (e.g. 1000, 1002, 1004, 1006) are 2-byte aligned.<\/li>\n@@ -287,2 +346,3 @@\n- * In other words, heap segments feature a (platform-dependent) <em>maximum<\/em> alignment which is derived from the\n- * size of the elements of the Java array backing the segment, as shown in the following table:\n+ * In other words, heap segments feature a (platform-dependent) <em>maximum<\/em>\n+ * alignment which is derived from the size of the elements of the Java array backing the\n+ * segment, as shown in the following table:\n@@ -318,4 +378,4 @@\n- * Heap segments can only be accessed using a layout whose alignment is smaller or equal to the\n- * maximum alignment associated with the heap segment. Attempting to access a heap segment using a layout\n- * whose alignment is greater than the maximum alignment associated with the heap segment will fail,\n- * as demonstrated in the following example:\n+ * Heap segments can only be accessed using a layout whose alignment is smaller or equal\n+ * to the maximum alignment associated with the heap segment. Attempting to access a\n+ * heap segment using a layout whose alignment is greater than the maximum alignment\n+ * associated with the heap segment will fail, as demonstrated in the following example:\n@@ -328,5 +388,7 @@\n- * In such circumstances, clients have two options. They can use a heap segment backed by a different array\n- * type (e.g. {@code long[]}), capable of supporting greater maximum alignment. More specifically, the maximum alignment\n- * associated with {@code long[]} is set to {@code ValueLayout.JAVA_LONG.byteAlignment()} which is a platform-dependent\n- * value (set to {@code ValueLayout.ADDRESS.byteSize()}). That is, {@code long[]}) is guaranteed to provide at least\n- * 8-byte alignment in 64-bit platforms, but only 4-byte alignment in 32-bit platforms:\n+ * In such circumstances, clients have two options. They can use a heap segment backed\n+ * by a different array type (e.g. {@code long[]}), capable of supporting greater maximum\n+ * alignment. More specifically, the maximum alignment associated with {@code long[]} is\n+ * set to {@code ValueLayout.JAVA_LONG.byteAlignment()} which is a platform-dependent\n+ * value (set to {@code ValueLayout.ADDRESS.byteSize()}). That is, {@code long[]}) is\n+ * guaranteed to provide at least 8-byte alignment in 64-bit platforms, but only 4-byte\n+ * alignment in 32-bit platforms:\n@@ -340,1 +402,2 @@\n- * All unaligned layout constants (e.g. {@link ValueLayout#JAVA_INT_UNALIGNED}) have their alignment constraint set to 1:\n+ * All unaligned layout constants (e.g. {@link ValueLayout#JAVA_INT_UNALIGNED}) have\n+ * their alignment constraint set to 1:\n@@ -348,9 +411,13 @@\n- * When interacting with <a href=\"package-summary.html#ffa\">foreign functions<\/a>, it is common for those functions\n- * to allocate a region of memory and return a pointer to that region. Modeling the region of memory with a memory segment\n- * is challenging because the Java runtime has no insight into the size of the region. Only the address of the start of\n- * the region, stored in the pointer, is available. For example, a C function with return type {@code char*} might return\n- * a pointer to a region containing a single {@code char} value, or to a region containing an array of {@code char} values,\n- * where the size of the array might be provided in a separate parameter. The size of the array is not readily apparent\n- * to the code calling the foreign function and hoping to use its result. In addition to having no insight\n- * into the size of the region of memory backing a pointer returned from a foreign function, it also has no insight\n- * into the lifetime intended for said region of memory by the foreign function that allocated it.\n+ * When interacting with <a href=\"package-summary.html#ffa\">foreign functions<\/a>, it is\n+ * common for those functions to allocate a region of memory and return a pointer to that\n+ * region. Modeling the region of memory with a memory segment is challenging because\n+ * the Java runtime has no insight into the size of the region. Only the address of the\n+ * start of the region, stored in the pointer, is available. For example, a C function\n+ * with return type {@code char*} might return a pointer to a region containing a single\n+ * {@code char} value, or to a region containing an array of {@code char} values, where\n+ * the size of the array might be provided in a separate parameter. The size of the\n+ * array is not readily apparent to the code calling the foreign function and hoping to\n+ * use its result. In addition to having no insight into the size of the region of\n+ * memory backing a pointer returned from a foreign function, it also has no insight\n+ * into the lifetime intended for said region of memory by the foreign function that\n+ * allocated it.\n@@ -361,1 +428,2 @@\n- *     <li>pointers <a href=\"Linker.html#function-pointers\">passed by a foreign function to an upcall stub<\/a>; and<\/li>\n+ *     <li>pointers <a href=\"Linker.html#function-pointers\">passed by a foreign function\n+ *         to an upcall stub<\/a>; and<\/li>\n@@ -364,2 +432,2 @@\n- * The address of the zero-length segment is the address stored in the pointer. The spatial and temporal bounds of the\n- * zero-length segment are as follows:\n+ * The address of the zero-length segment is the address stored in the pointer.\n+ * The spatial and temporal bounds of the zero-length segment are as follows:\n@@ -367,5 +435,6 @@\n- *     <li>The size of the segment is zero. any attempt to access these segments will fail with {@link IndexOutOfBoundsException}.\n- *     This is a crucial safety feature: as these segments are associated with a region\n- *     of memory whose size is not known, any access operations involving these segments cannot be validated.\n- *     In effect, a zero-length memory segment <em>wraps<\/em> an address, and it cannot be used without explicit intent\n- *     (see below);<\/li>\n+ *     <li>The size of the segment is zero. Any attempt to access these segments will\n+ *     fail with {@link IndexOutOfBoundsException}. This is a crucial safety feature: as\n+ *     these segments are associated with a region of memory whose size is not known, any\n+ *     access operations involving these segments cannot be validated. In effect, a\n+ *     zero-length memory segment <em>wraps<\/em> an address, and it cannot be used\n+ *     without explicit intent (see below);<\/li>\n@@ -373,1 +442,2 @@\n- *     memory segments cannot be accessed directly, they can be passed, opaquely, to other pointer-accepting foreign functions.<\/li>\n+ *     memory segments cannot be accessed directly, they can be passed, opaquely, to\n+ *     other pointer-accepting foreign functions.<\/li>\n@@ -376,7 +446,9 @@\n- * To demonstrate how clients can work with zero-length memory segments, consider the case of a client that wants\n- * to read a pointer from some memory segment. This can be done via the\n- * {@linkplain MemorySegment#get(AddressLayout, long)} access method. This method accepts an\n- * {@linkplain AddressLayout address layout} (e.g. {@link ValueLayout#ADDRESS}), the layout of the pointer\n- * to be read. For instance on a 64-bit platform, the size of an address layout is 8 bytes. The access operation\n- * also accepts an offset, expressed in bytes, which indicates the position (relative to the start of the memory segment)\n- * at which the pointer is stored. The access operation returns a zero-length native memory segment, backed by a region\n+ * To demonstrate how clients can work with zero-length memory segments, consider the\n+ * case of a client that wants to read a pointer from some memory segment. This can\n+ * be done via the {@linkplain MemorySegment#get(AddressLayout, long)} access method.\n+ * This method accepts an {@linkplain AddressLayout address layout}\n+ * (e.g. {@link ValueLayout#ADDRESS}), the layout of the pointer to be read. For instance\n+ * on a 64-bit platform, the size of an address layout is 8 bytes. The access operation\n+ * also accepts an offset, expressed in bytes, which indicates the position\n+ * (relative to the start of the memory segment) at which the pointer is stored. The\n+ * access operation returns a zero-length native memory segment, backed by a region\n@@ -385,3 +457,4 @@\n- * The returned zero-length memory segment cannot be accessed directly by the client: since the size of the segment\n- * is zero, any access operation would result in out-of-bounds access. Instead, the client must, <em>unsafely<\/em>,\n- * assign new spatial bounds to the zero-length memory segment. This can be done via the\n+ * The returned zero-length memory segment cannot be accessed directly by the client:\n+ * since the size of the segment is zero, any access operation would result in\n+ * out-of-bounds access. Instead, the client must, <em>unsafely<\/em>, assign new spatial\n+ * bounds to the zero-length memory segment. This can be done via the\n@@ -396,3 +469,4 @@\n- * In some cases, the client might additionally want to assign new temporal bounds to a zero-length memory segment.\n- * This can be done via the {@link #reinterpret(long, Arena, Consumer)} method, which returns a\n- * new native segment with the desired size and the same temporal bounds as those of the provided arena:\n+ * In some cases, the client might additionally want to assign new temporal bounds to a\n+ * zero-length memory segment. This can be done via the\n+ * {@link #reinterpret(long, Arena, Consumer)} method, which returns a new native segment\n+ * with the desired size and the same temporal bounds as those of the provided arena:\n@@ -410,2 +484,3 @@\n- * Alternatively, if the size of the region of memory backing the zero-length memory segment is known statically,\n- * the client can overlay a {@linkplain AddressLayout#withTargetLayout(MemoryLayout) target layout} on the address\n+ * Alternatively, if the size of the region of memory backing the zero-length memory\n+ * segment is known statically, the client can overlay a\n+ * {@linkplain AddressLayout#withTargetLayout(MemoryLayout) target layout} on the address\n@@ -413,3 +488,4 @@\n- * <em>expand<\/em> the size of the native memory segment returned by the access operation, so that the size\n- * of the segment is the same as the size of the target layout. In other words, the returned segment is no\n- * longer a zero-length memory segment, and the pointer it represents can be dereferenced directly:\n+ * <em>expand<\/em> the size of the native memory segment returned by the access operation\n+ * so that the size of the segment is the same as the size of the target layout . In other\n+ * words, the returned segment is no longer a zero-length memory segment, and the pointer\n+ * it represents can be de-referenced directly:\n@@ -427,3 +503,3 @@\n- * <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a> methods, and should be used with caution:\n- * assigning a segment incorrect spatial and\/or temporal bounds could result in a VM crash when attempting to access\n- * the memory segment.\n+ * <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a> methods, and should\n+ * be used with caution: assigning a segment incorrect spatial and\/or temporal bounds\n+ * could result in a VM crash when attempting to access the memory segment.\n@@ -432,1 +508,2 @@\n- * Implementations of this interface are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ * Implementations of this interface are immutable, thread-safe and\n+ * <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n@@ -441,5 +518,7 @@\n-     * @apiNote When using this method to pass a segment address to some external operation (e.g. a JNI function),\n-     * clients must ensure that the segment is kept <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">reachable<\/a>\n-     * for the entire duration of the operation. A failure to do so might result in the premature deallocation of the\n-     * region of memory backing the memory segment, in case the segment has been allocated with an\n-     * {@linkplain Arena#ofAuto() automatic arena}.\n+     * @apiNote When using this method to pass a segment address to some external\n+     *          operation (e.g. a JNI function), clients must ensure that the segment is\n+     *          kept <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">reachable<\/a>\n+     *          for the entire duration of the operation. A failure to do so might result\n+     *          in the premature de-allocation of the region of memory backing the memory\n+     *          segment, in case the segment has been allocated with an\n+     *          {@linkplain Arena#ofAuto() automatic arena}.\n@@ -450,5 +529,9 @@\n-     * Returns the Java object stored in the on-heap region of memory backing this memory segment, if any. For instance, if this\n-     * memory segment is a heap segment created with the {@link #ofArray(byte[])} factory method, this method will return the\n-     * {@code byte[]} object which was used to obtain the segment. This method returns an empty {@code Optional} value\n-     * if either this segment is a {@linkplain #isNative() native} segment, or if this segment is {@linkplain #isReadOnly() read-only}.\n-     * @return the Java object associated with this memory segment, if any.\n+     * Returns the Java object stored in the on-heap region of memory backing this memory\n+     * segment, if any. For instance, if this memory segment is a heap segment created\n+     * with the {@link #ofArray(byte[])} factory method, this method will return the\n+     * {@code byte[]} object which was used to obtain the segment. This method returns\n+     * an empty {@code Optional} value if either this segment is a\n+     * {@linkplain #isNative() native} segment, or if this segment is\n+     * {@linkplain #isReadOnly() read-only}.\n+     *\n+     * @return the Java object associated with this memory segment, if any\n@@ -459,3 +542,3 @@\n-     * Returns a spliterator for this memory segment. The returned spliterator reports {@link Spliterator#SIZED},\n-     * {@link Spliterator#SUBSIZED}, {@link Spliterator#IMMUTABLE}, {@link Spliterator#NONNULL} and {@link Spliterator#ORDERED}\n-     * characteristics.\n+     * Returns a spliterator for this memory segment. The returned spliterator reports\n+     * {@link Spliterator#SIZED}, {@link Spliterator#SUBSIZED}, {@link Spliterator#IMMUTABLE},\n+     * {@link Spliterator#NONNULL} and {@link Spliterator#ORDERED} characteristics.\n@@ -463,5 +546,7 @@\n-     * The returned spliterator splits this segment according to the specified element layout; that is,\n-     * if the supplied layout has size N, then calling {@link Spliterator#trySplit()} will result in a spliterator serving\n-     * approximately {@code S\/N} elements (depending on whether N is even or not), where {@code S} is the size of\n-     * this segment. As such, splitting is possible as long as {@code S\/N >= 2}. The spliterator returns segments that\n-     * have the same lifetime as that of this segment.\n+     * The returned spliterator splits this segment according to the specified element\n+     * layout; that is, if the supplied layout has size N, then calling\n+     * {@link Spliterator#trySplit()} will result in a spliterator serving approximately\n+     * {@code S\/N} elements (depending on whether N is even or not), where {@code S} is\n+     * the size of this segment. As such, splitting is possible as long as\n+     * {@code S\/N >= 2}. The spliterator returns segments that have the same lifetime as\n+     * that of this segment.\n@@ -469,2 +554,3 @@\n-     * The returned spliterator effectively allows to slice this segment into disjoint {@linkplain #asSlice(long, long) slices},\n-     * which can then be processed in parallel by multiple threads.\n+     * The returned spliterator effectively allows to slice this segment into disjoint\n+     * {@linkplain #asSlice(long, long) slices}, which can then be processed in parallel\n+     * by multiple threads.\n@@ -472,1 +558,1 @@\n-     * @param elementLayout the layout to be used for splitting.\n+     * @param elementLayout the layout to be used for splitting\n@@ -477,2 +563,3 @@\n-     * @throws IllegalArgumentException if this segment is <a href=\"MemorySegment.html#segment-alignment\">incompatible\n-     *         with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if this segment is\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in the provided layout.\n@@ -483,2 +570,3 @@\n-     * Returns a sequential {@code Stream} over disjoint slices (whose size matches that of the specified layout)\n-     * in this segment. Calling this method is equivalent to the following code:\n+     * Returns a sequential {@code Stream} over disjoint slices (whose size matches that\n+     * of the specified layout) in this segment. Calling this method is equivalent to\n+     * the following code:\n@@ -489,2 +577,2 @@\n-     * @param elementLayout the layout to be used for splitting.\n-     * @return a sequential {@code Stream} over disjoint slices in this segment.\n+     * @param elementLayout the layout to be used for splitting\n+     * @return a sequential {@code Stream} over disjoint slices in this segment\n@@ -494,2 +582,3 @@\n-     * @throws IllegalArgumentException if this segment is <a href=\"MemorySegment.html#segment-alignment\">incompatible\n-     *         with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if this segment is\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in the provided layout\n@@ -506,1 +595,1 @@\n-     * @param thread the thread to be tested.\n+     * @param thread the thread to be tested\n@@ -516,2 +605,3 @@\n-     * Returns a slice of this memory segment, at the given offset. The returned segment's address is the address\n-     * of this segment plus the given offset; its size is specified by the given argument.\n+     * Returns a slice of this memory segment, at the given offset. The returned\n+     * segment's address is the address of this segment plus the given offset;\n+     * its size is specified by the given argument.\n@@ -526,5 +616,6 @@\n-     * @param offset The new segment base offset (relative to the address of this segment), specified in bytes.\n-     * @param newSize The new segment size, specified in bytes.\n-     * @return a slice of this memory segment.\n-     * @throws IndexOutOfBoundsException if {@code offset < 0}, {@code offset > byteSize()}, {@code newSize < 0},\n-     *         or {@code newSize > byteSize() - offset}\n+     * @param offset The new segment base offset (relative to the address of this segment),\n+     *               specified in bytes\n+     * @param newSize The new segment size, specified in bytes\n+     * @return a slice of this memory segment\n+     * @throws IndexOutOfBoundsException if {@code offset < 0}, {@code offset > byteSize()},\n+     *         {@code newSize < 0}, or {@code newSize > byteSize() - offset}\n@@ -535,2 +626,3 @@\n-     * Returns a slice of this memory segment, at the given offset, with the provided alignment constraint.\n-     * The returned segment's address is the address of this segment plus the given offset; its size is specified by the given argument.\n+     * Returns a slice of this memory segment, at the given offset, with the provided\n+     * alignment constraint. The returned segment's address is the address of this\n+     * segment plus the given offset; its size is specified by the given argument.\n@@ -538,6 +630,7 @@\n-     * @param offset The new segment base offset (relative to the address of this segment), specified in bytes.\n-     * @param newSize The new segment size, specified in bytes.\n-     * @param byteAlignment The alignment constraint (in bytes) of the returned slice.\n-     * @return a slice of this memory segment.\n-     * @throws IndexOutOfBoundsException if {@code offset < 0}, {@code offset > byteSize()}, {@code newSize < 0},\n-     *         or {@code newSize > byteSize() - offset}\n+     * @param offset The new segment base offset (relative to the address of this segment),\n+     *               specified in bytes\n+     * @param newSize The new segment size, specified in bytes\n+     * @param byteAlignment The alignment constraint (in bytes) of the returned slice\n+     * @return a slice of this memory segment\n+     * @throws IndexOutOfBoundsException if {@code offset < 0}, {@code offset > byteSize()},\n+     *         {@code newSize < 0}, or {@code newSize > byteSize() - offset}\n@@ -546,1 +639,2 @@\n-     * @throws IllegalArgumentException if {@code byteAlignment <= 0}, or if {@code byteAlignment} is not a power of 2\n+     * @throws IllegalArgumentException if {@code byteAlignment <= 0}, or if\n+     *         {@code byteAlignment} is not a power of 2\n@@ -551,2 +645,3 @@\n-     * Returns a slice of this memory segment with the given layout, at the given offset. The returned segment's address is the address\n-     * of this segment plus the given offset; its size is the same as the size of the provided layout.\n+     * Returns a slice of this memory segment with the given layout, at the given offset.\n+     * The returned segment's address is the address of this segment plus the given\n+     * offset; its size is the same as the size of the provided layout.\n@@ -561,2 +656,3 @@\n-     * @param offset The new segment base offset (relative to the address of this segment), specified in bytes.\n-     * @param layout The layout of the segment slice.\n+     * @param offset The new segment base offset (relative to the address of this segment),\n+     *               specified in bytes\n+     * @param layout The layout of the segment slice\n@@ -565,3 +661,3 @@\n-     * @throws IllegalArgumentException if this segment cannot be accessed at {@code offset} under\n-     *         the alignment constraint specified by {@code layout}\n-     * @return a slice of this memory segment.\n+     * @throws IllegalArgumentException if this segment cannot be accessed at {@code offset}\n+     *         under the alignment constraint specified by {@code layout}\n+     * @return a slice of this memory segment\n@@ -572,2 +668,3 @@\n-     * Returns a slice of this memory segment, at the given offset. The returned segment's address is the address\n-     * of this segment plus the given offset; its size is computed by subtracting the specified offset from this segment size.\n+     * Returns a slice of this memory segment, at the given offset. The returned\n+     * segment's address is the address of this segment plus the given offset; its size\n+     * is computed by subtracting the specified offset from this segment size.\n@@ -582,2 +679,3 @@\n-     * @param offset The new segment base offset (relative to the address of this segment), specified in bytes.\n-     * @return a slice of this memory segment.\n+     * @param offset The new segment base offset (relative to the address of this segment),\n+     *               specified in bytes\n+     * @return a slice of this memory segment\n@@ -589,1 +687,2 @@\n-     * Returns a new memory segment that has the same address and scope as this segment, but with the provided size.\n+     * Returns a new memory segment that has the same address and scope as this segment,\n+     * but with the provided size.\n@@ -591,3 +690,3 @@\n-     * @param newSize the size of the returned segment.\n-     * @return a new memory segment that has the same address and scope as this segment, but the new\n-     * provided size.\n+     * @param newSize the size of the returned segment\n+     * @return a new memory segment that has the same address and scope as\n+     *         this segment, but the new provided size\n@@ -595,2 +694,4 @@\n-     * @throws UnsupportedOperationException if this segment is not a {@linkplain #isNative() native} segment\n-     * @throws IllegalCallerException if the caller is in a module that does not have native access enabled\n+     * @throws UnsupportedOperationException if this segment is not a\n+     *         {@linkplain #isNative() native} segment\n+     * @throws IllegalCallerException if the caller is in a module that does not have\n+     *         native access enabled\n@@ -603,7 +704,9 @@\n-     * Returns a new memory segment with the same address and size as this segment, but with the provided scope.\n-     * As such, the returned segment cannot be accessed after the provided arena has been closed.\n-     * Moreover, the returned segment can be accessed compatibly with the confinement restrictions associated with the\n-     * provided arena: that is, if the provided arena is a {@linkplain Arena#ofConfined() confined arena},\n-     * the returned segment can only be accessed by the arena's owner thread, regardless of the confinement restrictions\n-     * associated with this segment. In other words, this method returns a segment that behaves as if it had been allocated\n-     * using the provided arena.\n+     * Returns a new memory segment with the same address and size as this segment, but\n+     * with the provided scope. As such, the returned segment cannot be accessed after\n+     * the provided arena has been closed. Moreover, the returned segment can be\n+     * accessed compatibly with the confinement restrictions associated with the provided\n+     * arena: that is, if the provided arena is a {@linkplain Arena#ofConfined() confined arena},\n+     * the returned segment can only be accessed by the arena's owner thread, regardless\n+     * of the confinement restrictions associated with this segment. In other words, this\n+     * method returns a segment that behaves as if it had been allocated using the\n+     * provided arena.\n@@ -611,2 +714,3 @@\n-     * Clients can specify an optional cleanup action that should be executed when the provided scope becomes\n-     * invalid. This cleanup action receives a fresh memory segment that is obtained from this segment as follows:\n+     * Clients can specify an optional cleanup action that should be executed when the\n+     * provided scope becomes invalid. This cleanup action receives a fresh memory\n+     * segment that is obtained from this segment as follows:\n@@ -617,12 +721,17 @@\n-     * That is, the cleanup action receives a segment that is associated with the global scope,\n-     * and is accessible from any thread. The size of the segment accepted by the cleanup action is {@link #byteSize()}.\n-     *\n-     * @apiNote The cleanup action (if present) should take care not to leak the received segment to external\n-     * clients which might access the segment after its backing region of memory is no longer available. Furthermore,\n-     * if the provided scope is the scope of an {@linkplain Arena#ofAuto() automatic arena}, the cleanup action\n-     * must not prevent the scope from becoming <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n-     * A failure to do so will permanently prevent the regions of memory allocated by the automatic arena from being deallocated.\n-     *\n-     * @param arena the arena to be associated with the returned segment.\n-     * @param cleanup the cleanup action that should be executed when the provided arena is closed (can be {@code null}).\n-     * @return a new memory segment with unbounded size.\n+     * That is, the cleanup action receives a segment that is associated with the global\n+     * scope, and is accessible from any thread. The size of the segment accepted by the\n+     * cleanup action is {@link #byteSize()}.\n+     *\n+     * @apiNote The cleanup action (if present) should take care not to leak the received\n+     *          segment to external clients which might access the segment after its\n+     *          backing region of memory is no longer available. Furthermore,\n+     *          if the provided scope is the scope of an {@linkplain Arena#ofAuto() automatic arena},\n+     *          the cleanup action must not prevent the scope from becoming\n+     *          <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n+     *          A failure to do so will permanently prevent the regions of memory\n+     *          allocated by the automatic arena from being deallocated.\n+     *\n+     * @param arena the arena to be associated with the returned segment\n+     * @param cleanup the cleanup action that should be executed when the provided arena\n+     *                is closed (can be {@code null})\n+     * @return a new memory segment with unbounded size\n@@ -630,2 +739,4 @@\n-     * @throws UnsupportedOperationException if this segment is not a {@linkplain #isNative() native} segment\n-     * @throws IllegalCallerException if the caller is in a module that does not have native access enabled\n+     * @throws UnsupportedOperationException if this segment is not a\n+     *         {@linkplain #isNative() native} segment\n+     * @throws IllegalCallerException if the caller is in a module that does not have\n+     *         native access enabled\n@@ -638,7 +749,9 @@\n-     * Returns a new segment with the same address as this segment, but with the provided size and scope.\n-     * As such, the returned segment cannot be accessed after the provided arena has been closed.\n-     * Moreover, if the returned segment can be accessed compatibly with the confinement restrictions associated with the\n-     * provided arena: that is, if the provided arena is a {@linkplain Arena#ofConfined() confined arena},\n-     * the returned segment can only be accessed by the arena's owner thread, regardless of the confinement restrictions\n-     * associated with this segment. In other words, this method returns a segment that behaves as if it had been allocated\n-     * using the provided arena.\n+     * Returns a new segment with the same address as this segment, but with the provided\n+     * size and scope. As such, the returned segment cannot be accessed after the\n+     * provided arena has been closed. Moreover, if the returned segment can be accessed\n+     * compatibly with the confinement restrictions associated with the provided arena:\n+     * that is, if the provided arena is a {@linkplain Arena#ofConfined() confined arena},\n+     * the returned segment can only be accessed by the arena's owner thread, regardless\n+     * of the confinement restrictions associated with this segment. In other words,\n+     * this method returns a segment that behaves as if it had been allocated using the\n+     * provided arena.\n@@ -646,2 +759,3 @@\n-     * Clients can specify an optional cleanup action that should be executed when the provided scope becomes\n-     * invalid. This cleanup action receives a fresh memory segment that is obtained from this segment as follows:\n+     * Clients can specify an optional cleanup action that should be executed when the\n+     * provided scope becomes invalid. This cleanup action receives a fresh memory\n+     * segment that is obtained from this segment as follows:\n@@ -652,15 +766,21 @@\n-     * That is, the cleanup action receives a segment that is associated with the global scope,\n-     * and is accessible from any thread. The size of the segment accepted by the cleanup action is {@code newSize}.\n-     *\n-     * @apiNote The cleanup action (if present) should take care not to leak the received segment to external\n-     * clients which might access the segment after its backing region of memory is no longer available. Furthermore,\n-     * if the provided scope is the scope of an {@linkplain Arena#ofAuto() automatic arena}, the cleanup action\n-     * must not prevent the scope from becoming <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n-     * A failure to do so will permanently prevent the regions of memory allocated by the automatic arena from being deallocated.\n-     *\n-     * @param newSize the size of the returned segment.\n-     * @param arena the arena to be associated with the returned segment.\n-     * @param cleanup the cleanup action that should be executed when the provided arena is closed (can be {@code null}).\n-     * @return a new segment that has the same address as this segment, but with new size and its scope set to\n-     * that of the provided arena.\n-     * @throws UnsupportedOperationException if this segment is not a {@linkplain #isNative() native} segment\n+     * That is, the cleanup action receives a segment that is associated with the global\n+     * scope, and is accessible from any thread. The size of the segment accepted by the\n+     * cleanup action is {@code newSize}.\n+     *\n+     * @apiNote The cleanup action (if present) should take care not to leak the received\n+     *          segment to external clients which might access the segment after its\n+     *          backing region of memory is no longer available. Furthermore, if the\n+     *          provided scope is the scope of an {@linkplain Arena#ofAuto() automatic arena},\n+     *          the cleanup action must not prevent the scope from becoming\n+     *          <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n+     *          A failure to do so will permanently prevent the regions of memory\n+     *          allocated by the automatic arena from being deallocated.\n+     *\n+     * @param newSize the size of the returned segment\n+     * @param arena the arena to be associated with the returned segment\n+     * @param cleanup the cleanup action that should be executed when the provided arena\n+     *                is closed (can be {@code null})\n+     * @return a new segment that has the same address as this segment, but with new size\n+     *         and its scope set to that of the provided arena\n+     * @throws UnsupportedOperationException if this segment is not a\n+     *         {@linkplain #isNative() native} segment\n@@ -669,1 +789,2 @@\n-     * @throws IllegalCallerException if the caller is in a module that does not have native access enabled\n+     * @throws IllegalCallerException if the caller is in a module that does not have\n+     *         native access enabled\n@@ -682,3 +803,5 @@\n-     * Returns a read-only view of this segment. The resulting segment will be identical to this one, but\n-     * attempts to overwrite the contents of the returned segment will cause runtime exceptions.\n-     * @return a read-only view of this segment\n+     * {@return a read-only view of this segment}\n+     *\n+     * The resulting segment will be identical to this one, but attempts to overwrite the\n+     * contents of the returned segment will cause runtime exceptions.\n+     *\n@@ -690,4 +813,6 @@\n-     * Returns {@code true} if this segment is a native segment. A native segment is\n-     * created e.g. using the {@link Arena#allocate(long, long)} (and related) factory, or by\n-     * {@linkplain #ofBuffer(Buffer) wrapping} a {@linkplain ByteBuffer#allocateDirect(int) direct buffer}.\n-     * @return {@code true} if this segment is native segment.\n+     * {@return {@code true} if this segment is a native segment}\n+     *\n+     * A native segment is created e.g. using the\n+     * {@link Arena#allocate(long, long)} (and related) factory, or by\n+     * {@linkplain #ofBuffer(Buffer) wrapping} a\n+     * {@linkplain ByteBuffer#allocateDirect(int) direct buffer}.\n@@ -698,1 +823,3 @@\n-     * Returns {@code true} if this segment is a mapped segment. A mapped memory segment is created e.g. using the\n+     * {@return {@code true} if this segment is a mapped segment}\n+     *\n+     * A mapped memory segment is created e.g. using the\n@@ -700,2 +827,2 @@\n-     * {@linkplain #ofBuffer(Buffer) wrapping} a {@linkplain java.nio.MappedByteBuffer mapped byte buffer}.\n-     * @return {@code true} if this segment is a mapped segment.\n+     * {@linkplain #ofBuffer(Buffer) wrapping} a\n+     * {@linkplain java.nio.MappedByteBuffer mapped byte buffer}.\n@@ -706,2 +833,2 @@\n-     * Returns a slice of this segment that is the overlap between this and\n-     * the provided segment.\n+     * Returns a slice of this segment that is the overlap between this and the provided\n+     * segment.\n@@ -709,5 +836,6 @@\n-     * <p>Two segments {@code S1} and {@code S2} are said to overlap if it is possible to find\n-     * at least two slices {@code L1} (from {@code S1}) and {@code L2} (from {@code S2}) that are backed by the\n-     * same region of memory. As such, it is not possible for a\n-     * {@linkplain #isNative() native} segment to overlap with a heap segment; in\n-     * this case, or when no overlap occurs, an empty {@code Optional} is returned.\n+     * <p>Two segments {@code S1} and {@code S2} are said to overlap if it is possible to\n+     * find at least two slices {@code L1} (from {@code S1}) and {@code L2}\n+     * (from {@code S2}) that are backed by the same region of memory. As such, it is\n+     * not possible for a {@linkplain #isNative() native} segment to overlap with a heap\n+     * segment; in this case, or when no overlap occurs, an empty {@code Optional} is\n+     * returned.\n@@ -715,2 +843,2 @@\n-     * @param other the segment to test for an overlap with this segment.\n-     * @return a slice of this segment (where overlapping occurs).\n+     * @param other the segment to test for an overlap with this segment\n+     * @return a slice of this segment (where overlapping occurs)\n@@ -737,4 +865,4 @@\n-     * @param value the value to write into this segment.\n-     * @return this memory segment.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @param value the value to write into this segment\n+     * @return this memory segment\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -743,1 +871,2 @@\n-     * @throws UnsupportedOperationException if this segment is {@linkplain #isReadOnly() read-only}\n+     * @throws UnsupportedOperationException if this segment is\n+     *         {@linkplain #isReadOnly() read-only}\n@@ -748,3 +877,4 @@\n-     * Performs a bulk copy from given source segment to this segment. More specifically, the bytes at\n-     * offset {@code 0} through {@code src.byteSize() - 1} in the source segment are copied into this segment\n-     * at offset {@code 0} through {@code src.byteSize() - 1}.\n+     * Performs a bulk copy from given source segment to this segment. More specifically,\n+     * the bytes at offset {@code 0} through {@code src.byteSize() - 1} in the source\n+     * segment are copied into this segment at offset {@code 0} through\n+     * {@code src.byteSize() - 1}.\n@@ -756,1 +886,1 @@\n-     * @param src the source segment.\n+     * @param src the source segment\n@@ -758,2 +888,2 @@\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -762,2 +892,2 @@\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with {@code src} is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         {@code src} is not {@linkplain Scope#isAlive() alive}\n@@ -766,2 +896,3 @@\n-     * @throws UnsupportedOperationException if this segment is {@linkplain #isReadOnly() read-only}\n-     * @return this segment.\n+     * @throws UnsupportedOperationException if this segment is\n+     *         {@linkplain #isReadOnly() read-only}\n+     * @return this segment\n@@ -786,1 +917,1 @@\n-     * @param other the segment to be tested for a mismatch with this segment.\n+     * @param other the segment to be tested for a mismatch with this segment\n@@ -788,3 +919,3 @@\n-     * and the given other segment, otherwise -1 if no mismatch.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * and the given other segment, otherwise -1 if no mismatch\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -793,2 +924,2 @@\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with {@code other} is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         {@code other} is not {@linkplain Scope#isAlive() alive}\n@@ -807,1 +938,1 @@\n-     * faults or I\/O operations.  A return value of {@code false} does not\n+     * faults or I\/O operations. A return value of {@code false} does not\n@@ -818,2 +949,2 @@\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -822,2 +953,2 @@\n-     * @throws UnsupportedOperationException if this segment is not a mapped memory segment, e.g. if\n-     *         {@code isMapped() == false}.\n+     * @throws UnsupportedOperationException if this segment is not a mapped memory\n+     *         segment, e.g. if {@code isMapped() == false}\n@@ -829,3 +960,3 @@\n-     *\n-     * <p> This method makes a best effort to ensure that, when it returns,\n-     * this contents of this segment is resident in physical memory.  Invoking this\n+     * <p>\n+     * This method makes a best effort to ensure that, when it returns,\n+     * this contents of this segment is resident in physical memory. Invoking this\n@@ -835,6 +966,6 @@\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n-     * @throws WrongThreadException if this method is called from a thread {@code T},\n-     *         such that {@code isAccessibleBy(T) == false}\n-     * @throws UnsupportedOperationException if this segment is not a mapped memory segment, e.g. if\n-     *         {@code isMapped() == false}\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n+     * @throws WrongThreadException if this method is called from a thread\n+     *         {@code T}, such that {@code isAccessibleBy(T) == false}\n+     * @throws UnsupportedOperationException if this segment is not a mapped memory\n+     *         segment, e.g. if {@code isMapped() == false}\n@@ -846,0 +977,5 @@\n+     *<p>\n+     * This method makes a best effort to ensure that the contents of this segment\n+     * are are no longer resident in physical memory. Accessing this segment's contents\n+     * after invoking this method may cause some number of page faults and I\/O operations\n+     * to occur (as this segment's contents might need to be paged back in). <\/p>\n@@ -847,7 +983,2 @@\n-     * <p> This method makes a best effort to ensure that the contents of this segment are\n-     * are no longer resident in physical memory. Accessing this segment's contents\n-     * after invoking this method may cause some number of page faults and I\/O operations to\n-     * occur (as this segment's contents might need to be paged back in). <\/p>\n-     *\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -856,2 +987,2 @@\n-     * @throws UnsupportedOperationException if this segment is not a mapped memory segment, e.g. if\n-     *         {@code isMapped() == false}\n+     * @throws UnsupportedOperationException if this segment is not a mapped memory\n+     *         segment, e.g. if {@code isMapped() == false}\n@@ -862,18 +993,16 @@\n-     * Forces any changes made to the contents of this mapped segment to be written to the\n-     * storage device described by the mapped segment's file descriptor.\n-     *\n-     * <p> If the file descriptor associated with this mapped segment resides on a local storage\n-     * device then when this method returns it is guaranteed that all changes\n-     * made to this segment since it was created, or since this method was last\n-     * invoked, will have been written to that device.\n-     *\n-     * <p> If the file descriptor associated with this mapped segment does not reside on a local device then\n-     * no such guarantee is made.\n-     *\n-     * <p> If this segment was not mapped in read\/write mode ({@link\n-     * java.nio.channels.FileChannel.MapMode#READ_WRITE}) then\n-     * invoking this method may have no effect. In particular, the\n-     * method has no effect for segments mapped in read-only or private\n-     * mapping modes. This method may or may not have an effect for\n-     * implementation-specific mapping modes.\n-     * <\/p>\n+     * Forces any changes made to the contents of this mapped segment to be written to\n+     * the storage device described by the mapped segment's file descriptor.\n+     * <p>\n+     * If the file descriptor associated with this mapped segment resides on a local\n+     * storage device then when this method returns it is guaranteed that all changes\n+     * made to this segment since it was created, or since this method was last invoked,\n+     * will have been written to that device.\n+     * <p>\n+     * If the file descriptor associated with this mapped segment does not reside on\n+     * a local device then no such guarantee is made.\n+     * <p>\n+     * If this segment was not mapped in read\/write mode\n+     * ({@link java.nio.channels.FileChannel.MapMode#READ_WRITE}) then invoking this\n+     * method may have no effect. In particular, the method has no effect for segments\n+     * mapped in read-only or private mapping modes. This method may or may not have an\n+     * effect for implementation-specific mapping modes.\n@@ -893,2 +1022,3 @@\n-     * Wraps this segment in a {@link ByteBuffer}. Some properties of the returned buffer are linked to\n-     * the properties of this segment. More specifically, the resulting buffer has the following characteristics:\n+     * Wraps this segment in a {@link ByteBuffer}. Some properties of the returned buffer\n+     * are linked to the properties of this segment. More specifically, the resulting\n+     * buffer has the following characteristics:\n@@ -899,4 +1029,6 @@\n-     * <li>Its {@linkplain ByteBuffer#capacity() capacity} and {@linkplain ByteBuffer#limit() limit}\n-     * are both set to this segment' {@linkplain MemorySegment#byteSize() size}. For this reason, a byte buffer\n-     * cannot be returned if this segment's size is greater than {@link Integer#MAX_VALUE};<\/li>\n-     * <li>It is a {@linkplain ByteBuffer#isDirect() direct buffer}, if this is a native segment.<\/li>\n+     * <li>Its {@linkplain ByteBuffer#capacity() capacity} and\n+     * {@linkplain ByteBuffer#limit() limit} are both set to this segment's\n+     * {@linkplain MemorySegment#byteSize() size}. For this reason, a byte buffer cannot\n+     * be returned if this segment's size is greater than {@link Integer#MAX_VALUE};<\/li>\n+     * <li>It is a {@linkplain ByteBuffer#isDirect() direct buffer}, if this is a\n+     * native segment.<\/li>\n@@ -905,4 +1037,6 @@\n-     * The life-cycle of the returned buffer is tied to that of this segment. That is, accessing the returned buffer\n-     * after the scope associated with this segment is no longer {@linkplain Scope#isAlive() alive}, will\n-     * throw an {@link IllegalStateException}. Similarly, accessing the returned buffer from a thread {@code T}\n-     * such that {@code isAccessible(T) == false} will throw a {@link WrongThreadException}.\n+     * The life-cycle of the returned buffer is tied to that of this segment. That is,\n+     * accessing the returned buffer after the scope associated with this segment is no\n+     * longer {@linkplain Scope#isAlive() alive}, will throw an\n+     * {@link IllegalStateException}. Similarly, accessing the returned buffer from a\n+     * thread {@code T} such that {@code isAccessible(T) == false} will throw a\n+     * {@link WrongThreadException}.\n@@ -910,2 +1044,3 @@\n-     * If this segment is {@linkplain #isAccessibleBy(Thread) accessible} from a single thread, calling read\/write I\/O\n-     * operations on the resulting buffer might result in unspecified exceptions being thrown. Examples of such problematic operations are\n+     * If this segment is {@linkplain #isAccessibleBy(Thread) accessible} from a single\n+     * thread, calling read\/write I\/O operations on the resulting buffer might result in\n+     * unspecified exceptions being thrown. Examples of such problematic operations are\n@@ -915,1 +1050,2 @@\n-     * Finally, the resulting buffer's byte order is {@link java.nio.ByteOrder#BIG_ENDIAN}; this can be changed using\n+     * Finally, the resulting buffer's byte order is\n+     * {@link java.nio.ByteOrder#BIG_ENDIAN}; this can be changed using\n@@ -918,4 +1054,5 @@\n-     * @return a {@link ByteBuffer} view of this memory segment.\n-     * @throws UnsupportedOperationException if this segment cannot be mapped onto a {@link ByteBuffer} instance,\n-     *         e.g. if it is a heap segment backed by an array other than {@code byte[]}), or if its size is greater\n-     *         than {@link Integer#MAX_VALUE}\n+     * @return a {@link ByteBuffer} view of this memory segment\n+     * @throws UnsupportedOperationException if this segment cannot be mapped onto a\n+     *         {@link ByteBuffer} instance, e.g. if it is a heap segment backed by an\n+     *         array other than {@code byte[]}), or if its size is greater than\n+     *         {@link Integer#MAX_VALUE}\n@@ -927,5 +1064,8 @@\n-     * @param elementLayout the source element layout. If the byte order associated with the layout is\n-     * different from the {@linkplain ByteOrder#nativeOrder native order}, a byte swap operation will be performed on each array element.\n-     * @return a new byte array whose contents are copied from this memory segment.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     *\n+     * @param elementLayout the source element layout. If the byte order associated with\n+     *                      the layout is different from the\n+     *                      {@linkplain ByteOrder#nativeOrder native order}, a byte swap\n+     *                      operation will be performed on each array element\n+     * @return a new byte array whose contents are copied from this memory segment\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -934,2 +1074,2 @@\n-     * @throws IllegalStateException if this segment's contents cannot be copied into a {@code byte[]} instance,\n-     *         e.g. its size is greater than {@link Integer#MAX_VALUE}\n+     * @throws IllegalStateException if this segment's contents cannot be copied into a\n+     *         {@code byte[]} instance, e.g. its size is greater than {@link Integer#MAX_VALUE}\n@@ -941,5 +1081,8 @@\n-     * @param elementLayout the source element layout. If the byte order associated with the layout is\n-     * different from the {@linkplain ByteOrder#nativeOrder native order}, a byte swap operation will be performed on each array element.\n-     * @return a new short array whose contents are copied from this memory segment.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     *\n+     * @param elementLayout the source element layout. If the byte order associated with\n+     *                      the layout is different from the\n+     *                      {@linkplain ByteOrder#nativeOrder native order}, a byte swap\n+     *                      operation will be performed on each array element\n+     * @return a new short array whose contents are copied from this memory segment\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -948,2 +1091,3 @@\n-     * @throws IllegalStateException if this segment's contents cannot be copied into a {@code short[]} instance,\n-     *         e.g. because {@code byteSize() % 2 != 0}, or {@code byteSize() \/ 2 > Integer.MAX_VALUE}\n+     * @throws IllegalStateException if this segment's contents cannot be copied into a\n+     *         {@code short[]} instance, e.g. because {@code byteSize() % 2 != 0}, or\n+     *         {@code byteSize() \/ 2 > Integer.MAX_VALUE}\n@@ -955,5 +1099,8 @@\n-     * @param elementLayout the source element layout. If the byte order associated with the layout is\n-     * different from the {@linkplain ByteOrder#nativeOrder native order}, a byte swap operation will be performed on each array element.\n-     * @return a new char array whose contents are copied from this memory segment.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     *\n+     * @param elementLayout the source element layout. If the byte order associated with\n+     *                      the layout is different from the\n+     *                      {@linkplain ByteOrder#nativeOrder native order}, a byte swap\n+     *                      operation will be performed on each array element\n+     * @return a new char array whose contents are copied from this memory segment\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -962,2 +1109,3 @@\n-     * @throws IllegalStateException if this segment's contents cannot be copied into a {@code char[]} instance,\n-     *         e.g. because {@code byteSize() % 2 != 0}, or {@code byteSize() \/ 2 > Integer.MAX_VALUE}\n+     * @throws IllegalStateException if this segment's contents cannot be copied into a\n+     *         {@code char[]} instance, e.g. because {@code byteSize() % 2 != 0}, or\n+     *         {@code byteSize() \/ 2 > Integer.MAX_VALUE}\n@@ -969,5 +1117,8 @@\n-     * @param elementLayout the source element layout. If the byte order associated with the layout is\n-     * different from the {@linkplain ByteOrder#nativeOrder native order}, a byte swap operation will be performed on each array element.\n-     * @return a new int array whose contents are copied from this memory segment.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     *\n+     * @param elementLayout the source element layout. If the byte order associated with\n+     *                     the layout is different from the\n+     *                     {@linkplain ByteOrder#nativeOrder native order}, a byte swap\n+     *                     operation will be performed on each array element.\n+     * @return a new int array whose contents are copied from this memory segment\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -976,2 +1127,3 @@\n-     * @throws IllegalStateException if this segment's contents cannot be copied into a {@code int[]} instance,\n-     *         e.g. because {@code byteSize() % 4 != 0}, or {@code byteSize() \/ 4 > Integer.MAX_VALUE}\n+     * @throws IllegalStateException if this segment's contents cannot be copied into a\n+     *         {@code int[]} instance, e.g. because {@code byteSize() % 4 != 0}, or\n+     *         {@code byteSize() \/ 4 > Integer.MAX_VALUE}\n@@ -983,5 +1135,8 @@\n-     * @param elementLayout the source element layout. If the byte order associated with the layout is\n-     * different from the {@linkplain ByteOrder#nativeOrder native order}, a byte swap operation will be performed on each array element.\n-     * @return a new float array whose contents are copied from this memory segment.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     *\n+     * @param elementLayout the source element layout. If the byte order associated with\n+     *                      the layout is different from the\n+     *                      {@linkplain ByteOrder#nativeOrder native order}, a byte swap\n+     *                      operation will be performed on each array element\n+     * @return a new float array whose contents are copied from this memory segment\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -990,2 +1145,3 @@\n-     * @throws IllegalStateException if this segment's contents cannot be copied into a {@code float[]} instance,\n-     *         e.g. because {@code byteSize() % 4 != 0}, or {@code byteSize() \/ 4 > Integer.MAX_VALUE}.\n+     * @throws IllegalStateException if this segment's contents cannot be copied into a\n+     *         {@code float[]} instance, e.g. because {@code byteSize() % 4 != 0}, or\n+     *         {@code byteSize() \/ 4 > Integer.MAX_VALUE}\n@@ -997,5 +1153,8 @@\n-     * @param elementLayout the source element layout. If the byte order associated with the layout is\n-     * different from the {@linkplain ByteOrder#nativeOrder native order}, a byte swap operation will be performed on each array element.\n-     * @return a new long array whose contents are copied from this memory segment.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     *\n+     * @param elementLayout the source element layout. If the byte order associated with\n+     *                     the layout is different from the\n+     *                     {@linkplain ByteOrder#nativeOrder native order}, a byte swap\n+     *                     operation will be performed on each array element\n+     * @return a new long array whose contents are copied from this memory segment\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -1004,2 +1163,3 @@\n-     * @throws IllegalStateException if this segment's contents cannot be copied into a {@code long[]} instance,\n-     *         e.g. because {@code byteSize() % 8 != 0}, or {@code byteSize() \/ 8 > Integer.MAX_VALUE}\n+     * @throws IllegalStateException if this segment's contents cannot be copied into a\n+     *         {@code long[]} instance, e.g. because {@code byteSize() % 8 != 0}, or\n+     *         {@code byteSize() \/ 8 > Integer.MAX_VALUE}\n@@ -1011,5 +1171,8 @@\n-     * @param elementLayout the source element layout. If the byte order associated with the layout is\n-     * different from the {@linkplain ByteOrder#nativeOrder native order}, a byte swap operation will be performed on each array element.\n-     * @return a new double array whose contents are copied from this memory segment.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     *\n+     * @param elementLayout the source element layout. If the byte order associated with\n+     *                      the layout is different from the\n+     *                      {@linkplain ByteOrder#nativeOrder native order}, a byte swap\n+     *                      operation will be performed on each array element\n+     * @return a new double array whose contents are copied from this memory segment\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -1017,3 +1180,4 @@\n-     *         such that {@code isAccessibleBy(T) == false}.\n-     * @throws IllegalStateException if this segment's contents cannot be copied into a {@code double[]} instance,\n-     *         e.g. because {@code byteSize() % 8 != 0}, or {@code byteSize() \/ 8 > Integer.MAX_VALUE}.\n+     *         such that {@code isAccessibleBy(T) == false}\n+     * @throws IllegalStateException if this segment's contents cannot be copied into a\n+     *         {@code double[]} instance, e.g. because {@code byteSize() % 8 != 0}, or\n+     *         {@code byteSize() \/ 8 > Integer.MAX_VALUE}\n@@ -1032,5 +1196,7 @@\n-     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n-     * @return a Java string constructed from the bytes read from the given starting address up to (but not including)\n-     * the first {@code '\\0'} terminator character (assuming one is found).\n-     * @throws IllegalArgumentException if the size of the string is greater than the largest string\n-     *         supported by the platform.\n+     * @param offset offset in bytes (relative to this segment address) at which this\n+     *               access operation will occur\n+     * @return a Java string constructed from the bytes read from the given starting\n+     *         address up to (but not including) the first {@code '\\0'} terminator\n+     *         character (assuming one is found)\n+     * @throws IllegalArgumentException if the size of the string is greater than the\n+     *         largest string supported by the platform\n@@ -1038,4 +1204,5 @@\n-     * @throws IndexOutOfBoundsException if {@code offset > byteSize() - (B + 1)}, where {@code B} is the size,\n-     *         in bytes, of the string encoded using UTF-8 charset {@code str.getBytes(StandardCharsets.UTF_8).length})\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @throws IndexOutOfBoundsException if {@code offset > byteSize() - (B + 1)}, where\n+     *         {@code B} is the size, in bytes, of the string encoded using UTF-8 charset\n+     *         {@code str.getBytes(StandardCharsets.UTF_8).length})\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -1048,1 +1215,2 @@\n-     * Reads a null-terminated string from this segment at the given offset, using the provided charset.\n+     * Reads a null-terminated string from this segment at the given offset, using the\n+     * provided charset.\n@@ -1051,1 +1219,1 @@\n-     * sequences with this charset's default replacement string.  The {@link\n+     * sequences with this charset's default replacement string. The {@link\n@@ -1055,6 +1223,9 @@\n-     * @param offset  offset in bytes (relative to this segment address) at which this access operation will occur.\n-     * @param charset the charset used to {@linkplain Charset#newDecoder() decode} the string bytes.\n-     * @return a Java string constructed from the bytes read from the given starting address up to (but not including)\n-     * the first {@code '\\0'} terminator character (assuming one is found).\n-     * @throws IllegalArgumentException  if the size of the string is greater than the largest string\n-     *         supported by the platform\n+     * @param offset  offset in bytes (relative to this segment address) at which this\n+     *                access operation will occur\n+     * @param charset the charset used to {@linkplain Charset#newDecoder() decode} the\n+     *                string bytes\n+     * @return a Java string constructed from the bytes read from the given starting\n+     *         address up to (but not including) the first {@code '\\0'} terminator\n+     *         character (assuming one is found)\n+     * @throws IllegalArgumentException  if the size of the string is greater than the\n+     *         largest string supported by the platform\n@@ -1064,4 +1235,5 @@\n-     *             <li>{@code B} is the size, in bytes, of the string encoded using the provided charset\n-     *             (e.g. {@code str.getBytes(charset).length});<\/li>\n-     *             <li>{@code N} is the size (in bytes) of the terminator char according to the provided charset. For instance,\n-     *             this is 1 for {@link StandardCharsets#US_ASCII} and 2 for {@link StandardCharsets#UTF_16}.<\/li>\n+     *             <li>{@code B} is the size, in bytes, of the string encoded using the\n+     *             provided charset (e.g. {@code str.getBytes(charset).length});<\/li>\n+     *             <li>{@code N} is the size (in bytes) of the terminator char according\n+     *             to the provided charset. For instance, this is 1 for\n+     *             {@link StandardCharsets#US_ASCII} and 2 for {@link StandardCharsets#UTF_16}.<\/li>\n@@ -1069,2 +1241,2 @@\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -1073,1 +1245,2 @@\n-     * @throws IllegalArgumentException if {@code charset} is not a {@linkplain StandardCharsets standard charset}\n+     * @throws IllegalArgumentException if {@code charset} is not a\n+     *         {@linkplain StandardCharsets standard charset}\n@@ -1078,2 +1251,3 @@\n-     * Writes the given string into this segment at the given offset, converting it to a null-terminated byte sequence\n-     * using the {@linkplain StandardCharsets#UTF_8 UTF-8} charset.\n+     * Writes the given string into this segment at the given offset, converting it to\n+     * a null-terminated byte sequence using the {@linkplain StandardCharsets#UTF_8 UTF-8}\n+     * charset.\n@@ -1085,3 +1259,4 @@\n-     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n-     *               the final address of this write operation can be expressed as {@code address() + offset}.\n-     * @param str the Java string to be written into this segment.\n+     * @param offset offset in bytes (relative to this segment address) at which this\n+     *               access operation will occur, the final address of this write\n+     *               operation can be expressed as {@code address() + offset}\n+     * @param str the Java string to be written into this segment\n@@ -1089,4 +1264,5 @@\n-     * @throws IndexOutOfBoundsException if {@code offset > byteSize() - (B + 1)}, where {@code B} is the size,\n-     *         in bytes, of the string encoded using UTF-8 charset {@code str.getBytes(StandardCharsets.UTF_8).length})\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @throws IndexOutOfBoundsException if {@code offset > byteSize() - (B + 1)}, where\n+     *         {@code B} is the size, in bytes, of the string encoded using UTF-8 charset\n+     *         {@code str.getBytes(StandardCharsets.UTF_8).length})\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -1094,1 +1270,1 @@\n-     *         such that {@code isAccessibleBy(T) == false}.\n+     *         such that {@code isAccessibleBy(T) == false}\n@@ -1099,2 +1275,2 @@\n-     * Writes the given string into this segment at the given offset, converting it to a null-terminated byte sequence\n-     * using the provided charset.\n+     * Writes the given string into this segment at the given offset, converting it to a\n+     * null-terminated byte sequence using the provided charset.\n@@ -1103,1 +1279,1 @@\n-     * sequences with this charset's default replacement string.  The {@link\n+     * sequences with this charset's default replacement string. The {@link\n@@ -1112,4 +1288,5 @@\n-     * @param offset  offset in bytes (relative to this segment address) at which this access operation will occur.\n-     *                the final address of this write operation can be expressed as {@code address() + offset}.\n-     * @param str     the Java string to be written into this segment.\n-     * @param charset the charset used to {@linkplain Charset#newEncoder() encode} the string bytes.\n+     * @param offset  offset in bytes (relative to this segment address) at which this\n+     *                access operation will occur, the final address of this write\n+     *                operation can be expressed as {@code address() + offset}\n+     * @param str     the Java string to be written into this segment\n+     * @param charset the charset used to {@linkplain Charset#newEncoder() encode} the string bytes\n@@ -1119,4 +1296,5 @@\n-     *             <li>{@code B} is the size, in bytes, of the string encoded using the provided charset\n-     *             (e.g. {@code str.getBytes(charset).length});<\/li>\n-     *             <li>{@code N} is the size (in bytes) of the terminator char according to the provided charset. For\n-     *             instance, this is 1 for {@link StandardCharsets#US_ASCII} and 2 for {@link StandardCharsets#UTF_16}.<\/li>\n+     *             <li>{@code B} is the size, in bytes, of the string encoded using the\n+     *             provided charset (e.g. {@code str.getBytes(charset).length});<\/li>\n+     *             <li>{@code N} is the size (in bytes) of the terminator char according\n+     *             to the provided charset. For instance, this is 1 for\n+     *             {@link StandardCharsets#US_ASCII} and 2 for {@link StandardCharsets#UTF_16}.<\/li>\n@@ -1124,2 +1302,2 @@\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -1128,1 +1306,2 @@\n-     * @throws IllegalArgumentException if {@code charset} is not a {@linkplain StandardCharsets standard charset}\n+     * @throws IllegalArgumentException if {@code charset} is not a\n+     *         {@linkplain StandardCharsets standard charset}\n@@ -1133,2 +1312,3 @@\n-     * Creates a memory segment that is backed by the same region of memory that backs the given {@link Buffer} instance.\n-     * The segment starts relative to the buffer's position (inclusive) and ends relative to the buffer's limit (exclusive).\n+     * Creates a memory segment that is backed by the same region of memory that backs\n+     * the given {@link Buffer} instance. The segment starts relative to the buffer's\n+     * position (inclusive) and ends relative to the buffer's limit (exclusive).\n@@ -1136,3 +1316,4 @@\n-     * If the buffer is {@linkplain Buffer#isReadOnly() read-only}, the resulting segment is also\n-     * {@linkplain ByteBuffer#isReadOnly() read-only}. Moreover, if the buffer is a {@linkplain Buffer#isDirect() direct buffer},\n-     * the returned segment is a native segment; otherwise the returned memory segment is a heap segment.\n+     * If the buffer is {@linkplain Buffer#isReadOnly() read-only}, the resulting segment\n+     * is also {@linkplain ByteBuffer#isReadOnly() read-only}. Moreover, if the buffer\n+     * is a {@linkplain Buffer#isDirect() direct buffer}, the returned segment is a\n+     * native segment; otherwise the returned memory segment is a heap segment.\n@@ -1140,11 +1321,14 @@\n-     * If the provided buffer has been obtained by calling {@link #asByteBuffer()} on a memory segment whose\n-     * {@linkplain Scope scope} is {@code S}, the returned segment will be associated with the\n-     * same scope {@code S}. Otherwise, the scope of the returned segment is an automatic scope that keeps the provided\n-     * buffer reachable. As such, if the provided buffer is a direct buffer, its backing memory region will not be\n-     * deallocated as long as the returned segment (or any of its slices) are kept reachable.\n-     *\n-     * @param buffer the buffer instance to be turned into a new memory segment.\n-     * @return a memory segment, derived from the given buffer instance.\n-     * @throws IllegalArgumentException if the provided {@code buffer} is a heap buffer but is not backed by an array;\n-     *         For example, buffers directly or indirectly obtained via ({@link CharBuffer#wrap(CharSequence)} or\n-     *         {@link CharBuffer#wrap(char[], int, int)} are not backed by an array\n+     * If the provided buffer has been obtained by calling {@link #asByteBuffer()} on a\n+     * memory segment whose {@linkplain Scope scope} is {@code S}, the returned segment\n+     * will be associated with the same scope {@code S}. Otherwise, the scope of the\n+     * returned segment is an automatic scope that keeps the provided buffer reachable.\n+     * As such, if the provided buffer is a direct buffer, its backing memory region will\n+     * not be deallocated as long as the returned segment (or any of its slices) are kept\n+     * reachable.\n+     *\n+     * @param buffer the buffer instance to be turned into a new memory segment\n+     * @return a memory segment, derived from the given buffer instance\n+     * @throws IllegalArgumentException if the provided {@code buffer} is a heap buffer\n+     *         but is not backed by an array; For example, buffers directly or indirectly\n+     *         obtained via ({@link CharBuffer#wrap(CharSequence)} or\n+     *         {@link CharBuffer#wrap(char[], int, int)} are not backed by an array.\n@@ -1157,3 +1341,4 @@\n-     * Creates a heap segment backed by the on-heap region of memory that holds the given byte array.\n-     * The scope of the returned segment is an automatic scope that keeps the given array reachable.\n-     * The returned segment is always accessible, from any thread. Its {@link #address()} is set to zero.\n+     * Creates a heap segment backed by the on-heap region of memory that holds the given\n+     * byte array. The scope of the returned segment is an automatic scope that keeps\n+     * the given array reachable. The returned segment is always accessible, from any\n+     * thread. Its {@link #address()} is set to zero.\n@@ -1161,2 +1346,2 @@\n-     * @param byteArray the primitive array backing the heap memory segment.\n-     * @return a heap memory segment backed by a byte array.\n+     * @param byteArray the primitive array backing the heap memory segment\n+     * @return a heap memory segment backed by a byte array\n@@ -1169,3 +1354,4 @@\n-     * Creates a heap segment backed by the on-heap region of memory that holds the given char array.\n-     * The scope of the returned segment is an automatic scope that keeps the given array reachable.\n-     * The returned segment is always accessible, from any thread. Its {@link #address()} is set to zero.\n+     * Creates a heap segment backed by the on-heap region of memory that holds the given\n+     * char array. The scope of the returned segment is an automatic scope that keeps\n+     * the given array reachable. The returned segment is always accessible, from any\n+     * thread. Its {@link #address()} is set to zero.\n@@ -1173,2 +1359,2 @@\n-     * @param charArray the primitive array backing the heap segment.\n-     * @return a heap memory segment backed by a char array.\n+     * @param charArray the primitive array backing the heap segment\n+     * @return a heap memory segment backed by a char array\n@@ -1181,3 +1367,4 @@\n-     * Creates a heap segment backed by the on-heap region of memory that holds the given short array.\n-     * The scope of the returned segment is an automatic scope that keeps the given array reachable.\n-     * The returned segment is always accessible, from any thread. Its {@link #address()} is set to zero.\n+     * Creates a heap segment backed by the on-heap region of memory that holds the given\n+     * short array. The scope of the returned segment is an automatic scope that keeps\n+     * the given array reachable. The returned segment is always accessible, from any\n+     * thread. Its {@link #address()} is set to zero.\n@@ -1185,2 +1372,2 @@\n-     * @param shortArray the primitive array backing the heap segment.\n-     * @return a heap memory segment backed by a short array.\n+     * @param shortArray the primitive array backing the heap segment\n+     * @return a heap memory segment backed by a short array\n@@ -1193,3 +1380,4 @@\n-     * Creates a heap segment backed by the on-heap region of memory that holds the given int array.\n-     * The scope of the returned segment is an automatic scope that keeps the given array reachable.\n-     * The returned segment is always accessible, from any thread. Its {@link #address()} is set to zero.\n+     * Creates a heap segment backed by the on-heap region of memory that holds the given\n+     * int array. The scope of the returned segment is an automatic scope that keeps\n+     * the given array reachable. The returned segment is always accessible, from any\n+     * thread. Its {@link #address()} is set to zero.\n@@ -1197,2 +1385,2 @@\n-     * @param intArray the primitive array backing the heap segment.\n-     * @return a heap memory segment backed by an int array.\n+     * @param intArray the primitive array backing the heap segment\n+     * @return a heap memory segment backed by an int array\n@@ -1205,3 +1393,4 @@\n-     * Creates a heap segment backed by the on-heap region of memory that holds the given float array.\n-     * The scope of the returned segment is an automatic scope that keeps the given array reachable.\n-     * The returned segment is always accessible, from any thread. Its {@link #address()} is set to zero.\n+     * Creates a heap segment backed by the on-heap region of memory that holds the given\n+     * float array. The scope of the returned segment is an automatic scope that keeps\n+     * the given array reachable. The returned segment is always accessible, from any\n+     * thread. Its {@link #address()} is set to zero.\n@@ -1209,2 +1398,2 @@\n-     * @param floatArray the primitive array backing the heap segment.\n-     * @return a heap memory segment backed by a float array.\n+     * @param floatArray the primitive array backing the heap segment\n+     * @return a heap memory segment backed by a float array\n@@ -1217,3 +1406,4 @@\n-     * Creates a heap segment backed by the on-heap region of memory that holds the given long array.\n-     * The scope of the returned segment is an automatic scope that keeps the given array reachable.\n-     * The returned segment is always accessible, from any thread. Its {@link #address()} is set to zero.\n+     * Creates a heap segment backed by the on-heap region of memory that holds the given\n+     * long array. The scope of the returned segment is an automatic scope that keeps\n+     * the given array reachable. The returned segment is always accessible, from any\n+     * thread. Its {@link #address()} is set to zero.\n@@ -1221,2 +1411,2 @@\n-     * @param longArray the primitive array backing the heap segment.\n-     * @return a heap memory segment backed by a long array.\n+     * @param longArray the primitive array backing the heap segment\n+     * @return a heap memory segment backed by a long array\n@@ -1229,3 +1419,4 @@\n-     * Creates a heap segment backed by the on-heap region of memory that holds the given double array.\n-     * The scope of the returned segment is an automatic scope that keeps the given array reachable.\n-     * The returned segment is always accessible, from any thread. Its {@link #address()} is set to zero.\n+     * Creates a heap segment backed by the on-heap region of memory that holds the given\n+     * double array. The scope of the returned segment is an automatic scope that keeps\n+     * the given array reachable. The returned segment is always accessible, from any\n+     * thread. Its {@link #address()} is set to zero.\n@@ -1233,2 +1424,2 @@\n-     * @param doubleArray the primitive array backing the heap segment.\n-     * @return a heap memory segment backed by a double array.\n+     * @param doubleArray the primitive array backing the heap segment\n+     * @return a heap memory segment backed by a double array\n@@ -1241,1 +1432,2 @@\n-     * A zero-length native segment modelling the {@code NULL} address. Equivalent to {@code MemorySegment.ofAddress(0L)}.\n+     * A zero-length native segment modelling the {@code NULL} address. Equivalent to\n+     * {@code MemorySegment.ofAddress(0L)}.\n@@ -1246,2 +1438,5 @@\n-     * Creates a zero-length native segment from the given {@linkplain #address() address value}.\n-     * The returned segment is associated with the global scope, and is accessible from any thread.\n+     * Creates a zero-length native segment from the given\n+     * {@linkplain #address() address value}.\n+     * <p>\n+     * The returned segment is associated with the global scope, and is accessible from\n+     * any thread.\n@@ -1253,2 +1448,2 @@\n-     * @param address the address of the returned native segment.\n-     * @return a zero-length native segment with the given address.\n+     * @param address the address of the returned native segment\n+     * @return a zero-length native segment with the given address\n@@ -1261,3 +1456,5 @@\n-     * Performs a bulk copy from source segment to destination segment. More specifically, the bytes at offset\n-     * {@code srcOffset} through {@code srcOffset + bytes - 1} in the source segment are copied into the destination\n-     * segment at offset {@code dstOffset} through {@code dstOffset + bytes - 1}.\n+     * Performs a bulk copy from source segment to destination segment. More\n+     * specifically, the bytes at offset {@code srcOffset} through\n+     * {@code srcOffset + bytes - 1} in the source segment are copied into the\n+     * destination segment at offset {@code dstOffset} through\n+     * {@code dstOffset + bytes - 1}.\n@@ -1265,4 +1462,6 @@\n-     * If the source segment overlaps with the destination segment, then the copying is performed as if the bytes at\n-     * offset {@code srcOffset} through {@code srcOffset + bytes - 1} in the source segment were first copied into a\n-     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into\n-     * the destination segment at offset {@code dstOffset} through {@code dstOffset + bytes - 1}.\n+     * If the source segment overlaps with the destination segment, then the copying is\n+     * performed as if the bytes at offset {@code srcOffset} through\n+     * {@code srcOffset + bytes - 1} in the source segment were first copied into a\n+     * temporary segment with size {@code bytes}, and then the contents of the temporary\n+     * segment were copied into the destination segment at offset {@code dstOffset}\n+     * through {@code dstOffset + bytes - 1}.\n@@ -1270,3 +1469,4 @@\n-     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and the destination segment\n-     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n-     * For example, this may occur if the same file is {@linkplain FileChannel#map mapped} to two segments.\n+     * The result of a bulk copy is unspecified if, in the uncommon case, the source\n+     * segment and the destination segment do not overlap, but refer to overlapping\n+     * regions of the same backing storage using different addresses. For example, this\n+     * may occur if the same file is {@linkplain FileChannel#map mapped} to two segments.\n@@ -1278,7 +1478,7 @@\n-     * @param srcSegment the source segment.\n-     * @param srcOffset the starting offset, in bytes, of the source segment.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffset the starting offset, in bytes, of the destination segment.\n-     * @param bytes the number of bytes to be copied.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with {@code srcSegment} is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @param srcSegment the source segment\n+     * @param srcOffset the starting offset, in bytes, of the source segment\n+     * @param dstSegment the destination segment\n+     * @param dstOffset the starting offset, in bytes, of the destination segment\n+     * @param bytes the number of bytes to be copied\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         {@code srcSegment} is not {@linkplain Scope#isAlive() alive}\n@@ -1287,2 +1487,2 @@\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with {@code dstSegment} is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         {@code dstSegment} is not {@linkplain Scope#isAlive() alive}\n@@ -1293,3 +1493,4 @@\n-     * @throws IndexOutOfBoundsException if either {@code srcOffset}, {@code dstOffset}\n-     *         or {@code bytes} are {@code < 0}\n-     * @throws UnsupportedOperationException if {@code dstSegment} is {@linkplain #isReadOnly() read-only}\n+     * @throws IndexOutOfBoundsException if either {@code srcOffset},\n+     *         {@code dstOffset} or {@code bytes} are {@code < 0}\n+     * @throws UnsupportedOperationException if {@code dstSegment} is\n+     *         {@linkplain #isReadOnly() read-only}\n@@ -1304,3 +1505,5 @@\n-     * Performs a bulk copy from source segment to destination segment. More specifically, if {@code S} is the byte size\n-     * of the element layouts, the bytes at offset {@code srcOffset} through {@code srcOffset + (elementCount * S) - 1}\n-     * in the source segment are copied into the destination segment at offset {@code dstOffset} through {@code dstOffset + (elementCount * S) - 1}.\n+     * Performs a bulk copy from source segment to destination segment. More\n+     * specifically, if {@code S} is the byte size of the element layouts, the bytes at\n+     * offset {@code srcOffset} through {@code srcOffset + (elementCount * S) - 1}\n+     * in the source segment are copied into the destination segment at offset\n+     * {@code dstOffset} through {@code dstOffset + (elementCount * S) - 1}.\n@@ -1308,5 +1511,7 @@\n-     * The copy occurs in an element-wise fashion: the bytes in the source segment are interpreted as a sequence of elements\n-     * whose layout is {@code srcElementLayout}, whereas the bytes in the destination segment are interpreted as a sequence of\n-     * elements whose layout is {@code dstElementLayout}. Both element layouts must have same size {@code S}.\n-     * If the byte order of the two element layouts differ, the bytes corresponding to each element to be copied\n-     * are swapped accordingly during the copy operation.\n+     * The copy occurs in an element-wise fashion: the bytes in the source segment are\n+     * interpreted as a sequence of elements whose layout is {@code srcElementLayout},\n+     * whereas the bytes in the destination segment are interpreted as a sequence of\n+     * elements whose layout is {@code dstElementLayout}. Both element layouts must have\n+     * same size {@code S}. If the byte order of the two element layouts differ, the\n+     * bytes corresponding to each element to be copied are swapped accordingly during\n+     * the copy operation.\n@@ -1314,4 +1519,6 @@\n-     * If the source segment overlaps with the destination segment, then the copying is performed as if the bytes at\n-     * offset {@code srcOffset} through {@code srcOffset + (elementCount * S) - 1} in the source segment were first copied into a\n-     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into\n-     * the destination segment at offset {@code dstOffset} through {@code dstOffset + (elementCount * S) - 1}.\n+     * If the source segment overlaps with the destination segment, then the copying is\n+     * performed as if the bytes at offset {@code srcOffset} through\n+     * {@code srcOffset + (elementCount * S) - 1} in the source segment were first copied\n+     * into a temporary segment with size {@code bytes}, and then the contents of the\n+     * temporary segment were copied into the destination segment at offset\n+     * {@code dstOffset} through {@code dstOffset + (elementCount * S) - 1}.\n@@ -1319,12 +1526,15 @@\n-     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and the destination segment\n-     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n-     * For example, this may occur if the same file is {@linkplain FileChannel#map mapped} to two segments.\n-     * @param srcSegment the source segment.\n-     * @param srcElementLayout the element layout associated with the source segment.\n-     * @param srcOffset the starting offset, in bytes, of the source segment.\n-     * @param dstSegment the destination segment.\n-     * @param dstElementLayout the element layout associated with the destination segment.\n-     * @param dstOffset the starting offset, in bytes, of the destination segment.\n-     * @param elementCount the number of elements to be copied.\n-     * @throws IllegalArgumentException if the element layouts have different sizes, if the source (resp. destination)\n-     *         segment\/offset are <a href=\"MemorySegment.html#segment-alignment\">incompatible with the\n+     * The result of a bulk copy is unspecified if, in the uncommon case, the source\n+     * segment and the destination segment do not overlap, but refer to overlapping\n+     * regions of the same backing storage using different addresses. For example,\n+     * this may occur if the same file is {@linkplain FileChannel#map mapped} to two\n+     * segments.\n+     * @param srcSegment the source segment\n+     * @param srcElementLayout the element layout associated with the source segment\n+     * @param srcOffset the starting offset, in bytes, of the source segment\n+     * @param dstSegment the destination segment\n+     * @param dstElementLayout the element layout associated with the destination segment\n+     * @param dstOffset the starting offset, in bytes, of the destination segment\n+     * @param elementCount the number of elements to be copied\n+     * @throws IllegalArgumentException if the element layouts have different sizes, if\n+     *         the source (resp. destination) segment\/offset are\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the\n@@ -1334,2 +1544,2 @@\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with {@code srcSegment} is not\n-     *         {@linkplain Scope#isAlive() alive}.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         {@code srcSegment} is not {@linkplain Scope#isAlive() alive}.\n@@ -1338,2 +1548,2 @@\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with {@code dstSegment} is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         {@code dstSegment} is not {@linkplain Scope#isAlive() alive}\n@@ -1363,5 +1573,6 @@\n-     * @param layout the layout of the region of memory to be read.\n-     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n-     * @return a byte value read from this segment.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}.\n+     * @param layout the layout of the region of memory to be read\n+     * @param offset offset in bytes (relative to this segment address) at which this\n+     *               access operation will occur\n+     * @return a byte value read from this segment\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -1369,1 +1580,1 @@\n-     *         such that {@code isAccessibleBy(T) == false}.\n+     *         such that {@code isAccessibleBy(T) == false}\n@@ -1371,1 +1582,2 @@\n-     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in the provided layout\n@@ -1379,2 +1591,3 @@\n-     * @param layout the layout of the region of memory to be written.\n-     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n+     * @param layout the layout of the region of memory to be written\n+     * @param offset offset in bytes (relative to this segment address) at which this\n+     *               access operation will occur\n@@ -1382,2 +1595,2 @@\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -1387,1 +1600,2 @@\n-     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in the provided layout\n@@ -1389,1 +1603,2 @@\n-     * @throws UnsupportedOperationException if this segment is {@linkplain #isReadOnly() read-only}\n+     * @throws UnsupportedOperationException if this segment is\n+     *         {@linkplain #isReadOnly() read-only}\n@@ -1396,5 +1611,6 @@\n-     * @param layout the layout of the region of memory to be read.\n-     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n-     * @return a boolean value read from this segment.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @param layout the layout of the region of memory to be read\n+     * @param offset offset in bytes (relative to this segment address) at which this\n+     *               access operation will occur\n+     * @return a boolean value read from this segment\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -1404,1 +1620,2 @@\n-     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in the provided layout\n@@ -1412,5 +1629,6 @@\n-     * @param layout the layout of the region of memory to be written.\n-     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n-     * @param value the boolean value to be written.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     * {@linkplain Scope#isAlive() alive}.\n+     * @param layout the layout of the region of memory to be written\n+     * @param offset offset in bytes (relative to this segment address) at which this\n+     *               access operation will occur\n+     * @param value the boolean value to be written\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -1418,1 +1636,1 @@\n-     * such that {@code isAccessibleBy(T) == false}.\n+     *         such that {@code isAccessibleBy(T) == false}\n@@ -1420,1 +1638,2 @@\n-     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in the provided layout\n@@ -1422,1 +1641,2 @@\n-     * @throws UnsupportedOperationException if this segment is {@linkplain #isReadOnly() read-only}\n+     * @throws UnsupportedOperationException if this segment is\n+     *         {@linkplain #isReadOnly() read-only}\n@@ -1429,5 +1649,6 @@\n-     * @param layout the layout of the region of memory to be read.\n-     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n-     * @return a char value read from this segment.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @param layout the layout of the region of memory to be read\n+     * @param offset offset in bytes (relative to this segment address) at which this\n+     *               access operation will occur\n+     * @return a char value read from this segment\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -1437,1 +1658,2 @@\n-     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in the provided layout\n@@ -1445,5 +1667,6 @@\n-     * @param layout the layout of the region of memory to be written.\n-     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n-     * @param value the char value to be written.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @param layout the layout of the region of memory to be written\n+     * @param offset offset in bytes (relative to this segment address) at which this\n+     *               access operation will occur\n+     * @param value the char value to be written\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -1453,1 +1676,2 @@\n-     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in the provided layout\n@@ -1455,1 +1679,2 @@\n-     * @throws UnsupportedOperationException if this segment is {@linkplain #isReadOnly() read-only}\n+     * @throws UnsupportedOperationException if this segment is\n+     *         {@linkplain #isReadOnly() read-only}\n@@ -1462,5 +1687,6 @@\n-     * @param layout the layout of the region of memory to be read.\n-     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n-     * @return a short value read from this segment.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @param layout the layout of the region of memory to be read\n+     * @param offset offset in bytes (relative to this segment address) at which this\n+     *               access operation will occur\n+     * @return a short value read from this segment\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -1470,1 +1696,2 @@\n-     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in the provided layout\n@@ -1478,5 +1705,6 @@\n-     * @param layout the layout of the region of memory to be written.\n-     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n-     * @param value the short value to be written.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @param layout the layout of the region of memory to be written\n+     * @param offset offset in bytes (relative to this segment address) at which this\n+     *               access operation will occur\n+     * @param value the short value to be written\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -1486,1 +1714,2 @@\n-     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in the provided layout\n@@ -1488,1 +1717,2 @@\n-     * @throws UnsupportedOperationException if this segment is {@linkplain #isReadOnly() read-only}\n+     * @throws UnsupportedOperationException if this segment is\n+     *         {@linkplain #isReadOnly() read-only}\n@@ -1495,5 +1725,6 @@\n-     * @param layout the layout of the region of memory to be read.\n-     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n-     * @return an int value read from this segment.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @param layout the layout of the region of memory to be read\n+     * @param offset offset in bytes (relative to this segment address) at which this\n+     *               access operation will occur\n+     * @return an int value read from this segment\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -1503,1 +1734,2 @@\n-     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in the provided layout\n@@ -1511,5 +1743,6 @@\n-     * @param layout the layout of the region of memory to be written.\n-     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n-     * @param value the int value to be written.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @param layout the layout of the region of memory to be written\n+     * @param offset offset in bytes (relative to this segment address) at which this\n+     *               access operation will occur\n+     * @param value the int value to be written\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -1519,1 +1752,2 @@\n-     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in the provided layout\n@@ -1521,1 +1755,2 @@\n-     * @throws UnsupportedOperationException if this segment is {@linkplain #isReadOnly() read-only}\n+     * @throws UnsupportedOperationException if this segment is\n+     *         {@linkplain #isReadOnly() read-only}\n@@ -1528,5 +1763,6 @@\n-     * @param layout the layout of the region of memory to be read.\n-     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n-     * @return a float value read from this segment.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @param layout the layout of the region of memory to be read\n+     * @param offset offset in bytes (relative to this segment address) at which this\n+     *               access operation will occur\n+     * @return a float value read from this segment\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -1536,1 +1772,2 @@\n-     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in the provided layout\n@@ -1544,5 +1781,6 @@\n-     * @param layout the layout of the region of memory to be written.\n-     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n-     * @param value the float value to be written.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @param layout the layout of the region of memory to be written\n+     * @param offset offset in bytes (relative to this segment address) at which this\n+     *               access operation will occur\n+     * @param value the float value to be written\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -1552,1 +1790,2 @@\n-     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in the provided layout\n@@ -1554,1 +1793,2 @@\n-     * @throws UnsupportedOperationException if this segment is {@linkplain #isReadOnly() read-only}\n+     * @throws UnsupportedOperationException if this segment is\n+     *         {@linkplain #isReadOnly() read-only}\n@@ -1561,5 +1801,6 @@\n-     * @param layout the layout of the region of memory to be read.\n-     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n-     * @return a long value read from this segment.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @param layout the layout of the region of memory to be read\n+     * @param offset offset in bytes (relative to this segment address) at which this\n+     *               access operation will occur\n+     * @return a long value read from this segment\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -1569,1 +1810,2 @@\n-     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in the provided layout\n@@ -1577,5 +1819,6 @@\n-     * @param layout the layout of the region of memory to be written.\n-     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n-     * @param value the long value to be written.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @param layout the layout of the region of memory to be written\n+     * @param offset offset in bytes (relative to this segment address) at which this\n+     *               access operation will occur\n+     * @param value the long value to be written\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -1585,1 +1828,2 @@\n-     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in the provided layout\n@@ -1587,1 +1831,2 @@\n-     * @throws UnsupportedOperationException if this segment is {@linkplain #isReadOnly() read-only}\n+     * @throws UnsupportedOperationException if this segment is\n+     *         {@linkplain #isReadOnly() read-only}\n@@ -1594,5 +1839,6 @@\n-     * @param layout the layout of the region of memory to be read.\n-     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n-     * @return a double value read from this segment.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @param layout the layout of the region of memory to be read\n+     * @param offset offset in bytes (relative to this segment address) at which this\n+     *               access operation will occur\n+     * @return a double value read from this segment\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -1602,1 +1848,2 @@\n-     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in the provided layout\n@@ -1610,5 +1857,6 @@\n-     * @param layout the layout of the region of memory to be written.\n-     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n-     * @param value the double value to be written.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @param layout the layout of the region of memory to be written\n+     * @param offset offset in bytes (relative to this segment address) at which this\n+     *               access operation will occur\n+     * @param value the double value to be written\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -1618,1 +1866,2 @@\n-     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in the provided layout\n@@ -1620,1 +1869,2 @@\n-     * @throws UnsupportedOperationException if this segment is {@linkplain #isReadOnly() read-only}\n+     * @throws UnsupportedOperationException if this segment is\n+     *         {@linkplain #isReadOnly() read-only}\n@@ -1625,10 +1875,13 @@\n-     * Reads an address from this segment at the given offset, with the given layout. The read address is wrapped in\n-     * a native segment, associated with the global scope. Under normal conditions,\n-     * the size of the returned segment is {@code 0}. However, if the provided address layout has a\n-     * {@linkplain AddressLayout#targetLayout() target layout} {@code T}, then the size of the returned segment\n-     * is set to {@code T.byteSize()}.\n-     * @param layout the layout of the region of memory to be read.\n-     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n-     * @return a native segment wrapping an address read from this segment.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * Reads an address from this segment at the given offset, with the given layout.\n+     * The read address is wrapped in a native segment, associated with the global scope.\n+     * Under normal conditions, the size of the returned segment is {@code 0}. However,\n+     * if the provided address layout has a\n+     * {@linkplain AddressLayout#targetLayout() target layout} {@code T}, then the size\n+     * of the returned segment is set to {@code T.byteSize()}.\n+     *\n+     * @param layout the layout of the region of memory to be read\n+     * @param offset offset in bytes (relative to this segment address) at which this\n+     *               access operation will occur\n+     * @return a native segment wrapping an address read from this segment\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -1638,2 +1891,4 @@\n-     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout\n-     * @throws IllegalArgumentException if provided address layout has a {@linkplain AddressLayout#targetLayout() target layout}\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in the provided layout\n+     * @throws IllegalArgumentException if provided address layout has a\n+     *         {@linkplain AddressLayout#targetLayout() target layout}\n@@ -1641,1 +1896,2 @@\n-     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in {@code T}\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in {@code T}\n@@ -1649,5 +1905,6 @@\n-     * @param layout the layout of the region of memory to be written.\n-     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n-     * @param value the address value to be written.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @param layout the layout of the region of memory to be written\n+     * @param offset offset in bytes (relative to this segment address) at which this\n+     *               access operation will occur\n+     * @param value the byte value to be written\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -1657,1 +1914,2 @@\n-     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in the provided layout\n@@ -1659,2 +1917,4 @@\n-     * @throws UnsupportedOperationException if this segment is {@linkplain #isReadOnly() read-only}\n-     * @throws UnsupportedOperationException if {@code value} is not a {@linkplain #isNative() native} segment\n+     * @throws UnsupportedOperationException if this segment is\n+     *         {@linkplain #isReadOnly() read-only}\n+     * @throws UnsupportedOperationException if {@code value} is not a\n+     *         {@linkplain #isNative() native} segment\n@@ -1665,1 +1925,2 @@\n-     * Reads a byte from this segment at the given index, scaled by the given layout size.\n+     * Reads a byte from this segment at the given index, scaled by the given\n+     * layout size.\n@@ -1667,6 +1928,7 @@\n-     * @param layout the layout of the region of memory to be read.\n-     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n-     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n-     * @return a byte value read from this segment.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @param layout the layout of the region of memory to be read\n+     * @param index a logical index, the offset in bytes (relative to this\n+     *              segment address) at which the access operation will occur can be\n+     *              expressed as {@code (index * layout.byteSize())}\n+     * @return a byte value read from this segment\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -1676,1 +1938,2 @@\n-     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in the provided layout\n@@ -1684,1 +1947,2 @@\n-     * Reads a boolean from this segment at the given index, scaled by the given layout size.\n+     * Reads a boolean from this segment at the given index, scaled by the given\n+     * layout size.\n@@ -1686,6 +1950,7 @@\n-     * @param layout the layout of the region of memory to be read.\n-     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n-     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n-     * @return a boolean value read from this segment.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @param layout the layout of the region of memory to be read\n+     * @param index a logical index, the offset in bytes (relative to this\n+     *             segment address) at which the access operation will occur can be\n+     *             expressed as {@code (index * layout.byteSize())}\n+     * @return a boolean value read from this segment\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -1695,1 +1960,2 @@\n-     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in the provided layout\n@@ -1703,1 +1969,2 @@\n-     * Reads a char from this segment at the given index, scaled by the given layout size.\n+     * Reads a char from this segment at the given index, scaled by the given\n+     * layout size.\n@@ -1705,6 +1972,7 @@\n-     * @param layout the layout of the region of memory to be read.\n-     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n-     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n-     * @return a char value read from this segment.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @param layout the layout of the region of memory to be read\n+     * @param index a logical index, the offset in bytes (relative to this\n+     *              segment address) at which the access operation will occur can be\n+     *              expressed as {@code (index * layout.byteSize())}.\n+     * @return a char value read from this segment\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -1714,1 +1982,2 @@\n-     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in the provided layout\n@@ -1722,1 +1991,2 @@\n-     * Writes a char into this segment at the given index, scaled by the given layout size.\n+     * Writes a char into this segment at the given index, scaled by the given\n+     * layout size.\n@@ -1724,6 +1994,7 @@\n-     * @param layout the layout of the region of memory to be written.\n-     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n-     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n-     * @param value the char value to be written.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @param layout the layout of the region of memory to be written\n+     * @param index a logical index, the offset in bytes (relative to this\n+     *              segment address) at which the access operation will occur can be\n+     *              expressed as {@code (index * layout.byteSize())}\n+     * @param value the char value to be written\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -1733,1 +2004,2 @@\n-     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in the provided layout\n@@ -1742,1 +2014,2 @@\n-     * Reads a short from this segment at the given index, scaled by the given layout size.\n+     * Reads a short from this segment at the given index, scaled by the given\n+     * layout size.\n@@ -1744,6 +2017,7 @@\n-     * @param layout the layout of the region of memory to be read.\n-     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n-     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n-     * @return a short value read from this segment.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @param layout the layout of the region of memory to be read\n+     * @param index a logical index, the offset in bytes (relative to this\n+     *              segment address) at which the access operation will occur can be\n+     *              expressed as {@code (index * layout.byteSize())}\n+     * @return a short value read from this segment\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -1753,1 +2027,2 @@\n-     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in the provided layout\n@@ -1763,6 +2038,7 @@\n-     * @param layout the layout of the region of memory to be written.\n-     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n-     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n-     * @param value the short value to be written.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @param layout the layout of the region of memory to be written\n+     * @param index a logical index, the offset in bytes (relative to this\n+     *              segment address) at which the access operation will occur can be\n+     *              expressed as {@code (index * layout.byteSize())}\n+     * @param value the short value to be written\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -1772,1 +2048,2 @@\n-     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in the provided layout\n@@ -1781,1 +2058,2 @@\n-     * Writes a boolean into this segment at the given index, scaled by the given layout size.\n+     * Writes a boolean into this segment at the given index, scaled by the given\n+     * layout size.\n@@ -1783,6 +2061,7 @@\n-     * @param layout the layout of the region of memory to be written.\n-     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n-     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n-     * @param value the short value to be written.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @param layout the layout of the region of memory to be written\n+     * @param index a logical index, the offset in bytes (relative to this\n+     *              segment address) at which the access operation will occur can be\n+     *              expressed as {@code (index * layout.byteSize())}\n+     * @param value the short value to be written\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -1792,1 +2071,2 @@\n-     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in the provided layout\n@@ -1801,1 +2081,2 @@\n-     * Writes a short into this segment at the given index, scaled by the given layout size.\n+     * Writes a short into this segment at the given index, scaled by the given\n+     * layout size.\n@@ -1803,6 +2084,7 @@\n-     * @param layout the layout of the region of memory to be written.\n-     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n-     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n-     * @param value the short value to be written.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @param layout the layout of the region of memory to be written\n+     * @param index a logical index, the offset in bytes (relative to this\n+     *              segment address) at which the access operation will occur can be\n+     *              expressed as {@code (index * layout.byteSize())}\n+     * @param value the short value to be written\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -1812,1 +2094,2 @@\n-     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in the provided layout\n@@ -1821,1 +2104,2 @@\n-     * Reads an int from this segment at the given index, scaled by the given layout size.\n+     * Reads an int from this segment at the given index, scaled by the given\n+     * layout size.\n@@ -1824,5 +2108,6 @@\n-     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n-     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n-     * @return an int value read from this segment.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @param index a logical index, the offset in bytes (relative to this\n+     *              segment address) at which the access operation will occur can be\n+     *              expressed as {@code (index * layout.byteSize())}\n+     * @return an int value read from this segment\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -1832,1 +2117,2 @@\n-     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in the provided layout\n@@ -1840,1 +2126,2 @@\n-     * Writes an int into this segment at the given index, scaled by the given layout size.\n+     * Writes an int into this segment at the given index, scaled by the given\n+     * layout size.\n@@ -1842,6 +2129,7 @@\n-     * @param layout the layout of the region of memory to be written.\n-     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n-     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n-     * @param value the int value to be written.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @param layout the layout of the region of memory to be written\n+     * @param index a logical index, the offset in bytes (relative to this\n+     *              segment address) at which the access operation\n+     *              will occur can be expressed as {@code (index * layout.byteSize())}\n+     * @param value the int value to be written\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -1851,1 +2139,2 @@\n-     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in the provided layout\n@@ -1860,1 +2149,2 @@\n-     * Reads a float from this segment at the given index, scaled by the given layout size.\n+     * Reads a float from this segment at the given index, scaled by the given\n+     * layout size.\n@@ -1862,6 +2152,7 @@\n-     * @param layout the layout of the region of memory to be read.\n-     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n-     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n-     * @return a float value read from this segment.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @param layout the layout of the region of memory to be read\n+     * @param index a logical index, the offset in bytes (relative to this\n+     *              segment address) at which the access operation will occur can be\n+     *              expressed as {@code (index * layout.byteSize())}\n+     * @return a float value read from this segment\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -1871,1 +2162,2 @@\n-     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in the provided layout\n@@ -1879,1 +2171,2 @@\n-     * Writes a float into this segment at the given index, scaled by the given layout size.\n+     * Writes a float into this segment at the given index, scaled by the given\n+     * layout size.\n@@ -1881,6 +2174,7 @@\n-     * @param layout the layout of the region of memory to be written.\n-     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n-     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n-     * @param value the float value to be written.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @param layout the layout of the region of memory to be written\n+     * @param index a logical index, the offset in bytes (relative to this\n+     *              segment address) at which the access operation will occur can be\n+     *              expressed as {@code (index * layout.byteSize())}\n+     * @param value the float value to be written\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -1890,1 +2184,2 @@\n-     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in the provided layout\n@@ -1899,1 +2194,2 @@\n-     * Reads a long from this segment at the given index, scaled by the given layout size.\n+     * Reads a long from this segment at the given index, scaled by the given\n+     * layout size.\n@@ -1901,6 +2197,7 @@\n-     * @param layout the layout of the region of memory to be read.\n-     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n-     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n-     * @return a long value read from this segment.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @param layout the layout of the region of memory to be read\n+     * @param index a logical index, the offset in bytes (relative to this\n+     *              segment address) at which the access operation will occur can be\n+     *              expressed as {@code (index * layout.byteSize())}\n+     * @return a long value read from this segment\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -1910,1 +2207,2 @@\n-     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in the provided layout\n@@ -1918,1 +2216,2 @@\n-     * Writes a long into this segment at the given index, scaled by the given layout size.\n+     * Writes a long into this segment at the given index, scaled by the given\n+     * layout size.\n@@ -1920,6 +2219,7 @@\n-     * @param layout the layout of the region of memory to be written.\n-     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n-     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n-     * @param value the long value to be written.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @param layout the layout of the region of memory to be written\n+     * @param index a logical index, the offset in bytes (relative to this\n+     *              segment address) at which the access operation will occur can be\n+     *              expressed as {@code (index * layout.byteSize())}\n+     * @param value the long value to be written\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -1929,1 +2229,2 @@\n-     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in the provided layout\n@@ -1938,1 +2239,2 @@\n-     * Reads a double from this segment at the given index, scaled by the given layout size.\n+     * Reads a double from this segment at the given index, scaled by the given\n+     * layout size.\n@@ -1940,6 +2242,7 @@\n-     * @param layout the layout of the region of memory to be read.\n-     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n-     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n-     * @return a double value read from this segment.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @param layout the layout of the region of memory to be read\n+     * @param index a logical index, the offset in bytes (relative to this\n+     *              segment address) at which the access operation will occur can be\n+     *              expressed as {@code (index * layout.byteSize())}\n+     * @return a double value read from this segment\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -1949,1 +2252,2 @@\n-     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in the provided layout\n@@ -1957,1 +2261,2 @@\n-     * Writes a double into this segment at the given index, scaled by the given layout size.\n+     * Writes a double into this segment at the given index, scaled by the given\n+     * layout size.\n@@ -1959,6 +2264,7 @@\n-     * @param layout the layout of the region of memory to be written.\n-     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n-     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n-     * @param value the double value to be written.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @param layout the layout of the region of memory to be written\n+     * @param index a logical index, the offset in bytes (relative to this\n+     *              segment address) at which the access operation will occur can be\n+     *              expressed as {@code (index * layout.byteSize())}\n+     * @param value the double value to be written\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -1968,1 +2274,2 @@\n-     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in the provided layout\n@@ -1977,11 +2284,14 @@\n-     * Reads an address from this segment at the given at the given index, scaled by the given layout size. The read address is wrapped in\n-     * a native segment, associated with the global scope. Under normal conditions,\n-     * the size of the returned segment is {@code 0}. However, if the provided address layout has a\n-     * {@linkplain AddressLayout#targetLayout() target layout} {@code T}, then the size of the returned segment\n-     * is set to {@code T.byteSize()}.\n-     * @param layout the layout of the region of memory to be read.\n-     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n-     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n-     * @return a native segment wrapping an address read from this segment.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * Reads an address from this segment at the given at the given index, scaled by the\n+     * given layout size. The read address is wrapped in a native segment, associated\n+     * with the global scope. Under normal conditions, the size of the returned segment\n+     * is {@code 0}. However, if the provided address layout has a\n+     * {@linkplain AddressLayout#targetLayout() target layout} {@code T}, then the size\n+     * of the returned segment is set to {@code T.byteSize()}.\n+     *\n+     * @param layout the layout of the region of memory to be read\n+     * @param index a logical index, the offset in bytes (relative to this\n+     *              segment address) at which the access operation will occur can be\n+     *              expressed as {@code (index * layout.byteSize())}\n+     * @return a native segment wrapping an address read from this segment\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -1991,1 +2301,2 @@\n-     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in the provided layout.\n@@ -1993,3 +2304,5 @@\n-     * @throws IllegalArgumentException if provided address layout has a {@linkplain AddressLayout#targetLayout() target layout}\n-     *         {@code T}, and the address of the returned segment\n-     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in {@code T}\n+     * @throws IllegalArgumentException if provided address layout has a\n+     *         {@linkplain AddressLayout#targetLayout() target layout} {@code T}, and the\n+     *         address of the returned segment is\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in {@code T}\n@@ -2002,1 +2315,2 @@\n-     * Writes an address into this segment at the given index, scaled by the given layout size.\n+     * Writes an address into this segment at the given index, scaled by the given\n+     * layout size.\n@@ -2004,6 +2318,7 @@\n-     * @param layout the layout of the region of memory to be written.\n-     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n-     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n-     * @param value the address value to be written.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n-     * {@linkplain Scope#isAlive() alive}.\n+     * @param layout the layout of the region of memory to be written\n+     * @param index a logical index, the offset in bytes (relative to this\n+     *              segment address) at which the access operation will occur can be\n+     *              expressed as {@code (index * layout.byteSize())}\n+     * @param value the address value to be written\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n@@ -2011,1 +2326,1 @@\n-     * such that {@code isAccessibleBy(T) == false}.\n+     *         such that {@code isAccessibleBy(T) == false}\n@@ -2013,6 +2328,7 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n-     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n-     * @throws IndexOutOfBoundsException if {@code index * layout.byteSize()} overflows.\n-     * @throws IndexOutOfBoundsException if {@code index * layout.byteSize() > byteSize() - layout.byteSize()}.\n-     * @throws UnsupportedOperationException if this segment is {@linkplain #isReadOnly() read-only}.\n-     * @throws UnsupportedOperationException if {@code value} is not a {@linkplain #isNative() native} segment.\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}\n+     * @throws IndexOutOfBoundsException if {@code index * layout.byteSize()} overflows\n+     * @throws IndexOutOfBoundsException if {@code index * layout.byteSize() > byteSize() - layout.byteSize()}\n+     * @throws UnsupportedOperationException if this segment is {@linkplain #isReadOnly() read-only}\n+     * @throws UnsupportedOperationException if {@code value} is not a {@linkplain #isNative() native} segment\n@@ -2023,3 +2339,6 @@\n-     * Compares the specified object with this memory segment for equality. Returns {@code true} if and only if the specified\n-     * object is also a memory segment, and if the two segments refer to the same location, in some region of memory.\n-     * More specifically, for two segments {@code s1} and {@code s2} to be considered equals, all the following must be true:\n+     * Compares the specified object with this memory segment for equality. Returns\n+     * {@code true} if and only if the specified object is also a memory segment, and if\n+     * the two segments refer to the same location, in some region of memory.\n+     * <p>\n+     * More specifically, for two segments {@code s1} and {@code s2} to be considered\n+     * equal, all the following must be true:\n@@ -2027,6 +2346,8 @@\n-     *     <li>{@code s1.heapBase().equals(s2.heapBase())}, that is, the two segments must be of the same kind;\n-     *     either both are {@linkplain #isNative() native segments}, backed by off-heap memory, or both are backed by\n-     *     the same on-heap {@linkplain #heapBase() Java object};\n-     *     <li>{@code s1.address() == s2.address()}, that is, the address of the two segments should be the same.\n-     *     This means that the two segments either refer to the same location in some off-heap region, or they refer\n-     *     to the same offset inside their associated {@linkplain #heapBase() Java object}.<\/li>\n+     *     <li>{@code s1.heapBase().equals(s2.heapBase())}, that is, the two segments\n+     *     must be of the same kind; either both are {@linkplain #isNative() native segments},\n+     *     backed by off-heap memory, or both are backed by the same on-heap\n+     *     {@linkplain #heapBase() Java object};\n+     *     <li>{@code s1.address() == s2.address()}, that is, the address of the two\n+     *     segments should be the same. This means that the two segments either refer to\n+     *     the same location in some off-heap region, or they refer to the same offset\n+     *     inside their associated {@linkplain #heapBase() Java object}.<\/li>\n@@ -2034,7 +2355,9 @@\n-     * @apiNote This method does not perform a structural comparison of the contents of the two memory segments. Clients can\n-     * compare memory segments structurally by using the {@link #mismatch(MemorySegment)} method instead. Note that this\n-     * method does <em>not<\/em> compare the temporal and spatial bounds of two segments. As such it is suitable\n-     * to check whether two segments have the same address.\n-     *\n-     * @param that the object to be compared for equality with this memory segment.\n-     * @return {@code true} if the specified object is equal to this memory segment.\n+     * @apiNote This method does not perform a structural comparison of the contents of\n+     *          the two memory segments. Clients can compare memory segments structurally\n+     *          by using the {@link #mismatch(MemorySegment)} method instead. Note that\n+     *          this method does <em>not<\/em> compare the temporal and spatial bounds of\n+     *          two segments. As such, it is suitable to check whether two segments have\n+     *          the same address.\n+     *\n+     * @param that the object to be compared for equality with this memory segment\n+     * @return {@code true} if the specified object is equal to this memory segment\n@@ -2054,13 +2377,21 @@\n-     * Copies a number of elements from a source memory segment to a destination array. The elements, whose size and alignment\n-     * constraints are specified by the given layout, are read from the source segment, starting at the given offset\n-     * (expressed in bytes), and are copied into the destination array, at the given index.\n-     * Supported array types are {@code byte[]}, {@code char[]}, {@code short[]}, {@code int[]}, {@code float[]}, {@code long[]} and {@code double[]}.\n-     * @param srcSegment the source segment.\n-     * @param srcLayout the source element layout. If the byte order associated with the layout is\n-     * different from the {@linkplain ByteOrder#nativeOrder native order}, a byte swap operation will be performed on each array element.\n-     * @param srcOffset the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination array.\n-     * @param dstIndex the starting index of the destination array.\n-     * @param elementCount the number of array elements to be copied.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with {@code srcSegment} is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * Copies a number of elements from a source memory segment to a destination array.\n+     * The elements, whose size and alignment constraints are specified by the given\n+     * layout, are read from the source segment, starting at the given offset\n+     * (expressed in bytes), and are copied into the destination array, at the\n+     * given index.\n+     * <p>\n+     * Supported array types are :\n+     * {@code byte[]}, {@code char[]}, {@code short[]},\n+     * {@code int[]}, {@code float[]}, {@code long[]} and {@code double[]}.\n+     *\n+     * @param srcSegment the source segment\n+     * @param srcLayout the source element layout. If the byte order associated with the\n+     *                 layout is different from the\n+     *                 {@linkplain ByteOrder#nativeOrder native order}, a byte swap\n+     *                  operation will be performed on each array element\n+     * @param srcOffset the starting offset, in bytes, of the source segment\n+     * @param dstArray the destination array\n+     * @param dstIndex the starting index of the destination array\n+     * @param elementCount the number of array elements to be copied\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         {@code srcSegment} is not {@linkplain Scope#isAlive() alive}\n@@ -2069,4 +2400,7 @@\n-     * @throws IllegalArgumentException if {@code dstArray} is not an array, or if it is an array but whose type is not supported\n-     * @throws IllegalArgumentException if the destination array component type does not match {@code srcLayout.carrier()}\n-     * @throws IllegalArgumentException if {@code offset} is <a href=\"MemorySegment.html#segment-alignment\">incompatible\n-     *         with the alignment constraint<\/a> in the source element layout\n+     * @throws IllegalArgumentException if {@code dstArray} is not an array, or if it is\n+     *         an array but whose type is not supported\n+     * @throws IllegalArgumentException if the destination array component type does not\n+     *         match {@code srcLayout.carrier()}\n+     * @throws IllegalArgumentException if {@code offset} is\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in the source element layout\n@@ -2093,13 +2427,21 @@\n-     * Copies a number of elements from a source array to a destination memory segment. The elements, whose size and alignment\n-     * constraints are specified by the given layout, are read from the source array, starting at the given index,\n-     * and are copied into the destination segment, at the given offset (expressed in bytes).\n-     * Supported array types are {@code byte[]}, {@code char[]}, {@code short[]}, {@code int[]}, {@code float[]}, {@code long[]} and {@code double[]}.\n-     * @param srcArray the source array.\n-     * @param srcIndex the starting index of the source array.\n-     * @param dstSegment the destination segment.\n-     * @param dstLayout the destination element layout. If the byte order associated with the layout is\n-     * different from the {@linkplain ByteOrder#nativeOrder native order}, a byte swap operation will be performed on each array element.\n-     * @param dstOffset the starting offset, in bytes, of the destination segment.\n-     * @param elementCount the number of array elements to be copied.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with {@code dstSegment} is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * Copies a number of elements from a source array to a destination memory segment.\n+     * <p>\n+     * The elements, whose size and alignment constraints are specified by the given\n+     * layout, are read from the source array, starting at the given index, and are\n+     * copied into the destination segment, at the given offset (expressed in bytes).\n+     * <p>\n+     * Supported array types are\n+     * {@code byte[]}, {@code char[]}, {@code short[]},\n+     * {@code int[]}, {@code float[]}, {@code long[]} and {@code double[]}.\n+     *\n+     * @param srcArray the source array\n+     * @param srcIndex the starting index of the source array\n+     * @param dstSegment the destination segment\n+     * @param dstLayout the destination element layout. If the byte order associated\n+     *                  with the layout is different from the\n+     *                  {@linkplain ByteOrder#nativeOrder native order}, a byte swap\n+     *                  operation will be performed on each array element.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment\n+     * @param elementCount the number of array elements to be copied\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         {@code dstSegment} is not {@linkplain Scope#isAlive() alive}\n@@ -2108,4 +2450,7 @@\n-     * @throws IllegalArgumentException if {@code srcArray} is not an array, or if it is an array but whose type is not supported\n-     * @throws IllegalArgumentException if the source array component type does not match {@code srcLayout.carrier()}\n-     * @throws IllegalArgumentException if {@code offset} is <a href=\"MemorySegment.html#segment-alignment\">incompatible\n-     *         with the alignment constraint<\/a> in the source element layout\n+     * @throws IllegalArgumentException if {@code srcArray} is not an array, or if it is\n+     *         an array but whose type is not supported\n+     * @throws IllegalArgumentException if the source array component type does not\n+     *         match {@code srcLayout.carrier()}\n+     * @throws IllegalArgumentException if {@code offset} is\n+     *         <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     *         in the source element layout\n@@ -2133,3 +2478,4 @@\n-     * Finds and returns the relative offset, in bytes, of the first mismatch between the source and the destination\n-     * segments. More specifically, the bytes at offset {@code srcFromOffset} through {@code srcToOffset - 1} in the\n-     * source segment are compared against the bytes at offset {@code dstFromOffset} through {@code dstToOffset - 1}\n+     * Finds and returns the relative offset, in bytes, of the first mismatch between the\n+     * source and the destination segments. More specifically, the bytes at offset\n+     * {@code srcFromOffset} through {@code srcToOffset - 1} in the source segment are\n+     * compared against the bytes at offset {@code dstFromOffset} through {@code dstToOffset - 1}\n@@ -2138,5 +2484,7 @@\n-     * If the two segments, over the specified ranges, share a common prefix then the returned offset is the length\n-     * of the common prefix, and it follows that there is a mismatch between the two segments at that relative offset\n-     * within the respective segments. If one segment is a proper prefix of the other, over the specified ranges,\n-     * then the returned offset is the smallest range, and it follows that the relative offset is only\n-     * valid for the segment with the larger range. Otherwise, there is no mismatch and {@code -1} is returned.\n+     * If the two segments, over the specified ranges, share a common prefix then the\n+     * returned offset is the length of the common prefix, and it follows that there is a\n+     * mismatch between the two segments at that relative offset within the respective\n+     * segments. If one segment is a proper prefix of the other, over the specified\n+     * ranges, then the returned offset is the smallest range, and it follows that the\n+     * relative offset is only valid for the segment with the larger range. Otherwise,\n+     * there is no mismatch and {@code -1} is returned.\n@@ -2145,9 +2493,13 @@\n-     * @param srcFromOffset the offset (inclusive) of the first byte in the source segment to be tested.\n-     * @param srcToOffset the offset (exclusive) of the last byte in the source segment to be tested.\n-     * @param dstSegment the destination segment.\n-     * @param dstFromOffset the offset (inclusive) of the first byte in the destination segment to be tested.\n-     * @param dstToOffset the offset (exclusive) of the last byte in the destination segment to be tested.\n-     * @return the relative offset, in bytes, of the first mismatch between the source and destination segments,\n-     * otherwise -1 if no mismatch.\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with {@code srcSegment} is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @param srcFromOffset the offset (inclusive) of the first byte in the\n+     *                      source segment to be tested\n+     * @param srcToOffset the offset (exclusive) of the last byte in the\n+     *                    source segment to be tested\n+     * @param dstSegment the destination segment\n+     * @param dstFromOffset the offset (inclusive) of the first byte in the\n+     *                      destination segment to be tested\n+     * @param dstToOffset the offset (exclusive) of the last byte in the\n+     *                    destination segment to be tested\n+     * @return the relative offset, in bytes, of the first mismatch between the\n+     *         source and destination segments, otherwise -1 if no mismatch\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         {@code srcSegment} is not {@linkplain Scope#isAlive() alive}\n@@ -2156,2 +2508,2 @@\n-     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with {@code dstSegment} is not\n-     *         {@linkplain Scope#isAlive() alive}\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         {@code dstSegment} is not {@linkplain Scope#isAlive() alive}\n@@ -2160,1 +2512,2 @@\n-     * @throws IndexOutOfBoundsException if {@code srcFromOffset < 0}, {@code srcToOffset < srcFromOffset} or\n+     * @throws IndexOutOfBoundsException if {@code srcFromOffset < 0},\n+     *         {@code srcToOffset < srcFromOffset} or\n@@ -2162,1 +2515,2 @@\n-     * @throws IndexOutOfBoundsException if {@code dstFromOffset < 0}, {@code dstToOffset < dstFromOffset} or\n+     * @throws IndexOutOfBoundsException if {@code dstFromOffset < 0},\n+     *         {@code dstToOffset < dstFromOffset} or\n@@ -2175,3 +2529,11 @@\n-     * A scope models the <em>lifetime<\/em> of all the memory segments associated with it. That is, a memory segment\n-     * cannot be accessed if its associated scope is not {@linkplain #isAlive() alive}. Scope instances can be compared\n-     * for equality. That is, two scopes are considered {@linkplain #equals(Object) equal} if they denote the same lifetime.\n+     * A scope models the <em>lifetime<\/em> of all the memory segments associated with it.\n+     * <p>\n+     * That is, a memory segment cannot be accessed if its associated scope is not\n+     * {@linkplain #isAlive() alive}. Scope instances can be compared for equality.\n+     * That is, two scopes are considered {@linkplain #equals(Object) equal} if they\n+     * denote the same lifetime.\n+     * <p>\n+     * The lifetime of a memory segment can be either <em>unbounded<\/em> or\n+     * <em>bounded<\/em>. An unbounded lifetime is modelled with the <em>global scope<\/em>.\n+     * The global scope is always {@link #isAlive() alive}. As such, a segment associated\n+     * with the global scope features trivial temporal bounds, and is always accessible.\n@@ -2179,3 +2541,0 @@\n-     * The lifetime of a memory segment can be either <em>unbounded<\/em> or <em>bounded<\/em>. An unbounded lifetime\n-     * is modelled with the <em>global scope<\/em>. The global scope is always {@link #isAlive() alive}. As such, a segment\n-     * associated with the global scope features trivial temporal bounds, and is always accessible.\n@@ -2185,1 +2544,2 @@\n-     *     <li>Segments obtained from a raw address, using the {@link MemorySegment#ofAddress(long)} factory; and<\/li>\n+     *     <li>Segments obtained from a raw address, using the\n+     *         {@link MemorySegment#ofAddress(long)} factory; and<\/li>\n@@ -2189,3 +2549,6 @@\n-     * Conversely, a bounded lifetime is modelled with a segment scope that can be invalidated, either {@link Arena#close() explicitly},\n-     * or automatically, by the garbage collector. A segment scope that is invalidated automatically is an <em>automatic scope<\/em>.\n-     * An automatic scope is always {@link #isAlive() alive} as long as it is <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">reachable<\/a>.\n+     * Conversely, a bounded lifetime is modelled with a segment scope that can be\n+     * invalidated, either {@link Arena#close() explicitly}, or automatically, by the\n+     * garbage collector. A segment scope that is invalidated automatically is an\n+     * <em>automatic scope<\/em>. An automatic scope is always {@link #isAlive() alive}\n+     * as long as it is <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">reachable<\/a>.\n+     * <p>\n@@ -2195,2 +2558,4 @@\n-     *     <li>Segments obtained from a Java array, e.g. using the {@link MemorySegment#ofArray(int[])} factory;<\/li>\n-     *     <li>Segments obtained from a buffer, using the {@link MemorySegment#ofBuffer(Buffer)} factory; and<\/li>\n+     *     <li>Segments obtained from a Java array, e.g. using the\n+     *         {@link MemorySegment#ofArray(int[])} factory;<\/li>\n+     *     <li>Segments obtained from a buffer, using the\n+     *         {@link MemorySegment#ofBuffer(Buffer)} factory; and<\/li>\n@@ -2199,2 +2564,3 @@\n-     * If two memory segments are obtained from the same {@linkplain #ofBuffer(Buffer) buffer}\n-     * or {@linkplain #ofArray(int[]) array}, the automatic scopes associated with said segments are considered\n+     * If two memory segments are obtained from the same\n+     * {@linkplain #ofBuffer(Buffer) buffer} or {@linkplain #ofArray(int[]) array}, the\n+     * automatic scopes associated with said segments are considered\n@@ -2211,2 +2577,2 @@\n-         * {@return {@code true}, if the regions of memory backing the memory segments associated with this scope are\n-         * still valid}\n+         * {@return {@code true}, if the regions of memory backing the memory segments\n+         * associated with this scope are still valid}\n@@ -2217,4 +2583,5 @@\n-         * {@return {@code true}, if the provided object is also a scope, which models the same lifetime as that\n-         * modelled by this scope}. In that case, it is always the case that\n-         * {@code this.isAlive() == ((Scope)that).isAlive()}.\n-         * @param that the object to be tested.\n+         * {@return {@code true}, if the provided object is also a scope, which models\n+         * the same lifetime as that modelled by this scope}. In that case, it is always\n+         * the case that {@code this.isAlive() == ((Scope)that).isAlive()}.\n+         *\n+         * @param that the object to be tested\n@@ -2227,2 +2594,5 @@\n-         * @implSpec Implementations of this method obey the general contract of {@link Object#hashCode}.\n-         * @return the hash code of this scope object.\n+         *\n+         * @implSpec Implementations of this method obey the general contract of\n+         * {@link Object#hashCode}.\n+         *\n+         * @return the hash code of this scope object\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":1348,"deletions":978,"binary":false,"changes":2326,"status":"modified"},{"patch":"@@ -31,2 +31,3 @@\n- * A padding layout. A padding layout specifies the size of extra space which is typically not accessed by applications,\n- * and is typically used for aligning member layouts around word boundaries.\n+ * A padding layout. A padding layout specifies the size of extra space which is\n+ * typically not accessed by applications, and is typically used for aligning member\n+ * layouts around word boundaries.\n@@ -35,1 +36,2 @@\n- * Implementing classes are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ * Implementing classes are immutable, thread-safe and\n+ * <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/PaddingLayout.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -39,3 +39,4 @@\n- * An object that may be used to allocate {@linkplain MemorySegment memory segments}. Clients implementing this interface\n- * must implement the {@link #allocate(long, long)} method. A segment allocator defines several methods\n- * which can be useful to create segments from several kinds of Java values such as primitives and arrays.\n+ * An object that may be used to allocate {@linkplain MemorySegment memory segments}.\n+ * Clients implementing this interface must implement the {@link #allocate(long, long)}\n+ * method. A segment allocator defines several methods which can be useful to create\n+ * segments from several kinds of Java values such as primitives and arrays.\n@@ -43,2 +44,3 @@\n- * {@code SegmentAllocator} is a {@linkplain FunctionalInterface functional interface}. Clients can easily obtain a new\n- * segment allocator by using either a lambda expression or a method reference:\n+ * {@code SegmentAllocator} is a {@linkplain FunctionalInterface functional interface}.\n+ * Clients can easily obtain a new segment allocator by using either a lambda expression\n+ * or a method reference:\n@@ -52,4 +54,5 @@\n- *     <li>{@link #slicingAllocator(MemorySegment)} obtains an efficient slicing allocator, where memory\n- *     is allocated by repeatedly slicing the provided memory segment;<\/li>\n- *     <li>{@link #prefixAllocator(MemorySegment)} obtains an allocator which wraps a segment\n- *     and recycles its content upon each new allocation request.<\/li>\n+ *     <li>{@link #slicingAllocator(MemorySegment)} obtains an efficient slicing\n+ *         allocator, where memory is allocated by repeatedly slicing the provided\n+ *         memory segment;<\/li>\n+ *     <li>{@link #prefixAllocator(MemorySegment)} obtains an allocator which wraps a\n+ *         segment and recycles its content upon each new allocation request.<\/li>\n@@ -58,5 +61,7 @@\n- * Passing a segment allocator to an API can be especially useful in circumstances where a client wants to communicate <em>where<\/em>\n- * the results of a certain operation (performed by the API) should be stored, as a memory segment. For instance,\n- * {@linkplain Linker#downcallHandle(FunctionDescriptor, Linker.Option...) downcall method handles} can accept an additional\n- * {@link SegmentAllocator} parameter if the underlying foreign function is known to return a struct by-value. Effectively,\n- * the allocator parameter tells the linker where to store the return value of the foreign function.\n+ * Passing a segment allocator to an API can be especially useful in circumstances where\n+ * a client wants to communicate <em>where<\/em> the results of a certain operation\n+ * (performed by the API) should be stored, as a memory segment. For instance,\n+ * {@linkplain Linker#downcallHandle(FunctionDescriptor, Linker.Option...) downcall method handles}\n+ * can accept an additional {@link SegmentAllocator} parameter if the underlying\n+ * foreign function is known to return a struct by-value. Effectively, the allocator\n+ * parameter tells the linker where to store the return value of the foreign function.\n@@ -64,4 +69,5 @@\n- * @apiNote Unless otherwise specified, the {@link #allocate(long, long)} method is not thread-safe.\n- * Furthermore, memory segments allocated by a segment allocator can be associated with different\n- * lifetimes, and can even be backed by overlapping regions of memory. For these reasons, clients should generally\n- * only interact with a segment allocator they own.\n+ * @apiNote Unless otherwise specified, the {@link #allocate(long, long)} method is\n+ *          not thread-safe. Furthermore, memory segments allocated by a segment\n+ *          allocator can be associated with different lifetimes, and can even be backed\n+ *          by overlapping regions of memory. For these reasons, clients should\n+ *          generally only interact with a segment allocator they own.\n@@ -69,2 +75,2 @@\n- * Clients should consider using an {@linkplain Arena arena} instead, which, provides strong thread-safety,\n- * lifetime and non-overlapping guarantees.\n+ * Clients should consider using an {@linkplain Arena arena} instead, which, provides\n+ * strong thread-safety, lifetime and non-overlapping guarantees.\n@@ -78,2 +84,3 @@\n-     * Converts a Java string into a null-terminated C string using the {@linkplain StandardCharsets#UTF_8 UTF-8} charset,\n-     * storing the result into a memory segment.\n+     * Converts a Java string into a null-terminated C string using the\n+     * {@linkplain StandardCharsets#UTF_8 UTF-8} charset, storing the result into a\n+     * memory segment.\n@@ -86,2 +93,2 @@\n-     * @param str the Java string to be converted into a C string.\n-     * @return a new native segment containing the converted C string.\n+     * @param str the Java string to be converted into a C string\n+     * @return a new native segment containing the converted C string\n@@ -100,1 +107,1 @@\n-     * sequences with this charset's default replacement byte array.  The\n+     * sequences with this charset's default replacement byte array. The\n@@ -109,6 +116,9 @@\n-     * @param str     the Java string to be converted into a C string.\n-     * @param charset the charset used to {@linkplain Charset#newEncoder() encode} the string bytes.\n-     * @return a new native segment containing the converted C string.\n-     * @throws IllegalArgumentException if {@code charset} is not a {@linkplain StandardCharsets standard charset}\n-     * @implSpec The default implementation for this method copies the contents of the provided Java string\n-     * into a new memory segment obtained by calling {@code this.allocate(B + N)}, where:\n+     * @param str     the Java string to be converted into a C string\n+     * @param charset the charset used to {@linkplain Charset#newEncoder() encode} the\n+     *                string bytes\n+     * @return a new native segment containing the converted C string\n+     * @throws IllegalArgumentException if {@code charset} is not a\n+     *         {@linkplain StandardCharsets standard charset}\n+     * @implSpec The default implementation for this method copies the contents of the\n+     *           provided Java string into a new memory segment obtained by calling\n+     *           {@code this.allocate(B + N)}, where:\n@@ -116,4 +126,5 @@\n-     *     <li>{@code B} is the size, in bytes, of the string encoded using the provided charset\n-     *     (e.g. {@code str.getBytes(charset).length});<\/li>\n-     *     <li>{@code N} is the size (in bytes) of the terminator char according to the provided charset. For instance,\n-     *     this is 1 for {@link StandardCharsets#US_ASCII} and 2 for {@link StandardCharsets#UTF_16}.<\/li>\n+     *     <li>{@code B} is the size, in bytes, of the string encoded using the\n+     *         provided charset (e.g. {@code str.getBytes(charset).length});<\/li>\n+     *     <li>{@code N} is the size (in bytes) of the terminator char according to the\n+     *         provided charset. For instance, this is 1 for {@link StandardCharsets#US_ASCII}\n+     *         and 2 for {@link StandardCharsets#UTF_16}.<\/li>\n@@ -146,1 +157,1 @@\n-     * {@return a new memory segment initialized with the provided byte value.}\n+     * {@return a new memory segment initialized with the provided byte value}\n@@ -148,3 +159,4 @@\n-     * The size of the allocated memory segment is the {@linkplain MemoryLayout#byteSize() size} of the given layout.\n-     * The given value is written into the segment according to the byte order and alignment constraint of the\n-     * given layout.\n+     * The size of the allocated memory segment is the\n+     * {@linkplain MemoryLayout#byteSize() size} of the given layout. The given value is\n+     * written into the segment according to the byte order and alignment constraint of\n+     * the given layout.\n@@ -159,2 +171,2 @@\n-     * @param layout the layout of the block of memory to be allocated.\n-     * @param value  the value to be set in the newly allocated memory segment.\n+     * @param layout the layout of the block of memory to be allocated\n+     * @param value  the value to be set in the newly allocated memory segment\n@@ -170,1 +182,1 @@\n-     * {@return a new memory segment initialized with the provided char value.}\n+     * {@return a new memory segment initialized with the provided char value}\n@@ -172,3 +184,4 @@\n-     * The size of the allocated memory segment is the {@linkplain MemoryLayout#byteSize() size} of the given layout.\n-     * The given value is written into the segment according to the byte order and alignment constraint of the\n-     * given layout.\n+     * The size of the allocated memory segment is the\n+     * {@linkplain MemoryLayout#byteSize() size} of the given layout.\n+     * The given value is written into the segment according to the byte order and\n+     * alignment constraint of the given layout.\n@@ -183,2 +196,2 @@\n-     * @param layout the layout of the block of memory to be allocated.\n-     * @param value  the value to be set in the newly allocated memory segment.\n+     * @param layout the layout of the block of memory to be allocated\n+     * @param value  the value to be set in the newly allocated memory segment\n@@ -194,1 +207,1 @@\n-     * {@return a new memory segment initialized with the provided short value.}\n+     * {@return a new memory segment initialized with the provided short value}\n@@ -196,3 +209,4 @@\n-     * The size of the allocated memory segment is the {@linkplain MemoryLayout#byteSize() size} of the given layout.\n-     * The given value is written into the segment according to the byte order and alignment constraint of the\n-     * given layout.\n+     * The size of the allocated memory segment is the\n+     * {@linkplain MemoryLayout#byteSize() size} of the given layout. The given value is\n+     * written into the segment according to the byte order and alignment constraint of\n+     * the given layout.\n@@ -207,2 +221,2 @@\n-     * @param layout the layout of the block of memory to be allocated.\n-     * @param value  the value to be set in the newly allocated memory segment.\n+     * @param layout the layout of the block of memory to be allocated\n+     * @param value  the value to be set in the newly allocated memory segment\n@@ -218,1 +232,1 @@\n-     * {@return a new memory segment initialized with the provided int value.}\n+     * {@return a new memory segment initialized with the provided int value}\n@@ -220,3 +234,4 @@\n-     * The size of the allocated memory segment is the {@linkplain MemoryLayout#byteSize() size} of the given layout.\n-     * The given value is written into the segment according to the byte order and alignment constraint of the\n-     * given layout.\n+     * The size of the allocated memory segment is the\n+     * {@linkplain MemoryLayout#byteSize() size} of the given layout. The given value is\n+     * written into the segment according to the byte order and alignment constraint of\n+     * the given layout.\n@@ -231,2 +246,2 @@\n-     * @param layout the layout of the block of memory to be allocated.\n-     * @param value  the value to be set in the newly allocated memory segment.\n+     * @param layout the layout of the block of memory to be allocated\n+     * @param value  the value to be set in the newly allocated memory segment\n@@ -242,1 +257,1 @@\n-     * {@return a new memory segment initialized with the provided float value.}\n+     * {@return a new memory segment initialized with the provided float value}\n@@ -244,3 +259,4 @@\n-     * The size of the allocated memory segment is the {@linkplain MemoryLayout#byteSize() size} of the given layout.\n-     * The given value is written into the segment according to the byte order and alignment constraint of the\n-     * given layout.\n+     * The size of the allocated memory segment is the\n+     * {@linkplain MemoryLayout#byteSize() size} of the given layout. The given value is\n+     * written into the segment according to the byte order and alignment constraint of\n+     * the given layout.\n@@ -255,2 +271,2 @@\n-     * @param layout the layout of the block of memory to be allocated.\n-     * @param value  the value to be set in the newly allocated memory segment.\n+     * @param layout the layout of the block of memory to be allocated\n+     * @param value  the value to be set in the newly allocated memory segment\n@@ -266,1 +282,1 @@\n-     * {@return a new memory segment initialized with the provided long value.}\n+     * {@return a new memory segment initialized with the provided long value}\n@@ -268,3 +284,4 @@\n-     * The size of the allocated memory segment is the {@linkplain MemoryLayout#byteSize() size} of the given layout.\n-     * The given value is written into the segment according to the byte order and alignment constraint of the\n-     * given layout.\n+     * The size of the allocated memory segment is the\n+     * {@linkplain MemoryLayout#byteSize() size} of the given layout. The given value is\n+     * written into the segment according to the byte order and alignment constraint of\n+     * the given layout.\n@@ -279,2 +296,2 @@\n-     * @param layout the layout of the block of memory to be allocated.\n-     * @param value  the value to be set in the newly allocated memory segment.\n+     * @param layout the layout of the block of memory to be allocated\n+     * @param value  the value to be set in the newly allocated memory segment\n@@ -290,1 +307,1 @@\n-     * {@return a new memory segment initialized with the provided double value.}\n+     * {@return a new memory segment initialized with the provided double value}\n@@ -292,3 +309,4 @@\n-     * The size of the allocated memory segment is the {@linkplain MemoryLayout#byteSize() size} of the given layout.\n-     * The given value is written into the segment according to the byte order and alignment constraint of the\n-     * given layout.\n+     * The size of the allocated memory segment is the\n+     * {@linkplain MemoryLayout#byteSize() size} of the given layout. The given value is\n+     * written into the segment according to the byte order and alignment constraint of\n+     * the given layout.\n@@ -303,2 +321,2 @@\n-     * @param layout the layout of the block of memory to be allocated.\n-     * @param value  the value to be set in the newly allocated memory segment.\n+     * @param layout the layout of the block of memory to be allocated\n+     * @param value  the value to be set in the newly allocated memory segment\n@@ -314,1 +332,2 @@\n-     * {@return a new memory segment initialized with the {@linkplain MemorySegment#address() address} of the provided memory segment.}\n+     * {@return a new memory segment initialized with the\n+     * {@linkplain MemorySegment#address() address} of the provided memory segment}\n@@ -316,1 +335,2 @@\n-     * The address value might be narrowed according to the platform address size (see {@link ValueLayout#ADDRESS}).\n+     * The address value might be narrowed according to the platform address size\n+     * (see {@link ValueLayout#ADDRESS}).\n@@ -318,3 +338,4 @@\n-     * The size of the allocated memory segment is the {@linkplain MemoryLayout#byteSize() size} of the given layout.\n-     * The given value is written into the segment according to the byte order and alignment constraint of the\n-     * given layout.\n+     * The size of the allocated memory segment is the\n+     * {@linkplain MemoryLayout#byteSize() size} of the given layout. The given value is\n+     * written into the segment according to the byte order and alignment constraint of\n+     * the given layout.\n@@ -330,3 +351,4 @@\n-     * @param layout the layout of the block of memory to be allocated.\n-     * @param value  the value to be set in the newly allocated memory segment.\n-     * @throws UnsupportedOperationException if {@code value} is not a {@linkplain MemorySegment#isNative() native} segment\n+     * @param layout the layout of the block of memory to be allocated\n+     * @param value  the value to be set in the newly allocated memory segment\n+     * @throws UnsupportedOperationException if {@code value} is not\n+     *         a {@linkplain MemorySegment#isNative() native} segment\n@@ -343,1 +365,1 @@\n-     * {@return a new memory segment initialized with the contents of the provided segment.}\n+     * {@return a new memory segment initialized with the contents of the provided segment}\n@@ -345,3 +367,4 @@\n-     * The size of the allocated memory segment is the {@code elementLayout.byteSize() * elementCount}.\n-     * The contents of the source segment is copied into the result segment element by element, according to the byte\n-     * order and alignment constraint of the given element layout.\n+     * The size of the allocated memory segment is the\n+     * {@code elementLayout.byteSize() * elementCount}. The contents of the\n+     * source segment is copied into the result segment element by element, according\n+     * to the byte order and alignment constraint of the given element layout.\n@@ -355,5 +378,5 @@\n-     * @param elementLayout the element layout of the allocated array.\n-     * @param source the source segment.\n-     * @param sourceElementLayout the element layout of the source segment.\n-     * @param sourceOffset the starting offset, in bytes, of the source segment.\n-     * @param elementCount the number of elements in the source segment to be copied.\n+     * @param elementLayout the element layout of the allocated array\n+     * @param source the source segment\n+     * @param sourceElementLayout the element layout of the source segment\n+     * @param sourceOffset the starting offset, in bytes, of the source segment\n+     * @param elementCount the number of elements in the source segment to be copied\n@@ -363,1 +386,1 @@\n-     *         in the source element layout.\n+     *         in the source element layout\n@@ -366,2 +389,2 @@\n-     * @throws IllegalStateException if the {@linkplain MemorySegment#scope() scope} associated with {@code source} is not\n-     *         {@linkplain MemorySegment.Scope#isAlive() alive}\n+     * @throws IllegalStateException if the {@linkplain MemorySegment#scope() scope} associated\n+     *         with {@code source} is not {@linkplain MemorySegment.Scope#isAlive() alive}\n@@ -386,1 +409,2 @@\n-     * {@return a new memory segment initialized with the elements in the provided byte array.}\n+     * {@return a new memory segment initialized with the elements in the provided\n+     *          byte array}\n@@ -388,3 +412,4 @@\n-     * The size of the allocated memory segment is {@code elementLayout.byteSize() * elements.length}.\n-     * The contents of the source array is copied into the result segment element by element, according to the byte\n-     * order and alignment constraint of the given element layout.\n+     * The size of the allocated memory segment is\n+     * {@code elementLayout.byteSize() * elements.length}. The contents of the\n+     * source array is copied into the result segment element by element, according\n+     * to the byte order and alignment constraint of the given element layout.\n@@ -392,1 +417,2 @@\n-     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * @implSpec the default implementation for this method is equivalent to the\n+     *           following code:\n@@ -397,3 +423,5 @@\n-     * @param elementLayout the element layout of the array to be allocated.\n-     * @param elements      the byte elements to be copied to the newly allocated memory block.\n-     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}\n+     * @param elementLayout the element layout of the array to be allocated\n+     * @param elements      the byte elements to be copied to the newly allocated\n+     *                      memory block\n+     * @throws IllegalArgumentException if\n+     *         {@code elementLayout.byteAlignment() > elementLayout.byteSize()}\n@@ -408,1 +436,2 @@\n-     * {@return a new memory segment initialized with the elements in the provided short array.}\n+     * {@return a new memory segment initialized with the elements in the provided\n+     *          short array}\n@@ -410,3 +439,4 @@\n-     * The size of the allocated memory segment is {@code elementLayout.byteSize() * elements.length}.\n-     * The contents of the source array is copied into the result segment element by element, according to the byte\n-     * order and alignment constraint of the given element layout.\n+     * The size of the allocated memory segment is\n+     * {@code elementLayout.byteSize() * elements.length}. The contents of the\n+     * source array is copied into the result segment element by element, according\n+     * to the byte order and alignment constraint of the given element layout.\n@@ -414,1 +444,2 @@\n-     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * @implSpec the default implementation for this method is equivalent to the\n+     *           following code:\n@@ -419,3 +450,5 @@\n-     * @param elementLayout the element layout of the array to be allocated.\n-     * @param elements      the short elements to be copied to the newly allocated memory block.\n-     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}\n+     * @param elementLayout the element layout of the array to be allocated\n+     * @param elements      the short elements to be copied to the newly allocated\n+     *                      memory block\n+     * @throws IllegalArgumentException if\n+     *         {@code elementLayout.byteAlignment() > elementLayout.byteSize()}\n@@ -430,1 +463,2 @@\n-     * {@return a new memory segment initialized with the elements in the provided char array.}\n+     * {@return a new memory segment initialized with the elements in the provided\n+     *          char array}\n@@ -432,3 +466,4 @@\n-     * The size of the allocated memory segment is {@code elementLayout.byteSize() * elements.length}.\n-     * The contents of the source array is copied into the result segment element by element, according to the byte\n-     * order and alignment constraint of the given element layout.\n+     * The size of the allocated memory segment is\n+     * {@code elementLayout.byteSize() * elements.length}. The contents of the\n+     * source array is copied into the result segment element by element, according\n+     * to the byte order and alignment constraint of the given element layout.\n@@ -436,1 +471,2 @@\n-     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * @implSpec the default implementation for this method is equivalent to the\n+     *           following code:\n@@ -441,3 +477,5 @@\n-     * @param elementLayout the element layout of the array to be allocated.\n-     * @param elements      the char elements to be copied to the newly allocated memory block.\n-     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}\n+     * @param elementLayout the element layout of the array to be allocated\n+     * @param elements      the char elements to be copied to the newly allocated\n+     *                      memory block\n+     * @throws IllegalArgumentException if\n+     *         {@code elementLayout.byteAlignment() > elementLayout.byteSize()}\n@@ -452,1 +490,2 @@\n-     * {@return a new memory segment initialized with the elements in the provided int array.}\n+     * {@return a new memory segment initialized with the elements in the provided\n+     *          int array}\n@@ -454,3 +493,4 @@\n-     * The size of the allocated memory segment is {@code elementLayout.byteSize() * elements.length}.\n-     * The contents of the source array is copied into the result segment element by element, according to the byte\n-     * order and alignment constraint of the given element layout.\n+     * The size of the allocated memory segment is\n+     * {@code elementLayout.byteSize() * elements.length}. The contents of the\n+     * source array is copied into the result segment element by element, according\n+     * to the byte order and alignment constraint of the given element layout.\n@@ -458,1 +498,2 @@\n-     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * @implSpec the default implementation for this method is equivalent to the\n+     *           following code:\n@@ -463,3 +504,5 @@\n-     * @param elementLayout the element layout of the array to be allocated.\n-     * @param elements      the int elements to be copied to the newly allocated memory block.\n-     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}\n+     * @param elementLayout the element layout of the array to be allocated\n+     * @param elements      the int elements to be copied to the newly allocated\n+     *                      memory block\n+     * @throws IllegalArgumentException if\n+     *         {@code elementLayout.byteAlignment() > elementLayout.byteSize()}\n@@ -474,1 +517,2 @@\n-     * {@return a new memory segment initialized with the elements in the provided float array.}\n+     * {@return a new memory segment initialized with the elements in the provided\n+     *          float array}\n@@ -476,3 +520,4 @@\n-     * The size of the allocated memory segment is {@code elementLayout.byteSize() * elements.length}.\n-     * The contents of the source array is copied into the result segment element by element, according to the byte\n-     * order and alignment constraint of the given element layout.\n+     * The size of the allocated memory segment is\n+     * {@code elementLayout.byteSize() * elements.length}. The contents of\n+     * the source array is copied into the result segment element by element, according\n+     * to the byte order and alignment constraint of the given element layout.\n@@ -480,1 +525,2 @@\n-     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * @implSpec the default implementation for this method is equivalent to the\n+     *           following code:\n@@ -485,3 +531,5 @@\n-     * @param elementLayout the element layout of the array to be allocated.\n-     * @param elements the float elements to be copied to the newly allocated memory block.\n-     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}\n+     * @param elementLayout the element layout of the array to be allocated\n+     * @param elements the float elements to be copied to the newly allocated\n+     *                 memory block\n+     * @throws IllegalArgumentException if\n+     *         {@code elementLayout.byteAlignment() > elementLayout.byteSize()}\n@@ -496,1 +544,2 @@\n-     * {@return a new memory segment initialized with the elements in the provided long array.}\n+     * {@return a new memory segment initialized with the elements in the provided\n+     *          long array}\n@@ -498,3 +547,4 @@\n-     * The size of the allocated memory segment is {@code elementLayout.byteSize() * elements.length}.\n-     * The contents of the source array is copied into the result segment element by element, according to the byte\n-     * order and alignment constraint of the given element layout.\n+     * The size of the allocated memory segment is\n+     * {@code elementLayout.byteSize() * elements.length}. The contents of\n+     * the source array is copied into the result segment element by element, according\n+     * to the byte order and alignment constraint of the given element layout.\n@@ -502,1 +552,2 @@\n-     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * @implSpec the default implementation for this method is equivalent to the\n+     *           following code:\n@@ -507,3 +558,5 @@\n-     * @param elementLayout the element layout of the array to be allocated.\n-     * @param elements the long elements to be copied to the newly allocated memory block.\n-     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}\n+     * @param elementLayout the element layout of the array to be allocated\n+     * @param elements the long elements to be copied to the newly allocated\n+     *                 memory block\n+     * @throws IllegalArgumentException if\n+     *         {@code elementLayout.byteAlignment() > elementLayout.byteSize()}\n@@ -518,1 +571,2 @@\n-     * {@return a new memory segment initialized with the elements in the provided double array.}\n+     * {@return a new memory segment initialized with the elements in the provided\n+     *          double array}\n@@ -520,3 +574,4 @@\n-     * The size of the allocated memory segment is {@code elementLayout.byteSize() * elements.length}.\n-     * The contents of the source array is copied into the result segment element by element, according to the byte\n-     * order and alignment constraint of the given element layout.\n+     * The size of the allocated memory segment is\n+     * {@code elementLayout.byteSize() * elements.length}. The contents of\n+     * the source array is copied into the result segment element by element, according\n+     * to the byte order and alignment constraint of the given element layout.\n@@ -524,1 +579,2 @@\n-     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * @implSpec the default implementation for this method is equivalent to\n+     *           the following code:\n@@ -529,3 +585,5 @@\n-     * @param elementLayout the element layout of the array to be allocated.\n-     * @param elements      the double elements to be copied to the newly allocated memory block.\n-     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}\n+     * @param elementLayout the element layout of the array to be allocated\n+     * @param elements      the double elements to be copied to the newly allocated\n+     *                      memory block\n+     * @throws IllegalArgumentException if\n+     *         {@code elementLayout.byteAlignment() > elementLayout.byteSize()}\n@@ -543,1 +601,1 @@\n-     * {@code this.allocate(layout.byteSize(), layout.byteAlignment())}.\n+     *           {@code this.allocate(layout.byteSize(), layout.byteAlignment())}.\n@@ -545,1 +603,1 @@\n-     * @param layout the layout of the block of memory to be allocated.\n+     * @param layout the layout of the block of memory to be allocated\n@@ -556,1 +614,1 @@\n-     * {@code this.allocate(MemoryLayout.sequenceLayout(count, elementLayout))}.\n+     *           {@code this.allocate(MemoryLayout.sequenceLayout(count, elementLayout))}.\n@@ -558,3 +616,4 @@\n-     * @param elementLayout the array element layout.\n-     * @param count the array element count.\n-     * @throws IllegalArgumentException if {@code elementLayout.byteSize() * count} overflows\n+     * @param elementLayout the array element layout\n+     * @param count the array element count\n+     * @throws IllegalArgumentException if {@code elementLayout.byteSize() * count}\n+     *         overflows\n@@ -575,1 +634,1 @@\n-     * {@code this.allocate(byteSize, 1)}.\n+     *           {@code this.allocate(byteSize, 1)}.\n@@ -577,1 +636,1 @@\n-     * @param byteSize the size (in bytes) of the block of memory to be allocated.\n+     * @param byteSize the size (in bytes) of the block of memory to be allocated\n@@ -585,5 +644,9 @@\n-     * {@return a new memory segment with the given {@code byteSize} and {@code byteAlignment}}\n-     *\n-     * @param byteSize the size (in bytes) of the block of memory to be allocated.\n-     * @param byteAlignment the alignment (in bytes) of the block of memory to be allocated.\n-     * @throws IllegalArgumentException if {@code byteSize < 0}, {@code byteAlignment <= 0},\n+     * {@return a new memory segment with the given {@code byteSize} and\n+     *          {@code byteAlignment}}\n+     *\n+     * @param byteSize the size (in bytes) of the block of memory\n+     *                 to be allocated\n+     * @param byteAlignment the alignment (in bytes) of the block of memory\n+     *                      to be allocated\n+     * @throws IllegalArgumentException if {@code byteSize < 0},\n+     *         {@code byteAlignment <= 0},\n@@ -595,3 +658,4 @@\n-     * Returns a segment allocator which responds to allocation requests by returning consecutive slices\n-     * obtained from the provided segment. Each new allocation request will return a new slice starting at the\n-     * current offset (modulo additional padding to satisfy alignment constraint), with given size.\n+     * Returns a segment allocator which responds to allocation requests by returning\n+     * consecutive slices obtained from the provided segment. Each new allocation\n+     * request will return a new slice starting at the current offset (modulo additional\n+     * padding to satisfy alignment constraint), with given size.\n@@ -599,2 +663,2 @@\n-     * The returned allocator throws {@link IndexOutOfBoundsException} when a slice of the provided\n-     * segment with the requested size and alignment cannot be found.\n+     * The returned allocator throws {@link IndexOutOfBoundsException} when a slice of\n+     * the provided segment with the requested size and alignment cannot be found.\n@@ -604,1 +668,1 @@\n-     * @param segment the segment which the returned allocator should slice from.\n+     * @param segment the segment which the returned allocator should slice from\n@@ -613,3 +677,4 @@\n-     * Returns a segment allocator which responds to allocation requests by recycling a single segment. Each\n-     * new allocation request will return a new slice starting at the segment offset {@code 0}, hence the name\n-     * <em>prefix allocator<\/em>.\n+     * Returns a segment allocator which responds to allocation requests by recycling a\n+     * single segment. Each new allocation request will return a new slice starting at\n+     * the segment offset {@code 0}, hence the name <em>prefix allocator<\/em>.\n+     * <p>\n@@ -621,2 +686,6 @@\n-     * The returned allocator throws {@link IndexOutOfBoundsException} when a slice of the provided\n-     * segment with the requested size and alignment cannot be found.\n+     * The returned allocator throws {@link IndexOutOfBoundsException} when a slice of\n+     * the provided segment with the requested size and alignment cannot be found.\n+     *\n+     * @apiNote A prefix allocator can be useful to limit allocation requests in case a\n+     *          client knows that they have fully processed the contents of the allocated\n+     *          segment before the subsequent allocation request takes place.\n@@ -624,5 +693,3 @@\n-     * @apiNote A prefix allocator can be useful to limit allocation requests in case a client\n-     * knows that they have fully processed the contents of the allocated segment before the subsequent allocation request\n-     * takes place.\n-     * @implNote While a prefix allocator is <em>thread-safe<\/em>, concurrent access on the same recycling\n-     * allocator might cause a thread to overwrite contents written to the underlying segment by a different thread.\n+     * @implNote While a prefix allocator is <em>thread-safe<\/em>, concurrent access on\n+     *           the same recycling allocator might cause a thread to overwrite contents\n+     *           written to the underlying segment by a different thread.\n@@ -630,2 +697,3 @@\n-     * @param segment the memory segment to be recycled by the returned allocator.\n-     * @return an allocator which recycles an existing segment upon each new allocation request.\n+     * @param segment the memory segment to be recycled by the returned allocator\n+     * @return an allocator which recycles an existing segment upon each new allocation\n+     *         request\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":252,"deletions":184,"binary":false,"changes":436,"status":"modified"},{"patch":"@@ -31,4 +31,5 @@\n- * A compound layout that denotes a homogeneous repetition of a given <em>element layout<\/em>.\n- * The repetition count is said to be the sequence layout's <em>element count<\/em>. A sequence layout can be thought of as a\n- * struct layout where the sequence layout's element layout is repeated a number of times that is equal to the sequence\n- * layout's element count. In other words this layout:\n+ * A compound layout that denotes a homogeneous repetition of a given\n+ * <em>element layout<\/em>. The repetition count is said to be the sequence layout's\n+ * <em>element count<\/em>. A sequence layout can be thought of as a struct layout where\n+ * the sequence layout's element layout is repeated a number of times that is equal to\n+ * the sequence layout's element count. In other words this layout:\n@@ -50,1 +51,2 @@\n- * This class is immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ * This class is immutable, thread-safe and\n+ * <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n@@ -68,2 +70,3 @@\n-     * {@return a sequence layout with the same characteristics of this layout, but with the given element count}\n-     * @param elementCount the new element count.\n+     * {@return a sequence layout with the same characteristics of this layout, but with\n+     *          the given element count}\n+     * @param elementCount the new element count\n@@ -71,1 +74,2 @@\n-     * @throws IllegalArgumentException if {@code elementLayout.bitSize() * elementCount} overflows\n+     * @throws IllegalArgumentException if {@code elementLayout.bitSize() * elementCount}\n+     *         overflows\n@@ -76,4 +80,5 @@\n-     * Rearranges the elements in this sequence layout into a multi-dimensional sequence layout.\n-     * The resulting layout is a sequence layout where element layouts in the {@linkplain #flatten() flattened projection}\n-     * of this sequence layout are rearranged into one or more nested sequence layouts\n-     * according to the provided element counts. This transformation preserves the layout size;\n+     * Rearranges the elements in this sequence layout into a multidimensional sequence\n+     * layout. The resulting layout is a sequence layout where element layouts in the\n+     * {@linkplain #flatten() flattened projection} of this sequence layout are\n+     * rearranged into one or more nested sequence layouts according to the provided\n+     * element counts. This transformation preserves the layout size;\n@@ -92,4 +97,5 @@\n-     * If one of the provided element count is the special value {@code -1}, then the element\n-     * count in that position will be inferred from the remaining element counts and the\n-     * element count of the flattened projection of this layout. For instance, a layout equivalent to\n-     * the above {@code reshapeSeq} can also be computed in the following ways:\n+     * If one of the provided element count is the special value {@code -1}, then\n+     * the element count in that position will be inferred from the remaining element\n+     * counts and the element count of the flattened projection of this layout.\n+     * For instance, a layout equivalent to the above {@code reshapeSeq} can also be\n+     * computed in the following ways:\n@@ -100,6 +106,9 @@\n-     * @param elementCounts an array of element counts, of which at most one can be {@code -1}.\n-     * @return a sequence layout where element layouts in the {@linkplain #flatten() flattened projection} of this\n-     * sequence layout (see {@link #flatten()}) are re-arranged into one or more nested sequence layouts.\n-     * @throws IllegalArgumentException if two or more element counts are set to {@code -1}, or if one\n-     *         or more element count is {@code <= 0} (but other than {@code -1}) or, if, after any required inference,\n-     *         multiplying the element counts does not yield the same element count as the flattened projection of this\n+     * @param elementCounts an array of element counts, of which at most one can be {@code -1}\n+     * @return a sequence layout where element layouts in the\n+     *         {@linkplain #flatten() flattened projection} of this sequence layout\n+     *         (see {@link #flatten()}) are re-arranged into one or more nested\n+     *         sequence layouts\n+     * @throws IllegalArgumentException if two or more element counts are set to {@code -1},\n+     *         or if one or more element count is {@code <= 0} (but other than {@code -1}) or,\n+     *         if, after any required inference, multiplying the element counts does not\n+     *         yield the same element count as the flattened projection of this\n@@ -111,2 +120,3 @@\n-     * Returns a flattened sequence layout. The element layout of the returned sequence layout\n-     * is the first non-sequence layout found by inspecting (recursively, if needed) the element layout of this sequence layout:\n+     * Returns a flattened sequence layout. The element layout of the returned\n+     * sequence layout is the first non-sequence layout found by inspecting\n+     * (recursively, if needed) the element layout of this sequence layout:\n@@ -122,3 +132,4 @@\n-     * This transformation preserves the layout size; nested sequence layout in this sequence layout will\n-     * be dropped and their element counts will be incorporated into that of the returned sequence layout.\n-     * For instance, given a sequence layout of the kind:\n+     * This transformation preserves the layout size; nested sequence layout in this\n+     * sequence layout will be dropped and their element counts will be incorporated\n+     * into that of the returned sequence layout. For instance, given a\n+     * sequence layout of the kind:\n@@ -132,2 +143,3 @@\n-     * @return a sequence layout with the same size as this layout (but, possibly, with different\n-     * element count), whose element layout is not a sequence layout.\n+     * @return a sequence layout with the same size as this layout\n+     *         (but, possibly, with different element count), whose\n+     *         element layout is not a sequence layout\n@@ -152,1 +164,2 @@\n-     * @throws IllegalArgumentException if {@code byteAlignment < elementLayout().byteAlignment()}\n+     * @throws IllegalArgumentException if\n+     *         {@code byteAlignment < elementLayout().byteAlignment()}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SequenceLayout.java","additions":43,"deletions":30,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -34,1 +34,2 @@\n- * Implementing classes are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ * Implementing classes are immutable, thread-safe and\n+ * <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/StructLayout.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -49,2 +49,3 @@\n- * A symbol lookup is created with respect to a particular library (or libraries). Subsequently, the {@link SymbolLookup#find(String)}\n- * method takes the name of a symbol and returns the address of the symbol in that library.\n+ * A symbol lookup is created with respect to a particular library (or libraries).\n+ * Subsequently, the {@link SymbolLookup#find(String)} method takes the name of a symbol\n+ * and returns the address of the symbol in that library.\n@@ -52,1 +53,2 @@\n- * The address of a symbol is modelled as a zero-length {@linkplain MemorySegment memory segment}. The segment can be used in different ways:\n+ * The address of a symbol is modelled as a zero-length\n+ * {@linkplain MemorySegment memory segment}. The segment can be used in different ways:\n@@ -54,5 +56,10 @@\n- *     <li>It can be passed to a {@link Linker} to create a downcall method handle, which can then be used to call the foreign function at the segment's address.<\/li>\n- *     <li>It can be passed to an existing {@linkplain Linker#downcallHandle(FunctionDescriptor, Linker.Option...) downcall method handle}, as an argument to the underlying foreign function.<\/li>\n- *     <li>It can be {@linkplain MemorySegment#set(AddressLayout, long, MemorySegment) stored} inside another memory segment.<\/li>\n- *     <li>It can be used to access the region of memory backing a global variable (this requires\n- *     {@linkplain MemorySegment#reinterpret(long) resizing} the segment first).<\/li>\n+ *     <li>It can be passed to a {@link Linker} to create a downcall method handle, which\n+ *         can then be used to call the foreign function at the segment's address.<\/li>\n+ *     <li>It can be passed to an existing\n+ *         {@linkplain Linker#downcallHandle(FunctionDescriptor, Linker.Option...) downcall method handle},\n+ *         as an argument to the underlying foreign function.<\/li>\n+ *     <li>It can be {@linkplain MemorySegment#set(AddressLayout, long, MemorySegment) stored}\n+ *         inside another memory segment.<\/li>\n+ *     <li>It can be used to access the region of memory backing a global variable\n+ *         (this requires {@linkplain MemorySegment#reinterpret(long) resizing}\n+ *         the segment first).<\/li>\n@@ -63,6 +70,7 @@\n- * The factory methods {@link #libraryLookup(String, Arena)} and {@link #libraryLookup(Path, Arena)}\n- * create a symbol lookup for a library known to the operating system. The library is specified by either its name or a path.\n- * The library is loaded if not already loaded. The symbol lookup, which is known as a <em>library lookup<\/em>, and its\n- * lifetime is controlled by an {@linkplain Arena arena}. For instance, if the provided arena is a\n- * confined arena, the library associated with the symbol lookup is unloaded when the confined arena\n- * is {@linkplain Arena#close() closed}:\n+ * The factory methods {@link #libraryLookup(String, Arena)} and\n+ * {@link #libraryLookup(Path, Arena)} create a symbol lookup for a library known to\n+ * the operating system. The library is specified by either its name or a path.\n+ * The library is loaded if not already loaded. The symbol lookup, which is known as a\n+ * <em>library lookup<\/em>, and its lifetime is controlled by an {@linkplain Arena arena}.\n+ * For instance, if the provided arena is a confined arena, the library associated with\n+ * the symbol lookup is unloaded when the confined arena is {@linkplain Arena#close() closed}:\n@@ -79,2 +87,3 @@\n- * or {@link System#loadLibrary(String)}, then the library was also associated with a particular class loader. The factory\n- * method {@link #loaderLookup()} creates a symbol lookup for all the libraries associated with the caller's class loader:\n+ * or {@link System#loadLibrary(String)}, then the library was also associated with\n+ * a particular class loader. The factory method {@link #loaderLookup()} creates\n+ * a symbol lookup for all the libraries associated with the caller's class loader:\n@@ -89,3 +98,4 @@\n- * This symbol lookup, which is known as a <em>loader lookup<\/em>, is dynamic with respect to the libraries associated\n- * with the class loader. If other libraries are subsequently loaded through JNI and associated with the class loader,\n- * then the loader lookup will expose their symbols automatically.\n+ * This symbol lookup, which is known as a <em>loader lookup<\/em>, is dynamic with\n+ * respect to the libraries associated with the class loader. If other libraries are\n+ * subsequently loaded through JNI and associated with the class loader, then the loader\n+ * lookup will expose their symbols automatically.\n@@ -93,3 +103,4 @@\n- * Note that a loader lookup only exposes symbols in libraries that were previously loaded through JNI, i.e.,\n- * by {@link System#load(String)} or {@link System#loadLibrary(String)}. A loader lookup does not expose symbols in libraries\n- * that were loaded in the course of creating a library lookup:\n+ * Note that a loader lookup only exposes symbols in libraries that were previously\n+ * loaded through JNI, i.e., by {@link System#load(String)} or {@link System#loadLibrary(String)}.\n+ * A loader lookup does not expose symbols in libraries that were loaded in the course\n+ * of creating a library lookup:\n@@ -102,2 +113,3 @@\n- * Note also that a library lookup for library {@code L} exposes symbols in {@code L} even if {@code L} was previously loaded\n- * through JNI (the association with a class loader is immaterial to the library lookup):\n+ * Note also that a library lookup for library {@code L} exposes symbols in {@code L}\n+ * even if {@code L} was previously loaded through JNI (the association with\n+ * a class loader is immaterial to the library lookup):\n@@ -111,4 +123,5 @@\n- * Finally, each {@link Linker} provides a symbol lookup for libraries that are commonly used on the OS and processor\n- * combination supported by that {@link Linker}. This symbol lookup, which is known as a <em>default lookup<\/em>,\n- * helps clients to quickly find addresses of well-known symbols. For example, a {@link Linker} for Linux\/x64 might choose to\n- * expose symbols in {@code libc} through the default lookup:\n+ * Finally, each {@link Linker} provides a symbol lookup for libraries that are commonly\n+ * used on the OS and processor combination supported by that {@link Linker}. This\n+ * symbol lookup, which is known as a <em>default lookup<\/em>, helps clients to quickly\n+ * find addresses of well-known symbols. For example, a {@link Linker} for Linux\/x64\n+ * might choose to expose symbols in {@code libc} through the default lookup:\n@@ -129,2 +142,4 @@\n-     * @param name the symbol name.\n-     * @return a zero-length memory segment whose address indicates the address of the symbol, if found.\n+     *\n+     * @param name the symbol name\n+     * @return a zero-length memory segment whose address indicates the address of\n+     *         the symbol, if found\n@@ -135,2 +150,3 @@\n-     * {@return a composed symbol lookup that returns result of finding the symbol with this lookup if found,\n-     * otherwise returns the result of finding the symbol with the other lookup}\n+     * {@return a composed symbol lookup that returns result of finding the symbol with\n+     * this lookup if found, otherwise returns the result of finding the symbol with the\n+     * other lookup}\n@@ -138,2 +154,3 @@\n-     * @apiNote This method could be used to chain multiple symbol lookups together, e.g. so that symbols could\n-     * be retrieved, in order, from multiple libraries:\n+     * @apiNote This method could be used to chain multiple symbol lookups together,\n+     *          e.g. so that symbols could be retrieved, in order, from multiple\n+     *          libraries:\n@@ -145,3 +162,4 @@\n-     * The above code creates a symbol lookup that first searches for symbols in the \"foo\" library. If no symbol is found\n-     * in \"foo\" then \"bar\" is searched. Finally, if a symbol is not found in neither \"foo\" nor \"bar\", the {@linkplain\n-     * SymbolLookup#loaderLookup() loader lookup} is used.\n+     * The above code creates a symbol lookup that first searches for symbols in\n+     * the \"foo\" library. If no symbol is found in \"foo\" then \"bar\" is searched.\n+     * Finally, if a symbol is not found in neither \"foo\" nor \"bar\", the\n+     * {@linkplain SymbolLookup#loaderLookup() loader lookup} is used.\n@@ -149,1 +167,2 @@\n-     * @param other the symbol lookup that should be used to look for symbols not found in this lookup.\n+     * @param other the symbol lookup that should be used to look for symbols not found\n+     *              in this lookup\n@@ -157,1 +176,2 @@\n-     * Returns a symbol lookup for symbols in the libraries associated with the caller's class loader.\n+     * Returns a symbol lookup for symbols in the libraries associated with the caller's\n+     * class loader.\n@@ -159,6 +179,8 @@\n-     * A library is associated with a class loader {@code CL} when the library is loaded via an invocation of\n-     * {@link System#load(String)} or {@link System#loadLibrary(String)} from code in a class defined by {@code CL}.\n-     * If that code makes further invocations of {@link System#load(String)} or {@link System#loadLibrary(String)},\n-     * then more libraries are loaded and associated with {@code CL}. The symbol lookup returned by this method is always\n-     * current: it reflects all the libraries associated with the relevant class loader, even if they were loaded after\n-     * this method returned.\n+     * A library is associated with a class loader {@code CL} when the library is loaded\n+     * via an invocation of {@link System#load(String)} or\n+     * {@link System#loadLibrary(String)} from code in a class defined by {@code CL}.\n+     * If that code makes further invocations of {@link System#load(String)} or\n+     * {@link System#loadLibrary(String)} then more libraries are loaded and associated\n+     * with {@code CL}. The symbol lookup returned by this method is always current: it\n+     * reflects all the libraries associated with the relevant class loader, even if they\n+     * were loaded after this method returned.\n@@ -167,5 +189,6 @@\n-     * <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>. The symbol lookup\n-     * returned by this method is associated with an automatic {@linkplain MemorySegment.Scope scope} which keeps the caller's\n-     * class loader reachable. Therefore, libraries associated with the caller's class loader are kept loaded\n-     * (and their symbols available) as long as a loader lookup for that class loader, or any of the segments\n-     * obtained by it, is reachable.\n+     * <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>. The\n+     * symbol lookup returned by this method is associated with an automatic\n+     * {@linkplain MemorySegment.Scope scope} which keeps the caller's class loader\n+     * reachable. Therefore, libraries associated with the caller's class loader are\n+     * kept loaded (and their symbols available) as long as a loader lookup for that\n+     * class loader, or any of the segments obtained by it, is reachable.\n@@ -173,2 +196,3 @@\n-     * In cases where this method is called from a context where there is no caller frame on the stack\n-     * (e.g. when called directly from a JNI attached thread), the caller's class loader defaults to the\n+     * In cases where this method is called from a context where there is no caller\n+     * frame on the stack (e.g. when called directly from a JNI attached thread), the\n+     * caller's class loader defaults to the\n@@ -177,1 +201,2 @@\n-     * @return a symbol lookup for symbols in the libraries associated with the caller's class loader.\n+     * @return a symbol lookup for symbols in the libraries associated with\n+     *         the caller's class loader\n@@ -209,5 +234,5 @@\n-     * Loads a library with the given name (if not already loaded) and creates a symbol lookup for symbols in that library.\n-     * The lifetime of the returned library lookup is controlled by the provided arena.\n-     * For instance, if the provided arena is a confined arena, the library\n-     * associated with the returned lookup will be unloaded when the provided confined arena is\n-     * {@linkplain Arena#close() closed}.\n+     * Loads a library with the given name (if not already loaded) and creates a symbol\n+     * lookup for symbols in that library. The lifetime of the returned library lookup\n+     * is controlled by the provided arena. For instance, if the provided arena is a\n+     * confined arena, the library associated with the returned lookup will be unloaded\n+     * when the provided confined arena is {@linkplain Arena#close() closed}.\n@@ -215,3 +240,5 @@\n-     * @implNote The process of resolving a library name is OS-specific. For instance, in a POSIX-compliant OS,\n-     * the library name is resolved according to the specification of the {@code dlopen} function for that OS.\n-     * In Windows, the library name is resolved according to the specification of the {@code LoadLibrary} function.\n+     * @implNote The process of resolving a library name is OS-specific. For instance,\n+     *           in a POSIX-compliant OS, the library name is resolved according to the\n+     *           specification of the {@code dlopen} function for that OS. In Windows,\n+     *           the library name is resolved according to the specification of the\n+     *           {@code LoadLibrary} function.\n@@ -219,3 +246,4 @@\n-     * @param name the name of the library in which symbols should be looked up.\n-     * @param arena the arena associated with symbols obtained from the returned lookup.\n-     * @return a new symbol lookup suitable to find symbols in a library with the given name.\n+     * @param name the name of the library in which symbols should be looked up\n+     * @param arena the arena associated with symbols obtained from the returned lookup\n+     * @return a new symbol lookup suitable to find symbols in a library with the\n+     *         given name\n@@ -223,2 +251,2 @@\n-     * @throws WrongThreadException if {@code arena} is a confined arena, and this method is called from a\n-     *         thread {@code T}, other than the arena's owner thread\n+     * @throws WrongThreadException if {@code arena} is a confined arena, and this method\n+     *         is called from a thread {@code T}, other than the arena's owner thread\n@@ -226,1 +254,2 @@\n-     * @throws IllegalCallerException If the caller is in a module that does not have native access enabled\n+     * @throws IllegalCallerException If the caller is in a module that does not have\n+     *         native access enabled\n@@ -239,5 +268,9 @@\n-     * Loads a library from the given path (if not already loaded) and creates a symbol lookup for symbols\n-     * in that library. The lifetime of the returned library lookup is controlled by the provided arena.\n-     * For instance, if the provided arena is a confined arena, the library\n-     * associated with the returned lookup will be unloaded when the provided confined arena is\n-     * {@linkplain Arena#close() closed}.\n+     * Loads a library from the given path (if not already loaded) and creates a symbol\n+     * lookup for symbols in that library. The lifetime of the returned library lookup\n+     * is controlled by the provided arena. For instance, if the provided arena is a\n+     * confined arena, the library associated with the returned lookup will be unloaded\n+     * when the provided confined arena is {@linkplain Arena#close() closed}.\n+     *\n+     * @implNote On Linux, the functionalities provided by this factory method and the\n+     *           returned symbol lookup are implemented using the {@code dlopen},\n+     *           {@code dlsym} and {@code dlclose} functions.\n@@ -245,5 +278,4 @@\n-     * @implNote On Linux, the functionalities provided by this factory method and the returned symbol lookup are\n-     * implemented using the {@code dlopen}, {@code dlsym} and {@code dlclose} functions.\n-     * @param path the path of the library in which symbols should be looked up.\n-     * @param arena the arena associated with symbols obtained from the returned lookup.\n-     * @return a new symbol lookup suitable to find symbols in a library with the given path.\n+     * @param path the path of the library in which symbols should be looked up\n+     * @param arena the arena associated with symbols obtained from the returned lookup\n+     * @return a new symbol lookup suitable to find symbols in a library with the given\n+     *         path\n@@ -251,2 +283,2 @@\n-     * @throws WrongThreadException if {@code arena} is a confined arena, and this method is called from a\n-     *         thread {@code T}, other than the arena's owner thread\n+     * @throws WrongThreadException if {@code arena} is a confined arena, and this method\n+     *         is called from a thread {@code T}, other than the arena's owner thread\n@@ -254,1 +286,2 @@\n-     * @throws IllegalCallerException If the caller is in a module that does not have native access enabled\n+     * @throws IllegalCallerException If the caller is in a module that does not have\n+     *         native access enabled\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":113,"deletions":80,"binary":false,"changes":193,"status":"modified"},{"patch":"@@ -34,1 +34,2 @@\n- * Implementing classes are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ * Implementing classes are immutable, thread-safe and\n+ * <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/UnionLayout.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,3 +33,3 @@\n- * A layout that models values of basic data types. Examples of values modelled by a value layout are\n- * <em>integral<\/em> values (either signed or unsigned), <em>floating-point<\/em> values and\n- * <em>address<\/em> values.\n+ * A layout that models values of basic data types. Examples of values modelled by a\n+ * value layout are <em>integral<\/em> values (either signed or unsigned),\n+ * <em>floating-point<\/em> values and <em>address<\/em> values.\n@@ -38,2 +38,3 @@\n- * a {@linkplain ByteOrder byte order}, and a <em>carrier<\/em>, that is, the Java type that should be used when\n- * {@linkplain MemorySegment#get(OfInt, long) accessing} a region of memory using the value layout.\n+ * a {@linkplain ByteOrder byte order}, and a <em>carrier<\/em>, that is, the Java type\n+ * that should be used when {@linkplain MemorySegment#get(OfInt, long) accessing} a\n+ * region of memory using the value layout.\n@@ -41,6 +42,2 @@\n- * This class defines useful value layout constants for Java primitive types and addresses.\n- * @apiNote Some characteristics of the Java layout constants are platform-dependent. For instance, the byte order of\n- * these constants is set to the {@linkplain ByteOrder#nativeOrder() native byte order}, thus making it easy to work\n- * with other APIs, such as arrays and {@link java.nio.ByteBuffer}. Moreover, the alignment constraint of\n- * {@link ValueLayout#JAVA_LONG} and {@link ValueLayout#JAVA_DOUBLE} is set to 8 bytes on 64-bit platforms, but only to\n- * 4 bytes on 32-bit platforms.\n+ * This class defines useful value layout constants for Java primitive types and\n+ * addresses.\n@@ -48,1 +45,10 @@\n- * @implSpec implementing classes and subclasses are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ * @apiNote Some characteristics of the Java layout constants are platform-dependent.\n+ *          For instance, the byte order of these constants is set to the\n+ *          {@linkplain ByteOrder#nativeOrder() native byte order}, thus making it easy\n+ *          to work with other APIs, such as arrays and {@link java.nio.ByteBuffer}.\n+ *          Moreover, the alignment constraint of {@link ValueLayout#JAVA_LONG} and\n+ *          {@link ValueLayout#JAVA_DOUBLE} is set to 8 bytes on 64-bit platforms,\n+ *          but only to 4 bytes on 32-bit platforms.\n+ *\n+ * @implSpec implementing classes and subclasses are immutable, thread-safe and\n+ * <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n@@ -65,1 +71,1 @@\n-     * @param order the desired byte order.\n+     * @param order the desired byte order\n@@ -95,1 +101,2 @@\n-     * {@return a var handle which can be used to access values described by this value layout, in a given memory segment.}\n+     * {@return a var handle which can be used to access values described by this value\n+     *          layout, in a given memory segment}\n@@ -97,4 +104,6 @@\n-     * The returned var handle's {@linkplain VarHandle#varType() var type} is the {@linkplain ValueLayout#carrier() carrier type} of\n-     * this value layout, and the list of coordinate types is {@code (MemorySegment, long)}, where the memory segment coordinate\n-     * corresponds to the memory segment to be accessed, and the {@code long} coordinate corresponds to the byte offset\n-     * into the accessed memory segment at which the access occurs.\n+     * The returned var handle's {@linkplain VarHandle#varType() var type} is the\n+     * {@linkplain ValueLayout#carrier() carrier type} of this value layout, and the\n+     * list of coordinate types is {@code (MemorySegment, long)}, where the\n+     * memory segment coordinate corresponds to the memory segment to be accessed, and\n+     * the {@code long} coordinate corresponds to the byte offset into the accessed\n+     * memory segment at which the access occurs.\n@@ -102,2 +111,2 @@\n-     * The returned var handle checks that accesses are aligned according to this value layout's\n-     * {@linkplain MemoryLayout#byteAlignment() alignment constraint}.\n+     * The returned var handle checks that accesses are aligned according to\n+     * this value layout's {@linkplain MemoryLayout#byteAlignment() alignment constraint}.\n@@ -105,2 +114,3 @@\n-     * @apiNote This method is similar, but more efficient, than calling {@code MemoryLayout#varHandle(PathElement...)}\n-     * with an empty path element array, as it avoids the creation of the var args array.\n+     * @apiNote This method is similar, but more efficient, than calling\n+     *          {@code MemoryLayout#varHandle(PathElement...)} with an empty path\n+     *          element array, as it avoids the creation of the var args array.\n@@ -108,2 +118,3 @@\n-     * @apiNote The returned var handle features certain <a href=\"MemoryLayout.html#access-mode-restrictions\">access mode\n-     * restrictions<\/a> common to all memory access var handles derived from memory layouts.\n+     * @apiNote The returned var handle features certain\n+     *          <a href=\"MemoryLayout.html#access-mode-restrictions\">access mode restrictions<\/a>\n+     *          common to all memory access var handles derived from memory layouts.\n@@ -401,2 +412,3 @@\n-     * An address layout constant whose size is the same as that of a machine address ({@code size_t}),\n-     * byte alignment set to {@code sizeof(size_t)}, byte order set to {@link ByteOrder#nativeOrder()}.\n+     * An address layout constant whose size is the same as that of a\n+     * machine address ({@code size_t}), byte alignment set to {@code sizeof(size_t)},\n+     * byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -457,2 +469,3 @@\n-     * An unaligned address layout constant whose size is the same as that of a machine address ({@code size_t}),\n-     * and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * An unaligned address layout constant whose size is the same as that of a\n+     * machine address ({@code size_t}), and byte order set to\n+     * {@link ByteOrder#nativeOrder()}.\n@@ -463,2 +476,2 @@\n-     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n-     *          performance and portability issues.\n+     * @apiNote Care should be taken when using unaligned value layouts as they may\n+     *          induce performance and portability issues.\n@@ -475,2 +488,2 @@\n-     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n-     *          performance and portability issues.\n+     * @apiNote Care should be taken when using unaligned value layouts as they may\n+     *          induce performance and portability issues.\n@@ -487,2 +500,2 @@\n-     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n-     *          performance and portability issues.\n+     * @apiNote Care should be taken when using unaligned value layouts as they may\n+     *          induce performance and portability issues.\n@@ -499,2 +512,2 @@\n-     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n-     *          performance and portability issues.\n+     * @apiNote Care should be taken when using unaligned value layouts as they may\n+     *          induce performance and portability issues.\n@@ -511,2 +524,2 @@\n-     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n-     *          performance and portability issues.\n+     * @apiNote Care should be taken when using unaligned value layouts as they may\n+     *          induce performance and portability issues.\n@@ -523,2 +536,2 @@\n-     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n-     *          performance and portability issues.\n+     * @apiNote Care should be taken when using unaligned value layouts as they may\n+     *          induce performance and portability issues.\n@@ -535,2 +548,2 @@\n-     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n-     *          performance and portability issues.\n+     * @apiNote Care should be taken when using unaligned value layouts as they may\n+     *          induce performance and portability issues.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":55,"deletions":42,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -32,6 +32,8 @@\n- * The main abstraction introduced to support foreign memory access is {@link java.lang.foreign.MemorySegment}, which\n- * models a contiguous region of memory, residing either inside or outside the Java heap. Memory segments are\n- * typically allocated using an {@link java.lang.foreign.Arena}, which controls the lifetime of the regions of memory\n- * backing the segments it allocates. The contents of a memory segment can be described using a\n- * {@link java.lang.foreign.MemoryLayout memory layout}, which provides basic operations to query sizes, offsets and\n- * alignment constraints. Memory layouts also provide an alternate, more abstract way, to\n+ * The main abstraction introduced to support foreign memory access is\n+ * {@link java.lang.foreign.MemorySegment}, which models a contiguous region of memory,\n+ * residing either inside or outside the Java heap. Memory segments are typically\n+ * allocated using an {@link java.lang.foreign.Arena}, which controls the lifetime of the\n+ * regions of memory backing the segments it allocates. The contents of a memory segment\n+ * can be described using a {@link java.lang.foreign.MemoryLayout memory layout}, which\n+ * provides basic operations to query sizes, offsets and alignment constraints. Memory\n+ * layouts also provide an alternate, more abstract way, to\n@@ -41,3 +43,4 @@\n- *\n- * For example, to allocate an off-heap region of memory big enough to hold 10 values of the primitive type {@code int},\n- * and fill it with values ranging from {@code 0} to {@code 9}, we can use the following code:\n+ * <p>\n+ * For example, to allocate an off-heap region of memory big enough to hold 10 values of\n+ * the primitive type {@code int}, and fill it with values ranging from {@code 0} to\n+ * {@code 9}, we can use the following code:\n@@ -54,7 +57,9 @@\n- * This code creates a <em>native<\/em> memory segment, that is, a memory segment backed by\n- * off-heap memory; the size of the segment is 40 bytes, enough to store 10 values of the primitive type {@code int}.\n- * The native segment is allocated using a {@linkplain java.lang.foreign.Arena#ofConfined() confined arena}.\n- * As such, access to the native segment is restricted to the current thread (the thread that created the arena).\n- * Moreover, when the arena is closed, the native segment is invalidated, and its backing region of memory is\n- * deallocated. Note the use of the <em>try-with-resources<\/em> construct: this idiom ensures that the off-heap region\n- * of memory backing the native segment will be released at the end of the block, according to the semantics described\n+ * This code creates a <em>native<\/em> memory segment, that is, a memory segment backed\n+ * by off-heap memory; the size of the segment is 40 bytes, enough to store 10 values of\n+ * the primitive type {@code int}.   The native segment is allocated using a\n+ * {@linkplain java.lang.foreign.Arena#ofConfined() confined arena}. As such, access to\n+ * the native segment is restricted to the current thread (the thread that created the\n+ * arena). Moreover, when the arena is closed, the native segment is invalidated, and\n+ * its backing region of memory is deallocated. Note the use of the <em>try-with-resources<\/em>\n+ * construct: this idiom ensures that the off-heap region of memory backing the native\n+ * segment will be released at the end of the block, according to the semantics described\n@@ -63,4 +68,6 @@\n- * Memory segments provide strong safety guarantees when it comes to memory access. First, when accessing a memory segment,\n- * the access coordinates are validated (upon access), to make sure that access does not occur at any address which resides\n- * <em>outside<\/em> the boundaries of the memory segment used by the access operation. We call this guarantee <em>spatial safety<\/em>;\n- * in other words, access to memory segments is bounds-checked, in the same way as array access is, as described in\n+ * Memory segments provide strong safety guarantees when it comes to memory access.\n+ * First, when accessing a memory segment, the access coordinates are validated\n+ * (upon access), to make sure that access does not occur at any address which resides\n+ * <em>outside<\/em> the boundaries of the memory segment used by the access operation.\n+ * We call this guarantee <em>spatial safety<\/em>; in other words, access to\n+ * memory segments is bounds-checked, in the same way as array access is, as described in\n@@ -69,3 +76,4 @@\n- * Additionally, to prevent a region of memory from being accessed <em>after<\/em> it has been deallocated\n- * (i.e. <em>use-after-free<\/em>), a segment is also validated (upon access) to make sure that the arena from which it\n- * has been obtained has not been closed. We call this guarantee <em>temporal safety<\/em>.\n+ * Additionally, to prevent a region of memory from being accessed <em>after<\/em> it has\n+ * been deallocated (i.e. <em>use-after-free<\/em>), a segment is also validated\n+ * (upon access) to make sure that the arena from which it has been obtained has not\n+ * been closed. We call this guarantee <em>temporal safety<\/em>.\n@@ -73,2 +81,3 @@\n- * Together, spatial and temporal safety ensure that each memory access operation either succeeds - and accesses a valid\n- * location within the region of memory backing the memory segment - or fails.\n+ * Together, spatial and temporal safety ensure that each memory access operation either\n+ * succeeds - and accesses a valid location within the region of memory backing the\n+ * memory segment - or fails.\n@@ -77,6 +86,9 @@\n- * The key abstractions introduced to support foreign function access are {@link java.lang.foreign.SymbolLookup},\n- * {@link java.lang.foreign.FunctionDescriptor} and {@link java.lang.foreign.Linker}. The first is used to look up symbols\n- * inside libraries; the second is used to model the signature of foreign functions, while the third is used\n- * to link foreign functions as {@link java.lang.invoke.MethodHandle} instances,\n- * so that clients can perform foreign function calls directly in Java, without the need for intermediate layers of C\/C++\n- * code (as is the case with the <a href=\"{@docRoot}\/..\/specs\/jni\/index.html\">Java Native Interface (JNI)<\/a>).\n+ *\n+ * The key abstractions introduced to support foreign function access are\n+ * {@link java.lang.foreign.SymbolLookup}, {@link java.lang.foreign.FunctionDescriptor} and\n+ * {@link java.lang.foreign.Linker}. The first is used to look up symbols inside\n+ * libraries; the second is used to model the signature of foreign functions, while the\n+ * third is used to link foreign functions as {@link java.lang.invoke.MethodHandle}\n+ * instances, so that clients can perform foreign function calls directly in Java,\n+ * without the need for intermediate layers of C\/C++ code (as is the case with the\n+ * <a href=\"{@docRoot}\/..\/specs\/jni\/index.html\">Java Native Interface (JNI)<\/a>).\n@@ -84,2 +96,2 @@\n- * For example, to compute the length of a string using the C standard library function {@code strlen} on a Linux\/x64 platform,\n- * we can use the following code:\n+ * For example, to compute the length of a string using the C standard library function\n+ * {@code strlen} on a Linux\/x64 platform, we can use the following code:\n@@ -101,3 +113,4 @@\n- * Here, we obtain a {@linkplain java.lang.foreign.Linker#nativeLinker() native linker} and we use it\n- * to {@linkplain java.lang.foreign.SymbolLookup#find(java.lang.String) look up} the {@code strlen} function in the\n- * standard C library; a <em>downcall method handle<\/em> targeting said function is subsequently\n+ * Here, we obtain a {@linkplain java.lang.foreign.Linker#nativeLinker() native linker}\n+ * and we use it to {@linkplain java.lang.foreign.SymbolLookup#find(java.lang.String) look up}\n+ * the {@code strlen} function in the standard C library; a <em>downcall method handle<\/em>\n+ * targeting said function is subsequently\n@@ -105,5 +118,8 @@\n- * To complete the linking successfully, we must provide a {@link java.lang.foreign.FunctionDescriptor} instance,\n- * describing the signature of the {@code strlen} function.\n- * From this information, the linker will uniquely determine the sequence of steps which will turn\n- * the method handle invocation (here performed using {@link java.lang.invoke.MethodHandle#invokeExact(java.lang.Object...)})\n- * into a foreign function call, according to the rules specified by the ABI of the underlying platform.\n+ * To complete the linking successfully, we must provide a\n+ * {@link java.lang.foreign.FunctionDescriptor} instance, describing the signature of the\n+ * {@code strlen} function. From this information, the linker will uniquely determine\n+ * the sequence of steps which will turn the method handle invocation (here performed\n+ * using {@link java.lang.invoke.MethodHandle#invokeExact(java.lang.Object...)})\n+ * into a foreign function call, according to the rules specified by the ABI of the\n+ * underlying platform.\n+ * <p>\n@@ -112,2 +128,2 @@\n- * {@linkplain java.lang.foreign.SegmentAllocator#allocateFrom(java.lang.String) converting} Java strings into\n- * zero-terminated, UTF-8 strings, as demonstrated in the above example.\n+ * {@linkplain java.lang.foreign.SegmentAllocator#allocateFrom(java.lang.String) converting}\n+ * Java strings into zero-terminated, UTF-8 strings, as demonstrated in the above example.\n@@ -116,5 +132,8 @@\n- * Some methods in this package are considered <em>restricted<\/em>. Restricted methods are typically used to bind native\n- * foreign data and\/or functions to first-class Java API elements which can then be used directly by clients. For instance\n- * the restricted method {@link java.lang.foreign.MemorySegment#reinterpret(long)}\n- * can be used to create a fresh segment with the same address and temporal bounds,\n- * but with the provided size. This can be useful to resize memory segments obtained when interacting with native functions.\n+ *\n+ * Some methods in this package are considered <em>restricted<\/em>. Restricted methods\n+ * are typically used to bind native foreign data and\/or functions to first-class\n+ * Java API elements which can then be used directly by clients. For instance the\n+ * restricted method {@link java.lang.foreign.MemorySegment#reinterpret(long)} can be\n+ * used to create a fresh segment with the same address and temporal bounds, but with\n+ * the provided size. This can be useful to resize memory segments obtained when\n+ * interacting with native functions.\n@@ -122,6 +141,8 @@\n- * Binding foreign data and\/or functions is generally unsafe and, if done incorrectly, can result in VM crashes,\n- * or memory corruption when the bound Java API element is accessed. For instance, incorrectly resizing a native\n- * memory sgement using {@link java.lang.foreign.MemorySegment#reinterpret(long)} can lead to a JVM crash, or, worse,\n- * lead to silent memory corruption when attempting to access the resized segment. For these reasons, it is crucial for\n- * code that calls a restricted method to never pass arguments that might cause incorrect binding of foreign data and\/or\n- * functions to a Java API.\n+ * Binding foreign data and\/or functions is generally unsafe and, if done incorrectly,\n+ * can result in VM crashes, or memory corruption when the bound Java API element is\n+ * accessed. For instance, incorrectly resizing a native memory segment using\n+ * {@link java.lang.foreign.MemorySegment#reinterpret(long)} can lead to a JVM crash, or,\n+ * worse, lead to silent memory corruption when attempting to access the resized segment.\n+ * For these reasons, it is crucial for code that calls a restricted method to never pass\n+ * arguments that might cause incorrect binding of foreign data and\/or functions to a\n+ * Java API.\n@@ -129,3 +150,5 @@\n- * Given the potential danger of restricted methods, the Java runtime issues a warning on the standard error stream\n- * every time a restricted method is invoked. Such warnings can be disabled by granting access to restricted methods\n- * to selected modules. This can be done either via implementation-specific command line options, or programmatically, e.g. by calling\n+ * Given the potential danger of restricted methods, the Java runtime issues a warning on\n+ * the standard error stream every time a restricted method is invoked. Such warnings\n+ * can be disabled by granting access to restricted methods to selected modules. This\n+ * can be done either via implementation-specific command line options, or\n+ * programmatically, e.g. by calling\n@@ -134,3 +157,4 @@\n- * For every class in this package, unless specified otherwise, any method arguments of reference\n- * type must not be null, and any null argument will elicit a {@code NullPointerException}.  This fact is not individually\n- * documented for methods of this API.\n+ * For every class in this package, unless specified otherwise, any method arguments of\n+ * reference type must not be {@code null}, and any null argument will elicit a\n+ * {@code NullPointerException}. This fact is not individually documented for methods of\n+ * this API.\n@@ -138,2 +162,2 @@\n- * @apiNote Usual memory model guarantees (see {@jls 17.4}) do not apply when accessing native memory segments as\n- * these segments are backed by off-heap regions of memory.\n+ * @apiNote Usual memory model guarantees (see {@jls 17.4}) do not apply when accessing\n+ * native memory segments as these segments are backed by off-heap regions of memory.\n@@ -142,5 +166,7 @@\n- * In the reference implementation, access to restricted methods can be granted to specific modules using the command line option\n- * {@code --enable-native-access=M1,M2, ... Mn}, where {@code M1}, {@code M2}, {@code ... Mn} are module names\n- * (for the unnamed module, the special value {@code ALL-UNNAMED} can be used). If this option is specified, access to\n- * restricted methods is only granted to the modules listed by that option. If this option is not specified,\n- * access to restricted methods is enabled for all modules, but access to restricted methods will result in runtime warnings.\n+ * In the reference implementation, access to restricted methods can be granted to\n+ * specific modules using the command line option {@code --enable-native-access=M1,M2, ... Mn},\n+ * where {@code M1}, {@code M2}, {@code ... Mn} are module names (for the unnamed module,\n+ * the special value {@code ALL-UNNAMED} can be used). If this option is specified,\n+ * access to restricted methods is only granted to the modules listed by that option.\n+ * If this option is not specified, access to restricted methods is enabled for all\n+ * modules, but access to restricted methods will result in runtime warnings.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/package-info.java","additions":93,"deletions":67,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -1071,2 +1071,2 @@\n-     *          If {@code arena} is a confined scoped arena, and this method is called from a\n-     *          thread {@code T}, other than the scoped arena's owner thread.\n+     *          If {@code arena} is a confined scoped arena, and this method is called\n+     *          from a thread {@code T}, other than the scoped arena's owner thread.\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/FileChannel.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}