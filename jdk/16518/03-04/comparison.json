{"files":[{"patch":"@@ -38,2 +38,2 @@\n- * A value layout used to model the address of some region of memory.  The carrier\n- * associated with an address layout is {@code MemorySegment.class}.  The size and\n+ * A value layout used to model the address of some region of memory. The carrier\n+ * associated with an address layout is {@code MemorySegment.class}. The size and\n@@ -45,1 +45,1 @@\n- * region of memory whose layout is {@code T}.  For instance, an address layout with\n+ * region of memory whose layout is {@code T}. For instance, an address layout with\n@@ -47,1 +47,1 @@\n- * region of memory that is 4 bytes long.  Specifying a target layout can be useful in\n+ * region of memory that is 4 bytes long. Specifying a target layout can be useful in\n@@ -95,1 +95,1 @@\n-     * specified layout.  Moreover, if the accessed raw address is not compatible with\n+     * specified layout. Moreover, if the accessed raw address is not compatible with\n@@ -100,1 +100,1 @@\n-     * native memory segments with maximal size (e.g. {@linkplain Long#MAX_VALUE}).  This\n+     * native memory segments with maximal size (e.g. {@linkplain Long#MAX_VALUE}). This\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/AddressLayout.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * All the segments allocated by the arena are associated with the arena scope.  As such,\n+ * All the segments allocated by the arena are associated with the arena scope. As such,\n@@ -43,1 +43,1 @@\n- * threads.  An arena is a {@link SegmentAllocator} and features several allocation\n+ * threads. An arena is a {@link SegmentAllocator} and features several allocation\n@@ -46,4 +46,4 @@\n- * The simplest arena is the {@linkplain Arena#global() global arena}.  The global arena\n- * features an <em>unbounded lifetime<\/em>.  The scope of the global arena is the global\n- * scope.  As such, native segments allocated with the global arena are always accessible\n- * and their backing regions of memory are never deallocated.  Moreover, memory segments\n+ * The simplest arena is the {@linkplain Arena#global() global arena}. The global arena\n+ * features an <em>unbounded lifetime<\/em>. The scope of the global arena is the global\n+ * scope. As such, native segments allocated with the global arena are always accessible\n+ * and their backing regions of memory are never deallocated. Moreover, memory segments\n@@ -60,1 +60,1 @@\n- * by the garbage collector.  The scope of an automatic arena is an automatic scope.  As\n+ * by the garbage collector. The scope of an automatic arena is an automatic scope. As\n@@ -75,4 +75,4 @@\n- * back memory segments.  Two kinds of arenas support this, namely {@linkplain #ofConfined() confined}\n- * and {@linkplain #ofShared() shared} arenas.  They both feature bounded lifetimes that\n- * are managed manually.  For instance, when a confined arena is {@linkplain #close() closed}\n- * successfully, its scope is {@linkplain Scope#isAlive() invalidated}.  As a result, all\n+ * back memory segments. Two kinds of arenas support this, namely {@linkplain #ofConfined() confined}\n+ * and {@linkplain #ofShared() shared} arenas. They both feature bounded lifetimes that\n+ * are managed manually. For instance, when a confined arena is {@linkplain #close() closed}\n+ * successfully, its scope is {@linkplain Scope#isAlive() invalidated}. As a result, all\n@@ -92,1 +92,1 @@\n- * accessed (and closed) by the thread that created the arena.  If access to a memory\n+ * accessed (and closed) by the thread that created the arena. If access to a memory\n@@ -131,1 +131,1 @@\n- * arena cannot be accessed <em>after<\/em> the arena has been closed.  The cost of\n+ * arena cannot be accessed <em>after<\/em> the arena has been closed. The cost of\n@@ -133,1 +133,1 @@\n- * memory segments allocated by the arena.  For instance, if an arena is always created\n+ * memory segments allocated by the arena. For instance, if an arena is always created\n@@ -139,1 +139,1 @@\n- * ensuring correctness is much more complex.  For example, a segment allocated with the\n+ * ensuring correctness is much more complex. For example, a segment allocated with the\n@@ -141,1 +141,1 @@\n- * the arena.  To provide the strong temporal safety guarantee without forcing every\n+ * the arena. To provide the strong temporal safety guarantee without forcing every\n@@ -145,1 +145,1 @@\n- * Confined arenas, support strong thread-confinement guarantees.  Upon creation, they are\n+ * Confined arenas, support strong thread-confinement guarantees. Upon creation, they are\n@@ -147,1 +147,1 @@\n- * operation.  The segments created by a confined arena can only be\n+ * operation. The segments created by a confined arena can only be\n@@ -152,1 +152,1 @@\n- * Shared arenas, on the other hand, have no owner thread.  The segments created by a\n+ * Shared arenas, on the other hand, have no owner thread. The segments created by a\n@@ -154,2 +154,2 @@\n- * any thread.  This might be useful when multiple threads need to access the same memory\n- * segment concurrently (e.g. in the case of parallel processing).  Moreover, a shared\n+ * any thread. This might be useful when multiple threads need to access the same memory\n+ * segment concurrently (e.g. in the case of parallel processing). Moreover, a shared\n@@ -161,1 +161,1 @@\n- * or to have better control over when (and by whom) an arena can be closed.  As an\n+ * or to have better control over when (and by whom) an arena can be closed. As an\n@@ -229,1 +229,1 @@\n-     * Obtains the global arena.  Segments allocated with the global arena can be\n+     * Obtains the global arena. Segments allocated with the global arena can be\n@@ -299,1 +299,1 @@\n-     * can no longer be accessed.  Furthermore, any off-heap region of memory backing the\n+     * can no longer be accessed. Furthermore, any off-heap region of memory backing the\n@@ -303,1 +303,1 @@\n-     *          <em>always<\/em> results in an exception being thrown.  This reflects a\n+     *          <em>always<\/em> results in an exception being thrown. This reflects a\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Arena.java","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n- * A function descriptor models the signature of a foreign function.  A function\n+ * A function descriptor models the signature of a foreign function. A function\n@@ -112,1 +112,1 @@\n-     *          layouts.  As such, it is not necessary to specify how padding layout\n+     *          layouts. As such, it is not necessary to specify how padding layout\n@@ -138,1 +138,1 @@\n-     * layout.  This is useful to model functions that return no values.\n+     * layout. This is useful to model functions that return no values.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/FunctionDescriptor.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * <em>member layouts<\/em>.  There are two ways in which member layouts can be combined:\n+ * <em>member layouts<\/em>. There are two ways in which member layouts can be combined:\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/GroupLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,2 +47,2 @@\n- * Foreign functions typically reside in libraries that can be loaded on-demand.  Each\n- * library conforms to a specific ABI (Application Binary Interface).  An ABI is a set of\n+ * Foreign functions typically reside in libraries that can be loaded on-demand. Each\n+ * library conforms to a specific ABI (Application Binary Interface). An ABI is a set of\n@@ -50,1 +50,1 @@\n- * where the library was built.  For example, a C compiler on Linux\/x64 usually builds\n+ * where the library was built. For example, a C compiler on Linux\/x64 usually builds\n@@ -54,2 +54,2 @@\n- * specific ABI.  For any library which conforms to that ABI, the linker can mediate\n- * between Java code running in the JVM and foreign functions in the library.  In\n+ * specific ABI. For any library which conforms to that ABI, the linker can mediate\n+ * between Java code running in the JVM and foreign functions in the library. In\n@@ -65,3 +65,3 @@\n- * data types used by the ABI.  For example, a linker implementing the C ABI might choose\n- * to provide a canonical layout for the C {@code size_t} type.  On 64-bit platforms,\n- * this canonical layout might be equal to {@link ValueLayout#JAVA_LONG}.  The canonical\n+ * data types used by the ABI. For example, a linker implementing the C ABI might choose\n+ * to provide a canonical layout for the C {@code size_t} type. On 64-bit platforms,\n+ * this canonical layout might be equal to {@link ValueLayout#JAVA_LONG}. The canonical\n@@ -72,3 +72,3 @@\n- * conform to the ABI.  Each linker chooses a set of libraries that are commonly used on\n- * the OS and processor combination associated with the ABI.  For example, a linker for\n- * Linux\/x64 might choose two libraries: {@code libc} and {@code libm}.  The functions in\n+ * conform to the ABI. Each linker chooses a set of libraries that are commonly used on\n+ * the OS and processor combination associated with the ABI. For example, a linker for\n+ * Linux\/x64 might choose two libraries: {@code libc} and {@code libm}. The functions in\n@@ -80,1 +80,1 @@\n- * defined in C libraries (native functions).  Suppose we wish to downcall from Java to\n+ * defined in C libraries (native functions). Suppose we wish to downcall from Java to\n@@ -99,1 +99,1 @@\n- * function.  That address is then passed, along with a <em>platform-dependent description<\/em>\n+ * function. That address is then passed, along with a <em>platform-dependent description<\/em>\n@@ -102,1 +102,1 @@\n- * method.  The obtained downcall method handle is then invoked as follows:\n+ * method. The obtained downcall method handle is then invoked as follows:\n@@ -113,1 +113,1 @@\n- * description of the signature of the C function they wish to link against.  This\n+ * description of the signature of the C function they wish to link against. This\n@@ -118,1 +118,1 @@\n- * {@linkplain ValueLayout value layouts} of a suitable carrier.  The\n+ * {@linkplain ValueLayout value layouts} of a suitable carrier. The\n@@ -122,1 +122,1 @@\n- * Composite types are modelled as {@linkplain GroupLayout group layouts}.  More\n+ * Composite types are modelled as {@linkplain GroupLayout group layouts}. More\n@@ -124,1 +124,1 @@\n- * whereas a C {@code union} type maps to a {@link UnionLayout union layout}.  When\n+ * whereas a C {@code union} type maps to a {@link UnionLayout union layout}. When\n@@ -126,1 +126,1 @@\n- * alignment constraint of the corresponding composite type definition in C.  For\n+ * alignment constraint of the corresponding composite type definition in C. For\n@@ -132,1 +132,1 @@\n- * modelled as {@linkplain AddressLayout address layouts}.  When the spatial bounds of\n+ * modelled as {@linkplain AddressLayout address layouts}. When the spatial bounds of\n@@ -134,1 +134,1 @@\n- * {@linkplain AddressLayout#targetLayout() target layout}.  For instance, a pointer that\n+ * {@linkplain AddressLayout#targetLayout() target layout}. For instance, a pointer that\n@@ -155,1 +155,1 @@\n- * depending on the data model supported by a given ABI.  For instance, the C type\n+ * depending on the data model supported by a given ABI. For instance, the C type\n@@ -163,2 +163,2 @@\n- * types.  Instead, they are modelled using the canonical layouts associated with their\n- * corresponding signed integral types.  For instance, the C type {@code unsigned long}\n+ * types. Instead, they are modelled using the canonical layouts associated with their\n+ * corresponding signed integral types. For instance, the C type {@code unsigned long}\n@@ -245,1 +245,1 @@\n- * All native linker implementations operate on a subset of memory layouts.  More formally,\n+ * All native linker implementations operate on a subset of memory layouts. More formally,\n@@ -286,1 +286,1 @@\n- * (the {@code compar} parameter).  To be able to call the {@code qsort} function from\n+ * (the {@code compar} parameter). To be able to call the {@code qsort} function from\n@@ -302,2 +302,2 @@\n- * to be passed as the last parameter.  That is, we need to create a function pointer out\n- * of an existing method handle.  First, let's write a Java method that can compare two\n+ * to be passed as the last parameter. That is, we need to create a function pointer out\n+ * of an existing method handle. First, let's write a Java method that can compare two\n@@ -325,1 +325,1 @@\n- * First, we create a function descriptor for the function pointer type.  Since we know\n+ * First, we create a function descriptor for the function pointer type. Since we know\n@@ -328,2 +328,2 @@\n- * layout for the address layouts of both parameters.  This will allow the comparator\n- * method to access the contents of the array elements to be compared.  We then\n+ * layout for the address layouts of both parameters. This will allow the comparator\n+ * method to access the contents of the array elements to be compared. We then\n@@ -332,1 +332,1 @@\n- * look up the comparator method handle.  We can now create an upcall stub which points\n+ * look up the comparator method handle. We can now create an upcall stub which points\n@@ -347,1 +347,1 @@\n- * function we obtained from the native linker.  After the invocation, the contents\n+ * function we obtained from the native linker. After the invocation, the contents\n@@ -349,1 +349,1 @@\n- * Java.  We then extract a new Java array from the segment, which contains the sorted\n+ * Java. We then extract a new Java array from the segment, which contains the sorted\n@@ -355,1 +355,1 @@\n- * a region of memory and return a pointer to that region.  Let's consider the following\n+ * a region of memory and return a pointer to that region. Let's consider the following\n@@ -371,1 +371,1 @@\n- * region.  In this section we will show how to interact with these native functions,\n+ * region. In this section we will show how to interact with these native functions,\n@@ -395,1 +395,1 @@\n- * lifetime of the returned pointer.  Consider the following code:\n+ * lifetime of the returned pointer. Consider the following code:\n@@ -402,3 +402,3 @@\n- * <a href=\"MemorySegment.html#wrapping-addresses\">zero<\/a>.  Moreover, the scope of the\n- * returned segment is the global scope.  To provide safe access to the segment, we must,\n- * unsafely, resize the segment to the desired size (100, in this case).  It might also\n+ * <a href=\"MemorySegment.html#wrapping-addresses\">zero<\/a>. Moreover, the scope of the\n+ * returned segment is the global scope. To provide safe access to the segment, we must,\n+ * unsafely, resize the segment to the desired size (100, in this case). It might also\n@@ -407,1 +407,1 @@\n- * as for any other native segment created directly from Java code.  Both of these\n+ * as for any other native segment created directly from Java code. Both of these\n@@ -425,1 +425,1 @@\n- * arena.  The method calls the {@code malloc} downcall method handle, and unsafely\n+ * arena. The method calls the {@code malloc} downcall method handle, and unsafely\n@@ -429,1 +429,1 @@\n- * arena is closed.  Unsurprisingly, the cleanup action passes the segment to the\n+ * arena is closed. Unsurprisingly, the cleanup action passes the segment to the\n@@ -440,1 +440,1 @@\n- * managed by the confined arena.  More specifically, the obtained segment has the\n+ * managed by the confined arena. More specifically, the obtained segment has the\n@@ -448,3 +448,3 @@\n- * arguments.  They are declared with a trailing ellipsis ({@code ...}) at the end of the\n- * formal parameter list, such as: {@code void foo(int x, ...);}.  The arguments passed\n- * in place of the ellipsis are called <em>variadic arguments<\/em>.  Variadic functions\n+ * arguments. They are declared with a trailing ellipsis ({@code ...}) at the end of the\n+ * formal parameter list, such as: {@code void foo(int x, ...);}. The arguments passed\n+ * in place of the ellipsis are called <em>variadic arguments<\/em>. Variadic functions\n@@ -456,1 +456,1 @@\n- * promotion in C.  For instance, the following argument promotions are applied:\n+ * promotion in C. For instance, the following argument promotions are applied:\n@@ -464,2 +464,2 @@\n- * promoted type.  The complete process of default argument promotion is described in the\n- * C specification.  In effect these promotions place limits on the types that can be\n+ * promoted type. The complete process of default argument promotion is described in the\n+ * C specification. In effect these promotions place limits on the types that can be\n@@ -471,1 +471,1 @@\n- * describing the specialized form.  Additionally, the {@link Linker.Option#firstVariadicArg(int)}\n+ * describing the specialized form. Additionally, the {@link Linker.Option#firstVariadicArg(int)}\n@@ -473,1 +473,1 @@\n- * parameter list.  The corresponding argument layout (if any), and all following\n+ * parameter list. The corresponding argument layout (if any), and all following\n@@ -477,1 +477,1 @@\n- * The native linker does not automatically perform default argument promotions.  However,\n+ * The native linker does not automatically perform default argument promotions. However,\n@@ -481,2 +481,2 @@\n- * non-promoted C type.  Since the size of the C {@code int} type is platform-specific,\n- * exactly which layouts will be rejected is platform-specific as well.  As an example:\n+ * non-promoted C type. Since the size of the C {@code int} type is platform-specific,\n+ * exactly which layouts will be rejected is platform-specific as well. As an example:\n@@ -485,1 +485,1 @@\n- * will be rejected by the linker.  The {@link #canonicalLayouts()} method can be used to\n+ * will be rejected by the linker. The {@link #canonicalLayouts()} method can be used to\n@@ -496,1 +496,1 @@\n- * of such arguments is dictated by the format string).  Consider the following\n+ * of such arguments is dictated by the format string). Consider the following\n@@ -505,2 +505,2 @@\n- * call.  This descriptor must include an additional layout for each variadic argument we\n- * intend to provide.  In this case, the specialized signature of the C function is\n+ * call. This descriptor must include an additional layout for each variadic argument we\n+ * intend to provide. In this case, the specialized signature of the C function is\n@@ -510,1 +510,1 @@\n- * descriptor (starting from 0).  In this case, since the first parameter is the format\n+ * descriptor (starting from 0). In this case, since the first parameter is the format\n@@ -534,1 +534,1 @@\n- * Creating a downcall method handle is intrinsically unsafe.  A symbol in a foreign\n+ * Creating a downcall method handle is intrinsically unsafe. A symbol in a foreign\n@@ -536,2 +536,2 @@\n- * types of foreign function parameters).  As a consequence, the linker runtime cannot\n- * validate linkage requests.  When a client interacts with a downcall method handle\n+ * types of foreign function parameters). As a consequence, the linker runtime cannot\n+ * validate linkage requests. When a client interacts with a downcall method handle\n@@ -545,1 +545,1 @@\n- * function through the resulting function pointer.  Moreover, if the method handle\n+ * function through the resulting function pointer. Moreover, if the method handle\n@@ -548,1 +548,1 @@\n- * completes.  This can lead to unspecified behavior, and even JVM crashes, since an\n+ * completes. This can lead to unspecified behavior, and even JVM crashes, since an\n@@ -571,1 +571,1 @@\n-     *           the process where the Java runtime is currently executing.  For example,\n+     *           the process where the Java runtime is currently executing. For example,\n@@ -617,1 +617,1 @@\n-     * of the target foreign function is derived.  Moreover, if the function descriptor's\n+     * of the target foreign function is derived. Moreover, if the function descriptor's\n@@ -641,2 +641,2 @@\n-     * will return a native segment associated with the global scope.  Under normal\n-     * conditions, the size of the returned segment is {@code 0}.  However, if the\n+     * will return a native segment associated with the global scope. Under normal\n+     * conditions, the size of the returned segment is {@code 0}. However, if the\n@@ -649,1 +649,1 @@\n-     * the {@link MemorySegment#NULL} address.  If an argument is a {@link MemorySegment},\n+     * the {@link MemorySegment#NULL} address. If an argument is a {@link MemorySegment},\n@@ -651,1 +651,1 @@\n-     * might attempt to access the contents of the segment.  As such, one of the\n+     * might attempt to access the contents of the segment. As such, one of the\n@@ -654,1 +654,1 @@\n-     * methods may be thrown.  The returned method handle will additionally throw\n+     * methods may be thrown. The returned method handle will additionally throw\n@@ -673,1 +673,1 @@\n-     * function pointer, associated with the given arena.  Calling such a function\n+     * function pointer, associated with the given arena. Calling such a function\n@@ -678,2 +678,2 @@\n-     * and is associated with the provided arena.  As such, the lifetime of the returned\n-     * upcall stub segment is controlled by the provided arena.  For instance, if the\n+     * and is associated with the provided arena. As such, the lifetime of the returned\n+     * upcall stub segment is controlled by the provided arena. For instance, if the\n@@ -685,2 +685,2 @@\n-     * global scope.  Under normal conditions, the size of this segment argument is\n-     * {@code 0}.  However, if the address layout has a\n+     * global scope. Under normal conditions, the size of this segment argument is\n+     * {@code 0}. However, if the address layout has a\n@@ -691,1 +691,1 @@\n-     * handle does throw an exception, the JVM will terminate abruptly.  To avoid this,\n+     * handle does throw an exception, the JVM will terminate abruptly. To avoid this,\n@@ -693,1 +693,1 @@\n-     * catch any unexpected exceptions.  This can be done using the\n+     * catch any unexpected exceptions. This can be done using the\n@@ -725,1 +725,1 @@\n-     * {@link Linker}.  Accordingly, the precise set of symbols exposed by the symbol\n+     * {@link Linker}. Accordingly, the precise set of symbols exposed by the symbol\n@@ -729,1 +729,1 @@\n-     *           exposes a set of symbols that is stable over time.  Clients of\n+     *           exposes a set of symbols that is stable over time. Clients of\n@@ -748,1 +748,1 @@\n-     * {@link Linker}.  Accordingly, the precise set of data type names and canonical\n+     * {@link Linker}. Accordingly, the precise set of data type names and canonical\n@@ -753,1 +753,1 @@\n-     *           exposes a set of symbols that is stable over time.  Clients of\n+     *           exposes a set of symbols that is stable over time. Clients of\n@@ -779,1 +779,1 @@\n-         * conjunction with this linker option.  When the {@code index} is:\n+         * conjunction with this linker option. When the {@code index} is:\n@@ -812,1 +812,1 @@\n-         * handle.  For this purpose, a downcall method handle linked with this option\n+         * handle. For this purpose, a downcall method handle linked with this option\n@@ -814,1 +814,1 @@\n-         * the target address, and optional {@link SegmentAllocator} parameters.  This\n+         * the target address, and optional {@link SegmentAllocator} parameters. This\n@@ -819,1 +819,1 @@\n-         * layout returned by {@linkplain #captureStateLayout}.  This layout is a struct\n+         * layout returned by {@linkplain #captureStateLayout}. This layout is a struct\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":87,"deletions":87,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n- * are primarily present for alignment reasons.  Some common value layout constants, such\n+ * are primarily present for alignment reasons. Some common value layout constants, such\n@@ -52,1 +52,1 @@\n- * defined in the {@link ValueLayout} class.  A special kind of value layout, namely an\n+ * defined in the {@link ValueLayout} class. A special kind of value layout, namely an\n@@ -59,1 +59,1 @@\n- * denotes a heterogeneous aggregation of zero or more member layouts.  Group layouts\n+ * denotes a heterogeneous aggregation of zero or more member layouts. Group layouts\n@@ -64,1 +64,1 @@\n- * Layouts can be optionally associated with a <em>name<\/em>.  A layout name can be\n+ * Layouts can be optionally associated with a <em>name<\/em>. A layout name can be\n@@ -93,1 +93,1 @@\n- *     associated with the value layout.  That is, the constant {@link ValueLayout#JAVA_INT}\n+ *     associated with the value layout. That is, the constant {@link ValueLayout#JAVA_INT}\n@@ -95,1 +95,1 @@\n- *     <li>The size of an address layout is platform-dependent.  That is, the constant\n+ *     <li>The size of an address layout is platform-dependent. That is, the constant\n@@ -129,1 +129,1 @@\n- * other layout.  Layout paths are typically expressed as a sequence of one or more\n+ * other layout. Layout paths are typically expressed as a sequence of one or more\n@@ -159,1 +159,1 @@\n- * layouts at once.  For instance, the open path elements\n+ * layouts at once. For instance, the open path elements\n@@ -161,1 +161,1 @@\n- * select an unspecified element in a sequence layout.  A var handle derived from a\n+ * select an unspecified element in a sequence layout. A var handle derived from a\n@@ -178,1 +178,1 @@\n- * {@linkplain #byteOffsetHandle(PathElement...) offset-computing method handles}.  Each\n+ * {@linkplain #byteOffsetHandle(PathElement...) offset-computing method handles}. Each\n@@ -180,1 +180,1 @@\n- * handle.  This parameter can be used to specify the index of the sequence element whose\n+ * handle. This parameter can be used to specify the index of the sequence element whose\n@@ -193,1 +193,1 @@\n- * handles obtained from memory layouts to follow pointers.  Consider the following layout:\n+ * handles obtained from memory layouts to follow pointers. Consider the following layout:\n@@ -208,1 +208,1 @@\n- * This layout is a struct layout which describe a rectangle.  It contains a single field,\n+ * This layout is a struct layout which describe a rectangle. It contains a single field,\n@@ -211,1 +211,1 @@\n- * struct layouts.  Each struct layout describes a two-dimensional point, and is defined\n+ * struct layouts. Each struct layout describes a two-dimensional point, and is defined\n@@ -236,1 +236,1 @@\n- * <em>initial layout<\/em>.  Each path element in a layout path can be thought of as a\n+ * <em>initial layout<\/em>. Each path element in a layout path can be thought of as a\n@@ -238,1 +238,1 @@\n- * {@code C_i}.  That is, for each path element {@code E1, E2, ... En}, in a layout path\n+ * {@code C_i}. That is, for each path element {@code E1, E2, ... En}, in a layout path\n@@ -245,1 +245,1 @@\n- * corresponding input layouts {@code C_0, C_1, ... C_n-1}.  A path element {@code E} is\n+ * corresponding input layouts {@code C_0, C_1, ... C_n-1}. A path element {@code E} is\n@@ -250,1 +250,1 @@\n- * or {@link PathElement#sequenceElement()}).  Moreover, if {@code E} contains one or\n+ * or {@link PathElement#sequenceElement()}). Moreover, if {@code E} contains one or\n@@ -275,1 +275,1 @@\n- * <i>access mode restrictions<\/i>.  We say that a var handle is <em>aligned<\/em> if its\n+ * <i>access mode restrictions<\/i>. We say that a var handle is <em>aligned<\/em> if its\n@@ -277,1 +277,1 @@\n- * if {@code A >= S}.  An aligned var handle is guaranteed to support the following\n+ * if {@code A >= S}. An aligned var handle is guaranteed to support the following\n@@ -280,1 +280,1 @@\n- * <li>read write access modes for all {@code T}.  On 32-bit platforms, access modes\n+ * <li>read write access modes for all {@code T}. On 32-bit platforms, access modes\n@@ -301,2 +301,2 @@\n- * is incompatible with the access size {@code S}, that is, if {@code A < S}.  An\n- * unaligned var handle only supports the {@code get} and {@code set} access modes.  All\n+ * is incompatible with the access size {@code S}, that is, if {@code A < S}. An\n+ * unaligned var handle only supports the {@code get} and {@code set} access modes. All\n@@ -310,2 +310,2 @@\n- * size is known <em>statically<\/em>.  There are cases, however, where the array size is\n- * only known <em>dynamically<\/em>.  We call such arrays <em>variable-length arrays<\/em>.\n+ * size is known <em>statically<\/em>. There are cases, however, where the array size is\n+ * only known <em>dynamically<\/em>. We call such arrays <em>variable-length arrays<\/em>.\n@@ -335,1 +335,1 @@\n- * respectively).  Now consider the following snippet of C code:\n+ * respectively). Now consider the following snippet of C code:\n@@ -345,2 +345,2 @@\n- * Here, we allocate an array of point ({@code points}).  Crucially, the size of the array\n- * is dynamically bound to the value of the {@code size} variable.  Inside the loop, the\n+ * Here, we allocate an array of point ({@code points}). Crucially, the size of the array\n+ * is dynamically bound to the value of the {@code size} variable. Inside the loop, the\n@@ -361,2 +361,2 @@\n- * necessary access var handles from the sequence layout.  But this approach is\n- * problematic, as the size of the variable-length array is not known.  Instead, a\n+ * necessary access var handles from the sequence layout. But this approach is\n+ * problematic, as the size of the variable-length array is not known. Instead, a\n@@ -379,1 +379,1 @@\n- * {@link #arrayElementVarHandle(PathElement...)} method.  This var handle features two\n+ * {@link #arrayElementVarHandle(PathElement...)} method. This var handle features two\n@@ -386,1 +386,1 @@\n- * of that below).  In cases where the base offset is constant (as in the previous\n+ * of that below). In cases where the base offset is constant (as in the previous\n@@ -388,1 +388,1 @@\n- * expression simpler.  This is achieved using the\n+ * expression simpler. This is achieved using the\n@@ -404,2 +404,2 @@\n- * and an array of points (one for each vertex in the polygon).  The number of vertices\n- * depends on the number of edges in the polygon.  As such, the size of the\n+ * and an array of points (one for each vertex in the polygon). The number of vertices\n+ * depends on the number of edges in the polygon. As such, the size of the\n@@ -423,1 +423,1 @@\n- * The {@code POLYGON} layout contains a sequence layout of size <em>zero<\/em>.  The\n+ * The {@code POLYGON} layout contains a sequence layout of size <em>zero<\/em>. The\n@@ -441,1 +441,1 @@\n- * offset coordinate of the {@code POINT_ARR_X} var handle.  As before, the loop\n+ * offset coordinate of the {@code POINT_ARR_X} var handle. As before, the loop\n@@ -489,1 +489,1 @@\n-     * pointer that correctly points to this layout.  Thus:\n+     * pointer that correctly points to this layout. Thus:\n@@ -557,1 +557,1 @@\n-     *     path.  The order of these parameters corresponds to the order in which the\n+     *     path. The order of these parameters corresponds to the order in which the\n@@ -603,1 +603,1 @@\n-     *     layout path, denoted as {@code I1, I2, ... In}, respectively.  The order of\n+     *     layout path, denoted as {@code I1, I2, ... In}, respectively. The order of\n@@ -621,1 +621,1 @@\n-     *     (this layout), or an {@link IllegalArgumentException} is thrown.  Note\n+     *     (this layout), or an {@link IllegalArgumentException} is thrown. Note\n@@ -626,1 +626,1 @@\n-     *     {@link IndexOutOfBoundsException} is thrown.  This is the case when\n+     *     {@link IndexOutOfBoundsException} is thrown. This is the case when\n@@ -640,1 +640,1 @@\n-     * memory segment.  The segment is associated with the global scope.  Moreover, the\n+     * memory segment. The segment is associated with the global scope. Moreover, the\n@@ -642,1 +642,1 @@\n-     * {@linkplain AddressLayout#targetLayout() target layout}.  More specifically:\n+     * {@linkplain AddressLayout#targetLayout() target layout}. More specifically:\n@@ -658,1 +658,1 @@\n-     * to {@code m} (if any).  Then, the returned var handle is computed as follows:\n+     * to {@code m} (if any). Then, the returned var handle is computed as follows:\n@@ -740,1 +740,1 @@\n-     * the spatial bound of the accessed memory segment.  As such, the var handles\n+     * the spatial bound of the accessed memory segment. As such, the var handles\n@@ -768,1 +768,1 @@\n-     *     layout path.  The order of these parameters corresponds to the order in which\n+     *     layout path. The order of these parameters corresponds to the order in which\n@@ -782,1 +782,1 @@\n-     *     (this layout), or an {@link IllegalArgumentException} is thrown.  Note\n+     *     (this layout), or an {@link IllegalArgumentException} is thrown. Note\n@@ -787,1 +787,1 @@\n-     *     {@link IndexOutOfBoundsException} is thrown.  This is the case when\n+     *     {@link IndexOutOfBoundsException} is thrown. This is the case when\n@@ -854,1 +854,1 @@\n-         *           selected.  In such cases, using {@link #groupElement(long)} might be\n+         *           selected. In such cases, using {@link #groupElement(long)} might be\n@@ -904,1 +904,1 @@\n-         * layout.  The range is expressed as a pair of starting index (inclusive)\n+         * layout. The range is expressed as a pair of starting index (inclusive)\n@@ -908,1 +908,1 @@\n-         * {@code I}.  If {@code C} is the\n+         * {@code I}. If {@code C} is the\n@@ -939,1 +939,1 @@\n-         * {@code I}.  If {@code C} is the sequence element count, it follows that\n+         * {@code I}. If {@code C} is the sequence element count, it follows that\n@@ -964,1 +964,1 @@\n-     * layout.  Two layouts are considered equal if they are of the same kind, have the\n+     * layout. Two layouts are considered equal if they are of the same kind, have the\n@@ -970,1 +970,1 @@\n-     *     {@linkplain ValueLayout#carrier() carrier}.  Additionally, two address\n+     *     {@linkplain ValueLayout#carrier() carrier}. Additionally, two address\n@@ -999,1 +999,1 @@\n-     * returned layout is 1.  As such, regardless of its size, in the absence of an\n+     * returned layout is 1. As such, regardless of its size, in the absence of an\n@@ -1043,1 +1043,1 @@\n-     *          additional {@linkplain PaddingLayout padding layout} elements.  As such,\n+     *          additional {@linkplain PaddingLayout padding layout} elements. As such,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":57,"deletions":57,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n- * factory methods.  These methods return a memory segment backed by the on-heap region\n+ * factory methods. These methods return a memory segment backed by the on-heap region\n@@ -76,1 +76,1 @@\n- * <a href=\"#segment-deref\">access operations<\/a>.  An access operation on a memory\n+ * <a href=\"#segment-deref\">access operations<\/a>. An access operation on a memory\n@@ -83,1 +83,1 @@\n- * {@code long} value.  The nature of a segment's address depends on the kind of the\n+ * {@code long} value. The nature of a segment's address depends on the kind of the\n@@ -87,1 +87,1 @@\n- * within the region of memory which backs the segment.  The region is inside the Java\n+ * within the region of memory which backs the segment. The region is inside the Java\n@@ -97,3 +97,3 @@\n- * Every memory segment has a {@linkplain #byteSize() size}.  The size of a heap segment\n- * is derived from the Java array from which it is obtained.  This size is predictable\n- * across Java runtimes.  The size of a native segment is either passed explicitly\n+ * Every memory segment has a {@linkplain #byteSize() size}. The size of a heap segment\n+ * is derived from the Java array from which it is obtained. This size is predictable\n+ * across Java runtimes. The size of a native segment is either passed explicitly\n@@ -101,1 +101,1 @@\n- * (as in {@link Arena#allocate(MemoryLayout)}).  The size of a memory segment is typically\n+ * (as in {@link Arena#allocate(MemoryLayout)}). The size of a memory segment is typically\n@@ -106,1 +106,1 @@\n- * backs the segment.  That is, a memory segment has <em>spatial bounds<\/em>.\n+ * backs the segment. That is, a memory segment has <em>spatial bounds<\/em>.\n@@ -108,1 +108,1 @@\n- * Every memory segment is associated with a {@linkplain Scope scope}.  This ensures that\n+ * Every memory segment is associated with a {@linkplain Scope scope}. This ensures that\n@@ -111,1 +111,1 @@\n- * the accessed memory segment is no longer {@linkplain Scope#isAlive() alive}).  That is,\n+ * the accessed memory segment is no longer {@linkplain Scope#isAlive() alive}). That is,\n@@ -115,1 +115,1 @@\n- * l thread-confinement checks.  Heap segments can be accessed from any thread.\n+ * l thread-confinement checks. Heap segments can be accessed from any thread.\n@@ -123,1 +123,1 @@\n- * this class (e.g. {@link #get(ValueLayout.OfInt, long)}).  Each access operation takes\n+ * this class (e.g. {@link #get(ValueLayout.OfInt, long)}). Each access operation takes\n@@ -125,1 +125,1 @@\n- * value, and an offset, expressed in bytes.  For instance, to read an {@code int} from\n+ * value, and an offset, expressed in bytes. For instance, to read an {@code int} from\n@@ -139,1 +139,1 @@\n- * Access operations on memory segments are implemented using var handles.  The\n+ * Access operations on memory segments are implemented using var handles. The\n@@ -160,1 +160,1 @@\n- * expression simpler.  This can be used to implement access operations such as\n+ * expression simpler. This can be used to implement access operations such as\n@@ -177,2 +177,2 @@\n- * region of memory as the original.  The address of the sliced segment is derived from\n- * the address of the original segment, by adding an offset (expressed in bytes).  The\n+ * region of memory as the original. The address of the sliced segment is derived from\n+ * the address of the original segment, by adding an offset (expressed in bytes). The\n@@ -180,1 +180,1 @@\n- * offset from the size of the original segment), or provided explicitly.  In other words,\n+ * offset from the size of the original segment), or provided explicitly. In other words,\n@@ -192,1 +192,1 @@\n- * slice that starts at offset 50 of {@code segment}, and is 10 bytes long.  That is, the\n+ * slice that starts at offset 50 of {@code segment}, and is 10 bytes long. That is, the\n@@ -195,1 +195,1 @@\n- * will result in an exception.  The {@linkplain Arena temporal bounds} of the original\n+ * will result in an exception. The {@linkplain Arena temporal bounds} of the original\n@@ -220,1 +220,1 @@\n- * value layout specified to the operation.  An access operation can access only those\n+ * value layout specified to the operation. An access operation can access only those\n@@ -222,1 +222,1 @@\n- * <em>aligned<\/em> according to the layout.  An address in physical memory is\n+ * <em>aligned<\/em> according to the layout. An address in physical memory is\n@@ -224,1 +224,1 @@\n- * layout's alignment constraint.  For example, the address 1000 is aligned according to\n+ * layout's alignment constraint. For example, the address 1000 is aligned according to\n@@ -231,1 +231,1 @@\n- * available at a given physical address.  For instance,\n+ * available at a given physical address. For instance,\n@@ -234,1 +234,1 @@\n- * addresses.  In addition, alignment applies to an access operation whether the segment\n+ * addresses. In addition, alignment applies to an access operation whether the segment\n@@ -239,1 +239,1 @@\n- * obtain the <em>target address<\/em> in physical memory.  The pseudo-function below\n+ * obtain the <em>target address<\/em> in physical memory. The pseudo-function below\n@@ -267,1 +267,1 @@\n- *     under a 2-byte alignment constraint.  Under an 8-byte alignment constraint,\n+ *     under a 2-byte alignment constraint. Under an 8-byte alignment constraint,\n@@ -281,1 +281,1 @@\n- * of the data structure stored in the segment.  For example, if the programmer wishes to\n+ * of the data structure stored in the segment. For example, if the programmer wishes to\n@@ -284,1 +284,1 @@\n- * {@link Arena#allocate(long, long)} or {@link Arena#allocate(MemoryLayout)}.  These\n+ * {@link Arena#allocate(long, long)} or {@link Arena#allocate(MemoryLayout)}. These\n@@ -286,1 +286,1 @@\n- * a starting address that is 8-byte aligned.  Subsequently, the programmer can access the\n+ * a starting address that is 8-byte aligned. Subsequently, the programmer can access the\n@@ -291,1 +291,1 @@\n- * is aligned is more complex.  The address of the segment in physical memory is not\n+ * is aligned is more complex. The address of the segment in physical memory is not\n@@ -293,2 +293,2 @@\n- * garbage collection).  This means that the address cannot be combined with the\n- * specified offset to determine a target address in physical memory.  Since the\n+ * garbage collection). This means that the address cannot be combined with the\n+ * specified offset to determine a target address in physical memory. Since the\n@@ -297,2 +297,2 @@\n- * is aligned.  For example, suppose the programmer chooses an 8-byte alignment\n- * constraint and tries to access offset 16 in a heap segment.  If the heap segment's\n+ * is aligned. For example, suppose the programmer chooses an 8-byte alignment\n+ * constraint and tries to access offset 16 in a heap segment. If the heap segment's\n@@ -301,1 +301,1 @@\n- * address (1020) would not be aligned.  It is undesirable to allow access to target\n+ * address (1020) would not be aligned. It is undesirable to allow access to target\n@@ -308,1 +308,1 @@\n- * {@code double[]}, where alignment is platform-dependent, as explained below).  The\n+ * {@code double[]}, where alignment is platform-dependent, as explained below). The\n@@ -310,1 +310,1 @@\n- * collection.  Access operations rely on this invariant to determine if the specified\n+ * collection. Access operations rely on this invariant to determine if the specified\n@@ -316,1 +316,1 @@\n- *     (e.g. 1006, 1008, 1010, 1012, etc).  A heap segment backed by a {@code short[]}\n+ *     (e.g. 1006, 1008, 1010, 1012, etc). A heap segment backed by a {@code short[]}\n@@ -318,1 +318,1 @@\n- *     constraint.  The segment cannot be accessed at <em>any<\/em> offset under a 4-byte\n+ *     constraint. The segment cannot be accessed at <em>any<\/em> offset under a 4-byte\n@@ -321,1 +321,1 @@\n- *     offset 1 would correspond to physical address 1007.  Similarly, the segment cannot\n+ *     offset 1 would correspond to physical address 1007. Similarly, the segment cannot\n@@ -328,1 +328,1 @@\n- *     aligned addresses (e.g., 1000, 1008, 1016, 1024, etc.).  On 64-bit platforms,\n+ *     aligned addresses (e.g., 1000, 1008, 1016, 1024, etc.). On 64-bit platforms,\n@@ -330,1 +330,1 @@\n- *     0, 8, 16, 24, etc under an 8-byte alignment constraint.  In addition, the segment\n+ *     0, 8, 16, 24, etc under an 8-byte alignment constraint. In addition, the segment\n@@ -332,1 +332,1 @@\n- *     because the target addresses (1000, 1004, 1008, 1012) are 4-byte aligned.  And,\n+ *     because the target addresses (1000, 1004, 1008, 1012) are 4-byte aligned. And,\n@@ -341,1 +341,1 @@\n- *     addresses (1004, 1008, 1012, 1016) are 4-byte aligned.  And, the segment\n+ *     addresses (1004, 1008, 1012, 1016) are 4-byte aligned. And, the segment\n@@ -379,1 +379,1 @@\n- * to the maximum alignment associated with the heap segment.  Attempting to access a\n+ * to the maximum alignment associated with the heap segment. Attempting to access a\n@@ -388,1 +388,1 @@\n- * In such circumstances, clients have two options.  They can use a heap segment backed\n+ * In such circumstances, clients have two options. They can use a heap segment backed\n@@ -390,1 +390,1 @@\n- * alignment.  More specifically, the maximum alignment associated with {@code long[]} is\n+ * alignment. More specifically, the maximum alignment associated with {@code long[]} is\n@@ -392,1 +392,1 @@\n- * value (set to {@code ValueLayout.ADDRESS.byteSize()}).  That is, {@code long[]}) is\n+ * value (set to {@code ValueLayout.ADDRESS.byteSize()}). That is, {@code long[]}) is\n@@ -413,3 +413,3 @@\n- * region.  Modeling the region of memory with a memory segment is challenging because\n- * the Java runtime has no insight into the size of the region.  Only the address of the\n- * start of the region, stored in the pointer, is available.  For example, a C function\n+ * region. Modeling the region of memory with a memory segment is challenging because\n+ * the Java runtime has no insight into the size of the region. Only the address of the\n+ * start of the region, stored in the pointer, is available. For example, a C function\n@@ -418,1 +418,1 @@\n- * the size of the array might be provided in a separate parameter.  The size of the\n+ * the size of the array might be provided in a separate parameter. The size of the\n@@ -420,1 +420,1 @@\n- * use its result.  In addition to having no insight into the size of the region of\n+ * use its result. In addition to having no insight into the size of the region of\n@@ -435,2 +435,2 @@\n- *     <li>The size of the segment is zero.  Any attempt to access these segments will\n- *     fail with {@link IndexOutOfBoundsException}.  This is a crucial safety feature: as\n+ *     <li>The size of the segment is zero. Any attempt to access these segments will\n+ *     fail with {@link IndexOutOfBoundsException}. This is a crucial safety feature: as\n@@ -438,1 +438,1 @@\n- *     access operations involving these segments cannot be validated.  In effect, a\n+ *     access operations involving these segments cannot be validated. In effect, a\n@@ -441,1 +441,1 @@\n- *     <li>The segment is associated with the global scope.  Thus, while zero-length\n+ *     <li>The segment is associated with the global scope. Thus, while zero-length\n@@ -447,1 +447,1 @@\n- * case of a client that wants to read a pointer from some memory segment.  This can\n+ * case of a client that wants to read a pointer from some memory segment. This can\n@@ -450,2 +450,2 @@\n- * (e.g. {@link ValueLayout#ADDRESS}), the layout of the pointer to be read.  For instance\n- * on a 64-bit platform, the size of an address layout is 8 bytes.  The access operation\n+ * (e.g. {@link ValueLayout#ADDRESS}), the layout of the pointer to be read. For instance\n+ * on a 64-bit platform, the size of an address layout is 8 bytes. The access operation\n@@ -453,1 +453,1 @@\n- * (relative to the start of the memory segment) at which the pointer is stored.  The\n+ * (relative to the start of the memory segment) at which the pointer is stored. The\n@@ -459,2 +459,2 @@\n- * out-of-bounds access.  Instead, the client must, <em>unsafely<\/em>, assign new spatial\n- * bounds to the zero-length memory segment.  This can be done via the\n+ * out-of-bounds access. Instead, the client must, <em>unsafely<\/em>, assign new spatial\n+ * bounds to the zero-length memory segment. This can be done via the\n@@ -470,1 +470,1 @@\n- * zero-length memory segment.  This can be done via the\n+ * zero-length memory segment. This can be done via the\n@@ -487,1 +487,1 @@\n- * layout used when reading a pointer.  The target layout is then used to dynamically\n+ * layout used when reading a pointer. The target layout is then used to dynamically\n@@ -532,1 +532,1 @@\n-     * {@code byte[]} object which was used to obtain the segment.  This method returns\n+     * {@code byte[]} object which was used to obtain the segment. This method returns\n@@ -550,1 +550,1 @@\n-     * the size of this segment.  As such, splitting is possible as long as\n+     * the size of this segment. As such, splitting is possible as long as\n@@ -571,1 +571,1 @@\n-     * of the specified layout) in this segment.  Calling this method is equivalent to\n+     * of the specified layout) in this segment. Calling this method is equivalent to\n@@ -605,1 +605,1 @@\n-     * Returns a slice of this memory segment, at the given offset.  The returned\n+     * Returns a slice of this memory segment, at the given offset. The returned\n@@ -668,1 +668,1 @@\n-     * Returns a slice of this memory segment, at the given offset.  The returned\n+     * Returns a slice of this memory segment, at the given offset. The returned\n@@ -705,2 +705,2 @@\n-     * with the provided scope.  As such, the returned segment cannot be accessed after\n-     * the provided arena has been closed.  Moreover, the returned segment can be\n+     * with the provided scope. As such, the returned segment cannot be accessed after\n+     * the provided arena has been closed. Moreover, the returned segment can be\n@@ -715,1 +715,1 @@\n-     * provided scope becomes invalid.  This cleanup action receives a fresh memory\n+     * provided scope becomes invalid. This cleanup action receives a fresh memory\n@@ -722,1 +722,1 @@\n-     * scope, and is accessible from any thread.  The size of the segment accepted by the\n+     * scope, and is accessible from any thread. The size of the segment accepted by the\n@@ -727,1 +727,1 @@\n-     *          backing region of memory is no longer available.  Furthermore,\n+     *          backing region of memory is no longer available. Furthermore,\n@@ -750,2 +750,2 @@\n-     * size and scope.  As such, the returned segment cannot be accessed after the\n-     * provided arena has been closed.  Moreover, if the returned segment can be accessed\n+     * size and scope. As such, the returned segment cannot be accessed after the\n+     * provided arena has been closed. Moreover, if the returned segment can be accessed\n@@ -755,1 +755,1 @@\n-     * of the confinement restrictions associated with this segment.  In other words,\n+     * of the confinement restrictions associated with this segment. In other words,\n@@ -760,1 +760,1 @@\n-     * provided scope becomes invalid.  This cleanup action receives a fresh memory\n+     * provided scope becomes invalid. This cleanup action receives a fresh memory\n@@ -767,1 +767,1 @@\n-     * scope, and is accessible from any thread.  The size of the segment accepted by the\n+     * scope, and is accessible from any thread. The size of the segment accepted by the\n@@ -772,1 +772,1 @@\n-     *          backing region of memory is no longer available.  Furthermore, if the\n+     *          backing region of memory is no longer available. Furthermore, if the\n@@ -838,1 +838,1 @@\n-     * (from {@code S2}) that are backed by the same region of memory.  As such, it is\n+     * (from {@code S2}) that are backed by the same region of memory. As such, it is\n@@ -877,1 +877,1 @@\n-     * Performs a bulk copy from given source segment to this segment.  More specifically,\n+     * Performs a bulk copy from given source segment to this segment. More specifically,\n@@ -938,1 +938,1 @@\n-     * faults or I\/O operations.  A return value of {@code false} does not\n+     * faults or I\/O operations. A return value of {@code false} does not\n@@ -962,1 +962,1 @@\n-     * this contents of this segment is resident in physical memory.  Invoking this\n+     * this contents of this segment is resident in physical memory. Invoking this\n@@ -979,1 +979,1 @@\n-     * are are no longer resident in physical memory.  Accessing this segment's contents\n+     * are are no longer resident in physical memory. Accessing this segment's contents\n@@ -1007,1 +1007,1 @@\n-     * mapped in read-only or private mapping modes.  This method may or may not have an\n+     * mapped in read-only or private mapping modes. This method may or may not have an\n@@ -1023,1 +1023,1 @@\n-     * are linked to the properties of this segment.  More specifically, the resulting\n+     * are linked to the properties of this segment. More specifically, the resulting\n@@ -1031,1 +1031,1 @@\n-     * {@linkplain MemorySegment#byteSize() size}.  For this reason, a byte buffer cannot\n+     * {@linkplain MemorySegment#byteSize() size}. For this reason, a byte buffer cannot\n@@ -1037,1 +1037,1 @@\n-     * The life-cycle of the returned buffer is tied to that of this segment.  That is,\n+     * The life-cycle of the returned buffer is tied to that of this segment. That is,\n@@ -1040,1 +1040,1 @@\n-     * {@link IllegalStateException}.  Similarly, accessing the returned buffer from a\n+     * {@link IllegalStateException}. Similarly, accessing the returned buffer from a\n@@ -1046,1 +1046,1 @@\n-     * unspecified exceptions being thrown.  Examples of such problematic operations are\n+     * unspecified exceptions being thrown. Examples of such problematic operations are\n@@ -1219,1 +1219,1 @@\n-     * sequences with this charset's default replacement string.  The {@link\n+     * sequences with this charset's default replacement string. The {@link\n@@ -1238,1 +1238,1 @@\n-     *             to the provided charset.  For instance, this is 1 for\n+     *             to the provided charset. For instance, this is 1 for\n@@ -1260,1 +1260,1 @@\n-     *               access operation will occur.  The final address of this write\n+     *               access operation will occur. The final address of this write\n@@ -1279,1 +1279,1 @@\n-     * sequences with this charset's default replacement string.  The {@link\n+     * sequences with this charset's default replacement string. The {@link\n@@ -1289,1 +1289,1 @@\n-     *                access operation will occur.  The final address of this write\n+     *                access operation will occur. The final address of this write\n@@ -1299,1 +1299,1 @@\n-     *             to the provided charset.  For instance, this is 1 for\n+     *             to the provided charset. For instance, this is 1 for\n@@ -1313,1 +1313,1 @@\n-     * the given {@link Buffer} instance.  The segment starts relative to the buffer's\n+     * the given {@link Buffer} instance. The segment starts relative to the buffer's\n@@ -1317,1 +1317,1 @@\n-     * is also {@linkplain ByteBuffer#isReadOnly() read-only}.  Moreover, if the buffer\n+     * is also {@linkplain ByteBuffer#isReadOnly() read-only}. Moreover, if the buffer\n@@ -1342,3 +1342,3 @@\n-     * byte array.  The scope of the returned segment is an automatic scope that keeps\n-     * the given array reachable.  The returned segment is always accessible, from any\n-     * thread.  Its {@link #address()} is set to zero.\n+     * byte array. The scope of the returned segment is an automatic scope that keeps\n+     * the given array reachable. The returned segment is always accessible, from any\n+     * thread. Its {@link #address()} is set to zero.\n@@ -1355,3 +1355,3 @@\n-     * char array.  The scope of the returned segment is an automatic scope that keeps\n-     * the given array reachable.  The returned segment is always accessible, from any\n-     * thread.  Its {@link #address()} is set to zero.\n+     * char array. The scope of the returned segment is an automatic scope that keeps\n+     * the given array reachable. The returned segment is always accessible, from any\n+     * thread. Its {@link #address()} is set to zero.\n@@ -1370,1 +1370,1 @@\n-     * thread.  Its {@link #address()} is set to zero.\n+     * thread. Its {@link #address()} is set to zero.\n@@ -1382,2 +1382,2 @@\n-     * the given array reachable.  The returned segment is always accessible, from any\n-     * thread.  Its {@link #address()} is set to zero.\n+     * the given array reachable. The returned segment is always accessible, from any\n+     * thread. Its {@link #address()} is set to zero.\n@@ -1394,3 +1394,3 @@\n-     * float array.  The scope of the returned segment is an automatic scope that keeps\n-     * the given array reachable.  The returned segment is always accessible, from any\n-     * thread.  Its {@link #address()} is set to zero.\n+     * float array. The scope of the returned segment is an automatic scope that keeps\n+     * the given array reachable. The returned segment is always accessible, from any\n+     * thread. Its {@link #address()} is set to zero.\n@@ -1407,2 +1407,2 @@\n-     * long array.  The scope of the returned segment is an automatic scope that keeps\n-     * the given array reachable.  The returned segment is always accessible, from any\n+     * long array. The scope of the returned segment is an automatic scope that keeps\n+     * the given array reachable. The returned segment is always accessible, from any\n@@ -1420,2 +1420,2 @@\n-     * double array.  The scope of the returned segment is an automatic scope that keeps\n-     * the given array reachable.  The returned segment is always accessible, from any\n+     * double array. The scope of the returned segment is an automatic scope that keeps\n+     * the given array reachable. The returned segment is always accessible, from any\n@@ -1456,1 +1456,1 @@\n-     * Performs a bulk copy from source segment to destination segment.  More\n+     * Performs a bulk copy from source segment to destination segment. More\n@@ -1505,1 +1505,1 @@\n-     * Performs a bulk copy from source segment to destination segment.  More\n+     * Performs a bulk copy from source segment to destination segment. More\n@@ -1515,1 +1515,1 @@\n-     * same size {@code S}.  If the byte order of the two element layouts differ, the\n+     * same size {@code S}. If the byte order of the two element layouts differ, the\n@@ -1929,1 +1929,1 @@\n-     * @param index a logical index.  The offset in bytes (relative to this\n+     * @param index a logical index. The offset in bytes (relative to this\n@@ -1951,1 +1951,1 @@\n-     * @param index a logical index.  The offset in bytes (relative to this\n+     * @param index a logical index. The offset in bytes (relative to this\n@@ -1973,1 +1973,1 @@\n-     * @param index a logical index.  The offset in bytes (relative to this\n+     * @param index a logical index. The offset in bytes (relative to this\n@@ -2039,1 +2039,1 @@\n-     * @param index a logical index.  The offset in bytes (relative to this\n+     * @param index a logical index. The offset in bytes (relative to this\n@@ -2130,1 +2130,1 @@\n-     * @param index a logical index.  The offset in bytes (relative to this\n+     * @param index a logical index. The offset in bytes (relative to this\n@@ -2285,3 +2285,3 @@\n-     * given layout size.  The read address is wrapped in a native segment, associated\n-     * with the global scope.  Under normal conditions, the size of the returned segment\n-     * is {@code 0}.  However, if the provided address layout has a\n+     * given layout size. The read address is wrapped in a native segment, associated\n+     * with the global scope. Under normal conditions, the size of the returned segment\n+     * is {@code 0}. However, if the provided address layout has a\n@@ -2338,1 +2338,1 @@\n-     * Compares the specified object with this memory segment for equality.  Returns\n+     * Compares the specified object with this memory segment for equality. Returns\n@@ -2350,1 +2350,1 @@\n-     *     segments should be the same.  This means that the two segments either refer to\n+     *     segments should be the same. This means that the two segments either refer to\n@@ -2355,1 +2355,1 @@\n-     *          the two memory segments.  Clients can compare memory segments structurally\n+     *          the two memory segments. Clients can compare memory segments structurally\n@@ -2358,1 +2358,1 @@\n-     *          two segments.  As such, it is suitable to check whether two segments have\n+     *          two segments. As such, it is suitable to check whether two segments have\n@@ -2387,1 +2387,1 @@\n-     * @param srcLayout the source element layout.  If the byte order associated with the\n+     * @param srcLayout the source element layout. If the byte order associated with the\n@@ -2439,1 +2439,1 @@\n-     * @param dstLayout the destination element layout.  If the byte order associated\n+     * @param dstLayout the destination element layout. If the byte order associated\n@@ -2478,1 +2478,1 @@\n-     * source and the destination segments.  More specifically, the bytes at offset\n+     * source and the destination segments. More specifically, the bytes at offset\n@@ -2486,1 +2486,1 @@\n-     * segments.  If one segment is a proper prefix of the other, over the specified\n+     * segments. If one segment is a proper prefix of the other, over the specified\n@@ -2488,1 +2488,1 @@\n-     * relative offset is only valid for the segment with the larger range.  Otherwise,\n+     * relative offset is only valid for the segment with the larger range. Otherwise,\n@@ -2531,1 +2531,1 @@\n-     * {@linkplain #isAlive() alive}.  Scope instances can be compared for equality.\n+     * {@linkplain #isAlive() alive}. Scope instances can be compared for equality.\n@@ -2536,1 +2536,1 @@\n-     * <em>bounded<\/em>.  An unbounded lifetime is modelled with the <em>global scope<\/em>.\n+     * <em>bounded<\/em>. An unbounded lifetime is modelled with the <em>global scope<\/em>.\n@@ -2550,2 +2550,2 @@\n-     * garbage collector.  A segment scope that is invalidated automatically is an\n-     * <em>automatic scope<\/em>.  An automatic scope is always {@link #isAlive() alive}\n+     * garbage collector. A segment scope that is invalidated automatically is an\n+     * <em>automatic scope<\/em>. An automatic scope is always {@link #isAlive() alive}\n@@ -2583,1 +2583,1 @@\n-         * the same lifetime as that modelled by this scope}.  In that case, it is always\n+         * the same lifetime as that modelled by this scope}. In that case, it is always\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":143,"deletions":143,"binary":false,"changes":286,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * A padding layout.  A padding layout specifies the size of extra space which is\n+ * A padding layout. A padding layout specifies the size of extra space which is\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/PaddingLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n- * method.  A segment allocator defines several methods which can be useful to create\n+ * method. A segment allocator defines several methods which can be useful to create\n@@ -63,1 +63,1 @@\n- * (performed by the API) should be stored, as a memory segment.  For instance,\n+ * (performed by the API) should be stored, as a memory segment. For instance,\n@@ -66,1 +66,1 @@\n- * foreign function is known to return a struct by-value.  Effectively, the allocator\n+ * foreign function is known to return a struct by-value. Effectively, the allocator\n@@ -70,1 +70,1 @@\n- *          not thread-safe.  Furthermore, memory segments allocated by a segment\n+ *          not thread-safe. Furthermore, memory segments allocated by a segment\n@@ -72,1 +72,1 @@\n- *          by overlapping regions of memory.  For these reasons, clients should\n+ *          by overlapping regions of memory. For these reasons, clients should\n@@ -107,1 +107,1 @@\n-     * sequences with this charset's default replacement byte array.  The\n+     * sequences with this charset's default replacement byte array. The\n@@ -112,1 +112,1 @@\n-     * copied as well.  This means that, depending on the method used to read\n+     * copied as well. This means that, depending on the method used to read\n@@ -129,1 +129,1 @@\n-     *         provided charset.  For instance, this is 1 for {@link StandardCharsets#US_ASCII}\n+     *         provided charset. For instance, this is 1 for {@link StandardCharsets#US_ASCII}\n@@ -160,1 +160,1 @@\n-     * {@linkplain MemoryLayout#byteSize() size} of the given layout.  The given value is\n+     * {@linkplain MemoryLayout#byteSize() size} of the given layout. The given value is\n@@ -210,1 +210,1 @@\n-     * {@linkplain MemoryLayout#byteSize() size} of the given layout.  The given value is\n+     * {@linkplain MemoryLayout#byteSize() size} of the given layout. The given value is\n@@ -235,1 +235,1 @@\n-     * {@linkplain MemoryLayout#byteSize() size} of the given layout.  The given value is\n+     * {@linkplain MemoryLayout#byteSize() size} of the given layout. The given value is\n@@ -260,1 +260,1 @@\n-     * {@linkplain MemoryLayout#byteSize() size} of the given layout.  The given value is\n+     * {@linkplain MemoryLayout#byteSize() size} of the given layout. The given value is\n@@ -285,1 +285,1 @@\n-     * {@linkplain MemoryLayout#byteSize() size} of the given layout.  The given value is\n+     * {@linkplain MemoryLayout#byteSize() size} of the given layout. The given value is\n@@ -310,1 +310,1 @@\n-     * {@linkplain MemoryLayout#byteSize() size} of the given layout.  The given value is\n+     * {@linkplain MemoryLayout#byteSize() size} of the given layout. The given value is\n@@ -339,1 +339,1 @@\n-     * {@linkplain MemoryLayout#byteSize() size} of the given layout.  The given value is\n+     * {@linkplain MemoryLayout#byteSize() size} of the given layout. The given value is\n@@ -367,1 +367,1 @@\n-     * {@code elementLayout.byteSize() * elementCount}.  The contents of the\n+     * {@code elementLayout.byteSize() * elementCount}. The contents of the\n@@ -412,1 +412,1 @@\n-     * {@code elementLayout.byteSize() * elements.length}.  The contents of the\n+     * {@code elementLayout.byteSize() * elements.length}. The contents of the\n@@ -439,1 +439,1 @@\n-     * {@code elementLayout.byteSize() * elements.length}.  The contents of the\n+     * {@code elementLayout.byteSize() * elements.length}. The contents of the\n@@ -466,1 +466,1 @@\n-     * {@code elementLayout.byteSize() * elements.length}.  The contents of the\n+     * {@code elementLayout.byteSize() * elements.length}. The contents of the\n@@ -493,1 +493,1 @@\n-     * {@code elementLayout.byteSize() * elements.length}.  The contents of the\n+     * {@code elementLayout.byteSize() * elements.length}. The contents of the\n@@ -520,1 +520,1 @@\n-     * {@code elementLayout.byteSize() * elements.length}.  The contents of\n+     * {@code elementLayout.byteSize() * elements.length}. The contents of\n@@ -547,1 +547,1 @@\n-     * {@code elementLayout.byteSize() * elements.length}.  The contents of\n+     * {@code elementLayout.byteSize() * elements.length}. The contents of\n@@ -574,1 +574,1 @@\n-     * {@code elementLayout.byteSize() * elements.length}.  The contents of\n+     * {@code elementLayout.byteSize() * elements.length}. The contents of\n@@ -658,1 +658,1 @@\n-     * consecutive slices obtained from the provided segment.  Each new allocation\n+     * consecutive slices obtained from the provided segment. Each new allocation\n@@ -677,1 +677,1 @@\n-     * single segment.  Each new allocation request will return a new slice starting at\n+     * single segment. Each new allocation request will return a new slice starting at\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n- * <em>element layout<\/em>.  The repetition count is said to be the sequence layout's\n- * <em>element count<\/em>.  A sequence layout can be thought of as a struct layout where\n+ * <em>element layout<\/em>. The repetition count is said to be the sequence layout's\n+ * <em>element count<\/em>. A sequence layout can be thought of as a struct layout where\n@@ -35,1 +35,1 @@\n- * the sequence layout's element count.  In other words this layout:\n+ * the sequence layout's element count. In other words this layout:\n@@ -81,1 +81,1 @@\n-     * layout.  The resulting layout is a sequence layout where element layouts in the\n+     * layout. The resulting layout is a sequence layout where element layouts in the\n@@ -84,1 +84,1 @@\n-     * element counts.  This transformation preserves the layout size;\n+     * element counts. This transformation preserves the layout size;\n@@ -120,1 +120,1 @@\n-     * Returns a flattened sequence layout.  The element layout of the returned\n+     * Returns a flattened sequence layout. The element layout of the returned\n@@ -134,1 +134,1 @@\n-     * into that of the returned sequence layout.  For instance, given a\n+     * into that of the returned sequence layout. For instance, given a\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SequenceLayout.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n- * {@linkplain MemorySegment memory segment}.  The segment can be used in different ways:\n+ * {@linkplain MemorySegment memory segment}. The segment can be used in different ways:\n@@ -72,2 +72,2 @@\n- * the operating system.  The library is specified by either its name or a path.\n- * The library is loaded if not already loaded.  The symbol lookup, which is known as a\n+ * the operating system. The library is specified by either its name or a path.\n+ * The library is loaded if not already loaded. The symbol lookup, which is known as a\n@@ -88,1 +88,1 @@\n- * a particular class loader.  The factory method {@link #loaderLookup()} creates\n+ * a particular class loader. The factory method {@link #loaderLookup()} creates\n@@ -99,1 +99,1 @@\n- * respect to the libraries associated with the class loader.  If other libraries are\n+ * respect to the libraries associated with the class loader. If other libraries are\n@@ -124,1 +124,1 @@\n- * used on the OS and processor combination supported by that {@link Linker}.  This\n+ * used on the OS and processor combination supported by that {@link Linker}. This\n@@ -126,1 +126,1 @@\n- * find addresses of well-known symbols.  For example, a {@link Linker} for Linux\/x64\n+ * find addresses of well-known symbols. For example, a {@link Linker} for Linux\/x64\n@@ -162,1 +162,1 @@\n-     * the \"foo\" library.  If no symbol is found in \"foo\" then \"bar\" is searched.\n+     * the \"foo\" library. If no symbol is found in \"foo\" then \"bar\" is searched.\n@@ -183,1 +183,1 @@\n-     * with {@code CL}.  The symbol lookup returned by this method is always current: it\n+     * with {@code CL}. The symbol lookup returned by this method is always current: it\n@@ -188,1 +188,1 @@\n-     * <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.  The\n+     * <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>. The\n@@ -191,1 +191,1 @@\n-     * reachable.  Therefore, libraries associated with the caller's class loader are\n+     * reachable. Therefore, libraries associated with the caller's class loader are\n@@ -234,2 +234,2 @@\n-     * lookup for symbols in that library.  The lifetime of the returned library lookup\n-     * is controlled by the provided arena.  For instance, if the provided arena is a\n+     * lookup for symbols in that library. The lifetime of the returned library lookup\n+     * is controlled by the provided arena. For instance, if the provided arena is a\n@@ -239,1 +239,1 @@\n-     * @implNote The process of resolving a library name is OS-specific.  For instance,\n+     * @implNote The process of resolving a library name is OS-specific. For instance,\n@@ -241,1 +241,1 @@\n-     *           specification of the {@code dlopen} function for that OS.  In Windows,\n+     *           specification of the {@code dlopen} function for that OS. In Windows,\n@@ -268,2 +268,2 @@\n-     * lookup for symbols in that library.  The lifetime of the returned library lookup\n-     * is controlled by the provided arena.  For instance, if the provided arena is a\n+     * lookup for symbols in that library. The lifetime of the returned library lookup\n+     * is controlled by the provided arena. For instance, if the provided arena is a\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * A layout that models values of basic data types.  Examples of values modelled by a\n+ * A layout that models values of basic data types. Examples of values modelled by a\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * residing either inside or outside the Java heap.  Memory segments are typically\n+ * residing either inside or outside the Java heap. Memory segments are typically\n@@ -36,1 +36,1 @@\n- * regions of memory backing the segments it allocates.  The contents of a memory segment\n+ * regions of memory backing the segments it allocates. The contents of a memory segment\n@@ -38,1 +38,1 @@\n- * provides basic operations to query sizes, offsets and alignment constraints.  Memory\n+ * provides basic operations to query sizes, offsets and alignment constraints. Memory\n@@ -60,1 +60,1 @@\n- * {@linkplain java.lang.foreign.Arena#ofConfined() confined arena}.  As such, access to\n+ * {@linkplain java.lang.foreign.Arena#ofConfined() confined arena}. As such, access to\n@@ -62,2 +62,2 @@\n- * arena).  Moreover, when the arena is closed, the native segment is invalidated, and\n- * its backing region of memory is deallocated.  Note the use of the <em>try-with-resources<\/em>\n+ * arena). Moreover, when the arena is closed, the native segment is invalidated, and\n+ * its backing region of memory is deallocated. Note the use of the <em>try-with-resources<\/em>\n@@ -79,1 +79,1 @@\n- * been closed.  We call this guarantee <em>temporal safety<\/em>.\n+ * been closed. We call this guarantee <em>temporal safety<\/em>.\n@@ -89,1 +89,1 @@\n- * {@link java.lang.foreign.Linker}.  The first is used to look up symbols inside\n+ * {@link java.lang.foreign.Linker}. The first is used to look up symbols inside\n@@ -120,1 +120,1 @@\n- * {@code strlen} function.  From this information, the linker will uniquely determine\n+ * {@code strlen} function. From this information, the linker will uniquely determine\n@@ -133,1 +133,1 @@\n- * Some methods in this package are considered <em>restricted<\/em>.  Restricted methods\n+ * Some methods in this package are considered <em>restricted<\/em>. Restricted methods\n@@ -135,1 +135,1 @@\n- * Java API elements which can then be used directly by clients.  For instance the\n+ * Java API elements which can then be used directly by clients. For instance the\n@@ -138,1 +138,1 @@\n- * the provided size.  This can be useful to resize memory segments obtained when\n+ * the provided size. This can be useful to resize memory segments obtained when\n@@ -143,1 +143,1 @@\n- * accessed.  For instance, incorrectly resizing a native memory segment using\n+ * accessed. For instance, incorrectly resizing a native memory segment using\n@@ -151,2 +151,2 @@\n- * the standard error stream every time a restricted method is invoked.  Such warnings\n- * can be disabled by granting access to restricted methods to selected modules.  This\n+ * the standard error stream every time a restricted method is invoked. Such warnings\n+ * can be disabled by granting access to restricted methods to selected modules. This\n@@ -159,1 +159,1 @@\n- * {@code NullPointerException}.  This fact is not individually documented for methods of\n+ * {@code NullPointerException}. This fact is not individually documented for methods of\n@@ -169,1 +169,1 @@\n- * the special value {@code ALL-UNNAMED} can be used).  If this option is specified,\n+ * the special value {@code ALL-UNNAMED} can be used). If this option is specified,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/package-info.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"}]}