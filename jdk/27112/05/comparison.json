{"files":[{"patch":"@@ -421,0 +421,1 @@\n+  assert(thread->thread_state() == _thread_in_vm, \"thread should be in vm\");\n@@ -1829,0 +1830,6 @@\n+  \/\/ At this point we only have the address of a \"raw result\" and\n+  \/\/ we just call into the interpreter to convert this into a jvalue.\n+  \/\/ This method always makes transition to vm and back where GC can happen.\n+  \/\/ So it is needed to preserve result and then restore it\n+  \/\/ even if events are not actually posted.\n+  \/\/ Saving oop_result into value.j is deferred until jvmti state is ready.\n@@ -1831,8 +1838,0 @@\n-\n-  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n-\n-  if (state == nullptr || !state->is_interp_only_mode()) {\n-    \/\/ for any thread that actually wants method exit, interp_only_mode is set\n-    return;\n-  }\n-\n@@ -1840,0 +1839,1 @@\n+  oop oop_result;\n@@ -1842,12 +1842,5 @@\n-\n-  if (state->is_enabled(JVMTI_EVENT_METHOD_EXIT)) {\n-    \/\/ At this point we only have the address of a \"raw result\" and\n-    \/\/ we just call into the interpreter to convert this into a jvalue.\n-    oop oop_result;\n-    BasicType type = current_frame.interpreter_frame_result(&oop_result, &value);\n-    assert(type == T_VOID || current_frame.interpreter_frame_expression_stack_size() > 0,\n-           \"Stack shouldn't be empty\");\n-    if (is_reference_type(type)) {\n-      result = Handle(thread, oop_result);\n-      value.l = JNIHandles::make_local(thread, result());\n-    }\n+  BasicType type = current_frame.interpreter_frame_result(&oop_result, &value);\n+  assert(mh->is_native() || type == T_VOID || current_frame.interpreter_frame_expression_stack_size() > 0,\n+         \"Stack shouldn't be empty\");\n+  if (is_reference_type(type)) {\n+    result = Handle(thread, oop_result);\n@@ -1855,6 +1848,1 @@\n-\n-  \/\/ Do not allow NotifyFramePop to add new FramePop event request at\n-  \/\/ depth 0 as it is already late in the method exiting dance.\n-  state->set_top_frame_is_exiting();\n-\n-  \/\/ Deferred transition to VM, so we can stash away the return oop before GC.\n+  JvmtiThreadState* state; \/\/ should be initialized in vm state only\n@@ -1863,2 +1851,8 @@\n-    post_method_exit_inner(thread, mh, state, false \/* not exception exit *\/, current_frame, value);\n-  JRT_BLOCK_END\n+    state = get_jvmti_thread_state(thread);\n+    if (state != nullptr && state->is_interp_only_mode()) {\n+      if (state->is_enabled(JVMTI_EVENT_METHOD_EXIT)) {\n+        \/\/ Deferred saving Object result into value.\n+        if (is_reference_type(type)) {\n+          value.l = JNIHandles::make_local(thread, result());\n+        }\n+      }\n@@ -1866,3 +1860,3 @@\n-  \/\/ The JRT_BLOCK_END can safepoint in ThreadInVMfromJava desctructor. Now it is safe to allow\n-  \/\/ adding FramePop event requests as no safepoint can happen before removing activation.\n-  state->clr_top_frame_is_exiting();\n+      \/\/ Do not allow NotifyFramePop to add new FramePop event request at\n+      \/\/ depth 0 as it is already late in the method exiting dance.\n+      state->set_top_frame_is_exiting();\n@@ -1870,0 +1864,8 @@\n+      post_method_exit_inner(thread, mh, state, false \/* not exception exit *\/, current_frame, value);\n+    }\n+  JRT_BLOCK_END\n+  if (state != nullptr && state->is_interp_only_mode()) {\n+    \/\/ The JRT_BLOCK_END can safepoint in ThreadInVMfromJava desctructor. Now it is safe to allow\n+    \/\/ adding FramePop event requests as no safepoint can happen before removing activation.\n+    state->clr_top_frame_is_exiting();\n+  }\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":33,"deletions":31,"binary":false,"changes":64,"status":"modified"}]}