{"files":[{"patch":"@@ -421,0 +421,1 @@\n+  assert(thread->thread_state() == _thread_in_vm, \"thread should be in vm\");\n@@ -1829,0 +1830,6 @@\n+  \/\/ At this point we only have the address of a \"raw result\" and\n+  \/\/ we just call into the interpreter to convert this into a jvalue.\n+  \/\/ The post_method_exit_transition always makes transition to vm and back\n+  \/\/ where GC can happen. So it is needed to preserve result  and then restore it\n+  \/\/ even if events are not actually posted.\n+  \/\/ Saving oop_result into value.j is deferred until jvmti state is ready.\n@@ -1831,8 +1838,0 @@\n-\n-  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n-\n-  if (state == nullptr || !state->is_interp_only_mode()) {\n-    \/\/ for any thread that actually wants method exit, interp_only_mode is set\n-    return;\n-  }\n-\n@@ -1840,0 +1839,1 @@\n+  oop oop_result;\n@@ -1842,12 +1842,5 @@\n-\n-  if (state->is_enabled(JVMTI_EVENT_METHOD_EXIT)) {\n-    \/\/ At this point we only have the address of a \"raw result\" and\n-    \/\/ we just call into the interpreter to convert this into a jvalue.\n-    oop oop_result;\n-    BasicType type = current_frame.interpreter_frame_result(&oop_result, &value);\n-    assert(type == T_VOID || current_frame.interpreter_frame_expression_stack_size() > 0,\n-           \"Stack shouldn't be empty\");\n-    if (is_reference_type(type)) {\n-      result = Handle(thread, oop_result);\n-      value.l = JNIHandles::make_local(thread, result());\n-    }\n+  BasicType type = current_frame.interpreter_frame_result(&oop_result, &value);\n+  assert(type == T_VOID || current_frame.interpreter_frame_expression_stack_size() > 0,\n+          \"Stack shouldn't be empty\");\n+  if (is_reference_type(type)) {\n+    result = Handle(thread, oop_result);\n@@ -1855,0 +1848,5 @@\n+  post_method_exit_transition(thread, mh, type, result, value);\n+  if (result.not_null() && !mh->is_native()) {\n+    *(oop*)current_frame.interpreter_frame_tos_address() = result();\n+  }\n+}\n@@ -1856,5 +1854,3 @@\n-  \/\/ Do not allow NotifyFramePop to add new FramePop event request at\n-  \/\/ depth 0 as it is already late in the method exiting dance.\n-  state->set_top_frame_is_exiting();\n-\n-  \/\/ Deferred transition to VM, so we can stash away the return oop before GC.\n+void JvmtiExport::post_method_exit_transition(JavaThread* thread, methodHandle mh,\n+                                    BasicType type, Handle result, jvalue value) {\n+  JvmtiThreadState* state; \/\/ should be initialized in vm state only\n@@ -1863,1 +1859,18 @@\n-    post_method_exit_inner(thread, mh, state, false \/* not exception exit *\/, current_frame, value);\n+    state = get_jvmti_thread_state(thread);\n+    if (state == nullptr || !state->is_interp_only_mode()) {\n+      \/\/ The transition from vm to java\n+      return;\n+    }\n+\n+    if (state->is_enabled(JVMTI_EVENT_METHOD_EXIT)) {\n+      \/\/ Deferred saving Object result into value.\n+      if (is_reference_type(type)) {\n+       value.l = JNIHandles::make_local(thread, result());\n+      }\n+    }\n+\n+    \/\/ Do not allow NotifyFramePop to add new FramePop event request at\n+    \/\/ depth 0 as it is already late in the method exiting dance.\n+    state->set_top_frame_is_exiting();\n+\n+    post_method_exit_inner(thread, mh, state, false \/* not exception exit *\/, value);\n@@ -1869,5 +1882,0 @@\n-\n-  if (result.not_null() && !mh->is_native()) {\n-    \/\/ We have to restore the oop on the stack for interpreter frames\n-    *(oop*)current_frame.interpreter_frame_tos_address() = result();\n-  }\n@@ -1880,1 +1888,0 @@\n-                                         frame current_frame,\n@@ -2110,1 +2117,1 @@\n-        JvmtiExport::post_method_exit_inner(thread, mh, state, true, thread->last_frame(), no_value);\n+        JvmtiExport::post_method_exit_inner(thread, mh, state, true, no_value);\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":40,"deletions":33,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -213,0 +213,6 @@\n+  static void post_method_exit_transition(JavaThread* thread,\n+                                          methodHandle mh,\n+                                          BasicType type,\n+                                          Handle result,\n+                                          jvalue value);\n+\n@@ -217,1 +223,0 @@\n-                                     frame current_frame,\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"}]}