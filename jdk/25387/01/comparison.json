{"files":[{"patch":"@@ -378,0 +378,12 @@\n+  product(uint, AutoVectorizationOverrideProfitability, 1, DIAGNOSTIC,      \\\n+          \"Override the auto vectorization profitability heuristics.\"       \\\n+          \"0 = Run auto vectorizer, but abort just before applying\"         \\\n+          \"    vectorization, as though it was not profitable.\"             \\\n+          \"1 = Run auto vectorizer with the default profitability\"          \\\n+          \"    heuristics. This is the default, and hopefully\"              \\\n+          \"    delivers the best performance.\"                              \\\n+          \"2 = Run auto vectorizer, and vectorize even if the\"              \\\n+          \"    profitability heuristics predict that vectorization\"         \\\n+          \"    is not profitable.\")                                         \\\n+          range(0, 2)                                                       \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1608,5 +1608,23 @@\n-      \/\/ Length 2 reductions of INT\/LONG do not offer performance benefits\n-      if (((arith_type->basic_type() == T_INT) || (arith_type->basic_type() == T_LONG)) && (size == 2)) {\n-        retValue = false;\n-      } else {\n-        retValue = ReductionNode::implemented(opc, size, arith_type->basic_type());\n+      \/\/ This heuristic predicts 2-element reductions for INT\/LONG, predicting\n+      \/\/ that they are not profitable. This was added in JDK-8078563. The argument\n+      \/\/ was that reductions are not just a single instruction, but multiple, and\n+      \/\/ hence it is not directly clear that they are profitable. If we only have\n+      \/\/ two elements per vector, then the performance gains from non-reduction\n+      \/\/ vectors are at most going from 2 scalar instructions to 1 vector instruction.\n+      \/\/ But a 2-element reduction vector goes from 2 scalar instructions to\n+      \/\/ 3 instructions (1 shuffle and two reduction ops).\n+      \/\/ However, this optimization assumes that these reductions stay in the loop\n+      \/\/ which may not be true any more in most cases after the introduction of:\n+      \/\/ PhaseIdealLoop::move_unordered_reduction_out_of_loop\n+      \/\/ Hence, this heuristic has room for improvement.\n+      bool is_two_element_int_or_long_reduction = (size == 2) &&\n+                                                  (arith_type->basic_type() == T_INT ||\n+                                                   arith_type->basic_type() == T_LONG);\n+      if (is_two_element_int_or_long_reduction && AutoVectorizationOverrideProfitability != 2) {\n+#ifndef PRODUCT\n+        if (is_trace_superword_rejections()) {\n+          tty->print_cr(\"\\nPerformance heuristic: 2-element INT\/LONG reduction not profitable.\");\n+          tty->print_cr(\"  Can override with AutoVectorizationOverrideProfitability=2\");\n+        }\n+#endif\n+        return false;\n@@ -1614,0 +1632,1 @@\n+      retValue = ReductionNode::implemented(opc, size, arith_type->basic_type());\n@@ -1759,3 +1778,23 @@\n-    if ((second_pk == nullptr) || (_num_work_vecs == _num_reductions)) {\n-      \/\/ No parent pack or not enough work\n-      \/\/ to cover reduction expansion overhead\n+    if (second_pk == nullptr) {\n+      \/\/ The second input has to be the vector we wanted to reduce,\n+      \/\/ but it was not packed.\n+      return false;\n+    } else if (_num_work_vecs == _num_reductions && AutoVectorizationOverrideProfitability != 2) {\n+      \/\/ This heuristic predicts that the reduction is not profitable.\n+      \/\/ Reduction vectors can be expensive, because they require multiple\n+      \/\/ operations to fold all the lanes together. Hence, vectorizing the\n+      \/\/ reduction is not profitable on its own. Hence, we need a lot of\n+      \/\/ other \"work vectors\" that deliver performance improvements to\n+      \/\/ balance out the performance loss due to reductions.\n+      \/\/ This heuristic is a bit simplistic, and assumes that the reduction\n+      \/\/ vector stays in the loop. But in some cases, we can move the\n+      \/\/ reduction out of the loop, replacing it with a single vector op.\n+      \/\/ See: PhaseIdealLoop::move_unordered_reduction_out_of_loop\n+      \/\/ Hence, this heuristic has room for improvement.\n+#ifndef PRODUCT\n+        if (is_trace_superword_rejections()) {\n+          tty->print_cr(\"\\nPerformance heuristic: not enough vectors in the loop to make\");\n+          tty->print_cr(\"  reduction profitable.\");\n+          tty->print_cr(\"  Can override with AutoVectorizationOverrideProfitability=2\");\n+        }\n+#endif\n@@ -1917,0 +1956,10 @@\n+\n+  if (AutoVectorizationOverrideProfitability == 0) {\n+#ifndef PRODUCT\n+    if (is_trace_superword_any()) {\n+      tty->print_cr(\"\\nForced bailout of vectorization (AutoVectorizationOverrideProfitability=0).\");\n+    }\n+#endif\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":57,"deletions":8,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8357530\n+ * @summary Test the effect of AutoVectorizationOverrideProfitability.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestAutoVectorizationOverrideProfitability\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.verify.*;\n+import compiler.lib.generators.Generator;\n+import static compiler.lib.generators.Generators.G;\n+\n+public class TestAutoVectorizationOverrideProfitability {\n+    public static final Generator<Integer> GEN_I = G.ints();\n+    public static final Generator<Float>   GEN_F = G.floats();\n+\n+    public static int[] aI = new int[10_000];\n+    public static int[] rI = new int[10_000];\n+    public static float[] aF = new float[10_000];\n+    public static float[] rF = new float[10_000];\n+\n+    static {\n+        G.fill(GEN_I, aI);\n+        G.fill(GEN_F, aF);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Do not vectorize, even if profitable.\n+        TestFramework.runWithFlags(\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:AutoVectorizationOverrideProfitability=0\");\n+\n+        \/\/ Normal run, i.e. with normal heuristic. In some cases this vectorizes, in some not.\n+        \/\/ By default, we have AutoVectorizationOverrideProfitability=1\n+        TestFramework.run();\n+\n+        \/\/ Vectorize even if not profitable.\n+        TestFramework.runWithFlags(\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:AutoVectorizationOverrideProfitability=2\");\n+    }\n+\n+    public static final float GOLD_SIMPLE_FLOAT_REDUCTION = simpleFloatReduction();\n+\n+    @Test\n+    @Warmup(10)\n+    @IR(applyIfCPUFeatureOr = {\"avx\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"= 2\"},\n+        counts = {IRNode.ADD_REDUCTION_VF, \"> 0\"})\n+    @IR(applyIfCPUFeatureOr = {\"avx\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"< 2\"},\n+        counts = {IRNode.ADD_REDUCTION_VF, \"= 0\"})\n+    \/\/ The simple float reduction is not profitable. We need to sequentially\n+    \/\/ add up the values, and so we cannot move the reduction out of the loop.\n+    private static float simpleFloatReduction() {\n+        float sum = 0;\n+        for (int i = 0; i < aF.length; i++) {\n+            sum += aF[i];\n+        }\n+        return sum;\n+    }\n+\n+    @Check(test=\"simpleFloatReduction\")\n+    public static void checkSimpleFloatReduction(float result) {\n+        Verify.checkEQ(GOLD_SIMPLE_FLOAT_REDUCTION, result);\n+    }\n+\n+    static { simpleFloatCopy(); }\n+    public static final float[] GOLD_SIMPLE_FLOAT_COPY = rF.clone();\n+\n+    @Test\n+    @Warmup(10)\n+    @IR(applyIfCPUFeatureOr = {\"avx\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"> 0\"},\n+        counts = {IRNode.LOAD_VECTOR_F, \"> 0\"})\n+    @IR(applyIfCPUFeatureOr = {\"avx\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"= 0\"},\n+        counts = {IRNode.LOAD_VECTOR_F, \"= 0\"})\n+    \/\/ The simple float copy is always profitable.\n+    private static void simpleFloatCopy() {\n+        for (int i = 0; i < aF.length; i++) {\n+            rF[i] = aF[i];\n+        }\n+    }\n+\n+    @Check(test=\"simpleFloatCopy\")\n+    public static void checkSimpleFloatCopy() {\n+        Verify.checkEQ(GOLD_SIMPLE_FLOAT_COPY, rF);\n+    }\n+\n+    public static final int GOLD_SIMPLE_INT_REDUCTION = simpleIntReduction();\n+\n+    @Test\n+    @Warmup(10)\n+    @IR(applyIfCPUFeatureOr = {\"avx\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"= 2\"},\n+        counts = {IRNode.ADD_REDUCTION_VI, \"> 0\", IRNode.ADD_VI, \"> 0\"})\n+    @IR(applyIfCPUFeatureOr = {\"avx\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"< 2\"},\n+        counts = {IRNode.ADD_REDUCTION_VI, \"= 0\", IRNode.ADD_VI, \"= 0\"})\n+    \/\/ Current heuristics say that this simple int reduction is not profitable.\n+    \/\/ But it would actually be profitable, since we are able to move the\n+    \/\/ reduction out of the loop (we can reorder the reduction). When moving\n+    \/\/ the reduction out of the loop, we instead accumulate with a simple\n+    \/\/ ADD_VI inside the loop.\n+    \/\/ See: JDK-8307516 JDK-8345044\n+    private static int simpleIntReduction() {\n+        int sum = 0;\n+        for (int i = 0; i < aI.length; i++) {\n+            sum += aI[i];\n+        }\n+        return sum;\n+    }\n+\n+    @Check(test=\"simpleIntReduction\")\n+    public static void checkSimpleIntReduction(int result) {\n+        Verify.checkEQ(GOLD_SIMPLE_INT_REDUCTION, result);\n+    }\n+\n+    static { simpleIntCopy(); }\n+    public static final int[] GOLD_SIMPLE_INT_COPY = rI.clone();\n+\n+    @Test\n+    @Warmup(10)\n+    @IR(applyIfCPUFeatureOr = {\"avx\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"> 0\"},\n+        counts = {IRNode.LOAD_VECTOR_I, \"> 0\"})\n+    @IR(applyIfCPUFeatureOr = {\"avx\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"= 0\"},\n+        counts = {IRNode.LOAD_VECTOR_I, \"= 0\"})\n+    \/\/ The simple int copy is always profitable.\n+    private static void simpleIntCopy() {\n+        for (int i = 0; i < aI.length; i++) {\n+            rI[i] = aI[i];\n+        }\n+    }\n+\n+    @Check(test=\"simpleIntCopy\")\n+    public static void checkSimpleIntCopy() {\n+        Verify.checkEQ(GOLD_SIMPLE_INT_COPY, rI);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAutoVectorizationOverrideProfitability.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"}]}