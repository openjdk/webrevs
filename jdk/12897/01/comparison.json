{"files":[{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/stackValue.hpp\"\n@@ -73,1 +74,2 @@\n-    assert(_obj_pool->at(i)->as_ObjectValue()->id() != id, \"should not be read twice\");\n+    assert(!_obj_pool->at(i)->is_object() || _obj_pool->at(i)->as_ObjectValue()->id() != id, \"should not be read twice\");\n+    assert(!_obj_pool->at(i)->is_object_merge() || _obj_pool->at(i)->as_ObjectMergeValue()->id() != id, \"should not be read twice\");\n@@ -83,0 +85,15 @@\n+ScopeValue* DebugInfoReadStream::read_object_merge_value() {\n+  int id = read_int();\n+#ifdef ASSERT\n+  assert(_obj_pool != NULL, \"object pool does not exist\");\n+  for (int i = _obj_pool->length() - 1; i >= 0; i--) {\n+    assert(!_obj_pool->at(i)->is_object() || _obj_pool->at(i)->as_ObjectValue()->id() != id, \"should not be read twice\");\n+    assert(!_obj_pool->at(i)->is_object_merge() || _obj_pool->at(i)->as_ObjectMergeValue()->id() != id, \"should not be read twice\");\n+  }\n+#endif\n+  ObjectMergeValue* result = new ObjectMergeValue(id);\n+  _obj_pool->push(result);\n+  result->read_object(this);\n+  return result;\n+}\n+\n@@ -87,3 +104,5 @@\n-    ObjectValue* ov = _obj_pool->at(i)->as_ObjectValue();\n-    if (ov->id() == id) {\n-      return ov;\n+    ScopeValue* sv = _obj_pool->at(i);\n+    if (sv->is_object() && sv->as_ObjectValue()->id() == id) {\n+      return sv->as_ObjectValue();\n+    } else if (sv->is_object_merge() && sv->as_ObjectMergeValue()->id() == id) {\n+      return sv->as_ObjectMergeValue();\n@@ -101,1 +120,2 @@\n-                          AUTO_BOX_OBJECT_CODE = 7, MARKER_CODE = 8 };\n+                          AUTO_BOX_OBJECT_CODE = 7, MARKER_CODE = 8,\n+                          OBJECT_MERGE_CODE = 9 };\n@@ -113,0 +133,1 @@\n+   case OBJECT_MERGE_CODE:    result = stream->read_object_merge_value();                break;\n@@ -179,1 +200,7 @@\n-  st->print(\"%s[%d]\", is_auto_box() ? \"box_obj\" : \"obj\", _id);\n+  st->print(\"%s: ID=%d, is_merge_candidate=%d, skip_field_assignment=%d, N.Fields=%d\",\n+            is_auto_box() ? \"box_obj\" : \"obj\", _id,\n+            _merge_candidate, _skip_field_assignment, _field_values.length());\n+  st->print_cr(\", klass: %s \", java_lang_Class::as_Klass(_klass->as_ConstantOopReadValue()->value()())->external_name());\n+  st->print(\"Fields: \");\n+  print_fields_on(st);\n+  st->cr();\n@@ -194,0 +221,101 @@\n+\n+\/\/ ObjectMergeValue\n+\n+\/\/ Returns the ObjectValue that should be used for the local that this\n+\/\/ ObjectMergeValue represents. ObjectMergeValue represents allocation\n+\/\/ merges in C2. This method will select which path the allocation merge\n+\/\/ took during execution of the Trap that triggered the rematerialization\n+\/\/ of the object.\n+ObjectValue* ObjectMergeValue::select(frame* fr, RegisterMap* reg_map) {\n+  assert(fr != NULL && reg_map != NULL, \"sanity\");\n+\n+  \/\/ If we call select again on the same merge we should return the same result\n+  if (_selected != NULL) {\n+    return _selected;\n+  }\n+\n+  StackValue* sv_selector = StackValue::create_stack_value(fr, reg_map, _selector);\n+  jint selector = sv_selector->get_int();\n+\n+  \/\/ If the selector is '-1' it means that execution followed the path\n+  \/\/ where no scalar replacement happened.\n+  \/\/ Otherwise, it is the index in _possible_objects array that holds\n+  \/\/ the description of the scalar replaced object.\n+  if (selector == -1) {\n+    StackValue* sv_merge_pointer = StackValue::create_stack_value(fr, reg_map, _merge_pointer);\n+    _selected = new ObjectValue(id());\n+\n+    \/\/ Retrieve the pointer to the real object and use it as if we had\n+    \/\/ allocated it during the deoptimization\n+    _selected->set_value(sv_merge_pointer->get_obj()());\n+\n+    \/\/ No need for field assignment as the object wasn't really scalar replaced\n+    _selected->set_skip_field_assignment();\n+\n+    return _selected;\n+  } else {\n+    assert(selector < _possible_objects.length(), \"sanity\");\n+    _selected = (ObjectValue*) _possible_objects.at(selector);\n+\n+    \/\/ Exchange the id of the selected object and the merge object.\n+    \/\/ I.e., the candidate essentially becomes the real deal.\n+    int tmp = _selected->id();\n+    _selected->set_id(id());\n+    _id = tmp;\n+\n+    \/\/ Candidate is not candidate anymore, it's the real object\n+    _selected->set_merge_candidate(false);\n+\n+    \/\/ Returns NULL and that should indicate to the caller that\n+    \/\/ one of the candidate objects, inside this merge, became\n+    \/\/ a real object.\n+    return NULL;\n+  }\n+}\n+\n+void ObjectMergeValue::set_value(oop value) {\n+  _value = Handle(Thread::current(), value);\n+}\n+\n+void ObjectMergeValue::read_object(DebugInfoReadStream* stream) {\n+  _selector = read_from(stream);\n+  _merge_pointer = read_from(stream);\n+  int ncandidates = stream->read_int();\n+  for (int i = 0; i < ncandidates; i++) {\n+    ScopeValue* result = read_from(stream);\n+    assert(result->is_object(), \"Candidate is not an object!\");\n+    ObjectValue* obj = result->as_ObjectValue();\n+    obj->set_merge_candidate(true);\n+    _possible_objects.append(obj);\n+  }\n+}\n+\n+void ObjectMergeValue::write_on(DebugInfoWriteStream* stream) {\n+  if (is_visited()) {\n+    stream->write_int(OBJECT_ID_CODE);\n+    stream->write_int(_id);\n+  } else {\n+    set_visited(true);\n+    stream->write_int(OBJECT_MERGE_CODE);\n+    stream->write_int(_id);\n+    _selector->write_on(stream);\n+    _merge_pointer->write_on(stream);\n+    int ncandidates = _possible_objects.length();\n+    stream->write_int(ncandidates);\n+    for (int i = 0; i < ncandidates; i++) {\n+      _possible_objects.at(i)->as_ObjectValue()->write_on(stream);\n+    }\n+  }\n+}\n+\n+void ObjectMergeValue::print_on(outputStream* st) const {\n+  st->print(\"merge: ID=%d, N.Candidates=%d\", _id, _possible_objects.length());\n+}\n+\n+void ObjectMergeValue::print_candidates_on(outputStream* st) const {\n+  int ncandidates = _possible_objects.length();\n+  for (int i = 0; i < ncandidates; i++) {\n+    _possible_objects.at(i)->as_ObjectValue()->print_on(st);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/code\/debugInfo.cpp","additions":134,"deletions":6,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+class ObjectMergeValue;\n@@ -53,0 +54,1 @@\n+  virtual bool is_object_merge() const { return false; }\n@@ -76,0 +78,5 @@\n+  ObjectMergeValue* as_ObjectMergeValue() {\n+    assert(is_object_merge(), \"must be\");\n+    return (ObjectMergeValue*)this;\n+  }\n+\n@@ -129,0 +136,6 @@\n+  bool                       _merge_candidate;        \/\/ Will be true if this object is just representing\n+                                                      \/\/ a scalar replaced object inside an ObjectMergeValue.\n+\n+  bool                       _skip_field_assignment;  \/\/ Will be true if the _value field of this object\n+                                                      \/\/ actually holds a pointer to a non-scalarized object\n+                                                      \/\/ that was participating in an allocation merge.\n@@ -135,1 +148,3 @@\n-     , _visited(false) {\n+     , _visited(false)\n+     , _merge_candidate(false)\n+     , _skip_field_assignment(false) {\n@@ -144,1 +159,3 @@\n-     , _visited(false) {}\n+     , _visited(false)\n+     , _merge_candidate(false)\n+     , _skip_field_assignment(false) {}\n@@ -147,9 +164,12 @@\n-  bool                        is_object() const         { return true; }\n-  int                         id() const                { return _id; }\n-  ScopeValue*                 klass() const             { return _klass; }\n-  GrowableArray<ScopeValue*>* field_values()            { return &_field_values; }\n-  ScopeValue*                 field_at(int i) const     { return _field_values.at(i); }\n-  int                         field_size()              { return _field_values.length(); }\n-  Handle                      value() const             { return _value; }\n-  bool                        is_visited() const        { return _visited; }\n-\n+  bool                        is_object() const              { return true; }\n+  int                         id() const                     { return _id; }\n+  ScopeValue*                 klass() const                  { return _klass; }\n+  GrowableArray<ScopeValue*>* field_values()                 { return &_field_values; }\n+  ScopeValue*                 field_at(int i) const          { return _field_values.at(i); }\n+  int                         field_size()                   { return _field_values.length(); }\n+  Handle                      value() const                  { return _value; }\n+  bool                        is_visited() const             { return _visited; }\n+  bool                        is_merge_candidate() const     { return _merge_candidate; }\n+  bool                        skip_field_assignment() const  { return _skip_field_assignment; }\n+\n+  void                        set_id(int id)                 { _id = id; }\n@@ -157,1 +177,3 @@\n-  void                        set_visited(bool visited) { _visited = visited; }\n+  void                        set_visited(bool visited)      { _visited = visited; }\n+  void                        set_merge_candidate(bool cnd)  { _merge_candidate = cnd; }\n+  void                        set_skip_field_assignment()    { _skip_field_assignment = true; }\n@@ -168,0 +190,57 @@\n+\/\/ An ObjectMergeValue describes objects that were inputs to a Phi in C2 and at\n+\/\/ least one of them were scalar replaced.\n+\/\/ '_selector' is an integer value that will be '-1' if during the execution of\n+\/\/ the C2 compiled code the path taken was that of the Phi input that was NOT\n+\/\/ scalar replaced. In that case '_merge_pointer' is a pointer to an already\n+\/\/ allocated object. If '_selector' is not '-1' then it should be the index\n+\/\/ of a candidate object in '_possible_objects'. That candidate object is an\n+\/\/ ObjectValue describing an object that was scalar replaced.\n+\n+class ObjectMergeValue: public ScopeValue {\n+protected:\n+  int                        _id;\n+  ScopeValue*                _selector;\n+  ScopeValue*                _merge_pointer;\n+  GrowableArray<ScopeValue*> _possible_objects;\n+  ObjectValue*               _selected;\n+  Handle                     _value;\n+  bool                       _visited;\n+public:\n+  ObjectMergeValue(int id, ScopeValue* merge_pointer, ScopeValue* selector)\n+     : _id(id)\n+     , _selector(selector)\n+     , _merge_pointer(merge_pointer)\n+     , _selected(NULL)\n+     , _value()\n+     , _visited(false) {}\n+\n+  ObjectMergeValue(int id)\n+     : _id(id)\n+     , _selector(NULL)\n+     , _merge_pointer(NULL)\n+     , _selected(NULL)\n+     , _value()\n+     , _visited(false) {}\n+\n+  bool                        is_object_merge() const         { return true; }\n+  int                         id() const                      { return _id; }\n+  ScopeValue*                 selector() const                { return _selector; }\n+  ScopeValue*                 merge_pointer() const           { return _merge_pointer; }\n+  GrowableArray<ScopeValue*>* possible_objects()              { return &_possible_objects; }\n+  Handle                      value() const                   { return _value; }\n+  bool                        is_visited() const              { return _visited; }\n+  ObjectValue*                select(frame* fr, RegisterMap* reg_map) ;\n+  ObjectValue*                selected()                      { assert(_selected != NULL, \"not yet.\"); return _selected; };\n+\n+  void                        set_value(oop value);\n+  void                        set_visited(bool visited)       { _visited = visited; }\n+\n+  \/\/ Serialization of debugging information\n+  void read_object(DebugInfoReadStream* stream);\n+  void write_on(DebugInfoWriteStream* stream);\n+\n+  \/\/ Printing\n+  void print_on(outputStream* st) const;\n+  void print_candidates_on(outputStream* st) const;\n+};\n+\n@@ -319,0 +398,1 @@\n+  ScopeValue* read_object_merge_value();\n","filename":"src\/hotspot\/share\/code\/debugInfo.hpp","additions":92,"deletions":12,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -357,1 +357,12 @@\n-      objects->at(i)->as_ObjectValue()->set_visited(false);\n+      ScopeValue* sv = objects->at(i);\n+      if (sv->is_object()) {\n+        sv->as_ObjectValue()->set_visited(false);\n+      } else if (sv->is_object_merge()) {\n+        ObjectMergeValue* obj = sv->as_ObjectMergeValue();\n+        obj->set_visited(false);\n+        for (int j = 0; j < obj->possible_objects()->length(); j++) {\n+          obj->possible_objects()->at(j)->as_ObjectValue()->set_visited(false);\n+        }\n+      } else {\n+        assert(false, \"Unknown object type in object pool.\");\n+      }\n","filename":"src\/hotspot\/share\/code\/debugInfoRec.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -117,1 +117,0 @@\n-  assert(result->length() == length, \"inconsistent debug information\");\n@@ -240,5 +239,8 @@\n-      ObjectValue* sv = (ObjectValue*) _objects->at(i);\n-      st->print(\"    - %d: \", sv->id());\n-      st->print(\"%s \", java_lang_Class::as_Klass(sv->klass()->as_ConstantOopReadValue()->value()())->external_name());\n-      sv->print_fields_on(st);\n-      st->cr();\n+      ScopeValue* sv = (ScopeValue*) _objects->at(i);\n+      if (sv->is_object()) {\n+        sv->as_ObjectValue()->print_on(st);\n+      } else if (sv->is_object_merge()) {\n+        sv->as_ObjectMergeValue()->print_on(st);\n+      } else {\n+        st->print_cr(\"Unknown Object Type in Object Pool\");\n+      }\n","filename":"src\/hotspot\/share\/code\/scopeDesc.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -478,0 +478,6 @@\n+  product(bool, ReduceAllocationMerges, true,                               \\\n+          \"Try to simplify allocation merges before Scalar Replacement\")    \\\n+                                                                            \\\n+  develop(bool, TraceReduceAllocationMerges, false,                         \\\n+          \"Trace decision for simplifying allocation merges.\")              \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1106,0 +1106,6 @@\n+\/\/----------------------------is_uncommon_trap----------------------------\n+\/\/ Returns true if this is an uncommon trap.\n+bool CallStaticJavaNode::is_uncommon_trap() const {\n+  return (_name != NULL && !strcmp(_name, \"uncommon_trap\"));\n+}\n+\n@@ -1109,4 +1115,1 @@\n-  if (_name != nullptr && !strcmp(_name, \"uncommon_trap\")) {\n-    return extract_uncommon_trap_request(this);\n-  }\n-  return 0;\n+  return is_uncommon_trap() ? extract_uncommon_trap_request(this) : 0;\n@@ -1468,1 +1471,3 @@\n-                                                     uint n_fields) :\n+                                                     uint n_fields,\n+                                                     int merge_pointer_idx,\n+                                                     uint number_of_objects) :\n@@ -1471,1 +1476,1 @@\n-  _n_fields(n_fields)\n+  _n_fields(n_fields),\n@@ -1473,1 +1478,1 @@\n-  , _alloc(alloc)\n+  _alloc(alloc),\n@@ -1475,0 +1480,2 @@\n+  _merge_pointer_idx(merge_pointer_idx),\n+  _number_of_objects(number_of_objects)\n@@ -1477,2 +1484,2 @@\n-  if (!alloc->is_Allocate()\n-      && !(alloc->Opcode() == Op_VectorBox)) {\n+  if (merge_pointer_idx < 0 && \/\/ not a merge\n+      !alloc->is_Allocate() && !(alloc->Opcode() == Op_VectorBox)) {\n@@ -1524,2 +1531,2 @@\n-  st->print(\" # fields@[%d..%d]\", first_index(),\n-             first_index() + n_fields() - 1);\n+  st->print(\" # fields@[%d..%d], \", first_index(), first_index() + n_fields() - 1);\n+  st->print(\"merge_ptr_idx=%d, number_of_objects=%d\", _merge_pointer_idx, _number_of_objects);\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":18,"deletions":11,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -241,1 +241,1 @@\n-  bool        is_loc(uint i) const { return locoff() <= i && i < stkoff(); }\n+  bool        is_loc(uint i) const { return locoff()<= i && i < stkoff(); }\n@@ -506,2 +506,48 @@\n-\/\/ A SafePointScalarObjectNode represents the state of a scalarized object\n-\/\/ at a safepoint.\n+\/\/ A SafePointScalarObjectNode (aka spobj) represents the state of one or more\n+\/\/ scalarized objects at a SafePointNode. There are two scenarios where a\n+\/\/ 'spobj' is created: 1) A scalar replaced (SR) object is directly referenced\n+\/\/ by a SafePoint; 2) A scalar replaced object is participating in an allocation\n+\/\/ merge (Phi) and the Phi is referenced by a SafePoint. The schematics of how\n+\/\/ 'spobj' is used in both scenarios are described below.\n+\/\/\n+\/\/ Scenario 1: Representing an object directly referenced by a SafePoint.\n+\/\/   Only the _first_index, _n_fields and _alloc fields are required.\n+\/\/   _first_index : relative index in the SafePoint node's input array where pointers\n+\/\/                  to the values of the fields of the SR object are going to be stored.\n+\/\/   _nfields     : how many fields the SR object has.\n+\/\/   _alloc       : pointer to the Allocate object that previously created the SR object.\n+\/\/                  Only used for debug purposes.\n+\/\/\n+\/\/ Scenario 2: Representing SR objects participating in merges.\n+\/\/  Only the _merge_pointer_idx and _number_of_objects fields are required.\n+\/\/  _number_of_objects : how many objects participating in the merge were SR\n+\/\/                       and are represented in this 'sobj'.\n+\/\/  _merge_pointer_idx : relative index in the SafePoint node's input array\n+\/\/                       where the description of the SR _allocation merge_\n+\/\/                       starts. The two entries in the SafePoint node's input\n+\/\/                       array starting at '_merge_pointer_idx` are Phi nodes\n+\/\/                       representing: 1) a pointer to any non-SR'ed object\n+\/\/                       participating in the merge, and 2) a \"selector\" Phi\n+\/\/                       identifying the input of the original allocation merge\n+\/\/                       that should be used during execution.\n+\/\/\n+\/\/    SafePoint->in(_merge_pointer_idx + 0) ----> Phi(Region, ccpp, NULL, NULL)\n+\/\/    SafePoint->in(_merge_pointer_idx + 1) ----> Phi(Region,   -1,    0,    1)\n+\/\/\n+\/\/    In the example above the last two objects participating in the merge were\n+\/\/    scalar replaced. Additional entries in the SafePoint node's input array\n+\/\/    are used to represent the scalar replaced objects in a similar fashion\n+\/\/    as in Scenario 1 above. The only difference is that we add a reference\n+\/\/    to the Klass of the SR'ed object before the list of fields.\n+\/\/\n+\/\/    SafePoint->in(_merge_pointer_idx + 0) ----> Phi(Region, ccpp, NULL, NULL)\n+\/\/    SafePoint->in(_merge_pointer_idx + 1) ----> Phi(Region,   -1,    0,    1)\n+\/\/    SafePoint->in(_merge_pointer_idx + 2) ----> \"Point#Klass\"\n+\/\/    SafePoint->in(_merge_pointer_idx + 3) --------> Parm4\n+\/\/    SafePoint->in(_merge_pointer_idx + 4) --------> Parm5\n+\/\/    SafePoint->in(_merge_pointer_idx + 5) ----> \"Point#Klass\"\n+\/\/    SafePoint->in(_merge_pointer_idx + 6) --------> Parm6\n+\/\/    SafePoint->in(_merge_pointer_idx + 6) --------> Parm7\n+\/\/\n+\/\/    The example above assumes that two objects of the class Point were scalar\n+\/\/    replaced. Each object has two non-static field.\n@@ -510,5 +556,20 @@\n-  uint _first_index; \/\/ First input edge relative index of a SafePoint node where\n-                     \/\/ states of the scalarized object fields are collected.\n-                     \/\/ It is relative to the last (youngest) jvms->_scloff.\n-  uint _n_fields;    \/\/ Number of non-static fields of the scalarized object.\n-  DEBUG_ONLY(Node* _alloc;)\n+  uint _first_index;              \/\/ First input edge relative index of a SafePoint node where\n+                                  \/\/ states of the scalarized object fields are collected.\n+                                  \/\/ It is relative to the last (youngest) jvms->_scloff.\n+                                  \/\/ It will be zero if the Spobj is from a merge.\n+\n+  uint _n_fields;                 \/\/ Number of non-static fields of the scalarized object.\n+                                  \/\/ It will be zero if the Spobj is from a merge.\n+\n+  DEBUG_ONLY(Node* _alloc;)       \/\/ Just for debugging purposes.\n+\n+  int _merge_pointer_idx;         \/\/ Only used when the Spobj is representing the scalar replacement\n+                                  \/\/ of an allocation merge. This is the first input edge relative\n+                                  \/\/ index of a SafePoint node where metadata information relative\n+                                  \/\/ to restoring the merge is stored. The corresponding input\n+                                  \/\/ in the associated SafePoint will point to a Phi representing\n+                                  \/\/ potential non-scalar replaced objects.\n+\n+  uint _number_of_objects;        \/\/ How many scalar replaced objects this Spobj represents.\n+                                  \/\/ It will always be >= 1. It can be more than 1 when Spobj\n+                                  \/\/ was created for an allocation merge.\n@@ -526,1 +587,5 @@\n-                            uint first_index, uint n_fields);\n+                            uint first_index,\n+                            uint n_fields,\n+                            int merge_pointer_idx = -1,\n+                            uint number_of_objects = 1);\n+\n@@ -545,0 +610,14 @@\n+  bool is_from_merge() const { return _merge_pointer_idx >= 0; }\n+\n+  int merge_pointer_idx(JVMState* jvms) const {\n+    assert(jvms != NULL, \"JVMS reference is NULL.\");\n+    return jvms->scloff() + _merge_pointer_idx;\n+  }\n+\n+  int selector_idx(JVMState* jvms) const {\n+    assert(jvms != NULL, \"JVMS reference is NULL.\");\n+    return jvms->scloff() + _merge_pointer_idx + 1;\n+  }\n+\n+  uint number_of_objects() const { return _number_of_objects; }\n+\n@@ -738,0 +817,1 @@\n+  bool is_uncommon_trap() const;\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":89,"deletions":9,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"opto\/macro.hpp\"\n@@ -59,0 +60,1 @@\n+  set_not_scalar_replaceable(phantom_obj NOT_PRODUCT(COMMA \"Phantom object\"));\n@@ -64,0 +66,1 @@\n+  set_not_scalar_replaceable(null_obj NOT_PRODUCT(COMMA \"Null object\"));\n@@ -127,0 +130,1 @@\n+  Unique_Node_List reducible_merges;\n@@ -295,1 +299,1 @@\n-      adjust_scalar_replaceable_state(ptn);\n+      adjust_scalar_replaceable_state(ptn, reducible_merges);\n@@ -362,1 +366,1 @@\n-    split_unique_types(alloc_worklist, arraycopy_worklist, mergemem_worklist);\n+    split_unique_types(alloc_worklist, arraycopy_worklist, mergemem_worklist, reducible_merges);\n@@ -382,0 +386,11 @@\n+  \/\/ 6. Remove reducible allocation merges from ideal graph\n+  if (ReduceAllocationMerges && reducible_merges.size() > 0) {\n+    bool delay = _igvn->delay_transform();\n+    _igvn->set_delay_transform(true);\n+    for (uint i = 0; i < reducible_merges.size(); i++ ) {\n+      Node* n = reducible_merges.at(i);\n+      reduce_this_phi(ptnode_adr(n->_idx)->as_LocalVar());\n+    }\n+    _igvn->set_delay_transform(delay);\n+  }\n+\n@@ -404,0 +419,233 @@\n+\/\/ Check if it's profitable to reduce the Phi passed as parameter.  Returns true\n+\/\/ if at least one scalar replaceable allocation participates in the merge and\n+\/\/ no input to the Phi is nullable.\n+bool ConnectionGraph::can_reduce_this_phi_inputs(PhiNode* phi) const {\n+  \/\/ Check if there is an scalar replaceable allocate in the Phi\n+  bool found_sr_allocate = false;\n+\n+  for (uint i = 1; i < phi->req(); i++) {\n+    \/\/ Right now we can't restore a \"null\" pointer during deoptimization\n+    if (_igvn->type(phi->in(i))->maybe_null()) {\n+      NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Can NOT reduce Phi %d. Input %d is nullable.\", phi->_idx, i);)\n+      return false;\n+    }\n+\n+    \/\/ We are looking for at least one SR object in the merge\n+    JavaObjectNode* ptn = unique_java_object(phi->in(i));\n+    if (ptn != NULL && ptn->scalar_replaceable()) {\n+      assert(ptn->ideal_node() != NULL && ptn->ideal_node()->is_Allocate(), \"sanity\");\n+      Node* alloc = ptn->ideal_node()->as_Allocate();\n+\n+      if (PhaseMacroExpand::can_eliminate_allocation(_igvn, alloc->as_Allocate(), NULL, true)) {\n+        found_sr_allocate = true;\n+      } else {\n+        ptn->set_scalar_replaceable(false);\n+      }\n+    }\n+  }\n+\n+  NOT_PRODUCT(if (TraceReduceAllocationMerges && !found_sr_allocate) tty->print_cr(\"Can NOT reduce Phi %d. No SR Allocate as input.\", phi->_idx);)\n+  return found_sr_allocate;\n+}\n+\n+\/\/ Check if we are able to untangle the merge. Right now we only reduce Phis\n+\/\/ which are only used as debug information.\n+bool ConnectionGraph::can_reduce_this_phi_users(PhiNode* phi) const {\n+  for (DUIterator_Fast imax, i = phi->fast_outs(imax); i < imax; i++) {\n+    Node* use = phi->fast_out(i);\n+\n+    if (use->is_SafePoint()) {\n+      if (use->is_Call() && use->as_Call()->has_non_debug_use(phi)) {\n+        NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Can NOT reduce Phi %d. Call has non_debug_use().\", phi->_idx);)\n+        return false;\n+      }\n+    } else {\n+      NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Can NOT reduce Phi %d. One of the uses is: %d %s\", phi->_idx, use->_idx, use->Name());)\n+      return false;\n+    }\n+  }\n+\n+  return true;\n+}\n+\n+\/\/ Returns true if: 1) It's profitable to reduce the merge, and 2) It The Phi is\n+\/\/ only used in some certain code shapes. Check comments in\n+\/\/ 'can_reduce_this_phi_inputs' and 'can_reduce_this_phi_users' for more\n+\/\/ details.\n+bool ConnectionGraph::can_reduce_this_phi(PointsToNode* var) const {\n+  assert(var->escape_state() == PointsToNode::NoEscape, \"Phi should be NoEscape\");\n+\n+  PhiNode* phi = var->ideal_node()->as_Phi();\n+  const Type* phi_t = _igvn->type(phi);\n+  if (phi_t == NULL || phi_t->isa_instptr() == NULL || !phi_t->is_instptr()->klass_is_exact()) {\n+    return false;\n+  }\n+\n+  if (!can_reduce_this_phi_inputs(phi) || !can_reduce_this_phi_users(phi)) {\n+    return false;\n+  }\n+\n+  NOT_PRODUCT(if (TraceReduceAllocationMerges) { tty->print_cr(\"Can reduce this Phi during invocation %d: \", _invocation); phi->dump(); })\n+  return true;\n+}\n+\n+\/\/ This method will create SafePointScalarObjectNode for each combination of\n+\/\/ scalar replaceable allocation in 'var' and SafePoint node in 'safepoints'.\n+\/\/ Each SafePointScalarObjectNodes created here may describe multiple scalar\n+\/\/ replaced objects - check detailed description in SafePointScalarObjectNode\n+\/\/ class header.\n+\/\/\n+\/\/ This method will set to 'NULL' entries in the Phi that are scalar replaceable.\n+void ConnectionGraph::reduce_this_phi_on_safepoints(LocalVarNode* var, Unique_Node_List* safepoints) {\n+  assert(var->ideal_node()->is_Phi(), \"Not a Phi!\");\n+  PhiNode* ophi             = var->ideal_node()->as_Phi();\n+  Node* minus_one           = _igvn->register_new_node_with_optimizer(ConINode::make(-1));\n+  Node* selector            = _igvn->register_new_node_with_optimizer(PhiNode::make(ophi->region(), minus_one, TypeInt::INT));\n+  Node* null_ptr            = _igvn->makecon(TypePtr::NULL_PTR);\n+  const TypeOopPtr* merge_t = _igvn->type(ophi)->make_oopptr();\n+  uint number_of_sr_objects = 0;\n+\n+  _igvn->hash_delete(ophi);\n+\n+ \/\/ Fill in the 'selector' Phi. If index 'i' of the selector is:\n+ \/\/ -> a '-1' constant, the i'th input of the original Phi is NSR.\n+ \/\/ -> a 'x' constant >=0, the i'th input of of original Phi will be SR and the\n+ \/\/    info about the scalarized object will be at index x of\n+ \/\/    ObjectMergeValue::possible_objects\n+ for (uint i = 1; i < ophi->req(); i++) {\n+   Node* base          = ophi->in(i);\n+   JavaObjectNode* ptn = unique_java_object(base);\n+\n+   if (ptn != NULL && ptn->scalar_replaceable()) {\n+     Node* sr_obj_idx = _igvn->register_new_node_with_optimizer(ConINode::make(number_of_sr_objects));\n+     selector->set_req(i, sr_obj_idx);\n+     number_of_sr_objects++;\n+   }\n+ }\n+\n+ \/\/ Update the debug information of all safepoints in turn\n+ for (uint spi = 0; spi < safepoints->size(); spi++ ) {\n+   Node* call               = safepoints->at(spi);\n+   Node* ctrl               = call->in(TypeFunc::Control);\n+   Node* memory             = call->in(TypeFunc::Memory);\n+   JVMState *jvms           = call->jvms();\n+   uint scalar_fields_index = (call->req() - jvms->scloff());\n+   int debug_start          = jvms->debug_start();\n+   int debug_end            = jvms->debug_end();\n+\n+   \/\/ Keep a copy of the original pointer to NSR objects\n+   call->add_req(ophi);\n+   \/\/ Add the selector so we know which direction the execution took\n+   call->add_req(selector);\n+\n+   for (uint i = 1; i < ophi->req(); i++) {\n+     Node* base               = ophi->in(i);\n+     JavaObjectNode* ptn      = unique_java_object(base);\n+\n+     \/\/ If the base is not scalar replaceable we don't need to register information about\n+     \/\/ it at this time.\n+     if (ptn == NULL || !ptn->scalar_replaceable()) {\n+       continue;\n+     }\n+\n+     const TypeOopPtr* base_t   = _igvn->type(base)->make_oopptr();\n+     ciInstanceKlass* iklass    = base_t->is_instptr()->instance_klass();\n+     int nfields                = iklass->nof_nonstatic_fields();\n+     AllocateNode* alloc        = ptn->ideal_node()->as_Allocate();\n+     Node* ccpp                 = alloc->result_cast();\n+     const TypeOopPtr* res_type = _igvn->type(ccpp)->isa_oopptr();\n+     Node* base_klass_node      = alloc->in(AllocateNode::KlassNode);\n+     assert(base_klass_node != NULL, \"This shouldn't happen.\");\n+\n+     call->add_req(base_klass_node);\n+\n+     for (int j = 0; j < nfields; j++) {\n+       ciField* field            = iklass->nonstatic_field_at(j);\n+       ciType* elem_type         = field->type();\n+       BasicType basic_elem_type = field->layout_type();\n+       const Type* field_type    = NULL;\n+       const TypeOopPtr *field_adr_type = res_type->add_offset(field->offset())->isa_oopptr();\n+\n+       if (is_reference_type(basic_elem_type)) {\n+         if (!elem_type->is_loaded()) {\n+           field_type = TypeInstPtr::BOTTOM;\n+         } else {\n+           field_type = TypeOopPtr::make_from_klass(elem_type->as_klass());\n+         }\n+\n+         if (UseCompressedOops) {\n+           field_type = field_type->make_narrowoop();\n+           basic_elem_type = T_NARROWOOP;\n+         }\n+       } else {\n+         field_type = Type::get_const_basic_type(basic_elem_type);\n+       }\n+\n+       Node* field_val = PhaseMacroExpand::value_from_mem(_compile, _igvn, memory, ctrl, basic_elem_type, field_type, field_adr_type, alloc);\n+       assert(field_val != NULL, \"field_val is NULL\");\n+\n+       call->add_req(field_val);\n+     }\n+\n+     JVMState *jvms = call->jvms();\n+     jvms->set_endoff(call->req());\n+   }\n+\n+   SafePointScalarObjectNode* sobj = new SafePointScalarObjectNode(merge_t,\n+#ifdef ASSERT\n+   NOT_PRODUCT(NULL),\n+#endif\n+                                                                   \/* first_index *\/ 0,\n+                                                                   \/* n_fields *\/ 0,\n+                                                                   scalar_fields_index,\n+                                                                   number_of_sr_objects);\n+   assert(sobj->is_from_merge(), \"sanity\");\n+\n+   sobj->init_req(0, _compile->root());\n+   _igvn->register_new_node_with_optimizer(sobj);\n+\n+   \/\/ Replaces debug information references to \"ophi\" in \"call\" with references to \"sobj\"\n+   call->replace_edges_in_range(ophi, sobj, debug_start, debug_end, _igvn);\n+   _igvn->_worklist.push(call);\n+ }\n+\n+  \/\/ Now we can change ophi since we don't need to know the types\n+  \/\/ of the input allocations anymore.\n+  const Type* new_t = merge_t->meet(TypePtr::NULL_PTR);\n+  Node* new_phi = _igvn->register_new_node_with_optimizer(PhiNode::make(ophi->region(), null_ptr, new_t));\n+  for (uint i = 1; i < ophi->req(); i++) {\n+    Node* base          = ophi->in(i);\n+    JavaObjectNode* ptn = unique_java_object(base);\n+\n+    if (ptn != NULL && ptn->scalar_replaceable()) {\n+      new_phi->set_req(i, null_ptr);\n+    }\n+    else {\n+      new_phi->set_req(i, ophi->in(i));\n+    }\n+  }\n+\n+  _igvn->replace_node(ophi, new_phi);\n+  _igvn->hash_insert(ophi);\n+  _igvn->_worklist.push(ophi);\n+}\n+\n+void ConnectionGraph::reduce_this_phi(LocalVarNode* var) {\n+  Node* phi = var->ideal_node();\n+  Unique_Node_List safepoints;\n+\n+  for (uint i = 0; i < phi->outcnt(); i++) {\n+    Node* use = phi->raw_out(i);\n+\n+    \/\/ All SafePoint nodes using the same Phi node uses the same debug\n+    \/\/ information (regarding to the Phi). Furthermore, reducing the Phi used\n+    \/\/ by a SafePoint requires changing the Phi Therefore, I collect all\n+    \/\/ safepoints and patch them all at once later.\n+    if (use->is_SafePoint()) {\n+      safepoints.push(use->as_SafePoint());\n+    }\n+  }\n+\n+  reduce_this_phi_on_safepoints(var, &safepoints);\n+}\n+\n@@ -583,1 +831,2 @@\n-      add_java_object(n, es);\n+      PointsToNode* ptn_con = add_java_object(n, es);\n+      set_not_scalar_replaceable(ptn_con NOT_PRODUCT(COMMA \"Constant pointer\"));\n@@ -672,1 +921,2 @@\n-      add_java_object(n, PointsToNode::ArgEscape);\n+      PointsToNode* ptn_thr = add_java_object(n, PointsToNode::ArgEscape);\n+      set_not_scalar_replaceable(ptn_thr NOT_PRODUCT(COMMA \"Constant pointer\"));\n@@ -1050,0 +1300,3 @@\n+      if (es == PointsToNode::GlobalEscape) {\n+        set_not_scalar_replaceable(ptnode_adr(call->_idx) NOT_PRODUCT(COMMA \"object can be loaded from boxing cache\"));\n+      }\n@@ -1863,1 +2116,1 @@\n-void ConnectionGraph::adjust_scalar_replaceable_state(JavaObjectNode* jobj) {\n+void ConnectionGraph::adjust_scalar_replaceable_state(JavaObjectNode* jobj, Unique_Node_List &reducible_merges) {\n@@ -1898,1 +2151,2 @@\n-    \/\/ 3. An object is not scalar replaceable if it is merged with other objects.\n+    \/\/ 3. An object is not scalar replaceable if it is merged with other objects\n+    \/\/ and we can't remove the merge\n@@ -1902,3 +2156,8 @@\n-        \/\/ Mark all objects.\n-        set_not_scalar_replaceable(jobj NOT_PRODUCT(COMMA trace_merged_message(ptn)));\n-        set_not_scalar_replaceable(ptn NOT_PRODUCT(COMMA trace_merged_message(jobj)));\n+        if (ReduceAllocationMerges &&\n+            use->ideal_node()->is_Phi() && can_reduce_this_phi(use)) {\n+          reducible_merges.push(use->ideal_node());\n+        } else {\n+          \/\/ Mark all objects as NSR & NonUnique if we can't remove the merge\n+          set_not_scalar_replaceable(jobj NOT_PRODUCT(COMMA trace_merged_message(ptn)));\n+          set_not_scalar_replaceable(ptn NOT_PRODUCT(COMMA trace_merged_message(jobj)));\n+        }\n@@ -2246,1 +2505,1 @@\n-void ConnectionGraph::add_java_object(Node *n, PointsToNode::EscapeState es) {\n+PointsToNode* ConnectionGraph::add_java_object(Node *n, PointsToNode::EscapeState es) {\n@@ -2250,1 +2509,1 @@\n-    return;\n+    return ptadr;\n@@ -2255,0 +2514,1 @@\n+  return ptadr;\n@@ -2345,2 +2605,1 @@\n-JavaObjectNode* ConnectionGraph::unique_java_object(Node *n) {\n-  assert(!_collecting, \"should not call when constructed graph\");\n+JavaObjectNode* ConnectionGraph::unique_java_object(Node *n) const {\n@@ -3185,1 +3444,2 @@\n-                                         GrowableArray<MergeMemNode*> &mergemem_worklist) {\n+                                         GrowableArray<MergeMemNode*> &mergemem_worklist,\n+                                         Unique_Node_List &reducible_merges) {\n@@ -3353,0 +3613,4 @@\n+      \/\/ Reducible Phi's will be removed from the graph after split_unique_types finishes\n+      if (reducible_merges.member(n)) {\n+        continue;\n+      }\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":278,"deletions":14,"binary":false,"changes":292,"status":"modified"},{"patch":"@@ -364,1 +364,1 @@\n-  void add_java_object(Node* n, PointsToNode::EscapeState es);\n+  PointsToNode* add_java_object(Node* n, PointsToNode::EscapeState es);\n@@ -445,0 +445,4 @@\n+\n+      if (esc != PointsToNode::NoEscape) {\n+        ptn->set_scalar_replaceable(false);\n+      }\n@@ -455,0 +459,4 @@\n+\n+      if (esc != PointsToNode::NoEscape) {\n+        ptn->set_scalar_replaceable(false);\n+      }\n@@ -464,1 +472,1 @@\n-  void adjust_scalar_replaceable_state(JavaObjectNode* jobj);\n+  void adjust_scalar_replaceable_state(JavaObjectNode* jobj, Unique_Node_List &reducible_merges);\n@@ -476,1 +484,1 @@\n-  JavaObjectNode* unique_java_object(Node *n);\n+  JavaObjectNode* unique_java_object(Node *n) const;\n@@ -536,1 +544,2 @@\n-                          GrowableArray<MergeMemNode*> &mergemem_worklist);\n+                          GrowableArray<MergeMemNode*> &mergemem_worklist,\n+                          Unique_Node_List &reducible_merges);\n@@ -581,0 +590,10 @@\n+  \/\/ -------------------------------------------\n+  \/\/ Methods related to Reduce Allocation Merges\n+\n+  bool can_reduce_this_phi(PointsToNode* var) const;\n+  bool can_reduce_this_phi_users(PhiNode* phi) const;\n+  bool can_reduce_this_phi_inputs(PhiNode* phi) const;\n+\n+  void reduce_this_phi_on_safepoints(LocalVarNode* var, Unique_Node_List* safepoints);\n+  void reduce_this_phi(LocalVarNode* var);\n+\n","filename":"src\/hotspot\/share\/opto\/escape.hpp","additions":23,"deletions":4,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -277,1 +277,1 @@\n-Node* PhaseMacroExpand::make_arraycopy_load(ArrayCopyNode* ac, intptr_t offset, Node* ctl, Node* mem, BasicType ft, const Type *ftype, AllocateNode *alloc) {\n+Node* PhaseMacroExpand::make_arraycopy_load(Compile* comp, PhaseIterGVN* igvn, ArrayCopyNode* ac, intptr_t offset, Node* ctl, Node* mem, BasicType ft, const Type *ftype, AllocateNode *alloc) {\n@@ -288,3 +288,3 @@\n-    Node* adr = _igvn.transform(new AddPNode(base, base, MakeConX(offset)));\n-    const TypePtr* adr_type = _igvn.type(base)->is_ptr()->add_offset(offset);\n-    MergeMemNode* mergemen = _igvn.transform(MergeMemNode::make(mem))->as_MergeMem();\n+    Node* adr = igvn->transform(new AddPNode(base, base, igvn->MakeConX(offset)));\n+    const TypePtr* adr_type = igvn->type(base)->is_ptr()->add_offset(offset);\n+    MergeMemNode* mergemen = igvn->transform(MergeMemNode::make(mem))->as_MergeMem();\n@@ -292,1 +292,1 @@\n-    res = ArrayCopyNode::load(bs, &_igvn, ctl, mergemen, adr, adr_type, type, bt);\n+    res = ArrayCopyNode::load(bs, igvn, ctl, mergemen, adr, adr_type, type, bt);\n@@ -294,1 +294,1 @@\n-    if (ac->modifies(offset, offset, &_igvn, true)) {\n+    if (ac->modifies(offset, offset, igvn, true)) {\n@@ -299,2 +299,2 @@\n-      const TypeInt* src_pos_t = _igvn.type(src_pos)->is_int();\n-      const TypeInt* dest_pos_t = _igvn.type(dest_pos)->is_int();\n+      const TypeInt* src_pos_t = igvn->type(src_pos)->is_int();\n+      const TypeInt* dest_pos_t = igvn->type(dest_pos)->is_int();\n@@ -307,2 +307,2 @@\n-        adr = _igvn.transform(new AddPNode(base, base, MakeConX(off)));\n-        adr_type = _igvn.type(base)->is_ptr()->add_offset(off);\n+        adr = igvn->transform(new AddPNode(base, base, igvn->MakeConX(off)));\n+        adr_type = igvn->type(base)->is_ptr()->add_offset(off);\n@@ -311,1 +311,1 @@\n-          return value_from_mem(ac->in(TypeFunc::Memory), ctl, ft, ftype, adr_type->isa_oopptr(), alloc);\n+          return value_from_mem(comp, igvn, ac->in(TypeFunc::Memory), ctl, ft, ftype, adr_type->isa_oopptr(), alloc);\n@@ -314,1 +314,1 @@\n-        Node* diff = _igvn.transform(new SubINode(ac->in(ArrayCopyNode::SrcPos), ac->in(ArrayCopyNode::DestPos)));\n+        Node* diff = igvn->transform(new SubINode(ac->in(ArrayCopyNode::SrcPos), ac->in(ArrayCopyNode::DestPos)));\n@@ -316,1 +316,1 @@\n-        diff = _igvn.transform(new ConvI2LNode(diff));\n+        diff = igvn->transform(new ConvI2LNode(diff));\n@@ -318,1 +318,1 @@\n-        diff = _igvn.transform(new LShiftXNode(diff, intcon(shift)));\n+        diff = igvn->transform(new LShiftXNode(diff, igvn->intcon(shift)));\n@@ -320,1 +320,1 @@\n-        Node* off = _igvn.transform(new AddXNode(MakeConX(offset), diff));\n+        Node* off = igvn->transform(new AddXNode(igvn->MakeConX(offset), diff));\n@@ -322,2 +322,2 @@\n-        adr = _igvn.transform(new AddPNode(base, base, off));\n-        adr_type = _igvn.type(base)->is_ptr()->add_offset(Type::OffsetBot);\n+        adr = igvn->transform(new AddPNode(base, base, off));\n+        adr_type = igvn->type(base)->is_ptr()->add_offset(Type::OffsetBot);\n@@ -330,1 +330,1 @@\n-      MergeMemNode* mergemen = _igvn.transform(MergeMemNode::make(mem))->as_MergeMem();\n+      MergeMemNode* mergemen = igvn->transform(MergeMemNode::make(mem))->as_MergeMem();\n@@ -332,1 +332,1 @@\n-      res = ArrayCopyNode::load(bs, &_igvn, ctl, mergemen, adr, adr_type, type, bt);\n+      res = ArrayCopyNode::load(bs, igvn, ctl, mergemen, adr, adr_type, type, bt);\n@@ -338,1 +338,1 @@\n-      res = _igvn.transform(new EncodePNode(res, ftype));\n+      res = igvn->transform(new EncodePNode(res, ftype));\n@@ -350,1 +350,1 @@\n-Node *PhaseMacroExpand::value_from_mem_phi(Node *mem, BasicType ft, const Type *phi_type, const TypeOopPtr *adr_t, AllocateNode *alloc, Node_Stack *value_phis, int level) {\n+Node *PhaseMacroExpand::value_from_mem_phi(Compile* comp, PhaseIterGVN* igvn, Node *mem, BasicType ft, const Type *phi_type, const TypeOopPtr *adr_t, AllocateNode *alloc, Node_Stack *value_phis, int level) {\n@@ -352,1 +352,1 @@\n-  int alias_idx = C->get_alias_index(adr_t);\n+  int alias_idx = comp->get_alias_index(adr_t);\n@@ -373,1 +373,1 @@\n-  Node *start_mem = C->start()->proj_out_or_null(TypeFunc::Memory);\n+  Node *start_mem = comp->start()->proj_out_or_null(TypeFunc::Memory);\n@@ -381,1 +381,1 @@\n-  transform_later(phi);\n+  igvn->register_new_node_with_optimizer(phi);\n@@ -389,1 +389,1 @@\n-      Node *val = scan_mem_chain(in, alias_idx, offset, start_mem, alloc, &_igvn);\n+      Node *val = scan_mem_chain(in, alias_idx, offset, start_mem, alloc, igvn);\n@@ -392,1 +392,1 @@\n-        values.at_put(j, _igvn.zerocon(ft));\n+        values.at_put(j, igvn->zerocon(ft));\n@@ -396,1 +396,1 @@\n-        val = val->as_Initialize()->find_captured_store(offset, type2aelembytes(ft), &_igvn);\n+        val = val->as_Initialize()->find_captured_store(offset, type2aelembytes(ft), igvn);\n@@ -408,1 +408,1 @@\n-          n = Compile::narrow_value(ft, n, phi_type, &_igvn, true);\n+          n = Compile::narrow_value(ft, n, phi_type, igvn, true);\n@@ -412,1 +412,1 @@\n-        values.at_put(j, _igvn.zerocon(ft));\n+        values.at_put(j, igvn->zerocon(ft));\n@@ -414,1 +414,1 @@\n-        val = value_from_mem_phi(val, ft, phi_type, adr_t, alloc, value_phis, level-1);\n+        val = value_from_mem_phi(comp, igvn, val, ft, phi_type, adr_t, alloc, value_phis, level-1);\n@@ -426,1 +426,1 @@\n-        Node* res = make_arraycopy_load(val->as_ArrayCopy(), offset, val->in(0), val->in(TypeFunc::Memory), ft, phi_type, alloc);\n+        Node* res = make_arraycopy_load(comp, igvn, val->as_ArrayCopy(), offset, val->in(0), val->in(TypeFunc::Memory), ft, phi_type, alloc);\n@@ -450,1 +450,1 @@\n-Node *PhaseMacroExpand::value_from_mem(Node *sfpt_mem, Node *sfpt_ctl, BasicType ft, const Type *ftype, const TypeOopPtr *adr_t, AllocateNode *alloc) {\n+Node *PhaseMacroExpand::value_from_mem(Compile* comp, PhaseIterGVN* igvn, Node *sfpt_mem, Node *sfpt_ctl, BasicType ft, const Type *ftype, const TypeOopPtr *adr_t, AllocateNode *alloc) {\n@@ -455,1 +455,1 @@\n-  int alias_idx = C->get_alias_index(adr_t);\n+  int alias_idx = comp->get_alias_index(adr_t);\n@@ -457,1 +457,1 @@\n-  Node *start_mem = C->start()->proj_out_or_null(TypeFunc::Memory);\n+  Node *start_mem = comp->start()->proj_out_or_null(TypeFunc::Memory);\n@@ -468,1 +468,1 @@\n-    mem = scan_mem_chain(mem, alias_idx, offset, start_mem, alloc, &_igvn);\n+    mem = scan_mem_chain(mem, alias_idx, offset, start_mem, alloc, igvn);\n@@ -472,1 +472,1 @@\n-      mem = mem->as_Initialize()->find_captured_store(offset, type2aelembytes(ft), &_igvn);\n+      mem = mem->as_Initialize()->find_captured_store(offset, type2aelembytes(ft), igvn);\n@@ -477,1 +477,1 @@\n-        assert(C->get_alias_index(atype) == Compile::AliasIdxRaw, \"store is correct memory slice\");\n+        assert(comp->get_alias_index(atype) == Compile::AliasIdxRaw, \"store is correct memory slice\");\n@@ -483,1 +483,1 @@\n-      assert(C->get_alias_index(atype) == alias_idx &&\n+      assert(comp->get_alias_index(atype) == alias_idx &&\n@@ -490,1 +490,1 @@\n-      Node *top = C->top();\n+      Node *top = comp->top();\n@@ -492,1 +492,1 @@\n-        Node *n = scan_mem_chain(mem->in(i), alias_idx, offset, start_mem, alloc, &_igvn);\n+        Node *n = scan_mem_chain(mem->in(i), alias_idx, offset, start_mem, alloc, igvn);\n@@ -517,1 +517,1 @@\n-      return _igvn.zerocon(ft);\n+      return igvn->zerocon(ft);\n@@ -526,1 +526,1 @@\n-      Node* phi = value_from_mem_phi(mem, ft, ftype, adr_t, alloc, &value_phis, ValueSearchLimit);\n+      Node* phi = value_from_mem_phi(comp, igvn, mem, ft, ftype, adr_t, alloc, &value_phis, ValueSearchLimit);\n@@ -533,1 +533,1 @@\n-          _igvn.replace_node(n, C->top());\n+          igvn->replace_node(n, comp->top());\n@@ -545,1 +545,1 @@\n-      return make_arraycopy_load(mem->as_ArrayCopy(), offset, ctl, m, ft, ftype, alloc);\n+      return make_arraycopy_load(comp, igvn, mem->as_ArrayCopy(), offset, ctl, m, ft, ftype, alloc);\n@@ -553,1 +553,1 @@\n-bool PhaseMacroExpand::can_eliminate_allocation(AllocateNode *alloc, GrowableArray <SafePointNode *>& safepoints) {\n+bool PhaseMacroExpand::can_eliminate_allocation(PhaseIterGVN* igvn, AllocateNode *alloc, GrowableArray <SafePointNode *>* safepoints, bool ignore_merges) {\n@@ -568,1 +568,1 @@\n-    res_type = _igvn.type(res)->isa_oopptr();\n+    res_type = igvn->type(res)->isa_oopptr();\n@@ -588,1 +588,1 @@\n-        const TypePtr* addp_type = _igvn.type(use)->is_ptr();\n+        const TypePtr* addp_type = igvn->type(use)->is_ptr();\n@@ -629,2 +629,2 @@\n-        } else {\n-          safepoints.append_if_missing(sfpt);\n+        } else if (safepoints != NULL) {\n+          safepoints->append_if_missing(sfpt);\n@@ -632,0 +632,2 @@\n+      } else if (ignore_merges && use->is_Phi()) {\n+        \/\/ Nothing to do\n@@ -654,1 +656,1 @@\n-  if (PrintEliminateAllocations) {\n+  if (PrintEliminateAllocations && safepoints != NULL) {\n@@ -768,1 +770,1 @@\n-      Node *field_val = value_from_mem(mem, ctl, basic_elem_type, field_type, field_addr_type, alloc);\n+      Node *field_val = value_from_mem(C, &_igvn, mem, ctl, basic_elem_type, field_type, field_addr_type, alloc);\n@@ -1033,1 +1035,1 @@\n-  if (!can_eliminate_allocation(alloc, safepoints)) {\n+  if (!can_eliminate_allocation(&_igvn, alloc, &safepoints)) {\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":54,"deletions":52,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -97,2 +97,0 @@\n-  Node *value_from_mem(Node *mem, Node *ctl, BasicType ft, const Type *ftype, const TypeOopPtr *adr_t, AllocateNode *alloc);\n-  Node *value_from_mem_phi(Node *mem, BasicType ft, const Type *ftype, const TypeOopPtr *adr_t, AllocateNode *alloc, Node_Stack *value_phis, int level);\n@@ -102,1 +100,0 @@\n-  bool can_eliminate_allocation(AllocateNode *alloc, GrowableArray <SafePointNode *>& safepoints);\n@@ -199,1 +196,1 @@\n-  Node* make_arraycopy_load(ArrayCopyNode* ac, intptr_t offset, Node* ctl, Node* mem, BasicType ft, const Type *ftype, AllocateNode *alloc);\n+  static Node* make_arraycopy_load(Compile* comp, PhaseIterGVN* igvn, ArrayCopyNode* ac, intptr_t offset, Node* ctl, Node* mem, BasicType ft, const Type *ftype, AllocateNode *alloc);\n@@ -208,0 +205,4 @@\n+  static bool can_eliminate_allocation(PhaseIterGVN *igvn, AllocateNode *alloc, GrowableArray <SafePointNode *> *safepoints, bool ignore_merges = false);\n+  static Node *value_from_mem(Compile *comp, PhaseIterGVN *igvn, Node *mem, Node *ctl, BasicType ft, const Type *ftype, const TypeOopPtr *adr_t, AllocateNode *alloc);\n+  static Node *value_from_mem_phi(Compile *comp, PhaseIterGVN *igvn, Node *mem, BasicType ft, const Type *ftype, const TypeOopPtr *adr_t, AllocateNode *alloc, Node_Stack *value_phis, int level);\n+\n","filename":"src\/hotspot\/share\/opto\/macro.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -929,0 +929,1 @@\n+  case T_NARROWOOP:\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -709,1 +709,1 @@\n-ObjectValue*\n+ScopeValue*\n@@ -712,4 +712,12 @@\n-    assert(objs->at(i)->is_object(), \"corrupt object cache\");\n-    ObjectValue* sv = (ObjectValue*) objs->at(i);\n-    if (sv->id() == id) {\n-      return sv;\n+    if (objs->at(i)->is_object()) {\n+      ObjectValue* sv = (ObjectValue*) objs->at(i);\n+      if (sv->id() == id) {\n+        return sv;\n+      }\n+    } else if (objs->at(i)->is_object_merge()) {\n+      ObjectMergeValue* sv = (ObjectMergeValue*) objs->at(i);\n+      if (sv->id() == id) {\n+        return sv;\n+      }\n+    } else {\n+      assert(false, \"corrupt object cache\");\n@@ -722,3 +730,3 @@\n-void PhaseOutput::set_sv_for_object_node(GrowableArray<ScopeValue*> *objs,\n-                                     ObjectValue* sv ) {\n-  assert(sv_for_node_id(objs, sv->id()) == nullptr, \"Precondition\");\n+void PhaseOutput::set_sv_for_object_node(GrowableArray<ScopeValue*> *objs, ScopeValue* sv ) {\n+  assert(!sv->is_object() || (sv_for_node_id(objs, sv->as_ObjectValue()->id()) == nullptr), \"Precondition\");\n+  assert(!sv->is_object_merge() || (sv_for_node_id(objs, sv->as_ObjectMergeValue()->id()) == nullptr), \"Precondition\");\n@@ -752,13 +760,53 @@\n-    ObjectValue* sv = sv_for_node_id(objs, spobj->_idx);\n-    if (sv == nullptr) {\n-      ciKlass* cik = t->is_oopptr()->exact_klass();\n-      assert(cik->is_instance_klass() ||\n-             cik->is_array_klass(), \"Not supported allocation.\");\n-      sv = new ObjectValue(spobj->_idx,\n-                           new ConstantOopWriteValue(cik->java_mirror()->constant_encoding()));\n-      set_sv_for_object_node(objs, sv);\n-\n-      uint first_ind = spobj->first_index(sfpt->jvms());\n-      for (uint i = 0; i < spobj->n_fields(); i++) {\n-        Node* fld_node = sfpt->in(first_ind+i);\n-        (void)FillLocArray(sv->field_values()->length(), sfpt, fld_node, sv->field_values(), objs);\n+    if (!spobj->is_from_merge()) {\n+      ObjectValue* sv = (ObjectValue*) sv_for_node_id(objs, spobj->_idx);\n+      if (sv == nullptr) {\n+        ciKlass* cik = t->is_oopptr()->exact_klass();\n+        assert(cik->is_instance_klass() ||\n+              cik->is_array_klass(), \"Not supported allocation.\");\n+        sv = new ObjectValue(spobj->_idx,\n+                            new ConstantOopWriteValue(cik->java_mirror()->constant_encoding()));\n+        set_sv_for_object_node(objs, sv);\n+\n+        uint first_ind = spobj->first_index(sfpt->jvms());\n+        for (uint i = 0; i < spobj->n_fields(); i++) {\n+          Node* fld_node = sfpt->in(first_ind+i);\n+          (void)FillLocArray(sv->field_values()->length(), sfpt, fld_node, sv->field_values(), objs);\n+        }\n+      }\n+\n+      array->append(sv);\n+    } else if (spobj->is_from_merge()) {\n+      ObjectMergeValue* sv = (ObjectMergeValue*) sv_for_node_id(objs, spobj->_idx);\n+      if (sv == NULL) {\n+        GrowableArray<ScopeValue*> deps;\n+\n+        int merge_pointer_idx = spobj->merge_pointer_idx(sfpt->jvms());\n+        (void)FillLocArray(0, NULL, sfpt->in(merge_pointer_idx), &deps, NULL);\n+        assert(deps.length() == 1, \"missing value\");\n+\n+        int selector_idx = spobj->selector_idx(sfpt->jvms());\n+        (void)FillLocArray(1, NULL, sfpt->in(selector_idx), &deps, NULL);\n+        assert(deps.length() == 2, \"missing value\");\n+\n+        sv = new ObjectMergeValue(spobj->_idx, deps.at(0), deps.at(1));\n+        set_sv_for_object_node(objs, sv);\n+\n+        uint number_of_sr_objects = spobj->number_of_objects();\n+        uint field_index = selector_idx+1;\n+        const uint CANDIDATE_OBJ_BASE_IDX = 100000;\n+        for (uint i = 0; i < number_of_sr_objects; i++) {\n+          Node* klass_node = sfpt->in(field_index++);\n+          const Type *t = klass_node->bottom_type();\n+          assert(t->is_instklassptr(), \"Not supported allocation.\");\n+          ciInstanceKlass* cik = t->isa_instklassptr()->instance_klass();\n+\n+          ObjectValue* sv_o = new ObjectValue(CANDIDATE_OBJ_BASE_IDX + spobj->_idx + i,\n+                              new ConstantOopWriteValue(cik->java_mirror()->constant_encoding()));\n+          set_sv_for_object_node(sv->possible_objects(), sv_o);\n+\n+          uint nfields = cik->nof_nonstatic_fields();\n+          for (uint j = 0; j < nfields; j++) {\n+            Node* fld_node = sfpt->in(field_index++);\n+            (void)FillLocArray(sv_o->field_values()->length(), sfpt, fld_node, sv_o->field_values(), sv->possible_objects());\n+          }\n+        }\n@@ -766,0 +814,2 @@\n+\n+      array->append(sv);\n@@ -767,1 +817,0 @@\n-    array->append(sv);\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":71,"deletions":22,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -143,3 +143,3 @@\n-  \/\/ If \"objs\" contains an ObjectValue whose id is \"id\", returns it, else null.\n-  static ObjectValue* sv_for_node_id(GrowableArray<ScopeValue*> *objs, int id);\n-  static void set_sv_for_object_node(GrowableArray<ScopeValue*> *objs, ObjectValue* sv);\n+  \/\/ If \"objs\" contains an ObjectValue\/ObjectMergeValue whose id is \"id\", returns it, else NULL.\n+  static ScopeValue* sv_for_node_id(GrowableArray<ScopeValue*> *objs, int id);\n+  static void set_sv_for_object_node(GrowableArray<ScopeValue*> *objs, ScopeValue* sv);\n","filename":"src\/hotspot\/share\/opto\/output.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -294,1 +294,2 @@\n-                          GrowableArray<ScopeValue*>* objects, bool realloc_failures) {\n+                          GrowableArray<ScopeValue*>* objects, bool realloc_failures,\n+                          frame* frame, RegisterMap* reg_map) {\n@@ -301,1 +302,9 @@\n-    ObjectValue* sv = (ObjectValue*) objects->at(i);\n+    ObjectValue* sv = NULL;\n+\n+    if (objects->at(i)->is_object()) {\n+      sv = objects->at(i)->as_ObjectValue();\n+    } else if (objects->at(i)->is_object_merge()) {\n+      ObjectMergeValue* merged = objects->at(i)->as_ObjectMergeValue();\n+      sv = merged->select(frame, reg_map);\n+    }\n+\n@@ -373,1 +382,1 @@\n-      print_objects(deoptee_thread, objects, realloc_failures);\n+      print_objects(deoptee_thread, objects, realloc_failures, &deoptee, &map);\n@@ -1190,2 +1199,27 @@\n-    assert(objects->at(i)->is_object(), \"invalid debug information\");\n-    ObjectValue* sv = (ObjectValue*) objects->at(i);\n+    assert(objects->at(i)->is_object() || objects->at(i)->is_object_merge(), \"invalid debug information\");\n+    ObjectValue* sv = nullptr;\n+\n+    if (objects->at(i)->is_object()) {\n+      sv = objects->at(i)->as_ObjectValue();\n+\n+      \/\/ This object is only a candidate inside an ObjectMergeValue\n+      if (sv->is_merge_candidate()) {\n+        continue;\n+      }\n+    } else {\n+      ObjectMergeValue* merged = objects->at(i)->as_ObjectMergeValue();\n+      sv = merged->select(fr, reg_map);\n+\n+      \/\/ If this is true it means that a candidate object became a\n+      \/\/ real object and we are going to reach that object in a later\n+      \/\/ iteration of the outer loop.\n+      if (sv == NULL) {\n+        continue;\n+      }\n+\n+      \/\/ Will be non-null when it's a pointer from a merge where the\n+      \/\/ executed path is of an object NOT scalar replaced.\n+      if (!sv->value().is_null()) {\n+        continue;\n+      }\n+    }\n@@ -1540,1 +1574,19 @@\n-    ObjectValue* sv = (ObjectValue*) objects->at(i);\n+    assert(objects->at(i)->is_object() || objects->at(i)->is_object_merge(), \"invalid debug information\");\n+    ObjectValue* sv = nullptr;\n+\n+    if (objects->at(i)->is_object()) {\n+      sv = objects->at(i)->as_ObjectValue();\n+\n+      \/\/ If the object is only a candidate inside an ObjectMergeValue we\n+      \/\/ skip processing it.\n+      \/\/\n+      \/\/ If the pointer didn't came from a scalar replaced object then\n+      \/\/ we don't need to do field reassignment.\n+      if (sv->is_merge_candidate() || sv->skip_field_assignment()) {\n+        continue;\n+      }\n+    } else {\n+      \/\/ Merge objects don't need field reassignment\n+      continue;\n+    }\n+\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":58,"deletions":6,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -229,0 +229,3 @@\n+  } else if (sv->is_object_merge()) {\n+    Handle ov = ((ObjectMergeValue *)sv)->selected()->value();\n+    return new StackValue(ov, (ov.is_null()) ? 1 : 0);\n","filename":"src\/hotspot\/share\/runtime\/stackValue.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -781,0 +781,7 @@\n+        \/\/ The 'getStackAccessControlContext' call inside 'isPrivileged'\n+        \/\/ requires that no Local was scalar replaced. However, in some\n+        \/\/ situations, after inlining, 'result' (or part of a possibly\n+        \/\/ allocation merge Phi leading to it) might become NonEscaping and get\n+        \/\/ scalar replaced. The call below enforces 'result' to always escape.\n+        ensureMaterializedForStackWalk(result);\n+\n","filename":"src\/java.base\/share\/classes\/java\/security\/AccessController.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,932 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests.scalarReplacement;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8281429\n+ * @summary Tests that C2 can correctly scalar replace some object allocation merges.\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @run driver compiler.c2.irTests.scalarReplacement.AllocationMergesTests\n+ *\/\n+public class AllocationMergesTests {\n+    private static Point global_escape = new Point(2022, 2023);\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-XX:+ReduceAllocationMerges\",\n+                                   \"-XX:CompileCommand=exclude,*::dummy*\");\n+    }\n+\n+    \/\/ ------------------ No Scalar Replacement Should Happen in The Tests Below ------------------- \/\/\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"1\" })\n+    int testGlobalEscape(int x, int y) {\n+        Point p = new Point(x, y);\n+\n+        AllocationMergesTests.global_escape = p;\n+\n+        return p.x * p.y;\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"1\" })\n+    int testArgEscape(int x, int y) {\n+        Point p = new Point(x, y);\n+\n+        int val = dummy(p);\n+\n+        return val + p.x + p.y;\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"2\" })\n+    int testEscapeInCallAfterMerge(boolean cond, boolean cond2, int x, int y) {\n+        Point p = new Point(x, x);\n+\n+        if (cond) {\n+            p = new Point(y, y);\n+        }\n+\n+        if (cond2) {\n+            dummy(p);\n+        }\n+\n+        return p.x * p.y;\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"2\" })\n+    \/\/ Merge won't be reduced because of the field accesses\n+    int testNoEscapeWithWriteInLoop(boolean cond, boolean cond2, int x, int y) {\n+        Point p = new Point(x, y);\n+        int res = 0;\n+\n+        if (cond) {\n+            p = new Point(y, x);\n+        }\n+\n+        for (int i=0; i<100; i++) {\n+            p.x += p.y + i;\n+            p.y += p.x + i;\n+        }\n+\n+        return res + p.x + p.y;\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"2\" })\n+    \/\/ Merge won't be reduced because of the field accesses\n+    int testPollutedWithWrite(boolean cond, int l) {\n+        Shape obj1 = new Square(l);\n+        Shape obj2 = new Square(l);\n+        Shape obj = null;\n+\n+        if (cond) {\n+            obj = obj1;\n+        } else {\n+            obj = obj2;\n+        }\n+\n+        for (int i=1; i<132; i++) {\n+            obj.x++;\n+        }\n+\n+        return obj1.x + obj2.y;\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"2\" })\n+    \/\/ Merge won't be reduced because of the field accesses\n+    int testPollutedPolymorphic(boolean cond, int l) {\n+        Shape obj1 = new Square(l);\n+        Shape obj2 = new Circle(l);\n+        Shape obj = (cond ? obj1 : obj2);\n+        int res = 0;\n+\n+        for (int i=1; i<232; i++) {\n+            res += obj.x;\n+        }\n+\n+        return res + obj1.x + obj2.y;\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"2\" })\n+    \/\/ Merge won't be reduced because write to one of the inputs *after* the merge\n+    int testMergedLoadAfterDirectStore(boolean cond, int x, int y) {\n+        Point p0 = new Point(x, x);\n+        Point p1 = new Point(y, y);\n+        Point p = null;\n+\n+        if (cond) {\n+            p = p0;\n+        } else {\n+            p = p1;\n+        }\n+\n+        p0.x = x * y;\n+\n+        return p.x;\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"3\" })\n+    \/\/ Objects won't be scalar replaced because:\n+    \/\/  - p is written inside the loop.\n+    \/\/  - p2 is ArgEscape\n+    int testMergedAccessAfterCallWithWrite(boolean cond, int x, int y) {\n+        Point p2 = new Point(x, x);\n+        Point p = new Point(y, y);\n+\n+        p.x = p.x * y;\n+\n+        if (cond) {\n+            p = new Point(x, x);\n+        }\n+\n+        dummy(p2);\n+\n+        for (int i=3; i<324; i++) {\n+            p.x += i * x;\n+        }\n+\n+        return p.x;\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"2\" })\n+    \/\/ Allocations won't be removed because of the field accesses\n+    int testLoadAfterTrap(boolean cond, int x, int y) {\n+        Point p = null;\n+\n+        if (cond) {\n+            p = new Point(x, x);\n+        } else {\n+            p = new Point(y, y);\n+        }\n+\n+        dummy(x+y);\n+\n+        return p.x + p.y;\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"1\" })\n+    \/\/ The merge won't be simplified because the merge with NULL and the field x access\n+    int testCondAfterMergeWithNull(boolean cond1, boolean cond2, int x, int y) {\n+        Point p = null;\n+\n+        if (cond1) {\n+            p = new Point(y, x);\n+        }\n+\n+        if (cond2 && cond1) {\n+            return p.x;\n+        } else {\n+            return 321;\n+        }\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"2\" })\n+    \/\/ The access to the fields at the end of the method will prevent the scalar replacement\n+    int testLoadAfterLoopAlias(boolean cond, int x, int y) {\n+        Point a = new Point(x, y);\n+        Point b = new Point(y, x);\n+        Point c = a;\n+\n+        for (int i=10; i<232; i++) {\n+            if (i == 124) {\n+                c = b;\n+            }\n+        }\n+\n+        return cond ? c.x : c.y;\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"1\" })\n+    \/\/ Merge won't be reduced because of field access\n+    int testCallOneSide(boolean cond1, int x, int y) {\n+        Point p = dummy(x, y);\n+\n+        if (cond1) {\n+            p = new Point(y, x);\n+        }\n+\n+        return p.x;\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.CALL, \"3\" })\n+    \/\/ Merge won't be reduced because both of the inputs are NSR\n+    int testCallTwoSide(boolean cond1, int x, int y) {\n+        Point p = dummy(x, y);\n+\n+        if (cond1) {\n+            p = dummy(y, x);\n+        }\n+\n+        return p.x;\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"3\" })\n+    \/\/ The allocations to \"p\" won't be removed because of the access to x inside the loop.\n+    int testMergedAccessAfterCallNoWrite(boolean cond, int x, int y) {\n+        Point p2 = new Point(x, x);\n+        Point p = new Point(y, y);\n+        int res = 0;\n+\n+        p.x = p.x * y;\n+\n+        if (cond) {\n+            p = new Point(y, y);\n+        }\n+\n+        dummy(p2);\n+\n+        for (int i=3; i<324; i++) {\n+            res += p.x + i * x;\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"1\" })\n+    \/\/ Merge won't be reduced because, among other things, one of the inputs is null.\n+    int testCmpMergeWithNull_Second(boolean cond, int x, int y) {\n+        Point p = null;\n+\n+        if (cond) {\n+            p = new Point(x*x, y*y);\n+        }\n+\n+        dummy(x);\n+\n+        if (p != null) {\n+            return p.x * p.y;\n+        } else {\n+            return 1984;\n+        }\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"1\" })\n+    \/\/ The field access will block the reduction\n+    int testObjectIdentity(boolean cond, int x, int y) {\n+        Point o = new Point(x, y);\n+\n+        if (cond) {\n+            o = global_escape;\n+            dummy();\n+        }\n+\n+        dummy();\n+\n+        return o == global_escape ? o.x + o.y : 0;\n+    }\n+\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"2\" })\n+    int testSubclassesTrapping(boolean c1, boolean c2, int x, int y, int w, int z) {\n+        new A();\n+        Root s = new Home(x, y);\n+        new B();\n+\n+        if (c1) {\n+            new C();\n+            s = new Etc(\"Hello\");\n+            new D();\n+        } else {\n+            new E();\n+            s = new Usr(y, x, z);\n+            new F();\n+        }\n+\n+        dummy();\n+\n+        return s.a;\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH, Argument.NUMBER_42, Argument.NUMBER_42 })\n+    @IR(counts = { IRNode.ALLOC, \"2\" })\n+    int testCmpMergeWithNull(boolean cond, int x, int y) {\n+        Point p = null;\n+\n+        if (cond) {\n+            p = new Point(x*x, y*y);\n+        } else if (x == y) {\n+            p = new Point(x+y, x*y);\n+        }\n+\n+        if (p != null) {\n+            return p.x * p.y;\n+        } else {\n+            return 1984;\n+        }\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"2\" })\n+    \/\/ The unused allocation will be removed.\n+    \/\/ The merge on \"s\" will remain because of the access to \"a\"\n+    int testSubclasses(boolean c1, boolean c2, int x, int y, int w, int z) {\n+        new A();\n+        Root s = new Home(x, y);\n+        new B();\n+\n+        if (c1) {\n+            new C();\n+            s = new Etc(\"Hello\");\n+            new D();\n+        } else {\n+            new E();\n+            s = new Usr(y, x, z);\n+            new F();\n+        }\n+\n+        new G();\n+\n+        return s.a;\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"4\" })\n+    \/\/ Won't be reduced because of the field access\n+    Point testNestedObjectsObject(boolean cond, int x, int y) {\n+        Picture p = new Picture(x, x, y);\n+\n+        if (cond) {\n+            p = new Picture(y, y, x);\n+        }\n+\n+        return p.position;\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"4\" })\n+    int testNestedObjectsNoEscapeObject(boolean cond, int x, int y) {\n+        Picture p = new Picture(x, x, y);\n+\n+        if (cond) {\n+            p = new Picture(y, y, x);\n+        }\n+\n+        return p.position.x;\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"6\" })\n+    \/\/ 2 arrays inside each of the two PicturePositions. Each array have 2 other objects.\n+    Point[] testNestedObjectsArray(boolean cond, int x, int y) {\n+        PicturePositions p = new PicturePositions(x, y, x+y);\n+\n+        if (cond) {\n+            p = new PicturePositions(x+1, y+1, x+y+1);\n+        }\n+\n+        return p.positions;\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"2\" })\n+    \/\/ The allocation inside the last if will be removed\n+    int testTrappingAfterMerge(boolean cond, int x, int y) {\n+        Point p = new Point(x, y);\n+        int res = 0;\n+\n+        if (cond) {\n+            p = new Point(y, y);\n+        }\n+\n+        for (int i=832; i<932; i++) {\n+            res += p.x;\n+        }\n+\n+        if (x > y) {\n+            res += new Point(p.x, p.y).x;\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"2\" })\n+    int testSimpleAliasedAlloc(boolean cond, int x, int y) {\n+        Point p1 = new Point(x, y);\n+        Point p2 = new Point(y, x);\n+        Point p = p1;\n+\n+        if (cond) {\n+            p = p2;\n+        }\n+\n+        return p.x * p.y;\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"4\" })\n+    int testSimpleDoubleMerge(boolean cond, int x, int y) {\n+        Point p1 = new Point(x, y);\n+        Point p2 = new Point(x+1, y+1);\n+\n+        if (cond) {\n+            p1 = new Point(y, x);\n+            p2 = new Point(y+1, x+1);\n+        }\n+\n+        return p1.x + p2.y;\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"4\" })\n+    int testConsecutiveSimpleMerge(boolean cond1, boolean cond2, int x, int y) {\n+        Point p0 = new Point(x, x);\n+        Point p1 = new Point(x, y);\n+        Point pA = null;\n+\n+        Point p2 = new Point(y, x);\n+        Point p3 = new Point(y, y);\n+        Point pB = null;\n+\n+        if (cond1) {\n+            pA = p0;\n+        } else {\n+            pA = p1;\n+        }\n+\n+        if (cond2) {\n+            pB = p2;\n+        } else {\n+            pB = p3;\n+        }\n+\n+        return pA.x * pA.y + pB.x * pB.y;\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"4\" })\n+    int testDoubleIfElseMerge(boolean cond, int x, int y) {\n+        Point p1 = new Point(x, y);\n+        Point p2 = new Point(x+1, y+1);\n+\n+        if (cond) {\n+            p1 = new Point(y, x);\n+            p2 = new Point(y, x);\n+        } else {\n+            p1 = new Point(x, y);\n+            p2 = new Point(x+1, y+1);\n+        }\n+\n+        return p1.x * p2.y;\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"2\" })\n+    int testNoEscapeWithLoadInLoop(boolean cond, int x, int y) {\n+        Point p = new Point(x, y);\n+        int res = 0;\n+\n+        if (cond) {\n+            p = new Point(y, x);\n+        }\n+\n+        for (int i=3342; i<4234; i++) {\n+            res += p.x + p.y + i;\n+        }\n+\n+        return res + p.x + p.y;\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"2\" })\n+    int testCmpAfterMerge(boolean cond, boolean cond2, int x, int y) {\n+        Point a = new Point(x, y);\n+        Point b = new Point(y, x);\n+        Point c = null;\n+\n+        if (x+2 >= y-5) {\n+            c = a;\n+        } else {\n+            c = b;\n+        }\n+\n+        return cond2 ? c.x : c.y;\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"2\" })\n+    int testCondAfterMergeWithAllocate(boolean cond1, boolean cond2, int x, int y) {\n+        Point p = new Point(x, y);\n+\n+        if (cond1) {\n+            p = new Point(y, x);\n+        }\n+\n+        if (cond2 && cond1) {\n+            return p.x;\n+        } else {\n+            return 321;\n+        }\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"2\" })\n+    int testCondLoadAfterMerge(boolean cond1, boolean cond2, int x, int y) {\n+        Point p = new Point(x, y);\n+\n+        if (cond1) {\n+            p = new Point(y, x);\n+        }\n+\n+        if (cond1 == false && cond2 == false) {\n+            return p.x + 1;\n+        } else if (cond1 == false && cond2 == true) {\n+            return p.x + 30;\n+        } else if (cond1 == true && cond2 == false) {\n+            return p.x + 40;\n+        } else if (cond1 == true && cond2 == true) {\n+            return p.x + 50;\n+        } else {\n+            return -1;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \"2\" })\n+    int testIfElseInLoop() {\n+        int res = 0;\n+\n+        for (int i=1; i<1000; i++) {\n+            Point obj = new Point(i, i);\n+\n+            if (i % 2 == 1) {\n+                obj = new Point(i, i+1);\n+            } else {\n+                obj = new Point(i-1, i);\n+            }\n+\n+            res += obj.x;\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"2\" })\n+    int testLoadInCondAfterMerge(boolean cond, int x, int y) {\n+        Point p = new Point(x, y);\n+\n+        if (cond) {\n+            p = new Point(y, x);\n+        }\n+\n+        if (p.x == 10) {\n+            if (p.y == 10) {\n+                return dummy(10);\n+            } else {\n+                return dummy(20);\n+            }\n+        } else if (p.x == 20) {\n+            if (p.y == 20) {\n+                return dummy(30);\n+            } else {\n+                return dummy(40);\n+            }\n+        }\n+\n+        return 1984;\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"2\" })\n+    int testLoadInLoop(boolean cond, int x, int y) {\n+        Point obj1 = new Point(x, y);\n+        Point obj2 = new Point(y, x);\n+        Point obj = null;\n+        int res = 0;\n+\n+        if (cond) {\n+            obj = obj1;\n+        } else {\n+            obj = obj2;\n+        }\n+\n+        for (int i = 0; i < 532; i++) {\n+            res += obj.x;\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"3\" })\n+    int testMergesAndMixedEscape(boolean cond, int x, int y) {\n+        Point p1 = new Point(x, y);\n+        Point p2 = new Point(x, y);\n+        int val  = 0;\n+\n+        if (cond) {\n+            p1 = new Point(x+1, y+1);\n+            val = dummy(p2);\n+        }\n+\n+        return val + p1.x + p2.y;\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"0\" })\n+    \/\/ all allocations will be dead\n+    int testPartialPhis(boolean cond, int l, int x, int y) {\n+        int k = l;\n+\n+        if (l == 0) {\n+            k = l + 1;\n+        } else if (l == 2) {\n+            k = l + 2;\n+        } else if (l == 3) {\n+            new Point(x, y);\n+        } else if (l == 4) {\n+            new Point(y, x);\n+        }\n+\n+        return k;\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"2\" })\n+    int testPollutedNoWrite(boolean cond, int l) {\n+        Shape obj1 = new Square(l);\n+        Shape obj2 = new Square(l);\n+        Shape obj = null;\n+        int res = 0;\n+\n+        if (cond) {\n+            obj = obj1;\n+        } else {\n+            obj = obj2;\n+        }\n+\n+        for (int i=1; i<132; i++) {\n+            res += obj.x;\n+        }\n+\n+        return res + obj1.x + obj2.y;\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"2\" })\n+    \/\/ just 2 allocations because initial p3 will always be dead\n+    int testThreeWayAliasedAlloc(boolean cond, int x, int y) {\n+        Point p1 = new Point(x, y);\n+        Point p2 = new Point(x+1, y+1);\n+        Point p3 = new Point(x+2, y+2);\n+\n+        if (cond) {\n+            p3 = p1;\n+        } else {\n+            p3 = p2;\n+        }\n+\n+        return p3.x + p3.y;\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"2\" })\n+    int TestTrapAfterMerge(boolean cond, int x, int y) {\n+        Point p = new Point(x, x);\n+\n+        if (cond) {\n+            p = new Point(y, y);\n+        }\n+\n+        for (int i=402; i<432; i+=x) {\n+            x++;\n+        }\n+\n+        return p.x + x;\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"2\" })\n+    int testMergedWithDeadCode(boolean cond, int x) {\n+        ADefaults obj1 = new ADefaults(x);\n+        ADefaults obj2 = new ADefaults();\n+        ADefaults obj = cond ? obj1 : obj2;\n+\n+        return obj1.i + obj.ble + 1082;\n+    }\n+\n+\n+    \/\/ ------------------ Utility for Testing ------------------- \/\/\n+\n+    @DontCompile\n+    static void dummy() {\n+    }\n+\n+    @DontCompile\n+    static int dummy(Point p) {\n+        return p.x * p.y;\n+    }\n+\n+    @DontCompile\n+    static int dummy(int x) {\n+        return x;\n+    }\n+\n+    @DontCompile\n+    static Point dummy(int x, int y) {\n+        return new Point(x, y);\n+    }\n+\n+    @DontCompile\n+    static ADefaults dummy_defaults() {\n+        return new ADefaults();\n+    }\n+\n+    static class Point {\n+        int x, y;\n+        Point(int x, int y) {\n+            this.x = x;\n+            this.y = y;\n+        }\n+    }\n+\n+    class Shape {\n+        int x, y, l;\n+        Shape(int x, int y) {\n+            this.x = x;\n+            this.y = y;\n+        }\n+    }\n+\n+    class Square extends Shape {\n+        Square(int l) {\n+            super(0, 0);\n+            this.l = l;\n+        }\n+    }\n+\n+    class Circle extends Shape {\n+        Circle(int l) {\n+            super(0, 0);\n+            this.l = l;\n+        }\n+    }\n+\n+   static class ADefaults {\n+        static int ble;\n+        int i;\n+        @DontCompile\n+        ADefaults(int i) { this.i = i; }\n+        @DontCompile\n+        ADefaults() { }\n+    }\n+\n+    static class Picture {\n+        public int id;\n+        public Point position;\n+\n+        public Picture(int id, int x, int y) {\n+            this.id = id;\n+            this.position = new Point(x, y);\n+        }\n+    }\n+\n+    static class PicturePositions {\n+        public int id;\n+        public Point[] positions;\n+\n+        public PicturePositions(int id, int x, int y) {\n+            this.id = id;\n+            this.positions = new Point[] { new Point(x, y), new Point(y, x) };\n+        }\n+    }\n+\n+    class Root {\n+        public int a;\n+        public int b;\n+        public int c;\n+        public int d;\n+        public int e;\n+\n+        public Root(int a, int b, int c, int d, int e) {\n+            this.a = a;\n+            this.b = b;\n+            this.c = c;\n+            this.d = d;\n+            this.e = e;\n+        }\n+    }\n+\n+    class Usr extends Root {\n+        public float flt;\n+\n+        public Usr(float a, float b, float c) {\n+            super((int)a, (int)b, (int)c, 0, 0);\n+            this.flt = a;\n+        }\n+    }\n+\n+    class Home extends Root {\n+        public double[] arr;\n+\n+        public Home(double a, double b) {\n+            super((int)a, (int)b, 0, 0, 0);\n+            this.arr = new double[] {a, b};\n+        }\n+\n+    }\n+\n+    class Tmp extends Root {\n+        public String s;\n+\n+        public Tmp(String s) {\n+            super((int)s.length(), 0, 0, 0, 0);\n+            this.s = s;\n+        }\n+    }\n+\n+    class Etc extends Root {\n+        public String a;\n+\n+        public Etc(String s) {\n+            super((int)s.length(), 0, 0, 0, 0);\n+            this.a = s;\n+        }\n+    }\n+\n+    class A { }\n+    class B { }\n+    class C { }\n+    class D { }\n+    class E { }\n+    class F { }\n+    class G { }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/scalarReplacement\/AllocationMergesTests.java","additions":932,"deletions":0,"binary":false,"changes":932,"status":"added"}]}