{"files":[{"patch":"@@ -94,4 +94,19 @@\n-  for (nmethodBucket* b = dependencies_not_unloading(); b != nullptr; b = b->next_not_unloading()) {\n-    if (nm == b->get_nmethod()) {\n-      return;\n-    }\n+  assert(nm->is_not_installed(), \"Precondition: new nmethod\");\n+\n+  \/\/ This method tries to add never before seen nmethod, holding the CodeCache_lock\n+  \/\/ until all dependencies are added. The caller code can call multiple times\n+  \/\/ with the same nmethod, but always under the same lock hold.\n+  \/\/\n+  \/\/ This means the buckets list is guaranteed to be in either of two states, with\n+  \/\/ regards to the newly added nmethod:\n+  \/\/   1. The nmethod is not in the list, and can be just added to the head of the list.\n+  \/\/   2. The nmethod is in the list, and it is already at the head of the list.\n+  \/\/\n+  \/\/ This path is the only path that adds to the list. There can be concurrent removals\n+  \/\/ from the list, but they do not break this invariant. This invariant allows us\n+  \/\/ to skip list scans. The individual method checks are cheap, but walking the large\n+  \/\/ list of dependencies gets expensive.\n+\n+  nmethodBucket* head = Atomic::load(_dependency_context_addr);\n+  if (head != nullptr && nm == head->get_nmethod()) {\n+    return;\n@@ -99,0 +114,7 @@\n+\n+#ifdef ASSERT\n+  for (nmethodBucket* b = head; b != nullptr; b = b->next()) {\n+    assert(nm != b->get_nmethod(), \"Invariant: should not be in the list yet\");\n+  }\n+#endif\n+\n@@ -101,1 +123,0 @@\n-    nmethodBucket* head = Atomic::load(_dependency_context_addr);\n@@ -106,0 +127,1 @@\n+    head = Atomic::load(_dependency_context_addr);\n","filename":"src\/hotspot\/share\/code\/dependencyContext.cpp","additions":27,"deletions":5,"binary":false,"changes":32,"status":"modified"}]}