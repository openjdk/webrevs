{"files":[{"patch":"@@ -5375,0 +5375,1 @@\n+\/\/ Collects all the control inputs from nodes on the worklist and from their data dependencies\n@@ -5381,7 +5382,6 @@\n-      if (in != nullptr && !in->is_Root()) {\n-        if (in->is_CFG()) {\n-          if (in->is_Multi()) {\n-            candidates.push(in->as_Multi()->proj_out(TypeFunc::Control));\n-          } else {\n-            candidates.push(in);\n-          }\n+      if (in == nullptr || in->is_Root()) {\n+        continue;\n+      }\n+      if (in->is_CFG()) {\n+        if (in->is_Multi()) {\n+          candidates.push(in->as_Multi()->proj_out(TypeFunc::Control));\n@@ -5389,1 +5389,1 @@\n-          worklist.push(in);\n+          candidates.push(in);\n@@ -5391,0 +5391,2 @@\n+      } else {\n+        worklist.push(in);\n@@ -5396,8 +5398,4 @@\n-\/\/ Returns a candidate node whose CFG predecessors cover all other candidates\n-static Node* pick_control(const Unique_Node_List& candidates) {\n-  const uint num_candidates = candidates.size();\n-  for (uint i = 0; i < num_candidates; i++) {\n-    Node* candidate = candidates.at(i);\n-    uint matching_predecessors = 0;\n-    Unique_Node_List worklist;\n-    worklist.push(candidate);\n+\/\/ Returns the candidate node that is a descendant to all the other candidates\n+static Node* pick_control(Unique_Node_List& candidates) {\n+  Unique_Node_List worklist;\n+  worklist.copy(candidates);\n@@ -5405,4 +5403,9 @@\n-    \/\/ Traverse backwards through the CFG\n-    for (uint j = 0; j < worklist.size(); j++) {\n-      Node* n = worklist.at(j);\n-      if (n->is_Root()) {\n+  \/\/ Traverse backwards through the CFG\n+  for (uint i = 0; i < worklist.size(); i++) {\n+    const Node* n = worklist.at(i);\n+    if (n->is_Root()) {\n+      continue;\n+    }\n+    for (uint j = 0; j < n->req(); j++) {\n+      \/\/ Skip backedge of loops to avoid cycles\n+      if (n->is_Loop() && j == LoopNode::LoopBackControl) {\n@@ -5411,13 +5414,0 @@\n-      for (uint k = 0; k < n->req(); k++) {\n-        Node* pred = n->in(k);\n-        if (pred == nullptr) {\n-          continue;\n-        }\n-        \/\/ Skip backedge of loops to avoid cycles\n-        if (n->is_Loop() && k == LoopNode::LoopBackControl) {\n-          continue;\n-        }\n-        \/\/ Count candidates that we have encountered\n-        if (candidates.member(pred) && !worklist.member(pred)) {\n-          matching_predecessors++;\n-        }\n@@ -5425,3 +5415,5 @@\n-        if (pred->is_CFG()) {\n-          worklist.push(pred);\n-        }\n+      Node* pred = n->in(j);\n+      if (pred != nullptr && pred != n && pred->is_CFG()) {\n+        worklist.push(pred);\n+        \/\/ if pred is an ancestor of n, then pred is an ancestor to at least one candidate\n+        candidates.remove(pred);\n@@ -5430,3 +5422,0 @@\n-    if (matching_predecessors == num_candidates - 1) {\n-      return candidate;\n-    }\n@@ -5434,2 +5423,3 @@\n-  ShouldNotReachHere();\n-  return nullptr;\n+\n+  assert(candidates.size() == 1, \"unexpected control flow\");\n+  return candidates.at(0);\n@@ -5438,1 +5428,2 @@\n-static void debug_init_req(Node* call, Node* parm, Node* half, int* pos) {\n+\/\/ Initialize a parameter input for a debug print call, using a placeholder for jlong and jdouble\n+static void debug_print_init_parm(Node* call, Node* parm, Node* half, int* pos) {\n@@ -5465,1 +5456,0 @@\n-\n@@ -5474,1 +5464,8 @@\n-  Node* frame_ptr = C->start()->proj_out(TypeFunc::FramePtr);\n+  \/\/ find all the previous users of the control we picked\n+  GrowableArray<Node*> users_of_control;\n+  for (DUIterator_Fast kmax, i = control->fast_outs(kmax); i < kmax; i++) {\n+    Node* use = control->fast_out(i);\n+    if (use->is_CFG() && use != control) {\n+      users_of_control.push(use);\n+    }\n+  }\n@@ -5480,1 +5477,1 @@\n-  call->init_req(TypeFunc::FramePtr,  frame_ptr);\n+  call->init_req(TypeFunc::FramePtr,  C->start()->proj_out(TypeFunc::FramePtr));\n@@ -5485,7 +5482,7 @@\n-  if (parm0 != nullptr) { debug_init_req(call, parm0, top(), &pos);\n-  if (parm1 != nullptr) { debug_init_req(call, parm1, top(), &pos);\n-  if (parm2 != nullptr) { debug_init_req(call, parm2, top(), &pos);\n-  if (parm3 != nullptr) { debug_init_req(call, parm3, top(), &pos);\n-  if (parm4 != nullptr) { debug_init_req(call, parm4, top(), &pos);\n-  if (parm5 != nullptr) { debug_init_req(call, parm5, top(), &pos);\n-  if (parm6 != nullptr) { debug_init_req(call, parm6, top(), &pos);\n+  if (parm0 != nullptr) { debug_print_init_parm(call, parm0, top(), &pos);\n+  if (parm1 != nullptr) { debug_print_init_parm(call, parm1, top(), &pos);\n+  if (parm2 != nullptr) { debug_print_init_parm(call, parm2, top(), &pos);\n+  if (parm3 != nullptr) { debug_print_init_parm(call, parm3, top(), &pos);\n+  if (parm4 != nullptr) { debug_print_init_parm(call, parm4, top(), &pos);\n+  if (parm5 != nullptr) { debug_print_init_parm(call, parm5, top(), &pos);\n+  if (parm6 != nullptr) { debug_print_init_parm(call, parm6, top(), &pos);\n@@ -5498,8 +5495,1 @@\n-  GrowableArray<Node*> users_of_control;\n-  for (DUIterator_Fast kmax, k = control->fast_outs(kmax); k < kmax; k++) {\n-    Node* use = control->fast_out(k);\n-    if (use->is_CFG() && use != control && use != call) {\n-      users_of_control.push(use);\n-    }\n-  }\n-\n+  \/\/ rewire previous users to have the new call as control instead\n@@ -5507,2 +5497,2 @@\n-  for (int k = 0; k < users_of_control.length(); k++) {\n-    Node* use = users_of_control.at(k);\n+  for (int i = 0; i < users_of_control.length(); i++) {\n+    Node* use = users_of_control.at(i);\n@@ -5510,3 +5500,2 @@\n-      Node* def = use->in(j);\n-      if (def == control) {\n-        if (igvn != nullptr) {\n+      if (use->in(j) == control) {\n+        if (igvn) {\n@@ -5514,1 +5503,1 @@\n-        } else if (gvn != nullptr) {\n+        } else {\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":55,"deletions":66,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -1320,0 +1320,1 @@\n+  \/\/ getting rid of the template makes things easier\n@@ -1327,1 +1328,5 @@\n-  \/\/ Creates a CallLeafNode that prints a static string and the values of the nodes passed as arguments\n+  \/\/ Creates a CallLeafNode for a runtime call that prints a static string and the values of the\n+  \/\/ nodes passed as arguments.\n+  \/\/ This function also takes care of doing the necessary wiring, including finding a suitable control\n+  \/\/ based on the nodes that need to be printed. Note that passing nodes that have incompatible controls\n+  \/\/ is undefined behavior.\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"}]}