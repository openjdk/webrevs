{"files":[{"patch":"@@ -5346,0 +5346,137 @@\n+\n+#ifndef PRODUCT\n+static void find_candidate_control_inputs(Unique_Node_List& worklist, Unique_Node_List& candidates) {\n+  \/\/ Follow non-control edges until we reach CFG nodes\n+  for (uint i = 0; i < worklist.size(); i++) {\n+    const Node* n = worklist.at(i);\n+    for (uint j = 0; j < n->req(); j++) {\n+      Node* in = n->in(j);\n+      if (in != nullptr) {\n+        if (in->is_CFG()) {\n+          if (in->is_Multi()) {\n+            candidates.push(in->as_Multi()->proj_out(TypeFunc::Control));\n+          } else {\n+            candidates.push(in);\n+          }\n+        } else {\n+          worklist.push(in);\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ Returns a candidate node whose CFG predecessors cover all other candidates\n+static Node* pick_control(const Unique_Node_List& candidates) {\n+  const uint num_candidates = candidates.size();\n+  for (uint i = 0; i < num_candidates; i++) {\n+    Node* candidate = candidates.at(i);\n+    uint matching_predecessors = 0;\n+    Unique_Node_List worklist;\n+    worklist.push(candidate);\n+\n+    \/\/ Traverse backwards through the CFG\n+    for (uint j = 0; j < worklist.size(); j++) {\n+      Node* n = worklist.at(j);\n+      if (n->is_Root()) {\n+        continue;\n+      }\n+      for (uint k = 0; k < n->req(); k++) {\n+        Node* pred = n->in(k);\n+        if (pred == nullptr) {\n+          continue;\n+        }\n+        \/\/ Skip backedge of loops to avoid cycles\n+        if (n->is_Loop() && k == LoopNode::LoopBackControl) {\n+          continue;\n+        }\n+        \/\/ Count candidates that we have encountered\n+        if (candidates.member(pred) && !worklist.member(pred)) {\n+          matching_predecessors++;\n+        }\n+\n+        if (pred->is_CFG()) {\n+          worklist.push(pred);\n+        }\n+      }\n+    }\n+    if (matching_predecessors == num_candidates - 1) {\n+      return candidate;\n+    }\n+  }\n+  ShouldNotReachHere();\n+  return nullptr;\n+}\n+\n+Node* Compile::make_debug_print_call(const char* str, address call_addr, PhaseGVN* gvn,\n+                              Node* parm0, Node* parm1,\n+                              Node* parm2, Node* parm3,\n+                              Node* parm4, Node* parm5,\n+                              Node* parm6) const {\n+  Node* str_node = gvn->transform(new ConPNode(TypeRawPtr::make(((address) str))));\n+  const TypeFunc* type = OptoRuntime::debug_print_Type(parm0, parm1, parm2, parm3, parm4, parm5, parm6);\n+  Node *call = new CallLeafNode(type, call_addr, \"debug_print\", TypeRawPtr::BOTTOM);\n+\n+  \/\/ find the most suitable control input\n+  Unique_Node_List worklist, candidates;\n+  if (parm0 != nullptr) { worklist.push(parm0);\n+  if (parm1 != nullptr) { worklist.push(parm1);\n+  if (parm2 != nullptr) { worklist.push(parm2);\n+  if (parm3 != nullptr) { worklist.push(parm3);\n+  if (parm4 != nullptr) { worklist.push(parm4);\n+  if (parm5 != nullptr) { worklist.push(parm5);\n+  if (parm6 != nullptr) { worklist.push(parm6);\n+  \/* close each nested if ===> *\/  } } } } } } }\n+\n+  find_candidate_control_inputs(worklist, candidates);\n+  Node* control = pick_control(candidates);\n+\n+  Node* frame_ptr = C->start()->proj_out(TypeFunc::FramePtr);\n+\n+  \/\/ we do not actually care about IO and memory as it uses neither\n+  call->init_req(TypeFunc::Control,   control);\n+  call->init_req(TypeFunc::I_O,       top());\n+  call->init_req(TypeFunc::Memory,    top());\n+  call->init_req(TypeFunc::FramePtr,  frame_ptr);\n+  call->init_req(TypeFunc::ReturnAdr, top());\n+\n+  call->init_req(TypeFunc::Parms+0, str_node);\n+  if (parm0 != nullptr) { call->init_req(TypeFunc::Parms+1, parm0);\n+  if (parm1 != nullptr) { call->init_req(TypeFunc::Parms+2, parm1);\n+  if (parm2 != nullptr) { call->init_req(TypeFunc::Parms+3, parm2);\n+  if (parm3 != nullptr) { call->init_req(TypeFunc::Parms+4, parm3);\n+  if (parm4 != nullptr) { call->init_req(TypeFunc::Parms+5, parm4);\n+  if (parm5 != nullptr) { call->init_req(TypeFunc::Parms+6, parm5);\n+  if (parm6 != nullptr) { call->init_req(TypeFunc::Parms+7, parm6);\n+  \/* close each nested if ===> *\/  } } } } } } }\n+  assert(call->in(call->req()-1) != nullptr, \"must initialize all parms\");\n+\n+  call = gvn->transform(call);\n+  Node* call_control_proj = gvn->transform(new ProjNode(call, TypeFunc::Control));\n+\n+  GrowableArray<Node*> users_of_control;\n+  for (DUIterator_Fast kmax, k = control->fast_outs(kmax); k < kmax; k++) {\n+    Node* use = control->fast_out(k);\n+    if (use->is_CFG() && use != control && use != call) {\n+      users_of_control.push(use);\n+    }\n+  }\n+\n+  PhaseIterGVN* igvn = gvn->is_IterGVN();\n+  for (int k = 0; k < users_of_control.length(); k++) {\n+    Node* use = users_of_control.at(k);\n+    for (uint j = 0; j < use->req(); j++) {\n+      Node* def = use->in(j);\n+      if (def == control) {\n+        if (igvn != nullptr) {\n+          igvn->replace_input_of(use, j, call_control_proj);\n+        } else if (gvn != nullptr) {\n+          use->set_req(j, call_control_proj);\n+        }\n+      }\n+    }\n+  }\n+\n+  return call;\n+}\n+#endif \/\/ !PRODUCT\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":137,"deletions":0,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -1317,0 +1317,17 @@\n+\n+#ifndef PRODUCT\n+private:\n+  Node* make_debug_print_call(const char* str, address call_addr, PhaseGVN* gvn,\n+                              Node* parm0 = nullptr, Node* parm1 = nullptr,\n+                              Node* parm2 = nullptr, Node* parm3 = nullptr,\n+                              Node* parm4 = nullptr, Node* parm5 = nullptr,\n+                              Node* parm6 = nullptr) const;\n+\n+public:\n+  \/\/ Creates a CallLeafNode that prints a static string and the values of the nodes passed as arguments\n+  template <typename... TT, typename... NN>\n+  Node* make_debug_print(const char* str, PhaseGVN* gvn, NN... in) {\n+    address call_addr = CAST_FROM_FN_PTR(address, SharedRuntime::debug_print<TT...>);\n+    return make_debug_print_call(str, call_addr, gvn, in...);\n+  }\n+#endif\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1783,0 +1783,49 @@\n+#ifndef PRODUCT\n+void OptoRuntime::debug_print_convert_type(const Type** fields, int* argp, Node *parm) {\n+  const Type *type = Type::get_const_basic_type(parm->bottom_type()->basic_type());\n+  if (type == TypePtr::NULL_PTR) { \/\/ half of long and double\n+    fields[(*argp)++] = Type::HALF;\n+  } else {\n+    fields[(*argp)++] = type;\n+  }\n+}\n+\n+const TypeFunc* OptoRuntime::debug_print_Type(Node* parm0, Node* parm1,\n+                                        Node* parm2, Node* parm3,\n+                                        Node* parm4, Node* parm5,\n+                                        Node* parm6) {\n+  int argcnt = 1;\n+  if (parm0 != nullptr) { argcnt++;\n+  if (parm1 != nullptr) { argcnt++;\n+  if (parm2 != nullptr) { argcnt++;\n+  if (parm3 != nullptr) { argcnt++;\n+  if (parm4 != nullptr) { argcnt++;\n+  if (parm5 != nullptr) { argcnt++;\n+  if (parm6 != nullptr) { argcnt++;\n+  \/* close each nested if ===> *\/  } } } } } } }\n+\n+  \/\/ create input type (domain)\n+  const Type** fields = TypeTuple::fields(argcnt);\n+  int argp = TypeFunc::Parms;\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ static string pointer\n+\n+  if (parm0 != nullptr) { debug_print_convert_type(fields, &argp, parm0);\n+  if (parm1 != nullptr) { debug_print_convert_type(fields, &argp, parm1);\n+  if (parm2 != nullptr) { debug_print_convert_type(fields, &argp, parm2);\n+  if (parm3 != nullptr) { debug_print_convert_type(fields, &argp, parm3);\n+  if (parm4 != nullptr) { debug_print_convert_type(fields, &argp, parm4);\n+  if (parm5 != nullptr) { debug_print_convert_type(fields, &argp, parm5);\n+  if (parm6 != nullptr) { debug_print_convert_type(fields, &argp, parm6);\n+  \/* close each nested if ===> *\/  } } } } } } }\n+\n+  assert(argp == TypeFunc::Parms+argcnt, \"correct decoding\");\n+  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);\n+\n+  \/\/ no result type needed\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);\n+  return TypeFunc::make(domain, range);\n+}\n+#endif \/\/ PRODUCT\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -740,0 +740,14 @@\n+#ifndef PRODUCT\n+  private:\n+  static void debug_print_convert_type(const Type** fields, int* argp, Node *parm);\n+\n+  public:\n+  \/\/ Signature for runtime calls in debug printing nodes, which depends on which nodes are actually passed\n+  \/\/ Note: we do not allow more than 7 node arguments as GraphKit::make_runtime_call only allows 8, and we need\n+  \/\/ one for the static string\n+  static const TypeFunc* debug_print_Type(Node* parm0 = nullptr, Node* parm1 = nullptr,\n+                                          Node* parm2 = nullptr, Node* parm3 = nullptr,\n+                                          Node* parm4 = nullptr, Node* parm5 = nullptr,\n+                                          Node* parm6 = nullptr);\n+#endif \/\/ PRODUCT\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -267,0 +267,38 @@\n+\n+\/\/ Runtime methods for printf-style debug nodes (same printing format as fieldDescriptor::print_on_for)\n+void SharedRuntime::debug_print_value(jboolean x) {\n+  tty->print_cr(\"boolean %d\", x);\n+}\n+\n+void SharedRuntime::debug_print_value(jbyte x) {\n+  tty->print_cr(\"byte %d\", x);\n+}\n+\n+void SharedRuntime::debug_print_value(jshort x) {\n+  tty->print_cr(\"short %d\", x);\n+}\n+\n+void SharedRuntime::debug_print_value(jchar x) {\n+  tty->print_cr(\"char %c %d\", isprint(x) ? x : ' ', x);\n+}\n+\n+void SharedRuntime::debug_print_value(jint x) {\n+  tty->print_cr(\"int %d\", x);\n+}\n+\n+void SharedRuntime::debug_print_value(jlong x) {\n+  tty->print_cr(\"long \" JLONG_FORMAT, x);\n+}\n+\n+void SharedRuntime::debug_print_value(jfloat x) {\n+  tty->print_cr(\"float %f\", x);\n+}\n+\n+void SharedRuntime::debug_print_value(jdouble x) {\n+  tty->print_cr(\"double %lf\", x);\n+}\n+\n+void SharedRuntime::debug_print_value(oopDesc* x) {\n+  x->print();\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"runtime\/safepointVerifiers.hpp\"\n@@ -641,0 +642,31 @@\n+  \/\/ Runtime methods for printf-style debug nodes\n+  static void debug_print_value(jboolean x);\n+  static void debug_print_value(jbyte x);\n+  static void debug_print_value(jshort x);\n+  static void debug_print_value(jchar x);\n+  static void debug_print_value(jint x);\n+  static void debug_print_value(jlong x);\n+  static void debug_print_value(jfloat x);\n+  static void debug_print_value(jdouble x);\n+  static void debug_print_value(oopDesc* x);\n+\n+  template <typename T, typename... Rest>\n+  static void debug_print_rec(T arg, Rest... args) {\n+    debug_print_value(arg);\n+    debug_print_rec(args...);\n+  }\n+\n+  static void debug_print_rec() {}\n+\n+  \/\/ template is required here as we need to know the exact signature at compile-time\n+  template <typename... TT>\n+  static void debug_print(const char *str, TT... args) {\n+    \/\/ these three lines are the manual expansion of JRT_LEAF ... JRT_END, does not work well with templates\n+    DEBUG_ONLY(NoHandleMark __hm;)\n+    os::verify_stack_alignment();\n+    DEBUG_ONLY(NoSafepointVerifier __nsv;)\n+\n+    tty->print(\"%s\\n\", str);\n+    debug_print_rec(args...);\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"}]}