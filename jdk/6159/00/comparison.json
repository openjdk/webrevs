{"files":[{"patch":"@@ -1649,0 +1649,3 @@\n+  \/\/ The very first entry is the InstanceKlass of the root method of the current compilation in order to get the right\n+  \/\/ protection domain to load subsequent classes during replay compilation.\n+  out->print_cr(\"instanceKlass %s\", CURRENT_ENV->replay_name(task()->method()->method_holder()));\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -871,0 +871,6 @@\n+    if (_protection_domain() == NULL) {\n+      \/\/ The first entry is the holder class of the method for which a replay compilation is requested.\n+      \/\/ Use the same protection domain to load all subsequent classes in order to resolve all classes\n+      \/\/ in signatures of inlinees. This ensures that inlining can be done as stated in the replay file.\n+      _protection_domain = Handle(_thread, k->protection_domain());\n+    }\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-        \"-XX:+ReplayCompiles\", REPLAY_FILE_OPTION};\n+        \"-XX:+ReplayCompiles\"};\n@@ -149,1 +149,1 @@\n-    public static void cleanup() {\n+    public void cleanup() {\n@@ -157,0 +157,4 @@\n+    public String getReplayFileName() {\n+        return REPLAY_FILE_NAME;\n+    }\n+\n@@ -167,1 +171,1 @@\n-                options.add(\"-XX:CompileOnly='\" + getTestClass() + \"::test'\");\n+                options.add(\"-XX:CompileOnly='\" + getTestClass() + \"::\" + getTestMethod() + \"'\");\n@@ -173,1 +177,1 @@\n-                options.add(\"-XX:CompileOnly=\" + getTestClass() + \"::test\");\n+                options.add(\"-XX:CompileOnly=\" + getTestClass() + \"::\" + getTestMethod());\n@@ -201,0 +205,4 @@\n+    public String getTestMethod() {\n+        return \"test\";\n+    }\n+\n@@ -212,0 +220,1 @@\n+            allAdditionalOpts.add(\"-XX:ReplayDataFile=\" + getReplayFileName());\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/CiReplayBase.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.ciReplay;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+public abstract class DumpReplayBase extends CiReplayBase {\n+\n+    private static final String DUMP_REPLAY_PATTERN = \"replay_pid\";\n+    private List<File> replayFiles;\n+    private String replayFileName;\n+\n+    @Override\n+    public void runTest(boolean needCoreDump, String... args) {\n+        throw new RuntimeException(\"use runTests(String...)\");\n+    }\n+\n+    public void runTest(String... args) {\n+        if (generateReplay(args)) {\n+            testAction();\n+            cleanup();\n+        } else {\n+            throw new Error(\"Host is not configured to generate cores\");\n+        }\n+    }\n+\n+    @Override\n+    public void cleanup() {\n+        replayFiles.forEach(f -> remove(f.getName()));\n+    }\n+\n+    @Override\n+    public String getReplayFileName() {\n+        Asserts.assertEQ(replayFiles.size(), 1, \"Test should only dump 1 replay file when trying to replay compile\");\n+        return replayFileName;\n+    }\n+\n+    public boolean generateReplay(String... vmopts) {\n+        OutputAnalyzer oa;\n+        try {\n+            List<String> options = new ArrayList<>(Arrays.asList(vmopts));\n+            options.add(\"-XX:CompileCommand=option,\" + getTestClass() + \"::\" + getTestMethod() + \",bool,DumpReplay,true\");\n+            options.add(\"-XX:+IgnoreUnrecognizedVMOptions\");\n+            options.add(\"-XX:TypeProfileLevel=222\");\n+            options.add(\"-XX:CompileCommand=compileonly,\" + getTestClass() + \"::\" + getTestMethod());\n+            options.add(\"-Xbatch\");\n+            options.add(getTestClass());\n+            oa = ProcessTools.executeProcess(ProcessTools.createTestJvm(options));\n+            Asserts.assertEquals(oa.getExitValue(), 0, \"Crash JVM exits gracefully\");\n+            replayFiles = Files.list(Paths.get(\".\"))\n+                                    .map(Path::toFile)\n+                                    .filter(f -> f.getName().startsWith(DUMP_REPLAY_PATTERN)).collect(Collectors.toList());\n+            Asserts.assertFalse(replayFiles.isEmpty(), \"Did not find a replay file starting with \" + DUMP_REPLAY_PATTERN);\n+            replayFileName = replayFiles.get(0).getName();\n+        } catch (Throwable t) {\n+            throw new Error(\"Can't create replay: \" + t, t);\n+        }\n+        return true;\n+    }\n+\n+    public int getCompileIdFromFile(String replayFileName) {\n+        Pattern p = Pattern.compile(\"replay_pid.*_compid([0-9]+)\\\\.log\");\n+        Matcher matcher = p.matcher(replayFileName);\n+        if (matcher.find()) {\n+            try {\n+                return Integer.parseInt(matcher.group(1));\n+            } catch (NumberFormatException e) {\n+                throw new RuntimeException(\"Could not parse compile id from filename \\\"\" + replayFileName + \"\\\"\");\n+            }\n+        } else {\n+            throw new RuntimeException(\"Could not find compile id in filename \\\"\" + replayFileName + \"\\\"\");\n+        }\n+    }\n+\n+    public List<File> getReplayFiles() {\n+        return replayFiles;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/DumpReplayBase.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,304 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8275868\n+ * @library \/ \/test\/lib\n+ * @summary Testing that ciReplay inlining does not fail with unresolved signature classes.\n+ * @requires vm.flightRecorder != true & vm.compMode != \"Xint\" & vm.compMode != \"Xcomp\" & vm.debug == true & vm.compiler2.enabled\n+ * @modules java.base\/jdk.internal.misc\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      compiler.ciReplay.TestInliningProtectionDomain\n+ *\/\n+\n+package compiler.ciReplay;\n+\n+import jdk.test.lib.Asserts;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class TestInliningProtectionDomain extends DumpReplayBase {\n+    public static final String LOG_FILE_NORMAL = \"hotspot_normal.log\";\n+    public static final String LOG_FILE_REPLAY = \"hotspot_replay.log\";\n+    private final String[] commandLineReplay;\n+\n+    private final String className;\n+\n+    public static void main(String[] args) {\n+        new TestInliningProtectionDomain(\"ProtectionDomainTestCompiledBefore\", true);\n+        new TestInliningProtectionDomain(\"ProtectionDomainTestNoOtherCompilationPublic\", false);\n+        new TestInliningProtectionDomain(\"ProtectionDomainTestNoOtherCompilationPrivate\", false);\n+        new TestInliningProtectionDomain(\"ProtectionDomainTestNoOtherCompilationPrivateString\", false);\n+    }\n+\n+    public TestInliningProtectionDomain(String className, boolean compileBar) {\n+        this.className = className;\n+        List<String> commandLineNormal = new ArrayList<>(List.of(\"-XX:LogFile=\" + LOG_FILE_NORMAL + \"\", \"-XX:+LogCompilation\", \"-XX:-TieredCompilation\",\n+                                                           \"-XX:CompileCommand=exclude,\" + getTestClass() + \"::main\",\n+                                                           \"-XX:CompileCommand=option,\" + getTestClass()  + \"::test,bool,PrintInlining,true\"));\n+        if (compileBar) {\n+            commandLineNormal.add(\"-XX:CompileCommand=compileonly,\" + getTestClass() + \"::bar\");\n+        }\n+        commandLineReplay = new String[]\n+                {\"-XX:LogFile=\" + LOG_FILE_REPLAY + \"\", \"-XX:+LogCompilation\",\n+                 \"-XX:CompileCommand=option,\" + getTestClass()  + \"::test,bool,PrintInlining,true\"};\n+        runTest(commandLineNormal.toArray(new String[0]));\n+    }\n+\n+    @Override\n+    public void testAction() {\n+        positiveTest(commandLineReplay);\n+        String klass = \"compiler.ciReplay.\" + className;\n+        String entryString = klass + \" \" + \"test\";\n+        boolean inlineFails = className.equals(\"ProtectionDomainTestNoOtherCompilationPrivate\");\n+        int inlineeCount = inlineFails ? 1 : 5;\n+\n+        List<Entry> inlineesNormal = parseLogFile(LOG_FILE_NORMAL, entryString, \"compile_id='\" + getCompileIdFromFile(getReplayFileName()), inlineeCount);\n+        List<Entry> inlineesReplay = parseLogFile(LOG_FILE_REPLAY, entryString, \"test ()V\", inlineeCount);\n+        verifyLists(inlineesNormal, inlineesReplay, inlineeCount);\n+\n+        if (inlineFails) {\n+            Asserts.assertTrue(compare(inlineesNormal.get(0), \"compiler.ciReplay.ProtectionDomainTestNoOtherCompilationPrivate\",\n+                                       \"bar\", inlineesNormal.get(0).isUnloadedSignatureClasses()));\n+            Asserts.assertTrue(compare(inlineesReplay.get(0), \"compiler.ciReplay.ProtectionDomainTestNoOtherCompilationPrivate\",\n+                                       \"bar\", inlineesReplay.get(0).isDisallowedByReplay()));\n+        } else {\n+            Asserts.assertTrue(compare(inlineesNormal.get(4), \"compiler.ciReplay.InliningBar\", \"bar2\", inlineesNormal.get(4).isNormalInline()));\n+            Asserts.assertTrue(compare(inlineesReplay.get(4), \"compiler.ciReplay.InliningBar\", \"bar2\", inlineesReplay.get(4).isForcedByReplay()));\n+        }\n+        remove(LOG_FILE_NORMAL);\n+        remove(LOG_FILE_REPLAY);\n+    }\n+\n+    private void verifyLists(List<Entry> inlineesNormal, List<Entry> inlineesReplay, int expectedSize) {\n+        if (!inlineesNormal.equals(inlineesReplay)) {\n+            System.err.println(\"Normal entries:\");\n+            inlineesNormal.forEach(System.err::println);\n+            System.err.println(\"Replay entries:\");\n+            inlineesReplay.forEach(System.err::println);\n+            Asserts.fail(\"different inlining decision in normal run vs. replay run\");\n+        }\n+        Asserts.assertEQ(expectedSize, inlineesNormal.size(), \"unexpected number of inlinees found\");\n+    }\n+\n+    public static boolean compare(Entry e, String klass, String method, boolean kind) {\n+        return e.klass.equals(klass) && e.method.equals(method) && kind;\n+    }\n+\n+    public static List<Entry> parseLogFile(String logFile, String rootMethod, String nmethodMatch, int inlineeCount) {\n+        String nmethodStart = \"<nmethod\";\n+        List<Entry> inlinees = new ArrayList<>();\n+        int foundLines = 0;\n+        try (var br = Files.newBufferedReader(Paths.get(logFile))) {\n+            String line;\n+            boolean nmethodLine = false;\n+            boolean inlinineLine = false;\n+            while ((line = br.readLine()) != null) {\n+                if (nmethodLine) {\n+                    \/\/ Ignore other entries which could be in between nmethod entry and inlining statements\n+                    if (line.startsWith(\"             \")) {\n+                        inlinineLine = true;\n+                        Pattern p = Pattern.compile(\"(\\\\S+)::(\\\\S+).*bytes\\\\)\\s+(.*)\");\n+                        Matcher matcher = p.matcher(line);\n+                        Asserts.assertTrue(matcher.find(), \"must find inlinee method\");\n+                        inlinees.add(new Entry(matcher.group(1), matcher.group(2), matcher.group(3).trim()));\n+                        foundLines++;\n+                    } else if (inlinineLine) {\n+                        Asserts.assertEQ(foundLines, inlineeCount, \"did not find all inlinees\");\n+                        return inlinees;\n+                    }\n+                } else {\n+                    nmethodLine = line.startsWith(nmethodStart) && line.contains(nmethodMatch);\n+                    if (nmethodLine) {\n+                        Asserts.assertTrue(line.contains(rootMethod), \"should only dump inline information for \" + rootMethod);\n+                    }\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new Error(\"Failed to read \" + logFile + \" data: \" + e, e);\n+        }\n+        Asserts.fail(\"Should have found inlinees\");\n+        return inlinees;\n+    }\n+\n+\n+    @Override\n+    public String getTestClass() {\n+        return \"compiler.ciReplay.\" + className;\n+    }\n+\n+    static class Entry {\n+        String klass;\n+        String method;\n+        String reason;\n+\n+        public Entry(String klass, String method, String reason) {\n+            this.klass = klass;\n+            this.method = method;\n+            this.reason = reason;\n+        }\n+\n+        public boolean isNormalInline() {\n+            return reason.equals(\"inline (hot)\");\n+        }\n+\n+        public boolean isForcedByReplay() {\n+            return reason.equals(\"force inline by ciReplay\");\n+        }\n+\n+        public boolean isDisallowedByReplay() {\n+            return reason.equals(\"disallowed by ciReplay\");\n+        }\n+\n+        public boolean isUnloadedSignatureClasses() {\n+            return reason.equals(\"unloaded signature classes\");\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            if (other == this) {\n+                return true;\n+            }\n+\n+            if (!(other instanceof Entry)) {\n+                return false;\n+            }\n+\n+            Entry e = (Entry)other;\n+            return klass.equals(e.klass) && method.equals(e.method);\n+        }\n+    }\n+}\n+\n+class ProtectionDomainTestCompiledBefore {\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 10000; i++) {\n+            bar(); \/\/ Ensure that bar() was compiled\n+        }\n+        for (int i = 0; i < 10000; i++) {\n+            test();\n+        }\n+    }\n+\n+    public static void test() {\n+        bar();\n+    }\n+\n+    \/\/ Integer should be resolved for the protection domain of this class because the separate compilation of bar() in\n+    \/\/ the normal run will resolve all classes in the signature. Inlining succeeds.\n+    private static Integer bar() {\n+        InliningFoo.foo();\n+        return null;\n+    }\n+}\n+\n+class ProtectionDomainTestNoOtherCompilationPublic {\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 10000; i++) {\n+            test();\n+        }\n+    }\n+\n+    public static void test() {\n+        bar(); \/\/ Not compiled before separately\n+    }\n+\n+    \/\/ Integer should be resolved for the protection domain of this class because getDeclaredMethods is called in normal run\n+    \/\/ when validating main() method. In this process, all public methods of this class are visited and its signature classes\n+    \/\/ are resolved. Inlining of bar() succeeds.\n+    public static Integer bar() {\n+        InliningFoo.foo();\n+        return null;\n+    }\n+}\n+\n+class ProtectionDomainTestNoOtherCompilationPrivate {\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 10000; i++) {\n+            test();\n+        }\n+    }\n+\n+    public static void test() {\n+        bar(); \/\/ Not compiled before separately\n+    }\n+\n+    \/\/ Integer should be unresolved for the protection domain of this class even though getDeclaredMethods is called in normal\n+    \/\/ run when validating main() method. In this process, only public methods of this class are visited and its signature\n+    \/\/ classes are resolved. Since this method is private, the signature classes are not resolved for this protection domain.\n+    \/\/ Inlining of bar() should fail in normal run with \"unresolved signature classes\". Therefore, replay compilation should\n+    \/\/ also not inline bar().\n+    private static Integer bar() {\n+        InliningFoo.foo();\n+        return null;\n+    }\n+}\n+\n+class ProtectionDomainTestNoOtherCompilationPrivateString {\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 10000; i++) {\n+            test();\n+        }\n+    }\n+\n+    public static void test() {\n+        bar(); \/\/ Not compiled before separately\n+    }\n+\n+    \/\/ Integer should be resovled for the protection domain of this class because getDeclaredMethods is called in normal run\n+    \/\/ when validating main() method. In this process, public methods of this class are visited and its signature classes\n+    \/\/ are resolved. bar() is private and not visited in this process (i.e. no resolution of String). But since main()\n+    \/\/ has String[] as parameter, the String class will be resolved for this protection domain. Inlining of bar() succeeds.\n+    private static String bar() {\n+        InliningFoo.foo();\n+        return null;\n+    }\n+}\n+\n+class InliningFoo {\n+    public static void foo() {\n+        foo2();\n+    }\n+\n+    private static void foo2() {\n+        InliningBar.bar();\n+    }\n+}\n+\n+\n+class InliningBar {\n+    public static void bar() {\n+        bar2();\n+    }\n+\n+    private static void bar2() {}\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/TestInliningProtectionDomain.java","additions":304,"deletions":0,"binary":false,"changes":304,"status":"added"}]}