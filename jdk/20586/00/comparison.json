{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -278,9 +278,1 @@\n-\n-        var bootstrapDesc = desc.bootstrapMethod();\n-        ClassEntry bsOwner = constantPool.classEntry(bootstrapDesc.owner());\n-        NameAndTypeEntry bsNameAndType = constantPool.nameAndTypeEntry(bootstrapDesc.methodName(),\n-                                                               bootstrapDesc.invocationType());\n-        int bsRefKind = bootstrapDesc.refKind();\n-\n-        MemberRefEntry memberRefEntry = toBootstrapMemberRef(constantPool, bsRefKind, bsOwner, bsNameAndType, bootstrapDesc.isOwnerInterface());\n-        MethodHandleEntry methodHandleEntry = constantPool.methodHandleEntry(bsRefKind, memberRefEntry);\n+        MethodHandleEntry methodHandleEntry = handleDescToHandleInfo(constantPool, desc.bootstrapMethod());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BytecodeHelpers.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8304031 8338406\n+ * @summary Testing handling of various constant descriptors in ClassFile API.\n+ * @run junit ConstantDescSymbolsTest\n+ *\/\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.DynamicConstantDesc;\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.function.Supplier;\n+import java.lang.classfile.ClassFile;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+import static java.lang.constant.ConstantDescs.*;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class ConstantDescSymbolsTest {\n+\n+    \/\/ Testing that primitive class descs are encoded properly as loadable constants.\n+    @Test\n+    void testPrimitiveClassDesc() throws Throwable {\n+        ClassDesc ape = ClassDesc.of(\"Ape\");\n+        var lookup = MethodHandles.lookup();\n+        Class<?> a = lookup.defineClass(ClassFile.of().build(ape, clb -> {\n+            clb.withSuperclass(CD_Object);\n+            clb.withInterfaceSymbols(Supplier.class.describeConstable().orElseThrow());\n+            clb.withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC, cob -> {\n+                cob.aload(0);\n+                cob.invokespecial(CD_Object, INIT_NAME, MTD_void);\n+                cob.return_();\n+            });\n+            clb.withMethodBody(\"get\", MethodTypeDesc.of(CD_Object), ACC_PUBLIC, cob -> {\n+                cob.loadConstant(CD_int);\n+                cob.areturn();\n+            });\n+            clb.withMethodBody(\"get2\", MethodTypeDesc.of(CD_Class), ACC_PUBLIC, cob -> {\n+                Assertions.assertThrows(IllegalArgumentException.class, () -> cob.constantPool().classEntry(CD_long));\n+                var t = cob.constantPool().loadableConstantEntry(CD_long);\n+                cob.ldc(t);\n+                cob.areturn();\n+            });\n+        }));\n+        Supplier<?> t = (Supplier<?>) lookup.findConstructor(a, MethodType.methodType(void.class))\n+                .asType(MethodType.methodType(Supplier.class))\n+                .invokeExact();\n+        assertSame(int.class, t.get());\n+    }\n+\n+    \/\/ Tests that condy symbols with non-static-method bootstraps are using the right lookup descriptor.\n+    @Test\n+    void testConstantDynamicNonStaticBootstrapMethod() throws Throwable {\n+        record CondyBoot(MethodHandles.Lookup lookup, String name, Class<?> type) {}\n+        var bootClass = CondyBoot.class.describeConstable().orElseThrow();\n+        var bootMhDesc = MethodHandleDesc.ofConstructor(bootClass, CD_MethodHandles_Lookup, CD_String, CD_Class);\n+        var condyDesc = DynamicConstantDesc.of(bootMhDesc);\n+\n+        var targetCd = ClassDesc.of(\"Bat\");\n+        var lookup = MethodHandles.lookup();\n+        Class<?> a = lookup.defineClass(ClassFile.of().build(targetCd, clb -> {\n+            clb.withInterfaceSymbols(Supplier.class.describeConstable().orElseThrow())\n+                    .withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC, cob -> cob\n+                            .aload(0).invokespecial(CD_Object, INIT_NAME, MTD_void).return_())\n+                    .withMethodBody(\"get\", MethodTypeDesc.of(CD_Object), ACC_PUBLIC, cob -> cob\n+                            .loadConstant(condyDesc).areturn());\n+        }));\n+        @SuppressWarnings(\"unchecked\")\n+        Supplier<CondyBoot> t = (Supplier<CondyBoot>) lookup.findConstructor(a, MethodType.methodType(void.class))\n+                .asType(MethodType.methodType(Supplier.class)).invokeExact();\n+        var cb = t.get();\n+        assertEquals(MethodHandles.Lookup.ORIGINAL, cb.lookup.lookupModes() & MethodHandles.Lookup.ORIGINAL);\n+        assertSame(a, cb.lookup.lookupClass());\n+        assertEquals(DEFAULT_NAME, cb.name);\n+        assertEquals(CondyBoot.class, cb.type);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/ConstantDescSymbolsTest.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -1,79 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8304031\n- * @summary Testing that primitive class descs are encoded properly as loadable constants.\n- * @run junit PrimitiveClassConstantTest\n- *\/\n-\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.MethodTypeDesc;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.util.function.Supplier;\n-import java.lang.classfile.ClassFile;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n-\n-import static java.lang.constant.ConstantDescs.CD_Class;\n-import static java.lang.constant.ConstantDescs.CD_Object;\n-import static java.lang.constant.ConstantDescs.CD_int;\n-import static java.lang.constant.ConstantDescs.CD_long;\n-import static java.lang.constant.ConstantDescs.INIT_NAME;\n-import static java.lang.constant.ConstantDescs.MTD_void;\n-import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n-\n-public final class PrimitiveClassConstantTest {\n-\n-    @Test\n-    public void test() throws Throwable {\n-        ClassDesc ape = ClassDesc.of(\"Ape\");\n-        var lookup = MethodHandles.lookup();\n-        Class<?> a = lookup.defineClass(ClassFile.of().build(ape, clb -> {\n-            clb.withSuperclass(CD_Object);\n-            clb.withInterfaceSymbols(Supplier.class.describeConstable().orElseThrow());\n-            clb.withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC, cob -> {\n-                cob.aload(0);\n-                cob.invokespecial(CD_Object, INIT_NAME, MTD_void);\n-                cob.return_();\n-            });\n-            clb.withMethodBody(\"get\", MethodTypeDesc.of(CD_Object), ACC_PUBLIC, cob -> {\n-                cob.loadConstant(CD_int);\n-                cob.areturn();\n-            });\n-            clb.withMethodBody(\"get2\", MethodTypeDesc.of(CD_Class), ACC_PUBLIC, cob -> {\n-                Assertions.assertThrows(IllegalArgumentException.class, () -> cob.constantPool().classEntry(CD_long));\n-                var t = cob.constantPool().loadableConstantEntry(CD_long);\n-                cob.ldc(t);\n-                cob.areturn();\n-            });\n-        }));\n-        Supplier<?> t = (Supplier<?>) lookup.findConstructor(a, MethodType.methodType(void.class))\n-                .asType(MethodType.methodType(Supplier.class))\n-                .invokeExact();\n-        Assertions.assertSame(int.class, t.get());\n-    }\n-\n-}\n","filename":"test\/jdk\/jdk\/classfile\/PrimitiveClassConstantTest.java","additions":0,"deletions":79,"binary":false,"changes":79,"status":"deleted"}]}