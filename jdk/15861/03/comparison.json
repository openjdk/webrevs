{"files":[{"patch":"@@ -28,0 +28,3 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+\n@@ -29,0 +32,2 @@\n+import java.nio.charset.CharacterCodingException;\n+import java.nio.charset.StandardCharsets;\n@@ -30,3 +35,4 @@\n-import static java.lang.Double.*;\n-import static java.lang.Long.*;\n-import static java.lang.Math.multiplyHigh;\n+import static java.lang.Double.PRECISION;\n+import static java.lang.Double.doubleToRawLongBits;\n+import static java.lang.Long.numberOfLeadingZeros;\n+import static java.lang.Math.*;\n@@ -104,8 +110,1 @@\n-    \/*\n-     * Room for the longer of the forms\n-     *     -ddddd.dddddddddddd         H + 2 characters\n-     *     -0.00ddddddddddddddddd      H + 5 characters\n-     *     -d.ddddddddddddddddE-eee    H + 7 characters\n-     * where there are H digits d\n-     *\/\n-    public static final int MAX_CHARS = H + 7;\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n@@ -113,1 +112,1 @@\n-    private final byte[] bytes;\n+    private byte[] bytes;\n@@ -115,1 +114,1 @@\n-    \/* Index into bytes of rightmost valid character *\/\n+    \/* Index into bytes *\/\n@@ -118,2 +117,1 @@\n-    private DoubleToDecimal(boolean noChars) {\n-        bytes = noChars ? null : new byte[MAX_CHARS];\n+    private DoubleToDecimal() {\n@@ -131,1 +129,1 @@\n-        return new DoubleToDecimal(false).toDecimalString(v);\n+        return new DoubleToDecimal().toDecimalString(v);\n@@ -152,1 +150,1 @@\n-        new DoubleToDecimal(true).toDecimal(v, fd);\n+        new DoubleToDecimal().toDecimal(v, fd);\n@@ -168,1 +166,1 @@\n-        return new DoubleToDecimal(false).appendDecimalTo(v, app);\n+        return new DoubleToDecimal().appendDecimalTo(v, app);\n@@ -184,22 +182,8 @@\n-        switch (toDecimal(v, null)) {\n-            case NON_SPECIAL:\n-                char[] chars = new char[index + 1];\n-                for (int i = 0; i < chars.length; ++i) {\n-                    chars[i] = (char) bytes[i];\n-                }\n-                if (app instanceof StringBuilder builder) {\n-                    return builder.append(chars);\n-                }\n-                if (app instanceof StringBuffer buffer) {\n-                    return buffer.append(chars);\n-                }\n-                for (char c : chars) {\n-                    app.append(c);\n-                }\n-                return app;\n-            case PLUS_ZERO: return app.append(\"0.0\");\n-            case MINUS_ZERO: return app.append(\"-0.0\");\n-            case PLUS_INF: return app.append(\"Infinity\");\n-            case MINUS_INF: return app.append(\"-Infinity\");\n-            default: return app.append(\"NaN\");\n-        }\n+        return switch (toDecimal(v, null)) {\n+            case NON_SPECIAL -> app.append(charsToString());\n+            case PLUS_ZERO -> app.append(\"0.0\");\n+            case MINUS_ZERO -> app.append(\"-0.0\");\n+            case PLUS_INF -> app.append(\"Infinity\");\n+            case MINUS_INF -> app.append(\"-Infinity\");\n+            default -> app.append(\"NaN\");\n+        };\n@@ -230,8 +214,1 @@\n-            index = -1;\n-            if (bits < 0) {\n-                \/*\n-                 * fd != null implies bytes == null and bits >= 0\n-                 * Thus, when fd != null, control never reaches here.\n-                 *\/\n-                append('-');\n-            }\n+            index = bits < 0 ? 1 : 0;\n@@ -391,1 +368,1 @@\n-         *     fp 10^ep = f 10^(e-H) = 0.f 10^e\n+         *     fp 10^ep = f 10^(e-H) = f_0.f_1...f_{H-1} 10^e\n@@ -394,1 +371,1 @@\n-        e += len;\n+        e += len - 1;\n@@ -409,0 +386,5 @@\n+         *\n+         * dlen is the index of the least significant non-zero decimal in\n+         *     f_0f_1...f_{H-1}\n+         * which is the expansion of f.\n+         * For example, when f = 12_345_670_000_000_000 then dlen = 6.\n@@ -414,3 +396,11 @@\n-\n-        if (0 < e && e <= 7) {\n-            return toChars1(h, m, l, e);\n+        int dlen = l != 0\n+            ? 16 - decNumberOfTrailingZeros(l)\n+            : m != 0\n+            ? 8 - decNumberOfTrailingZeros(m)\n+            : 0;\n+\n+        if (0 <= e && e < 7) {\n+            if (dlen <= e) {\n+                return toChars0(h, m, e);\n+            }\n+            return toChars1(h, m, l, e, dlen);\n@@ -418,2 +408,2 @@\n-        if (-3 < e && e <= 0) {\n-            return toChars2(h, m, l, e);\n+        if (-3 <= e && e < 0) {\n+            return toChars2(h, m, l, e, dlen);\n@@ -421,1 +411,1 @@\n-        return toChars3(h, m, l, e);\n+        return toChars3(h, m, l, e, dlen);\n@@ -424,1 +414,1 @@\n-    private int toChars1(int h, int m, int l, int e) {\n+    private int toChars0(int h, int m, int e) {\n@@ -426,1 +416,1 @@\n-         * 0 < e <= 7: plain format without leading zeroes.\n+         * 0 <= e < 7: plain format without leading zeroes, integer values.\n@@ -430,0 +420,2 @@\n+        bytes = new byte[index + e + 3];\n+        appendSign();\n@@ -432,4 +424,2 @@\n-        int t;\n-        int i = 1;\n-        for (; i < e; ++i) {\n-            t = 10 * y;\n+        for (; e > 0; --e) {\n+            int t = 10 * y;\n@@ -440,2 +430,20 @@\n-        for (; i <= 8; ++i) {\n-            t = 10 * y;\n+        append('0');\n+        return NON_SPECIAL;\n+    }\n+\n+    private int toChars1(int h, int m, int l, int e, int dlen) {\n+        \/*\n+         * 0 <= e < 7: plain format without leading zeroes.\n+         * Left-to-right digits extraction:\n+         * algorithm 1 in [3], with b = 10, k = 8, n = 28.\n+         *\/\n+        bytes = new byte[index + dlen + 2];\n+        appendSign();\n+        appendDigit(h);\n+        int y = y(m);\n+        int min = min(dlen, 8);\n+        for (int i = 0; i < min; ++i) {\n+            if (i == e) {\n+                append('.');\n+            }\n+            int t = 10 * y;\n@@ -445,1 +453,3 @@\n-        lowDigits(l);\n+        if (l != 0) {\n+            appendLow(l, dlen);\n+        }\n@@ -449,3 +459,5 @@\n-    private int toChars2(int h, int m, int l, int e) {\n-        \/* -3 < e <= 0: plain format with leading zeroes *\/\n-        appendDigit(0);\n+    private int toChars2(int h, int m, int l, int e, int dlen) {\n+        \/* -3 <= e < 0: plain format with leading zeroes *\/\n+        bytes = new byte[index + 2 - e + dlen];\n+        appendSign();\n+        append('0');\n@@ -453,2 +465,2 @@\n-        for (; e < 0; ++e) {\n-            appendDigit(0);\n+        for (; e < -1; ++e) {\n+            append('0');\n@@ -457,2 +469,9 @@\n-        append8Digits(m);\n-        lowDigits(l);\n+        int y = y(m);\n+        for (int min = min(dlen, 8); min > 0; --min) {\n+            int t = 10 * y;\n+            appendDigit(t >>> 28);\n+            y = t & MASK_28;\n+        }\n+        if (l != 0) {\n+            appendLow(l, dlen);\n+        }\n@@ -462,2 +481,9 @@\n-    private int toChars3(int h, int m, int l, int e) {\n-        \/* -3 >= e | e > 7: computerized scientific notation *\/\n+    private int toChars3(int h, int m, int l, int e, int dlen) {\n+        \/* -3 > e | e >= 7: computerized scientific notation *\/\n+        if (dlen == 0) {\n+            dlen = 1;\n+        }\n+        int ea = abs(e);\n+        int elen = ea < 10 ? 1 : ea < 100 ? 2 : 3;\n+        bytes = new byte[index + dlen + elen + (e < 0 ? 4 : 3)];\n+        appendSign();\n@@ -466,18 +492,0 @@\n-        append8Digits(m);\n-        lowDigits(l);\n-        exponent(e - 1);\n-        return NON_SPECIAL;\n-    }\n-\n-    private void lowDigits(int l) {\n-        if (l != 0) {\n-            append8Digits(l);\n-        }\n-        removeTrailingZeroes();\n-    }\n-\n-    private void append8Digits(int m) {\n-        \/*\n-         * Left-to-right digits extraction:\n-         * algorithm 1 in [3], with b = 10, k = 8, n = 28.\n-         *\/\n@@ -485,1 +493,1 @@\n-        for (int i = 0; i < 8; ++i) {\n+        for (int min = min(dlen, 8); min > 0; --min) {\n@@ -490,0 +498,9 @@\n+        if (l != 0) {\n+            appendLow(l, dlen);\n+        }\n+        append('E');\n+        if (e < 0) {\n+            append('-');\n+        }\n+        exponent(ea);\n+        return NON_SPECIAL;\n@@ -492,7 +509,6 @@\n-    private void removeTrailingZeroes() {\n-        while (bytes[index] == '0') {\n-            --index;\n-        }\n-        \/* ... but do not remove the one directly to the right of '.' *\/\n-        if (bytes[index] == '.') {\n-            ++index;\n+    private void appendLow(int l, int dlen) {\n+        int y = y(l);\n+        for (; dlen > 8; --dlen) {\n+            int t = 10 * y;\n+            appendDigit(t >>> 28);\n+            y = t & MASK_28;\n@@ -502,1 +518,1 @@\n-    private int y(int a) {\n+    private static int y(int a) {\n@@ -516,8 +532,3 @@\n-    private void exponent(int e) {\n-        append('E');\n-        if (e < 0) {\n-            append('-');\n-            e = -e;\n-        }\n-        if (e < 10) {\n-            appendDigit(e);\n+    private void exponent(int ea) {\n+        if (ea < 10) {\n+            appendDigit(ea);\n@@ -527,1 +538,1 @@\n-        if (e >= 100) {\n+        if (ea >= 100) {\n@@ -530,1 +541,1 @@\n-             *     floor(e \/ 100) = floor(1_311 e \/ 2^17)\n+             *     floor(ea \/ 100) = floor(1_311 ea \/ 2^17)\n@@ -532,1 +543,1 @@\n-            d = e * 1_311 >>> 17;\n+            d = ea * 1_311 >>> 17;\n@@ -534,1 +545,1 @@\n-            e -= 100 * d;\n+            ea -= 100 * d;\n@@ -538,1 +549,1 @@\n-         *     floor(e \/ 10) = floor(103 e \/ 2^10)\n+         *     floor(ea \/ 10) = floor(103 ea \/ 2^10)\n@@ -540,1 +551,1 @@\n-        d = e * 103 >>> 10;\n+        d = ea * 103 >>> 10;\n@@ -542,1 +553,7 @@\n-        appendDigit(e - 10 * d);\n+        appendDigit(ea - 10 * d);\n+    }\n+\n+    private void appendSign() {\n+        if (index != 0) {\n+            bytes[0] = '-';\n+        }\n@@ -546,1 +563,1 @@\n-        bytes[++index] = (byte) c;\n+        bytes[index++] = (byte) c;\n@@ -550,1 +567,1 @@\n-        bytes[++index] = (byte) ('0' + d);\n+        bytes[index++] = (byte) ('0' + d);\n@@ -553,2 +570,0 @@\n-    \/* Using the deprecated constructor enhances performance *\/\n-    @SuppressWarnings(\"deprecation\")\n@@ -556,1 +571,5 @@\n-        return new String(bytes, 0, 0, index + 1);\n+        try {\n+            return JLA.newStringNoRepl(bytes, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException e) {\n+            throw new AssertionError(e);\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/DoubleToDecimal.java","additions":140,"deletions":121,"binary":false,"changes":261,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+\n@@ -29,0 +32,2 @@\n+import java.nio.charset.CharacterCodingException;\n+import java.nio.charset.StandardCharsets;\n@@ -30,3 +35,4 @@\n-import static java.lang.Float.*;\n-import static java.lang.Integer.*;\n-import static java.lang.Math.multiplyHigh;\n+import static java.lang.Float.PRECISION;\n+import static java.lang.Float.floatToRawIntBits;\n+import static java.lang.Integer.numberOfLeadingZeros;\n+import static java.lang.Math.*;\n@@ -104,8 +110,1 @@\n-    \/*\n-     * Room for the longer of the forms\n-     *     -ddddd.dddd         H + 2 characters\n-     *     -0.00ddddddddd      H + 5 characters\n-     *     -d.ddddddddE-ee     H + 6 characters\n-     * where there are H digits d\n-     *\/\n-    public static final int MAX_CHARS = H + 6;\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n@@ -113,1 +112,1 @@\n-    private final byte[] bytes = new byte[MAX_CHARS];\n+    private byte[] bytes;\n@@ -115,1 +114,1 @@\n-    \/* Index into bytes of rightmost valid character *\/\n+    \/* Index into bytes *\/\n@@ -162,22 +161,8 @@\n-        switch (toDecimal(v)) {\n-            case NON_SPECIAL:\n-                char[] chars = new char[index + 1];\n-                for (int i = 0; i < chars.length; ++i) {\n-                    chars[i] = (char) bytes[i];\n-                }\n-                if (app instanceof StringBuilder builder) {\n-                    return builder.append(chars);\n-                }\n-                if (app instanceof StringBuffer buffer) {\n-                    return buffer.append(chars);\n-                }\n-                for (char c : chars) {\n-                    app.append(c);\n-                }\n-                return app;\n-            case PLUS_ZERO: return app.append(\"0.0\");\n-            case MINUS_ZERO: return app.append(\"-0.0\");\n-            case PLUS_INF: return app.append(\"Infinity\");\n-            case MINUS_INF: return app.append(\"-Infinity\");\n-            default: return app.append(\"NaN\");\n-        }\n+        return switch (toDecimal(v)) {\n+            case NON_SPECIAL -> app.append(charsToString());\n+            case PLUS_ZERO -> app.append(\"0.0\");\n+            case MINUS_ZERO -> app.append(\"-0.0\");\n+            case PLUS_INF -> app.append(\"Infinity\");\n+            case MINUS_INF -> app.append(\"-Infinity\");\n+            default -> app.append(\"NaN\");\n+        };\n@@ -208,4 +193,1 @@\n-            index = -1;\n-            if (bits < 0) {\n-                append('-');\n-            }\n+            index = bits < 0 ? 1 : 0;\n@@ -357,1 +339,1 @@\n-         *     fp 10^ep = f 10^(e-H) = 0.f 10^e\n+         *     fp 10^ep = f 10^(e-H) = f_0.f_1...f_{H-1} 10^e\n@@ -360,1 +342,1 @@\n-        e += len;\n+        e += len - 1;\n@@ -371,0 +353,5 @@\n+         *\n+         * dlen is the index of the least significant non-zero decimal in\n+         *     f_0f_1...f_{H-1}\n+         * which is the expansion of f.\n+         * For example, when f = 123_456_700 then dlen = 6.\n@@ -374,0 +361,3 @@\n+        int dlen = l != 0\n+            ? 8 - decNumberOfTrailingZeros(l)\n+            : 0;\n@@ -375,2 +365,5 @@\n-        if (0 < e && e <= 7) {\n-            return toChars1(h, l, e);\n+        if (0 <= e && e < 7) {\n+            if (dlen <= e) {\n+                return toChars0(h, l, e);\n+            }\n+            return toChars1(h, l, e, dlen);\n@@ -378,2 +371,2 @@\n-        if (-3 < e && e <= 0) {\n-            return toChars2(h, l, e);\n+        if (-3 <= e && e < 0) {\n+            return toChars2(h, l, e, dlen);\n@@ -381,1 +374,1 @@\n-        return toChars3(h, l, e);\n+        return toChars3(h, l, e, dlen);\n@@ -384,1 +377,1 @@\n-    private int toChars1(int h, int l, int e) {\n+    private int toChars0(int h, int m, int e) {\n@@ -386,1 +379,1 @@\n-         * 0 < e <= 7: plain format without leading zeroes.\n+         * 0 <= e < 7: plain format without leading zeroes, integer values.\n@@ -390,0 +383,2 @@\n+        bytes = new byte[index + e + 3];\n+        appendSign();\n@@ -391,5 +386,3 @@\n-        int y = y(l);\n-        int t;\n-        int i = 1;\n-        for (; i < e; ++i) {\n-            t = 10 * y;\n+        int y = y(m);\n+        for (; e > 0; --e) {\n+            int t = 10 * y;\n@@ -400,2 +393,20 @@\n-        for (; i <= 8; ++i) {\n-            t = 10 * y;\n+        append('0');\n+        return NON_SPECIAL;\n+    }\n+\n+    private int toChars1(int h, int l, int e, int dlen) {\n+        \/*\n+         * 0 <= e < 7: plain format without leading zeroes.\n+         * Left-to-right digits extraction:\n+         * algorithm 1 in [3], with b = 10, k = 8, n = 28.\n+         *\/\n+        bytes = new byte[index + dlen + 2];\n+        appendSign();\n+        appendDigit(h);\n+        int y = y(l);\n+        int min = min(dlen, 8);\n+        for (int i = 0; i < min; ++i) {\n+            if (i == e) {\n+                append('.');\n+            }\n+            int t = 10 * y;\n@@ -405,1 +416,0 @@\n-        removeTrailingZeroes();\n@@ -409,3 +419,5 @@\n-    private int toChars2(int h, int l, int e) {\n-        \/* -3 < e <= 0: plain format with leading zeroes *\/\n-        appendDigit(0);\n+    private int toChars2(int h, int l, int e, int dlen) {\n+        \/* -3 <= e < 0: plain format with leading zeroes *\/\n+        bytes = new byte[index + 2 - e + dlen];\n+        appendSign();\n+        append('0');\n@@ -413,2 +425,2 @@\n-        for (; e < 0; ++e) {\n-          appendDigit(0);\n+        for (; e < -1; ++e) {\n+            append('0');\n@@ -417,2 +429,6 @@\n-        append8Digits(l);\n-        removeTrailingZeroes();\n+        int y = y(l);\n+        for (int min = min(dlen, 8); min > 0; --min) {\n+            int t = 10 * y;\n+            appendDigit(t >>> 28);\n+            y = t & MASK_28;\n+        }\n@@ -422,2 +438,9 @@\n-    private int toChars3(int h, int l, int e) {\n-        \/* -3 >= e | e > 7: computerized scientific notation *\/\n+    private int toChars3(int h, int l, int e, int dlen) {\n+        \/* -3 > e | e >= 7: computerized scientific notation *\/\n+        if (dlen == 0) {\n+            dlen = 1;\n+        }\n+        int ea = abs(e);\n+        int elen = ea < 10 ? 1 : 2;\n+        bytes = new byte[index + dlen + elen + (e < 0 ? 4 : 3)];\n+        appendSign();\n@@ -426,13 +449,2 @@\n-        append8Digits(l);\n-        removeTrailingZeroes();\n-        exponent(e - 1);\n-        return NON_SPECIAL;\n-    }\n-\n-    private void append8Digits(int m) {\n-        \/*\n-         * Left-to-right digits extraction:\n-         * algorithm 1 in [3], with b = 10, k = 8, n = 28.\n-         *\/\n-        int y = y(m);\n-        for (int i = 0; i < 8; ++i) {\n+        int y = y(l);\n+        for (int min = min(dlen, 8); min > 0; --min) {\n@@ -443,9 +455,3 @@\n-    }\n-\n-    private void removeTrailingZeroes() {\n-        while (bytes[index] == '0') {\n-            --index;\n-        }\n-        \/* ... but do not remove the one directly to the right of '.' *\/\n-        if (bytes[index] == '.') {\n-            ++index;\n+        append('E');\n+        if (e < 0) {\n+            append('-');\n@@ -453,0 +459,2 @@\n+        exponent(ea);\n+        return NON_SPECIAL;\n@@ -455,1 +463,1 @@\n-    private int y(int a) {\n+    private static int y(int a) {\n@@ -469,8 +477,3 @@\n-    private void exponent(int e) {\n-        append('E');\n-        if (e < 0) {\n-            append('-');\n-            e = -e;\n-        }\n-        if (e < 10) {\n-            appendDigit(e);\n+    private void exponent(int ea) {\n+        if (ea < 10) {\n+            appendDigit(ea);\n@@ -481,1 +484,1 @@\n-         *     floor(e \/ 10) = floor(103 e \/ 2^10)\n+         *     floor(ea \/ 10) = floor(103 ea \/ 2^10)\n@@ -483,1 +486,1 @@\n-        int d = e * 103 >>> 10;\n+        int d = ea * 103 >>> 10;\n@@ -485,1 +488,7 @@\n-        appendDigit(e - 10 * d);\n+        appendDigit(ea - 10 * d);\n+    }\n+\n+    private void appendSign() {\n+        if (index != 0) {\n+            bytes[0] = '-';\n+        }\n@@ -489,1 +498,1 @@\n-        bytes[++index] = (byte) c;\n+        bytes[index++] = (byte) c;\n@@ -493,1 +502,1 @@\n-        bytes[++index] = (byte) ('0' + d);\n+        bytes[index++] = (byte) ('0' + d);\n@@ -496,2 +505,0 @@\n-    \/* Using the deprecated constructor enhances performance *\/\n-    @SuppressWarnings(\"deprecation\")\n@@ -499,1 +506,5 @@\n-        return new String(bytes, 0, 0, index + 1);\n+        try {\n+            return JLA.newStringNoRepl(bytes, StandardCharsets.ISO_8859_1);\n+        } catch (CharacterCodingException e) {\n+            throw new AssertionError(e);\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/FloatToDecimal.java","additions":116,"deletions":105,"binary":false,"changes":221,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,0 +87,23 @@\n+    \/**\n+     * {@return the count of trailing zeros in the decimal expansion of the argument}\n+     * @param n the input, assumed (but not checked) to be positive: {@code n} &gt; 0\n+     *\/\n+    static int decNumberOfTrailingZeros(int n) {\n+        \/*\n+         * When n > 0 then\n+         *      (int) (n * 3_435_973_837L >>> 35) == n \/ 10\n+         * This is for the benefit of CPUs that lack support for efficient\n+         * division instructions.\n+         *\/\n+        if (n != (n = (int) (n * 3_435_973_837L >>> 35)) * 10) return 0;\n+        if (n != (n = (int) (n * 3_435_973_837L >>> 35)) * 10) return 1;\n+        if (n != (n = (int) (n * 3_435_973_837L >>> 35)) * 10) return 2;\n+        if (n != (n = (int) (n * 3_435_973_837L >>> 35)) * 10) return 3;\n+        if (n != (n = (int) (n * 3_435_973_837L >>> 35)) * 10) return 4;\n+        if (n != (n = (int) (n * 3_435_973_837L >>> 35)) * 10) return 5;\n+        if (n != (n = (int) (n * 3_435_973_837L >>> 35)) * 10) return 6;\n+        if (n != (n = (int) (n * 3_435_973_837L >>> 35)) * 10) return 7;\n+        if (n != (int) (n * 3_435_973_837L >>> 35) * 10) return 8;\n+        return 9;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/MathUtils.java","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"}]}