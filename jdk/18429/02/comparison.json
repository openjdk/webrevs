{"files":[{"patch":"@@ -79,6 +79,4 @@\n-\/\/ Note that scoped accesses (cf. scopedMemoryAccess.cpp) can install\n-\/\/ an async handshake on the entry to an Unsafe method. When that happens,\n-\/\/ it is expected that we are not allowed to touch the underlying memory\n-\/\/ that might have gotten unmapped. Therefore, we check at the entry\n-\/\/ to unsafe functions, if we have such async exception conditions,\n-\/\/ and return immediately if that is the case.\n+\/\/ All memory access methods (e.g. getInt, copyMemory) must use this macro.\n+\/\/ We call these methods \"scoped\" methods, as access to these methods is\n+\/\/ typically governed by a \"scope\" (a MemorySessionImpl object), and no\n+\/\/ access is allowed when the scope is no longer alive.\n@@ -86,6 +84,6 @@\n-\/\/ We can't have safepoints in this code.\n-\/\/ It would be problematic if an async exception handshake were installed later on\n-\/\/ during another safepoint in the function, but before the memory access happens,\n-\/\/ as the memory will be freed after the handshake is installed. We must notice\n-\/\/ the installed handshake and return early before doing the memory access to prevent\n-\/\/ accesses to freed memory.\n+\/\/ Closing a scope object (cf. scopedMemoryAccess.cpp) can install\n+\/\/ an async exception during a safepoint. When that happens,\n+\/\/ scoped methods are not allowed to touch the underlying memory (as that\n+\/\/ memory might have been released). Therefore, when entering a scoped method\n+\/\/ we check if an async exception has been installed, and return immediately\n+\/\/ if that is the case.\n@@ -93,5 +91,8 @@\n-\/\/ Note also that we MUST do a scoped memory access in the VM (or Java) thread\n-\/\/ state. Since we rely on a handshake to check for threads that are accessing\n-\/\/ scoped memory, and we need the handshaking thread to wait until we get to a\n-\/\/ safepoint, in order to make sure we are not in the middle of accessing memory\n-\/\/ that is about to be freed. (i.e. there can be no UNSAFE_LEAF_SCOPED)\n+\/\/ As a rule, we disallow safepoints in the middle of a scoped method.\n+\/\/ If an async exception handshake were installed in such a safepoint,\n+\/\/ memory access might still occur before the handshake is honored by\n+\/\/ the accessing thread.\n+\/\/\n+\/\/ Corollary: as threads in native state are considered to be at a safepoint,\n+\/\/ scoped methods must NOT be executed while in the native thread state.\n+\/\/ Because of this, there can be no UNSAFE_LEAF_SCOPED.\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":18,"deletions":17,"binary":false,"changes":35,"status":"modified"}]}