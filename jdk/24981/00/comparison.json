{"files":[{"patch":"@@ -0,0 +1,174 @@\n+\/*\n+ * Copyright (c) 2025, Huawei Technologies Co., Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.g1;\n+\n+\/*\n+ * @test TestG1MetadataSize.java\n+ * @bug 8350860\n+ * @summary Ensure G1 metadata size does not grow unreasonably.\n+ * Should treat JDK-8350857 as a followup to reduce MarkStackSize\n+ * @requires vm.gc.G1\n+ * @requires vm.bits != \"32\"\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver gc.g1.TestG1MetadataSize\n+ *\/\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class TestG1MetadataSize {\n+\n+    private static final int K = 1024;\n+    private static final int MARK_STACK_SIZE_IN_M = 4;\n+    \/\/ NMT report sample:\n+    \/\/ - GC (reserved=448282674, committed=111427634)\n+    \/\/  (malloc=54079538 #626) (at peak)\n+    \/\/  (mmap: reserved=394203136, committed=57348096, at peak)\n+    private static final String GC_LINE_PATTERN = \"GC \\\\((.*)\\\\n(.*?\\\\n)(.*?\\\\n)(.*)\\\\n\";;\n+\n+    public static void main(String[] args) throws Exception {\n+        for (int maxHeapSizeMb = 64; maxHeapSizeMb <= 16 * K; maxHeapSizeMb *= 2) {\n+            \/\/ NMT current is not related to initialHeapSizeMb. Iterate it over to prevent regression\n+            for (int initialHeapSizeMb = 64; initialHeapSizeMb <= maxHeapSizeMb; initialHeapSizeMb *= 2) {\n+                for (int parallelGCThreads = 1; parallelGCThreads <= 16; parallelGCThreads *= 2) {\n+                    for (int concGCThreads = 1; concGCThreads <= 16; concGCThreads *= 2) {\n+                        test(initialHeapSizeMb, maxHeapSizeMb, parallelGCThreads, concGCThreads);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void test(int initialHeapSizeMb, int maxHeapSizeMb, int parallelGCThreads, int concGCThreads) throws Exception {\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n+            String.format(\"-Xms%dm\", initialHeapSizeMb),\n+            String.format(\"-Xmx%dm\", maxHeapSizeMb),\n+            \"-XX:+UseG1GC\",\n+            String.format(\"-XX:ParallelGCThreads=%d\", parallelGCThreads),\n+            String.format(\"-XX:ConcGCThreads=%d\", concGCThreads),\n+            String.format(\"-XX:MarkStackSize=%d\", MARK_STACK_SIZE_IN_M * K * K),\n+            \"-Xlog:nmt\",\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-XX:+PrintNMTStatistics\",\n+            \"-XX:NativeMemoryTracking=summary\",\n+            GCTest.class.getName());\n+\n+        verifyMalloc(output, maxHeapSizeMb, parallelGCThreads, concGCThreads);\n+        verifyMmap(output, maxHeapSizeMb);\n+    }\n+\n+    private static void verifyMalloc(OutputAnalyzer output, int maxHeapSizeMb, int parallelGCThreads, int concGCThreads) {\n+        String mallocLine = output.firstMatch(GC_LINE_PATTERN, 2);\n+        Asserts.assertNotNull(mallocLine, \"Couldn't find pattern '\" + GC_LINE_PATTERN\n+                + \"': in output '\" + output.getOutput() + \"'\");\n+\n+        Pattern mmapLinePattern = Pattern.compile(\"malloc=(.*) \\\\#(.*)\");\n+        Matcher matcher = mmapLinePattern.matcher(mallocLine);\n+        matcher.find();\n+        String mallocMem = matcher.group(1);\n+\n+        long mallocByte = Long.parseLong(mallocMem);\n+\n+        \/\/ Must be more than zero\n+        Asserts.assertGT(mallocByte, 0L);\n+\n+        long maxBytes = expectedMallocFootPrintInK(parallelGCThreads, concGCThreads, maxHeapSizeMb) * K;\n+        Asserts.assertLTE(mallocByte, maxBytes);\n+    }\n+\n+    private static void verifyMmap(OutputAnalyzer output, int maxHeapSizeMb) {\n+        String mmapLine = output.firstMatch(TestG1MetadataSize.GC_LINE_PATTERN, 3);\n+        Asserts.assertNotNull(mmapLine, \"Couldn't find pattern '\" + TestG1MetadataSize.GC_LINE_PATTERN\n+        + \"': in output '\" + output.getOutput() + \"'\");\n+        System.out.println(mmapLine);\n+\n+        Pattern mmapLinePattern = Pattern.compile(\"mmap: reserved=(.*), committed=(.*), (.*)\");\n+        Matcher matcher = mmapLinePattern.matcher(mmapLine);\n+        matcher.find();\n+        String committed = matcher.group(2);\n+\n+        long committedBytes = Long.parseLong(committed);\n+\n+        \/\/ Must be more than zero\n+        Asserts.assertGT(committedBytes, 0L);\n+\n+        long maxBytes = expectedMaxMmapFootprintInK(maxHeapSizeMb) * K;\n+        Asserts.assertLTE(committedBytes, maxBytes);\n+    }\n+\n+    private static long expectedMaxMmapFootprintInK(int maxHeapSizeMb) {\n+        long expected = 0;\n+        \/\/ Top contributor 1: G1CMMarkStack::ChunkAllocator::reserve(unsigned long)\n+        \/\/ Only related to MarkStackSize value. Does not grow along with heap size, parallelGCThreads or concGCThreads\n+        \/\/ 4 Mb MarkStackSize - 32768KB mmap memory\n+        expected += MARK_STACK_SIZE_IN_M * K * 8;\n+\n+        \/\/ Top contributor 2: G1CollectedHeap::create_aux_memory_mapper\n+        \/\/ Grows as heap size grows. It creates BOT, card table and the bitmap\n+        \/\/ 1g heap - 20480KB mmap memory\n+        expected += maxHeapSizeMb * 20;\n+\n+        \/\/ Other insignificant mmap memory and headroom\n+        expected += expected \/ 10;\n+\n+        System.out.println(\"expected Kb for mmap: \" + expected + \" maxHeapSizeMb: \" + maxHeapSizeMb);\n+        return expected;\n+    }\n+\n+    private static int expectedMallocFootPrintInK(int parallelGCThreads, int concGCThreads, int maxHeapSizeMb) {\n+        \/\/ malloc size is not impacted by heap size dramatically. When both parallelGCThreads and concGCThreads are 1,\n+        \/\/ GC malloc is around 3877KB when heap is 16G, around 2231KB when heap is 64M.\n+\n+        int expectedInK = 0;\n+        \/\/ Top contributor 1: G1CollectedHeap::G1CollectedHeap\n+        \/\/ It grows along with parallelGCThreads. n parallelGCThreads -> n MB\n+        expectedInK += parallelGCThreads * K;\n+\n+        \/\/ Top contributor 2: G1ConcurrentMark::G1ConcurrentMark(G1CollectedHeap*, G1RegionToSpaceMapper*)\n+        \/\/ Grows with thread counts.\n+        expectedInK += Math.max(parallelGCThreads, concGCThreads) * K;\n+\n+        \/\/ Top contributor 3: G1CardSetMemoryManager::G1CardSetMemoryManager\n+        \/\/ It grows along with heap size. heapsize 1024M -> ~1024K memory allocated by malloc\n+        expectedInK += maxHeapSizeMb;\n+\n+        \/\/ 10% headroom\n+        expectedInK += expectedInK \/ 10;\n+\n+        return expectedInK;\n+    }\n+\n+    static class GCTest {\n+        static Object sink;\n+        static int ARRAY_SIZE = 100;\n+\n+        public static void main(String[] args) throws Exception {\n+            sink = new byte[ARRAY_SIZE];\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestG1MetadataSize.java","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"}]}