{"files":[{"patch":"@@ -0,0 +1,843 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ record pattern of allocations of memory calls:\n+\/\/\n+\/\/ .\/build\/macosx-aarch64-server-release\/xcode\/build\/jdk\/bin\/java -XX:+UnlockDiagnosticVMOptions -XX:NativeMemoryTracking=summary -XX:NMTRecordMemoryAllocations=0x7FFFFFFF -jar build\/macosx-aarch64-server-release\/images\/jdk\/demo\/jfc\/J2Ddemo\/J2Ddemo.jar\n+\/\/\n+\/\/ OR record pattern of allocations of virtual memory calls:\n+\/\/\n+\/\/ .\/build\/macosx-aarch64-server-release\/xcode\/build\/jdk\/bin\/java -XX:+UnlockDiagnosticVMOptions -XX:NMTRecordVirtualMemoryAllocations=0x7FFFFFFF -jar build\/macosx-aarch64-server-release\/images\/jdk\/demo\/jfc\/J2Ddemo\/J2Ddemo.jar\n+\/\/\n+\/\/ this will produce 3 files:\n+\/\/\n+\/\/ #1 hs_nmt_pid22770_allocs_record.log (is the chronological record of the the desired operations)\n+\/\/ OR\n+\/\/ #1 hs_nmt_pid22918_virtual_allocs_record.log (is the chronological record of the desired operations)\n+\/\/ #2 hs_nmt_pid22770_info_record.log (is the record of default NMT memory overhead and the NMT state)\n+\/\/ #3 hs_nmt_pid22770_threads_record.log (is the record of thread names that can be retrieved later when processing)\n+\/\/\n+\/\/ then to actually run the benchmark:\n+\/\/\n+\/\/ .\/build\/macosx-aarch64-server-release\/xcode\/build\/jdk\/bin\/java -XX:+UnlockDiagnosticVMOptions -XX:NativeMemoryTracking=summary -XX:NMTBenchmarkRecordedPID=55996 -XX:NMTBenchmarkRecordedLoops=10\n+\n+#include \"precompiled.hpp\"\n+#include \"jvm.h\"\n+#include \"nmt\/nmtCommon.hpp\"\n+#include \"nmt\/mallocHeader.hpp\"\n+#include \"nmt\/mallocHeader.inline.hpp\"\n+#include \"nmt\/memLogRecorder.hpp\"\n+#include \"nmt\/memReporter.hpp\"\n+#include \"nmt\/memTracker.hpp\"\n+#include \"nmt\/memTracker.hpp\"\n+#include \"runtime\/arguments.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/thread.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/nativeCallStack.hpp\"\n+#include \"utilities\/permitForbiddenFunctions.hpp\"\n+#include \"utilities\/vmError.hpp\"\n+\n+#include <locale.h>\n+#if defined(LINUX)\n+#include <malloc.h>\n+#elif defined(__APPLE__)\n+#include <malloc\/malloc.h>\n+#endif\n+\n+#if defined(LINUX) || defined(__APPLE__)\n+#include <pthread.h>\n+#include <string.h>\n+#include <sys\/mman.h>\n+#endif\n+\n+NMT_MemoryLogRecorder NMT_MemoryLogRecorder::_recorder;\n+NMT_VirtualMemoryLogRecorder NMT_VirtualMemoryLogRecorder::_recorder;\n+\n+void NMT_LogRecorder::initialize(intx memoryCount, intx virtualMemoryCount) {\n+  NMT_MemoryLogRecorder::initialize(NMTRecordMemoryAllocations);\n+  NMT_VirtualMemoryLogRecorder::initialize(NMTRecordVirtualMemoryAllocations);\n+}\n+\n+void NMT_LogRecorder::finish() {\n+  if (!NMT_MemoryLogRecorder::instance()->done()) {\n+    NMT_MemoryLogRecorder::instance()->finish();\n+  }\n+  if (!NMT_VirtualMemoryLogRecorder::instance()->done()) {\n+    NMT_VirtualMemoryLogRecorder::instance()->finish();\n+  }\n+}\n+\n+void NMT_LogRecorder::replay(const char* path, const int pid) {\n+  NMT_MemoryLogRecorder::instance()->replay(path, pid);\n+  NMT_VirtualMemoryLogRecorder::instance()->replay(path, pid);\n+}\n+\n+void NMT_LogRecorder::init() {\n+#if defined(LINUX) || defined(__APPLE__)\n+  pthread_mutex_t _mutex;\n+#elif defined(WINDOWS)\n+ \/\/ ???\n+#endif\n+  pthread_mutex_init(&_mutex, NULL);\n+  _threads_names = nullptr;\n+  _done = true;\n+  _count = 0;\n+}\n+\n+bool NMT_LogRecorder::lockIfNotDone() {\n+  if (!_done) {\n+    lock();\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+void NMT_LogRecorder::lock() {\n+#if defined(LINUX) || defined(__APPLE__)\n+  pthread_mutex_lock(&_mutex);\n+#elif defined(WINDOWS)\n+ \/\/ ???\n+#endif\n+}\n+\n+void NMT_LogRecorder::unlock() {\n+#if defined(LINUX) || defined(__APPLE__)\n+  pthread_mutex_unlock(&_mutex);\n+#elif defined(WINDOWS)\n+ \/\/ ???\n+#endif\n+}\n+\n+void NMT_LogRecorder::logThreadName(const char* name) {\n+  NMT_MemoryLogRecorder::instance()->_logThreadName(name);\n+}\n+void NMT_LogRecorder::_logThreadName(const char* name) {\n+  if (_done) {\n+    return;\n+  }\n+  if (_threads_names == nullptr) {\n+    _threads_names = (thread_name_info*)permit_forbidden_function::calloc(_threads_names_capacity, sizeof(thread_name_info));\n+  }\n+  if (_threads_names_counter < _threads_names_capacity) {\n+    volatile size_t counter = _threads_names_counter++;\n+    if (counter < _threads_names_capacity) {\n+      strncpy((char*)_threads_names[counter].name, name, _threads_name_length-1);\n+      _threads_names[counter].thread = os::current_thread_id();\n+    }\n+  } else {\n+    _threads_names_capacity *= 2;\n+    _threads_names = (thread_name_info*)permit_forbidden_function::realloc((void*)_threads_names, _threads_names_capacity*sizeof(thread_name_info));\n+      logThreadName(name);\n+  }\n+}\n+\n+size_t NMT_LogRecorder::mallocSize(void* ptr)\n+{\n+#if defined(LINUX)\n+  return permit_forbidden_function::malloc_usable_size(ptr);\n+#elif defined(WINDOWS)\n+  return permit_forbidden_function::_msize(ptr);)\n+#elif defined(__APPLE__)\n+  return permit_forbidden_function::malloc_size(ptr);\n+#endif\n+}\n+\n+#define REALLOC_MARKER       ((void *)1)\n+#define IS_FREE(e)           ((e->requested == 0) && (e->old == nullptr))\n+#define IS_REALLOC(e)        ((e->requested  > 0) && (e->old != nullptr))\n+#define IS_MALLOC_REALLOC(e) ((e->requested  > 0) && (e->old == REALLOC_MARKER))\n+#define IS_MALLOC(e)         ((e->requested  > 0) && (e->old == nullptr))\n+\n+#define ALLOCS_LOG_FILE \"hs_nmt_pid%p_allocs_record.log\"\n+#define THREADS_LOG_FILE \"hs_nmt_pid%p_threads_record.log\"\n+#define INFO_LOG_FILE \"hs_nmt_pid%p_info_record.log\"\n+#define BENCHMARK_LOG_FILE \"hs_nmt_pid%p_benchmark.log\"\n+#define VALLOCS_LOG_FILE \"hs_nmt_pid%p_virtual_allocs_record.log\"\n+\n+static int _prepare_log_file(const char* pattern, const char* default_pattern) {\n+  int fd = -1;\n+  if (ErrorFileToStdout) {\n+    fd = STDOUT_FILENO;\n+  } else if (ErrorFileToStderr) {\n+    fd = STDERR_FILENO;\n+  } else {\n+    static char name_buffer[O_BUFLEN];\n+    fd = VMError::prepare_log_file(pattern, default_pattern, true, name_buffer, sizeof(name_buffer));\n+    if (fd == -1) {\n+      int e = errno;\n+      tty->print(\"Can't open memory [%s]. Error: \", pattern?pattern:\"null\");\n+      tty->print_raw_cr(os::strerror(e));\n+      tty->print_cr(\"NMT memory recorder report will be written to console.\");\n+      \/\/ See notes in VMError::report_and_die about hard coding tty to 1\n+      fd = 1;\n+    }\n+  }\n+  return fd;\n+}\n+\n+#define IS_VALID_FD(fd) (fd > STDERR_FILENO)\n+\n+static void _write_and_check(int fd, const void *buf, size_t count) {\n+  if (!IS_VALID_FD(fd)) {\n+    fprintf(stderr, \"write_and_check(%d) ERROR\\n\", fd);\n+    \/\/assert(false, \"fd: %d\", fd);\n+  }\n+  errno = 0;\n+  ssize_t written = ::write(fd, buf, count);\n+  if ((long)written != (long)count) {\n+    int e = errno;\n+    fprintf(stderr, \"write_and_check(%d) ERROR:[%s]\\n\", fd, os::strerror(e));\n+    \/\/assert((long)written != (long)count, \"written != count [%ld,%ld]\", (long)written, (long)count);\n+  }\n+}\n+\n+static int _close_and_check(int fd) {\n+  if (!IS_VALID_FD(fd)) {\n+    fprintf(stderr, \"close_and_check(%d) ERROR\\n\", fd);\n+    return fd;\n+  }\n+  if (fd > STDERR_FILENO) {\n+    errno = 0;\n+    int status = close(fd);\n+    if (status != 0) {\n+      int e = errno;\n+      fprintf(stderr, \"ERROR:[%s]\\n\", os::strerror(e));\n+      assert(status != 0, \"close(%d) returned %d\", fd, status);\n+      return fd;\n+    } else {\n+      return -1;\n+    }\n+  } else {\n+    return fd;\n+  }\n+}\n+\n+static bool _create_file_path_with_pid(const char *path, const char *file, char* file_path, int pid) {\n+  char *tmp_path = NEW_C_HEAP_ARRAY(char, JVM_MAXPATHLEN, mtNMT);\n+  strcpy(tmp_path, path);\n+  strcat(tmp_path, os::file_separator());\n+  strcat(tmp_path, file);\n+  if (!Arguments::copy_expand_pid(tmp_path, strlen(tmp_path), file_path, JVM_MAXPATHLEN, pid)) {\n+    FREE_C_HEAP_ARRAY(char, tmp_path);\n+    return false;\n+  } else {\n+    FREE_C_HEAP_ARRAY(char, tmp_path);\n+    return true;\n+  }\n+}\n+\n+typedef struct file_info {\n+  void*   ptr;\n+  size_t  size;\n+  int     fd;\n+} file_info;\n+\n+static file_info _open_file_and_read(const char* pattern, const char* path, int pid) {\n+  file_info info = { nullptr, 0, -1 };\n+\n+  char *file_path = NEW_C_HEAP_ARRAY(char, JVM_MAXPATHLEN, mtNMT);\n+  if (!_create_file_path_with_pid(path, pattern, file_path, pid)) {\n+    tty->print(\"Can't construct path [%s:%s:%d].\", pattern, path, pid);\n+    return info;\n+  }\n+\n+  info.fd = os::open(file_path, O_RDONLY, 0);\n+  if (info.fd == -1) {\n+    int e = errno;\n+    tty->print(\"Can't open file [%s].\", file_path);\n+    tty->print_raw_cr(os::strerror(e));\n+    return info;\n+  }\n+\n+  struct stat file_info;\n+  ::fstat(info.fd, &file_info);\n+  info.size = file_info.st_size;\n+  ::lseek(info.fd, 0, SEEK_SET);\n+\n+  info.ptr = ::mmap(NULL, info.size, PROT_READ, MAP_PRIVATE, info.fd, 0);\n+  assert(info.ptr != MAP_FAILED, \"info.ptr != MAP_FAILED\");\n+\n+  FREE_C_HEAP_ARRAY(char, file_path);\n+\n+  return info;\n+}\n+\n+void NMT_MemoryLogRecorder::initialize(intx limit) {\n+  fprintf(stderr, \"> NMT_MemoryLogRecorder::initialize(%ld)\\n\", limit);\n+  if ((NMTPrintMemoryAllocationsSizesFor != nullptr) && (strlen(NMTPrintMemoryAllocationsSizesFor) > 0)) {\n+    NMT_MemoryLogRecorder::printActualSizesFor((const char*)NMTPrintMemoryAllocationsSizesFor);\n+    os::exit(0);\n+    fprintf(stderr, \">> NMTPrintMemoryAllocationsSizesFor:%s\\n\", NMTPrintMemoryAllocationsSizesFor);\n+    fprintf(stderr, \">> os::exit()\\n\");\n+  }\n+  NMT_MemoryLogRecorder *recorder = NMT_MemoryLogRecorder::instance();\n+  recorder->init();\n+  recorder->lock();\n+  {\n+    recorder->_limit = limit;\n+    if (recorder->_limit > 0) {\n+      recorder->_log_fd = _prepare_log_file(nullptr, ALLOCS_LOG_FILE);\n+      fprintf(stderr, \">> _memLogRecorder._log_fd:%d\\n\", recorder->_log_fd);\n+      recorder->_done = false;\n+    } else {\n+      recorder->_done = true;\n+    }\n+  }\n+  recorder->unlock();\n+}\n+\n+void NMT_MemoryLogRecorder::finish(void) {\n+  NMT_MemoryLogRecorder *recorder = NMT_MemoryLogRecorder::instance();\n+  fprintf(stderr, \"NMT_MemoryLogRecorder::finish() %p\\n\", NMT_MemoryLogRecorder::instance());\n+  if (recorder->lockIfNotDone()) {\n+    volatile int log_fd = recorder->_log_fd;\n+    recorder->_log_fd = -1;\n+    fprintf(stderr, \" log_fd:%d\\n\", log_fd);\n+    log_fd = _close_and_check(log_fd);\n+    fprintf(stderr, \" log_fd:%d\\n\", log_fd);\n+\n+    int threads_fd = _prepare_log_file(nullptr, THREADS_LOG_FILE);\n+    fprintf(stderr, \" threads_fd:%d\\n\", threads_fd);\n+    if (threads_fd != -1) {\n+      _write_and_check(threads_fd, recorder->_threads_names, recorder->_threads_names_counter*sizeof(thread_name_info));\n+      threads_fd = _close_and_check(threads_fd);\n+      fprintf(stderr, \" threads_fd:%d\\n\", threads_fd);\n+    }\n+\n+    int info_fd = _prepare_log_file(nullptr, INFO_LOG_FILE);\n+    fprintf(stderr, \" info_fd:%d\\n\", info_fd);\n+    if (info_fd != -1) {\n+      size_t level = NMTUtil::parse_tracking_level(NativeMemoryTracking);\n+      _write_and_check(info_fd, &level, sizeof(level));\n+      size_t overhead = MemTracker::overhead_per_malloc();\n+      _write_and_check(info_fd, &overhead, sizeof(overhead));\n+      info_fd = _close_and_check(info_fd);\n+      fprintf(stderr, \" info_fd:%d\\n\", info_fd);\n+    }\n+\n+    recorder->_done = true;\n+    recorder->unlock();\n+  }\n+}\n+\n+void NMT_MemoryLogRecorder::replay(const char* path, const int pid) {\n+  fprintf(stderr, \"> NMT_MemoryLogRecorder::replay(\\\"%s\\\", %d)\\n\", path, pid);\n+  if ((pid != 0) && ((path == nullptr) || (strlen(path) == 0))) {\n+    static const char *home = \".\";\n+    path = home;\n+  }\n+  if ((path != nullptr) && (strlen(path) > 0)) {\n+    setlocale(LC_NUMERIC, \"\");\n+    NMT_MemoryLogRecorder *recorder = NMT_MemoryLogRecorder::instance();\n+    recorder->lock();\n+\n+    \/\/ compare the recorded and current levels of NMT and exit if different\n+    file_info log_fi = _open_file_and_read(INFO_LOG_FILE, path, pid);\n+    if (log_fi.fd == -1) {\n+      return;\n+    }\n+    size_t* status_file_bytes = (size_t*)log_fi.ptr;\n+    NMT_TrackingLevel recorded_nmt_level = (NMT_TrackingLevel)status_file_bytes[0];\n+    if (NMTUtil::parse_tracking_level(NativeMemoryTracking) != recorded_nmt_level) {\n+      tty->print(\"NativeMemoryTracking mismatch [%u != %u].\\n\", recorded_nmt_level, NMTUtil::parse_tracking_level(NativeMemoryTracking));\n+      tty->print(\"Re-run with \\\"-XX:NativeMemoryTracking=%s\\\"\\n\", NMTUtil::tracking_level_to_string(recorded_nmt_level));\n+      os::exit(-1);\n+    }\n+\n+    \/\/ open records file for reading the memory allocations to \"play back\"\n+    file_info records_fi = _open_file_and_read(ALLOCS_LOG_FILE, path, pid);\n+    if (records_fi.fd == -1) {\n+      return;\n+    }\n+    Entry* records_file_entries = (Entry*)records_fi.ptr;\n+    long int count = (records_fi.size \/ sizeof(Entry));\n+    size_t size_pointers = count * sizeof(address);\n+    address *pointers = (address*)::mmap(NULL, size_pointers, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0);\n+    assert(pointers != MAP_FAILED, \"pointers != MAP_FAILED\");\n+\n+    \/\/ open benchmark file for writing the final results\n+    char *benchmark_file_path = NEW_C_HEAP_ARRAY(char, JVM_MAXPATHLEN, mtNMT);\n+    if (!_create_file_path_with_pid(path, BENCHMARK_LOG_FILE, benchmark_file_path, pid)) {\n+      tty->print(\"Can't construct benchmark_file_path [%s].\", benchmark_file_path);\n+      os::exit(-1);\n+    }\n+    int benchmark_fd = _prepare_log_file(benchmark_file_path, nullptr);\n+    if (benchmark_fd == -1) {\n+      tty->print(\"Can't open [%s].\", benchmark_file_path);\n+      os::exit(-1);\n+    }\n+\n+    jlong nanoseconds = 0;\n+    jlong requestedTotal = 0;\n+    jlong actualTotal = 0;\n+    fprintf(stderr, \"benchmarking \\\"%s\\\"\\n\", benchmark_file_path);\n+    for (off_t i = 0; i < count; i++) {\n+      Entry *e = &records_file_entries[i];\n+      MemTag mem_tag = NMTUtil::index_to_tag((int)e->mem_tag);\n+      int frameCount;\n+      for (frameCount = 0; frameCount < NMT_TrackingStackDepth; frameCount++) {\n+        if (e->stack[frameCount] == 0) {\n+          break;\n+        }\n+      }\n+      NativeCallStack stack = NativeCallStack::empty_stack();\n+      if (frameCount > 0) {\n+        stack = NativeCallStack(e->stack, frameCount);\n+      }\n+      jlong requested = 0;\n+      jlong actual = 0;\n+      pointers[i] = nullptr;\n+      jlong start = 0;\n+      jlong end = 0;\n+      {\n+        if (IS_MALLOC(e) || (IS_MALLOC_REALLOC(e))) {\n+          address client_ptr = nullptr;\n+          start = os::javaTimeNanos();\n+          {\n+            client_ptr = (address)os::malloc(e->requested, mem_tag, stack);\n+          }\n+          end = os::javaTimeNanos();\n+          requested = e->requested;\n+          actual = e->actual;\n+          pointers[i] = client_ptr;\n+        } else if (IS_REALLOC(e)) {\n+          \/\/ the recorded \"realloc\" was captured in a different process,\n+          \/\/ so find the corresponding \"malloc\" or \"realloc\" in this process\n+          for (off_t j = i-1; j >= 0; j--) {\n+            Entry *p = &records_file_entries[j];\n+            if (e->old == p->ptr) {\n+              address ptr = pointers[j];\n+              requested -= p->requested;\n+              actual -= p->actual;\n+              start = os::javaTimeNanos();\n+              {\n+                ptr = (address)os::realloc(ptr, e->requested, mem_tag, stack);\n+              }\n+              end = os::javaTimeNanos();\n+              requested += e->requested;\n+              actual += e->actual;\n+              pointers[i] = ptr;\n+              pointers[j] = nullptr;\n+              break;\n+            }\n+          }\n+        } else if (IS_FREE(e)) {\n+          \/\/ the recorded \"free\" was captured in a different process,\n+          \/\/ so find the corresponding \"malloc\" or \"realloc\" in this process\n+          for (off_t j = i-1; j >= 0; j--) {\n+            Entry *p = &records_file_entries[j];\n+            if ((e->old == p->ptr) || (e->ptr == p->ptr)) {\n+              void* ptr = pointers[j];\n+              requested -= p->requested;\n+              actual -= p->actual;\n+              start = os::javaTimeNanos();\n+              {\n+                os::free(ptr);\n+              }\n+              end = os::javaTimeNanos();\n+              pointers[i] = nullptr;\n+              pointers[j] = nullptr;\n+              break;\n+            }\n+          }\n+        } else {\n+          fprintf(stderr, \"HUH?\\n\");\n+          os::exit(-1);\n+        }\n+        requestedTotal += requested;\n+        actualTotal += actual;\n+        \/\/fprintf(stderr, \"requested:%ld, actual:%ld\\n\", requested, actual);\n+      }\n+      jlong duration = (start > 0) ? (end - start) : 0;\n+      nanoseconds += duration;\n+\n+      _write_and_check(benchmark_fd, &duration, sizeof(duration));\n+      _write_and_check(benchmark_fd, &requested, sizeof(requested));\n+      _write_and_check(benchmark_fd, &actual, sizeof(actual));\n+      char type = (IS_MALLOC(e) * 1) | (IS_REALLOC(e) * 2) | (IS_FREE(e) * 4);\n+      _write_and_check(benchmark_fd, &type, sizeof(type));\n+      \/\/fprintf(stderr, \" %9ld:%9ld:%9ld %d:%d:%d\\n\", requested, actual, duration, IS_MALOC(e), IS_REALLOC(e), IS_FREE(e));\n+    }\n+    jlong overhead = actualTotal - requestedTotal;\n+    double overheadPercentage = 100.0 * (double)overhead \/ (double)requestedTotal;\n+    fprintf(stderr, \"time:%'ld[ns] [samples:%'ld] memory overhead=%'zu bytes [%.2f%%] [requestedTotal=%'zu actualTotal=%'zu]\\n\", nanoseconds, count, overhead, overheadPercentage, requestedTotal, actualTotal);\n+\n+    _close_and_check(log_fi.fd);\n+    _close_and_check(records_fi.fd);\n+    _close_and_check(benchmark_fd);\n+    FREE_C_HEAP_ARRAY(char, benchmark_file_path);\n+\n+    for (off_t i = 0; i < count; i++) {\n+      if (pointers[i] != nullptr) {\n+        os::free(pointers[i]);\n+        pointers[i] = nullptr;\n+      }\n+    }\n+    munmap((void*)pointers, size_pointers);\n+\n+    recorder->unlock();\n+\n+    os::exit(0);\n+  }\n+}\n+\n+void NMT_MemoryLogRecorder::_log(MemTag mem_tag, size_t requested, address ptr, address old, const NativeCallStack *stack) {\n+  NMT_MemoryLogRecorder *recorder = NMT_MemoryLogRecorder::instance();\n+  \/\/fprintf(stderr, \"NMT_MemoryLogRecorder::log(%16s, %6ld, %12p, %12p)\\n\", NMTUtil::tag_to_name(mem_tag), requested, ptr, old);\n+  if (recorder->lockIfNotDone()) {\n+    volatile intx count = recorder->_count++;\n+    if (count < recorder->_limit) {\n+      Entry entry;\n+      entry.time = count;\n+      if (MemTracker::is_initialized())\n+      {\n+        entry.time = os::javaTimeNanos();\n+      }\n+      entry.thread = os::current_thread_id();\n+      entry.ptr = ptr;\n+      entry.old = old;\n+      entry.requested = requested;\n+      entry.actual = 0;\n+      if (entry.requested > 0)\n+      {\n+        entry.actual = NMT_LogRecorder::mallocSize(ptr);\n+      }\n+\n+      entry.mem_tag = (jlong)mem_tag;\n+      if ((MemTracker::is_initialized()) && (stack != nullptr)) {\n+        \/\/ recording stack frames will make sure that the hashtables\n+        \/\/ are used, so they get benchmarked\n+        for (int i = 0; i < NMT_TrackingStackDepth; i++) {\n+          entry.stack[i] = stack->get_frame(i);\n+        }\n+      }\n+\n+      if (recorder->_log_fd != -1) {\n+        _write_and_check(recorder->_log_fd, &entry, sizeof(Entry));\n+      }\n+    } else {\n+      recorder->finish();\n+    }\n+\n+    recorder->unlock();\n+  }\n+}\n+\n+void NMT_MemoryLogRecorder::log_free(void *ptr)\n+{\n+  NMT_MemoryLogRecorder::_log(mtNone, 0, (address)ptr, nullptr, nullptr);\n+}\n+\n+void NMT_MemoryLogRecorder::log_malloc(MemTag mem_tag, size_t requested, void* ptr, const NativeCallStack *stack)\n+{\n+  NMT_MemoryLogRecorder::_log(mem_tag, requested, (address)ptr, nullptr, stack);\n+}\n+\n+void NMT_MemoryLogRecorder::log_realloc(MemTag mem_tag, size_t requested, void* ptr, void* old, const NativeCallStack *stack)\n+{\n+  if (old == nullptr)\n+  {\n+    \/\/ mark the realloc's old pointer, so that we can tell realloc(NULL) and malloc() apart\n+    old = REALLOC_MARKER;\n+  }\n+  NMT_MemoryLogRecorder::_log(mem_tag, requested, (address)ptr, (address)old, stack);\n+}\n+\n+void NMT_MemoryLogRecorder::printActualSizesFor(const char* list) {\n+fprintf(stderr, \"NMT_MemoryLogRecorder::printActualSizesFor(%s)\\n\", list);\n+  char* string = os::strdup(NMTPrintMemoryAllocationsSizesFor, mtNMT);\n+  if (string != nullptr) {\n+    char* token = permit_forbidden_function::strtok(string, \",\");\n+    while (token) {\n+      long requested =  permit_forbidden_function::strtol(token, nullptr, 10);\n+      long actual = 0;\n+      void *ptr = permit_forbidden_function::malloc(requested);\n+      if (ptr != nullptr) {\n+        actual = NMT_LogRecorder::mallocSize(ptr);\n+        permit_forbidden_function::free(ptr);\n+      }\n+      printf(\"%ld\", actual);\n+        token = permit_forbidden_function::strtok(NULL, \",\");\n+      if (token) {\n+        printf(\",\");\n+      }\n+    }\n+    os::exit(0);\n+  }\n+}\n+void NMT_MemoryLogRecorder::print(Entry *e) {\n+  if (e == nullptr) {\n+    fprintf(stderr, \"nullptr\\n\");\n+  } else {\n+    if (IS_FREE(e)) {\n+      fprintf(stderr, \"           FREE: \");\n+    } else if (IS_REALLOC(e)) {\n+      fprintf(stderr, \"        REALLOC: \");\n+    } else if (IS_MALLOC_REALLOC(e)) {\n+      fprintf(stderr, \"MALLOC\/RERALLOC: \");\n+    } else if (IS_MALLOC(e)) {\n+      fprintf(stderr, \"         MALLOC: \");\n+    }\n+    fprintf(stderr, \"time:%15ld, thread:%6ld, ptr:%14p, old:%14p, requested:%8ld, actual:%8ld, mem_tag:%s\\n\", e->time, e->thread, e->ptr, e->old, e->requested, e->actual, NMTUtil::tag_to_name(NMTUtil::index_to_tag((int)e->mem_tag)));\n+  }\n+}\n+\n+static inline const char* type_to_name(NMT_VirtualMemoryLogRecorder::Type type) {\n+  switch (type) {\n+    case NMT_VirtualMemoryLogRecorder::Type::RESERVE: return \"RESERVE\"; break;\n+    case NMT_VirtualMemoryLogRecorder::Type::RELEASE: return \"RELEASE\"; break;\n+    case NMT_VirtualMemoryLogRecorder::Type::UNCOMMIT: return \"UNCOMMIT\"; break;\n+    case NMT_VirtualMemoryLogRecorder::Type::RESERVE_AND_COMMIT: return \"RESERVE_AND_COMMIT\"; break;\n+    case NMT_VirtualMemoryLogRecorder::Type::COMMIT: return \"COMMIT\"; break;\n+    case NMT_VirtualMemoryLogRecorder::Type::SPLIT_RESERVED: return \"SPLIT_RESERVED\"; break;\n+    case NMT_VirtualMemoryLogRecorder::Type::TAG: return \"TAG\"; break;\n+    default: break;\n+  }\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::initialize(intx limit) {\n+  fprintf(stderr, \"> NMT_VirtualMemoryLogRecorder::initialize(%ld)\\n\", limit);\n+  NMT_VirtualMemoryLogRecorder *recorder = NMT_VirtualMemoryLogRecorder::instance();\n+  recorder->init();\n+  recorder->lock();\n+  {\n+    recorder->_limit = limit;\n+    if (recorder->_limit > 0) {\n+      recorder->_log_fd = _prepare_log_file(nullptr, VALLOCS_LOG_FILE);\n+      fprintf(stderr, \">> _memLogRecorder._log_fd:%d\\n\", recorder->_log_fd);\n+      recorder->_done = false;\n+    } else {\n+      recorder->_done = true;\n+    }\n+  }\n+  recorder->unlock();\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::finish(void) {\n+  fprintf(stderr, \"NMT_VirtualMemoryLogRecorder::finish()\\n\");\n+  NMT_VirtualMemoryLogRecorder *recorder = NMT_VirtualMemoryLogRecorder::instance();\n+  if (recorder->lockIfNotDone()) {\n+      volatile int log_fd = recorder->_log_fd;\n+    recorder->_log_fd = -1;\n+      \/\/fprintf(stderr, \" log_fd:%d\\n\", log_fd);\n+      log_fd = _close_and_check(log_fd);\n+  }\n+\n+  int info_fd = _prepare_log_file(nullptr, INFO_LOG_FILE);\n+  fprintf(stderr, \" info_fd:%d\\n\", info_fd);\n+  if (info_fd != -1) {\n+    size_t level = NMTUtil::parse_tracking_level(NativeMemoryTracking);\n+    _write_and_check(info_fd, &level, sizeof(level));\n+    size_t overhead = MemTracker::overhead_per_malloc();\n+    _write_and_check(info_fd, &overhead, sizeof(overhead));\n+    info_fd = _close_and_check(info_fd);\n+    fprintf(stderr, \" info_fd:%d\\n\", info_fd);\n+  }\n+\n+  recorder->_done = true;\n+  recorder->unlock();\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::replay(const char* path, const int pid) {\n+    fprintf(stderr, \"NMT_VirtualMemoryLogRecorder::replay(\\\"%s\\\", %d)\\n\", path, pid);\n+  if ((pid != 0) && ((path == nullptr) || (strlen(path) == 0))) {\n+    static const char *home = \".\";\n+    path = home;\n+  }\n+  if ((path != nullptr) && (strlen(path) > 0)) {\n+    \/\/ compare the recorded and current levels of NMT and exit if different\n+    \/\/    file_info log_fi = _open_file_and_read(INFO_LOG_FILE, path, pid);\n+    \/\/    size_t* status_file_bytes = (size_t*)log_fi.ptr;\n+    \/\/    NMT_TrackingLevel recorded_nmt_level = (NMT_TrackingLevel)status_file_bytes[0];\n+    \/\/    if (NMTUtil::parse_tracking_level(NativeMemoryTracking) != recorded_nmt_level) {\n+    \/\/      tty->print(\"NativeMemoryTracking mismatch [%u != %u].\\n\", recorded_nmt_level, NMTUtil::parse_tracking_level(NativeMemoryTracking));\n+    \/\/      tty->print(\"Re-run with \\\"-XX:NativeMemoryTracking=%s\\\"\\n\", NMTUtil::tracking_level_to_string(recorded_nmt_level));\n+    \/\/      os::exit(-1);\n+    \/\/    }\n+\n+    \/\/ open records file for reading the virtual memory allocations to \"play back\"\n+    file_info records_fi = _open_file_and_read(VALLOCS_LOG_FILE, path, pid);\n+    Entry* records_file_entries = (Entry*)records_fi.ptr;\n+    long int count = (records_fi.size \/ sizeof(Entry));\n+\n+    jlong total = 0;\n+    for (off_t l = 0; l < NMTBenchmarkRecordedLoops; l++) {\n+      \/\/VirtualMemoryTracker::Instance::initialize(NMTUtil::parse_tracking_level(NativeMemoryTracking));\n+      for (off_t i = 0; i < count; i++) {\n+        Entry *e = &records_file_entries[i];\n+        \n+        MemTag mem_tag = mtNone; \/\/NMTUtil::index_to_tag((int)e->mem_tag);\n+        int frameCount;\n+        for (frameCount = 0; frameCount < NMT_TrackingStackDepth; frameCount++) {\n+          if (e->stack[frameCount] == 0) {\n+            break;\n+          }\n+        }\n+        NativeCallStack stack = NativeCallStack::empty_stack();\n+        if (frameCount > 0) {\n+          stack = NativeCallStack(e->stack, frameCount);\n+        }\n+\n+        jlong start = os::javaTimeNanos();\n+        {\n+          switch (e->type) {\n+            case NMT_VirtualMemoryLogRecorder::Type::RESERVE:\n+              \/\/fprintf(stderr, \"[record_virtual_memory_reserve(%p, %zu, %p, %hhu)\\n\", e->ptr, e->size, &stack, mem_tag);fflush(stderr);\n+              MemTracker::record_virtual_memory_reserve(e->ptr, e->size, stack, mem_tag);\n+              \/\/fprintf(stderr, \"]\\n\");fflush(stderr);\n+              break;\n+            case NMT_VirtualMemoryLogRecorder::Type::RELEASE:\n+              \/\/fprintf(stderr, \"[record_virtual_memory_release(%p, %zu)\\n\", e->ptr, e->size);fflush(stderr);\n+              MemTracker::record_virtual_memory_release(e->ptr, e->size);\n+              \/\/fprintf(stderr, \"]\\n\");fflush(stderr);\n+              break;\n+            case NMT_VirtualMemoryLogRecorder::Type::UNCOMMIT:\n+              \/\/fprintf(stderr, \"<record_virtual_memory_uncommit(%p, %zu)\\n\", e->ptr, e->size);fflush(stderr);\n+              MemTracker::record_virtual_memory_uncommit(e->ptr, e->size);\n+              \/\/fprintf(stderr, \">\\n\");fflush(stderr);\n+              break;\n+            case NMT_VirtualMemoryLogRecorder::Type::RESERVE_AND_COMMIT:\n+              \/\/fprintf(stderr, \"[MemTracker::record_virtual_memory_reserve_and_commit\\n\");\n+              MemTracker::record_virtual_memory_reserve_and_commit(e->ptr, e->size, stack, mem_tag);\n+              \/\/fprintf(stderr, \"]\\n\");fflush(stderr);\n+              break;\n+            case NMT_VirtualMemoryLogRecorder::Type::COMMIT:\n+              \/\/fprintf(stderr, \"[record_virtual_memory_commit(%p, %zu, %p)\\n\", e->ptr, e->size, &stack);fflush(stderr);\n+              MemTracker::record_virtual_memory_commit(e->ptr, e->size, stack);\n+              \/\/fprintf(stderr, \"]\\n\");fflush(stderr);\n+              break;\n+            case NMT_VirtualMemoryLogRecorder::Type::SPLIT_RESERVED:\n+              \/\/fprintf(stderr, \"[MemTracker::record_virtual_memory_split_reserved\\n\");\n+              MemTracker::record_virtual_memory_split_reserved(e->ptr, e->size, e->size_split, mem_tag, NMTUtil::index_to_tag((int)e->mem_tag_split));\n+              \/\/fprintf(stderr, \"]\\n\");fflush(stderr);\n+              break;\n+            case NMT_VirtualMemoryLogRecorder::Type::TAG:\n+              \/\/fprintf(stderr, \"[record_virtual_memory_type(%p, %zu, %p)\\n\", e->ptr, e->size, &stack);fflush(stderr);\n+              MemTracker::record_virtual_memory_tag(e->ptr, mem_tag);\n+              \/\/fprintf(stderr, \"]\\n\");fflush(stderr);\n+              break;\n+            default:\n+              fprintf(stderr, \"HUH?\\n\");\n+              os::exit(-1);\n+              break;\n+          }\n+        }\n+        jlong end = os::javaTimeNanos();\n+        jlong duration = (start > 0) ? (end - start) : 0;\n+        total += duration;\n+      }\n+    }\n+    fprintf(stderr, \"time:%ld[ns] [samples:%ld] [loops:%ld]\\n\", total, count, NMTBenchmarkRecordedLoops);\n+\n+\/\/    if (count > 0) {\n+\/\/      nullStream bench_null;\n+\/\/      total = 0;\n+\/\/      for (off_t l = 0; l < 1; l++) {\n+\/\/        jlong start = os::javaTimeNanos();\n+\/\/        VirtualMemoryTracker::Instance::print_self(tty);\n+\/\/        jlong end = os::javaTimeNanos();\n+\/\/        jlong duration = (start > 0) ? (end - start) : 0;\n+\/\/        total += duration;\n+\/\/      }\n+\/\/      fprintf(stderr, \"loops:%d total:%ld\\n\", NMTBenchmarkRecordedLoops, total);\n+\/\/    }\n+\n+    _close_and_check(records_fi.fd);\n+\n+    os::exit(0);\n+  }\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::_log(NMT_VirtualMemoryLogRecorder::Type type, MemTag mem_tag, MemTag mem_tag_split, size_t size, size_t size_split, address ptr, const NativeCallStack *stack) {\n+  \/\/fprintf(stderr, \"NMT_VirtualMemoryLogRecorder::log (%s, %hhu, %hhu, %zu, %zu, %p, %p)\\n\",\n+  \/\/        type_to_name(type), mem_tag, mem_tag_split, size, size_split, ptr, stack);fflush(stderr);\n+  NMT_VirtualMemoryLogRecorder *recorder = NMT_VirtualMemoryLogRecorder::instance();\n+  if (recorder->lockIfNotDone()) {\n+    volatile intx count = recorder->_count++;\n+    if (count < recorder->_limit) {\n+      Entry entry;\n+      entry.type = type;\n+      entry.time = count;\n+      if (MemTracker::is_initialized())\n+      {\n+        entry.time = os::javaTimeNanos();\n+      }\n+      entry.thread = os::current_thread_id();\n+      entry.ptr = ptr;\n+      entry.mem_tag = (jlong)mem_tag;\n+      entry.mem_tag_split = (jlong)mem_tag_split;\n+      entry.size = size;\n+      entry.size_split = size_split;\n+      if ((MemTracker::is_initialized()) && (stack != nullptr)) {\n+        \/\/ the only use of frames is for benchmarking -\n+        \/\/ the NMT code uses a hashtable to store these values,\n+        \/\/ so preserving these will make sure that the hashtables\n+        \/\/ are used when ran with this data\n+        for (int i = 0; i < NMT_TrackingStackDepth; i++) {\n+          entry.stack[i] = stack->get_frame(i);\n+        }\n+      }\n+      fprintf(stderr, \"recorder->_log_fd: %d\\n\", recorder->_log_fd);\n+      if (recorder->_log_fd != -1) {\n+        _write_and_check(recorder->_log_fd, &entry, sizeof(Entry));\n+      }\n+    } else {\n+      recorder->finish();\n+    }\n+\n+    recorder->unlock();\n+  }\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::log_virtual_memory_reserve(void* addr, size_t size, const NativeCallStack& stack, MemTag mem_tag) {\n+  NMT_VirtualMemoryLogRecorder::_log(Type::RESERVE, mem_tag, mtNone, size, 0, (address)addr, &stack);\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::log_virtual_memory_release(address addr, size_t size) {\n+  NMT_VirtualMemoryLogRecorder::_log(Type::RELEASE, mtNone, mtNone, size, 0, (address)addr, nullptr);\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::log_virtual_memory_uncommit(address addr, size_t size) {\n+  NMT_VirtualMemoryLogRecorder::_log(Type::UNCOMMIT, mtNone, mtNone, size, 0, (address)addr, nullptr);\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::log_virtual_memory_reserve_and_commit(void* addr, size_t size, const NativeCallStack& stack, MemTag mem_tag) {\n+  NMT_VirtualMemoryLogRecorder::_log(Type::RESERVE_AND_COMMIT, mem_tag, mtNone, size, 0, (address)addr, &stack);\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::log_virtual_memory_commit(void* addr, size_t size, const NativeCallStack& stack) {\n+  NMT_VirtualMemoryLogRecorder::_log(Type::COMMIT, mtNone, mtNone, size, 0, (address)addr, &stack);\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::log_virtual_memory_split_reserved(void* addr, size_t size, size_t split, MemTag mem_tag, MemTag split_mem_tag) {\n+  NMT_VirtualMemoryLogRecorder::_log(Type::SPLIT_RESERVED, mem_tag, split_mem_tag, size, split, (address)addr, nullptr);\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::log_virtual_memory_tag(void* addr, MemTag mem_tag) {\n+  NMT_VirtualMemoryLogRecorder::_log(Type::TAG, mem_tag, mtNone, 0, 0, (address)addr, nullptr);\n+}\n+\n","filename":"src\/hotspot\/share\/nmt\/memLogRecorder.cpp","additions":843,"deletions":0,"binary":false,"changes":843,"status":"added"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_NMT_MEMLOGRECORDER_HPP\n+#define SHARE_NMT_MEMLOGRECORDER_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"nmt\/nmtCommon.hpp\"\n+#include \"runtime\/globals.hpp\"\n+\n+class NMT_LogRecorder : public StackObj {\n+#if defined(LINUX) || defined(__APPLE__)\n+  pthread_mutex_t _mutex;\n+#elif defined(WINDOWS)\n+ \/\/ ???\n+#endif\n+protected:\n+  intx _limit  = 0;\n+  intx _count  = 0;\n+  int _log_fd;\n+  volatile bool _done = true;\n+  static constexpr size_t _threads_name_length = 32;\n+  volatile size_t _threads_names_capacity = 128;\n+  volatile size_t _threads_names_counter = 0;\n+  typedef struct thread_name_info {\n+    char name[_threads_name_length];\n+    intx thread;\n+  } thread_name_info;\n+  thread_name_info *_threads_names = nullptr;\n+\n+public:\n+  static void initialize(intx memoryCount, intx virtualMemoryCount);\n+  static void finish();\n+  static void replay(const char* path, const int pid);\n+  static void logThreadName(const char* name);\n+  static size_t mallocSize(void* ptr);\n+\n+public:\n+  void init();\n+  bool lockIfNotDone();\n+  void lock();\n+  void unlock();\n+  bool done() {\n+    return _done;\n+  }\n+\n+private:\n+  void _logThreadName(const char* name);\n+};\n+\n+class NMT_MemoryLogRecorder : public NMT_LogRecorder {\n+\n+private:\n+  static NMT_MemoryLogRecorder _recorder;\n+\n+private:\n+    struct Entry {\n+    jlong time;\n+    intx thread;\n+    address ptr;\n+    address old;\n+    address stack[NMT_TrackingStackDepth];\n+    size_t requested;\n+    size_t actual;\n+    jlong mem_tag;\n+  };\n+\n+public:\n+  static NMT_MemoryLogRecorder* instance() {\n+    return &_recorder;\n+  };\n+  static void initialize(intx count);\n+  static bool initialized() {\n+    return false;\n+  }\n+  static void print(Entry *e);\n+  static void finish(void);\n+  static void replay(const char* path, const int pid);\n+  static void log_free(void *ptr);\n+  static void log_malloc(MemTag mem_tag, size_t requested, void* ptr, const NativeCallStack *stack);\n+  static void log_realloc(MemTag mem_tag, size_t requested, void* ptr, void* old, const NativeCallStack *stack);\n+  static void printActualSizesFor(const char* list);\n+\n+private:\n+  static void _log(MemTag mem_tag, size_t requested, address ptr, address old, const NativeCallStack *stack);\n+};\n+\n+class NMT_VirtualMemoryLogRecorder : public NMT_LogRecorder {\n+\n+private:\n+  static NMT_VirtualMemoryLogRecorder _recorder;\n+\n+private:\n+  struct Entry {\n+    jlong time;\n+    intx thread;\n+    address ptr;\n+    address stack[NMT_TrackingStackDepth];\n+    jlong mem_tag;\n+    jlong mem_tag_split;\n+    size_t size;\n+    size_t size_split;\n+    int type;\n+  };\n+\n+public:\n+  enum Type {\n+    RESERVE,\n+    RELEASE,\n+    UNCOMMIT,\n+    RESERVE_AND_COMMIT,\n+    COMMIT,\n+    SPLIT_RESERVED,\n+    TAG\n+  };\n+\n+public:\n+  static NMT_VirtualMemoryLogRecorder* instance() {\n+    return &_recorder;\n+  };\n+  static void initialize(intx count);\n+  static void finish(void);\n+  static void replay(const char* path, const int pid);\n+  static void log_virtual_memory_reserve(void* addr, size_t size, const NativeCallStack& stack, MemTag mem_tag = mtNone);\n+  static void log_virtual_memory_release(address addr, size_t size);\n+  static void log_virtual_memory_uncommit(address addr, size_t size);\n+  static void log_virtual_memory_reserve_and_commit(void* addr, size_t size, const NativeCallStack& stack, MemTag mem_tag = mtNone);\n+  static void log_virtual_memory_commit(void* addr, size_t size, const NativeCallStack& stack);\n+  static void log_virtual_memory_split_reserved(void* addr, size_t size, size_t split, MemTag flag, MemTag mem_tag_split);\n+  static void log_virtual_memory_tag(void* addr, MemTag mem_tag);\n+\n+private:\n+  static void _log(NMT_VirtualMemoryLogRecorder::Type type, MemTag mem_tag, MemTag mem_tag_split, size_t size, size_t size_split, address ptr, const NativeCallStack *stack);\n+};\n+\n+#endif \/\/ SHARE_NMT_MEMLOGRECORDER_HPP\n","filename":"src\/hotspot\/share\/nmt\/memLogRecorder.hpp","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -56,0 +56,2 @@\n+  NMT_LogRecorder::initialize(NMTRecordMemoryAllocations, NMTRecordVirtualMemoryAllocations);\n+\n@@ -96,0 +98,2 @@\n+\n+  NMT_LogRecorder::replay(NMTBenchmarkRecordedDir, NMTBenchmarkRecordedPID);\n","filename":"src\/hotspot\/share\/nmt\/memTracker.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"nmt\/memLogRecorder.hpp\"\n@@ -129,0 +130,1 @@\n+      NMT_VirtualMemoryLogRecorder::log_virtual_memory_reserve((address)addr, size, stack, mem_tag);\n@@ -137,0 +139,1 @@\n+      NMT_VirtualMemoryLogRecorder::log_virtual_memory_release((address)addr, size);\n@@ -145,0 +148,1 @@\n+      NMT_VirtualMemoryLogRecorder::log_virtual_memory_uncommit((address)addr, size);\n@@ -155,0 +159,1 @@\n+      NMT_VirtualMemoryLogRecorder::log_virtual_memory_reserve_and_commit((address)addr, size, stack, mem_tag);\n@@ -166,0 +171,1 @@\n+      NMT_VirtualMemoryLogRecorder::log_virtual_memory_commit((address)addr, size, stack);\n@@ -214,0 +220,1 @@\n+      NMT_VirtualMemoryLogRecorder::log_virtual_memory_split_reserved((address)addr, size, split, mem_tag, split_tag);\n@@ -223,0 +230,1 @@\n+      NMT_VirtualMemoryLogRecorder::log_virtual_memory_tag((address)addr, mem_tag);\n","filename":"src\/hotspot\/share\/nmt\/memTracker.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3924,1 +3924,1 @@\n-                                char* buf, size_t buflen) {\n+                                char* buf, size_t buflen, int pid) {\n@@ -3940,1 +3940,4 @@\n-        int ret = jio_snprintf(b, buf_sz, \"%d\", os::current_process_id());\n+        if (pid == 0) {\n+          pid = os::current_process_id();\n+        }\n+        int ret = jio_snprintf(b, buf_sz, \"%d\", pid);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -510,1 +510,1 @@\n-  static bool copy_expand_pid(const char* src, size_t srclen, char* buf, size_t buflen);\n+  static bool copy_expand_pid(const char* src, size_t srclen, char* buf, size_t buflen, int pid = 0);\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -580,0 +580,27 @@\n+  product(intx, NMTRecordMemoryAllocations, 0, DIAGNOSTIC,                  \\\n+          \"Record the specified number of memory allocations.\"              \\\n+          \" 0: (the default) disables this feature.\"                        \\\n+          \" max_jint (0x7FFFFFFF): keep recording until the process exits\") \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n+  product(intx, NMTRecordVirtualMemoryAllocations, 0, DIAGNOSTIC,           \\\n+          \"Record the specified number of virtual memory allocations.\"      \\\n+          \" 0: (the default) disables this feature.\"                        \\\n+          \" max_jint (0x7FFFFFFF): keep recording until the process exits\") \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n+  product(ccstr, NMTBenchmarkRecordedDir, nullptr, DIAGNOSTIC,              \\\n+          \"Benchmark memory allocations using results found in folder\")     \\\n+                                                                            \\\n+  product(int, NMTBenchmarkRecordedPID, 0, DIAGNOSTIC,                      \\\n+          \"Benchmark memory allocations using results recorderd with PID\")  \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n+  product(int, NMTBenchmarkRecordedLoops, 1, DIAGNOSTIC,                    \\\n+          \"Benchmark memory allocations specified number of times\")         \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n+  product(ccstrlist, NMTPrintMemoryAllocationsSizesFor, nullptr, DIAGNOSTIC,\\\n+          \"Print the actual allocated memory sizes for given \"              \\\n+          \"comma separated list of malloc sizes\")                           \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -665,0 +665,2 @@\n+  NMT_MemoryLogRecorder::log_malloc(mem_tag, outer_size, outer_ptr, &stack);\n+\n@@ -735,0 +737,3 @@\n+\n+    NMT_MemoryLogRecorder::log_realloc(mem_tag, new_outer_size, new_outer_ptr, header, &stack);\n+\n@@ -783,0 +788,2 @@\n+  NMT_MemoryLogRecorder::log_free(old_outer_ptr);\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"nmt\/memLogRecorder.hpp\"\n@@ -358,0 +359,1 @@\n+    NMT_LogRecorder::logThreadName(name);\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -928,0 +928,2 @@\n+  NMT_LogRecorder::finish();\n+\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -564,0 +564,1 @@\n+  NMT_LogRecorder::finish();\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,6 @@\n+#if defined(LINUX)\n+#include <malloc.h>\n+#elif defined(__APPLE__)\n+#include <malloc\/malloc.h>\n+#endif\n+\n@@ -70,0 +76,11 @@\n+inline char *strtok(char *str, const char *sep) { return ::strtok(str, sep); }\n+inline long strtol(const char *str, char **endptr, int base) { return ::strtol(str, endptr, base); }\n+\n+#if defined(LINUX)\n+inline size_t malloc_usable_size(void *_Nullable ptr) { return ::malloc_usable_size(ptr); }\n+#elif defined(WINDOWS)\n+inline size_t _msize(void *memblock) { return ::_msize(memblock); }\n+#elif defined(__APPLE__)\n+inline size_t malloc_size(const void *ptr) { return ::malloc_size(ptr); }\n+#endif\n+\n","filename":"src\/hotspot\/share\/utilities\/permitForbiddenFunctions.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1804,0 +1804,2 @@\n+  NMT_LogRecorder::finish();\n+\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}