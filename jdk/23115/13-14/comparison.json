{"files":[{"patch":"@@ -93,3 +93,3 @@\n-void NMT_LogRecorder::replay(const char* path, const int pid) {\n-  NMT_MemoryLogRecorder::instance()->replay(path, pid);\n-  NMT_VirtualMemoryLogRecorder::instance()->replay(path, pid);\n+void NMT_LogRecorder::replay(const int pid) {\n+  NMT_MemoryLogRecorder::instance()->replay(pid);\n+  NMT_VirtualMemoryLogRecorder::instance()->replay(pid);\n@@ -341,1 +341,1 @@\n-void NMT_MemoryLogRecorder::replay(const char* path, const int pid) {\n+void NMT_MemoryLogRecorder::replay(const int pid) {\n@@ -343,21 +343,4 @@\n-  if ((pid != 0) && ((path == nullptr) || (strlen(path) == 0))) {\n-    static const char *home = \".\";\n-    path = home;\n-  }\n-  if ((path != nullptr) && (strlen(path) > 0)) {\n-    setlocale(LC_NUMERIC, \"\");\n-    NMT_MemoryLogRecorder *recorder = NMT_MemoryLogRecorder::instance();\n-    recorder->lock();\n-\n-    \/\/ compare the recorded and current levels of NMT and exit if different\n-    file_info log_fi = _open_file_and_read(INFO_LOG_FILE, path, pid);\n-    if (log_fi.fd == -1) {\n-      return;\n-    }\n-    size_t* status_file_bytes = (size_t*)log_fi.ptr;\n-    NMT_TrackingLevel recorded_nmt_level = (NMT_TrackingLevel)status_file_bytes[0];\n-    if (NMTUtil::parse_tracking_level(NativeMemoryTracking) != recorded_nmt_level) {\n-      tty->print(\"NativeMemoryTracking mismatch [%u != %u].\\n\", recorded_nmt_level, NMTUtil::parse_tracking_level(NativeMemoryTracking));\n-      tty->print(\"Re-run with \\\"-XX:NativeMemoryTracking=%s\\\"\\n\", NMTUtil::tracking_level_to_string(recorded_nmt_level));\n-      os::exit(-1);\n-    }\n+  static const char *path = \".\";\n+  setlocale(LC_NUMERIC, \"\");\n+  NMT_MemoryLogRecorder *recorder = NMT_MemoryLogRecorder::instance();\n+  recorder->lock();\n@@ -365,16 +348,49 @@\n-    \/\/ open records file for reading the memory allocations to \"play back\"\n-    file_info records_fi = _open_file_and_read(ALLOCS_LOG_FILE, path, pid);\n-    if (records_fi.fd == -1) {\n-      return;\n-    }\n-    Entry* records_file_entries = (Entry*)records_fi.ptr;\n-    long int count = (records_fi.size \/ sizeof(Entry));\n-    size_t size_pointers = count * sizeof(address);\n-    address *pointers = (address*)::mmap(NULL, size_pointers, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0);\n-    assert(pointers != MAP_FAILED, \"pointers != MAP_FAILED\");\n-\n-    \/\/ open benchmark file for writing the final results\n-    char *benchmark_file_path = NEW_C_HEAP_ARRAY(char, JVM_MAXPATHLEN, mtNMT);\n-    if (!_create_file_path_with_pid(path, BENCHMARK_LOG_FILE, benchmark_file_path, pid)) {\n-      tty->print(\"Can't construct benchmark_file_path [%s].\", benchmark_file_path);\n-      os::exit(-1);\n+  \/\/ compare the recorded and current levels of NMT and exit if different\n+  file_info log_fi = _open_file_and_read(INFO_LOG_FILE, path, pid);\n+  if (log_fi.fd == -1) {\n+    return;\n+  }\n+  size_t* status_file_bytes = (size_t*)log_fi.ptr;\n+  NMT_TrackingLevel recorded_nmt_level = (NMT_TrackingLevel)status_file_bytes[0];\n+  if (NMTUtil::parse_tracking_level(NativeMemoryTracking) != recorded_nmt_level) {\n+    tty->print(\"NativeMemoryTracking mismatch [%u != %u].\\n\", recorded_nmt_level, NMTUtil::parse_tracking_level(NativeMemoryTracking));\n+    tty->print(\"Re-run with \\\"-XX:NativeMemoryTracking=%s\\\"\\n\", NMTUtil::tracking_level_to_string(recorded_nmt_level));\n+    os::exit(-1);\n+  }\n+\n+  \/\/ open records file for reading the memory allocations to \"play back\"\n+  file_info records_fi = _open_file_and_read(ALLOCS_LOG_FILE, path, pid);\n+  if (records_fi.fd == -1) {\n+    return;\n+  }\n+  Entry* records_file_entries = (Entry*)records_fi.ptr;\n+  long int count = (records_fi.size \/ sizeof(Entry));\n+  size_t size_pointers = count * sizeof(address);\n+  address *pointers = (address*)::mmap(NULL, size_pointers, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0);\n+  assert(pointers != MAP_FAILED, \"pointers != MAP_FAILED\");\n+\n+  \/\/ open benchmark file for writing the final results\n+  char *benchmark_file_path = NEW_C_HEAP_ARRAY(char, JVM_MAXPATHLEN, mtNMT);\n+  if (!_create_file_path_with_pid(path, BENCHMARK_LOG_FILE, benchmark_file_path, pid)) {\n+    tty->print(\"Can't construct benchmark_file_path [%s].\", benchmark_file_path);\n+    os::exit(-1);\n+  }\n+  int benchmark_fd = _prepare_log_file(benchmark_file_path, nullptr);\n+  if (benchmark_fd == -1) {\n+    tty->print(\"Can't open [%s].\", benchmark_file_path);\n+    os::exit(-1);\n+  }\n+  jlong requestedByCategory[mt_number_of_tags] = {0};\n+  jlong allocatedByCategory[mt_number_of_tags] = {0};\n+  jlong nmtObjectsByCategory[mt_number_of_tags] = {0};\n+  jlong nanoseconds = 0;\n+  jlong requestedTotal = 0;\n+  jlong actualTotal = 0;\n+  for (off_t i = 0; i < count; i++) {\n+    Entry *e = &records_file_entries[i];\n+    MemTag mem_tag = NMTUtil::index_to_tag((int)e->mem_tag);\n+    int frameCount;\n+    for (frameCount = 0; frameCount < NMT_TrackingStackDepth; frameCount++) {\n+      if (e->stack[frameCount] == 0) {\n+        break;\n+      }\n@@ -382,4 +398,3 @@\n-    int benchmark_fd = _prepare_log_file(benchmark_file_path, nullptr);\n-    if (benchmark_fd == -1) {\n-      tty->print(\"Can't open [%s].\", benchmark_file_path);\n-      os::exit(-1);\n+    NativeCallStack stack = NativeCallStack::empty_stack();\n+    if (frameCount > 0) {\n+      stack = NativeCallStack(e->stack, frameCount);\n@@ -387,13 +402,11 @@\n-    jlong requestedByCategory[mt_number_of_tags] = {0};\n-    jlong allocatedByCategory[mt_number_of_tags] = {0};\n-    jlong nmtObjectsByCategory[mt_number_of_tags] = {0};\n-    jlong nanoseconds = 0;\n-    jlong requestedTotal = 0;\n-    jlong actualTotal = 0;\n-    for (off_t i = 0; i < count; i++) {\n-      Entry *e = &records_file_entries[i];\n-      MemTag mem_tag = NMTUtil::index_to_tag((int)e->mem_tag);\n-      int frameCount;\n-      for (frameCount = 0; frameCount < NMT_TrackingStackDepth; frameCount++) {\n-        if (e->stack[frameCount] == 0) {\n-          break;\n+    jlong requested = 0;\n+    jlong actual = 0;\n+    pointers[i] = nullptr;\n+    jlong start = 0;\n+    jlong end = 0;\n+    {\n+      if (IS_MALLOC(e) || (IS_MALLOC_REALLOC(e))) {\n+        address client_ptr = nullptr;\n+        start = os::javaTimeNanos();\n+        {\n+          client_ptr = (address)os::malloc(e->requested, mem_tag, stack);\n@@ -401,16 +414,26 @@\n-      }\n-      NativeCallStack stack = NativeCallStack::empty_stack();\n-      if (frameCount > 0) {\n-        stack = NativeCallStack(e->stack, frameCount);\n-      }\n-      jlong requested = 0;\n-      jlong actual = 0;\n-      pointers[i] = nullptr;\n-      jlong start = 0;\n-      jlong end = 0;\n-      {\n-        if (IS_MALLOC(e) || (IS_MALLOC_REALLOC(e))) {\n-          address client_ptr = nullptr;\n-          start = os::javaTimeNanos();\n-          {\n-            client_ptr = (address)os::malloc(e->requested, mem_tag, stack);\n+        end = os::javaTimeNanos();\n+        requested = e->requested;\n+        actual = e->actual;\n+        pointers[i] = client_ptr;\n+        if (mem_tag == mtNone) {\n+          fprintf(stderr, \"MALLOC?\\n\");\n+        }\n+      } else if (IS_REALLOC(e)) {\n+        \/\/ the recorded \"realloc\" was captured in a different process,\n+        \/\/ so find the corresponding \"malloc\" or \"realloc\" in this process\n+        for (off_t j = i-1; j >= 0; j--) {\n+          Entry *p = &records_file_entries[j];\n+          if (e->old == p->ptr) {\n+            address ptr = pointers[j];\n+            requested -= p->requested;\n+            actual -= p->actual;\n+            start = os::javaTimeNanos();\n+            {\n+              ptr = (address)os::realloc(ptr, e->requested, mem_tag, stack);\n+            }\n+            end = os::javaTimeNanos();\n+            requested += e->requested;\n+            actual += e->actual;\n+            pointers[i] = ptr;\n+            pointers[j] = nullptr;\n+            break;\n@@ -418,4 +441,0 @@\n-          end = os::javaTimeNanos();\n-          requested = e->requested;\n-          actual = e->actual;\n-          pointers[i] = client_ptr;\n@@ -423,1 +442,1 @@\n-            fprintf(stderr, \"MALLOC?\\n\");\n+            fprintf(stderr, \"REALLOC?\\n\");\n@@ -425,42 +444,14 @@\n-        } else if (IS_REALLOC(e)) {\n-          \/\/ the recorded \"realloc\" was captured in a different process,\n-          \/\/ so find the corresponding \"malloc\" or \"realloc\" in this process\n-          for (off_t j = i-1; j >= 0; j--) {\n-            Entry *p = &records_file_entries[j];\n-            if (e->old == p->ptr) {\n-              address ptr = pointers[j];\n-              requested -= p->requested;\n-              actual -= p->actual;\n-              start = os::javaTimeNanos();\n-              {\n-                ptr = (address)os::realloc(ptr, e->requested, mem_tag, stack);\n-              }\n-              end = os::javaTimeNanos();\n-              requested += e->requested;\n-              actual += e->actual;\n-              pointers[i] = ptr;\n-              pointers[j] = nullptr;\n-              break;\n-            }\n-            if (mem_tag == mtNone) {\n-              fprintf(stderr, \"REALLOC?\\n\");\n-            }\n-          }\n-        } else if (IS_FREE(e)) {\n-          \/\/ the recorded \"free\" was captured in a different process,\n-          \/\/ so find the corresponding \"malloc\" or \"realloc\" in this process\n-          for (off_t j = i-1; j >= 0; j--) {\n-            Entry *p = &records_file_entries[j];\n-            if ((e->old == p->ptr) || (e->ptr == p->ptr)) {\n-              mem_tag = NMTUtil::index_to_tag((int)p->mem_tag);\n-              void* ptr = pointers[j];\n-              requested -= p->requested;\n-              actual -= p->actual;\n-              start = os::javaTimeNanos();\n-              {\n-                os::free(ptr);\n-              }\n-              end = os::javaTimeNanos();\n-              pointers[i] = nullptr;\n-              pointers[j] = nullptr;\n-              break;\n+        }\n+      } else if (IS_FREE(e)) {\n+        \/\/ the recorded \"free\" was captured in a different process,\n+        \/\/ so find the corresponding \"malloc\" or \"realloc\" in this process\n+        for (off_t j = i-1; j >= 0; j--) {\n+          Entry *p = &records_file_entries[j];\n+          if ((e->old == p->ptr) || (e->ptr == p->ptr)) {\n+            mem_tag = NMTUtil::index_to_tag((int)p->mem_tag);\n+            void* ptr = pointers[j];\n+            requested -= p->requested;\n+            actual -= p->actual;\n+            start = os::javaTimeNanos();\n+            {\n+              os::free(ptr);\n@@ -468,0 +459,4 @@\n+            end = os::javaTimeNanos();\n+            pointers[i] = nullptr;\n+            pointers[j] = nullptr;\n+            break;\n@@ -469,6 +464,0 @@\n-          if (mem_tag == mtNone) {\n-            fprintf(stderr, \"FREE?\\n\");\n-          }\n-        } else {\n-          fprintf(stderr, \"HUH?\\n\");\n-          os::exit(-1);\n@@ -476,9 +465,2 @@\n-        requestedTotal += requested;\n-        actualTotal += actual;\n-\n-        requestedByCategory[NMTUtil::tag_to_index(mem_tag)] += requested;\n-        allocatedByCategory[NMTUtil::tag_to_index(mem_tag)] += actual;\n-        if (IS_FREE(e)) {\n-          nmtObjectsByCategory[NMTUtil::tag_to_index(mem_tag)]--;\n-        } else {\n-          nmtObjectsByCategory[NMTUtil::tag_to_index(mem_tag)]++;\n+        if (mem_tag == mtNone) {\n+          fprintf(stderr, \"FREE?\\n\");\n@@ -486,0 +468,13 @@\n+      } else {\n+        fprintf(stderr, \"HUH?\\n\");\n+        os::exit(-1);\n+      }\n+      requestedTotal += requested;\n+      actualTotal += actual;\n+\n+      requestedByCategory[NMTUtil::tag_to_index(mem_tag)] += requested;\n+      allocatedByCategory[NMTUtil::tag_to_index(mem_tag)] += actual;\n+      if (IS_FREE(e)) {\n+        nmtObjectsByCategory[NMTUtil::tag_to_index(mem_tag)]--;\n+      } else {\n+        nmtObjectsByCategory[NMTUtil::tag_to_index(mem_tag)]++;\n@@ -487,9 +482,0 @@\n-      jlong duration = (start > 0) ? (end - start) : 0;\n-      nanoseconds += duration;\n-\n-      _write_and_check(benchmark_fd, &duration, sizeof(duration));\n-      _write_and_check(benchmark_fd, &requested, sizeof(requested));\n-      _write_and_check(benchmark_fd, &actual, sizeof(actual));\n-      char type = (IS_MALLOC(e) * 1) | (IS_REALLOC(e) * 2) | (IS_FREE(e) * 4);\n-      _write_and_check(benchmark_fd, &type, sizeof(type));\n-      \/\/fprintf(stderr, \" %9ld:%9ld:%9ld %d:%d:%d\\n\", requested, actual, duration, IS_MALOC(e), IS_REALLOC(e), IS_FREE(e));\n@@ -497,0 +483,10 @@\n+    jlong duration = (start > 0) ? (end - start) : 0;\n+    nanoseconds += duration;\n+\n+    _write_and_check(benchmark_fd, &duration, sizeof(duration));\n+    _write_and_check(benchmark_fd, &requested, sizeof(requested));\n+    _write_and_check(benchmark_fd, &actual, sizeof(actual));\n+    char type = (IS_MALLOC(e) * 1) | (IS_REALLOC(e) * 2) | (IS_FREE(e) * 4);\n+    _write_and_check(benchmark_fd, &type, sizeof(type));\n+    \/\/fprintf(stderr, \" %9ld:%9ld:%9ld %d:%d:%d\\n\", requested, actual, duration, IS_MALOC(e), IS_REALLOC(e), IS_FREE(e));\n+  }\n@@ -498,16 +494,14 @@\n-    jlong overhead = actualTotal - requestedTotal;\n-    double overheadPercentage = 100.0 * (double)overhead \/ (double)requestedTotal;\n-    size_t overhead_NMT = count * MemTracker::overhead_per_malloc();\n-    fprintf(stderr, \"\\n\\n\\nmalloc summary:\\n\\n\");\n-    fprintf(stderr, \"time:%'ld[ns] [samples:%'ld]\\n\", nanoseconds, count);\n-    fprintf(stderr, \"memory requested:%'zu bytes, allocated:%'zu bytes, overhead=%'zu bytes [%2.2f%%]\\n\", requestedTotal, actualTotal, overhead, overheadPercentage);\n-    fprintf(stderr, \"requested total=%'zu, actual total=%'zu, NMT headers=%'zu\\n\", requestedTotal, actualTotal, overhead_NMT);\n-    fprintf(stderr, \"\\n\");\n-    fprintf(stderr, \"%22s: %12s: %12s: %12s:\\n\", \"NMT category\", \"objects\", \"bytes\", \"overhead\");\n-    fprintf(stderr, \"-----------------------------------------------------------------\\n\");\n-    for (int i = 0; i < mt_number_of_tags; i++) {\n-      double overhead = 0.0;\n-      if (requestedByCategory[i] > 0) {\n-        overhead = 100.0 * ((double)allocatedByCategory[i] - (double)requestedByCategory[i]) \/ (double)requestedByCategory[i];\n-      }\n-      fprintf(stderr, \"%22s: %'12ld %'12ld         [%.2f%%]\\n\", NMTUtil::tag_to_name(NMTUtil::index_to_tag(i)), nmtObjectsByCategory[i], allocatedByCategory[i], overhead);\n+  jlong overhead = actualTotal - requestedTotal;\n+  double overheadPercentage = 100.0 * (double)overhead \/ (double)requestedTotal;\n+  size_t overhead_NMT = count * MemTracker::overhead_per_malloc();\n+  fprintf(stderr, \"\\n\\n\\nmalloc summary:\\n\\n\");\n+  fprintf(stderr, \"time:%'ld[ns] [samples:%'ld]\\n\", nanoseconds, count);\n+  fprintf(stderr, \"memory requested:%'zu bytes, allocated:%'zu bytes, overhead=%'zu bytes [%2.2f%%]\\n\", requestedTotal, actualTotal, overhead, overheadPercentage);\n+  fprintf(stderr, \"requested total=%'zu, actual total=%'zu, NMT headers=%'zu\\n\", requestedTotal, actualTotal, overhead_NMT);\n+  fprintf(stderr, \"\\n\");\n+  fprintf(stderr, \"%22s: %12s: %12s: %12s:\\n\", \"NMT category\", \"objects\", \"bytes\", \"overhead\");\n+  fprintf(stderr, \"-----------------------------------------------------------------\\n\");\n+  for (int i = 0; i < mt_number_of_tags; i++) {\n+    double overhead = 0.0;\n+    if (requestedByCategory[i] > 0) {\n+      overhead = 100.0 * ((double)allocatedByCategory[i] - (double)requestedByCategory[i]) \/ (double)requestedByCategory[i];\n@@ -515,10 +509,11 @@\n-    _close_and_check(log_fi.fd);\n-    _close_and_check(records_fi.fd);\n-    _close_and_check(benchmark_fd);\n-    FREE_C_HEAP_ARRAY(char, benchmark_file_path);\n-\n-    for (off_t i = 0; i < count; i++) {\n-      if (pointers[i] != nullptr) {\n-        os::free(pointers[i]);\n-        pointers[i] = nullptr;\n-      }\n+    fprintf(stderr, \"%22s: %'12ld %'12ld         [%.2f%%]\\n\", NMTUtil::tag_to_name(NMTUtil::index_to_tag(i)), nmtObjectsByCategory[i], allocatedByCategory[i], overhead);\n+  }\n+  _close_and_check(log_fi.fd);\n+  _close_and_check(records_fi.fd);\n+  _close_and_check(benchmark_fd);\n+  FREE_C_HEAP_ARRAY(char, benchmark_file_path);\n+\n+  for (off_t i = 0; i < count; i++) {\n+    if (pointers[i] != nullptr) {\n+      os::free(pointers[i]);\n+      pointers[i] = nullptr;\n@@ -526,1 +521,2 @@\n-    munmap((void*)pointers, size_pointers);\n+  }\n+  munmap((void*)pointers, size_pointers);\n@@ -528,1 +524,1 @@\n-    recorder->unlock();\n+  recorder->unlock();\n@@ -530,2 +526,1 @@\n-    os::exit(0);\n-  }\n+  os::exit(0);\n@@ -659,37 +654,28 @@\n-void NMT_VirtualMemoryLogRecorder::replay(const char* path, const int pid) {\n-    \/\/fprintf(stderr, \"NMT_VirtualMemoryLogRecorder::replay(\\\"%s\\\", %d)\\n\", path, pid);\n-  if ((pid != 0) && ((path == nullptr) || (strlen(path) == 0))) {\n-    static const char *home = \".\";\n-    path = home;\n-  }\n-  if ((path != nullptr) && (strlen(path) > 0)) {\n-    \/\/ compare the recorded and current levels of NMT and exit if different\n-    \/\/    file_info log_fi = _open_file_and_read(INFO_LOG_FILE, path, pid);\n-    \/\/    size_t* status_file_bytes = (size_t*)log_fi.ptr;\n-    \/\/    NMT_TrackingLevel recorded_nmt_level = (NMT_TrackingLevel)status_file_bytes[0];\n-    \/\/    if (NMTUtil::parse_tracking_level(NativeMemoryTracking) != recorded_nmt_level) {\n-    \/\/      tty->print(\"NativeMemoryTracking mismatch [%u != %u].\\n\", recorded_nmt_level, NMTUtil::parse_tracking_level(NativeMemoryTracking));\n-    \/\/      tty->print(\"Re-run with \\\"-XX:NativeMemoryTracking=%s\\\"\\n\", NMTUtil::tracking_level_to_string(recorded_nmt_level));\n-    \/\/      os::exit(-1);\n-    \/\/    }\n-\n-    \/\/ open records file for reading the virtual memory allocations to \"play back\"\n-    file_info records_fi = _open_file_and_read(VALLOCS_LOG_FILE, path, pid);\n-    Entry* records_file_entries = (Entry*)records_fi.ptr;\n-    long int count = (records_fi.size \/ sizeof(Entry));\n-\n-    jlong total = 0;\n-    \/\/VirtualMemoryTracker::Instance::initialize(NMTUtil::parse_tracking_level(NativeMemoryTracking));\n-    for (off_t i = 0; i < count; i++) {\n-      Entry *e = &records_file_entries[i];\n-\n-      MemTag mem_tag = NMTUtil::index_to_tag((int)e->mem_tag);\n-      int frameCount;\n-      for (frameCount = 0; frameCount < NMT_TrackingStackDepth; frameCount++) {\n-        if (e->stack[frameCount] == 0) {\n-          break;\n-        }\n-      }\n-      NativeCallStack stack = NativeCallStack::empty_stack();\n-      if (frameCount > 0) {\n-        stack = NativeCallStack(e->stack, frameCount);\n+void NMT_VirtualMemoryLogRecorder::replay(const int pid) {\n+  \/\/fprintf(stderr, \"NMT_VirtualMemoryLogRecorder::replay(\\\"%s\\\", %d)\\n\", path, pid);\n+  static const char *path = \".\";\n+  \/\/ compare the recorded and current levels of NMT and exit if different\n+  \/\/    file_info log_fi = _open_file_and_read(INFO_LOG_FILE, path, pid);\n+  \/\/    size_t* status_file_bytes = (size_t*)log_fi.ptr;\n+  \/\/    NMT_TrackingLevel recorded_nmt_level = (NMT_TrackingLevel)status_file_bytes[0];\n+  \/\/    if (NMTUtil::parse_tracking_level(NativeMemoryTracking) != recorded_nmt_level) {\n+  \/\/      tty->print(\"NativeMemoryTracking mismatch [%u != %u].\\n\", recorded_nmt_level, NMTUtil::parse_tracking_level(NativeMemoryTracking));\n+  \/\/      tty->print(\"Re-run with \\\"-XX:NativeMemoryTracking=%s\\\"\\n\", NMTUtil::tracking_level_to_string(recorded_nmt_level));\n+  \/\/      os::exit(-1);\n+  \/\/    }\n+\n+  \/\/ open records file for reading the virtual memory allocations to \"play back\"\n+  file_info records_fi = _open_file_and_read(VALLOCS_LOG_FILE, path, pid);\n+  Entry* records_file_entries = (Entry*)records_fi.ptr;\n+  long int count = (records_fi.size \/ sizeof(Entry));\n+\n+  jlong total = 0;\n+  \/\/VirtualMemoryTracker::Instance::initialize(NMTUtil::parse_tracking_level(NativeMemoryTracking));\n+  for (off_t i = 0; i < count; i++) {\n+    Entry *e = &records_file_entries[i];\n+\n+    MemTag mem_tag = NMTUtil::index_to_tag((int)e->mem_tag);\n+    int frameCount;\n+    for (frameCount = 0; frameCount < NMT_TrackingStackDepth; frameCount++) {\n+      if (e->stack[frameCount] == 0) {\n+        break;\n@@ -697,0 +683,5 @@\n+    }\n+    NativeCallStack stack = NativeCallStack::empty_stack();\n+    if (frameCount > 0) {\n+      stack = NativeCallStack(e->stack, frameCount);\n+    }\n@@ -698,43 +689,42 @@\n-      jlong start = os::javaTimeNanos();\n-      {\n-        switch (e->type) {\n-          case NMT_VirtualMemoryLogRecorder::Type::RESERVE:\n-            \/\/fprintf(stderr, \"[record_virtual_memory_reserve(%p, %zu, %p, %hhu)\\n\", e->ptr, e->size, &stack, mem_tag);fflush(stderr);\n-            MemTracker::record_virtual_memory_reserve(e->ptr, e->size, stack, mem_tag);\n-            \/\/fprintf(stderr, \"]\\n\");fflush(stderr);\n-            break;\n-          case NMT_VirtualMemoryLogRecorder::Type::RELEASE:\n-            \/\/fprintf(stderr, \"[record_virtual_memory_release(%p, %zu)\\n\", e->ptr, e->size);fflush(stderr);\n-            MemTracker::record_virtual_memory_release(e->ptr, e->size);\n-            \/\/fprintf(stderr, \"]\\n\");fflush(stderr);\n-            break;\n-          case NMT_VirtualMemoryLogRecorder::Type::UNCOMMIT:\n-            \/\/fprintf(stderr, \"<record_virtual_memory_uncommit(%p, %zu)\\n\", e->ptr, e->size);fflush(stderr);\n-            MemTracker::record_virtual_memory_uncommit(e->ptr, e->size);\n-            \/\/fprintf(stderr, \">\\n\");fflush(stderr);\n-            break;\n-          case NMT_VirtualMemoryLogRecorder::Type::RESERVE_AND_COMMIT:\n-            \/\/fprintf(stderr, \"[MemTracker::record_virtual_memory_reserve_and_commit\\n\");\n-            MemTracker::record_virtual_memory_reserve_and_commit(e->ptr, e->size, stack, mem_tag);\n-            \/\/fprintf(stderr, \"]\\n\");fflush(stderr);\n-            break;\n-          case NMT_VirtualMemoryLogRecorder::Type::COMMIT:\n-            \/\/fprintf(stderr, \"[record_virtual_memory_commit(%p, %zu, %p)\\n\", e->ptr, e->size, &stack);fflush(stderr);\n-            MemTracker::record_virtual_memory_commit(e->ptr, e->size, stack);\n-            \/\/fprintf(stderr, \"]\\n\");fflush(stderr);\n-            break;\n-          case NMT_VirtualMemoryLogRecorder::Type::SPLIT_RESERVED:\n-            \/\/fprintf(stderr, \"[MemTracker::record_virtual_memory_split_reserved\\n\");\n-            MemTracker::record_virtual_memory_split_reserved(e->ptr, e->size, e->size_split, mem_tag, NMTUtil::index_to_tag((int)e->mem_tag_split));\n-            \/\/fprintf(stderr, \"]\\n\");fflush(stderr);\n-            break;\n-          case NMT_VirtualMemoryLogRecorder::Type::TAG:\n-            \/\/fprintf(stderr, \"[record_virtual_memory_type(%p, %zu, %p)\\n\", e->ptr, e->size, &stack);fflush(stderr);\n-            MemTracker::record_virtual_memory_tag(e->ptr, mem_tag);\n-            \/\/fprintf(stderr, \"]\\n\");fflush(stderr);\n-            break;\n-          default:\n-            fprintf(stderr, \"HUH?\\n\");\n-            os::exit(-1);\n-            break;\n-        }\n+    jlong start = os::javaTimeNanos();\n+    {\n+      switch (e->type) {\n+        case NMT_VirtualMemoryLogRecorder::Type::RESERVE:\n+          \/\/fprintf(stderr, \"[record_virtual_memory_reserve(%p, %zu, %p, %hhu)\\n\", e->ptr, e->size, &stack, mem_tag);fflush(stderr);\n+          MemTracker::record_virtual_memory_reserve(e->ptr, e->size, stack, mem_tag);\n+          \/\/fprintf(stderr, \"]\\n\");fflush(stderr);\n+          break;\n+        case NMT_VirtualMemoryLogRecorder::Type::RELEASE:\n+          \/\/fprintf(stderr, \"[record_virtual_memory_release(%p, %zu)\\n\", e->ptr, e->size);fflush(stderr);\n+          MemTracker::record_virtual_memory_release(e->ptr, e->size);\n+          \/\/fprintf(stderr, \"]\\n\");fflush(stderr);\n+          break;\n+        case NMT_VirtualMemoryLogRecorder::Type::UNCOMMIT:\n+          \/\/fprintf(stderr, \"<record_virtual_memory_uncommit(%p, %zu)\\n\", e->ptr, e->size);fflush(stderr);\n+          MemTracker::record_virtual_memory_uncommit(e->ptr, e->size);\n+          \/\/fprintf(stderr, \">\\n\");fflush(stderr);\n+          break;\n+        case NMT_VirtualMemoryLogRecorder::Type::RESERVE_AND_COMMIT:\n+          \/\/fprintf(stderr, \"[MemTracker::record_virtual_memory_reserve_and_commit\\n\");\n+          MemTracker::record_virtual_memory_reserve_and_commit(e->ptr, e->size, stack, mem_tag);\n+          \/\/fprintf(stderr, \"]\\n\");fflush(stderr);\n+          break;\n+        case NMT_VirtualMemoryLogRecorder::Type::COMMIT:\n+          \/\/fprintf(stderr, \"[record_virtual_memory_commit(%p, %zu, %p)\\n\", e->ptr, e->size, &stack);fflush(stderr);\n+          MemTracker::record_virtual_memory_commit(e->ptr, e->size, stack);\n+          \/\/fprintf(stderr, \"]\\n\");fflush(stderr);\n+          break;\n+        case NMT_VirtualMemoryLogRecorder::Type::SPLIT_RESERVED:\n+          \/\/fprintf(stderr, \"[MemTracker::record_virtual_memory_split_reserved\\n\");\n+          MemTracker::record_virtual_memory_split_reserved(e->ptr, e->size, e->size_split, mem_tag, NMTUtil::index_to_tag((int)e->mem_tag_split));\n+          \/\/fprintf(stderr, \"]\\n\");fflush(stderr);\n+          break;\n+        case NMT_VirtualMemoryLogRecorder::Type::TAG:\n+          \/\/fprintf(stderr, \"[record_virtual_memory_type(%p, %zu, %p)\\n\", e->ptr, e->size, &stack);fflush(stderr);\n+          MemTracker::record_virtual_memory_tag(e->ptr, mem_tag);\n+          \/\/fprintf(stderr, \"]\\n\");fflush(stderr);\n+          break;\n+        default:\n+          fprintf(stderr, \"HUH?\\n\");\n+          os::exit(-1);\n+          break;\n@@ -742,3 +732,0 @@\n-      jlong end = os::javaTimeNanos();\n-      jlong duration = (start > 0) ? (end - start) : 0;\n-      total += duration;\n@@ -746,2 +733,6 @@\n-    fprintf(stderr, \"\\n\\n\\nVirtualMemoryTracker summary:\\n\\n\\n\");\n-    fprintf(stderr, \"time:%'ld[ns] [samples:%'ld]\\n\", total, count);\n+    jlong end = os::javaTimeNanos();\n+    jlong duration = (start > 0) ? (end - start) : 0;\n+    total += duration;\n+  }\n+  fprintf(stderr, \"\\n\\n\\nVirtualMemoryTracker summary:\\n\\n\\n\");\n+  fprintf(stderr, \"time:%'ld[ns] [samples:%'ld]\\n\", total, count);\n@@ -761,1 +752,1 @@\n-    _close_and_check(records_fi.fd);\n+  _close_and_check(records_fi.fd);\n@@ -763,2 +754,1 @@\n-    os::exit(0);\n-  }\n+  os::exit(0);\n","filename":"src\/hotspot\/share\/nmt\/memLogRecorder.cpp","additions":253,"deletions":263,"binary":false,"changes":516,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-  static void replay(const char* path, const int pid);\n+  static void replay(const int pid);\n@@ -99,1 +99,1 @@\n-  static void replay(const char* path, const int pid);\n+  static void replay(const int pid);\n@@ -143,1 +143,1 @@\n-  static void replay(const char* path, const int pid);\n+  static void replay(const int pid);\n","filename":"src\/hotspot\/share\/nmt\/memLogRecorder.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-  NMT_LogRecorder::replay(NMTBenchmarkRecordedDir, NMTBenchmarkRecordedPID);\n+  NMT_LogRecorder::replay(NMTBenchmarkRecordedPID);\n","filename":"src\/hotspot\/share\/nmt\/memTracker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}