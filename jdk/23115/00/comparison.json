{"files":[{"patch":"@@ -446,1 +446,4 @@\n-                Scene scene = director.get(index);\n+              if (index == 5) {\n+                  System.exit(0);\n+              }\n+              Scene scene = director.get(index);\n","filename":"src\/demo\/share\/jfc\/J2Ddemo\/java2d\/Intro.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,826 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ record pattern of allocations of memory calls:\n+\/\/\n+\/\/ .\/build\/macosx-aarch64-server-release\/xcode\/build\/jdk\/bin\/java -XX:+UnlockDiagnosticVMOptions -XX:NMTRecordMemoryAllocations=0x7FFFFFFF -jar build\/macosx-aarch64-server-release\/images\/jdk\/demo\/jfc\/J2Ddemo\/J2Ddemo.jar\n+\/\/\n+\/\/ OR record pattern of allocations of virtual memory calls:\n+\/\/\n+\/\/ .\/build\/macosx-aarch64-server-release\/xcode\/build\/jdk\/bin\/java -XX:+UnlockDiagnosticVMOptions -XX:NMTRecordVirtualMemoryAllocations=0x7FFFFFFF -jar build\/macosx-aarch64-server-release\/images\/jdk\/demo\/jfc\/J2Ddemo\/J2Ddemo.jar\n+\/\/\n+\/\/ this will produce 3 files:\n+\/\/\n+\/\/ #1 hs_nmt_pid22770_allocs_record.log (is the chronological record of the the desired operations)\n+\/\/ OR\n+\/\/ #1 hs_nmt_pid22918_virtual_allocs_record.log (is the chronological record of the desired operations)\n+\/\/ #2 hs_nmt_pid22770_info_record.log (is the record of default NMT memory overhead and the NMT state)\n+\/\/ #3 hs_nmt_pid22770_threads_record.log (is the record of thread names that can be retrieved later when processing)\n+\/\/\n+\/\/ then to actually run the benchmark:\n+\/\/\n+\/\/ .\/build\/macosx-aarch64-server-release\/xcode\/build\/jdk\/bin\/java -XX:+UnlockDiagnosticVMOptions -XX:NMTBenchmarkRecordedPID=43100 -XX:NMTBenchmarkRecordedLoops=10\n+\n+#include \"precompiled.hpp\"\n+#include \"jvm.h\"\n+#include \"nmt\/nmtCommon.hpp\"\n+#include \"nmt\/mallocHeader.hpp\"\n+#include \"nmt\/mallocHeader.inline.hpp\"\n+#include \"nmt\/memLogRecorder.hpp\"\n+#include \"nmt\/memReporter.hpp\"\n+#include \"nmt\/memTracker.hpp\"\n+#include \"runtime\/arguments.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/thread.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/nativeCallStack.hpp\"\n+#include \"utilities\/permitForbiddenFunctions.hpp\"\n+#include \"utilities\/vmError.hpp\"\n+\n+#if defined(LINUX)\n+#include <malloc.h>\n+#elif defined(__APPLE__)\n+#include <malloc\/malloc.h>\n+#endif\n+\n+#if defined(LINUX) || defined(__APPLE__)\n+#include <pthread.h>\n+#include <string.h>\n+#include <sys\/mman.h>\n+#endif\n+\n+NMT_MemoryLogRecorder NMT_MemoryLogRecorder::_recorder;\n+NMT_VirtualMemoryLogRecorder NMT_VirtualMemoryLogRecorder::_recorder;\n+\n+void NMT_LogRecorder::initialize(intx memoryCount, intx virtualMemoryCount) {\n+  NMT_MemoryLogRecorder::initialize(NMTRecordMemoryAllocations);\n+  NMT_VirtualMemoryLogRecorder::initialize(NMTRecordVirtualMemoryAllocations);\n+}\n+\n+void NMT_LogRecorder::finish() {\n+  NMT_MemoryLogRecorder::instance()->finish();\n+  NMT_VirtualMemoryLogRecorder::instance()->finish();\n+}\n+\n+void NMT_LogRecorder::replay(const char* path, const int pid) {\n+  NMT_MemoryLogRecorder::instance()->replay(path, pid);\n+  NMT_VirtualMemoryLogRecorder::instance()->replay(path, pid);\n+}\n+\n+void NMT_LogRecorder::init() {\n+#if defined(LINUX) || defined(__APPLE__)\n+  pthread_mutex_t _mutex;\n+#elif defined(WINDOWS)\n+ \/\/ ???\n+#endif\n+  pthread_mutex_init(&_mutex, NULL);\n+  _threads_names = nullptr;\n+  _done = true;\n+  _count = 0;\n+}\n+\n+bool NMT_LogRecorder::lockIfNotDone() {\n+  if (!_done) {\n+    lock();\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+void NMT_LogRecorder::lock() {\n+#if defined(LINUX) || defined(__APPLE__)\n+  pthread_mutex_lock(&_mutex);\n+#elif defined(WINDOWS)\n+ \/\/ ???\n+#endif\n+}\n+\n+void NMT_LogRecorder::unlock() {\n+#if defined(LINUX) || defined(__APPLE__)\n+  pthread_mutex_unlock(&_mutex);\n+#elif defined(WINDOWS)\n+ \/\/ ???\n+#endif\n+}\n+\n+void NMT_LogRecorder::logThreadName(const char* name) {\n+  NMT_MemoryLogRecorder::instance()->_logThreadName(name);\n+}\n+void NMT_LogRecorder::_logThreadName(const char* name) {\n+  if (_done) {\n+    return;\n+  }\n+  if (_threads_names == nullptr) {\n+    _threads_names = (thread_name_info*)permit_forbidden_function::calloc(_threads_names_capacity, sizeof(thread_name_info));\n+  }\n+  if (_threads_names_counter < _threads_names_capacity) {\n+    volatile size_t counter = _threads_names_counter++;\n+    if (counter < _threads_names_capacity) {\n+      strncpy((char*)_threads_names[counter].name, name, _threads_name_length-1);\n+      _threads_names[counter].thread = os::current_thread_id();\n+    }\n+  } else {\n+    _threads_names_capacity *= 2;\n+    _threads_names = (thread_name_info*)permit_forbidden_function::realloc((void*)_threads_names, _threads_names_capacity*sizeof(thread_name_info));\n+      logThreadName(name);\n+  }\n+}\n+\n+#define REALLOC_MARKER       ((void *)1)\n+#define IS_FREE(e)           ((e->requested == 0) && (e->old == nullptr))\n+#define IS_REALLOC(e)        ((e->requested  > 0) && (e->old != nullptr))\n+#define IS_MALLOC_REALLOC(e) ((e->requested  > 0) && (e->old == REALLOC_MARKER))\n+#define IS_MALOC(e)          ((e->requested  > 0) && (e->old == nullptr))\n+\n+#define ALLOCS_LOG_FILE \"hs_nmt_pid%p_allocs_record.log\"\n+#define THREADS_LOG_FILE \"hs_nmt_pid%p_threads_record.log\"\n+#define INFO_LOG_FILE \"hs_nmt_pid%p_info_record.log\"\n+#define BENCHMARK_LOG_FILE \"hs_nmt_pid%p_benchmark.log\"\n+#define VALLOCS_LOG_FILE \"hs_nmt_pid%p_virtual_allocs_record.log\"\n+\n+static int _prepare_log_file(const char* pattern, const char* default_pattern) {\n+  int fd = -1;\n+  if (ErrorFileToStdout) {\n+    fd = STDOUT_FILENO;\n+  } else if (ErrorFileToStderr) {\n+    fd = STDERR_FILENO;\n+  } else {\n+    static char name_buffer[O_BUFLEN];\n+    fd = VMError::prepare_log_file(pattern, default_pattern, true, name_buffer, sizeof(name_buffer));\n+    if (fd == -1) {\n+      int e = errno;\n+      tty->print(\"Can't open memory [%s]. Error: \", pattern?pattern:\"null\");\n+      tty->print_raw_cr(os::strerror(e));\n+      tty->print_cr(\"NMT memory recorder report will be written to console.\");\n+      \/\/ See notes in VMError::report_and_die about hard coding tty to 1\n+      fd = 1;\n+    }\n+  }\n+  return fd;\n+}\n+\n+#define IS_VALID_FD(fd) (fd > STDERR_FILENO)\n+\n+static void _write_and_check(int fd, const void *buf, size_t count) {\n+  if (!IS_VALID_FD(fd)) {\n+    fprintf(stderr, \"write_and_check(%d) ERROR\\n\", fd);\n+    \/\/assert(false, \"fd: %d\", fd);\n+  }\n+  errno = 0;\n+  ssize_t written = ::write(fd, buf, count);\n+  if ((long)written != (long)count) {\n+    int e = errno;\n+    fprintf(stderr, \"write_and_check(%d) ERROR:[%s]\\n\", fd, os::strerror(e));\n+    \/\/assert((long)written != (long)count, \"written != count [%ld,%ld]\", (long)written, (long)count);\n+  }\n+}\n+\n+static int _close_and_check(int fd) {\n+  if (!IS_VALID_FD(fd)) {\n+    fprintf(stderr, \"close_and_check(%d) ERROR\\n\", fd);\n+    return fd;\n+  }\n+  if (fd > STDERR_FILENO) {\n+    errno = 0;\n+    int status = close(fd);\n+    if (status != 0) {\n+      int e = errno;\n+      fprintf(stderr, \"ERROR:[%s]\\n\", os::strerror(e));\n+      assert(status != 0, \"close(%d) returned %d\", fd, status);\n+      return fd;\n+    } else {\n+      return -1;\n+    }\n+  } else {\n+    return fd;\n+  }\n+}\n+\n+static bool _create_file_path_with_pid(const char *path, const char *file, char* file_path, int pid) {\n+  char *tmp_path = NEW_C_HEAP_ARRAY(char, JVM_MAXPATHLEN, mtNMT);\n+  strcpy(tmp_path, path);\n+  strcat(tmp_path, os::file_separator());\n+  strcat(tmp_path, file);\n+  if (!Arguments::copy_expand_pid(tmp_path, strlen(tmp_path), file_path, JVM_MAXPATHLEN, pid)) {\n+    FREE_C_HEAP_ARRAY(char, tmp_path);\n+    return false;\n+  } else {\n+    FREE_C_HEAP_ARRAY(char, tmp_path);\n+    return true;\n+  }\n+}\n+\n+typedef struct file_info {\n+  void*   ptr;\n+  size_t  size;\n+  int     fd;\n+} file_info;\n+\n+static file_info _open_file_and_read(const char* pattern, const char* path, int pid) {\n+  file_info info = { nullptr, 0, -1 };\n+\n+  char *file_path = NEW_C_HEAP_ARRAY(char, JVM_MAXPATHLEN, mtNMT);\n+  if (!_create_file_path_with_pid(path, pattern, file_path, pid)) {\n+    tty->print(\"Can't construct path [%s:%s:%d].\", pattern, path, pid);\n+    return info;\n+  }\n+\n+  info.fd = os::open(file_path, O_RDONLY, 0);\n+  if (info.fd == -1) {\n+    int e = errno;\n+    tty->print(\"Can't open file [%s].\", file_path);\n+    tty->print_raw_cr(os::strerror(e));\n+    return info;\n+  }\n+\n+  struct stat file_info;\n+  ::fstat(info.fd, &file_info);\n+  info.size = file_info.st_size;\n+  ::lseek(info.fd, 0, SEEK_SET);\n+\n+  info.ptr = ::mmap(NULL, info.size, PROT_READ, MAP_PRIVATE, info.fd, 0);\n+  assert(info.ptr != MAP_FAILED, \"info.ptr != MAP_FAILED\");\n+\n+  FREE_C_HEAP_ARRAY(char, file_path);\n+\n+  return info;\n+}\n+\n+void NMT_MemoryLogRecorder::initialize(intx limit) {\n+  fprintf(stderr, \"> NMT_MemoryLogRecorder::initialize(%ld)\\n\", limit);\n+  if ((NMTPrintMemoryAllocationsSizesFor != nullptr) && (strlen(NMTPrintMemoryAllocationsSizesFor) > 0)) {\n+    NMT_MemoryLogRecorder::printActualSizesFor((const char*)NMTPrintMemoryAllocationsSizesFor);\n+    os::exit(0);\n+    fprintf(stderr, \">> NMTPrintMemoryAllocationsSizesFor:%s\\n\", NMTPrintMemoryAllocationsSizesFor);\n+    fprintf(stderr, \">> os::exit()\\n\");\n+  }\n+  NMT_MemoryLogRecorder *recorder = NMT_MemoryLogRecorder::instance();\n+  recorder->init();\n+  recorder->lock();\n+  {\n+    recorder->_limit = limit;\n+    if (recorder->_limit > 0) {\n+      recorder->_log_fd = _prepare_log_file(nullptr, ALLOCS_LOG_FILE);\n+      fprintf(stderr, \">> _memLogRecorder._log_fd:%d\\n\", recorder->_log_fd);\n+      recorder->_done = false;\n+    } else {\n+      recorder->_done = true;\n+    }\n+  }\n+  recorder->unlock();\n+}\n+\n+void NMT_MemoryLogRecorder::finish(void) {\n+  NMT_MemoryLogRecorder *recorder = NMT_MemoryLogRecorder::instance();\n+  fprintf(stderr, \"NMT_MemoryLogRecorder::finish() %p\\n\", NMT_MemoryLogRecorder::instance());\n+  if (recorder->lockIfNotDone()) {\n+    volatile int log_fd = recorder->_log_fd;\n+    recorder->_log_fd = -1;\n+    fprintf(stderr, \" log_fd:%d\\n\", log_fd);\n+    log_fd = _close_and_check(log_fd);\n+    fprintf(stderr, \" log_fd:%d\\n\", log_fd);\n+\n+    int threads_fd = _prepare_log_file(nullptr, THREADS_LOG_FILE);\n+    fprintf(stderr, \" threads_fd:%d\\n\", threads_fd);\n+    if (threads_fd != -1) {\n+      _write_and_check(threads_fd, recorder->_threads_names, recorder->_threads_names_counter*sizeof(thread_name_info));\n+      threads_fd = _close_and_check(threads_fd);\n+      fprintf(stderr, \" threads_fd:%d\\n\", threads_fd);\n+    }\n+\n+    int info_fd = _prepare_log_file(nullptr, INFO_LOG_FILE);\n+    fprintf(stderr, \" info_fd:%d\\n\", info_fd);\n+    if (info_fd != -1) {\n+      size_t level = NMTUtil::parse_tracking_level(NativeMemoryTracking);\n+      _write_and_check(info_fd, &level, sizeof(level));\n+      size_t overhead = MemTracker::overhead_per_malloc();\n+      _write_and_check(info_fd, &overhead, sizeof(overhead));\n+      info_fd = _close_and_check(info_fd);\n+      fprintf(stderr, \" info_fd:%d\\n\", info_fd);\n+    }\n+\n+    recorder->_done = true;\n+    recorder->unlock();\n+  }\n+}\n+\n+void NMT_MemoryLogRecorder::replay(const char* path, const int pid) {\n+  fprintf(stderr, \"> NMT_MemoryLogRecorder::replay(\\\"%s\\\", %d)\\n\", path, pid);\n+  if ((pid != 0) && ((path == nullptr) || (strlen(path) == 0))) {\n+    static const char *home = \".\";\n+    path = home;\n+  }\n+  if ((path != nullptr) && (strlen(path) > 0)) {\n+    NMT_MemoryLogRecorder *recorder = NMT_MemoryLogRecorder::instance();\n+    recorder->lock();\n+\n+    \/\/ compare the recorded and current levels of NMT and exit if different\n+    file_info log_fi = _open_file_and_read(INFO_LOG_FILE, path, pid);\n+    if (log_fi.fd == -1) {\n+      return;\n+    }\n+    size_t* status_file_bytes = (size_t*)log_fi.ptr;\n+    NMT_TrackingLevel recorded_nmt_level = (NMT_TrackingLevel)status_file_bytes[0];\n+    if (NMTUtil::parse_tracking_level(NativeMemoryTracking) != recorded_nmt_level) {\n+      tty->print(\"NativeMemoryTracking mismatch [%u != %u].\\n\", recorded_nmt_level, NMTUtil::parse_tracking_level(NativeMemoryTracking));\n+      tty->print(\"Re-run with \\\"-XX:NativeMemoryTracking=%s\\\"\\n\", NMTUtil::tracking_level_to_string(recorded_nmt_level));\n+      os::exit(-1);\n+    }\n+\n+    \/\/ open records file for reading the memory allocations to \"play back\"\n+    file_info records_fi = _open_file_and_read(ALLOCS_LOG_FILE, path, pid);\n+    if (records_fi.fd == -1) {\n+      return;\n+    }\n+    Entry* records_file_entries = (Entry*)records_fi.ptr;\n+    long int count = (records_fi.size \/ sizeof(Entry));\n+    size_t size_pointers = count * sizeof(address);\n+    address *pointers = (address*)::mmap(NULL, size_pointers, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0);\n+    assert(pointers != MAP_FAILED, \"pointers != MAP_FAILED\");\n+\n+    \/\/ open benchmark file for writing the final results\n+    char *benchmark_file_path = NEW_C_HEAP_ARRAY(char, JVM_MAXPATHLEN, mtNMT);\n+    if (!_create_file_path_with_pid(path, BENCHMARK_LOG_FILE, benchmark_file_path, pid)) {\n+      tty->print(\"Can't construct benchmark_file_path [%s].\", benchmark_file_path);\n+      os::exit(-1);\n+    }\n+    int benchmark_fd = _prepare_log_file(benchmark_file_path, nullptr);\n+    if (benchmark_fd == -1) {\n+      tty->print(\"Can't open [%s].\", benchmark_file_path);\n+      os::exit(-1);\n+    }\n+\n+    jlong total = 0;\n+    fprintf(stderr, \"benchmarking \\\"%s\\\"\\n\", benchmark_file_path);\n+    for (off_t i = 0; i < count; i++) {\n+      Entry *e = &records_file_entries[i];\n+      MemTag mem_tag = NMTUtil::index_to_tag((int)e->mem_tag);\n+      int frameCount;\n+      for (frameCount = 0; frameCount < NMT_TrackingStackDepth; frameCount++) {\n+        if (e->stack[frameCount] == 0) {\n+          break;\n+        }\n+      }\n+      NativeCallStack stack = NativeCallStack::empty_stack();\n+      if (frameCount > 0) {\n+        stack = NativeCallStack(e->stack, frameCount);\n+      }\n+      size_t requested = 0;\n+      size_t actual = 0;\n+\n+      pointers[i] = nullptr;\n+      jlong start = 0;\n+      jlong end = 0;\n+      {\n+        requested = e->requested;\n+        if (IS_MALOC(e)) {\n+          start = os::javaTimeNanos();\n+          {\n+            pointers[i] = (address)os::malloc(e->requested, mem_tag, stack);\n+          }\n+          end = os::javaTimeNanos();\n+        } else if (IS_MALLOC_REALLOC(e)) {\n+          start = os::javaTimeNanos();\n+          {\n+            \/\/ the recorded \"realloc\" that was captured in a different process\n+            \/\/ is trivial one (i.e. realloc(nullptr)) which looks like \"malloc\",\n+            \/\/ but continue to treat it as \"realloc\"\n+            pointers[i] = (address)os::realloc(nullptr, e->requested, mem_tag, stack);\n+          }\n+          end = os::javaTimeNanos();\n+        } else if (IS_REALLOC(e)) {\n+          \/\/ the recorded \"realloc\" was captured in a different process,\n+          \/\/ so find the corresponding \"malloc\" or \"realloc\" in this process\n+          for (off_t j = i; j >= 0; j--) {\n+            Entry *p = &records_file_entries[j];\n+            if (e->old == p->ptr) {\n+              start = os::javaTimeNanos();\n+              {\n+                pointers[i] = (address)os::realloc(pointers[j], e->requested, mem_tag, stack);\n+              }\n+              end = os::javaTimeNanos();\n+              pointers[j] = nullptr;\n+              break;\n+            }\n+          }\n+        } else if (IS_FREE(e)) {\n+          \/\/ the recorded \"free\" was captured in a different process,\n+          \/\/ so find the corresponding \"malloc\" or \"realloc\" in this process\n+          for (off_t j = i; j >= 0; j--) {\n+            Entry *p = &records_file_entries[j];\n+            if (e->ptr == p->ptr) {\n+              start = os::javaTimeNanos();\n+              {\n+                os::free(pointers[j]);\n+              }\n+              end = os::javaTimeNanos();\n+              pointers[i] = nullptr;\n+              pointers[j] = nullptr;\n+              break;\n+            }\n+          }\n+        } else {\n+          fprintf(stderr, \"HUH?\\n\");\n+          os::exit(-1);\n+        }\n+\n+        if (!IS_FREE(e)) {\n+          void* outer_ptr = pointers[i];\n+          if ((outer_ptr != nullptr) && (MemTracker::enabled())) {\n+            outer_ptr = MallocHeader::resolve_checked(outer_ptr);\n+          }\n+#if defined(LINUX)\n+          actual = permit_forbidden_function::malloc_usable_size(outer_ptr);\n+#elif defined(WINDOWS)\n+          actual = permit_forbidden_function::_msize(outer_ptr);)\n+#elif defined(__APPLE__)\n+          actual = permit_forbidden_function::malloc_size(outer_ptr);\n+#endif\n+        }\n+      }\n+      jlong duration = (start > 0) ? (end - start) : 0;\n+      total += duration;\n+\n+      _write_and_check(benchmark_fd, &duration, sizeof(duration));\n+      _write_and_check(benchmark_fd, &requested, sizeof(requested));\n+      _write_and_check(benchmark_fd, &actual, sizeof(actual));\n+      char type = (IS_MALOC(e) * 1) | (IS_REALLOC(e) * 2) | (IS_FREE(e) * 4);\n+      _write_and_check(benchmark_fd, &type, sizeof(type));\n+      \/\/fprintf(stderr, \" %9ld:%9ld:%9ld %d:%d:%d\\n\", requested, actual, duration, IS_MALOC(e), IS_REALLOC(e), IS_FREE(e));\n+    }\n+    fprintf(stderr, \"time:%ld[ns] [samples:%ld]\\n\", total, count);\n+\n+    _close_and_check(log_fi.fd);\n+    _close_and_check(records_fi.fd);\n+    _close_and_check(benchmark_fd);\n+    FREE_C_HEAP_ARRAY(char, benchmark_file_path);\n+\n+    for (off_t i = 0; i < count; i++) {\n+      if (pointers[i] != nullptr) {\n+        os::free(pointers[i]);\n+        pointers[i] = nullptr;\n+      }\n+    }\n+    munmap((void*)pointers, size_pointers);\n+\n+    recorder->unlock();\n+\n+    os::exit(0);\n+  }\n+}\n+\n+void NMT_MemoryLogRecorder::_log(MemTag mem_tag, size_t requested, address ptr, address old, const NativeCallStack *stack) {\n+  NMT_MemoryLogRecorder *recorder = NMT_MemoryLogRecorder::instance();\n+  \/\/fprintf(stderr, \"NMT_MemoryLogRecorder::log(%16s, %6ld, %12p, %12p)\\n\", NMTUtil::tag_to_name(mem_tag), requested, ptr, old);\n+  volatile intx count = recorder->_count++;\n+  if (recorder->lockIfNotDone()) {\n+    if (count < recorder->_limit) {\n+      Entry entry;\n+      entry.time = count;\n+      if (MemTracker::is_initialized())\n+      {\n+        entry.time = os::javaTimeNanos();\n+      }\n+      entry.thread = os::current_thread_id();\n+      entry.ptr = ptr;\n+      entry.old = old;\n+      entry.requested = requested;\n+      entry.actual = 0;\n+      if (entry.requested > 0)\n+      {\n+#if defined(LINUX)\n+        entry.actual = permit_forbidden_function::malloc_usable_size(ptr);\n+#elif defined(WINDOWS)\n+        entry.actual = permit_forbidden_function::_msize(ptr);\n+#elif defined(__APPLE__)\n+        entry.actual = permit_forbidden_function::malloc_size(ptr);\n+#endif\n+      }\n+\n+      entry.mem_tag = (jlong)mem_tag;\n+      if ((MemTracker::is_initialized()) && (stack != nullptr)) {\n+        \/\/ recording stack frames will make sure that the hashtables\n+        \/\/ are used, so they get benchmarked\n+        for (int i = 0; i < NMT_TrackingStackDepth; i++) {\n+          entry.stack[i] = stack->get_frame(i);\n+        }\n+      }\n+\n+      if (recorder->_log_fd != -1) {\n+        _write_and_check(recorder->_log_fd, &entry, sizeof(Entry));\n+      }\n+    } else {\n+      recorder->finish();\n+    }\n+\n+    recorder->unlock();\n+  }\n+}\n+\n+void NMT_MemoryLogRecorder::log_free(void *ptr)\n+{\n+  NMT_MemoryLogRecorder::_log(mtNone, 0, (address)ptr, nullptr, nullptr);\n+}\n+\n+void NMT_MemoryLogRecorder::log_malloc(MemTag mem_tag, size_t requested, void* ptr, const NativeCallStack *stack)\n+{\n+  NMT_MemoryLogRecorder::_log(mem_tag, requested, (address)ptr, nullptr, stack);\n+}\n+\n+void NMT_MemoryLogRecorder::log_realloc(MemTag mem_tag, size_t requested, void* ptr, void* old, const NativeCallStack *stack)\n+{\n+  if (old == nullptr)\n+  {\n+    \/\/ mark the realloc's old pointer, so that we can tell realloc(NULL) and malloc() apart\n+    old = REALLOC_MARKER;\n+  }\n+  NMT_MemoryLogRecorder::_log(mem_tag, requested, (address)ptr, (address)old, stack);\n+}\n+\n+void NMT_MemoryLogRecorder::printActualSizesFor(const char* list) {\n+fprintf(stderr, \"NMT_MemoryLogRecorder::printActualSizesFor(%s)\\n\", list);\n+  char* string = os::strdup(NMTPrintMemoryAllocationsSizesFor, mtNMT);\n+  if (string != nullptr) {\n+    char* token = permit_forbidden_function::strtok(string, \",\");\n+    while (token) {\n+      long requested =  permit_forbidden_function::strtol(token, nullptr, 10);\n+      long actual = 0;\n+      void *ptr = permit_forbidden_function::malloc(requested);\n+      if (ptr != nullptr) {\n+#if defined(LINUX)\n+        actual = permit_forbidden_function::malloc_usable_size(ptr);\n+#elif defined(WINDOWS)\n+        actual = permit_forbidden_function::_msize(ptr);\n+#elif defined(__APPLE__)\n+        actual = permit_forbidden_function::malloc_size(ptr);\n+#endif\n+        permit_forbidden_function::free(ptr);\n+      }\n+      printf(\"%ld\", actual);\n+        token = permit_forbidden_function::strtok(NULL, \",\");\n+      if (token) {\n+        printf(\",\");\n+      }\n+    }\n+    os::exit(0);\n+  }\n+}\n+\n+static inline const char* type_to_name(NMT_VirtualMemoryLogRecorder::Type type) {\n+  switch (type) {\n+    case NMT_VirtualMemoryLogRecorder::Type::RESERVE: return \"RESERVE\"; break;\n+    case NMT_VirtualMemoryLogRecorder::Type::RELEASE: return \"RELEASE\"; break;\n+    case NMT_VirtualMemoryLogRecorder::Type::UNCOMMIT: return \"UNCOMMIT\"; break;\n+    case NMT_VirtualMemoryLogRecorder::Type::RESERVE_AND_COMMIT: return \"RESERVE_AND_COMMIT\"; break;\n+    case NMT_VirtualMemoryLogRecorder::Type::COMMIT: return \"COMMIT\"; break;\n+    case NMT_VirtualMemoryLogRecorder::Type::SPLIT_RESERVED: return \"SPLIT_RESERVED\"; break;\n+    case NMT_VirtualMemoryLogRecorder::Type::TAG: return \"TAG\"; break;\n+    default: break;\n+  }\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::initialize(intx limit) {\n+  fprintf(stderr, \"> NMT_VirtualMemoryLogRecorder::initialize(%ld)\\n\", limit);\n+  NMT_VirtualMemoryLogRecorder *recorder = NMT_VirtualMemoryLogRecorder::instance();\n+  recorder->init();\n+  recorder->lock();\n+  {\n+    recorder->_limit = limit;\n+    if (recorder->_limit > 0) {\n+      recorder->_log_fd = _prepare_log_file(nullptr, VALLOCS_LOG_FILE);\n+      fprintf(stderr, \">> _memLogRecorder._log_fd:%d\\n\", recorder->_log_fd);\n+      recorder->_done = false;\n+    } else {\n+      recorder->_done = true;\n+    }\n+  }\n+  recorder->unlock();\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::finish(void) {\n+  fprintf(stderr, \"NMT_VirtualMemoryLogRecorder::finish()\\n\");\n+  NMT_VirtualMemoryLogRecorder *recorder = NMT_VirtualMemoryLogRecorder::instance();\n+  if (recorder->lockIfNotDone()) {\n+      volatile int log_fd = recorder->_log_fd;\n+    recorder->_log_fd = -1;\n+      \/\/fprintf(stderr, \" log_fd:%d\\n\", log_fd);\n+      log_fd = _close_and_check(log_fd);\n+  }\n+\n+  int info_fd = _prepare_log_file(nullptr, INFO_LOG_FILE);\n+  fprintf(stderr, \" info_fd:%d\\n\", info_fd);\n+  if (info_fd != -1) {\n+    size_t level = NMTUtil::parse_tracking_level(NativeMemoryTracking);\n+    _write_and_check(info_fd, &level, sizeof(level));\n+    size_t overhead = MemTracker::overhead_per_malloc();\n+    _write_and_check(info_fd, &overhead, sizeof(overhead));\n+    info_fd = _close_and_check(info_fd);\n+    fprintf(stderr, \" info_fd:%d\\n\", info_fd);\n+  }\n+\n+  recorder->_done = true;\n+  recorder->unlock();\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::replay(const char* path, const int pid) {\n+    fprintf(stderr, \"NMT_VirtualMemoryLogRecorder::replay(\\\"%s\\\", %d)\\n\", path, pid);\n+  if ((pid != 0) && ((path == nullptr) || (strlen(path) == 0))) {\n+    static const char *home = \".\";\n+    path = home;\n+  }\n+  if ((path != nullptr) && (strlen(path) > 0)) {\n+    \/\/ compare the recorded and current levels of NMT and exit if different\n+    \/\/    file_info log_fi = _open_file_and_read(INFO_LOG_FILE, path, pid);\n+    \/\/    size_t* status_file_bytes = (size_t*)log_fi.ptr;\n+    \/\/    NMT_TrackingLevel recorded_nmt_level = (NMT_TrackingLevel)status_file_bytes[0];\n+    \/\/    if (NMTUtil::parse_tracking_level(NativeMemoryTracking) != recorded_nmt_level) {\n+    \/\/      tty->print(\"NativeMemoryTracking mismatch [%u != %u].\\n\", recorded_nmt_level, NMTUtil::parse_tracking_level(NativeMemoryTracking));\n+    \/\/      tty->print(\"Re-run with \\\"-XX:NativeMemoryTracking=%s\\\"\\n\", NMTUtil::tracking_level_to_string(recorded_nmt_level));\n+    \/\/      os::exit(-1);\n+    \/\/    }\n+\n+    \/\/ open records file for reading the virtual memory allocations to \"play back\"\n+    file_info records_fi = _open_file_and_read(VALLOCS_LOG_FILE, path, pid);\n+    Entry* records_file_entries = (Entry*)records_fi.ptr;\n+    long int count = (records_fi.size \/ sizeof(Entry));\n+\n+    jlong total = 0;\n+    for (off_t l = 0; l < NMTBenchmarkRecordedLoops; l++) {\n+      \/\/VirtualMemoryTracker::Instance::initialize(NMTUtil::parse_tracking_level(NativeMemoryTracking));\n+      for (off_t i = 0; i < count; i++) {\n+        Entry *e = &records_file_entries[i];\n+\n+        MemTag mem_tag = mtNone; \/\/NMTUtil::index_to_tag((int)e->mem_tag);\n+        int frameCount;\n+        for (frameCount = 0; frameCount < NMT_TrackingStackDepth; frameCount++) {\n+          if (e->stack[frameCount] == 0) {\n+            break;\n+          }\n+        }\n+        NativeCallStack stack = NativeCallStack::empty_stack();\n+        if (frameCount > 0) {\n+          stack = NativeCallStack(e->stack, frameCount);\n+        }\n+\n+        jlong start = os::javaTimeNanos();\n+        {\n+          switch (e->type) {\n+            case NMT_VirtualMemoryLogRecorder::Type::RESERVE:\n+              \/\/fprintf(stderr, \"[record_virtual_memory_reserve(%p, %zu, %p, %hhu)\\n\", e->ptr, e->size, &stack, mem_tag);fflush(stderr);\n+              MemTracker::record_virtual_memory_reserve(e->ptr, e->size, stack, mem_tag);\n+              \/\/fprintf(stderr, \"]\\n\");fflush(stderr);\n+              break;\n+            case NMT_VirtualMemoryLogRecorder::Type::RELEASE:\n+              \/\/fprintf(stderr, \"[record_virtual_memory_release(%p, %zu)\\n\", e->ptr, e->size);fflush(stderr);\n+              MemTracker::record_virtual_memory_release(e->ptr, e->size);\n+              \/\/fprintf(stderr, \"]\\n\");fflush(stderr);\n+              break;\n+            case NMT_VirtualMemoryLogRecorder::Type::UNCOMMIT:\n+              \/\/fprintf(stderr, \"<record_virtual_memory_uncommit(%p, %zu)\\n\", e->ptr, e->size);fflush(stderr);\n+              MemTracker::record_virtual_memory_uncommit(e->ptr, e->size);\n+              \/\/fprintf(stderr, \">\\n\");fflush(stderr);\n+              break;\n+            case NMT_VirtualMemoryLogRecorder::Type::RESERVE_AND_COMMIT:\n+              \/\/fprintf(stderr, \"[MemTracker::record_virtual_memory_reserve_and_commit\\n\");\n+              MemTracker::record_virtual_memory_reserve_and_commit(e->ptr, e->size, stack, mem_tag);\n+              \/\/fprintf(stderr, \"]\\n\");fflush(stderr);\n+              break;\n+            case NMT_VirtualMemoryLogRecorder::Type::COMMIT:\n+              \/\/fprintf(stderr, \"[record_virtual_memory_commit(%p, %zu, %p)\\n\", e->ptr, e->size, &stack);fflush(stderr);\n+              MemTracker::record_virtual_memory_commit(e->ptr, e->size, stack);\n+              \/\/fprintf(stderr, \"]\\n\");fflush(stderr);\n+              break;\n+            case NMT_VirtualMemoryLogRecorder::Type::SPLIT_RESERVED:\n+              \/\/fprintf(stderr, \"[MemTracker::record_virtual_memory_split_reserved\\n\");\n+              MemTracker::record_virtual_memory_split_reserved(e->ptr, e->size, e->size_split, mem_tag, NMTUtil::index_to_tag((int)e->mem_tag_split));\n+              \/\/fprintf(stderr, \"]\\n\");fflush(stderr);\n+              break;\n+            case NMT_VirtualMemoryLogRecorder::Type::TAG:\n+              \/\/fprintf(stderr, \"[record_virtual_memory_type(%p, %zu, %p)\\n\", e->ptr, e->size, &stack);fflush(stderr);\n+              MemTracker::record_virtual_memory_tag(e->ptr, mem_tag);\n+              \/\/fprintf(stderr, \"]\\n\");fflush(stderr);\n+              break;\n+            default:\n+              fprintf(stderr, \"HUH?\\n\");\n+              os::exit(-1);\n+              break;\n+          }\n+        }\n+        jlong end = os::javaTimeNanos();\n+        jlong duration = (start > 0) ? (end - start) : 0;\n+        total += duration;\n+      }\n+    }\n+    fprintf(stderr, \"time:%ld[ns] [samples:%ld] [loops:ld]\\n\", total, count, NMTBenchmarkRecordedLoops);\n+\n+\/\/    if (count > 0) {\n+\/\/      nullStream bench_null;\n+\/\/      total = 0;\n+\/\/      for (off_t l = 0; l < 1; l++) {\n+\/\/        jlong start = os::javaTimeNanos();\n+\/\/        VirtualMemoryTracker::Instance::print_self(tty);\n+\/\/        jlong end = os::javaTimeNanos();\n+\/\/        jlong duration = (start > 0) ? (end - start) : 0;\n+\/\/        total += duration;\n+\/\/      }\n+\/\/      fprintf(stderr, \"loops:%d total:%ld\\n\", NMTBenchmarkRecordedLoops, total);\n+\/\/    }\n+\n+    _close_and_check(records_fi.fd);\n+\n+    os::exit(0);\n+  }\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::_log(NMT_VirtualMemoryLogRecorder::Type type, MemTag mem_tag, MemTag mem_tag_split, size_t size, size_t size_split, address ptr, const NativeCallStack *stack) {\n+  fprintf(stderr, \"NMT_VirtualMemoryLogRecorder::log (%s, %hhu, %hhu, %zu, %zu, %p, %p)\\n\",\n+          type_to_name(type), mem_tag, mem_tag_split, size, size_split, ptr, stack);fflush(stderr);\n+  NMT_VirtualMemoryLogRecorder *recorder = NMT_VirtualMemoryLogRecorder::instance();\n+  volatile intx count = recorder->_count++;\n+  if (recorder->lockIfNotDone()) {\n+    if (count < recorder->_limit) {\n+      Entry entry;\n+      entry.type = type;\n+      entry.time = count;\n+      if (MemTracker::is_initialized())\n+      {\n+        entry.time = os::javaTimeNanos();\n+      }\n+      entry.thread = os::current_thread_id();\n+      entry.ptr = ptr;\n+      entry.mem_tag = (jlong)mem_tag;\n+      entry.mem_tag_split = (jlong)mem_tag_split;\n+      entry.size = size;\n+      entry.size_split = size_split;\n+      if ((MemTracker::is_initialized()) && (stack != nullptr)) {\n+        \/\/ the only use of frames is for benchmarking -\n+        \/\/ the NMT code uses a hashtable to store these values,\n+        \/\/ so preserving these will make sure that the hashtables\n+        \/\/ are used when ran with this data\n+        for (int i = 0; i < NMT_TrackingStackDepth; i++) {\n+          entry.stack[i] = stack->get_frame(i);\n+        }\n+      }\n+      fprintf(stderr, \"recorder->_log_fd: %d\\n\", recorder->_log_fd);\n+      if (recorder->_log_fd != -1) {\n+        _write_and_check(recorder->_log_fd, &entry, sizeof(Entry));\n+      }\n+    } else {\n+      recorder->finish();\n+    }\n+\n+    recorder->unlock();\n+  }\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::log_virtual_memory_reserve(void* addr, size_t size, const NativeCallStack& stack, MemTag mem_tag) {\n+  NMT_VirtualMemoryLogRecorder::_log(Type::RESERVE, mem_tag, mtNone, size, 0, (address)addr, &stack);\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::log_virtual_memory_release(address addr, size_t size) {\n+  NMT_VirtualMemoryLogRecorder::_log(Type::RELEASE, mtNone, mtNone, size, 0, (address)addr, nullptr);\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::log_virtual_memory_uncommit(address addr, size_t size) {\n+  NMT_VirtualMemoryLogRecorder::_log(Type::UNCOMMIT, mtNone, mtNone, size, 0, (address)addr, nullptr);\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::log_virtual_memory_reserve_and_commit(void* addr, size_t size, const NativeCallStack& stack, MemTag mem_tag) {\n+  NMT_VirtualMemoryLogRecorder::_log(Type::RESERVE_AND_COMMIT, mem_tag, mtNone, size, 0, (address)addr, &stack);\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::log_virtual_memory_commit(void* addr, size_t size, const NativeCallStack& stack) {\n+  NMT_VirtualMemoryLogRecorder::_log(Type::COMMIT, mtNone, mtNone, size, 0, (address)addr, &stack);\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::log_virtual_memory_split_reserved(void* addr, size_t size, size_t split, MemTag mem_tag, MemTag split_mem_tag) {\n+  NMT_VirtualMemoryLogRecorder::_log(Type::SPLIT_RESERVED, mem_tag, split_mem_tag, size, split, (address)addr, nullptr);\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::log_virtual_memory_tag(void* addr, MemTag mem_tag) {\n+  NMT_VirtualMemoryLogRecorder::_log(Type::TAG, mem_tag, mtNone, 0, 0, (address)addr, nullptr);\n+}\n+\n","filename":"src\/hotspot\/share\/nmt\/memLogRecorder.cpp","additions":826,"deletions":0,"binary":false,"changes":826,"status":"added"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_NMT_MEMLOGRECORDER_HPP\n+#define SHARE_NMT_MEMLOGRECORDER_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"nmt\/nmtCommon.hpp\"\n+#include \"runtime\/globals.hpp\"\n+\n+class NMT_LogRecorder : public StackObj {\n+#if defined(LINUX) || defined(__APPLE__)\n+  pthread_mutex_t _mutex;\n+#elif defined(WINDOWS)\n+ \/\/ ???\n+#endif\n+protected:\n+  intx _limit  = 0;\n+  intx _count  = 0;\n+  int _log_fd;\n+  volatile bool _done = true;\n+  static constexpr size_t _threads_name_length = 32;\n+  volatile size_t _threads_names_capacity = 128;\n+  volatile size_t _threads_names_counter = 0;\n+  typedef struct thread_name_info {\n+    char name[_threads_name_length];\n+    intx thread;\n+  } thread_name_info;\n+  thread_name_info *_threads_names = nullptr;\n+\n+public:\n+  static void initialize(intx memoryCount, intx virtualMemoryCount);\n+  static void finish();\n+  static void replay(const char* path, const int pid);\n+  static void logThreadName(const char* name);\n+\n+public:\n+  void init();\n+  bool lockIfNotDone();\n+  void lock();\n+  void unlock();\n+  bool done() {\n+    return _done;\n+  }\n+\n+private:\n+  void _logThreadName(const char* name);\n+};\n+\n+class NMT_MemoryLogRecorder : public NMT_LogRecorder {\n+\n+private:\n+  static NMT_MemoryLogRecorder _recorder;\n+\n+private:\n+  struct Entry {\n+    jlong time;\n+    intx thread;\n+    address ptr;\n+    address old;\n+    address stack[NMT_TrackingStackDepth];\n+    size_t requested;\n+    size_t actual;\n+    jlong mem_tag;\n+  };\n+\n+public:\n+  static NMT_MemoryLogRecorder* instance() {\n+    return &_recorder;\n+  };\n+  static void initialize(intx count);\n+  static bool initialized() {\n+    return false;\n+  }\n+  static void finish(void);\n+  static void replay(const char* path, const int pid);\n+  static void log_free(void *ptr);\n+  static void log_malloc(MemTag mem_tag, size_t requested, void* ptr, const NativeCallStack *stack);\n+  static void log_realloc(MemTag mem_tag, size_t requested, void* ptr, void* old, const NativeCallStack *stack);\n+  static void printActualSizesFor(const char* list);\n+\n+private:\n+  static void _log(MemTag mem_tag, size_t requested, address ptr, address old, const NativeCallStack *stack);\n+};\n+\n+class NMT_VirtualMemoryLogRecorder : public NMT_LogRecorder {\n+\n+private:\n+  static NMT_VirtualMemoryLogRecorder _recorder;\n+\n+private:\n+  struct Entry {\n+    jlong time;\n+    intx thread;\n+    address ptr;\n+    address stack[NMT_TrackingStackDepth];\n+    jlong mem_tag;\n+    jlong mem_tag_split;\n+    size_t size;\n+    size_t size_split;\n+    int type;\n+  };\n+\n+public:\n+  enum Type {\n+    RESERVE,\n+    RELEASE,\n+    UNCOMMIT,\n+    RESERVE_AND_COMMIT,\n+    COMMIT,\n+    SPLIT_RESERVED,\n+    TAG\n+  };\n+\n+public:\n+  static NMT_VirtualMemoryLogRecorder* instance() {\n+    return &_recorder;\n+  };\n+  static void initialize(intx count);\n+  static void finish(void);\n+  static void replay(const char* path, const int pid);\n+  static void log_virtual_memory_reserve(void* addr, size_t size, const NativeCallStack& stack, MemTag mem_tag = mtNone);\n+  static void log_virtual_memory_release(address addr, size_t size);\n+  static void log_virtual_memory_uncommit(address addr, size_t size);\n+  static void log_virtual_memory_reserve_and_commit(void* addr, size_t size, const NativeCallStack& stack, MemTag mem_tag = mtNone);\n+  static void log_virtual_memory_commit(void* addr, size_t size, const NativeCallStack& stack);\n+  static void log_virtual_memory_split_reserved(void* addr, size_t size, size_t split, MemTag flag, MemTag mem_tag_split);\n+  static void log_virtual_memory_tag(void* addr, MemTag mem_tag);\n+\n+private:\n+  static void _log(NMT_VirtualMemoryLogRecorder::Type type, MemTag mem_tag, MemTag mem_tag_split, size_t size, size_t size_split, address ptr, const NativeCallStack *stack);\n+};\n+\n+#endif \/\/ SHARE_NMT_MEMLOGRECORDER_HPP\n","filename":"src\/hotspot\/share\/nmt\/memLogRecorder.hpp","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"},{"patch":"@@ -56,0 +56,2 @@\n+  NMT_LogRecorder::initialize(NMTRecordMemoryAllocations, NMTRecordVirtualMemoryAllocations);\n+\n@@ -96,0 +98,2 @@\n+\n+  NMT_LogRecorder::replay(NMTBenchmarkRecordedDir, NMTBenchmarkRecordedPID);\n","filename":"src\/hotspot\/share\/nmt\/memTracker.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"nmt\/memLogRecorder.hpp\"\n@@ -129,0 +130,1 @@\n+      NMT_VirtualMemoryLogRecorder::log_virtual_memory_reserve((address)addr, size, stack, mem_tag);\n@@ -137,0 +139,1 @@\n+      NMT_VirtualMemoryLogRecorder::log_virtual_memory_release((address)addr, size);\n@@ -145,0 +148,1 @@\n+      NMT_VirtualMemoryLogRecorder::log_virtual_memory_uncommit((address)addr, size);\n@@ -155,0 +159,1 @@\n+      NMT_VirtualMemoryLogRecorder::log_virtual_memory_reserve_and_commit((address)addr, size, stack, mem_tag);\n@@ -166,0 +171,1 @@\n+      NMT_VirtualMemoryLogRecorder::log_virtual_memory_commit((address)addr, size, stack);\n@@ -214,0 +220,1 @@\n+      NMT_VirtualMemoryLogRecorder::log_virtual_memory_split_reserved((address)addr, size, split, mem_tag, split_tag);\n@@ -223,0 +230,1 @@\n+      NMT_VirtualMemoryLogRecorder::log_virtual_memory_tag((address)addr, mem_tag);\n","filename":"src\/hotspot\/share\/nmt\/memTracker.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3924,1 +3924,1 @@\n-                                char* buf, size_t buflen) {\n+                                char* buf, size_t buflen, int pid) {\n@@ -3940,1 +3940,4 @@\n-        int ret = jio_snprintf(b, buf_sz, \"%d\", os::current_process_id());\n+        if (pid == 0) {\n+          pid = os::current_process_id();\n+        }\n+        int ret = jio_snprintf(b, buf_sz, \"%d\", pid);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -510,1 +510,1 @@\n-  static bool copy_expand_pid(const char* src, size_t srclen, char* buf, size_t buflen);\n+  static bool copy_expand_pid(const char* src, size_t srclen, char* buf, size_t buflen, int pid = 0);\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -580,0 +580,27 @@\n+  product(intx, NMTRecordMemoryAllocations, 0, DIAGNOSTIC,                  \\\n+          \"Record the specified number of memory allocations.\"              \\\n+          \" 0: (the default) disables this feature.\"                        \\\n+          \" max_jint (0x7FFFFFFF): keep recording until the process exits\") \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n+  product(intx, NMTRecordVirtualMemoryAllocations, 0, DIAGNOSTIC,           \\\n+          \"Record the specified number of virtual memory allocations.\"      \\\n+          \" 0: (the default) disables this feature.\"                        \\\n+          \" max_jint (0x7FFFFFFF): keep recording until the process exits\") \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n+  product(ccstr, NMTBenchmarkRecordedDir, nullptr, DIAGNOSTIC,              \\\n+          \"Benchmark memory allocations using results found in folder\")     \\\n+                                                                            \\\n+  product(int, NMTBenchmarkRecordedPID, 0, DIAGNOSTIC,                      \\\n+          \"Benchmark memory allocations using results recorderd with PID\")  \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n+  product(int, NMTBenchmarkRecordedLoops, 1, DIAGNOSTIC,                    \\\n+          \"Benchmark memory allocations specified number of times\")         \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n+  product(ccstrlist, NMTPrintMemoryAllocationsSizesFor, nullptr, DIAGNOSTIC,\\\n+          \"Print the actual allocated memory sizes for given \"              \\\n+          \"comma separated list of malloc sizes\")                           \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -665,0 +665,2 @@\n+  NMT_MemoryLogRecorder::log_malloc(mem_tag, outer_size, outer_ptr, &stack);\n+\n@@ -735,0 +737,3 @@\n+\n+    NMT_MemoryLogRecorder::log_realloc(mem_tag, new_outer_size, new_outer_ptr, header, &stack);\n+\n@@ -783,0 +788,2 @@\n+  NMT_MemoryLogRecorder::log_free(old_outer_ptr);\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"nmt\/memLogRecorder.hpp\"\n@@ -358,0 +359,1 @@\n+    NMT_LogRecorder::logThreadName(name);\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -928,0 +928,2 @@\n+  NMT_LogRecorder::finish();\n+\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -564,0 +564,1 @@\n+  NMT_LogRecorder::finish();\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,6 @@\n+#if defined(LINUX)\n+#include <malloc.h>\n+#elif defined(__APPLE__)\n+#include <malloc\/malloc.h>\n+#endif\n+\n@@ -70,0 +76,11 @@\n+inline char *strtok(char *str, const char *sep) { return ::strtok(str, sep); }\n+inline long strtol(const char *str, char **endptr, int base) { return ::strtol(str, endptr, base); }\n+\n+#if defined(LINUX)\n+inline size_t malloc_usable_size(void *_Nullable ptr) { return ::malloc_usable_size(ptr); }\n+#elif defined(WINDOWS)\n+inline size_t _msize(void *memblock) { return ::_msize(memblock); }\n+#elif defined(__APPLE__)\n+inline size_t malloc_size(const void *ptr) { return ::malloc_size(ptr); }\n+#endif\n+\n","filename":"src\/hotspot\/share\/utilities\/permitForbiddenFunctions.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1804,0 +1804,2 @@\n+  NMT_LogRecorder::finish();\n+\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,540 @@\n+package nmt;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+\n+public class AllocationHistogram\n+{\n+    class HistogramValue\n+    {\n+        long requested;\n+        long actual;\n+        long count;\n+        long overhead;\n+        public HistogramValue(long r, long a)\n+        {\n+            this.requested = r;\n+            this.actual = a;\n+            this.count = 1;\n+            this.overhead = (a-r);\n+        }\n+\n+        public void add(long r, long a)\n+        {\n+            this.count++;\n+            this.overhead += (a-r);\n+        }\n+\n+        public long requested()\n+        {\n+            return this.requested;\n+        }\n+\n+        public long actual()\n+        {\n+            return this.actual;\n+        }\n+\n+        public long count()\n+        {\n+            return this.count;\n+        }\n+\n+        public long overhead()\n+        {\n+            return this.overhead;\n+        }\n+\n+        @Override public String toString()\n+        {\n+            return \"\"+this.count+\" \"+this.overhead;\n+        }\n+    }\n+\n+    HashMap<Long, HistogramValue> map_requested;\n+    HashMap<Long, HistogramValue> map_actual;\n+\n+    long max_count_requested = Long.MIN_VALUE;\n+    long max_count_actual = Long.MIN_VALUE;\n+    long max_overhead = Long.MIN_VALUE;\n+    long total_overhead;\n+\n+    int nmt_flag;\n+\n+    public AllocationHistogram(NMT_Allocation[] allocations)\n+    {\n+        this(allocations, NMT_Component.ALL);\n+    }\n+    public AllocationHistogram(NMT_Allocation[] allocations, int nmt_type)\n+    {\n+        this.total_overhead = 0;\n+\n+        this.nmt_flag = nmt_type;\n+        this.map_requested = new HashMap<>(Constants.HISTOGRAM_BUCKETS);\n+        this.map_actual = new HashMap<>(Constants.HISTOGRAM_BUCKETS);\n+        for (int i = 0; i < allocations.length; i++)\n+        {\n+            NMT_Allocation a = allocations[i];\n+            if (a.active)\n+            {\n+                if ((this.nmt_flag == NMT_Component.ALL) || (this.nmt_flag == a.flags))\n+                {\n+                    long requested = a.requested;\n+                    long actual = a.actual;\n+\n+                    HistogramValue v = this.map_requested.get(requested);\n+                    if (v == null)\n+                    {\n+                        this.map_requested.put(requested, new HistogramValue(requested, actual));\n+                    }\n+                    else\n+                    {\n+                        v.add(requested, actual);\n+                    }\n+\n+                    v = this.map_actual.get(actual);\n+                    if (v == null)\n+                    {\n+                        this.map_actual.put(actual, new HistogramValue(requested, actual));\n+                    }\n+                    else\n+                    {\n+                        v.add(requested, actual);\n+                    }\n+                }\n+            }\n+        }\n+\n+        long totalOverheadRequested = 0;\n+        ArrayList<Long> sizes = new ArrayList<>(this.map_requested.keySet());\n+        if (sizes.size() > 0)\n+        {\n+            Collections.sort(sizes);\n+            for (Long s : sizes)\n+            {\n+                HistogramValue v = this.map_requested.get(s);\n+                this.max_count_requested = Long.max(this.max_count_requested, v.count());\n+                long overhead = v.overhead();\n+                totalOverheadRequested += overhead;\n+            }\n+        }\n+        else\n+        {\n+            this.max_count_requested = 0;\n+        }\n+\n+        long totalOverheadActual = 0;\n+        sizes = new ArrayList<>(this.map_actual.keySet());\n+        if (sizes.size() > 0)\n+        {\n+            Collections.sort(sizes);\n+            for (Long s : sizes)\n+            {\n+                HistogramValue v = this.map_actual.get(s);\n+                this.max_count_actual = Long.max(this.max_count_actual, v.count());\n+                long overhead = v.overhead();\n+                totalOverheadActual += overhead;\n+                this.max_overhead = Long.max(this.max_overhead, overhead);\n+            }\n+        }\n+        else\n+        {\n+            this.max_count_actual = 0;\n+            this.total_overhead = 0;\n+            this.max_overhead = 0;\n+        }\n+\n+        if (totalOverheadRequested != totalOverheadActual)\n+        {\n+            throw new RuntimeException(\"totalOverheadRequested != totalOverheadActual [\"+totalOverheadRequested+\" != \"+totalOverheadActual+\"]\");\n+        }\n+        this.total_overhead = totalOverheadRequested;\n+    }\n+\n+    void printHeader(boolean memoryTypeActual, boolean countTypeSimple)\n+    {\n+        System.out.printf(\"Histogram of memory [NMT component: \\\"\"+NMT_Component.name(this.nmt_flag)+\"\\\"] \");\n+        if (countTypeSimple)\n+        {\n+            System.out.printf(\"[count type: simple] \");\n+        }\n+        else\n+        {\n+            System.out.printf(\"[count type: ratio] \");\n+        }\n+\n+        if (memoryTypeActual)\n+        {\n+            System.out.printf(\"[memory type: actual] \");\n+        }\n+        else\n+        {\n+            System.out.printf(\"[memory type: requested] \");\n+        }\n+\n+        \/\/boolean uses_linear = countTypeSimple;\n+        boolean uses_linear = false;\n+        if (uses_linear)\n+        {\n+            System.out.printf(\"[scale: linear]\");\n+        }\n+        else\n+        {\n+            System.out.printf(\"[scale: quadratic]\");\n+        }\n+        System.out.printf(\"\\n\");\n+\n+        \/\/printCounters(memoryTypeActual);\n+\n+        if (countTypeSimple)\n+        {\n+            if (memoryTypeActual)\n+            {\n+                System.out.printf(String.format(\"%3s %11s %11s %9s\\n\", \"#\", \" \", \"actual:\", \"<count:>\"));\n+            }\n+            else\n+            {\n+                System.out.printf(String.format(\"%3s %11s %11s %9s\\n\", \"#\", \"requested:\", \"actual:\", \"<count:>\"));\n+            }\n+        }\n+        else\n+        {\n+            if (memoryTypeActual)\n+            {\n+              System.out.printf(String.format(\"%3s %11s %11s %7s %10s %9s [ratio == overhead \/ total overhead]\\n\", \"#\", \" \", \"actual:\", \"count:\", \"overhead:\", \"<ratio:>\"));\n+            }\n+            else\n+            {\n+              System.out.printf(String.format(\"%3s %11s %11s %7s %10s %9s [ratio == overhead \/ total overhead]\\n\", \"#\", \"requested:\", \"actual:\", \"count:\", \"overhead:\", \"<ratio:>\"));\n+            }\n+        }\n+    }\n+\n+    void printLineGraph(double line, int width)\n+    {\n+        int l;\n+        for (l = 0; l < (int)line; l++)\n+        {\n+            System.out.printf(\"%c\", Constants.HISTOGRAM_BIG_DOT_ASCII);\n+        }\n+        for (; l < width; l++)\n+        {\n+            System.out.printf(\"%c\", Constants.HISTOGRAM_SMALL_DOT_ASCII);\n+        }\n+        System.out.printf(\"\\n\");\n+    }\n+\n+    void printLine(boolean memoryTypeActual, boolean useCount, int width, int index, Long s)\n+    {\n+        HistogramValue v = null;\n+        if (memoryTypeActual)\n+        {\n+            v = this.map_actual.get(s);\n+        }\n+        else\n+        {\n+            v = this.map_requested.get(s);\n+        }\n+        long overhead_in_bytes = v.overhead(); \/\/ [0..this.max_overhead]\n+        double percentage;\n+        if (useCount)\n+        {\n+            double max = 0.0;\n+            if (memoryTypeActual)\n+            {\n+                max = this.max_count_actual;\n+            }\n+            else\n+            {\n+                max = this.max_count_requested;\n+            }\n+            percentage = 100.0 * ((double)v.count \/ (double)max); \/\/ [0..100]\n+        }\n+        else\n+        {\n+            percentage = 100.0 * (double)overhead_in_bytes \/ (double)this.total_overhead; \/\/ [0..100]\n+        }\n+        if (percentage > Constants.HISTOGRAM_LINE_CUTOUT)\n+        {\n+            double line = 0.0;\n+            double a = 0.0;\n+            double b = 0.0;\n+\n+            if (useCount)\n+            {\n+                a = v.count;\n+                if (memoryTypeActual)\n+                {\n+                    System.out.printf(String.format(\"%3d %11s %,11d  %,7d  \", index, \" \", v.actual(), v.count()));\n+                    b = this.max_count_actual;\n+                }\n+                else\n+                {\n+                    System.out.printf(String.format(\"%3d %,11d %,11d  %,7d  \", index, v.requested(), v.actual(), v.count()));\n+                    b = this.max_count_requested;\n+                }\n+            }\n+            else\n+            {\n+                if (memoryTypeActual)\n+                {\n+                    System.out.printf(String.format(\"%3d %11s %,11d %,7d %,10d  %7.3f  \", index, \" \", v.actual(), v.count(), overhead_in_bytes, percentage));\n+                    b = this.max_count_actual;\n+                }\n+                else\n+                {\n+                    System.out.printf(String.format(\"%3d %,11d %,11d %,7d %,10d  %7.3f  \", index, v.requested(), v.actual(), v.count(), overhead_in_bytes, percentage));\n+                    b = this.max_count_requested;\n+                }\n+                a = overhead_in_bytes;\n+                b = this.max_overhead;\n+            }\n+\n+            \/\/boolean uses_linear = countTypeSimple;\n+            boolean uses_linear = false;\n+            if (uses_linear)\n+            {\n+                line = (a \/ b) * (double)width; \/\/ [0..width]\n+            }\n+            else\n+            {\n+                \/\/ quadratic function which goes through 3 points: (0,0) (25,50) (100,100)\n+                \/\/ https:\/\/www.mathepower.com\/en\/quadraticfunctions.php\n+                \/\/ y = -0.013*x*x + 2.333*x, x=[0..100], y=[0..100]\n+                double x = 100.0 * a \/ b; \/\/ [0..100]\n+                double y = Double.min(-0.013*x*x + 2.333*x, 100.0);\n+                line = (double)width * y \/ 100.0;\n+            }\n+\n+            printLineGraph(line, width);\n+        }\n+    }\n+\n+    public void print(boolean memoryTypeActual, boolean useCount, int width)\n+    {\n+        if (this.total_overhead != 0)\n+        {\n+            ArrayList<Long> sizes = null;\n+            if (memoryTypeActual)\n+            {\n+                sizes = new ArrayList<>(this.map_actual.keySet());\n+            }\n+            else\n+            {\n+                sizes = new ArrayList<>(this.map_requested.keySet());\n+            }\n+            Collections.sort(sizes);\n+            printHeader(memoryTypeActual, useCount);\n+            int index = 1;\n+            for (Long s : sizes)\n+            {\n+                printLine(memoryTypeActual, useCount, width ,index, s);\n+                index++;\n+            }\n+            System.out.printf(\"\\n\");\n+        }\n+    }\n+\n+    void printKeyValues()\n+    {\n+        printCounters(false);\n+        ArrayList<Long> sizes = new ArrayList<>(this.map_requested.keySet());\n+        Collections.sort(sizes);\n+        int index = 1;\n+        for (Long s : sizes)\n+        {\n+          System.out.printf(String.format(\"index:%3d key:%,9d value: %12s\\n\", index, s, this.map_requested.get(s)));\n+          index++;\n+        }\n+        System.out.printf(\"\\n\");\n+    }\n+\n+    void printCounters(boolean useActual)\n+    {\n+        HashMap<Long, HistogramValue> map = null;\n+        if (useActual)\n+        {\n+            map = this.map_actual;\n+            System.out.printf(String.format(\" max_count_actual:%,d length:%,d total overhead:%,d\\n\", this.max_count_actual, map.size(), this.total_overhead));\n+        }\n+        else\n+        {\n+            map = this.map_requested;\n+            System.out.printf(String.format(\" max_count_requested:%,d length:%,d total overhead:%,d\\n\", this.max_count_requested, map.size(), this.total_overhead));\n+        }\n+    }\n+\n+    void printMemorySizes(boolean memoryTypeActual)\n+    {\n+        HashMap<Long, HistogramValue> map = null;\n+        ArrayList<Long> sizes = null;\n+        if (memoryTypeActual)\n+        {\n+            map = this.map_actual;\n+            sizes = new ArrayList<>(map.keySet());\n+            System.out.printf(String.format(\"Malloc allocation sizes [%,d]: \", sizes.size()));\n+        }\n+        else\n+        {\n+            map = this.map_requested;\n+            sizes = new ArrayList<>(map.keySet());\n+            System.out.printf(String.format(\"Malloc request sizes [%,d]: \", sizes.size()));\n+        }\n+        Collections.sort(sizes);\n+        for (Long s : sizes)\n+        {\n+            HistogramValue v = map.get(s);\n+            if (memoryTypeActual)\n+            {\n+                System.out.printf(String.format(\"%,d \", v.actual()));\n+            }\n+            else\n+            {\n+              System.out.printf(String.format(\"%,d \", v.requested()));\n+            }\n+        }\n+        System.out.printf(\"\\n\\n\");\n+    }\n+\n+    void print(int memory_type, int count_type, boolean print_sizes, int width)\n+    {\n+        \/\/printKeyValues();\n+        if ((count_type == COUNT_BOTH) || (count_type == COUNT_OVERHEAD))\n+        {\n+            if ((memory_type == MEMORY_BOTH) || (memory_type == MEMORY_REQUESTED))\n+            {\n+                print(true, false, width);\n+            }\n+            if ((memory_type == MEMORY_BOTH) || (memory_type == MEMORY_ACTUAL))\n+            {\n+                print(false, false, width);\n+            }\n+        }\n+        if ((count_type == COUNT_BOTH) || (count_type == COUNT_SIMPLE))\n+        {\n+            if ((memory_type == MEMORY_BOTH) || (memory_type == MEMORY_REQUESTED))\n+            {\n+                print(true, true, width);\n+            }\n+            if ((memory_type == MEMORY_BOTH) || (memory_type == MEMORY_ACTUAL))\n+            {\n+                print(false, true, width);\n+            }\n+        }\n+        if (print_sizes)\n+        {\n+            if ((memory_type == MEMORY_BOTH) || (memory_type == MEMORY_REQUESTED))\n+            {\n+                printMemorySizes(false);\n+            }\n+            if ((memory_type == MEMORY_BOTH) || (memory_type == MEMORY_ACTUAL))\n+            {\n+                printMemorySizes(true);\n+            }\n+        }\n+        System.out.println(\"\");\n+    }\n+\n+    MemoryStats estimateStatsNoNMT(String java_path, NMT_Allocation[] allocations, int overhead_per_malloc)\n+    {\n+        findMissingSizes(java_path, allocations, overhead_per_malloc);\n+\n+        MemoryStats no_nmt_stats = new MemoryStats();\n+        for (int a = 0; a < allocations.length; a++)\n+        {\n+            NMT_Allocation alloc = allocations[a];\n+            if (alloc.is_active() && !alloc.is_free())\n+            {\n+                if (alloc.flags != NMT_Component.NATIVE_MEMORY_TRACKING)\n+                {\n+                    long requested = alloc.requested;\n+                    if (alloc.flags != NMT_Component.PREINIT)\n+                    {\n+                        requested -= overhead_per_malloc;\n+                    }\n+                    no_nmt_stats.requested_bytes += requested;\n+                    HistogramValue v = this.map_requested.get(requested);\n+                    if (v != null)\n+                    {\n+                        long actual = v.actual();\n+                        if (actual==0)\n+                        {\n+                            throw new RuntimeException(\"missing actual size for \"+requested);\n+                        }\n+                        no_nmt_stats.allocated_bytes += actual;\n+                    }\n+                    else\n+                    {\n+                        throw new RuntimeException(\"missing HistogramValue for \"+requested);\n+                    }\n+                }\n+            }\n+        }\n+        return no_nmt_stats;\n+    }\n+\n+    \/\/ since we are pretending here that NMT is OFF, we might end up with allocation sizes\n+    \/\/ that we haven't had to use yet, so identify those and then ask the VM itself\n+    \/\/ (using NMTPrintMemoryAllocationsSizesFor) to find out the actual sizes for these estimated requests\n+    void findMissingSizes(String java_path, NMT_Allocation[] allocations, int overhead_per_malloc)\n+    {\n+        HashMap<Long, String> missing = new HashMap<>(256);\n+        for (int a = 0; a < allocations.length; a++)\n+        {\n+            NMT_Allocation alloc = allocations[a];\n+            if (alloc.is_active() && !alloc.is_free())\n+            {\n+                if (alloc.flags != NMT_Component.NATIVE_MEMORY_TRACKING)\n+                {\n+                    long requested = alloc.requested;\n+                    if (alloc.flags != NMT_Component.PREINIT)\n+                    {\n+                        requested -= overhead_per_malloc;\n+                    }\n+                    HistogramValue v = this.map_requested.get(requested);\n+                    if (v == null)\n+                    {\n+                        \/\/ collect allocation sizes that we have not recorded yet\n+                        missing.putIfAbsent(requested, Long.toString(requested));\n+                    }\n+                }\n+            }\n+        }\n+\n+        if (missing.size() > 0)\n+        {\n+            ArrayList<Long> sizes = new ArrayList<>(missing.keySet());\n+            String list = \"\";\n+            for (Long s : sizes)\n+            {\n+                list += s;\n+                if (!s.equals(sizes.getLast()))\n+                {\n+                    list += \",\";\n+                }\n+            }\n+\n+            \/\/System.err.println(\"list:[\"+list+\"]\");\n+            \/\/ send the list of missing allocations off to \"java\" process\n+            String[] cmd = {java_path, \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:NMTPrintMemoryAllocationsSizesFor=\"+list};\n+            String string = Execute.execCmd(cmd).output();\n+            String[] found = string.split(\",\");\n+\n+            \/\/ add the newly found allocations\n+            for (int i = 0; i < found.length; i++)\n+            {\n+                long requested = sizes.get(i).longValue();\n+                long actual = Long.parseLong(found[i]);\n+                this.map_requested.put(requested, new HistogramValue(requested, actual));\n+            }\n+        }\n+    }\n+\n+    static final int MEMORY_REQUESTED  = 1;\n+    static final int MEMORY_ACTUAL     = 2;\n+    static final int MEMORY_BOTH       = 3;\n+    static final int COUNT_SIMPLE      = 4;\n+    static final int COUNT_OVERHEAD    = 5;\n+    static final int COUNT_BOTH        = 6;\n+}\n","filename":"src\/utils\/nmt\/AllocationHistogram.java","additions":540,"deletions":0,"binary":false,"changes":540,"status":"added"},{"patch":"@@ -0,0 +1,268 @@\n+package nmt;\n+\n+import java.util.Arrays;\n+\n+public class Benchmark\n+{\n+  private static double OverheadPercentage(double before, double after)\n+  {\n+    if ((before > 0.0) && (after > 0.0))\n+    {\n+      return ((after\/before - 1.0) * 100.0);\n+    }\n+    else\n+    {\n+      return 0.0;\n+    }\n+  }\n+\n+  private static void print_summary(String java_path, NMT_LogInfo nmt_log_info, NMT_Allocation[] allocations, NMT_Component[] components, MemoryStats total_stats, AllocationHistogram histogram_all)\n+  {\n+    System.out.println(\"\\n\");\n+    System.out.println(\"-----------------------------------------------------------------------------------------------------------------------------\");\n+    System.out.println(String.format(\"                                     NMT_LogInfo: %s\", nmt_log_info.levelAsString()));\n+    System.out.println(\"\\n\");\n+\n+    System.out.println(String.format(\"                            Requested (with NMT): %,11d bytes\", total_stats.requested_bytes));\n+    System.out.println(String.format(\"                            Allocated (with NMT): %,11d bytes\", total_stats.allocated_bytes));\n+\n+    long overhead_in_bytes = total_stats.overheadBytes();\n+    double malloc_overhead = OverheadPercentage(total_stats.requested_bytes, total_stats.allocated_bytes);\n+    System.out.println(String.format(\"   Overhead due to malloc rounding up (with NMT): %,11d bytes [%.3f%%]\", overhead_in_bytes, malloc_overhead));\n+    System.out.println(\"\");\n+\n+    if (nmt_log_info.equals(NMT_LogInfo.SUMMARY) || nmt_log_info.equals(NMT_LogInfo.DETAIL))\n+    {\n+      MemoryStats preinit_stats = null;\n+      for (int c = 0; c < components.length; c++)\n+      {\n+        if (components[c].flag == NMT_Component.PREINIT)\n+        {\n+          preinit_stats = components[c].getStatistics();\n+          break;\n+        }\n+      }\n+\n+      MemoryStats nmt_stats = null;\n+      for (int c = 0; c < components.length; c++)\n+      {\n+        if (components[c].flag == NMT_Component.NATIVE_MEMORY_TRACKING)\n+        {\n+          nmt_stats = components[c].getStatistics();\n+          break;\n+        }\n+      }\n+\n+      MemoryStats no_nmt_stats = histogram_all.estimateStatsNoNMT(java_path, allocations, nmt_log_info.overhead());\n+      long requested_no_nmt = no_nmt_stats.requested_bytes;\n+      long allocated_no_nmt = no_nmt_stats.allocated_bytes;\n+      long no_nmt_overhead_in_bytes = allocated_no_nmt - requested_no_nmt;\n+      double no_nmt_overhead = OverheadPercentage(requested_no_nmt, allocated_no_nmt);\n+      System.out.println(String.format(\"                         Requested (est. no NMT): %,11d bytes\", requested_no_nmt));\n+      System.out.println(String.format(\"                         Allocated (est. no NMT): %,11d bytes\", allocated_no_nmt));\n+      System.out.println(String.format(\"Overhead due to malloc rounding up (est. no NMT): %,11d bytes [%.3f%%]\", no_nmt_overhead_in_bytes, no_nmt_overhead));\n+      System.out.println(\"\");\n+\n+      long nmt_headers_count = total_stats.mallocs_count + total_stats.reallocs_count - preinit_stats.mallocs_count - preinit_stats.reallocs_count;\n+      long nmt_headers_bytes = nmt_headers_count * nmt_log_info.overhead();\n+      double nmt_headers_overhead = OverheadPercentage(total_stats.requested_bytes-nmt_headers_bytes, total_stats.requested_bytes);\n+      System.out.println(String.format(\"         Overhead due to NMT headers (requested): %,11d bytes [%.3f%%] [#%d]\", nmt_headers_bytes, nmt_headers_overhead, nmt_headers_count));\n+\n+      long nmt_objects_count = nmt_stats.mallocs_count + nmt_stats.reallocs_count;\n+      long nmt_objects_bytes = nmt_stats.requested_bytes - (nmt_objects_count * nmt_log_info.overhead()); \/\/ substract the NMT header cost\n+      double nmt_objects_overhead = OverheadPercentage(total_stats.requested_bytes-nmt_objects_bytes, total_stats.requested_bytes);\n+      System.out.println(String.format(\"         Overhead due to NMT objects (requested): %,11d bytes [%.3f%%] [#%d]\", nmt_objects_bytes, nmt_objects_overhead, nmt_objects_count));\n+\n+      long total_nmt_bytes = nmt_headers_bytes + nmt_objects_bytes;\n+      double total_nmt_overhead = OverheadPercentage(total_stats.requested_bytes-total_nmt_bytes, total_stats.requested_bytes);\n+      System.out.println(String.format(\"                 Overhead due to NMT (requested): %,11d bytes [%.3f%%]\", total_nmt_bytes, total_nmt_overhead));\n+      System.out.println(\"\");\n+\n+      System.out.println(String.format(\"               NMT overhead (requested) increase: %11.3f %%\", OverheadPercentage(requested_no_nmt, total_stats.requested_bytes)));\n+      System.out.println(String.format(\"               NMT overhead (allocated) increase: %11.3f %%\", OverheadPercentage(allocated_no_nmt, total_stats.allocated_bytes)));\n+    }\n+    System.out.println(\"\\n\\n\");\n+  }\n+\n+  private static void print_memory_pointers_bits_coverage(NMT_Allocation[] allocations)\n+  {\n+    System.out.println(\"memory pointers bits coverage (percentile of 1 vs 0 appearing in bits 63..0):\");\n+    double bits_counter_total = 0;\n+    long bits_counters[] = new long[64];\n+    for (int i = 0; i < 64; i++)\n+    {\n+      bits_counters[i] = 0;\n+    }\n+    for (int i = 0; i < allocations.length; i++)\n+    {\n+      NMT_Allocation a = allocations[i];\n+      long ptr = a.ptr_curr;\n+      if (ptr != 0)\n+      {\n+        bits_counter_total++;\n+        for (int j = 0; j < 64; j++)\n+        {\n+          bits_counters[j] += (ptr >> j) & 0b1;\n+        }\n+      }\n+    }\n+    for (int j = 63; j >= 0; j--)\n+    {\n+      System.out.printf(\"%3d \", Math.round(100.0*(double)bits_counters[j]\/bits_counter_total));\n+    }\n+    System.out.println(\"\");\n+  }\n+\n+  private static void print_memory_histograms(NMT_Allocation[] allocations, NMT_Component[] components, AllocationHistogram histogram)\n+  {\n+    boolean print_sizes = true;\n+    int memory_type = AllocationHistogram.MEMORY_BOTH;\n+    int count_type = AllocationHistogram.COUNT_OVERHEAD;\n+    AllocationHistogram h = null;\n+    for (int i = 0; i < components.length; i++)\n+    {\n+      NMT_Component c = components[i];\n+      System.out.println(\"-----------------------------------------------------------------------------------------------------------------------------------------\");\n+      System.out.println(\"Histograms for NMT component \\\"\"+c+\"\\\" [line cutoff=\"+Constants.HISTOGRAM_LINE_CUTOUT+\"]:\\n\");\n+      h = new AllocationHistogram(allocations, c.flag);\n+      h.print(memory_type, count_type, print_sizes, Constants.HISTOGRAM_WIDTH);\n+    }\n+    System.out.println(\"\\n\");\n+    System.out.println(\"-----------------------------------------------------------------------------------------------------------------------------------------\");\n+    histogram.print(memory_type, count_type, print_sizes, Constants.HISTOGRAM_WIDTH);\n+    System.out.println(\"\\n\");\n+  }\n+\n+  private static void print_performance_histograms(NMT_Duration[] durations)\n+  {\n+    \/\/ for (int i = 0; i < durations.length; i++)\n+    \/\/ {\n+    \/\/     System.err.println(\"-->\"+durations[i].duration+\",\"+durations[i].requested+\",\"+durations[i].actual+\",\"+durations[i].type);\n+    \/\/ }\n+    DurationHistogram h = new DurationHistogram(durations);\n+    h.print(Constants.HISTOGRAM_WIDTH);\n+  }\n+\n+  public static long examine_recording_with_pid(String mode, String java_path, long baseline_pid, String path) throws Exception\n+  {\n+    NMT_LogInfo nmt_log_info = NMT_LogInfo.read_status_log(baseline_pid, path);\n+    NMT_Allocation[] allocations = NMT_Allocation.read_memory_log(baseline_pid, path);\n+    NMT_Thread[] threads = NMT_Thread.read_thread_log(baseline_pid, path, NMT_Allocation.getMainThreadId(allocations));\n+    NMT_Component[] components = NMT_Component.get();\n+\n+    boolean consolidateMemory = true;\n+    if (consolidateMemory)\n+    {\n+      \/\/ apply \"free\" to the allocations to get the current picture of the memory\n+      NMT_Allocation.consolidate(allocations, mode.equals(\"All\"));\n+    }\n+\n+    AllocationHistogram histogram = new AllocationHistogram(allocations);\n+    if (mode.equals(\"All\") || mode.equals(\"MemoryHistograms\"))\n+    {\n+      print_memory_histograms(allocations, components, histogram);\n+    }\n+\n+    if (mode.equals(\"All\") || mode.equals(\"PerformanceHistograms\"))\n+    {\n+      NMT_Duration[] durations = NMT_Duration.read_benchmark_log(baseline_pid, path);\n+      print_performance_histograms(durations);\n+    }\n+\n+    if (mode.equals(\"All\") || mode.equals(\"MemorySummary\"))\n+    {\n+      \/\/ prints current summary of memory allocations\n+      MemoryStats totals = find_totals(allocations, threads);\n+      print_totals(\"Current summary of memory allocations by thread:\", totals, threads);\n+    }\n+\n+    MemoryStats total_stats = find_totals(allocations, components);\n+    if (mode.equals(\"All\") || mode.equals(\"MemorySummary\"))\n+    {\n+      print_totals(\"Current summary of memory allocations by component:\", total_stats, components);\n+    }\n+\n+    if (mode.equals(\"All\") || mode.equals(\"MemorySummary\"))\n+    {\n+      \/\/ prints total lifetime summary of memory allocations\n+      MemoryStats totals = find_totals(allocations, threads);\n+      print_totals(\"Total lifetime summary of memory allocations by thread:\", totals, threads);\n+      totals = find_totals(allocations, components);\n+      print_totals(\"Total lifetime summary of memory allocations component:\", totals, components);\n+    }\n+\n+    print_summary(java_path, nmt_log_info, allocations, components, total_stats, histogram);\n+\n+    \/\/ unrelated to benchmarking, but the following code shows bits of memory pointer that are unused by the os,\n+    \/\/ so they could be used for memory pointer coloring\n+    \/\/print_memory_pointers_bits_coverage(allocations);\n+\n+    return total_stats.requested_bytes;\n+  }\n+\n+  private static void print_totals(String title, MemoryStats totals, Statistical[] items)\n+  {\n+    System.out.printf(\"%s\\n\", title);\n+    System.out.printf(\"-----------------------------------------------------------------------------------------------------------------------------\\n\");\n+    System.out.printf(String.format(\"%40s %10s %10s %10s %11s %12s %12s %13s\\n\", \"name:\", \"mallocs:\", \"reallocs:\", \"frees:\", \"requested:\", \"allocated:\", \"overhead:\", \"overhead:\"));\n+    System.out.printf(String.format(\"%40s %10s %10s %10s %11s %12s %12s %14s\\n\", \" \", \"(count)\", \"(count)\", \"(count)\", \"(bytes)\", \"(bytes)\", \"(bytes)\", \"(mem diff %%)\"));\n+    System.out.printf(\"-----------------------------------------------------------------------------------------------------------------------------\\n\");\n+    for (int t = 0; t < items.length; t++)\n+    {\n+      Statistical item = items[t];\n+      MemoryStats stats = item.getStatistics();\n+      stats.print(item.toString());\n+    }\n+    System.out.printf(\"-----------------------------------------------------------------------------------------------------------------------------\\n\");\n+    totals.print(\"TOTALS:\");\n+    System.out.printf(\"-------------------------------------------------------------------------\\n\");\n+    System.out.printf(String.format(\"%40s %,10d\\n\", \"TOTALS:\", totals.count()));\n+    System.out.printf(\"-----------------------------------------------------------------------------------------------------------------------------\\n\");\n+    System.out.print(\"\\n\");\n+  }\n+\n+  private static MemoryStats find_totals(NMT_Allocation[] allocations, Statistical[] items)\n+  {\n+    if (items == null)\n+    {\n+      return new MemoryStats();\n+    }\n+\n+    for (int j = 0; j < items.length; j++)\n+    {\n+      items[j].clearStatistics();\n+    }\n+\n+    boolean all = false;\n+    for (int i = 0; i < allocations.length; i++)\n+    {\n+      for (int j = 0; j < items.length; j++)\n+      {\n+        NMT_Allocation a = allocations[i];\n+        if (all || (a.is_active()))\n+        {\n+          items[j].addStatistics(allocations[i]);\n+        }\n+      }\n+    }\n+\n+    Arrays.sort(items);\n+\n+    MemoryStats totals = new MemoryStats();\n+    for (int t = 0; t < items.length; t++)\n+    {\n+      Statistical item = items[t];\n+      MemoryStats stats = item.getStatistics();\n+      totals.add(stats);\n+    }\n+\n+    for (int t = 0; t < items.length; t++)\n+    {\n+      Statistical item = items[t];\n+      MemoryStats stats = item.getStatistics();\n+      stats.calculateOverheadPercentage(totals.overheadBytes());\n+    }\n+    totals.calculateOverheadPercentage(totals.overheadBytes());\n+    return totals;\n+  }\n+}\n","filename":"src\/utils\/nmt\/Benchmark.java","additions":268,"deletions":0,"binary":false,"changes":268,"status":"added"},{"patch":"@@ -0,0 +1,141 @@\n+package nmt;\n+\n+import com.sun.tools.javac.Main;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+\n+\/\/ helper for recording BENCHMARK_COUNT of benchmarks, then selecting the \"best\" for further analysis\n+public class BenchmarkRecorder\n+{\n+  static final int BENCHMARK_COUNT = 11; \/\/ must be odd (so that it is easy to find median)!\n+  static\n+  {\n+    if ((BENCHMARK_COUNT%2) == 0)\n+    {\n+      throw new RuntimeException(\"BENCHMARK_COUNT is not odd: \"+BENCHMARK_COUNT);\n+    }\n+  }\n+\n+  static class Result implements Comparable<Result>\n+  {\n+    long pid;\n+    long memory;\n+\n+    public Result(long p, long m)\n+    {\n+      this.pid = p;\n+      this.memory = m;\n+    }\n+\n+    public long pid()\n+    {\n+      return this.pid;\n+    }\n+\n+    public long memory()\n+    {\n+      return this.memory;\n+    }\n+\n+    @Override public int compareTo(Result r)\n+    {\n+      return (int)(this.memory - r.memory);\n+    }\n+  }\n+\n+  static void print_best_record(String mode, String recording_path, String java_path, String[] args) throws Exception\n+  {\n+    final String[] NMT_FLAGS = {\"-XX:NativeMemoryTracking=off\", \"-XX:NativeMemoryTracking=summary\", \"-XX:NativeMemoryTracking=detail\"};\n+    final String RECORD_FLAG = \"-XX:NMTRecordMemoryAllocations=0x7ffffff\";\n+    final Result[] RESULTS = new Result[BENCHMARK_COUNT];\n+    for (int f = 0; f < NMT_FLAGS.length; f++)\n+    {\n+      System.out.printf(String.format(\"\\nrecording with NMT '%s'\\n\", NMT_FLAGS[f]));\n+      long min_pid = 0;\n+      long max_pid = 0;\n+      long min_result = Long.MAX_VALUE;\n+      long max_result = Long.MIN_VALUE;\n+      double total_result = 0.0;\n+      for (int i = 0; i < BENCHMARK_COUNT; i++)\n+      {\n+        System.out.printf(String.format(\"\\n%d\/%d\\n\", (i+1), BENCHMARK_COUNT));\n+        int nmt_args_size = 4;\n+        String[] cmd = new String[nmt_args_size+args.length];\n+        cmd[0] = java_path;\n+        cmd[1] = \"-XX:+UnlockDiagnosticVMOptions\";\n+        cmd[2] = NMT_FLAGS[f];\n+        cmd[3] = RECORD_FLAG;\n+        for (int a = 0; a < args.length; a++)\n+        {\n+          cmd[nmt_args_size+a] = args[a];\n+        }\n+        Execute.ProcessRunner pr = Execute.execCmd(cmd, recording_path);\n+        String output = pr.output();\n+        if (output == null)\n+        {\n+          throw new RuntimeException(\"output == null\");\n+        }\n+        long pid = pr.pid();\n+\n+        long result = Benchmark.examine_recording_with_pid(mode, java_path, pid, recording_path.toString());\n+        total_result += result;\n+        RESULTS[i] = new Result(pid, result);\n+        if (result < min_result)\n+        {\n+          min_pid = pid;\n+          min_result = result;\n+        }\n+        else if (result > max_result)\n+        {\n+          max_pid = pid;\n+          max_result = result;\n+        }\n+        System.out.printf(String.format(\"   current: %,10d [%d]\\n\", result, pid));\n+      }\n+      System.out.printf(String.format(\"\\n\"));\n+      System.out.printf(String.format(\"       min: %,10d [%d]\\n\", min_result, min_pid));\n+      System.out.printf(String.format(\"   average: %,10d\\n\", (int)(total_result\/(double)BENCHMARK_COUNT)));\n+      Arrays.sort(RESULTS);\n+      Result r = RESULTS[BENCHMARK_COUNT\/2];\n+      System.out.printf(String.format(\"    median: %,10d [%d]\\n\", r.memory(), r.pid()));\n+      System.out.printf(String.format(\"       max: %,10d [%d]\\n\", max_result, max_pid));\n+      System.out.printf(String.format(\"     range: %,10d %.3f\\n\", (max_result-min_result), 100.0*(double)(max_result-min_result)\/(double)(r.memory())));\n+    }\n+  }\n+\n+  public static void record(String mode, String wdir_path, String jdk_bin_path) throws Exception\n+  {\n+    String java_path = Path.of(jdk_bin_path, \"java\").toAbsolutePath().toString();\n+    System.out.println(\" java_path:\"+java_path);\n+    String recordings_path = Path.of(wdir_path, \"recordings\").toAbsolutePath().toString();\n+    System.out.println(\" recordings_path:\"+recordings_path);\n+    String demos_path = Path.of(wdir_path, \"demos\").toAbsolutePath().toString();\n+    System.out.println(\" demos_path:\"+demos_path);\n+\n+    Files.createDirectories(Path.of(recordings_path));\n+\n+    boolean recordHelloWorld = false;\n+    if (recordHelloWorld)\n+    {\n+      System.err.println(\"\\n\\nrecording HelloWorld...\");\n+      String rec_path = Path.of(recordings_path, \"HelloWorld\").toAbsolutePath().toString();\n+      Files.createDirectories(Path.of(rec_path));\n+\n+      String[] args = {\"-cp\", demos_path, \"HelloWorld\"};\n+      print_best_record(mode, rec_path, java_path, args);\n+    }\n+\n+    boolean recordJ2Ddemo = true;\n+    if (recordJ2Ddemo)\n+    {\n+      System.err.println(\"\\n\\nrecording J2Ddemo...\");\n+      String rec_path = Path.of(recordings_path, \"J2Ddemo\").toAbsolutePath().toString();\n+      Files.createDirectories(Path.of(rec_path));\n+\n+      String jar_path = Path.of(demos_path, \"J2Ddemo.jar\").toAbsolutePath().toString();\n+      String[] args = {\"-jar\", jar_path};\n+      print_best_record(mode, rec_path, java_path, args);\n+    }\n+  }\n+}\n","filename":"src\/utils\/nmt\/BenchmarkRecorder.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -0,0 +1,17 @@\n+package nmt;\n+\n+public class Constants\n+{\n+  public static final int HISTOGRAM_WIDTH = 128;\n+  public static final int HISTOGRAM_BUCKETS = 256;\n+\n+  \/\/public static final char HISTOGRAM_SMALL_DOT_ASCII = '.';\n+  public static final char HISTOGRAM_SMALL_DOT_ASCII = 0xB7; \/\/ ''\n+\n+  \/\/public static final char HISTOGRAM_BIG_DOT_ASCII = '*';\n+  \/\/public static final char HISTOGRAM_BIG_DOT_ASCII = '#';\n+  public static final char HISTOGRAM_BIG_DOT_ASCII = 0xBA; \/\/ ''\n+\n+  public static final double HISTOGRAM_LINE_CUTOUT = 0.0;\n+  \/\/public static final double HISTOGRAM_LINE_CUTOUT = 0.6;\n+}\n","filename":"src\/utils\/nmt\/Constants.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"@@ -0,0 +1,328 @@\n+package nmt;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import javax.xml.validation.Validator;\n+\n+public class DurationHistogram\n+{\n+  HashMap<Long, NMT_Duration> size_count_malloc;\n+  long size_count_malloc_max = 0;\n+  long size_count_malloc_total = 0;\n+\n+  HashMap<Long, NMT_Duration> size_count_realloc;\n+  long size_count_realloc_max = 0;\n+  long size_count_realloc_total = 0;\n+\n+  HashMap<Long, NMT_Duration> duration_count_malloc;\n+  long duration_count_malloc_max = 0;\n+  long duration_count_malloc_total = 0;\n+\n+  HashMap<Long, NMT_Duration> duration_count_realloc;\n+  long duration_count_realloc_max = 0;\n+  long duration_count_realloc_total = 0;\n+\n+  HashMap<Long, NMT_Duration> duration_count_free;\n+  long duration_count_free_max = 0;\n+  long duration_count_free_total = 0;\n+\n+  Object durations_count_size_malloc[];\n+  long durations_count_size_malloc_max[];\n+  long durations_count_size_malloc_total[];\n+\n+  Object durations_count_size_realloc[];\n+  long durations_count_size_realloc_max[];\n+  long durations_count_size_realloc_total[];\n+\n+  static long initMapCounts(NMT_Duration[] durations, HashMap<Long, NMT_Duration> map, byte type)\n+  {\n+    long max = 0;\n+    for (int i = 0; i < durations.length; i++)\n+    {\n+      NMT_Duration d = durations[i];\n+      if (d.is_type(type))\n+      {\n+        NMT_Duration v = map.get(d.actual());\n+        if (v == null)\n+        {\n+          v = d.clone();\n+          map.put(d.actual(), v);\n+        }\n+        else\n+        {\n+          v.add();\n+        }\n+        max = Long.max(max, v.count());\n+      }\n+    }\n+    return max;\n+  }\n+\n+  static long initMap(NMT_Duration[] durations, HashMap<Long, NMT_Duration> map, byte type)\n+  {\n+    return initMap(durations, map, type, 0);\n+  }\n+  static long initMap(NMT_Duration[] durations, HashMap<Long, NMT_Duration> map, byte type, long actual)\n+  {\n+    long max = 0;\n+    for (int i = 0; i < durations.length; i++)\n+    {\n+      NMT_Duration d = durations[i];\n+      if (d.is_type(type))\n+      {\n+        if ((actual == 0) || (d.actual() == actual))\n+        {\n+          NMT_Duration v = map.get(d.duration());\n+          if (v == null)\n+          {\n+            v = d.clone();\n+            map.put(d.duration(), v);\n+          }\n+          else\n+          {\n+            v.add();\n+          }\n+          max = Long.max(max, v.count());\n+        }\n+      }\n+    }\n+    return max;\n+  }\n+\n+  static long countTotal(HashMap<Long, NMT_Duration> map)\n+  {\n+    long total = 0;\n+    ArrayList<Long> keys = new ArrayList<>(map.keySet());\n+    for (int i = 0; i < keys.size(); i++)\n+    {\n+      long duration = keys.get(i);\n+      NMT_Duration d = map.get(duration);\n+      total += d.count();\n+    }\n+    return total;\n+  }\n+\n+  public DurationHistogram(NMT_Duration[] durations)\n+  {\n+    \/\/ for (int i = 0; i < durations.length; i++)\n+    \/\/ {\n+    \/\/     NMT_Duration d = durations[i];\n+    \/\/     System.err.println(d);\n+    \/\/ }\n+\n+    this.size_count_malloc = new HashMap<>(Constants.HISTOGRAM_BUCKETS);\n+    this.size_count_malloc_max = initMapCounts(durations, this.size_count_malloc, NMT_Duration.MALLOC_TYPE);\n+    this.size_count_malloc_total = countTotal(this.size_count_malloc);\n+\n+    this.size_count_realloc = new HashMap<>(Constants.HISTOGRAM_BUCKETS);\n+    this.size_count_realloc_max = initMapCounts(durations, this.size_count_realloc, NMT_Duration.REALLOC_TYPE);\n+    this.size_count_realloc_total = countTotal(this.size_count_realloc);\n+\n+    this.duration_count_malloc = new HashMap<>(Constants.HISTOGRAM_BUCKETS);\n+    this.duration_count_malloc_max = initMap(durations, this.duration_count_malloc, NMT_Duration.MALLOC_TYPE);\n+    this.duration_count_malloc_total = countTotal(this.duration_count_malloc);\n+\n+    this.duration_count_realloc = new HashMap<>(Constants.HISTOGRAM_BUCKETS);\n+    this.duration_count_realloc_max = initMap(durations, this.duration_count_realloc, NMT_Duration.REALLOC_TYPE);\n+    this.duration_count_realloc_total = countTotal(this.duration_count_realloc);\n+\n+    this.duration_count_free = new HashMap<>(Constants.HISTOGRAM_BUCKETS);\n+    this.duration_count_free_max = initMap(durations, this.duration_count_free, NMT_Duration.FREE_TYPE);\n+    this.duration_count_free_total = countTotal(this.duration_count_free);\n+\n+    ArrayList<Long> keys = null;\n+\n+    keys = new ArrayList<>(this.size_count_malloc.keySet());\n+    Collections.sort(keys);\n+    this.durations_count_size_malloc = new Object[keys.size()];\n+    this.durations_count_size_malloc_max = new long[keys.size()];\n+    this.durations_count_size_malloc_total = new long[keys.size()];\n+    for (int i = 0; i < this.durations_count_size_malloc.length; i++)\n+    {\n+      HashMap<Long, NMT_Duration> h = new HashMap<>(Constants.HISTOGRAM_BUCKETS);\n+      this.durations_count_size_malloc[i] = h;\n+      this.durations_count_size_malloc_max[i] = initMap(durations, h, NMT_Duration.MALLOC_TYPE, keys.get(i));\n+      this.durations_count_size_malloc_total[i] = countTotal(h);\n+    }\n+\n+    keys = new ArrayList<>(this.size_count_realloc.keySet());\n+    Collections.sort(keys);\n+    this.durations_count_size_realloc = new Object[keys.size()];\n+    this.durations_count_size_realloc_max = new long[keys.size()];\n+    this.durations_count_size_realloc_total = new long[keys.size()];\n+    for (int i = 0; i < this.durations_count_size_realloc.length; i++)\n+    {\n+      HashMap<Long, NMT_Duration> h = new HashMap<>(Constants.HISTOGRAM_BUCKETS);\n+      this.durations_count_size_realloc[i] = h;\n+      this.durations_count_size_realloc_max[i] = initMap(durations, h, NMT_Duration.REALLOC_TYPE, keys.get(i));\n+      this.durations_count_size_realloc_total[i] = countTotal(h);\n+    }\n+  }\n+\n+  void printLineGraph(double line, int width)\n+  {\n+    int l;\n+    for (l = 0; l < (int)line; l++)\n+    {\n+      System.out.printf(\"%c\", Constants.HISTOGRAM_BIG_DOT_ASCII);\n+    }\n+    for (; l < width; l++)\n+    {\n+      System.out.printf(\"%c\", Constants.HISTOGRAM_SMALL_DOT_ASCII);\n+    }\n+    System.out.printf(\"\\n\");\n+  }\n+\n+  void printLine(double percentage, long count, long max, int width)\n+  {\n+    double line = 0.0;\n+    double a = count;\n+    double b = max;\n+\n+    boolean uses_linear = true;\n+    if (uses_linear)\n+    {\n+      line = (a \/ b) * (double)width; \/\/ [0..width]\n+    }\n+    else\n+    {\n+      \/\/ quadratic function which goes through 3 points: (0,0) (25,50) (100,100)\n+      \/\/ https:\/\/www.mathepower.com\/en\/quadraticfunctions.php\n+      \/\/ y = -0.013*x*x + 2.333*x, x=[0..100], y=[0..100]\n+      double x = 100.0 * a \/ b; \/\/ [0..100]\n+      double y = Double.min(-0.013*x*x + 2.333*x, 100.0);\n+      line = (double)width * y \/ 100.0;\n+    }\n+\n+    printLineGraph(line, width);\n+  }\n+\n+  void printMapCounts(int width, HashMap<Long, NMT_Duration> map, long max)\n+  {\n+    System.out.printf(\"idx:         size:      count:\\n\");\n+    int index = 1;\n+    ArrayList<Long> keys = new ArrayList<>(map.keySet());\n+    Collections.sort(keys);\n+    for (Long k : keys)\n+    {\n+      NMT_Duration v = map.get(k);\n+      double percentage = 100.0 * ((double)v.count() \/ (double)max); \/\/ [0..100]\n+      if (percentage > Constants.HISTOGRAM_LINE_CUTOUT)\n+      {\n+        System.out.printf(String.format(\"%4d   %,11d     %,7d  \", index, v.actual(), v.count()));\n+        printLine(percentage, v.count(), max, width);\n+      }\n+      index++;\n+    }\n+    System.out.printf(\"\\n\");\n+  }\n+\n+  void printMap(int width, Object m, long max)\n+  {\n+    HashMap<Long, NMT_Duration> map = (HashMap<Long, NMT_Duration>)m;\n+    System.out.printf(\"idx:     duration:      count:\\n\");\n+    @SuppressWarnings(\"unchecked\")\n+    HashMap<Long, NMT_Duration> h = (HashMap<Long, NMT_Duration>)map;\n+    ArrayList<Long> keys = new ArrayList<>(h.keySet());\n+    Collections.sort(keys);\n+    int index = 1;\n+    for (Long k : keys)\n+    {\n+      NMT_Duration v = h.get(k);\n+      double percentage = 100.0 * ((double)v.count() \/ (double)max); \/\/ [0..100]\n+      if (percentage > Constants.HISTOGRAM_LINE_CUTOUT)\n+      {\n+        System.out.printf(String.format(\"%4d   %,11d     %,7d  \", index, v.duration(), v.count()));\n+        printLine(percentage, v.count(), max, width);\n+      }\n+      index++;\n+    }\n+    System.out.printf(\"\\n\");\n+  }\n+\n+  public void printLines(int width)\n+  {\n+    System.out.printf(String.format(\"summary \\\"free\\\" histogram of durations & count [#%,d]:\\n\",\n+                                    this.duration_count_free_total));\n+    printMap(width, this.duration_count_free, this.duration_count_free_max);\n+\n+    System.out.printf(String.format(\"summary \\\"malloc\\\" histogram of durations & count [#%,d]:\\n\",\n+                                    this.duration_count_malloc_total));\n+    printMap(width, this.duration_count_malloc, this.duration_count_malloc_max);\n+\n+    System.out.printf(String.format(\"summary \\\"realloc\\\" histogram of durations & count [#%,d]:\\n\",\n+                                    this.duration_count_realloc_total));\n+    printMap(width, this.duration_count_realloc, this.duration_count_realloc_max);\n+\n+    System.out.printf(String.format(\"summary \\\"malloc\\\" histogram of sizes & count [#%,d]:\\n\",\n+                                    this.size_count_malloc_total));\n+    printMapCounts(width, this.size_count_malloc, this.size_count_malloc_max);\n+\n+    System.out.printf(String.format(\"summary \\\"realloc\\\" histogram of sizes & count [#%,d]:\\n\",\n+                                    this.size_count_realloc_total));\n+    printMapCounts(width, this.size_count_realloc, this.size_count_realloc_max);\n+\n+    ArrayList<Long> keys = null;\n+\n+    keys = new ArrayList<>(this.size_count_malloc.keySet());\n+    Collections.sort(keys);\n+    for (int i = 0; i < this.durations_count_size_malloc.length; i++)\n+    {\n+      System.out.printf(String.format(\"detail \\\"malloc\\\" histogram of durations & count for size %,d [#%,d]:\\n\",\n+                                      keys.get(i), this.durations_count_size_malloc_total[i]));\n+      printMap(width, this.durations_count_size_malloc[i], this.durations_count_size_malloc_max[i]);\n+    }\n+\n+    keys = new ArrayList<>(this.size_count_realloc.keySet());\n+    Collections.sort(keys);\n+    for (int i = 0; i < this.durations_count_size_realloc.length; i++)\n+    {\n+      System.out.printf(String.format(\"detail \\\"realloc\\\" histogram of durations & count for size %,d [#%,d]:\\n\",\n+                                      keys.get(i), this.durations_count_size_realloc_total[i]));\n+      printMap(width, this.durations_count_size_realloc[i], this.durations_count_size_realloc_max[i]);\n+    }\n+  }\n+\n+  void printKeyValues()\n+  {\n+    printCounters();\n+    ArrayList<Long> sizes = new ArrayList<>(this.size_count_malloc.keySet());\n+    Collections.sort(sizes);\n+    int index = 1;\n+    for (Long s : sizes)\n+    {\n+      System.out.printf(String.format(\"index:%3d key:%,9d value: %12s\\n\",\n+                                      index, s, this.size_count_malloc.get(s)));\n+      index++;\n+    }\n+    System.out.printf(\"\\n\");\n+  }\n+\n+  void printCounters()\n+  {\n+    System.out.printf(String.format(\" max_count:%,d length:%,d total\\n\",\n+                                    this.size_count_malloc_max, this.size_count_malloc.size()));\n+  }\n+\n+  void printMemorySizes()\n+  {\n+    ArrayList<Long> sizes = new ArrayList<>(this.size_count_malloc.keySet());\n+    System.out.printf(String.format(\"----> Malloc allocation sizes [%,d]: \", sizes.size()));\n+    Collections.sort(sizes);\n+    for (Long s : sizes)\n+    {\n+      NMT_Duration v = this.size_count_malloc.get(s);\n+      System.out.printf(String.format(\"%,d \", v.actual()));\n+    }\n+    System.out.printf(\"\\n\\n\");\n+  }\n+\n+  void print(int width)\n+  {\n+    \/\/printKeyValues();\n+    \/\/printMemorySizes();\n+    printLines(width);\n+    System.out.println(\"\");\n+  }\n+}\n","filename":"src\/utils\/nmt\/DurationHistogram.java","additions":328,"deletions":0,"binary":false,"changes":328,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+package nmt;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteOrder;\n+import java.nio.MappedByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.stream.Collectors;\n+\n+public class Execute\n+{\n+  public static class ProcessRunner\n+  {\n+    long pid;\n+    String output;\n+\n+    public ProcessRunner(String args[], Path wdir)\n+    {\n+      try\n+      {\n+        ProcessBuilder pb = new ProcessBuilder(Arrays.asList(args));\n+        pb.directory(wdir.toFile());\n+        Process p = pb.start();\n+        this.pid = p.pid();\n+        BufferedReader out = new BufferedReader(new InputStreamReader(p.getInputStream()));\n+        this.output = out.lines().collect(Collectors.joining(System.lineSeparator()));\n+        p.waitFor();\n+        if (p.exitValue() != 0)\n+        {\n+          \/\/throw new RuntimeException(\"ProcessRunner exited with \"+p.exitValue());\n+          System.err.println(\"ProcessRunner exited with \"+p.exitValue());\n+          \/\/System.exit(1);\n+        }\n+      }\n+      catch (Exception e)\n+      {\n+        e.printStackTrace();\n+      }\n+    }\n+\n+    public String output()\n+    {\n+      return this.output;\n+    }\n+\n+    public long pid()\n+    {\n+      return this.pid;\n+    }\n+  }\n+\n+  public static ProcessRunner execCmd(String cmd[])\n+  {\n+    return execCmd(cmd, Paths.get(\"\").toAbsolutePath().toString());\n+  }\n+  public static ProcessRunner execCmd(String cmd[], String path)\n+  {\n+    final boolean DEBUG = true;\n+    if (DEBUG)\n+    {\n+      System.err.println(\"execCmd\");\n+      for (int c = 0; c < cmd.length; c++)\n+      {\n+        System.err.println(\"  cmd[\"+c+\"]:\"+cmd[c]);\n+      }\n+      System.err.println(\"  path[\"+path+\"]\");\n+    }\n+    ProcessRunner pr = new ProcessRunner(cmd, Path.of(path));\n+    if (DEBUG)\n+    {\n+      System.err.println(\"  result:[\"+pr.output()+\"]\");\n+      System.err.println(\"  pid:[\"+pr.pid()+\"]\");\n+    }\n+    return pr;\n+  }\n+}\n","filename":"src\/utils\/nmt\/Execute.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+package nmt;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteOrder;\n+import java.nio.MappedByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.util.HexFormat;\n+\n+public class LogFile\n+{\n+  static final HexFormat HEX = HexFormat.of();\n+\n+  final String name;\n+  int size = 0;\n+  RandomAccessFile file = null;\n+  MappedByteBuffer out = null;\n+\n+  public LogFile(String name)\n+  {\n+    super();\n+    this.name = name;\n+\n+    try\n+    {\n+      RandomAccessFile f = new RandomAccessFile(this.name, \"r\"); \/\/ check if the file exists\n+      f.close();\n+\n+      this.file = new RandomAccessFile(this.name, \"rw\"); \/\/ open for reading and writing\n+      if (this.file.length() < Integer.MAX_VALUE)\n+      {\n+        this.size = (int)this.file.length();\n+      }\n+      else\n+      {\n+        throw new RuntimeException(\"this.file.length() > Integer.MAX_VALUE [\"+this.file.length()+\"]\");\n+      }\n+      \/\/System.out.println(String.format(\"file: \\\"%s\\\", length: %.2fM\", this.name, (size()\/1024.0\/1024.0)));\n+      this.out = this.file.getChannel().map(FileChannel.MapMode.PRIVATE, 0, this.size);\n+      \/\/System.out.println(String.format(\"direct: %s, order: %s\", this.out.isDirect(), this.out.order()));\n+      \/\/System.out.println(\"\");\n+      this.out.order(ByteOrder.nativeOrder());\n+    }\n+    catch (Exception e)\n+    {\n+      this.file = null;\n+      this.out = null;\n+      System.out.println(e);\n+    }\n+  }\n+\n+  public void close()\n+  {\n+    try\n+    {\n+      this.file.close();\n+      this.file = null;\n+    }\n+    catch (IOException e)\n+    {\n+      System.out.println(e);\n+    }\n+  }\n+\n+  public int size()\n+  {\n+    return this.size;\n+  }\n+\n+  public void print(int i)\n+  {\n+    System.out.print(\"00000000:\");\n+    System.out.print(\" \");\n+    System.out.print(HEX.toHexDigits(this.out.get((i*16)+0)));\n+    System.out.print(HEX.toHexDigits(this.out.get((i*16)+1)));\n+    System.out.print(\" \");\n+    System.out.print(HEX.toHexDigits(this.out.get((i*16)+2)));\n+    System.out.print(HEX.toHexDigits(this.out.get((i*16)+3)));\n+    System.out.print(\" \");\n+    System.out.print(HEX.toHexDigits(this.out.get((i*16)+4)));\n+    System.out.print(HEX.toHexDigits(this.out.get((i*16)+5)));\n+    System.out.print(\" \");\n+    System.out.print(HEX.toHexDigits(this.out.get((i*16)+6)));\n+    System.out.print(HEX.toHexDigits(this.out.get((i*16)+7)));\n+    System.out.print(\" \");\n+    System.out.print(HEX.toHexDigits(this.out.get((i*16)+8)));\n+    System.out.print(HEX.toHexDigits(this.out.get((i*16)+9)));\n+    System.out.print(\" \");\n+    System.out.print(HEX.toHexDigits(this.out.get((i*16)+10)));\n+    System.out.print(HEX.toHexDigits(this.out.get((i*16)+11)));\n+    System.out.print(\" \");\n+    System.out.print(HEX.toHexDigits(this.out.get((i*16)+12)));\n+    System.out.print(HEX.toHexDigits(this.out.get((i*16)+13)));\n+    System.out.print(\" \");\n+    System.out.print(HEX.toHexDigits(this.out.get((i*16)+14)));\n+    System.out.print(HEX.toHexDigits(this.out.get((i*16)+15)));\n+    System.out.print(\" \");\n+    System.out.print(\" \");\n+    for (int j = (i*16); j < ((i*16)+16); j++)\n+    {\n+      if ((this.out.get(j) >= 32) && (this.out.get(j) < 128))\n+      {\n+        System.out.print((char)this.out.get(j));\n+      }\n+      else\n+      {\n+        System.out.print('.');\n+      }\n+    }\n+    System.out.println();\n+  }\n+}\n","filename":"src\/utils\/nmt\/LogFile.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+package nmt;\n+\n+import java.nio.file.Paths;\n+\n+public class Main\n+{\n+  public static void main(String[] args) throws Exception\n+  {\n+    boolean DEBUG = false;\n+    if (DEBUG)\n+    {\n+      System.out.println(\"\\n\\n\\n\");\n+      for (int i = 0; i < args.length; i++)\n+      {\n+        System.out.println(\"args[\"+i+\"]: \\\"\"+args[i]+\"\\\"\");\n+      }\n+      System.out.println(\"\");\n+    }\n+\n+    if (args.length == 3)\n+    {\n+      System.out.println(\"Running as benchmark recorder\");\n+      String mode = args[0];\n+      String wdir_path = Paths.get(args[1]).toAbsolutePath().toString();\n+      System.out.println(\" wdir_path:\"+wdir_path);\n+      String jdk_bin_path = Paths.get(args[2]).toAbsolutePath().toString();\n+      System.out.println(\" jdk_bin_path:\"+jdk_bin_path);\n+      BenchmarkRecorder.record(mode, wdir_path, jdk_bin_path);\n+    }\n+    else if (args.length == 4)\n+    {\n+      System.out.println(\"Running as benchmark analyzer\");\n+      String mode = args[0];\n+      System.out.println(\" mode:\"+mode);\n+      String java_path = Paths.get(args[1]).toAbsolutePath().toString();\n+      System.out.println(\" java_path:\"+java_path);\n+      String path = Paths.get(args[2]).toAbsolutePath().toString();\n+      System.out.println(\" path:\"+path);\n+      long pid = Long.parseLong(args[3]);\n+      System.out.println(\" pid:\"+pid);\n+      Benchmark.examine_recording_with_pid(mode, java_path, pid, path);\n+    }\n+  }\n+}\n","filename":"src\/utils\/nmt\/Main.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+package nmt;\n+\n+public class MemoryStats implements Comparable<MemoryStats>\n+{\n+  long mallocs_count;\n+  long reallocs_count;\n+  long free_count;\n+  long requested_bytes;\n+  long allocated_bytes;\n+  long overheadBytes;\n+  double overheadPercentage;\n+\n+  public void add(MemoryStats stats)\n+  {\n+    this.mallocs_count += stats.mallocs_count;\n+    this.reallocs_count += stats.reallocs_count;\n+    this.free_count += stats.free_count;\n+    this.requested_bytes += stats.requested_bytes;\n+    this.allocated_bytes += stats.allocated_bytes;\n+  }\n+\n+  public void calculateOverheadPercentage(long total)\n+  {\n+    if (total > 0)\n+    {\n+      this.overheadPercentage = (100.0 * ((double)overheadBytes()\/(double)total));\n+    }\n+  }\n+\n+  public boolean process(NMT_Allocation ai)\n+  {\n+    boolean processed = false;\n+    if (ai.is_free())\n+    {\n+      processed = true;\n+      this.free_count++;\n+    }\n+    else if (ai.is_realloc())\n+    {\n+      processed = true;\n+      this.reallocs_count++;\n+      this.requested_bytes += ai.requested;\n+      this.allocated_bytes += ai.actual;\n+    }\n+    else if (ai.is_malloc())\n+    {\n+      processed = true;\n+      this.mallocs_count++;\n+      this.requested_bytes += ai.requested;\n+      this.allocated_bytes += ai.actual;\n+    }\n+    return processed;\n+  }\n+\n+  public long overheadBytes()\n+  {\n+    this.overheadBytes = (this.allocated_bytes-this.requested_bytes);\n+    return this.overheadBytes;\n+  }\n+\n+  public double overheadPercentage()\n+  {\n+    return this.overheadPercentage;\n+  }\n+\n+  public long count()\n+  {\n+    return this.mallocs_count+this.reallocs_count+this.free_count;\n+  }\n+\n+  public void print(String item)\n+  {\n+    System.out.printf(String.format(\"%40s \", item));\n+    System.out.print(String.format(\"%,10d \", this.mallocs_count));\n+    System.out.print(String.format(\"%,10d \", this.reallocs_count));\n+    System.out.print(String.format(\"%,10d \", this.free_count));\n+    System.out.print(String.format(\"%,11d \", this.requested_bytes));\n+    System.out.print(String.format(\"%,12d \", this.allocated_bytes));\n+    System.out.print(String.format(\"%,12d \", overheadBytes()));\n+    System.out.print(String.format(\"%,13.3f  \", overheadPercentage()));\n+    System.out.print(\"\\n\");\n+  }\n+\n+  @Override public int compareTo(MemoryStats s)\n+  {\n+    int comparison = (int)(s.overheadBytes() - overheadBytes());\n+    if (comparison == 0)\n+    {\n+      comparison = (int)(s.allocated_bytes - allocated_bytes);\n+    }\n+    return comparison;\n+  }\n+}\n","filename":"src\/utils\/nmt\/MemoryStats.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,337 @@\n+package nmt;\n+\n+import java.nio.file.Path;\n+\n+public class NMT_Allocation\n+{\n+  \/\/ in bytes for a single allocation data in log file\n+  static int SIZE = 88;\n+\n+  \/\/ how many threads to use while processing the results\n+  static final int THREADS_COUNT = 8;\n+\n+  long time;\n+  long thread;\n+  long ptr_curr;\n+  long ptr_prev;\n+  long stack1;\n+  long stack2;\n+  long stack3;\n+  long stack4;\n+  long requested;\n+  long actual;\n+  long flags;\n+  boolean active;\n+\n+  NMT_Allocation()\n+  {\n+\n+  }\n+\n+  NMT_Allocation(NMT_Allocation copy)\n+  {\n+    this.time = copy.time;\n+    this.thread = copy.thread;\n+    this.ptr_curr = copy.ptr_curr;\n+    this.ptr_prev = copy.ptr_prev;\n+    this.stack1 = copy.stack1;\n+    this.stack2 = copy.stack2;\n+    this.stack3 = copy.stack3;\n+    this.stack4 = copy.stack4;\n+    this.requested = copy.requested;\n+    this.actual = copy.actual;\n+    this.flags = copy.flags;\n+    this.active = copy.active;\n+  }\n+\n+  static int size()\n+  {\n+    return SIZE;\n+  }\n+\n+  static long getMainThreadId(NMT_Allocation[] allocations)\n+  {\n+    return allocations[0].thread; \/\/ assumes that the 1st memory allocation is made from main thread\n+  }\n+\n+  @Override public String toString()\n+  {\n+    String type = \"[???????] \";\n+    if (is_free())\n+    {\n+      type = \"   [free] \";\n+    }\n+    else if (is_malloc())\n+    {\n+      type = \" [malloc] \";\n+    }\n+    else if (is_realloc())\n+    {\n+      type = \"[realloc] \";\n+    }\n+    return new String(type+\"0x\"+Long.toHexString(time)+\", \"+thread+\", 0x\"+Long.toHexString(ptr_curr)+\", 0x\"+Long.toHexString(ptr_prev)+\n+                      \/\/\",\"+Long.toHexString(stack1)+\",\"+Long.toHexString(stack1)+\",\"+Long.toHexString(stack1)+\",\"+Long.toHexString(stack4)+\n+                      \", \"+requested+\", \"+actual+\", \"+NMT_Component.name(flags)+\" [\"+active+\"]\");\n+  }\n+\n+  public void print()\n+  {\n+    System.out.println(\"Allocation:\");\n+    System.out.println(\"      time: 0x\"+Long.toHexString(time));\n+    System.out.println(\" thread id: \"+thread);\n+    System.out.println(\"       ptr: 0x\"+Long.toHexString(ptr_curr));\n+    System.out.println(\"       old: 0x\"+Long.toHexString(ptr_prev));\n+    System.out.println(\"    stack1: 0x\"+Long.toHexString(stack1));\n+    System.out.println(\"    stack2: 0x\"+Long.toHexString(stack2));\n+    System.out.println(\"    stack3: 0x\"+Long.toHexString(stack3));\n+    System.out.println(\"    stack4: 0x\"+Long.toHexString(stack4));\n+    System.out.println(\" requested: \"+requested);\n+    System.out.println(\"    actual: \"+actual);\n+    System.out.println(\"     flags: 0b\"+Long.toBinaryString(flags));\n+    System.out.println(\"    active: \"+active);\n+    System.out.println(\"\");\n+  }\n+  \/*\n+   # xxd -l 88 hs_nmt_pid58895_allocs_record.log\n+   00000000: addd 9e42 cf3a 0000 0329 0000 0000 0000  ...B.:...)......\n+   00000010: 40c2 2d00 0060 0000 0000 0000 0000 0000  @.-..`..........\n+   00000020: feff ffff ffff ffff feff ffff ffff ffff  ................\n+   00000030: feff ffff ffff ffff feff ffff ffff ffff  ................\n+   00000040: 5400 0000 0000 0000 6000 0000 0000 0000  T.......`.......\n+   00000050: 1300 0000 0000 0000                      ........\n+\n+   # xxd -l 88 -ps -c 8 hs_nmt_pid58895_allocs_record.log\n+   addd9e42cf3a0000\n+   0329000000000000\n+   40c22d0000600000\n+   0000000000000000\n+   feffffffffffffff\n+   feffffffffffffff\n+   feffffffffffffff\n+   feffffffffffffff\n+   5400000000000000\n+   6000000000000000\n+   1300000000000000\n+   *\/\n+  static NMT_Allocation get(LogFile log, int i)\n+  {\n+    NMT_Allocation ai = new NMT_Allocation();\n+\n+    int offset = 0;\n+    ai.time = log.out.getLong((i*size())+offset); offset += 8;\n+    ai.thread = log.out.getLong((i*size())+offset); offset += 8;\n+    ai.ptr_curr = log.out.getLong((i*size())+offset); offset += 8;\n+    ai.ptr_prev = log.out.getLong((i*size())+offset); offset += 8;\n+    ai.stack1 = log.out.getLong((i*size())+offset); offset += 8;\n+    ai.stack2 = log.out.getLong((i*size())+offset); offset += 8;\n+    ai.stack3 = log.out.getLong((i*size())+offset); offset += 8;\n+    ai.stack4 = log.out.getLong((i*size())+offset); offset += 8;\n+    ai.requested = log.out.getLong((i*size())+offset); offset += 8;\n+    ai.actual = log.out.getLong((i*size())+offset); offset += 8;\n+    ai.flags = log.out.getLong((i*size())+offset); offset += 8;\n+    ai.active = true;\n+\n+    return ai;\n+  }\n+\n+  public void deactivate()\n+  {\n+    this.active = false;\n+  }\n+\n+  public boolean is_active()\n+  {\n+    return this.active;\n+  }\n+\n+  public boolean is_free()\n+  {\n+    return is_active() && (requested == 0L) && (ptr_prev == 0L);\n+  }\n+\n+  public boolean is_realloc()\n+  {\n+    return is_active() && (requested > 0L) && (ptr_prev != 0L);\n+  }\n+\n+  public boolean is_malloc()\n+  {\n+    return is_active() && (requested > 0L) && (ptr_prev == 0L);\n+  }\n+  \/\/  static bool is_active(Entry* e)   { return (e->active == 1); };\n+  \/\/  static void deactivate(Entry* e)  { e->active = 0; };\n+  \/\/  static bool is_type_nmt(Entry* e) { return (e->flags == MEMFLAGS::mtNMT); };\n+  \/\/  static bool is_free(Entry* e)     { return (e->requested == 0) && (e->old == nullptr); };\n+  \/\/  static bool is_realloc(Entry* e)  { return (e->requested > 0)  && (e->old != nullptr); };\n+  \/\/  static bool is_malloc(Entry* e)   { return (e->requested > 0)  && (e->old == nullptr); };\n+  \/\/  static bool is_alloc(Entry* e)    { return is_malloc(e) || is_realloc(e); };\n+\n+  public static NMT_Allocation[] read_memory_log(long pid, String path)\n+  {\n+    NMT_Allocation[] elements = null;\n+\n+    String name = Path.of(path, \"hs_nmt_pid\"+pid+\"_allocs_record.log\").toString();\n+    LogFile log = new LogFile(name);\n+\n+    int elements_count = log.size() \/ NMT_Allocation.size();\n+    \/\/System.out.printf(String.format(\"number of recorded allocation operations:%,d\\n\", elements_count));\n+\n+    if (elements_count > 0)\n+    {\n+      elements = new NMT_Allocation[elements_count];\n+      for (int i = 0; i < elements_count; i++)\n+      {\n+        elements[i] = NMT_Allocation.get(log, i);\n+        \/\/System.out.println(elements[i]);\n+      }\n+    }\n+\n+    log.close();\n+    log = null;\n+\n+    return elements;\n+  }\n+\n+  \/\/ multithreaded\n+  static void consolidateChunk(NMT_Allocation[] allocations, int offset, int stripe, boolean full)\n+  {\n+    int start = (allocations.length-1) - offset;\n+    long stamp = System.currentTimeMillis();\n+    for (int i = start; i >= 0; i -= stripe)\n+    {\n+      NMT_Allocation a = allocations[i];\n+      \/\/ look for a \"free\" operation, then walk backwards and remove\n+      \/\/ (deactivate) all \"realloc\" and the originating alloc\n+      \/\/ (which could be another \"realloc\" or just \"malloc\") in this chain\n+      if (a.is_free())\n+      {\n+        \/\/System.err.println(\"FREE chain:\");\n+        boolean found = false;\n+        long ptr = a.ptr_curr;\n+        for (int j = (i-1); j >= 0; j--)\n+        {\n+          if (full && (offset == (stripe-1)))\n+          {\n+            long now = System.currentTimeMillis();\n+            if (now-stamp > 1000)\n+            {\n+              double o = allocations.length;\n+              double progress = (100.0 * ((((o-i)*o) + (o-j)) \/ (o*o)));\n+              System.out.printf(String.format(\"%.2f, \", progress));\n+              stamp = now;\n+            }\n+          }\n+          NMT_Allocation b = allocations[j];\n+          if (b.is_active() && b.ptr_curr == ptr)\n+          {\n+            if (b.is_malloc())\n+            {\n+              \/\/System.err.println(\" MALLOC\");\n+              found = true;\n+              b.deactivate();\n+              break;\n+            }\n+            else if (b.is_realloc())\n+            {\n+              \/\/System.err.println(\" REALLOC\");\n+              found = true;\n+              b.deactivate();\n+              ptr = b.ptr_prev; \/\/ realloc --> use previous pointer to go backwards in this chain\n+            }\n+          }\n+        }\n+        if (!found)\n+        {\n+          if (a.ptr_curr != 0)\n+          {\n+            \/\/throw new RuntimeException(\"Untracked FREE? \"+a);\n+            System.err.println(\"Untracked FREE?\\n \"+a);\n+          }\n+        }\n+        a.deactivate();\n+      }\n+    }\n+    if (full && (offset == (stripe-1)))\n+    {\n+      System.out.printf(String.format(\"\\n\"));\n+    }\n+  }\n+\n+  public static void consolidate(NMT_Allocation[] allocations, boolean full)\n+  {\n+    if (full)\n+    {\n+      System.out.println(\"Consolidating memory...\\n\");\n+    }\n+\n+    Thread[] threads = new Thread[THREADS_COUNT];\n+    for (int i = 0; i < THREADS_COUNT; i++)\n+    {\n+      final int offset = i;\n+      Runnable runnable = () ->\n+      {\n+        consolidateChunk(allocations, offset, THREADS_COUNT, full);\n+      };\n+      threads[i] = new Thread(runnable);\n+      threads[i].start();\n+    }\n+    try\n+    {\n+      for (int i = 0; i < THREADS_COUNT; i++)\n+      {\n+        threads[i].join();\n+      }\n+    }\n+    catch (InterruptedException e)\n+    {\n+      System.err.println(e);\n+    }\n+\n+    \/\/ remove all mallocs and reallocs except the very last realloc\n+    \/\/ in the chain\n+    for (int i = (allocations.length-1); i >= 0; i--)\n+    {\n+      NMT_Allocation a = allocations[i];\n+      if (a.is_realloc())\n+      {\n+        long ptr = a.ptr_prev; \/\/ realloc --> use previous pointer to go backwards in this chain\n+        \/\/System.err.println(\"REALLOC chain: \"+a);\n+        for (int j = (i-1); j >= 0; j--)\n+        {\n+          NMT_Allocation b = allocations[j];\n+          if (b.ptr_curr == ptr)\n+          {\n+            if (b.is_malloc())\n+            {\n+              \/\/System.err.println(\" MALLOC\");\n+              b.deactivate();\n+              break;\n+            }\n+            else if (b.is_realloc())\n+            {\n+              \/\/System.err.println(\" REALLOC\");\n+              b.deactivate();\n+              ptr = b.ptr_prev; \/\/ realloc --> use previous pointer to go backwards in this chain\n+            }\n+          }\n+        }\n+      }\n+    }\n+\n+    int count = 0;\n+    for (int i = 0; i < allocations.length; i++)\n+    {\n+      NMT_Allocation a = allocations[i];\n+      if (a.is_active())\n+      {\n+        count++;\n+      }\n+    }\n+\n+    if (full)\n+    {\n+      System.out.printf(String.format(\"After memory consolidation the memory operations count is %,d was %,d - a difference of %,d allocations\\n\\n\",\n+                                      count, allocations.length, (allocations.length-count)));\n+    }\n+  }\n+}\n","filename":"src\/utils\/nmt\/NMT_Allocation.java","additions":337,"deletions":0,"binary":false,"changes":337,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+package nmt;\n+\n+public class NMT_Component implements Statistical, Comparable<NMT_Component>\n+{\n+  static public final int JAVA_HEAP = 0;\n+  static public final int CLASS = JAVA_HEAP+1;\n+  static public final int THREAD = CLASS+1;\n+  static public final int THREAD_STACK = THREAD+1;\n+  static public final int CODE = THREAD_STACK+1;\n+  static public final int GC = CODE+1;\n+  static public final int GC_CARD_SET = GC+1;\n+  static public final int COMPILER = GC_CARD_SET+1;\n+  static public final int JVMCI = COMPILER+1;\n+  static public final int INTERNAL = JVMCI+1;\n+  static public final int OTHER = INTERNAL+1;\n+  static public final int SYMBOL = OTHER+1;\n+  static public final int NATIVE_MEMORY_TRACKING = SYMBOL+1;\n+  static public final int SHARED_CLASS_SPACE = NATIVE_MEMORY_TRACKING+1;\n+  static public final int ARENA_CHUNK = SHARED_CLASS_SPACE+1;\n+  static public final int TEST = ARENA_CHUNK+1;\n+  static public final int TRACING = TEST+1;\n+  static public final int LOGGING = TRACING+1;\n+  static public final int STATISTICS = LOGGING+1;\n+  static public final int ARGUMENTS = STATISTICS+1;\n+  static public final int MODULE = ARGUMENTS+1;\n+  static public final int SAFEPOINT = MODULE+1;\n+  static public final int SYNCHRONIZATION = SAFEPOINT+1;\n+  static public final int SERVICEABILITY = SYNCHRONIZATION+1;\n+  static public final int METASPACE = SERVICEABILITY+1;\n+  static public final int STRING_DEDUPLICATION = METASPACE+1;\n+  static public final int OBJECT_MONITORS = STRING_DEDUPLICATION+1;\n+  static public final int UNKNOWN = OBJECT_MONITORS+1;\n+  static public final int PREINIT = UNKNOWN+1;\n+  static public final int ALL = PREINIT+1;\n+  static private final String names[] = {\"Java Heap\", \"Class\", \"Thread\", \"Thread Stack\", \"Code\",\n+  \"GC\", \"GCCardSet\", \"Compiler\", \"JVMCI\", \"Internal\", \"Other\", \"Symbol\", \"Native Memory Tracking\",\n+  \"Shared class space\", \"Arena Chunk\", \"Test\", \"Tracing\", \"Logging\", \"Statistics\", \"Arguments\",\n+  \"Module\", \"Safepoint\", \"Synchronization\", \"Serviceability\", \"Metaspace\", \"String Deduplication\",\n+  \"Object Monitors\", \"Unknown\", \"Pre Init\", \"All\"};\n+  int flag;\n+  MemoryStats stats;\n+\n+  public NMT_Component(int f)\n+  {\n+    this.flag = f;\n+    this.stats = new MemoryStats();\n+  }\n+\n+  public static NMT_Component[] get()\n+  {\n+    NMT_Component[] components = new NMT_Component[names.length-1];\n+    for (int n = 0; n < names.length-1; n++)\n+    {\n+      components[n] = new NMT_Component(n);\n+    }\n+    return components;\n+  }\n+\n+  public static String name(long f)\n+  {\n+    return name((int)f);\n+  }\n+\n+  public static String name(int f)\n+  {\n+    return names[f];\n+  }\n+\n+  public String toString()\n+  {\n+    return names[this.flag];\n+  }\n+\n+  @Override public MemoryStats getStatistics()\n+  {\n+    return this.stats;\n+  }\n+\n+  @Override public void clearStatistics()\n+  {\n+    this.stats = new MemoryStats();\n+  }\n+\n+  @Override public boolean addStatistics(NMT_Allocation ai)\n+  {\n+    if (this.flag == ai.flags)\n+    {\n+      return this.stats.process(ai);\n+    }\n+    else\n+    {\n+      return false;\n+    }\n+  }\n+\n+  @Override public int compareTo(NMT_Component c)\n+  {\n+    return (int)(this.getStatistics().compareTo(c.getStatistics()));\n+  }\n+}\n","filename":"src\/utils\/nmt\/NMT_Component.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+package nmt;\n+\n+import java.nio.file.Path;\n+\n+public class NMT_Duration\n+{\n+  \/\/ in bytes for a single duration data in log file\n+  static int SIZE = (8+8+8+1);\n+\n+  private long count = 1;\n+\n+  private long duration;\n+  private long requested;\n+  private long actual;\n+  private byte type;\n+\n+  static final public byte MALLOC_TYPE  = 1;\n+  static final public byte REALLOC_TYPE = 2;\n+  static final public byte FREE_TYPE    = 4;\n+\n+  public NMT_Duration(long d, long r, long a, byte t)\n+  {\n+    this.duration = d;\n+    this.requested = r;\n+    this.actual = a;\n+    this.type = t;\n+  }\n+\n+  public void add()\n+  {\n+    this.count++;\n+  }\n+\n+  public long count()\n+  {\n+    return this.count;\n+  }\n+\n+  public long duration()\n+  {\n+    return this.duration;\n+  }\n+\n+  public long actual()\n+  {\n+    return this.actual;\n+  }\n+\n+  public long requested()\n+  {\n+    return this.requested;\n+  }\n+\n+  public byte type()\n+  {\n+    return this.type;\n+  }\n+\n+  public boolean is_type(byte t)\n+  {\n+    return (this.type == t);\n+  }\n+\n+  public boolean is_alloc()\n+  {\n+    return (this.type == MALLOC_TYPE);\n+  }\n+\n+  public boolean is_realloc()\n+  {\n+    return (this.type == REALLOC_TYPE);\n+  }\n+\n+  public boolean is_free()\n+  {\n+    return (this.type == FREE_TYPE);\n+  }\n+\n+  @Override\n+  public String toString()\n+  {\n+    return \"duration:\"+this.duration+\" requested:\"+this.requested+\" actual:\"+this.actual+\" type:\"+this.type;\n+  }\n+\n+  @Override\n+  public NMT_Duration clone()\n+  {\n+    return new NMT_Duration(this.duration, this.requested, this.actual, this.type);\n+  }\n+\n+  static int size()\n+  {\n+    return SIZE;\n+  }\n+\n+  static NMT_Duration get(LogFile log, int i)\n+  {\n+    int offset = 0;\n+    long duration = log.out.getLong((i*size())+offset); offset += 8;\n+    long requested = log.out.getLong((i*size())+offset); offset += 8;\n+    long actual = log.out.getLong((i*size())+offset); offset += 8;\n+    byte type = log.out.get((i*size())+offset); offset += 1;\n+\n+    return new NMT_Duration(duration, requested, actual, type);\n+  }\n+\n+  public static NMT_Duration[] read_benchmark_log(long pid, String path)\n+  {\n+    NMT_Duration[] elements = null;\n+\n+    \/\/ hs_nmt_pid83457_benchmark.log\n+    String name = Path.of(path, \"hs_nmt_pid\"+pid+\"_benchmark.log\").toString();\n+    LogFile log = new LogFile(name);\n+\n+    int elements_count = log.size() \/ NMT_Duration.size();\n+    \/\/System.out.printf(String.format(\"number of recorded allocation operations:%,d\\n\", elements_count));\n+\n+    if (elements_count > 0)\n+    {\n+      elements = new NMT_Duration[elements_count];\n+      for (int i = 0; i < elements_count; i++)\n+      {\n+        elements[i] = NMT_Duration.get(log, i);\n+        \/\/System.out.println(elements[i]);\n+      }\n+    }\n+\n+    log.close();\n+    log = null;\n+\n+    return elements;\n+  }\n+}\n","filename":"src\/utils\/nmt\/NMT_Duration.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+package nmt;\n+\n+import java.nio.file.Path;\n+\n+public class NMT_LogInfo\n+{\n+  static public final int UNKNOWN = 0;\n+  static public final int OFF = UNKNOWN+1;\n+  static public final int SUMMARY = OFF+1;\n+  static public final int DETAIL = SUMMARY+1;\n+  private final String names[] = {\"NMT_unknown\", \"NMT_off\", \"NMT_summary\", \"NMT_detail\"};\n+  private final int level;\n+  private final int overhead;\n+\n+  static public NMT_LogInfo read_status_log(long pid, String path)\n+  {\n+    return new NMT_LogInfo(pid, path);\n+  }\n+\n+  public NMT_LogInfo(long pid, String path)\n+  {\n+    String name = Path.of(path, \"hs_nmt_pid\"+pid+\"_info_record.log\").toString();\n+    LogFile log = new LogFile(name);\n+\n+    \/*\n+     00000000: 0300 0000 0000 0000 1000 0000 0000 0000  ................\n+     *\/\n+    this.level = log.out.getInt(0);\n+    this.overhead = log.out.getInt(8);\n+    \/\/System.err.println(\"this.level:\"+this.level);\n+    \/\/System.err.println(\"this.overhead:\"+this.overhead);\n+\n+    log.close();\n+    log = null;\n+  }\n+\n+  public String levelAsString()\n+  {\n+    return names[level()];\n+  }\n+\n+  public int level()\n+  {\n+    return this.level;\n+  }\n+\n+  public int overhead()\n+  {\n+    return this.overhead;\n+  }\n+\n+  public boolean equals(int l)\n+  {\n+    return (level() == l);\n+  }\n+}\n","filename":"src\/utils\/nmt\/NMT_LogInfo.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,138 @@\n+package nmt;\n+\n+import java.nio.file.Path;\n+\n+public class NMT_Thread implements Statistical, Comparable<NMT_Thread>\n+{\n+  static int SIZE = 40;\n+  static byte[] BYTES = new byte[32];\n+\n+  String name;\n+  long id;\n+  MemoryStats stats;\n+\n+  public NMT_Thread()\n+  {\n+    super();\n+  }\n+  public NMT_Thread(long main)\n+  {\n+    this();\n+    this.name = \"Main\";\n+    this.id = main;\n+  }\n+\n+  static public int size()\n+  {\n+    return SIZE;\n+  }\n+\n+  public String toString()\n+  {\n+    return this.name;\n+  }\n+\n+  public void print()\n+  {\n+    System.out.println(\"NMT_Thread:\");\n+    System.out.println(\" name: \\\"\"+this.name+\"\\\"\");\n+    System.out.println(\"   id: \"+this.id);\n+    System.out.println(\"\");\n+  }\n+  \/*\n+   # xxd -l 40 hs_nmt_pid58895_threads_record.log\n+   00000000: 4743 2054 6872 6561 6423 3000 0000 0000  GC Thread#0.....\n+   00000010: 0000 0000 0000 0000 0000 0000 0000 0000  ................\n+   00000020: 0337 0000 0000 0000                      .7......\n+\n+   # xxd -l 40 -ps -c 8 hs_nmt_pid58895_threads_record.log\n+   4743205468726561\n+   6423300000000000\n+   0000000000000000\n+   0000000000000000\n+   0337000000000000\n+   *\/\n+  public static NMT_Thread get(LogFile log, int i)\n+  {\n+    NMT_Thread ti = new NMT_Thread();\n+\n+    int offset = i*size();\n+    for (int j = 0; j < 32; j++)\n+    {\n+      NMT_Thread.BYTES[j] = log.out.get(offset++);\n+    }\n+    int length = 32;\n+    for (int j = 31; j >= 0; j--)\n+    {\n+      if (NMT_Thread.BYTES[j] != 0)\n+      {\n+        break;\n+      }\n+      else\n+      {\n+        length--;\n+      }\n+    }\n+\n+    ti.name = new String(NMT_Thread.BYTES, 0, length);\n+    ti.id = log.out.getInt(offset);\n+\n+    return ti;\n+  }\n+\n+  @Override public boolean addStatistics(NMT_Allocation ai)\n+  {\n+    if (this.id == ai.thread)\n+    {\n+      return this.stats.process(ai);\n+    }\n+    else\n+    {\n+      return false;\n+    }\n+  }\n+\n+  @Override public MemoryStats getStatistics()\n+  {\n+    return this.stats;\n+  }\n+\n+  @Override public void clearStatistics()\n+  {\n+    this.stats = new MemoryStats();\n+  }\n+\n+  @Override public int compareTo(NMT_Thread t)\n+  {\n+    return (int)(this.getStatistics().compareTo(t.getStatistics()));\n+  }\n+\n+  public static NMT_Thread[] read_thread_log(long pid, String path, long main_thread_id)\n+  {\n+    NMT_Thread[] elements = null;\n+\n+    String name = Path.of(path, \"hs_nmt_pid\"+pid+\"_threads_record.log\").toString();\n+    LogFile log = new LogFile(name);\n+\n+    int elements_count = (log.size() \/ NMT_Thread.size());\n+\n+    if (elements_count > 0)\n+    {\n+      elements = new NMT_Thread[elements_count+1];\n+      elements[0] = new NMT_Thread(main_thread_id);\n+      for (int i = 0; i < elements_count; i++)\n+      {\n+        elements[i+1] = NMT_Thread.get(log, i);\n+        if (i < 3)\n+        {\n+          \/\/elements[i].print();\n+        }\n+      }\n+    }\n+\n+    log.close();\n+    log = null;\n+\n+    return elements;\n+  }\n+}\n","filename":"src\/utils\/nmt\/NMT_Thread.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -0,0 +1,8 @@\n+package nmt;\n+\n+public interface Statistical\n+  {\n+    public boolean addStatistics(NMT_Allocation ai);\n+    public void clearStatistics();\n+    public MemoryStats getStatistics();\n+  }\n","filename":"src\/utils\/nmt\/Statistical.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\n+example:\n+\n+cd \/Volumes\/Work\/bugs\/8317453\n+\n+\n+.\/build\/xcode\/build\/jdk\/bin\/java \\\n+  -XX:+UnlockDiagnosticVMOptions -XX:NativeMemoryTracking=summary \\\n+  -XX:NMTRecordMemoryAllocations=0x7FFFFFFF -cp demos HelloWorld\n+\n+.\/build\/xcode\/build\/jdk\/bin\/java \\\n+  -XX:+UnlockDiagnosticVMOptions -XX:NativeMemoryTracking=summary \\\n+  -XX:NMTRecordMemoryAllocations=0x7FFFFFFF -jar demos\/J2Ddemo.jar\n+\n+.\/build\/xcode\/build\/jdk\/bin\/java \\\n+  -XX:+UnlockDiagnosticVMOptions -XX:NativeMemoryTracking=summary \\\n+  -XX:NMTBenchmarkRecordedDir=. -XX:NMTBenchmarkRecordedPID=68705\n+\n+\n+rm nmt\/*.class ; javac nmt\/Main.java ; java nmt.Main All \/Users\/gerard\/Work\/bugs\/8337217\/johan\/build\/xcode\/build\/jdk\/bin\/java \/Users\/gerard\/Work\/bugs\/8337217\/johan 68705\n+rm nmt\/*.class ; javac nmt\/Main.java ; java nmt.Main MemoryHistograms .\/jdk\/build\/xcode\/build\/jdk\/bin\/java . 83457\n+rm nmt\/*.class ; javac nmt\/Main.java ; java nmt.Main PerformanceHistograms .\/jdk\/build\/xcode\/build\/jdk\/bin\/java . 83457\n+rm nmt\/*.class ; javac nmt\/Main.java ; java nmt.Main MemorySummary .\/jdk\/build\/xcode\/build\/jdk\/bin\/java . 83457\n+\n+\n+\n+\n+\n+\n+\n+\n+the process to create samples:\n+\n+\n+.\/jdk\/build\/xcode\/build\/jdk\/bin\/java -XX:+UnlockDiagnosticVMOptions -XX:NativeMemoryTracking=detail -XX:NMTRecordMemoryAllocations=2147483647 Main\n+\n+creates 3 files:\n+\n+CWD\/hs_nmt_pidPID_info_record.log\n+CWD\/hs_nmt_pidPID_allocs_record.log\n+CWD\/hs_nmt_pidPID_threads_record.log\n+\n+\n+.\/jdk\/build\/xcode\/build\/jdk\/bin\/java -XX:+UnlockDiagnosticVMOptions -XX:NMTBenchmarkRecordedDir=CWD -XX:NMTBenchmarkRecordedPID=PID\n+\n+creates 1 file:\n+\n+CWD\/hs_nmt_pid83457_benchmark.log\n+\n+and shows LOG_FILE_PATH,TOTAL_SAMPLES_DURATION,MAX_SAMPLE_DURATION:\n+\n+CWD\/hs_nmt_pid83457_benchmark.log,1643193,30456\n+\n+\n+to use samples to show memory statistics:\n+\n+rm *.class ; javac nmt.java ; java nmt.Main .\/jdk\/build\/xcode\/build\/jdk\/bin\/java CWD PID\n+\n+\n+\n+\n","filename":"src\/utils\/nmt\/notes.txt","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"}]}