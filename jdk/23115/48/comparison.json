{"files":[{"patch":"@@ -171,2 +171,1 @@\n-  const NativeCallStack& stack)\n-{\n+  const NativeCallStack& stack, void* old_malloc_base) {\n@@ -182,0 +181,2 @@\n+  NMT_MemoryLogRecorder::log_malloc(mem_tag, size, malloc_base, &stack, old_malloc_base);\n+\n@@ -212,0 +213,2 @@\n+  NMT_MemoryLogRecorder::log_free(header);\n+\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -284,1 +284,1 @@\n-    const NativeCallStack& stack);\n+    const NativeCallStack& stack, void* old_base = nullptr);\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,968 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ record pattern of allocations of memory calls:\n+\/\/\n+\/\/ NMTRecordMemoryAllocations=0x7FFFFFFF .\/build\/macosx-aarch64-server-release\/xcode\/build\/jdk\/bin\/java -XX:+UnlockDiagnosticVMOptions -XX:NativeMemoryTracking=summary -jar build\/macosx-aarch64-server-release\/images\/jdk\/demo\/jfc\/J2Ddemo\/J2Ddemo.jar\n+\/\/\n+\/\/ OR record pattern of allocations of virtual memory calls:\n+\/\/\n+\/\/ NMTRecordVirtualMemoryAllocations=0x7FFFFFFF .\/build\/macosx-aarch64-server-release\/xcode\/build\/jdk\/bin\/java -XX:+UnlockDiagnosticVMOptions -XX:NativeMemoryTracking=summary -jar build\/macosx-aarch64-server-release\/images\/jdk\/demo\/jfc\/J2Ddemo\/J2Ddemo.jar\n+\/\/\n+\/\/ this will produce 3 files:\n+\/\/\n+\/\/ #1 hs_nmt_pid22770_allocs_record.log (is the chronological record of the the desired operations)\n+\/\/ OR\n+\/\/ #1 hs_nmt_pid22918_virtual_allocs_record.log (is the chronological record of the desired operations)\n+\/\/ #2 hs_nmt_pid22770_info_record.log (is the record of default NMT memory overhead and the NMT state)\n+\/\/ #3 hs_nmt_pid22770_threads_record.log (is the record of thread names that can be retrieved later when processing)\n+\/\/\n+\/\/ then to actually run the benchmark:\n+\/\/\n+\/\/ NMTBenchmarkRecordedPID=22770 .\/build\/macosx-aarch64-server-release\/xcode\/build\/jdk\/bin\/java -XX:+UnlockDiagnosticVMOptions -XX:NativeMemoryTracking=summary\n+\n+#include \"precompiled.hpp\"\n+#include \"jvm.h\"\n+#include \"nmt\/nmtCommon.hpp\"\n+#include \"nmt\/mallocHeader.hpp\"\n+#include \"nmt\/mallocHeader.inline.hpp\"\n+#include \"nmt\/memLogRecorder.hpp\"\n+#include \"nmt\/memReporter.hpp\"\n+#include \"nmt\/memTracker.hpp\"\n+#include \"nmt\/memTracker.hpp\"\n+#include \"runtime\/arguments.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/thread.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/nativeCallStack.hpp\"\n+#include \"utilities\/permitForbiddenFunctions.hpp\"\n+#include \"utilities\/vmError.hpp\"\n+\n+#include <locale.h>\n+#include <string.h>\n+#include <errno.h>\n+\n+#if defined(LINUX)\n+#include <malloc.h>\n+#elif defined(__APPLE__)\n+#include <malloc\/malloc.h>\n+#endif\n+\n+#if defined(LINUX) || defined(__APPLE__)\n+#include <pthread.h>\n+#include <sys\/mman.h>\n+#include <unistd.h>\n+#endif\n+\n+#if defined(_WIN64)\n+#define LD_FORMAT \"%ld\"\n+#define LD_FORMAT2 \"%10ld\"\n+\/\/ TODO: suppress undefined errors for now\n+#define STDERR_FILENO 2\n+#define STDOUT_FILENO 1\n+#else\n+#define LD_FORMAT \"%'ld\"\n+#define LD_FORMAT2 \"%'10ld\"\n+#endif\n+\n+NMT_MemoryLogRecorder NMT_MemoryLogRecorder::_recorder;\n+NMT_VirtualMemoryLogRecorder NMT_VirtualMemoryLogRecorder::_recorder;\n+\n+void NMT_LogRecorder::initialize() {\n+  char* NMTRecordMemoryAllocations = getenv(\"NMTRecordMemoryAllocations\");\n+  if (NMTRecordMemoryAllocations != nullptr) {\n+    long count = atol(NMTRecordMemoryAllocations);\n+    if (count == 0) {\n+      count = strtol(NMTRecordMemoryAllocations, NULL, 16);\n+    }\n+    NMT_MemoryLogRecorder::initialize(count);\n+  }\n+  char* NMTRecordVirtualMemoryAllocations = getenv(\"NMTRecordVirtualMemoryAllocations\");\n+  if (NMTRecordVirtualMemoryAllocations != nullptr) {\n+    long count = atol(NMTRecordVirtualMemoryAllocations);\n+    if (count == 0) {\n+      count = strtol(NMTRecordVirtualMemoryAllocations, NULL, 16);\n+    }\n+    NMT_VirtualMemoryLogRecorder::initialize(count);\n+  }\n+}\n+\n+void NMT_LogRecorder::finish() {\n+  if (!NMT_MemoryLogRecorder::instance()->done()) {\n+    NMT_MemoryLogRecorder::instance()->finish();\n+  }\n+  if (!NMT_VirtualMemoryLogRecorder::instance()->done()) {\n+    NMT_VirtualMemoryLogRecorder::instance()->finish();\n+  }\n+}\n+\n+void NMT_LogRecorder::replay() {\n+  char* NMTBenchmarkRecordedPID = getenv(\"NMTBenchmarkRecordedPID\");\n+  if (NMTBenchmarkRecordedPID != nullptr) {\n+    int pid = atoi(NMTBenchmarkRecordedPID);\n+    NMT_MemoryLogRecorder::instance()->replay(pid);\n+    NMT_VirtualMemoryLogRecorder::instance()->replay(pid);\n+    os::exit(0);\n+  }\n+}\n+\n+void NMT_LogRecorder::init() {\n+#if defined(LINUX) || defined(__APPLE__)\n+  pthread_mutex_t _mutex;\n+  pthread_mutex_init(&_mutex, NULL);\n+#elif defined(_WIN64)\n+  \/\/ TODO: NMT_LogRecorder::init\n+#endif\n+  _threads_names_counter = 1;\n+  _threads_names = (thread_name_info*)permit_forbidden_function::calloc(_threads_names_counter, sizeof(thread_name_info));\n+  _done = true;\n+  _count = 0;\n+}\n+\n+bool NMT_LogRecorder::lockIfNotDone() {\n+  if (!_done) {\n+    lock();\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+void NMT_LogRecorder::lock() {\n+#if defined(LINUX) || defined(__APPLE__)\n+  pthread_mutex_lock(&_mutex);\n+#elif defined(_WIN64)\n+  \/\/ TODO: NMT_LogRecorder::lock\n+#endif\n+}\n+\n+void NMT_LogRecorder::unlock() {\n+#if defined(LINUX) || defined(__APPLE__)\n+  pthread_mutex_unlock(&_mutex);\n+#elif defined(_WIN64)\n+  \/\/ TODO: NMT_LogRecorder::unlock\n+#endif\n+}\n+\n+intx NMT_LogRecorder::thread_id() {\n+#if defined(LINUX) || defined(__APPLE__)\n+  return (intx)pthread_self();\n+#elif defined(_WIN64)\n+  \/\/ TODO: NMT_LogRecorder::thread_id\n+  return 0;\n+#endif\n+}\n+\n+void NMT_LogRecorder::thread_name(char* buf) {\n+#if defined(__APPLE__)\n+  if (pthread_main_np()) {\n+    strcpy(buf, \"main\");\n+  } else {\n+    pthread_getname_np(pthread_self(), buf, MAXTHREADNAMESIZE);\n+  }\n+#elif defined(LINUX)\n+  pthread_getname_np(pthread_self(), buf, MAXTHREADNAMESIZE);\n+#elif defined(_WIN64)\n+  \/\/ TODO: NMT_LogRecorder::thread_name\n+#endif\n+}\n+\n+void NMT_LogRecorder::logThreadName() {\n+  for (size_t i = 0; i < _threads_names_counter; i++) {\n+    if (_threads_names[i].thread == thread_id()) {\n+      return;\n+    }\n+  }\n+  static char name[MAXTHREADNAMESIZE];\n+  thread_name(name);\n+  if (strlen(name) > 0) {\n+    _threads_names_counter++;\n+    _threads_names = (thread_name_info*)permit_forbidden_function::realloc((void*)_threads_names, (_threads_names_counter+1)*sizeof(thread_name_info));\n+    _threads_names[_threads_names_counter-1].thread = thread_id();\n+    strncpy((char*)_threads_names[_threads_names_counter-1].name, name, MAXTHREADNAMESIZE);\n+  }\n+}\n+\n+size_t NMT_LogRecorder::mallocSize(void* ptr)\n+{\n+#if defined(LINUX)\n+  return permit_forbidden_function::malloc_usable_size(ptr);\n+#elif defined(_WIN64)\n+  return permit_forbidden_function::_msize(ptr);\n+#elif defined(__APPLE__)\n+  return permit_forbidden_function::malloc_size(ptr);\n+#endif\n+}\n+\n+#define IS_FREE(e)           ((e->requested == 0) && (e->old == nullptr))\n+#define IS_REALLOC(e)        ((e->requested  > 0) && (e->old != nullptr))\n+#define IS_MALLOC(e)         ((e->requested  > 0) && (e->old == nullptr))\n+\n+#define ALLOCS_LOG_FILE \"hs_nmt_pid%p_allocs_record.log\"\n+#define THREADS_LOG_FILE \"hs_nmt_pid%p_threads_record.log\"\n+#define INFO_LOG_FILE \"hs_nmt_pid%p_info_record.log\"\n+#define BENCHMARK_LOG_FILE \"hs_nmt_pid%p_benchmark.log\"\n+#define VALLOCS_LOG_FILE \"hs_nmt_pid%p_virtual_allocs_record.log\"\n+\n+static int _prepare_log_file(const char* pattern, const char* default_pattern) {\n+  int fd = -1;\n+  if (ErrorFileToStdout) {\n+    fd = STDOUT_FILENO;\n+  } else if (ErrorFileToStderr) {\n+    fd = STDERR_FILENO;\n+  } else {\n+    static char name_buffer[O_BUFLEN];\n+    fd = VMError::prepare_log_file(pattern, default_pattern, true, name_buffer, sizeof(name_buffer));\n+    if (fd == -1) {\n+      int e = errno;\n+      tty->print(\"Can't open memory [%s]. Error: \", pattern?pattern:\"null\");\n+      tty->print_raw_cr(os::strerror(e));\n+      tty->print_cr(\"NMT memory recorder report will be written to console.\");\n+      \/\/ See notes in VMError::report_and_die about hard coding tty to 1\n+      fd = 1;\n+    }\n+  }\n+  return fd;\n+}\n+\n+#define IS_VALID_FD(fd) (fd > STDERR_FILENO)\n+\n+static void _write_and_check(int fd, const void *buf, size_t count) {\n+  if (!IS_VALID_FD(fd)) {\n+    fprintf(stderr, \"write_and_check(%d) ERROR\\n\", fd);\n+    \/\/assert(false, \"fd: %d\", fd);\n+  }\n+  errno = 0;\n+  ssize_t written = (ssize_t)::write(fd, buf, count);\n+  if ((long)written != (long)count) {\n+    int e = errno;\n+    fprintf(stderr, \"write_and_check(%d) ERROR:[%s]\\n\", fd, os::strerror(e));\n+    \/\/assert((long)written != (long)count, \"written != count [%ld,%ld]\", (long)written, (long)count);\n+  }\n+}\n+\n+static int _close_and_check(int fd) {\n+  if (!IS_VALID_FD(fd)) {\n+    fprintf(stderr, \"close_and_check(%d) ERROR\\n\", fd);\n+    return fd;\n+  }\n+  if (fd > STDERR_FILENO) {\n+    errno = 0;\n+    int status = close(fd);\n+    if (status != 0) {\n+      int e = errno;\n+      fprintf(stderr, \"ERROR:[%s]\\n\", os::strerror(e));\n+      assert(status != 0, \"close(%d) returned %d\", fd, status);\n+      return fd;\n+    } else {\n+      return -1;\n+    }\n+  } else {\n+    return fd;\n+  }\n+}\n+\n+static bool _create_file_path_with_pid(const char *path, const char *file, char* file_path, int pid) {\n+  char *tmp_path = NEW_C_HEAP_ARRAY(char, JVM_MAXPATHLEN, mtNMT);\n+  strcpy(tmp_path, path);\n+  strcat(tmp_path, os::file_separator());\n+  strcat(tmp_path, file);\n+  if (!Arguments::copy_expand_pid(tmp_path, strlen(tmp_path), file_path, JVM_MAXPATHLEN, pid)) {\n+    FREE_C_HEAP_ARRAY(char, tmp_path);\n+    return false;\n+  } else {\n+    FREE_C_HEAP_ARRAY(char, tmp_path);\n+    return true;\n+  }\n+}\n+\n+typedef struct file_info {\n+  void*   ptr;\n+  size_t  size;\n+  int     fd;\n+} file_info;\n+\n+static file_info _open_file_and_read(const char* pattern, const char* path, int pid) {\n+  file_info info = { nullptr, 0, -1 };\n+\n+  char *file_path = NEW_C_HEAP_ARRAY(char, JVM_MAXPATHLEN, mtNMT);\n+  if (!_create_file_path_with_pid(path, pattern, file_path, pid)) {\n+    tty->print(\"Can't construct path [%s:%s:%d].\", pattern, path, pid);\n+    return info;\n+  }\n+\n+  info.fd = os::open(file_path, O_RDONLY, 0);\n+  if (info.fd == -1) {\n+    int e = errno;\n+    tty->print(\"Can't open file [%s].\", file_path);\n+    tty->print_raw_cr(os::strerror(e));\n+    return info;\n+  }\n+\n+  struct stat file_info;\n+  ::fstat(info.fd, &file_info);\n+  info.size = file_info.st_size;\n+  ::lseek(info.fd, 0, SEEK_SET);\n+\n+#if !defined(_WIN64)\n+  info.ptr = ::mmap(NULL, info.size, PROT_READ, MAP_PRIVATE, info.fd, 0);\n+  assert(info.ptr != MAP_FAILED, \"info.ptr != MAP_FAILED\");\n+#endif\n+\n+  FREE_C_HEAP_ARRAY(char, file_path);\n+\n+  return info;\n+}\n+\n+void NMT_MemoryLogRecorder::initialize(intx limit) {\n+  \/\/fprintf(stderr, \"> NMT_MemoryLogRecorder::initialize(%ld, %ld)\\n\", limit, sizeof(Entry));\n+  NMT_MemoryLogRecorder *recorder = NMT_MemoryLogRecorder::instance();\n+  recorder->init();\n+  recorder->lock();\n+  {\n+    recorder->_limit = limit;\n+    if (recorder->_limit > 0) {\n+      recorder->_log_fd = _prepare_log_file(nullptr, ALLOCS_LOG_FILE);\n+      \/\/fprintf(stderr, \">> _memLogRecorder._log_fd:%d\\n\", recorder->_log_fd);\n+      recorder->_done = false;\n+    } else {\n+      recorder->_done = true;\n+    }\n+  }\n+  recorder->unlock();\n+}\n+\n+void NMT_MemoryLogRecorder::finish(void) {\n+  NMT_MemoryLogRecorder *recorder = NMT_MemoryLogRecorder::instance();\n+  \/\/fprintf(stderr, \"NMT_MemoryLogRecorder::finish() %p\\n\", NMT_MemoryLogRecorder::instance());\n+  if (recorder->lockIfNotDone()) {\n+    volatile int log_fd = recorder->_log_fd;\n+    recorder->_log_fd = -1;\n+    \/\/fprintf(stderr, \" log_fd:%d\\n\", log_fd);\n+    log_fd = _close_and_check(log_fd);\n+    \/\/fprintf(stderr, \" log_fd:%d\\n\", log_fd);\n+\n+    int threads_fd = _prepare_log_file(nullptr, THREADS_LOG_FILE);\n+    \/\/fprintf(stderr, \" threads_fd:%d\\n\", threads_fd);\n+    if (threads_fd != -1) {\n+      _write_and_check(threads_fd, recorder->_threads_names, recorder->_threads_names_counter*sizeof(thread_name_info));\n+      threads_fd = _close_and_check(threads_fd);\n+      \/\/fprintf(stderr, \" threads_fd:%d\\n\", threads_fd);\n+    }\n+\n+    int info_fd = _prepare_log_file(nullptr, INFO_LOG_FILE);\n+    \/\/fprintf(stderr, \" info_fd:%d\\n\", info_fd);\n+    if (info_fd != -1) {\n+      size_t level = NMTUtil::parse_tracking_level(NativeMemoryTracking);\n+      _write_and_check(info_fd, &level, sizeof(level));\n+      size_t overhead = MemTracker::overhead_per_malloc();\n+      _write_and_check(info_fd, &overhead, sizeof(overhead));\n+      info_fd = _close_and_check(info_fd);\n+      \/\/fprintf(stderr, \" info_fd:%d\\n\", info_fd);\n+    }\n+\n+    recorder->_done = true;\n+    recorder->unlock();\n+  }\n+}\n+\n+long int histogramLimits[] = {32, 64, 128, 256, 512, 1024, 4096, 8192, 16896};\n+\/\/long int histogramLimits[] = {16, 32, 48, 64, 80, 96, 112, 128, 256, 512, 1024, 4096, 8192, 16896, 65536};\n+const long int histogramLimitsSize = (long int)(sizeof(histogramLimits)\/sizeof(long int));\n+const char *histogramChars[] = {\"▁\", \"▂\", \"▃\", \"▄\", \"▅\", \"▆\", \"▇\", \"█\"};\n+typedef struct HistogramBuckets {\n+  long int buckets[histogramLimitsSize+1];\n+} HistogramBuckets;\n+\n+void NMT_MemoryLogRecorder::replay(const int pid) {\n+  \/\/fprintf(stderr, \"NMT_MemoryLogRecorder::replay(\\\"%s\\\", %d)\\n\", path, pid);\n+  static const char *path = \".\";\n+  setlocale(LC_NUMERIC, \"\");\n+  NMT_MemoryLogRecorder *recorder = NMT_MemoryLogRecorder::instance();\n+  recorder->lock();\n+\n+  \/\/ compare the recorded and current levels of NMT and exit if different\n+  file_info log_fi = _open_file_and_read(INFO_LOG_FILE, path, pid);\n+  if (log_fi.fd == -1) {\n+    return;\n+  }\n+  size_t* status_file_bytes = (size_t*)log_fi.ptr;\n+  NMT_TrackingLevel recorded_nmt_level = (NMT_TrackingLevel)status_file_bytes[0];\n+  bool timeOnly = NMTUtil::parse_tracking_level(NativeMemoryTracking) != recorded_nmt_level;\n+  if (timeOnly) {\n+    tty->print(\"\\n\\nNativeMemoryTracking mismatch [%s != %s].\\n\", NMTUtil::tracking_level_to_string(recorded_nmt_level), NMTUtil::tracking_level_to_string(NMTUtil::parse_tracking_level(NativeMemoryTracking)));\n+    tty->print(\"(Can not be used for memory usage comparison)\\n\");\n+  }\n+\n+  file_info threads_fi = _open_file_and_read(THREADS_LOG_FILE, path, pid);\n+  if (threads_fi.fd == -1) {\n+    return;\n+  }\n+  thread_name_info* thread_entries = (thread_name_info*)threads_fi.ptr;\n+  long int countThreads = (long int)(threads_fi.size \/ sizeof(thread_name_info));\n+  long int* histogramsThreads = nullptr;\n+#if !defined(_WIN64)\n+  long int size_threads = (long int)(countThreads * sizeof(long int));\n+  histogramsThreads = (long int*)::mmap(NULL, size_threads, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0);\n+  assert(histogramsThreads != MAP_FAILED, \"histogramsThreads != MAP_FAILED\");\n+#endif\n+\n+  \/\/ open records file for reading the memory allocations to \"play back\"\n+  file_info records_fi = _open_file_and_read(ALLOCS_LOG_FILE, path, pid);\n+  if (records_fi.fd == -1) {\n+    return;\n+  }\n+  Entry* records_file_entries = (Entry*)records_fi.ptr;\n+  long int count = (long int)(records_fi.size \/ sizeof(Entry));\n+  long int size_pointers = (long int)(count * sizeof(address));\n+  address *pointers = nullptr;\n+#if !defined(_WIN64)\n+  pointers = (address*)::mmap(NULL, size_pointers, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0);\n+  assert(pointers != MAP_FAILED, \"pointers != MAP_FAILED\");\n+#endif\n+\n+  \/\/ open benchmark file for writing the final results\n+  char *benchmark_file_path = NEW_C_HEAP_ARRAY(char, JVM_MAXPATHLEN, mtNMT);\n+  if (!_create_file_path_with_pid(path, BENCHMARK_LOG_FILE, benchmark_file_path, pid)) {\n+    tty->print(\"Can't construct benchmark_file_path [%s].\", benchmark_file_path);\n+    os::exit(-1);\n+  }\n+  int benchmark_fd = _prepare_log_file(benchmark_file_path, nullptr);\n+  if (benchmark_fd == -1) {\n+    tty->print(\"Can't open [%s].\", benchmark_file_path);\n+    os::exit(-1);\n+  }\n+  long int requestedByCategory[mt_number_of_tags] = {0};\n+  long int allocatedByCategory[mt_number_of_tags] = {0};\n+  long int nmtObjectsByCategory[mt_number_of_tags] = {0};\n+  long int timeByCategory[mt_number_of_tags] = {0};\n+  HistogramBuckets histogramByCategory[mt_number_of_tags] = {0};\n+\n+  long int nanoseconds = 0;\n+  long int requestedTotal = 0;\n+  long int actualTotal = 0;\n+  long int headers = 0;\n+  for (off_t i = 0; i < count; i++) {\n+    Entry *e = &records_file_entries[i];\n+    MemTag mem_tag = NMTUtil::index_to_tag((int)e->mem_tag);\n+    int frameCount;\n+    for (frameCount = 0; frameCount < NMT_TrackingStackDepth; frameCount++) {\n+      if (e->stack[frameCount] == 0) {\n+        break;\n+      }\n+    }\n+    NativeCallStack stack = NativeCallStack::empty_stack();\n+    if (frameCount > 0) {\n+      stack = NativeCallStack(e->stack, frameCount);\n+    }\n+    long int requested = 0;\n+    long int actual = 0;\n+    pointers[i] = nullptr;\n+    long int start = 0;\n+    long int end = 0;\n+    {\n+      if (IS_MALLOC(e)) {\n+        address client_ptr = nullptr;\n+        start = os::javaTimeNanos();\n+        {\n+          client_ptr = (address)os::malloc(e->requested, mem_tag, stack);\n+        }\n+        end = os::javaTimeNanos();\n+        requested = (long int)e->requested;\n+        actual = (long int)e->actual;\n+        pointers[i] = client_ptr;\n+        if (mem_tag == mtNone) {\n+          fprintf(stderr, \"MALLOC?\\n\");\n+        }\n+      } else if (IS_REALLOC(e)) {\n+        \/\/ the recorded \"realloc\" was captured in a different process,\n+        \/\/ so find the corresponding \"malloc\" or \"realloc\" in this process\n+        for (off_t j = i-1; j >= 0; j--) {\n+          Entry *p = &records_file_entries[j];\n+          if (e->old == p->ptr) {\n+            address ptr = pointers[j];\n+            requested -= (long int)p->requested;\n+            actual -= (long int)p->actual;\n+            start = os::javaTimeNanos();\n+            {\n+              ptr = (address)os::realloc(ptr, e->requested, mem_tag, stack);\n+            }\n+            end = os::javaTimeNanos();\n+            requested += (long int)e->requested;\n+            actual += (long int)e->actual;\n+            pointers[i] = ptr;\n+            pointers[j] = nullptr;\n+            break;\n+          }\n+          if (mem_tag == mtNone) {\n+            fprintf(stderr, \"REALLOC?\\n\");\n+          }\n+        }\n+      } else if (IS_FREE(e)) {\n+        \/\/ the recorded \"free\" was captured in a different process,\n+        \/\/ so find the corresponding \"malloc\" or \"realloc\" in this process\n+        for (off_t j = i-1; j >= 0; j--) {\n+          Entry *p = &records_file_entries[j];\n+          if ((e->old == p->ptr) || (e->ptr == p->ptr)) {\n+            mem_tag = NMTUtil::index_to_tag((int)p->mem_tag);\n+            void* ptr = pointers[j];\n+            requested -= (long int)p->requested;\n+            actual -= (long int)p->actual;\n+            start = os::javaTimeNanos();\n+            {\n+              os::free(ptr);\n+            }\n+            end = os::javaTimeNanos();\n+            pointers[i] = nullptr;\n+            pointers[j] = nullptr;\n+            break;\n+          }\n+        }\n+        if (mem_tag == mtNone) {\n+          fprintf(stderr, \"FREE?\\n\");\n+        }\n+      } else {\n+        fprintf(stderr, \"HUH?\\n\");\n+        os::exit(-1);\n+      }\n+      requestedTotal += requested;\n+      actualTotal += actual;\n+\n+      requestedByCategory[NMTUtil::tag_to_index(mem_tag)] += requested;\n+      allocatedByCategory[NMTUtil::tag_to_index(mem_tag)] += actual;\n+      if (IS_FREE(e)) {\n+        headers--;\n+        nmtObjectsByCategory[NMTUtil::tag_to_index(mem_tag)]--;\n+      } else if IS_MALLOC(e) {\n+        headers++;\n+        nmtObjectsByCategory[NMTUtil::tag_to_index(mem_tag)]++;\n+      }\n+    }\n+    long int duration = (start > 0) ? (end - start) : 0;\n+    timeByCategory[NMTUtil::tag_to_index(mem_tag)] += duration;\n+    nanoseconds += duration;\n+\n+    _write_and_check(benchmark_fd, &duration, sizeof(duration));\n+    _write_and_check(benchmark_fd, &requested, sizeof(requested));\n+    _write_and_check(benchmark_fd, &actual, sizeof(actual));\n+    char type = (IS_MALLOC(e) * 1) | (IS_REALLOC(e) * 2) | (IS_FREE(e) * 4);\n+    _write_and_check(benchmark_fd, &type, sizeof(type));\n+    \/\/fprintf(stderr, \" %9ld:%9ld:%9ld %d:%d:%d\\n\", requested, actual, duration, IS_MALLOC(e), IS_REALLOC(e), IS_FREE(e));\n+\n+    for (int i = 0; i < countThreads; i++) {\n+      if (e->thread == thread_entries[i].thread) {\n+        histogramsThreads[i]++;\n+        break;\n+      }\n+    }\n+\n+    HistogramBuckets* histogram = &histogramByCategory[NMTUtil::tag_to_index(mem_tag)];\n+    for (int s = histogramLimitsSize; s >= 0; s--) {\n+      if (actual >= histogramLimits[s]) {\n+        histogram->buckets[s]++;\n+        break;\n+      }\n+    }\n+  }\n+\n+  setlocale(LC_ALL, \"\");\n+  long int overhead_NMT = (long int)(headers * MemTracker::overhead_per_malloc());\n+  long int overhead_malloc = actualTotal - requestedTotal - overhead_NMT;\n+  double overheadPercentage_malloc = 100.0 * (double)overhead_malloc \/ (double)requestedTotal;\n+  fprintf(stderr, \"\\n\\n\\nmalloc summary [recorded NMT mode \\\"%s\\\"]:\\n\\n\", NMTUtil::tracking_level_to_string(recorded_nmt_level));\n+  fprintf(stderr, \"time:\" LD_FORMAT \"[ns]\\n\", nanoseconds);\n+  if (!timeOnly) {\n+    double overheadPercentage_NMT = 100.0 * (double)overhead_NMT \/ (double)requestedTotal;\n+    fprintf(stderr, \"[samples:\" LD_FORMAT \"] [NMT headers:\" LD_FORMAT \"]\\n\", count, headers);\n+    fprintf(stderr, \"memory requested:\" LD_FORMAT \" bytes, allocated:\" LD_FORMAT \" bytes\\n\", requestedTotal, actualTotal);\n+    fprintf(stderr, \"malloc overhead=\" LD_FORMAT \" bytes [%2.2f%%], NMT headers overhead=\" LD_FORMAT \" bytes [%2.2f%%]\\n\", overhead_malloc, overheadPercentage_malloc, overhead_NMT, overheadPercentage_NMT);\n+    fprintf(stderr, \"\\n\");\n+    fprintf(stderr, \"%22s: %12s: %12s: %12s: %12s: %12s: %12s: %12s:\\n\", \"NMT type\", \"objects\", \"bytes\", \"time\", \"objects%\", \"bytes%\", \"time%\", \"overhead%\");\n+    fprintf(stderr, \"-------------------------------------------------------------------------------------------------------------------------\\n\");\n+    for (int i = 0; i < mt_number_of_tags; i++) {\n+      double overhead = 0.0;\n+      if (requestedByCategory[i] > 0) {\n+        overhead = 100.0 * ((double)allocatedByCategory[i] - (double)requestedByCategory[i]) \/ (double)requestedByCategory[i];\n+      }\n+      fprintf(stderr, \"%22s: %'12ld  %'12ld   %'12ld\", NMTUtil::tag_to_name(NMTUtil::index_to_tag(i)), nmtObjectsByCategory[i], allocatedByCategory[i], timeByCategory[i]);\n+      double countPercentage = 100.0 * ((double)nmtObjectsByCategory[i] \/ (double)headers);\n+      if (countPercentage > 10.0) {\n+        fprintf(stderr, \"        %.1f%%\", countPercentage);\n+      } else {\n+        fprintf(stderr, \"         %.1f%%\", countPercentage);\n+      }\n+      double bytesPercentage = 100.0 * ((double)allocatedByCategory[i] \/ (double)actualTotal);\n+      if (bytesPercentage > 10.0) {\n+        fprintf(stderr, \"         %.1f%%\", bytesPercentage);\n+      } else {\n+        fprintf(stderr, \"          %.1f%%\", bytesPercentage);\n+      }\n+      double timePercentage = 100.0 * ((double)timeByCategory[i] \/ (double)nanoseconds);\n+      if (timePercentage > 10.0) {\n+        fprintf(stderr, \"         %.1f%%\", timePercentage);\n+      } else {\n+        fprintf(stderr, \"          %.1f%%\", timePercentage);\n+      }\n+      if (overhead > 100.0) {\n+        fprintf(stderr, \"        %.1f%%\", overhead);\n+      } else if (overhead > 10.0) {\n+        fprintf(stderr, \"         %.1f%%\", overhead);\n+      } else {\n+        fprintf(stderr, \"          %.1f%%\", overhead);\n+      }\n+      fprintf(stderr, \"    \");\n+\n+      HistogramBuckets* histogram = &histogramByCategory[i];\n+      long int max = 0;\n+      for (int s = histogramLimitsSize; s >= 0; s--) {\n+        if (histogram->buckets[s] > max) {\n+          max = histogram->buckets[s];\n+        }\n+      }\n+      for (int s = 0; s < histogramLimitsSize; s++) {\n+        int index = (int)(100.0 * ((double)histogram->buckets[s] \/ (double)max)) % 8;\n+        fprintf(stderr, \"%s\", histogramChars[index]);\n+      }\n+      fprintf(stderr, \"\\n\");\n+    }\n+  }\n+\n+  fprintf(stderr, \"\\n\\n\");\n+  fprintf(stderr, \"-------------------------------------------------------------------------------------------------------------------------\\n\");\n+  fprintf(stderr, \"threads info:\\n\\n\");\n+  for (int i = 1; i < countThreads; i++) {\n+    double percentageOps = 100.0 * (double)histogramsThreads[i] \/ (double)count;\n+    if (percentageOps < 10.0) {\n+      fprintf(stderr, \"%32s: \" LD_FORMAT2 \" [ops]     %.2f%%\\n\", thread_entries[i].name, histogramsThreads[i], percentageOps);\n+    } else {\n+      fprintf(stderr, \"%32s: \" LD_FORMAT2 \" [ops]    %.2f%%\\n\", thread_entries[i].name, histogramsThreads[i], percentageOps);\n+    }\n+  }\n+\n+  _close_and_check(log_fi.fd);\n+  _close_and_check(threads_fi.fd);\n+  _close_and_check(records_fi.fd);\n+  _close_and_check(benchmark_fd);\n+  FREE_C_HEAP_ARRAY(char, benchmark_file_path);\n+\n+  for (off_t i = 0; i < count; i++) {\n+    if (pointers[i] != nullptr) {\n+      os::free(pointers[i]);\n+      pointers[i] = nullptr;\n+    }\n+  }\n+#if !defined(_WIN64)\n+  munmap((void*)pointers, size_pointers);\n+  munmap((void*)histogramsThreads, size_threads);\n+#endif\n+\n+  recorder->unlock();\n+\n+  os::exit(0);\n+}\n+\n+void NMT_MemoryLogRecorder::_log(MemTag mem_tag, size_t requested, address ptr, address old, const NativeCallStack *stack){\n+  NMT_MemoryLogRecorder *recorder = NMT_MemoryLogRecorder::instance();\n+  \/\/fprintf(stderr, \"NMT_MemoryLogRecorder::log(%16s, %6ld, %12p, %12p)\\n\", NMTUtil::tag_to_name(mem_tag), requested, ptr, old);\n+  if (recorder->lockIfNotDone()) {\n+    volatile intx count = recorder->_count++;\n+    if (count < recorder->_limit) {\n+      Entry entry;\n+      entry.time = count;\n+      if (MemTracker::is_initialized()) {\n+        entry.time = os::javaTimeNanos();\n+      }\n+      entry.thread = NMT_LogRecorder::thread_id();\n+      entry.ptr = ptr;\n+      entry.old = old;\n+      entry.requested = requested;\n+      if (entry.requested > 0) {\n+        \/\/entry.requested += MemTracker::overhead_per_malloc();\n+      }\n+      entry.actual = 0;\n+      if (entry.requested > 0) {\n+        entry.actual = NMT_LogRecorder::mallocSize(ptr);\n+      }\n+\n+      entry.mem_tag = (jlong)mem_tag;\n+      if ((MemTracker::is_initialized()) && (stack != nullptr)) {\n+        \/\/ recording stack frames will make sure that the hashtables\n+        \/\/ are used, so they get benchmarked\n+        for (int i = 0; i < NMT_TrackingStackDepth; i++) {\n+          entry.stack[i] = stack->get_frame(i);\n+        }\n+      }\n+\n+      if (recorder->_log_fd != -1) {\n+        _write_and_check(recorder->_log_fd, &entry, sizeof(Entry));\n+      }\n+\n+      recorder->logThreadName();\n+    } else {\n+      recorder->finish();\n+    }\n+\n+    recorder->unlock();\n+  }\n+}\n+\n+void NMT_MemoryLogRecorder::log_free(void *ptr) {\n+  \/\/fprintf(stderr, \"NMT_MemoryLogRecorder::log(%16p)\\n\", ptr);\n+  NMT_MemoryLogRecorder::_log(mtNone, 0, (address)ptr, nullptr, nullptr);\n+}\n+\n+void NMT_MemoryLogRecorder::log_malloc(MemTag mem_tag, size_t requested, void* ptr, const NativeCallStack *stack, void* old) {\n+  NMT_MemoryLogRecorder::_log(mem_tag, requested, (address)ptr, (address)old, stack);\n+}\n+\n+\/\/void NMT_MemoryLogRecorder::print(Entry *e) {\n+\/\/  if (e == nullptr) {\n+\/\/    fprintf(stderr, \"nullptr\\n\");\n+\/\/  } else {\n+\/\/    if (IS_FREE(e)) {\n+\/\/      fprintf(stderr, \"           FREE: \");\n+\/\/    } else if (IS_REALLOC(e)) {\n+\/\/      fprintf(stderr, \"        REALLOC: \");\n+\/\/    } else if (IS_MALLOC(e)) {\n+\/\/      fprintf(stderr, \"         MALLOC: \");\n+\/\/    }\n+\/\/    fprintf(stderr, \"time:%15ld, thread:%6ld, ptr:%14p, old:%14p, requested:%8ld, actual:%8ld, mem_tag:%s\\n\", e->time, e->thread, e->ptr, e->old, e->requested, e->actual, NMTUtil::tag_to_name(NMTUtil::index_to_tag((int)e->mem_tag)));\n+\/\/  }\n+\/\/}\n+\n+\/\/static inline const char* type_to_name(NMT_VirtualMemoryLogRecorder::Type type) {\n+\/\/  switch (type) {\n+\/\/    case NMT_VirtualMemoryLogRecorder::Type::RESERVE: return \"RESERVE\"; break;\n+\/\/    case NMT_VirtualMemoryLogRecorder::Type::RELEASE: return \"RELEASE\"; break;\n+\/\/    case NMT_VirtualMemoryLogRecorder::Type::UNCOMMIT: return \"UNCOMMIT\"; break;\n+\/\/    case NMT_VirtualMemoryLogRecorder::Type::RESERVE_AND_COMMIT: return \"RESERVE_AND_COMMIT\"; break;\n+\/\/    case NMT_VirtualMemoryLogRecorder::Type::COMMIT: return \"COMMIT\"; break;\n+\/\/    case NMT_VirtualMemoryLogRecorder::Type::SPLIT_RESERVED: return \"SPLIT_RESERVED\"; break;\n+\/\/    case NMT_VirtualMemoryLogRecorder::Type::TAG: return \"TAG\"; break;\n+\/\/    default: break;\n+\/\/  }\n+\/\/}\n+\n+void NMT_VirtualMemoryLogRecorder::initialize(intx limit) {\n+  \/\/fprintf(stderr, \"> NMT_VirtualMemoryLogRecorder::initialize(%ld, %ld)\\n\", limit, sizeof(Entry));\n+  NMT_VirtualMemoryLogRecorder *recorder = NMT_VirtualMemoryLogRecorder::instance();\n+  recorder->init();\n+  recorder->lock();\n+  {\n+    recorder->_limit = limit;\n+    if (recorder->_limit > 0) {\n+      recorder->_log_fd = _prepare_log_file(nullptr, VALLOCS_LOG_FILE);\n+      recorder->_done = false;\n+    } else {\n+      recorder->_done = true;\n+    }\n+  }\n+  recorder->unlock();\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::finish(void) {\n+  NMT_VirtualMemoryLogRecorder *recorder = NMT_VirtualMemoryLogRecorder::instance();\n+  if (recorder->lockIfNotDone()) {\n+      volatile int log_fd = recorder->_log_fd;\n+    recorder->_log_fd = -1;\n+      \/\/fprintf(stderr, \" log_fd:%d\\n\", log_fd);\n+      log_fd = _close_and_check(log_fd);\n+  }\n+\n+  int info_fd = _prepare_log_file(nullptr, INFO_LOG_FILE);\n+  if (info_fd != -1) {\n+    size_t mode = NMTUtil::parse_tracking_level(NativeMemoryTracking);\n+    _write_and_check(info_fd, &mode, sizeof(mode));\n+    size_t overhead = MemTracker::overhead_per_malloc();\n+    _write_and_check(info_fd, &overhead, sizeof(overhead));\n+    info_fd = _close_and_check(info_fd);\n+  }\n+\n+  recorder->_done = true;\n+  recorder->unlock();\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::replay(const int pid) {\n+  \/\/fprintf(stderr, \"NMT_VirtualMemoryLogRecorder::replay(\\\"%s\\\", %d)\\n\", path, pid);\n+  static const char *path = \".\";\n+\n+  \/\/ open records file for reading the virtual memory allocations to \"play back\"\n+  file_info records_fi = _open_file_and_read(VALLOCS_LOG_FILE, path, pid);\n+  if (records_fi.fd == -1) {\n+    return;\n+  }\n+  Entry* records_file_entries = (Entry*)records_fi.ptr;\n+  long int count = (long int)(records_fi.size \/ sizeof(Entry));\n+\n+  long int total = 0;\n+  \/\/VirtualMemoryTracker::Instance::initialize(NMTUtil::parse_tracking_level(NativeMemoryTracking));\n+  for (off_t i = 0; i < count; i++) {\n+    Entry *e = &records_file_entries[i];\n+\n+    MemTag mem_tag = NMTUtil::index_to_tag((int)e->mem_tag);\n+    int frameCount;\n+    for (frameCount = 0; frameCount < NMT_TrackingStackDepth; frameCount++) {\n+      if (e->stack[frameCount] == 0) {\n+        break;\n+      }\n+    }\n+    NativeCallStack stack = NativeCallStack::empty_stack();\n+    if (frameCount > 0) {\n+      stack = NativeCallStack(e->stack, frameCount);\n+    }\n+\n+    long int start = os::javaTimeNanos();\n+    {\n+      switch (e->type) {\n+        case NMT_VirtualMemoryLogRecorder::Type::RESERVE:\n+          \/\/fprintf(stderr, \"[record_virtual_memory_reserve(%p, %ld, %p, %hhu)\\n\", e->ptr, e->size, &stack, mem_tag);fflush(stderr);\n+          MemTracker::record_virtual_memory_reserve(e->ptr, e->size, stack, mem_tag);\n+          \/\/fprintf(stderr, \"]\\n\");fflush(stderr);\n+          break;\n+        case NMT_VirtualMemoryLogRecorder::Type::RELEASE:\n+          \/\/fprintf(stderr, \"[record_virtual_memory_release(%p, %ld)\\n\", e->ptr, e->size);fflush(stderr);\n+          MemTracker::record_virtual_memory_release(e->ptr, e->size);\n+          \/\/fprintf(stderr, \"]\\n\");fflush(stderr);\n+          break;\n+        case NMT_VirtualMemoryLogRecorder::Type::UNCOMMIT:\n+          \/\/fprintf(stderr, \"<record_virtual_memory_uncommit(%p, %ld)\\n\", e->ptr, e->size);fflush(stderr);\n+          MemTracker::record_virtual_memory_uncommit(e->ptr, e->size);\n+          \/\/fprintf(stderr, \">\\n\");fflush(stderr);\n+          break;\n+        case NMT_VirtualMemoryLogRecorder::Type::RESERVE_AND_COMMIT:\n+          \/\/fprintf(stderr, \"[MemTracker::record_virtual_memory_reserve_and_commit\\n\");\n+          MemTracker::record_virtual_memory_reserve_and_commit(e->ptr, e->size, stack, mem_tag);\n+          \/\/fprintf(stderr, \"]\\n\");fflush(stderr);\n+          break;\n+        case NMT_VirtualMemoryLogRecorder::Type::COMMIT:\n+          \/\/fprintf(stderr, \"[record_virtual_memory_commit(%p, %ld, %p)\\n\", e->ptr, e->size, &stack);fflush(stderr);\n+          MemTracker::record_virtual_memory_commit(e->ptr, e->size, stack);\n+          \/\/fprintf(stderr, \"]\\n\");fflush(stderr);\n+          break;\n+        case NMT_VirtualMemoryLogRecorder::Type::SPLIT_RESERVED:\n+          \/\/fprintf(stderr, \"[MemTracker::record_virtual_memory_split_reserved\\n\");\n+          MemTracker::record_virtual_memory_split_reserved(e->ptr, e->size, e->size_split, mem_tag, NMTUtil::index_to_tag((int)e->mem_tag_split));\n+          \/\/fprintf(stderr, \"]\\n\");fflush(stderr);\n+          break;\n+        case NMT_VirtualMemoryLogRecorder::Type::TAG:\n+          \/\/fprintf(stderr, \"[record_virtual_memory_type(%p, %ld, %p)\\n\", e->ptr, e->size, &stack);fflush(stderr);\n+          MemTracker::record_virtual_memory_tag(e->ptr, mem_tag);\n+          \/\/fprintf(stderr, \"]\\n\");fflush(stderr);\n+          break;\n+        default:\n+          fprintf(stderr, \"HUH?\\n\");\n+          os::exit(-1);\n+          break;\n+      }\n+    }\n+    long int end = os::javaTimeNanos();\n+    long int duration = (start > 0) ? (end - start) : 0;\n+    total += duration;\n+  }\n+  fprintf(stderr, \"\\n\\n\\nVirtualMemoryTracker summary:\\n\\n\\n\");\n+  fprintf(stderr, \"time:\" LD_FORMAT \"[ns] [samples:\" LD_FORMAT \"]\\n\", total, count);\n+\/\/    if (count > 0) {\n+\/\/      nullStream bench_null;\n+\/\/      total = 0;\n+\/\/      for (off_t l = 0; l < 1; l++) {\n+\/\/        long int start = os::javaTimeNanos();\n+\/\/        VirtualMemoryTracker::Instance::print_self(tty);\n+\/\/        long int end = os::javaTimeNanos();\n+\/\/        long int duration = (start > 0) ? (end - start) : 0;\n+\/\/        total += duration;\n+\/\/      }\n+\/\/    }\n+\n+  _close_and_check(records_fi.fd);\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::_log(NMT_VirtualMemoryLogRecorder::Type type, MemTag mem_tag, MemTag mem_tag_split, size_t size, size_t size_split, address ptr, const NativeCallStack *stack) {\n+  \/\/fprintf(stderr, \"NMT_VirtualMemoryLogRecorder::log (%s, %hhu, %hhu, %ld, %ld, %p, %p)\\n\",\n+  \/\/        type_to_name(type), mem_tag, mem_tag_split, size, size_split, ptr, stack);fflush(stderr);\n+  NMT_VirtualMemoryLogRecorder *recorder = NMT_VirtualMemoryLogRecorder::instance();\n+  if (recorder->lockIfNotDone()) {\n+    volatile intx count = recorder->_count++;\n+    if (count < recorder->_limit) {\n+      Entry entry;\n+      entry.type = type;\n+      entry.time = count;\n+      if (MemTracker::is_initialized())\n+      {\n+        entry.time = os::javaTimeNanos();\n+      }\n+      entry.thread = os::current_thread_id();\n+      entry.ptr = ptr;\n+      entry.mem_tag = (jlong)mem_tag;\n+      entry.mem_tag_split = (jlong)mem_tag_split;\n+      entry.size = size;\n+      entry.size_split = size_split;\n+      if ((MemTracker::is_initialized()) && (stack != nullptr)) {\n+        \/\/ the only use of frames is for benchmarking -\n+        \/\/ the NMT code uses a hashtable to store these values,\n+        \/\/ so preserving these will make sure that the hashtables\n+        \/\/ are used when ran with this data\n+        for (int i = 0; i < NMT_TrackingStackDepth; i++) {\n+          entry.stack[i] = stack->get_frame(i);\n+        }\n+      }\n+      \/\/fprintf(stderr, \"recorder->_log_fd: %d\\n\", recorder->_log_fd);\n+      if (recorder->_log_fd != -1) {\n+        _write_and_check(recorder->_log_fd, &entry, sizeof(Entry));\n+      }\n+    } else {\n+      recorder->finish();\n+    }\n+\n+    recorder->unlock();\n+  }\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::log_virtual_memory_reserve(void* addr, size_t size, const NativeCallStack& stack, MemTag mem_tag) {\n+  NMT_VirtualMemoryLogRecorder::_log(Type::RESERVE, mem_tag, mtNone, size, 0, (address)addr, &stack);\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::log_virtual_memory_release(address addr, size_t size) {\n+  NMT_VirtualMemoryLogRecorder::_log(Type::RELEASE, mtNone, mtNone, size, 0, (address)addr, nullptr);\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::log_virtual_memory_uncommit(address addr, size_t size) {\n+  NMT_VirtualMemoryLogRecorder::_log(Type::UNCOMMIT, mtNone, mtNone, size, 0, (address)addr, nullptr);\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::log_virtual_memory_reserve_and_commit(void* addr, size_t size, const NativeCallStack& stack, MemTag mem_tag) {\n+  NMT_VirtualMemoryLogRecorder::_log(Type::RESERVE_AND_COMMIT, mem_tag, mtNone, size, 0, (address)addr, &stack);\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::log_virtual_memory_commit(void* addr, size_t size, const NativeCallStack& stack) {\n+  NMT_VirtualMemoryLogRecorder::_log(Type::COMMIT, mtNone, mtNone, size, 0, (address)addr, &stack);\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::log_virtual_memory_split_reserved(void* addr, size_t size, size_t split, MemTag mem_tag, MemTag split_mem_tag) {\n+  NMT_VirtualMemoryLogRecorder::_log(Type::SPLIT_RESERVED, mem_tag, split_mem_tag, size, split, (address)addr, nullptr);\n+}\n+\n+void NMT_VirtualMemoryLogRecorder::log_virtual_memory_tag(void* addr, MemTag mem_tag) {\n+  NMT_VirtualMemoryLogRecorder::_log(Type::TAG, mem_tag, mtNone, 0, 0, (address)addr, nullptr);\n+}\n","filename":"src\/hotspot\/share\/nmt\/memLogRecorder.cpp","additions":968,"deletions":0,"binary":false,"changes":968,"status":"added"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_NMT_MEMLOGRECORDER_HPP\n+#define SHARE_NMT_MEMLOGRECORDER_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"nmt\/nmtCommon.hpp\"\n+#include \"runtime\/globals.hpp\"\n+\n+#if defined(LINUX) || defined(_WIN64)\n+#define MAXTHREADNAMESIZE 256\n+#endif\n+\n+class NMT_LogRecorder : public StackObj {\n+#if defined(LINUX) || defined(__APPLE__)\n+  pthread_mutex_t _mutex;\n+#elif defined(_WIN64)\n+ \/\/ ???\n+#endif\n+protected:\n+  intx _limit  = 0;\n+  intx _count  = 0;\n+  int _log_fd;\n+  volatile bool _done = true;\n+  volatile size_t _threads_names_counter = 0;\n+  typedef struct thread_name_info {\n+    char name[MAXTHREADNAMESIZE];\n+    intx thread;\n+  } thread_name_info;\n+  thread_name_info *_threads_names = nullptr;\n+\n+public:\n+  static void initialize();\n+  static void finish();\n+  static void replay();\n+  static void logThreadName(const char* name);\n+  static size_t mallocSize(void* ptr);\n+  static intx thread_id();\n+\n+public:\n+  void init();\n+  bool lockIfNotDone();\n+  void lock();\n+  void unlock();\n+  void thread_name(char* buf);\n+  bool done() {\n+    return _done;\n+  }\n+  void logThreadName();\n+};\n+\n+class NMT_MemoryLogRecorder : public NMT_LogRecorder {\n+\n+private:\n+  static NMT_MemoryLogRecorder _recorder;\n+\n+private:\n+    struct Entry {\n+    jlong time;\n+    intx thread;\n+    address ptr;\n+    address old;\n+    address stack[NMT_TrackingStackDepth];\n+    size_t requested;\n+    size_t actual;\n+    jlong mem_tag;\n+  };\n+\n+public:\n+  static NMT_MemoryLogRecorder* instance() {\n+    return &_recorder;\n+  };\n+  static void initialize(intx count);\n+  static bool initialized() {\n+    return false;\n+  }\n+  static void print(Entry *e);\n+  static void finish(void);\n+  static void replay(const int pid);\n+  static void log_free(void *ptr);\n+  static void log_malloc(MemTag mem_tag, size_t requested, void* ptr, const NativeCallStack *stack, void* old = nullptr);\n+  static void printActualSizesFor(const char* list);\n+\n+private:\n+  static void _log(MemTag mem_tag, size_t requested, address ptr, address old, const NativeCallStack *stack);\n+};\n+\n+class NMT_VirtualMemoryLogRecorder : public NMT_LogRecorder {\n+\n+private:\n+  static NMT_VirtualMemoryLogRecorder _recorder;\n+\n+private:\n+  struct Entry {\n+    jlong time;\n+    intx thread;\n+    address ptr;\n+    address stack[NMT_TrackingStackDepth];\n+    jlong mem_tag;\n+    jlong mem_tag_split;\n+    size_t size;\n+    size_t size_split;\n+    int type;\n+  };\n+\n+public:\n+  enum Type {\n+    RESERVE,\n+    RELEASE,\n+    UNCOMMIT,\n+    RESERVE_AND_COMMIT,\n+    COMMIT,\n+    SPLIT_RESERVED,\n+    TAG\n+  };\n+\n+public:\n+  static NMT_VirtualMemoryLogRecorder* instance() {\n+    return &_recorder;\n+  };\n+  static void initialize(intx count);\n+  static void finish(void);\n+  static void replay(const int pid);\n+  static void log_virtual_memory_reserve(void* addr, size_t size, const NativeCallStack& stack, MemTag mem_tag = mtNone);\n+  static void log_virtual_memory_release(address addr, size_t size);\n+  static void log_virtual_memory_uncommit(address addr, size_t size);\n+  static void log_virtual_memory_reserve_and_commit(void* addr, size_t size, const NativeCallStack& stack, MemTag mem_tag = mtNone);\n+  static void log_virtual_memory_commit(void* addr, size_t size, const NativeCallStack& stack);\n+  static void log_virtual_memory_split_reserved(void* addr, size_t size, size_t split, MemTag flag, MemTag mem_tag_split);\n+  static void log_virtual_memory_tag(void* addr, MemTag mem_tag);\n+\n+private:\n+  static void _log(NMT_VirtualMemoryLogRecorder::Type type, MemTag mem_tag, MemTag mem_tag_split, size_t size, size_t size_split, address ptr, const NativeCallStack *stack);\n+};\n+\n+#endif \/\/ SHARE_NMT_MEMLOGRECORDER_HPP\n","filename":"src\/hotspot\/share\/nmt\/memLogRecorder.hpp","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -56,0 +56,2 @@\n+  NMT_LogRecorder::initialize();\n+\n@@ -96,0 +98,2 @@\n+\n+  NMT_LogRecorder::replay();\n","filename":"src\/hotspot\/share\/nmt\/memTracker.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"nmt\/memLogRecorder.hpp\"\n@@ -79,1 +80,1 @@\n-    const NativeCallStack& stack) {\n+    const NativeCallStack& stack, void* old_base = nullptr) {\n@@ -82,1 +83,1 @@\n-      return MallocTracker::record_malloc(mem_base, size, mem_tag, stack);\n+      return MallocTracker::record_malloc(mem_base, size, mem_tag, stack, old_base);\n@@ -129,0 +130,1 @@\n+      NMT_VirtualMemoryLogRecorder::log_virtual_memory_reserve((address)addr, size, stack, mem_tag);\n@@ -137,0 +139,1 @@\n+      NMT_VirtualMemoryLogRecorder::log_virtual_memory_release((address)addr, size);\n@@ -145,0 +148,1 @@\n+      NMT_VirtualMemoryLogRecorder::log_virtual_memory_uncommit((address)addr, size);\n@@ -155,0 +159,1 @@\n+      NMT_VirtualMemoryLogRecorder::log_virtual_memory_reserve_and_commit((address)addr, size, stack, mem_tag);\n@@ -166,0 +171,1 @@\n+      NMT_VirtualMemoryLogRecorder::log_virtual_memory_commit((address)addr, size, stack);\n@@ -214,0 +220,1 @@\n+      NMT_VirtualMemoryLogRecorder::log_virtual_memory_split_reserved((address)addr, size, split, mem_tag, split_tag);\n@@ -223,0 +230,1 @@\n+      NMT_VirtualMemoryLogRecorder::log_virtual_memory_tag((address)addr, mem_tag);\n","filename":"src\/hotspot\/share\/nmt\/memTracker.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3924,1 +3924,1 @@\n-                                char* buf, size_t buflen) {\n+                                char* buf, size_t buflen, int pid) {\n@@ -3940,1 +3940,4 @@\n-        int ret = jio_snprintf(b, buf_sz, \"%d\", os::current_process_id());\n+        if (pid == 0) {\n+          pid = os::current_process_id();\n+        }\n+        int ret = jio_snprintf(b, buf_sz, \"%d\", pid);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -510,1 +510,1 @@\n-  static bool copy_expand_pid(const char* src, size_t srclen, char* buf, size_t buflen);\n+  static bool copy_expand_pid(const char* src, size_t srclen, char* buf, size_t buflen, int pid = 0);\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -740,1 +740,1 @@\n-    void* const new_inner_ptr = MemTracker::record_malloc(new_outer_ptr, size, mem_tag, stack);\n+    void* const new_inner_ptr = MemTracker::record_malloc(new_outer_ptr, size, mem_tag, stack, memblock);\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"nmt\/memLogRecorder.hpp\"\n@@ -564,0 +565,1 @@\n+  NMT_LogRecorder::finish();\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,6 @@\n+#if defined(LINUX)\n+#include <malloc.h>\n+#elif defined(__APPLE__)\n+#include <malloc\/malloc.h>\n+#endif\n+\n@@ -70,0 +76,8 @@\n+#if defined(LINUX)\n+inline size_t malloc_usable_size(void *ptr) { return ::malloc_usable_size(ptr); }\n+#elif defined(_WIN64)\n+inline size_t _msize(void *memblock) { return ::_msize(memblock); }\n+#elif defined(__APPLE__)\n+inline size_t malloc_size(const void *ptr) { return ::malloc_size(ptr); }\n+#endif\n+\n","filename":"src\/hotspot\/share\/utilities\/permitForbiddenFunctions.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1804,0 +1804,2 @@\n+  NMT_LogRecorder::finish();\n+\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}