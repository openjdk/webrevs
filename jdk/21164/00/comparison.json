{"files":[{"patch":"@@ -3096,0 +3096,53 @@\n+\n+void C2_MacroAssembler::round_double_mode_v(VectorRegister dst, BasicType dst_bt, uint vector_length,\n+                                            VectorRegister src, int round_mode,\n+                                            VectorRegister tmp1, VectorRegister tmp2) {\n+\n+  assert_different_registers(dst, src);\n+  assert_different_registers(tmp1, tmp2);\n+  vsetvli_helper(dst_bt, vector_length);\n+\n+  \/\/ The vector implementation is similar to the scalar version,\n+  \/\/ check C2_MacroAssembler::round_double_mode for more details\n+  \/\/ Set rounding mode for conversions\n+  \/\/ Here we use similar modes to double->long and long->double conversions\n+  \/\/ Different mode for long->double conversion matter only if long value was not representable as double,\n+  \/\/ we got long value as a result of double->long conversion so, it is definitely representable\n+  switch (round_mode) {\n+    case RoundDoubleModeNode::rmode_ceil:\n+      csrwi(CSR_FRM, C2_MacroAssembler::rup);\n+      break;\n+    case RoundDoubleModeNode::rmode_floor:\n+      csrwi(CSR_FRM, C2_MacroAssembler::rdn);\n+      break;\n+    case RoundDoubleModeNode::rmode_rint:\n+      csrwi(CSR_FRM, C2_MacroAssembler::rne);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+\n+  \/\/ Conversion from double to long\n+  vfcvt_x_f_v(dst, src);\n+\n+  \/\/ Generate constant (100...0000)\n+  addi(t0, zr, 1);\n+  slli(t0, t0, 63);\n+  vmv_v_x(tmp1, t0);\n+\n+  \/\/ Prepare converted long\n+  \/\/ as a result when conversion overflow we got:\n+  \/\/ 011...1111 or 100...0000\n+  \/\/ Convert it to: 100...0000\n+  vadd_vi(tmp2, dst, 1);\n+  vand_vi(tmp2, tmp2, -2);\n+  vmsne_vv(v0, tmp1, tmp2);\n+\n+  \/\/ Conversion from long to double\n+  vfcvt_f_x_v(dst, dst, Assembler::v0_t);\n+  \/\/ Add sign of input value to result for +\/- 0 cases\n+  vfsgnj_vv(dst, dst, src, Assembler::v0_t);\n+\n+  \/\/ If got conversion overflow return src\n+  vmerge_vvm(dst, src, dst);\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":53,"deletions":0,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -280,0 +280,4 @@\n+  void round_double_mode_v(VectorRegister dst, BasicType dst_bt, uint vector_length,\n+                           VectorRegister src, int round_mode,\n+                           VectorRegister tmp1, VectorRegister tmp2);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1926,0 +1926,1 @@\n+    case Op_RoundDoubleModeV:\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4746,0 +4746,17 @@\n+\/\/ ------------------------------ RoundDouble ----------------------------------\n+\n+instruct vroundD(vReg dst, vReg src, immI rmode, vRegMask_V0 v0, vReg tmp1, vReg tmp2) %{\n+  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n+  match(Set dst (RoundDoubleModeV src rmode));\n+  ins_cost(VEC_COST);\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2, TEMP v0);\n+  format %{ \"vroundD $dst, $src, $rmode\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ round_double_mode_v(as_VectorRegister($dst$$reg), bt, Matcher::vector_length(this),\n+                           as_VectorRegister($src$$reg), $rmode$$constant,\n+                           as_VectorRegister($tmp1$$reg), as_VectorRegister($tmp2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"}]}