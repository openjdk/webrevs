{"files":[{"patch":"@@ -29,1 +29,0 @@\n-import java.util.concurrent.ThreadPoolExecutor;\n@@ -111,5 +110,4 @@\n-            return switch (Scheduler.instance()) {\n-                case ForkJoinPool pool -> pool.getParallelism();\n-                case ThreadPoolExecutor pool -> pool.getMaximumPoolSize();\n-                default -> -1;\n-            };\n+            if (Scheduler.instance() instanceof ForkJoinPool pool) {\n+                return pool.getParallelism();\n+            }\n+            throw new InternalError();  \/\/ should not get here\n@@ -120,7 +118,5 @@\n-            switch (Scheduler.instance()) {\n-                case ForkJoinPool pool -> {\n-                    pool.setParallelism(size);\n-                    if (pool.getPoolSize() < size) {\n-                        \/\/ FJ worker thread creation is on-demand\n-                        Thread.startVirtualThread(() -> { });\n-                    }\n+            if (Scheduler.instance() instanceof ForkJoinPool pool) {\n+                pool.setParallelism(size);\n+                if (pool.getPoolSize() < size) {\n+                    \/\/ FJ worker thread creation is on-demand\n+                    Thread.startVirtualThread(() -> { });\n@@ -128,2 +124,2 @@\n-                case ThreadPoolExecutor pool -> pool.setMaximumPoolSize(size);\n-                default -> throw new UnsupportedOperationException();\n+\n+                return;\n@@ -131,0 +127,1 @@\n+            throw new UnsupportedOperationException();  \/\/ should not get here\n@@ -135,5 +132,4 @@\n-            return switch (Scheduler.instance()) {\n-                case ForkJoinPool pool -> pool.getPoolSize();\n-                case ThreadPoolExecutor pool -> pool.getPoolSize();\n-                default -> -1;\n-            };\n+            if (Scheduler.instance() instanceof ForkJoinPool pool) {\n+                return pool.getPoolSize();\n+            }\n+            return -1;  \/\/ should not get here\n@@ -144,5 +140,4 @@\n-            return switch (Scheduler.instance()) {\n-                case ForkJoinPool pool -> pool.getActiveThreadCount();\n-                case ThreadPoolExecutor pool -> pool.getActiveCount();\n-                default -> -1;\n-            };\n+            if (Scheduler.instance() instanceof ForkJoinPool pool) {\n+                return pool.getActiveThreadCount();\n+            }\n+            return -1;  \/\/ should not get here\n@@ -153,5 +148,4 @@\n-            return switch (Scheduler.instance()) {\n-                case ForkJoinPool pool -> pool.getQueuedTaskCount() + pool.getQueuedSubmissionCount();\n-                case ThreadPoolExecutor pool -> pool.getQueue().size();\n-                default -> -1L;\n-            };\n+            if (Scheduler.instance() instanceof ForkJoinPool pool) {\n+                return pool.getQueuedTaskCount() + pool.getQueuedSubmissionCount();\n+            }\n+            return -1L;  \/\/ should not get here\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/internal\/VirtualThreadSchedulerImpls.java","additions":24,"deletions":30,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run junit\/othervm --enable-native-access=ALL-UNNAMED VirtualThreadSchedulerMXBeanTest\n+ * @run junit\/othervm VirtualThreadSchedulerMXBeanTest\n@@ -35,1 +35,0 @@\n-import java.util.concurrent.CountDownLatch;\n@@ -37,0 +36,1 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n@@ -38,0 +38,1 @@\n+import java.util.stream.IntStream;\n@@ -42,1 +43,0 @@\n-import jdk.test.lib.thread.VThreadPinner;\n@@ -47,0 +47,1 @@\n+import static org.junit.jupiter.api.Assumptions.*;\n@@ -65,1 +66,1 @@\n-     * Test parallelism.\n+     * Test default parallelism.\n@@ -69,6 +70,40 @@\n-    void testParallelism(VirtualThreadSchedulerMXBean bean) {\n-        int parallelism = bean.getParallelism();\n-        assertTrue(parallelism > 0);\n-        bean.setParallelism(parallelism + 1);\n-        try {\n-            assertEquals(parallelism + 1, bean.getParallelism());\n+    void testDefaultParallelism(VirtualThreadSchedulerMXBean bean) {\n+        assertEquals(Runtime.getRuntime().availableProcessors(), bean.getParallelism());\n+    }\n+\n+    \/**\n+     * Test increasing parallelism.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"managedBeans\")\n+    void testIncreaseParallelism(VirtualThreadSchedulerMXBean bean) throws Exception {\n+        assumeFalse(Thread.currentThread().isVirtual(), \"Main thread is a virtual thread\");\n+\n+        final int parallelism = bean.getParallelism();\n+        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n+            var done = new AtomicBoolean();\n+            Runnable busyTask = () -> {\n+                while (!done.get()) {\n+                    Thread.onSpinWait();\n+                }\n+            };\n+\n+            try {\n+                \/\/ saturate\n+                IntStream.range(0, parallelism).forEach(_ -> executor.submit(busyTask));\n+                awaitPoolSizeGte(bean, parallelism);\n+                awaitMountedVirtualThreadCountGte(bean, parallelism);\n+\n+                \/\/ increase parallelism\n+                for (int k = 1; k <= 4; k++) {\n+                    int newParallelism = parallelism + k;\n+                    bean.setParallelism(newParallelism);\n+                    executor.submit(busyTask);\n+\n+                    \/\/ pool size and mounted virtual thread should increase\n+                    awaitPoolSizeGte(bean, newParallelism);\n+                    awaitMountedVirtualThreadCountGte(bean, newParallelism);\n+                }\n+            } finally {\n+                done.set(true);\n+            }\n@@ -76,2 +111,56 @@\n-            \/\/ restore\n-            bean.setParallelism(parallelism);\n+            bean.setParallelism(parallelism);   \/\/ restore\n+        }\n+    }\n+\n+    \/**\n+     * Test reducing parallelism.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"managedBeans\")\n+    void testReduceParallelism(VirtualThreadSchedulerMXBean bean) throws Exception {\n+        assumeFalse(Thread.currentThread().isVirtual(), \"Main thread is a virtual thread\");\n+\n+        final int parallelism = bean.getParallelism();\n+        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n+            var done = new AtomicBoolean();\n+            var sleep = new AtomicBoolean();\n+\n+            \/\/ spin when !sleep\n+            Runnable busyTask = () -> {\n+                while (!done.get()) {\n+                    if (sleep.get()) {\n+                        try {\n+                            Thread.sleep(10);\n+                        } catch (InterruptedException e) { }\n+                    } else {\n+                        Thread.onSpinWait();\n+                    }\n+                }\n+            };\n+\n+            try {\n+                \/\/ increase parallelism + saturate\n+                int newParallelism = parallelism + 4;\n+                bean.setParallelism(newParallelism);\n+                IntStream.range(0, newParallelism).forEach(_ -> executor.submit(busyTask));\n+                awaitMountedVirtualThreadCountGte(bean, newParallelism);\n+\n+                \/\/ reduce parallelism and workload\n+                newParallelism = Math.clamp(parallelism \/ 2, 1, parallelism);\n+                bean.setParallelism(newParallelism);\n+                sleep.set(true);\n+                \/\/ mounted virtual thread count should reduce\n+                awaitMountedVirtualThreadCountLte(bean, newParallelism);\n+\n+                \/\/ increase workload, the mounted virtual thread count should not increase\n+                sleep.set(false);\n+                for (int i = 0; i < 5; i++) {\n+                    Thread.sleep(100);\n+                    assertTrue(bean.getMountedVirtualThreadCount() <= newParallelism);\n+                }\n+\n+            } finally {\n+                done.set(true);\n+            }\n+        } finally {\n+            bean.setParallelism(parallelism);  \/\/ restore\n@@ -87,1 +176,1 @@\n-        \/\/ run test in virtual thread\n+        assertTrue(bean.getPoolSize() >= 0);\n@@ -89,1 +178,2 @@\n-            assertTrue(bean.getPoolSize() > 0);\n+            assertTrue(Thread.currentThread().isVirtual());\n+            assertTrue(bean.getPoolSize() >= 1);\n@@ -99,1 +189,1 @@\n-        \/\/ run test in virtual thread\n+        assertTrue(bean.getMountedVirtualThreadCount() >= 0);\n@@ -101,1 +191,2 @@\n-            assertTrue(bean.getMountedVirtualThreadCount() > 0);\n+            assertTrue(Thread.currentThread().isVirtual());\n+            assertTrue(bean.getMountedVirtualThreadCount() >= 1);\n@@ -111,9 +202,1 @@\n-        \/\/ skip if virtual thread\n-        if (Thread.currentThread().isVirtual()) {\n-            return;\n-        }\n-        int parallelism = bean.getParallelism();\n-        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n-            var ready = new CountDownLatch(parallelism);\n-            var done = new CountDownLatch(1);\n-            try {\n+        assumeFalse(Thread.currentThread().isVirtual(), \"Main thread is a virtual thread\");\n@@ -121,9 +204,5 @@\n-                \/\/ start virtual threads to pin all carriers\n-                for (int i = 0; i < parallelism; i++) {\n-                    executor.submit(() -> {\n-                        VThreadPinner.runPinned(() -> {\n-                            ready.countDown();\n-                            done.await();\n-                        });\n-                        return null;\n-                    });\n+        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n+            var done = new AtomicBoolean();\n+            Runnable busyTask = () -> {\n+                while (!done.get()) {\n+                    Thread.onSpinWait();\n@@ -131,1 +210,1 @@\n-                ready.await();\n+            };\n@@ -133,1 +212,7 @@\n-                \/\/ start 5 virtual threads, their tasks will be queued to exeucte\n+            try {\n+                \/\/ saturate\n+                int parallelism = bean.getParallelism();\n+                IntStream.range(0, parallelism).forEach(_ -> executor.submit(busyTask));\n+                awaitMountedVirtualThreadCountGte(bean, parallelism);\n+\n+                \/\/ start 5 virtual threads, their tasks will be queued to execute\n@@ -135,1 +220,1 @@\n-                    Thread.startVirtualThread(() -> { });\n+                    executor.submit(() -> { });\n@@ -138,1 +223,0 @@\n-\n@@ -140,1 +224,1 @@\n-                done.countDown();\n+                done.set(true);\n@@ -144,0 +228,32 @@\n+\n+    \/**\n+     * Waits for pool size >= target to be true.\n+     *\/\n+    void awaitPoolSizeGte(VirtualThreadSchedulerMXBean bean, int target) throws InterruptedException {\n+        System.err.format(\"await pool size >= %d ...%n\", target);\n+        while (bean.getPoolSize() < target) {\n+            Thread.sleep(10);\n+        }\n+    }\n+\n+    \/**\n+     * Waits for the mounted virtual thread count >= target to be true.\n+     *\/\n+    void awaitMountedVirtualThreadCountGte(VirtualThreadSchedulerMXBean bean,\n+                                           int target) throws InterruptedException {\n+        System.err.format(\"await mounted virtual thread count >= %d ...%n\", target);\n+        while (bean.getMountedVirtualThreadCount() < target) {\n+            Thread.sleep(10);\n+        }\n+    }\n+\n+    \/**\n+     * Waits for the mounted virtual thread count <= target to be true.\n+     *\/\n+    void awaitMountedVirtualThreadCountLte(VirtualThreadSchedulerMXBean bean,\n+                                           int target) throws InterruptedException {\n+        System.err.format(\"await mounted virtual thread count <= %d ...%n\", target);\n+        while (bean.getMountedVirtualThreadCount() > target) {\n+            Thread.sleep(10);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/management\/VirtualThreadSchedulerMXBean\/VirtualThreadSchedulerMXBeanTest.java","additions":155,"deletions":39,"binary":false,"changes":194,"status":"modified"}]}