{"files":[{"patch":"@@ -257,0 +257,40 @@\n+    public static final String SADD_VB = VECTOR_PREFIX + \"SADD_VB\" + POSTFIX;\n+    static {\n+        vectorNode(SADD_VB, \"SaturatingAddV\", TYPE_BYTE);\n+    }\n+\n+    public static final String SADD_VS = VECTOR_PREFIX + \"SADD_VS\" + POSTFIX;\n+    static {\n+        vectorNode(SADD_VS, \"SaturatingAddV\", TYPE_SHORT);\n+    }\n+\n+    public static final String SADD_VI = VECTOR_PREFIX + \"SADD_VI\" + POSTFIX;\n+    static {\n+        vectorNode(SADD_VI, \"SaturatingAddV\", TYPE_INT);\n+    }\n+\n+    public static final String SADD_VL = VECTOR_PREFIX + \"SADD_VL\" + POSTFIX;\n+    static {\n+        vectorNode(SADD_VL, \"SaturatingAddV\", TYPE_LONG);\n+    }\n+\n+    public static final String SSUB_VB = VECTOR_PREFIX + \"SSUB_VB\" + POSTFIX;\n+    static {\n+        vectorNode(SSUB_VB, \"SaturatingSubV\", TYPE_BYTE);\n+    }\n+\n+    public static final String SSUB_VS = VECTOR_PREFIX + \"SSUB_VS\" + POSTFIX;\n+    static {\n+        vectorNode(SSUB_VS, \"SaturatingSubV\", TYPE_SHORT);\n+    }\n+\n+    public static final String SSUB_VI = VECTOR_PREFIX + \"SSUB_VI\" + POSTFIX;\n+    static {\n+        vectorNode(SSUB_VI, \"SaturatingSubV\", TYPE_INT);\n+    }\n+\n+    public static final String SSUB_VL = VECTOR_PREFIX + \"SSUB_VL\" + POSTFIX;\n+    static {\n+        vectorNode(SSUB_VL, \"SaturatingSubV\", TYPE_LONG);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -0,0 +1,474 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @bug 8342677\n+* @summary Add IR validation tests for newly added saturated vector add \/ sub operations\n+* @modules jdk.incubator.vector\n+* @library \/test\/lib \/\n+* @run driver compiler.vectorapi.VectorSaturatedOperationsTest\n+*\/\n+\n+package compiler.vectorapi;\n+\n+import jdk.incubator.vector.*;\n+import compiler.lib.ir_framework.*;\n+import java.util.stream.IntStream;\n+\n+public class VectorSaturatedOperationsTest {\n+    private static final int COUNT = 2048;\n+    private static final VectorSpecies<Long> lspec    = LongVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Integer> ispec = IntVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Short> sspec   = ShortVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Byte> bspec    = ByteVector.SPECIES_PREFERRED;\n+\n+    private long[]  long_in1;\n+    private int[]   int_in1;\n+    private short[] short_in1;\n+    private byte[]  byte_in1;\n+\n+    private long[]  long_in2;\n+    private int[]   int_in2;\n+    private short[] short_in2;\n+    private byte[]  byte_in2;\n+\n+    private long[]  long_out;\n+    private int[]   int_out;\n+    private short[] short_out;\n+    private byte[]  byte_out;\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.setDefaultWarmup(5000)\n+                     .addFlags(\"--add-modules=jdk.incubator.vector\")\n+                     .start();\n+    }\n+\n+    public VectorSaturatedOperationsTest() {\n+        byte_in1  = new byte[COUNT];\n+        short_in1 = new short[COUNT];\n+        int_in1   = new int[COUNT];\n+        long_in1  = new long[COUNT];\n+\n+        byte_in2  = new byte[COUNT];\n+        short_in2 = new short[COUNT];\n+        int_in2   = new int[COUNT];\n+        long_in2  = new long[COUNT];\n+        IntStream.range(0, COUNT).forEach(\n+            i -> {\n+                if ((i & 1) == 0) {\n+                    long_in1[i] = Long.MAX_VALUE;\n+                    long_in2[i] = i;\n+                    int_in1[i]  = Integer.MAX_VALUE;\n+                    int_in2[i]  = i;\n+                    short_in1[i] = Short.MAX_VALUE;\n+                    short_in2[i] = (short)i;\n+                    byte_in1[i]  = Byte.MAX_VALUE;\n+                    byte_in2[i]  = (byte)i;\n+                } else {\n+                    long_in1[i] = Long.MIN_VALUE;\n+                    long_in2[i] = -i;\n+                    int_in1[i]  = Integer.MIN_VALUE;\n+                    int_in2[i]  = -i;\n+                    short_in1[i] = Short.MIN_VALUE;\n+                    short_in2[i] = (short)-i;\n+                    byte_in1[i]  = Byte.MIN_VALUE;\n+                    byte_in2[i]  = (byte)-i;\n+                }\n+            }\n+        );\n+        long_out  = new long[COUNT];\n+        int_out   = new int[COUNT];\n+        short_out = new short[COUNT];\n+        byte_out  = new byte[COUNT];\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SADD_VB, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void sadd_byte() {\n+        for (int i = 0; i < COUNT; i += bspec.length()) {\n+            ByteVector.fromArray(bspec, byte_in1, i)\n+                     .lanewise(VectorOperators.SADD,\n+                               ByteVector.fromArray(bspec, byte_in2, i))\n+                     .intoArray(byte_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"sadd_byte\")\n+    public void sadd_byte_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            byte actual = byte_out[i];\n+            byte expected = VectorMath.addSaturating(byte_in1[i], byte_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SADD_VS, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void sadd_short() {\n+        for (int i = 0; i < COUNT; i += sspec.length()) {\n+            ShortVector.fromArray(sspec, short_in1, i)\n+                     .lanewise(VectorOperators.SADD,\n+                               ShortVector.fromArray(sspec, short_in2, i))\n+                     .intoArray(short_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"sadd_short\")\n+    public void sadd_short_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            short actual = short_out[i];\n+            short expected = VectorMath.addSaturating(short_in1[i], short_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SADD_VI, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void sadd_int() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector.fromArray(ispec, int_in1, i)\n+                     .lanewise(VectorOperators.SADD,\n+                               IntVector.fromArray(ispec, int_in2, i))\n+                     .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"sadd_int\")\n+    public void sadd_int_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.addSaturating(int_in1[i], int_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SADD_VL, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void sadd_long() {\n+        for (int i = 0; i < COUNT; i += lspec.length()) {\n+            LongVector.fromArray(lspec, long_in1, i)\n+                     .lanewise(VectorOperators.SADD,\n+                               LongVector.fromArray(lspec, long_in2, i))\n+                     .intoArray(long_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"sadd_long\")\n+    public void sadd_long_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            long actual = long_out[i];\n+            long expected = VectorMath.addSaturating(long_in1[i], long_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SADD_VB, \" >0 \" , \"unsigned_vector_node\", \" >0 \"}, phase = {CompilePhase.BEFORE_MATCHING}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void suadd_byte() {\n+        for (int i = 0; i < COUNT; i += bspec.length()) {\n+            ByteVector.fromArray(bspec, byte_in1, i)\n+                     .lanewise(VectorOperators.SUADD,\n+                               ByteVector.fromArray(bspec, byte_in2, i))\n+                     .intoArray(byte_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"suadd_byte\")\n+    public void suadd_byte_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            byte actual = byte_out[i];\n+            byte expected = VectorMath.addSaturatingUnsigned(byte_in1[i], byte_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SADD_VS, \" >0 \", \"unsigned_vector_node\", \" >0 \"}, phase = {CompilePhase.BEFORE_MATCHING}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void suadd_short() {\n+        for (int i = 0; i < COUNT; i += sspec.length()) {\n+            ShortVector.fromArray(sspec, short_in1, i)\n+                     .lanewise(VectorOperators.SUADD,\n+                               ShortVector.fromArray(sspec, short_in2, i))\n+                     .intoArray(short_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"suadd_short\")\n+    public void suadd_short_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            short actual = short_out[i];\n+            short expected = VectorMath.addSaturatingUnsigned(short_in1[i], short_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SADD_VI, \" >0 \", \"unsigned_vector_node\", \" >0 \"}, phase = {CompilePhase.BEFORE_MATCHING}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void suadd_int() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector.fromArray(ispec, int_in1, i)\n+                     .lanewise(VectorOperators.SUADD,\n+                               IntVector.fromArray(ispec, int_in2, i))\n+                     .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"suadd_int\")\n+    public void suadd_int_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.addSaturatingUnsigned(int_in1[i], int_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SADD_VL, \" >0 \", \"unsigned_vector_node\", \" >0 \"}, phase = {CompilePhase.BEFORE_MATCHING}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void suadd_long() {\n+        for (int i = 0; i < COUNT; i += lspec.length()) {\n+            LongVector.fromArray(lspec, long_in1, i)\n+                     .lanewise(VectorOperators.SUADD,\n+                               LongVector.fromArray(lspec, long_in2, i))\n+                     .intoArray(long_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"suadd_long\")\n+    public void suadd_long_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            long actual = long_out[i];\n+            long expected = VectorMath.addSaturatingUnsigned(long_in1[i], long_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SSUB_VB, \" >0 \"}, phase = {CompilePhase.BEFORE_MATCHING}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void ssub_byte() {\n+        for (int i = 0; i < COUNT; i += bspec.length()) {\n+            ByteVector.fromArray(bspec, byte_in1, i)\n+                     .lanewise(VectorOperators.SSUB,\n+                               ByteVector.fromArray(bspec, byte_in2, i))\n+                     .intoArray(byte_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"ssub_byte\")\n+    public void ssub_byte_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            byte actual = byte_out[i];\n+            byte expected = VectorMath.subSaturating(byte_in1[i], byte_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SSUB_VS, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void ssub_short() {\n+        for (int i = 0; i < COUNT; i += sspec.length()) {\n+            ShortVector.fromArray(sspec, short_in1, i)\n+                     .lanewise(VectorOperators.SSUB,\n+                               ShortVector.fromArray(sspec, short_in2, i))\n+                     .intoArray(short_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"ssub_short\")\n+    public void ssub_short_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            short actual = short_out[i];\n+            short expected = VectorMath.subSaturating(short_in1[i], short_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SSUB_VI, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void ssub_int() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector.fromArray(ispec, int_in1, i)\n+                     .lanewise(VectorOperators.SSUB,\n+                               IntVector.fromArray(ispec, int_in2, i))\n+                     .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"ssub_int\")\n+    public void ssub_int_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.subSaturating(int_in1[i], int_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SSUB_VL, \" >0 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void ssub_long() {\n+        for (int i = 0; i < COUNT; i += lspec.length()) {\n+            LongVector.fromArray(lspec, long_in1, i)\n+                     .lanewise(VectorOperators.SSUB,\n+                               LongVector.fromArray(lspec, long_in2, i))\n+                     .intoArray(long_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"ssub_long\")\n+    public void ssub_long_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            long actual = long_out[i];\n+            long expected = VectorMath.subSaturating(long_in1[i], long_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SSUB_VB, \" >0 \" , \"unsigned_vector_node\", \" >0 \"}, phase = {CompilePhase.BEFORE_MATCHING}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void susub_byte() {\n+        for (int i = 0; i < COUNT; i += bspec.length()) {\n+            ByteVector.fromArray(bspec, byte_in1, i)\n+                     .lanewise(VectorOperators.SUSUB,\n+                               ByteVector.fromArray(bspec, byte_in2, i))\n+                     .intoArray(byte_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"susub_byte\")\n+    public void susub_byte_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            byte actual = byte_out[i];\n+            byte expected = VectorMath.subSaturatingUnsigned(byte_in1[i], byte_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SSUB_VS, \" >0 \", \"unsigned_vector_node\", \" >0 \"}, phase = {CompilePhase.BEFORE_MATCHING}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void susub_short() {\n+        for (int i = 0; i < COUNT; i += sspec.length()) {\n+            ShortVector.fromArray(sspec, short_in1, i)\n+                     .lanewise(VectorOperators.SUSUB,\n+                               ShortVector.fromArray(sspec, short_in2, i))\n+                     .intoArray(short_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"susub_short\")\n+    public void susub_short_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            short actual = short_out[i];\n+            short expected = VectorMath.subSaturatingUnsigned(short_in1[i], short_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SSUB_VI, \" >0 \", \"unsigned_vector_node\", \" >0 \"}, phase = {CompilePhase.BEFORE_MATCHING}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void susub_int() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector.fromArray(ispec, int_in1, i)\n+                     .lanewise(VectorOperators.SUSUB,\n+                               IntVector.fromArray(ispec, int_in2, i))\n+                     .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"susub_int\")\n+    public void susub_int_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.subSaturatingUnsigned(int_in1[i], int_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SSUB_VL, \" >0 \", \"unsigned_vector_node\", \" >0 \"}, phase = {CompilePhase.BEFORE_MATCHING}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void susub_long() {\n+        for (int i = 0; i < COUNT; i += lspec.length()) {\n+            LongVector.fromArray(lspec, long_in1, i)\n+                     .lanewise(VectorOperators.SUSUB,\n+                               LongVector.fromArray(lspec, long_in2, i))\n+                     .intoArray(long_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"susub_long\")\n+    public void susub_long_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            long actual = long_out[i];\n+            long expected = VectorMath.subSaturatingUnsigned(long_in1[i], long_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorSaturatedOperationsTest.java","additions":474,"deletions":0,"binary":false,"changes":474,"status":"added"}]}