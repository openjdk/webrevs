{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,3 +30,0 @@\n-#include \"memory\/arena.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"metaprogramming\/enableIf.hpp\"\n@@ -34,1 +31,0 @@\n-#include \"runtime\/os.hpp\"\n@@ -70,1 +66,0 @@\n-\n@@ -72,0 +67,2 @@\n+class Arena;\n+class ResourceArea;\n@@ -87,1 +84,1 @@\n-  IntrusiveRBNode() : _parent(0), _left(nullptr), _right(nullptr) DEBUG_ONLY(COMMA _visited(false)) {}\n+  IntrusiveRBNode();\n@@ -102,2 +99,2 @@\n-  bool is_black() const { return (_parent & 0x1) != 0; }\n-  bool is_red() const { return (_parent & 0x1) == 0; }\n+  bool is_black() const;\n+  bool is_red() const;\n@@ -105,2 +102,2 @@\n-  void set_black() { _parent |= 0x1; }\n-  void set_red() { _parent &= ~0x1; }\n+  void set_black();\n+  void set_red();\n@@ -108,2 +105,2 @@\n-  IntrusiveRBNode* parent() const { return (IntrusiveRBNode*)(_parent & ~0x1); }\n-  void set_parent(IntrusiveRBNode* new_parent) { _parent = (_parent & 0x1) | (uintptr_t)new_parent; }\n+  IntrusiveRBNode* parent() const;\n+  void set_parent(IntrusiveRBNode* new_parent);\n@@ -111,3 +108,1 @@\n-  bool is_right_child() const {\n-    return parent() != nullptr && parent()->_right == this;\n-  }\n+  bool is_right_child() const;\n@@ -115,3 +110,1 @@\n-  bool is_left_child() const {\n-    return parent() != nullptr && parent()->_left == this;\n-  }\n+  bool is_left_child() const;\n@@ -148,1 +141,1 @@\n-  const K& key() const { return _key; }\n+  const K& key() const;\n@@ -150,3 +143,3 @@\n-  V& val() { return _value; }\n-  const V& val() const { return _value; }\n-  void set_val(const V& v) { _value = v; }\n+  V& val();\n+  const V& val() const;\n+  void set_val(const V& v);\n@@ -154,3 +147,3 @@\n-  RBNode() {}\n-  RBNode(const K& key) : IntrusiveRBNode(), _key(key) {}\n-  RBNode(const K& key, const V& val) : IntrusiveRBNode(), _key(key), _value(val) {}\n+  RBNode();\n+  RBNode(const K& key);\n+  RBNode(const K& key, const V& val);\n@@ -158,4 +151,4 @@\n-  const RBNode<K, V>* prev() const { return (RBNode<K, V>*)IntrusiveRBNode::prev(); }\n-  const RBNode<K, V>* next() const { return (RBNode<K, V>*)IntrusiveRBNode::next(); }\n-  RBNode<K, V>* prev() { return (RBNode<K, V>*)IntrusiveRBNode::prev(); }\n-  RBNode<K, V>* next() { return (RBNode<K, V>*)IntrusiveRBNode::next(); }\n+  const RBNode<K, V>* prev() const;\n+  const RBNode<K, V>* next() const;\n+  RBNode<K, V>* prev();\n+  RBNode<K, V>* next();\n@@ -182,5 +175,3 @@\n-    Cursor() : _insert_location(nullptr), _parent(nullptr) {}\n-    Cursor(NodeType** insert_location, NodeType* parent)\n-        : _insert_location(insert_location), _parent(parent) {}\n-    Cursor(NodeType* const* insert_location, NodeType* parent)\n-        : _insert_location((NodeType**)insert_location), _parent(parent) {}\n+    Cursor();\n+    Cursor(NodeType** insert_location, NodeType* parent);\n+    Cursor(NodeType* const* insert_location, NodeType* parent);\n@@ -189,4 +180,4 @@\n-    bool valid() const { return _insert_location != nullptr; }\n-    bool found() const { return *_insert_location != nullptr; }\n-    NodeType* node() { return _insert_location == nullptr ? nullptr : *_insert_location; }\n-    NodeType* node() const { return _insert_location == nullptr ? nullptr : *_insert_location; }\n+    bool valid() const;\n+    bool found() const;\n+    NodeType* node();\n+    NodeType* node() const;\n@@ -218,21 +209,5 @@\n-  RBTreeOrdering cmp(const K& a, const NodeType* b) const {\n-    if constexpr (HasNodeComparator) {\n-      return COMPARATOR::cmp(a, b);\n-    } else if constexpr (HasKeyComparator) {\n-      return COMPARATOR::cmp(a, b->key());\n-    }\n-  }\n-\n-  bool less_than(const NodeType* a, const NodeType* b) const {\n-    if constexpr (HasNodeVerifier) {\n-      return COMPARATOR::less_than(a, b);\n-    } else {\n-      return true;\n-    }\n-  }\n-\n-  void assert_key_leq(K a, K b) const {\n-    if constexpr (HasKeyComparator) { \/\/ Cannot assert if no key comparator exist.\n-      assert(COMPARATOR::cmp(a, b) != RBTreeOrdering::GT, \"key a must be less or equal to key b\");\n-    }\n-  }\n+  RBTreeOrdering cmp(const K& a, const NodeType* b) const;\n+\n+  bool less_than(const NodeType* a, const NodeType* b) const;\n+\n+  void assert_key_leq(K a, K b) const;\n@@ -241,3 +216,1 @@\n-  static inline bool is_black(const IntrusiveRBNode* node) {\n-    return node == nullptr || node->is_black();\n-  }\n+  static inline bool is_black(const IntrusiveRBNode* node);\n@@ -245,3 +218,1 @@\n-  static inline bool is_red(const IntrusiveRBNode* node) {\n-    return node != nullptr && node->is_red();\n-  }\n+  static inline bool is_red(const IntrusiveRBNode* node);\n@@ -257,3 +228,1 @@\n-    bool operator()(const NodeType* n) const {\n-      return true;\n-    }\n+    bool operator()(const NodeType* n) const;\n@@ -266,3 +235,1 @@\n-    void operator()(outputStream* st, const NodeType* n, int depth) const {\n-      n->print_on(st, depth);\n-    }\n+    void operator()(outputStream* st, const NodeType* n, int depth) const;\n@@ -277,4 +244,1 @@\n-  AbstractRBTree() : _num_nodes(0), _root(nullptr) DEBUG_ONLY(COMMA _expected_visited(false)) {\n-    static_assert(std::is_trivially_destructible<K>::value, \"key type must be trivially destructable\");\n-    static_assert(HasKeyComparator || HasNodeComparator, \"comparator must be of correct type\");\n-  }\n+  AbstractRBTree();\n@@ -282,1 +246,1 @@\n-  size_t size() const { return _num_nodes; }\n+  size_t size() const;\n@@ -317,9 +281,2 @@\n-  NodeType* find_node(const K& key, const NodeType* hint_node = nullptr) const {\n-    Cursor node_cursor = cursor(key, hint_node);\n-    return node_cursor.node();\n-  }\n-\n-  NodeType* find_node(const K& key, const NodeType* hint_node = nullptr) {\n-    Cursor node_cursor = cursor(key, hint_node);\n-    return node_cursor.node();\n-  }\n+  NodeType* find_node(const K& key, const NodeType* hint_node = nullptr);\n+  NodeType* find_node(const K& key, const NodeType* hint_node = nullptr) const;\n@@ -328,4 +285,1 @@\n-  void insert(const K& key, NodeType* node, const NodeType* hint_node = nullptr) {\n-    Cursor node_cursor = cursor(key, hint_node);\n-    insert_at_cursor(node, node_cursor);\n-  }\n+  void insert(const K& key, NodeType* node, const NodeType* hint_node = nullptr);\n@@ -333,4 +287,2 @@\n-  void remove(NodeType* node) {\n-    Cursor node_cursor = cursor(node);\n-    remove_at_cursor(node_cursor);\n-  }\n+  \/\/ Removes the given node from the tree.\n+  void remove(NodeType* node);\n@@ -340,9 +292,2 @@\n-  NodeType* closest_leq(const K& key) const {\n-    Cursor node_cursor = cursor(key);\n-    return node_cursor.found() ? node_cursor.node() : prev(node_cursor).node();\n-  }\n-\n-  NodeType* closest_leq(const K& key) {\n-    Cursor node_cursor = cursor(key);\n-    return node_cursor.found() ? node_cursor.node() : prev(node_cursor).node();\n-  }\n+  NodeType* closest_leq(const K& key);\n+  NodeType* closest_leq(const K& key) const;\n@@ -352,9 +297,2 @@\n-  NodeType* closest_gt(const K& key) const {\n-    Cursor node_cursor = cursor(key);\n-    return next(node_cursor).node();\n-  }\n-\n-  NodeType* closest_gt(const K& key) {\n-    Cursor node_cursor = cursor(key);\n-    return next(node_cursor).node();\n-  }\n+  NodeType* closest_gt(const K& key);\n+  NodeType* closest_gt(const K& key) const;\n@@ -364,9 +302,2 @@\n-  NodeType* closest_ge(const K& key) const {\n-    Cursor node_cursor = cursor(key);\n-    return node_cursor.found() ? node_cursor.node() : next(node_cursor).node();\n-  }\n-\n-  NodeType* closest_ge(const K& key) {\n-    Cursor node_cursor = cursor(key);\n-    return node_cursor.found() ? node_cursor.node() : next(node_cursor).node();\n-  }\n+  NodeType* closest_ge(const K& key);\n+  NodeType* closest_ge(const K& key) const;\n@@ -376,8 +307,2 @@\n-  const NodeType* leftmost() const {\n-    IntrusiveRBNode* n = _root, *n2 = nullptr;\n-    while (n != nullptr) {\n-      n2 = n;\n-      n = n->_left;\n-    }\n-    return (NodeType*)n2;\n-  }\n+  NodeType* leftmost();\n+  const NodeType* leftmost() const;\n@@ -387,11 +312,2 @@\n-  const NodeType* rightmost() const {\n-    IntrusiveRBNode* n = _root, *n2 = nullptr;\n-    while (n != nullptr) {\n-      n2 = n;\n-      n = n->_right;\n-    }\n-    return (NodeType*)n2;\n-  }\n-\n-  NodeType* leftmost()  { return const_cast<NodeType*>(static_cast<const TreeType*>(this)->leftmost()); }\n-  NodeType* rightmost() { return const_cast<NodeType*>(static_cast<const TreeType*>(this)->rightmost()); }\n+  NodeType* rightmost();\n+  const NodeType* rightmost() const;\n@@ -409,5 +325,1 @@\n-  Range find_enclosing_range(K key) const {\n-    NodeType* start = closest_leq(key);\n-    NodeType* end = closest_gt(key);\n-    return Range(start, end);\n-  }\n+  Range find_enclosing_range(K key) const;\n@@ -423,1 +335,0 @@\n-\n@@ -439,9 +350,1 @@\n-  void verify_self(const USER_VERIFIER& extra_verifier = USER_VERIFIER()) const {\n-    if constexpr (HasNodeVerifier) {\n-      verify_self([](const NodeType* a, const NodeType* b){ return COMPARATOR::less_than(a, b);}, extra_verifier);\n-    } else if constexpr (HasKeyComparator) {\n-      verify_self([](const NodeType* a, const NodeType* b){ return COMPARATOR::cmp(a->key(), b->key()) == RBTreeOrdering::LT; }, extra_verifier);\n-    } else {\n-      verify_self([](const NodeType*, const NodeType*){ return true;}, extra_verifier);\n-    }\n-  }\n+  void verify_self(const USER_VERIFIER& extra_verifier = USER_VERIFIER()) const;\n@@ -465,1 +368,2 @@\n-  RBTree(AllocArgs... alloc_args) : BaseType(), _allocator(alloc_args...) {}\n+  RBTree(AllocArgs... alloc_args);\n+  ~RBTree();\n@@ -467,1 +371,0 @@\n-  ~RBTree() { remove_all(); }\n@@ -478,26 +381,6 @@\n-  void replace_at_cursor(RBNode<K, V>* new_node, const Cursor& node_cursor) {\n-    RBNode<K, V>* old_node = node_cursor.node();\n-    BaseType::replace_at_cursor(new_node, node_cursor);\n-    free_node(old_node);\n-  }\n-\n-  RBNode<K, V>* allocate_node(const K& key) {\n-    void* node_place = _allocator.allocate(sizeof(RBNode<K, V>));\n-    if (node_place == nullptr) {\n-      return nullptr;\n-    }\n-    return new (node_place) RBNode<K, V>(key);\n-  }\n-\n-  RBNode<K, V>* allocate_node(const K& key, const V& val) {\n-    void* node_place = _allocator.allocate(sizeof(RBNode<K, V>));\n-    if (node_place == nullptr) {\n-      return nullptr;\n-    }\n-    return new (node_place) RBNode<K, V>(key, val);\n-  }\n-\n-  void free_node(RBNode<K, V>* node) {\n-    node->_value.~V();\n-    _allocator.free(node);\n-  }\n+  void replace_at_cursor(RBNode<K, V>* new_node, const Cursor& node_cursor);\n+\n+  RBNode<K, V>* allocate_node(const K& key);\n+  RBNode<K, V>* allocate_node(const K& key, const V& val);\n+\n+  void free_node(RBNode<K, V>* node);\n@@ -508,15 +391,1 @@\n-  bool upsert(const K& key, const V& val, const RBNode<K, V>* hint_node = nullptr) {\n-    Cursor node_cursor = cursor(key, hint_node);\n-    RBNode<K, V>* node = node_cursor.node();\n-    if (node != nullptr) {\n-      node->set_val(val);\n-      return true;\n-    }\n-\n-    node = allocate_node(key, val);\n-    if (node == nullptr) {\n-      return false;\n-    }\n-    insert_at_cursor(node, node_cursor);\n-    return true;\n-  }\n+  bool upsert(const K& key, const V& val, const RBNode<K, V>* hint_node = nullptr);\n@@ -525,15 +394,4 @@\n-  V* find(const K& key) {\n-    Cursor node_cursor = cursor(key);\n-    return node_cursor.found() ? &node_cursor.node()->_value : nullptr;\n-  }\n-\n-  V* find(const K& key) const {\n-    const Cursor node_cursor = cursor(key);\n-    return node_cursor.found() ? &node_cursor.node()->_value : nullptr;\n-  }\n-\n-  void remove(RBNode<K, V>* node) {\n-    Cursor node_cursor = cursor(node);\n-    remove_at_cursor(node_cursor);\n-    free_node(node);\n-  }\n+  V* find(const K& key);\n+  V* find(const K& key) const;\n+\n+  void remove(RBNode<K, V>* node);\n@@ -543,10 +401,1 @@\n-  bool remove(const K& key) {\n-    Cursor node_cursor = cursor(key);\n-    if (!node_cursor.found()) {\n-      return false;\n-    }\n-    RBNode<K, V>* node = node_cursor.node();\n-    remove_at_cursor(node_cursor);\n-    free_node((RBNode<K, V>*)node);\n-    return true;\n-  }\n+  bool remove(const K& key);\n@@ -555,15 +404,1 @@\n-  void remove_all() {\n-    IntrusiveRBNode* to_delete[64];\n-    int stack_idx = 0;\n-    to_delete[stack_idx++] = BaseType::_root;\n-\n-    while (stack_idx > 0) {\n-      IntrusiveRBNode* head = to_delete[--stack_idx];\n-      if (head == nullptr) continue;\n-      to_delete[stack_idx++] = head->_left;\n-      to_delete[stack_idx++] = head->_right;\n-      free_node((RBNode<K, V>*)head);\n-    }\n-    BaseType::_num_nodes = 0;\n-    BaseType::_root = nullptr;\n-  }\n+  void remove_all();\n@@ -575,10 +410,2 @@\n-  void* allocate(size_t sz) {\n-    void* allocation = os::malloc(sz, mem_tag);\n-    if (allocation == nullptr && strategy == AllocFailStrategy::EXIT_OOM) {\n-      vm_exit_out_of_memory(sz, OOM_MALLOC_ERROR,\n-                            \"red-black tree failed allocation\");\n-    }\n-    return allocation;\n-  }\n-\n-  void free(void* ptr) { os::free(ptr); }\n+  void* allocate(size_t sz);\n+  void free(void* ptr);\n@@ -591,6 +418,3 @@\n-  RBTreeArenaAllocator(Arena* arena) : _arena(arena) {}\n-\n-  void* allocate(size_t sz) {\n-    return _arena->Amalloc(sz, strategy);\n-  }\n-  void free(void* ptr) { \/* NOP *\/ }\n+  RBTreeArenaAllocator(Arena* arena);\n+  void* allocate(size_t sz);\n+  void free(void* ptr);\n@@ -603,5 +427,3 @@\n-  RBTreeResourceAreaAllocator(ResourceArea* rarea) : _rarea(rarea) {}\n-  void* allocate(size_t sz) {\n-    return _rarea->Amalloc(sz, strategy);\n-  }\n-  void free(void* ptr) { \/* NOP *\/ }\n+  RBTreeResourceAreaAllocator(ResourceArea* rarea);\n+  void* allocate(size_t sz);\n+  void free(void* ptr);\n","filename":"src\/hotspot\/share\/utilities\/rbTree.hpp","additions":81,"deletions":259,"binary":false,"changes":340,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,3 @@\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/arena.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n@@ -36,0 +39,20 @@\n+inline IntrusiveRBNode::IntrusiveRBNode()\n+  : _parent(0), _left(nullptr), _right(nullptr) DEBUG_ONLY(COMMA _visited(false)) {}\n+\n+inline bool IntrusiveRBNode::is_black() const { return (_parent & 0x1) != 0; }\n+inline bool IntrusiveRBNode::is_red()   const { return (_parent & 0x1) == 0; }\n+\n+inline void IntrusiveRBNode::set_black() { _parent |= 0x1; }\n+inline void IntrusiveRBNode::set_red()   { _parent &= ~0x1; }\n+\n+inline IntrusiveRBNode* IntrusiveRBNode::parent() const { return reinterpret_cast<IntrusiveRBNode*>(_parent & ~0x1); }\n+inline void IntrusiveRBNode::set_parent(IntrusiveRBNode* new_parent) { _parent = (_parent & 0x1) | reinterpret_cast<uintptr_t>(new_parent); }\n+\n+inline bool IntrusiveRBNode::is_right_child() const {\n+  return parent() != nullptr && parent()->_right == this;\n+}\n+\n+inline bool IntrusiveRBNode::is_left_child() const {\n+  return parent() != nullptr && parent()->_left == this;\n+}\n+\n@@ -188,0 +211,114 @@\n+template <typename K, typename V>\n+inline const K& RBNode<K, V>::key() const { return _key; }\n+\n+template <typename K, typename V>\n+inline V& RBNode<K, V>::val() { return _value; }\n+\n+template <typename K, typename V>\n+inline const V& RBNode<K, V>::val() const { return _value; }\n+\n+template <typename K, typename V>\n+inline void RBNode<K, V>::set_val(const V& v) { _value = v; }\n+\n+template <typename K, typename V>\n+inline RBNode<K, V>::RBNode() {}\n+\n+template <typename K, typename V>\n+inline RBNode<K, V>::RBNode(const K& key) : IntrusiveRBNode(), _key(key) {}\n+\n+template <typename K, typename V>\n+inline RBNode<K, V>::RBNode(const K& key, const V& val) : IntrusiveRBNode(), _key(key), _value(val) {}\n+\n+template <typename K, typename V>\n+inline const RBNode<K, V>* RBNode<K, V>::prev() const { return static_cast<const RBNode<K, V>*>(IntrusiveRBNode::prev()); }\n+\n+template <typename K, typename V>\n+inline const RBNode<K, V>* RBNode<K, V>::next() const { return static_cast<const RBNode<K, V>*>(IntrusiveRBNode::next()); }\n+\n+template <typename K, typename V>\n+inline RBNode<K, V>* RBNode<K, V>::prev() { return static_cast<RBNode<K, V>*>(IntrusiveRBNode::prev()); }\n+\n+template <typename K, typename V>\n+inline RBNode<K, V>* RBNode<K, V>::next() { return static_cast<RBNode<K, V>*>(IntrusiveRBNode::next()); }\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline AbstractRBTree<K, NodeType, COMPARATOR>::Cursor::Cursor()\n+  : _insert_location(nullptr), _parent(nullptr) {}\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline AbstractRBTree<K, NodeType, COMPARATOR>::Cursor::Cursor(NodeType** insert_location, NodeType* parent)\n+  : _insert_location(insert_location), _parent(parent) {}\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline AbstractRBTree<K, NodeType, COMPARATOR>::Cursor::Cursor(NodeType* const* insert_location, NodeType* parent)\n+  : _insert_location(const_cast<NodeType**>(insert_location)), _parent(parent) {}\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline bool AbstractRBTree<K, NodeType, COMPARATOR>::Cursor::valid() const { return _insert_location != nullptr; }\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline bool AbstractRBTree<K, NodeType, COMPARATOR>::Cursor::found() const { return *_insert_location != nullptr; }\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline NodeType* AbstractRBTree<K, NodeType, COMPARATOR>::Cursor::node() { return _insert_location == nullptr ? nullptr : *_insert_location; }\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline NodeType* AbstractRBTree<K, NodeType, COMPARATOR>::Cursor::node() const { return _insert_location == nullptr ? nullptr : *_insert_location; }\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline RBTreeOrdering AbstractRBTree<K, NodeType, COMPARATOR>::cmp(const K& a, const NodeType* b) const {\n+  if constexpr (HasNodeComparator) {\n+    return COMPARATOR::cmp(a, b);\n+  } else if constexpr (HasKeyComparator) {\n+    return COMPARATOR::cmp(a, b->key());\n+  }\n+}\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline bool AbstractRBTree<K, NodeType, COMPARATOR>::less_than(const NodeType* a, const NodeType* b) const {\n+  if constexpr (HasNodeVerifier) {\n+    return COMPARATOR::less_than(a, b);\n+  } else {\n+    return true;\n+  }\n+}\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline void AbstractRBTree<K, NodeType, COMPARATOR>::assert_key_leq(K a, K b) const {\n+  if constexpr (HasKeyComparator) { \/\/ Cannot assert if no key comparator exist.\n+    assert(COMPARATOR::cmp(a, b) != RBTreeOrdering::GT, \"key a must be less or equal to key b\");\n+  }\n+}\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline bool AbstractRBTree<K, NodeType, COMPARATOR>::is_black(const IntrusiveRBNode* node) {\n+  return node == nullptr || node->is_black();\n+}\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline bool AbstractRBTree<K, NodeType, COMPARATOR>::is_red(const IntrusiveRBNode* node) {\n+  return node != nullptr && node->is_red();\n+}\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline bool AbstractRBTree<K, NodeType, COMPARATOR>::empty_verifier::operator()(const NodeType* n) const {\n+  return true;\n+}\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline void AbstractRBTree<K, NodeType, COMPARATOR>::default_printer::operator()(outputStream* st, const NodeType* n, int depth) const {\n+  n->print_on(st, depth);\n+}\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline AbstractRBTree<K, NodeType, COMPARATOR>::AbstractRBTree()\n+    : _num_nodes(0), _root(nullptr) DEBUG_ONLY(COMMA _expected_visited(false)) {\n+  static_assert(std::is_trivially_destructible<K>::value, \"key type must be trivially destructable\");\n+  static_assert(HasKeyComparator || HasNodeComparator, \"comparator must be of correct type\");\n+}\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline size_t AbstractRBTree<K, NodeType, COMPARATOR>::size() const {\n+  return _num_nodes;\n+}\n+\n@@ -599,0 +736,98 @@\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline NodeType* AbstractRBTree<K, NodeType, COMPARATOR>::find_node(const K& key, const NodeType* hint_node) const {\n+  Cursor node_cursor = cursor(key, hint_node);\n+  return node_cursor.node();\n+}\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline NodeType* AbstractRBTree<K, NodeType, COMPARATOR>::find_node(const K& key, const NodeType* hint_node) {\n+  Cursor node_cursor = cursor(key, hint_node);\n+  return node_cursor.node();\n+}\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline void AbstractRBTree<K, NodeType, COMPARATOR>::insert(const K& key, NodeType* node, const NodeType* hint_node) {\n+  Cursor node_cursor = cursor(key, hint_node);\n+  insert_at_cursor(node, node_cursor);\n+}\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline void AbstractRBTree<K, NodeType, COMPARATOR>::remove(NodeType* node) {\n+  Cursor node_cursor = cursor(node);\n+  remove_at_cursor(node_cursor);\n+}\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline NodeType* AbstractRBTree<K, NodeType, COMPARATOR>::closest_leq(const K& key) const {\n+  Cursor node_cursor = cursor(key);\n+  return node_cursor.found() ? node_cursor.node() : prev(node_cursor).node();\n+}\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline NodeType* AbstractRBTree<K, NodeType, COMPARATOR>::closest_leq(const K& key) {\n+  Cursor node_cursor = cursor(key);\n+  return node_cursor.found() ? node_cursor.node() : prev(node_cursor).node();\n+}\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline NodeType* AbstractRBTree<K, NodeType, COMPARATOR>::closest_gt(const K& key) const {\n+  Cursor node_cursor = cursor(key);\n+  return next(node_cursor).node();\n+}\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline NodeType* AbstractRBTree<K, NodeType, COMPARATOR>::closest_gt(const K& key) {\n+  Cursor node_cursor = cursor(key);\n+  return next(node_cursor).node();\n+}\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline NodeType* AbstractRBTree<K, NodeType, COMPARATOR>::closest_ge(const K& key) const {\n+  Cursor node_cursor = cursor(key);\n+  return node_cursor.found() ? node_cursor.node() : next(node_cursor).node();\n+}\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline NodeType* AbstractRBTree<K, NodeType, COMPARATOR>::closest_ge(const K& key) {\n+  Cursor node_cursor = cursor(key);\n+  return node_cursor.found() ? node_cursor.node() : next(node_cursor).node();\n+}\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline const NodeType* AbstractRBTree<K, NodeType, COMPARATOR>::leftmost() const {\n+  IntrusiveRBNode* n = _root, *n2 = nullptr;\n+  while (n != nullptr) {\n+    n2 = n;\n+    n = n->_left;\n+  }\n+  return static_cast<const NodeType*>(n2);\n+}\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline const NodeType* AbstractRBTree<K, NodeType, COMPARATOR>::rightmost() const {\n+  IntrusiveRBNode* n = _root, *n2 = nullptr;\n+  while (n != nullptr) {\n+    n2 = n;\n+    n = n->_right;\n+  }\n+  return static_cast<const NodeType*>(n2);\n+}\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline NodeType* AbstractRBTree<K, NodeType, COMPARATOR>::leftmost() {\n+  return const_cast<NodeType*>(static_cast<const AbstractRBTree<K, NodeType, COMPARATOR>*>(this)->leftmost());\n+}\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline NodeType* AbstractRBTree<K, NodeType, COMPARATOR>::rightmost() {\n+  return const_cast<NodeType*>(static_cast<const AbstractRBTree<K, NodeType, COMPARATOR>*>(this)->rightmost());\n+}\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+inline typename AbstractRBTree<K, NodeType, COMPARATOR>::Range\n+AbstractRBTree<K, NodeType, COMPARATOR>::find_enclosing_range(K key) const {\n+  NodeType* start = closest_leq(key);\n+  NodeType* end = closest_gt(key);\n+  return Range(start, end);\n+}\n+\n@@ -665,0 +900,12 @@\n+template <typename K, typename NodeType, typename COMPARATOR>\n+template <typename USER_VERIFIER>\n+inline void AbstractRBTree<K, NodeType, COMPARATOR>::verify_self(const USER_VERIFIER& extra_verifier) const {\n+  if constexpr (HasNodeVerifier) {\n+    verify_self([](const NodeType* a, const NodeType* b){ return COMPARATOR::less_than(a, b);}, extra_verifier);\n+  } else if constexpr (HasKeyComparator) {\n+    verify_self([](const NodeType* a, const NodeType* b){ return COMPARATOR::cmp(a->key(), b->key()) == RBTreeOrdering::LT; }, extra_verifier);\n+  } else {\n+    verify_self([](const NodeType*, const NodeType*){ return true;}, extra_verifier);\n+  }\n+}\n+\n@@ -756,0 +1003,9 @@\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+template<typename... AllocArgs>\n+inline RBTree<K, V, COMPARATOR, ALLOCATOR>::RBTree(AllocArgs... alloc_args) : BaseType(), _allocator(alloc_args...) {}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline RBTree<K, V, COMPARATOR, ALLOCATOR>::~RBTree() {\n+  remove_all();\n+}\n+\n@@ -805,0 +1061,129 @@\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::replace_at_cursor(RBNode<K, V>* new_node, const Cursor& node_cursor) {\n+  RBNode<K, V>* old_node = node_cursor.node();\n+  BaseType::replace_at_cursor(new_node, node_cursor);\n+  free_node(old_node);\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline RBNode<K, V>* RBTree<K, V, COMPARATOR, ALLOCATOR>::allocate_node(const K& key) {\n+  void* node_place = _allocator.allocate(sizeof(RBNode<K, V>));\n+  if (node_place == nullptr) {\n+    return nullptr;\n+  }\n+  return new (node_place) RBNode<K, V>(key);\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline RBNode<K, V>* RBTree<K, V, COMPARATOR, ALLOCATOR>::allocate_node(const K& key, const V& val) {\n+  void* node_place = _allocator.allocate(sizeof(RBNode<K, V>));\n+  if (node_place == nullptr) {\n+    return nullptr;\n+  }\n+  return new (node_place) RBNode<K, V>(key, val);\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::free_node(RBNode<K, V>* node) {\n+  node->_value.~V();\n+  _allocator.free(node);\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline bool RBTree<K, V, COMPARATOR, ALLOCATOR>::upsert(const K& key, const V& val, const RBNode<K, V>* hint_node) {\n+  Cursor node_cursor = cursor(key, hint_node);\n+  RBNode<K, V>* node = node_cursor.node();\n+  if (node != nullptr) {\n+    node->set_val(val);\n+    return true;\n+  }\n+\n+  node = allocate_node(key, val);\n+  if (node == nullptr) {\n+    return false;\n+  }\n+  insert_at_cursor(node, node_cursor);\n+  return true;\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline V* RBTree<K, V, COMPARATOR, ALLOCATOR>::find(const K& key) {\n+  Cursor node_cursor = cursor(key);\n+  return node_cursor.found() ? &node_cursor.node()->_value : nullptr;\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline V* RBTree<K, V, COMPARATOR, ALLOCATOR>::find(const K& key) const {\n+  const Cursor node_cursor = cursor(key);\n+  return node_cursor.found() ? &node_cursor.node()->_value : nullptr;\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::remove(RBNode<K, V>* node) {\n+  Cursor node_cursor = cursor(node);\n+  remove_at_cursor(node_cursor);\n+  free_node(node);\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline bool RBTree<K, V, COMPARATOR, ALLOCATOR>::remove(const K& key) {\n+  Cursor node_cursor = cursor(key);\n+  if (!node_cursor.found()) {\n+    return false;\n+  }\n+  RBNode<K, V>* node = node_cursor.node();\n+  remove_at_cursor(node_cursor);\n+  free_node((RBNode<K, V>*)node);\n+  return true;\n+}\n+\n+template <typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n+inline void RBTree<K, V, COMPARATOR, ALLOCATOR>::remove_all() {\n+  IntrusiveRBNode* to_delete[64];\n+  int stack_idx = 0;\n+  to_delete[stack_idx++] = BaseType::_root;\n+\n+  while (stack_idx > 0) {\n+    IntrusiveRBNode* head = to_delete[--stack_idx];\n+    if (head == nullptr) continue;\n+    to_delete[stack_idx++] = head->_left;\n+    to_delete[stack_idx++] = head->_right;\n+    free_node((RBNode<K, V>*)head);\n+  }\n+  BaseType::_num_nodes = 0;\n+  BaseType::_root = nullptr;\n+}\n+\n+template <MemTag mem_tag, AllocFailType strategy>\n+inline void* RBTreeCHeapAllocator<mem_tag, strategy>::allocate(size_t sz) {\n+  return static_cast<void*>(AllocateHeap(sz, mem_tag, strategy));\n+}\n+\n+template <MemTag mem_tag, AllocFailType strategy>\n+inline void RBTreeCHeapAllocator<mem_tag, strategy>::free(void* ptr) {\n+  FreeHeap(ptr);\n+}\n+\n+template <AllocFailType strategy>\n+inline RBTreeArenaAllocator<strategy>::RBTreeArenaAllocator(Arena* arena) : _arena(arena) {}\n+\n+template <AllocFailType strategy>\n+inline void* RBTreeArenaAllocator<strategy>::allocate(size_t sz) {\n+  return _arena->Amalloc(sz, strategy);\n+}\n+\n+template <AllocFailType strategy>\n+inline void RBTreeArenaAllocator<strategy>::free(void* ptr) { \/* NOP *\/ }\n+\n+\n+template <AllocFailType strategy>\n+inline RBTreeResourceAreaAllocator<strategy>::RBTreeResourceAreaAllocator(ResourceArea* rarea) : _rarea(rarea) {}\n+\n+template <AllocFailType strategy>\n+inline void* RBTreeResourceAreaAllocator<strategy>::allocate(size_t sz) {\n+  return _rarea->Amalloc(sz, strategy);\n+}\n+\n+template <AllocFailType strategy>\n+inline void RBTreeResourceAreaAllocator<strategy>::free(void* ptr) { \/* NOP *\/ }\n+\n","filename":"src\/hotspot\/share\/utilities\/rbTree.inline.hpp","additions":386,"deletions":1,"binary":false,"changes":387,"status":"modified"}]}