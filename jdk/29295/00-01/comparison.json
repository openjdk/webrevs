{"files":[{"patch":"@@ -42,2 +42,7 @@\n-inline bool IntrusiveRBNode::is_black() const { return (_parent & 0x1) != 0; }\n-inline bool IntrusiveRBNode::is_red()   const { return (_parent & 0x1) == 0; }\n+inline bool IntrusiveRBNode::is_black() const {\n+  return (_parent & 0x1) != 0;\n+}\n+\n+inline bool IntrusiveRBNode::is_red() const {\n+  return (_parent & 0x1) == 0;\n+}\n@@ -45,2 +50,6 @@\n-inline void IntrusiveRBNode::set_black() { _parent |= 0x1; }\n-inline void IntrusiveRBNode::set_red()   { _parent &= ~0x1; }\n+inline void IntrusiveRBNode::set_black() {\n+  _parent |= 0x1;\n+}\n+inline void IntrusiveRBNode::set_red() {\n+  _parent &= ~0x1;\n+}\n@@ -48,2 +57,7 @@\n-inline IntrusiveRBNode* IntrusiveRBNode::parent() const { return reinterpret_cast<IntrusiveRBNode*>(_parent & ~0x1); }\n-inline void IntrusiveRBNode::set_parent(IntrusiveRBNode* new_parent) { _parent = (_parent & 0x1) | reinterpret_cast<uintptr_t>(new_parent); }\n+inline IntrusiveRBNode* IntrusiveRBNode::parent() const {\n+  return reinterpret_cast<IntrusiveRBNode*>(_parent & ~0x1);\n+}\n+\n+inline void IntrusiveRBNode::set_parent(IntrusiveRBNode* new_parent) {\n+  _parent = (_parent & 0x1) | reinterpret_cast<uintptr_t>(new_parent);\n+}\n@@ -212,1 +226,3 @@\n-inline const K& RBNode<K, V>::key() const { return _key; }\n+inline const K& RBNode<K, V>::key() const {\n+  return _key;\n+}\n@@ -215,1 +231,3 @@\n-inline V& RBNode<K, V>::val() { return _value; }\n+inline V& RBNode<K, V>::val() {\n+  return _value;\n+}\n@@ -218,1 +236,3 @@\n-inline const V& RBNode<K, V>::val() const { return _value; }\n+inline const V& RBNode<K, V>::val() const {\n+  return _value;\n+}\n@@ -221,1 +241,3 @@\n-inline void RBNode<K, V>::set_val(const V& v) { _value = v; }\n+inline void RBNode<K, V>::set_val(const V& v) {\n+  _value = v;\n+}\n@@ -233,1 +255,3 @@\n-inline const RBNode<K, V>* RBNode<K, V>::prev() const { return static_cast<const RBNode<K, V>*>(IntrusiveRBNode::prev()); }\n+inline const RBNode<K, V>* RBNode<K, V>::prev() const {\n+  return static_cast<const RBNode<K, V>*>(IntrusiveRBNode::prev());\n+}\n@@ -236,1 +260,3 @@\n-inline const RBNode<K, V>* RBNode<K, V>::next() const { return static_cast<const RBNode<K, V>*>(IntrusiveRBNode::next()); }\n+inline const RBNode<K, V>* RBNode<K, V>::next() const {\n+  return static_cast<const RBNode<K, V>*>(IntrusiveRBNode::next());\n+}\n@@ -239,1 +265,3 @@\n-inline RBNode<K, V>* RBNode<K, V>::prev() { return static_cast<RBNode<K, V>*>(IntrusiveRBNode::prev()); }\n+inline RBNode<K, V>* RBNode<K, V>::prev() {\n+  return static_cast<RBNode<K, V>*>(IntrusiveRBNode::prev());\n+}\n@@ -242,1 +270,3 @@\n-inline RBNode<K, V>* RBNode<K, V>::next() { return static_cast<RBNode<K, V>*>(IntrusiveRBNode::next()); }\n+inline RBNode<K, V>* RBNode<K, V>::next() {\n+  return static_cast<RBNode<K, V>*>(IntrusiveRBNode::next());\n+}\n@@ -257,1 +287,3 @@\n-inline bool AbstractRBTree<K, NodeType, COMPARATOR>::Cursor::valid() const { return _insert_location != nullptr; }\n+inline bool AbstractRBTree<K, NodeType, COMPARATOR>::Cursor::valid() const {\n+  return _insert_location != nullptr;\n+}\n@@ -260,1 +292,3 @@\n-inline bool AbstractRBTree<K, NodeType, COMPARATOR>::Cursor::found() const { return *_insert_location != nullptr; }\n+inline bool AbstractRBTree<K, NodeType, COMPARATOR>::Cursor::found() const {\n+  return *_insert_location != nullptr;\n+}\n@@ -263,1 +297,3 @@\n-inline NodeType* AbstractRBTree<K, NodeType, COMPARATOR>::Cursor::node() { return _insert_location == nullptr ? nullptr : *_insert_location; }\n+inline NodeType* AbstractRBTree<K, NodeType, COMPARATOR>::Cursor::node() {\n+  return _insert_location == nullptr ? nullptr : *_insert_location;\n+}\n@@ -266,1 +302,3 @@\n-inline NodeType* AbstractRBTree<K, NodeType, COMPARATOR>::Cursor::node() const { return _insert_location == nullptr ? nullptr : *_insert_location; }\n+inline NodeType* AbstractRBTree<K, NodeType, COMPARATOR>::Cursor::node() const {\n+  return _insert_location == nullptr ? nullptr : *_insert_location;\n+}\n@@ -1159,1 +1197,1 @@\n-  return static_cast<void*>(AllocateHeap(sz, mem_tag, strategy));\n+  return AllocateHeap(sz, mem_tag, strategy);\n@@ -1178,1 +1216,0 @@\n-\n","filename":"src\/hotspot\/share\/utilities\/rbTree.inline.hpp","additions":57,"deletions":20,"binary":false,"changes":77,"status":"modified"}]}