{"files":[{"patch":"@@ -874,0 +874,1 @@\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_JDK_LIBS_libVThreadEventTest := java.base:libjvm\n@@ -1512,0 +1513,1 @@\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_JDK_LIBS_libVThreadEventTest := java.base:libjvm\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,1 +68,0 @@\n-import java.util.concurrent.Callable;\n@@ -2267,0 +2266,1 @@\n+        @Override\n@@ -2684,8 +2684,0 @@\n-            public <V> V executeOnCarrierThread(Callable<V> task) throws Exception {\n-                if (Thread.currentThread() instanceof VirtualThread vthread) {\n-                    return vthread.executeOnCarrierThread(task);\n-                } else {\n-                    return task.call();\n-                }\n-            }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import java.util.concurrent.TimeUnit;\n@@ -65,2 +66,1 @@\n- * A thread that is scheduled by the Java virtual machine rather than the operating\n- * system.\n+ * A thread that is scheduled by the Java virtual machine rather than the operating system.\n@@ -72,1 +72,1 @@\n-    private static final ScheduledExecutorService UNPARKER = createDelayedTaskScheduler();\n+    private static final ScheduledExecutorService[] DELAYED_TASK_SCHEDULERS = createDelayedTaskSchedulers();\n@@ -220,1 +220,1 @@\n-    @ChangesCurrentThread\n+    @ChangesCurrentThread \/\/ allow mount\/unmount to be inlined\n@@ -260,0 +260,2 @@\n+     * @param scheduler the scheduler\n+     * @param retryOnOOME true to retry indefinitely if OutOfMemoryError is thrown\n@@ -262,6 +264,32 @@\n-    private void submitRunContinuation() {\n-        try {\n-            scheduler.execute(runContinuation);\n-        } catch (RejectedExecutionException ree) {\n-            submitFailed(ree);\n-            throw ree;\n+    @ChangesCurrentThread\n+    private void submitRunContinuation(Executor scheduler, boolean retryOnOOME) {\n+        boolean done = false;\n+        while (!done) {\n+            try {\n+                \/\/ The scheduler's execute method is invoked in the context of the\n+                \/\/ carrier thread. For the default scheduler this ensures that the\n+                \/\/ current thread is a ForkJoinWorkerThread so the task will be pushed\n+                \/\/ to the local queue. For other schedulers, it avoids deadlock that\n+                \/\/ would arise due to platform and virtual threads contending for a\n+                \/\/ lock on the scheduler's submission queue.\n+                if (currentThread() instanceof VirtualThread vthread) {\n+                    vthread.switchToCarrierThread();\n+                    try {\n+                        scheduler.execute(runContinuation);\n+                    } finally {\n+                        switchToVirtualThread(vthread);\n+                    }\n+                } else {\n+                    scheduler.execute(runContinuation);\n+                }\n+                done = true;\n+            } catch (RejectedExecutionException ree) {\n+                submitFailed(ree);\n+                throw ree;\n+            } catch (OutOfMemoryError e) {\n+                if (retryOnOOME) {\n+                    U.park(false, 100_000_000); \/\/ 100ms\n+                } else {\n+                    throw e;\n+                }\n+            }\n@@ -273,0 +301,1 @@\n+     * If OutOfMemoryError is thrown then the submit will be retried until it succeeds.\n@@ -277,0 +306,1 @@\n+        assert Thread.currentThread() instanceof CarrierThread;\n@@ -282,0 +312,2 @@\n+        } catch (OutOfMemoryError e) {\n+            submitRunContinuation(pool, true);\n@@ -287,0 +319,1 @@\n+     * If OutOfMemoryError is thrown then the submit will be retried until it succeeds.\n@@ -291,0 +324,1 @@\n+        assert Thread.currentThread() instanceof CarrierThread;\n@@ -296,0 +330,33 @@\n+        } catch (OutOfMemoryError e) {\n+            submitRunContinuation(pool, true);\n+        }\n+    }\n+\n+    \/**\n+     * Submits the runContinuation task to the scheduler. For the default scheduler,\n+     * and calling it on a worker thread, the task will be pushed to the local queue,\n+     * otherwise it will be pushed to an external submission queue.\n+     * If OutOfMemoryError is thrown then the submit will be retried until it succeeds.\n+     * @throws RejectedExecutionException\n+     *\/\n+    private void submitRunContinuation() {\n+        submitRunContinuation(scheduler, true);\n+    }\n+\n+    \/**\n+     * Submits the runContinuation task to the scheduler. For the default scheduler, and\n+     * calling it a virtual thread that uses the default scheduler, the task will be\n+     * pushed to an external submission queue. This method may throw OutOfMemoryError.\n+     * @throws RejectedExecutionException\n+     * @throws OutOfMemoryError\n+     *\/\n+    private void externalSubmitRunContinuationOrThrow() {\n+        if (scheduler == DEFAULT_SCHEDULER && currentCarrierThread() instanceof CarrierThread ct) {\n+            try {\n+                ct.getPool().externalSubmit(ForkJoinTask.adapt(runContinuation));\n+            } catch (RejectedExecutionException ree) {\n+                submitFailed(ree);\n+                throw ree;\n+            }\n+        } else {\n+            submitRunContinuation(scheduler, false);\n@@ -388,0 +455,2 @@\n+        assert !Thread.holdsLock(interruptLock);\n+\n@@ -420,1 +489,1 @@\n-    private void switchToVirtualThread(VirtualThread vthread) {\n+    private static void switchToVirtualThread(VirtualThread vthread) {\n@@ -477,2 +546,2 @@\n-                \/\/ lazy submit to continue on the current thread as carrier if possible\n-                if (currentThread() instanceof CarrierThread ct) {\n+                \/\/ lazy submit to continue on the current carrier if possible\n+                if (currentThread() instanceof CarrierThread ct && ct.getQueuedTaskCount() == 0) {\n@@ -483,1 +552,0 @@\n-\n@@ -564,2 +632,2 @@\n-            \/\/ submit task to run thread\n-            submitRunContinuation();\n+            \/\/ submit task to run thread, using externalSubmit if possible\n+            externalSubmitRunContinuationOrThrow();\n@@ -710,1 +778,1 @@\n-            return UNPARKER.schedule(this::unpark, nanos, NANOSECONDS);\n+            return schedule(this::unpark, nanos, NANOSECONDS);\n@@ -721,0 +789,1 @@\n+        assert Thread.currentThread() == this;\n@@ -733,4 +802,3 @@\n-     * Re-enables this virtual thread for scheduling. If the virtual thread was\n-     * {@link #park() parked} then it will be unblocked, otherwise its next call\n-     * to {@code park} or {@linkplain #parkNanos(long) parkNanos} is guaranteed\n-     * not to block.\n+     * Re-enables this virtual thread for scheduling. If this virtual thread is parked\n+     * then its task is scheduled to continue, otherwise its next call to {@code park} or\n+     * {@linkplain #parkNanos(long) parkNanos} is guaranteed not to block.\n@@ -740,1 +808,0 @@\n-    @ChangesCurrentThread\n@@ -742,2 +809,1 @@\n-        Thread currentThread = Thread.currentThread();\n-        if (!getAndSetParkPermit(true) && currentThread != this) {\n+        if (!getAndSetParkPermit(true) && currentThread() != this) {\n@@ -745,13 +811,9 @@\n-            boolean parked = (s == PARKED) || (s == TIMED_PARKED);\n-            if (parked && compareAndSetState(s, UNPARKED)) {\n-                if (currentThread instanceof VirtualThread vthread) {\n-                    vthread.switchToCarrierThread();\n-                    try {\n-                        submitRunContinuation();\n-                    } finally {\n-                        switchToVirtualThread(vthread);\n-                    }\n-                } else {\n-                    submitRunContinuation();\n-                }\n-            } else if ((s == PINNED) || (s == TIMED_PINNED)) {\n+\n+            \/\/ unparked while parked\n+            if ((s == PARKED || s == TIMED_PARKED) && compareAndSetState(s, UNPARKED)) {\n+                submitRunContinuation();\n+                return;\n+            }\n+\n+            \/\/ unparked while parked when pinned\n+            if (s == PINNED || s == TIMED_PINNED) {\n@@ -759,1 +821,1 @@\n-                notifyJvmtiDisableSuspend(true);\n+                disableSuspendAndPreempt();\n@@ -768,1 +830,1 @@\n-                    notifyJvmtiDisableSuspend(false);\n+                    enableSuspendAndPreempt();\n@@ -770,0 +832,1 @@\n+                return;\n@@ -862,1 +925,1 @@\n-        notifyJvmtiDisableSuspend(true);\n+        disableSuspendAndPreempt();\n@@ -866,1 +929,1 @@\n-            notifyJvmtiDisableSuspend(false);\n+            enableSuspendAndPreempt();\n@@ -877,1 +940,1 @@\n-            \/\/ suspended when entering or holding interruptLock\n+            \/\/ suspended or unmounted when entering or holding interruptLock\n@@ -879,1 +942,1 @@\n-            notifyJvmtiDisableSuspend(true);\n+            disableSuspendAndPreempt();\n@@ -893,1 +956,1 @@\n-                notifyJvmtiDisableSuspend(false);\n+                enableSuspendAndPreempt();\n@@ -900,0 +963,4 @@\n+\n+            \/\/ make available parking permit, unpark thread if parked\n+            unpark();\n+\n@@ -903,0 +970,1 @@\n+            setParkPermit(true);\n@@ -904,1 +972,0 @@\n-        unpark();\n@@ -917,1 +984,1 @@\n-            notifyJvmtiDisableSuspend(true);\n+            disableSuspendAndPreempt();\n@@ -924,1 +991,1 @@\n-                notifyJvmtiDisableSuspend(false);\n+                enableSuspendAndPreempt();\n@@ -949,6 +1016,8 @@\n-                notifyJvmtiDisableSuspend(true);\n-                try {\n-                    synchronized (carrierThreadAccessLock()) {\n-                        Thread carrierThread = this.carrierThread;\n-                        if (carrierThread != null) {\n-                            return carrierThread.threadState();\n+                if (Thread.currentThread() != this) {\n+                    disableSuspendAndPreempt();\n+                    try {\n+                        synchronized (carrierThreadAccessLock()) {\n+                            Thread carrierThread = this.carrierThread;\n+                            if (carrierThread != null) {\n+                                return carrierThread.threadState();\n+                            }\n@@ -956,0 +1025,2 @@\n+                    } finally {\n+                        enableSuspendAndPreempt();\n@@ -957,2 +1028,0 @@\n-                } finally {\n-                    notifyJvmtiDisableSuspend(false);\n@@ -1071,4 +1140,7 @@\n-        Thread carrier = carrierThread;\n-        if (carrier != null) {\n-            \/\/ include the carrier thread state and name when mounted\n-            notifyJvmtiDisableSuspend(true);\n+\n+        \/\/ add the carrier state and thread name when mounted\n+        boolean mounted;\n+        if (Thread.currentThread() == this) {\n+            mounted = appendCarrierInfo(sb);\n+        } else {\n+            disableSuspendAndPreempt();\n@@ -1077,7 +1149,1 @@\n-                    carrier = carrierThread;\n-                    if (carrier != null) {\n-                        String stateAsString = carrier.threadState().toString();\n-                        sb.append(stateAsString.toLowerCase(Locale.ROOT));\n-                        sb.append('@');\n-                        sb.append(carrier.getName());\n-                    }\n+                    mounted = appendCarrierInfo(sb);\n@@ -1086,1 +1152,1 @@\n-                notifyJvmtiDisableSuspend(false);\n+                enableSuspendAndPreempt();\n@@ -1089,2 +1155,3 @@\n-        \/\/ include virtual thread state when not mounted\n-        if (carrier == null) {\n+\n+        \/\/ add virtual thread state when not mounted\n+        if (!mounted) {\n@@ -1094,0 +1161,1 @@\n+\n@@ -1097,0 +1165,18 @@\n+    \/**\n+     * Appends the carrier state and thread name to the string buffer if mounted.\n+     * @return true if mounted, false if not mounted\n+     *\/\n+    private boolean appendCarrierInfo(StringBuilder sb) {\n+        assert Thread.currentThread() == this || Thread.holdsLock(carrierThreadAccessLock());\n+        Thread carrier = carrierThread;\n+        if (carrier != null) {\n+            String stateAsString = carrier.threadState().toString();\n+            sb.append(stateAsString.toLowerCase(Locale.ROOT));\n+            sb.append('@');\n+            sb.append(carrier.getName());\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n@@ -1130,0 +1216,16 @@\n+    \/**\n+     * Disallow the current thread be suspended or preempted.\n+     *\/\n+    private void disableSuspendAndPreempt() {\n+        notifyJvmtiDisableSuspend(true);\n+        Continuation.pin();\n+    }\n+\n+    \/**\n+     * Allow the current thread be suspended or preempted.\n+     *\/\n+    private void enableSuspendAndPreempt() {\n+        Continuation.unpin();\n+        notifyJvmtiDisableSuspend(false);\n+    }\n+\n@@ -1191,0 +1293,6 @@\n+\n+        \/\/ ensure VTHREAD_GROUP is created, may be accessed by JVMTI\n+        var group = Thread.virtualThreadGroup();\n+\n+        \/\/ ensure VirtualThreadPinnedEvent is loaded\/initialized\n+        U.ensureClassInitialized(VirtualThreadPinnedEvent.class);\n@@ -1194,1 +1302,1 @@\n-     * Creates the default scheduler.\n+     * Creates the default ForkJoinPool scheduler.\n@@ -1232,1 +1340,1 @@\n-     * Creates the ScheduledThreadPoolExecutor used for timed unpark.\n+     * Schedule a runnable task to run after a delay.\n@@ -1234,3 +1342,13 @@\n-    private static ScheduledExecutorService createDelayedTaskScheduler() {\n-        String propValue = GetPropertyAction.privilegedGetProperty(\"jdk.unparker.maxPoolSize\");\n-        int poolSize;\n+    private static Future<?> schedule(Runnable command, long delay, TimeUnit unit) {\n+        long tid = Thread.currentThread().threadId();\n+        int index = (int) tid & (DELAYED_TASK_SCHEDULERS.length - 1);\n+        return DELAYED_TASK_SCHEDULERS[index].schedule(command, delay, unit);\n+    }\n+\n+    \/**\n+     * Creates the ScheduledThreadPoolExecutors used to execute delayed tasks.\n+     *\/\n+    private static ScheduledExecutorService[] createDelayedTaskSchedulers() {\n+        String propName = \"jdk.virtualThreadScheduler.timerQueues\";\n+        String propValue = GetPropertyAction.privilegedGetProperty(propName);\n+        int queueCount;\n@@ -1238,1 +1356,4 @@\n-            poolSize = Integer.parseInt(propValue);\n+            queueCount = Integer.parseInt(propValue);\n+            if (queueCount != Integer.highestOneBit(queueCount)) {\n+                throw new RuntimeException(\"Value of \" + propName + \" must be power of 2\");\n+            }\n@@ -1240,1 +1361,13 @@\n-            poolSize = 1;\n+            int ncpus = Runtime.getRuntime().availableProcessors();\n+            queueCount = Math.max(Integer.highestOneBit(ncpus \/ 4), 1);\n+        }\n+        var schedulers = new ScheduledExecutorService[queueCount];\n+        for (int i = 0; i < queueCount; i++) {\n+            ScheduledThreadPoolExecutor stpe = (ScheduledThreadPoolExecutor)\n+                Executors.newScheduledThreadPool(1, task -> {\n+                    Thread t = InnocuousThread.newThread(\"VirtualThread-unparker\", task);\n+                    t.setDaemon(true);\n+                    return t;\n+                });\n+            stpe.setRemoveOnCancelPolicy(true);\n+            schedulers[i] = stpe;\n@@ -1242,6 +1375,1 @@\n-        ScheduledThreadPoolExecutor stpe = (ScheduledThreadPoolExecutor)\n-            Executors.newScheduledThreadPool(poolSize, task -> {\n-                return InnocuousThread.newThread(\"VirtualThread-unparker\", task);\n-            });\n-        stpe.setRemoveOnCancelPolicy(true);\n-        return stpe;\n+        return schedulers;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":210,"deletions":82,"binary":false,"changes":292,"status":"modified"},{"patch":"@@ -38,1 +38,3 @@\n-import jdk.internal.misc.VirtualThreads;\n+import java.util.concurrent.TimeUnit;\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -179,1 +181,1 @@\n-                VirtualThreads.unpark(thread);\n+                JLA.unparkVirtualThread(thread);\n@@ -219,1 +221,1 @@\n-                VirtualThreads.park();\n+                JLA.parkVirtualThread();\n@@ -267,1 +269,1 @@\n-                    VirtualThreads.park(nanos);\n+                    JLA.parkVirtualThread(nanos);\n@@ -314,5 +316,1 @@\n-            if (t.isVirtual()) {\n-                VirtualThreads.parkUntil(deadline);\n-            } else {\n-                U.park(true, deadline);\n-            }\n+            parkUntil(deadline);\n@@ -369,1 +367,1 @@\n-            VirtualThreads.park();\n+            JLA.parkVirtualThread();\n@@ -408,1 +406,1 @@\n-                VirtualThreads.park(nanos);\n+                JLA.parkVirtualThread(nanos);\n@@ -447,1 +445,2 @@\n-            VirtualThreads.parkUntil(deadline);\n+            long millis = deadline - System.currentTimeMillis();\n+            JLA.parkVirtualThread(TimeUnit.MILLISECONDS.toNanos(millis));\n@@ -465,0 +464,1 @@\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/locks\/LockSupport.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-import java.util.concurrent.Callable;\n@@ -513,5 +512,0 @@\n-    \/**\n-     * Executes the given value returning task on the current carrier thread.\n-     *\/\n-    <V> V executeOnCarrierThread(Callable<V> task) throws Exception;\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,95 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.misc;\n-\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.RejectedExecutionException;\n-import jdk.internal.access.JavaLangAccess;\n-import jdk.internal.access.SharedSecrets;\n-\n-\/**\n- * Defines static methods to support execution in the context of a virtual thread.\n- *\/\n-public final class VirtualThreads {\n-    private static final JavaLangAccess JLA;\n-    static {\n-        JLA = SharedSecrets.getJavaLangAccess();\n-        if (JLA == null) {\n-            throw new InternalError(\"JavaLangAccess not setup\");\n-        }\n-    }\n-    private VirtualThreads() { }\n-\n-    \/**\n-     * Parks the current virtual thread until it is unparked or interrupted.\n-     * If already unparked then the parking permit is consumed and this method\n-     * completes immediately (meaning it doesn't yield). It also completes\n-     * immediately if the interrupt status is set.\n-     * @throws WrongThreadException if the current thread is not a virtual thread\n-     *\/\n-    public static void park() {\n-        JLA.parkVirtualThread();\n-    }\n-\n-    \/**\n-     * Parks the current virtual thread up to the given waiting time or until it\n-     * is unparked or interrupted. If already unparked then the parking permit is\n-     * consumed and this method completes immediately (meaning it doesn't yield).\n-     * It also completes immediately if the interrupt status is set or the waiting\n-     * time is {@code <= 0}.\n-     * @param nanos the maximum number of nanoseconds to wait\n-     * @throws WrongThreadException if the current thread is not a virtual thread\n-     *\/\n-    public static void park(long nanos) {\n-        JLA.parkVirtualThread(nanos);\n-    }\n-\n-    \/**\n-     * Parks the current virtual thread until the given deadline or until is is\n-     * unparked or interrupted. If already unparked then the parking permit is\n-     * consumed and this method completes immediately (meaning it doesn't yield).\n-     * It also completes immediately if the interrupt status is set or the\n-     * deadline has past.\n-     * @param deadline absolute time, in milliseconds, from the epoch\n-     * @throws WrongThreadException if the current thread is not a virtual thread\n-     *\/\n-    public static void parkUntil(long deadline) {\n-        long millis = deadline - System.currentTimeMillis();\n-        long nanos = TimeUnit.NANOSECONDS.convert(millis, TimeUnit.MILLISECONDS);\n-        park(nanos);\n-    }\n-\n-    \/**\n-     * Re-enables a virtual thread for scheduling. If the thread was parked then\n-     * it will be unblocked, otherwise its next attempt to park will not block\n-     * @param thread the virtual thread to unpark\n-     * @throws IllegalArgumentException if the thread is not a virtual thread\n-     * @throws RejectedExecutionException if the scheduler cannot accept a task\n-     *\/\n-    public static void unpark(Thread thread) {\n-        JLA.unparkVirtualThread(thread);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/VirtualThreads.java","additions":0,"deletions":95,"binary":false,"changes":95,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,1 +82,1 @@\n-        checkFrames(vThread1, false, 14);\n+        checkFrames(vThread1, false, 13);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetFrameCount\/framecnt01\/framecnt01.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @modules java.base\/java.lang:+open\n@@ -29,1 +30,1 @@\n- * @run junit\/othervm\/native GetThreadStateTest\n+ * @run junit\/othervm\/native --enable-native-access=ALL-UNNAMED GetThreadStateTest\n@@ -35,0 +36,1 @@\n+ * @modules java.base\/java.lang:+open\n@@ -36,1 +38,1 @@\n- * @run junit\/othervm\/native -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations GetThreadStateTest\n+ * @run junit\/othervm\/native -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations --enable-native-access=ALL-UNNAMED GetThreadStateTest\n@@ -43,0 +45,1 @@\n+import jdk.test.lib.thread.VThreadRunner;\n@@ -46,0 +49,2 @@\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n@@ -54,0 +59,5 @@\n+\n+        \/\/ need >=2 carriers for testing pinning when main thread is a virtual thread\n+        if (Thread.currentThread().isVirtual()) {\n+            VThreadRunner.ensureParallelism(2);\n+        }\n@@ -108,1 +118,1 @@\n-     * Test state of thread waiting to enter a monitor.\n+     * Test state of thread waiting to enter a monitor when pinned and not pinned.\n@@ -110,3 +120,4 @@\n-    @Test\n-    void testMonitorEnter() throws Exception {\n-        var started = new AtomicBoolean();\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testMonitorEnter(boolean pinned) throws Exception {\n+        var ready = new AtomicBoolean();\n@@ -115,2 +126,9 @@\n-            started.set(true);\n-            synchronized (lock) { }\n+            if (pinned) {\n+                VThreadPinner.runPinned(() -> {\n+                    ready.set(true);\n+                    synchronized (lock) { }\n+                });\n+            } else {\n+                ready.set(true);\n+                synchronized (lock) { }\n+            }\n@@ -122,1 +140,1 @@\n-                awaitTrue(started);\n+                awaitTrue(ready);\n@@ -138,1 +156,1 @@\n-     * Test state of thread waiting in Object.wait().\n+     * Test state of thread waiting in Object.wait() when pinned and not pinned.\n@@ -140,3 +158,4 @@\n-    @Test\n-    void testObjectWait() throws Exception {\n-        var started = new AtomicBoolean();\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testObjectWait(boolean pinned) throws Exception {\n+        var ready = new AtomicBoolean();\n@@ -146,1 +165,0 @@\n-                started.set(true);\n@@ -148,1 +166,9 @@\n-                    lock.wait();\n+                    if (pinned) {\n+                        VThreadPinner.runPinned(() -> {\n+                            ready.set(true);\n+                            lock.wait();\n+                        });\n+                    } else {\n+                        ready.set(true);\n+                        lock.wait();\n+                    }\n@@ -154,1 +180,1 @@\n-            awaitTrue(started);\n+            awaitTrue(ready);\n@@ -180,1 +206,1 @@\n-     * Test state of thread waiting in Object.wait(millis).\n+     * Test state of thread waiting in Object.wait(millis) when pinned and not pinned.\n@@ -182,3 +208,4 @@\n-    @Test\n-    void testObjectWaitMillis() throws Exception {\n-        var started = new AtomicBoolean();\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testObjectWaitMillis(boolean pinned) throws Exception {\n+        var ready = new AtomicBoolean();\n@@ -188,4 +215,13 @@\n-                started.set(true);\n-                try {\n-                    lock.wait(Long.MAX_VALUE);\n-                } catch (InterruptedException e) { }\n+                synchronized (lock) {\n+                    try {\n+                        if (pinned) {\n+                            VThreadPinner.runPinned(() -> {\n+                                ready.set(true);\n+                                lock.wait(Long.MAX_VALUE);\n+                            });\n+                        } else {\n+                            ready.set(true);\n+                            lock.wait(Long.MAX_VALUE);\n+                        }\n+                    } catch (InterruptedException e) { }\n+                }\n@@ -196,1 +232,1 @@\n-            awaitTrue(started);\n+            awaitTrue(ready);\n@@ -222,1 +258,1 @@\n-     * Test state of thread parked with LockSupport.park.\n+     * Test state of thread parked with LockSupport.park when pinned and not pinned.\n@@ -224,3 +260,4 @@\n-    @Test\n-    void testPark() throws Exception {\n-        var started = new AtomicBoolean();\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testPark(boolean pinned) throws Exception {\n+        var ready = new AtomicBoolean();\n@@ -229,62 +266,9 @@\n-            started.set(true);\n-            while (!done.get()) {\n-                LockSupport.park();\n-            }\n-        });\n-        try {\n-            \/\/ wait for thread to start execution\n-            awaitTrue(started);\n-\n-            \/\/ thread should park\n-            int expected = JVMTI_THREAD_STATE_ALIVE |\n-                    JVMTI_THREAD_STATE_WAITING |\n-                    JVMTI_THREAD_STATE_WAITING_INDEFINITELY |\n-                    JVMTI_THREAD_STATE_PARKED;\n-            await(thread, expected);\n-        } finally {\n-            done.set(true);\n-            LockSupport.unpark(thread);\n-            thread.join();\n-        }\n-    }\n-\n-    \/**\n-     * Test state of thread parked with LockSupport.parkNanos.\n-     *\/\n-    @Test\n-    void testParkNanos() throws Exception {\n-        var started = new AtomicBoolean();\n-        var done = new AtomicBoolean();\n-        var thread = Thread.ofVirtual().start(() -> {\n-            started.set(true);\n-            while (!done.get()) {\n-                LockSupport.parkNanos(Long.MAX_VALUE);\n-            }\n-        });\n-        try {\n-            \/\/ wait for thread to start execution\n-            awaitTrue(started);\n-\n-            \/\/ thread should park\n-            int expected = JVMTI_THREAD_STATE_ALIVE |\n-                    JVMTI_THREAD_STATE_WAITING |\n-                    JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT |\n-                    JVMTI_THREAD_STATE_PARKED;\n-            await(thread, expected);\n-        } finally {\n-            done.set(true);\n-            LockSupport.unpark(thread);\n-            thread.join();\n-        }\n-    }\n-\n-    \/**\n-     * Test state of thread parked with LockSupport.park while holding a monitor.\n-     *\/\n-    @Test\n-    void testParkWhenPinned() throws Exception {\n-        var started = new AtomicBoolean();\n-        var done = new AtomicBoolean();\n-        var thread = Thread.ofVirtual().start(() -> {\n-            VThreadPinner.runPinned(() -> {\n-                started.set(true);\n+            if (pinned) {\n+                VThreadPinner.runPinned(() -> {\n+                    ready.set(true);\n+                    while (!done.get()) {\n+                        LockSupport.park();\n+                    }\n+                });\n+            } else {\n+                ready.set(true);\n@@ -294,1 +278,1 @@\n-            });\n+            }\n@@ -298,1 +282,1 @@\n-            awaitTrue(started);\n+            awaitTrue(ready);\n@@ -314,1 +298,1 @@\n-     * Test state of thread parked with LockSupport.parkNanos while holding a monitor.\n+     * Test state of thread parked with LockSupport.parkNanos when pinned and not pinned.\n@@ -316,3 +300,4 @@\n-    @Test\n-    void testParkNanosWhenPinned() throws Exception {\n-        var started = new AtomicBoolean();\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testParkNanos(boolean pinned) throws Exception {\n+        var ready = new AtomicBoolean();\n@@ -321,2 +306,9 @@\n-            VThreadPinner.runPinned(() -> {\n-                started.set(true);\n+            if (pinned) {\n+                VThreadPinner.runPinned(() -> {\n+                    ready.set(true);\n+                    while (!done.get()) {\n+                        LockSupport.parkNanos(Long.MAX_VALUE);\n+                    }\n+                });\n+            } else {\n+                ready.set(true);\n@@ -326,1 +318,1 @@\n-            });\n+            }\n@@ -330,1 +322,1 @@\n-            awaitTrue(started);\n+            awaitTrue(ready);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/GetThreadState\/GetThreadStateTest.java","additions":94,"deletions":102,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+ * @modules java.base\/java.lang:+open\n+ * @library \/test\/lib\n@@ -32,1 +34,0 @@\n- *     -Djdk.virtualThreadScheduler.parallelism=9\n@@ -37,2 +38,1 @@\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicBoolean;\n@@ -42,24 +42,1 @@\n-\n-\/*\n- * The test uses custom implementation of the CountDownLatch class.\n- * The reason is we want the state of tested thread to be predictable.\n- * With java.util.concurrent.CountDownLatch it is not clear what thread state is expected.\n- *\/\n-class CountDownLatch {\n-    private int count = 0;\n-\n-    CountDownLatch(int count) {\n-        this.count = count;\n-    }\n-\n-    public synchronized void countDown() {\n-        count--;\n-        notify();\n-    }\n-\n-    public synchronized void await() throws InterruptedException {\n-        while (count > 0) {\n-            wait(1);\n-        }\n-    }\n-}\n+import jdk.test.lib.thread.VThreadRunner;\n@@ -68,4 +45,2 @@\n-    static final int TCNT1 = 10;\n-    static final int TCNT2 = 4;\n-    static final int TCNT3 = 4;\n-    static final int THREAD_CNT = TCNT1 + TCNT2 + TCNT3;\n+    static final int PARKED_THREAD_COUNT = 4;\n+    static final int SPINNING_THREAD_COUNT = 4;\n@@ -80,14 +55,4 @@\n-    private static boolean failed;\n-    private static List<Thread> test1Threads = new ArrayList(TCNT1);\n-\n-    private static CountDownLatch ready0 = new CountDownLatch(THREAD_CNT);\n-    private static CountDownLatch ready1 = new CountDownLatch(TCNT1);\n-    private static CountDownLatch ready2 = new CountDownLatch(THREAD_CNT);\n-    private static CountDownLatch mready = new CountDownLatch(1);\n-\n-    private static void await(CountDownLatch dumpedLatch) {\n-        try {\n-            dumpedLatch.await();\n-        } catch (InterruptedException e) {\n-            throw new RuntimeException(e);\n-        }\n+\n+    \/\/ called by agent when it is initialized and has enabled events\n+    static void agentStarted() {\n+        attached = true;\n@@ -96,4 +61,4 @@\n-    \/\/ The test1 vthreads are kept unmounted until interrupted after agent attach.\n-    static final Runnable test1 = () -> {\n-        synchronized (test1Threads) {\n-            test1Threads.add(Thread.currentThread());\n+    public static void main(String[] args) throws Exception {\n+        if (Thread.currentThread().isVirtual()) {\n+            System.out.println(\"Skipping test as current thread is a virtual thread\");\n+            return;\n@@ -101,8 +66,17 @@\n-        log(\"test1 vthread started\");\n-        ready0.countDown();\n-        await(mready);\n-        ready1.countDown(); \/\/ to guaranty state is not State.WAITING after await(mready)\n-        try {\n-            Thread.sleep(20000); \/\/ big timeout to keep unmounted until interrupted\n-        } catch (InterruptedException ex) {\n-            \/\/ it is expected, ignore\n+        VThreadRunner.ensureParallelism(SPINNING_THREAD_COUNT+1);\n+\n+        \/\/ start threads that park (unmount)\n+        var threads1 = new ArrayList<Thread>();\n+        for (int i = 0; i < PARKED_THREAD_COUNT; i++) {\n+            var started = new AtomicBoolean();\n+            var thread = Thread.startVirtualThread(() -> {\n+                started.set(true);\n+                LockSupport.park();\n+            });\n+\n+            \/\/ wait for thread to start execution + park\n+            while (!started.get()) {\n+                Thread.sleep(10);\n+            }\n+            await(thread, Thread.State.WAITING);\n+            threads1.add(thread);\n@@ -110,10 +84,17 @@\n-        ready2.countDown();\n-    };\n-\n-    \/\/ The test2 vthreads are kept mounted until agent attach.\n-    static final Runnable test2 = () -> {\n-        log(\"test2 vthread started\");\n-        ready0.countDown();\n-        await(mready);\n-        while (!attached) {\n-            \/\/ keep mounted\n+\n+        \/\/ start threads that spin (stay mounted)\n+        var threads2 = new ArrayList<Thread>();\n+        for (int i = 0; i < SPINNING_THREAD_COUNT; i++) {\n+            var started = new AtomicBoolean();\n+            var thread = Thread.startVirtualThread(() -> {\n+                started.set(true);\n+                while (!attached) {\n+                    Thread.onSpinWait();\n+                }\n+            });\n+\n+            \/\/ wait for thread to start execution\n+            while (!started.get()) {\n+                Thread.sleep(10);\n+            }\n+            threads2.add(thread);\n@@ -121,8 +102,6 @@\n-        ready2.countDown();\n-    };\n-\n-    \/\/ The test3 vthreads are kept mounted until agent attach.\n-    static final Runnable test3 = () -> {\n-        log(\"test3 vthread started\");\n-        ready0.countDown();\n-        await(mready);\n+\n+        \/\/ attach to the current VM\n+        VirtualMachine vm = VirtualMachine.attach(String.valueOf(ProcessHandle.current().pid()));\n+        vm.loadAgentLibrary(\"VThreadEventTest\");\n+\n+        \/\/ wait for agent to start\n@@ -130,1 +109,1 @@\n-            \/\/ keep mounted\n+            Thread.sleep(10);\n@@ -132,3 +111,0 @@\n-        LockSupport.parkNanos(10_000_000L); \/\/ will cause extra mount and unmount\n-        ready2.countDown();\n-    };\n@@ -136,3 +112,3 @@\n-    public static void main(String[] args) throws Exception {\n-        if (Runtime.getRuntime().availableProcessors() < 8) {\n-            log(\"WARNING: test expects at least 8 processors.\");\n+        \/\/ unpark the threads that were parked\n+        for (Thread thread : threads1) {\n+            LockSupport.unpark(thread);\n@@ -140,27 +116,0 @@\n-        try (ExecutorService executorService = Executors.newVirtualThreadPerTaskExecutor()) {\n-            for (int i = 0; i < TCNT1; i++) {\n-                executorService.execute(test1);\n-            }\n-            for (int i = 0; i < TCNT2; i++) {\n-                executorService.execute(test2);\n-            }\n-            for (int i = 0; i < TCNT3; i++) {\n-                executorService.execute(test3);\n-            }\n-            await(ready0);\n-            mready.countDown();\n-            await(ready1); \/\/ to guarantee state is not State.TIMED_WAITING after await(mready) in test1()\n-            \/\/ wait for test1 threads to reach TIMED_WAITING state in sleep()\n-            for (Thread t : test1Threads) {\n-                Thread.State state = t.getState();\n-                log(\"DBG: state: \" + state);\n-                while (state != Thread.State.TIMED_WAITING) {\n-                    Thread.sleep(10);\n-                    state = t.getState();\n-                    log(\"DBG: state: \" + state);\n-                }\n-            }\n-\n-            VirtualMachine vm = VirtualMachine.attach(String.valueOf(ProcessHandle.current().pid()));\n-            vm.loadAgentLibrary(\"VThreadEventTest\");\n-            Thread.sleep(200); \/\/ to allow the agent to get ready\n@@ -168,5 +117,3 @@\n-            attached = true;\n-            for (Thread t : test1Threads) {\n-                 t.interrupt();\n-            }\n-            ready2.await();\n+        \/\/ wait for all threads to terminate\n+        for (Thread thread : threads1) {\n+            thread.join();\n@@ -174,6 +121,2 @@\n-        \/\/ wait until all VirtualThreadEnd events have been sent\n-        for (int sleepNo = 1; threadEndCount() < THREAD_CNT; sleepNo++) {\n-            Thread.sleep(100);\n-            if (sleepNo % 100 == 0) { \/\/ 10 sec period of waiting\n-                log(\"main: waited seconds: \" + sleepNo\/10);\n-            }\n+        for (Thread thread : threads2) {\n+            thread.join();\n@@ -181,0 +124,1 @@\n+\n@@ -184,3 +128,0 @@\n-        int threadEndExp = THREAD_CNT;\n-        int threadMountExp = THREAD_CNT - TCNT2;\n-        int threadUnmountExp = THREAD_CNT + TCNT3;\n@@ -188,3 +129,4 @@\n-        log(\"ThreadEnd cnt: \"     + threadEndCnt     + \" (expected: \" + threadEndExp + \")\");\n-        log(\"ThreadMount cnt: \"   + threadMountCnt   + \" (expected: \" + threadMountExp + \")\");\n-        log(\"ThreadUnmount cnt: \" + threadUnmountCnt + \" (expected: \" + threadUnmountExp + \")\");\n+        int threadCount = PARKED_THREAD_COUNT + SPINNING_THREAD_COUNT;\n+        log(\"VirtualThreadEnd events: \" + threadEndCnt + \", expected: \" + threadCount);\n+        log(\"VirtualThreadMount events: \" + threadMountCnt + \", expected: \" + PARKED_THREAD_COUNT);\n+        log(\"VirtualThreadUnmount events: \" + threadUnmountCnt + \", expected: \" + threadCount);\n@@ -192,2 +134,3 @@\n-        if (threadEndCnt != threadEndExp) {\n-            log(\"FAILED: unexpected count of ThreadEnd events\");\n+        boolean failed = false;\n+        if (threadEndCnt != threadCount) {\n+            log(\"FAILED: unexpected count of VirtualThreadEnd events\");\n@@ -196,2 +139,2 @@\n-        if (threadMountCnt != threadMountExp) {\n-            log(\"FAILED: unexpected count of ThreadMount events\");\n+        if (threadMountCnt != PARKED_THREAD_COUNT) {\n+            log(\"FAILED: unexpected count of VirtualThreadMount events\");\n@@ -200,2 +143,2 @@\n-        if (threadUnmountCnt != threadUnmountExp) {\n-            log(\"FAILED: unexpected count of ThreadUnmount events\");\n+        if (threadUnmountCnt != threadCount) {\n+            log(\"FAILED: unexpected count of VirtualThreadUnmount events\");\n@@ -209,0 +152,9 @@\n+    private static void await(Thread thread, Thread.State expectedState) throws InterruptedException {\n+        Thread.State state = thread.getState();\n+        while (state != expectedState) {\n+            assert state != Thread.State.TERMINATED : \"Thread has terminated\";\n+            Thread.sleep(10);\n+            state = thread.getState();\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/VThreadEventTest\/VThreadEventTest.java","additions":85,"deletions":133,"binary":false,"changes":218,"status":"modified"},{"patch":"@@ -68,0 +68,5 @@\n+  JNIEnv *env;\n+  jsize nVMs;\n+  jint res;\n+  jclass clazz;\n+  jmethodID mid;\n@@ -100,0 +105,35 @@\n+\n+  \/\/ call VThreadEventTest.agentStarted to notify test that agent has started\n+\n+  res = JNI_GetCreatedJavaVMs(&vm, 1, &nVMs);\n+  if (res != JNI_OK) {\n+      LOG(\"JNI_GetCreatedJavaVMs failed: %d\\n\", res);\n+      return JNI_ERR;\n+  }\n+\n+  res = vm->GetEnv((void **) &env, JNI_VERSION_21);\n+  if (res != JNI_OK) {\n+    LOG(\"GetEnv failed: %d\\n\", res);\n+    return JNI_ERR;\n+  }\n+\n+  clazz = env->FindClass(\"VThreadEventTest\");\n+  if (clazz == NULL) {\n+      LOG(\"FindClass failed\\n\");\n+      return JNI_ERR;\n+  }\n+\n+  mid = env->GetStaticMethodID(clazz, \"agentStarted\", \"()V\");\n+  if (mid == NULL) {\n+      LOG(\"GetStaticMethodID failed\\n\");\n+      return JNI_ERR;\n+  }\n+\n+  env->CallStaticVoidMethod(clazz, mid);\n+  if (env->ExceptionOccurred()) {\n+      LOG(\"CallStaticVoidMethod failed\\n\");\n+      return JNI_ERR;\n+  }\n+\n+  LOG(\"Agent_OnAttach done\\n\");\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/VThreadEventTest\/libVThreadEventTest.cpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -0,0 +1,243 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test id=default\n+ * @bug 8284161 8286788\n+ * @summary Test java.lang.management.ThreadInfo contains expected information for carrier threads\n+ * @requires vm.continuations\n+ * @modules java.base\/java.lang:+open\n+ * @library \/test\/lib\n+ * @run junit CarrierThreadInfo\n+ *\/\n+\n+\/**\n+ * @test id=LM_LIGHTWEIGHT\n+ * @requires vm.continuations\n+ * @modules java.base\/java.lang:+open\n+ * @library \/test\/lib\n+ * @run junit\/othervm -XX:LockingMode=2 CarrierThreadInfo\n+ *\/\n+\n+\/**\n+ * @test id=LM_LEGACY\n+ * @requires vm.continuations\n+ * @modules java.base\/java.lang:+open\n+ * @library \/test\/lib\n+ * @run junit\/othervm -XX:LockingMode=1 CarrierThreadInfo\n+ *\/\n+\n+\/**\n+ * @test id=LM_MONITOR\n+ * @requires vm.continuations\n+ * @modules java.base\/java.lang:+open\n+ * @library \/test\/lib\n+ * @run junit\/othervm -XX:LockingMode=0 CarrierThreadInfo\n+ *\/\n+\n+import java.lang.management.LockInfo;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.ThreadInfo;\n+import java.lang.management.ThreadMXBean;\n+import java.util.Arrays;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import jdk.test.lib.thread.VThreadScheduler;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class CarrierThreadInfo {\n+\n+    \/**\n+     * Test that ThreadInfo.getLockedMonitors returns information about a lock held by\n+     * a carrier thread.\n+     *\/\n+    @Test\n+    void testCarrierThreadHoldsLock() throws Exception {\n+        Object lock = new Object();\n+        ThreadFactory factory = task -> Thread.ofPlatform().unstarted(() -> {\n+            synchronized (lock) {\n+                task.run();\n+            }\n+        });\n+\n+        try (var scheduler = new CustomScheduler(factory)) {\n+            var started = new AtomicBoolean();\n+            var done = new AtomicBoolean();\n+            Thread vthread = scheduler.forkVirtualThread(() -> {\n+                started.set(true);\n+                while (!done.get()) {\n+                    Thread.onSpinWait();\n+                }\n+            });\n+            try {\n+                awaitTrue(started);\n+\n+                \/\/ carrier threads holds the lock\n+                long carrierId = scheduler.carrier().threadId();\n+                ThreadInfo threadInfo = ManagementFactory.getPlatformMXBean(ThreadMXBean.class)\n+                        .getThreadInfo(new long[] { carrierId }, true, true)[0];\n+                boolean holdsLock = Arrays.stream(threadInfo.getLockedMonitors())\n+                        .anyMatch(mi -> mi.getIdentityHashCode() == System.identityHashCode(lock));\n+                assertTrue(holdsLock, \"Carrier should hold lock\");\n+\n+            } finally {\n+                done.set(true);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test that ThreadInfo.getLockedMonitors does not return information about a lock\n+     * held by mounted virtual thread.\n+     *\/\n+    @Test\n+    void testVirtualThreadHoldsLock() throws Exception {\n+        ThreadFactory factory = Executors.defaultThreadFactory();\n+        try (var scheduler = new CustomScheduler(factory)) {\n+            var started = new AtomicBoolean();\n+            var lock = new Object();\n+            var done = new AtomicBoolean();\n+            Thread vthread = scheduler.forkVirtualThread(() -> {\n+                started.set(true);\n+                while (!done.get()) {\n+                    Thread.onSpinWait();\n+                }\n+            });\n+            try {\n+                awaitTrue(started);\n+\n+                \/\/ carrier threads does not hold lock\n+                long carrierId = scheduler.carrier().threadId();\n+                ThreadInfo threadInfo = ManagementFactory.getPlatformMXBean(ThreadMXBean.class)\n+                        .getThreadInfo(new long[] { carrierId }, true, true)[0];\n+                boolean holdsLock = Arrays.stream(threadInfo.getLockedMonitors())\n+                        .anyMatch(mi -> mi.getIdentityHashCode() == System.identityHashCode(lock));\n+                assertFalse(holdsLock, \"Carrier should not hold lock\");\n+\n+            } finally {\n+                done.set(true);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test that ThreadInfo.getLockOwnerId and getLockInfo return information about a\n+     * synthetic lock that make it appear that the carrier is blocking waiting on the\n+     * virtual thread.\n+     *\/\n+    @Test\n+    void testCarrierThreadWaits() throws Exception {\n+        ThreadFactory factory = Executors.defaultThreadFactory();\n+        try (var scheduler = new CustomScheduler(factory)) {\n+            var started = new AtomicBoolean();\n+            var done = new AtomicBoolean();\n+            Thread vthread = scheduler.forkVirtualThread(() -> {\n+                started.set(true);\n+                while (!done.get()) {\n+                    Thread.onSpinWait();\n+                }\n+            });\n+            try {\n+                awaitTrue(started);\n+\n+                long carrierId = scheduler.carrier().threadId();\n+                long vthreadId = vthread.threadId();\n+\n+                ThreadInfo threadInfo = ManagementFactory.getThreadMXBean().getThreadInfo(carrierId);\n+                assertNotNull(threadInfo);\n+\n+                \/\/ carrier should be blocked waiting for lock owned by virtual thread\n+                assertEquals(vthreadId, threadInfo.getLockOwnerId());\n+\n+                \/\/ carrier thread should be on blocked waiting on virtual thread\n+                LockInfo lockInfo = threadInfo.getLockInfo();\n+                assertNotNull(lockInfo);\n+                assertEquals(vthread.getClass().getName(), lockInfo.getClassName());\n+                assertEquals(System.identityHashCode(vthread), lockInfo.getIdentityHashCode());\n+\n+            } finally {\n+                done.set(true);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Custom scheduler with a single carrier thread.\n+     *\/\n+    private static class CustomScheduler implements AutoCloseable {\n+        private final ExecutorService pool;\n+        private final Executor scheduler;\n+        private final AtomicReference<Thread> carrierRef = new AtomicReference<>();\n+\n+        CustomScheduler(ThreadFactory factory) {\n+            pool = Executors.newSingleThreadExecutor(factory);\n+            scheduler = task -> {\n+                pool.submit(() -> {\n+                    carrierRef.set(Thread.currentThread());\n+                    try {\n+                        task.run();\n+                    } finally {\n+                        carrierRef.set(null);\n+                    }\n+                });\n+            };\n+        }\n+\n+        \/**\n+         * Returns the carrier thread if a virtual thread is mounted.\n+         *\/\n+        Thread carrier() throws InterruptedException {\n+            return carrierRef.get();\n+        }\n+\n+        \/**\n+         * Starts a virtual thread to execute the give task.\n+         *\/\n+        Thread forkVirtualThread(Runnable task) {\n+            ThreadFactory factory = VThreadScheduler.virtualThreadFactory(scheduler);\n+            Thread thread = factory.newThread(task);\n+            thread.start();\n+            return thread;\n+        }\n+\n+        @Override\n+        public void close() {\n+            pool.close();\n+        }\n+    }\n+\n+    \/**\n+     * Waits for the boolean value to become true.\n+     *\/\n+    private static void awaitTrue(AtomicBoolean ref) throws InterruptedException {\n+        while (!ref.get()) {\n+            Thread.sleep(20);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/CarrierThreadInfo.java","additions":243,"deletions":0,"binary":false,"changes":243,"status":"added"},{"patch":"@@ -1,110 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8284161 8286788\n- * @summary Test that a carrier thread waits on a virtual thread\n- * @requires vm.continuations\n- * @modules java.base\/java.lang:+open\n- * @run junit CarrierThreadWaits\n- *\/\n-\n-\/**\n- * @test\n- * @requires vm.continuations & vm.debug\n- * @modules java.base\/java.lang:+open\n- * @run junit\/othervm -XX:LockingMode=0 CarrierThreadWaits\n- *\/\n-\n-import java.lang.management.LockInfo;\n-import java.lang.management.ManagementFactory;\n-import java.lang.management.ThreadInfo;\n-import java.util.concurrent.Executor;\n-import java.util.concurrent.ForkJoinPool;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicReference;\n-\n-import org.junit.jupiter.api.Test;\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-class CarrierThreadWaits {\n-\n-    @Test\n-    void testCarrierThreadWaiting() throws Exception {\n-        try (ForkJoinPool pool = new ForkJoinPool(1)) {\n-            var carrierRef = new AtomicReference<Thread>();\n-            var vthreadRef = new AtomicReference<Thread>();\n-\n-            Executor scheduler = task -> {\n-                pool.submit(() -> {\n-                    Thread carrier = Thread.currentThread();\n-                    carrierRef.set(carrier);\n-                    Thread vthread = vthreadRef.get();\n-\n-                    System.err.format(\"%s run task (%s) ...%n\", carrier, vthread);\n-                    task.run();\n-                    System.err.format(\"%s task done (%s)%n\", carrier, vthread);\n-                });\n-            };\n-\n-            \/\/ start a virtual thread that spins and remains mounted until \"done\"\n-            var started = new AtomicBoolean();\n-            var done = new AtomicBoolean();\n-            Thread.Builder builder = ThreadBuilders.virtualThreadBuilder(scheduler);\n-            Thread vthread = builder.unstarted(() -> {\n-                started.set(true);\n-                while (!done.get()) {\n-                    Thread.onSpinWait();\n-                }\n-            });\n-            vthreadRef.set(vthread);\n-            vthread.start();\n-\n-            try {\n-                \/\/ wait for virtual thread to start\n-                while (!started.get()) {\n-                    Thread.sleep(10);\n-                }\n-\n-                Thread carrier = carrierRef.get();\n-\n-                long carrierId = carrier.threadId();\n-                long vthreadId = vthread.threadId();\n-\n-                \/\/ carrier thread should be on WAITING on virtual thread\n-                ThreadInfo ti = ManagementFactory.getThreadMXBean().getThreadInfo(carrierId);\n-                Thread.State state = ti.getThreadState();\n-                LockInfo lockInfo = ti.getLockInfo();\n-                assertEquals(Thread.State.WAITING, state);\n-                assertNotNull(lockInfo);\n-                assertEquals(vthread.getClass().getName(), lockInfo.getClassName());\n-                assertEquals(System.identityHashCode(vthread), lockInfo.getIdentityHashCode());\n-                assertEquals(vthreadId, ti.getLockOwnerId());\n-            } finally {\n-                done.set(true);\n-            }\n-        }\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/CarrierThreadWaits.java","additions":0,"deletions":110,"binary":false,"changes":110,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @library \/test\/lib\n@@ -38,0 +39,1 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -41,0 +43,2 @@\n+import jdk.test.lib.thread.VThreadScheduler;\n+import jdk.test.lib.thread.VThreadRunner;\n@@ -68,4 +72,7 @@\n-        AtomicReference<Executor> ref = new AtomicReference<>();\n-        ThreadBuilders.virtualThreadBuilder(scheduler1).start(() -> {\n-            ref.set(scheduler(Thread.currentThread()));\n-        }).join();\n+        var ref = new AtomicReference<Executor>();\n+        ThreadFactory factory = VThreadScheduler.virtualThreadFactory(scheduler1);\n+        Thread thread = factory.newThread(() -> {\n+            ref.set(VThreadScheduler.scheduler(Thread.currentThread()));\n+        });\n+        thread.start();\n+        thread.join();\n@@ -80,11 +87,1 @@\n-        AtomicReference<Executor> ref = new AtomicReference<>();\n-        Thread.ofVirtual().start(() -> {\n-            try {\n-                ThreadBuilders.virtualThreadBuilder(scheduler1).start(() -> {\n-                    ref.set(scheduler(Thread.currentThread()));\n-                }).join();\n-            } catch (Exception e) {\n-                e.printStackTrace();\n-            }\n-        }).join();\n-        assertTrue(ref.get() == scheduler1);\n+        VThreadRunner.run(this::testCustomScheduler1);\n@@ -99,2 +96,3 @@\n-        AtomicReference<Executor> ref = new AtomicReference<>();\n-        ThreadBuilders.virtualThreadBuilder(scheduler1).start(() -> {\n+        var ref = new AtomicReference<Executor>();\n+        ThreadFactory factory = VThreadScheduler.virtualThreadFactory(scheduler1);\n+        Thread thread = factory.newThread(() -> {\n@@ -103,1 +101,1 @@\n-                    ref.set(scheduler(Thread.currentThread()));\n+                    ref.set(VThreadScheduler.scheduler(Thread.currentThread()));\n@@ -108,1 +106,3 @@\n-        }).join();\n+        });\n+        thread.start();\n+        thread.join();\n@@ -118,2 +118,4 @@\n-        AtomicReference<Executor> ref = new AtomicReference<>();\n-        ThreadBuilders.virtualThreadBuilder(scheduler1).start(() -> {\n+        var ref = new AtomicReference<Executor>();\n+        ThreadFactory factory1 = VThreadScheduler.virtualThreadFactory(scheduler1);\n+        ThreadFactory factory2 = VThreadScheduler.virtualThreadFactory(scheduler2);\n+        Thread thread1 = factory1.newThread(() -> {\n@@ -121,3 +123,5 @@\n-                ThreadBuilders.virtualThreadBuilder(scheduler2).start(() -> {\n-                    ref.set(scheduler(Thread.currentThread()));\n-                }).join();\n+                Thread thread2 = factory2.newThread(() -> {\n+                    ref.set(VThreadScheduler.scheduler(Thread.currentThread()));\n+                });\n+                thread2.start();\n+                thread2.join();\n@@ -127,1 +131,3 @@\n-        }).join();\n+        });\n+        thread1.start();\n+        thread1.join();\n@@ -152,2 +158,3 @@\n-\n-        ThreadBuilders.virtualThreadBuilder(scheduler).start(LockSupport::park);\n+        ThreadFactory factory = VThreadScheduler.virtualThreadFactory(scheduler);\n+        Thread thread = factory.newThread(LockSupport::park);\n+        thread.start();\n@@ -165,2 +172,2 @@\n-            var builder = ThreadBuilders.virtualThreadBuilder(Runnable::run);\n-            Thread vthread = builder.start(() -> {\n+            ThreadFactory factory = VThreadScheduler.virtualThreadFactory(Runnable::run);\n+            Thread vthread = factory.newThread(() -> {\n@@ -170,0 +177,1 @@\n+            vthread.start();\n@@ -186,2 +194,2 @@\n-            var builder = ThreadBuilders.virtualThreadBuilder(Runnable::run);\n-            Thread vthread = builder.start(() -> {\n+            ThreadFactory factory = VThreadScheduler.virtualThreadFactory(Runnable::run);\n+            Thread vthread = factory.newThread(() -> {\n@@ -190,0 +198,1 @@\n+            vthread.start();\n@@ -207,0 +216,1 @@\n+        ThreadFactory factory = VThreadScheduler.virtualThreadFactory(scheduler);\n@@ -209,1 +219,1 @@\n-            Thread vthread = ThreadBuilders.virtualThreadBuilder(scheduler).start(() -> {\n+            Thread vthread = factory.newThread(() -> {\n@@ -212,0 +222,1 @@\n+            vthread.start();\n@@ -219,1 +230,1 @@\n-     * Returns the scheduler for the given virtual thread.\n+     * Test custom scheduler throwing OOME when starting a thread.\n@@ -221,10 +232,52 @@\n-    private static Executor scheduler(Thread thread) {\n-        if (!thread.isVirtual())\n-            throw new IllegalArgumentException(\"Not a virtual thread\");\n-        try {\n-            Field scheduler = Class.forName(\"java.lang.VirtualThread\")\n-                    .getDeclaredField(\"scheduler\");\n-            scheduler.setAccessible(true);\n-            return (Executor) scheduler.get(thread);\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n+    @Test\n+    void testThreadStartOOME() throws Exception {\n+        Executor scheduler = task -> {\n+            System.err.println(\"OutOfMemoryError\");\n+            throw new OutOfMemoryError();\n+        };\n+        ThreadFactory factory = VThreadScheduler.virtualThreadFactory(scheduler);\n+        Thread thread = factory.newThread(() -> { });\n+        assertThrows(OutOfMemoryError.class, thread::start);\n+    }\n+\n+    \/**\n+     * Test custom scheduler throwing OOME when unparking a thread.\n+     *\/\n+    @Test\n+    void testThreadUnparkOOME() throws Exception {\n+        try (ExecutorService executor = Executors.newFixedThreadPool(1)) {\n+            AtomicInteger counter = new AtomicInteger();\n+            Executor scheduler = task -> {\n+                switch (counter.getAndIncrement()) {\n+                    case 0 -> executor.execute(task);             \/\/ Thread.start\n+                    case 1, 2 -> {                                \/\/ unpark attempt 1+2\n+                        System.err.println(\"OutOfMemoryError\");\n+                        throw new OutOfMemoryError();\n+                    }\n+                    default -> executor.execute(task);\n+                }\n+                executor.execute(task);\n+            };\n+\n+            \/\/ start thread and wait for it to park\n+            ThreadFactory factory = VThreadScheduler.virtualThreadFactory(scheduler);\n+            var thread = factory.newThread(LockSupport::park);\n+            thread.start();\n+            await(thread, Thread.State.WAITING);\n+\n+            \/\/ unpark thread, this should retry until OOME is not thrown\n+            LockSupport.unpark(thread);\n+            thread.join();\n+        }\n+\n+    }\n+\n+    \/**\n+     * Waits for the given thread to reach a given state.\n+     *\/\n+    private void await(Thread thread, Thread.State expectedState) throws InterruptedException {\n+        Thread.State state = thread.getState();\n+        while (state != expectedState) {\n+            assertTrue(state != Thread.State.TERMINATED, \"Thread has terminated\");\n+            Thread.sleep(10);\n+            state = thread.getState();\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/CustomScheduler.java","additions":97,"deletions":44,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -1,129 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @summary Test Thread.getStackTrace to examine the stack trace of a virtual\n- *     thread and its carrier\n- * @requires vm.continuations\n- * @modules java.base\/java.lang:+open\n- * @run main GetStackTrace\n- *\/\n-\n-import java.util.Objects;\n-import java.util.concurrent.BlockingQueue;\n-import java.util.concurrent.Executor;\n-import java.util.concurrent.LinkedTransferQueue;\n-import java.util.stream.Stream;\n-\n-public class GetStackTrace {\n-\n-    private static final Object LOCK = new Object();\n-\n-    public static void main(String[] args) throws Exception {\n-        try (var scheduler = new Scheduler()) {\n-            Thread vthread = scheduler.startVirtualThread(() -> {\n-                synchronized (LOCK) {\n-                    try {\n-                        LOCK.wait();\n-                    } catch (InterruptedException e) { }\n-                }\n-            });\n-\n-            try {\n-                \/\/ wait for virtual thread to wait\n-                while (vthread.getState() != Thread.State.WAITING) {\n-                    Thread.sleep(10);\n-                }\n-\n-                \/\/ bottom-most frame of virtual thread should be VirtualThread.run\n-                System.out.println(vthread);\n-                StackTraceElement[] vthreadStack = vthread.getStackTrace();\n-                Stream.of(vthreadStack).forEach(System.out::println);\n-                assertEquals(\"run\", vthreadStack[vthreadStack.length - 1].getMethodName());\n-\n-                System.out.println();\n-\n-                \/\/ top-most frame of carrier thread should be Continuation.run\n-                \/\/ bottom-most frame of carrier thread should be Thread.run\n-                var carrier = scheduler.thread();\n-                System.out.println(carrier);\n-                StackTraceElement[] carrierStack = carrier.getStackTrace();\n-                Stream.of(carrierStack).forEach(System.out::println);\n-                assertEquals(\"run\", carrierStack[0].getMethodName());\n-                assertEquals(\"run\", carrierStack[carrierStack.length - 1].getMethodName());\n-            } finally {\n-                vthread.interrupt();\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * A scheduler with one thread.\n-     *\/\n-    private static class Scheduler implements AutoCloseable, Executor {\n-        private final BlockingQueue<Runnable> tasks = new LinkedTransferQueue<>();\n-        private final Thread thread;\n-        private volatile boolean done;\n-\n-        Scheduler() {\n-            this.thread = Thread.ofPlatform().start(() -> {\n-                try {\n-                    while (!done) {\n-                        Runnable task = tasks.take();\n-                        task.run();\n-                    }\n-                } catch (InterruptedException e) { }\n-            });\n-        }\n-\n-        Thread thread() {\n-            return thread;\n-        }\n-\n-        @Override\n-        public void close() throws InterruptedException {\n-            done = true;\n-            thread.interrupt();\n-            thread.join();\n-        }\n-\n-        @Override\n-        public void execute(Runnable task) {\n-            tasks.add(task);\n-        }\n-\n-        Thread startVirtualThread(Runnable task) {\n-            return ThreadBuilders.virtualThreadBuilder(this).start(task);\n-        }\n-    }\n-\n-    private static void assertTrue(boolean e) {\n-        if (!e) throw new RuntimeException();\n-    }\n-\n-    private static void assertEquals(Object x, Object y) {\n-        if (!Objects.equals(x, y))\n-            throw new RuntimeException();\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/GetStackTrace.java","additions":0,"deletions":129,"binary":false,"changes":129,"status":"deleted"},{"patch":"@@ -1,85 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @summary Test Thread::getStackTrace on a virtual thread that is runnable-unmounted\n- * @requires vm.continuations\n- * @run main\/othervm -Djdk.virtualThreadScheduler.maxPoolSize=1 GetStackTraceWhenRunnable\n- *\/\n-\n-import java.io.IOException;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.locks.LockSupport;\n-\n-public class GetStackTraceWhenRunnable {\n-\n-    public static void main(String[] args) throws Exception {\n-\n-        \/\/ start thread1 and wait for it to park\n-        Thread thread1 = Thread.startVirtualThread(LockSupport::park);\n-        while (thread1.getState() != Thread.State.WAITING) {\n-            Thread.sleep(20);\n-        }\n-\n-        \/\/ start thread2 to pin the carrier thread\n-        var started = new AtomicBoolean();\n-        var done = new AtomicBoolean();\n-        Thread thread2 = Thread.startVirtualThread(() -> {\n-            started.set(true);\n-            while (!done.get()) {\n-                Thread.onSpinWait();\n-            }\n-        });\n-        try {\n-            \/\/ wait for thread2 to start\n-            while (!started.get()) {\n-                Thread.sleep(10);\n-            }\n-\n-            \/\/ unpark thread1 and check that it is \"stuck\" in the runnable state\n-            \/\/ (the carrier thread is pinned, no other virtual thread can run)\n-            LockSupport.unpark(thread1);\n-            for (int i = 0; i < 5; i++) {\n-                assertTrue(thread1.getState() == Thread.State.RUNNABLE);\n-                Thread.sleep(100);\n-            }\n-\n-            \/\/ print thread1's stack trace\n-            StackTraceElement[] stack = thread1.getStackTrace();\n-            assertTrue(stack.length > 0);\n-            for (StackTraceElement e : stack) {\n-                System.out.println(e);\n-            }\n-        } finally {\n-            done.set(true);\n-            thread2.join();\n-            thread1.join();\n-        }\n-    }\n-\n-    static void assertTrue(boolean e) {\n-        if (!e) throw new RuntimeException();\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/GetStackTraceWhenRunnable.java","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,0 @@\n-import java.util.concurrent.atomic.AtomicReference;\n@@ -45,1 +44,0 @@\n-import java.util.function.Consumer;\n@@ -55,1 +53,2 @@\n-import jdk.test.lib.thread.VThreadRunner.ThrowingRunnable;\n+import jdk.test.lib.thread.VThreadRunner;\n+import jdk.test.lib.thread.VThreadScheduler;\n@@ -57,0 +56,1 @@\n+import org.junit.jupiter.api.BeforeAll;\n@@ -58,2 +58,1 @@\n-import org.junit.jupiter.params.provider.Arguments;\n-import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n@@ -64,0 +63,9 @@\n+    @BeforeAll\n+    static void setup() {\n+        int minParallelism = 2;\n+        if (Thread.currentThread().isVirtual()) {\n+            minParallelism++;\n+        }\n+        VThreadRunner.ensureParallelism(minParallelism);\n+    }\n+\n@@ -96,50 +104,1 @@\n-     * Arguments for testVirtualThreadPinned to test jdk.VirtualThreadPinned event.\n-     *   [0] label\/description\n-     *   [1] the operation to park\/wait\n-     *   [2] the Thread.State when parked\/waiting\n-     *   [3] the action to unpark\/notify the thread\n-     *\/\n-    static Stream<Arguments> pinnedCases() {\n-        Object lock = new Object();\n-\n-        \/\/ park with native frame on stack\n-        var finish1 = new AtomicBoolean();\n-        var parkWhenPinned = Arguments.of(\n-            \"LockSupport.park when pinned\",\n-            (ThrowingRunnable<Exception>) () -> {\n-                VThreadPinner.runPinned(() -> {\n-                    while (!finish1.get()) {\n-                        LockSupport.park();\n-                    }\n-                });\n-            },\n-            Thread.State.WAITING,\n-                (Consumer<Thread>) t -> {\n-                    finish1.set(true);\n-                    LockSupport.unpark(t);\n-                }\n-        );\n-\n-        \/\/ timed park with native frame on stack\n-        var finish2 = new AtomicBoolean();\n-        var timedParkWhenPinned = Arguments.of(\n-            \"LockSupport.parkNanos when pinned\",\n-            (ThrowingRunnable<Exception>) () -> {\n-                VThreadPinner.runPinned(() -> {\n-                    while (!finish2.get()) {\n-                        LockSupport.parkNanos(Long.MAX_VALUE);\n-                    }\n-                });\n-            },\n-            Thread.State.TIMED_WAITING,\n-            (Consumer<Thread>) t -> {\n-                finish2.set(true);\n-                LockSupport.unpark(t);\n-            }\n-        );\n-\n-        return Stream.of(parkWhenPinned, timedParkWhenPinned);\n-    }\n-\n-    \/**\n-     * Test jdk.VirtualThreadPinned event.\n+     * Test jdk.VirtualThreadPinned event when parking while pinned.\n@@ -148,6 +107,2 @@\n-    @MethodSource(\"pinnedCases\")\n-    void testVirtualThreadPinned(String label,\n-                                 ThrowingRunnable<Exception> parker,\n-                                 Thread.State expectedState,\n-                                 Consumer<Thread> unparker) throws Exception {\n-\n+    @ValueSource(booleans = { true, false })\n+    void testParkWhenPinned(boolean timed) throws Exception {\n@@ -156,1 +111,0 @@\n-\n@@ -158,7 +112,12 @@\n-            try {\n-                var exception = new AtomicReference<Throwable>();\n-                var thread = Thread.ofVirtual().start(() -> {\n-                    try {\n-                        parker.run();\n-                    } catch (Throwable e) {\n-                        exception.set(e);\n+\n+            var started = new AtomicBoolean();\n+            var done = new AtomicBoolean();\n+            var vthread = Thread.startVirtualThread(() -> {\n+                VThreadPinner.runPinned(() -> {\n+                    started.set(true);\n+                    while (!done.get()) {\n+                        if (timed) {\n+                            LockSupport.parkNanos(Long.MAX_VALUE);\n+                        } else {\n+                            LockSupport.park();\n+                        }\n@@ -167,13 +126,6 @@\n-                try {\n-                    \/\/ wait for thread to park\/wait\n-                    Thread.State state = thread.getState();\n-                    while (state != expectedState) {\n-                        assertTrue(state != Thread.State.TERMINATED, thread.toString());\n-                        Thread.sleep(10);\n-                        state = thread.getState();\n-                    }\n-                } finally {\n-                    unparker.accept(thread);\n-                    thread.join();\n-                    assertNull(exception.get());\n-                }\n+            });\n+\n+            try {\n+                \/\/ wait for thread to start and park\n+                awaitTrue(started);\n+                await(vthread, timed ? Thread.State.TIMED_WAITING : Thread.State.WAITING);\n@@ -181,0 +133,3 @@\n+                done.set(true);\n+                LockSupport.unpark(vthread);\n+                vthread.join();\n@@ -184,6 +139,1 @@\n-            Map<String, Integer> events = sumEvents(recording);\n-            System.err.println(events);\n-\n-            \/\/ should have at least one pinned event\n-            int pinnedCount = events.getOrDefault(\"jdk.VirtualThreadPinned\", 0);\n-            assertTrue(pinnedCount >= 1, \"Expected one or more events\");\n+            assertContainsPinnedEvent(recording, vthread);\n@@ -206,1 +156,1 @@\n-                ThreadFactory factory = ThreadBuilders.virtualThreadBuilder(scheduler).factory();\n+                ThreadFactory factory = VThreadScheduler.virtualThreadFactory(scheduler);\n@@ -213,3 +163,1 @@\n-                while (thread.getState() != Thread.State.WAITING) {\n-                    Thread.sleep(10);\n-                }\n+                await(thread, Thread.State.WAITING);\n@@ -235,5 +183,3 @@\n-            Map<String, Integer> events = sumEvents(recording);\n-            System.err.println(events);\n-\n-            int count = events.getOrDefault(\"jdk.VirtualThreadSubmitFailed\", 0);\n-            assertEquals(2, count);\n+            List<RecordedEvent> submitFailedEvents = find(recording, \"jdk.VirtualThreadSubmitFailed\");\n+            System.err.println(submitFailedEvents);\n+            assertTrue(submitFailedEvents.size() == 2, \"Expected two events\");\n@@ -243,0 +189,11 @@\n+    \/**\n+     * Returns the list of events in the given recording with the given name.\n+     *\/\n+    private static List<RecordedEvent> find(Recording recording, String name) throws IOException {\n+        Path recordingFile = recordingFile(recording);\n+        return RecordingFile.readAllEvents(recordingFile)\n+                .stream()\n+                .filter(e -> e.getEventType().getName().equals(name))\n+                .toList();\n+    }\n+\n@@ -267,0 +224,34 @@\n+\n+    \/**\n+     * Assert that a recording contains a jdk.VirtualThreadPinned event on the given thread.\n+     *\/\n+    private void assertContainsPinnedEvent(Recording recording, Thread thread) throws IOException {\n+        List<RecordedEvent> pinnedEvents = find(recording, \"jdk.VirtualThreadPinned\");\n+        assertTrue(pinnedEvents.size() > 0, \"No jdk.VirtualThreadPinned events in recording\");\n+        System.err.println(pinnedEvents);\n+\n+        long tid = thread.threadId();\n+        assertTrue(pinnedEvents.stream()\n+                        .anyMatch(e -> e.getThread().getJavaThreadId() == tid),\n+                \"jdk.VirtualThreadPinned for javaThreadId = \" + tid + \" not found\");\n+    }\n+\n+    \/**\n+     * Waits for the given boolean to be set to true.\n+     *\/\n+    private void awaitTrue(AtomicBoolean b) throws InterruptedException {\n+        while (!b.get()) {\n+            Thread.sleep(10);\n+        }\n+    }\n+\n+    \/**\n+     * Waits for the given thread to reach a given state.\n+     *\/\n+    private static void await(Thread thread, Thread.State expectedState) throws InterruptedException {\n+        Thread.State state = thread.getState();\n+        while (state != expectedState) {\n+            Thread.sleep(10);\n+            state = thread.getState();\n+        }\n+    }\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/JfrEvents.java","additions":89,"deletions":98,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -0,0 +1,410 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=default\n+ * @summary Test virtual thread with monitor enter\/exit\n+ * @modules java.base\/java.lang:+open\n+ * @library \/test\/lib\n+ * @run junit\/othervm --enable-native-access=ALL-UNNAMED MonitorEnterExit\n+ *\/\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.LockSupport;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import jdk.test.lib.thread.VThreadPinner;\n+import jdk.test.lib.thread.VThreadRunner;\n+import jdk.test.lib.thread.VThreadScheduler;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.RepeatedTest;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.api.condition.*;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assumptions.*;\n+\n+class MonitorEnterExit {\n+    static final int MAX_ENTER_DEPTH = 256;\n+\n+    @BeforeAll\n+    static void setup() {\n+        \/\/ need >=2 carriers for testing pinning when main thread is a virtual thread\n+        if (Thread.currentThread().isVirtual()) {\n+            VThreadRunner.ensureParallelism(2);\n+        }\n+    }\n+\n+    \/**\n+     * Test monitor enter with no contention.\n+     *\/\n+    @Test\n+    void testEnterNoContention() throws Exception {\n+        var lock = new Object();\n+        VThreadRunner.run(() -> {\n+            synchronized (lock) {\n+                assertTrue(Thread.holdsLock(lock));\n+            }\n+            assertFalse(Thread.holdsLock(lock));\n+        });\n+    }\n+\n+    \/**\n+     * Test monitor enter with contention, monitor is held by platform thread.\n+     *\/\n+    @Test\n+    void testEnterWhenHeldByPlatformThread() throws Exception {\n+        testEnterWithContention();\n+    }\n+\n+    \/**\n+     * Test monitor enter with contention, monitor is held by virtual thread.\n+     *\/\n+    @Test\n+    void testEnterWhenHeldByVirtualThread() throws Exception {\n+        VThreadRunner.run(this::testEnterWithContention);\n+    }\n+\n+    \/**\n+     * Test monitor enter with contention, monitor will be held by caller thread.\n+     *\/\n+    private void testEnterWithContention() throws Exception {\n+        var lock = new Object();\n+        var started = new CountDownLatch(1);\n+        var entered = new AtomicBoolean();\n+        var vthread = Thread.ofVirtual().unstarted(() -> {\n+            started.countDown();\n+            synchronized (lock) {\n+                assertTrue(Thread.holdsLock(lock));\n+                entered.set(true);\n+            }\n+            assertFalse(Thread.holdsLock(lock));\n+        });\n+        try {\n+            synchronized (lock) {\n+                vthread.start();\n+\n+                \/\/ wait for thread to start and block\n+                started.await();\n+                await(vthread, Thread.State.BLOCKED);\n+\n+                assertFalse(entered.get());\n+            }\n+        } finally {\n+            vthread.join();\n+        }\n+        assertTrue(entered.get());\n+    }\n+\n+    \/**\n+     * Test monitor reenter.\n+     *\/\n+    @Test\n+    void testReenter() throws Exception {\n+        var lock = new Object();\n+        VThreadRunner.run(() -> {\n+            testReenter(lock, 0);\n+            assertFalse(Thread.holdsLock(lock));\n+        });\n+    }\n+\n+    private void testReenter(Object lock, int depth) {\n+        if (depth < MAX_ENTER_DEPTH) {\n+            synchronized (lock) {\n+                assertTrue(Thread.holdsLock(lock));\n+                testReenter(lock, depth + 1);\n+                assertTrue(Thread.holdsLock(lock));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test monitor enter when pinned.\n+     *\/\n+    @Test\n+    void testEnterWhenPinned() throws Exception {\n+        var lock = new Object();\n+        VThreadPinner.runPinned(() -> {\n+            synchronized (lock) {\n+                assertTrue(Thread.holdsLock(lock));\n+            }\n+            assertFalse(Thread.holdsLock(lock));\n+        });\n+    }\n+\n+    \/**\n+     * Test monitor reenter when pinned.\n+     *\/\n+    @Test\n+    void testReenterWhenPinned() throws Exception {\n+        VThreadRunner.run(() -> {\n+            var lock = new Object();\n+            synchronized (lock) {\n+                VThreadPinner.runPinned(() -> {\n+                    assertTrue(Thread.holdsLock(lock));\n+                    synchronized (lock) {\n+                        assertTrue(Thread.holdsLock(lock));\n+                    }\n+                    assertTrue(Thread.holdsLock(lock));\n+                });\n+            }\n+            assertFalse(Thread.holdsLock(lock));\n+        });\n+    }\n+\n+    \/**\n+     * Test contended monitor enter when pinned. Monitor is held by platform thread.\n+     *\/\n+    @Test\n+    void testContendedEnterWhenPinnedHeldByPlatformThread() throws Exception {\n+        testEnterWithContentionWhenPinned();\n+    }\n+\n+    \/**\n+     * Test contended monitor enter when pinned. Monitor is held by virtual thread.\n+     *\/\n+    @Test\n+    void testContendedEnterWhenPinnedHeldByVirtualThread() throws Exception {\n+        \/\/ need at least two carrier threads\n+        int previousParallelism = VThreadRunner.ensureParallelism(2);\n+        try {\n+            VThreadRunner.run(this::testEnterWithContentionWhenPinned);\n+        } finally {\n+            VThreadRunner.setParallelism(previousParallelism);\n+        }\n+    }\n+\n+    \/**\n+     * Test contended monitor enter when pinned, monitor will be held by caller thread.\n+     *\/\n+    private void testEnterWithContentionWhenPinned() throws Exception {\n+        var lock = new Object();\n+        var started = new CountDownLatch(1);\n+        var entered = new AtomicBoolean();\n+        Thread vthread = Thread.ofVirtual().unstarted(() -> {\n+            VThreadPinner.runPinned(() -> {\n+                started.countDown();\n+                synchronized (lock) {\n+                    entered.set(true);\n+                }\n+            });\n+        });\n+        synchronized (lock) {\n+            \/\/ start thread and wait for it to block\n+            vthread.start();\n+            started.await();\n+            await(vthread, Thread.State.BLOCKED);\n+            assertFalse(entered.get());\n+        }\n+        vthread.join();\n+\n+        \/\/ check thread entered monitor\n+        assertTrue(entered.get());\n+    }\n+\n+    \/**\n+     * Returns a stream of elements that are ordered pairs of platform and virtual thread\n+     * counts. 0,2,4,..16 platform threads. 2,4,6,..32 virtual threads.\n+     *\/\n+    static Stream<Arguments> threadCounts() {\n+        return IntStream.range(0, 17)\n+                .filter(i -> i % 2 == 0)\n+                .mapToObj(i -> i)\n+                .flatMap(np -> IntStream.range(2, 33)\n+                        .filter(i -> i % 2 == 0)\n+                        .mapToObj(vp -> Arguments.of(np, vp)));\n+    }\n+\n+    \/**\n+     * Test mutual exclusion of monitors with platform and virtual threads.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"threadCounts\")\n+    void testMutualExclusion(int nPlatformThreads, int nVirtualThreads) throws Exception {\n+        class Counter {\n+            int count;\n+            synchronized void increment() {\n+                count++;\n+                Thread.yield();\n+            }\n+        }\n+        var counter = new Counter();\n+        int nThreads = nPlatformThreads + nVirtualThreads;\n+        var threads = new Thread[nThreads];\n+        int index = 0;\n+        for (int i = 0; i < nPlatformThreads; i++) {\n+            threads[index] = Thread.ofPlatform()\n+                    .name(\"platform-\" + index)\n+                    .unstarted(counter::increment);\n+            index++;\n+        }\n+        for (int i = 0; i < nVirtualThreads; i++) {\n+            threads[index] = Thread.ofVirtual()\n+                    .name(\"virtual-\" + index)\n+                    .unstarted(counter::increment);\n+            index++;\n+        }\n+        \/\/ start all threads\n+        for (Thread thread : threads) {\n+            thread.start();\n+        }\n+        \/\/ wait for all threads to terminate\n+        for (Thread thread : threads) {\n+            thread.join();\n+        }\n+        assertEquals(nThreads, counter.count);\n+    }\n+\n+    \/**\n+     * Test unblocking a virtual thread waiting to enter a monitor held by a platform thread.\n+     *\/\n+    @RepeatedTest(20)\n+    void testUnblockingByPlatformThread() throws Exception {\n+        testUnblocking();\n+    }\n+\n+    \/**\n+     * Test unblocking a virtual thread waiting to enter a monitor held by another\n+     * virtual thread.\n+     *\/\n+    @RepeatedTest(20)\n+    void testUnblockingByVirtualThread() throws Exception {\n+        VThreadRunner.run(this::testUnblocking);\n+    }\n+\n+    \/**\n+     * Test unblocking a virtual thread waiting to enter a monitor, monitor will be\n+     * initially be held by caller thread.\n+     *\/\n+    private void testUnblocking() throws Exception {\n+        var lock = new Object();\n+        var started = new CountDownLatch(1);\n+        var entered = new AtomicBoolean();\n+        var vthread = Thread.ofVirtual().unstarted(() -> {\n+            started.countDown();\n+            synchronized (lock) {\n+                entered.set(true);\n+            }\n+        });\n+        try {\n+            synchronized (lock) {\n+                vthread.start();\n+                started.await();\n+\n+                \/\/ random delay before exiting monitor\n+                switch (ThreadLocalRandom.current().nextInt(4)) {\n+                    case 0 -> { \/* no delay *\/}\n+                    case 1 -> Thread.onSpinWait();\n+                    case 2 -> Thread.yield();\n+                    case 3 -> await(vthread, Thread.State.BLOCKED);\n+                    default -> fail();\n+                }\n+\n+                assertFalse(entered.get());\n+            }\n+        } finally {\n+            vthread.join();\n+        }\n+        assertTrue(entered.get());\n+    }\n+\n+    \/**\n+     * Test that unblocking a virtual thread waiting to enter a monitor does not consume\n+     * the thread's parking permit.\n+     *\/\n+    @Test\n+    void testParkingPermitNotConsumed() throws Exception {\n+        var lock = new Object();\n+        var started = new CountDownLatch(1);\n+        var vthread = Thread.ofVirtual().unstarted(() -> {\n+            started.countDown();\n+            LockSupport.unpark(Thread.currentThread());\n+            synchronized (lock) { }  \/\/ should block\n+            LockSupport.park();      \/\/ should not park\n+        });\n+\n+        synchronized (lock) {\n+            vthread.start();\n+            \/\/ wait for thread to start and block\n+            started.await();\n+            await(vthread, Thread.State.BLOCKED);\n+        }\n+        vthread.join();\n+    }\n+\n+    \/**\n+     * Test that unblocking a virtual thread waiting to enter a monitor does not make\n+     * available the thread's parking permit.\n+     *\/\n+    @Test\n+    void testParkingPermitNotOffered() throws Exception {\n+        var lock = new Object();\n+        var started = new CountDownLatch(1);\n+        var vthread = Thread.ofVirtual().unstarted(() -> {\n+            started.countDown();\n+            synchronized (lock) { }  \/\/ should block\n+            LockSupport.park();      \/\/ should park\n+        });\n+\n+        synchronized (lock) {\n+            vthread.start();\n+            \/\/ wait for thread to start and block\n+            started.await();\n+            await(vthread, Thread.State.BLOCKED);\n+        }\n+\n+        try {\n+            \/\/ wait for thread to park, it should not terminate\n+            await(vthread, Thread.State.WAITING);\n+            vthread.join(Duration.ofMillis(100));\n+            assertEquals(Thread.State.WAITING, vthread.getState());\n+        } finally {\n+            LockSupport.unpark(vthread);\n+            vthread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Waits for the given thread to reach a given state.\n+     *\/\n+    private void await(Thread thread, Thread.State expectedState) throws InterruptedException {\n+        Thread.State state = thread.getState();\n+        while (state != expectedState) {\n+            assertTrue(state != Thread.State.TERMINATED, \"Thread has terminated\");\n+            Thread.sleep(10);\n+            state = thread.getState();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/MonitorEnterExit.java","additions":410,"deletions":0,"binary":false,"changes":410,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +24,2 @@\n-\/**\n- * @test\n+\/*\n+ * @test id=default\n@@ -29,1 +29,1 @@\n- * @run junit MonitorWaitNotify\n+ * @run junit\/othervm --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n@@ -32,1 +32,15 @@\n-import java.util.concurrent.Semaphore;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.LockSupport;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+import java.util.stream.Collectors;\n@@ -34,0 +48,2 @@\n+import jdk.test.lib.thread.VThreadScheduler;\n+import jdk.test.lib.thread.VThreadRunner;\n@@ -35,0 +51,1 @@\n+import jdk.test.lib.thread.VThreadPinner;\n@@ -36,0 +53,3 @@\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n@@ -37,0 +57,1 @@\n+import static org.junit.jupiter.api.Assumptions.*;\n@@ -40,0 +61,6 @@\n+    @BeforeAll\n+    static void setup() {\n+        \/\/ need >=2 carriers for testing pinning\n+        VThreadRunner.ensureParallelism(2);\n+    }\n+\n@@ -43,2 +70,3 @@\n-    @Test\n-    void testWaitNotify1() throws Exception {\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testWaitNotify1(boolean pinned) throws Exception {\n@@ -46,1 +74,1 @@\n-        var ready = new Semaphore(0);\n+        var ready = new AtomicBoolean();\n@@ -49,1 +77,0 @@\n-                ready.release();\n@@ -51,1 +78,9 @@\n-                    lock.wait();\n+                    if (pinned) {\n+                        VThreadPinner.runPinned(() -> {\n+                            ready.set(true);\n+                            lock.wait();\n+                        });\n+                    } else {\n+                        ready.set(true);\n+                        lock.wait();\n+                    }\n@@ -55,2 +90,3 @@\n-        \/\/ thread invokes notify\n-        ready.acquire();\n+        awaitTrue(ready);\n+\n+        \/\/ notify, thread should block waiting to reenter\n@@ -59,0 +95,1 @@\n+            await(thread, Thread.State.BLOCKED);\n@@ -69,3 +106,1 @@\n-        var ready = new Semaphore(0);\n-        var thread = Thread.ofVirtual().start(() -> {\n-            ready.acquireUninterruptibly();\n+        var thread = Thread.ofVirtual().unstarted(() -> {\n@@ -77,1 +112,1 @@\n-            ready.release();\n+            thread.start();\n@@ -86,11 +121,15 @@\n-    @Test\n-    void testWaitNotify3() throws Exception {\n-        \/\/ need at least two carrier threads due to pinning\n-        int previousParallelism = VThreadRunner.ensureParallelism(2);\n-        try {\n-            var lock = new Object();\n-            var ready = new Semaphore(0);\n-            var thread1 = Thread.ofVirtual().start(() -> {\n-                synchronized (lock) {\n-                    ready.release();\n-                    try {\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testWaitNotify3(boolean pinned) throws Exception {\n+        var lock = new Object();\n+        var ready = new AtomicBoolean();\n+        var thread1 = Thread.ofVirtual().start(() -> {\n+            synchronized (lock) {\n+                try {\n+                    if (pinned) {\n+                        VThreadPinner.runPinned(() -> {\n+                            ready.set(true);\n+                            lock.wait();\n+                        });\n+                    } else {\n+                        ready.set(true);\n@@ -98,1 +137,3 @@\n-                    } catch (InterruptedException e) { }\n+                    }\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n@@ -100,3 +141,7 @@\n-            });\n-            var thread2 = Thread.ofVirtual().start(() -> {\n-                ready.acquireUninterruptibly();\n+            }\n+        });\n+        var thread2 = Thread.ofVirtual().start(() -> {\n+            try {\n+                awaitTrue(ready);\n+\n+                \/\/ notify, thread should block waiting to reenter\n@@ -105,0 +150,1 @@\n+                    await(thread1, Thread.State.BLOCKED);\n@@ -106,3 +152,48 @@\n-            });\n-            thread1.join();\n-            thread2.join();\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        });\n+        thread1.join();\n+        thread2.join();\n+    }\n+\n+    \/**\n+     * Test notifyAll when there are no threads waiting.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(ints = { 0, 30000, Integer.MAX_VALUE })\n+    void testNotifyBeforeWait(int timeout) throws Exception {\n+        var lock = new Object();\n+\n+        \/\/ no threads waiting\n+        synchronized (lock) {\n+            lock.notifyAll();\n+        }\n+\n+        var ready = new AtomicBoolean();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            try {\n+                synchronized (lock) {\n+                    ready.set(true);\n+\n+                    \/\/ thread should wait\n+                    if (timeout > 0) {\n+                        lock.wait(timeout);\n+                    } else {\n+                        lock.wait();\n+                    }\n+                }\n+            } catch (InterruptedException e) { }\n+        });\n+\n+        try {\n+            \/\/ wait for thread to start and wait\n+            awaitTrue(ready);\n+            Thread.State expectedState = timeout > 0\n+                    ? Thread.State.TIMED_WAITING\n+                    : Thread.State.WAITING;\n+            await(thread, expectedState);\n+\n+            \/\/ poll thread state again, it should still be waiting\n+            Thread.sleep(10);\n+            assertEquals(thread.getState(), expectedState);\n@@ -110,2 +201,4 @@\n-            \/\/ restore\n-            VThreadRunner.setParallelism(previousParallelism);\n+            synchronized (lock) {\n+                lock.notifyAll();\n+            }\n+            thread.join();\n@@ -114,0 +207,23 @@\n+    \/**\n+     * Test duration of timed Object.wait.\n+     *\/\n+    @Test\n+    void testTimedWaitDuration1() throws Exception {\n+        var lock = new Object();\n+\n+        var durationRef = new AtomicReference<Long>();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            try {\n+                synchronized (lock) {\n+                    long start = millisTime();\n+                    lock.wait(2000);\n+                    durationRef.set(millisTime() - start);\n+                }\n+            } catch (InterruptedException e) { }\n+        });\n+\n+        thread.join();\n+\n+        long duration = durationRef.get();\n+        checkDuration(duration, 1900, 20_000);\n+    }\n@@ -116,1 +232,3 @@\n-     * Test interrupt status set when calling Object.wait.\n+     * Test duration of timed Object.wait. This test invokes wait twice, first with a short\n+     * timeout, the second with a longer timeout. The test scenario ensures that the\n+     * timeout from the first wait doesn't interfere with the second wait.\n@@ -119,1 +237,40 @@\n-    void testWaitNotify4() throws Exception {\n+    void testTimedWaitDuration2() throws Exception {\n+        var lock = new Object();\n+\n+        var ready = new AtomicBoolean();\n+        var waited = new AtomicBoolean();\n+        var durationRef = new AtomicReference<Long>();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            try {\n+                synchronized (lock) {\n+                    ready.set(true);\n+                    lock.wait(200);\n+                    waited.set(true);\n+\n+                    long start = millisTime();\n+                    lock.wait(2000);\n+                    durationRef.set(millisTime() - start);\n+                }\n+            } catch (InterruptedException e) { }\n+        });\n+\n+        awaitTrue(ready);\n+        synchronized (lock) {\n+            \/\/ wake thread if waiting in first wait\n+            if (!waited.get()) {\n+                lock.notifyAll();\n+            }\n+        }\n+\n+        thread.join();\n+\n+        long duration = durationRef.get();\n+        checkDuration(duration, 1900, 20_000);\n+    }\n+\n+    \/**\n+     * Testing invoking Object.wait with interrupt status set.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(ints = { 0, 30000, Integer.MAX_VALUE })\n+    void testWaitWithInterruptSet(int timeout) throws Exception {\n@@ -121,2 +278,0 @@\n-            Thread t = Thread.currentThread();\n-            t.interrupt();\n@@ -124,0 +279,146 @@\n+            synchronized (lock) {\n+                Thread.currentThread().interrupt();\n+                if (timeout > 0) {\n+                    assertThrows(InterruptedException.class, () -> lock.wait(timeout));\n+                } else {\n+                    assertThrows(InterruptedException.class, lock::wait);\n+                }\n+                assertFalse(Thread.currentThread().isInterrupted());\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Test interrupting a virtual thread waiting in Object.wait.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(ints = { 0, 30000, Integer.MAX_VALUE })\n+    void testInterruptWait(int timeout) throws Exception {\n+        var lock = new Object();\n+        var ready = new AtomicBoolean();\n+        var interruptedException = new AtomicBoolean();\n+        var vthread = Thread.ofVirtual().start(() -> {\n+            synchronized (lock) {\n+                try {\n+                    ready.set(true);\n+                    if (timeout > 0) {\n+                        lock.wait(timeout);\n+                    } else {\n+                        lock.wait();\n+                    }\n+                } catch (InterruptedException e) {\n+                    \/\/ check stack trace has the expected frames\n+                    Set<String> expected = Set.of(\"wait0\", \"wait\", \"run\");\n+                    Set<String> methods = Stream.of(e.getStackTrace())\n+                            .map(StackTraceElement::getMethodName)\n+                            .collect(Collectors.toSet());\n+                    assertTrue(methods.containsAll(expected));\n+\n+                    interruptedException.set(true);\n+                }\n+            }\n+        });\n+\n+        \/\/ wait for thread to start and wait\n+        awaitTrue(ready);\n+        await(vthread, timeout > 0 ? Thread.State.TIMED_WAITING : Thread.State.WAITING);\n+\n+        \/\/ interrupt thread, should block, then throw InterruptedException\n+        synchronized (lock) {\n+            vthread.interrupt();\n+            await(vthread, Thread.State.BLOCKED);\n+        }\n+        vthread.join();\n+        assertTrue(interruptedException.get());\n+    }\n+\n+    \/**\n+     * Test interrupting a virtual thread blocked waiting to reenter after waiting.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(ints = { 0, 30000, Integer.MAX_VALUE })\n+    void testInterruptReenterAfterWait(int timeout) throws Exception {\n+        var lock = new Object();\n+        var ready = new AtomicBoolean();\n+        var interruptedException = new AtomicBoolean();\n+        var vthread = Thread.ofVirtual().start(() -> {\n+            synchronized (lock) {\n+                try {\n+                    ready.set(true);\n+                    if (timeout > 0) {\n+                        lock.wait(timeout);\n+                    } else {\n+                        lock.wait();\n+                    }\n+                } catch (InterruptedException e) {\n+                    interruptedException.set(true);\n+                }\n+            }\n+        });\n+\n+        \/\/ wait for thread to start and wait\n+        awaitTrue(ready);\n+        await(vthread, timeout > 0 ? Thread.State.TIMED_WAITING : Thread.State.WAITING);\n+\n+        \/\/ notify, thread should block waiting to reenter\n+        synchronized (lock) {\n+            lock.notifyAll();\n+            await(vthread, Thread.State.BLOCKED);\n+\n+            \/\/ interrupt when blocked\n+            vthread.interrupt();\n+        }\n+\n+        vthread.join();\n+        assertFalse(interruptedException.get());\n+        assertTrue(vthread.isInterrupted());\n+    }\n+\n+    \/**\n+     * Test Object.wait when the monitor entry count > 1.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(ints = { 0, 30000, Integer.MAX_VALUE })\n+    void testWaitWhenEnteredManyTimes(int timeout) throws Exception {\n+        var lock = new Object();\n+        var ready = new AtomicBoolean();\n+        var vthread = Thread.ofVirtual().start(() -> {\n+            synchronized (lock) {\n+                synchronized (lock) {\n+                    synchronized (lock) {\n+                        try {\n+                            ready.set(true);\n+                            if (timeout > 0) {\n+                                lock.wait(timeout);\n+                            } else {\n+                                lock.wait();\n+                            }\n+                        } catch (InterruptedException e) { }\n+                    }\n+                }\n+            }\n+        });\n+\n+        \/\/ wait for thread to start and wait\n+        awaitTrue(ready);\n+        await(vthread, timeout > 0 ? Thread.State.TIMED_WAITING : Thread.State.WAITING);\n+\n+        \/\/ notify, thread should block waiting to reenter\n+        synchronized (lock) {\n+            lock.notifyAll();\n+            await(vthread, Thread.State.BLOCKED);\n+        }\n+        vthread.join();\n+    }\n+\n+    \/**\n+     * Test that Object.wait does not consume the thread's parking permit.\n+     *\/\n+    @Test\n+    void testParkingPermitNotConsumed() throws Exception {\n+        var lock = new Object();\n+        var started = new CountDownLatch(1);\n+        var completed = new AtomicBoolean();\n+        var vthread = Thread.ofVirtual().start(() -> {\n+            started.countDown();\n+            LockSupport.unpark(Thread.currentThread());\n@@ -127,1 +428,0 @@\n-                    fail();\n@@ -129,2 +429,1 @@\n-                    \/\/ interrupt status should be cleared\n-                    assertFalse(t.isInterrupted());\n+                    fail(\"wait interrupted\");\n@@ -133,0 +432,2 @@\n+            LockSupport.park();      \/\/ should not park\n+            completed.set(true);\n@@ -134,0 +435,13 @@\n+\n+        \/\/ wait for thread to start and wait\n+        started.await();\n+        await(vthread, Thread.State.WAITING);\n+\n+        \/\/ wakeup thread\n+        synchronized (lock) {\n+            lock.notifyAll();\n+        }\n+\n+        \/\/ thread should terminate\n+        vthread.join();\n+        assertTrue(completed.get());\n@@ -137,1 +451,1 @@\n-     * Test interrupt when blocked in Object.wait.\n+     * Test that Object.wait does not make available the thread's parking permit.\n@@ -140,5 +454,7 @@\n-    void testWaitNotify5() throws Exception {\n-        VThreadRunner.run(() -> {\n-            Thread t = Thread.currentThread();\n-            scheduleInterrupt(t, 1000);\n-            Object lock = new Object();\n+    void testParkingPermitNotOffered() throws Exception {\n+        var lock = new Object();\n+        var started = new CountDownLatch(1);\n+        var readyToPark = new CountDownLatch(1);\n+        var completed = new AtomicBoolean();\n+        var vthread = Thread.ofVirtual().start(() -> {\n+            started.countDown();\n@@ -148,1 +464,0 @@\n-                    fail();\n@@ -150,2 +465,1 @@\n-                    \/\/ interrupt status should be cleared\n-                    assertFalse(t.isInterrupted());\n+                    fail(\"wait interrupted\");\n@@ -154,0 +468,3 @@\n+            readyToPark.countDown();\n+            LockSupport.park();      \/\/ should park\n+            completed.set(true);\n@@ -155,0 +472,19 @@\n+\n+        \/\/ wait for thread to start and wait\n+        started.await();\n+        await(vthread, Thread.State.WAITING);\n+\n+        \/\/ wakeup thread\n+        synchronized (lock) {\n+            lock.notifyAll();\n+        }\n+\n+        \/\/ thread should park\n+        readyToPark.await();\n+        await(vthread, Thread.State.WAITING);\n+\n+        LockSupport.unpark(vthread);\n+\n+        \/\/ thread should terminate\n+        vthread.join();\n+        assertTrue(completed.get());\n@@ -158,1 +494,1 @@\n-     * Schedule a thread to be interrupted after a delay.\n+     * Test that wait(long) throws IAE when timeout is negative.\n@@ -160,7 +496,8 @@\n-    private static void scheduleInterrupt(Thread thread, long delay) {\n-        Runnable interruptTask = () -> {\n-            try {\n-                Thread.sleep(delay);\n-                thread.interrupt();\n-            } catch (Exception e) {\n-                e.printStackTrace();\n+    @Test\n+    void testIllegalArgumentException() throws Exception {\n+        VThreadRunner.run(() -> {\n+            Object obj = new Object();\n+            synchronized (obj) {\n+                assertThrows(IllegalArgumentException.class, () -> obj.wait(-1L));\n+                assertThrows(IllegalArgumentException.class, () -> obj.wait(-1000L));\n+                assertThrows(IllegalArgumentException.class, () -> obj.wait(Long.MIN_VALUE));\n@@ -168,2 +505,58 @@\n-        };\n-        new Thread(interruptTask).start();\n+        });\n+    }\n+\n+    \/**\n+     * Test that wait throws IMSE when not owner.\n+     *\/\n+    @Test\n+    void testIllegalMonitorStateException() throws Exception {\n+        VThreadRunner.run(() -> {\n+            Object obj = new Object();\n+            assertThrows(IllegalMonitorStateException.class, () -> obj.wait());\n+            assertThrows(IllegalMonitorStateException.class, () -> obj.wait(0));\n+            assertThrows(IllegalMonitorStateException.class, () -> obj.wait(1000));\n+            assertThrows(IllegalMonitorStateException.class, () -> obj.wait(Long.MAX_VALUE));\n+        });\n+    }\n+\n+    \/**\n+     * Waits for the boolean value to become true.\n+     *\/\n+    private static void awaitTrue(AtomicBoolean ref) throws InterruptedException {\n+        while (!ref.get()) {\n+            Thread.sleep(20);\n+        }\n+    }\n+\n+    \/**\n+     * Waits for the given thread to reach a given state.\n+     *\/\n+    private void await(Thread thread, Thread.State expectedState) throws InterruptedException {\n+        Thread.State state = thread.getState();\n+        while (state != expectedState) {\n+            assertTrue(state != Thread.State.TERMINATED, \"Thread has terminated\");\n+            Thread.sleep(10);\n+            state = thread.getState();\n+        }\n+    }\n+\n+    \/**\n+     * Returns the current time in milliseconds.\n+     *\/\n+    private static long millisTime() {\n+        long now = System.nanoTime();\n+        return TimeUnit.MILLISECONDS.convert(now, TimeUnit.NANOSECONDS);\n+    }\n+\n+    \/**\n+     * Check a duration is within expected bounds.\n+     * @param duration, in milliseconds\n+     * @param min minimum expected duration, in milliseconds\n+     * @param max maximum expected duration, in milliseconds\n+     * @return the duration (now - start), in milliseconds\n+     *\/\n+    private static void checkDuration(long duration, long min, long max) {\n+        assertTrue(duration >= min,\n+                \"Duration \" + duration + \"ms, expected >= \" + min + \"ms\");\n+        assertTrue(duration <= max,\n+                \"Duration \" + duration + \"ms, expected <= \" + max + \"ms\");\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/MonitorWaitNotify.java","additions":455,"deletions":62,"binary":false,"changes":517,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @library \/test\/lib\n@@ -35,0 +36,1 @@\n+import jdk.test.lib.thread.VThreadScheduler;\n@@ -61,3 +63,1 @@\n-            ThreadFactory factory = ThreadBuilders.virtualThreadBuilder(scheduler)\n-                    .name(\"vthread-\", 0)\n-                    .factory();\n+            ThreadFactory factory = VThreadScheduler.virtualThreadFactory(scheduler);\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ParkWithFixedThreadPool.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import jdk.test.lib.thread.VThreadScheduler;\n@@ -145,1 +146,1 @@\n-        assumeTrue(ThreadBuilders.supportsCustomScheduler(), \"No support for custom schedulers\");\n+        assumeTrue(VThreadScheduler.supportsCustomScheduler(), \"No support for custom schedulers\");\n@@ -148,2 +149,1 @@\n-            Thread.Builder builder = ThreadBuilders.virtualThreadBuilder(scheduler);\n-            ThreadFactory factory = builder.factory();\n+            ThreadFactory factory = VThreadScheduler.virtualThreadFactory(scheduler);\n@@ -324,1 +324,1 @@\n-        assumeTrue(ThreadBuilders.supportsCustomScheduler(), \"No support for custom schedulers\");\n+        assumeTrue(VThreadScheduler.supportsCustomScheduler(), \"No support for custom schedulers\");\n@@ -327,2 +327,1 @@\n-            Thread.Builder builder = ThreadBuilders.virtualThreadBuilder(scheduler);\n-            ThreadFactory factory = builder.factory();\n+            ThreadFactory factory = VThreadScheduler.virtualThreadFactory(scheduler);\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/Reflection.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Test stack traces in exceptions, stack frames walked by the StackWalker,\n+ *    and the stack trace returned by Thread.getStackTrace\n+ * @requires vm.continuations\n+ * @modules java.base\/java.lang:+open java.management\n+ * @library \/test\/lib\n+ * @run junit StackFrames\n+ * @run junit\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+ShowCarrierFrames StackFrames\n+ *\/\n+\n+import java.lang.management.ManagementFactory;\n+import java.util.Arrays;\n+import java.util.Set;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.ForkJoinWorkerThread;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Stream;\n+import static java.lang.StackWalker.Option.*;\n+\n+import jdk.test.lib.thread.VThreadRunner;\n+import jdk.test.lib.thread.VThreadScheduler;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class StackFrames {\n+\n+    \/**\n+     * Test that the stack trace in exceptions does not include the carrier thread\n+     * frames, except when running with -XX:+ShowCarrierFrames.\n+     *\/\n+    @Test\n+    void testStackTraceException() throws Exception {\n+        VThreadRunner.run(() -> {\n+            Exception e = new Exception();\n+            boolean found = Arrays.stream(e.getStackTrace())\n+                    .map(StackTraceElement::getClassName)\n+                    .anyMatch(\"java.util.concurrent.ForkJoinPool\"::equals);\n+            assertTrue(found == hasJvmArgument(\"-XX:+ShowCarrierFrames\"));\n+        });\n+    }\n+\n+    \/**\n+     * Test that StackWalker does not include carrier thread frames in the stream of\n+     * stack frames.\n+     *\/\n+    @Test\n+    void testStackWalker() throws Exception {\n+        VThreadRunner.run(() -> {\n+            StackWalker walker = StackWalker.getInstance(Set.of(RETAIN_CLASS_REFERENCE));\n+            boolean found = walker.walk(sf ->\n+                    sf.map(StackWalker.StackFrame::getDeclaringClass)\n+                            .anyMatch(c -> c == ForkJoinPool.class));\n+            assertFalse(found);\n+        });\n+    }\n+\n+    \/**\n+     * Test Thread.getStackTrace returns the expected bottom frame for both the carrier\n+     * and virtual thread.\n+     *\/\n+    @Test\n+    void testBottomFrames() throws Exception {\n+        try (ForkJoinPool pool = new ForkJoinPool(1)) {\n+            var carrierRef = new AtomicReference<Thread>();\n+            Executor scheduler = task -> {\n+                pool.submit(() -> {\n+                    carrierRef.set(Thread.currentThread());\n+                    task.run();\n+                });\n+            };\n+            ThreadFactory factory = VThreadScheduler.virtualThreadFactory(scheduler);\n+\n+            var ready = new AtomicBoolean();\n+            var done = new AtomicBoolean();\n+\n+            \/\/ create virtual thread to use custom scheduler\n+            var vthread = factory.newThread(() -> {\n+                ready.set(true);\n+                while (!done.get()) {\n+                    Thread.onSpinWait();\n+                }\n+            });\n+\n+            vthread.start();\n+            try {\n+                awaitTrue(ready);\n+\n+                \/\/ get carrier Thread\n+                Thread carrier = carrierRef.get();\n+                assertTrue(carrier instanceof ForkJoinWorkerThread);\n+\n+                \/\/ bottom-most frame of virtual thread should be VirtualThread.run\n+                System.err.println(vthread);\n+                StackTraceElement[] vthreadStack = vthread.getStackTrace();\n+                Stream.of(vthreadStack).forEach(e -> System.err.println(\"    \" + e));\n+                StackTraceElement bottomFrame = vthreadStack[vthreadStack.length - 1];\n+                assertEquals(\"java.lang.VirtualThread.run\",\n+                        bottomFrame.getClassName() + \".\" + bottomFrame.getMethodName());\n+\n+                \/\/ bottom-most frame of carrier thread should be Thread.run\n+                System.err.println(carrier);\n+                StackTraceElement[] carrierStack = carrier.getStackTrace();\n+                Stream.of(carrierStack).forEach(e -> System.err.println(\"    \" + e));\n+                bottomFrame = carrierStack[carrierStack.length - 1];\n+                assertEquals(\"java.util.concurrent.ForkJoinWorkerThread.run\",\n+                        bottomFrame.getClassName() + \".\" + bottomFrame.getMethodName());\n+\n+            } finally {\n+                done.set(true);\n+                vthread.join();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Returns true if started with the given VM option.\n+     *\/\n+    private static boolean hasJvmArgument(String arg) {\n+        for (String argument : ManagementFactory.getRuntimeMXBean().getInputArguments()) {\n+            if (argument.equals(arg)) return true;\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Waits for the boolean value to become true.\n+     *\/\n+    private static void awaitTrue(AtomicBoolean ref) throws InterruptedException {\n+        while (!ref.get()) {\n+            Thread.sleep(20);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/StackFrames.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @summary Test stack traces in exceptions and stack frames walked by the StackWalker\n- *     API do not include the carrier stack frames\n- * @requires vm.continuations\n- * @modules java.management\n- * @library \/test\/lib\n- * @run junit StackTraces\n- * @run junit\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+ShowCarrierFrames StackTraces\n- *\/\n-\n-import java.lang.management.ManagementFactory;\n-import java.util.Arrays;\n-import java.util.Set;\n-import java.util.concurrent.ForkJoinPool;\n-import static java.lang.StackWalker.Option.*;\n-\n-import jdk.test.lib.thread.VThreadRunner;\n-import org.junit.jupiter.api.Test;\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-class StackTraces {\n-\n-    \/**\n-     * Test that the stack trace in exceptions does not include the carrier thread\n-     * frames, except when running with -XX:+ShowCarrierFrames.\n-     *\/\n-    @Test\n-    void testStackTrace() throws Exception {\n-        VThreadRunner.run(() -> {\n-            Exception e = new Exception();\n-            boolean found = Arrays.stream(e.getStackTrace())\n-                    .map(StackTraceElement::getClassName)\n-                    .anyMatch(\"java.util.concurrent.ForkJoinPool\"::equals);\n-            assertTrue(found == hasJvmArgument(\"-XX:+ShowCarrierFrames\"));\n-        });\n-    }\n-\n-    \/**\n-     * Test that StackWalker does not include carrier thread frames.\n-     *\/\n-    @Test\n-    void testStackWalker() throws Exception {\n-        VThreadRunner.run(() -> {\n-            StackWalker walker = StackWalker.getInstance(Set.of(RETAIN_CLASS_REFERENCE));\n-            boolean found = walker.walk(sf ->\n-                    sf.map(StackWalker.StackFrame::getDeclaringClass)\n-                            .anyMatch(c -> c == ForkJoinPool.class));\n-            assertFalse(found);\n-        });\n-    }\n-\n-    private static boolean hasJvmArgument(String arg) {\n-        for (String argument : ManagementFactory.getRuntimeMXBean().getInputArguments()) {\n-            if (argument.equals(arg)) return true;\n-        }\n-        return false;\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/StackTraces.java","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,0 @@\n-import jdk.test.lib.thread.VThreadRunner;\n@@ -66,0 +65,2 @@\n+import jdk.test.lib.thread.VThreadRunner;\n+import jdk.test.lib.thread.VThreadScheduler;\n@@ -69,0 +70,1 @@\n+import org.junit.jupiter.api.Disabled;\n@@ -71,0 +73,1 @@\n+import org.junit.jupiter.params.provider.ValueSource;\n@@ -81,1 +84,1 @@\n-    static void setup() throws Exception {\n+    static void setup() {\n@@ -84,0 +87,3 @@\n+\n+        \/\/ need >=2 carriers for testing pinning\n+        VThreadRunner.ensureParallelism(2);\n@@ -722,8 +728,1 @@\n-        \/\/ need at least two carrier threads due to pinning\n-        int previousParallelism = VThreadRunner.ensureParallelism(2);\n-        try {\n-            VThreadRunner.run(this::testJoin33);\n-        } finally {\n-            \/\/ restore\n-            VThreadRunner.setParallelism(previousParallelism);\n-        }\n+        VThreadRunner.run(this::testJoin33);\n@@ -1087,1 +1086,1 @@\n-        assumeTrue(ThreadBuilders.supportsCustomScheduler(), \"No support for custom schedulers\");\n+        assumeTrue(VThreadScheduler.supportsCustomScheduler(), \"No support for custom schedulers\");\n@@ -1090,2 +1089,1 @@\n-            Thread.Builder builder = ThreadBuilders.virtualThreadBuilder(scheduler);\n-            ThreadFactory factory = builder.factory();\n+            ThreadFactory factory = VThreadScheduler.virtualThreadFactory(scheduler);\n@@ -1115,1 +1113,1 @@\n-        assumeTrue(ThreadBuilders.supportsCustomScheduler(), \"No support for custom schedulers\");\n+        assumeTrue(VThreadScheduler.supportsCustomScheduler(), \"No support for custom schedulers\");\n@@ -1118,2 +1116,1 @@\n-            Thread.Builder builder = ThreadBuilders.virtualThreadBuilder(scheduler);\n-            ThreadFactory factory = builder.factory();\n+            ThreadFactory factory = VThreadScheduler.virtualThreadFactory(scheduler);\n@@ -1711,1 +1708,1 @@\n-        assumeTrue(ThreadBuilders.supportsCustomScheduler(), \"No support for custom schedulers\");\n+        assumeTrue(VThreadScheduler.supportsCustomScheduler(), \"No support for custom schedulers\");\n@@ -1714,4 +1711,4 @@\n-            Thread.Builder builder = ThreadBuilders.virtualThreadBuilder(scheduler);\n-            Thread t1 = builder.start(() -> {\n-                Thread t2 = builder.unstarted(LockSupport::park);\n-                assertEquals(Thread.State.NEW, t2.getState());\n+            ThreadFactory factory = VThreadScheduler.virtualThreadFactory(scheduler);\n+            Thread thread1 = factory.newThread(() -> {\n+                Thread thread2 = factory.newThread(LockSupport::park);\n+                assertEquals(Thread.State.NEW, thread2.getState());\n@@ -1720,1 +1717,1 @@\n-                t2.start();\n+                thread2.start();\n@@ -1722,1 +1719,1 @@\n-                    assertEquals(Thread.State.RUNNABLE, t2.getState());\n+                    assertEquals(Thread.State.RUNNABLE, thread2.getState());\n@@ -1726,1 +1723,1 @@\n-                    assertEquals(Thread.State.WAITING, t2.getState());\n+                    assertEquals(Thread.State.WAITING, thread2.getState());\n@@ -1729,1 +1726,1 @@\n-                    LockSupport.unpark(t2);\n+                    LockSupport.unpark(thread2);\n@@ -1733,1 +1730,1 @@\n-                assertEquals(Thread.State.RUNNABLE, t2.getState());\n+                assertEquals(Thread.State.RUNNABLE, thread2.getState());\n@@ -1737,1 +1734,2 @@\n-            t1.join();\n+            thread1.start();\n+            thread1.join();\n@@ -1743,1 +1741,1 @@\n-     * Test Thread::getState when thread is waiting to enter a monitor.\n+     * Test Thread::getState when thread is blocked waiting to enter a monitor.\n@@ -1745,3 +1743,4 @@\n-    @Test\n-    void testGetState5() throws Exception {\n-        var started = new CountDownLatch(1);\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testGetState5(boolean pinned) throws Exception {\n+        var ready = new AtomicBoolean();\n@@ -1749,2 +1748,9 @@\n-            started.countDown();\n-            synchronized (lock) { }\n+            if (pinned) {\n+                VThreadPinner.runPinned(() -> {\n+                    ready.set(true);\n+                    synchronized (lock) { }\n+                });\n+            } else {\n+                ready.set(true);\n+                synchronized (lock) { }\n+            }\n@@ -1754,1 +1760,1 @@\n-            started.await();\n+            awaitTrue(ready);\n@@ -1765,2 +1771,4 @@\n-    @Test\n-    void testGetState6() throws Exception {\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testGetState6(boolean pinned) throws Exception {\n+        var ready = new AtomicBoolean();\n@@ -1769,1 +1777,11 @@\n-                try { lock.wait(); } catch (InterruptedException e) { }\n+                try {\n+                    if (pinned) {\n+                        VThreadPinner.runPinned(() -> {\n+                            ready.set(true);\n+                            lock.wait();\n+                        });\n+                    } else {\n+                        ready.set(true);\n+                        lock.wait();\n+                    }\n+                } catch (InterruptedException e) { }\n@@ -1774,0 +1792,1 @@\n+            awaitTrue(ready);\n@@ -1775,0 +1794,6 @@\n+\n+            \/\/ notify, thread should block trying to reenter\n+            synchronized (lock) {\n+                lock.notifyAll();\n+                await(thread, Thread.State.BLOCKED);\n+            }\n@@ -1784,2 +1809,4 @@\n-    @Test\n-    void testGetState7() throws Exception {\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testGetState7(boolean pinned) throws Exception {\n+        var ready = new AtomicBoolean();\n@@ -1789,1 +1816,9 @@\n-                    lock.wait(Long.MAX_VALUE);\n+                    if (pinned) {\n+                        VThreadPinner.runPinned(() -> {\n+                            ready.set(true);\n+                            lock.wait(Long.MAX_VALUE);\n+                        });\n+                    } else {\n+                        ready.set(true);\n+                        lock.wait(Long.MAX_VALUE);\n+                    }\n@@ -1794,1 +1829,2 @@\n-            \/\/ wait for thread to wait\n+            \/\/ wait for thread to timed-wait\n+            awaitTrue(ready);\n@@ -1796,0 +1832,6 @@\n+\n+            \/\/ notify, thread should block trying to reenter\n+            synchronized (lock) {\n+                lock.notifyAll();\n+                await(thread, Thread.State.BLOCKED);\n+            }\n@@ -1936,1 +1978,1 @@\n-    void testGetStackTrace1() {\n+    void testGetStackTraceUnstarted() {\n@@ -1946,2 +1988,2 @@\n-    void testGetStackTrace2() throws Exception {\n-        assumeTrue(ThreadBuilders.supportsCustomScheduler(), \"No support for custom schedulers\");\n+    void testGetStackTraceStarted() throws Exception {\n+        assumeTrue(VThreadScheduler.supportsCustomScheduler(), \"No support for custom schedulers\");\n@@ -1949,2 +1991,3 @@\n-        Thread.Builder builder = ThreadBuilders.virtualThreadBuilder(scheduler);\n-        Thread thread = builder.start(() -> { });\n+        ThreadFactory factory = VThreadScheduler.virtualThreadFactory(scheduler);\n+        Thread thread = factory.newThread(() -> { });\n+        thread.start();\n@@ -1956,1 +1999,1 @@\n-     * Test Thread::getStackTrace on running thread.\n+     * Test Thread::getStackTrace on thread that is runnable-mounted.\n@@ -1959,9 +2002,10 @@\n-    void testGetStackTrace3() throws Exception {\n-        var sel = Selector.open();\n-        var thread = Thread.ofVirtual().start(() -> {\n-            try { sel.select(); } catch (Exception e) { }\n-        });\n-        try {\n-            while (!contains(thread.getStackTrace(), \"select\")) {\n-                assertTrue(thread.isAlive());\n-                Thread.sleep(20);\n+    void testGetStackTraceRunnableMounted() throws Exception {\n+        var ready = new AtomicBoolean();\n+        var done = new AtomicBoolean();\n+\n+        class Foo {\n+            void spinUntilDone() {\n+                ready.set(true);\n+                while (!done.get()) {\n+                    Thread.onSpinWait();\n+                }\n@@ -1969,0 +2013,8 @@\n+        }\n+\n+        Foo foo = new Foo();\n+        var thread = Thread.ofVirtual().start(foo::spinUntilDone);\n+        try {\n+            awaitTrue(ready);\n+            StackTraceElement[] stack = thread.getStackTrace();\n+            assertTrue(contains(stack, Foo.class.getName() + \".spinUntilDone\"));\n@@ -1970,1 +2022,1 @@\n-            sel.close();\n+            done.set(true);\n@@ -1976,1 +2028,1 @@\n-     * Test Thread::getStackTrace on thread waiting in Object.wait.\n+     * Test Thread::getStackTrace on thread that is runnable-unmounted.\n@@ -1979,10 +2031,2 @@\n-    void testGetStackTrace4() throws Exception {\n-        assumeTrue(ThreadBuilders.supportsCustomScheduler(), \"No support for custom schedulers\");\n-        try (ForkJoinPool pool = new ForkJoinPool(1)) {\n-            AtomicReference<Thread> ref = new AtomicReference<>();\n-            Executor scheduler = task -> {\n-                pool.submit(() -> {\n-                    ref.set(Thread.currentThread());\n-                    task.run();\n-                });\n-            };\n+    void testGetStackTraceRunnableUnmounted() throws Exception {\n+        assumeTrue(VThreadScheduler.supportsCustomScheduler(), \"No support for custom schedulers\");\n@@ -1990,6 +2034,16 @@\n-            Thread.Builder builder = ThreadBuilders.virtualThreadBuilder(scheduler);\n-            Thread vthread = builder.start(() -> {\n-                synchronized (lock) {\n-                    try {\n-                        lock.wait();\n-                    } catch (Exception e) { }\n+        \/\/ custom scheduler with one carrier thread\n+        try (ExecutorService scheduler = Executors.newFixedThreadPool(1)) {\n+            ThreadFactory factory = VThreadScheduler.virtualThreadFactory(scheduler);\n+\n+            \/\/ start thread1 to park\n+            Thread thread1 = factory.newThread(LockSupport::park);\n+            thread1.start();\n+            await(thread1, Thread.State.WAITING);\n+\n+            \/\/ start thread2 to spin and pin the carrier thread\n+            var started = new AtomicBoolean();\n+            var done = new AtomicBoolean();\n+            Thread thread2 = factory.newThread(() -> {\n+                started.set(true);\n+                while (!done.get()) {\n+                    Thread.onSpinWait();\n@@ -1998,0 +2052,2 @@\n+            thread2.start();\n+            awaitTrue(started);\n@@ -1999,5 +2055,5 @@\n-            \/\/ get carrier Thread\n-            Thread carrier;\n-            while ((carrier = ref.get()) == null) {\n-                Thread.sleep(20);\n-            }\n+            try {\n+                \/\/ unpark thread1, it should be \"stuck\" in runnable state\n+                \/\/ (the carrier thread is pinned, no other virtual thread can run)\n+                LockSupport.unpark(thread1);\n+                assertEquals(Thread.State.RUNNABLE, thread1.getState());\n@@ -2005,2 +2061,3 @@\n-            \/\/ wait for virtual thread to block in wait\n-            await(vthread, Thread.State.WAITING);\n+                \/\/ print thread1's stack trace\n+                StackTraceElement[] stack = thread1.getStackTrace();\n+                assertTrue(contains(stack, \"LockSupport.park\"));\n@@ -2008,3 +2065,5 @@\n-            \/\/ get stack trace of both carrier and virtual thread\n-            StackTraceElement[] carrierStackTrace = carrier.getStackTrace();\n-            StackTraceElement[] vthreadStackTrace = vthread.getStackTrace();\n+            } finally {\n+                done.set(true);\n+            }\n+        }\n+    }\n@@ -2012,3 +2071,22 @@\n-            \/\/ allow virtual thread to terminate\n-            synchronized (lock) {\n-                lock.notifyAll();\n+    \/**\n+     * Test Thread::getStackTrace on thread blocked on monitor enter.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testGetStackTraceBlocked(boolean pinned) throws Exception {\n+        class Foo {\n+            void enter() {\n+                synchronized (this) { }\n+            }\n+        }\n+        Foo foo = new Foo();\n+        var ready = new AtomicBoolean();\n+        var thread = Thread.ofVirtual().unstarted(() -> {\n+            if (pinned) {\n+                VThreadPinner.runPinned(() -> {\n+                    ready.set(true);\n+                    foo.enter();\n+                });\n+            } else {\n+                ready.set(true);\n+                foo.enter();\n@@ -2016,0 +2094,4 @@\n+        });\n+        synchronized (foo) {\n+            thread.start();\n+            awaitTrue(ready);\n@@ -2017,3 +2099,2 @@\n-            \/\/ check carrier thread's stack trace\n-            assertTrue(contains(carrierStackTrace, \"java.util.concurrent.ForkJoinPool.runWorker\"));\n-            assertFalse(contains(carrierStackTrace, \"java.lang.Object.wait\"));\n+            \/\/ wait for thread to block\n+            await(thread, Thread.State.BLOCKED);\n@@ -2021,3 +2102,2 @@\n-            \/\/ check virtual thread's stack trace\n-            assertFalse(contains(vthreadStackTrace, \"java.util.concurrent.ForkJoinPool.runWorker\"));\n-            assertTrue(contains(vthreadStackTrace, \"java.lang.Object.wait\"));\n+            StackTraceElement[] stack = thread.getStackTrace();\n+            assertTrue(contains(stack, Foo.class.getName() + \".enter\"));\n@@ -2025,0 +2105,1 @@\n+        thread.join();\n@@ -2028,1 +2109,1 @@\n-     * Test Thread::getStackTrace on parked thread.\n+     * Test Thread::getStackTrace when thread is waiting in Object.wait.\n@@ -2030,4 +2111,19 @@\n-    @Test\n-    void testGetStackTrace5() throws Exception {\n-        var thread = Thread.ofVirtual().start(LockSupport::park);\n-        await(thread, Thread.State.WAITING);\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testGetStackTraceWaiting(boolean pinned) throws Exception {\n+        var ready = new AtomicBoolean();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            synchronized (lock) {\n+                try {\n+                    if (pinned) {\n+                        VThreadPinner.runPinned(() -> {\n+                            ready.set(true);\n+                            lock.wait();\n+                        });\n+                    } else {\n+                        ready.set(true);\n+                        lock.wait();\n+                    }\n+                } catch (InterruptedException e) { }\n+            }\n+        });\n@@ -2035,0 +2131,4 @@\n+            \/\/ wait for thread to wait\n+            awaitTrue(ready);\n+            await(thread, Thread.State.WAITING);\n+\n@@ -2036,1 +2136,1 @@\n-            assertTrue(contains(stack, \"LockSupport.park\"));\n+            assertTrue(contains(stack, \"Object.wait\"));\n@@ -2038,1 +2138,1 @@\n-            LockSupport.unpark(thread);\n+            thread.interrupt();\n@@ -2044,1 +2144,1 @@\n-     * Test Thread::getStackTrace on timed-parked thread.\n+     * Test Thread::getStackTrace when thread is waiting in timed-Object.wait.\n@@ -2046,2 +2146,4 @@\n-    @Test\n-    void testGetStackTrace6() throws Exception {\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testGetStackTraceTimedWaiting(boolean pinned) throws Exception {\n+        var ready = new AtomicBoolean();\n@@ -2049,1 +2151,13 @@\n-            LockSupport.parkNanos(Long.MAX_VALUE);\n+            synchronized (lock) {\n+                try {\n+                    if (pinned) {\n+                        VThreadPinner.runPinned(() -> {\n+                            ready.set(true);\n+                            lock.wait(Long.MAX_VALUE);\n+                        });\n+                    } else {\n+                        ready.set(true);\n+                        lock.wait(Long.MAX_VALUE);\n+                    }\n+                } catch (InterruptedException e) { }\n+            }\n@@ -2051,1 +2165,0 @@\n-        await(thread, Thread.State.TIMED_WAITING);\n@@ -2053,0 +2166,4 @@\n+            \/\/ wait for thread to wait\n+            awaitTrue(ready);\n+            await(thread, Thread.State.TIMED_WAITING);\n+\n@@ -2054,1 +2171,1 @@\n-            assertTrue(contains(stack, \"LockSupport.parkNanos\"));\n+            assertTrue(contains(stack, \"Object.wait\"));\n@@ -2056,1 +2173,1 @@\n-            LockSupport.unpark(thread);\n+            thread.interrupt();\n@@ -2062,1 +2179,1 @@\n-     * Test Thread::getStackTrace on parked thread that is pinned.\n+     * Test Thread::getStackTrace when thread in park.\n@@ -2064,3 +2181,5 @@\n-    @Test\n-    void testGetStackTrace7() throws Exception {\n-        AtomicBoolean done = new AtomicBoolean();\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testGetStackTraceParked(boolean pinned) throws Exception {\n+        var ready = new AtomicBoolean();\n+        var done = new AtomicBoolean();\n@@ -2068,1 +2187,9 @@\n-            VThreadPinner.runPinned(() -> {\n+            if (pinned) {\n+                VThreadPinner.runPinned(() -> {\n+                    ready.set(true);\n+                    while (!done.get()) {\n+                        LockSupport.park();\n+                    }\n+                });\n+            } else {\n+                ready.set(true);\n@@ -2072,1 +2199,1 @@\n-            });\n+            }\n@@ -2074,1 +2201,0 @@\n-        await(thread, Thread.State.WAITING);\n@@ -2076,0 +2202,4 @@\n+            \/\/ wait for thread to park\n+            awaitTrue(ready);\n+            await(thread, Thread.State.WAITING);\n+\n@@ -2086,1 +2216,1 @@\n-     * Test Thread::getStackTrace on timed-parked thread that is pinned.\n+     * Test Thread::getStackTrace when thread in timed-park.\n@@ -2088,3 +2218,5 @@\n-    @Test\n-    void testGetStackTrace8() throws Exception {\n-        AtomicBoolean done = new AtomicBoolean();\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testGetStackTraceTimedPark(boolean pinned) throws Exception {\n+        var ready = new AtomicBoolean();\n+        var done = new AtomicBoolean();\n@@ -2092,1 +2224,9 @@\n-            VThreadPinner.runPinned(() -> {\n+            if (pinned) {\n+                ready.set(true);\n+                VThreadPinner.runPinned(() -> {\n+                    while (!done.get()) {\n+                        LockSupport.parkNanos(Long.MAX_VALUE);\n+                    }\n+                });\n+            } else {\n+                ready.set(true);\n@@ -2096,1 +2236,1 @@\n-            });\n+            }\n@@ -2098,1 +2238,0 @@\n-        await(thread, Thread.State.TIMED_WAITING);\n@@ -2100,0 +2239,4 @@\n+            \/\/ wait for thread to park\n+            awaitTrue(ready);\n+            await(thread, Thread.State.TIMED_WAITING);\n+\n@@ -2113,1 +2256,1 @@\n-    void testGetStackTrace9() throws Exception {\n+    void testGetStackTraceTerminated() throws Exception {\n@@ -2136,1 +2279,1 @@\n-        assumeTrue(ThreadBuilders.supportsCustomScheduler(), \"No support for custom schedulers\");\n+        assumeTrue(VThreadScheduler.supportsCustomScheduler(), \"No support for custom schedulers\");\n@@ -2146,2 +2289,2 @@\n-            Thread.Builder builder = ThreadBuilders.virtualThreadBuilder(scheduler);\n-            Thread vthread = builder.start(() -> {\n+            ThreadFactory factory = VThreadScheduler.virtualThreadFactory(scheduler);\n+            Thread vthread = factory.newThread(() -> {\n@@ -2154,0 +2297,1 @@\n+            vthread.start();\n@@ -2171,0 +2315,1 @@\n+            vthread.join();\n@@ -2172,1 +2317,1 @@\n-            \/\/ get stack trace for the carrier thread\n+            \/\/ stack trace for the carrier thread\n@@ -2420,0 +2565,9 @@\n+    \/**\n+     * Waits for the boolean value to become true.\n+     *\/\n+    private static void awaitTrue(AtomicBoolean ref) throws Exception {\n+        while (!ref.get()) {\n+            Thread.sleep(20);\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ThreadAPI.java","additions":281,"deletions":127,"binary":false,"changes":408,"status":"modified"},{"patch":"@@ -1,80 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.InvocationTargetException;\n-import java.util.concurrent.Executor;\n-import java.util.concurrent.Executors;\n-\n-\/**\n- * Helper class for creating Thread buidlers.\n- *\n- * Tests using this class need to open java.base\/java.lang.\n- *\/\n-class ThreadBuilders {\n-    private ThreadBuilders() { }\n-\n-    private static final Constructor<?> VTBUILDER_CTOR;\n-    static {\n-        try {\n-            Class<?> clazz = Class.forName(\"java.lang.ThreadBuilders$VirtualThreadBuilder\");\n-            Constructor<?> ctor = clazz.getDeclaredConstructor(Executor.class);\n-            ctor.setAccessible(true);\n-            VTBUILDER_CTOR = ctor;\n-        } catch (Exception e) {\n-            throw new InternalError(e);\n-        }\n-    }\n-\n-    \/**\n-     * Returns a builder to create virtual threads that use the given scheduler.\n-     * @throws UnsupportedOperationException if custom schedulers are not supported\n-     *\/\n-    static Thread.Builder.OfVirtual virtualThreadBuilder(Executor scheduler) {\n-        try {\n-            return (Thread.Builder.OfVirtual) VTBUILDER_CTOR.newInstance(scheduler);\n-        } catch (InvocationTargetException e) {\n-            Throwable cause = e.getCause();\n-            if (cause instanceof RuntimeException re) {\n-                throw re;\n-            }\n-            throw new RuntimeException(e);\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    \/**\n-     * Return true if custom schedulers are supported.\n-     *\/\n-    static boolean supportsCustomScheduler() {\n-        try (var pool = Executors.newCachedThreadPool()) {\n-            try {\n-                virtualThreadBuilder(pool);\n-                return true;\n-            } catch (UnsupportedOperationException e) {\n-                return false;\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ThreadBuilders.java","additions":0,"deletions":80,"binary":false,"changes":80,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @modules java.base\/jdk.internal.event\n+ * @modules java.base\/java.lang:+open java.base\/jdk.internal.event\n@@ -39,0 +39,1 @@\n+import jdk.test.lib.thread.VThreadRunner;\n@@ -41,0 +42,1 @@\n+import org.junit.jupiter.api.BeforeAll;\n@@ -45,0 +47,8 @@\n+    @BeforeAll\n+    static void setup() {\n+        \/\/ need >=2 carriers for testing pinning when main thread is a virtual thread\n+        if (Thread.currentThread().isVirtual()) {\n+            VThreadRunner.ensureParallelism(2);\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/VirtualThreadPinnedEventThrows.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Stress parking with CompletableFuture timed get\n+ * @requires vm.debug != true & vm.continuations\n+ * @run main\/othervm -Xmx1g CompletableFutureTimedGet 100000\n+ *\/\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+public class CompletableFutureTimedGet {\n+\n+    static final String RESULT = \"foo\";\n+\n+    public static void main(String... args) throws InterruptedException {\n+        int threadCount = 250_000;\n+        if (args.length > 0) {\n+            threadCount = Integer.parseInt(args[0]);\n+        }\n+\n+        \/\/ the count of the number of threads that complete successfully\n+        AtomicInteger completed = new AtomicInteger();\n+\n+        \/\/ list of futures and threads\n+        List<CompletableFuture<String>> futures = new ArrayList<>();\n+        List<Thread> threads = new ArrayList<>();\n+\n+        \/\/ start threads that wait with timeout for a result\n+        for (int i = 0; i < threadCount; i++) {\n+            var future = new CompletableFuture<String>();\n+            futures.add(future);\n+\n+            \/\/ start a thread that uses a timed-get to wait for the result\n+            Thread thread = Thread.ofVirtual().start(() -> {\n+                try {\n+                    String result = future.get(1, TimeUnit.DAYS);\n+                    if (!RESULT.equals(result)) {\n+                        throw new RuntimeException(\"result=\" + result);\n+                    }\n+                    completed.incrementAndGet();\n+                } catch (Exception e) {\n+                    e.printStackTrace();\n+                }\n+            });\n+            threads.add(thread);\n+        }\n+\n+        \/\/ sets the result, which will unpark waiting threads\n+        futures.forEach(f -> f.complete(RESULT));\n+\n+        \/\/ wait for all threads to terminate\n+        long lastTimestamp = System.currentTimeMillis();\n+        boolean done;\n+        do {\n+            done = true;\n+            for (Thread t : threads) {\n+                if (!t.join(Duration.ofSeconds(1))) {\n+                    done = false;\n+                }\n+            }\n+\n+            \/\/ print trace message so the output tracks progress\n+            long currentTime = System.currentTimeMillis();\n+            if (done || ((currentTime - lastTimestamp) > 500)) {\n+                System.out.format(\"%s => completed %d of %d%n\",\n+                        Instant.now(), completed.get(), threadCount);\n+                lastTimestamp = currentTime;\n+            }\n+\n+        } while (!done);\n+\n+        \/\/ all tasks should have completed successfully\n+        int completedCount = completed.get();\n+        if (completedCount != threadCount) {\n+            throw new RuntimeException(\"completed = \" + completedCount);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/CompletableFutureTimedGet.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -1,123 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @summary Stress test asynchronous Thread.getStackTrace\n- * @requires vm.debug != true & vm.continuations\n- * @modules java.base\/java.lang:+open\n- * @compile GetStackTraceALot.java ..\/ThreadBuilders.java\n- * @run main GetStackTraceALot\n- *\/\n-\n-\/**\n- * @test\n- * @requires vm.debug == true & vm.continuations\n- * @modules java.base\/java.lang:+open\n- * @compile GetStackTraceALot.java ..\/ThreadBuilders.java\n- * @run main\/timeout=300 GetStackTraceALot 1000\n- *\/\n-\n-import java.time.Duration;\n-import java.util.concurrent.Executor;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.ThreadFactory;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.locks.LockSupport;\n-\n-public class GetStackTraceALot {\n-    static class RoundRobinExecutor implements Executor, AutoCloseable {\n-        private final ExecutorService[] executors;\n-        private int next;\n-\n-        RoundRobinExecutor() {\n-            var factory = Thread.ofPlatform().name(\"worker-\", 1).daemon(true).factory();\n-            var executors = new ExecutorService[2];\n-            for (int i = 0; i < executors.length; i++) {\n-                executors[i] = Executors.newSingleThreadExecutor(factory);\n-            }\n-            this.executors = executors;\n-        }\n-\n-        @Override\n-        public void execute(Runnable task) {\n-            executors[next].execute(task);\n-            next = (next + 1) % executors.length;\n-        }\n-\n-        @Override\n-        public void close() {\n-            for (int i = 0; i < executors.length; i++) {\n-                executors[i].shutdown();\n-            }\n-        }\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        int iterations = args.length > 0 ? Integer.parseInt(args[0])  : 10_000;\n-\n-        final int ITERATIONS = iterations;\n-        final int SPIN_NANOS = 5000;\n-\n-        AtomicInteger count = new AtomicInteger();\n-\n-        try (RoundRobinExecutor executor = new RoundRobinExecutor()) {\n-            Thread thread = ThreadBuilders.virtualThreadBuilder(executor).start(() -> {\n-                while (count.incrementAndGet() < ITERATIONS) {\n-                    long start = System.nanoTime();\n-                    while ((System.nanoTime() - start) < SPIN_NANOS) {\n-                        Thread.onSpinWait();\n-                    }\n-                    LockSupport.parkNanos(500_000);\n-                }\n-            });\n-\n-            long start = System.nanoTime();\n-            while (thread.isAlive()) {\n-                StackTraceElement[] stackTrace = thread.getStackTrace();\n-                \/\/ printStackTrace(stackTrace);\n-                Thread.sleep(5);\n-                if ((System.nanoTime() - start) > 500_000_000) {\n-                    System.out.println(count.get());\n-                    start = System.nanoTime();\n-                }\n-            }\n-\n-            int countValue = count.get();\n-            if (countValue != ITERATIONS) {\n-                throw new RuntimeException(\"count = \" + countValue);\n-            }\n-        }\n-    }\n-\n-    static void printStackTrace(StackTraceElement[] stackTrace) {\n-        if (stackTrace == null) {\n-            System.out.println(\"NULL\");\n-        } else {\n-            for (var e : stackTrace) {\n-                System.out.println(\"\\t\" + e);\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/GetStackTraceALot.java","additions":0,"deletions":123,"binary":false,"changes":123,"status":"deleted"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Stress test Thread.getStackTrace on virtual threads that are blocking or\n+ *     blocked on monitorenter\n+ * @requires vm.debug != true\n+ * @modules java.base\/java.lang:+open\n+ * @library \/test\/lib\n+ * @run main\/othervm GetStackTraceALotWhenBlocking 500000\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires vm.debug == true & vm.continuations\n+ * @modules java.base\/java.lang:+open\n+ * @library \/test\/lib\n+ * @run main\/othervm\/timeout=300 GetStackTraceALotWhenBlocking 50000\n+ *\/\n+\n+import java.time.Instant;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import jdk.test.lib.thread.VThreadRunner;\n+\n+public class GetStackTraceALotWhenBlocking {\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ need at least two carriers\n+        VThreadRunner.ensureParallelism(2);\n+\n+        int iterations = args.length > 0 ? Integer.parseInt(args[0]) : 100_000;\n+\n+        var done = new AtomicBoolean();\n+        var lock = new Object();\n+\n+        Runnable task = () -> {\n+            long count = 0L;\n+            while (!done.get()) {\n+                synchronized (lock) {\n+                    pause();\n+                }\n+                count++;\n+            }\n+            System.out.format(\"%s %s => %d loops%n\", Instant.now(), Thread.currentThread(), count);\n+        };\n+\n+        var thread1 = Thread.ofVirtual().start(task);\n+        var thread2 = Thread.ofVirtual().start(task);\n+        try {\n+            for (int i = 1; i <= iterations; i++) {\n+                if ((i % 10_000) == 0) {\n+                    System.out.format(\"%s => %d of %d%n\", Instant.now(), i, iterations);\n+                }\n+\n+                thread1.getStackTrace();\n+                pause();\n+                thread2.getStackTrace();\n+                pause();\n+            }\n+        } finally {\n+            done.set(true);\n+            thread1.join();\n+            thread2.join();\n+        }\n+    }\n+\n+    private static void pause() {\n+        if (ThreadLocalRandom.current().nextBoolean()) {\n+            Thread.onSpinWait();\n+        } else {\n+            Thread.yield();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/GetStackTraceALotWhenBlocking.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Stress test asynchronous Thread.getStackTrace when parking\n+ * @requires vm.debug != true & vm.continuations\n+ * @modules java.base\/java.lang:+open\n+ * @library \/test\/lib\n+ * @run main GetStackTraceALotWhenParking\n+ *\/\n+\n+\/**\n+ * @test\n+ * @requires vm.debug == true & vm.continuations\n+ * @modules java.base\/java.lang:+open\n+ * @library \/test\/lib\n+ * @run main\/timeout=300 GetStackTraceALotWhenParking 1000\n+ *\/\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.LockSupport;\n+import jdk.test.lib.thread.VThreadScheduler;\n+\n+public class GetStackTraceALotWhenParking {\n+    static class RoundRobinExecutor implements Executor, AutoCloseable {\n+        private final ExecutorService[] executors;\n+        private int next;\n+\n+        RoundRobinExecutor() {\n+            var factory = Thread.ofPlatform().name(\"worker-\", 1).daemon(true).factory();\n+            var executors = new ExecutorService[2];\n+            for (int i = 0; i < executors.length; i++) {\n+                executors[i] = Executors.newSingleThreadExecutor(factory);\n+            }\n+            this.executors = executors;\n+        }\n+\n+        @Override\n+        public void execute(Runnable task) {\n+            executors[next].execute(task);\n+            next = (next + 1) % executors.length;\n+        }\n+\n+        @Override\n+        public void close() {\n+            for (int i = 0; i < executors.length; i++) {\n+                executors[i].shutdown();\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        int iterations = args.length > 0 ? Integer.parseInt(args[0])  : 10_000;\n+\n+        final int ITERATIONS = iterations;\n+        final int SPIN_NANOS = 5000;\n+\n+        AtomicInteger count = new AtomicInteger();\n+\n+        try (RoundRobinExecutor executor = new RoundRobinExecutor()) {\n+            ThreadFactory factory = VThreadScheduler.virtualThreadFactory(executor);\n+\n+            Thread thread = factory.newThread(() -> {\n+                while (count.incrementAndGet() < ITERATIONS) {\n+                    long start = System.nanoTime();\n+                    while ((System.nanoTime() - start) < SPIN_NANOS) {\n+                        Thread.onSpinWait();\n+                    }\n+                    LockSupport.parkNanos(500_000);\n+                }\n+            });\n+            thread.start();\n+\n+            long start = System.nanoTime();\n+            while (thread.isAlive()) {\n+                StackTraceElement[] stackTrace = thread.getStackTrace();\n+                \/\/ printStackTrace(stackTrace);\n+                Thread.sleep(5);\n+                if ((System.nanoTime() - start) > 500_000_000) {\n+                    System.out.format(\"%s => %d of %d%n\", Instant.now(), count.get(), ITERATIONS);\n+                    start = System.nanoTime();\n+                }\n+            }\n+\n+            int countValue = count.get();\n+            if (countValue != ITERATIONS) {\n+                throw new RuntimeException(\"count = \" + countValue);\n+            }\n+        }\n+    }\n+\n+    static void printStackTrace(StackTraceElement[] stackTrace) {\n+        if (stackTrace == null) {\n+            System.out.println(\"NULL\");\n+        } else {\n+            for (var e : stackTrace) {\n+                System.out.println(\"\\t\" + e);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/GetStackTraceALotWhenParking.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -31,1 +31,1 @@\n- * @run main\/othervm GetStackTraceALotWhenPinned 500000\n+ * @run main\/othervm --enable-native-access=ALL-UNNAMED GetStackTraceALotWhenPinned 500000\n@@ -39,1 +39,1 @@\n- * @run main\/othervm\/timeout=300 GetStackTraceALotWhenPinned 200000\n+ * @run main\/othervm\/timeout=300 --enable-native-access=ALL-UNNAMED GetStackTraceALotWhenPinned 200000\n@@ -82,1 +82,1 @@\n-        for (int i = 0; i < iterations; i++) {\n+        for (int i = 1; i <= iterations; i++) {\n@@ -90,2 +90,2 @@\n-            if ((currentTime - lastTimestamp) > 500) {\n-                System.out.format(\"%s %d remaining ...%n\", Instant.now(), (iterations - i));\n+            if (i == iterations || ((currentTime - lastTimestamp) > 500)) {\n+                System.out.format(\"%s => %d of %d%n\", Instant.now(), i, iterations);\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/GetStackTraceALotWhenPinned.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-        int iterations = 1_000_000;\n+        int iterations;\n@@ -52,0 +52,2 @@\n+        } else {\n+            iterations = 1_000_000;\n@@ -53,1 +55,0 @@\n-        final int ITERATIONS = iterations;\n@@ -56,1 +57,0 @@\n-\n@@ -59,1 +59,1 @@\n-                while (count.incrementAndGet() < ITERATIONS) {\n+                while (count.incrementAndGet() < iterations) {\n@@ -68,1 +68,1 @@\n-            System.out.println(Instant.now() + \" => \" + count.get());\n+            System.out.println(Instant.now() + \" => \" + count.get() + \" of \" + iterations);\n@@ -72,2 +72,2 @@\n-        if (countValue != ITERATIONS) {\n-            throw new RuntimeException(\"count = \" + countValue);\n+        if (countValue != iterations) {\n+            throw new RuntimeException(\"Thread terminated, count=\" + countValue);\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/PinALot.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import java.time.Instant;\n@@ -94,1 +95,1 @@\n-            if (terminated)\n+            if (terminated) {\n@@ -96,1 +97,3 @@\n-            System.out.format(\"%d %s%n\", count1.get(), count2.get());\n+            }\n+            System.out.format(\"%s => T1 %d of %d, T2 %d of %d%n\",\n+                    Instant.now(), count1.get(), iterations, count2.get(), iterations);\n@@ -98,1 +101,0 @@\n-\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/PingPong.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,1 @@\n-            throw new AssertionError(\"unexpected result!\");\n+            throw new RuntimeException(\"Expected \" + expected);\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/Skynet.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-        int iterations = 1_000_000;\n+        int iterations;\n@@ -47,0 +47,2 @@\n+        } else {\n+            iterations = 1_000_000;\n@@ -48,1 +50,0 @@\n-        final int ITERATIONS = iterations;\n@@ -51,1 +52,0 @@\n-\n@@ -53,1 +53,1 @@\n-            while (count.incrementAndGet() < ITERATIONS) {\n+            while (count.incrementAndGet() < iterations) {\n@@ -63,1 +63,1 @@\n-            System.out.println(Instant.now() + \" => \" + count.get());\n+            System.out.println(Instant.now() + \" => \" + count.get() + \" of \" + iterations);\n@@ -67,2 +67,2 @@\n-        if (countValue != ITERATIONS) {\n-            throw new RuntimeException(\"count = \" + countValue);\n+        if (countValue != iterations) {\n+            throw new RuntimeException(\"Thread terminated, count=\" + countValue);\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/SleepALot.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1,108 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Stress parking with CompletableFuture timed get\n- * @requires vm.debug != true & vm.continuations\n- * @run main\/othervm -Xmx1g TimedGet 100000\n- *\/\n-\n-import java.time.Duration;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-public class TimedGet {\n-\n-    static final String RESULT = \"foo\";\n-\n-    public static void main(String... args) throws InterruptedException {\n-        int threadCount = 250_000;\n-        if (args.length > 0) {\n-            threadCount = Integer.parseInt(args[0]);\n-        }\n-\n-        \/\/ the count of the number of threads that complete successfully\n-        AtomicInteger completed = new AtomicInteger();\n-\n-        \/\/ list of futures and threads\n-        List<CompletableFuture<String>> futures = new ArrayList<>();\n-        List<Thread> threads = new ArrayList<>();\n-\n-        \/\/ start threads that wait with timeout for a result\n-        for (int i = 0; i < threadCount; i++) {\n-            var future = new CompletableFuture<String>();\n-            futures.add(future);\n-\n-            \/\/ start a thread that uses a timed-get to wait for the result\n-            Thread thread = Thread.ofVirtual().start(() -> {\n-                try {\n-                    String result = future.get(1, TimeUnit.DAYS);\n-                    if (!RESULT.equals(result)) {\n-                        throw new RuntimeException(\"result=\" + result);\n-                    }\n-                    completed.incrementAndGet();\n-                } catch (Exception e) {\n-                    e.printStackTrace();\n-                }\n-            });\n-            threads.add(thread);\n-        }\n-\n-        \/\/ sets the result, which will unpark waiting threads\n-        futures.forEach(f -> f.complete(RESULT));\n-\n-        \/\/ wait for all threads to terminate\n-        long lastTimestamp = System.currentTimeMillis();\n-        int i = 0;\n-        while (i < threadCount) {\n-            Thread t = threads.get(i);\n-            boolean terminated;\n-            if (t.isAlive()) {\n-                terminated = t.join(Duration.ofMillis(500));\n-\n-                \/\/ print trace message so the output tracks progress\n-                long currentTime = System.currentTimeMillis();\n-                if ((currentTime - lastTimestamp) > 500) {\n-                    System.out.println(completed.get());\n-                    lastTimestamp = currentTime;\n-                }\n-            } else {\n-                terminated = true;\n-            }\n-            if (terminated) {\n-                i++;\n-            }\n-        }\n-\n-        \/\/ all tasks should have completed successfully\n-        int completedCount = completed.get();\n-        System.out.println(completedCount);\n-        if (completedCount != threadCount) {\n-            throw new RuntimeException(\"completed = \" + completedCount);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/TimedGet.java","additions":0,"deletions":108,"binary":false,"changes":108,"status":"deleted"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=timeout\n+ * @summary Stress test timed-Object.wait\n+ * @run main\/othervm TimedWaitALot 200\n+ *\/\n+\n+\/*\n+ * @test id=timeout-notify\n+ * @summary Test timed-Object.wait where the waiting thread is awakened with Object.notify\n+ *     at around the same time that the timeout expires.\n+ * @run main\/othervm TimedWaitALot 200 true false\n+ *\/\n+\n+\/*\n+ * @test id=timeout-interrupt\n+ * @summary Test timed-Object.wait where the waiting thread is awakened with Thread.interrupt\n+ *     at around the same time that the timeout expires.\n+ * @run main\/othervm TimedWaitALot 200 false true\n+ *\/\n+\n+\/*\n+ * @test id=timeout-notify-interrupt\n+ * @summary Test timed-Object.wait where the waiting thread is awakened with Object.notify\n+ *     and Thread.interrupt at around the same time that the timeout expires.\n+ * @run main\/othervm TimedWaitALot 100 true true\n+ *\/\n+\n+import java.time.Instant;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.SynchronousQueue;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+public class TimedWaitALot {\n+    public static void main(String[] args) throws Exception {\n+        int iterations = Integer.parseInt(args[0]);\n+        boolean notify = args.length >= 2 && \"true\".equals(args[1]);\n+        boolean interrupt = args.length >=3 && \"true\".equals(args[2]);\n+\n+        \/\/ test all timeouts concurrently\n+        int[] timeouts = { 10, 20, 50, 100 };\n+        for (int i = 1; i <= iterations; i++) {\n+            System.out.println(Instant.now() + \" => \" + i + \" of \" + iterations);\n+            test(notify, interrupt, timeouts);\n+        }\n+    }\n+\n+    \/**\n+     * Start a first virtual thread to wait in Object.wait(millis).\n+     * If {@code notify} is true, start a virtual thread to use Object.notifyAll at around\n+     * the same time that the timeout expires.\n+     * If {@code interrupt} is true, start virtual thread to interrupts the first virtual\n+     * thread at around the same time as the timeout expires.\n+     *\/\n+    static void test(boolean notify, boolean interrupt, int... timeouts) throws Exception {\n+        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n+            for (int timeout : timeouts) {\n+                var queue = new SynchronousQueue<Thread>();\n+                var lock = new Object();\n+\n+                \/\/ virtual thread waits with Object.wait(timeout)\n+                executor.submit(() -> {\n+                    queue.put(Thread.currentThread());\n+                    synchronized (lock) {\n+                        lock.wait(timeout);\n+                    }\n+                    return null;\n+                });\n+\n+                \/\/ wait for thread to start\n+                Thread thread = queue.take();\n+\n+                \/\/ start thread to Object.notifyAll at around time that the timeout expires\n+                if (notify) {\n+                    if (ThreadLocalRandom.current().nextBoolean()) {\n+                        synchronized (lock) {\n+                            sleepLessThan(timeout);\n+                            lock.notifyAll();\n+                        }\n+                    } else {\n+                        sleepLessThan(timeout);\n+                        synchronized (lock) {\n+                            lock.notifyAll();\n+                        }\n+                    }\n+                }\n+\n+                \/\/ start thread to interrupt first thread at around time that the timeout expires\n+                if (interrupt) {\n+                    executor.submit(() -> {\n+                        sleepLessThan(timeout);\n+                        thread.interrupt();\n+                        return null;\n+                    });\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Sleeps for just less than the given timeout, in millis.\n+     *\/\n+    private static void sleepLessThan(long timeout) throws InterruptedException {\n+        int delta = ThreadLocalRandom.current().nextInt(10);\n+        Thread.sleep(timeout - delta);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/TimedWaitALot.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run main YieldALot 350000\n+ * @run main YieldALot 500000\n@@ -38,0 +38,1 @@\n+import java.time.Instant;\n@@ -43,1 +44,1 @@\n-        int iterations = 1_000_000;\n+        int iterations;\n@@ -46,0 +47,2 @@\n+        } else {\n+            iterations = 1_000_000;\n@@ -47,1 +50,0 @@\n-        final int ITERATIONS = iterations;\n@@ -50,1 +52,0 @@\n-\n@@ -52,1 +53,1 @@\n-            while (count.incrementAndGet() < ITERATIONS) {\n+            while (count.incrementAndGet() < iterations) {\n@@ -59,2 +60,2 @@\n-            terminated = thread.join(Duration.ofMillis(500));\n-            System.out.println(count.get());\n+            terminated = thread.join(Duration.ofSeconds(1));\n+            System.out.println(Instant.now() + \" => \" + count.get() + \" of \" + iterations);\n@@ -64,2 +65,2 @@\n-        if (countValue != ITERATIONS) {\n-            throw new RuntimeException(\"count = \" + countValue);\n+        if (countValue != iterations) {\n+            throw new RuntimeException(\"Thread terminated, count=\" + countValue);\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/YieldALot.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test ThreadMXBean.getLockedMonitors returns information about an object\n+ *    monitor lock entered with a synchronized native method or JNI MonitorEnter\n+ * @run junit\/othervm LockedMonitorInNative\n+ *\/\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.ThreadInfo;\n+import java.lang.management.ThreadMXBean;\n+import java.util.Arrays;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeAll;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class LockedMonitorInNative {\n+\n+    @BeforeAll\n+    static void setup() throws Exception {\n+        System.loadLibrary(\"LockedMonitorInNative\");\n+    }\n+\n+    \/**\n+     * Test ThreadMXBean.getLockedMonitors returns information about an object\n+     * monitor lock entered with a synchronized native method.\n+     *\/\n+    @Test\n+    void testSynchronizedNative() {\n+        Object lock = this;\n+        runWithSynchronizedNative(() -> {\n+            assertTrue(holdsLock(lock), \"Thread does not hold lock\");\n+        });\n+    }\n+\n+    \/**\n+     * Test ThreadMXBean.getLockedMonitors returns information about an object\n+     * monitor lock entered with JNI MonitorEnter.\n+     *\/\n+    @Test\n+    void testMonitorEnteredInNative() {\n+        var lock = new Object();\n+        runWithMonitorEnteredInNative(lock, () -> {\n+            assertTrue(holdsLock(lock), \"Thread does not hold lock\");\n+        });\n+    }\n+\n+    private boolean holdsLock(Object lock) {\n+        int hc = System.identityHashCode(lock);\n+        long tid = Thread.currentThread().threadId();\n+        ThreadInfo ti = ManagementFactory.getPlatformMXBean(ThreadMXBean.class)\n+                .getThreadInfo(new long[] { tid }, true, true)[0];\n+        return Arrays.stream(ti.getLockedMonitors())\n+                .anyMatch(mi -> mi.getIdentityHashCode() == hc);\n+    }\n+\n+    \/**\n+     * Invokes the given task's run method while holding the monitor for \"this\".\n+     *\/\n+    private synchronized native void runWithSynchronizedNative(Runnable task);\n+\n+    \/**\n+     * Invokes the given task's run method while holding the monitor for the given\n+     * object. The monitor is entered with JNI MonitorEnter, and exited with JNI MonitorExit.\n+     *\/\n+    private native void runWithMonitorEnteredInNative(Object lock, Runnable task);\n+\n+    \/**\n+     * Called from native methods to run the given task.\n+     *\/\n+    private void run(Runnable task) {\n+        task.run();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/management\/ThreadMXBean\/LockedMonitorInNative.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,2 +44,0 @@\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.InvocationTargetException;\n@@ -52,0 +50,1 @@\n+import java.util.concurrent.ThreadFactory;\n@@ -56,0 +55,1 @@\n+import jdk.test.lib.thread.VThreadPinner;\n@@ -57,0 +57,1 @@\n+import jdk.test.lib.thread.VThreadScheduler;\n@@ -198,1 +199,1 @@\n-        assumeTrue(supportsCustomScheduler(), \"No support for custom schedulers\");\n+        assumeTrue(VThreadScheduler.supportsCustomScheduler(), \"No support for custom schedulers\");\n@@ -207,0 +208,1 @@\n+            ThreadFactory factory = VThreadScheduler.virtualThreadFactory(scheduler);\n@@ -209,1 +211,3 @@\n-            virtualThreadBuilder(scheduler).start(() -> { }).join();\n+            Thread thread = factory.newThread(() -> { });\n+            thread.start();\n+            thread.join();\n@@ -214,2 +218,4 @@\n-                \/\/ start virtual thread that blocks in a native method\n-                virtualThreadBuilder(scheduler).start(() -> {\n+                String selClassName = sel.getClass().getName();\n+\n+                \/\/ start virtual thread that blocks while pinned\n+                Thread vthread = factory.newThread(() -> {\n@@ -217,1 +223,1 @@\n-                        sel.select();\n+                        VThreadPinner.runPinned(sel::select);\n@@ -220,0 +226,6 @@\n+                vthread.start();\n+\n+                \/\/ wait for virtual thread to block in select\n+                while (!contains(vthread.getStackTrace(), selClassName)) {\n+                    Thread.sleep(20);\n+                }\n@@ -228,1 +240,1 @@\n-                assertFalse(contains(stack, \"java.nio.channels.Selector\"));\n+                assertFalse(contains(stack, selClassName));\n@@ -354,36 +366,0 @@\n-\n-    \/**\n-     * Returns a builder to create virtual threads that use the given scheduler.\n-     * @throws UnsupportedOperationException if there is no support for custom schedulers\n-     *\/\n-    private static Thread.Builder.OfVirtual virtualThreadBuilder(Executor scheduler) {\n-        Thread.Builder.OfVirtual builder = Thread.ofVirtual();\n-        try {\n-            Class<?> clazz = Class.forName(\"java.lang.ThreadBuilders$VirtualThreadBuilder\");\n-            Constructor<?> ctor = clazz.getDeclaredConstructor(Executor.class);\n-            ctor.setAccessible(true);\n-            return (Thread.Builder.OfVirtual) ctor.newInstance(scheduler);\n-        } catch (InvocationTargetException e) {\n-            Throwable cause = e.getCause();\n-            if (cause instanceof RuntimeException re) {\n-                throw re;\n-            }\n-            throw new RuntimeException(e);\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    \/**\n-     * Return true if custom schedulers are supported.\n-     *\/\n-    private static boolean supportsCustomScheduler() {\n-        try (var pool = Executors.newCachedThreadPool()) {\n-            try {\n-                virtualThreadBuilder(pool);\n-                return true;\n-            } catch (UnsupportedOperationException e) {\n-                return false;\n-            }\n-        }\n-    }\n","filename":"test\/jdk\/java\/lang\/management\/ThreadMXBean\/VirtualThreads.java","additions":21,"deletions":45,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+\n+JNIEXPORT void JNICALL\n+Java_LockedMonitorInNative_runWithSynchronizedNative(JNIEnv *env, jobject obj, jobject task) {\n+    jclass clazz = (*env)->GetObjectClass(env, obj);\n+    jmethodID mid = (*env)->GetMethodID(env, clazz, \"run\", \"(Ljava\/lang\/Runnable;)V\");\n+    if (mid != NULL) {\n+        (*env)->CallVoidMethod(env, obj, mid, task);\n+    }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_LockedMonitorInNative_runWithMonitorEnteredInNative(JNIEnv *env, jobject obj, jobject lock, jobject task) {\n+    jclass clazz = (*env)->GetObjectClass(env, obj);\n+    jmethodID mid = (*env)->GetMethodID(env, clazz, \"run\", \"(Ljava\/lang\/Runnable;)V\");\n+    if (mid != NULL && (*env)->MonitorEnter(env, lock) == 0) {\n+        (*env)->CallVoidMethod(env, obj, mid, task);\n+        (*env)->MonitorExit(env, lock);  \/\/ can be called with pending exception\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/management\/ThreadMXBean\/libLockedMonitorInNative.c","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -429,1 +429,1 @@\n-            checkDuration(startMillis, 1900, 4000);\n+            checkDuration(startMillis, 1900, 20_000);\n@@ -456,1 +456,1 @@\n-                    checkDuration(startMillis, 1900, 4000);\n+                    checkDuration(startMillis, 1900, 20_000);\n","filename":"test\/jdk\/jdk\/internal\/misc\/ThreadFlock\/ThreadFlockTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.thread;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n+\n+\/**\n+ * Helper class to allow tests run virtual threads with a custom scheduler.\n+ *\n+ * Tests using this class need to open java.base\/java.lang.\n+ *\/\n+public class VThreadScheduler {\n+    private VThreadScheduler() { }\n+\n+    \/**\n+     * Returns the scheduler for the given virtual thread.\n+     *\/\n+    public static Executor scheduler(Thread thread) {\n+        if (!thread.isVirtual())\n+            throw new IllegalArgumentException(\"Not a virtual thread\");\n+        try {\n+            Field scheduler = Class.forName(\"java.lang.VirtualThread\")\n+                    .getDeclaredField(\"scheduler\");\n+            scheduler.setAccessible(true);\n+            return (Executor) scheduler.get(thread);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Return true if custom schedulers are supported.\n+     *\/\n+    public static boolean supportsCustomScheduler() {\n+        try (var pool = Executors.newCachedThreadPool()) {\n+            try {\n+                virtualThreadBuilder(pool);\n+                return true;\n+            } catch (UnsupportedOperationException e) {\n+                return false;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Returns a builder to create virtual threads that use the given scheduler.\n+     * @throws UnsupportedOperationException if custom schedulers are not supported\n+     *\/\n+    public static Thread.Builder.OfVirtual virtualThreadBuilder(Executor scheduler) {\n+        try {\n+            Class<?> clazz = Class.forName(\"java.lang.ThreadBuilders$VirtualThreadBuilder\");\n+            Constructor<?> ctor = clazz.getDeclaredConstructor(Executor.class);\n+            ctor.setAccessible(true);\n+            return (Thread.Builder.OfVirtual) ctor.newInstance(scheduler);\n+        } catch (InvocationTargetException e) {\n+            Throwable cause = e.getCause();\n+            if (cause instanceof RuntimeException re) {\n+                throw re;\n+            }\n+            throw new RuntimeException(e);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Returns a ThreadFactory to create virtual threads that use the given scheduler.\n+     * @throws UnsupportedOperationException if custom schedulers are not supported\n+     *\/\n+    public static ThreadFactory virtualThreadFactory(Executor scheduler) {\n+        return virtualThreadBuilder(scheduler).factory();\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/thread\/VThreadScheduler.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"}]}