{"files":[{"patch":"@@ -2719,0 +2719,3 @@\n+void os::jfr_report_process_size() {}\n+void os::jfr_report_libc_statistics() {}\n+int os::num_process_threads() { return -1; }\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-inline bool os::trim_native_heap(os::size_change_t* rss_change) { return false; }\n+inline bool os::trim_native_heap(os::size_change_t& rss_change) { return false; }\n","filename":"src\/hotspot\/os\/aix\/os_aix.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -210,2 +210,0 @@\n-size_t os::rss() {\n-  size_t rss = 0;\n@@ -213,0 +211,1 @@\n+bool os::Bsd::query_process_memory_info(os::Bsd::process_info_t* pi) {\n@@ -215,1 +214,0 @@\n-\n@@ -219,1 +217,6 @@\n-    rss = info.resident_size;\n+    pi->vsize = info.virtual_size;\n+    pi->rss = info.resident_size;\n+    \/\/ We've seen that resident_size_max sometimes trails resident_size with one page.\n+    \/\/ Make sure we always report size <= peak\n+    pi->rssmax = MAX2(info.resident_size_max, info.resident_size);\n+    return true;\n@@ -221,1 +224,3 @@\n-#endif \/\/ __APPLE__\n+  return false;\n+}\n+#endif\n@@ -223,1 +228,8 @@\n-  return rss;\n+size_t os::rss() {\n+#ifdef __APPLE__\n+  os::Bsd::process_info_t info;\n+  if (os::Bsd::query_process_memory_info(&info)) {\n+    return info.rss;\n+  }\n+#endif \/\/ __APPLE__\n+  return 0;\n@@ -2450,4 +2462,7 @@\n-void os::jfr_report_memory_info() {\n-#ifdef __APPLE__\n-  mach_task_basic_info info;\n-  mach_msg_type_number_t count = MACH_TASK_BASIC_INFO_COUNT;\n+#define JFR_WARN_ONCE(text) { \\\n+  static bool first_warning = true; \\\n+  if (first_warning) { \\\n+    log_warning(jfr)(text); \\\n+    first_warning = false; \\\n+  } \\\n+}\n@@ -2455,3 +2470,4 @@\n-  kern_return_t ret = task_info(mach_task_self(), MACH_TASK_BASIC_INFO, (task_info_t)&info, &count);\n-  if (ret == KERN_SUCCESS) {\n-    \/\/ Send the RSS JFR event\n+#ifdef __APPLE__\n+void os::jfr_report_memory_info() {\n+  os::Bsd::process_info_t info;\n+  if (os::Bsd::query_process_memory_info(&info)) {\n@@ -2459,4 +2475,2 @@\n-    event.set_size(info.resident_size);\n-    \/\/ We've seen that resident_size_max sometimes trails resident_size with one page.\n-    \/\/ Make sure we always report size <= peak\n-    event.set_peak(MAX2(info.resident_size_max, info.resident_size));\n+    event.set_size(info.rss);\n+    event.set_peak(info.rssmax);\n@@ -2465,6 +2479,20 @@\n-    \/\/ Log a warning\n-    static bool first_warning = true;\n-    if (first_warning) {\n-      log_warning(jfr)(\"Error fetching RSS values: task_info failed\");\n-      first_warning = false;\n-    }\n+    JFR_WARN_ONCE(\"Error fetching RSS values: task_info failed\");\n+  }\n+}\n+\n+void os::jfr_report_process_size() {\n+  os::Bsd::process_info_t info;\n+  if (os::Bsd::query_process_memory_info(&info)) {\n+    EventProcessSize e;\n+    e.set_vsize(info.vsize);\n+    e.set_rss(info.rss);\n+    e.set_rssPeak(info.rssmax);\n+    e.set_rssAnon(0);\n+    e.set_rssFile(0);\n+    e.set_rssShmem(0);\n+    e.set_committed(0);\n+    e.set_pagetable(0);\n+    e.set_swap(0);\n+    e.commit();\n+  } else {\n+    JFR_WARN_ONCE(\"Error fetching RSS values: task_info failed\");\n@@ -2472,2 +2500,0 @@\n-\n-#endif \/\/ __APPLE__\n@@ -2475,0 +2501,4 @@\n+#else\n+void os::jfr_report_memory_info() {}\n+void os::jfr_report_process_size() {}\n+#endif \/\/ __APPLE__\n@@ -2476,0 +2506,2 @@\n+void os::jfr_report_libc_statistics() {}\n+int os::num_process_threads() { return -1; }\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":57,"deletions":25,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,11 @@\n+\n+  \/\/ Output structure for query_process_memory_info()\n+  struct process_info_t {\n+    \/\/ see mach_task_basic_info_data_t\n+    size_t vsize;      \/\/ current virtual size\n+    size_t rss;        \/\/ current resident set size\n+    size_t rssmax;     \/\/ max resident set size\n+  };\n+\n+  \/\/ Attempts to query memory information about the current process and return it in the output structure.\n+  static bool query_process_memory_info(process_info_t* info);\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-inline bool os::trim_native_heap(os::size_change_t* rss_change) { return false; }\n+inline bool os::trim_native_heap(os::size_change_t& rss_change) { return false; }\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -354,2 +354,2 @@\n-  os::Linux::meminfo_t info;\n-  if (os::Linux::query_process_memory_info(&info)) {\n+  os::Linux::process_info_t info;\n+  if (os::Linux::query_process_info(&info)) {\n@@ -2316,1 +2316,1 @@\n-bool os::Linux::query_process_memory_info(os::Linux::meminfo_t* info) {\n+bool os::Linux::query_process_info(os::Linux::process_info_t* info) {\n@@ -2318,2 +2318,0 @@\n-  const int num_values = sizeof(os::Linux::meminfo_t) \/ sizeof(size_t);\n-  int num_found = 0;\n@@ -2322,1 +2320,4 @@\n-      info->rssanon = info->rssfile = info->rssshmem = -1;\n+      info->rssanon = info->rssfile = info->rssshmem = info->vmpte = -1;\n+  info->threads = info->fdsize = -1;\n+  constexpr int num_values = 11;\n+  int num_found = 0;\n@@ -2332,1 +2333,4 @@\n-           (info->rssshmem == -1  && sscanf(buf, \"RssShmem: %zd kB\", &info->rssshmem) == 1)  \/\/ Needs Linux 4.5\n+           (info->rssshmem == -1  && sscanf(buf, \"RssShmem: %zd kB\", &info->rssshmem) == 1) || \/\/ Needs Linux 4.5\n+           (info->vmpte == -1     && sscanf(buf, \"VmPTE: %zd kB\", &info->vmpte) == 1) || \/\/ Needs Linux 2.6.10\n+           (info->fdsize == -1    && sscanf(buf, \"FDSize: %d\", &info->fdsize) == 1) ||\n+           (info->threads == -1   && sscanf(buf, \"Threads: %d\", &info->threads) == 1)\n@@ -2378,2 +2382,2 @@\n-  meminfo_t info;\n-  if (query_process_memory_info(&info)) {\n+  process_info_t info;\n+  if (query_process_info(&info)) {\n@@ -2663,0 +2667,8 @@\n+#define JFR_WARN_ONCE(text) { \\\n+  static bool first_warning = true; \\\n+  if (first_warning) { \\\n+    log_warning(jfr)(text); \\\n+    first_warning = false; \\\n+  } \\\n+}\n+\n@@ -2664,2 +2676,2 @@\n-  os::Linux::meminfo_t info;\n-  if (os::Linux::query_process_memory_info(&info)) {\n+  os::Linux::process_info_t info;\n+  if (os::Linux::query_process_info(&info)) {\n@@ -2672,6 +2684,36 @@\n-    \/\/ Log a warning\n-    static bool first_warning = true;\n-    if (first_warning) {\n-      log_warning(jfr)(\"Error fetching RSS values: query_process_memory_info failed\");\n-      first_warning = false;\n-    }\n+    JFR_WARN_ONCE(\"Error fetching RSS values: query_process_memory_info failed\");\n+  }\n+}\n+\n+void os::jfr_report_process_size() {\n+  os::Linux::process_info_t info;\n+  if (os::Linux::query_process_info(&info)) {\n+    EventProcessSize e;\n+    e.set_vsize(info.vmsize * K);\n+    e.set_rss(info.vmrss * K);\n+    e.set_rssPeak(info.vmhwm * K);\n+    e.set_rssAnon(info.rssanon * K);\n+    e.set_rssFile(info.rssfile * K);\n+    e.set_rssShmem(info.rssshmem * K);\n+    e.set_committed(0);\n+    e.set_pagetable(info.vmpte * K);\n+    e.set_swap(info.vmswap * K);\n+    e.commit();\n+  } else {\n+    JFR_WARN_ONCE(\"Error fetching ProcessSize: query_process_memory_info failed\");\n+  }\n+}\n+\n+void os::jfr_report_libc_statistics() {\n+#ifdef __GLIBC__\n+  bool might_have_wrapped = false;\n+  os::Linux::glibc_mallinfo mi;\n+  os::Linux::get_mallinfo(&mi, &might_have_wrapped);\n+  if (!might_have_wrapped) {\n+    EventLibcStatistics e;\n+    e.set_mallocOutstanding(mi.uordblks + mi.hblkhd);\n+    e.set_mallocRetained(mi.fordblks);\n+    e.set_trims(mi.num_trims);\n+    e.commit();\n+  } else {\n+    JFR_WARN_ONCE(\"Error libc statistics: too old glibc\");\n@@ -2679,0 +2721,1 @@\n+#endif\n@@ -2683,0 +2726,8 @@\n+int os::num_process_threads() {\n+  os::Linux::process_info_t info;\n+  if (os::Linux::query_process_info(&info)) {\n+    return info.threads; \/\/ These are OS threads\n+  }\n+  return -1;\n+}\n+\n@@ -4875,2 +4926,3 @@\n-  \/\/ might fork and exec without closing all appropriate file descriptors,\n-  \/\/ and this in turn might:\n+  \/\/ might fork and exec without closing all appropriate file descriptors\n+  \/\/ (e.g. as we do in closeDescriptors in UNIXProcess.c), and this in\n+  \/\/ turn might:\n@@ -5311,0 +5363,1 @@\n+static unsigned g_num_trims = 0;\n@@ -5324,0 +5377,1 @@\n+    out->num_trims = g_num_trims;\n@@ -5338,0 +5392,1 @@\n+    out->num_trims = g_num_trims;\n@@ -5353,1 +5408,1 @@\n-bool os::trim_native_heap(os::size_change_t* rss_change) {\n+bool os::trim_native_heap(os::size_change_t& rss_change) {\n@@ -5355,2 +5410,2 @@\n-  os::Linux::meminfo_t info1;\n-  os::Linux::meminfo_t info2;\n+  os::Linux::process_info_t info1;\n+  os::Linux::process_info_t info2;\n@@ -5358,2 +5413,1 @@\n-  bool have_info1 = rss_change != nullptr &&\n-                    os::Linux::query_process_memory_info(&info1);\n+  bool have_info1 = os::Linux::query_process_info(&info1);\n@@ -5361,2 +5415,1 @@\n-  bool have_info2 = rss_change != nullptr && have_info1 &&\n-                    os::Linux::query_process_memory_info(&info2);\n+  bool have_info2 = have_info1 && os::Linux::query_process_info(&info2);\n@@ -5364,10 +5417,8 @@\n-  if (rss_change != nullptr) {\n-    if (have_info1 && have_info2 &&\n-        info1.vmrss != -1 && info2.vmrss != -1 &&\n-        info1.vmswap != -1 && info2.vmswap != -1) {\n-      \/\/ Note: query_process_memory_info returns values in K\n-      rss_change->before = (info1.vmrss + info1.vmswap) * K;\n-      rss_change->after = (info2.vmrss + info2.vmswap) * K;\n-    } else {\n-      rss_change->after = rss_change->before = SIZE_MAX;\n-    }\n+  if (have_info1 && have_info2 &&\n+      info1.vmrss != -1 && info2.vmrss != -1 &&\n+      info1.vmswap != -1 && info2.vmswap != -1) {\n+    \/\/ Note: query_process_memory_info returns values in K\n+    rss_change.before = (info1.vmrss + info1.vmswap) * K;\n+    rss_change.after = (info2.vmrss + info2.vmswap) * K;\n+  } else {\n+    rss_change.after = rss_change.before = SIZE_MAX;\n@@ -5376,0 +5427,2 @@\n+  g_num_trims ++;\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":89,"deletions":36,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -167,2 +167,3 @@\n-  \/\/ Output structure for query_process_memory_info() (all values in KB)\n-  struct meminfo_t {\n+  \/\/ Output structure for query_process_memory_info()\n+  \/\/ (memory values in KB)\n+  struct process_info_t {\n@@ -177,0 +178,3 @@\n+    ssize_t vmpte;      \/\/ size of page table entries (needs 2.6.10)\n+    int threads;        \/\/ number of threads\n+    int fdsize;         \/\/ file descriptor array size\n@@ -182,1 +186,1 @@\n-  static bool query_process_memory_info(meminfo_t* info);\n+  static bool query_process_info(process_info_t* info);\n@@ -455,0 +459,1 @@\n+    unsigned num_trims; \/\/ Number of times the hotspot trimmed by calling os::trim_native_heap.\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"jfr\/jfrEvents.hpp\"\n@@ -29,0 +30,1 @@\n+#include \"utilities\/checkedCast.hpp\"\n@@ -32,0 +34,1 @@\n+#include \"utilities\/ticks.hpp\"\n@@ -38,1 +41,4 @@\n-    if (os::trim_native_heap(&sc)) {\n+    const Ticks ticks1 = Ticks::now();\n+    if (os::trim_native_heap(sc)) {\n+      const Ticks ticks2 = Ticks::now();\n+      const double duration = (ticks2.microseconds() - ticks1.microseconds()) \/ 1000.0; \/\/ millis\n@@ -41,4 +47,3 @@\n-        const size_t delta = sc.after < sc.before ? (sc.before - sc.after) : (sc.after - sc.before);\n-        const char sign = sc.after < sc.before ? '-' : '+';\n-        _output->print_cr(\"RSS+Swap: \" PROPERFMT \"->\" PROPERFMT \" (%c\" PROPERFMT \")\",\n-                          PROPERFMTARGS(sc.before), PROPERFMTARGS(sc.after), sign, PROPERFMTARGS(delta));\n+        const size_t recovered = MIN2((size_t)0, sc.after - sc.before);\n+        _output->print_cr(\"RSS+Swap: \" PROPERFMT \"->\" PROPERFMT \" (-\" PROPERFMT \") (%.3fms)\",\n+                          PROPERFMTARGS(sc.before), PROPERFMTARGS(sc.after), PROPERFMTARGS(recovered), duration);\n@@ -46,2 +51,3 @@\n-        log_info(trimnative)(\"Manual Trim: \" PROPERFMT \"->\" PROPERFMT \" (%c\" PROPERFMT \")\",\n-                             PROPERFMTARGS(sc.before), PROPERFMTARGS(sc.after), sign, PROPERFMTARGS(delta));\n+        log_info(trimnative)(\"Manual Trim: \" PROPERFMT \"->\" PROPERFMT \" (-\" PROPERFMT \") (%.3fms)\",\n+                              PROPERFMTARGS(sc.before), PROPERFMTARGS(sc.after), PROPERFMTARGS(recovered), duration);\n+        JFR_ONLY(EventLibcHeapTrim::commit(ticks1, ticks2, true, duration, sc.before, sc.after, recovered);)\n","filename":"src\/hotspot\/os\/linux\/trimCHeapDCmd.cpp","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -887,2 +887,1 @@\n-size_t os::rss() {\n-  size_t rss = 0;\n+bool os::win32::query_process_memory_info(os::win32::process_info_t* info) {\n@@ -890,1 +889,1 @@\n-  ZeroMemory(&pmex, sizeof(PROCESS_MEMORY_COUNTERS_EX));\n+  ZeroMemory(&pmex, sizeof(pmex));\n@@ -892,2 +891,1 @@\n-  BOOL ret = GetProcessMemoryInfo(\n-      GetCurrentProcess(), (PROCESS_MEMORY_COUNTERS *)&pmex, sizeof(pmex));\n+  const BOOL ret = GetProcessMemoryInfo(GetCurrentProcess(), (PROCESS_MEMORY_COUNTERS*)&pmex, sizeof(pmex));\n@@ -895,1 +893,6 @@\n-    rss = pmex.WorkingSetSize;\n+    info->working_set_size = pmex.WorkingSetSize;\n+    info->working_set_size_peak = pmex.PeakWorkingSetSize;\n+    info->commit_charge = pmex.PagefileUsage;\n+    info->commit_charge_peak = pmex.PeakPagefileUsage;\n+    info->pagefaults = pmex.PageFaultCount;\n+    return true;\n@@ -897,1 +900,1 @@\n-  return rss;\n+  return false;\n@@ -900,0 +903,7 @@\n+size_t os::rss() {\n+  os::win32::process_info_t pi;\n+  if (os::win32::query_process_memory_info(&pi)) {\n+    return pi.working_set_size;\n+  }\n+  return 0;\n+}\n@@ -2144,4 +2154,4 @@\n-  PROCESS_MEMORY_COUNTERS_EX pmex;\n-  ZeroMemory(&pmex, sizeof(PROCESS_MEMORY_COUNTERS_EX));\n-  pmex.cb = sizeof(pmex);\n-  int r2 = GetProcessMemoryInfo(GetCurrentProcess(), (PROCESS_MEMORY_COUNTERS*) &pmex, sizeof(pmex));\n+  os::win32::process_info_t pi;\n+  if (os::win32::query_process_memory_info(&pi)) {\n+    st->print(\"\\ncurrent process WorkingSet (physical memory assigned to process): %zuM, peak: %zuM\",\n+              pi.working_set_size \/ M, pi.working_set_size_peak \/ M);\n@@ -2149,8 +2159,2 @@\n-  if (r2 != 0) {\n-    st->print(\"\\ncurrent process WorkingSet (physical memory assigned to process): \" INT64_FORMAT \"M, \",\n-             (int64_t) pmex.WorkingSetSize >> 20);\n-    st->print(\"peak: \" INT64_FORMAT \"M\\n\", (int64_t) pmex.PeakWorkingSetSize >> 20);\n-\n-    st->print(\"current process commit charge (\\\"private bytes\\\"): \" INT64_FORMAT \"M, \",\n-             (int64_t) pmex.PrivateUsage >> 20);\n-    st->print(\"peak: \" INT64_FORMAT \"M\", (int64_t) pmex.PeakPagefileUsage >> 20);\n+    st->print(\"current process commit charge (\\\"private bytes\\\"): %zuM, peak: %zuM\",\n+              pi.commit_charge \/ M, pi.commit_charge_peak \/ M);\n@@ -6218,4 +6222,7 @@\n-void os::jfr_report_memory_info() {\n-  PROCESS_MEMORY_COUNTERS_EX pmex;\n-  ZeroMemory(&pmex, sizeof(PROCESS_MEMORY_COUNTERS_EX));\n-  pmex.cb = sizeof(pmex);\n+#define JFR_WARN_ONCE(text) { \\\n+  static bool first_warning = true; \\\n+  if (first_warning) { \\\n+    log_warning(jfr)(text); \\\n+    first_warning = false; \\\n+  } \\\n+}\n@@ -6223,3 +6230,3 @@\n-  BOOL ret = GetProcessMemoryInfo(GetCurrentProcess(), (PROCESS_MEMORY_COUNTERS*) &pmex, sizeof(pmex));\n-  if (ret != 0) {\n-    \/\/ Send the RSS JFR event\n+void os::jfr_report_memory_info() {\n+  os::win32::process_info_t pi;\n+  if (os::win32::query_process_memory_info(&pi)) {\n@@ -6227,2 +6234,2 @@\n-    event.set_size(pmex.WorkingSetSize);\n-    event.set_peak(pmex.PeakWorkingSetSize);\n+    event.set_size(pi.working_set_size);\n+    event.set_peak(pi.working_set_size_peak);\n@@ -6231,6 +6238,20 @@\n-    \/\/ Log a warning\n-    static bool first_warning = true;\n-    if (first_warning) {\n-      log_warning(jfr)(\"Error fetching RSS values: GetProcessMemoryInfo failed\");\n-      first_warning = false;\n-    }\n+    JFR_WARN_ONCE(\"Error fetching RSS values: GetProcessMemoryInfo failed\");\n+  }\n+}\n+\n+void os::jfr_report_process_size() {\n+  os::win32::process_info_t pi;\n+  if (os::win32::query_process_memory_info(&pi)) {\n+    EventProcessSize e;\n+    e.set_vsize(0);\n+    e.set_rss(pi.working_set_size);\n+    e.set_rssPeak(pi.working_set_size_peak);\n+    e.set_rssAnon(0);\n+    e.set_rssFile(0);\n+    e.set_rssShmem(0);\n+    e.set_committed(pi.commit_charge);\n+    e.set_pagetable(0);\n+    e.set_swap(0);\n+    e.commit();\n+  } else {\n+    JFR_WARN_ONCE(\"Error fetching RSS values: GetProcessMemoryInfo failed\");\n@@ -6240,0 +6261,3 @@\n+void os::jfr_report_libc_statistics() {}\n+int os::num_process_threads() { return -1; }\n+\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":58,"deletions":34,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -153,0 +153,12 @@\n+\n+  \/\/ Output structure for query_process_memory_info(); see GetProcessMemoryInfo\n+  struct process_info_t {\n+    size_t working_set_size;\n+    size_t working_set_size_peak;\n+    size_t commit_charge;\n+    size_t commit_charge_peak;\n+    unsigned pagefaults;\n+  };\n+\n+  \/\/ Attempts to query memory information about the current process and return it in the output structure.\n+  static bool query_process_memory_info(process_info_t* info);\n","filename":"src\/hotspot\/os\/windows\/os_windows.hpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,1 +91,1 @@\n-inline bool os::trim_native_heap(os::size_change_t* rss_change) { return false; }\n+inline bool os::trim_native_heap(os::size_change_t& rss_change) { return false; }\n","filename":"src\/hotspot\/os\/windows\/os_windows.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -771,1 +771,1 @@\n-    description=\"Total native memory usage for the JVM. Might not be the exact sum of the NativeMemoryUsage events due to timeing.\" period=\"everyChunk\">\n+    description=\"Total native memory usage for the JVM. Might not be the exact sum of the NativeMemoryUsage events due to timing.\" period=\"everyChunk\">\n@@ -891,0 +891,2 @@\n+    <Field type=\"long\" name=\"nonJavaThreadCount\" label=\"Non-Java Threads\" description=\"JVM-internal non-Java threads\" \/>\n+    <Field type=\"long\" name=\"osThreadCount\" label=\"OS Threads\" description=\"Number of OS threads (JVM- and non-JVM-Threads)\" \/>\n@@ -1325,0 +1327,27 @@\n+  <Event name=\"ProcessSize\" category=\"Java Virtual Machine, Memory\" label=\"Process Size\" description=\"Memory sizes related to the process\" thread=\"false\" period=\"everyChunk\">\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"vsize\" label=\"VSize\" description=\"Virtual Size\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"rss\" label=\"RSS\" description=\"Resident Set Size\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"rssPeak\" label=\"Peak RSS\" description=\"Resident Set Size, Peak\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"rssAnon\" label=\"Anon RSS\" description=\"Resident Set Size, Anonymous\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"rssFile\" label=\"File RSS\" description=\"Resident Set Size, File Buffers\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"rssShmem\" label=\"Shmem RSS\" description=\"Resident Set Size, Shared Memory\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"committed\" label=\"Committed\" description=\"Size of the commit charge of the process\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"swap\" label=\"Swap\" description=\"Process memory swapped out\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"pagetable\" label=\"Page Table Size\" description=\"Size of Page Table Entries\" \/>\n+  <\/Event>\n+\n+  <Event name=\"LibcStatistics\" category=\"Java Virtual Machine, Memory\" label=\"Libc Malloc Statistics\" description=\"Malloc Statistics reported by the Libc\" thread=\"false\" period=\"everyChunk\">\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"mallocOutstanding\" label=\"Libc Malloc Outstanding\" description=\"Outstanding Malloc Size\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"mallocRetained\" label=\"Libc Malloc Retained\" description=\"Retained (freed but cached in libc) Malloc size (estimate)\" \/>\n+    <Field type=\"ulong\" name=\"trims\" label=\"libc trims\" description=\"Number of Libc Heap Trims\" \/>\n+  <\/Event>\n+\n+  <Event name=\"LibcHeapTrim\" category=\"Java Virtual Machine, Memory\" label=\"Libc Heap Trim\" thread=\"true\" startTime=\"true\"\n+    description=\"A Libc Trim operation\">\n+    <Field type=\"boolean\" name=\"manual\" label=\"manual\" description=\"True for manual trims, false for periodic automatic trims\" \/>\n+    <Field type=\"double\" contentType=\"millis\" name=\"duration\" label=\"Duration\" description=\"Trim duration\" \/>\n+    <Field type=\"long\" contentType=\"bytes\" name=\"rssPre\" label=\"RSS Before\" description=\"RSS before Trim\" \/>\n+    <Field type=\"long\" contentType=\"bytes\" name=\"rssPost\" label=\"RSS After\" description=\"RSS after Trim\" \/>\n+    <Field type=\"long\" contentType=\"bytes\" name=\"rssRecovered\" label=\"RSS Recovered\" description=\"Amount of RSS Recovered by Trim (estimate)\" \/>\n+  <\/Event>\n+\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+#include \"runtime\/nonJavaThread.hpp\"\n@@ -102,0 +103,8 @@\n+TRACE_REQUEST_FUNC(ProcessSize) {\n+  os::jfr_report_process_size();\n+}\n+\n+TRACE_REQUEST_FUNC(LibcStatistics) {\n+  os::jfr_report_libc_statistics();\n+}\n+\n@@ -551,0 +560,3 @@\n+  const int os_threads = os::num_process_threads();\n+  event.set_osThreadCount(os_threads == -1 ? 0 : os_threads);\n+  event.set_nonJavaThreadCount(NonJavaThread::count());\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrPeriodic.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/nmt\/nmtUsage.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+  static volatile int _count;\n@@ -54,0 +55,1 @@\n+volatile int NonJavaThread::List::_count = 0;\n@@ -81,0 +83,1 @@\n+  Atomic::inc(&_the_list._count);\n@@ -95,0 +98,1 @@\n+    Atomic::dec(&_the_list._count);\n@@ -104,0 +108,4 @@\n+int NonJavaThread::count() {\n+  return Atomic::load(&_the_list._count);\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/nonJavaThread.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,1 @@\n+  static int count();\n","filename":"src\/hotspot\/share\/runtime\/nonJavaThread.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -497,1 +497,1 @@\n-  static bool trim_native_heap(size_change_t* rss_change = nullptr);\n+  static bool trim_native_heap(size_change_t& rss_change);\n@@ -852,0 +852,7 @@\n+  static void jfr_report_process_size() NOT_JFR_RETURN();\n+  static void jfr_report_libc_statistics() NOT_JFR_RETURN();\n+\n+  \/\/ Returns number of OS threads for the calling process; -1 if the information cannot be obtained.\n+  \/\/ Note: this includes, but is not limited to, the number of threads the JVM has created or that\n+  \/\/ are attached to it. It may be higher if many threads are created outside the JVM.\n+  static int num_process_threads();\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"jfr\/jfrEvents.hpp\"\n@@ -39,0 +40,1 @@\n+#include \"utilities\/ticks.hpp\"\n@@ -140,4 +142,4 @@\n-    const bool logging_enabled = lt.is_enabled();\n-\n-    \/\/ We only collect size change information if we are logging; save the access to procfs otherwise.\n-    if (os::trim_native_heap(logging_enabled ? &sc : nullptr)) {\n+    const Ticks ticks1 = Ticks::now();\n+    if (os::trim_native_heap(sc)) {\n+      const Ticks ticks2 = Ticks::now();\n+      const double duration = (ticks2.microseconds() - ticks1.microseconds()) \/ 1000.0; \/\/ millis\n@@ -145,2 +147,1 @@\n-      if (logging_enabled) {\n-        double t2 = now();\n+      if (lt.is_enabled()) {\n@@ -148,3 +149,2 @@\n-          const size_t delta = sc.after < sc.before ? (sc.before - sc.after) : (sc.after - sc.before);\n-          const char sign = sc.after < sc.before ? '-' : '+';\n-          log_info(trimnative)(\"Periodic Trim (\" UINT64_FORMAT \"): \" PROPERFMT \"->\" PROPERFMT \" (%c\" PROPERFMT \") %.3fms\",\n+          const size_t recovered = MIN2((size_t)0, sc.after - sc.before);\n+          log_info(trimnative)(\"Periodic Trim (\" UINT64_FORMAT \"): \" PROPERFMT \"->\" PROPERFMT \" (-\" PROPERFMT \") (%.3fms)\",\n@@ -152,2 +152,2 @@\n-                               PROPERFMTARGS(sc.before), PROPERFMTARGS(sc.after), sign, PROPERFMTARGS(delta),\n-                               to_ms(t2 - t1));\n+                               PROPERFMTARGS(sc.before), PROPERFMTARGS(sc.after), PROPERFMTARGS(recovered), duration);\n+          JFR_ONLY(EventLibcHeapTrim::commit(ticks1, ticks2, false, duration, sc.before, sc.after, recovered);)\n@@ -156,2 +156,1 @@\n-                               _num_trims_performed,\n-                               to_ms(t2 - t1));\n+                               _num_trims_performed, duration);\n","filename":"src\/hotspot\/share\/runtime\/trimNativeHeap.cpp","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1510,0 +1510,1 @@\n+  st->cr();\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -968,0 +968,15 @@\n+    <event name=\"jdk.ProcessSize\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"period\">5000 ms<\/setting>\n+    <\/event>\n+\n+    <event name=\"jdk.LibcStatistics\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"period\">5000 ms<\/setting>\n+    <\/event>\n+\n+    <event name=\"jdk.LibcHeapTrim\">\n+      <setting name=\"enabled\">false<\/setting>\n+      <setting name=\"threshold\">0 ms<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -968,0 +968,15 @@\n+    <event name=\"jdk.ProcessSize\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"period\">1000 ms<\/setting>\n+    <\/event>\n+\n+    <event name=\"jdk.LibcStatistics\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"period\">1000 ms<\/setting>\n+    <\/event>\n+\n+    <event name=\"jdk.LibcHeapTrim\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"threshold\">0 ms<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1033,1 +1033,1 @@\n-  EXPECT_TRUE(os::trim_native_heap(&sc));\n+  EXPECT_TRUE(os::trim_native_heap(sc));\n@@ -1043,2 +1043,0 @@\n-  \/\/ Should also work\n-  EXPECT_TRUE(os::trim_native_heap());\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -564,1 +564,4 @@\n-    jdk\/jfr\/api\/consumer\/recordingstream\/TestBasics.java\n+    jdk\/jfr\/api\/consumer\/recordingstream\/TestBasics.java \\\n+    jdk\/jfr\/event\/runtime\/TestProcessSizeEvent.java \\\n+    jdk\/jfr\/event\/runtime\/TestLibcStatisticsEvent.java \\\n+    jdk\/jfr\/event\/runtime\/TestLibcHeapTrimEvent.java \\\n","filename":"test\/jdk\/TEST.groups","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -77,0 +77,3 @@\n+            Events.assertField(event, \"nonJavaThreadCount\").atLeast(1L).getValue();\n+            Events.assertField(event, \"osThreadCount\").atLeast(activeCount).atLeast(1L).atMost(200L).getValue();\n+\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestJavaThreadStatisticsEvent.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, IBM Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.runtime;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * @test\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @library \/test\/lib\n+ * @modules jdk.jfr\n+ *          jdk.management\n+ * @run main\/othervm -Xmx64m -Xlog:trimnative -XX:TrimNativeHeapInterval=200 jdk.jfr.event.runtime.TestLibcHeapTrimEvent\n+ *\/\n+public class TestLibcHeapTrimEvent {\n+    private final static long K = 1024;\n+    private final static long M = K * K;\n+    private final static long G = M * K;\n+    private final static long sleepTime = 5000; \/\/ Time enough for the trimmer thread to get started and engaged\n+\n+    private static ArrayList<byte[]> data = new ArrayList<byte[]>();\n+\n+    private static void generateEvents(Recording recording) throws Exception {\n+        recording.enable(EventNames.LibcHeapTrim);\n+\n+        recording.start();\n+\n+        Thread.sleep(sleepTime);\n+\n+        recording.stop();\n+    }\n+\n+    private static void verifyExpectedEvents(List<RecordedEvent> events) throws Exception {\n+        List<RecordedEvent> filteredEvents = events.stream().filter(e -> e.getEventType().getName().equals(EventNames.LibcHeapTrim)).toList();\n+\n+System.out.println(\"COUNT \" + events.stream().count());\n+System.out.println(events.stream().collect(Collectors.toList()));\n+\n+        assertGreaterThan(filteredEvents.size(), 0, \"Should exist events of type: \" + EventNames.LibcHeapTrim);\n+\n+        for (RecordedEvent event : filteredEvents) {\n+            System.out.println(event);\n+            double duration = event.getLong(\"duration\");\n+            long rssPre = event.getLong(\"rssPre\");\n+            long rssPost = event.getLong(\"rssPost\");\n+            long rssRecovered = event.getLong(\"rssRecovered\");\n+\n+            long reasonableHigh = G;\n+            assertGreaterThan(rssPre, 0L, \"Must be\");\n+            assertLessThan(rssPre, reasonableHigh, \"Must be\");\n+\n+            assertGreaterThan(rssPost, 0L, \"Must be\");\n+            assertLessThan(rssPost, reasonableHigh, \"Must be\");\n+\n+            assertGreaterThanOrEqual(rssRecovered, 0L, \"Must be\");\n+            assertLessThan(rssRecovered, rssPre, \"Must be\");\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        try (Recording recording = new Recording()) {\n+            generateEvents(recording);\n+            var events = Events.fromRecording(recording);\n+            verifyExpectedEvents(events);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestLibcHeapTrimEvent.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, IBM Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.runtime;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * @test\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @library \/test\/lib\n+ * @modules jdk.jfr\n+ *          jdk.management\n+ * @run main\/othervm -Xmx64m -XX:TrimNativeHeapInterval=250 -XX:+UnlockDiagnosticVMOptions -XX:+PrintNMTStatistics jdk.jfr.event.runtime.TestLibcStatisticsEvent\n+ *\/\n+public class TestLibcStatisticsEvent {\n+    private final static String LibcStatisticsEventName = EventNames.LibcStatistics;\n+\n+    private final static long K = 1024;\n+    private final static long M = K * K;\n+    private final static long G = M * K;\n+    private final static long toAllocate = M * 64;\n+    private final static long sleepTime = 3000;\n+\n+    private static ArrayList<byte[]> data = new ArrayList<byte[]>();\n+\n+    private static void doNoisyThings() throws InterruptedException {\n+        \/\/ Allocate some memory in the C-Heap (using DBBs).\n+        \/\/ Touch that memory to drive up RSS.\n+        long bufferSize = M;\n+        long numBuffers = toAllocate \/ bufferSize;\n+        ByteBuffer[] list = new ByteBuffer[(int)numBuffers];\n+        for (int i = 0; i < list.length; i++) {\n+            list[i] = ByteBuffer.allocateDirect((int)bufferSize);\n+        }\n+        for (ByteBuffer b : list) {\n+            while (b.position() < b.capacity()) {\n+                b.put((byte) 'A');\n+                if (b.position() < (b.capacity() - K)) {\n+                    b.position(b.position() + (int)K);\n+                }\n+            }\n+        }\n+        Thread.sleep(sleepTime);\n+    }\n+\n+    private static void generateEvents(Recording recording) throws Exception {\n+        recording.enable(LibcStatisticsEventName).with(\"period\", \"250ms\");\n+\n+        recording.start();\n+\n+        doNoisyThings();\n+\n+        recording.stop();\n+    }\n+\n+    private static void verifyExpectedEvents(List<RecordedEvent> events) throws Exception {\n+        List<RecordedEvent> filteredEvents = events.stream().filter(e -> e.getEventType().getName().equals(LibcStatisticsEventName)).toList();\n+\n+        assertGreaterThan(filteredEvents.size(), 0, \"Should exist events of type: \" + LibcStatisticsEventName);\n+\n+        long mallocOutstanding = 0, mallocRetained = 0;\n+        long trims = 0;\n+\n+        RecordedEvent last = null;\n+        for (RecordedEvent event : filteredEvents) {\n+            System.out.println(event);\n+            mallocOutstanding = event.getLong(\"mallocOutstanding\");\n+            mallocRetained = event.getLong(\"mallocRetained\");\n+            trims = event.getLong(\"trims\");\n+\n+            long reasonableLow = K; \/\/ probably a lot more, but the very first events may not show much yet\n+            long reasonableLimit = G; \/\/ probably a lot less\n+            assertGreaterThan(mallocOutstanding, reasonableLow);\n+            assertLessThan(mallocOutstanding, reasonableLimit);\n+\n+            assertGreaterThan(mallocRetained, 0L);\n+            assertLessThan(mallocRetained, reasonableLimit);\n+\n+            last = event;\n+        }\n+\n+        assertNotNull(last);\n+        \/\/ we activated periodic trims and by the time the last event was taken we should see them\n+        assertGreaterThan(trims, 0L, \"Must be\");\n+        \/\/ by this time we also should have allocated the majority of what we allocate\n+        assertGreaterThan(mallocOutstanding, toAllocate \/ 2, \"Must be\");\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        try (Recording recording = new Recording()) {\n+            generateEvents(recording);\n+            var events = Events.fromRecording(recording);\n+            verifyExpectedEvents(events);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestLibcStatisticsEvent.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,147 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, IBM Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.runtime;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * @test\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @requires (os.family != \"aix\")\n+ * @library \/test\/lib\n+ * @modules jdk.jfr\n+ *          jdk.management\n+ * @run main\/othervm -Xmx64m -XX:+UnlockDiagnosticVMOptions -XX:+PrintVMInfoAtExit jdk.jfr.event.runtime.TestProcessSizeEvent\n+ *\/\n+public class TestProcessSizeEvent {\n+    private final static String ProcessSizeEventName = EventNames.ProcessSize;\n+    private final static String LibcStatisticsEventName = EventNames.LibcStatistics;\n+\n+    private final static long K = 1024;\n+    private final static long M = K * K;\n+    private final static long G = M * K;\n+    private final static long toAllocate = M * 16;\n+    private final static long sleepTime = 3000;\n+\n+    private static ArrayList<byte[]> data = new ArrayList<byte[]>();\n+\n+    private static void doNoisyThings() throws InterruptedException {\n+        \/\/ Allocate some memory in the C-Heap (using DBBs).\n+        \/\/ Touch that memory to drive up RSS.\n+        long bufferSize = M;\n+        long numBuffers = toAllocate \/ bufferSize;\n+        ByteBuffer[] list = new ByteBuffer[(int)numBuffers];\n+        for (int i = 0; i < list.length; i++) {\n+            list[i] = ByteBuffer.allocateDirect((int)bufferSize);\n+        }\n+        for (ByteBuffer b : list) {\n+            while (b.position() < b.capacity()) {\n+                b.put((byte) 'A');\n+                if (b.position() < (b.capacity() - K)) {\n+                    b.position(b.position() + (int)K);\n+                }\n+            }\n+        }\n+        Thread.sleep(sleepTime);\n+    }\n+\n+    private static void generateEvents(Recording recording) throws Exception {\n+        recording.enable(ProcessSizeEventName).with(\"period\", \"250ms\");\n+\n+        recording.start();\n+\n+        doNoisyThings();\n+\n+        recording.stop();\n+    }\n+\n+    final static long reasonableVsizeHigh = G * 10000;\n+    final static long reasonableVsizeLow = 100 * M;\n+    final static long reasonableRSSHigh = G;\n+    \/\/ We may run on undersized test machines, in which case the test may be heavily swapping. This in turn\n+    \/\/ can falsify the reported RSS (which is why we report Swap as a metric, too).\n+    \/\/ To avoid false positives, RSS low is chosen to be a very defensive low number.\n+    final static long reasonableRSSLow = 5 * M;\n+\n+    private static void verifyExpectedEventLinux(RecordedEvent event) throws Exception {\n+        long vsize = Events.assertField(event, \"vsize\").\n+                atLeast(reasonableVsizeLow).atMost(reasonableVsizeHigh).getValue();\n+        long rss = Events.assertField(event, \"rss\").\n+                atLeast(reasonableRSSLow).atMost(reasonableRSSHigh).atMost(vsize).getValue();\n+        Events.assertField(event, \"rssPeak\").atLeast(rss).atMost(reasonableRSSHigh);\n+        Events.assertField(event, \"rssPeak\").atLeast(rss).atMost(reasonableRSSHigh);\n+        Events.assertField(event, \"rssAnon\").atLeast(reasonableRSSLow \/ 8).atMost(reasonableRSSHigh).atMost(rss);\n+        Events.assertField(event, \"rssFile\").atLeast(0L).atMost(reasonableRSSHigh).atMost(rss);\n+        Events.assertField(event, \"rssShmem\").atLeast(0L).atMost(reasonableRSSHigh).atMost(rss);\n+        Events.assertField(event, \"swap\").atLeast(0L).atMost(vsize);\n+        Events.assertField(event, \"pagetable\").atLeast(0L).atMost(vsize \/ 8);\n+    }\n+\n+    private static void verifyExpectedEventWindows(RecordedEvent event) throws Exception {\n+        long rss = Events.assertField(event, \"rss\").\n+                atLeast(reasonableRSSLow).atMost(reasonableRSSHigh).getValue();\n+        Events.assertField(event, \"rssPeak\").atLeast(rss).atMost(reasonableRSSHigh);\n+        Events.assertField(event, \"committed\").atLeast(4 * K).atMost(reasonableVsizeHigh);\n+    }\n+\n+    private static void verifyExpectedEventMacOS(RecordedEvent event) throws Exception {\n+        long vsize = Events.assertField(event, \"vsize\").\n+                atLeast(reasonableVsizeLow).atMost(reasonableVsizeHigh).getValue();\n+        long rss = Events.assertField(event, \"rss\").\n+                atLeast(reasonableRSSLow).atMost(reasonableRSSHigh).atMost(vsize).getValue();\n+        Events.assertField(event, \"rssPeak\").atLeast(rss).atMost(reasonableRSSHigh);\n+    }\n+\n+    private static void verifyExpectedEvents(List<RecordedEvent> events) throws Exception {\n+        List<RecordedEvent> filteredEvents = events.stream().filter(e -> e.getEventType().getName().equals(ProcessSizeEventName)).toList();\n+        assertGreaterThan(filteredEvents.size(), 0, \"Should exist events of type: \" + ProcessSizeEventName);\n+        for (RecordedEvent event : filteredEvents) {\n+            System.out.println(event);\n+            if (Platform.isLinux()) verifyExpectedEventLinux(event);\n+            else if (Platform.isWindows()) verifyExpectedEventWindows(event);\n+            else if (Platform.isOSX()) verifyExpectedEventMacOS(event);\n+            else throw new RuntimeException(\"Unsupported OS\");\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        try (Recording recording = new Recording()) {\n+            generateEvents(recording);\n+            var events = Events.fromRecording(recording);\n+            verifyExpectedEvents(events);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestProcessSizeEvent.java","additions":147,"deletions":0,"binary":false,"changes":147,"status":"added"},{"patch":"@@ -198,0 +198,3 @@\n+    public static final String ProcessSize = PREFIX + \"ProcessSize\";\n+    public static final String LibcStatistics = PREFIX + \"LibcStatistics\";\n+    public static final String LibcHeapTrim = PREFIX + \"LibcHeapTrim\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}