{"files":[{"patch":"@@ -2624,2 +2624,2 @@\n-  G1CollectionSetCandidates* candidates = G1CollectedHeap::heap()->collection_set()->candidates();\n-  return candidates != nullptr && candidates->num_remaining() > 0;\n+  const G1CollectionSetCandidates* candidates = collection_set()->candidates();\n+  return !candidates->is_empty();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -921,0 +921,2 @@\n+  inline bool is_collection_set_candidate(const HeapRegion* r) const;\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -285,0 +285,5 @@\n+inline bool G1CollectedHeap::is_collection_set_candidate(const HeapRegion* r) const {\n+  const G1CollectionSetCandidates* candidates = collection_set()->candidates();\n+  return candidates->contains(r);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -53,4 +53,1 @@\n-  _candidates(nullptr),\n-  _eden_region_length(0),\n-  _survivor_region_length(0),\n-  _old_region_length(0),\n+  _candidates(),\n@@ -60,1 +57,4 @@\n-  _num_optional_regions(0),\n+  _eden_region_length(0),\n+  _survivor_region_length(0),\n+  _initial_old_region_length(0),\n+  _optional_old_regions(),\n@@ -67,2 +67,1 @@\n-  free_optional_regions();\n-  clear_candidates();\n+  abandon_all_candidates();\n@@ -78,1 +77,1 @@\n-  assert((size_t) young_region_length() == _collection_set_cur_length,\n+  assert((size_t)young_region_length() == _collection_set_cur_length,\n@@ -81,2 +80,2 @@\n-  _old_region_length = 0;\n-  free_optional_regions();\n+  _initial_old_region_length = 0;\n+  _optional_old_regions.clear();\n@@ -89,1 +88,0 @@\n-}\n@@ -91,2 +89,1 @@\n-void G1CollectionSet::free_optional_regions() {\n-  _num_optional_regions = 0;\n+  _candidates.initialize(max_region_length);\n@@ -95,3 +92,4 @@\n-void G1CollectionSet::clear_candidates() {\n-  delete _candidates;\n-  _candidates = nullptr;\n+void G1CollectionSet::abandon_all_candidates() {\n+  _candidates.clear();\n+  _initial_old_region_length = 0;\n+  _optional_old_regions.clear();\n@@ -100,1 +98,0 @@\n-\/\/ Add the heap region at the head of the non-incremental collection set\n@@ -113,2 +110,1 @@\n-\n-  _old_region_length++;\n+  _initial_old_region_length++;\n@@ -119,9 +115,0 @@\n-void G1CollectionSet::add_optional_region(HeapRegion* hr) {\n-  assert(hr->is_old(), \"the region should be old\");\n-  assert(!hr->in_collection_set(), \"should not already be in the CSet\");\n-\n-  _g1h->register_optional_region_with_region_attr(hr);\n-\n-  hr->set_index_in_opt_cset(_num_optional_regions++);\n-}\n-\n@@ -168,2 +155,1 @@\n-  for (uint i = 0; i < _num_optional_regions; i++) {\n-    HeapRegion* r = _candidates->at(i);\n+  for (HeapRegion* r : _optional_old_regions) {\n@@ -340,2 +326,2 @@\n-    uint num_initial_old_regions;\n-    uint num_optional_old_regions;\n+    G1CollectionCandidateRegionList initial_old_regions;\n+    assert(_optional_old_regions.length() == 0, \"must be\");\n@@ -343,4 +329,4 @@\n-    _policy->calculate_old_collection_set_regions(candidates(),\n-                                                  time_remaining_ms,\n-                                                  num_initial_old_regions,\n-                                                  num_optional_old_regions);\n+    _policy->select_candidates_from_marking(&candidates()->marking_regions(),\n+                                            time_remaining_ms,\n+                                            &initial_old_regions,\n+                                            &_optional_old_regions);\n@@ -348,8 +334,4 @@\n-    \/\/ Prepare initial old regions.\n-    move_candidates_to_collection_set(num_initial_old_regions);\n-\n-    \/\/ Prepare optional old regions for evacuation.\n-    uint candidate_idx = candidates()->cur_idx();\n-    for (uint i = 0; i < num_optional_old_regions; i++) {\n-      add_optional_region(candidates()->at(candidate_idx + i));\n-    }\n+    \/\/ Move initially selected old regions to collection set directly.\n+    move_candidates_to_collection_set(&initial_old_regions);\n+    \/\/ Only prepare selected optional regions for now.\n+    prepare_optional_regions(&_optional_old_regions);\n@@ -358,0 +340,2 @@\n+  } else {\n+    log_debug(gc, ergo, cset)(\"No candidates to reclaim.\");\n@@ -368,9 +352,2 @@\n-void G1CollectionSet::move_candidates_to_collection_set(uint num_old_candidate_regions) {\n-  if (num_old_candidate_regions == 0) {\n-    return;\n-  }\n-  uint candidate_idx = candidates()->cur_idx();\n-  for (uint i = 0; i < num_old_candidate_regions; i++) {\n-    HeapRegion* r = candidates()->at(candidate_idx + i);\n-    \/\/ This potentially optional candidate region is going to be an actual collection\n-    \/\/ set region. Clear cset marker.\n+void G1CollectionSet::move_candidates_to_collection_set(G1CollectionCandidateRegionList* regions) {\n+  for (HeapRegion* r : *regions) {\n@@ -380,1 +357,8 @@\n-  candidates()->remove(num_old_candidate_regions);\n+  candidates()->remove(regions);\n+}\n+\n+void G1CollectionSet::prepare_optional_regions(G1CollectionCandidateRegionList* regions){\n+  uint cur_index = 0;\n+  for (HeapRegion* r : *regions) {\n+    assert(r->is_old(), \"the region should be old\");\n+    assert(!r->in_collection_set(), \"should not already be in the CSet\");\n@@ -382,1 +366,4 @@\n-  candidates()->verify();\n+    _g1h->register_optional_region_with_region_attr(r);\n+\n+    r->set_index_in_opt_cset(cur_index++);\n+  }\n@@ -393,3 +380,2 @@\n-  uint num_selected_regions;\n-  _policy->calculate_optional_collection_set_regions(candidates(),\n-                                                     _num_optional_regions,\n+  G1CollectionCandidateRegionList selected_regions;\n+  _policy->calculate_optional_collection_set_regions(&_optional_old_regions,\n@@ -397,1 +383,1 @@\n-                                                     num_selected_regions);\n+                                                     &selected_regions);\n@@ -399,1 +385,1 @@\n-  move_candidates_to_collection_set(num_selected_regions);\n+  move_candidates_to_collection_set(&selected_regions);\n@@ -401,1 +387,1 @@\n-  _num_optional_regions -= num_selected_regions;\n+  _optional_old_regions.remove_prefix(&selected_regions);\n@@ -407,1 +393,1 @@\n-  return num_selected_regions > 0;\n+  return selected_regions.length() > 0;\n@@ -411,2 +397,1 @@\n-  for (uint i = 0; i < _num_optional_regions; i++) {\n-    HeapRegion* r = candidates()->at(candidates()->cur_idx() + i);\n+  for (HeapRegion* r : _optional_old_regions) {\n@@ -420,1 +405,1 @@\n-  free_optional_regions();\n+  _optional_old_regions.clear();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":50,"deletions":65,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/g1\/g1CollectionSetCandidates.hpp\"\n@@ -32,1 +33,0 @@\n-class G1CollectionSetCandidates;\n@@ -136,6 +136,2 @@\n-  \/\/ All old gen collection set candidate regions for the current mixed phase.\n-  G1CollectionSetCandidates* _candidates;\n-\n-  uint _eden_region_length;\n-  uint _survivor_region_length;\n-  uint _old_region_length;\n+  \/\/ All old gen collection set candidate regions.\n+  G1CollectionSetCandidates _candidates;\n@@ -153,0 +149,4 @@\n+  uint _eden_region_length;\n+  uint _survivor_region_length;\n+  uint _initial_old_region_length;\n+\n@@ -154,4 +154,2 @@\n-  \/\/ will be collected only if there is enough time. We call these optional regions.\n-  \/\/ This member records the current number of regions that are of that type that\n-  \/\/ correspond to the first x entries in the collection set candidates.\n-  uint _num_optional_regions;\n+  \/\/ will be collected only if there is enough time. We call these optional (old) regions.\n+  G1CollectionCandidateRegionList _optional_old_regions;\n@@ -175,1 +173,1 @@\n-  \/\/ Add old region \"hr\" to the collection set.\n+  \/\/ Add the given old region to the head of the current collection set.\n@@ -177,1 +175,0 @@\n-  void free_optional_regions();\n@@ -179,4 +176,4 @@\n-  \/\/ Add old region \"hr\" to optional collection set.\n-  void add_optional_region(HeapRegion* hr);\n-\n-  void move_candidates_to_collection_set(uint num_regions);\n+  void move_candidates_to_collection_set(G1CollectionCandidateRegionList* regions);\n+  \/\/ Prepares old regions in the given set for optional collection later. Does not\n+  \/\/ add the region to collection set yet.\n+  void prepare_optional_regions(G1CollectionCandidateRegionList* regions);\n@@ -211,1 +208,1 @@\n-  void clear_candidates();\n+  void abandon_all_candidates();\n@@ -213,5 +210,2 @@\n-  void set_candidates(G1CollectionSetCandidates* candidates) {\n-    assert(_candidates == nullptr, \"Trying to replace collection set candidates.\");\n-    _candidates = candidates;\n-  }\n-  G1CollectionSetCandidates* candidates() { return _candidates; }\n+  G1CollectionSetCandidates* candidates() { return &_candidates; }\n+  const G1CollectionSetCandidates* candidates() const { return &_candidates; }\n@@ -223,1 +217,1 @@\n-                                            old_region_length(); }\n+                                            initial_old_region_length(); }\n@@ -227,1 +221,1 @@\n-  uint eden_region_length() const     { return _eden_region_length;     }\n+  uint eden_region_length() const     { return _eden_region_length; }\n@@ -229,2 +223,4 @@\n-  uint old_region_length() const      { return _old_region_length;      }\n-  uint optional_region_length() const { return _num_optional_regions; }\n+  uint initial_old_region_length() const      { return _initial_old_region_length; }\n+  uint optional_region_length() const { return _optional_old_regions.length(); }\n+\n+  bool only_contains_young_regions() const { return (initial_old_region_length() + optional_region_length()) == 0; }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.hpp","additions":23,"deletions":27,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+#include \"utilities\/bitMap.inline.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n@@ -30,5 +32,30 @@\n-void G1CollectionSetCandidates::remove(uint num_regions) {\n-  assert(num_regions <= num_remaining(), \"Trying to remove more regions (%u) than available (%u)\", num_regions, num_remaining());\n-  for (uint i = 0; i < num_regions; i++) {\n-    _remaining_reclaimable_bytes -= at(_front_idx)->reclaimable_bytes();\n-    _front_idx++;\n+G1CollectionCandidateList::G1CollectionCandidateList() : _candidates(2, mtGC) { }\n+\n+void G1CollectionCandidateList::set(G1CollectionCandidateList::CandidateInfo* candidate_infos, uint num_infos) {\n+  assert(_candidates.is_empty(), \"must be\");\n+\n+  GrowableArrayFromArray<G1CollectionCandidateList::CandidateInfo> a(candidate_infos, (int)num_infos);\n+  _candidates.appendAll(&a);\n+}\n+\n+void G1CollectionCandidateList::remove(G1CollectionCandidateRegionList* other) {\n+  guarantee((uint)_candidates.length() >= other->length(), \"must be\");\n+\n+  if (other->length() == 0) {\n+    \/\/ Nothing to remove or nothing in the original set.\n+    return;\n+  }\n+\n+  \/\/ Create a list from scratch, copying over the elements from the candidate\n+  \/\/ list not in the other list. Finally deallocate and overwrite the old list.\n+  int new_length = _candidates.length() - other->length();\n+  GrowableArray<CandidateInfo> new_list(new_length, mtGC);\n+\n+  uint other_idx = 0;\n+\n+  for (uint candidate_idx = 0; candidate_idx < (uint)_candidates.length(); candidate_idx++) {\n+    if ((other_idx == other->length()) || _candidates.at(candidate_idx)._r != other->at(other_idx)) {\n+      new_list.append(_candidates.at(candidate_idx));\n+    } else {\n+      other_idx++;\n+    }\n@@ -36,0 +63,4 @@\n+  _candidates.swap(&new_list);\n+\n+  verify();\n+  assert(_candidates.length() == new_length, \"must be %u %u\", _candidates.length(), new_length);\n@@ -38,2 +69,3 @@\n-void G1CollectionSetCandidates::remove_from_end(uint num_remove, size_t wasted) {\n-  assert(num_remove <= num_remaining(), \"trying to remove more regions than remaining\");\n+void G1CollectionCandidateList::clear() {\n+  _candidates.clear();\n+}\n@@ -41,2 +73,3 @@\n-#ifdef ASSERT\n-  size_t reclaimable = 0;\n+#ifndef PRODUCT\n+void G1CollectionCandidateList::verify() {\n+  CandidateInfo* prev = nullptr;\n@@ -44,5 +77,21 @@\n-  for (uint i = 0; i < num_remove; i++) {\n-    uint cur_idx = _num_regions - i - 1;\n-    reclaimable += at(cur_idx)->reclaimable_bytes();\n-    \/\/ Make sure we crash if we access it.\n-    _regions[cur_idx] = nullptr;\n+  for (uint i = 0; i < (uint)_candidates.length(); i++) {\n+    CandidateInfo& ci = _candidates.at(i);\n+    assert(prev == nullptr || prev->_gc_efficiency >= ci._gc_efficiency,\n+           \"Stored gc efficiency must be descending from region %u to %u\",\n+           prev->_r->hrm_index(), ci._r->hrm_index());\n+    prev = &ci;\n+    assert(ci._r->rem_set()->is_tracked(), \"remset for region %u must be tracked\", ci._r->hrm_index());\n+  }\n+}\n+#endif\n+\n+int G1CollectionCandidateList::compare(CandidateInfo* ci1, CandidateInfo* ci2) {\n+  \/\/ Make sure that null entries are moved to the end.\n+  if (ci1->_r == nullptr) {\n+    if (ci2->_r == nullptr) {\n+      return 0;\n+    } else {\n+      return 1;\n+    }\n+  } else if (ci2->_r == nullptr) {\n+    return -1;\n@@ -51,1 +100,27 @@\n-  assert(reclaimable == wasted, \"Recalculated reclaimable inconsistent\");\n+  double gc_eff1 = ci1->_gc_efficiency;\n+  double gc_eff2 = ci2->_gc_efficiency;\n+\n+  if (gc_eff1 > gc_eff2) {\n+    return -1;\n+  } if (gc_eff1 < gc_eff2) {\n+    return 1;\n+  } else {\n+    return 0;\n+  }\n+}\n+\n+G1CollectionCandidateRegionList::G1CollectionCandidateRegionList() : _regions(2, mtGC) { }\n+\n+void G1CollectionCandidateRegionList::append(HeapRegion* r) {\n+  assert(!_regions.contains(r), \"must be\");\n+  _regions.append(r);\n+}\n+\n+void G1CollectionCandidateRegionList::remove_prefix(G1CollectionCandidateRegionList* other) {\n+#ifdef ASSERT\n+  \/\/ Check that the given list is a prefix of this list.\n+  int i = 0;\n+  for (HeapRegion* r : *other) {\n+    assert(_regions.at(i) == r, \"must be in order, but element %d is not\", i);\n+    i++;\n+  }\n@@ -53,2 +128,5 @@\n-  _num_regions -= num_remove;\n-  _remaining_reclaimable_bytes -= wasted;\n+\n+  if (other->length() == 0) {\n+    return;\n+  }\n+  _regions.remove_till(other->length());\n@@ -57,7 +135,35 @@\n-void G1CollectionSetCandidates::iterate(HeapRegionClosure* cl) {\n-  for (uint i = _front_idx; i < _num_regions; i++) {\n-    HeapRegion* r = _regions[i];\n-    if (cl->do_heap_region(r)) {\n-      cl->set_incomplete();\n-      break;\n-    }\n+HeapRegion* G1CollectionCandidateRegionList::at(uint index) {\n+  return _regions.at(index);\n+}\n+\n+void G1CollectionCandidateRegionList::clear() {\n+  _regions.clear();\n+}\n+\n+G1CollectionSetCandidates::G1CollectionSetCandidates() :\n+  _marking_regions(),\n+  _contains_map(nullptr),\n+  _max_regions(0),\n+  _last_marking_candidates_length(0)\n+{ }\n+\n+G1CollectionSetCandidates::~G1CollectionSetCandidates() {\n+  FREE_C_HEAP_ARRAY(CandidateOrigin, _contains_map);\n+}\n+\n+bool G1CollectionSetCandidates::is_from_marking(HeapRegion* r) const {\n+  assert(contains(r), \"must be\");\n+  return _contains_map[r->hrm_index()] == CandidateOrigin::Marking;\n+}\n+\n+void G1CollectionSetCandidates::initialize(uint max_regions) {\n+  assert(_contains_map == nullptr, \"already initialized\");\n+  _max_regions = max_regions;\n+  _contains_map = NEW_C_HEAP_ARRAY(CandidateOrigin, max_regions, mtGC);\n+  clear();\n+}\n+\n+void G1CollectionSetCandidates::clear() {\n+  _marking_regions.clear();\n+  for (uint i = 0; i < _max_regions; i++) {\n+    _contains_map[i] = CandidateOrigin::Invalid;\n@@ -65,0 +171,1 @@\n+  _last_marking_candidates_length = 0;\n@@ -67,7 +174,23 @@\n-void G1CollectionSetCandidates::iterate_backwards(HeapRegionClosure* cl) {\n-  for (uint i = _num_regions; i > _front_idx; i--) {\n-    HeapRegion* r = _regions[i - 1];\n-    if (cl->do_heap_region(r)) {\n-      cl->set_incomplete();\n-      break;\n-    }\n+void G1CollectionSetCandidates::set_candidates_from_marking(G1CollectionCandidateList::CandidateInfo* candidate_infos,\n+                                                            uint num_infos) {\n+  assert(_marking_regions.length() == 0, \"must be empty before adding new ones\");\n+\n+  verify();\n+\n+  _marking_regions.set(candidate_infos, num_infos);\n+  for (uint i = 0; i < num_infos; i++) {\n+    HeapRegion* r = candidate_infos[i]._r;\n+    assert(!contains(r), \"must not contain region %u\", r->hrm_index());\n+    _contains_map[r->hrm_index()] = CandidateOrigin::Marking;\n+  }\n+  _last_marking_candidates_length = num_infos;\n+\n+  verify();\n+}\n+\n+void G1CollectionSetCandidates::remove(G1CollectionCandidateRegionList* other) {\n+  _marking_regions.remove(other);\n+\n+  for (HeapRegion* r : *other) {\n+    assert(contains(r), \"must contain region %u\", r->hrm_index());\n+    _contains_map[r->hrm_index()] = CandidateOrigin::Invalid;\n@@ -75,0 +198,10 @@\n+\n+  verify();\n+}\n+\n+bool G1CollectionSetCandidates::is_empty() const {\n+  return length() == 0;\n+}\n+\n+bool G1CollectionSetCandidates::has_more_marking_candidates() const {\n+  return _marking_regions.length() != 0;\n@@ -78,17 +211,8 @@\n-void G1CollectionSetCandidates::verify() const {\n-  guarantee(_front_idx <= _num_regions, \"Index: %u Num_regions: %u\", _front_idx, _num_regions);\n-  uint idx = _front_idx;\n-  size_t sum_of_reclaimable_bytes = 0;\n-  HeapRegion *prev = nullptr;\n-  for (; idx < _num_regions; idx++) {\n-    HeapRegion *cur = _regions[idx];\n-    guarantee(cur != nullptr, \"Regions after _front_idx %u cannot be NULL but %u is\", _front_idx, idx);\n-    \/\/ Currently the decision whether young gc moves region contents is determined\n-    \/\/ at region allocation time. It is not possible that a region becomes non-movable\n-    \/\/ at a later point, which means below condition always holds true.\n-    guarantee(G1CollectionSetChooser::should_add(cur),\n-              \"Region %u should be eligible for addition.\", cur->hrm_index());\n-    if (prev != nullptr) {\n-      guarantee(prev->gc_efficiency() >= cur->gc_efficiency(),\n-                \"GC efficiency for region %u: %1.4f smaller than for region %u: %1.4f\",\n-                prev->hrm_index(), prev->gc_efficiency(), cur->hrm_index(), cur->gc_efficiency());\n+void G1CollectionSetCandidates::verify_helper(G1CollectionCandidateList* list, uint& from_marking, CandidateOrigin* verify_map) {\n+  list->verify();\n+\n+  for (uint i = 0; i < (uint)list->length(); i++) {\n+    HeapRegion* r = list->at(i)._r;\n+\n+    if (is_from_marking(r)) {\n+      from_marking++;\n@@ -96,2 +220,29 @@\n-    sum_of_reclaimable_bytes += cur->reclaimable_bytes();\n-    prev = cur;\n+    const uint hrm_index = r->hrm_index();\n+    assert(_contains_map[hrm_index] == CandidateOrigin::Marking,\n+           \"must be %u is %u\", hrm_index, (uint)_contains_map[hrm_index]);\n+    assert(verify_map[hrm_index] == CandidateOrigin::Invalid, \"already added\");\n+\n+    verify_map[hrm_index] = CandidateOrigin::Verify;\n+  }\n+}\n+\n+void G1CollectionSetCandidates::verify() {\n+  uint from_marking = 0;\n+\n+  CandidateOrigin* verify_map = NEW_C_HEAP_ARRAY(CandidateOrigin, _max_regions, mtGC);\n+  for (uint i = 0; i < _max_regions; i++) {\n+    verify_map[i] = CandidateOrigin::Invalid;\n+  }\n+\n+  verify_helper(&_marking_regions, from_marking, verify_map);\n+\n+  assert(from_marking == marking_regions_length(), \"must be\");\n+\n+  \/\/ Check whether the _contains_map is consistent with the list.\n+  for (uint i = 0; i < _max_regions; i++) {\n+    assert(_contains_map[i] == verify_map[i] ||\n+           (_contains_map[i] != CandidateOrigin::Invalid && verify_map[i] == CandidateOrigin::Verify),\n+           \"Candidate origin does not match for region %u, is %u but should be %u\",\n+           i,\n+           static_cast<std::underlying_type<CandidateOrigin>::type>(_contains_map[i]),\n+           static_cast<std::underlying_type<CandidateOrigin>::type>(verify_map[i]));\n@@ -99,3 +250,20 @@\n-  guarantee(sum_of_reclaimable_bytes == _remaining_reclaimable_bytes,\n-            \"Inconsistent remaining_reclaimable bytes, remaining \" SIZE_FORMAT \" calculated \" SIZE_FORMAT,\n-            _remaining_reclaimable_bytes, sum_of_reclaimable_bytes);\n+\n+  FREE_C_HEAP_ARRAY(CandidateOrigin, verify_map);\n+}\n+#endif\n+\n+bool G1CollectionSetCandidates::contains(const HeapRegion* r) const {\n+  const uint index = r->hrm_index();\n+  assert(index < _max_regions, \"must be\");\n+  return _contains_map[index] != CandidateOrigin::Invalid;\n+}\n+\n+const char* G1CollectionSetCandidates::get_short_type_str(const HeapRegion* r) const {\n+  static const char* type_strings[] = {\n+    \"Ci\",  \/\/ Invalid\n+    \"Cm\",  \/\/ Marking\n+    \"Cv\"   \/\/ Verification\n+  };\n+\n+  uint8_t kind = static_cast<std::underlying_type<CandidateOrigin>::type>(_contains_map[r->hrm_index()]);\n+  return type_strings[kind];\n@@ -103,1 +271,0 @@\n-#endif \/\/ !PRODUCT\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.cpp","additions":221,"deletions":54,"binary":false,"changes":275,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+#include \"utilities\/bitMap.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n@@ -33,0 +35,2 @@\n+class G1CollectionCandidateList;\n+class G1CollectionSetCandidates;\n@@ -36,8 +40,1 @@\n-\/\/ Set of collection set candidates, i.e. all old gen regions we consider worth\n-\/\/ collecting in the remainder of the current mixed phase. Regions are sorted by decreasing\n-\/\/ gc efficiency.\n-\/\/ Maintains a cursor into the list that specifies the next collection set candidate\n-\/\/ to put into the current collection set.\n-class G1CollectionSetCandidates : public CHeapObj<mtGC> {\n-  HeapRegion** _regions;\n-  uint _num_regions; \/\/ Total number of regions in the collection set candidate set.\n+using G1CollectionCandidateRegionListIterator = GrowableArrayIterator<HeapRegion*>;\n@@ -45,6 +42,3 @@\n-  \/\/ The sum of bytes that can be reclaimed in the remaining set of collection\n-  \/\/ set candidates.\n-  size_t _remaining_reclaimable_bytes;\n-  \/\/ The index of the next candidate old region to be considered for\n-  \/\/ addition to the current collection set.\n-  uint _front_idx;\n+\/\/ A set of HeapRegion*, a thin wrapper around GrowableArray.\n+class G1CollectionCandidateRegionList {\n+  GrowableArray<HeapRegion*> _regions;\n@@ -53,9 +47,33 @@\n-  G1CollectionSetCandidates(HeapRegion** regions, uint num_regions, size_t remaining_reclaimable_bytes) :\n-    _regions(regions),\n-    _num_regions(num_regions),\n-    _remaining_reclaimable_bytes(remaining_reclaimable_bytes),\n-    _front_idx(0) { }\n-\n-  ~G1CollectionSetCandidates() {\n-    FREE_C_HEAP_ARRAY(HeapRegion*, _regions);\n-  }\n+  G1CollectionCandidateRegionList();\n+\n+  \/\/ Append a HeapRegion to the end of this list. The region must not be in the list\n+  \/\/ already.\n+  void append(HeapRegion* r);\n+  \/\/ Remove the given list of HeapRegion* from this list. The given list must be a prefix\n+  \/\/ of this list.\n+  void remove_prefix(G1CollectionCandidateRegionList* list);\n+\n+  \/\/ Empty contents of the list.\n+  void clear();\n+\n+  HeapRegion* at(uint index);\n+\n+  uint length() const { return (uint)_regions.length(); }\n+\n+  G1CollectionCandidateRegionListIterator begin() const { return _regions.begin(); }\n+  G1CollectionCandidateRegionListIterator end() const { return _regions.end(); }\n+};\n+\n+class G1CollectionCandidateListIterator : public StackObj {\n+  G1CollectionCandidateList* _which;\n+  uint _position;\n+\n+public:\n+  G1CollectionCandidateListIterator(G1CollectionCandidateList* which, uint position);\n+\n+  G1CollectionCandidateListIterator& operator++();\n+  HeapRegion* operator*();\n+\n+  bool operator==(const G1CollectionCandidateListIterator& rhs);\n+  bool operator!=(const G1CollectionCandidateListIterator& rhs);\n+};\n@@ -63,2 +81,4 @@\n-  \/\/ Returns the total number of collection set candidate old regions added.\n-  uint num_regions() { return _num_regions; }\n+\/\/ List of collection set candidates (regions with their efficiency) ordered by\n+\/\/ decreasing gc efficiency.\n+class G1CollectionCandidateList : public CHeapObj<mtGC> {\n+  friend class G1CollectionCandidateListIterator;\n@@ -66,1 +86,40 @@\n-  uint cur_idx() const { return _front_idx; }\n+public:\n+  struct CandidateInfo {\n+    HeapRegion* _r;\n+    double _gc_efficiency;\n+\n+    CandidateInfo() : CandidateInfo(nullptr, 0.0) { }\n+    CandidateInfo(HeapRegion* r, double gc_efficiency) : _r(r), _gc_efficiency(gc_efficiency) { }\n+  };\n+\n+private:\n+  GrowableArray<CandidateInfo> _candidates;\n+\n+public:\n+  G1CollectionCandidateList();\n+\n+  \/\/ Put the given set of candidates into this list, preserving the efficiency ordering.\n+  void set(CandidateInfo* candidate_infos, uint num_infos);\n+  \/\/ Removes any HeapRegions stored in this list also in the other list. The other\n+  \/\/ list may only contain regions in this list, sorted by gc efficiency. It need\n+  \/\/ not be a prefix of this list. Returns the number of regions removed.\n+  \/\/ E.g. if this list is \"A B G H\", the other list may be \"A G H\", but not \"F\" (not in\n+  \/\/ this list) or \"A H G\" (wrong order).\n+  void remove(G1CollectionCandidateRegionList* other);\n+\n+  void clear();\n+\n+  CandidateInfo& at(uint position) { return _candidates.at(position); }\n+\n+  uint length() const { return (uint)_candidates.length(); }\n+\n+  void verify() PRODUCT_RETURN;\n+\n+  \/\/ Comparison function to order regions in decreasing GC efficiency order. This\n+  \/\/ will cause regions with a lot of live objects and large remembered sets to end\n+  \/\/ up at the end of the list.\n+  static int compare(CandidateInfo* ci1, CandidateInfo* ci2);\n+\n+  G1CollectionCandidateListIterator begin() {\n+    return G1CollectionCandidateListIterator(this, 0);\n+  }\n@@ -68,7 +127,2 @@\n-  HeapRegion* at(uint idx) const {\n-    HeapRegion* res = nullptr;\n-    if (idx < _num_regions) {\n-      res = _regions[idx];\n-      assert(res != nullptr, \"Unexpected null HeapRegion at index %u\", idx);\n-    }\n-    return res;\n+  G1CollectionCandidateListIterator end() {\n+    return G1CollectionCandidateListIterator(this, length());\n@@ -76,0 +130,16 @@\n+};\n+\n+\/\/ Iterator for G1CollectionSetCandidates.\n+class G1CollectionSetCandidatesIterator : public StackObj {\n+  G1CollectionSetCandidates* _which;\n+  uint _marking_position;\n+\n+public:\n+  G1CollectionSetCandidatesIterator(G1CollectionSetCandidates* which, uint marking_position);\n+\n+  G1CollectionSetCandidatesIterator& operator++();\n+  HeapRegion* operator*();\n+\n+  bool operator==(const G1CollectionSetCandidatesIterator& rhs);\n+  bool operator!=(const G1CollectionSetCandidatesIterator& rhs);\n+};\n@@ -77,4 +147,25 @@\n-  \/\/ Remove num_regions from the front of the collection set candidate list.\n-  void remove(uint num_regions);\n-  \/\/ Remove num_remove regions from the back of the collection set candidate list.\n-  void remove_from_end(uint num_remove, size_t wasted);\n+\/\/ Tracks all collection set candidates, i.e. regions that could\/should be evacuated soon.\n+\/\/\n+\/\/ These candidate regions are tracked in a list of regions, sorted by decreasing\n+\/\/ \"gc efficiency\".\n+\/\/\n+\/\/ Currently there is only one type of such regions:\n+\/\/\n+\/\/ * marking_regions: the set of regions selected by concurrent marking to be\n+\/\/                    evacuated to keep overall heap occupancy stable.\n+\/\/                    They are guaranteed to be evacuated and cleared out during\n+\/\/                    the mixed phase.\n+\/\/\n+class G1CollectionSetCandidates : public CHeapObj<mtGC> {\n+  friend class G1CollectionSetCandidatesIterator;\n+\n+  enum class CandidateOrigin : uint8_t {\n+    Invalid,\n+    Marking,                   \/\/ This region has been determined as candidate by concurrent marking.\n+    Verify                     \/\/ Special value for verification.\n+  };\n+\n+  G1CollectionCandidateList _marking_regions;\n+\n+  CandidateOrigin* _contains_map;\n+  uint _max_regions;\n@@ -82,5 +173,8 @@\n-  \/\/ Iterate over all remaining collection set candidate regions.\n-  void iterate(HeapRegionClosure* cl);\n-  \/\/ Iterate over all remaining collection set candidate regions from the end\n-  \/\/ to the beginning of the set.\n-  void iterate_backwards(HeapRegionClosure* cl);\n+  \/\/ The number of regions from the last merge of candidates from the marking.\n+  uint _last_marking_candidates_length;\n+\n+  bool is_from_marking(HeapRegion* r) const;\n+\n+public:\n+  G1CollectionSetCandidates();\n+  ~G1CollectionSetCandidates();\n@@ -88,2 +182,1 @@\n-  \/\/ Return the number of candidate regions remaining.\n-  uint num_remaining() { return _num_regions - _front_idx; }\n+  G1CollectionCandidateList& marking_regions() { return _marking_regions; }\n@@ -91,1 +184,1 @@\n-  bool is_empty() { return num_remaining() == 0; }\n+  void initialize(uint max_regions);\n@@ -93,3 +186,1 @@\n-  \/\/ Return the amount of reclaimable bytes that may be collected by the remaining\n-  \/\/ candidate regions.\n-  size_t remaining_reclaimable_bytes() { return _remaining_reclaimable_bytes; }\n+  void clear();\n@@ -97,1 +188,38 @@\n-  void verify() const PRODUCT_RETURN;\n+  \/\/ Merge collection set candidates from marking into the current marking list\n+  \/\/ (which needs to be empty).\n+  void set_candidates_from_marking(G1CollectionCandidateList::CandidateInfo* candidate_infos,\n+                                   uint num_infos);\n+  \/\/ The most recent length of the list that had been merged last via\n+  \/\/ set_candidates_from_marking(). Used for calculating minimum collection set\n+  \/\/ regions.\n+  uint last_marking_candidates_length() const { return _last_marking_candidates_length; }\n+\n+  \/\/ Remove the given regions from the candidates. All given regions must be part\n+  \/\/ of the candidates.\n+  void remove(G1CollectionCandidateRegionList* other);\n+\n+  bool contains(const HeapRegion* r) const;\n+\n+  const char* get_short_type_str(const HeapRegion* r) const;\n+\n+  bool is_empty() const;\n+  bool has_more_marking_candidates() const;\n+\n+  uint marking_regions_length() const { return _marking_regions.length(); }\n+\n+private:\n+  void verify_helper(G1CollectionCandidateList* list, uint& from_marking, CandidateOrigin* verify_map) PRODUCT_RETURN;\n+\n+public:\n+  void verify() PRODUCT_RETURN;\n+\n+  uint length() const { return marking_regions_length(); }\n+\n+  \/\/ Iteration\n+  G1CollectionSetCandidatesIterator begin() {\n+    return G1CollectionSetCandidatesIterator(this, 0);\n+  }\n+\n+  G1CollectionSetCandidatesIterator end() {\n+    return G1CollectionSetCandidatesIterator(this, marking_regions_length());\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.hpp","additions":177,"deletions":49,"binary":false,"changes":226,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1COLLECTIONSETCANDIDATES_INLINE_HPP\n+#define SHARE_GC_G1_G1COLLECTIONSETCANDIDATES_INLINE_HPP\n+\n+#include \"gc\/g1\/g1CollectionSetCandidates.hpp\"\n+\n+#include \"utilities\/growableArray.hpp\"\n+\n+inline G1CollectionCandidateListIterator::G1CollectionCandidateListIterator(G1CollectionCandidateList* which, uint position) :\n+  _which(which), _position(position) { }\n+\n+inline G1CollectionCandidateListIterator& G1CollectionCandidateListIterator::operator++() {\n+  assert(_position < _which->length(), \"must be\");\n+  _position++;\n+  return *this;\n+}\n+\n+inline HeapRegion* G1CollectionCandidateListIterator::operator*() {\n+  return _which->_candidates.at(_position)._r;\n+}\n+\n+inline bool G1CollectionCandidateListIterator::operator==(const G1CollectionCandidateListIterator& rhs) {\n+  assert(_which == rhs._which, \"iterator belongs to different array\");\n+  return _position == rhs._position;\n+}\n+\n+inline bool G1CollectionCandidateListIterator::operator!=(const G1CollectionCandidateListIterator& rhs) {\n+  return !(*this == rhs);\n+}\n+\n+inline G1CollectionSetCandidatesIterator::G1CollectionSetCandidatesIterator(G1CollectionSetCandidates* which, uint marking_position) :\n+  _which(which), _marking_position(marking_position) {\n+}\n+\n+inline G1CollectionSetCandidatesIterator& G1CollectionSetCandidatesIterator::operator++() {\n+  assert(_marking_position < _which->_marking_regions.length(),\n+         \"must not be at end already\");\n+\n+  _marking_position++;\n+  return *this;\n+}\n+\n+inline HeapRegion* G1CollectionSetCandidatesIterator::operator*() {\n+  return _which->_marking_regions.at(_marking_position)._r;\n+}\n+\n+inline bool G1CollectionSetCandidatesIterator::operator==(const G1CollectionSetCandidatesIterator& rhs)  {\n+  assert(_which == rhs._which, \"iterator belongs to different array\");\n+  return _marking_position == rhs._marking_position;\n+}\n+\n+inline bool G1CollectionSetCandidatesIterator::operator!=(const G1CollectionSetCandidatesIterator& rhs)  {\n+  return !(*this == rhs);\n+}\n+\n+#endif \/* SHARE_GC_G1_G1COLLECTIONSETCANDIDATES_INLINE_HPP *\/\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.inline.hpp","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -34,31 +34,0 @@\n-\/\/ Order regions according to GC efficiency. This will cause regions with a lot\n-\/\/ of live objects and large remembered sets to end up at the end of the array.\n-\/\/ Given that we might skip collecting the last few old regions, if after a few\n-\/\/ mixed GCs the remaining have reclaimable bytes under a certain threshold, the\n-\/\/ hope is that the ones we'll skip are ones with both large remembered sets and\n-\/\/ a lot of live objects, not the ones with just a lot of live objects if we\n-\/\/ ordered according to the amount of reclaimable bytes per region.\n-static int order_regions(HeapRegion* hr1, HeapRegion* hr2) {\n-  \/\/ Make sure that null entries are moved to the end.\n-  if (hr1 == nullptr) {\n-    if (hr2 == nullptr) {\n-      return 0;\n-    } else {\n-      return 1;\n-    }\n-  } else if (hr2 == nullptr) {\n-    return -1;\n-  }\n-\n-  double gc_eff1 = hr1->gc_efficiency();\n-  double gc_eff2 = hr2->gc_efficiency();\n-\n-  if (gc_eff1 > gc_eff2) {\n-    return -1;\n-  } if (gc_eff1 < gc_eff2) {\n-    return 1;\n-  } else {\n-    return 0;\n-  }\n-}\n-\n@@ -74,0 +43,2 @@\n+  using CandidateInfo = G1CollectionCandidateList::CandidateInfo;\n+\n@@ -85,1 +56,1 @@\n-    HeapRegion** _data;\n+    CandidateInfo* _data;\n@@ -102,1 +73,1 @@\n-      _data(NEW_C_HEAP_ARRAY(HeapRegion*, _max_size, mtGC)),\n+      _data(NEW_C_HEAP_ARRAY(CandidateInfo, _max_size, mtGC)),\n@@ -105,1 +76,1 @@\n-        _data[i] = nullptr;\n+        _data[i] = CandidateInfo();\n@@ -110,1 +81,1 @@\n-      FREE_C_HEAP_ARRAY(HeapRegion*, _data);\n+      FREE_C_HEAP_ARRAY(CandidateInfo, _data);\n@@ -126,2 +97,2 @@\n-      assert(_data[idx] == nullptr, \"Value must not have been set.\");\n-      _data[idx] = hr;\n+      assert(_data[idx]._r == nullptr, \"Value must not have been set.\");\n+      _data[idx] = CandidateInfo(hr, hr->calc_gc_efficiency());\n@@ -130,1 +101,1 @@\n-    void sort_and_copy_into(HeapRegion** dest, uint num_regions) {\n+    void sort_by_efficiency() {\n@@ -135,5 +106,1 @@\n-        assert(_data[i] == nullptr, \"must be\");\n-      }\n-      QuickSort::sort(_data, _cur_claim_idx, order_regions, true);\n-      for (uint i = num_regions; i < _max_size; i++) {\n-        assert(_data[i] == nullptr, \"must be\");\n+        assert(_data[i]._r == nullptr, \"must be\");\n@@ -141,2 +108,3 @@\n-      for (uint i = 0; i < num_regions; i++) {\n-        dest[i] = _data[i];\n+      qsort(_data, _cur_claim_idx, sizeof(_data[0]), (_sort_Fn)G1CollectionCandidateList::compare);\n+      for (uint i = _cur_claim_idx; i < _max_size; i++) {\n+        assert(_data[i]._r == nullptr, \"must be\");\n@@ -145,0 +113,2 @@\n+\n+    CandidateInfo* array() const { return _data; }\n@@ -157,1 +127,0 @@\n-    size_t _reclaimable_bytes_added;\n@@ -165,1 +134,0 @@\n-      hr->calc_gc_efficiency();\n@@ -171,1 +139,0 @@\n-      _reclaimable_bytes_added += hr->reclaimable_bytes();\n@@ -181,2 +148,1 @@\n-      _regions_added(0),\n-      _reclaimable_bytes_added(0) { }\n+      _regions_added(0) { }\n@@ -191,2 +157,1 @@\n-        \/\/ Keep remembered sets for humongous regions, otherwise clean out remembered\n-        \/\/ sets for old regions.\n+        \/\/ Keep remembered sets for humongous regions, otherwise clean them out.\n@@ -203,1 +168,0 @@\n-    size_t reclaimable_bytes_added() const { return _reclaimable_bytes_added; }\n@@ -210,1 +174,0 @@\n-  size_t volatile _reclaimable_bytes_added;\n@@ -214,1 +177,1 @@\n-  void update_totals(uint num_regions, size_t reclaimable_bytes) {\n+  void update_totals(uint num_regions) {\n@@ -216,1 +179,0 @@\n-      assert(reclaimable_bytes > 0, \"invariant\");\n@@ -218,3 +180,0 @@\n-      Atomic::add(&_reclaimable_bytes_added, reclaimable_bytes);\n-    } else {\n-      assert(reclaimable_bytes == 0, \"invariant\");\n@@ -224,0 +183,44 @@\n+  \/\/ Early prune (remove) regions meeting the G1HeapWastePercent criteria. That\n+  \/\/ is, either until only the minimum amount of old collection set regions are\n+  \/\/ available (for forward progress in evacuation) or the waste accumulated by the\n+  \/\/ removed regions is above the maximum allowed waste.\n+  \/\/ Updates number of candidates and reclaimable bytes given.\n+  void prune(CandidateInfo* data) {\n+    G1Policy* p = G1CollectedHeap::heap()->policy();\n+\n+    uint num_candidates = Atomic::load(&_num_regions_added);\n+\n+    uint min_old_cset_length = p->calc_min_old_cset_length(num_candidates);\n+    uint num_pruned = 0;\n+    size_t wasted_bytes = 0;\n+\n+    if (min_old_cset_length >= num_candidates) {\n+      \/\/ We take all of the candidate regions to provide some forward progress.\n+      return;\n+    }\n+\n+    size_t allowed_waste = p->allowed_waste_in_collection_set();\n+    uint max_to_prune = num_candidates - min_old_cset_length;\n+\n+    while (true) {\n+      HeapRegion* r = data[num_candidates - num_pruned - 1]._r;\n+      size_t const reclaimable = r->reclaimable_bytes();\n+      if (num_pruned >= max_to_prune ||\n+          wasted_bytes + reclaimable > allowed_waste) {\n+        break;\n+      }\n+      r->rem_set()->clear(true \/* cardset_only *\/);\n+\n+      wasted_bytes += reclaimable;\n+      num_pruned++;\n+    }\n+\n+    log_debug(gc, ergo, cset)(\"Pruned %u regions out of %u, leaving \" SIZE_FORMAT \" bytes waste (allowed \" SIZE_FORMAT \")\",\n+                              num_pruned,\n+                              num_candidates,\n+                              wasted_bytes,\n+                              allowed_waste);\n+\n+    Atomic::sub(&_num_regions_added, num_pruned, memory_order_relaxed);\n+  }\n+\n@@ -230,1 +233,0 @@\n-    _reclaimable_bytes_added(0),\n@@ -236,1 +238,1 @@\n-    update_totals(cl.regions_added(), cl.reclaimable_bytes_added());\n+    update_totals(cl.regions_added());\n@@ -239,6 +241,5 @@\n-  G1CollectionSetCandidates* get_sorted_candidates() {\n-    HeapRegion** regions = NEW_C_HEAP_ARRAY(HeapRegion*, _num_regions_added, mtGC);\n-    _result.sort_and_copy_into(regions, _num_regions_added);\n-    return new G1CollectionSetCandidates(regions,\n-                                         _num_regions_added,\n-                                         _reclaimable_bytes_added);\n+  void sort_and_prune_into(G1CollectionSetCandidates* candidates) {\n+    _result.sort_by_efficiency();\n+    prune(_result.array());\n+    candidates->set_candidates_from_marking(_result.array(),\n+                                            _num_regions_added);\n@@ -260,55 +261,1 @@\n-\/\/ Closure implementing early pruning (removal) of regions meeting the\n-\/\/ G1HeapWastePercent criteria. That is, either until _max_pruned regions were\n-\/\/ removed (for forward progress in evacuation) or the waste accumulated by the\n-\/\/ removed regions is above max_wasted.\n-class G1PruneRegionClosure : public HeapRegionClosure {\n-  uint _num_pruned;\n-  size_t _cur_wasted;\n-\n-  uint const _max_pruned;\n-  size_t const _max_wasted;\n-\n-public:\n-  G1PruneRegionClosure(uint max_pruned, size_t max_wasted) :\n-    _num_pruned(0), _cur_wasted(0), _max_pruned(max_pruned), _max_wasted(max_wasted) { }\n-\n-  virtual bool do_heap_region(HeapRegion* r) {\n-    size_t const reclaimable = r->reclaimable_bytes();\n-    if (_num_pruned >= _max_pruned ||\n-        _cur_wasted + reclaimable > _max_wasted) {\n-      return true;\n-    }\n-    r->rem_set()->clear(true \/* cardset_only *\/);\n-    _cur_wasted += reclaimable;\n-    _num_pruned++;\n-    return false;\n-  }\n-\n-  uint num_pruned() const { return _num_pruned; }\n-  size_t wasted() const { return _cur_wasted; }\n-};\n-\n-void G1CollectionSetChooser::prune(G1CollectionSetCandidates* candidates) {\n-  G1Policy* p = G1CollectedHeap::heap()->policy();\n-\n-  uint min_old_cset_length = p->calc_min_old_cset_length(candidates->num_regions());\n-  uint num_candidates = candidates->num_regions();\n-\n-  if (min_old_cset_length < num_candidates) {\n-    size_t allowed_waste = p->allowed_waste_in_collection_set();\n-\n-    G1PruneRegionClosure prune_cl(num_candidates - min_old_cset_length,\n-                                  allowed_waste);\n-    candidates->iterate_backwards(&prune_cl);\n-\n-    log_debug(gc, ergo, cset)(\"Pruned %u regions out of %u, leaving \" SIZE_FORMAT \" bytes waste (allowed \" SIZE_FORMAT \")\",\n-                              prune_cl.num_pruned(),\n-                              candidates->num_regions(),\n-                              prune_cl.wasted(),\n-                              allowed_waste);\n-\n-    candidates->remove_from_end(prune_cl.num_pruned(), prune_cl.wasted());\n-  }\n-}\n-\n-G1CollectionSetCandidates* G1CollectionSetChooser::build(WorkerThreads* workers, uint max_num_regions) {\n+void G1CollectionSetChooser::build(WorkerThreads* workers, uint max_num_regions, G1CollectionSetCandidates* candidates) {\n@@ -321,4 +268,2 @@\n-  G1CollectionSetCandidates* result = cl.get_sorted_candidates();\n-  prune(result);\n-  result->verify();\n-  return result;\n+  cl.sort_and_prune_into(candidates);\n+  candidates->verify();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.cpp","additions":71,"deletions":126,"binary":false,"changes":197,"status":"modified"},{"patch":"@@ -41,4 +41,0 @@\n-  \/\/ Remove regions in the collection set candidates as long as the G1HeapWastePercent\n-  \/\/ criteria is met. Keep at least the minimum amount of old regions to guarantee\n-  \/\/ some progress.\n-  static void prune(G1CollectionSetCandidates* candidates);\n@@ -46,1 +42,0 @@\n-\n@@ -63,1 +58,1 @@\n-  static G1CollectionSetCandidates* build(WorkerThreads* workers, uint max_num_regions);\n+  static void build(WorkerThreads* workers, uint max_num_regions, G1CollectionSetCandidates* candidates);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2992,1 +2992,1 @@\n-  double gc_eff          = r->gc_efficiency();\n+  double gc_eff          = r->calc_gc_efficiency();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -436,0 +436,2 @@\n+\n+  _g1h->collection_set()->candidates()->verify();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,2 +62,1 @@\n-                                           size_t young_cset_length,\n-                                           size_t optional_cset_length,\n+                                           G1CollectionSet* collection_set,\n@@ -81,1 +80,1 @@\n-    _surviving_words_length(young_cset_length + 1),\n+    _surviving_words_length(collection_set->young_region_length() + 1),\n@@ -86,1 +85,1 @@\n-    _max_num_optional_regions(optional_cset_length),\n+    _max_num_optional_regions(collection_set->optional_region_length()),\n@@ -107,1 +106,3 @@\n-  _closures = G1EvacuationRootClosures::create_root_closures(this, _g1h);\n+  _closures = G1EvacuationRootClosures::create_root_closures(_g1h,\n+                                                             this,\n+                                                             collection_set->only_contains_young_regions());\n@@ -572,2 +573,1 @@\n-                               _young_cset_length,\n-                               _optional_cset_length,\n+                               _collection_set,\n@@ -693,2 +693,1 @@\n-                                                 size_t young_cset_length,\n-                                                 size_t optional_cset_length,\n+                                                 G1CollectionSet* collection_set,\n@@ -697,0 +696,1 @@\n+    _collection_set(collection_set),\n@@ -700,3 +700,1 @@\n-    _surviving_young_words_total(NEW_C_HEAP_ARRAY(size_t, young_cset_length + 1, mtGC)),\n-    _young_cset_length(young_cset_length),\n-    _optional_cset_length(optional_cset_length),\n+    _surviving_young_words_total(NEW_C_HEAP_ARRAY(size_t, collection_set->young_region_length() + 1, mtGC)),\n@@ -710,1 +708,1 @@\n-  memset(_surviving_young_words_total, 0, (young_cset_length + 1) * sizeof(size_t));\n+  memset(_surviving_young_words_total, 0, (collection_set->young_region_length() + 1) * sizeof(size_t));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+class G1CollectionSet;\n@@ -120,2 +121,1 @@\n-                       size_t young_cset_length,\n-                       size_t optional_cset_length,\n+                       G1CollectionSet* collection_set,\n@@ -234,0 +234,1 @@\n+  G1CollectionSet* _collection_set;\n@@ -238,2 +239,0 @@\n-  size_t _young_cset_length;\n-  size_t _optional_cset_length;\n@@ -247,2 +246,1 @@\n-                          size_t young_cset_length,\n-                          size_t optional_cset_length,\n+                          G1CollectionSet* collection_set,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"gc\/g1\/g1CollectionSetCandidates.hpp\"\n+#include \"gc\/g1\/g1CollectionSetCandidates.inline.hpp\"\n@@ -488,4 +488,2 @@\n-  G1CollectionSetCandidates* candidates = _collection_set->candidates();\n-\n-  uint min_old_regions_end = MIN2(candidates->cur_idx() + calc_min_old_cset_length(candidates->num_regions()),\n-                                  candidates->num_regions());\n+  uint min_marking_candidates = MIN2(calc_min_old_cset_length(candidates()->last_marking_candidates_length()),\n+                                     candidates()->marking_regions_length());\n@@ -493,2 +491,4 @@\n-  for (uint i = candidates->cur_idx(); i < min_old_regions_end; i++) {\n-    HeapRegion* r = candidates->at(i);\n+  for (HeapRegion* r : candidates()->marking_regions()) {\n+    if (min_marking_candidates == 0) {\n+      break;\n+    }\n@@ -496,0 +496,1 @@\n+    min_marking_candidates--;\n@@ -497,4 +498,0 @@\n-  uint desired_eden_length_by_min_cset_length =\n-     calculate_desired_eden_length_before_young_only(predicted_region_evac_time_ms,\n-                                                     min_eden_length,\n-                                                     max_eden_length);\n@@ -502,1 +499,3 @@\n-  return desired_eden_length_by_min_cset_length;\n+  return calculate_desired_eden_length_before_young_only(predicted_region_evac_time_ms,\n+                                                         min_eden_length,\n+                                                         max_eden_length);\n@@ -540,1 +539,1 @@\n-  _collection_set->clear_candidates();\n+  _collection_set->abandon_all_candidates();\n@@ -668,0 +667,4 @@\n+G1CollectionSetCandidates* G1Policy::candidates() const {\n+  return _collection_set->candidates();\n+}\n+\n@@ -800,1 +803,3 @@\n-      clear_collection_set_candidates();\n+      assert(!candidates()->has_more_marking_candidates(),\n+             \"only end mixed if all candidates from marking were processed\");\n+\n@@ -861,1 +866,1 @@\n-    if (_collection_set->old_region_length() > 0) {\n+    if (_collection_set->initial_old_region_length() > 0) {\n@@ -863,1 +868,1 @@\n-                                                            _collection_set->old_region_length());\n+                                                            _collection_set->initial_old_region_length());\n@@ -1215,1 +1220,1 @@\n-      clear_collection_set_candidates();\n+      abandon_collection_set_candidates();\n@@ -1247,2 +1252,1 @@\n-    G1CollectionSetCandidates* candidates = G1CollectionSetChooser::build(_g1h->workers(), _g1h->num_regions());\n-    _collection_set->set_candidates(candidates);\n+    G1CollectionSetChooser::build(_g1h->workers(), _g1h->num_regions(), candidates());\n@@ -1258,1 +1262,0 @@\n-    clear_collection_set_candidates();\n@@ -1272,15 +1275,1 @@\n-double G1Policy::reclaimable_bytes_percent(size_t reclaimable_bytes) const {\n-  return percent_of(reclaimable_bytes, _g1h->capacity());\n-}\n-\n-class G1ClearCollectionSetCandidateRemSets : public HeapRegionClosure {\n-  virtual bool do_heap_region(HeapRegion* r) {\n-    r->rem_set()->clear_locked(true \/* only_cardset *\/);\n-    return false;\n-  }\n-};\n-\n-void G1Policy::clear_collection_set_candidates() {\n-  if (_collection_set->candidates() == nullptr) {\n-    return;\n-  }\n+void G1Policy::abandon_collection_set_candidates() {\n@@ -1289,3 +1278,4 @@\n-  G1ClearCollectionSetCandidateRemSets cl;\n-  _collection_set->candidates()->iterate(&cl);\n-  _collection_set->clear_candidates();\n+  for (HeapRegion* r : *candidates()) {\n+    r->rem_set()->clear_locked(true \/* only_cardset *\/);\n+  }\n+  _collection_set->abandon_all_candidates();\n@@ -1374,3 +1364,1 @@\n-  G1CollectionSetCandidates* candidates = _collection_set->candidates();\n-\n-  if (candidates == nullptr || candidates->is_empty()) {\n+  if (!candidates()->has_more_marking_candidates()) {\n@@ -1417,5 +1405,10 @@\n-void G1Policy::calculate_old_collection_set_regions(G1CollectionSetCandidates* candidates,\n-                                                    double time_remaining_ms,\n-                                                    uint& num_initial_regions,\n-                                                    uint& num_optional_regions) {\n-  assert(candidates != nullptr, \"Must be\");\n+static void print_finish_message(const char* reason, bool from_marking) {\n+  log_debug(gc, ergo, cset)(\"Finish adding %s candidates to collection set (%s).\",\n+                            from_marking ? \"marking\" : \"retained\", reason);\n+}\n+\n+double G1Policy::select_candidates_from_marking(G1CollectionCandidateList* marking_list,\n+                                                double time_remaining_ms,\n+                                                G1CollectionCandidateRegionList* initial_old_regions,\n+                                                G1CollectionCandidateRegionList* optional_old_regions) {\n+  assert(marking_list != nullptr, \"must be\");\n@@ -1423,2 +1416,0 @@\n-  num_initial_regions = 0;\n-  num_optional_regions = 0;\n@@ -1427,0 +1418,3 @@\n+  uint num_initial_regions_selected = 0;\n+  uint num_optional_regions_selected = 0;\n+\n@@ -1432,1 +1426,1 @@\n-  const uint min_old_cset_length = calc_min_old_cset_length(candidates->num_regions());\n+  const uint min_old_cset_length = calc_min_old_cset_length(candidates()->last_marking_candidates_length());\n@@ -1437,3 +1431,2 @@\n-  uint candidate_idx = candidates->cur_idx();\n-\n-  log_debug(gc, ergo, cset)(\"Start adding old regions to collection set. Min %u regions, max %u regions, \"\n+  log_debug(gc, ergo, cset)(\"Start adding marking candidates to collection set. \"\n+                            \"Min %u regions, max %u regions, \"\n@@ -1443,3 +1436,3 @@\n-  HeapRegion* hr = candidates->at(candidate_idx);\n-  while (hr != nullptr) {\n-    if (num_initial_regions + num_optional_regions >= max_old_cset_length) {\n+  G1CollectionCandidateListIterator iter = marking_list->begin();\n+  for (; iter != marking_list->end(); ++iter) {\n+    if (num_initial_regions_selected + num_optional_regions_selected >= max_old_cset_length) {\n@@ -1447,3 +1440,1 @@\n-      log_debug(gc, ergo, cset)(\"Finish adding old regions to collection set (Maximum number of regions). \"\n-                                \"Initial %u regions, optional %u regions\",\n-                                num_initial_regions, num_optional_regions);\n+      print_finish_message(\"Maximum number of regions reached\", true);\n@@ -1452,1 +1443,1 @@\n-\n+    HeapRegion* hr = *iter;\n@@ -1456,1 +1447,3 @@\n-    if (num_initial_regions < min_old_cset_length) {\n+    if (initial_old_regions->length() < min_old_cset_length) {\n+      initial_old_regions->append(hr);\n+      num_initial_regions_selected++;\n@@ -1458,1 +1451,0 @@\n-      num_initial_regions++;\n@@ -1466,1 +1458,1 @@\n-      log_debug(gc, ergo, cset)(\"Finish adding old regions to collection set (Region amount reached min).\");\n+      print_finish_message(\"Region amount reached min\", true);\n@@ -1472,1 +1464,2 @@\n-        num_initial_regions++;\n+        initial_old_regions->append(hr);\n+        num_initial_regions_selected++;\n@@ -1475,1 +1468,1 @@\n-        assert(num_optional_regions < max_optional_regions, \"Should not be possible.\");\n+        assert(optional_old_regions->length() < max_optional_regions, \"Should not be possible.\");\n@@ -1477,1 +1470,2 @@\n-        num_optional_regions++;\n+        optional_old_regions->append(hr);\n+        num_optional_regions_selected++;\n@@ -1479,1 +1473,1 @@\n-        log_debug(gc, ergo, cset)(\"Finish adding old regions to collection set (Predicted time too high).\");\n+        print_finish_message(\"Predicted time too high\", true);\n@@ -1483,1 +1477,0 @@\n-    hr = candidates->at(++candidate_idx);\n@@ -1485,2 +1478,2 @@\n-  if (hr == nullptr) {\n-    log_debug(gc, ergo, cset)(\"Old candidate collection set empty.\");\n+  if (iter == marking_list->end()) {\n+    log_debug(gc, ergo, cset)(\"Marking candidates exhausted.\");\n@@ -1490,1 +1483,1 @@\n-    log_debug(gc, ergo, cset)(\"Added %u initial old regions to collection set although the predicted time was too high.\",\n+    log_debug(gc, ergo, cset)(\"Added %u marking candidates to collection set although the predicted time was too high.\",\n@@ -1494,3 +1487,3 @@\n-  log_debug(gc, ergo, cset)(\"Finish choosing collection set old regions. Initial: %u, optional: %u, \"\n-                            \"predicted initial time: %1.2fms, predicted optional time: %1.2fms, time remaining: %1.2f\",\n-                            num_initial_regions, num_optional_regions,\n+  log_debug(gc, ergo, cset)(\"Finish adding marking candidates to collection set. Initial: %u, optional: %u, \"\n+                            \"predicted initial time: %1.2fms, predicted optional time: %1.2fms, time remaining: %1.2fms\",\n+                            num_initial_regions_selected, num_optional_regions_selected,\n@@ -1498,0 +1491,4 @@\n+\n+  assert(initial_old_regions->length() == num_initial_regions_selected, \"must be\");\n+  assert(optional_old_regions->length() == num_optional_regions_selected, \"must be\");\n+  return time_remaining_ms;\n@@ -1500,2 +1497,1 @@\n-void G1Policy::calculate_optional_collection_set_regions(G1CollectionSetCandidates* candidates,\n-                                                         uint const max_optional_regions,\n+void G1Policy::calculate_optional_collection_set_regions(G1CollectionCandidateRegionList* optional_regions,\n@@ -1503,2 +1499,3 @@\n-                                                         uint& num_optional_regions) {\n-  assert(_g1h->collector_state()->in_mixed_phase(), \"Should only be called in mixed phase\");\n+                                                         G1CollectionCandidateRegionList* selected_regions) {\n+  assert(_collection_set->optional_region_length() > 0,\n+         \"Should only be called when there are optional regions\");\n@@ -1506,1 +1503,0 @@\n-  num_optional_regions = 0;\n@@ -1508,1 +1504,0 @@\n-  uint candidate_idx = candidates->cur_idx();\n@@ -1510,3 +1505,1 @@\n-  HeapRegion* r = candidates->at(candidate_idx);\n-  while (num_optional_regions < max_optional_regions) {\n-    assert(r != nullptr, \"Region must exist\");\n+  for (HeapRegion* r : *optional_regions) {\n@@ -1524,2 +1517,2 @@\n-    num_optional_regions++;\n-    r = candidates->at(++candidate_idx);\n+\n+    selected_regions->append(r);\n@@ -1529,1 +1522,1 @@\n-                            num_optional_regions, max_optional_regions, total_prediction_ms);\n+                            selected_regions->length(), optional_regions->length(), total_prediction_ms);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":78,"deletions":85,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+class G1CollectionCandidateList;\n@@ -51,0 +52,1 @@\n+class G1CollectionCandidateRegionList;\n@@ -184,0 +186,1 @@\n+  G1CollectionSetCandidates* candidates() const;\n@@ -268,5 +271,0 @@\n-  \/\/ Returns the given amount of reclaimable bytes (that represents\n-  \/\/ the amount of reclaimable space still to be collected) as a\n-  \/\/ percentage of the current heap capacity.\n-  double reclaimable_bytes_percent(size_t reclaimable_bytes) const;\n-\n@@ -274,1 +272,1 @@\n-  void clear_collection_set_candidates();\n+  void abandon_collection_set_candidates();\n@@ -343,6 +341,7 @@\n-  \/\/ Calculate and return the number of initial and optional old gen regions from\n-  \/\/ the given collection set candidates and the remaining time.\n-  void calculate_old_collection_set_regions(G1CollectionSetCandidates* candidates,\n-                                            double time_remaining_ms,\n-                                            uint& num_initial_regions,\n-                                            uint& num_optional_regions);\n+  \/\/ Calculate and fill in the initial and optional old gen candidate regions from\n+  \/\/ the given candidate list and the remaining time.\n+  \/\/ Returns the remaining time.\n+  double select_candidates_from_marking(G1CollectionCandidateList* marking_list,\n+                                        double time_remaining_ms,\n+                                        G1CollectionCandidateRegionList* initial_old_regions,\n+                                        G1CollectionCandidateRegionList* optional_old_regions);\n@@ -353,2 +352,1 @@\n-  void calculate_optional_collection_set_regions(G1CollectionSetCandidates* candidates,\n-                                                 uint const max_optional_regions,\n+  void calculate_optional_collection_set_regions(G1CollectionCandidateRegionList* optional_old_regions,\n@@ -356,1 +354,1 @@\n-                                                 uint& num_optional_regions);\n+                                                 G1CollectionCandidateRegionList* selected);\n@@ -425,1 +423,1 @@\n-  double optional_prediction_fraction() { return 0.2; }\n+  double optional_prediction_fraction() const { return 0.2; }\n@@ -430,1 +428,1 @@\n-  double optional_evacuation_fraction() { return 0.75; }\n+  double optional_evacuation_fraction() const { return 0.75; }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":15,"deletions":17,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -72,1 +72,3 @@\n-G1EvacuationRootClosures* G1EvacuationRootClosures::create_root_closures(G1ParScanThreadState* pss, G1CollectedHeap* g1h) {\n+G1EvacuationRootClosures* G1EvacuationRootClosures::create_root_closures(G1CollectedHeap* g1h,\n+                                                                         G1ParScanThreadState* pss,\n+                                                                         bool process_only_dirty_klasses) {\n@@ -81,1 +83,1 @@\n-    res = new G1EvacuationClosures(g1h, pss, g1h->collector_state()->in_young_only_phase());\n+    res = new G1EvacuationClosures(g1h, pss, process_only_dirty_klasses);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RootClosures.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -52,1 +52,3 @@\n-  static G1EvacuationRootClosures* create_root_closures(G1ParScanThreadState* pss, G1CollectedHeap* g1h);\n+  static G1EvacuationRootClosures* create_root_closures(G1CollectedHeap* g1h,\n+                                                        G1ParScanThreadState* pss,\n+                                                        bool process_only_dirty_klasses);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RootClosures.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -271,1 +271,1 @@\n-                                            collection_set()->optional_region_length());\n+                                              collection_set()->optional_region_length());\n@@ -1017,1 +1017,1 @@\n-                              collector_state()->in_mixed_phase() \/* all_memory_pools_affected *\/);\n+                              !collection_set()->candidates()->is_empty() \/* all_memory_pools_affected *\/);\n@@ -1046,2 +1046,1 @@\n-                                              collection_set()->young_region_length(),\n-                                              collection_set()->optional_region_length(),\n+                                              collection_set(),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"gc\/g1\/g1CollectionSetCandidates.hpp\"\n+#include \"gc\/g1\/g1CollectionSetCandidates.inline.hpp\"\n@@ -84,11 +84,0 @@\n-\n-    class G1SampleCollectionSetCandidatesClosure : public HeapRegionClosure {\n-    public:\n-      G1MonotonicArenaMemoryStats _total;\n-\n-      bool do_heap_region(HeapRegion* r) override {\n-        _total.add(r->rem_set()->card_set_memory_stats());\n-        return false;\n-      }\n-    } cl;\n-\n@@ -97,2 +86,6 @@\n-    g1h->collection_set()->candidates()->iterate(&cl);\n-    g1h->set_collection_set_candidates_stats(cl._total);\n+    G1MonotonicArenaMemoryStats _total;\n+    G1CollectionSetCandidates* candidates = g1h->collection_set()->candidates();\n+    for (HeapRegion* r : *candidates) {\n+      _total.add(r->rem_set()->card_set_memory_stats());\n+    }\n+    g1h->set_collection_set_candidates_stats(_total);\n@@ -360,1 +353,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":7,"deletions":15,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -72,1 +72,0 @@\n-  class ResizeTLABsTask;\n@@ -74,0 +73,1 @@\n+  class ResizeTLABsTask;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/g1\/g1CollectionSetCandidates.inline.hpp\"\n@@ -130,2 +131,0 @@\n-\n-  _gc_efficiency = -1.0;\n@@ -139,1 +138,1 @@\n-void HeapRegion::calc_gc_efficiency() {\n+double HeapRegion::calc_gc_efficiency() {\n@@ -148,1 +147,1 @@\n-  _gc_efficiency = (double) reclaimable_bytes() \/ region_elapsed_time_ms;\n+  return (double)reclaimable_bytes() \/ region_elapsed_time_ms;\n@@ -236,1 +235,2 @@\n-  _surv_rate_group(nullptr), _age_index(G1SurvRateGroup::InvalidAgeIndex), _gc_efficiency(-1.0),\n+  _surv_rate_group(nullptr),\n+  _age_index(G1SurvRateGroup::InvalidAgeIndex),\n@@ -266,1 +266,1 @@\n-void HeapRegion::note_evacuation_failure(bool during_concurrent_start) {\n+ void HeapRegion::note_evacuation_failure(bool during_concurrent_start) {\n@@ -432,0 +432,3 @@\n+  } else if (is_collection_set_candidate()) {\n+    G1CollectionSetCandidates* candidates = G1CollectedHeap::heap()->collection_set()->candidates();\n+    st->print(\"|%s\", candidates->get_short_type_str(this));\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -253,5 +253,1 @@\n-  \/\/ Cached attributes used in the collection set policy information\n-\n-  \/\/ The calculated GC efficiency of the region.\n-  double _gc_efficiency;\n-\n+  \/\/ NUMA node.\n@@ -344,1 +340,1 @@\n-    assert(known_live_bytes <= capacity(), \"sanity\");\n+    assert(known_live_bytes <= capacity(), \"sanity %u %zu %zu %zu\", hrm_index(), known_live_bytes, used(), garbage_bytes());\n@@ -348,0 +344,2 @@\n+  inline bool is_collection_set_candidate() const;\n+\n@@ -381,1 +379,1 @@\n-  bool needs_scrubbing() const { return is_old(); }\n+  bool needs_scrubbing() const;\n@@ -443,0 +441,2 @@\n+  inline const char* collection_set_candidate_short_type_str() const;\n+\n@@ -504,2 +504,1 @@\n-  void calc_gc_efficiency(void);\n-  double gc_efficiency() const { return _gc_efficiency;}\n+  double calc_gc_efficiency();\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -165,0 +165,4 @@\n+inline bool HeapRegion::is_collection_set_candidate() const {\n+ return G1CollectedHeap::heap()->is_collection_set_candidate(this);\n+}\n+\n@@ -293,2 +297,4 @@\n-  set_top_at_mark_start(top());\n-  _gc_efficiency = -1.0;\n+  assert(top_at_mark_start() == bottom(), \"CA region's TAMS must always be at bottom\");\n+  if (is_old_or_humongous()) {\n+    set_top_at_mark_start(top());\n+  }\n@@ -300,1 +306,3 @@\n-  _garbage_bytes = byte_size(bottom(), top_at_mark_start()) - marked_bytes;\n+  if (top_at_mark_start() != bottom()) {\n+    _garbage_bytes = byte_size(bottom(), top_at_mark_start()) - marked_bytes;\n+  }\n@@ -328,0 +336,4 @@\n+inline bool HeapRegion::needs_scrubbing() const {\n+  return is_old();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -344,0 +344,8 @@\n+template <typename E>\n+class GrowableArrayFromArray : public GrowableArrayView<E> {\n+public:\n+\n+  GrowableArrayFromArray<E>(E* data, int len) :\n+    GrowableArrayView<E>(data, len, len) {}\n+};\n+\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"}]}