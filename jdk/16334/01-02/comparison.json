{"files":[{"patch":"@@ -771,0 +771,18 @@\n+\/\/ Check if the given node is a NOT operation, i.e., n == m ^ (-1).\n+static bool is_not(PhaseGVN* phase, Node* n, BasicType bt) {\n+  return n->Opcode() == Op_Xor(bt) && phase->type(n->in(2)) == TypeInteger::minus_1(bt);\n+}\n+\n+\/\/ Make a NOT operation, i.e., returning n ^ (-1).\n+static Node* make_not(PhaseGVN* phase, Node* n, BasicType bt) {\n+  switch (bt) {\n+    case T_INT:\n+      return new XorINode(n, phase->intcon(-1));\n+    case T_LONG:\n+      return new XorLNode(n, phase->longcon(-1L));\n+    default:\n+      fatal(\"Not implemented for %s\", type2name(bt));\n+  }\n+  return nullptr;\n+}\n+\n@@ -795,5 +813,4 @@\n-  if (in(1)->Opcode() == Op_XorI\n-      && phase->type(in(1)->in(2)) == TypeInt::MINUS_1\n-      && in(2)->Opcode() == Op_XorI\n-      && in(1)->in(2) == in(2)->in(2)) {\n-    return new XorINode(phase->transform(new AndINode(in(1)->in(1), in(2)->in(1))), in(1)->in(2));\n+  if (is_not(phase, in(1), T_INT) && is_not(phase, in(2), T_INT)) {\n+    return make_not(phase,\n+\t\t    phase->transform(new AndINode(in(1)->in(1), in(2)->in(1))),\n+\t\t    T_INT);\n@@ -869,5 +886,4 @@\n-  if (in(1)->Opcode() == Op_XorL\n-      && phase->type(in(1)->in(2)) == TypeLong::MINUS_1\n-      && in(2)->Opcode() == Op_XorL\n-      && in(1)->in(2) == in(2)->in(2)) {\n-    return new XorLNode(phase->transform(new AndLNode(in(1)->in(1), in(2)->in(1))), in(1)->in(2));\n+  if (is_not(phase, in(1), T_LONG) && is_not(phase, in(2), T_LONG)) {\n+    return make_not(phase,\n+\t\t    phase->transform(new AndLNode(in(1)->in(1), in(2)->in(1))),\n+\t\t    T_LONG);\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":26,"deletions":10,"binary":false,"changes":36,"status":"modified"}]}