{"files":[{"patch":"@@ -130,1 +130,6 @@\n-        }).map(MacApplicationLayout.class::cast).map(MacApplicationLayout::runtimeRootDirectory).ifPresent(codesigners);\n+        }).map(MacApplicationLayout.class::cast)\n+                .map(MacApplicationLayout::runtimeRootDirectory)\n+                .flatMap(MacBundle::fromPath)\n+                .filter(MacBundle::isValid)\n+                .map(MacBundle::root)\n+                .ifPresent(codesigners);\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/AppImageSigner.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -136,1 +136,1 @@\n-                        .appImageAction(MacPackagingPipeline::writeRuntimeInfoPlist)\n+                        .noaction()\n@@ -189,1 +189,1 @@\n-                    \/\/ The predefined app image is a macOS bundle.\n+                    \/\/ The input runtime image is a macOS bundle.\n@@ -193,0 +193,4 @@\n+                } else {\n+                    \/\/ The input runtime is not a macOS bundle and doesn't have the plist file. Create one.\n+                    builder.task(MacCopyAppImageTaskID.COPY_RUNTIME_INFO_PLIST)\n+                            .appImageAction(MacPackagingPipeline::writeRuntimeInfoPlist).add();\n@@ -196,1 +200,1 @@\n-                    \/\/ The predefined app image is a signed bundle; explicit signing is not requested for the package.\n+                    \/\/ The input runtime is a signed bundle; explicit signing is not requested for the package.\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPackagingPipeline.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -434,0 +434,4 @@\n+\n+        if (TRACE_TASK_GRAPTH) {\n+            taskGraph.dumpToStdout();\n+        }\n@@ -633,1 +637,18 @@\n-            if (config.action.isPresent() && context.test(id)) {\n+\n+            final var withAction = config.action.isPresent();\n+            final var accepted = withAction && context.test(id);\n+\n+            if (TRACE_TASK_ACTION) {\n+                var sb = new StringBuffer();\n+                sb.append(\"Execute task=[\").append(id).append(\"]: \");\n+                if (!withAction) {\n+                    sb.append(\"no action\");\n+                } else if (!accepted) {\n+                    sb.append(\"rejected\");\n+                } else {\n+                    sb.append(\"run\");\n+                }\n+                System.out.println(sb);\n+            }\n+\n+            if (accepted) {\n@@ -636,0 +657,1 @@\n+\n@@ -643,0 +665,3 @@\n+\n+    private static final boolean TRACE_TASK_GRAPTH = false;\n+    private static final boolean TRACE_TASK_ACTION = false;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/PackagingPipeline.java","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import javax.xml.transform.dom.DOMSource;\n@@ -163,9 +164,7 @@\n-        final var node = getNode(keyName);\n-        switch (node.getNodeName()) {\n-            case \"string\" -> {\n-                return node.getTextContent();\n-            }\n-            default -> {\n-                throw new NoSuchElementException();\n-            }\n-        }\n+        return findValue(keyName).orElseThrow(NoSuchElementException::new);\n+    }\n+\n+    public Optional<String> findValue(String keyName) {\n+        return findNode(keyName).filter(node -> {\n+            return \"string\".equals(node.getNodeName());\n+        }).map(Node::getTextContent);\n@@ -185,9 +184,7 @@\n-        final var node = getNode(keyName);\n-        switch (node.getNodeName()) {\n-            case \"dict\" -> {\n-                return new PListReader(node);\n-            }\n-            default -> {\n-                throw new NoSuchElementException();\n-            }\n-        }\n+        return findDictValue(keyName).orElseThrow(NoSuchElementException::new);\n+    }\n+\n+    public Optional<PListReader> findDictValue(String keyName) {\n+        return findNode(keyName).filter(node -> {\n+            return \"dict\".equals(node.getNodeName());\n+        }).map(PListReader::new);\n@@ -207,10 +204,12 @@\n-        final var node = getNode(keyName);\n-        switch (node.getNodeName()) {\n-            case \"true\" -> {\n-                return true;\n-            }\n-            case \"false\" -> {\n-                return false;\n-            }\n-            default -> {\n-                throw new NoSuchElementException();\n+        return findBoolValue(keyName).orElseThrow(NoSuchElementException::new);\n+    }\n+\n+    public Optional<Boolean> findBoolValue(String keyName) {\n+        return findNode(keyName).filter(node -> {\n+            switch (node.getNodeName()) {\n+                case \"true\", \"false\" -> {\n+                    return true;\n+                }\n+                default -> {\n+                    return false;\n+                }\n@@ -218,1 +217,1 @@\n-        }\n+        }).map(Node::getNodeName).map(Boolean::parseBoolean);\n@@ -236,4 +235,10 @@\n-        return queryArrayValue(keyName, false).map(v -> {\n-            if (v instanceof Raw r) {\n-                if (r.type() == Raw.Type.STRING) {\n-                    return r.value();\n+        return findStringArrayValue(keyName).orElseThrow(NoSuchElementException::new);\n+    }\n+\n+    public Optional<List<String>> findStringArrayValue(String keyName) {\n+        return findArrayValue(keyName, false).map(stream -> {\n+            return stream.map(v -> {\n+                if (v instanceof Raw r) {\n+                    if (r.type() == Raw.Type.STRING) {\n+                        return r.value();\n+                    }\n@@ -241,3 +246,3 @@\n-            }\n-            return (String)null;\n-        }).filter(Objects::nonNull).toList();\n+                return (String)null;\n+            }).filter(Objects::nonNull).toList();\n+        });\n@@ -269,9 +274,15 @@\n-        final var node = getNode(keyName);\n-        switch (node.getNodeName()) {\n-            case \"array\" -> {\n-                return readArray(node, fetchDictionaries);\n-            }\n-            default -> {\n-                throw new NoSuchElementException();\n-            }\n-        }\n+        return findArrayValue(keyName, fetchDictionaries).orElseThrow(NoSuchElementException::new);\n+    }\n+\n+    public Optional<Stream<Object>> findArrayValue(String keyName, boolean fetchDictionaries) {\n+        return findNode(keyName).filter(node -> {\n+            return \"array\".equals(node.getNodeName());\n+        }).map(node -> {\n+            return readArray(node, fetchDictionaries);\n+        });\n+    }\n+\n+    public XmlConsumer toXmlConsumer() {\n+        return xml -> {\n+            XmlUtils.concatXml(xml, new DOMSource(root));\n+        };\n@@ -336,1 +347,1 @@\n-    private Node getNode(String keyName) {\n+    private Optional<Node> findNode(String keyName) {\n@@ -341,1 +352,1 @@\n-        }).get()).orElseThrow(NoSuchElementException::new);\n+        }).get());\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/PListReader.java","additions":58,"deletions":47,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import java.util.Collection;\n+import java.util.List;\n@@ -108,1 +108,5 @@\n-    public static void mergeXmls(XMLStreamWriter xml, Collection<Source> sources)\n+    public static void concatXml(XMLStreamWriter xml, Source... sources) throws XMLStreamException, IOException {\n+        concatXml(xml, List.of(sources));\n+    }\n+\n+    public static void concatXml(XMLStreamWriter xml, Iterable<? extends Source> sources)\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/XmlUtils.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-            XmlUtils.mergeXmls(xml, sources);\n+            XmlUtils.concatXml(xml, sources);\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixLauncherAsService.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -378,1 +378,1 @@\n-    public static Path createInputRuntimeImage() throws IOException {\n+    public static Path createInputRuntimeImage() {\n@@ -408,1 +408,1 @@\n-        return addArguments(\"--name\", TKit.getCurrentDefaultAppName());\n+        return setArgumentValue(\"--name\", TKit.getCurrentDefaultAppName());\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import static jdk.jpackage.internal.util.XmlUtils.initDocumentBuilder;\n@@ -62,0 +63,1 @@\n+import javax.xml.stream.XMLStreamException;\n@@ -73,0 +75,1 @@\n+import org.xml.sax.SAXException;\n@@ -299,7 +302,80 @@\n-            var allProps = Stream.of(cmd.getAllArgumentValues(\"--file-associations\")).map(Path::of).map(propFile -> {\n-                try (var propFileReader = Files.newBufferedReader(propFile)) {\n-                    var props = new Properties();\n-                    props.load(propFileReader);\n-                    return props;\n-                } catch (IOException ex) {\n-                    throw new UncheckedIOException(ex);\n+            if (cmd.hasArgument(\"--app-image\")) {\n+                copyFaPListFragmentFromPredefinedAppImage(cmd, xml);\n+            } else {\n+                createFaPListFragmentFromFaProperties(cmd, xml);\n+            }\n+        }).run();\n+    }\n+\n+    private static void createFaPListFragmentFromFaProperties(JPackageCommand cmd, XMLStreamWriter xml)\n+            throws XMLStreamException, IOException {\n+\n+        var allProps = Stream.of(cmd.getAllArgumentValues(\"--file-associations\")).map(Path::of).map(propFile -> {\n+            try (var propFileReader = Files.newBufferedReader(propFile)) {\n+                var props = new Properties();\n+                props.load(propFileReader);\n+                return props;\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }).toList();\n+\n+        if (!allProps.isEmpty()) {\n+            var bundleId = getPackageId(cmd);\n+\n+            Function<Properties, String> contentType = fa -> {\n+                return String.format(\"%s.%s\", bundleId, Objects.requireNonNull(fa.getProperty(\"extension\")));\n+            };\n+\n+            Function<Properties, Optional<String>> icon = fa -> {\n+                return Optional.ofNullable(fa.getProperty(\"icon\")).map(Path::of).map(Path::getFileName).map(Path::toString);\n+            };\n+\n+            BiFunction<Properties, String, Optional<Boolean>> asBoolean = (fa, key) -> {\n+                return Optional.ofNullable(fa.getProperty(key)).map(Boolean::parseBoolean);\n+            };\n+\n+            BiFunction<Properties, String, List<String>> asList = (fa, key) -> {\n+                return Optional.ofNullable(fa.getProperty(key)).map(str -> {\n+                    return List.of(str.split(\"[ ,]+\"));\n+                }).orElseGet(List::of);\n+            };\n+\n+            writeKey(xml, \"CFBundleDocumentTypes\");\n+            writeArray(xml, toXmlConsumer(() -> {\n+                for (var fa : allProps) {\n+                    writeDict(xml, toXmlConsumer(() -> {\n+                        writeStringArray(xml, \"LSItemContentTypes\", List.of(contentType.apply(fa)));\n+                        writeStringOptional(xml, \"CFBundleTypeName\", Optional.ofNullable(fa.getProperty(\"description\")));\n+                        writeString(xml, \"LSHandlerRank\", Optional.ofNullable(fa.getProperty(\"mac.LSHandlerRank\")).orElse(\"Owner\"));\n+                        writeString(xml, \"CFBundleTypeRole\", Optional.ofNullable(fa.getProperty(\"mac.CFBundleTypeRole\")).orElse(\"Editor\"));\n+                        writeStringOptional(xml, \"NSPersistentStoreTypeKey\", Optional.ofNullable(fa.getProperty(\"mac.NSPersistentStoreTypeKey\")));\n+                        writeStringOptional(xml, \"NSDocumentClass\", Optional.ofNullable(fa.getProperty(\"mac.NSDocumentClass\")));\n+                        writeBoolean(xml, \"LSIsAppleDefaultForType\", true);\n+                        writeBooleanOptional(xml, \"LSTypeIsPackage\", asBoolean.apply(fa, \"mac.LSTypeIsPackage\"));\n+                        writeBooleanOptional(xml, \"LSSupportsOpeningDocumentsInPlace\", asBoolean.apply(fa, \"mac.LSSupportsOpeningDocumentsInPlace\"));\n+                        writeBooleanOptional(xml, \"UISupportsDocumentBrowser\", asBoolean.apply(fa, \"mac.UISupportsDocumentBrowser\"));\n+                        writeStringOptional(xml, \"CFBundleTypeIconFile\", icon.apply(fa));\n+                    }));\n+                }\n+            }));\n+\n+            writeKey(xml, \"UTExportedTypeDeclarations\");\n+            writeArray(xml, toXmlConsumer(() -> {\n+                for (var fa : allProps) {\n+                    writeDict(xml, toXmlConsumer(() -> {\n+                        writeString(xml, \"UTTypeIdentifier\", contentType.apply(fa));\n+                        writeStringOptional(xml, \"UTTypeDescription\", Optional.ofNullable(fa.getProperty(\"description\")));\n+                        if (fa.containsKey(\"mac.UTTypeConformsTo\")) {\n+                            writeStringArray(xml, \"UTTypeConformsTo\", asList.apply(fa, \"mac.UTTypeConformsTo\"));\n+                        } else {\n+                            writeStringArray(xml, \"UTTypeConformsTo\", List.of(\"public.data\"));\n+                        }\n+                        writeStringOptional(xml, \"UTTypeIconFile\", icon.apply(fa));\n+                        writeKey(xml, \"UTTypeTagSpecification\");\n+                        writeDict(xml, toXmlConsumer(() -> {\n+                            writeStringArray(xml, \"public.filename-extension\", List.of(fa.getProperty(\"extension\")));\n+                            writeStringArray(xml, \"public.mime-type\", List.of(fa.getProperty(\"mime-type\")));\n+                            writeStringArray(xml, \"NSExportableTypes\", asList.apply(fa, \"mac.NSExportableTypes\"));\n+                        }));\n+                    }));\n@@ -307,1 +383,3 @@\n-            }).toList();\n+            }));\n+        }\n+    }\n@@ -309,2 +387,2 @@\n-            if (!allProps.isEmpty()) {\n-                var bundleId = getPackageId(cmd);\n+    private static void copyFaPListFragmentFromPredefinedAppImage(JPackageCommand cmd, XMLStreamWriter xml)\n+            throws IOException, SAXException, XMLStreamException {\n@@ -312,3 +390,1 @@\n-                Function<Properties, String> contentType = fa -> {\n-                    return String.format(\"%s.%s\", bundleId, Objects.requireNonNull(fa.getProperty(\"extension\")));\n-                };\n+        var predefinedAppImage = Path.of(Optional.ofNullable(cmd.getArgumentValue(\"--app-image\")).orElseThrow(IllegalArgumentException::new));\n@@ -316,3 +392,1 @@\n-                Function<Properties, Optional<String>> icon = fa -> {\n-                    return Optional.ofNullable(fa.getProperty(\"icon\")).map(Path::of).map(Path::getFileName).map(Path::toString);\n-                };\n+        var plistPath = ApplicationLayout.macAppImage().resolveAt(predefinedAppImage).contentDirectory().resolve(\"Info.plist\");\n@@ -320,3 +394,2 @@\n-                BiFunction<Properties, String, Optional<Boolean>> asBoolean = (fa, key) -> {\n-                    return Optional.ofNullable(fa.getProperty(key)).map(Boolean::parseBoolean);\n-                };\n+        try (var plistStream = Files.newInputStream(plistPath)) {\n+            var plist = new PListReader(initDocumentBuilder().parse(plistStream));\n@@ -324,5 +397,7 @@\n-                BiFunction<Properties, String, List<String>> asList = (fa, key) -> {\n-                    return Optional.ofNullable(fa.getProperty(key)).map(str -> {\n-                        return List.of(str.split(\"[ ,]+\"));\n-                    }).orElseGet(List::of);\n-                };\n+            var entries = Stream.of(\"CFBundleDocumentTypes\", \"UTExportedTypeDeclarations\").map(key -> {\n+                return plist.findArrayValue(key, false).map(stream -> {\n+                    return stream.map(PListReader.class::cast).toList();\n+                }).map(plistList -> {\n+                    return Map.entry(key, plistList);\n+                });\n+            }).filter(Optional::isPresent).map(Optional::get).toList();\n@@ -330,1 +405,2 @@\n-                writeKey(xml, \"CFBundleDocumentTypes\");\n+            for (var e : entries) {\n+                writeKey(xml, e.getKey());\n@@ -332,14 +408,2 @@\n-                    for (var fa : allProps) {\n-                        writeDict(xml, toXmlConsumer(() -> {\n-                            writeStringArray(xml, \"LSItemContentTypes\", List.of(contentType.apply(fa)));\n-                            writeStringOptional(xml, \"CFBundleTypeName\", Optional.ofNullable(fa.getProperty(\"description\")));\n-                            writeString(xml, \"LSHandlerRank\", Optional.ofNullable(fa.getProperty(\"mac.LSHandlerRank\")).orElse(\"Owner\"));\n-                            writeString(xml, \"CFBundleTypeRole\", Optional.ofNullable(fa.getProperty(\"mac.CFBundleTypeRole\")).orElse(\"Editor\"));\n-                            writeStringOptional(xml, \"NSPersistentStoreTypeKey\", Optional.ofNullable(fa.getProperty(\"mac.NSPersistentStoreTypeKey\")));\n-                            writeStringOptional(xml, \"NSDocumentClass\", Optional.ofNullable(fa.getProperty(\"mac.NSDocumentClass\")));\n-                            writeBoolean(xml, \"LSIsAppleDefaultForType\", true);\n-                            writeBooleanOptional(xml, \"LSTypeIsPackage\", asBoolean.apply(fa, \"mac.LSTypeIsPackage\"));\n-                            writeBooleanOptional(xml, \"LSSupportsOpeningDocumentsInPlace\", asBoolean.apply(fa, \"mac.LSSupportsOpeningDocumentsInPlace\"));\n-                            writeBooleanOptional(xml, \"UISupportsDocumentBrowser\", asBoolean.apply(fa, \"mac.UISupportsDocumentBrowser\"));\n-                            writeStringOptional(xml, \"CFBundleTypeIconFile\", icon.apply(fa));\n-                        }));\n+                    for (var arrayElement : e.getValue()) {\n+                        arrayElement.toXmlConsumer().accept(xml);\n@@ -348,0 +412,3 @@\n+            }\n+        }\n+    }\n@@ -349,21 +416,36 @@\n-                writeKey(xml, \"UTExportedTypeDeclarations\");\n-                writeArray(xml, toXmlConsumer(() -> {\n-                    for (var fa : allProps) {\n-                        writeDict(xml, toXmlConsumer(() -> {\n-                            writeString(xml, \"UTTypeIdentifier\", contentType.apply(fa));\n-                            writeStringOptional(xml, \"UTTypeDescription\", Optional.ofNullable(fa.getProperty(\"description\")));\n-                            if (fa.containsKey(\"mac.UTTypeConformsTo\")) {\n-                                writeStringArray(xml, \"UTTypeConformsTo\", asList.apply(fa, \"mac.UTTypeConformsTo\"));\n-                            } else {\n-                                writeStringArray(xml, \"UTTypeConformsTo\", List.of(\"public.data\"));\n-                            }\n-                            writeStringOptional(xml, \"UTTypeIconFile\", icon.apply(fa));\n-                            writeKey(xml, \"UTTypeTagSpecification\");\n-                            writeDict(xml, toXmlConsumer(() -> {\n-                                writeStringArray(xml, \"public.filename-extension\", List.of(fa.getProperty(\"extension\")));\n-                                writeStringArray(xml, \"public.mime-type\", List.of(fa.getProperty(\"mime-type\")));\n-                                writeStringArray(xml, \"NSExportableTypes\", asList.apply(fa, \"mac.NSExportableTypes\"));\n-                            }));\n-                        }));\n-                    }\n-                }));\n+    public static Path createRuntimeBundle(Consumer<JPackageCommand> mutator) {\n+        return createRuntimeBundle(Optional.of(mutator));\n+    }\n+\n+    public static Path createRuntimeBundle() {\n+        return createRuntimeBundle(Optional.empty());\n+    }\n+\n+    public static Path createRuntimeBundle(Optional<Consumer<JPackageCommand>> mutator) {\n+        Objects.requireNonNull(mutator);\n+\n+        final var runtimeImage = JPackageCommand.createInputRuntimeImage();\n+\n+        final var runtimeBundleWorkDir = TKit.createTempDirectory(\"runtime-bundle\");\n+\n+        final var unpackadeRuntimeBundleDir = runtimeBundleWorkDir.resolve(\"unpacked\");\n+\n+        var cmd = new JPackageCommand()\n+                .useToolProvider(true)\n+                .ignoreDefaultRuntime(true)\n+                .dumpOutput(true)\n+                .setPackageType(PackageType.MAC_DMG)\n+                .setArgumentValue(\"--name\", \"foo\")\n+                .addArguments(\"--runtime-image\", runtimeImage)\n+                .addArguments(\"--dest\", runtimeBundleWorkDir);\n+\n+        mutator.ifPresent(cmd::mutate);\n+\n+        cmd.execute();\n+\n+        MacHelper.withExplodedDmg(cmd, dmgImage -> {\n+            if (dmgImage.endsWith(cmd.appInstallationDirectory().getFileName())) {\n+                Executor.of(\"cp\", \"-R\")\n+                        .addArgument(dmgImage)\n+                        .addArgument(unpackadeRuntimeBundleDir)\n+                        .execute(0);\n@@ -371,1 +453,3 @@\n-        }).run();\n+        });\n+\n+        return unpackadeRuntimeBundleDir;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacHelper.java","additions":145,"deletions":61,"binary":false,"changes":206,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import static jdk.jpackage.internal.util.XmlUtils.initDocumentBuilder;\n@@ -33,0 +34,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -44,0 +47,1 @@\n+import org.junit.jupiter.api.io.TempDir;\n@@ -280,2 +284,39 @@\n-    @Test\n-    public void test_toMap() {\n+    @ParameterizedTest\n+    @MethodSource(\"parsedPLists\")\n+    public void test_toMap(ParsedPList data) {\n+        testSpec().xml(data.xml()).expect(data.xmlAsMap()).queryType(QueryType.TO_MAP_RECURSIVE).create().test();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"parsedPLists\")\n+    public void test_toConsumer(ParsedPList data, @TempDir Path workDir) throws IOException, SAXException {\n+        var node = createXml(data.xml);\n+\n+        var srcPList = new PListReader(node);\n+\n+        var sink = workDir.resolve(\"sink.xml\");\n+\n+        XmlUtils.createXml(sink, xml -> {\n+            PListWriter.writePList(xml, srcPList.toXmlConsumer());\n+        });\n+\n+        try (var in = Files.newInputStream(sink)) {\n+            var dstPList = new PListReader(initDocumentBuilder().parse(in));\n+\n+            var src = srcPList.toMap(true);\n+            var dst = dstPList.toMap(true);\n+\n+            assertEquals(data.xmlAsMap(), src);\n+            assertEquals(data.xmlAsMap(), dst);\n+        }\n+    }\n+\n+    private record ParsedPList(Map<String, Object> xmlAsMap, String... xml) {\n+        ParsedPList {\n+            Objects.requireNonNull(xmlAsMap);\n+        }\n+\n+        ParsedPList(Map<String, Object> xmlAsMap, List<String> xml) {\n+            this(xmlAsMap, xml.toArray(String[]::new));\n+        }\n+    }\n@@ -283,1 +324,1 @@\n-        var builder = testSpec();\n+    private static Stream<ParsedPList> parsedPLists() {\n@@ -285,1 +326,1 @@\n-        builder.xml(\n+        var xml = List.of(\n@@ -370,1 +411,1 @@\n-        builder.expect(expected).queryType(QueryType.TO_MAP_RECURSIVE).create().test();\n+        return Stream.of(new ParsedPList(expected, xml));\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/util\/PListReaderTest.java","additions":46,"deletions":5,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n@@ -46,0 +47,1 @@\n+import java.util.function.Consumer;\n@@ -52,1 +54,1 @@\n-import jdk.jpackage.internal.util.function.ThrowingConsumer;\n+import jdk.jpackage.test.Annotations.Parameter;\n@@ -55,0 +57,1 @@\n+import jdk.jpackage.test.ConfigurationTarget;\n@@ -85,4 +88,1 @@\n-        var cmd = cfg.init(JPackageCommand.helloAppImage());\n-        var verifier = cfg.createPListFilesVerifier(cmd.executePrerequisiteActions());\n-        cmd.executeAndAssertHelloAppImageCreated();\n-        verifier.accept(cmd);\n+        testApp(new ConfigurationTarget(JPackageCommand.helloAppImage()), cfg);\n@@ -93,6 +93,20 @@\n-    public void testNativePackage(TestConfig cfg) {\n-        List<ThrowingConsumer<JPackageCommand>> verifier = new ArrayList<>();\n-        new PackageTest().configureHelloApp().addInitializer(cmd -> {\n-            cfg.init(cmd.setFakeRuntime());\n-        }).addRunOnceInitializer(() -> {\n-            verifier.add(cfg.createPListFilesVerifier(JPackageCommand.helloAppImage().executePrerequisiteActions()));\n+    public void testPackage(TestConfig cfg) {\n+        testApp(new ConfigurationTarget(new PackageTest().configureHelloApp()), cfg);\n+    }\n+\n+    @Test\n+    @ParameterSupplier(\"customPLists\")\n+    public void testFromAppImage(TestConfig cfg) {\n+\n+        List<Consumer<JPackageCommand>> verifier = new ArrayList<>();\n+        JPackageCommand[] appImageCmd = new JPackageCommand[1];\n+\n+        new PackageTest().addRunOnceInitializer(() -> {\n+            \/\/ Create the input app image with custom plist file(s).\n+            \/\/ Call JPackageCommand.executePrerequisiteActions() to initialize\n+            \/\/ all command line options.\n+            appImageCmd[0] = cfg.init(JPackageCommand.helloAppImage().setFakeRuntime().executePrerequisiteActions());\n+            appImageCmd[0].execute();\n+            verifier.add(cfg.createPListFilesVerifier(appImageCmd[0]));\n+        }).addInitializer(cmd -> {\n+            cmd.removeArgumentWithValue(\"--input\").setArgumentValue(\"--app-image\", appImageCmd[0].outputBundle());\n@@ -105,1 +119,3 @@\n-    public void testRuntime() {\n+    @Parameter(\"true\")\n+    @Parameter(\"false\")\n+    public void testRuntime(boolean runtimeBundle) {\n@@ -111,1 +127,13 @@\n-            runtimeImage[0] = JPackageCommand.createInputRuntimeImage();\n+            if (runtimeBundle) {\n+                \/\/ Use custom plist file with the input runtime bundle.\n+                runtimeImage[0] = MacHelper.createRuntimeBundle(toConsumer(buildRuntimeBundleCmd -> {\n+                    \/\/ Use the same name for the input runtime bundle as the name of the output bundle.\n+                    \/\/ This is to make the plist file validation pass, as the custom plist file\n+                    \/\/ is configured for the command building the input runtime bundle,\n+                    \/\/ but the plist file from the output bundle is examined.\n+                    buildRuntimeBundleCmd.setDefaultAppName();\n+                    cfg.init(buildRuntimeBundleCmd);\n+                }));\n+            } else {\n+                runtimeImage[0] = JPackageCommand.createInputRuntimeImage();\n+            }\n@@ -116,1 +144,3 @@\n-            cfg.init(cmd);\n+            if (!runtimeBundle) {\n+                cfg.init(cmd);\n+            }\n@@ -133,0 +163,25 @@\n+    private void testApp(ConfigurationTarget target, TestConfig cfg) {\n+\n+        List<Consumer<JPackageCommand>> verifier = new ArrayList<>();\n+\n+        target.addInitializer(JPackageCommand::setFakeRuntime);\n+\n+        target.addInitializer(toConsumer(cfg::init));\n+\n+        target.addRunOnceInitializer(_ -> {\n+            verifier.add(cfg.createPListFilesVerifier(\n+                    target.cmd().orElseGet(JPackageCommand::helloAppImage).executePrerequisiteActions()\n+            ));\n+        });\n+\n+        target.cmd().ifPresent(JPackageCommand::executeAndAssertHelloAppImageCreated);\n+\n+        target.addInstallVerifier(cmd -> {\n+            verifier.get(0).accept(cmd);\n+        });\n+\n+        target.test().ifPresent(test -> {\n+            test.run(Action.CREATE_AND_UNPACK);\n+        });\n+    }\n+\n@@ -176,2 +231,2 @@\n-        ThrowingConsumer<JPackageCommand> createPListFilesVerifier(JPackageCommand cmd) throws IOException {\n-            ThrowingConsumer<JPackageCommand> defaultVerifier = otherCmd -> {\n+        Consumer<JPackageCommand> createPListFilesVerifier(JPackageCommand cmd) {\n+            Consumer<JPackageCommand> customPListFilesVerifier = toConsumer(otherCmd -> {\n@@ -181,1 +236,1 @@\n-            };\n+            });\n@@ -183,0 +238,2 @@\n+            \/\/ Get the list of default plist files.\n+            \/\/ These are the plist files created from the plist file templates in jpackage resources.\n@@ -186,1 +243,2 @@\n-                return defaultVerifier;\n+                \/\/ All plist files in the bundle are customized.\n+                return customPListFilesVerifier;\n@@ -188,1 +246,6 @@\n-                var vanillaCmd = new JPackageCommand().setFakeRuntime()\n+                \/\/ There are some default plist files in the bundle.\n+                \/\/ Verify the expected default plist files are such.\n+\n+                \/\/ Create a copy of the `cmd` without the resource directory and with the app image bundling type.\n+                \/\/ Execute it and get the default plist files.\n+                var vanillaCmd = new JPackageCommand()\n@@ -193,1 +256,1 @@\n-                vanillaCmd.executeIgnoreExitCode().assertExitCodeIsZero();\n+                vanillaCmd.execute();\n@@ -196,1 +259,3 @@\n-                    defaultVerifier.accept(otherCmd);\n+                    \/\/ Verify custom plist files.\n+                    customPListFilesVerifier.accept(otherCmd);\n+                    \/\/ Verify default plist files.\n@@ -239,1 +304,4 @@\n-        APP_WITH_FA(APP),\n+        APP_WITH_FA(\n+                CustomPListFactory.PLIST_INPUT::writeAppPlistWithFa,\n+                CustomPListFactory.PLIST_OUTPUT::writeAppPlistWithFa,\n+                \"Info.plist\"),\n@@ -261,6 +329,0 @@\n-        private CustomPListType(CustomPListType other) {\n-            this.inputPlistWriter = other.inputPlistWriter;\n-            this.outputPlistWriter = other.outputPlistWriter;\n-            this.outputPlistFilename = other.outputPlistFilename;\n-        }\n-\n@@ -318,0 +380,4 @@\n+        private void writeAppPlistWithFa(JPackageCommand cmd, XMLStreamWriter xml) throws XMLStreamException, IOException {\n+            writeAppPlist(cmd, xml, true);\n+        }\n+\n@@ -319,0 +385,4 @@\n+            writeAppPlist(cmd, xml, false);\n+        }\n+\n+        private void writeAppPlist(JPackageCommand cmd, XMLStreamWriter xml, boolean withFa) throws XMLStreamException, IOException {\n@@ -331,1 +401,1 @@\n-                    if (cmd.hasArgument(\"--file-associations\")) {\n+                    if (withFa) {\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/CustomInfoPListTest.java","additions":99,"deletions":29,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import java.io.IOException;\n@@ -32,1 +31,0 @@\n-import jdk.jpackage.test.Executor;\n@@ -37,2 +35,0 @@\n-import jdk.jpackage.test.PackageType;\n-import jdk.jpackage.test.TKit;\n@@ -99,28 +95,3 @@\n-    private static Path createInputRuntimeBundle(MacSign.ResolvedKeychain keychain, int certIndex) throws IOException {\n-\n-        final var runtimeImage = JPackageCommand.createInputRuntimeImage();\n-\n-        final var runtimeBundleWorkDir = TKit.createTempDirectory(\"runtime-bundle\");\n-\n-        final var unpackadeRuntimeBundleDir = runtimeBundleWorkDir.resolve(\"unpacked\");\n-\n-        var cmd = new JPackageCommand()\n-                .useToolProvider(true)\n-                .ignoreDefaultRuntime(true)\n-                .dumpOutput(true)\n-                .setPackageType(PackageType.MAC_DMG)\n-                .setArgumentValue(\"--name\", \"foo\")\n-                .addArguments(\"--runtime-image\", runtimeImage)\n-                .addArguments(\"--dest\", runtimeBundleWorkDir);\n-\n-        addSignOptions(cmd, keychain, certIndex);\n-\n-        cmd.execute();\n-\n-        MacHelper.withExplodedDmg(cmd, dmgImage -> {\n-            if (dmgImage.endsWith(cmd.appInstallationDirectory().getFileName())) {\n-                Executor.of(\"cp\", \"-R\")\n-                        .addArgument(dmgImage)\n-                        .addArgument(unpackadeRuntimeBundleDir)\n-                        .execute(0);\n-            }\n+    private static Path createInputRuntimeBundle(MacSign.ResolvedKeychain keychain, int certIndex) {\n+        return MacHelper.createRuntimeBundle(cmd -> {\n+            addSignOptions(cmd, keychain, certIndex);\n@@ -128,2 +99,0 @@\n-\n-        return unpackadeRuntimeBundleDir;\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningRuntimeImagePackageTest.java","additions":3,"deletions":34,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.io.IOException;\n@@ -37,1 +36,0 @@\n-import jdk.jpackage.test.Executor;\n@@ -39,1 +37,0 @@\n-import jdk.jpackage.test.JavaTool;\n@@ -92,1 +89,1 @@\n-        init(RuntimePackageTest::createInputRuntimeBundle).run();\n+        init(MacHelper::createRuntimeBundle).run();\n@@ -117,1 +114,1 @@\n-        return init(RuntimePackageTest::createInputRuntimeImage);\n+        return init(JPackageCommand::createInputRuntimeImage);\n@@ -171,54 +168,0 @@\n-\n-    private static Path createInputRuntimeImage() throws IOException {\n-\n-        final Path runtimeImageDir;\n-\n-        if (JPackageCommand.DEFAULT_RUNTIME_IMAGE != null) {\n-            runtimeImageDir = JPackageCommand.DEFAULT_RUNTIME_IMAGE;\n-        } else {\n-            runtimeImageDir = TKit.createTempDirectory(\"runtime-image\").resolve(\"data\");\n-\n-            new Executor().setToolProvider(JavaTool.JLINK)\n-                    .dumpOutput()\n-                    .addArguments(\n-                            \"--output\", runtimeImageDir.toString(),\n-                            \"--add-modules\", \"java.desktop\",\n-                            \"--strip-debug\",\n-                            \"--no-header-files\",\n-                            \"--no-man-pages\")\n-                    .execute();\n-        }\n-\n-        return runtimeImageDir;\n-    }\n-\n-    private static Path createInputRuntimeBundle() throws IOException {\n-\n-        final var runtimeImage = createInputRuntimeImage();\n-\n-        final var runtimeBundleWorkDir = TKit.createTempDirectory(\"runtime-bundle\");\n-\n-        final var unpackadeRuntimeBundleDir = runtimeBundleWorkDir.resolve(\"unpacked\");\n-\n-        var cmd = new JPackageCommand()\n-                .useToolProvider(true)\n-                .ignoreDefaultRuntime(true)\n-                .dumpOutput(true)\n-                .setPackageType(PackageType.MAC_DMG)\n-                .setArgumentValue(\"--name\", \"foo\")\n-                .addArguments(\"--runtime-image\", runtimeImage)\n-                .addArguments(\"--dest\", runtimeBundleWorkDir);\n-\n-        cmd.execute();\n-\n-        MacHelper.withExplodedDmg(cmd, dmgImage -> {\n-            if (dmgImage.endsWith(cmd.appInstallationDirectory().getFileName())) {\n-                Executor.of(\"cp\", \"-R\")\n-                        .addArgument(dmgImage)\n-                        .addArgument(unpackadeRuntimeBundleDir)\n-                        .execute(0);\n-            }\n-        });\n-\n-        return unpackadeRuntimeBundleDir;\n-    }\n","filename":"test\/jdk\/tools\/jpackage\/share\/RuntimePackageTest.java","additions":2,"deletions":59,"binary":false,"changes":61,"status":"modified"}]}