{"files":[{"patch":"@@ -135,4 +135,0 @@\n-  }\n-\n-  \/\/ Wait for _needs_gc  to be cleared\n-  while (needs_gc()) {\n@@ -140,1 +136,4 @@\n-    ml.wait();\n+    \/\/ Wait for _needs_gc to be cleared\n+    while (needs_gc()) {\n+      ml.wait();\n+    }\n@@ -155,2 +154,0 @@\n-  }\n-  while (needs_gc()) {\n@@ -158,9 +155,11 @@\n-    \/\/ There's at least one thread that has not left the critical region (CR)\n-    \/\/ completely. When that last thread (no new threads can enter CR due to the\n-    \/\/ blocking) exits CR, it calls `jni_unlock`, which sets `_needs_gc`\n-    \/\/ to false and wakes up all blocked threads.\n-    \/\/ We would like to assert #threads in CR to be > 0, `_jni_lock_count > 0`\n-    \/\/ in the code, but it's too strong; it's possible that the last thread\n-    \/\/ has called `jni_unlock`, but not yet finished the call, e.g. initiating\n-    \/\/ a GCCause::_gc_locker GC.\n-    ml.wait();\n+    while (needs_gc()) {\n+      \/\/ There's at least one thread that has not left the critical region (CR)\n+      \/\/ completely. When that last thread (no new threads can enter CR due to the\n+      \/\/ blocking) exits CR, it calls `jni_unlock`, which sets `_needs_gc`\n+      \/\/ to false and wakes up all blocked threads.\n+      \/\/ We would like to assert #threads in CR to be > 0, `_jni_lock_count > 0`\n+      \/\/ in the code, but it's too strong; it's possible that the last thread\n+      \/\/ has called `jni_unlock`, but not yet finished the call, e.g. initiating\n+      \/\/ a GCCause::_gc_locker GC.\n+      ml.wait();\n+    }\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLocker.cpp","additions":15,"deletions":16,"binary":false,"changes":31,"status":"modified"}]}