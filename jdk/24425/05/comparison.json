{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -700,40 +700,0 @@\n-        \/**\n-         * When a failure happens during certificate checking from an\n-         * {@link X509TrustManager}, determine what TLS alert description\n-         * to use.\n-         *\n-         * @param cexc The exception thrown by the {@link X509TrustManager}\n-         *\n-         * @return A byte value corresponding to a TLS alert description number.\n-         *\/\n-        private static Alert getCertificateAlert(\n-                ClientHandshakeContext chc, CertificateException cexc) {\n-            \/\/ The specific reason for the failure will determine how to\n-            \/\/ set the alert description value\n-            Alert alert = Alert.CERTIFICATE_UNKNOWN;\n-\n-            Throwable baseCause = cexc.getCause();\n-            if (baseCause instanceof CertPathValidatorException cpve) {\n-                Reason reason = cpve.getReason();\n-                if (reason == BasicReason.REVOKED) {\n-                    alert = chc.staplingActive ?\n-                            Alert.BAD_CERT_STATUS_RESPONSE :\n-                            Alert.CERTIFICATE_REVOKED;\n-                } else if (\n-                        reason == BasicReason.UNDETERMINED_REVOCATION_STATUS) {\n-                    alert = chc.staplingActive ?\n-                            Alert.BAD_CERT_STATUS_RESPONSE :\n-                            Alert.CERTIFICATE_UNKNOWN;\n-                } else if (reason == BasicReason.ALGORITHM_CONSTRAINED) {\n-                    alert = Alert.UNSUPPORTED_CERTIFICATE;\n-                } else if (reason == BasicReason.EXPIRED) {\n-                    alert = Alert.CERTIFICATE_EXPIRED;\n-                } else if (reason == BasicReason.INVALID_SIGNATURE ||\n-                        reason == BasicReason.NOT_YET_VALID) {\n-                    alert = Alert.BAD_CERTIFICATE;\n-                }\n-            }\n-\n-            return alert;\n-        }\n-\n@@ -1332,27 +1292,46 @@\n-        \/**\n-         * When a failure happens during certificate checking from an\n-         * {@link X509TrustManager}, determine what TLS alert description\n-         * to use.\n-         *\n-         * @param cexc The exception thrown by the {@link X509TrustManager}\n-         *\n-         * @return A byte value corresponding to a TLS alert description number.\n-         *\/\n-        private static Alert getCertificateAlert(\n-                ClientHandshakeContext chc, CertificateException cexc) {\n-            \/\/ The specific reason for the failure will determine how to\n-            \/\/ set the alert description value\n-            Alert alert = Alert.CERTIFICATE_UNKNOWN;\n-\n-            Throwable baseCause = cexc.getCause();\n-            if (baseCause instanceof CertPathValidatorException cpve) {\n-                Reason reason = cpve.getReason();\n-                if (reason == BasicReason.REVOKED) {\n-                    alert = chc.staplingActive ?\n-                            Alert.BAD_CERT_STATUS_RESPONSE :\n-                            Alert.CERTIFICATE_REVOKED;\n-                } else if (\n-                        reason == BasicReason.UNDETERMINED_REVOCATION_STATUS) {\n-                    alert = chc.staplingActive ?\n-                            Alert.BAD_CERT_STATUS_RESPONSE :\n-                            Alert.CERTIFICATE_UNKNOWN;\n+    }\n+\n+    \/**\n+     * When a failure happens during certificate checking from an\n+     * {@link X509TrustManager}, determine what TLS alert description\n+     * to use.\n+     *\n+     * @param cexc The exception thrown by the {@link X509TrustManager}\n+     * @return A byte value corresponding to a TLS alert description number.\n+     *\/\n+    private static Alert getCertificateAlert(\n+            ClientHandshakeContext chc, CertificateException cexc) {\n+        \/\/ The specific reason for the failure will determine how to\n+        \/\/ set the alert description value\n+        Alert alert = Alert.CERTIFICATE_UNKNOWN;\n+\n+        Throwable baseCause = cexc.getCause();\n+        if (baseCause instanceof CertPathValidatorException cpve) {\n+            Reason reason = cpve.getReason();\n+            if (reason == BasicReason.REVOKED) {\n+                alert = chc.staplingActive ?\n+                        Alert.BAD_CERT_STATUS_RESPONSE :\n+                        Alert.CERTIFICATE_REVOKED;\n+            } else if (reason == BasicReason.UNDETERMINED_REVOCATION_STATUS) {\n+                alert = chc.staplingActive ?\n+                        Alert.BAD_CERT_STATUS_RESPONSE :\n+                        Alert.CERTIFICATE_UNKNOWN;\n+            } else if (reason == BasicReason.EXPIRED) {\n+                alert = Alert.CERTIFICATE_EXPIRED;\n+            } else if (reason == BasicReason.INVALID_SIGNATURE\n+                    || reason == BasicReason.NOT_YET_VALID) {\n+                alert = Alert.BAD_CERTIFICATE;\n+            } else if (reason == BasicReason.ALGORITHM_CONSTRAINED) {\n+                alert = Alert.UNSUPPORTED_CERTIFICATE;\n+\n+                \/\/ Per TLSv1.3 RFC we MUST abort the handshake with a\n+                \/\/ \"bad_certificate\" alert if we reject certificate\n+                \/\/ because of the signature using MD5 or SHA1 algorithm.\n+                if (chc.negotiatedProtocol != null\n+                        && chc.negotiatedProtocol.useTLS13PlusSpec()) {\n+                    final String exMsg = cexc.getMessage().toUpperCase();\n+\n+                    if (exMsg.contains(\"MD5WITH\")\n+                            || exMsg.contains(\"SHA1WITH\")) {\n+                        alert = Alert.BAD_CERTIFICATE;\n+                    }\n@@ -1361,2 +1340,0 @@\n-\n-            return alert;\n@@ -1364,0 +1341,2 @@\n+\n+        return alert;\n@@ -1365,0 +1344,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertificateMessage.java","additions":50,"deletions":70,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -828,0 +828,4 @@\n+            \/\/ Protocol version is negotiated, update locally supported\n+            \/\/ signature schemes according to the protocol being used.\n+            SignatureScheme.updateHandshakeLocalSupportedAlgs(context);\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ClientHello.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -362,0 +362,5 @@\n+\n+                \/\/ Protocol version is negotiated, update locally supported\n+                \/\/ signature schemes according to the protocol being used.\n+                SignatureScheme.updateHandshakeLocalSupportedAlgs(shc);\n+\n@@ -573,0 +578,5 @@\n+\n+                \/\/ Protocol version is negotiated, update locally supported\n+                \/\/ signature schemes according to the protocol being used.\n+                SignatureScheme.updateHandshakeLocalSupportedAlgs(shc);\n+\n@@ -962,0 +972,4 @@\n+            \/\/ Protocol version is negotiated, update locally supported\n+            \/\/ signature schemes according to the protocol being used.\n+            SignatureScheme.updateHandshakeLocalSupportedAlgs(chc);\n+\n@@ -1013,0 +1027,4 @@\n+            \/\/ Protocol version is negotiated, update locally supported\n+            \/\/ signature schemes according to the protocol being used.\n+            SignatureScheme.updateHandshakeLocalSupportedAlgs(chc);\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ServerHello.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -553,0 +553,31 @@\n+    \/\/ Convenience method to update all locally supported signature schemes for\n+    \/\/ a given HandshakeContext.\n+    static void updateHandshakeLocalSupportedAlgs(HandshakeContext hc) {\n+        \/\/ To improve performance we only update when necessary.\n+        \/\/ No need to do anything if we already computed the local supported\n+        \/\/ algorithms when the only active protocol ends up to be the\n+        \/\/ negotiated protocol.\n+        if (hc.localSupportedSignAlgs != null\n+                && hc.localSupportedCertSignAlgs != null\n+                && hc.activeProtocols.size() == 1\n+                && hc.activeProtocols.get(0).equals(hc.negotiatedProtocol)) {\n+            return;\n+        }\n+\n+        List<ProtocolVersion> protocols = hc.negotiatedProtocol != null ?\n+                List.of(hc.negotiatedProtocol) :\n+                hc.activeProtocols;\n+\n+        hc.localSupportedSignAlgs = getSupportedAlgorithms(\n+                hc.sslConfig,\n+                hc.algorithmConstraints,\n+                protocols,\n+                HANDSHAKE_SCOPE);\n+\n+        hc.localSupportedCertSignAlgs = getSupportedAlgorithms(\n+                hc.sslConfig,\n+                hc.algorithmConstraints,\n+                protocols,\n+                CERTIFICATE_SCOPE);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SignatureScheme.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,0 +108,1 @@\n+        sslServerSocket.setEnabledProtocols(new String[]{\"TLSv1.2\"});\n","filename":"test\/jdk\/javax\/net\/ssl\/HttpsURLConnection\/CriticalSubjectAltName.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -248,1 +248,1 @@\n-        \/\/ the test case if the serer is not ready.\n+        \/\/ the test case if the server is not ready.\n@@ -381,1 +381,1 @@\n-            \/\/ If both failed, return the curthread's exception.\n+            \/\/ If both failed, return the current thread's exception.\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/SSLSocketTemplate.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -896,1 +896,1 @@\n-        SSLContext ctx = SSLContext.getInstance(\"TLS\");\n+        SSLContext ctx = SSLContext.getInstance(\"TLSv1.2\");\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpsURLConnection\/DNSIdentities.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -904,1 +904,1 @@\n-        SSLContext ctx = SSLContext.getInstance(\"TLS\");\n+        SSLContext ctx = SSLContext.getInstance(\"TLSv1.2\");\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpsURLConnection\/IPAddressIPIdentities.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -903,1 +903,1 @@\n-        SSLContext ctx = SSLContext.getInstance(\"TLS\");\n+        SSLContext ctx = SSLContext.getInstance(\"TLSv1.2\");\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpsURLConnection\/IPIdentities.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -896,1 +896,1 @@\n-        SSLContext ctx = SSLContext.getInstance(\"TLS\");\n+        SSLContext ctx = SSLContext.getInstance(\"TLSv1.2\");\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpsURLConnection\/Identities.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,231 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8350807\n+ * @summary Certificates using MD5 algorithm that are disabled by default are\n+ *          incorrectly allowed in TLSv1.3 when re-enabled.\n+ * @modules java.base\/sun.security.x509\n+ *          java.base\/sun.security.util\n+ * @library \/javax\/net\/ssl\/templates\n+ *          \/test\/lib\n+ * @run main\/othervm MD5NotAllowedInTLS13CertificateSignature\n+ *\/\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertTrue;\n+import static jdk.test.lib.Utils.runAndCheckException;\n+\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.KeyStore;\n+import java.security.PrivateKey;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Date;\n+import java.util.List;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLHandshakeException;\n+import javax.net.ssl.TrustManagerFactory;\n+import jdk.test.lib.security.CertificateBuilder;\n+import jdk.test.lib.security.SecurityUtils;\n+import sun.security.x509.AuthorityKeyIdentifierExtension;\n+import sun.security.x509.GeneralName;\n+import sun.security.x509.GeneralNames;\n+import sun.security.x509.KeyIdentifier;\n+import sun.security.x509.SerialNumber;\n+import sun.security.x509.X500Name;\n+\n+public class MD5NotAllowedInTLS13CertificateSignature extends\n+        SSLSocketTemplate {\n+\n+    private final String protocol;\n+    private X509Certificate trustedCert;\n+    private X509Certificate serverCert;\n+    private X509Certificate clientCert;\n+    private KeyPair serverKeys;\n+    private KeyPair clientKeys;\n+\n+    protected MD5NotAllowedInTLS13CertificateSignature(String protocol)\n+            throws Exception {\n+        super();\n+        this.protocol = protocol;\n+        setupCertificates();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ MD5 is disabled by default in java.security config file,\n+        \/\/ re-enable it for our test.\n+        SecurityUtils.removeFromDisabledAlgs(\n+                \"jdk.certpath.disabledAlgorithms\", List.of(\"MD5\"));\n+        SecurityUtils.removeFromDisabledAlgs(\n+                \"jdk.tls.disabledAlgorithms\", List.of(\"MD5withRSA\"));\n+\n+        \/\/ Should fail on TLSv1.3 and up.\n+        runAndCheckException(\n+                \/\/ The conditions to reproduce the bug being fixed only met when\n+                \/\/ 'TLS' is specified, i.e. when older versions of protocol are\n+                \/\/ supported besides TLSv1.3.\n+                () -> new MD5NotAllowedInTLS13CertificateSignature(\"TLS\").run(),\n+                serverEx -> {\n+                    Throwable clientEx = serverEx.getSuppressed()[0];\n+                    assertTrue(clientEx instanceof SSLHandshakeException);\n+                    assertEquals(clientEx.getMessage(), \"(bad_certificate) \"\n+                            + \"PKIX path validation failed: \"\n+                            + \"java.security.cert.CertPathValidatorException: \"\n+                            + \"Algorithm constraints check failed on signature\"\n+                            + \" algorithm: MD5withRSA\");\n+                });\n+\n+        \/\/ Should run fine on TLSv1.2.\n+        new MD5NotAllowedInTLS13CertificateSignature(\"TLSv1.2\").run();\n+    }\n+\n+    @Override\n+    public SSLContext createServerSSLContext() throws Exception {\n+        return getSSLContext(\n+                trustedCert, serverCert, serverKeys.getPrivate(), protocol);\n+    }\n+\n+    @Override\n+    public SSLContext createClientSSLContext() throws Exception {\n+        return getSSLContext(\n+                trustedCert, clientCert, clientKeys.getPrivate(), protocol);\n+    }\n+\n+    private static SSLContext getSSLContext(\n+            X509Certificate trustedCertificate, X509Certificate keyCertificate,\n+            PrivateKey privateKey, String protocol)\n+            throws Exception {\n+\n+        \/\/ create a key store\n+        KeyStore ks = KeyStore.getInstance(\"JKS\");\n+        ks.load(null, null);\n+\n+        \/\/ import the trusted cert\n+        ks.setCertificateEntry(\"TLS Signer\", trustedCertificate);\n+\n+        \/\/ generate certificate chain\n+        Certificate[] chain = new Certificate[2];\n+        chain[0] = keyCertificate;\n+        chain[1] = trustedCertificate;\n+\n+        \/\/ import the key entry.\n+        final char[] passphrase = \"passphrase\".toCharArray();\n+        ks.setKeyEntry(\"Whatever\", privateKey, passphrase, chain);\n+\n+        \/\/ Using PKIX TrustManager - this is where MD5 signature check is done.\n+        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"PKIX\");\n+        tmf.init(ks);\n+\n+        \/\/ create SSL context\n+        SSLContext ctx = SSLContext.getInstance(protocol);\n+\n+        \/\/ Using \"SunX509\" which doesn't check peer supported signature\n+        \/\/ algorithms, so we check against local supported signature\n+        \/\/ algorithms which constitutes the fix being tested.\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n+        kmf.init(ks, passphrase);\n+\n+        ctx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n+\n+        return ctx;\n+    }\n+\n+    \/\/ Certificate-building helper methods.\n+    \/\/ Certificates are signed with signature using MD5WithRSA algorithm.\n+\n+    private void setupCertificates() throws Exception {\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\n+        kpg.initialize(1024);\n+        KeyPair caKeys = kpg.generateKeyPair();\n+        this.serverKeys = kpg.generateKeyPair();\n+        this.clientKeys = kpg.generateKeyPair();\n+\n+        this.trustedCert = createTrustedCert(caKeys);\n+\n+        this.serverCert = customCertificateBuilder(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                serverKeys.getPublic(), caKeys.getPublic())\n+                .addBasicConstraintsExt(false, false, -1)\n+                .build(trustedCert, caKeys.getPrivate(), \"MD5WithRSA\");\n+\n+        this.clientCert = customCertificateBuilder(\n+                \"CN=localhost, OU=SSL-Client, O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                clientKeys.getPublic(), caKeys.getPublic())\n+                .addBasicConstraintsExt(false, false, -1)\n+                .build(trustedCert, caKeys.getPrivate(), \"MD5WithRSA\");\n+    }\n+\n+    private static X509Certificate createTrustedCert(KeyPair caKeys)\n+            throws Exception {\n+        SecureRandom random = new SecureRandom();\n+\n+        KeyIdentifier kid = new KeyIdentifier(caKeys.getPublic());\n+        GeneralNames gns = new GeneralNames();\n+        GeneralName name = new GeneralName(new X500Name(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\"));\n+        gns.add(name);\n+        BigInteger serialNumber = BigInteger.valueOf(\n+                random.nextLong(1000000) + 1);\n+        return customCertificateBuilder(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                caKeys.getPublic(), caKeys.getPublic())\n+                .setSerialNumber(serialNumber)\n+                .addExtension(new AuthorityKeyIdentifierExtension(kid, gns,\n+                        new SerialNumber(serialNumber)))\n+                .addBasicConstraintsExt(true, true, -1)\n+                .build(null, caKeys.getPrivate(), \"MD5WithRSA\");\n+    }\n+\n+    private static CertificateBuilder customCertificateBuilder(\n+            String subjectName, PublicKey publicKey, PublicKey caKey)\n+            throws CertificateException, IOException {\n+        SecureRandom random = new SecureRandom();\n+\n+        CertificateBuilder builder = new CertificateBuilder()\n+                .setSubjectName(subjectName)\n+                .setPublicKey(publicKey)\n+                .setNotAfter(\n+                        Date.from(Instant.now().minus(1, ChronoUnit.HOURS)))\n+                .setNotAfter(Date.from(Instant.now().plus(1, ChronoUnit.HOURS)))\n+                .setSerialNumber(\n+                        BigInteger.valueOf(random.nextLong(1000000) + 1))\n+                .addSubjectKeyIdExt(publicKey)\n+                .addAuthorityKeyIdExt(caKey);\n+        builder.addKeyUsageExt(\n+                new boolean[]{true, true, true, true, true, true});\n+\n+        return builder;\n+    }\n+\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/MD5NotAllowedInTLS13CertificateSignature.java","additions":231,"deletions":0,"binary":false,"changes":231,"status":"added"}]}