{"files":[{"patch":"@@ -700,40 +700,0 @@\n-        \/**\n-         * When a failure happens during certificate checking from an\n-         * {@link X509TrustManager}, determine what TLS alert description\n-         * to use.\n-         *\n-         * @param cexc The exception thrown by the {@link X509TrustManager}\n-         *\n-         * @return A byte value corresponding to a TLS alert description number.\n-         *\/\n-        private static Alert getCertificateAlert(\n-                ClientHandshakeContext chc, CertificateException cexc) {\n-            \/\/ The specific reason for the failure will determine how to\n-            \/\/ set the alert description value\n-            Alert alert = Alert.CERTIFICATE_UNKNOWN;\n-\n-            Throwable baseCause = cexc.getCause();\n-            if (baseCause instanceof CertPathValidatorException cpve) {\n-                Reason reason = cpve.getReason();\n-                if (reason == BasicReason.REVOKED) {\n-                    alert = chc.staplingActive ?\n-                            Alert.BAD_CERT_STATUS_RESPONSE :\n-                            Alert.CERTIFICATE_REVOKED;\n-                } else if (\n-                        reason == BasicReason.UNDETERMINED_REVOCATION_STATUS) {\n-                    alert = chc.staplingActive ?\n-                            Alert.BAD_CERT_STATUS_RESPONSE :\n-                            Alert.CERTIFICATE_UNKNOWN;\n-                } else if (reason == BasicReason.ALGORITHM_CONSTRAINED) {\n-                    alert = Alert.UNSUPPORTED_CERTIFICATE;\n-                } else if (reason == BasicReason.EXPIRED) {\n-                    alert = Alert.CERTIFICATE_EXPIRED;\n-                } else if (reason == BasicReason.INVALID_SIGNATURE ||\n-                        reason == BasicReason.NOT_YET_VALID) {\n-                    alert = Alert.BAD_CERTIFICATE;\n-                }\n-            }\n-\n-            return alert;\n-        }\n-\n@@ -1332,27 +1292,46 @@\n-        \/**\n-         * When a failure happens during certificate checking from an\n-         * {@link X509TrustManager}, determine what TLS alert description\n-         * to use.\n-         *\n-         * @param cexc The exception thrown by the {@link X509TrustManager}\n-         *\n-         * @return A byte value corresponding to a TLS alert description number.\n-         *\/\n-        private static Alert getCertificateAlert(\n-                ClientHandshakeContext chc, CertificateException cexc) {\n-            \/\/ The specific reason for the failure will determine how to\n-            \/\/ set the alert description value\n-            Alert alert = Alert.CERTIFICATE_UNKNOWN;\n-\n-            Throwable baseCause = cexc.getCause();\n-            if (baseCause instanceof CertPathValidatorException cpve) {\n-                Reason reason = cpve.getReason();\n-                if (reason == BasicReason.REVOKED) {\n-                    alert = chc.staplingActive ?\n-                            Alert.BAD_CERT_STATUS_RESPONSE :\n-                            Alert.CERTIFICATE_REVOKED;\n-                } else if (\n-                        reason == BasicReason.UNDETERMINED_REVOCATION_STATUS) {\n-                    alert = chc.staplingActive ?\n-                            Alert.BAD_CERT_STATUS_RESPONSE :\n-                            Alert.CERTIFICATE_UNKNOWN;\n+    }\n+\n+    \/**\n+     * When a failure happens during certificate checking from an\n+     * {@link X509TrustManager}, determine what TLS alert description\n+     * to use.\n+     *\n+     * @param cexc The exception thrown by the {@link X509TrustManager}\n+     * @return A byte value corresponding to a TLS alert description number.\n+     *\/\n+    private static Alert getCertificateAlert(\n+            ClientHandshakeContext chc, CertificateException cexc) {\n+        \/\/ The specific reason for the failure will determine how to\n+        \/\/ set the alert description value\n+        Alert alert = Alert.CERTIFICATE_UNKNOWN;\n+\n+        Throwable baseCause = cexc.getCause();\n+        if (baseCause instanceof CertPathValidatorException cpve) {\n+            Reason reason = cpve.getReason();\n+            if (reason == BasicReason.REVOKED) {\n+                alert = chc.staplingActive ?\n+                        Alert.BAD_CERT_STATUS_RESPONSE :\n+                        Alert.CERTIFICATE_REVOKED;\n+            } else if (reason == BasicReason.UNDETERMINED_REVOCATION_STATUS) {\n+                alert = chc.staplingActive ?\n+                        Alert.BAD_CERT_STATUS_RESPONSE :\n+                        Alert.CERTIFICATE_UNKNOWN;\n+            } else if (reason == BasicReason.EXPIRED) {\n+                alert = Alert.CERTIFICATE_EXPIRED;\n+            } else if (reason == BasicReason.INVALID_SIGNATURE\n+                    || reason == BasicReason.NOT_YET_VALID) {\n+                alert = Alert.BAD_CERTIFICATE;\n+            } else if (reason == BasicReason.ALGORITHM_CONSTRAINED) {\n+                alert = Alert.UNSUPPORTED_CERTIFICATE;\n+\n+                \/\/ Per TLSv1.3 RFC we MUST abort the handshake with a\n+                \/\/ \"bad_certificate\" alert if we reject certificate\n+                \/\/ because of the signature using MD5 or SHA1 algorithm.\n+                if (chc.negotiatedProtocol != null\n+                        && chc.negotiatedProtocol.useTLS13PlusSpec()) {\n+                    final String exMsg = cexc.getMessage().toUpperCase();\n+\n+                    if (exMsg.contains(\"MD5WITH\")\n+                            || exMsg.contains(\"SHA1WITH\")) {\n+                        alert = Alert.BAD_CERTIFICATE;\n+                    }\n@@ -1361,2 +1340,0 @@\n-\n-            return alert;\n@@ -1364,0 +1341,2 @@\n+\n+        return alert;\n@@ -1365,0 +1344,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertificateMessage.java","additions":49,"deletions":69,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -828,0 +828,4 @@\n+            \/\/ Protocol version is negotiated, reset locally supported\n+            \/\/ signature schemes according to the protocol being used.\n+            SignatureScheme.setHandshakeLocalSupportedAlgs(context);\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ClientHello.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -362,0 +362,5 @@\n+\n+                \/\/ Protocol version is negotiated, reset locally supported\n+                \/\/ signature schemes according to the protocol being used.\n+                SignatureScheme.setHandshakeLocalSupportedAlgs(shc);\n+\n@@ -573,0 +578,5 @@\n+\n+                \/\/ Protocol version is negotiated, reset locally supported\n+                \/\/ signature schemes according to the protocol being used.\n+                SignatureScheme.setHandshakeLocalSupportedAlgs(shc);\n+\n@@ -962,0 +972,4 @@\n+            \/\/ Protocol version is negotiated, reset locally supported\n+            \/\/ signature schemes according to the protocol being used.\n+            SignatureScheme.setHandshakeLocalSupportedAlgs(chc);\n+\n@@ -1013,0 +1027,4 @@\n+            \/\/ Protocol version is negotiated, reset locally supported\n+            \/\/ signature schemes according to the protocol being used.\n+            SignatureScheme.setHandshakeLocalSupportedAlgs(chc);\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ServerHello.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -552,0 +552,20 @@\n+    \/\/ Convenience method to set all locally supported signature schemes for\n+    \/\/ a given HandshakeContext.\n+    static void setHandshakeLocalSupportedAlgs(HandshakeContext hc) {\n+        List<ProtocolVersion> protocols = hc.negotiatedProtocol != null ?\n+                List.of(hc.negotiatedProtocol) :\n+                hc.activeProtocols;\n+\n+        hc.localSupportedSignAlgs = getSupportedAlgorithms(\n+                hc.sslConfig,\n+                hc.algorithmConstraints,\n+                protocols,\n+                HANDSHAKE_SCOPE);\n+\n+        hc.localSupportedCertSignAlgs = getSupportedAlgorithms(\n+                hc.sslConfig,\n+                hc.algorithmConstraints,\n+                protocols,\n+                CERTIFICATE_SCOPE);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SignatureScheme.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -108,0 +108,1 @@\n+        sslServerSocket.setEnabledProtocols(new String[]{\"TLSv1.2\"});\n","filename":"test\/jdk\/javax\/net\/ssl\/HttpsURLConnection\/CriticalSubjectAltName.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -248,1 +248,1 @@\n-        \/\/ the test case if the serer is not ready.\n+        \/\/ the test case if the server is not ready.\n@@ -381,1 +381,1 @@\n-            \/\/ If both failed, return the curthread's exception.\n+            \/\/ If both failed, return the current thread's exception.\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/SSLSocketTemplate.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -896,1 +896,1 @@\n-        SSLContext ctx = SSLContext.getInstance(\"TLS\");\n+        SSLContext ctx = SSLContext.getInstance(\"TLSv1.2\");\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpsURLConnection\/DNSIdentities.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -904,1 +904,1 @@\n-        SSLContext ctx = SSLContext.getInstance(\"TLS\");\n+        SSLContext ctx = SSLContext.getInstance(\"TLSv1.2\");\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpsURLConnection\/IPAddressIPIdentities.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -903,1 +903,1 @@\n-        SSLContext ctx = SSLContext.getInstance(\"TLS\");\n+        SSLContext ctx = SSLContext.getInstance(\"TLSv1.2\");\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpsURLConnection\/IPIdentities.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -896,1 +896,1 @@\n-        SSLContext ctx = SSLContext.getInstance(\"TLS\");\n+        SSLContext ctx = SSLContext.getInstance(\"TLSv1.2\");\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpsURLConnection\/Identities.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,361 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8350807\n+ * @summary Certificates using MD5 algorithm that are disabled by default are\n+ *          incorrectly allowed in TLSv1.3 when re-enabled.\n+ * @library \/javax\/net\/ssl\/templates\n+ *          \/test\/lib\n+ * @run main\/othervm MD5NotAllowedInTLS13CertificateSignature\n+ *\/\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertTrue;\n+import static jdk.test.lib.Utils.runAndCheckException;\n+\n+import java.io.ByteArrayInputStream;\n+import java.math.BigInteger;\n+import java.security.KeyFactory;\n+import java.security.KeyStore;\n+import java.security.Security;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateFactory;\n+import java.security.interfaces.RSAPrivateKey;\n+import java.security.spec.RSAPrivateKeySpec;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLHandshakeException;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class MD5NotAllowedInTLS13CertificateSignature extends\n+        SSLSocketTemplate {\n+\n+    \/\/ Certificates and keys used in the test.\n+    \/\/ Certificates are signed with signature using MD5WithRSA algorithm.\n+    static String trusedCertStr =\n+            \"\"\"\n+            -----BEGIN CERTIFICATE-----\n+            MIICrDCCAhWgAwIBAgIBADANBgkqhkiG9w0BAQQFADBJMQswCQYDVQQGEwJVUzET\n+            MBEGA1UECBMKU29tZS1TdGF0ZTESMBAGA1UEBxMJU29tZS1DaXR5MREwDwYDVQQK\n+            EwhTb21lLU9yZzAeFw0wODEyMDgwMjQzMzZaFw0yODA4MjUwMjQzMzZaMEkxCzAJ\n+            BgNVBAYTAlVTMRMwEQYDVQQIEwpTb21lLVN0YXRlMRIwEAYDVQQHEwlTb21lLUNp\n+            dHkxETAPBgNVBAoTCFNvbWUtT3JnMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKB\n+            gQDLxDggB76Ip5OwoUNRLdeOha9U3a2ieyNbz5kTU5lFfe5tui2\/461uPZ8a+QOX\n+            4BdVrhEmV94BKY4FPyH35zboLjfXSKxT1mAOx1Bt9sWF94umxZE1cjyU7vEX8HHj\n+            7BvOyk5AQrBt7moO1uWtPA\/JuoJPePiJl4kqlRJM2Akq6QIDAQABo4GjMIGgMB0G\n+            A1UdDgQWBBT6uVG\/TOfZhpgz+efLHvEzSfeoFDBxBgNVHSMEajBogBT6uVG\/TOfZ\n+            hpgz+efLHvEzSfeoFKFNpEswSTELMAkGA1UEBhMCVVMxEzARBgNVBAgTClNvbWUt\n+            U3RhdGUxEjAQBgNVBAcTCVNvbWUtQ2l0eTERMA8GA1UEChMIU29tZS1PcmeCAQAw\n+            DAYDVR0TBAUwAwEB\/zANBgkqhkiG9w0BAQQFAAOBgQBcIm534U123Hz+rtyYO5uA\n+            ofd81G6FnTfEAV8Kw9fGyyEbQZclBv34A9JsFKeMvU4OFIaixD7nLZ\/NZ+IWbhmZ\n+            LovmJXyCkOufea73pNiZ+f\/4\/ScZaIlM\/PRycQSqbFNd4j9Wott+08qxHPLpsf3P\n+            6Mvf0r1PNTY2hwTJLJmKtg==\n+            -----END CERTIFICATE-----\"\"\";\n+\n+    static String serverCertStr =\n+            \"\"\"\n+            -----BEGIN CERTIFICATE-----\n+            MIICqjCCAhOgAwIBAgIBBDANBgkqhkiG9w0BAQQFADBJMQswCQYDVQQGEwJVUzET\n+            MBEGA1UECBMKU29tZS1TdGF0ZTESMBAGA1UEBxMJU29tZS1DaXR5MREwDwYDVQQK\n+            EwhTb21lLU9yZzAeFw0wODEyMDgwMzIxMTZaFw0yODA4MjUwMzIxMTZaMHIxCzAJ\n+            BgNVBAYTAlVTMRMwEQYDVQQIEwpTb21lLVN0YXRlMRIwEAYDVQQHEwlTb21lLUNp\n+            dHkxETAPBgNVBAoTCFNvbWUtT3JnMRMwEQYDVQQLEwpTU0wtU2VydmVyMRIwEAYD\n+            VQQDEwlsb2NhbGhvc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAKWsWxw3\n+            ot2ZiS2yebiP1Uil5xyEF41pnMasbfnyHR85GdrTch5u7ETMcKTcugAw9qBPPVR6\n+            YWrMV9AKf5UoGD+a2ZTyG8gkiH7+nQ89+1dTCLMgM9Q\/F0cU0c3qCNgOdU6vvszS\n+            7K+peknfwtmsuCRAkKYDVirQMAVALE+r2XSJAgMBAAGjeTB3MAkGA1UdEwQCMAAw\n+            CwYDVR0PBAQDAgXgMB0GA1UdDgQWBBTtbtv0tVbI+xoGYT8PCLumBNgWVDAfBgNV\n+            HSMEGDAWgBT6uVG\/TOfZhpgz+efLHvEzSfeoFDAdBgNVHREBAf8EEzARhwR\/AAAB\n+            gglsb2NhbGhvc3QwDQYJKoZIhvcNAQEEBQADgYEAWTrftGaL73lKLgRTrChGR+F6\n+            \/\/qvs0OM94IOKVeHz36NO49cMJmhJSbKdiGIkppBgpLIBoWxZlN9NOO9oSXFYZsZ\n+            rHaAe9\/lWMtQM7XpjqjhWVhB5VPvWFbkorQFMtRYLf7pkonGPFq8GOO1s0TKhogC\n+            jtYCdzlrU4v+om\/J3H8=\n+            -----END CERTIFICATE-----\"\"\";\n+\n+    static String clientCertStr =\n+            \"\"\"\n+            -----BEGIN CERTIFICATE-----\n+            MIICqjCCAhOgAwIBAgIBBTANBgkqhkiG9w0BAQQFADBJMQswCQYDVQQGEwJVUzET\n+            MBEGA1UECBMKU29tZS1TdGF0ZTESMBAGA1UEBxMJU29tZS1DaXR5MREwDwYDVQQK\n+            EwhTb21lLU9yZzAeFw0wODEyMDgwMzIyMTBaFw0yODA4MjUwMzIyMTBaMHIxCzAJ\n+            BgNVBAYTAlVTMRMwEQYDVQQIEwpTb21lLVN0YXRlMRIwEAYDVQQHEwlTb21lLUNp\n+            dHkxETAPBgNVBAoTCFNvbWUtT3JnMRMwEQYDVQQLEwpTU0wtQ2xpZW50MRIwEAYD\n+            VQQDEwlsb2NhbGhvc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBALvwQDas\n+            JlRO9KNaAC9pIW+5ejqT7KL24Y7HY9gvEjCZLrDyj\/gnLSR4KIT3Ab+NRHndO9JV\n+            8848slshfe\/9M0qxo\/\/GyJu5D3xBNZf52zoFYAUVr1kXkqMQrRYc5AdTr6h2olYq\n+            ktP5KOB4z14fSKtcGd3hZ0O6dY31gqxDkkQbAgMBAAGjeTB3MAkGA1UdEwQCMAAw\n+            CwYDVR0PBAQDAgXgMB0GA1UdDgQWBBTNu8iFqpG9\/R2+zWd8\/7PpTKgi5jAfBgNV\n+            HSMEGDAWgBT6uVG\/TOfZhpgz+efLHvEzSfeoFDAdBgNVHREBAf8EEzARhwR\/AAAB\n+            gglsb2NhbGhvc3QwDQYJKoZIhvcNAQEEBQADgYEAwDc4f13abs9ZeEkrl5WV2Z74\n+            BlmBhXu8ExtAvoF9q6Ug6xV1MDpxbD124KfUHHL0kNMhMB1WIpC0kOnQBxziNpfS\n+            7u6GOc3tWLSxw\/sHoJGCefnRBllLZOoQuSBrWB8qgilL6HRmZ4UqDcXu4UCaLBZ0\n+            KGDT5ASEN6Lq2GtiP4Y=\n+            -----END CERTIFICATE-----\"\"\";\n+\n+    static byte[] serverPrivateExponent = {\n+            (byte)0x6e, (byte)0xa7, (byte)0x1b, (byte)0x83,\n+            (byte)0x51, (byte)0x35, (byte)0x9a, (byte)0x44,\n+            (byte)0x7d, (byte)0xf6, (byte)0xe3, (byte)0x89,\n+            (byte)0xa0, (byte)0xd7, (byte)0x90, (byte)0x60,\n+            (byte)0xa1, (byte)0x4e, (byte)0x27, (byte)0x21,\n+            (byte)0xa2, (byte)0x89, (byte)0x74, (byte)0xcc,\n+            (byte)0x9d, (byte)0x75, (byte)0x75, (byte)0x4e,\n+            (byte)0xc7, (byte)0x82, (byte)0xe3, (byte)0xe3,\n+            (byte)0xc3, (byte)0x7d, (byte)0x00, (byte)0x54,\n+            (byte)0xec, (byte)0x36, (byte)0xb1, (byte)0xdf,\n+            (byte)0x91, (byte)0x9c, (byte)0x7a, (byte)0xc0,\n+            (byte)0x62, (byte)0x0a, (byte)0xd6, (byte)0xa9,\n+            (byte)0x22, (byte)0x91, (byte)0x4a, (byte)0x29,\n+            (byte)0x2e, (byte)0x43, (byte)0xfa, (byte)0x8c,\n+            (byte)0xd8, (byte)0xe9, (byte)0xbe, (byte)0xd9,\n+            (byte)0x4f, (byte)0xca, (byte)0x23, (byte)0xc6,\n+            (byte)0xe4, (byte)0x3f, (byte)0xb8, (byte)0x72,\n+            (byte)0xcf, (byte)0x02, (byte)0xfc, (byte)0xf4,\n+            (byte)0x58, (byte)0x34, (byte)0x77, (byte)0x76,\n+            (byte)0xce, (byte)0x22, (byte)0x44, (byte)0x5f,\n+            (byte)0x2d, (byte)0xca, (byte)0xee, (byte)0xf5,\n+            (byte)0x43, (byte)0x56, (byte)0x47, (byte)0x71,\n+            (byte)0x0b, (byte)0x09, (byte)0x6b, (byte)0x5e,\n+            (byte)0xf2, (byte)0xc8, (byte)0xee, (byte)0xd4,\n+            (byte)0x6e, (byte)0x44, (byte)0x92, (byte)0x2a,\n+            (byte)0x7f, (byte)0xcc, (byte)0xa7, (byte)0xd4,\n+            (byte)0x5b, (byte)0xfb, (byte)0xf7, (byte)0x4a,\n+            (byte)0xa9, (byte)0xfb, (byte)0x54, (byte)0x18,\n+            (byte)0xd5, (byte)0xd5, (byte)0x14, (byte)0xba,\n+            (byte)0xa0, (byte)0x1c, (byte)0x13, (byte)0xb3,\n+            (byte)0x37, (byte)0x6b, (byte)0x37, (byte)0x59,\n+            (byte)0xed, (byte)0xdb, (byte)0x6d, (byte)0xb1\n+    };\n+\n+    static byte[] serverModulus = {\n+            (byte)0x00,\n+            (byte)0xa5, (byte)0xac, (byte)0x5b, (byte)0x1c,\n+            (byte)0x37, (byte)0xa2, (byte)0xdd, (byte)0x99,\n+            (byte)0x89, (byte)0x2d, (byte)0xb2, (byte)0x79,\n+            (byte)0xb8, (byte)0x8f, (byte)0xd5, (byte)0x48,\n+            (byte)0xa5, (byte)0xe7, (byte)0x1c, (byte)0x84,\n+            (byte)0x17, (byte)0x8d, (byte)0x69, (byte)0x9c,\n+            (byte)0xc6, (byte)0xac, (byte)0x6d, (byte)0xf9,\n+            (byte)0xf2, (byte)0x1d, (byte)0x1f, (byte)0x39,\n+            (byte)0x19, (byte)0xda, (byte)0xd3, (byte)0x72,\n+            (byte)0x1e, (byte)0x6e, (byte)0xec, (byte)0x44,\n+            (byte)0xcc, (byte)0x70, (byte)0xa4, (byte)0xdc,\n+            (byte)0xba, (byte)0x00, (byte)0x30, (byte)0xf6,\n+            (byte)0xa0, (byte)0x4f, (byte)0x3d, (byte)0x54,\n+            (byte)0x7a, (byte)0x61, (byte)0x6a, (byte)0xcc,\n+            (byte)0x57, (byte)0xd0, (byte)0x0a, (byte)0x7f,\n+            (byte)0x95, (byte)0x28, (byte)0x18, (byte)0x3f,\n+            (byte)0x9a, (byte)0xd9, (byte)0x94, (byte)0xf2,\n+            (byte)0x1b, (byte)0xc8, (byte)0x24, (byte)0x88,\n+            (byte)0x7e, (byte)0xfe, (byte)0x9d, (byte)0x0f,\n+            (byte)0x3d, (byte)0xfb, (byte)0x57, (byte)0x53,\n+            (byte)0x08, (byte)0xb3, (byte)0x20, (byte)0x33,\n+            (byte)0xd4, (byte)0x3f, (byte)0x17, (byte)0x47,\n+            (byte)0x14, (byte)0xd1, (byte)0xcd, (byte)0xea,\n+            (byte)0x08, (byte)0xd8, (byte)0x0e, (byte)0x75,\n+            (byte)0x4e, (byte)0xaf, (byte)0xbe, (byte)0xcc,\n+            (byte)0xd2, (byte)0xec, (byte)0xaf, (byte)0xa9,\n+            (byte)0x7a, (byte)0x49, (byte)0xdf, (byte)0xc2,\n+            (byte)0xd9, (byte)0xac, (byte)0xb8, (byte)0x24,\n+            (byte)0x40, (byte)0x90, (byte)0xa6, (byte)0x03,\n+            (byte)0x56, (byte)0x2a, (byte)0xd0, (byte)0x30,\n+            (byte)0x05, (byte)0x40, (byte)0x2c, (byte)0x4f,\n+            (byte)0xab, (byte)0xd9, (byte)0x74, (byte)0x89\n+    };\n+\n+    static byte[] clientPrivateExponent = {\n+            (byte)0x11, (byte)0xb7, (byte)0x6a, (byte)0x36,\n+            (byte)0x3d, (byte)0x30, (byte)0x37, (byte)0xce,\n+            (byte)0x61, (byte)0x9d, (byte)0x6c, (byte)0x84,\n+            (byte)0x8b, (byte)0xf3, (byte)0x9b, (byte)0x25,\n+            (byte)0x4f, (byte)0x14, (byte)0xc8, (byte)0xa4,\n+            (byte)0xdd, (byte)0x2f, (byte)0xd7, (byte)0x9a,\n+            (byte)0x17, (byte)0xbd, (byte)0x90, (byte)0x19,\n+            (byte)0xf7, (byte)0x05, (byte)0xfd, (byte)0xf2,\n+            (byte)0xd2, (byte)0xc5, (byte)0xf7, (byte)0x77,\n+            (byte)0xbe, (byte)0xea, (byte)0xe2, (byte)0x84,\n+            (byte)0x87, (byte)0x97, (byte)0x3a, (byte)0x41,\n+            (byte)0x96, (byte)0xb6, (byte)0x99, (byte)0xf8,\n+            (byte)0x94, (byte)0x8c, (byte)0x58, (byte)0x71,\n+            (byte)0x51, (byte)0x8c, (byte)0xf4, (byte)0x2a,\n+            (byte)0x20, (byte)0x9e, (byte)0x1a, (byte)0xa0,\n+            (byte)0x26, (byte)0x99, (byte)0x75, (byte)0xd6,\n+            (byte)0x31, (byte)0x53, (byte)0x43, (byte)0x39,\n+            (byte)0xf5, (byte)0x2a, (byte)0xa6, (byte)0x7e,\n+            (byte)0x34, (byte)0x42, (byte)0x51, (byte)0x2a,\n+            (byte)0x40, (byte)0x87, (byte)0x03, (byte)0x88,\n+            (byte)0x43, (byte)0x69, (byte)0xb2, (byte)0x89,\n+            (byte)0x6d, (byte)0x20, (byte)0xbd, (byte)0x7d,\n+            (byte)0x71, (byte)0xef, (byte)0x47, (byte)0x0a,\n+            (byte)0xdf, (byte)0x06, (byte)0xc1, (byte)0x69,\n+            (byte)0x66, (byte)0xa8, (byte)0x22, (byte)0x37,\n+            (byte)0x1a, (byte)0x77, (byte)0x1e, (byte)0xc7,\n+            (byte)0x94, (byte)0x4e, (byte)0x2c, (byte)0x27,\n+            (byte)0x69, (byte)0x45, (byte)0x5e, (byte)0xc8,\n+            (byte)0xf8, (byte)0x0c, (byte)0xb7, (byte)0xf8,\n+            (byte)0xc0, (byte)0x8f, (byte)0x99, (byte)0xc1,\n+            (byte)0xe5, (byte)0x28, (byte)0x9b, (byte)0xf9,\n+            (byte)0x4c, (byte)0x94, (byte)0xc6, (byte)0xb1\n+    };\n+\n+    static byte[] clientModulus = {\n+            (byte)0x00,\n+            (byte)0xbb, (byte)0xf0, (byte)0x40, (byte)0x36,\n+            (byte)0xac, (byte)0x26, (byte)0x54, (byte)0x4e,\n+            (byte)0xf4, (byte)0xa3, (byte)0x5a, (byte)0x00,\n+            (byte)0x2f, (byte)0x69, (byte)0x21, (byte)0x6f,\n+            (byte)0xb9, (byte)0x7a, (byte)0x3a, (byte)0x93,\n+            (byte)0xec, (byte)0xa2, (byte)0xf6, (byte)0xe1,\n+            (byte)0x8e, (byte)0xc7, (byte)0x63, (byte)0xd8,\n+            (byte)0x2f, (byte)0x12, (byte)0x30, (byte)0x99,\n+            (byte)0x2e, (byte)0xb0, (byte)0xf2, (byte)0x8f,\n+            (byte)0xf8, (byte)0x27, (byte)0x2d, (byte)0x24,\n+            (byte)0x78, (byte)0x28, (byte)0x84, (byte)0xf7,\n+            (byte)0x01, (byte)0xbf, (byte)0x8d, (byte)0x44,\n+            (byte)0x79, (byte)0xdd, (byte)0x3b, (byte)0xd2,\n+            (byte)0x55, (byte)0xf3, (byte)0xce, (byte)0x3c,\n+            (byte)0xb2, (byte)0x5b, (byte)0x21, (byte)0x7d,\n+            (byte)0xef, (byte)0xfd, (byte)0x33, (byte)0x4a,\n+            (byte)0xb1, (byte)0xa3, (byte)0xff, (byte)0xc6,\n+            (byte)0xc8, (byte)0x9b, (byte)0xb9, (byte)0x0f,\n+            (byte)0x7c, (byte)0x41, (byte)0x35, (byte)0x97,\n+            (byte)0xf9, (byte)0xdb, (byte)0x3a, (byte)0x05,\n+            (byte)0x60, (byte)0x05, (byte)0x15, (byte)0xaf,\n+            (byte)0x59, (byte)0x17, (byte)0x92, (byte)0xa3,\n+            (byte)0x10, (byte)0xad, (byte)0x16, (byte)0x1c,\n+            (byte)0xe4, (byte)0x07, (byte)0x53, (byte)0xaf,\n+            (byte)0xa8, (byte)0x76, (byte)0xa2, (byte)0x56,\n+            (byte)0x2a, (byte)0x92, (byte)0xd3, (byte)0xf9,\n+            (byte)0x28, (byte)0xe0, (byte)0x78, (byte)0xcf,\n+            (byte)0x5e, (byte)0x1f, (byte)0x48, (byte)0xab,\n+            (byte)0x5c, (byte)0x19, (byte)0xdd, (byte)0xe1,\n+            (byte)0x67, (byte)0x43, (byte)0xba, (byte)0x75,\n+            (byte)0x8d, (byte)0xf5, (byte)0x82, (byte)0xac,\n+            (byte)0x43, (byte)0x92, (byte)0x44, (byte)0x1b\n+    };\n+\n+    static char[] passphrase = \"passphrase\".toCharArray();\n+    private final String protocol;\n+\n+    protected MD5NotAllowedInTLS13CertificateSignature(String protocol) {\n+        super();\n+        this.protocol = protocol;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ MD5 is disabled by default in java.security config file.\n+        Security.setProperty(\"jdk.certpath.disabledAlgorithms\", \"\");\n+        Security.setProperty(\"jdk.tls.disabledAlgorithms\", \"\");\n+\n+        \/\/ Should fail on TLSv1.3 and up.\n+        runAndCheckException(\n+                \/\/ The conditions to reproduce the bug being fixed only met when\n+                \/\/ 'TLS' is specified, i.e. when older versions of protocol are\n+                \/\/ supported besides TLSv1.3.\n+                () -> new MD5NotAllowedInTLS13CertificateSignature(\"TLS\").run(),\n+                serverEx -> {\n+                    Throwable clientEx = serverEx.getSuppressed()[0];\n+                    assertTrue(clientEx instanceof SSLHandshakeException);\n+                    assertEquals(clientEx.getMessage(), \"(bad_certificate) \"\n+                            + \"PKIX path validation failed: \"\n+                            + \"java.security.cert.CertPathValidatorException: \"\n+                            + \"Algorithm constraints check failed on signature\"\n+                            + \" algorithm: MD5withRSA\");\n+                });\n+\n+        \/\/ Should run fine on TLSv1.2.\n+        new MD5NotAllowedInTLS13CertificateSignature(\"TLSv1.2\").run();\n+    }\n+\n+    @Override\n+    public SSLContext createServerSSLContext() throws Exception {\n+        return getSSLContext(trusedCertStr, serverCertStr,\n+                serverModulus, serverPrivateExponent, passphrase, protocol);\n+    }\n+\n+    @Override\n+    public SSLContext createClientSSLContext() throws Exception {\n+        return getSSLContext(trusedCertStr, clientCertStr,\n+                clientModulus, clientPrivateExponent, passphrase, protocol);\n+    }\n+\n+    private static SSLContext getSSLContext(String trusedCertStr,\n+            String keyCertStr, byte[] modulus,\n+            byte[] privateExponent, char[] passphrase, String protocol)\n+            throws Exception {\n+\n+        \/\/ generate certificate from cert string\n+        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+\n+        ByteArrayInputStream is =\n+                new ByteArrayInputStream(trusedCertStr.getBytes());\n+        Certificate trusedCert = cf.generateCertificate(is);\n+        is.close();\n+\n+        \/\/ create a key store\n+        KeyStore ks = KeyStore.getInstance(\"JKS\");\n+        ks.load(null, null);\n+\n+        \/\/ import the trused cert\n+        ks.setCertificateEntry(\"TLS Signer\", trusedCert);\n+\n+        \/\/ generate the private key.\n+        RSAPrivateKeySpec priKeySpec = new RSAPrivateKeySpec(\n+                new BigInteger(modulus),\n+                new BigInteger(privateExponent));\n+        KeyFactory kf = KeyFactory.getInstance(\"RSA\");\n+        RSAPrivateKey priKey =\n+                (RSAPrivateKey) kf.generatePrivate(priKeySpec);\n+\n+        \/\/ generate certificate chain\n+        is = new ByteArrayInputStream(keyCertStr.getBytes());\n+        Certificate keyCert = cf.generateCertificate(is);\n+        is.close();\n+\n+        Certificate[] chain = new Certificate[2];\n+        chain[0] = keyCert;\n+        chain[1] = trusedCert;\n+\n+        \/\/ import the key entry.\n+        ks.setKeyEntry(\"Whatever\", priKey, passphrase, chain);\n+\n+        \/\/ Using PKIX TrustManager - this is where MD5 signature check is done.\n+        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"PKIX\");\n+        tmf.init(ks);\n+\n+        \/\/ create SSL context\n+        SSLContext ctx = SSLContext.getInstance(protocol);\n+\n+        \/\/ Using \"SunX509\" which doesn't check peer supported signature\n+        \/\/ algorithms, so we check against local supported signature\n+        \/\/ algorithms which constitutes the fix being tested.\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n+        kmf.init(ks, passphrase);\n+\n+        ctx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n+\n+        return ctx;\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/MD5NotAllowedInTLS13CertificateSignature.java","additions":361,"deletions":0,"binary":false,"changes":361,"status":"added"}]}