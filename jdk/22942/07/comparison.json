{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.util.HexDigits;\n@@ -286,1 +287,18 @@\n-        return toUnsignedString0(i, 4);\n+        int mag = Integer.SIZE - Integer.numberOfLeadingZeros(i);\n+        int len = Math.max(((mag + 3) >> 2), 1);\n+        long x = HexDigits.hex8Be(i);\n+        if (COMPACT_STRINGS) {\n+            byte[] chars = new byte[len];\n+            do {\n+                chars[--len] = (byte) x;\n+                x >>>= 8;\n+            } while (len > 0);\n+            return new String(chars, String.LATIN1);\n+        } else {\n+            byte[] chars = new byte[len << 1];\n+            do {\n+                StringUTF16.putChar(chars, --len, (byte) x);\n+                x >>>= 8;\n+            } while (len > 0);\n+            return new String(chars, String.UTF16);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -38,0 +39,1 @@\n+import jdk.internal.util.HexDigits;\n@@ -309,1 +311,32 @@\n-        return toUnsignedString0(i, 4);\n+        int mag = Long.SIZE - Long.numberOfLeadingZeros(i);\n+        int len = Math.max(((mag + 3) >> 2), 1);\n+        long x = HexDigits.hex8Be((int) i);\n+        if (COMPACT_STRINGS) {\n+            byte[] chars = new byte[len];\n+            if (len > 8) {\n+                len -= 8;\n+                Unsafe.getUnsafe().putLongUnaligned(chars, Unsafe.ARRAY_BYTE_BASE_OFFSET + len, x, true);\n+                x = HexDigits.hex8Be((int) (i >>> 32));\n+            }\n+            do {\n+                chars[--len] = (byte) x;\n+                x >>>= 8;\n+            } while (len > 0);\n+            return new String(chars, String.LATIN1);\n+        } else {\n+            byte[] chars = new byte[len << 1];\n+            byte b;\n+            if (len > 8) {\n+                for (int j = 0; j < 8; j++) {\n+                    b = (byte) x;\n+                    StringUTF16.putChar(chars, --len, b);\n+                    x >>>= 8;\n+                }\n+                x = HexDigits.hex8Be((int)(i >>> 32));\n+            }\n+            do {\n+                StringUTF16.putChar(chars, --len, (byte) x);\n+                x >>>= 8;\n+            } while (len > 0);\n+            return new String(chars, String.UTF16);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.internal.util.HexDigits;\n@@ -522,3 +523,3 @@\n-        \/\/ for the most common architectures. hex8 reverses the order internally.\n-        ByteArrayLittleEndian.setLong(buf, 0, hex8(mostSigBits >>> 32));\n-        long x0 = hex8(mostSigBits);\n+        \/\/ for the most common architectures.\n+        ByteArrayLittleEndian.setLong(buf, 0, Long.reverseBytes(HexDigits.hex8Be((int)(mostSigBits >>> 32))));\n+        long x0 = Long.reverseBytes(HexDigits.hex8Be((int)mostSigBits));\n@@ -528,1 +529,1 @@\n-        long x1 = hex8(leastSigBits >>> 32);\n+        long x1 = Long.reverseBytes(HexDigits.hex8Be((int)(leastSigBits >>> 32)));\n@@ -531,1 +532,1 @@\n-        ByteArrayLittleEndian.setLong(buf, 28, hex8(leastSigBits));\n+        ByteArrayLittleEndian.setLong(buf, 28, Long.reverseBytes(HexDigits.hex8Be((int)leastSigBits)));\n@@ -536,77 +537,0 @@\n-    \/**\n-     * Efficiently converts 8 hexadecimal digits to their ASCII representation using SIMD-style vector operations.\n-     * This method processes multiple digits in parallel by treating a long value as eight 8-bit lanes,\n-     * achieving significantly better performance compared to traditional loop-based conversion.\n-     *\n-     * <p>The conversion algorithm works as follows:\n-     * <pre>\n-     * 1. Input expansion: Each 4-bit hex digit is expanded to 8 bits\n-     * 2. Vector processing:\n-     *    - Add 6 to each digit: triggers carry flag for a-f digits\n-     *    - Mask with 0x10 pattern to isolate carry flags\n-     *    - Calculate ASCII adjustment: (carry << 1) + (carry >> 1) - (carry >> 4)\n-     *    - Add ASCII '0' base (0x30) and original value\n-     * 3. Byte order adjustment for final output\n-     * <\/pre>\n-     *\n-     * <p>Performance characteristics:\n-     * <ul>\n-     *   <li>Processes 8 digits in parallel using vector operations\n-     *   <li>Avoids branching and loops completely\n-     *   <li>Uses only integer arithmetic and bit operations\n-     *   <li>Constant time execution regardless of input values\n-     * <\/ul>\n-     *\n-     * <p>ASCII conversion mapping:\n-     * <ul>\n-     *   <li>Digits 0-9 → ASCII '0'-'9' (0x30-0x39)\n-     *   <li>Digits a-f → ASCII 'a'-'f' (0x61-0x66)\n-     * <\/ul>\n-     *\n-     * @param input A long containing 8 hex digits (each digit must be 0-15)\n-     * @return A long containing 8 ASCII bytes representing the hex digits\n-     *\n-     * @implNote The implementation leverages CPU vector processing capabilities through\n-     *           long integer operations. The algorithm is based on the observation that\n-     *           ASCII hex digits have a specific pattern that can be computed efficiently\n-     *           using carry flag manipulation.\n-     *\n-     * @example\n-     * <pre>\n-     * Input:  0xABCDEF01\n-     * Output: 3130666564636261 ('1','0','f','e','d','c','b','a' in ASCII)\n-     * <\/pre>\n-     *\n-     * @see Long#reverseBytes(long)\n-     *\/\n-    private static long hex8(long i) {\n-        \/\/ Expand each 4-bit group into 8 bits, spreading them out in the long value: 0xAABBCCDD -> 0xA0A0B0B0C0C0D0D\n-        i = Long.expand(i, 0x0F0F_0F0F_0F0F_0F0FL);\n-\n-        \/*\n-         * This method efficiently converts 8 hexadecimal digits simultaneously using vector operations\n-         * The algorithm works as follows:\n-         *\n-         * For input values 0-15:\n-         * - For digits 0-9: converts to ASCII '0'-'9' (0x30-0x39)\n-         * - For digits 10-15: converts to ASCII 'a'-'f' (0x61-0x66)\n-         *\n-         * The conversion process:\n-         * 1. Add 6 to each 4-bit group: i + 0x0606_0606_0606_0606L\n-         * 2. Mask to get the adjustment flags: & 0x1010_1010_1010_1010L\n-         * 3. Calculate the offset: (m << 1) + (m >> 1) - (m >> 4)\n-         *    - For 0-9: offset = 0\n-         *    - For a-f: offset = 39 (to bridge the gap between '9' and 'a' in ASCII)\n-         * 4. Add ASCII '0' base (0x30) and the original value\n-         * 5. Reverse byte order for correct positioning\n-         *\/\n-        long m = (i + 0x0606_0606_0606_0606L) & 0x1010_1010_1010_1010L;\n-\n-        \/\/ Calculate final ASCII values and reverse bytes for proper ordering\n-        return Long.reverseBytes(\n-                ((m << 1) + (m >> 1) - (m >> 4))\n-                + 0x3030_3030_3030_3030L \/\/ Add ASCII '0' base to all digits\n-                + i                      \/\/ Add original values\n-        );\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/util\/UUID.java","additions":6,"deletions":82,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -112,0 +112,16 @@\n+\n+    \/\/\/ Prints an unsigned 4-byte number into 8 hexadecimal digits in an ASCII character buffer.\n+    \/\/\/ The buffer is represented as a big-endian 8 byte integer.\n+    \/\/\/\n+    \/\/\/ Input:  0xA__B__C__D__E__F__0__1\n+    \/\/\/ Output: 0x61_62_63_64_65_66_30_31\n+    public static long hex8Be(int i) {\n+        \/\/ Expand each 4-bit group into 8 bits, spreading them out in the long value: 0xAABBCCDD -> 0xA0A0B0B0C0C0D0D\n+        long x = Long.expand(i, 0x0F0F_0F0F_0F0F_0F0FL);\n+\n+        long m = (x + 0x0606_0606_0606_0606L) & 0x1010_1010_1010_1010L;\n+\n+        return ((m << 1) + (m >> 1) - (m >> 4))\n+                + 0x3030_3030_3030_3030L \/\/ Add ASCII '0' base to all digits\n+                + x;                     \/\/ Add original values\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/HexDigits.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-@Warmup(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n@@ -61,0 +61,3 @@\n+    private int[] hexsTiny;\n+    private int[] hexsSmall;\n+    private int[] hexsBig;\n@@ -71,0 +74,3 @@\n+        hexsTiny  = new int[size];\n+        hexsSmall = new int[size];\n+        hexsBig   = new int[size];\n@@ -76,0 +82,4 @@\n+\n+            hexsTiny[i] = r.nextInt(0xFF);\n+            hexsSmall[i] = 0x100 * i + i + 0x103;\n+            hexsBig[i] = ((0x100 * i + i) << 24) + 0x4543 + i * 4;\n@@ -117,0 +127,21 @@\n+    @Benchmark\n+    public void toHexStringTiny(Blackhole bh) {\n+        for (int i : hexsTiny) {\n+            bh.consume(Integer.toHexString(i));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void toHexStringSmall(Blackhole bh) {\n+        for (int i : hexsSmall) {\n+            bh.consume(Integer.toHexString(i));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void toHexStringBig(Blackhole bh) {\n+        for (int i : hexsBig) {\n+            bh.consume(Integer.toHexString(i));\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/Integers.java","additions":32,"deletions":1,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+    private long[] hexsArraySmall;\n+    private long[] hexsArrayBig;\n@@ -66,0 +68,2 @@\n+        hexsArraySmall = new long[size];\n+        hexsArrayBig = new long[size];\n@@ -70,0 +74,2 @@\n+            hexsArraySmall[i] = 0x100L * i + i + 0x103L;\n+            hexsArrayBig[i] = ((0x100L * i + i) << 32) + 0x4543 + i * 4L;\n@@ -96,0 +102,14 @@\n+    @Benchmark\n+    public void toHexStringSmall(Blackhole bh) {\n+        for (long value : hexsArraySmall) {\n+            bh.consume(Long.toHexString(value));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void toHexStringBig(Blackhole bh) {\n+        for (long value : hexsArrayBig) {\n+            bh.consume(Long.toHexString(value));\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/Longs.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"}]}