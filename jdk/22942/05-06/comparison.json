{"files":[{"patch":"@@ -289,1 +289,1 @@\n-        long x = HexDigits.hex8(i);\n+        long x = HexDigits.hex8Be(i);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -313,1 +313,1 @@\n-        long x = HexDigits.hex8(i);\n+        long x = HexDigits.hex8Be((int)i);\n@@ -319,1 +319,1 @@\n-                x = HexDigits.hex8(i >>> 32);\n+                x = HexDigits.hex8Be((int)(i >>> 32));\n@@ -335,1 +335,1 @@\n-                x = HexDigits.hex8(i >>> 32);\n+                x = HexDigits.hex8Be((int)(i >>> 32));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -524,2 +524,2 @@\n-        ByteArrayLittleEndian.setLong(buf, 0, Long.reverseBytes(HexDigits.hex8(mostSigBits >>> 32)));\n-        long x0 = Long.reverseBytes(HexDigits.hex8(mostSigBits));\n+        ByteArrayLittleEndian.setLong(buf, 0, Long.reverseBytes(HexDigits.hex8Be((int)(mostSigBits >>> 32))));\n+        long x0 = Long.reverseBytes(HexDigits.hex8Be((int)mostSigBits));\n@@ -529,1 +529,1 @@\n-        long x1 = Long.reverseBytes(HexDigits.hex8(leastSigBits >>> 32));\n+        long x1 = Long.reverseBytes(HexDigits.hex8Be((int)(leastSigBits >>> 32)));\n@@ -532,1 +532,1 @@\n-        ByteArrayLittleEndian.setLong(buf, 28, Long.reverseBytes(HexDigits.hex8(leastSigBits)));\n+        ByteArrayLittleEndian.setLong(buf, 28, Long.reverseBytes(HexDigits.hex8Be((int)leastSigBits)));\n","filename":"src\/java.base\/share\/classes\/java\/util\/UUID.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -113,46 +113,6 @@\n-    \/**\n-     * Efficiently converts 8 hexadecimal digits to their ASCII representation using SIMD-style vector operations.\n-     * This method processes multiple digits in parallel by treating a long value as eight 8-bit lanes,\n-     * achieving significantly better performance compared to traditional loop-based conversion.\n-     *\n-     * <p>The conversion algorithm works as follows:\n-     * <pre>\n-     * 1. Input expansion: Each 4-bit hex digit is expanded to 8 bits\n-     * 2. Vector processing:\n-     *    - Add 6 to each digit: triggers carry flag for a-f digits\n-     *    - Mask with 0x10 pattern to isolate carry flags\n-     *    - Calculate ASCII adjustment: (carry << 1) + (carry >> 1) - (carry >> 4)\n-     *    - Add ASCII '0' base (0x30) and original value\n-     * 3. Byte order adjustment for final output\n-     * <\/pre>\n-     *\n-     * <p>Performance characteristics:\n-     * <ul>\n-     *   <li>Processes 8 digits in parallel using vector operations\n-     *   <li>Avoids branching and loops completely\n-     *   <li>Uses only integer arithmetic and bit operations\n-     *   <li>Constant time execution regardless of input values\n-     * <\/ul>\n-     *\n-     * <p>ASCII conversion mapping:\n-     * <ul>\n-     *   <li>Digits 0-9 → ASCII '0'-'9' (0x30-0x39)\n-     *   <li>Digits a-f → ASCII 'a'-'f' (0x61-0x66)\n-     * <\/ul>\n-     *\n-     * @param input A long containing 8 hex digits (each digit must be 0-15)\n-     * @return A long containing 8 ASCII bytes representing the hex digits\n-     *\n-     * @implNote The implementation leverages CPU vector processing capabilities through\n-     *           long integer operations. The algorithm is based on the observation that\n-     *           ASCII hex digits have a specific pattern that can be computed efficiently\n-     *           using carry flag manipulation.\n-     *\n-     * @example\n-     * <pre>\n-     * Input:  0xABCDEF01\n-     * Output: 3130666564636261 ('1','0','f','e','d','c','b','a' in ASCII)\n-     * <\/pre>\n-     *\n-     *\/\n-    public static long hex8(long i) {\n+    \/\/\/ Prints an unsigned 4-byte number into 8 hexadecimal digits in an ASCII character buffer.\n+    \/\/\/ The buffer is represented as a big-endian 8 byte integer.\n+    \/\/\/\n+    \/\/\/ Input:  0xA__B__C__D__E__F__0__1\n+    \/\/\/ Output: 0x61_62_63_64_65_66_30_31\n+    public static long hex8Be(int i) {\n@@ -160,1 +120,1 @@\n-        i = Long.expand(i, 0x0F0F_0F0F_0F0F_0F0FL);\n+        long x = Long.expand(i, 0x0F0F_0F0F_0F0F_0F0FL);\n@@ -162,18 +122,1 @@\n-        \/*\n-         * This method efficiently converts 8 hexadecimal digits simultaneously using vector operations\n-         * The algorithm works as follows:\n-         *\n-         * For input values 0-15:\n-         * - For digits 0-9: converts to ASCII '0'-'9' (0x30-0x39)\n-         * - For digits 10-15: converts to ASCII 'a'-'f' (0x61-0x66)\n-         *\n-         * The conversion process:\n-         * 1. Add 6 to each 4-bit group: i + 0x0606_0606_0606_0606L\n-         * 2. Mask to get the adjustment flags: & 0x1010_1010_1010_1010L\n-         * 3. Calculate the offset: (m << 1) + (m >> 1) - (m >> 4)\n-         *    - For 0-9: offset = 0\n-         *    - For a-f: offset = 39 (to bridge the gap between '9' and 'a' in ASCII)\n-         * 4. Add ASCII '0' base (0x30) and the original value\n-         * 5. Reverse byte order for correct positioning\n-         *\/\n-        long m = (i + 0x0606_0606_0606_0606L) & 0x1010_1010_1010_1010L;\n+        long m = (x + 0x0606_0606_0606_0606L) & 0x1010_1010_1010_1010L;\n@@ -181,1 +124,0 @@\n-        \/\/ Calculate final ASCII values and reverse bytes for proper ordering\n@@ -184,1 +126,1 @@\n-                + i;                     \/\/ Add original values\n+                + x;                     \/\/ Add original values\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/HexDigits.java","additions":9,"deletions":67,"binary":false,"changes":76,"status":"modified"}]}