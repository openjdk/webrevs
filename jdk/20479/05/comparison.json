{"files":[{"patch":"@@ -7323,0 +7323,22 @@\n+  \/\/ load Method* target of MethodHandle\n+  \/\/ j_rarg0 = jobject receiver\n+  \/\/ rmethod = result\n+  address generate_upcall_stub_load_target() {\n+    StubCodeMark mark(this, \"StubRoutines\", \"upcall_stub_load_target\");\n+    address start = __ pc();\n+\n+    __ resolve_global_jobject(j_rarg0, rscratch1, rscratch2);\n+      \/\/ Load target method from receiver\n+    __ load_heap_oop(rmethod, Address(j_rarg0, java_lang_invoke_MethodHandle::form_offset()), rscratch1, rscratch2);\n+    __ load_heap_oop(rmethod, Address(rmethod, java_lang_invoke_LambdaForm::vmentry_offset()), rscratch1, rscratch2);\n+    __ load_heap_oop(rmethod, Address(rmethod, java_lang_invoke_MemberName::method_offset()), rscratch1, rscratch2);\n+    __ access_load_at(T_ADDRESS, IN_HEAP, rmethod,\n+                      Address(rmethod, java_lang_invoke_ResolvedMethodName::vmtarget_offset()),\n+                      noreg, noreg);\n+    __ str(rmethod, Address(rthread, JavaThread::callee_target_offset())); \/\/ just in case callee is deoptimized\n+\n+    __ ret(lr);\n+\n+    return start;\n+  }\n+\n@@ -8244,0 +8266,1 @@\n+    StubRoutines::_upcall_stub_load_target = generate_upcall_stub_load_target();\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"classfile\/javaClasses.hpp\"\n@@ -120,1 +121,1 @@\n-address UpcallLinker::make_upcall_stub(jobject receiver, Method* entry,\n+address UpcallLinker::make_upcall_stub(jobject receiver, Symbol* signature,\n@@ -225,1 +226,0 @@\n-  __ movptr(c_rarg1, (intptr_t)receiver);\n@@ -241,6 +241,4 @@\n-  __ block_comment(\"{ receiver \");\n-  __ get_vm_result(j_rarg0, rthread);\n-  __ block_comment(\"} receiver \");\n-\n-  __ mov_metadata(rmethod, entry);\n-  __ str(rmethod, Address(rthread, JavaThread::callee_target_offset())); \/\/ just in case callee is deoptimized\n+  __ block_comment(\"{ load target \");\n+  __ movptr(j_rarg0, (intptr_t)receiver);\n+  __ far_call(RuntimeAddress(StubRoutines::upcall_stub_load_target()), rscratch1); \/\/ puts target Method* in rmethod\n+  __ block_comment(\"} load target \");\n@@ -321,1 +319,1 @@\n-  ss.print(\"upcall_stub_%s\", entry->signature()->as_C_string());\n+  ss.print(\"upcall_stub_%s\", signature->as_C_string());\n","filename":"src\/hotspot\/cpu\/aarch64\/upcallLinker_aarch64.cpp","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-address UpcallLinker::make_upcall_stub(jobject receiver, Method* entry,\n+address UpcallLinker::make_upcall_stub(jobject receiver, Symbol* signature,\n","filename":"src\/hotspot\/cpu\/arm\/upcallLinker_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4590,0 +4590,24 @@\n+  \/\/ load Method* target of MethodHandle\n+  \/\/ R3_ARG1 = jobject receiver\n+  \/\/ R19_method = result Method*\n+  address generate_upcall_stub_load_target() {\n+\n+    StubCodeMark mark(this, \"StubRoutines\", \"upcall_stub_load_target\");\n+    address start = __ pc();\n+\n+    __ resolve_global_jobject(R3_ARG1, R22_tmp2, R23_tmp3, MacroAssembler::PRESERVATION_FRAME_LR_GP_FP_REGS);\n+    \/\/ Load target method from receiver\n+    __ load_heap_oop(R19_method, java_lang_invoke_MethodHandle::form_offset(), R3_ARG1,\n+                     R22_tmp2, R23_tmp3, MacroAssembler::PRESERVATION_FRAME_LR_GP_FP_REGS, IS_NOT_NULL);\n+    __ load_heap_oop(R19_method, java_lang_invoke_LambdaForm::vmentry_offset(), R19_method,\n+                     R22_tmp2, R23_tmp3, MacroAssembler::PRESERVATION_FRAME_LR_GP_FP_REGS, IS_NOT_NULL);\n+    __ load_heap_oop(R19_method, java_lang_invoke_MemberName::method_offset(), R19_method,\n+                     R22_tmp2, R23_tmp3, MacroAssembler::PRESERVATION_FRAME_LR_GP_FP_REGS, IS_NOT_NULL);\n+    __ ld(R19_method, java_lang_invoke_ResolvedMethodName::vmtarget_offset(), R19_method);\n+    __ std(R19_method, in_bytes(JavaThread::callee_target_offset()), R16_thread); \/\/ just in case callee is deoptimized\n+\n+    __ blr();\n+\n+    return start;\n+  }\n+\n@@ -4654,0 +4678,1 @@\n+    StubRoutines::_upcall_stub_load_target = generate_upcall_stub_load_target();\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"classfile\/javaClasses.hpp\"\n@@ -121,1 +122,1 @@\n-address UpcallLinker::make_upcall_stub(jobject receiver, Method* entry,\n+address UpcallLinker::make_upcall_stub(jobject receiver, Symbol* signature,\n@@ -224,1 +225,0 @@\n-  __ load_const_optimized(R4_ARG2, (intptr_t)receiver, R0);\n@@ -239,6 +239,6 @@\n-  __ block_comment(\"{ receiver \");\n-  __ get_vm_result(R3_ARG1);\n-  __ block_comment(\"} receiver \");\n-\n-  __ load_const_optimized(R19_method, (intptr_t)entry);\n-  __ std(R19_method, in_bytes(JavaThread::callee_target_offset()), R16_thread);\n+  __ block_comment(\"{ load target \");\n+  __ load_const_optimized(call_target_address, StubRoutines::upcall_stub_load_target(), R0);\n+  __ load_const_optimized(R3_ARG1, (intptr_t)receiver, R0);\n+  __ mtctr(call_target_address);\n+  __ bctrl(); \/\/ loads target Method* into R19_method\n+  __ block_comment(\"} load target \");\n@@ -329,1 +329,1 @@\n-  ss.print(\"upcall_stub_%s\", entry->signature()->as_C_string());\n+  ss.print(\"upcall_stub_%s\", signature->as_C_string());\n","filename":"src\/hotspot\/cpu\/ppc\/upcallLinker_ppc.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -6128,0 +6128,23 @@\n+  \/\/ load Method* target of MethodHandle\n+  \/\/ j_rarg0 = jobject receiver\n+  \/\/ xmethod = Method* result\n+  address generate_upcall_stub_load_target() {\n+\n+    StubCodeMark mark(this, \"StubRoutines\", \"upcall_stub_load_target\");\n+    address start = __ pc();\n+\n+    __ resolve_global_jobject(j_rarg0, t0, t1);\n+      \/\/ Load target method from receiver\n+    __ load_heap_oop(xmethod, Address(j_rarg0, java_lang_invoke_MethodHandle::form_offset()), t0, t1);\n+    __ load_heap_oop(xmethod, Address(xmethod, java_lang_invoke_LambdaForm::vmentry_offset()), t0, t1);\n+    __ load_heap_oop(xmethod, Address(xmethod, java_lang_invoke_MemberName::method_offset()), t0, t1);\n+    __ access_load_at(T_ADDRESS, IN_HEAP, xmethod,\n+                      Address(xmethod, java_lang_invoke_ResolvedMethodName::vmtarget_offset()),\n+                      noreg, noreg);\n+    __ sd(xmethod, Address(xthread, JavaThread::callee_target_offset())); \/\/ just in case callee is deoptimized\n+\n+    __ ret();\n+\n+    return start;\n+  }\n+\n@@ -6193,0 +6216,1 @@\n+    StubRoutines::_upcall_stub_load_target = generate_upcall_stub_load_target();\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/javaClasses.hpp\"\n@@ -120,1 +121,1 @@\n-address UpcallLinker::make_upcall_stub(jobject receiver, Method* entry,\n+address UpcallLinker::make_upcall_stub(jobject receiver, Symbol* signature,\n@@ -226,1 +227,0 @@\n-  __ movptr(c_rarg1, (address) receiver);\n@@ -263,6 +263,4 @@\n-  __ block_comment(\"{ receiver \");\n-  __ get_vm_result(j_rarg0, xthread);\n-  __ block_comment(\"} receiver \");\n-\n-  __ mov_metadata(xmethod, entry);\n-  __ sd(xmethod, Address(xthread, JavaThread::callee_target_offset())); \/\/ just in case callee is deoptimized\n+  __ block_comment(\"{ load target \");\n+  __ movptr(j_rarg0, (address) receiver);\n+  __ far_call(RuntimeAddress(StubRoutines::upcall_stub_load_target())); \/\/ loads Method* into xmethod\n+  __ block_comment(\"} load target \");\n@@ -341,1 +339,1 @@\n-  ss.print(\"upcall_stub_%s\", entry->signature()->as_C_string());\n+  ss.print(\"upcall_stub_%s\", signature->as_C_string());\n","filename":"src\/hotspot\/cpu\/riscv\/upcallLinker_riscv.cpp","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3056,0 +3056,23 @@\n+  \/\/ load Method* target of MethodHandle\n+  \/\/ Z_ARG1 = jobject receiver\n+  \/\/ Z_method = Method* result\n+  address generate_upcall_stub_load_target() {\n+    StubCodeMark mark(this, \"StubRoutines\", \"upcall_stub_load_target\");\n+    address start = __ pc();\n+\n+    __ resolve_global_jobject(Z_ARG1, Z_tmp_1, Z_tmp_2);\n+      \/\/ Load target method from receiver\n+    __ load_heap_oop(Z_method, Address(Z_ARG1, java_lang_invoke_MethodHandle::form_offset()),\n+                    noreg, noreg, IS_NOT_NULL);\n+    __ load_heap_oop(Z_method, Address(Z_method, java_lang_invoke_LambdaForm::vmentry_offset()),\n+                    noreg, noreg, IS_NOT_NULL);\n+    __ load_heap_oop(Z_method, Address(Z_method, java_lang_invoke_MemberName::method_offset()),\n+                    noreg, noreg, IS_NOT_NULL);\n+    __ z_lg(Z_method, Address(Z_method, java_lang_invoke_ResolvedMethodName::vmtarget_offset()));\n+    __ z_stg(Z_method, Address(Z_thread, JavaThread::callee_target_offset())); \/\/ just in case callee is deoptimized\n+\n+    __ z_br(Z_R14);\n+\n+    return start;\n+  }\n+\n@@ -3113,0 +3136,1 @@\n+    StubRoutines::_upcall_stub_load_target = generate_upcall_stub_load_target();\n","filename":"src\/hotspot\/cpu\/s390\/stubGenerator_s390.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"classfile\/javaClasses.hpp\"\n@@ -119,1 +120,1 @@\n-address UpcallLinker::make_upcall_stub(jobject receiver, Method* entry,\n+address UpcallLinker::make_upcall_stub(jobject receiver, Symbol* signature,\n@@ -209,1 +210,0 @@\n-  __ load_const_optimized(Z_ARG2, (intptr_t)receiver);\n@@ -219,6 +219,5 @@\n-  __ block_comment(\"receiver {\");\n-  __ get_vm_result(Z_ARG1);\n-  __ block_comment(\"} receiver\");\n-\n-  __ load_const_optimized(Z_method, (intptr_t)entry);\n-  __ z_stg(Z_method, Address(Z_thread, in_bytes(JavaThread::callee_target_offset())));\n+  __ block_comment(\"load_target {\");\n+  __ load_const_optimized(Z_ARG1, (intptr_t)receiver);\n+  __ load_const_optimized(call_target_address, StubRoutines::upcall_stub_load_target());\n+  __ call(call_target_address); \/\/ load taget Method* into Z_method\n+  __ block_comment(\"} load_target\");\n@@ -277,1 +276,1 @@\n-  ss.print(\"upcall_stub_%s\", entry->signature()->as_C_string());\n+  ss.print(\"upcall_stub_%s\", signature->as_C_string());\n","filename":"src\/hotspot\/cpu\/s390\/upcallLinker_s390.cpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"classfile\/javaClasses.hpp\"\n@@ -3796,0 +3797,22 @@\n+\/\/ load Method* target of MethodHandle\n+\/\/ j_rarg0 = jobject receiver\n+\/\/ rbx = result\n+address StubGenerator::generate_upcall_stub_load_target() {\n+  StubCodeMark mark(this, \"StubRoutines\", \"upcall_stub_load_target\");\n+  address start = __ pc();\n+\n+  __ resolve_global_jobject(j_rarg0, r15_thread, rscratch1);\n+    \/\/ Load target method from receiver\n+  __ load_heap_oop(rbx, Address(j_rarg0, java_lang_invoke_MethodHandle::form_offset()), rscratch1);\n+  __ load_heap_oop(rbx, Address(rbx, java_lang_invoke_LambdaForm::vmentry_offset()), rscratch1);\n+  __ load_heap_oop(rbx, Address(rbx, java_lang_invoke_MemberName::method_offset()), rscratch1);\n+  __ access_load_at(T_ADDRESS, IN_HEAP, rbx,\n+                    Address(rbx, java_lang_invoke_ResolvedMethodName::vmtarget_offset()),\n+                    noreg, noreg);\n+  __ movptr(Address(r15_thread, JavaThread::callee_target_offset()), rbx); \/\/ just in case callee is deoptimized\n+\n+  __ ret(0);\n+\n+  return start;\n+}\n+\n@@ -3955,0 +3978,1 @@\n+  StubRoutines::_upcall_stub_load_target = generate_upcall_stub_load_target();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -611,0 +611,1 @@\n+  address generate_upcall_stub_load_target();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-address UpcallLinker::make_upcall_stub(jobject receiver, Method* entry,\n+address UpcallLinker::make_upcall_stub(jobject receiver, Symbol* signature,\n","filename":"src\/hotspot\/cpu\/x86\/upcallLinker_x86_32.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"code\/codeBlob.hpp\"\n+#include \"classfile\/javaClasses.hpp\"\n@@ -172,1 +172,1 @@\n-static const int upcall_stub_code_base_size = 1024;\n+static const int upcall_stub_code_base_size = 1200;\n@@ -175,1 +175,1 @@\n-address UpcallLinker::make_upcall_stub(jobject receiver, Method* entry,\n+address UpcallLinker::make_upcall_stub(jobject receiver, Symbol* signature,\n@@ -284,1 +284,0 @@\n-  __ movptr(c_rarg1, (intptr_t)receiver);\n@@ -300,6 +299,4 @@\n-  __ block_comment(\"{ receiver \");\n-  __ get_vm_result(j_rarg0, r15_thread);\n-  __ block_comment(\"} receiver \");\n-\n-  __ mov_metadata(rbx, entry);\n-  __ movptr(Address(r15_thread, JavaThread::callee_target_offset()), rbx); \/\/ just in case callee is deoptimized\n+  __ block_comment(\"{ load target \");\n+  __ movptr(j_rarg0, (intptr_t)receiver);\n+  __ call(RuntimeAddress(StubRoutines::upcall_stub_load_target())); \/\/ puts target Method* in rbx\n+  __ block_comment(\"} load target \");\n@@ -380,1 +377,1 @@\n-  ss.print(\"upcall_stub_%s\", entry->signature()->as_C_string());\n+  ss.print(\"upcall_stub_%s\", signature->as_C_string());\n","filename":"src\/hotspot\/cpu\/x86\/upcallLinker_x86_64.cpp","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-address UpcallLinker::make_upcall_stub(jobject mh, Method* entry,\n+address UpcallLinker::make_upcall_stub(jobject mh, Symbol* signature,\n","filename":"src\/hotspot\/cpu\/zero\/upcallLinker_zero.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-#include \"runtime\/jniHandles.hpp\"\n+#include \"runtime\/jniHandles.inline.hpp\"\n@@ -626,1 +626,1 @@\n-  trace_new_stub(blob, \"UpcallStub\");\n+  trace_new_stub(blob, \"UpcallStub - \", name);\n@@ -775,0 +775,4 @@\n+  st->print_cr(\"Frame data offset: %d\", (int) _frame_data_offset);\n+  oop recv = JNIHandles::resolve(_receiver);\n+  st->print(\"Receiver MH=\");\n+  recv->print_on(st);\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/javaClasses.inline.hpp\"\n@@ -76,1 +76,1 @@\n-JavaThread* UpcallLinker::on_entry(UpcallStub::FrameData* context, jobject receiver) {\n+JavaThread* UpcallLinker::on_entry(UpcallStub::FrameData* context) {\n@@ -111,2 +111,0 @@\n-  thread->set_vm_result(JNIHandles::resolve(receiver));\n-\n@@ -141,2 +139,0 @@\n-  ResourceMark rm;\n-  \/\/ Based on CATCH macro\n@@ -144,2 +140,3 @@\n-  exception->print();\n-  ShouldNotReachHere();\n+  Handle exception_h(Thread::current(), exception);\n+  java_lang_Throwable::print_stack_trace(exception_h, tty);\n+  fatal(\"Unrecoverable uncaught exception encountered\");\n@@ -153,0 +150,1 @@\n+  oop type = java_lang_invoke_MethodHandle::type(mh_h());\n@@ -154,9 +152,0 @@\n-  oop lform = java_lang_invoke_MethodHandle::form(mh_h());\n-  oop vmentry = java_lang_invoke_LambdaForm::vmentry(lform);\n-  Method* entry = java_lang_invoke_MemberName::vmtarget(vmentry);\n-  const methodHandle mh_entry(THREAD, entry);\n-\n-  assert(entry->method_holder()->is_initialized(), \"no clinit barrier\");\n-  CompilationPolicy::compile_if_required(mh_entry, CHECK_0);\n-\n-  assert(entry->is_static(), \"static only\");\n@@ -164,2 +153,1 @@\n-  const int total_out_args = entry->size_of_parameters();\n-  assert(total_out_args > 0, \"receiver arg\");\n+  const int total_out_args = java_lang_invoke_MethodType::ptype_slot_count(type) + 1; \/\/ +1 for receiver\n@@ -167,0 +155,2 @@\n+  bool create_new = true;\n+  TempNewSymbol signature = java_lang_invoke_MethodType::as_signature(type, create_new);\n@@ -171,1 +161,2 @@\n-    SignatureStream ss(entry->signature());\n+    out_sig_bt[i++] = T_OBJECT; \/\/ receiver MH\n+    SignatureStream ss(signature);\n@@ -177,1 +168,1 @@\n-    assert(i == total_out_args, \"\");\n+    assert(i == total_out_args, \"%d != %d\", i, total_out_args);\n@@ -182,1 +173,1 @@\n-    mh_j, entry, out_sig_bt, total_out_args, ret_type,\n+    mh_j, signature, out_sig_bt, total_out_args, ret_type,\n","filename":"src\/hotspot\/share\/prims\/upcallLinker.cpp","additions":13,"deletions":22,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  static JavaThread* on_entry(UpcallStub::FrameData* context, jobject receiver);\n+  static JavaThread* on_entry(UpcallStub::FrameData* context);\n@@ -40,1 +40,1 @@\n-  static address make_upcall_stub(jobject mh, Method* entry,\n+  static address make_upcall_stub(jobject mh, Symbol* signature,\n","filename":"src\/hotspot\/share\/prims\/upcallLinker.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -722,0 +722,2 @@\n+    } else if (_cb->is_upcall_stub()) {\n+      st->print(\"v  ~UpcallStub::%s \" PTR_FORMAT, _cb->name(), p2i(pc()));\n@@ -1119,0 +1121,13 @@\n+void frame::oops_upcall_do(OopClosure* f, const RegisterMap* map) const {\n+  assert(map != nullptr, \"map must be set\");\n+  if (map->include_argument_oops()) {\n+    \/\/ Upcall stubs call a MethodHandle impl method of which only the receiver\n+    \/\/ is ever an oop.\n+    \/\/ Currently we should not be able to get here, since there are no\n+    \/\/ safepoints in the one resolve stub we can get into (handle_wrong_method)\n+    \/\/ Leave this here as a trap in case we ever do:\n+    ShouldNotReachHere(); \/\/ not implemented\n+  }\n+  _cb->as_upcall_stub()->oops_do(f, *this);\n+}\n+\n@@ -1150,1 +1165,1 @@\n-    _cb->as_upcall_stub()->oops_do(f, *this);\n+    oops_upcall_do(f, map);\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -467,0 +467,1 @@\n+  void oops_upcall_do(OopClosure* f, const RegisterMap* map) const;\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -190,0 +190,1 @@\n+address StubRoutines::_upcall_stub_load_target = nullptr;\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -300,0 +300,1 @@\n+  static address _upcall_stub_load_target;\n@@ -507,0 +508,5 @@\n+  static address upcall_stub_load_target() {\n+    assert(_upcall_stub_load_target != nullptr, \"not implemented\");\n+    return _upcall_stub_load_target;\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -384,1 +384,2 @@\n-    -java\/foreign\/TestMatrix.java\n+    -java\/foreign\/TestMatrix.java \\\n+    -java\/foreign\/TestUpcallStress.java\n","filename":"test\/jdk\/TEST.groups","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires jdk.foreign.linker != \"FALLBACK\"\n+ * @requires (os.arch == \"aarch64\" | os.arch==\"riscv64\") & os.name == \"Linux\"\n+ * @requires os.maxMemory > 4G\n+ * @modules java.base\/jdk.internal.foreign\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcallBase\n+ * @bug 8337753\n+ *\n+ * @run testng\/othervm\/timeout=3200\n+ *   -Xcheck:jni\n+ *   -XX:+IgnoreUnrecognizedVMOptions\n+ *   -XX:-VerifyDependencies\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Dgenerator.sample.factor=17\n+ *   TestUpcallStress\n+ *\/\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemorySegment;\n+\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.*;\n+import java.util.function.Consumer;\n+\n+public class TestUpcallStress extends TestUpcallBase {\n+\n+    static {\n+        System.loadLibrary(\"TestUpcall\");\n+    }\n+\n+    @Test(dataProvider=\"functions\", dataProviderClass=CallGeneratorHelper.class)\n+    public void testUpcallsStress(int count, String fName, Ret ret, List<ParamType> paramTypes,\n+                                  List<StructFieldType> fields) throws Throwable {\n+        ExecutorService executor = Executors.newFixedThreadPool(16);\n+        for (int threadIdx = 0; threadIdx < 16; threadIdx++) {\n+            executor.submit(() -> {\n+                for (int iter = 0; iter < 10000; iter++) {\n+                    List<Consumer<Object>> returnChecks = new ArrayList<>();\n+                    List<Consumer<Object>> argChecks = new ArrayList<>();\n+                    MemorySegment addr = findNativeOrThrow(fName);\n+                    try (Arena arena = Arena.ofConfined()) {\n+                        FunctionDescriptor descriptor = function(ret, paramTypes, fields);\n+                        MethodHandle mh = downcallHandle(LINKER, addr, arena, descriptor);\n+                        AtomicReference<Object[]> capturedArgs = new AtomicReference<>();\n+                        Object[] args = makeArgs(capturedArgs, arena, descriptor, returnChecks, argChecks, 0);\n+\n+                        Object res = mh.invokeWithArguments(args);\n+\n+                        if (ret == Ret.NON_VOID) {\n+                            returnChecks.forEach(c -> c.accept(res));\n+                        }\n+\n+                        Object[] capturedArgsArr = capturedArgs.get();\n+                        for (int i = 0; i < capturedArgsArr.length; i++) {\n+                            argChecks.get(i).accept(capturedArgsArr[i]);\n+                        }\n+                    } catch (Throwable ex) {\n+                        throw new AssertionError(ex);\n+                    }\n+                }\n+            });\n+        }\n+        \/\/ This shutdownNow is 'wrong', since it doesn't wait for tasks to terminate,\n+        \/\/ but it seems to be the only way to reproduce the race of JDK-8337753\n+        executor.shutdownNow();\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStress.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"}]}