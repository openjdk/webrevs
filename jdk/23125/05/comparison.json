{"files":[{"patch":"@@ -476,0 +476,15 @@\n+void ObjectMonitor::notify_contended_enter(JavaThread *current) {\n+  current->set_current_pending_monitor(this);\n+\n+  DTRACE_MONITOR_PROBE(contended__enter, this, object(), current);\n+  if (JvmtiExport::should_post_monitor_contended_enter()) {\n+    JvmtiExport::post_monitor_contended_enter(current, this);\n+\n+    \/\/ The current thread does not yet own the monitor and does not\n+    \/\/ yet appear on any queues that would get it made the successor.\n+    \/\/ This means that the JVMTI_EVENT_MONITOR_CONTENDED_ENTER event\n+    \/\/ handler cannot accidentally consume an unpark() meant for the\n+    \/\/ ParkEvent associated with this ObjectMonitor.\n+  }\n+}\n+\n@@ -495,32 +510,18 @@\n-  { \/\/ Change java thread status to indicate blocked on monitor enter.\n-    JavaThreadBlockedOnMonitorEnterState jtbmes(current, this);\n-\n-    assert(current->current_pending_monitor() == nullptr, \"invariant\");\n-    current->set_current_pending_monitor(this);\n-\n-    DTRACE_MONITOR_PROBE(contended__enter, this, object(), current);\n-    if (JvmtiExport::should_post_monitor_contended_enter()) {\n-      JvmtiExport::post_monitor_contended_enter(current, this);\n-\n-      \/\/ The current thread does not yet own the monitor and does not\n-      \/\/ yet appear on any queues that would get it made the successor.\n-      \/\/ This means that the JVMTI_EVENT_MONITOR_CONTENDED_ENTER event\n-      \/\/ handler cannot accidentally consume an unpark() meant for the\n-      \/\/ ParkEvent associated with this ObjectMonitor.\n-    }\n-\n-    ContinuationEntry* ce = current->last_continuation();\n-    if (ce != nullptr && ce->is_virtual_thread()) {\n-      result = Continuation::try_preempt(current, ce->cont_oop(current));\n-      if (result == freeze_ok) {\n-        bool acquired = VThreadMonitorEnter(current);\n-        if (acquired) {\n-          \/\/ We actually acquired the monitor while trying to add the vthread to the\n-          \/\/ _cxq so cancel preemption. We will still go through the preempt stub\n-          \/\/ but instead of unmounting we will call thaw to continue execution.\n-          current->set_preemption_cancelled(true);\n-          if (JvmtiExport::should_post_monitor_contended_entered()) {\n-            \/\/ We are going to call thaw again after this and finish the VMTS\n-            \/\/ transition so no need to do it here. We will post the event there.\n-            current->set_contended_entered_monitor(this);\n-          }\n+  assert(current->current_pending_monitor() == nullptr, \"invariant\");\n+\n+  ContinuationEntry* ce = current->last_continuation();\n+  bool is_virtual = ce != nullptr && ce->is_virtual_thread();\n+  if (is_virtual) {\n+    notify_contended_enter(current);\n+    result = Continuation::try_preempt(current, ce->cont_oop(current));\n+    if (result == freeze_ok) {\n+      bool acquired = VThreadMonitorEnter(current);\n+      if (acquired) {\n+        \/\/ We actually acquired the monitor while trying to add the vthread to the\n+        \/\/ _cxq so cancel preemption. We will still go through the preempt stub\n+        \/\/ but instead of unmounting we will call thaw to continue execution.\n+        current->set_preemption_cancelled(true);\n+        if (JvmtiExport::should_post_monitor_contended_entered()) {\n+          \/\/ We are going to call thaw again after this and finish the VMTS\n+          \/\/ transition so no need to do it here. We will post the event there.\n+          current->set_contended_entered_monitor(this);\n@@ -528,5 +529,0 @@\n-        current->set_current_pending_monitor(nullptr);\n-        DEBUG_ONLY(int state = java_lang_VirtualThread::state(current->vthread()));\n-        assert((acquired && current->preemption_cancelled() && state == java_lang_VirtualThread::RUNNING) ||\n-               (!acquired && !current->preemption_cancelled() && state == java_lang_VirtualThread::BLOCKING), \"invariant\");\n-        return;\n@@ -534,0 +530,5 @@\n+      current->set_current_pending_monitor(nullptr);\n+      DEBUG_ONLY(int state = java_lang_VirtualThread::state(current->vthread()));\n+      assert((acquired && current->preemption_cancelled() && state == java_lang_VirtualThread::RUNNING) ||\n+             (!acquired && !current->preemption_cancelled() && state == java_lang_VirtualThread::BLOCKING), \"invariant\");\n+      return;\n@@ -535,0 +536,1 @@\n+  }\n@@ -536,0 +538,7 @@\n+  {\n+    \/\/ Change java thread status to indicate blocked on monitor enter.\n+    JavaThreadBlockedOnMonitorEnterState jtbmes(current, this);\n+\n+    if (!is_virtual) { \/\/ already notified contended_enter for virtual\n+      notify_contended_enter(current);\n+    }\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":46,"deletions":37,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -387,0 +387,1 @@\n+  void      notify_contended_enter(JavaThread *current);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}