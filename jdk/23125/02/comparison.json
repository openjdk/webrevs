{"files":[{"patch":"@@ -495,16 +495,10 @@\n-  { \/\/ Change java thread status to indicate blocked on monitor enter.\n-    JavaThreadBlockedOnMonitorEnterState jtbmes(current, this);\n-\n-    assert(current->current_pending_monitor() == nullptr, \"invariant\");\n-    current->set_current_pending_monitor(this);\n-\n-    DTRACE_MONITOR_PROBE(contended__enter, this, object(), current);\n-    if (JvmtiExport::should_post_monitor_contended_enter()) {\n-      JvmtiExport::post_monitor_contended_enter(current, this);\n-\n-      \/\/ The current thread does not yet own the monitor and does not\n-      \/\/ yet appear on any queues that would get it made the successor.\n-      \/\/ This means that the JVMTI_EVENT_MONITOR_CONTENDED_ENTER event\n-      \/\/ handler cannot accidentally consume an unpark() meant for the\n-      \/\/ ParkEvent associated with this ObjectMonitor.\n-    }\n+  DTRACE_MONITOR_PROBE(contended__enter, this, object(), current);\n+  if (JvmtiExport::should_post_monitor_contended_enter()) {\n+    JvmtiExport::post_monitor_contended_enter(current, this);\n+\n+    \/\/ The current thread does not yet own the monitor and does not\n+    \/\/ yet appear on any queues that would get it made the successor.\n+    \/\/ This means that the JVMTI_EVENT_MONITOR_CONTENDED_ENTER event\n+    \/\/ handler cannot accidentally consume an unpark() meant for the\n+    \/\/ ParkEvent associated with this ObjectMonitor.\n+  }\n@@ -512,15 +506,14 @@\n-    ContinuationEntry* ce = current->last_continuation();\n-    if (ce != nullptr && ce->is_virtual_thread()) {\n-      result = Continuation::try_preempt(current, ce->cont_oop(current));\n-      if (result == freeze_ok) {\n-        bool acquired = VThreadMonitorEnter(current);\n-        if (acquired) {\n-          \/\/ We actually acquired the monitor while trying to add the vthread to the\n-          \/\/ _cxq so cancel preemption. We will still go through the preempt stub\n-          \/\/ but instead of unmounting we will call thaw to continue execution.\n-          current->set_preemption_cancelled(true);\n-          if (JvmtiExport::should_post_monitor_contended_entered()) {\n-            \/\/ We are going to call thaw again after this and finish the VMTS\n-            \/\/ transition so no need to do it here. We will post the event there.\n-            current->set_contended_entered_monitor(this);\n-          }\n+  ContinuationEntry* ce = current->last_continuation();\n+  if (ce != nullptr && ce->is_virtual_thread()) {\n+    result = Continuation::try_preempt(current, ce->cont_oop(current));\n+    if (result == freeze_ok) {\n+      bool acquired = VThreadMonitorEnter(current);\n+      if (acquired) {\n+        \/\/ We actually acquired the monitor while trying to add the vthread to the\n+        \/\/ _cxq so cancel preemption. We will still go through the preempt stub\n+        \/\/ but instead of unmounting we will call thaw to continue execution.\n+        current->set_preemption_cancelled(true);\n+        if (JvmtiExport::should_post_monitor_contended_entered()) {\n+          \/\/ We are going to call thaw again after this and finish the VMTS\n+          \/\/ transition so no need to do it here. We will post the event there.\n+          current->set_contended_entered_monitor(this);\n@@ -528,5 +521,0 @@\n-        current->set_current_pending_monitor(nullptr);\n-        DEBUG_ONLY(int state = java_lang_VirtualThread::state(current->vthread()));\n-        assert((acquired && current->preemption_cancelled() && state == java_lang_VirtualThread::RUNNING) ||\n-               (!acquired && !current->preemption_cancelled() && state == java_lang_VirtualThread::BLOCKING), \"invariant\");\n-        return;\n@@ -534,0 +522,5 @@\n+      current->set_current_pending_monitor(nullptr);\n+      DEBUG_ONLY(int state = java_lang_VirtualThread::state(current->vthread()));\n+      assert((acquired && current->preemption_cancelled() && state == java_lang_VirtualThread::RUNNING) ||\n+             (!acquired && !current->preemption_cancelled() && state == java_lang_VirtualThread::BLOCKING), \"invariant\");\n+      return;\n@@ -535,0 +528,8 @@\n+  }\n+\n+  {\n+    \/\/ Change java thread status to indicate blocked on monitor enter.\n+    JavaThreadBlockedOnMonitorEnterState jtbmes(current, this);\n+\n+    assert(current->current_pending_monitor() == nullptr, \"invariant\");\n+    current->set_current_pending_monitor(this);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":37,"deletions":36,"binary":false,"changes":73,"status":"modified"}]}