{"files":[{"patch":"@@ -224,1 +224,1 @@\n-                            currSigAlg + \"signature and \" +\n+                            currSigAlg + \" signature and \" +\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/AlgorithmChecker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,5 @@\n+import java.security.spec.InvalidParameterSpecException;\n+import java.security.spec.PSSParameterSpec;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n@@ -33,0 +38,1 @@\n+import java.util.TreeSet;\n@@ -39,1 +45,1 @@\n- *\n+ * <p>\n@@ -45,0 +51,5 @@\n+    public enum SIGNATURE_CONSTRAINTS_MODE {\n+        PEER,  \/\/ Check against peer supported signatures\n+        LOCAL  \/\/ Check against local supported signatures\n+    }\n+\n@@ -60,1 +71,1 @@\n-                        new SSLAlgorithmConstraints(null, true);\n+            new SSLAlgorithmConstraints(null, true);\n@@ -64,1 +75,1 @@\n-                        new SSLAlgorithmConstraints(null, false);\n+            new SSLAlgorithmConstraints(null, false);\n@@ -66,2 +77,3 @@\n-    private SSLAlgorithmConstraints(AlgorithmConstraints userSpecifiedConstraints,\n-                                    boolean enabledX509DisabledAlgConstraints) {\n+    private SSLAlgorithmConstraints(\n+            AlgorithmConstraints userSpecifiedConstraints,\n+            boolean enabledX509DisabledAlgConstraints) {\n@@ -84,0 +96,1 @@\n+     *\n@@ -87,1 +100,2 @@\n-    static SSLAlgorithmConstraints wrap(AlgorithmConstraints userSpecifiedConstraints) {\n+    static SSLAlgorithmConstraints wrap(\n+            AlgorithmConstraints userSpecifiedConstraints) {\n@@ -105,0 +119,1 @@\n+     *\n@@ -106,0 +121,1 @@\n+     * @param mode SIGNATURE_CONSTRAINTS_MODE\n@@ -108,7 +124,0 @@\n-    static AlgorithmConstraints forSocket(SSLSocket socket,\n-                                          boolean withDefaultCertPathConstraints) {\n-        AlgorithmConstraints userSpecifiedConstraints =\n-                getUserSpecifiedConstraints(socket);\n-        return wrap(userSpecifiedConstraints, withDefaultCertPathConstraints);\n-    }\n-\n@@ -117,1 +126,1 @@\n-            String[] supportedAlgorithms,\n+            SIGNATURE_CONSTRAINTS_MODE mode,\n@@ -119,0 +128,5 @@\n+\n+        if (socket == null) {\n+            return wrap(null, withDefaultCertPathConstraints);\n+        }\n+\n@@ -121,1 +135,2 @@\n-                new SupportedSignatureAlgorithmConstraints(supportedAlgorithms),\n+                new SupportedSignatureAlgorithmConstraints(\n+                        socket.getHandshakeSession(), mode),\n@@ -129,0 +144,1 @@\n+     *\n@@ -130,0 +146,1 @@\n+     * @param mode SIGNATURE_CONSTRAINTS_MODE\n@@ -132,7 +149,0 @@\n-    static AlgorithmConstraints forEngine(SSLEngine engine,\n-                                          boolean withDefaultCertPathConstraints) {\n-        AlgorithmConstraints userSpecifiedConstraints =\n-                getUserSpecifiedConstraints(engine);\n-        return wrap(userSpecifiedConstraints, withDefaultCertPathConstraints);\n-    }\n-\n@@ -141,1 +151,1 @@\n-            String[] supportedAlgorithms,\n+            SIGNATURE_CONSTRAINTS_MODE mode,\n@@ -143,0 +153,5 @@\n+\n+        if (engine == null) {\n+            return wrap(null, withDefaultCertPathConstraints);\n+        }\n+\n@@ -145,1 +160,2 @@\n-                new SupportedSignatureAlgorithmConstraints(supportedAlgorithms),\n+                new SupportedSignatureAlgorithmConstraints(\n+                        engine.getHandshakeSession(), mode),\n@@ -162,1 +178,1 @@\n-                        ((SSLEngineImpl)engine).conContext.handshakeContext;\n+                        ((SSLEngineImpl) engine).conContext.handshakeContext;\n@@ -182,1 +198,1 @@\n-                        ((SSLSocketImpl)socket).conContext.handshakeContext;\n+                        ((SSLSocketImpl) socket).conContext.handshakeContext;\n@@ -282,9 +298,49 @@\n-                                    implements AlgorithmConstraints {\n-        \/\/ supported signature algorithms\n-        private final String[] supportedAlgorithms;\n-\n-        SupportedSignatureAlgorithmConstraints(String[] supportedAlgorithms) {\n-            if (supportedAlgorithms != null) {\n-                this.supportedAlgorithms = supportedAlgorithms.clone();\n-            } else {\n-                this.supportedAlgorithms = null;\n+            implements AlgorithmConstraints {\n+\n+        \/\/ Supported signature algorithms\n+        private Set<String> supportedAlgorithms;\n+        \/\/ Supported signature schemes\n+        private List<SignatureScheme> supportedSignatureSchemes;\n+        private boolean checksDisabled;\n+\n+        SupportedSignatureAlgorithmConstraints(\n+                SSLSession session, SIGNATURE_CONSTRAINTS_MODE mode) {\n+\n+            if (mode == null\n+                    || !(session instanceof ExtendedSSLSession extSession\n+                    \/\/ \"signature_algorithms_cert\" TLS extension is only\n+                    \/\/ available starting with TLSv1.2.\n+                    && ProtocolVersion.useTLS12PlusSpec(\n+                    extSession.getProtocol()))) {\n+\n+                checksDisabled = true;\n+                return;\n+            }\n+\n+            supportedAlgorithms = new TreeSet<>(\n+                    String.CASE_INSENSITIVE_ORDER);\n+\n+            switch (mode) {\n+                case SIGNATURE_CONSTRAINTS_MODE.PEER:\n+                    supportedAlgorithms.addAll(Arrays.asList(extSession\n+                            .getPeerSupportedSignatureAlgorithms()));\n+                    break;\n+                case SIGNATURE_CONSTRAINTS_MODE.LOCAL:\n+                    supportedAlgorithms.addAll(Arrays.asList(extSession\n+                            .getLocalSupportedSignatureAlgorithms()));\n+            }\n+\n+            \/\/ Do additional SignatureSchemes checks for in-house\n+            \/\/ ExtendedSSLSession implementation.\n+            if (extSession instanceof SSLSessionImpl sslSessionImpl) {\n+                switch (mode) {\n+                    case SIGNATURE_CONSTRAINTS_MODE.PEER:\n+                        supportedSignatureSchemes = new ArrayList<>(\n+                                sslSessionImpl\n+                                        .getPeerSupportedSignatureSchemes());\n+                        break;\n+                    case SIGNATURE_CONSTRAINTS_MODE.LOCAL:\n+                        supportedSignatureSchemes = new ArrayList<>(\n+                                sslSessionImpl\n+                                        .getLocalSupportedSignatureSchemes());\n+                }\n@@ -298,0 +354,4 @@\n+            if (checksDisabled) {\n+                return true;\n+            }\n+\n@@ -308,2 +368,1 @@\n-            if (supportedAlgorithms == null ||\n-                        supportedAlgorithms.length == 0) {\n+            if (supportedAlgorithms == null || supportedAlgorithms.isEmpty()) {\n@@ -313,13 +372,1 @@\n-            \/\/ trim the MGF part: <digest>with<encryption>and<mgf>\n-            int position = algorithm.indexOf(\"and\");\n-            if (position > 0) {\n-                algorithm = algorithm.substring(0, position);\n-            }\n-\n-            for (String supportedAlgorithm : supportedAlgorithms) {\n-                if (algorithm.equalsIgnoreCase(supportedAlgorithm)) {\n-                    return true;\n-                }\n-            }\n-\n-            return false;\n+            return supportedAlgorithms.contains(algorithm);\n@@ -342,1 +389,35 @@\n-            return permits(primitives, algorithm, parameters);\n+            return permits(primitives, algorithm, parameters)\n+                    && checkRsaSsaPssParams(algorithm, key, parameters);\n+        }\n+\n+        \/\/ Additional check for RSASSA-PSS signature algorithm parameters.\n+        private boolean checkRsaSsaPssParams(\n+                String algorithm, Key key, AlgorithmParameters parameters) {\n+\n+            if (supportedSignatureSchemes == null\n+                    || key == null\n+                    || parameters == null\n+                    || !\"RSASSA-PSS\".equalsIgnoreCase(algorithm)) {\n+                return true;\n+            }\n+\n+            try {\n+                String keyAlg = key.getAlgorithm();\n+                String paramDigestAlg = parameters.getParameterSpec(\n+                        PSSParameterSpec.class).getDigestAlgorithm();\n+\n+                return supportedSignatureSchemes.stream().anyMatch(ss ->\n+                        ss.algorithm.equalsIgnoreCase(algorithm)\n+                                && ss.keyAlgorithm.equalsIgnoreCase(keyAlg)\n+                                && ((PSSParameterSpec) ss.signAlgParams.parameterSpec)\n+                                .getDigestAlgorithm()\n+                                .equalsIgnoreCase(paramDigestAlg));\n+\n+            } catch (InvalidParameterSpecException e) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                    SSLLogger.warning(\"Invalid AlgorithmParameters: \"\n+                            + parameters + \"; Error: \" + e.getMessage());\n+                }\n+\n+                return true;\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLAlgorithmConstraints.java","additions":132,"deletions":51,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import sun.security.ssl.SSLAlgorithmConstraints.SIGNATURE_CONSTRAINTS_MODE;\n@@ -1452,16 +1453,2 @@\n-            \/\/ try the best to check the algorithm constraints\n-            AlgorithmConstraints constraints;\n-            if (ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {\n-                if (session instanceof ExtendedSSLSession extSession) {\n-                    String[] peerSupportedSignAlgs =\n-                            extSession.getLocalSupportedSignatureAlgorithms();\n-\n-                    constraints = SSLAlgorithmConstraints.forSocket(\n-                                    sslSocket, peerSupportedSignAlgs, true);\n-                } else {\n-                    constraints =\n-                            SSLAlgorithmConstraints.forSocket(sslSocket, true);\n-                }\n-            } else {\n-                constraints = SSLAlgorithmConstraints.forSocket(sslSocket, true);\n-            }\n+            AlgorithmConstraints constraints = SSLAlgorithmConstraints.forSocket(\n+                    sslSocket, SIGNATURE_CONSTRAINTS_MODE.LOCAL, true);\n@@ -1477,0 +1464,1 @@\n+\n@@ -1490,16 +1478,2 @@\n-            \/\/ try the best to check the algorithm constraints\n-            AlgorithmConstraints constraints;\n-            if (ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {\n-                if (session instanceof ExtendedSSLSession extSession) {\n-                    String[] peerSupportedSignAlgs =\n-                            extSession.getLocalSupportedSignatureAlgorithms();\n-\n-                    constraints = SSLAlgorithmConstraints.forEngine(\n-                                    engine, peerSupportedSignAlgs, true);\n-                } else {\n-                    constraints =\n-                            SSLAlgorithmConstraints.forEngine(engine, true);\n-                }\n-            } else {\n-                constraints = SSLAlgorithmConstraints.forEngine(engine, true);\n-            }\n+            AlgorithmConstraints constraints = SSLAlgorithmConstraints.forEngine(\n+                    engine, SIGNATURE_CONSTRAINTS_MODE.LOCAL, true);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLContextImpl.java","additions":7,"deletions":33,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1391,1 +1391,1 @@\n-     * Gets an array of supported signature schemes that the local side is\n+     * Gets a collection of supported signature schemes that the local side is\n@@ -1394,1 +1394,1 @@\n-    public Collection<SignatureScheme> getLocalSupportedSignatureSchemes() {\n+    Collection<SignatureScheme> getLocalSupportedSignatureSchemes() {\n@@ -1407,0 +1407,9 @@\n+    \/**\n+     * Gets a collection of supported signature schemes that the peer is\n+     * willing to verify. Those are sent with the \"signature_algorithms_cert\"\n+     * TLS extension.\n+     *\/\n+    Collection<SignatureScheme> getPeerSupportedSignatureSchemes() {\n+        return peerSupportedSignAlgs;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionImpl.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-    private final String algorithm;     \/\/ signature algorithm\n+    final String algorithm;     \/\/ signature algorithm\n@@ -153,1 +153,1 @@\n-    private final SigAlgParamSpec signAlgParams;    \/\/ signature parameters\n+    final SigAlgParamSpec signAlgParams;    \/\/ signature parameters\n@@ -188,1 +188,1 @@\n-        private final AlgorithmParameterSpec parameterSpec;\n+        final AlgorithmParameterSpec parameterSpec;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SignatureScheme.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-import javax.net.ssl.ExtendedSSLSession;\n@@ -46,1 +45,0 @@\n-import javax.net.ssl.SSLSession;\n@@ -52,0 +50,1 @@\n+import sun.security.ssl.SSLAlgorithmConstraints.SIGNATURE_CONSTRAINTS_MODE;\n@@ -171,13 +170,2 @@\n-            SSLSession session = sslSocket.getHandshakeSession();\n-\n-            if (session instanceof ExtendedSSLSession extSession\n-                    && ProtocolVersion.useTLS12PlusSpec(\n-                    extSession.getProtocol())) {\n-                \/\/ Use peer supported certificate signature algorithms\n-                \/\/ sent with \"signature_algorithms_cert\" TLS extension.\n-                return SSLAlgorithmConstraints.forSocket(sslSocket,\n-                        extSession.getPeerSupportedSignatureAlgorithms(),\n-                        true);\n-            }\n-\n-            return SSLAlgorithmConstraints.forSocket(sslSocket, true);\n+            return SSLAlgorithmConstraints.forSocket(\n+                    sslSocket, SIGNATURE_CONSTRAINTS_MODE.PEER, true);\n@@ -196,15 +184,2 @@\n-        if (engine != null) {\n-            SSLSession session = engine.getHandshakeSession();\n-\n-            if (session instanceof ExtendedSSLSession extSession\n-                    && ProtocolVersion.useTLS12PlusSpec(\n-                    extSession.getProtocol())) {\n-                \/\/ Use peer supported certificate signature algorithms\n-                \/\/ sent with \"signature_algorithms_cert\" TLS extension.\n-                return SSLAlgorithmConstraints.forEngine(engine,\n-                        extSession.getPeerSupportedSignatureAlgorithms(),\n-                        true);\n-            }\n-        }\n-\n-        return SSLAlgorithmConstraints.forEngine(engine, true);\n+        return SSLAlgorithmConstraints.forEngine(\n+                engine, SIGNATURE_CONSTRAINTS_MODE.PEER, true);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/X509KeyManagerCertChecking.java","additions":5,"deletions":30,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+import sun.security.provider.certpath.AlgorithmChecker;\n+import sun.security.ssl.SSLAlgorithmConstraints.SIGNATURE_CONSTRAINTS_MODE;\n@@ -201,2 +203,1 @@\n-        if ((socket != null) && socket.isConnected() &&\n-                (socket instanceof SSLSocket sslSocket)) {\n+        if (socket instanceof SSLSocket sslSocket && sslSocket.isConnected()) {\n@@ -209,14 +210,2 @@\n-            \/\/ create the algorithm constraints\n-            boolean isExtSession = (session instanceof ExtendedSSLSession);\n-            AlgorithmConstraints constraints;\n-            if (isExtSession &&\n-                    ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {\n-                ExtendedSSLSession extSession = (ExtendedSSLSession)session;\n-                String[] localSupportedSignAlgs =\n-                        extSession.getLocalSupportedSignatureAlgorithms();\n-\n-                constraints = SSLAlgorithmConstraints.forSocket(\n-                                sslSocket, localSupportedSignAlgs, false);\n-            } else {\n-                constraints = SSLAlgorithmConstraints.forSocket(sslSocket, false);\n-            }\n+            AlgorithmConstraints constraints = SSLAlgorithmConstraints.forSocket(\n+                    sslSocket, SIGNATURE_CONSTRAINTS_MODE.LOCAL, false);\n@@ -226,1 +215,1 @@\n-            if (!checkClientTrusted && isExtSession) {\n+            if (!checkClientTrusted && session instanceof ExtendedSSLSession) {\n@@ -240,0 +229,2 @@\n+\n+            constraintsCertChainCheck(constraints, trustedChain);\n@@ -258,0 +249,1 @@\n+\n@@ -263,14 +255,2 @@\n-            \/\/ create the algorithm constraints\n-            boolean isExtSession = (session instanceof ExtendedSSLSession);\n-            AlgorithmConstraints constraints;\n-            if (isExtSession &&\n-                    ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {\n-                ExtendedSSLSession extSession = (ExtendedSSLSession)session;\n-                String[] localSupportedSignAlgs =\n-                        extSession.getLocalSupportedSignatureAlgorithms();\n-\n-                constraints = SSLAlgorithmConstraints.forEngine(\n-                                engine, localSupportedSignAlgs, false);\n-            } else {\n-                constraints = SSLAlgorithmConstraints.forEngine(engine, false);\n-            }\n+            AlgorithmConstraints constraints = SSLAlgorithmConstraints.forEngine(\n+                    engine, SIGNATURE_CONSTRAINTS_MODE.LOCAL, false);\n@@ -280,1 +260,1 @@\n-            if (!checkClientTrusted && isExtSession) {\n+            if (!checkClientTrusted && session instanceof ExtendedSSLSession) {\n@@ -294,0 +274,2 @@\n+\n+            constraintsCertChainCheck(constraints, trustedChain);\n@@ -478,0 +460,29 @@\n+\n+    \/\/ Additional certificate chain check to verify that the algorithm\n+    \/\/ constraints permit the signature algorithms to be used with the\n+    \/\/ corresponding signing keys.\n+    \/\/ This method is important to differentiate between \"rsa_pss_pss_*\"\n+    \/\/ and \"rsa_pss_rsae_*\" signature schemes in SSLAlgorithmConstraints.\n+    \/\/ We make AlgorithmChecker to perform a check against signature\n+    \/\/ algorithms with the corresponding signing keys on the first iteration\n+    \/\/ by setting a Trust Anchor.\n+    private void constraintsCertChainCheck(\n+            AlgorithmConstraints constraints, X509Certificate[] chain)\n+            throws CertificateException {\n+\n+        \/\/ Omit checks if EE cert is also a trust anchor\n+        if (chain.length > 1) {\n+            AlgorithmChecker checker = new AlgorithmChecker(\n+                    new TrustAnchor(chain[chain.length - 1], null),\n+                    constraints, null, null);\n+            try {\n+                checker.init(false);\n+\n+                for (int i = chain.length - 2; i >= 0; i--) {\n+                    checker.check(chain[i], Collections.emptySet());\n+                }\n+            } catch (CertPathValidatorException e) {\n+                throw new CertificateException(e);\n+            }\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/X509TrustManagerImpl.java","additions":44,"deletions":33,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -0,0 +1,274 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertTrue;\n+import static jdk.test.lib.Utils.runAndCheckException;\n+\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.KeyStore;\n+import java.security.PrivateKey;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.Security;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Date;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLHandshakeException;\n+import javax.net.ssl.TrustManagerFactory;\n+import jdk.test.lib.security.CertificateBuilder;\n+import sun.security.x509.AuthorityKeyIdentifierExtension;\n+import sun.security.x509.GeneralName;\n+import sun.security.x509.GeneralNames;\n+import sun.security.x509.KeyIdentifier;\n+import sun.security.x509.SerialNumber;\n+import sun.security.x509.X500Name;\n+\n+\n+\/*\n+ * @test\n+ * @bug 8367104\n+ * @summary Check for RSASSA-PSS parameters when validating certificates\n+ *          against algorithm constraints.\n+ * @modules java.base\/sun.security.x509\n+ *          java.base\/sun.security.util\n+ * @library \/javax\/net\/ssl\/templates\n+ *          \/test\/lib\n+ * @run main\/othervm RsaSsaPssConstraints RSASSA-PSS RSASSA-PSS Rsa_pss_pss_Sha384 true\n+ * @run main\/othervm RsaSsaPssConstraints RSASSA-PSS RSASSA-PSS RsaSsa-Pss true\n+ * @run main\/othervm RsaSsaPssConstraints RSA RSASSA-PSS rsa_pss_Rsae_sha384 true\n+ * @run main\/othervm RsaSsaPssConstraints RSA RSASSA-PSS Rsa true\n+ * @run main\/othervm RsaSsaPssConstraints RSA RSASSA-PSS RSASSA-pSS true\n+ * @run main\/othervm RsaSsaPssConstraints RSA SHA384withRSA rsa_pkcs1_Sha384 true\n+ * @run main\/othervm RsaSsaPssConstraints EC SHA384withECDSA Ecdsa_Secp384r1_sha384 true\n+ * @run main\/othervm RsaSsaPssConstraints RSA SHA384withRSA SHA384withRsA true\n+ * @run main\/othervm RsaSsaPssConstraints RSASSA-PSS RSASSA-PSS rsa_pss_rsae_sha384 false\n+ * @run main\/othervm RsaSsaPssConstraints RSA RSASSA-PSS rsa_pss_pss_sha384 false\n+ * @run main\/othervm RsaSsaPssConstraints RSASSA-PSS RSASSA-PSS rsa_pss_pss_sha256 false\n+ * @run main\/othervm RsaSsaPssConstraints RSASSA-PSS RSASSA-PSS rsa_pss_pss_sha512 false\n+ * @run main\/othervm RsaSsaPssConstraints RSASSA-PSS RSASSA-PSS RSA false\n+ * @run main\/othervm RsaSsaPssConstraints RSA RSASSA-PSS rsa_pss_rsae_sha512 false\n+ * @run main\/othervm RsaSsaPssConstraints RSA SHA384withRSA rsa_pkcs1_sha256 false\n+ * @run main\/othervm RsaSsaPssConstraints EC SHA384withECDSA ecdsa_secp256r1_sha256 false\n+ * @run main\/othervm RsaSsaPssConstraints EC SHA384withECDSA SHA512withECDSA false\n+ *\/\n+\n+public class RsaSsaPssConstraints extends SSLSocketTemplate {\n+\n+    private final String protocol;\n+    private final String keyAlg;\n+    private final String certSigAlg;\n+    private X509Certificate trustedCert;\n+    private X509Certificate serverCert;\n+    private X509Certificate clientCert;\n+    private KeyPair serverKeys;\n+    private KeyPair clientKeys;\n+\n+    protected RsaSsaPssConstraints(\n+            String protocol, String keyAlg,\n+            String certSigAlg) throws Exception {\n+        super();\n+        this.protocol = protocol;\n+        this.keyAlg = keyAlg;\n+        this.certSigAlg = certSigAlg;\n+        setupCertificates();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 4) {\n+            throw new RuntimeException(\"Wrong number of arguments\");\n+        }\n+\n+        String keyAlg = args[0];\n+        String certSigAlg = args[1];\n+        String constraintAlgo = args[2];\n+        boolean fail = Boolean.parseBoolean(args[3]);\n+\n+        \/\/ Note: CertificateBuilder generates RSASSA-PSS certificate\n+        \/\/ signature using SHA-384 digest algorithm by default.\n+        Security.setProperty(\"jdk.tls.disabledAlgorithms\",\n+                constraintAlgo + \" usage CertificateSignature\");\n+\n+        for (String protocol : new String[]{\"TLSv1.3\", \"TLSv1.2\"}) {\n+            var test = new RsaSsaPssConstraints(protocol, keyAlg, certSigAlg);\n+\n+            final String errorMsg = protocol.equals(\"TLSv1.2\") ?\n+                    \"no cipher suites in common\" :\n+                    \"No available authentication scheme\";\n+\n+            if (fail) {\n+                runAndCheckException(test::run,\n+                        serverEx -> {\n+                            assertTrue(\n+                                    serverEx instanceof SSLHandshakeException);\n+                            assertEquals(serverEx.getMessage(),\n+                                    \"(handshake_failure) \" + errorMsg);\n+                        });\n+            } else {\n+                test.run();\n+            }\n+        }\n+\n+        \/\/ Disable KeyManager's algorithm constraints checking and\n+        \/\/ check against TrustManager's local supported signature\n+        \/\/ algorithms on the client side.\n+        System.setProperty(\n+                \"jdk.tls.SunX509KeyManager.certChecking\", \"false\");\n+\n+        for (String protocol : new String[]{\"TLSv1.3\", \"TLSv1.2\"}) {\n+            var test = new RsaSsaPssConstraints(protocol, keyAlg, certSigAlg);\n+\n+            if (fail) {\n+                runAndCheckException(test::run,\n+                        serverEx -> {\n+                            Throwable clientEx = serverEx.getSuppressed()[0];\n+                            assertTrue(\n+                                    clientEx instanceof SSLHandshakeException);\n+                        });\n+            } else {\n+                test.run();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public SSLContext createServerSSLContext() throws Exception {\n+        return getSSLContext(\n+                trustedCert, serverCert, serverKeys.getPrivate(), protocol);\n+    }\n+\n+    @Override\n+    public SSLContext createClientSSLContext() throws Exception {\n+        return getSSLContext(\n+                trustedCert, clientCert, clientKeys.getPrivate(), protocol);\n+    }\n+\n+    private static SSLContext getSSLContext(\n+            X509Certificate trustedCertificate, X509Certificate keyCertificate,\n+            PrivateKey privateKey, String protocol)\n+            throws Exception {\n+\n+        \/\/ create a key store\n+        KeyStore ks = KeyStore.getInstance(\"PKCS12\");\n+        ks.load(null, null);\n+\n+        \/\/ import the trusted cert\n+        ks.setCertificateEntry(\"TLS Signer\", trustedCertificate);\n+\n+        \/\/ generate certificate chain\n+        Certificate[] chain = new Certificate[2];\n+        chain[0] = keyCertificate;\n+        chain[1] = trustedCertificate;\n+\n+        \/\/ import the key entry.\n+        final char[] passphrase = \"passphrase\".toCharArray();\n+        ks.setKeyEntry(\"Whatever\", privateKey, passphrase, chain);\n+\n+        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"PKIX\");\n+        tmf.init(ks);\n+\n+        \/\/ create SSL context\n+        SSLContext ctx = SSLContext.getInstance(protocol);\n+\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n+        kmf.init(ks, passphrase);\n+\n+        ctx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n+\n+        return ctx;\n+    }\n+\n+    \/\/ Certificate-building helper methods.\n+\n+    private void setupCertificates() throws Exception {\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(keyAlg);\n+        KeyPair caKeys = kpg.generateKeyPair();\n+        this.serverKeys = kpg.generateKeyPair();\n+        this.clientKeys = kpg.generateKeyPair();\n+\n+        this.trustedCert = createTrustedCert(caKeys, certSigAlg);\n+\n+        this.serverCert = customCertificateBuilder(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                serverKeys.getPublic(), caKeys.getPublic())\n+                .addBasicConstraintsExt(false, false, -1)\n+                .build(trustedCert, caKeys.getPrivate(), certSigAlg);\n+\n+        this.clientCert = customCertificateBuilder(\n+                \"CN=localhost, OU=SSL-Client, O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                clientKeys.getPublic(), caKeys.getPublic())\n+                .addBasicConstraintsExt(false, false, -1)\n+                .build(trustedCert, caKeys.getPrivate(), certSigAlg);\n+    }\n+\n+    private static X509Certificate createTrustedCert(\n+            KeyPair caKeys, String certSigAlg)\n+            throws Exception {\n+        SecureRandom random = new SecureRandom();\n+\n+        KeyIdentifier kid = new KeyIdentifier(caKeys.getPublic());\n+        GeneralNames gns = new GeneralNames();\n+        GeneralName name = new GeneralName(new X500Name(\n+                \"O=Trusted-Org, L=Some-City, ST=Some-State, C=US\"));\n+        gns.add(name);\n+        BigInteger serialNumber = BigInteger.valueOf(\n+                random.nextLong(1000000) + 1);\n+        return customCertificateBuilder(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                caKeys.getPublic(), caKeys.getPublic())\n+                .setSerialNumber(serialNumber)\n+                .addExtension(new AuthorityKeyIdentifierExtension(kid, gns,\n+                        new SerialNumber(serialNumber)))\n+                .addBasicConstraintsExt(true, true, -1)\n+                .build(null, caKeys.getPrivate(), certSigAlg);\n+    }\n+\n+    private static CertificateBuilder customCertificateBuilder(\n+            String subjectName, PublicKey publicKey, PublicKey caKey)\n+            throws CertificateException, IOException {\n+        SecureRandom random = new SecureRandom();\n+\n+        CertificateBuilder builder = new CertificateBuilder()\n+                .setSubjectName(subjectName)\n+                .setPublicKey(publicKey)\n+                .setNotBefore(\n+                        Date.from(Instant.now().minus(1, ChronoUnit.HOURS)))\n+                .setNotAfter(Date.from(Instant.now().plus(1, ChronoUnit.HOURS)))\n+                .setSerialNumber(\n+                        BigInteger.valueOf(random.nextLong(1000000) + 1))\n+                .addSubjectKeyIdExt(publicKey)\n+                .addAuthorityKeyIdExt(caKey);\n+        builder.addKeyUsageExt(\n+                new boolean[]{true, true, true, true, true, true});\n+\n+        return builder;\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/RsaSsaPssConstraints.java","additions":274,"deletions":0,"binary":false,"changes":274,"status":"added"}]}