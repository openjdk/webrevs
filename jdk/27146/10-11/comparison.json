{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -264,1 +264,0 @@\n-        X500Principal subject = last.getSubjectX500Principal();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/validator\/PKIXValidator.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,277 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertTrue;\n+import static jdk.test.lib.Utils.runAndCheckException;\n+\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.KeyStore;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.Security;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Date;\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509ExtendedTrustManager;\n+import jdk.test.lib.security.CertificateBuilder;\n+import sun.security.validator.ValidatorException;\n+import sun.security.x509.AuthorityKeyIdentifierExtension;\n+import sun.security.x509.GeneralName;\n+import sun.security.x509.GeneralNames;\n+import sun.security.x509.KeyIdentifier;\n+import sun.security.x509.SerialNumber;\n+import sun.security.x509.X500Name;\n+\n+\/*\n+ * @test\n+ * @bug 8367104\n+ * @summary Check for RSASSA-PSS parameters when validating certificates\n+ *          against algorithm constraints.\n+ * @modules java.base\/sun.security.x509\n+ *          java.base\/sun.security.util\n+ *          java.base\/sun.security.validator\n+ * @library \/javax\/net\/ssl\/templates\n+ *          \/test\/lib\n+ * @run main\/othervm CertChainAlgorithmConstraints RSASSA-PSS RSASSA-PSS Rsa_pss_pss_Sha384 true\n+ * @run main\/othervm CertChainAlgorithmConstraints RSASSA-PSS RSASSA-PSS RsaSsa-Pss true\n+ * @run main\/othervm CertChainAlgorithmConstraints RSA RSASSA-PSS rsa_pss_Rsae_sha384 true\n+ * @run main\/othervm CertChainAlgorithmConstraints RSA RSASSA-PSS Rsa true\n+ * @run main\/othervm CertChainAlgorithmConstraints RSA RSASSA-PSS RSASSA-pSS true\n+ * @run main\/othervm CertChainAlgorithmConstraints RSA SHA384withRSA rsa_pkcs1_Sha384 true\n+ * @run main\/othervm CertChainAlgorithmConstraints EC SHA384withECDSA Ecdsa_Secp384r1_sha384 true\n+ * @run main\/othervm CertChainAlgorithmConstraints RSA SHA384withRSA SHA384withRsA true\n+ * @run main\/othervm CertChainAlgorithmConstraints RSASSA-PSS RSASSA-PSS rsa_pss_rsae_sha384 false\n+ * @run main\/othervm CertChainAlgorithmConstraints RSA RSASSA-PSS rsa_pss_pss_sha384 false\n+ * @run main\/othervm CertChainAlgorithmConstraints RSASSA-PSS RSASSA-PSS rsa_pss_pss_sha256 false\n+ * @run main\/othervm CertChainAlgorithmConstraints RSASSA-PSS RSASSA-PSS rsa_pss_pss_sha512 false\n+ * @run main\/othervm CertChainAlgorithmConstraints RSASSA-PSS RSASSA-PSS RSA false\n+ * @run main\/othervm CertChainAlgorithmConstraints RSA RSASSA-PSS rsa_pss_rsae_sha512 false\n+ * @run main\/othervm CertChainAlgorithmConstraints RSA SHA384withRSA rsa_pkcs1_sha256 false\n+ * @run main\/othervm CertChainAlgorithmConstraints EC SHA384withECDSA ecdsa_secp256r1_sha256 false\n+ * @run main\/othervm CertChainAlgorithmConstraints EC SHA384withECDSA SHA512withECDSA false\n+ *\/\n+\n+\/\/ Testing that an algorithm can be disabled with both a PKIXCertPathValidator\n+\/\/ and a CertPathBuilder code paths. It is somewhat common for JSSE to fall\n+\/\/ back to using a CertPathBuilder to find a valid chain.\n+public class CertChainAlgorithmConstraints extends SSLEngineTemplate {\n+\n+    private final String keyAlg;\n+    private final String certSigAlg;\n+    private final boolean fail;\n+\n+    private X509Certificate trustedCert;\n+    private X509Certificate serverCert;\n+    private X509Certificate linkCert1;\n+    private X509Certificate linkCert2;\n+\n+    protected CertChainAlgorithmConstraints(\n+            String keyAlg, String certSigAlg, boolean fail)\n+            throws Exception {\n+        super();\n+        this.keyAlg = keyAlg;\n+        this.certSigAlg = certSigAlg;\n+        this.fail = fail;\n+        setupCertificates();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 4) {\n+            throw new RuntimeException(\"Wrong number of arguments\");\n+        }\n+\n+        String keyAlg = args[0];\n+        String certSigAlg = args[1];\n+        String constraintAlgo = args[2];\n+        boolean fail = Boolean.parseBoolean(args[3]);\n+\n+        \/\/ Note: CertificateBuilder generates RSASSA-PSS certificate\n+        \/\/ signature using SHA-384 digest algorithm by default.\n+        Security.setProperty(\"jdk.tls.disabledAlgorithms\",\n+                constraintAlgo + \" usage CertificateSignature\");\n+\n+        new CertChainAlgorithmConstraints(keyAlg, certSigAlg, fail).run();\n+    }\n+\n+    \/\/ Run things in TLS handshake order.\n+    protected void run() throws Exception {\n+\n+        \/\/ Produce client_hello\n+        clientEngine.wrap(clientOut, cTOs);\n+        cTOs.flip();\n+\n+        \/\/ Consume client_hello.\n+        serverEngine.unwrap(cTOs, serverIn);\n+        runDelegatedTasks(serverEngine);\n+\n+        \/\/ Produce server_hello.\n+        serverEngine.wrap(serverOut, sTOc);\n+        sTOc.flip();\n+\n+        \/\/ Now that we have a Handshake session attached to the serverEngine,\n+        \/\/ do the check.\n+        checkChain(serverEngine);\n+    }\n+\n+    protected void checkChain(SSLEngine engine) throws Exception {\n+\n+        \/\/ Create a key store.\n+        KeyStore ks = KeyStore.getInstance(\"PKCS12\");\n+        ks.load(null, null);\n+\n+        \/\/ Import the trusted cert.\n+        ks.setCertificateEntry(\"Trusted\", trustedCert);\n+\n+        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"PKIX\");\n+        \/\/ Init TrustManager with a Key Store.\n+        tmf.init(ks);\n+\n+        \/\/ Generate a mixed-up certificate chain.\n+        X509Certificate[] mixedUpChain = new X509Certificate[3];\n+        mixedUpChain[0] = linkCert2;\n+        \/\/ Put EE cert between 2 link certs to mix up the chain.\n+        mixedUpChain[1] = serverCert;\n+        mixedUpChain[2] = linkCert1;\n+\n+        \/\/ Generate a valid certificate chain - we should get the same\n+        \/\/ results with it but a different code path to be used.\n+        X509Certificate[] validChain = new X509Certificate[3];\n+        validChain[0] = serverCert;\n+        validChain[1] = linkCert2;\n+        validChain[2] = linkCert1;\n+\n+        var tm = ((X509ExtendedTrustManager) tmf.getTrustManagers()[0]);\n+\n+        if (fail) {\n+            \/\/ Mixed-up chain: CertPathBuilder code path.\n+            runAndCheckException(\n+                    () -> tm.checkServerTrusted(mixedUpChain, \"RSA\", engine),\n+                    ex -> {\n+                        assertTrue(ex instanceof ValidatorException);\n+                        assertEquals(ex.getMessage(),\n+                                \"PKIX path building failed: \"\n+                                        + \"sun.security.provider.certpath.\"\n+                                        + \"SunCertPathBuilderException: unable to find \"\n+                                        + \"valid certification path to requested target\");\n+                    });\n+\n+            \/\/ Valid chain: PKIXCertPathValidator code path.\n+            runAndCheckException(\n+                    () -> tm.checkServerTrusted(validChain, \"RSA\", engine),\n+                    ex -> {\n+                        assertTrue(ex instanceof ValidatorException);\n+                        assertTrue(ex.getMessage().startsWith(\"PKIX path \"\n+                                + \"validation failed: java.security.cert.\"\n+                                + \"CertPathValidatorException: Algorithm \"\n+                                + \"constraints check failed on \"\n+                                + certSigAlg + \" signature and \"\n+                                + keyAlg + \" key\"));\n+                    });\n+        } else {\n+            tm.checkServerTrusted(mixedUpChain, \"RSA\", engine);\n+            tm.checkServerTrusted(validChain, \"RSA\", engine);\n+        }\n+    }\n+\n+    \/\/ Certificate-building helper methods.\n+\n+    private void setupCertificates() throws Exception {\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(keyAlg);\n+        var caKeys = kpg.generateKeyPair();\n+        var serverKeys = kpg.generateKeyPair();\n+        var linkKeys1 = kpg.generateKeyPair();\n+        var linkKeys2 = kpg.generateKeyPair();\n+\n+        this.trustedCert = createTrustedCert(caKeys, certSigAlg);\n+\n+        this.linkCert1 = customCertificateBuilder(\n+                \"O=Link1, L=Some-City, ST=Some-State, C=US\",\n+                linkKeys1.getPublic(), caKeys.getPublic())\n+                .addBasicConstraintsExt(true, true, -1)\n+                .build(trustedCert, caKeys.getPrivate(), certSigAlg);\n+\n+        this.linkCert2 = customCertificateBuilder(\n+                \"O=Link2, L=Some-City, ST=Some-State, C=US\",\n+                linkKeys2.getPublic(), linkKeys1.getPublic())\n+                .addBasicConstraintsExt(true, true, -1)\n+                .build(linkCert1, linkKeys1.getPrivate(), certSigAlg);\n+\n+        this.serverCert = customCertificateBuilder(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                serverKeys.getPublic(), linkKeys2.getPublic())\n+                .addBasicConstraintsExt(false, false, -1)\n+                .build(linkCert2, linkKeys2.getPrivate(),\n+                        certSigAlg);\n+    }\n+\n+    private static X509Certificate createTrustedCert(\n+            KeyPair caKeys, String certSigAlg)\n+            throws Exception {\n+        SecureRandom random = new SecureRandom();\n+\n+        KeyIdentifier kid = new KeyIdentifier(caKeys.getPublic());\n+        GeneralNames gns = new GeneralNames();\n+        GeneralName name = new GeneralName(new X500Name(\n+                \"O=Trusted-Org, L=Some-City, ST=Some-State, C=US\"));\n+        gns.add(name);\n+        BigInteger serialNumber = BigInteger.valueOf(\n+                random.nextLong(1000000) + 1);\n+        return customCertificateBuilder(\n+                name.toString(),\n+                caKeys.getPublic(), caKeys.getPublic())\n+                .setSerialNumber(serialNumber)\n+                .addExtension(new AuthorityKeyIdentifierExtension(kid, gns,\n+                        new SerialNumber(serialNumber)))\n+                .addBasicConstraintsExt(true, true, -1)\n+                .build(null, caKeys.getPrivate(), certSigAlg);\n+    }\n+\n+    private static CertificateBuilder customCertificateBuilder(\n+            String subjectName, PublicKey publicKey, PublicKey caKey)\n+            throws CertificateException, IOException {\n+        SecureRandom random = new SecureRandom();\n+\n+        CertificateBuilder builder = new CertificateBuilder()\n+                .setSubjectName(subjectName)\n+                .setPublicKey(publicKey)\n+                .setNotBefore(\n+                        Date.from(Instant.now().minus(1, ChronoUnit.HOURS)))\n+                .setNotAfter(Date.from(Instant.now().plus(1, ChronoUnit.HOURS)))\n+                .setSerialNumber(\n+                        BigInteger.valueOf(random.nextLong(1000000) + 1))\n+                .addSubjectKeyIdExt(publicKey)\n+                .addAuthorityKeyIdExt(caKey);\n+        builder.addKeyUsageExt(\n+                new boolean[]{true, true, true, true, true, true});\n+\n+        return builder;\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/CertChainAlgorithmConstraints.java","additions":277,"deletions":0,"binary":false,"changes":277,"status":"added"}]}