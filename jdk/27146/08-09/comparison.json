{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -215,0 +215,5 @@\n+\n+            \/\/ Set trust anchor for the user-specified AlgorithmChecker.\n+            if (checker instanceof AlgorithmChecker algChecker) {\n+                algChecker.trySetTrustAnchor(anchor);\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/PKIXCertPathValidator.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -229,2 +229,0 @@\n-\n-            constraintsCertChainCheck(constraints, trustedChain);\n@@ -274,2 +272,0 @@\n-\n-            constraintsCertChainCheck(constraints, trustedChain);\n@@ -460,29 +456,0 @@\n-\n-    \/\/ Additional certificate chain check to verify that the algorithm\n-    \/\/ constraints permit the signature algorithms to be used with the\n-    \/\/ corresponding signing keys.\n-    \/\/ This method is important to differentiate between \"rsa_pss_pss_*\"\n-    \/\/ and \"rsa_pss_rsae_*\" signature schemes in SSLAlgorithmConstraints.\n-    \/\/ We make AlgorithmChecker to perform a check against signature\n-    \/\/ algorithms with the corresponding signing keys on the first iteration\n-    \/\/ by setting a Trust Anchor.\n-    private void constraintsCertChainCheck(\n-            AlgorithmConstraints constraints, X509Certificate[] chain)\n-            throws CertificateException {\n-\n-        \/\/ Omit checks if EE cert is also a trust anchor\n-        if (chain.length > 1) {\n-            AlgorithmChecker checker = new AlgorithmChecker(\n-                    new TrustAnchor(chain[chain.length - 1], null),\n-                    constraints, null, null);\n-            try {\n-                checker.init(false);\n-\n-                for (int i = chain.length - 2; i >= 0; i--) {\n-                    checker.check(chain[i], Collections.emptySet());\n-                }\n-            } catch (CertPathValidatorException e) {\n-                throw new CertificateException(e);\n-            }\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/X509TrustManagerImpl.java","additions":0,"deletions":33,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import static jdk.test.lib.Asserts.assertEquals;\n@@ -102,5 +101,6 @@\n-                    assertEquals(clientEx.getMessage(), \"(bad_certificate) \"\n-                            + \"PKIX path validation failed: \"\n-                            + \"java.security.cert.CertPathValidatorException: \"\n-                            + \"Algorithm constraints check failed on signature\"\n-                            + \" algorithm: MD5withRSA\");\n+                    assertTrue(clientEx.getMessage().startsWith(\n+                            \"(bad_certificate)\"\n+                                    + \" PKIX path validation failed: \"\n+                                    + \"java.security.cert.CertPathValidatorException:\"\n+                                    + \" Algorithm constraints check failed on \"\n+                                    + \"MD5withRSA signature and RSA key\"));\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/MD5NotAllowedInTLS13CertificateSignature.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -153,2 +153,2 @@\n-                            assertTrue(\n-                                    clientEx instanceof SSLHandshakeException);\n+                            assertTrue(clientEx instanceof SSLHandshakeException\n+                                    || serverEx instanceof SSLHandshakeException);\n@@ -245,1 +245,1 @@\n-                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                name.toString(),\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/RsaSsaPssConstraints.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}