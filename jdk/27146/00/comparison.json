{"files":[{"patch":"@@ -224,1 +224,1 @@\n-                            currSigAlg + \"signature and \" +\n+                            currSigAlg + \" signature and \" +\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/AlgorithmChecker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,5 @@\n+import java.security.spec.InvalidParameterSpecException;\n+import java.security.spec.PSSParameterSpec;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n@@ -33,0 +38,1 @@\n+import java.util.TreeSet;\n@@ -45,0 +51,6 @@\n+    public enum SIGNATURE_CONSTRAINTS_MODE {\n+        NONE,  \/\/ Don't check against any supported signatures\n+        PEER,  \/\/ Check against peer supported signatures\n+        LOCAL  \/\/ Check against local supported signatures\n+    }\n+\n@@ -60,1 +72,1 @@\n-                        new SSLAlgorithmConstraints(null, true);\n+            new SSLAlgorithmConstraints(null, true);\n@@ -64,1 +76,1 @@\n-                        new SSLAlgorithmConstraints(null, false);\n+            new SSLAlgorithmConstraints(null, false);\n@@ -66,2 +78,3 @@\n-    private SSLAlgorithmConstraints(AlgorithmConstraints userSpecifiedConstraints,\n-                                    boolean enabledX509DisabledAlgConstraints) {\n+    private SSLAlgorithmConstraints(\n+            AlgorithmConstraints userSpecifiedConstraints,\n+            boolean enabledX509DisabledAlgConstraints) {\n@@ -84,0 +97,1 @@\n+     *\n@@ -87,1 +101,2 @@\n-    static SSLAlgorithmConstraints wrap(AlgorithmConstraints userSpecifiedConstraints) {\n+    static SSLAlgorithmConstraints wrap(\n+            AlgorithmConstraints userSpecifiedConstraints) {\n@@ -105,0 +120,1 @@\n+     *\n@@ -106,0 +122,1 @@\n+     * @param mode SIGNATURE_CONSTRAINTS_MODE\n@@ -108,7 +125,0 @@\n-    static AlgorithmConstraints forSocket(SSLSocket socket,\n-                                          boolean withDefaultCertPathConstraints) {\n-        AlgorithmConstraints userSpecifiedConstraints =\n-                getUserSpecifiedConstraints(socket);\n-        return wrap(userSpecifiedConstraints, withDefaultCertPathConstraints);\n-    }\n-\n@@ -117,1 +127,1 @@\n-            String[] supportedAlgorithms,\n+            SIGNATURE_CONSTRAINTS_MODE mode,\n@@ -119,0 +129,5 @@\n+\n+        if (socket == null) {\n+            return wrap(null, withDefaultCertPathConstraints);\n+        }\n+\n@@ -121,1 +136,2 @@\n-                new SupportedSignatureAlgorithmConstraints(supportedAlgorithms),\n+                new SupportedSignatureAlgorithmConstraints(\n+                        socket.getHandshakeSession(), mode),\n@@ -129,0 +145,1 @@\n+     *\n@@ -130,0 +147,1 @@\n+     * @param mode SIGNATURE_CONSTRAINTS_MODE\n@@ -132,7 +150,0 @@\n-    static AlgorithmConstraints forEngine(SSLEngine engine,\n-                                          boolean withDefaultCertPathConstraints) {\n-        AlgorithmConstraints userSpecifiedConstraints =\n-                getUserSpecifiedConstraints(engine);\n-        return wrap(userSpecifiedConstraints, withDefaultCertPathConstraints);\n-    }\n-\n@@ -141,1 +152,1 @@\n-            String[] supportedAlgorithms,\n+            SIGNATURE_CONSTRAINTS_MODE mode,\n@@ -143,0 +154,5 @@\n+\n+        if (engine == null) {\n+            return wrap(null, withDefaultCertPathConstraints);\n+        }\n+\n@@ -145,1 +161,2 @@\n-                new SupportedSignatureAlgorithmConstraints(supportedAlgorithms),\n+                new SupportedSignatureAlgorithmConstraints(\n+                        engine.getHandshakeSession(), mode),\n@@ -162,1 +179,1 @@\n-                        ((SSLEngineImpl)engine).conContext.handshakeContext;\n+                        ((SSLEngineImpl) engine).conContext.handshakeContext;\n@@ -182,1 +199,1 @@\n-                        ((SSLSocketImpl)socket).conContext.handshakeContext;\n+                        ((SSLSocketImpl) socket).conContext.handshakeContext;\n@@ -282,9 +299,52 @@\n-                                    implements AlgorithmConstraints {\n-        \/\/ supported signature algorithms\n-        private final String[] supportedAlgorithms;\n-\n-        SupportedSignatureAlgorithmConstraints(String[] supportedAlgorithms) {\n-            if (supportedAlgorithms != null) {\n-                this.supportedAlgorithms = supportedAlgorithms.clone();\n-            } else {\n-                this.supportedAlgorithms = null;\n+            implements AlgorithmConstraints {\n+\n+        \/\/ Supported signature algorithms\n+        private Set<String> supportedAlgorithms;\n+        \/\/ Supported signature schemes\n+        private List<SignatureScheme> supportedSignatureSchemes;\n+        private boolean checksDisabled;\n+\n+        SupportedSignatureAlgorithmConstraints(\n+                SSLSession session, SIGNATURE_CONSTRAINTS_MODE mode) {\n+            supportedAlgorithms = null;\n+            supportedSignatureSchemes = null;\n+            checksDisabled = false;\n+\n+            if (SIGNATURE_CONSTRAINTS_MODE.NONE.equals(mode)\n+                    || !(session instanceof ExtendedSSLSession extSession\n+                    \/\/ \"signature_algorithms_cert\" TLS extension is only\n+                    \/\/ available starting with TLSv1.2.\n+                    && ProtocolVersion.useTLS12PlusSpec(\n+                    extSession.getProtocol()))) {\n+\n+                checksDisabled = true;\n+                return;\n+            }\n+\n+            supportedAlgorithms = new TreeSet<>(\n+                    String.CASE_INSENSITIVE_ORDER);\n+\n+            switch (mode) {\n+                case SIGNATURE_CONSTRAINTS_MODE.PEER:\n+                    supportedAlgorithms.addAll(Arrays.asList(extSession\n+                            .getPeerSupportedSignatureAlgorithms()));\n+                    break;\n+                case SIGNATURE_CONSTRAINTS_MODE.LOCAL:\n+                    supportedAlgorithms.addAll(Arrays.asList(extSession\n+                            .getLocalSupportedSignatureAlgorithms()));\n+            }\n+\n+            \/\/ Do additional SignatureSchemes checks for in-house\n+            \/\/ ExtendedSSLSession implementation.\n+            if (extSession instanceof SSLSessionImpl sslSessionImpl) {\n+                switch (mode) {\n+                    case SIGNATURE_CONSTRAINTS_MODE.PEER:\n+                        supportedSignatureSchemes = new ArrayList<>(\n+                                sslSessionImpl\n+                                        .getPeerSupportedSignatureSchemes());\n+                        break;\n+                    case SIGNATURE_CONSTRAINTS_MODE.LOCAL:\n+                        supportedSignatureSchemes = new ArrayList<>(\n+                                sslSessionImpl\n+                                        .getLocalSupportedSignatureSchemes());\n+                }\n@@ -298,0 +358,4 @@\n+            if (checksDisabled) {\n+                return true;\n+            }\n+\n@@ -308,2 +372,1 @@\n-            if (supportedAlgorithms == null ||\n-                        supportedAlgorithms.length == 0) {\n+            if (supportedAlgorithms == null || supportedAlgorithms.isEmpty()) {\n@@ -313,13 +376,2 @@\n-            \/\/ trim the MGF part: <digest>with<encryption>and<mgf>\n-            int position = algorithm.indexOf(\"and\");\n-            if (position > 0) {\n-                algorithm = algorithm.substring(0, position);\n-            }\n-\n-            for (String supportedAlgorithm : supportedAlgorithms) {\n-                if (algorithm.equalsIgnoreCase(supportedAlgorithm)) {\n-                    return true;\n-                }\n-            }\n-\n-            return false;\n+            return supportedAlgorithms.contains(algorithm)\n+                    && checkRsaSsaPssParams(algorithm, parameters);\n@@ -344,0 +396,29 @@\n+\n+\n+        \/\/ Additional check for RSASSA-PSS algorithm parameters.\n+        private boolean checkRsaSsaPssParams(\n+                String algorithm, AlgorithmParameters parameters) {\n+\n+            if (supportedSignatureSchemes == null\n+                    || parameters == null\n+                    || !algorithm.equalsIgnoreCase(\"RSASSA-PSS\")) {\n+                return true;\n+            }\n+\n+            try {\n+                String paramKeyAlg = parameters.getAlgorithm();\n+                String paramDigestAlg = parameters.getParameterSpec(\n+                        PSSParameterSpec.class).getDigestAlgorithm();\n+\n+                return supportedSignatureSchemes.stream().anyMatch(ss ->\n+                        ss.algorithm.equalsIgnoreCase(algorithm)\n+                                && ss.keyAlgorithm.equalsIgnoreCase(paramKeyAlg)\n+                                && ((PSSParameterSpec) ss.signAlgParams.parameterSpec)\n+                                .getDigestAlgorithm()\n+                                .equalsIgnoreCase(paramDigestAlg));\n+\n+            } catch (InvalidParameterSpecException e) {\n+                throw new IllegalArgumentException(\n+                        \"Invalid AlgorithmParameters\", e);\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLAlgorithmConstraints.java","additions":130,"deletions":49,"binary":false,"changes":179,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import sun.security.ssl.SSLAlgorithmConstraints.SIGNATURE_CONSTRAINTS_MODE;\n@@ -1453,15 +1454,2 @@\n-            AlgorithmConstraints constraints;\n-            if (ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {\n-                if (session instanceof ExtendedSSLSession extSession) {\n-                    String[] peerSupportedSignAlgs =\n-                            extSession.getLocalSupportedSignatureAlgorithms();\n-\n-                    constraints = SSLAlgorithmConstraints.forSocket(\n-                                    sslSocket, peerSupportedSignAlgs, true);\n-                } else {\n-                    constraints =\n-                            SSLAlgorithmConstraints.forSocket(sslSocket, true);\n-                }\n-            } else {\n-                constraints = SSLAlgorithmConstraints.forSocket(sslSocket, true);\n-            }\n+            AlgorithmConstraints constraints = SSLAlgorithmConstraints.forSocket(\n+                    sslSocket, SIGNATURE_CONSTRAINTS_MODE.LOCAL, true);\n@@ -1491,15 +1479,2 @@\n-            AlgorithmConstraints constraints;\n-            if (ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {\n-                if (session instanceof ExtendedSSLSession extSession) {\n-                    String[] peerSupportedSignAlgs =\n-                            extSession.getLocalSupportedSignatureAlgorithms();\n-\n-                    constraints = SSLAlgorithmConstraints.forEngine(\n-                                    engine, peerSupportedSignAlgs, true);\n-                } else {\n-                    constraints =\n-                            SSLAlgorithmConstraints.forEngine(engine, true);\n-                }\n-            } else {\n-                constraints = SSLAlgorithmConstraints.forEngine(engine, true);\n-            }\n+            AlgorithmConstraints constraints = SSLAlgorithmConstraints.forEngine(\n+                    engine, SIGNATURE_CONSTRAINTS_MODE.LOCAL, true);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLContextImpl.java","additions":6,"deletions":31,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -1394,1 +1394,1 @@\n-    public Collection<SignatureScheme> getLocalSupportedSignatureSchemes() {\n+    Collection<SignatureScheme> getLocalSupportedSignatureSchemes() {\n@@ -1407,0 +1407,9 @@\n+    \/**\n+     * Gets an array of supported signature schemes that the peer is\n+     * willing to verify. Those are sent with \"signature_algorithms_cert\"\n+     * TLS extension.\n+     *\/\n+    Collection<SignatureScheme> getPeerSupportedSignatureSchemes() {\n+        return peerSupportedSignAlgs;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionImpl.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-    private final String algorithm;     \/\/ signature algorithm\n+    final String algorithm;     \/\/ signature algorithm\n@@ -153,1 +153,1 @@\n-    private final SigAlgParamSpec signAlgParams;    \/\/ signature parameters\n+    final SigAlgParamSpec signAlgParams;    \/\/ signature parameters\n@@ -188,1 +188,1 @@\n-        private final AlgorithmParameterSpec parameterSpec;\n+        final AlgorithmParameterSpec parameterSpec;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SignatureScheme.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-import javax.net.ssl.ExtendedSSLSession;\n@@ -46,1 +45,0 @@\n-import javax.net.ssl.SSLSession;\n@@ -52,0 +50,1 @@\n+import sun.security.ssl.SSLAlgorithmConstraints.SIGNATURE_CONSTRAINTS_MODE;\n@@ -170,22 +169,3 @@\n-        if (socket != null && socket.isConnected() &&\n-                socket instanceof SSLSocket sslSocket) {\n-\n-            SSLSession session = sslSocket.getHandshakeSession();\n-\n-            if (session != null) {\n-                if (ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {\n-                    String[] peerSupportedSignAlgs = null;\n-\n-                    if (session instanceof ExtendedSSLSession extSession) {\n-                        \/\/ Peer supported certificate signature algorithms\n-                        \/\/ sent with \"signature_algorithms_cert\" TLS extension.\n-                        peerSupportedSignAlgs =\n-                                extSession.getPeerSupportedSignatureAlgorithms();\n-                    }\n-\n-                    return SSLAlgorithmConstraints.forSocket(\n-                            sslSocket, peerSupportedSignAlgs, true);\n-                }\n-            }\n-\n-            return SSLAlgorithmConstraints.forSocket(sslSocket, true);\n+        if (socket instanceof SSLSocket sslSocket && sslSocket.isConnected()) {\n+            return SSLAlgorithmConstraints.forSocket(\n+                    sslSocket, SIGNATURE_CONSTRAINTS_MODE.PEER, true);\n@@ -204,20 +184,2 @@\n-        if (engine != null) {\n-            SSLSession session = engine.getHandshakeSession();\n-            if (session != null) {\n-                if (ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {\n-                    String[] peerSupportedSignAlgs = null;\n-\n-                    if (session instanceof ExtendedSSLSession extSession) {\n-                        \/\/ Peer supported certificate signature algorithms\n-                        \/\/ sent with \"signature_algorithms_cert\" TLS extension.\n-                        peerSupportedSignAlgs =\n-                                extSession.getPeerSupportedSignatureAlgorithms();\n-                    }\n-\n-                    return SSLAlgorithmConstraints.forEngine(\n-                            engine, peerSupportedSignAlgs, true);\n-                }\n-            }\n-        }\n-\n-        return SSLAlgorithmConstraints.forEngine(engine, true);\n+        return SSLAlgorithmConstraints.forEngine(\n+                engine, SIGNATURE_CONSTRAINTS_MODE.PEER, true);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/X509KeyManagerCertChecking.java","additions":6,"deletions":44,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import sun.security.ssl.SSLAlgorithmConstraints.SIGNATURE_CONSTRAINTS_MODE;\n@@ -201,2 +202,1 @@\n-        if ((socket != null) && socket.isConnected() &&\n-                (socket instanceof SSLSocket sslSocket)) {\n+        if (socket instanceof SSLSocket sslSocket && sslSocket.isConnected()) {\n@@ -210,13 +210,2 @@\n-            boolean isExtSession = (session instanceof ExtendedSSLSession);\n-            AlgorithmConstraints constraints;\n-            if (isExtSession &&\n-                    ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {\n-                ExtendedSSLSession extSession = (ExtendedSSLSession)session;\n-                String[] localSupportedSignAlgs =\n-                        extSession.getLocalSupportedSignatureAlgorithms();\n-\n-                constraints = SSLAlgorithmConstraints.forSocket(\n-                                sslSocket, localSupportedSignAlgs, false);\n-            } else {\n-                constraints = SSLAlgorithmConstraints.forSocket(sslSocket, false);\n-            }\n+            AlgorithmConstraints constraints = SSLAlgorithmConstraints.forSocket(\n+                    sslSocket, SIGNATURE_CONSTRAINTS_MODE.LOCAL, false);\n@@ -226,1 +215,1 @@\n-            if (!checkClientTrusted && isExtSession) {\n+            if (!checkClientTrusted && session instanceof ExtendedSSLSession) {\n@@ -264,13 +253,2 @@\n-            boolean isExtSession = (session instanceof ExtendedSSLSession);\n-            AlgorithmConstraints constraints;\n-            if (isExtSession &&\n-                    ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {\n-                ExtendedSSLSession extSession = (ExtendedSSLSession)session;\n-                String[] localSupportedSignAlgs =\n-                        extSession.getLocalSupportedSignatureAlgorithms();\n-\n-                constraints = SSLAlgorithmConstraints.forEngine(\n-                                engine, localSupportedSignAlgs, false);\n-            } else {\n-                constraints = SSLAlgorithmConstraints.forEngine(engine, false);\n-            }\n+            AlgorithmConstraints constraints = SSLAlgorithmConstraints.forEngine(\n+                    engine, SIGNATURE_CONSTRAINTS_MODE.LOCAL, false);\n@@ -280,1 +258,1 @@\n-            if (!checkClientTrusted && isExtSession) {\n+            if (!checkClientTrusted && session instanceof ExtendedSSLSession) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/X509TrustManagerImpl.java","additions":9,"deletions":31,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -0,0 +1,234 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertTrue;\n+import static jdk.test.lib.Utils.runAndCheckException;\n+\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.KeyStore;\n+import java.security.PrivateKey;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.Security;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Date;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLHandshakeException;\n+import javax.net.ssl.TrustManagerFactory;\n+import jdk.test.lib.security.CertificateBuilder;\n+import sun.security.x509.AuthorityKeyIdentifierExtension;\n+import sun.security.x509.GeneralName;\n+import sun.security.x509.GeneralNames;\n+import sun.security.x509.KeyIdentifier;\n+import sun.security.x509.SerialNumber;\n+import sun.security.x509.X500Name;\n+\n+\n+\/*\n+ * @test\n+ * @bug 8367104\n+ * @summary Check for RSASSA-PSS parameters when validating certificates\n+ *          against algorithm constraints.\n+ * @modules java.base\/sun.security.x509\n+ *          java.base\/sun.security.util\n+ * @library \/javax\/net\/ssl\/templates\n+ *          \/test\/lib\n+ * @run main\/othervm RsaSsaPssConstraints Rsa_pss_pss_Sha384 true\n+ * @run main\/othervm RsaSsaPssConstraints rsa_pss_pss_sha256 false\n+ * @run main\/othervm RsaSsaPssConstraints rsa_pss_pss_sha512 false\n+ * @run main\/othervm RsaSsaPssConstraints rsa_pss_rsae_sha256 false\n+ * @run main\/othervm RsaSsaPssConstraints rsa_pss_rsae_sha384 false\n+ * @run main\/othervm RsaSsaPssConstraints rsa_pss_rsae_sha512 false\n+ * @run main\/othervm RsaSsaPssConstraints rsa_pkcs1_sha384 false\n+ * @run main\/othervm RsaSsaPssConstraints RsaSsa-Pss true\n+ * @run main\/othervm RsaSsaPssConstraints RSA false\n+ *\/\n+\n+public class RsaSsaPssConstraints extends SSLSocketTemplate {\n+\n+    private static final String KEY_ALGORITHM = \"RSASSA-PSS\";\n+    private static final String CERT_SIG_ALG = \"RSASSA-PSS\";\n+\n+    private final String protocol;\n+    private X509Certificate trustedCert;\n+    private X509Certificate serverCert;\n+    private X509Certificate clientCert;\n+    private KeyPair serverKeys;\n+    private KeyPair clientKeys;\n+\n+    protected RsaSsaPssConstraints(String protocol)\n+            throws Exception {\n+        super();\n+        this.protocol = protocol;\n+        setupCertificates();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 2) {\n+            throw new RuntimeException(\"Wrong number of arguments\");\n+        }\n+\n+        String algo = args[0];\n+        boolean fail = Boolean.parseBoolean(args[1]);\n+        var test = new RsaSsaPssConstraints(\"TLS\");\n+\n+        Security.setProperty(\"jdk.tls.disabledAlgorithms\",\n+                \/\/ CertificateBuilder generates RSASSA-PSS certificate\n+                \/\/ signature using SHA-384 digest algorithm.\n+                algo + \" usage CertificateSignature\");\n+\n+        if (fail) {\n+            runAndCheckException(test::run,\n+                    serverEx -> {\n+                        assertTrue(serverEx instanceof SSLHandshakeException);\n+                        assertEquals(serverEx.getMessage(),\n+                                \"(handshake_failure) \"\n+                                        + \"No available authentication scheme\");\n+                    });\n+        } else {\n+            test.run();\n+        }\n+    }\n+\n+    @Override\n+    public SSLContext createServerSSLContext() throws Exception {\n+        return getSSLContext(\n+                trustedCert, serverCert, serverKeys.getPrivate(), protocol);\n+    }\n+\n+    @Override\n+    public SSLContext createClientSSLContext() throws Exception {\n+        return getSSLContext(\n+                trustedCert, clientCert, clientKeys.getPrivate(), protocol);\n+    }\n+\n+    private static SSLContext getSSLContext(\n+            X509Certificate trustedCertificate, X509Certificate keyCertificate,\n+            PrivateKey privateKey, String protocol)\n+            throws Exception {\n+\n+        \/\/ create a key store\n+        KeyStore ks = KeyStore.getInstance(\"PKCS12\");\n+        ks.load(null, null);\n+\n+        \/\/ import the trusted cert\n+        ks.setCertificateEntry(\"TLS Signer\", trustedCertificate);\n+\n+        \/\/ generate certificate chain\n+        Certificate[] chain = new Certificate[2];\n+        chain[0] = keyCertificate;\n+        chain[1] = trustedCertificate;\n+\n+        \/\/ import the key entry.\n+        final char[] passphrase = \"passphrase\".toCharArray();\n+        ks.setKeyEntry(\"Whatever\", privateKey, passphrase, chain);\n+\n+        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"PKIX\");\n+        tmf.init(ks);\n+\n+        \/\/ create SSL context\n+        SSLContext ctx = SSLContext.getInstance(protocol);\n+\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n+        kmf.init(ks, passphrase);\n+\n+        ctx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n+\n+        return ctx;\n+    }\n+\n+    \/\/ Certificate-building helper methods.\n+\n+    private void setupCertificates() throws Exception {\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(KEY_ALGORITHM);\n+        KeyPair caKeys = kpg.generateKeyPair();\n+        this.serverKeys = kpg.generateKeyPair();\n+        this.clientKeys = kpg.generateKeyPair();\n+\n+        this.trustedCert = createTrustedCert(caKeys);\n+\n+        this.serverCert = customCertificateBuilder(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                serverKeys.getPublic(), caKeys.getPublic())\n+                .addBasicConstraintsExt(false, false, -1)\n+                .build(trustedCert, caKeys.getPrivate(), CERT_SIG_ALG);\n+\n+        this.clientCert = customCertificateBuilder(\n+                \"CN=localhost, OU=SSL-Client, O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                clientKeys.getPublic(), caKeys.getPublic())\n+                .addBasicConstraintsExt(false, false, -1)\n+                .build(trustedCert, caKeys.getPrivate(), CERT_SIG_ALG);\n+    }\n+\n+    private static X509Certificate createTrustedCert(KeyPair caKeys)\n+            throws Exception {\n+        SecureRandom random = new SecureRandom();\n+\n+        KeyIdentifier kid = new KeyIdentifier(caKeys.getPublic());\n+        GeneralNames gns = new GeneralNames();\n+        GeneralName name = new GeneralName(new X500Name(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\"));\n+        gns.add(name);\n+        BigInteger serialNumber = BigInteger.valueOf(\n+                random.nextLong(1000000) + 1);\n+        return customCertificateBuilder(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                caKeys.getPublic(), caKeys.getPublic())\n+                .setSerialNumber(serialNumber)\n+                .addExtension(new AuthorityKeyIdentifierExtension(kid, gns,\n+                        new SerialNumber(serialNumber)))\n+                .addBasicConstraintsExt(true, true, -1)\n+                .build(null, caKeys.getPrivate(), CERT_SIG_ALG);\n+    }\n+\n+    private static CertificateBuilder customCertificateBuilder(\n+            String subjectName, PublicKey publicKey, PublicKey caKey)\n+            throws CertificateException, IOException {\n+        SecureRandom random = new SecureRandom();\n+\n+        CertificateBuilder builder = new CertificateBuilder()\n+                .setSubjectName(subjectName)\n+                .setPublicKey(publicKey)\n+                .setNotBefore(\n+                        Date.from(Instant.now().minus(1, ChronoUnit.HOURS)))\n+                .setNotAfter(Date.from(Instant.now().plus(1, ChronoUnit.HOURS)))\n+                .setSerialNumber(\n+                        BigInteger.valueOf(random.nextLong(1000000) + 1))\n+                .addSubjectKeyIdExt(publicKey)\n+                .addAuthorityKeyIdExt(caKey);\n+        builder.addKeyUsageExt(\n+                new boolean[]{true, true, true, true, true, true});\n+\n+        return builder;\n+    }\n+\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/RsaSsaPssConstraints.java","additions":234,"deletions":0,"binary":false,"changes":234,"status":"added"}]}