{"files":[{"patch":"@@ -28,1 +28,0 @@\n-import java.io.IOError;\n@@ -31,0 +30,1 @@\n+import java.net.URI;\n@@ -33,1 +33,0 @@\n-import java.nio.file.FileSystems;\n@@ -35,1 +34,0 @@\n-import java.nio.file.InvalidPathException;\n@@ -40,0 +38,1 @@\n+import java.util.HashMap;\n@@ -41,0 +40,1 @@\n+import java.util.Map;\n@@ -166,0 +166,26 @@\n+    \/\/ Must match the keys\/values expected by ZipFileSystem.java.\n+    private static final Map<String, String> READ_ONLY_JARFS_ENV = Map.of(\n+            \/\/ Jar files opened by Javac should always be read-only.\n+            \"accessMode\", \"readOnly\",\n+            \/\/ ignores timestamps not stored in ZIP central directory, reducing I\/O.\n+            \"zipinfo-time\", \"false\");\n+\n+    \/**\n+     * Returns a {@link java.nio.file.FileSystem FileSystem} environment map\n+     * suitable for creating read-only JAR file-systems with default timestamp\n+     * information via {@link FileSystemProvider#newFileSystem(Path, Map)}\n+     * or {@link java.nio.file.FileSystems#newFileSystem(Path, Map)}.\n+     *\n+     * @param releaseVersion the release version to use when creating a\n+     *                       file-system from a multi-release JAR (or\n+     *                       {@code null} to ignore release versioning).\n+     *\/\n+    public Map<String, ?> readOnlyJarFSEnv(String releaseVersion) {\n+        if (releaseVersion == null) {\n+            return READ_ONLY_JARFS_ENV;\n+        }\n+        \/\/ Multi-release JARs need an additional attribute.\n+        Map<String, String> env = new HashMap<>(READ_ONLY_JARFS_ENV);\n+        env.put(\"releaseVersion\", releaseVersion);\n+        return Collections.unmodifiableMap(env);\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/FSInfo.java","additions":29,"deletions":3,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -564,5 +564,0 @@\n-            Map<String,String> env = new HashMap<>();\n-            \/\/ ignores timestamps not stored in ZIP central directory, reducing I\/O\n-            \/\/ This key is handled by ZipFileSystem only.\n-            env.put(\"zipinfo-time\", \"false\");\n-\n@@ -570,1 +565,0 @@\n-                env.put(\"multi-release\", multiReleaseValue);\n@@ -573,0 +567,1 @@\n+                Map<String, ?> env = fsInfo.readOnlyJarFSEnv(multiReleaseValue);\n@@ -580,2 +575,5 @@\n-                \/\/ or if non \"*.jar\" files are on the classpath.\n-                this.fileSystem = FileSystems.newFileSystem(archivePath, env, (ClassLoader)null);\n+                \/\/ or if non \"*.jar\" files are on the classpath. If this is not a ZIP\/JAR file then it\n+                \/\/ will ignore ZIP specific parameters in env, and may not end up being read-only.\n+                \/\/ However, Javac should never attempt to write back to archives either way.\n+                Map<String, ?> env = fsInfo.readOnlyJarFSEnv(null);\n+                this.fileSystem = FileSystems.newFileSystem(archivePath, env);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/JavacFileManager.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -84,2 +84,0 @@\n-import com.sun.tools.javac.code.Lint;\n-import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -88,1 +86,0 @@\n-import com.sun.tools.javac.resources.CompilerProperties.Warnings;\n@@ -91,1 +88,0 @@\n-import com.sun.tools.javac.util.JCDiagnostic.Warning;\n@@ -144,1 +140,1 @@\n-    private Map<String,String> fsEnv = Collections.emptyMap();\n+    private String releaseVersion = null;\n@@ -236,1 +232,2 @@\n-        fsEnv = Collections.singletonMap(\"releaseVersion\", multiReleaseValue);\n+        \/\/ Null is implicitly allowed and unsets the value.\n+        this.releaseVersion = multiReleaseValue;\n@@ -483,1 +480,1 @@\n-         * @see JavaFileManager#getLocationForModule(Location, JavaFileObject, String)\n+         * @see JavaFileManager#getLocationForModule(Location, JavaFileObject)\n@@ -1390,1 +1387,1 @@\n-                    try (FileSystem fs = jarFSProvider.newFileSystem(p, fsEnv)) {\n+                    try (FileSystem fs = jarFSProvider.newFileSystem(p, fsInfo.readOnlyJarFSEnv(releaseVersion))) {\n@@ -1466,1 +1463,1 @@\n-                            fs = jarFSProvider.newFileSystem(p, Collections.emptyMap());\n+                            fs = jarFSProvider.newFileSystem(p, fsInfo.readOnlyJarFSEnv(null));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/Locations.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-import javax.tools.JavaFileManager.Location;\n@@ -57,1 +56,0 @@\n-import javax.tools.StandardJavaFileManager;\n@@ -99,0 +97,8 @@\n+    \/\/ These must match attributes defined in ZipFileSystem.java.\n+    private static final Map<String, ?> CT_SYM_ZIP_ENV = Map.of(\n+            \/\/ Symbol file should always be opened read-only.\n+            \"accessMode\", \"readOnly\",\n+            \/\/ Uses less accurate, but faster, timestamp information\n+            \/\/ (nobody should care about timestamps in the CT symbol file).\n+            \"zipinfo-time\", \"false\");\n+\n@@ -120,1 +126,1 @@\n-            try (FileSystem fs = FileSystems.newFileSystem(ctSymFile, (ClassLoader)null);\n+            try (FileSystem fs = FileSystems.newFileSystem(ctSymFile, CT_SYM_ZIP_ENV);\n@@ -252,1 +258,5 @@\n-                        ctSym2FileSystem.put(file, fs = FileSystems.newFileSystem(file, (ClassLoader)null));\n+                        fs = FileSystems.newFileSystem(file, CT_SYM_ZIP_ENV);\n+                        \/\/ If for any reason this was not opened from a ZIP file,\n+                        \/\/ then the resulting file system would not be read-only.\n+                        assert fs.isReadOnly();\n+                        ctSym2FileSystem.put(file, fs);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/platform\/JDKPlatformProvider.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.util.Map;\n@@ -163,1 +164,1 @@\n-            zipfs = FileSystems.newFileSystem(testZip);\n+            zipfs = FileSystems.newFileSystem(testZip, Map.of(\"accessMode\", \"readOnly\"));\n","filename":"test\/langtools\/tools\/javac\/api\/file\/SJFM_TestBase.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,1 +28,4 @@\n- * @clean ClassRefDupInConstantPoolTest$Duplicates\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ * @build toolbox.JavacTask toolbox.ToolBox\n@@ -32,0 +35,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -34,0 +39,3 @@\n+import toolbox.JavacTask;\n+import toolbox.ToolBox;\n+\n@@ -38,0 +46,9 @@\n+\n+    private static final String DUPLICATE_REFS_CLASS =\n+            \"\"\"\n+            class Duplicates {\n+                String concat(String s1, String s2) {\n+                    return s1 + (s2 == s1 ? \" \" : s2);\n+                }\n+            }\"\"\";\n+\n@@ -39,2 +56,3 @@\n-        ClassModel cls = ClassFile.of().parse(ClassRefDupInConstantPoolTest.class.\n-                                       getResourceAsStream(\"ClassRefDupInConstantPoolTest$Duplicates.class\").readAllBytes());\n+        new JavacTask(new ToolBox()).sources(DUPLICATE_REFS_CLASS).run();\n+\n+        ClassModel cls = ClassFile.of().parse(Files.readAllBytes(Path.of(\"Duplicates.class\")));\n","filename":"test\/langtools\/tools\/javac\/jvm\/ClassRefDupInConstantPoolTest.java","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ *          jdk.compiler\/com.sun.tools.javac.file\n@@ -37,0 +38,3 @@\n+import com.sun.tools.javac.file.FSInfo;\n+import com.sun.tools.javac.util.Context;\n+\n@@ -56,0 +60,2 @@\n+    private final FSInfo fsInfo = FSInfo.instance(new Context());\n+\n@@ -63,1 +69,2 @@\n-        try (FileSystem fs = FileSystems.newFileSystem(ctSym)) {\n+        \/\/ Expected to always be a ZIP filesystem.\n+        try (var fs = fsInfo.getJarFSProvider().newFileSystem(ctSym, fsInfo.readOnlyJarFSEnv(null))) {\n","filename":"test\/langtools\/tools\/javac\/platform\/VerifyCTSymClassFiles.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"}]}