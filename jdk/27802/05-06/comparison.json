{"files":[{"patch":"@@ -649,2 +649,2 @@\n-void InterpreterRuntime::resolve_get_put(JavaThread* current, Bytecodes::Code bytecode) {\n-  JavaThread* THREAD = current;\n+void InterpreterRuntime::resolve_get_put(Bytecodes::Code bytecode, TRAPS) {\n+  JavaThread* current = THREAD;\n@@ -655,1 +655,1 @@\n-  resolve_get_put(bytecode, last_frame.get_index_u2(bytecode), m, pool, ClassInitMode::init_preemptable, CHECK_AND_CLEAR_PREEMPTED);\n+  resolve_get_put(bytecode, last_frame.get_index_u2(bytecode), m, pool, ClassInitMode::init_preemptable, THREAD);\n@@ -797,1 +797,2 @@\n-void InterpreterRuntime::resolve_invoke(JavaThread* current, Bytecodes::Code bytecode) {\n+void InterpreterRuntime::resolve_invoke(Bytecodes::Code bytecode, TRAPS) {\n+  JavaThread* current = THREAD;\n@@ -825,1 +826,0 @@\n-    JavaThread* THREAD = current; \/\/ For exception macros.\n@@ -837,1 +837,0 @@\n-      CLEAR_PENDING_PREEMPTED_EXCEPTION;\n@@ -936,1 +935,2 @@\n-void InterpreterRuntime::resolve_invokehandle(JavaThread* current) {\n+void InterpreterRuntime::resolve_invokehandle(TRAPS) {\n+  JavaThread* current = THREAD;\n@@ -965,1 +965,2 @@\n-void InterpreterRuntime::resolve_invokedynamic(JavaThread* current) {\n+void InterpreterRuntime::resolve_invokedynamic(TRAPS) {\n+  JavaThread* current = THREAD;\n@@ -1000,1 +1001,1 @@\n-    resolve_get_put(current, bytecode);\n+    resolve_get_put(bytecode, CHECK_AND_CLEAR_PREEMPTED);\n@@ -1006,1 +1007,1 @@\n-    resolve_invoke(current, bytecode);\n+    resolve_invoke(bytecode, CHECK_AND_CLEAR_PREEMPTED);\n@@ -1009,1 +1010,1 @@\n-    resolve_invokehandle(current);\n+    resolve_invokehandle(THREAD);\n@@ -1012,1 +1013,1 @@\n-    resolve_invokedynamic(current);\n+    resolve_invokedynamic(THREAD);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-  static void resolve_get_put(JavaThread* current, Bytecodes::Code bytecode);\n+  static void resolve_get_put(Bytecodes::Code bytecode, TRAPS);\n@@ -109,3 +109,3 @@\n-  static void resolve_invoke(JavaThread* current, Bytecodes::Code bytecode);\n-  static void resolve_invokehandle (JavaThread* current);\n-  static void resolve_invokedynamic(JavaThread* current);\n+  static void resolve_invoke(Bytecodes::Code bytecode, TRAPS);\n+  static void resolve_invokehandle (TRAPS);\n+  static void resolve_invokedynamic(TRAPS);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -192,1 +192,1 @@\n-enum class ClassInitMode : uint8_t {\n+enum class ClassInitMode {\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -808,0 +808,17 @@\n+class PreemptableInitCall {\n+  JavaThread* _thread;\n+  bool _previous;\n+  DEBUG_ONLY(InstanceKlass* _previous_klass;)\n+ public:\n+  PreemptableInitCall(JavaThread* thread, InstanceKlass* ik) : _thread(thread) {\n+    _previous = thread->at_preemptable_init();\n+    _thread->set_at_preemptable_init(true);\n+    DEBUG_ONLY(_previous_klass = _thread->preempt_init_klass();)\n+    DEBUG_ONLY(_thread->set_preempt_init_klass(ik));\n+  }\n+  ~PreemptableInitCall() {\n+    _thread->set_at_preemptable_init(_previous);\n+    DEBUG_ONLY(_thread->set_preempt_init_klass(_previous_klass));\n+  }\n+};\n+\n@@ -810,1 +827,1 @@\n-    PREEMPT_ON_INIT_SUPPORTED_ONLY(PreemptableInitCall pic(THREAD, this);)\n+    PreemptableInitCall pic(THREAD, this);\n@@ -1191,0 +1208,11 @@\n+class ThreadWaitingForClassInit : public StackObj {\n+  JavaThread* _thread;\n+ public:\n+  ThreadWaitingForClassInit(JavaThread* thread, InstanceKlass* ik) : _thread(thread) {\n+    _thread->set_class_to_be_initialized(ik);\n+  }\n+  ~ThreadWaitingForClassInit() {\n+    _thread->set_class_to_be_initialized(nullptr);\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2061,1 +2061,1 @@\n-  ObjectMonitor* _monitor;\n+  ObjectMonitor* _init_lock;\n@@ -2386,0 +2386,1 @@\n+    ObjectMonitor* mon = nullptr;\n@@ -2390,1 +2391,1 @@\n-      ObjectMonitor* mon = waiter->monitor();\n+      mon = waiter->monitor();\n@@ -2400,1 +2401,0 @@\n-      _monitor = mon;        \/\/ remember monitor since we might need it on handle_preempted_continuation()\n@@ -2402,1 +2402,1 @@\n-      JVMTI_ONLY(assert(_thread->contended_entered_monitor() == nullptr || _thread->contended_entered_monitor() == _monitor, \"\"));\n+      JVMTI_ONLY(assert(_thread->contended_entered_monitor() == nullptr || _thread->contended_entered_monitor() == mon, \"\"));\n@@ -2407,2 +2407,2 @@\n-      \/\/ we released the monitor already at ~ObjectLocker, so here we set\n-      \/\/ _monitor to nullptr to indicate there is no need to release it later.\n+      \/\/ we released the monitor already at ~ObjectLocker, so _init_lock\n+      \/\/ will be set to nullptr below since there is no monitor to release.\n@@ -2410,1 +2410,0 @@\n-      _monitor = nullptr;\n@@ -2424,0 +2423,2 @@\n+      assert(waiter == nullptr || mon != nullptr, \"should have a monitor\");\n+      _init_lock = mon;  \/\/ remember monitor since we will need it on handle_preempted_continuation()\n@@ -2674,1 +2675,1 @@\n-    if (_monitor != nullptr) _monitor->exit(_thread);\n+    if (_init_lock != nullptr) _init_lock->exit(_thread);\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -540,1 +540,1 @@\n-#endif\n+#endif \/\/ ASSERT\n@@ -1372,17 +1372,0 @@\n-class PreemptableInitCall {\n-  JavaThread* _thread;\n-  bool _previous;\n-  DEBUG_ONLY(InstanceKlass* _previous_klass;)\n- public:\n-  PreemptableInitCall(JavaThread* thread, InstanceKlass* ik) : _thread(thread) {\n-    _previous = thread->at_preemptable_init();\n-    _thread->set_at_preemptable_init(true);\n-    DEBUG_ONLY(_previous_klass = _thread->preempt_init_klass();)\n-    DEBUG_ONLY(_thread->set_preempt_init_klass(ik));\n-  }\n-  ~PreemptableInitCall() {\n-    _thread->set_at_preemptable_init(_previous);\n-    DEBUG_ONLY(_thread->set_preempt_init_klass(_previous_klass));\n-  }\n-};\n-\n@@ -1421,11 +1404,0 @@\n-class ThreadWaitingForClassInit : public StackObj {\n-  JavaThread* _thread;\n- public:\n-  ThreadWaitingForClassInit(JavaThread* thread, InstanceKlass* ik) : _thread(thread) {\n-    _thread->set_class_to_be_initialized(ik);\n-  }\n-  ~ThreadWaitingForClassInit() {\n-    _thread->set_class_to_be_initialized(nullptr);\n-  }\n-};\n-\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":1,"deletions":29,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -646,6 +646,0 @@\n-#if defined(AARCH64) || defined(AMD64) || defined(RISCV64) || defined(PPC64)\n-#define PREEMPT_ON_INIT_SUPPORTED_ONLY(code) code\n-#else\n-#define PREEMPT_ON_INIT_SUPPORTED_ONLY(code)\n-#endif\n-\n","filename":"src\/hotspot\/share\/utilities\/macros.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"}]}