{"files":[{"patch":"@@ -203,0 +203,31 @@\n+inline intptr_t* AnchorMark::anchor_mark_set_pd() {\n+  intptr_t* sp = _top_frame.sp();\n+  if (_top_frame.is_interpreted_frame()) {\n+    \/\/ In case the top frame is interpreted we need to set up the anchor using\n+    \/\/ the last_sp saved in the frame (remove possible alignment added while\n+    \/\/ thawing, see ThawBase::finish_thaw()). We also need to clear the last_sp\n+    \/\/ saved in the frame as it is not expected to be set in case we preempt again.\n+    _last_sp_from_frame = _top_frame.interpreter_frame_last_sp();\n+    assert(_last_sp_from_frame != nullptr, \"\");\n+    _top_frame.interpreter_frame_set_last_sp(nullptr);\n+    if (sp != _last_sp_from_frame) {\n+      _last_sp_from_frame[-1] = (intptr_t)_top_frame.pc();\n+      _last_sp_from_frame[-2] = (intptr_t)_top_frame.fp();\n+    }\n+    _is_interpreted = true;\n+    sp = _last_sp_from_frame;\n+  }\n+  return sp;\n+}\n+\n+inline void AnchorMark::anchor_mark_clear_pd() {\n+  if (_is_interpreted) {\n+    \/\/ Restore last_sp_from_frame and possibly overwritten pc.\n+    _top_frame.interpreter_frame_set_last_sp(_last_sp_from_frame);\n+    intptr_t* sp = _top_frame.sp();\n+    if (sp != _last_sp_from_frame) {\n+      sp[-1] = (intptr_t)_top_frame.pc();\n+    }\n+  }\n+}\n+\n@@ -309,0 +340,6 @@\n+  return sp;\n+}\n+\n+inline intptr_t* ThawBase::push_preempt_adapter() {\n+  frame enterSpecial = new_entry_frame();\n+  intptr_t* sp = enterSpecial.sp();\n@@ -310,1 +347,1 @@\n-  log_develop_trace(continuations, preempt)(\"push_cleanup_continuation initial sp: \" INTPTR_FORMAT \" final sp: \" INTPTR_FORMAT, p2i(sp + 2 * frame::metadata_words), p2i(sp));\n+  sp[-1] = (intptr_t)StubRoutines::cont_preempt_stub();\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationFreezeThaw_aarch64.inline.hpp","additions":38,"deletions":1,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -55,0 +55,3 @@\n+    DEBUG_ONLY(Method* m = f.is_interpreted_frame() ? f.interpreter_frame_method() : f.cb()->as_nmethod()->method();)\n+    assert(m->is_object_wait0() || thread->interp_at_preemptable_vmcall_cnt() > 0,\n+           \"preemptable VM call not using call_VM_preemptable\");\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationHelper_aarch64.inline.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -482,0 +482,8 @@\n+#ifdef ASSERT\n+  Label not_preempted;\n+  ldr(rscratch1, Address(rthread, JavaThread::preempt_alternate_return_offset()));\n+  cbz(rscratch1, not_preempted);\n+  stop(\"remove_activation: should not have alternate return address set\");\n+  bind(not_preempted);\n+#endif \/* ASSERT *\/\n+\n@@ -1374,0 +1382,1 @@\n+                                             Label*   return_pc,\n@@ -1397,2 +1406,2 @@\n-                               entry_point, number_of_arguments,\n-                     check_exceptions);\n+                               return_pc, entry_point,\n+                               number_of_arguments, check_exceptions);\n@@ -1404,4 +1413,5 @@\n-void InterpreterMacroAssembler::call_VM_preemptable(Register oop_result,\n-                                                    address entry_point,\n-                                                    Register arg_1) {\n-  assert(arg_1 == c_rarg1, \"\");\n+void InterpreterMacroAssembler::call_VM_preemptable_helper(Register oop_result,\n+                                                           address entry_point,\n+                                                           int number_of_arguments,\n+                                                           bool check_exceptions) {\n+  assert(InterpreterRuntime::is_preemptable_call(entry_point), \"VM call not preemptable, should use call_VM()\");\n@@ -1412,1 +1422,1 @@\n-    Label L;\n+    Label L1, L2;\n@@ -1414,3 +1424,10 @@\n-    cbz(rscratch1, L);\n-    stop(\"Should not have alternate return address set\");\n-    bind(L);\n+    cbz(rscratch1, L1);\n+    stop(\"call_VM_preemptable_helper: Should not have alternate return address set\");\n+    bind(L1);\n+    \/\/ We check this counter in patch_return_pc_with_preempt_stub() during freeze.\n+    incrementw(Address(rthread, JavaThread::interp_at_preemptable_vmcall_cnt_offset()));\n+    ldrw(rscratch1, Address(rthread, JavaThread::interp_at_preemptable_vmcall_cnt_offset()));\n+    cmpw(rscratch1, 0);\n+    br(Assembler::GT, L2);\n+    stop(\"call_VM_preemptable_helper: should be > 0\");\n+    bind(L2);\n@@ -1424,3 +1441,2 @@\n-  adr(rscratch1, resume_pc);\n-  str(rscratch1, Address(rthread, JavaThread::last_Java_pc_offset()));\n-  call_VM_base(oop_result, noreg, noreg, entry_point, 1, false \/*check_exceptions*\/);\n+  \/\/ Note: call_VM_base will use resume_pc label to set last_Java_pc.\n+  call_VM_base(noreg, noreg, noreg, &resume_pc, entry_point, number_of_arguments, false \/*check_exceptions*\/);\n@@ -1430,0 +1446,12 @@\n+#ifdef ASSERT\n+  {\n+    Label L;\n+    decrementw(Address(rthread, JavaThread::interp_at_preemptable_vmcall_cnt_offset()));\n+    ldrw(rscratch1, Address(rthread, JavaThread::interp_at_preemptable_vmcall_cnt_offset()));\n+    cmpw(rscratch1, 0);\n+    br(Assembler::GE, L);\n+    stop(\"call_VM_preemptable_helper: should be >= 0\");\n+    bind(L);\n+  }\n+#endif \/* ASSERT *\/\n+\n@@ -1441,0 +1469,45 @@\n+  if (check_exceptions) {\n+    \/\/ check for pending exceptions\n+    ldr(rscratch1, Address(rthread, in_bytes(Thread::pending_exception_offset())));\n+    Label ok;\n+    cbz(rscratch1, ok);\n+    lea(rscratch1, RuntimeAddress(StubRoutines::forward_exception_entry()));\n+    br(rscratch1);\n+    bind(ok);\n+  }\n+\n+  \/\/ get oop result if there is one and reset the value in the thread\n+  if (oop_result->is_valid()) {\n+    get_vm_result_oop(oop_result, rthread);\n+  }\n+}\n+\n+static void pass_arg1(MacroAssembler* masm, Register arg) {\n+  if (c_rarg1 != arg ) {\n+    masm->mov(c_rarg1, arg);\n+  }\n+}\n+\n+static void pass_arg2(MacroAssembler* masm, Register arg) {\n+  if (c_rarg2 != arg ) {\n+    masm->mov(c_rarg2, arg);\n+  }\n+}\n+\n+void InterpreterMacroAssembler::call_VM_preemptable(Register oop_result,\n+                                         address entry_point,\n+                                         Register arg_1,\n+                                         bool check_exceptions) {\n+  pass_arg1(this, arg_1);\n+  call_VM_preemptable_helper(oop_result, entry_point, 1, check_exceptions);\n+}\n+\n+void InterpreterMacroAssembler::call_VM_preemptable(Register oop_result,\n+                                         address entry_point,\n+                                         Register arg_1,\n+                                         Register arg_2,\n+                                         bool check_exceptions) {\n+  LP64_ONLY(assert_different_registers(arg_1, c_rarg2));\n+  pass_arg2(this, arg_2);\n+  pass_arg1(this, arg_1);\n+  call_VM_preemptable_helper(oop_result, entry_point, 2, check_exceptions);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":86,"deletions":13,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+                            Label*   return_pc,\n@@ -61,0 +62,1 @@\n+  \/\/ Use for vthread preemption\n@@ -63,1 +65,7 @@\n-                           Register arg_1);\n+                           Register arg_1,\n+                           bool check_exceptions = true);\n+  void call_VM_preemptable(Register oop_result,\n+                           address entry_point,\n+                           Register arg_1,\n+                           Register arg_2,\n+                           bool check_exceptions = true);\n@@ -65,0 +73,5 @@\n+ private:\n+  void call_VM_preemptable_helper(Register oop_result,\n+                                  address entry_point,\n+                                  int number_of_arguments,\n+                                  bool check_exceptions);\n@@ -66,0 +79,1 @@\n+ public:\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.hpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -777,4 +777,0 @@\n-static bool is_preemptable(address entry_point) {\n-  return entry_point == CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter);\n-}\n-\n@@ -784,0 +780,1 @@\n+                                  Label*   return_pc,\n@@ -816,6 +813,1 @@\n-  if (is_preemptable(entry_point)) {\n-    \/\/ skip setting last_pc since we already set it to desired value.\n-    set_last_Java_frame(last_java_sp, rfp, noreg, rscratch1);\n-  } else {\n-    set_last_Java_frame(last_java_sp, rfp, l, rscratch1);\n-  }\n+  set_last_Java_frame(last_java_sp, rfp, return_pc != nullptr ? *return_pc : l, rscratch1);\n@@ -856,1 +848,1 @@\n-  call_VM_base(oop_result, noreg, noreg, entry_point, number_of_arguments, check_exceptions);\n+  call_VM_base(oop_result, noreg, noreg, nullptr, entry_point, number_of_arguments, check_exceptions);\n@@ -1114,1 +1106,1 @@\n-  call_VM_base(oop_result, rthread, last_java_sp, entry_point, number_of_arguments, check_exceptions);\n+  call_VM_base(oop_result, rthread, last_java_sp, nullptr, entry_point, number_of_arguments, check_exceptions);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -84,0 +84,1 @@\n+    Label*   return_pc,                \/\/ to set up last_Java_frame; use nullptr otherwise\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+class SmallRegisterMap;\n+\n@@ -32,4 +34,7 @@\n-class SmallRegisterMap {\n-  constexpr SmallRegisterMap() = default;\n-  ~SmallRegisterMap() = default;\n-  NONCOPYABLE(SmallRegisterMap);\n+template <bool IncludeArgs>\n+class SmallRegisterMapType {\n+  friend SmallRegisterMap;\n+\n+  constexpr SmallRegisterMapType() = default;\n+  ~SmallRegisterMapType() = default;\n+  NONCOPYABLE(SmallRegisterMapType);\n@@ -37,6 +42,0 @@\n-public:\n-  static const SmallRegisterMap* instance() {\n-    static constexpr SmallRegisterMap the_instance{};\n-    return &the_instance;\n-  }\n-private:\n@@ -74,1 +73,1 @@\n-  bool include_argument_oops() const { return false; }\n+  bool include_argument_oops() const { return IncludeArgs; }\n","filename":"src\/hotspot\/cpu\/aarch64\/smallRegisterMap_aarch64.inline.hpp","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -111,1 +111,2 @@\n-inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops() const {\n+template <typename RegisterMapT>\n+inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops(RegisterMapT* map) const {\n@@ -114,1 +115,0 @@\n-  InterpreterOopMap mask;\n@@ -116,6 +116,3 @@\n-  f.interpreted_frame_oop_map(&mask);\n-  return  mask.num_oops()\n-        + 1 \/\/ for the mirror oop\n-        + (f.interpreter_frame_method()->is_native() ? 1 : 0) \/\/ temp oop slot\n-        + pointer_delta_as_int((intptr_t*)f.interpreter_frame_monitor_begin(),\n-              (intptr_t*)f.interpreter_frame_monitor_end())\/BasicObjectLock::size();\n+  InterpreterOopCount closure;\n+  f.oops_interpreted_do(&closure, map);\n+  return closure.count();\n","filename":"src\/hotspot\/cpu\/aarch64\/stackChunkFrameStream_aarch64.inline.hpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2303,1 +2303,1 @@\n-  __ call_VM(noreg, entry, temp);\n+  __ call_VM_preemptable(noreg, entry, temp);\n@@ -2355,1 +2355,1 @@\n-  __ call_VM(noreg, entry, temp);\n+  __ call_VM_preemptable(noreg, entry, temp);\n@@ -3694,1 +3694,1 @@\n-  call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), c_rarg1, c_rarg2);\n+  __ call_VM_preemptable(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), c_rarg1, c_rarg2);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -71,0 +71,9 @@\n+inline intptr_t* AnchorMark::anchor_mark_set_pd() {\n+  Unimplemented();\n+  return nullptr;\n+}\n+\n+inline void AnchorMark::anchor_mark_clear_pd() {\n+  Unimplemented();\n+}\n+\n@@ -103,0 +112,5 @@\n+inline intptr_t* ThawBase::push_preempt_adapter() {\n+  Unimplemented();\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/continuationFreezeThaw_arm.inline.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+class SmallRegisterMap;\n+\n@@ -32,4 +34,7 @@\n-class SmallRegisterMap {\n-  constexpr SmallRegisterMap() = default;\n-  ~SmallRegisterMap() = default;\n-  NONCOPYABLE(SmallRegisterMap);\n+template <bool IncludeArgs>\n+class SmallRegisterMapType {\n+  friend SmallRegisterMap;\n+\n+  constexpr SmallRegisterMapType() = default;\n+  ~SmallRegisterMapType() = default;\n+  NONCOPYABLE(SmallRegisterMapType);\n@@ -37,6 +42,0 @@\n-public:\n-  static const SmallRegisterMap* instance() {\n-    static constexpr SmallRegisterMap the_instance{};\n-    return &the_instance;\n-  }\n-private:\n@@ -72,1 +71,1 @@\n-  bool include_argument_oops() const { return false; }\n+  bool include_argument_oops() const { return IncludeArgs; }\n","filename":"src\/hotspot\/cpu\/arm\/smallRegisterMap_arm.inline.hpp","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -88,1 +88,2 @@\n-inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops() const {\n+template <typename RegisterMapT>\n+inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops(RegisterMapT* map) const {\n","filename":"src\/hotspot\/cpu\/arm\/stackChunkFrameStream_arm.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -340,0 +340,7 @@\n+inline intptr_t* AnchorMark::anchor_mark_set_pd() {\n+  return _top_frame.sp();\n+}\n+\n+inline void AnchorMark::anchor_mark_clear_pd() {\n+}\n+\n@@ -569,0 +576,5 @@\n+inline intptr_t* ThawBase::push_preempt_adapter() {\n+  Unimplemented();\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/continuationFreezeThaw_ppc.inline.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+class SmallRegisterMap;\n+\n@@ -32,10 +34,7 @@\n-class SmallRegisterMap {\n-  constexpr SmallRegisterMap() = default;\n-  ~SmallRegisterMap() = default;\n-  NONCOPYABLE(SmallRegisterMap);\n-\n-public:\n-  static const SmallRegisterMap* instance() {\n-    static constexpr SmallRegisterMap the_instance{};\n-    return &the_instance;\n-  }\n+template <bool IncludeArgs>\n+class SmallRegisterMapType {\n+  friend SmallRegisterMap;\n+\n+  constexpr SmallRegisterMapType() = default;\n+  ~SmallRegisterMapType() = default;\n+  NONCOPYABLE(SmallRegisterMapType);\n@@ -43,0 +42,1 @@\n+ public:\n","filename":"src\/hotspot\/cpu\/ppc\/smallRegisterMap_ppc.inline.hpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -179,1 +179,2 @@\n-inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops() const {\n+template <typename RegisterMapT>\n+inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops(RegisterMapT* map) const {\n","filename":"src\/hotspot\/cpu\/ppc\/stackChunkFrameStream_ppc.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -210,0 +210,31 @@\n+inline intptr_t* AnchorMark::anchor_mark_set_pd() {\n+  intptr_t* sp = _top_frame.sp();\n+  if (_top_frame.is_interpreted_frame()) {\n+    \/\/ In case the top frame is interpreted we need to set up the anchor using\n+    \/\/ the last_sp saved in the frame (remove possible alignment added while\n+    \/\/ thawing, see ThawBase::finish_thaw()). We also need to clear the last_sp\n+    \/\/ saved in the frame as it is not expected to be set in case we preempt again.\n+    _last_sp_from_frame = _top_frame.interpreter_frame_last_sp();\n+    assert(_last_sp_from_frame != nullptr, \"\");\n+    _top_frame.interpreter_frame_set_last_sp(nullptr);\n+    if (sp != _last_sp_from_frame) {\n+      _last_sp_from_frame[-1] = (intptr_t)_top_frame.pc();\n+      _last_sp_from_frame[-2] = (intptr_t)_top_frame.fp();\n+    }\n+    _is_interpreted = true;\n+    sp = _last_sp_from_frame;\n+  }\n+  return sp;\n+}\n+\n+inline void AnchorMark::anchor_mark_clear_pd() {\n+  if (_is_interpreted) {\n+    \/\/ Restore last_sp_from_frame and possibly overwritten pc.\n+    _top_frame.interpreter_frame_set_last_sp(_last_sp_from_frame);\n+    intptr_t* sp = _top_frame.sp();\n+    if (sp != _last_sp_from_frame) {\n+      sp[-1] = (intptr_t)_top_frame.pc();\n+    }\n+  }\n+}\n+\n@@ -310,0 +341,6 @@\n+  return sp;\n+}\n+\n+inline intptr_t* ThawBase::push_preempt_adapter() {\n+  frame enterSpecial = new_entry_frame();\n+  intptr_t* sp = enterSpecial.sp();\n@@ -311,1 +348,1 @@\n-  log_develop_trace(continuations, preempt)(\"push_cleanup_continuation initial sp: \" INTPTR_FORMAT \" final sp: \" INTPTR_FORMAT, p2i(sp + 2 * frame::metadata_words), p2i(sp));\n+  sp[-1] = (intptr_t)StubRoutines::cont_preempt_stub();\n","filename":"src\/hotspot\/cpu\/riscv\/continuationFreezeThaw_riscv.inline.hpp","additions":38,"deletions":1,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -55,0 +55,3 @@\n+    DEBUG_ONLY(Method* m = f.is_interpreted_frame() ? f.interpreter_frame_method() : f.cb()->as_nmethod()->method();)\n+    assert(m->is_object_wait0() || thread->interp_at_preemptable_vmcall_cnt() > 0,\n+           \"preemptable VM call not using call_VM_preemptable\");\n","filename":"src\/hotspot\/cpu\/riscv\/continuationHelper_riscv.inline.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -521,0 +521,8 @@\n+#ifdef ASSERT\n+  Label not_preempted;\n+  ld(t0, Address(xthread, JavaThread::preempt_alternate_return_offset()));\n+  beqz(t0, not_preempted);\n+  stop(\"remove_activation: should not have alternate return address set\");\n+  bind(not_preempted);\n+#endif \/* ASSERT *\/\n+\n@@ -1444,0 +1452,1 @@\n+                                             Label*   return_pc,\n@@ -1466,3 +1475,3 @@\n-                               entry_point, number_of_arguments,\n-                               check_exceptions);\n-\/\/ interpreter specific\n+                               return_pc, entry_point,\n+                               number_of_arguments, check_exceptions);\n+  \/\/ interpreter specific\n@@ -1473,4 +1482,6 @@\n-void InterpreterMacroAssembler::call_VM_preemptable(Register oop_result,\n-                                                    address entry_point,\n-                                                    Register arg_1) {\n-  assert(arg_1 == c_rarg1, \"\");\n+void InterpreterMacroAssembler::call_VM_preemptable_helper(Register oop_result,\n+                                                           address entry_point,\n+                                                           int number_of_arguments,\n+                                                           bool check_exceptions) {\n+  assert(InterpreterRuntime::is_preemptable_call(entry_point),\n+         \"VM call not preemptable, should use call_VM()\");\n@@ -1481,1 +1492,1 @@\n-    Label L;\n+    Label L1, L2;\n@@ -1483,3 +1494,9 @@\n-    beqz(t0, L);\n-    stop(\"Should not have alternate return address set\");\n-    bind(L);\n+    beqz(t0, L1);\n+    stop(\"call_VM_preemptable_helper: Should not have alternate return address set\");\n+    bind(L1);\n+    \/\/ We check this counter in patch_return_pc_with_preempt_stub() during freeze.\n+    incrementw(Address(xthread, JavaThread::interp_at_preemptable_vmcall_cnt_offset()));\n+    lw(t0, Address(xthread, JavaThread::interp_at_preemptable_vmcall_cnt_offset()));\n+    bgtz(t0, L2);\n+    stop(\"call_VM_preemptable_helper: should be > 0\");\n+    bind(L2);\n@@ -1493,3 +1510,2 @@\n-  la(t0, resume_pc);\n-  sd(t0, Address(xthread, JavaThread::last_Java_pc_offset()));\n-  call_VM_base(oop_result, noreg, noreg, entry_point, 1, false \/*check_exceptions*\/);\n+  \/\/ Note: call_VM_base will use resume_pc label to set last_Java_pc.\n+  call_VM_base(noreg, noreg, noreg, &resume_pc, entry_point, number_of_arguments, false \/*check_exceptions*\/);\n@@ -1499,0 +1515,11 @@\n+#ifdef ASSERT\n+  {\n+    Label L;\n+    decrementw(Address(xthread, JavaThread::interp_at_preemptable_vmcall_cnt_offset()));\n+    lw(t0, Address(xthread, JavaThread::interp_at_preemptable_vmcall_cnt_offset()));\n+    bgez(t0, L);\n+    stop(\"call_VM_preemptable_helper: should be >= 0\");\n+    bind(L);\n+  }\n+#endif \/* ASSERT *\/\n+\n@@ -1510,0 +1537,45 @@\n+  if (check_exceptions) {\n+    \/\/ check for pending exceptions\n+    ld(t0, Address(xthread, in_bytes(Thread::pending_exception_offset())));\n+    Label ok;\n+    beqz(t0, ok);\n+    la(t1, RuntimeAddress(StubRoutines::forward_exception_entry()));\n+    jr(t1);\n+    bind(ok);\n+  }\n+\n+  \/\/ get oop result if there is one and reset the value in the thread\n+  if (oop_result->is_valid()) {\n+    get_vm_result_oop(oop_result, xthread);\n+  }\n+}\n+\n+static void pass_arg1(MacroAssembler* masm, Register arg) {\n+  if (c_rarg1 != arg) {\n+    masm->mv(c_rarg1, arg);\n+  }\n+}\n+\n+static void pass_arg2(MacroAssembler* masm, Register arg) {\n+  if (c_rarg2 != arg) {\n+    masm->mv(c_rarg2, arg);\n+  }\n+}\n+\n+void InterpreterMacroAssembler::call_VM_preemptable(Register oop_result,\n+                                         address entry_point,\n+                                         Register arg_1,\n+                                         bool check_exceptions) {\n+  pass_arg1(this, arg_1);\n+  call_VM_preemptable_helper(oop_result, entry_point, 1, check_exceptions);\n+}\n+\n+void InterpreterMacroAssembler::call_VM_preemptable(Register oop_result,\n+                                         address entry_point,\n+                                         Register arg_1,\n+                                         Register arg_2,\n+                                         bool check_exceptions) {\n+  LP64_ONLY(assert_different_registers(arg_1, c_rarg2));\n+  pass_arg2(this, arg_2);\n+  pass_arg1(this, arg_1);\n+  call_VM_preemptable_helper(oop_result, entry_point, 2, check_exceptions);\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":86,"deletions":14,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+                            Label*   return_pc,\n@@ -62,0 +63,1 @@\n+  \/\/ Use for vthread preemption\n@@ -64,1 +66,9 @@\n-                           Register arg_1);\n+                           Register arg_1,\n+                           bool check_exceptions = true);\n+\n+  void call_VM_preemptable(Register oop_result,\n+                           address entry_point,\n+                           Register arg_1,\n+                           Register arg_2,\n+                           bool check_exceptions = true);\n+\n@@ -67,0 +77,7 @@\n+ private:\n+  void call_VM_preemptable_helper(Register oop_result,\n+                                  address entry_point,\n+                                  int number_of_arguments,\n+                                  bool check_exceptions);\n+\n+ public:\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.hpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -236,1 +236,1 @@\n-  call_VM_base(oop_result, noreg, noreg, entry_point, number_of_arguments, check_exceptions);\n+  call_VM_base(oop_result, noreg, noreg, nullptr, entry_point, number_of_arguments, check_exceptions);\n@@ -287,1 +287,1 @@\n-  call_VM_base(oop_result, xthread, last_java_sp, entry_point, number_of_arguments, check_exceptions);\n+  call_VM_base(oop_result, xthread, last_java_sp, nullptr, entry_point, number_of_arguments, check_exceptions);\n@@ -412,4 +412,0 @@\n-static bool is_preemptable(address entry_point) {\n-  return entry_point == CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter);\n-}\n-\n@@ -419,0 +415,1 @@\n+                                  Label*   return_pc,\n@@ -426,0 +423,1 @@\n+\n@@ -445,6 +443,1 @@\n-  if (is_preemptable(entry_point)) {\n-    \/\/ skip setting last_pc since we already set it to desired value.\n-    set_last_Java_frame(last_java_sp, fp, noreg);\n-  } else {\n-    set_last_Java_frame(last_java_sp, fp, l, t0);\n-  }\n+  set_last_Java_frame(last_java_sp, fp, return_pc != nullptr ? *return_pc : l, t0);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":5,"deletions":12,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -171,0 +171,1 @@\n+    Label*   return_pc,                \/\/ to set up last_Java_frame; use nullptr otherwise\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+class SmallRegisterMap;\n+\n@@ -32,4 +34,7 @@\n-class SmallRegisterMap {\n-  constexpr SmallRegisterMap() = default;\n-  ~SmallRegisterMap() = default;\n-  NONCOPYABLE(SmallRegisterMap);\n+template <bool IncludeArgs>\n+class SmallRegisterMapType {\n+  friend SmallRegisterMap;\n+\n+  constexpr SmallRegisterMapType() = default;\n+  ~SmallRegisterMapType() = default;\n+  NONCOPYABLE(SmallRegisterMapType);\n@@ -37,6 +42,0 @@\n-public:\n-  static const SmallRegisterMap* instance() {\n-    static constexpr SmallRegisterMap the_instance{};\n-    return &the_instance;\n-  }\n-private:\n@@ -45,0 +44,1 @@\n+\n@@ -74,1 +74,1 @@\n-  bool include_argument_oops() const { return false; }\n+  bool include_argument_oops() const { return IncludeArgs; }\n","filename":"src\/hotspot\/cpu\/riscv\/smallRegisterMap_riscv.inline.hpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -109,1 +109,2 @@\n-inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops() const {\n+template <typename RegisterMapT>\n+inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops(RegisterMapT* map) const {\n@@ -112,1 +113,0 @@\n-  InterpreterOopMap mask;\n@@ -114,6 +114,3 @@\n-  f.interpreted_frame_oop_map(&mask);\n-  return mask.num_oops()\n-        + 1 \/\/ for the mirror oop\n-        + (f.interpreter_frame_method()->is_native() ? 1 : 0) \/\/ temp oop slot\n-        + pointer_delta_as_int((intptr_t*)f.interpreter_frame_monitor_begin(),\n-              (intptr_t*)f.interpreter_frame_monitor_end()) \/ BasicObjectLock::size();\n+  InterpreterOopCount closure;\n+  f.oops_interpreted_do(&closure, map);\n+  return closure.count();\n","filename":"src\/hotspot\/cpu\/riscv\/stackChunkFrameStream_riscv.inline.hpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2204,1 +2204,1 @@\n-  __ call_VM(noreg, entry, temp);\n+  __ call_VM_preemptable(noreg, entry, temp);\n@@ -2257,1 +2257,1 @@\n-  __ call_VM(noreg, entry, temp);\n+  __ call_VM_preemptable(noreg, entry, temp);\n@@ -3605,1 +3605,1 @@\n-  call_VM(x10, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), c_rarg1, c_rarg2);\n+  __ call_VM_preemptable(x10, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), c_rarg1, c_rarg2);\n","filename":"src\/hotspot\/cpu\/riscv\/templateTable_riscv.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -71,0 +71,9 @@\n+inline intptr_t* AnchorMark::anchor_mark_set_pd() {\n+  Unimplemented();\n+  return nullptr;\n+}\n+\n+inline void AnchorMark::anchor_mark_clear_pd() {\n+  Unimplemented();\n+}\n+\n@@ -103,0 +112,5 @@\n+inline intptr_t* ThawBase::push_preempt_adapter() {\n+  Unimplemented();\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/continuationFreezeThaw_s390.inline.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -31,5 +31,10 @@\n-\/\/ Java frames don't have callee saved registers (except for rfp), so we can use a smaller RegisterMap\n-class SmallRegisterMap {\n-  constexpr SmallRegisterMap() = default;\n-  ~SmallRegisterMap() = default;\n-  NONCOPYABLE(SmallRegisterMap);\n+class SmallRegisterMap;\n+\n+\/\/ Java frames don't have callee saved registers (except for rfp), so we can use a smaller SmallRegisterMapType\n+template <bool IncludeArgs>\n+class SmallRegisterMapType {\n+  friend SmallRegisterMap;\n+\n+  constexpr SmallRegisterMapType() = default;\n+  ~SmallRegisterMapType() = default;\n+  NONCOPYABLE(SmallRegisterMapType);\n@@ -37,6 +42,0 @@\n-public:\n-  static const SmallRegisterMap* instance() {\n-    static constexpr SmallRegisterMap the_instance{};\n-    return &the_instance;\n-  }\n-private:\n@@ -72,1 +71,1 @@\n-  bool include_argument_oops() const { return false; }\n+  bool include_argument_oops() const { return IncludeArgs; }\n","filename":"src\/hotspot\/cpu\/s390\/smallRegisterMap_s390.inline.hpp","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -88,1 +88,2 @@\n-inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops() const {\n+template <typename RegisterMapT>\n+inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops(RegisterMapT* map) const {\n","filename":"src\/hotspot\/cpu\/s390\/stackChunkFrameStream_s390.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -194,0 +194,31 @@\n+inline intptr_t* AnchorMark::anchor_mark_set_pd() {\n+  intptr_t* sp = _top_frame.sp();\n+  if (_top_frame.is_interpreted_frame()) {\n+    \/\/ In case the top frame is interpreted we need to set up the anchor using\n+    \/\/ the last_sp saved in the frame (remove possible alignment added while\n+    \/\/ thawing, see ThawBase::finish_thaw()). We also need to clear the last_sp\n+    \/\/ saved in the frame as it is not expected to be set in case we preempt again.\n+    _last_sp_from_frame = _top_frame.interpreter_frame_last_sp();\n+    assert(_last_sp_from_frame != nullptr, \"\");\n+    _top_frame.interpreter_frame_set_last_sp(nullptr);\n+    if (sp != _last_sp_from_frame) {\n+      _last_sp_from_frame[-1] = (intptr_t)_top_frame.pc();\n+      _last_sp_from_frame[-2] = (intptr_t)_top_frame.fp();\n+    }\n+    _is_interpreted = true;\n+    sp = _last_sp_from_frame;\n+  }\n+  return sp;\n+}\n+\n+inline void AnchorMark::anchor_mark_clear_pd() {\n+  if (_is_interpreted) {\n+    \/\/ Restore last_sp_from_frame and possibly overwritten pc.\n+    _top_frame.interpreter_frame_set_last_sp(_last_sp_from_frame);\n+    intptr_t* sp = _top_frame.sp();\n+    if (sp != _last_sp_from_frame) {\n+      sp[-1] = (intptr_t)_top_frame.pc();\n+    }\n+  }\n+}\n+\n@@ -296,0 +327,6 @@\n+  return sp;\n+}\n+\n+inline intptr_t* ThawBase::push_preempt_adapter() {\n+  frame enterSpecial = new_entry_frame();\n+  intptr_t* sp = enterSpecial.sp();\n@@ -297,1 +334,1 @@\n-  log_develop_trace(continuations, preempt)(\"push_cleanup_continuation initial sp: \" INTPTR_FORMAT \" final sp: \" INTPTR_FORMAT, p2i(sp + 2 * frame::metadata_words), p2i(sp));\n+  sp[-1] = (intptr_t)StubRoutines::cont_preempt_stub();\n","filename":"src\/hotspot\/cpu\/x86\/continuationFreezeThaw_x86.inline.hpp","additions":38,"deletions":1,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -53,0 +53,3 @@\n+    DEBUG_ONLY(Method* m = f.is_interpreted_frame() ? f.interpreter_frame_method() : f.cb()->as_nmethod()->method();)\n+    assert(m->is_object_wait0() || thread->interp_at_preemptable_vmcall_cnt() > 0,\n+           \"preemptable VM call not using call_VM_preemptable\");\n","filename":"src\/hotspot\/cpu\/x86\/continuationHelper_x86.inline.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -329,4 +329,5 @@\n-void InterpreterMacroAssembler::call_VM_preemptable(Register oop_result,\n-                                                    address entry_point,\n-                                                    Register arg_1) {\n-  assert(arg_1 == c_rarg1, \"\");\n+void InterpreterMacroAssembler::call_VM_preemptable_helper(Register oop_result,\n+                                                           address entry_point,\n+                                                           int number_of_arguments,\n+                                                           bool check_exceptions) {\n+  assert(InterpreterRuntime::is_preemptable_call(entry_point), \"VM call not preemptable, should use call_VM()\");\n@@ -337,1 +338,1 @@\n-    Label L;\n+    Label L1, L2;\n@@ -339,3 +340,9 @@\n-    jcc(Assembler::equal, L);\n-    stop(\"Should not have alternate return address set\");\n-    bind(L);\n+    jcc(Assembler::equal, L1);\n+    stop(\"call_VM_preemptable_helper: should not have alternate return address set\");\n+    bind(L1);\n+    \/\/ We check this counter in patch_return_pc_with_preempt_stub() during freeze.\n+    incrementl(Address(r15_thread, JavaThread::interp_at_preemptable_vmcall_cnt_offset()));\n+    cmpl(Address(r15_thread, JavaThread::interp_at_preemptable_vmcall_cnt_offset()), 0);\n+    jcc(Assembler::greater, L2);\n+    stop(\"call_VM_preemptable_helper: should be > 0\");\n+    bind(L2);\n@@ -349,1 +356,0 @@\n-  \/\/ Note: call_VM_helper requires last_Java_pc for anchor to be at the top of the stack.\n@@ -352,1 +358,2 @@\n-  MacroAssembler::call_VM_helper(oop_result, entry_point, 1, false \/*check_exceptions*\/);\n+  lea(rax, Address(rsp, wordSize));\n+  call_VM_base(noreg, rax, entry_point, number_of_arguments, false);\n@@ -357,0 +364,11 @@\n+#ifdef ASSERT\n+  {\n+    Label L;\n+    decrementl(Address(r15_thread, JavaThread::interp_at_preemptable_vmcall_cnt_offset()));\n+    cmpl(Address(r15_thread, JavaThread::interp_at_preemptable_vmcall_cnt_offset()), 0);\n+    jcc(Assembler::greaterEqual, L);\n+    stop(\"call_VM_preemptable_helper: should be >= 0\");\n+    bind(L);\n+  }\n+#endif \/* ASSERT *\/\n+\n@@ -369,0 +387,48 @@\n+  if (check_exceptions) {\n+    \/\/ check for pending exceptions\n+    cmpptr(Address(r15_thread, Thread::pending_exception_offset()), NULL_WORD);\n+    Label ok;\n+    jcc(Assembler::equal, ok);\n+    \/\/ Exception stub expects return pc to be at top of stack. We only need\n+    \/\/ it to check Interpreter::contains(return_address) so anything will do.\n+    lea(rscratch1, resume_pc);\n+    push(rscratch1);\n+    jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n+    bind(ok);\n+  }\n+\n+  \/\/ get oop result if there is one and reset the value in the thread\n+  if (oop_result->is_valid()) {\n+    get_vm_result_oop(oop_result);\n+  }\n+}\n+\n+static void pass_arg1(MacroAssembler* masm, Register arg) {\n+  if (c_rarg1 != arg ) {\n+    masm->mov(c_rarg1, arg);\n+  }\n+}\n+\n+static void pass_arg2(MacroAssembler* masm, Register arg) {\n+  if (c_rarg2 != arg ) {\n+    masm->mov(c_rarg2, arg);\n+  }\n+}\n+\n+void InterpreterMacroAssembler::call_VM_preemptable(Register oop_result,\n+                                         address entry_point,\n+                                         Register arg_1,\n+                                         bool check_exceptions) {\n+  pass_arg1(this, arg_1);\n+  call_VM_preemptable_helper(oop_result, entry_point, 1, check_exceptions);\n+}\n+\n+void InterpreterMacroAssembler::call_VM_preemptable(Register oop_result,\n+                                         address entry_point,\n+                                         Register arg_1,\n+                                         Register arg_2,\n+                                         bool check_exceptions) {\n+  LP64_ONLY(assert_different_registers(arg_1, c_rarg2));\n+  pass_arg2(this, arg_2);\n+  pass_arg1(this, arg_1);\n+  call_VM_preemptable_helper(oop_result, entry_point, 2, check_exceptions);\n@@ -803,0 +869,8 @@\n+#ifdef ASSERT\n+  Label not_preempted;\n+  cmpptr(Address(r15_thread, JavaThread::preempt_alternate_return_offset()), NULL_WORD);\n+  jcc(Assembler::equal, not_preempted);\n+  stop(\"remove_activation: should not have alternate return address set\");\n+  bind(not_preempted);\n+#endif \/* ASSERT *\/\n+\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":84,"deletions":10,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+  \/\/ Use for vthread preemption\n@@ -67,1 +68,7 @@\n-                           Register arg_1);\n+                           Register arg_1,\n+                           bool check_exceptions = true);\n+  void call_VM_preemptable(Register oop_result,\n+                           address entry_point,\n+                           Register arg_1,\n+                           Register arg_2,\n+                           bool check_exceptions = true);\n@@ -69,0 +76,5 @@\n+ private:\n+  void call_VM_preemptable_helper(Register oop_result,\n+                                  address entry_point,\n+                                  int number_of_arguments,\n+                                  bool check_exceptions);\n@@ -70,0 +82,1 @@\n+ public:\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.hpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+class SmallRegisterMap;\n+\n@@ -32,4 +34,3 @@\n-class SmallRegisterMap {\n-  constexpr SmallRegisterMap() = default;\n-  ~SmallRegisterMap() = default;\n-  NONCOPYABLE(SmallRegisterMap);\n+template <bool IncludeArgs>\n+class SmallRegisterMapType {\n+  friend SmallRegisterMap;\n@@ -37,5 +38,3 @@\n-public:\n-  static const SmallRegisterMap* instance() {\n-    static constexpr SmallRegisterMap the_instance{};\n-    return &the_instance;\n-  }\n+  constexpr SmallRegisterMapType() = default;\n+  ~SmallRegisterMapType() = default;\n+  NONCOPYABLE(SmallRegisterMapType);\n@@ -43,1 +42,0 @@\n-private:\n@@ -75,1 +73,1 @@\n-  bool include_argument_oops() const { return false; }\n+  bool include_argument_oops() const { return IncludeArgs; }\n","filename":"src\/hotspot\/cpu\/x86\/smallRegisterMap_x86.inline.hpp","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -109,1 +109,2 @@\n-inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops() const {\n+template <typename RegisterMapT>\n+inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops(RegisterMapT* map) const {\n@@ -112,1 +113,0 @@\n-  InterpreterOopMap mask;\n@@ -114,6 +114,3 @@\n-  f.interpreted_frame_oop_map(&mask);\n-  return  mask.num_oops()\n-        + 1 \/\/ for the mirror oop\n-        + (f.interpreter_frame_method()->is_native() ? 1 : 0) \/\/ temp oop slot\n-        + pointer_delta_as_int((intptr_t*)f.interpreter_frame_monitor_begin(),\n-              (intptr_t*)f.interpreter_frame_monitor_end())\/BasicObjectLock::size();\n+  InterpreterOopCount closure;\n+  f.oops_interpreted_do(&closure, map);\n+  return closure.count();\n","filename":"src\/hotspot\/cpu\/x86\/stackChunkFrameStream_x86.inline.hpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2236,1 +2236,1 @@\n-  __ call_VM(noreg, entry, temp);\n+  __ call_VM_preemptable(noreg, entry, temp);\n@@ -2283,1 +2283,1 @@\n-  __ call_VM(noreg, entry, temp);\n+  __ call_VM_preemptable(noreg, entry, temp);\n@@ -3647,2 +3647,2 @@\n-  call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), c_rarg1, c_rarg2);\n-   __ verify_oop(rax);\n+  __ call_VM_preemptable(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), c_rarg1, c_rarg2);\n+  __ verify_oop(rax);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -71,0 +71,9 @@\n+inline intptr_t* AnchorMark::anchor_mark_set_pd() {\n+  Unimplemented();\n+  return nullptr;\n+}\n+\n+inline void AnchorMark::anchor_mark_clear_pd() {\n+  Unimplemented();\n+}\n+\n@@ -103,0 +112,5 @@\n+inline intptr_t* ThawBase::push_preempt_adapter() {\n+  Unimplemented();\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/cpu\/zero\/continuationFreezeThaw_zero.inline.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+class SmallRegisterMap;\n+\n@@ -32,4 +34,7 @@\n-class SmallRegisterMap {\n-  constexpr SmallRegisterMap() = default;\n-  ~SmallRegisterMap() = default;\n-  NONCOPYABLE(SmallRegisterMap);\n+template <bool IncludeArgs>\n+class SmallRegisterMapType {\n+  friend SmallRegisterMap;\n+\n+  constexpr SmallRegisterMapType() = default;\n+  ~SmallRegisterMapType() = default;\n+  NONCOPYABLE(SmallRegisterMapType);\n@@ -37,6 +42,0 @@\n-public:\n-  static const SmallRegisterMap* instance() {\n-    static constexpr SmallRegisterMap the_instance{};\n-    return &the_instance;\n-  }\n-private:\n@@ -72,1 +71,1 @@\n-  bool include_argument_oops() const { return false; }\n+  bool include_argument_oops() const { return IncludeArgs; }\n","filename":"src\/hotspot\/cpu\/zero\/smallRegisterMap_zero.inline.hpp","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -88,1 +88,2 @@\n-inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops() const {\n+template <typename RegisterMapT>\n+inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops(RegisterMapT* map) const {\n","filename":"src\/hotspot\/cpu\/zero\/stackChunkFrameStream_zero.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -278,1 +278,1 @@\n-    InterpreterRuntime::resolve_get_put(bc, raw_index, mh, cp, false \/*initialize_holder*\/, CHECK);\n+    InterpreterRuntime::resolve_get_put(bc, raw_index, mh, cp, ClassInitMode::dont_init, CHECK);\n","filename":"src\/hotspot\/share\/cds\/aotConstantPoolResolver.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1812,1 +1812,2 @@\n-          name != vmSymbols::java_lang_NullPointerException()) {\n+          name != vmSymbols::java_lang_NullPointerException() &&\n+          name != vmSymbols::jdk_internal_vm_PreemptedException()) {\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -403,1 +403,1 @@\n-  LinkResolver::resolve_field(result, link_info, bc, false, CHECK_AND_CLEAR_(false));\n+  LinkResolver::resolve_field(result, link_info, bc, ClassInitMode::dont_init, CHECK_AND_CLEAR_(false));\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2118,0 +2118,1 @@\n+int java_lang_VirtualThread::_interruptible_wait_offset;\n@@ -2129,0 +2130,1 @@\n+  macro(_interruptible_wait_offset,        k, \"interruptibleWait\",  bool_signature,              false); \\\n@@ -2198,0 +2200,4 @@\n+void java_lang_VirtualThread::set_interruptible_wait(oop vthread, jboolean value) {\n+  vthread->bool_field_put_volatile(_interruptible_wait_offset, value);\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -566,0 +566,1 @@\n+  static int _interruptible_wait_offset;\n@@ -618,0 +619,1 @@\n+  static void set_interruptible_wait(oop vthread, jboolean value);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+  do_klass(PreemptedException_klass,                    jdk_internal_vm_PreemptedException                    ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -223,0 +223,1 @@\n+  template(jdk_internal_vm_PreemptedException,        \"jdk\/internal\/vm\/PreemptedException\")       \\\n@@ -515,0 +516,2 @@\n+  template(atKlassInit_name,                          \"atKlassInit\")                              \\\n+  template(hasArgsAtTop_name,                         \"hasArgsAtTop\")                             \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -222,1 +222,1 @@\n-  klass->initialize(CHECK);\n+  klass->initialize_preemptable(CHECK_AND_CLEAR_PREEMPTED);\n@@ -650,0 +650,1 @@\n+  JavaThread* THREAD = current;\n@@ -654,1 +655,1 @@\n-  resolve_get_put(bytecode, last_frame.get_index_u2(bytecode), m, pool, true \/*initialize_holder*\/, current);\n+  resolve_get_put(bytecode, last_frame.get_index_u2(bytecode), m, pool, ClassInitMode::init_preemptable, CHECK_AND_CLEAR_PREEMPTED);\n@@ -660,1 +661,1 @@\n-                                         bool initialize_holder, TRAPS) {\n+                                         ClassInitMode init_mode, TRAPS) {\n@@ -668,2 +669,1 @@\n-    LinkResolver::resolve_field_access(info, pool, field_index,\n-                                       m, bytecode, initialize_holder, CHECK);\n+    LinkResolver::resolve_field_access(info, pool, field_index, m, bytecode, init_mode, CHECK);\n@@ -828,1 +828,1 @@\n-                                 THREAD);\n+                                 ClassInitMode::init_preemptable, THREAD);\n@@ -837,0 +837,1 @@\n+      CLEAR_PENDING_PREEMPTED_EXCEPTION;\n@@ -1526,0 +1527,8 @@\n+\n+#ifdef ASSERT\n+bool InterpreterRuntime::is_preemptable_call(address entry_point) {\n+  return entry_point == CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter) ||\n+         entry_point == CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_from_cache) ||\n+         entry_point == CAST_FROM_FN_PTR(address, InterpreterRuntime::_new);\n+}\n+#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-                              methodHandle& m, constantPoolHandle& pool, bool initialize_holder, TRAPS);\n+                              methodHandle& m, constantPoolHandle& pool, ClassInitMode init_mode, TRAPS);\n@@ -173,0 +173,3 @@\n+\n+  \/\/ Virtual Thread Preemption\n+  DEBUG_ONLY(static bool is_preemptable_call(address entry_point);)\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -989,1 +989,1 @@\n-                                        bool initialize_class, TRAPS) {\n+                                        ClassInitMode init_mode, TRAPS) {\n@@ -991,1 +991,1 @@\n-  resolve_field(fd, link_info, byte, initialize_class, CHECK);\n+  resolve_field(fd, link_info, byte, init_mode, CHECK);\n@@ -996,1 +996,1 @@\n-                                 Bytecodes::Code byte, bool initialize_class,\n+                                 Bytecodes::Code byte, ClassInitMode init_mode,\n@@ -1080,2 +1080,6 @@\n-    if (is_static && initialize_class) {\n-      sel_klass->initialize(CHECK);\n+    if (is_static) {\n+      if (init_mode == ClassInitMode::init) {\n+        sel_klass->initialize(CHECK);\n+      } else if (init_mode == ClassInitMode::init_preemptable) {\n+        sel_klass->initialize_preemptable(CHECK);\n+      }\n@@ -1107,1 +1111,1 @@\n-                                       bool initialize_class, TRAPS) {\n+                                       ClassInitMode init_mode, TRAPS) {\n@@ -1114,2 +1118,6 @@\n-  if (initialize_class && resolved_klass->should_be_initialized()) {\n-    resolved_klass->initialize(CHECK);\n+  if (init_mode != ClassInitMode::dont_init && resolved_klass->should_be_initialized()) {\n+    if (init_mode == ClassInitMode::init) {\n+      resolved_klass->initialize(CHECK);\n+    } else if (init_mode == ClassInitMode::init_preemptable) {\n+      resolved_klass->initialize_preemptable(CHECK);\n+    }\n@@ -1677,1 +1685,1 @@\n-  resolve_static_call(info, link_info, \/*initialize_class*\/false, THREAD);\n+  resolve_static_call(info, link_info, ClassInitMode::dont_init, THREAD);\n@@ -1701,1 +1709,1 @@\n-void LinkResolver::resolve_invoke(CallInfo& result, Handle recv, const constantPoolHandle& pool, int index, Bytecodes::Code byte, TRAPS) {\n+void LinkResolver::resolve_invoke(CallInfo& result, Handle recv, const constantPoolHandle& pool, int index, Bytecodes::Code byte, ClassInitMode init_mode, TRAPS) {\n@@ -1703,7 +1711,7 @@\n-    case Bytecodes::_invokestatic   : resolve_invokestatic   (result,       pool, index, CHECK); break;\n-    case Bytecodes::_invokespecial  : resolve_invokespecial  (result, recv, pool, index, CHECK); break;\n-    case Bytecodes::_invokevirtual  : resolve_invokevirtual  (result, recv, pool, index, CHECK); break;\n-    case Bytecodes::_invokehandle   : resolve_invokehandle   (result,       pool, index, CHECK); break;\n-    case Bytecodes::_invokedynamic  : resolve_invokedynamic  (result,       pool, index, CHECK); break;\n-    case Bytecodes::_invokeinterface: resolve_invokeinterface(result, recv, pool, index, CHECK); break;\n-    default                         :                                                            break;\n+    case Bytecodes::_invokestatic   : resolve_invokestatic   (result,       pool, index, init_mode, CHECK); break;\n+    case Bytecodes::_invokespecial  : resolve_invokespecial  (result, recv, pool, index,            CHECK); break;\n+    case Bytecodes::_invokevirtual  : resolve_invokevirtual  (result, recv, pool, index,            CHECK); break;\n+    case Bytecodes::_invokehandle   : resolve_invokehandle   (result,       pool, index,            CHECK); break;\n+    case Bytecodes::_invokedynamic  : resolve_invokedynamic  (result,       pool, index,            CHECK); break;\n+    case Bytecodes::_invokeinterface: resolve_invokeinterface(result, recv, pool, index,            CHECK); break;\n+    default                         :                                                                       break;\n@@ -1731,1 +1739,1 @@\n-      resolve_static_call(result, link_info, \/*initialize_class=*\/false, CHECK);\n+      resolve_static_call(result, link_info, ClassInitMode::dont_init, CHECK);\n@@ -1742,1 +1750,1 @@\n-void LinkResolver::resolve_invokestatic(CallInfo& result, const constantPoolHandle& pool, int index, TRAPS) {\n+void LinkResolver::resolve_invokestatic(CallInfo& result, const constantPoolHandle& pool, int index, ClassInitMode init_mode, TRAPS) {\n@@ -1744,1 +1752,1 @@\n-  resolve_static_call(result, link_info, \/*initialize_class*\/true, CHECK);\n+  resolve_static_call(result, link_info, init_mode, CHECK);\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":28,"deletions":20,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -192,0 +192,6 @@\n+enum class ClassInitMode : uint8_t {\n+  dont_init,\n+  init,\n+  init_preemptable\n+};\n+\n@@ -270,1 +276,1 @@\n-                                      const constantPoolHandle& pool, int index, TRAPS);\n+                                      const constantPoolHandle& pool, int index, ClassInitMode mode, TRAPS);\n@@ -298,1 +304,1 @@\n-                                   bool initialize_class, TRAPS);\n+                                   ClassInitMode mode, TRAPS);\n@@ -304,2 +310,1 @@\n-    resolve_field_access(result, pool, index, method, byte,\n-                         \/* initialize_class*\/true, THREAD);\n+    resolve_field_access(result, pool, index, method, byte, ClassInitMode::init, THREAD);\n@@ -309,1 +314,1 @@\n-                            bool initialize_class, TRAPS);\n+                            ClassInitMode mode, TRAPS);\n@@ -313,1 +318,1 @@\n-                                     bool initialize_klass, TRAPS);\n+                                     ClassInitMode mode, TRAPS);\n@@ -355,1 +360,6 @@\n-                             Bytecodes::Code byte, TRAPS);\n+                             Bytecodes::Code byte, ClassInitMode static_mode, TRAPS);\n+  static void resolve_invoke(CallInfo& result, Handle recv,\n+                             const constantPoolHandle& pool, int index,\n+                             Bytecodes::Code byte, TRAPS) {\n+    resolve_invoke(result, recv, pool, index, byte, ClassInitMode::init, THREAD);\n+  }\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.hpp","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1011,1 +1011,1 @@\n-  LinkResolver::resolve_field(fd, link_info, Bytecodes::java_code(code), false, CHECK_NULL);\n+  LinkResolver::resolve_field(fd, link_info, Bytecodes::java_code(code), ClassInitMode::dont_init, CHECK_NULL);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -241,0 +241,1 @@\n+static BuiltinException _preempted_exception;\n@@ -261,0 +262,1 @@\n+oop Universe::preempted_exception_instance()      { return _preempted_exception.instance(); }\n@@ -320,0 +322,1 @@\n+  _preempted_exception.store_in_cds();\n@@ -339,0 +342,1 @@\n+    _preempted_exception.load_from_cds();\n@@ -358,0 +362,1 @@\n+  _preempted_exception.serialize(f);\n@@ -1136,0 +1141,1 @@\n+  _preempted_exception.init_if_empty(vmSymbols::jdk_internal_vm_PreemptedException(), CHECK_false);\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -247,0 +247,1 @@\n+  static oop          preempted_exception_instance();\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -796,1 +796,1 @@\n-\/\/ Set the initialization lock to null so the object can be GC'ed.  Any racing\n+\/\/ Set the initialization lock to null so the object can be GC'ed. Any racing\n@@ -799,1 +799,2 @@\n-\/\/ the lock and return.\n+\/\/ the lock and return. For preempted vthreads we keep the oop protected\n+\/\/ in the ObjectMonitor (see ObjectMonitor::set_object_strong()).\n@@ -807,0 +808,8 @@\n+void InstanceKlass::initialize_preemptable(TRAPS) {\n+  if (this->should_be_initialized()) {\n+    PREEMPT_ON_INIT_SUPPORTED_ONLY(PreemptableInitCall pic(THREAD, this);)\n+    initialize_impl(THREAD);\n+  } else {\n+    assert(is_initialized(), \"sanity check\");\n+  }\n+}\n@@ -983,1 +992,6 @@\n-    ObjectLocker ol(h_init_lock, jt);\n+    ObjectLocker ol(h_init_lock, CHECK_PREEMPTABLE_false);\n+    \/\/ Don't allow preemption if we link\/initialize classes below,\n+    \/\/ since that would release this monitor while we are in the\n+    \/\/ middle of linking this class.\n+    NoPreemptMark npm(THREAD);\n+\n@@ -1196,1 +1210,1 @@\n-    ObjectLocker ol(h_init_lock, jt);\n+    ObjectLocker ol(h_init_lock, CHECK_PREEMPTABLE);\n@@ -1209,3 +1223,2 @@\n-      jt->set_class_to_be_initialized(this);\n-      ol.wait_uninterruptibly(jt);\n-      jt->set_class_to_be_initialized(nullptr);\n+      ThreadWaitingForClassInit twcl(THREAD, this);\n+      ol.wait_uninterruptibly(CHECK_PREEMPTABLE);\n@@ -1269,0 +1282,4 @@\n+  \/\/ Block preemption once we are the initializer thread. Unmounting now\n+  \/\/ would complicate the reentrant case (identity is platform thread).\n+  NoPreemptMark npm(THREAD);\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":24,"deletions":7,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -541,0 +541,1 @@\n+  void initialize_preemptable(TRAPS);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -198,1 +198,2 @@\n-  const RegisterMap* get_map(const SmallRegisterMap* map, intptr_t* sp) { return map->copy_to_RegisterMap(&_map, sp); }\n+  template <typename SmallRegisterMapT>\n+  const RegisterMap* get_map(const SmallRegisterMapT map, intptr_t* sp) { return map->copy_to_RegisterMap(&_map, sp); }\n","filename":"src\/hotspot\/share\/oops\/instanceStackChunkKlass.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -255,0 +255,4 @@\n+void Klass::initialize_preemptable(TRAPS) {\n+  ShouldNotReachHere();\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -583,0 +583,1 @@\n+  virtual void initialize_preemptable(TRAPS);\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-      _f.oops_interpreted_do(cl, nullptr);\n+      _f.oops_interpreted_do(cl, _map);\n@@ -142,1 +142,1 @@\n-       f.next(SmallRegisterMap::instance())) {\n+       f.next(SmallRegisterMap::instance_no_args())) {\n@@ -418,4 +418,6 @@\n-template void stackChunkOopDesc::do_barriers0<stackChunkOopDesc::BarrierType::Load> (const StackChunkFrameStream<ChunkFrames::Mixed>& f, const SmallRegisterMap* map);\n-template void stackChunkOopDesc::do_barriers0<stackChunkOopDesc::BarrierType::Store>(const StackChunkFrameStream<ChunkFrames::Mixed>& f, const SmallRegisterMap* map);\n-template void stackChunkOopDesc::do_barriers0<stackChunkOopDesc::BarrierType::Load> (const StackChunkFrameStream<ChunkFrames::CompiledOnly>& f, const SmallRegisterMap* map);\n-template void stackChunkOopDesc::do_barriers0<stackChunkOopDesc::BarrierType::Store>(const StackChunkFrameStream<ChunkFrames::CompiledOnly>& f, const SmallRegisterMap* map);\n+template void stackChunkOopDesc::do_barriers0<stackChunkOopDesc::BarrierType::Load> (const StackChunkFrameStream<ChunkFrames::Mixed>& f, const SmallRegisterMapNoArgs* map);\n+template void stackChunkOopDesc::do_barriers0<stackChunkOopDesc::BarrierType::Store>(const StackChunkFrameStream<ChunkFrames::Mixed>& f, const SmallRegisterMapNoArgs* map);\n+template void stackChunkOopDesc::do_barriers0<stackChunkOopDesc::BarrierType::Load> (const StackChunkFrameStream<ChunkFrames::CompiledOnly>& f, const SmallRegisterMapNoArgs* map);\n+template void stackChunkOopDesc::do_barriers0<stackChunkOopDesc::BarrierType::Store>(const StackChunkFrameStream<ChunkFrames::CompiledOnly>& f, const SmallRegisterMapNoArgs* map);\n+template void stackChunkOopDesc::do_barriers0<stackChunkOopDesc::BarrierType::Load> (const StackChunkFrameStream<ChunkFrames::Mixed>& f, const SmallRegisterMapWithArgs* map);\n+template void stackChunkOopDesc::do_barriers0<stackChunkOopDesc::BarrierType::Store>(const StackChunkFrameStream<ChunkFrames::Mixed>& f, const SmallRegisterMapWithArgs* map);\n@@ -441,1 +443,2 @@\n-template void stackChunkOopDesc::fix_thawed_frame(const frame& f, const SmallRegisterMap* map);\n+template void stackChunkOopDesc::fix_thawed_frame(const frame& f, const SmallRegisterMapNoArgs* map);\n+template void stackChunkOopDesc::fix_thawed_frame(const frame& f, const SmallRegisterMapWithArgs* map);\n@@ -530,1 +533,1 @@\n-    int num_oops = f.num_oops();\n+    int num_oops = f.num_oops(map);\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.cpp","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -140,0 +140,6 @@\n+  inline bool at_klass_init() const;\n+  inline void set_at_klass_init(bool value);\n+\n+  inline bool has_args_at_top() const;\n+  inline void set_has_args_at_top(bool value);\n+\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -171,0 +171,12 @@\n+inline bool stackChunkOopDesc::at_klass_init() const { return jdk_internal_vm_StackChunk::atKlassInit(as_oop()); }\n+inline void stackChunkOopDesc::set_at_klass_init(bool value) {\n+  assert(at_klass_init() != value, \"\");\n+  jdk_internal_vm_StackChunk::set_atKlassInit(this, value);\n+}\n+\n+inline bool stackChunkOopDesc::has_args_at_top() const { return jdk_internal_vm_StackChunk::hasArgsAtTop(as_oop()); }\n+inline void stackChunkOopDesc::set_has_args_at_top(bool value) {\n+  assert(has_args_at_top() != value, \"\");\n+  jdk_internal_vm_StackChunk::set_hasArgsAtTop(this, value);\n+}\n+\n@@ -213,1 +225,1 @@\n-  const SmallRegisterMap* map = SmallRegisterMap::instance();\n+  const auto* map = SmallRegisterMap::instance_no_args();\n@@ -233,0 +245,3 @@\n+  } else if (frame_kind == ChunkFrames::Mixed && f.is_interpreted() && has_args_at_top()) {\n+    should_continue = closure->do_frame(f, SmallRegisterMap::instance_with_args());\n+    f.next(map);\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.inline.hpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -774,1 +774,1 @@\n-                        link_info, false, THREAD);\n+                        link_info, ClassInitMode::dont_init, THREAD);\n@@ -836,1 +836,1 @@\n-        LinkResolver::resolve_field(result, link_info, Bytecodes::_nop, false, THREAD);\n+        LinkResolver::resolve_field(result, link_info, Bytecodes::_nop, ClassInitMode::dont_init, THREAD);\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,2 +65,3 @@\n-    freeze_on_monitorenter,\n-    freeze_on_wait\n+    monitorenter,\n+    object_wait,\n+    object_locker\n","filename":"src\/hotspot\/share\/runtime\/continuation.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"interpreter\/bytecodeStream.hpp\"\n@@ -37,0 +38,1 @@\n+#include \"interpreter\/interpreterRuntime.hpp\"\n@@ -41,0 +43,1 @@\n+#include \"oops\/constantPool.inline.hpp\"\n@@ -66,0 +69,2 @@\n+#include \"runtime\/vframe.inline.hpp\"\n+#include \"runtime\/vframe_hp.hpp\"\n@@ -76,0 +81,6 @@\n+#ifdef COMPILER1\n+#include \"c1\/c1_Runtime1.hpp\"\n+#endif\n+#ifdef COMPILER2\n+#include \"opto\/runtime.hpp\"\n+#endif\n@@ -185,2 +196,2 @@\n-static void log_frames(JavaThread* thread);\n-static void log_frames_after_thaw(JavaThread* thread, ContinuationWrapper& cont, intptr_t* sp, bool preempted);\n+static void log_frames(JavaThread* thread, bool do_log = true);\n+static void log_frames_after_thaw(JavaThread* thread, ContinuationWrapper& cont, intptr_t* sp);\n@@ -188,0 +199,1 @@\n+static void verify_frame_kind(frame& top, Continuation::preempt_kind preempt_kind, Method** m_ptr = nullptr, const char** code_name_ptr = nullptr, int* bci_ptr = nullptr, stackChunkOop chunk = nullptr);\n@@ -1093,2 +1105,2 @@\n-    frame f = _thread->last_frame();\n-    if (f.is_interpreted_frame()) {\n+    frame top_frame = _thread->last_frame();\n+    if (top_frame.is_interpreted_frame()) {\n@@ -1099,1 +1111,15 @@\n-      prepare_freeze_interpreted_top_frame(f);\n+      prepare_freeze_interpreted_top_frame(top_frame);\n+    }\n+\n+    \/\/ Do this now so should_process_args_at_top() is set before calling finish_freeze\n+    \/\/ in case we might need to apply GC barriers to frames in this stackChunk.\n+    if (_thread->at_preemptable_init()) {\n+      assert(top_frame.is_interpreted_frame(), \"only InterpreterRuntime::_new\/resolve_from_cache allowed\");\n+      chunk->set_at_klass_init(true);\n+      methodHandle m(_thread, top_frame.interpreter_frame_method());\n+      Bytecode_invoke call = Bytecode_invoke_check(m, top_frame.interpreter_frame_bci());\n+      assert(!call.is_valid() || call.is_invokestatic(), \"only invokestatic allowed\");\n+      if (call.is_invokestatic() && call.size_of_parameters() > 0) {\n+        assert(top_frame.interpreter_frame_expression_stack_size() > 0, \"should have parameters in exp stack\");\n+        chunk->set_has_args_at_top(true);\n+      }\n@@ -1611,0 +1637,19 @@\n+class AnchorMark : public StackObj {\n+  JavaThread* _current;\n+  frame& _top_frame;\n+  intptr_t* _last_sp_from_frame;\n+  bool _is_interpreted;\n+\n+ public:\n+  AnchorMark(JavaThread* current, frame& f) : _current(current), _top_frame(f), _is_interpreted(false) {\n+    intptr_t* sp = anchor_mark_set_pd();\n+    set_anchor(_current, sp);\n+  }\n+  ~AnchorMark() {\n+    clear_anchor(_current);\n+    anchor_mark_clear_pd();\n+  }\n+  inline intptr_t* anchor_mark_set_pd();\n+  inline void anchor_mark_clear_pd();\n+};\n+\n@@ -1638,1 +1683,1 @@\n-static void jvmti_mount_end(JavaThread* current, ContinuationWrapper& cont, frame top) {\n+static void jvmti_mount_end(JavaThread* current, ContinuationWrapper& cont, frame top, Continuation::preempt_kind pk) {\n@@ -1641,1 +1686,1 @@\n-  HandleMarkCleaner hm(current);\n+  HandleMarkCleaner hm(current);  \/\/ Cleanup vth and so._conth Handles\n@@ -1643,1 +1688,0 @@\n-\n@@ -1646,2 +1690,1 @@\n-  \/\/ Since we might safepoint set the anchor so that the stack can be walked.\n-  set_anchor(current, top.sp());\n+  AnchorMark am(current, top);  \/\/ Set anchor so that the stack is walkable.\n@@ -1653,1 +1696,4 @@\n-      JvmtiExport::post_monitor_contended_entered(current, current->contended_entered_monitor());\n+      \/\/ No monitor JVMTI events for ObjectLocker case.\n+      if (pk != Continuation::object_locker) {\n+        JvmtiExport::post_monitor_contended_entered(current, current->contended_entered_monitor());\n+      }\n@@ -1657,2 +1703,0 @@\n-\n-  clear_anchor(current);\n@@ -1681,0 +1725,102 @@\n+\n+static void verify_frame_kind(frame& top, Continuation::preempt_kind preempt_kind, Method** m_ptr, const char** code_name_ptr, int* bci_ptr, stackChunkOop chunk) {\n+  Method* m;\n+  const char* code_name;\n+  int bci;\n+  if (preempt_kind == Continuation::monitorenter) {\n+    assert(top.is_interpreted_frame() || top.is_runtime_frame(), \"\");\n+    bool at_sync_method;\n+    if (top.is_interpreted_frame()) {\n+      m = top.interpreter_frame_method();\n+      assert(!m->is_native() || m->is_synchronized(), \"invalid method %s\", m->external_name());\n+      address bcp = top.interpreter_frame_bcp();\n+      assert(bcp != 0 || m->is_native(), \"\");\n+      at_sync_method = m->is_synchronized() && (bcp == 0 || bcp == m->code_base());\n+      \/\/ bcp is advanced on monitorenter before making the VM call, adjust for that.\n+      bool at_sync_bytecode = bcp > m->code_base() && Bytecode(m, bcp - 1).code() == Bytecodes::Code::_monitorenter;\n+      assert(at_sync_method || at_sync_bytecode, \"\");\n+      bci = at_sync_method ? -1 : top.interpreter_frame_bci();\n+    } else {\n+      JavaThread* current = JavaThread::current();\n+      ResourceMark rm(current);\n+      CodeBlob* cb = top.cb();\n+      RegisterMap reg_map(current,\n+                  RegisterMap::UpdateMap::skip,\n+                  RegisterMap::ProcessFrames::skip,\n+                  RegisterMap::WalkContinuation::include);\n+      if (top.is_heap_frame()) {\n+        assert(chunk != nullptr, \"\");\n+        reg_map.set_stack_chunk(chunk);\n+        top = chunk->relativize(top);\n+        top.set_frame_index(0);\n+      }\n+      frame fr = top.sender(&reg_map);\n+      vframe*  vf  = vframe::new_vframe(&fr, &reg_map, current);\n+      compiledVFrame* cvf = compiledVFrame::cast(vf);\n+      m = cvf->method();\n+      bci = cvf->scope()->bci();\n+      at_sync_method = bci == SynchronizationEntryBCI;\n+      assert(!at_sync_method || m->is_synchronized(), \"bci is %d but method %s is not synchronized\", bci, m->external_name());\n+      bool is_c1_monitorenter = false, is_c2_monitorenter = false;\n+      COMPILER1_PRESENT(is_c1_monitorenter = cb == Runtime1::blob_for(StubId::c1_monitorenter_id) ||\n+                                             cb == Runtime1::blob_for(StubId::c1_monitorenter_nofpu_id);)\n+      COMPILER2_PRESENT(is_c2_monitorenter = cb == CodeCache::find_blob(OptoRuntime::complete_monitor_locking_Java());)\n+      assert(is_c1_monitorenter || is_c2_monitorenter, \"wrong runtime stub frame\");\n+    }\n+    code_name = at_sync_method ? \"synchronized method\" : \"monitorenter\";\n+  } else if (preempt_kind == Continuation::object_wait) {\n+    assert(top.is_interpreted_frame() || top.is_native_frame(), \"\");\n+    m  = top.is_interpreted_frame() ? top.interpreter_frame_method() : top.cb()->as_nmethod()->method();\n+    assert(m->is_object_wait0(), \"\");\n+    bci = 0;\n+    code_name = \"\";\n+  } else {\n+    assert(preempt_kind == Continuation::object_locker, \"invalid preempt kind\");\n+    assert(top.is_interpreted_frame(), \"\");\n+    m = top.interpreter_frame_method();\n+    Bytecode current_bytecode = Bytecode(m, top.interpreter_frame_bcp());\n+    Bytecodes::Code code = current_bytecode.code();\n+    assert(code == Bytecodes::Code::_new || code == Bytecodes::Code::_invokestatic ||\n+           (code == Bytecodes::Code::_getstatic || code == Bytecodes::Code::_putstatic), \"invalid bytecode\");\n+    bci = top.interpreter_frame_bci();\n+    code_name = Bytecodes::name(current_bytecode.code());\n+  }\n+  assert(bci >= 0 || m->is_synchronized(), \"invalid bci:%d at method %s\", bci, m->external_name());\n+\n+  if (m_ptr != nullptr) {\n+    *m_ptr = m;\n+    *code_name_ptr = code_name;\n+    *bci_ptr = bci;\n+  }\n+}\n+\n+static void log_preempt_after_freeze(ContinuationWrapper& cont) {\n+  JavaThread* current = cont.thread();\n+  int64_t tid = current->monitor_owner_id();\n+\n+  StackChunkFrameStream<ChunkFrames::Mixed> sfs(cont.tail());\n+  frame top_frame = sfs.to_frame();\n+  bool at_init = current->at_preemptable_init();\n+  bool at_enter = current->current_pending_monitor() != nullptr;\n+  bool at_wait = current->current_waiting_monitor() != nullptr;\n+  assert((at_enter && !at_wait) || (!at_enter && at_wait), \"\");\n+  Continuation::preempt_kind pk = at_init ? Continuation::object_locker : at_enter ? Continuation::monitorenter : Continuation::object_wait;\n+\n+  Method* m = nullptr;\n+  const char* code_name = nullptr;\n+  int bci = InvalidFrameStateBci;\n+  verify_frame_kind(top_frame, pk, &m, &code_name, &bci, cont.tail());\n+  assert(m != nullptr && code_name != nullptr && bci != InvalidFrameStateBci, \"should be set\");\n+\n+  ResourceMark rm(current);\n+  if (bci < 0) {\n+    log_trace(continuations, preempt)(\"Preempted \" INT64_FORMAT \" while synchronizing on %smethod %s\", tid, m->is_native() ? \"native \" : \"\", m->external_name());\n+  } else if (m->is_object_wait0()) {\n+    log_trace(continuations, preempt)(\"Preempted \" INT64_FORMAT \" at native method %s\", tid, m->external_name());\n+  } else {\n+    Klass* k = current->preempt_init_klass();\n+    assert(k != nullptr || !at_init, \"\");\n+    log_trace(continuations, preempt)(\"Preempted \" INT64_FORMAT \" at %s(bci:%d) in method %s %s%s\", tid, code_name, bci,\n+            m->external_name(), at_init ? \"trying to initialize klass \" : \"\", at_init ? k->external_name() : \"\");\n+  }\n+}\n@@ -1710,0 +1856,1 @@\n+  \/\/ Set up things so that on return to Java we jump to preempt stub.\n@@ -1712,1 +1859,1 @@\n-\n+  DEBUG_ONLY(log_preempt_after_freeze(cont);)\n@@ -1908,0 +2055,1 @@\n+  bool _process_args_at_top;\n@@ -1912,0 +2060,3 @@\n+  \/\/ Only used for preemption on ObjectLocker\n+  ObjectMonitor* _monitor;\n+\n@@ -1938,0 +2089,2 @@\n+  inline intptr_t* push_preempt_adapter();\n+  intptr_t* redo_vmcall(JavaThread* current, frame& top);\n@@ -1954,1 +2107,1 @@\n-  NOINLINE void recurse_thaw_interpreted_frame(const frame& hf, frame& caller, int num_frames);\n+  NOINLINE void recurse_thaw_interpreted_frame(const frame& hf, frame& caller, int num_frames, bool is_top);\n@@ -2054,1 +2207,1 @@\n-    f.next(SmallRegisterMap::instance(), true \/* stop *\/);\n+    f.next(SmallRegisterMap::instance_no_args(), true \/* stop *\/);\n@@ -2070,1 +2223,1 @@\n-  f.next(SmallRegisterMap::instance(), true \/* stop *\/);\n+  f.next(SmallRegisterMap::instance_no_args(), true \/* stop *\/);\n@@ -2230,0 +2383,1 @@\n+  _process_args_at_top = false;\n@@ -2237,1 +2391,1 @@\n-      preempt_kind = waiter->is_wait() ? Continuation::freeze_on_wait : Continuation::freeze_on_monitorenter;\n+      preempt_kind = waiter->is_wait() ? Continuation::object_wait : Continuation::monitorenter;\n@@ -2243,0 +2397,1 @@\n+        log_develop_trace(continuations, preempt)(\"Failed to acquire monitor, unmounting again\");\n@@ -2245,0 +2400,1 @@\n+      _monitor = mon;        \/\/ remember monitor since we might need it on handle_preempted_continuation()\n@@ -2246,0 +2402,1 @@\n+      JVMTI_ONLY(assert(_thread->contended_entered_monitor() == nullptr || _thread->contended_entered_monitor() == _monitor, \"\"));\n@@ -2247,3 +2404,7 @@\n-      \/\/ Preemption cancelled in moniterenter case. We actually acquired\n-      \/\/ the monitor after freezing all frames so nothing to do.\n-      preempt_kind = Continuation::freeze_on_monitorenter;\n+      \/\/ Preemption cancelled on moniterenter or ObjectLocker case. We\n+      \/\/ actually acquired the monitor after freezing all frames so no\n+      \/\/ need to call resume_operation. If this is the ObjectLocker case\n+      \/\/ we released the monitor already at ~ObjectLocker, so here we set\n+      \/\/ _monitor to nullptr to indicate there is no need to release it later.\n+      preempt_kind = Continuation::monitorenter;\n+      _monitor = nullptr;\n@@ -2251,0 +2412,1 @@\n+\n@@ -2253,0 +2415,10 @@\n+\n+    if (chunk->at_klass_init()) {\n+      preempt_kind = Continuation::object_locker;\n+      chunk->set_at_klass_init(false);\n+      _process_args_at_top = chunk->has_args_at_top();\n+      if (_process_args_at_top) {\n+        \/\/ Only needed for the top frame which will be thawed.\n+        chunk->set_has_args_at_top(false);\n+      }\n+    }\n@@ -2336,1 +2508,1 @@\n-    recurse_thaw_interpreted_frame(heap_frame, caller, num_frames);\n+    recurse_thaw_interpreted_frame(heap_frame, caller, num_frames, top_on_preempt_case);\n@@ -2348,1 +2520,1 @@\n-  _stream.next(SmallRegisterMap::instance());\n+  _stream.next(SmallRegisterMap::instance_no_args());\n@@ -2453,1 +2625,0 @@\n-  assert(preempt_kind == Continuation::freeze_on_wait || preempt_kind == Continuation::freeze_on_monitorenter, \"\");\n@@ -2456,0 +2627,2 @@\n+  DEBUG_ONLY(verify_frame_kind(top, preempt_kind);)\n+  NOT_PRODUCT(int64_t tid = _thread->monitor_owner_id();)\n@@ -2463,1 +2636,1 @@\n-      jvmti_mount_end(_thread, _cont, top);\n+      jvmti_mount_end(_thread, _cont, top, preempt_kind);\n@@ -2480,1 +2653,1 @@\n-  if (preempt_kind == Continuation::freeze_on_wait) {\n+  if (preempt_kind == Continuation::object_wait) {\n@@ -2482,1 +2655,2 @@\n-    if (_thread->pending_interrupted_exception()) {\n+    bool throw_ie = _thread->pending_interrupted_exception();\n+    if (throw_ie) {\n@@ -2486,5 +2660,68 @@\n-  } else if (top.is_runtime_frame()) {\n-    \/\/ The continuation might now run on a different platform thread than the previous time so\n-    \/\/ we need to adjust the current thread saved in the stub frame before restoring registers.\n-    JavaThread** thread_addr = frame::saved_thread_address(top);\n-    if (thread_addr != nullptr) *thread_addr = _thread;\n+    log_develop_trace(continuations, preempt)(\"Resuming \" INT64_FORMAT\" after preemption on Object.wait%s\", tid, throw_ie ? \"(throwing IE)\" : \"\");\n+  } else if (preempt_kind == Continuation::monitorenter) {\n+    if (top.is_runtime_frame()) {\n+      \/\/ The continuation might now run on a different platform thread than the previous time so\n+      \/\/ we need to adjust the current thread saved in the stub frame before restoring registers.\n+      JavaThread** thread_addr = frame::saved_thread_address(top);\n+      if (thread_addr != nullptr) *thread_addr = _thread;\n+    }\n+    log_develop_trace(continuations, preempt)(\"Resuming \" INT64_FORMAT \" after preemption on monitorenter\", tid);\n+  } else {\n+    \/\/ We need to redo the original call into the VM. First though, we need\n+    \/\/ to exit the monitor we just acquired (except on preemption cancelled\n+    \/\/ case where it was already released).\n+    assert(preempt_kind == Continuation::object_locker, \"\");\n+    if (_monitor != nullptr) _monitor->exit(_thread);\n+    sp = redo_vmcall(_thread, top);\n+  }\n+  return sp;\n+}\n+\n+intptr_t* ThawBase::redo_vmcall(JavaThread* current, frame& top) {\n+  assert(!current->preempting(), \"\");\n+  NOT_PRODUCT(int64_t tid = current->monitor_owner_id();)\n+  intptr_t* sp = top.sp();\n+\n+  {\n+    HandleMarkCleaner hmc(current);  \/\/ Cleanup so._conth Handle\n+    ContinuationWrapper::SafepointOp so(current, _cont);\n+    AnchorMark am(current, top);    \/\/ Set the anchor so that the stack is walkable.\n+\n+    Method* m = top.interpreter_frame_method();\n+    Bytecode current_bytecode = Bytecode(m, top.interpreter_frame_bcp());\n+    Bytecodes::Code code = current_bytecode.code();\n+    log_develop_trace(continuations, preempt)(\"Redoing InterpreterRuntime::%s for \" INT64_FORMAT, code == Bytecodes::Code::_new ? \"_new\" : \"resolve_from_cache\", tid);\n+\n+    \/\/ These InterpreterRuntime entry points use JRT_ENTRY which uses a HandleMarkCleaner.\n+    \/\/ Create a HandeMark to avoid destroying so._conth.\n+    HandleMark hm(current);\n+    DEBUG_ONLY(JavaThread::AtRedoVMCall apvmc(current);)\n+    if (code == Bytecodes::Code::_new) {\n+      InterpreterRuntime::_new(current, m->constants(), current_bytecode.get_index_u2(code));\n+    } else {\n+      InterpreterRuntime::resolve_from_cache(current, code);\n+    }\n+  }\n+\n+  if (current->preempting()) {\n+    \/\/ Preempted again so we just arrange to return to preempt stub to unmount.\n+    sp = push_preempt_adapter();\n+    current->set_preempt_alternate_return(nullptr);\n+    bool cancelled = current->preemption_cancelled();\n+    if (cancelled) {\n+      \/\/ Since preemption was cancelled, the thread will call thaw again from the preempt\n+      \/\/ stub. These retries could happen several times due to contention on the init_lock,\n+      \/\/ so just let the vthread umount to give a chance for other vthreads to run.\n+      current->set_preemption_cancelled(false);\n+      oop vthread = current->vthread();\n+      assert(java_lang_VirtualThread::state(vthread) == java_lang_VirtualThread::RUNNING, \"wrong state for vthread\");\n+      java_lang_VirtualThread::set_state(vthread, java_lang_VirtualThread::YIELDING);\n+#if INCLUDE_JVMTI\n+      if (current->contended_entered_monitor() != nullptr) {\n+        current->set_contended_entered_monitor(nullptr);\n+      }\n+#endif\n+    }\n+    log_develop_trace(continuations, preempt)(\"Preempted \" INT64_FORMAT \" again%s\", tid, cancelled ? \"(preemption cancelled, setting state to YIELDING)\" : \"\");\n+  } else {\n+    log_develop_trace(continuations, preempt)(\"Call succesful, resuming \" INT64_FORMAT, tid);\n@@ -2496,0 +2733,1 @@\n+  HandleMarkCleaner hm(current);  \/\/ Cleanup so._conth Handle\n@@ -2505,1 +2743,1 @@\n-NOINLINE void ThawBase::recurse_thaw_interpreted_frame(const frame& hf, frame& caller, int num_frames) {\n+NOINLINE void ThawBase::recurse_thaw_interpreted_frame(const frame& hf, frame& caller, int num_frames, bool is_top) {\n@@ -2509,1 +2747,5 @@\n-    _cont.tail()->do_barriers<stackChunkOopDesc::BarrierType::Store>(_stream, SmallRegisterMap::instance());\n+    if (is_top && _process_args_at_top) {\n+      _cont.tail()->do_barriers<stackChunkOopDesc::BarrierType::Store>(_stream, SmallRegisterMap::instance_with_args());\n+    } else {\n+      _cont.tail()->do_barriers<stackChunkOopDesc::BarrierType::Store>(_stream, SmallRegisterMap::instance_no_args());\n+    }\n@@ -2554,1 +2796,1 @@\n-    _cont.tail()->fix_thawed_frame(caller, SmallRegisterMap::instance());\n+    _cont.tail()->fix_thawed_frame(caller, SmallRegisterMap::instance_no_args());\n@@ -2571,1 +2813,1 @@\n-    _cont.tail()->do_barriers<stackChunkOopDesc::BarrierType::Store>(_stream, SmallRegisterMap::instance());\n+    _cont.tail()->do_barriers<stackChunkOopDesc::BarrierType::Store>(_stream, SmallRegisterMap::instance_no_args());\n@@ -2630,1 +2872,1 @@\n-    _cont.tail()->fix_thawed_frame(caller, SmallRegisterMap::instance());\n+    _cont.tail()->fix_thawed_frame(caller, SmallRegisterMap::instance_no_args());\n@@ -2656,1 +2898,1 @@\n-    _stream.next(SmallRegisterMap::instance());\n+    _stream.next(SmallRegisterMap::instance_no_args());\n@@ -2696,1 +2938,1 @@\n-    _cont.tail()->do_barriers<stackChunkOopDesc::BarrierType::Store>(_stream, SmallRegisterMap::instance());\n+    _cont.tail()->do_barriers<stackChunkOopDesc::BarrierType::Store>(_stream, SmallRegisterMap::instance_no_args());\n@@ -2734,1 +2976,1 @@\n-  _cont.tail()->fix_thawed_frame(caller, SmallRegisterMap::instance());\n+  _cont.tail()->fix_thawed_frame(caller, SmallRegisterMap::instance_no_args());\n@@ -2761,1 +3003,6 @@\n-  chunk->fix_thawed_frame(f, SmallRegisterMap::instance()); \/\/ can only fix caller after push_return_frame (due to callee saved regs)\n+   \/\/ can only fix caller after push_return_frame (due to callee saved regs)\n+  if (_process_args_at_top) {\n+    chunk->fix_thawed_frame(f, SmallRegisterMap::instance_with_args());\n+  } else {\n+    chunk->fix_thawed_frame(f, SmallRegisterMap::instance_no_args());\n+  }\n@@ -2823,1 +3070,0 @@\n-  DEBUG_ONLY(bool preempted = cont.tail()->preempted();)\n@@ -2827,1 +3073,1 @@\n-  DEBUG_ONLY(log_frames_after_thaw(thread, cont, sp, preempted);)\n+  DEBUG_ONLY(log_frames_after_thaw(thread, cont, sp);)\n@@ -2924,1 +3170,1 @@\n-static void log_frames(JavaThread* thread) {\n+static void log_frames(JavaThread* thread, bool do_log) {\n@@ -2927,1 +3173,1 @@\n-  if (!lt.develop_is_enabled()) {\n+  if (!lt.develop_is_enabled() || !do_log) {\n@@ -2969,1 +3215,1 @@\n-static void log_frames_after_thaw(JavaThread* thread, ContinuationWrapper& cont, intptr_t* sp, bool preempted) {\n+static void log_frames_after_thaw(JavaThread* thread, ContinuationWrapper& cont, intptr_t* sp) {\n@@ -2973,1 +3219,3 @@\n-  if (preempted && sp0 == cont.entrySP()) {\n+  bool preempted = false;\n+  stackChunkOop tail = cont.tail();\n+  if (tail != nullptr && tail->preempted()) {\n@@ -2975,1 +3223,0 @@\n-    assert(cont.tail()->preempted(), \"\");\n@@ -2977,0 +3224,1 @@\n+    preempted = true;\n@@ -2985,1 +3233,1 @@\n-  assert(ContinuationEntry::assert_entry_frame_laid_out(thread), \"\");\n+  assert(preempted || ContinuationEntry::assert_entry_frame_laid_out(thread), \"\");\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":297,"deletions":49,"binary":false,"changes":346,"status":"modified"},{"patch":"@@ -90,0 +90,2 @@\n+int jdk_internal_vm_StackChunk::_atKlassInit_offset;\n+int jdk_internal_vm_StackChunk::_hasArgsAtTop_offset;\n","filename":"src\/hotspot\/share\/runtime\/continuationJavaClasses.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -79,0 +79,2 @@\n+  macro(jdk_internal_vm_StackChunk, atKlassInit,     bool_signature,         false) \\\n+  macro(jdk_internal_vm_StackChunk, hasArgsAtTop,    bool_signature,         false) \\\n@@ -91,0 +93,2 @@\n+  static int _atKlassInit_offset;\n+  static int _hasArgsAtTop_offset;\n@@ -132,0 +136,6 @@\n+  static inline bool atKlassInit(oop chunk);\n+  static inline void set_atKlassInit(oop chunk, bool value);\n+\n+  static inline bool hasArgsAtTop(oop chunk);\n+  static inline void set_hasArgsAtTop(oop chunk, bool value);\n+\n","filename":"src\/hotspot\/share\/runtime\/continuationJavaClasses.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -197,0 +197,16 @@\n+inline bool jdk_internal_vm_StackChunk::atKlassInit(oop chunk) {\n+  return chunk->bool_field(_atKlassInit_offset);\n+}\n+\n+inline void jdk_internal_vm_StackChunk::set_atKlassInit(oop chunk, bool value) {\n+  chunk->bool_field_put(_atKlassInit_offset, (jboolean)value);\n+}\n+\n+inline bool jdk_internal_vm_StackChunk::hasArgsAtTop(oop chunk) {\n+  return chunk->bool_field(_hasArgsAtTop_offset);\n+}\n+\n+inline void jdk_internal_vm_StackChunk::set_hasArgsAtTop(oop chunk, bool value) {\n+  chunk->bool_field_put(_hasArgsAtTop_offset, (jboolean)value);\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/continuationJavaClasses.inline.hpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -894,1 +894,2 @@\n-void frame::oops_interpreted_do(OopClosure* f, const RegisterMap* map, bool query_oop_map_cache) const {\n+template <typename RegisterMapT>\n+void frame::oops_interpreted_do(OopClosure* f, const RegisterMapT* map, bool query_oop_map_cache) const {\n@@ -931,3 +932,0 @@\n-  Symbol* signature = nullptr;\n-  bool has_receiver = false;\n-\n@@ -938,1 +936,1 @@\n-  if (!m->is_native()) {\n+  if (!m->is_native() && map != nullptr && map->include_argument_oops()) {\n@@ -940,18 +938,18 @@\n-    if (map != nullptr && call.is_valid()) {\n-      signature = call.signature();\n-      has_receiver = call.has_receiver();\n-      if (map->include_argument_oops() &&\n-          interpreter_frame_expression_stack_size() > 0) {\n-        ResourceMark rm(thread);  \/\/ is this right ???\n-        \/\/ we are at a call site & the expression stack is not empty\n-        \/\/ => process callee's arguments\n-        \/\/\n-        \/\/ Note: The expression stack can be empty if an exception\n-        \/\/       occurred during method resolution\/execution. In all\n-        \/\/       cases we empty the expression stack completely be-\n-        \/\/       fore handling the exception (the exception handling\n-        \/\/       code in the interpreter calls a blocking runtime\n-        \/\/       routine which can cause this code to be executed).\n-        \/\/       (was bug gri 7\/27\/98)\n-        oops_interpreted_arguments_do(signature, has_receiver, f);\n-      }\n+    if (call.is_valid() && interpreter_frame_expression_stack_size() > 0) {\n+      ResourceMark rm(thread);  \/\/ is this right ???\n+      Symbol* signature = call.signature();\n+      bool has_receiver = call.has_receiver();\n+      \/\/ we are at a call site & the expression stack is not empty\n+      \/\/ => process callee's arguments\n+      \/\/\n+      \/\/ Note: The expression stack can be empty if an exception\n+      \/\/       occurred during method resolution\/execution. In all\n+      \/\/       cases we empty the expression stack completely be-\n+      \/\/       fore handling the exception (the exception handling\n+      \/\/       code in the interpreter calls a blocking runtime\n+      \/\/       routine which can cause this code to be executed).\n+      \/\/       (was bug gri 7\/27\/98)\n+      \/\/ if (dolog) {\n+      \/\/   log_trace(continuations, tracking)(\"Processing arguments\");\n+      \/\/ }\n+      oops_interpreted_arguments_do(signature, has_receiver, f);\n@@ -973,0 +971,3 @@\n+template void frame::oops_interpreted_do(OopClosure* f, const RegisterMap* map, bool query_oop_map_cache) const;\n+template void frame::oops_interpreted_do(OopClosure* f, const SmallRegisterMapNoArgs* map, bool query_oop_map_cache) const;\n+template void frame::oops_interpreted_do(OopClosure* f, const SmallRegisterMapWithArgs* map, bool query_oop_map_cache) const;\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":24,"deletions":23,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -459,1 +459,2 @@\n-  void oops_interpreted_do(OopClosure* f, const RegisterMap* map, bool query_oop_map_cache = true) const;\n+  template <typename RegisterMapT>\n+  void oops_interpreted_do(OopClosure* f, const RegisterMapT* map, bool query_oop_map_cache = true) const;\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+  assert(!thread->preempting(), \"\");\n@@ -245,1 +246,1 @@\n-  LinkResolver::resolve_static_call(callinfo, link_info, true, CHECK);\n+  LinkResolver::resolve_static_call(callinfo, link_info, ClassInitMode::init, CHECK);\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -496,0 +496,3 @@\n+  _at_preemptable_init(false),\n+  DEBUG_ONLY(_preempt_init_klass(nullptr) COMMA)\n+  DEBUG_ONLY(_interp_at_preemptable_vmcall_cnt(0) COMMA)\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -492,0 +492,3 @@\n+  \/\/ We allow preemption on some klass initialization calls.\n+  \/\/ We use this boolean to mark such calls.\n+  bool _at_preemptable_init;\n@@ -500,1 +503,1 @@\n-  bool preempting()           { return _preempt_alternate_return != nullptr; }\n+  bool preempting()                              { return _preempt_alternate_return != nullptr; }\n@@ -503,1 +506,28 @@\n-private:\n+  bool at_preemptable_init()           { return _at_preemptable_init; }\n+  void set_at_preemptable_init(bool b) { _at_preemptable_init = b; }\n+\n+#ifdef ASSERT\n+  \/\/ Used for extra logging with -Xlog:continuation+preempt\n+  InstanceKlass* _preempt_init_klass;\n+\n+  InstanceKlass* preempt_init_klass() { return _preempt_init_klass; }\n+  void set_preempt_init_klass(InstanceKlass* ik) { _preempt_init_klass = ik; }\n+\n+  int _interp_at_preemptable_vmcall_cnt;\n+  int interp_at_preemptable_vmcall_cnt() { return _interp_at_preemptable_vmcall_cnt; }\n+\n+  class AtRedoVMCall : public StackObj {\n+    JavaThread* _thread;\n+   public:\n+    AtRedoVMCall(JavaThread* t) : _thread(t) {\n+      _thread->_interp_at_preemptable_vmcall_cnt++;\n+      assert(_thread->_interp_at_preemptable_vmcall_cnt > 0, \"Unexpected count: %d\",\n+             _thread->_interp_at_preemptable_vmcall_cnt);\n+    }\n+    ~AtRedoVMCall() {\n+      _thread->_interp_at_preemptable_vmcall_cnt--;\n+      assert(_thread->_interp_at_preemptable_vmcall_cnt >= 0, \"Unexpected count: %d\",\n+             _thread->_interp_at_preemptable_vmcall_cnt);\n+    }\n+  };\n+#endif\n@@ -505,0 +535,1 @@\n+private:\n@@ -892,0 +923,1 @@\n+  DEBUG_ONLY(static ByteSize interp_at_preemptable_vmcall_cnt_offset() { return byte_offset_of(JavaThread, _interp_at_preemptable_vmcall_cnt); })\n@@ -1333,0 +1365,17 @@\n+class PreemptableInitCall {\n+  JavaThread* _thread;\n+  bool _previous;\n+  DEBUG_ONLY(InstanceKlass* _previous_klass;)\n+ public:\n+  PreemptableInitCall(JavaThread* thread, InstanceKlass* ik) : _thread(thread) {\n+    _previous = thread->at_preemptable_init();\n+    _thread->set_at_preemptable_init(true);\n+    DEBUG_ONLY(_previous_klass = _thread->preempt_init_klass();)\n+    DEBUG_ONLY(_thread->set_preempt_init_klass(ik));\n+  }\n+  ~PreemptableInitCall() {\n+    _thread->set_at_preemptable_init(_previous);\n+    DEBUG_ONLY(_thread->set_preempt_init_klass(_previous_klass));\n+  }\n+};\n+\n@@ -1337,2 +1386,2 @@\n-  NoPreemptMark(JavaThread* thread) : _ce(thread->last_continuation()), _unpin(false) {\n-    if (_ce != nullptr) _unpin = _ce->pin();\n+  NoPreemptMark(JavaThread* thread, bool ignore_mark = false) : _ce(thread->last_continuation()), _unpin(false) {\n+    if (_ce != nullptr && !ignore_mark) _unpin = _ce->pin();\n@@ -1365,0 +1414,11 @@\n+class ThreadWaitingForClassInit : public StackObj {\n+  JavaThread* _thread;\n+ public:\n+  ThreadWaitingForClassInit(JavaThread* thread, InstanceKlass* ik) : _thread(thread) {\n+    _thread->set_class_to_be_initialized(ik);\n+  }\n+  ~ThreadWaitingForClassInit() {\n+    _thread->set_class_to_be_initialized(nullptr);\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":64,"deletions":4,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -307,0 +307,1 @@\n+  _object_strong.release(JavaThread::thread_oop_storage());\n@@ -314,0 +315,14 @@\n+\/\/ Keep object protected during ObjectLocker preemption.\n+void ObjectMonitor::set_object_strong() {\n+  check_object_context();\n+  if (_object_strong.is_empty()) {\n+    if (Thread::TrySpinAcquire(&_object_strong_lock)) {\n+      if (_object_strong.is_empty()) {\n+        assert(_object.resolve() != nullptr, \"\");\n+        _object_strong = OopHandle(JavaThread::thread_oop_storage(), _object.resolve());\n+      }\n+      Thread::SpinRelease(&_object_strong_lock);\n+    }\n+  }\n+}\n+\n@@ -1816,1 +1831,1 @@\n-      vthread_wait(current, millis);\n+      vthread_wait(current, millis, interruptible);\n@@ -2173,1 +2188,1 @@\n-void ObjectMonitor::vthread_wait(JavaThread* current, jlong millis) {\n+void ObjectMonitor::vthread_wait(JavaThread* current, jlong millis, bool interruptible) {\n@@ -2177,0 +2192,1 @@\n+  node->_interruptible = interruptible;\n@@ -2179,0 +2195,1 @@\n+  java_lang_VirtualThread::set_interruptible_wait(vthread, interruptible);\n@@ -2224,1 +2241,1 @@\n-  node->_interrupted = !was_notified && current->is_interrupted(false);\n+  node->_interrupted = node->_interruptible && !was_notified && current->is_interrupted(false);\n@@ -2226,1 +2243,2 @@\n-  \/\/ Post JFR and JVMTI events.\n+  \/\/ Post JFR and JVMTI events. If non-interruptible we are in\n+  \/\/ ObjectLocker case so we don't post anything.\n@@ -2228,1 +2246,1 @@\n-  if (wait_event.should_commit() || JvmtiExport::should_post_monitor_waited()) {\n+  if (node->_interruptible && (wait_event.should_commit() || JvmtiExport::should_post_monitor_waited())) {\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":23,"deletions":5,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+  bool     _interruptible;\n@@ -205,0 +206,1 @@\n+  OopHandle _object_strong;         \/\/ Used to protect object during preemption on class initialization\n@@ -209,0 +211,1 @@\n+  volatile int _object_strong_lock; \/\/ protects setting of _object_strong\n@@ -348,0 +351,1 @@\n+  void      set_object_strong();\n@@ -410,1 +414,1 @@\n-  void      vthread_wait(JavaThread* current, jlong millis);\n+  void      vthread_wait(JavaThread* current, jlong millis, bool interruptible);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,0 +32,15 @@\n+typedef SmallRegisterMapType<false> SmallRegisterMapNoArgs;\n+typedef SmallRegisterMapType<true>  SmallRegisterMapWithArgs;\n+\n+class SmallRegisterMap : AllStatic {\n+public:\n+  static const SmallRegisterMapNoArgs* instance_no_args() {\n+    static constexpr SmallRegisterMapNoArgs the_instance{};\n+    return &the_instance;\n+  }\n+  static const SmallRegisterMapWithArgs* instance_with_args() {\n+    static constexpr SmallRegisterMapWithArgs the_instance_with_args{};\n+    return &the_instance_with_args;\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/smallRegisterMap.inline.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"memory\/iterator.hpp\"\n@@ -82,1 +83,2 @@\n-  inline int num_oops() const;\n+  template <typename RegisterMapT>\n+  inline int num_oops(RegisterMapT* map) const;\n@@ -104,1 +106,2 @@\n-  inline int interpreter_frame_num_oops() const;\n+  template <typename RegisterMapT>\n+  inline int interpreter_frame_num_oops(RegisterMapT* map) const;\n@@ -126,0 +129,9 @@\n+class InterpreterOopCount : public OopClosure {\n+  int _count;\n+public:\n+  InterpreterOopCount() : _count(0) {}\n+  void do_oop(oop* p) override { _count++; }\n+  void do_oop(narrowOop* p) override { _count++; }\n+  int count() { return _count; }\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/stackChunkFrameStream.hpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -198,1 +198,2 @@\n-inline int StackChunkFrameStream<frame_kind>::num_oops() const {\n+template <typename RegisterMapT>\n+inline int StackChunkFrameStream<frame_kind>::num_oops(RegisterMapT* map) const {\n@@ -200,1 +201,1 @@\n-    return interpreter_frame_num_oops();\n+    return interpreter_frame_num_oops(map);\n@@ -368,1 +369,1 @@\n-    f.oops_interpreted_do(closure, nullptr, true);\n+    f.oops_interpreted_do(closure, map, true);\n","filename":"src\/hotspot\/share\/runtime\/stackChunkFrameStream.inline.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-template StackValue* StackValue::create_stack_value(const frame* fr, const SmallRegisterMap* reg_map, ScopeValue* sv);\n+template StackValue* StackValue::create_stack_value(const frame* fr, const SmallRegisterMapNoArgs* reg_map, ScopeValue* sv);\n@@ -260,1 +260,1 @@\n-template address StackValue::stack_value_address(const frame* fr, const SmallRegisterMap* reg_map, ScopeValue* sv);\n+template address StackValue::stack_value_address(const frame* fr, const SmallRegisterMapNoArgs* reg_map, ScopeValue* sv);\n","filename":"src\/hotspot\/share\/runtime\/stackValue.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -478,2 +478,4 @@\n-ObjectLocker::ObjectLocker(Handle obj, JavaThread* thread) : _npm(thread) {\n-  _thread = thread;\n+ObjectLocker::ObjectLocker(Handle obj, TRAPS) : _thread(THREAD), _obj(obj),\n+  _npm(_thread, _thread->at_preemptable_init() \/* ignore_mark *\/), _skip_exit(false) {\n+  assert(!_thread->preempting(), \"\");\n+\n@@ -481,1 +483,0 @@\n-  _obj = obj;\n@@ -485,0 +486,14 @@\n+\n+    if (_thread->preempting()) {\n+      \/\/ If preemption was cancelled we acquired the monitor after freezing\n+      \/\/ the frames. Redoing the vm call laterin thaw will require us to\n+      \/\/ release it since the call should look like the original one. We\n+      \/\/ do it in ~ObjectLocker to reduce the window of time we hold the\n+      \/\/ monitor since we can't do anything useful with it now, and would\n+      \/\/ otherwise just force other vthreads to preempt in case they try\n+      \/\/ to acquire this monitor.\n+      _skip_exit = !_thread->preemption_cancelled();\n+      ObjectSynchronizer::read_monitor(_thread, _obj())->set_object_strong();\n+      _thread->set_pending_preempted_exception();\n+\n+    }\n@@ -489,1 +504,1 @@\n-  if (_obj() != nullptr) {\n+  if (_obj() != nullptr && !_skip_exit) {\n@@ -494,0 +509,8 @@\n+void ObjectLocker::wait_uninterruptibly(TRAPS) {\n+  ObjectSynchronizer::waitUninterruptibly(_obj, 0, _thread);\n+  if (_thread->preempting()) {\n+    _skip_exit = true;\n+    ObjectSynchronizer::read_monitor(_thread, _obj())->set_object_strong();\n+    _thread->set_pending_preempted_exception();\n+  }\n+}\n@@ -520,3 +543,1 @@\n-  if (millis < 0) {\n-    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), \"timeout value is negative\");\n-  }\n+  assert(millis >= 0, \"timeout value is negative\");\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":28,"deletions":7,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -129,0 +129,1 @@\n+  inline static ObjectMonitor* read_monitor(Thread* current, oop obj);\n@@ -227,0 +228,1 @@\n+  bool    _skip_exit;\n@@ -228,1 +230,1 @@\n-  ObjectLocker(Handle obj, JavaThread* current);\n+  ObjectLocker(Handle obj, TRAPS);\n@@ -232,2 +234,1 @@\n-  void wait(TRAPS)  { ObjectSynchronizer::wait(_obj, 0, CHECK); } \/\/ wait forever\n-  void wait_uninterruptibly(TRAPS)  { ObjectSynchronizer::waitUninterruptibly(_obj, 0, CHECK); } \/\/ wait forever\n+  void wait_uninterruptibly(TRAPS);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -37,0 +37,4 @@\n+inline ObjectMonitor* ObjectSynchronizer::read_monitor(Thread* current, oop obj) {\n+  return ObjectSynchronizer::read_monitor(current, obj, obj->mark());\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -577,0 +577,4 @@\n+bool Thread::TrySpinAcquire(volatile int * adr) {\n+  return AtomicAccess::cmpxchg(adr, 0, 1) == 0;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -612,0 +612,1 @@\n+  static bool TrySpinAcquire(volatile int * adr);\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -407,0 +407,1 @@\n+  initialize_class(vmSymbols::jdk_internal_vm_PreemptedException(), CHECK);\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -65,0 +65,2 @@\n+  assert(_pending_exception == nullptr || !_pending_exception->is_a(vmClasses::PreemptedException_klass()),\n+         \"unexpected PreemptedException, missing NoPreemptMark?\");\n@@ -85,0 +87,24 @@\n+void ThreadShadow::set_pending_preempted_exception() {\n+  assert(!has_pending_exception(), \"\");\n+  \/\/ We always install the same pre-allocated exception since we only\n+  \/\/ want to use the TRAPS mechanism to bail out from all methods until\n+  \/\/ reaching the one using the CHECK_AND_CLEAR_PREEMPTED macro.\n+  set_pending_exception(Universe::preempted_exception_instance(), __FILE__, __LINE__);\n+}\n+\n+void ThreadShadow::clear_pending_preempted_exception() {\n+  assert(has_pending_exception(), \"\");\n+  if (pending_exception()->is_a(vmClasses::PreemptedException_klass())) {\n+    _pending_exception = nullptr;\n+    _exception_file    = nullptr;\n+    _exception_line    = 0;\n+  }\n+}\n+\n+#ifdef ASSERT\n+void ThreadShadow::check_preempted_exception() {\n+  assert(has_pending_exception(), \"\");\n+  assert(pending_exception()->is_a(vmClasses::PreemptedException_klass()), \"should only be PreemptedException\");\n+}\n+#endif\n+\n@@ -320,0 +346,5 @@\n+    \/\/ We could get here while linking or initializing a klass\n+    \/\/ from a preemptable call. Don't preempt here since before\n+    \/\/ the exception is propagated we might make an upcall to\n+    \/\/ Java to initialize the object with the cause of exception.\n+    NoPreemptMark npm(thread);\n","filename":"src\/hotspot\/share\/utilities\/exceptions.cpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -97,0 +97,4 @@\n+  void set_pending_preempted_exception();\n+  void clear_pending_preempted_exception();\n+  void check_preempted_exception() NOT_DEBUG_RETURN;\n+\n@@ -233,0 +237,2 @@\n+#define CHECK_PREEMPTABLE                        THREAD); if (HAS_PENDING_EXCEPTION) { THREAD->check_preempted_exception(); return;       } (void)(0\n+#define CHECK_PREEMPTABLE_false                  THREAD); if (HAS_PENDING_EXCEPTION) { THREAD->check_preempted_exception(); return false; } (void)(0\n@@ -252,0 +258,4 @@\n+#define CLEAR_PENDING_PREEMPTED_EXCEPTION       (((ThreadShadow*)THREAD)->clear_pending_preempted_exception())\n+#define CHECK_AND_CLEAR_PREEMPTED               THREAD); if (HAS_PENDING_EXCEPTION) { CLEAR_PENDING_PREEMPTED_EXCEPTION; return; } (void)(0\n+\n+\n","filename":"src\/hotspot\/share\/utilities\/exceptions.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -646,0 +646,6 @@\n+#if defined(AARCH64) || defined(AMD64) || defined(RISCV64)\n+#define PREEMPT_ON_INIT_SUPPORTED_ONLY(code) code\n+#else\n+#define PREEMPT_ON_INIT_SUPPORTED_ONLY(code)\n+#endif\n+\n","filename":"src\/hotspot\/share\/utilities\/macros.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -171,0 +171,3 @@\n+    \/\/ true when waiting in Object.wait, false for VM internal uninterruptible Object.wait\n+    private volatile boolean interruptibleWait;\n+\n@@ -602,0 +605,1 @@\n+            boolean interruptible = interruptibleWait;\n@@ -631,1 +635,1 @@\n-            if (interrupted && compareAndSetState(newState, UNBLOCKED)) {\n+            if (interruptible && interrupted && compareAndSetState(newState, UNBLOCKED)) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.vm;\n+\n+\/**\n+ * Internal exception used only by the VM.\n+ *\/\n+public class PreemptedException extends RuntimeException {\n+    @java.io.Serial\n+    private static final long serialVersionUID = 6700691236100628123L;\n+\n+    \/**\n+     * Constructs an {@code PreemptedException} with no detail  message.\n+     *\/\n+    public PreemptedException() {\n+        super();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/PreemptedException.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -105,1 +105,1 @@\n-    ol.wait(THREAD);\n+    ol.wait_uninterruptibly(THREAD);\n","filename":"test\/hotspot\/gtest\/oops\/test_markWord.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -305,1 +305,1 @@\n-     * Test jdk.VirtualThreadPinned event when waiting for a class initializer.\n+     * Test jdk.VirtualThreadPinned event when waiting for a class initializer while pinned.\n@@ -308,1 +308,1 @@\n-    void testWaitingForClassInitializer() throws Exception {\n+    void testWaitingForClassInitializerWhenPinned() throws Exception {\n@@ -331,1 +331,3 @@\n-                TestClass.m();\n+                VThreadPinner.runPinned(() -> {\n+                    TestClass.m();\n+                });\n@@ -344,1 +346,1 @@\n-                \/\/ give time for second virtual thread to wait on the MutexLocker\n+                \/\/ give time for second virtual thread to wait in VM\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/JfrEvents.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,489 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=default\n+ * @library \/test\/lib\n+ * @requires vm.continuations\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n+ * @run junit\/othervm\/timeout=480 -XX:CompileCommand=exclude,KlassInit::lambda$testReleaseAtKlassInit* -XX:CompileCommand=exclude,KlassInit$$Lambda*::run -XX:CompileCommand=exclude,KlassInit$1Driver::foo KlassInit\n+ *\/\n+\n+\/*\n+ * @test id=Xint\n+ * @library \/test\/lib\n+ * @requires vm.continuations\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n+ * @run junit\/othervm\/timeout=480 -Xint -XX:CompileCommand=exclude,KlassInit::lambda$testReleaseAtKlassInit* -XX:CompileCommand=exclude,KlassInit$$Lambda*::run -XX:CompileCommand=exclude,KlassInit$1Driver::foo KlassInit\n+ *\/\n+\n+\/*\n+ * @test id=Xcomp\n+ * @library \/test\/lib\n+ * @requires vm.continuations\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n+ * @run junit\/othervm\/timeout=480 -Xcomp -XX:CompileCommand=exclude,KlassInit::lambda$testReleaseAtKlassInit* -XX:CompileCommand=exclude,KlassInit$$Lambda*::run -XX:CompileCommand=exclude,KlassInit$1Driver::foo KlassInit\n+ *\/\n+\n+\/*\n+ * @test id=Xcomp-TieredStopAtLevel1\n+ * @library \/test\/lib\n+ * @requires vm.continuations\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n+ * @run junit\/othervm\/timeout=480 -Xcomp -XX:TieredStopAtLevel=1 -XX:CompileCommand=exclude,KlassInit::lambda$testReleaseAtKlassInit* -XX:CompileCommand=exclude,KlassInit$$Lambda*::run -XX:CompileCommand=exclude,KlassInit$1Driver::foo KlassInit\n+ *\/\n+\n+\/*\n+ * @test id=Xcomp-noTieredCompilation\n+ * @library \/test\/lib\n+ * @requires vm.continuations\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n+ * @run junit\/othervm\/timeout=480 -Xcomp -XX:-TieredCompilation -XX:CompileCommand=exclude,KlassInit::lambda$testReleaseAtKlassInit* -XX:CompileCommand=exclude,KlassInit$$Lambda*::run -XX:CompileCommand=exclude,KlassInit$1Driver::foo KlassInit\n+ *\/\n+\n+\/*\n+ * @test id=gc\n+ * @library \/test\/lib\n+ * @requires vm.debug == true & vm.continuations\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n+ * @run junit\/othervm\/timeout=480 -XX:+UnlockDiagnosticVMOptions -XX:+FullGCALot -XX:FullGCALotInterval=1000 -XX:CompileCommand=exclude,KlassInit::lambda$testReleaseAtKlassInit* -XX:CompileCommand=exclude,KlassInit$$Lambda*::run -XX:CompileCommand=exclude,KlassInit$1Driver::foo KlassInit\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.stream.Stream;\n+import java.util.stream.Collectors;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.Arguments;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class KlassInit {\n+    private static final int MAX_VTHREAD_COUNT = 8 * Runtime.getRuntime().availableProcessors();\n+\n+    private static final CountDownLatch finishInvokeStatic1 = new CountDownLatch(1);\n+    private static final CountDownLatch finishInvokeStatic2 = new CountDownLatch(1);\n+    private static final CountDownLatch finishInvokeStatic3 = new CountDownLatch(1);\n+    private static final CountDownLatch finishNew = new CountDownLatch(1);\n+    private static final CountDownLatch finishGetStatic = new CountDownLatch(1);\n+    private static final CountDownLatch finishPutStatic = new CountDownLatch(1);\n+    private static final CountDownLatch finishFailedInit = new CountDownLatch(1);\n+\n+    \/**\n+     * Test that threads blocked waiting for klass to be initialized\n+     * on invokestatic bytecode release the carrier.\n+     *\/\n+    @Test\n+    void testReleaseAtKlassInitInvokeStatic1() throws Exception {\n+        class TestClass {\n+            static {\n+                try {\n+                    finishInvokeStatic1.await();\n+                } catch (InterruptedException e) {}\n+            }\n+            static void m() {\n+            }\n+        }\n+\n+        Thread[] vthreads = new Thread[MAX_VTHREAD_COUNT];\n+        CountDownLatch[] started = new CountDownLatch[MAX_VTHREAD_COUNT];\n+        for (int i = 0; i < MAX_VTHREAD_COUNT; i++) {\n+            final int id = i;\n+            started[i] = new CountDownLatch(1);\n+            vthreads[i] = Thread.ofVirtual().start(() -> {\n+                started[id].countDown();\n+                TestClass.m();\n+            });\n+        }\n+        for (int i = 0; i < MAX_VTHREAD_COUNT; i++) {\n+            started[i].await();\n+            await(vthreads[i], Thread.State.WAITING);\n+        }\n+\n+        finishInvokeStatic1.countDown();\n+        for (int i = 0; i < MAX_VTHREAD_COUNT; i++) {\n+            vthreads[i].join();\n+        }\n+    }\n+\n+    \/**\n+     * Test with static method that takes arguments.\n+     *\/\n+    @Test\n+    void testReleaseAtKlassInitInvokeStatic2() throws Exception {\n+        class TestClass {\n+            static {\n+                try {\n+                    finishInvokeStatic2.await();\n+                } catch (InterruptedException e) {}\n+            }\n+            static void m(ArrayList<String> list, int id) {\n+                String str = list.get(0);\n+                if (str != null && str.equals(\"VThread#\" + id)) {\n+                    list.add(\"Success\");\n+                }\n+            }\n+        }\n+\n+        Thread[] vthreads = new Thread[MAX_VTHREAD_COUNT];\n+        CountDownLatch[] started = new CountDownLatch[MAX_VTHREAD_COUNT];\n+        ArrayList<String>[] lists = new ArrayList[MAX_VTHREAD_COUNT];\n+        for (int i = 0; i < MAX_VTHREAD_COUNT; i++) {\n+            final int id = i;\n+            started[i] = new CountDownLatch(1);\n+            lists[i] = new ArrayList<>(List.of(\"VThread#\" + i));\n+            vthreads[i] = Thread.ofVirtual().start(() -> {\n+                started[id].countDown();\n+                TestClass.m(lists[id], id);\n+            });\n+        }\n+        for (int i = 0; i < MAX_VTHREAD_COUNT; i++) {\n+            started[i].await();\n+            await(vthreads[i], Thread.State.WAITING);\n+        }\n+\n+        System.gc();\n+        finishInvokeStatic2.countDown();\n+        for (int i = 0; i < MAX_VTHREAD_COUNT; i++) {\n+            vthreads[i].join();\n+            assertEquals(lists[i].get(1), \"Success\");\n+        }\n+    }\n+\n+    \/**\n+     * Test invokestatic as first bytecode in method.\n+     *\/\n+    @Test\n+    void testReleaseAtKlassInitInvokeStatic3() throws Exception {\n+        class TestClass {\n+            static {\n+                try {\n+                    finishInvokeStatic3.await();\n+                } catch (InterruptedException e) {}\n+            }\n+            static void m() {\n+            }\n+        }\n+        class Driver {\n+            static void foo() {\n+                TestClass.m();\n+            }\n+        }\n+\n+        Thread[] vthreads = new Thread[MAX_VTHREAD_COUNT];\n+        CountDownLatch[] started = new CountDownLatch[MAX_VTHREAD_COUNT];\n+        started[0] = new CountDownLatch(1);\n+        vthreads[0] = Thread.ofVirtual().start(() -> {\n+            started[0].countDown();\n+            TestClass.m();\n+        });\n+        started[0].await();\n+        await(vthreads[0], Thread.State.WAITING);\n+\n+        for (int i = 1; i < MAX_VTHREAD_COUNT; i++) {\n+            final int id = i;\n+            started[i] = new CountDownLatch(1);\n+            vthreads[i] = Thread.ofVirtual().start(() -> {\n+                started[id].countDown();\n+                Driver.foo();\n+            });\n+        }\n+        for (int i = 1; i < MAX_VTHREAD_COUNT; i++) {\n+            started[i].await();\n+            await(vthreads[i], Thread.State.WAITING);\n+        }\n+\n+        finishInvokeStatic3.countDown();\n+        for (int i = 0; i < MAX_VTHREAD_COUNT; i++) {\n+            vthreads[i].join();\n+        }\n+    }\n+\n+    \/**\n+     * Test that threads blocked waiting for klass to be initialized\n+     * on new bytecode release the carrier.\n+     *\/\n+    @Test\n+    void testReleaseAtKlassInitNew() throws Exception {\n+        class TestClass {\n+            static {\n+                try {\n+                    finishNew.await();\n+                } catch (InterruptedException e) {}\n+            }\n+            void m() {\n+            }\n+        }\n+\n+        Thread[] vthreads = new Thread[MAX_VTHREAD_COUNT];\n+        CountDownLatch[] started = new CountDownLatch[MAX_VTHREAD_COUNT];\n+        for (int i = 0; i < MAX_VTHREAD_COUNT; i++) {\n+            final int id = i;\n+            started[i] = new CountDownLatch(1);\n+            vthreads[i] = Thread.ofVirtual().start(() -> {\n+                started[id].countDown();\n+                TestClass x = new TestClass();\n+                x.m();\n+            });\n+        }\n+        for (int i = 0; i < MAX_VTHREAD_COUNT; i++) {\n+            started[i].await();\n+            await(vthreads[i], Thread.State.WAITING);\n+        }\n+\n+        finishNew.countDown();\n+        for (int i = 0; i < MAX_VTHREAD_COUNT; i++) {\n+            vthreads[i].join();\n+        }\n+    }\n+\n+    \/**\n+     * Test that threads blocked waiting for klass to be initialized\n+     * on getstatic bytecode release the carrier.\n+     *\/\n+    @Test\n+    void testReleaseAtKlassInitGetStatic() throws Exception {\n+        class TestClass {\n+            static {\n+                try {\n+                    finishGetStatic.await();\n+                } catch (InterruptedException e) {}\n+            }\n+            public static int NUMBER = 150;\n+        }\n+\n+        Thread[] vthreads = new Thread[MAX_VTHREAD_COUNT];\n+        CountDownLatch[] started = new CountDownLatch[MAX_VTHREAD_COUNT];\n+        AtomicInteger[] result = new AtomicInteger[MAX_VTHREAD_COUNT];\n+        for (int i = 0; i < MAX_VTHREAD_COUNT; i++) {\n+            final int id = i;\n+            started[i] = new CountDownLatch(1);\n+            result[i] = new AtomicInteger();\n+            vthreads[i] = Thread.ofVirtual().start(() -> {\n+                started[id].countDown();\n+                result[id].set(TestClass.NUMBER);\n+            });\n+        }\n+        for (int i = 0; i < MAX_VTHREAD_COUNT; i++) {\n+            started[i].await();\n+            await(vthreads[i], Thread.State.WAITING);\n+        }\n+\n+        finishGetStatic.countDown();\n+        for (int i = 0; i < MAX_VTHREAD_COUNT; i++) {\n+            vthreads[i].join();\n+            assertEquals(result[i].get(), TestClass.NUMBER);\n+        }\n+    }\n+\n+    \/**\n+     * Test that threads blocked waiting for klass to be initialized\n+     * on putstatic release the carrier.\n+     *\/\n+    @Test\n+    void testReleaseAtKlassInitPutStatic() throws Exception {\n+        class TestClass {\n+            static {\n+                try {\n+                    finishPutStatic.await();\n+                } catch (InterruptedException e) {}\n+            }\n+            public static int NUMBER;\n+        }\n+\n+        Thread[] vthreads = new Thread[MAX_VTHREAD_COUNT];\n+        CountDownLatch[] started = new CountDownLatch[MAX_VTHREAD_COUNT];\n+        for (int i = 0; i < MAX_VTHREAD_COUNT; i++) {\n+            final int id = i;\n+            started[i] = new CountDownLatch(1);\n+            vthreads[i] = Thread.ofVirtual().start(() -> {\n+                started[id].countDown();\n+                TestClass.NUMBER = id;\n+            });\n+        }\n+        for (int i = 0; i < MAX_VTHREAD_COUNT; i++) {\n+            started[i].await();\n+            await(vthreads[i], Thread.State.WAITING);\n+        }\n+\n+        finishPutStatic.countDown();\n+        for (int i = 0; i < MAX_VTHREAD_COUNT; i++) {\n+            vthreads[i].join();\n+        }\n+    }\n+\n+    \/**\n+     * Test that interruptions during preemption on klass init\n+     * are preserved.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"interruptTestCases\")\n+    void testReleaseAtKlassInitPreserverInterrupt(int timeout, Runnable m, CountDownLatch finish) throws Exception {\n+        \/\/ Start vthread1 and wait until it blocks in TestClassX initializer\n+        var vthread1_started = new CountDownLatch(1);\n+        var vthread1 = Thread.ofVirtual().start(() -> {\n+                vthread1_started.countDown();\n+                m.run();\n+            });\n+        vthread1_started.await();\n+        await(vthread1, Thread.State.WAITING);\n+\n+        \/\/ Start vthread2 and wait until it gets preempted on TestClassX initialization\n+        var lock = new Object();\n+        var interruptedException = new AtomicBoolean();\n+        var vthread2_started = new CountDownLatch(1);\n+        var vthread2 = Thread.ofVirtual().start(() -> {\n+                vthread2_started.countDown();\n+                m.run();\n+                synchronized (lock) {\n+                    try {\n+                        if (timeout > 0) {\n+                            lock.wait(timeout);\n+                        } else {\n+                            lock.wait();\n+                        }\n+                    } catch (InterruptedException e) {\n+                        \/\/ check stack trace has the expected frames\n+                        Set<String> expected = Set.of(\"wait0\", \"wait\", \"run\");\n+                        Set<String> methods = Stream.of(e.getStackTrace())\n+                                .map(StackTraceElement::getMethodName)\n+                                .collect(Collectors.toSet());\n+                        assertTrue(methods.containsAll(expected));\n+                        interruptedException.set(true);\n+                    }\n+                }\n+            });\n+        vthread2_started.await();\n+        await(vthread2, Thread.State.WAITING);\n+\n+        \/\/ Interrupt vthread2 and let initialization of TestClassX finish\n+        vthread2.interrupt();\n+        finish.countDown();\n+        vthread1.join();\n+        vthread2.join();\n+        assertTrue(interruptedException.get());\n+    }\n+\n+    static CountDownLatch finishInterrupt0 = new CountDownLatch(1);\n+    class TestClass0 {\n+        static {\n+            try {\n+                finishInterrupt0.await();\n+            } catch (InterruptedException e) {}\n+        }\n+        static void m() {}\n+    }\n+\n+    static CountDownLatch finishInterrupt30000 = new CountDownLatch(1);\n+    class TestClass30000 {\n+        static {\n+            try {\n+                finishInterrupt30000.await();\n+            } catch (InterruptedException e) {}\n+        }\n+        static void m() {}\n+    }\n+\n+    static CountDownLatch finishInterruptMax = new CountDownLatch(1);\n+    class TestClassMax {\n+        static {\n+            try {\n+                finishInterruptMax.await();\n+            } catch (InterruptedException e) {}\n+        }\n+        static void m() {}\n+    }\n+\n+    static Stream<Arguments> interruptTestCases() {\n+        return Stream.of(\n+            Arguments.of(0, (Runnable) TestClass0::m, finishInterrupt0),\n+            Arguments.of(30000, (Runnable) TestClass30000::m, finishInterrupt30000),\n+            Arguments.of(Integer.MAX_VALUE, (Runnable) TestClassMax::m, finishInterruptMax)\n+        );\n+    }\n+\n+    \/**\n+     * Test case of threads blocked waiting for klass to be initialized\n+     * when the klass initialization fails.\n+     *\/\n+    @Test\n+    void testReleaseAtKlassInitFailedInit() throws Exception {\n+        class TestClass {\n+            static int[] a = {1, 2, 3};\n+            static {\n+                try {\n+                    finishFailedInit.await();\n+                    a[3] = 4;\n+                } catch (InterruptedException e) {}\n+            }\n+            static void m() {\n+            }\n+        }\n+\n+        Thread[] vthreads = new Thread[MAX_VTHREAD_COUNT];\n+        CountDownLatch[] started = new CountDownLatch[MAX_VTHREAD_COUNT];\n+        AtomicInteger failedCount = new AtomicInteger();\n+        for (int i = 0; i < MAX_VTHREAD_COUNT; i++) {\n+            final int id = i;\n+            started[i] = new CountDownLatch(1);\n+            vthreads[i] = Thread.ofVirtual().start(() -> {\n+                started[id].countDown();\n+                try {\n+                    TestClass.m();\n+                } catch (NoClassDefFoundError e) {\n+                    failedCount.getAndIncrement();\n+                } catch (ExceptionInInitializerError e) {\n+                    failedCount.getAndIncrement();\n+                }\n+            });\n+        }\n+        for (int i = 0; i < MAX_VTHREAD_COUNT; i++) {\n+            started[i].await();\n+            await(vthreads[i], Thread.State.WAITING);\n+        }\n+\n+        finishFailedInit.countDown();\n+        for (int i = 0; i < MAX_VTHREAD_COUNT; i++) {\n+            vthreads[i].join();\n+        }\n+        assertEquals(MAX_VTHREAD_COUNT, failedCount.get());\n+    }\n+\n+    \/**\n+     * Waits for the given thread to reach a given state.\n+     *\/\n+    private void await(Thread thread, Thread.State expectedState) throws InterruptedException {\n+        Thread.State state = thread.getState();\n+        while (state != expectedState) {\n+            assertTrue(state != Thread.State.TERMINATED, \"Thread has terminated\");\n+            Thread.sleep(10);\n+            state = thread.getState();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/KlassInit.java","additions":489,"deletions":0,"binary":false,"changes":489,"status":"added"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -37,0 +38,1 @@\n+import org.junit.jupiter.api.BeforeAll;\n@@ -41,0 +43,6 @@\n+    @BeforeAll\n+    static void setup() throws Exception {\n+        \/\/ waiting for LockSupport to be initialized can change the scheduling\n+        MethodHandles.lookup().ensureInitialized(LockSupport.class);\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/YieldQueuing.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run main LotsOfContendedMonitorEnter\n+ * @run main\/timeout=480 LotsOfContendedMonitorEnter\n@@ -31,0 +31,2 @@\n+import java.time.Instant;\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -35,0 +37,1 @@\n+    static int depth;\n@@ -37,1 +40,0 @@\n-        int depth;\n@@ -43,1 +45,11 @@\n-        VThreadRunner.run(() -> testContendedEnter(depth));\n+\n+        var exRef = new AtomicReference<Throwable>();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            try {\n+                testContendedEnter(depth);\n+            } catch (Exception e) {\n+                exRef.set(e);\n+            }\n+        });\n+        thread.join();\n+        assert exRef.get() == null;\n@@ -51,0 +63,1 @@\n+        boolean doLog = depthRemaining % 10 == 0;\n@@ -84,0 +97,3 @@\n+                    if (doLog) {\n+                        System.out.println(Instant.now() + \" => at depth: \" + (depth - depthRemaining));\n+                    }\n@@ -90,0 +106,3 @@\n+        if (doLog) {\n+            System.out.println(Instant.now() + \" => returning from depth: \" + (depth - depthRemaining));\n+        }\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/LotsOfContendedMonitorEnter.java","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"}]}