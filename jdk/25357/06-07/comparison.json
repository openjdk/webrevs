{"files":[{"patch":"@@ -1118,1 +1118,9 @@\n-    heap->free_set()->rebuild();\n+\n+    \/\/ We also do not expand old generation size following Full GC because we have scrambled age populations and\n+    \/\/ no longer have objects separated by age into distinct regions.\n+    size_t young_cset_regions, old_cset_regions, first_old, last_old, num_old;\n+    heap->free_set()->prepare_to_rebuild(young_cset_regions, old_cset_regions, first_old, last_old, num_old);\n+    if (heap->mode()->is_generational()) {\n+      ShenandoahGenerationalFullGC::compute_balances();\n+    }\n+    heap->free_set()->finish_rebuild(young_cset_regions, old_cset_regions, num_old);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -814,1 +814,14 @@\n-    heap->free_set()->rebuild();\n+\n+    \/\/ We are preparing for evacuation.  At this time, we ignore cset region tallies.\n+    size_t young_cset_regions, old_cset_regions, first_old, last_old, num_old;\n+    _free_set->prepare_to_rebuild(young_cset_regions, old_cset_regions, first_old, last_old, num_old);\n+    if (heap->mode()->is_generational()) {\n+      ShenandoahGenerationalHeap* gen_heap = ShenandoahGenerationalHeap::heap();\n+      \/\/ We know that old is large enough to represent any evacuations that are directed to Old.  If we ended up budgeting\n+      \/\/ more memory for old than is required by the chosen collection set, this is our opportunity to transfer some\n+      \/\/ regions from old to mutator in order to expand the allocation runway.\n+      size_t mutator_xfer_limit = 0;\n+      gen_heap->compute_old_generation_balance(mutator_xfer_limit, old_cset_regions, young_cset_regions);\n+    }\n+    \/\/ Free set construction uses reserve quantities, because they are known to be valid here\n+    _free_set->finish_rebuild(young_cset_regions, old_cset_regions, num_old);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -151,0 +151,9 @@\n+void ShenandoahGenerationalFullGC::compute_balances() {\n+  auto heap = ShenandoahGenerationalHeap::heap();\n+\n+  \/\/ In case this Full GC resulted from degeneration, clear the tally on anticipated promotion.\n+  heap->old_generation()->set_promotion_potential(0);\n+  \/\/ Invoke this in case we are able to transfer memory from OLD to YOUNG.\n+  heap->compute_old_generation_balance(0, 0, 0);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalFullGC.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -438,1 +438,13 @@\n-    _free_set->rebuild();\n+\n+    \/\/ We are initializing free set.  We ignore cset region tallies.\n+    size_t young_cset_regions, old_cset_regions, first_old, last_old, num_old;\n+    _free_set->prepare_to_rebuild(young_cset_regions, old_cset_regions, first_old, last_old, num_old);\n+    if (mode()->is_generational()) {\n+      ShenandoahGenerationalHeap* gen_heap = ShenandoahGenerationalHeap::heap();\n+      \/\/ We cannot call\n+      \/\/  gen_heap->young_generation()->heuristics()->bytes_of_allocation_runway_before_gc_trigger(young_cset_regions)\n+      \/\/ until after the heap is fully initialized.  So we make up a safe value here.\n+      size_t allocation_runway = InitialHeapSize \/ 2;\n+      gen_heap->compute_old_generation_balance(allocation_runway, old_cset_regions, young_cset_regions);\n+    }\n+    _free_set->finish_rebuild(young_cset_regions, old_cset_regions, num_old);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"}]}