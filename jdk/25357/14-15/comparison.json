{"files":[{"patch":"@@ -37,0 +37,4 @@\n+#undef KELVIN_DEBUG\n+#ifdef KELVIN_DEBUG\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n+#endif\n@@ -106,0 +110,7 @@\n+#undef KELVIN_DEBUG\n+#ifdef KELVIN_DEBUG\n+  ShenandoahYoungGeneration* young_gen = ShenandoahHeap::heap()->young_generation();\n+  log_info(gc)(\"ShenAdaptiveHeuristics::choose_collection_set_from_regiondata(), young available_with_reserve(): %zu\",\n+               young_gen->available_with_reserve());\n+#endif\n+\n@@ -126,0 +137,4 @@\n+#ifdef KELVIN_DEBUG\n+      log_info(gc)(\" after adding region %zu to cset with live_data: %zu, garbage: %zu, young available_with_reserve: %zu\",\n+                   r->index(), r->get_live_data_bytes(), r->garbage(), young_gen->available_with_reserve());\n+#endif\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-void ShenandoahGenerationalHeuristics::choose_collection_set(ShenandoahCollectionSet* collection_set) {\n+ssize_t ShenandoahGenerationalHeuristics::choose_collection_set(ShenandoahCollectionSet* collection_set) {\n@@ -66,0 +66,4 @@\n+#undef KELVIN_DEBUG\n+#ifdef KELVIN_DEBUG\n+  log_info(gc)(\"ShenandoahGenerationalHeuristics::choose_collection_set()\");\n+#endif\n@@ -173,0 +177,6 @@\n+#ifdef KELVIN_DEBUG\n+  log_info(gc)(\" choose_collection_set() finds doing_promote_in_place: %s, preselected_candidates: %zu, immediate_percent: %zu\",\n+               doing_promote_in_place? \"true\": \"false\", preselected_candidates, immediate_percent);\n+#endif\n+\n+  ssize_t regions_to_xfer = 0;\n@@ -188,1 +198,1 @@\n-      need_to_finalize_mixed |= heap->old_generation()->heuristics()->top_off_collection_set();\n+      need_to_finalize_mixed |= heap->old_generation()->heuristics()->top_off_collection_set(regions_to_xfer);\n@@ -209,0 +219,1 @@\n+  return regions_to_xfer;\n@@ -225,7 +236,0 @@\n-\n-      \/\/ r->used() is r->garbage() + r->get_live_data_bytes()\n-      \/\/ Since all live data in this region is being evacuated from young-gen, it is as if this memory\n-      \/\/ is garbage insofar as young-gen is concerned.  Counting this as garbage reduces the need to\n-      \/\/ reclaim highly utilized young-gen regions just for the sake of finding min_garbage to reclaim\n-      \/\/ within young-gen memory.\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahGenerationalHeuristics.cpp","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-  void choose_collection_set(ShenandoahCollectionSet* collection_set) override;\n+  ssize_t choose_collection_set(ShenandoahCollectionSet* collection_set) override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahGenerationalHeuristics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-void ShenandoahHeuristics::choose_collection_set(ShenandoahCollectionSet* collection_set) {\n+ssize_t ShenandoahHeuristics::choose_collection_set(ShenandoahCollectionSet* collection_set) {\n@@ -99,0 +99,4 @@\n+#undef KELVIN_DEBUG\n+#ifdef KELVIN_DEBUG\n+  log_info(gc)(\"ShenandoahHeuristics::choose_collection_set()\");\n+#endif\n@@ -153,0 +157,3 @@\n+#ifdef KELVIN_DEBUG\n+  log_info(gc)(\" choose_collection_set() finds immediate_percent: %zu\", immediate_percent);\n+#endif\n@@ -156,1 +163,0 @@\n-\n@@ -158,0 +164,1 @@\n+  return 0;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -229,1 +229,1 @@\n-  virtual void choose_collection_set(ShenandoahCollectionSet* collection_set);\n+  virtual ssize_t choose_collection_set(ShenandoahCollectionSet* collection_set);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -86,0 +86,5 @@\n+#undef KELVIN_DEBUG\n+#ifdef KELVIN_DEBUG\n+  log_info(gc)(\"prime_collection_set(), %s preparing for mark\",  _old_generation->is_preparing_for_mark()? \"is\": \"is not\");\n+#endif\n+\n@@ -107,1 +112,1 @@\n-  \/\/ if fragmented_available is non-zero, excess_fragmented_available represents the amount of fragmented memory\n+  \/\/ if fragmented_available is non-zero, excess_fragmented_old_budget represents the amount of fragmented memory\n@@ -109,1 +114,1 @@\n-  \/\/ are added into the collection set, their free memory is subtracted from excess_fragmented_available until the\n+  \/\/ are added into the collection set, their free memory is subtracted from excess_fragmented_old_budget until the\n@@ -118,3 +123,7 @@\n-    _unfragmented_available = _old_evacuation_budget;\n-    _fragmented_available = 0;\n-    _excess_fragmented_available = 0;\n+    _unspent_unfragmented_old_budget = _old_evacuation_budget;\n+    _unspent_fragmented_old_budget = 0;\n+#ifdef KELVIN_DEBUG\n+    log_info(gc)(\" setting _unspent_unfragmented_old_budget to %zu, _unspent_fragmented_old_budget to zero\",\n+                 _unspent_unfragmented_old_budget);\n+#endif\n+    _excess_fragmented_old_budget = 0;\n@@ -126,2 +135,2 @@\n-      _excess_fragmented_available = (affiliated_available + unaffiliated_available) - _old_evacuation_reserve;\n-      affiliated_available -= _excess_fragmented_available;\n+      _excess_fragmented_old_budget = (affiliated_available + unaffiliated_available) - _old_evacuation_reserve;\n+      affiliated_available -= _excess_fragmented_old_budget;\n@@ -129,2 +138,10 @@\n-    _fragmented_available = (size_t) ((double) affiliated_available \/ ShenandoahOldEvacWaste);\n-    _unfragmented_available = (size_t) ((double) unaffiliated_available \/ ShenandoahOldEvacWaste);\n+    _unspent_fragmented_old_budget = (size_t) ((double) affiliated_available \/ ShenandoahOldEvacWaste);\n+    _unspent_unfragmented_old_budget = (size_t) ((double) unaffiliated_available \/ ShenandoahOldEvacWaste);\n+#ifdef KELVIN_DEBUG\n+    log_info(gc)(\"               _old_evacuation_reserve: %zu\", _old_evacuation_reserve);\n+    log_info(gc)(\"                  affiliated_available: %zu\", affiliated_available);\n+    log_info(gc)(\"        _unspent_fragmented_old_budget: %zu\", _unspent_fragmented_old_budget);\n+    log_info(gc)(\"                unaffiliated_available: %zu\", unaffiliated_available);\n+    log_info(gc)(\"      _unspent_unfragmented_old_budget: %zu\", _unspent_unfragmented_old_budget);\n+    log_info(gc)(\"          _excess_fragmented_old_budget: %zu\", _excess_fragmented_old_budget);\n+#endif\n@@ -215,0 +232,12 @@\n+#undef KELVIN_DEBUG\n+#ifdef KELVIN_DEBUG\n+  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+  ShenandoahOldGeneration* old_gen = _heap->old_generation();\n+  log_info(gc)(\"add_old_regions_to_cset() with non-zero unprocessed candidates, old available: %zu\",\n+               old_gen->available());\n+  log_info(gc)(\"          _excess_fragmented_old_budget: %zu\", _excess_fragmented_old_budget);\n+  log_info(gc)(\"        _unspent_fragmented_old_budget: %zu\", _unspent_fragmented_old_budget);\n+  log_info(gc)(\"      _unspent_unfragmented_old_budget: %zu\", _unspent_unfragmented_old_budget);\n+  log_info(gc)(\"                  _evacuated_old_bytes: %zu\", _evacuated_old_bytes);\n+  log_info(gc)(\"                  _collected_old_bytes: %zu\", _collected_old_bytes);\n+#endif\n@@ -234,9 +263,6 @@\n-    if ((lost_available > 0) && (_excess_fragmented_available > 0)) {\n-      if (lost_available < _excess_fragmented_available) {\n-        _excess_fragmented_available -= lost_available;\n-        lost_available = 0;\n-      } else {\n-        lost_available -= _excess_fragmented_available;\n-        _excess_fragmented_available = 0;\n-      }\n-    }\n+#ifdef KELVIN_DEBUG\n+    log_info(gc)(\" Consider adding region: %zu, with live_bytes: %zu, garbage: %zu, and available: %zu\",\n+                 r->index(), live_data_for_evacuation, r->garbage(), lost_available);\n+    ssize_t delta = region_size_bytes - (live_data_for_evacuation + r->garbage() + lost_available);\n+    log_info(gc)(\" We expect that garbage plus live + lost_available is region_size_bytes, off by: %zd\", delta);\n+#endif\n@@ -246,4 +272,21 @@\n-    size_t scaled_loss = (size_t) ((double) lost_available \/ ShenandoahOldEvacWaste);\n-    if ((lost_available > 0) && (_fragmented_available > 0)) {\n-      if (scaled_loss < _fragmented_available) {\n-        _fragmented_available -= scaled_loss;\n+    ssize_t excess_delta = 0;\n+\n+    \/\/ We must decrease our mixed-evacuation budgets proportional to the lost available memory.  This memory that is no\n+    \/\/ longer available was likely \"promised\" to promotions, so we must decrease our mixed evacuations now.\n+    \/\/ (e.g. if we loose 14 bytes of available old memory, we must decrease the evacuation budget by 10 bytes.)\n+    size_t scaled_loss = (size_t) (((double) lost_available) \/ ShenandoahOldEvacWaste);\n+#ifdef KELVIN_DEBUG\n+    log_info(gc)(\" Computed scaled_loss: %zu\", scaled_loss);\n+#endif\n+    if (lost_available > 0) {\n+      \/\/ We need to subtract lost_available from our working evacuation budgets\n+      if (scaled_loss < _excess_fragmented_old_budget) {\n+        excess_delta -= scaled_loss;\n+        _excess_fragmented_old_budget -= scaled_loss;\n+      } else {\n+        excess_delta -= _excess_fragmented_old_budget;\n+        _excess_fragmented_old_budget = 0;\n+      }\n+\n+      if (scaled_loss < _unspent_fragmented_old_budget) {\n+        _unspent_fragmented_old_budget -= scaled_loss;\n@@ -251,0 +294,4 @@\n+#ifdef KELVIN_DEBUG\n+        log_info(gc)(\" Decrease _unspent_fragmented_old_budget by scaled_loss: %zu to yield: %zu\",\n+                     scaled_loss, _unspent_fragmented_old_budget);\n+#endif\n@@ -253,3 +300,23 @@\n-        scaled_loss -= _fragmented_available;\n-        fragmented_delta = -_fragmented_available;\n-        _fragmented_available = 0;\n+        scaled_loss -= _unspent_fragmented_old_budget;\n+        fragmented_delta = -_unspent_fragmented_old_budget;\n+        _unspent_fragmented_old_budget = 0;\n+#ifdef KELVIN_DEBUG\n+        log_info(gc)(\" Zeroing _unspent_fragmented_old_budget, scaled_loss is: %zu\", scaled_loss);\n+#endif\n+      }\n+\n+      if (scaled_loss < _unspent_unfragmented_old_budget) {\n+        _unspent_unfragmented_old_budget -= scaled_loss;\n+        unfragmented_delta = -scaled_loss;\n+#ifdef KELVIN_DEBUG\n+        log_info(gc)(\" Decrease _unspent_unfragmented_old_budget by scaled_loss: %zu to yield: %zu\",\n+                     scaled_loss, _unspent_unfragmented_old_budget);\n+#endif\n+        scaled_loss = 0;\n+      } else {\n+        scaled_loss -= _unspent_unfragmented_old_budget;\n+        fragmented_delta = -_unspent_unfragmented_old_budget;\n+        _unspent_unfragmented_old_budget = 0;\n+#ifdef KELVIN_DEBUG\n+        log_info(gc)(\" Zeroing _unspent_unfragmented_old_budget\");\n+#endif\n@@ -258,0 +325,1 @@\n+\n@@ -260,2 +328,6 @@\n-    if (evacuation_need < _unfragmented_available) {\n-      _unfragmented_available -= evacuation_need;;\n+    if (evacuation_need < _unspent_unfragmented_old_budget) {\n+      _unspent_unfragmented_old_budget -= evacuation_need;\n+#ifdef KELVIN_DEBUG\n+      log_info(gc)(\" Decrementing _unspent_unfragmented_old_budget by evacuation_need: %zu, yielding: %zu\",\n+                   evacuation_need, _unspent_unfragmented_old_budget);\n+#endif\n@@ -263,4 +335,7 @@\n-      if (_unfragmented_available > 0) {\n-        evacuation_need -= _unfragmented_available;\n-        unfragmented_delta = -_unfragmented_available;\n-        _unfragmented_available = 0;\n+      if (_unspent_unfragmented_old_budget > 0) {\n+        evacuation_need -= _unspent_unfragmented_old_budget;\n+        unfragmented_delta -= _unspent_unfragmented_old_budget;\n+        _unspent_unfragmented_old_budget = 0;\n+#ifdef KELVIN_DEBUG\n+        log_info(gc)(\" Zeroing _unspent_unfragmented_old_budget\");\n+#endif\n@@ -269,2 +344,5 @@\n-      if (_fragmented_available > evacuation_need) {\n-        _fragmented_available -= evacuation_need;\n+      if (_unspent_fragmented_old_budget > evacuation_need) {\n+        _unspent_fragmented_old_budget -= evacuation_need;\n+#ifdef KELVIN_DEBUG\n+        log_info(gc)(\" Decreasing _unspent_fragmented_old_budget by %zu to yield: %zu\", evacuation_need, _unspent_fragmented_old_budget);\n+#endif\n@@ -273,2 +351,9 @@\n-        _fragmented_available -= fragmented_delta;\n-        _unfragmented_available -= unfragmented_delta;\n+        _unspent_fragmented_old_budget -= fragmented_delta;\n+        _unspent_unfragmented_old_budget -= unfragmented_delta;\n+        _excess_fragmented_old_budget -= excess_delta;\n+#ifdef KELVIN_DEBUG\n+        log_info(gc)(\" Never mind, region %zu cannot be added to cset.  Breaking out of loop after ...\", r->index());\n+        log_info(gc)(\"    restoring _unspent_fragmented_old_budget to %zu\", _unspent_fragmented_old_budget);\n+        log_info(gc)(\"  restoring _unspent_unfragmented_old_budget to %zu\", _unspent_unfragmented_old_budget);\n+        log_info(gc)(\"     restoring _excess_fragmented_old_budget to %zu\", _excess_fragmented_old_budget);\n+#endif\n@@ -283,0 +368,6 @@\n+#ifdef KELVIN_DEBUG\n+    log_info(gc)(\" Successfully added region %zu to collection set, old_available is now: %zu\", r->index(),\n+                 old_gen->available());\n+    log_info(gc)(\" _evacuated_old_bytes is now %zu\", _evacuated_old_bytes);\n+    log_info(gc)(\" _collected_old_bytes is now %zu\", _collected_old_bytes);\n+#endif\n@@ -324,1 +415,1 @@\n-bool ShenandoahOldHeuristics::top_off_collection_set() {\n+bool ShenandoahOldHeuristics::top_off_collection_set(ssize_t &regions_to_xfer) {\n@@ -331,2 +422,4 @@\n-    size_t planned_young_evac =\n-      _mixed_evac_cset->get_live_bytes_in_untenurable_regions() + _mixed_evac_cset->get_live_bytes_in_tenurable_regions();\n+\n+    \/\/ We have budgeted to assure the live_bytes_in_tenurable_regions() get evacuated into old generation.  Young reserves\n+    \/\/ only for untenurable region evacuations.\n+    size_t planned_young_evac = _mixed_evac_cset->get_live_bytes_in_untenurable_regions();\n@@ -334,2 +427,1 @@\n-    size_t available_to_loan_from_young_reserve = ((consumed_from_young_cset >= max_young_cset)?\n-                                                   0: max_young_cset - consumed_from_young_cset);\n+\n@@ -337,2 +429,30 @@\n-    if ((young_unaffiliated_regions == 0) || (available_to_loan_from_young_reserve < region_size_bytes)) {\n-      return false;\n+    size_t regions_required_for_collector_reserve = (consumed_from_young_cset + region_size_bytes - 1) \/ region_size_bytes;\n+\n+#undef KELVIN_DEBUG\n+#ifdef KELVIN_DEBUG\n+    ShenandoahOldGeneration* old_gen = _heap->old_generation();\n+    log_info(gc)(\"top_off_collection_set(), young available with reserves: %zu\", old_gen->available());\n+    log_info(gc)(\" young unaffiliated regions: %zu, bytes: %zu\", young_unaffiliated_regions,\n+                 young_unaffiliated_regions * region_size_bytes);\n+    log_info(gc)(\" young evacuation reserve with waste: %zu\", max_young_cset);\n+    log_info(gc)(\" planed_young_evac: %zu, consumed_from_young_cset: %zu\", planned_young_evac, consumed_from_young_cset);\n+    log_info(gc)(\" regions required for collector reserve: %zu\", regions_required_for_collector_reserve);\n+#endif\n+\n+    assert(consumed_from_young_cset <= max_young_cset, \"sanity\");\n+    assert(max_young_cset <= young_unaffiliated_regions * region_size_bytes, \"sanity\");\n+\n+    size_t regions_for_old_expansion;\n+    if (consumed_from_young_cset < max_young_cset) {\n+      size_t excess_young_reserves = max_young_cset - consumed_from_young_cset;\n+      \/\/ We can only transfer empty regions from young to old.  Furthermore, we must be careful to assure that the young\n+      \/\/ Collector reserve that remains after transfer is comprised entirely of empty (unaffiliated) regions.\n+      size_t consumed_unaffiliated_regions = (consumed_from_young_cset + region_size_bytes - 1) \/ region_size_bytes;\n+      size_t available_unaffiliated_regions = ((young_unaffiliated_regions > consumed_unaffiliated_regions)?\n+                                               young_unaffiliated_regions - consumed_unaffiliated_regions: 0);\n+#ifdef KELVIN_DEBUG\n+      log_info(gc)(\" excess_young_reserves: %zu\", excess_young_reserves);\n+      log_info(gc)(\" consumed_unaffiliated_regions: %zu\", consumed_unaffiliated_regions);\n+      log_info(gc)(\" available_unaffiliated_regions: %zu\", available_unaffiliated_regions);\n+#endif\n+      regions_for_old_expansion = MIN2(available_unaffiliated_regions, excess_young_reserves \/ region_size_bytes);\n@@ -340,4 +460,6 @@\n-      size_t regions_for_old_expansion = (available_to_loan_from_young_reserve \/ region_size_bytes);\n-      if (regions_for_old_expansion > young_unaffiliated_regions) {\n-        regions_for_old_expansion = young_unaffiliated_regions;\n-      }\n+      regions_for_old_expansion = 0;\n+    }\n+#ifdef KELVIN_DEBUG\n+    log_info(gc)(\" regions_for_old_expansion: %zu\", regions_for_old_expansion);\n+#endif\n+    if (regions_for_old_expansion > 0) {\n@@ -346,0 +468,1 @@\n+      regions_to_xfer = regions_for_old_expansion;\n@@ -347,3 +470,10 @@\n-      size_t supplement_after_waste = (size_t) (((double) budget_supplement) \/ ShenandoahOldEvacWaste);\n-      _old_evacuation_budget += supplement_after_waste;\n-      _unfragmented_available += supplement_after_waste;\n+      size_t supplement_without_waste = (size_t) (((double) budget_supplement) \/ ShenandoahOldEvacWaste);\n+      _old_evacuation_budget += supplement_without_waste;\n+      _unspent_unfragmented_old_budget += supplement_without_waste;\n+#ifdef KELVIN_DEBUG\n+      log_info(gc)(\" budget_supplement: %zu, without waste: %zu\", budget_supplement, supplement_without_waste);\n+      log_info(gc)(\" expanded _old_evacuation_budget: %zu\", _old_evacuation_budget);\n+      log_info(gc)(\" expanded _unspent_unfragmented_old_budget: %zu\", _unspent_unfragmented_old_budget);\n+      log_info(gc)(\" aumgenting old_gen->evacuatino_reserve() by %zu\", budget_supplement);\n+      log_info(gc)(\" decreasing young_gen->evacuation_reserve() by the same\");\n+#endif\n@@ -355,0 +485,3 @@\n+    } else {\n+      regions_to_xfer = 0;\n+      return false;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":182,"deletions":49,"binary":false,"changes":231,"status":"modified"},{"patch":"@@ -115,3 +115,13 @@\n-  size_t _unfragmented_available;\n-  size_t _fragmented_available;\n-  size_t _excess_fragmented_available;\n+\n+  \/\/ This represents the amount of memory that can be evacuated from old into initially empty regions during a mixed evacuation.\n+  \/\/ This is the total amount of unfragmented free memory in old divided by ShenandoahOldEvacWaste.\n+  size_t _unspent_unfragmented_old_budget;\n+\n+  \/\/ This represents the amount of memory that can be evacuated from old into initially non-empty regions during a mixed\n+  \/\/ evacuation.  This is the total amount of initially fragmented free memory in old divided by ShenandoahOldEvacWaste.\n+  size_t _unspent_fragmented_old_budget;\n+\n+  \/\/ If there is more available memory in old than is required by the intended mixed evacuation, the amount of excess\n+  \/\/ memory is represented by _excess_fragmented_old.  To convert this value into a promotion budget, multiply by\n+  \/\/ ShenandoahOldEvacWaste and divide by ShenandoahPromoWaste.\n+  size_t _excess_fragmented_old_budget;\n@@ -159,2 +169,3 @@\n-  \/\/ Returns true iff we need to finalize mixed evacs.\n-  bool top_off_collection_set();\n+  \/\/ Returns true iff we need to finalize mixed evacs.  Upon return, the var parameter regions_to_xfer holds the\n+  \/\/ number of regions to transfer from young to old.\n+  bool top_off_collection_set(ssize_t &regions_to_xfer);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -53,0 +53,2 @@\n+  _young_available_bytes_collected(0),\n+  _old_available_bytes_collected(0),\n@@ -107,0 +109,1 @@\n+    _old_available_bytes_collected += free;\n@@ -143,0 +146,1 @@\n+  _old_available_bytes_collected = 0;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -78,0 +78,4 @@\n+  \/\/ When a region having memory available to be allocated is added to the collection set, the region's available memory\n+  \/\/ should be subtracted from what's available.\n+  size_t                _old_available_bytes_collected;\n+  \n@@ -124,0 +128,3 @@\n+  \/\/ Returns the amount of free bytes in old regions in the collection set.\n+  size_t get_old_available_bytes_collected() const { return _old_available_bytes_collected; }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2758,3 +2758,3 @@\n-  size_t young_cset_regions, old_cset_regions, first_old_region, last_old_region, old_region_count;\n-  prepare_to_rebuild(young_cset_regions, old_cset_regions, first_old_region, last_old_region, old_region_count);\n-  finish_rebuild(young_cset_regions, old_cset_regions, old_region_count);\n+  size_t young_trashed_regions, old_trashed_regions, first_old_region, last_old_region, old_region_count;\n+  prepare_to_rebuild(young_trashed_regions, old_trashed_regions, first_old_region, last_old_region, old_region_count);\n+  finish_rebuild(young_trashed_regions, old_trashed_regions, old_region_count);\n@@ -2850,1 +2850,1 @@\n-  size_t old_available = old_generation->available() + old_trashed_regions * region_size_bytes;\n+  size_t old_available = old_generation->available();\n@@ -2867,0 +2867,8 @@\n+#define KELVIN_DEBUG\n+#ifdef KELVIN_DEBUG\n+  log_info(gc)(\"compute_young_and_old_reserves(%zu, %zu)\", young_trashed_regions, old_trashed_regions);\n+  log_info(gc)(\"  (should have called compute_old_generation_balance() before here.\");\n+  log_info(gc)(\"   old_available: %zu (including %zu unaffiliated regions)\", old_available, old_unaffiliated_regions);\n+  log_info(gc)(\" young_available: %zu (including %zu unaffiliated regions)\", young_available, young_unaffiliated_regions);\n+#endif\n+\n@@ -2874,0 +2882,3 @@\n+#ifdef KELVIN_DEBUG\n+  log_info(gc)(\" old_region_balance is %zd\", old_region_balance);\n+#endif\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -739,2 +739,3 @@\n-  \/\/ young_cset_regions is the number of regions currently in the young cset if we are starting to evacuate, or zero\n-  \/\/   old_cset_regions is the number of regions currently in the old cset if we are starting a mixed evacuation, or zero\n+  \/\/ young_trashed_regions is the number of trashed regions (immediate garbage at final mark, cset regions after update refs)\n+  \/\/   old_trashed_regions is the number of trashed regions\n+  \/\/                       (immediate garbage at final old mark, cset regions after update refs for mixed evac)\n@@ -744,1 +745,1 @@\n-  void prepare_to_rebuild(size_t &young_cset_regions, size_t &old_cset_regions,\n+  void prepare_to_rebuild(size_t &young_trashed_regions, size_t &old_trashed_regions,\n@@ -751,1 +752,2 @@\n-  \/\/ old_collector sets to hold evacuations.\n+  \/\/ old_collector sets to hold evacuations.  Likewise, at the end of update refs, we rebuild the free set in order\n+  \/\/ to set aside reserves to be consumed during the next GC cycle.\n@@ -753,2 +755,3 @@\n-  \/\/ young_cset_regions is the number of regions currently in the young cset if we are starting to evacuate, or zero\n-  \/\/   old_cset_regions is the number of regions currently in the old cset if we are starting a mixed evacuation, or zero\n+  \/\/ young_trashed_regions is the number of trashed regions (immediate garbage at final mark, cset regions after update refs)\n+  \/\/   old_trashed_regions is the number of trashed regions\n+  \/\/                       (immediate garbage at final old mark, cset regions after update refs for mixed evac)\n@@ -756,1 +759,1 @@\n-  void finish_rebuild(size_t young_cset_regions, size_t old_cset_regions, size_t num_old_regions);\n+  void finish_rebuild(size_t young_trashed_regions, size_t old_trashed_regions, size_t num_old_regions);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1121,2 +1121,2 @@\n-    size_t young_cset_regions, old_cset_regions, first_old, last_old, num_old;\n-    heap->free_set()->prepare_to_rebuild(young_cset_regions, old_cset_regions, first_old, last_old, num_old);\n+    size_t young_trashed_regions, old_trashed_regions, first_old, last_old, num_old;\n+    heap->free_set()->prepare_to_rebuild(young_trashed_regions, old_trashed_regions, first_old, last_old, num_old);\n@@ -1126,1 +1126,1 @@\n-    heap->free_set()->finish_rebuild(young_cset_regions, old_cset_regions, num_old);\n+    heap->free_set()->finish_rebuild(young_trashed_regions, old_trashed_regions, num_old);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -250,0 +250,1 @@\n+  const size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n@@ -251,0 +252,4 @@\n+#undef KELVIN_DEBUG\n+#ifdef KELVIN_DEBUG\n+  log_info(gc)(\"compute_evacuation_budgets()\");\n+#endif\n@@ -266,1 +271,4 @@\n-  size_t young_evacuation_reserve = MIN2(maximum_young_evacuation_reserve, young_generation->available_with_reserve());\n+#ifdef KELVIN_DEBUG\n+  log_info(gc)(\" maximum_young_evacuation_reserve: %zu, available_with_reserve: %zu\",\n+               maximum_young_evacuation_reserve, young_generation->available_with_reserve());\n+#endif\n@@ -290,0 +298,10 @@\n+  \/\/ In some cases, maximum_old_reserve < old_available (when limited by ShenandoahOldEvacPercent)\n+  \/\/ This limit affects mixed evacuations, but does not affect promotions.\n+\n+\n+#ifdef KELVIN_DEBUG\n+  log_info(gc)(\" old_available: %zu, ShenandoahOldEvacPercent limit: %zu\",\n+               old_available, (maximum_young_evacuation_reserve * ShenandoahOldEvacPercent) \/ (100 - ShenandoahOldEvacPercent));\n+  log_info(gc)(\" old_unaffiliated is: %zu\", old_generation->free_unaffiliated_regions() * region_size_bytes);\n+  log_info(gc)(\" maximum_old_evacuation_reserve: %zu\", maximum_old_evacuation_reserve);\n+#endif\n@@ -306,4 +324,2 @@\n-    \/\/ Set old_promo_reserve to enforce that no regions are preselected for promotion.  Such regions typically\n-    \/\/ have relatively high memory utilization.  We still call select_aged_regions() because this will prepare for\n-    \/\/ promotions in place, if relevant.\n-    old_promo_reserve = 0;\n+    \/\/ Use remnant of old_available to hold promotions.\n+    old_promo_reserve = old_available - maximum_old_evacuation_reserve;\n@@ -320,1 +336,1 @@\n-    old_promo_reserve = 0;\n+    old_promo_reserve = old_available - maximum_old_evacuation_reserve;\n@@ -323,1 +339,1 @@\n-    old_evacuation_reserve = 0;\n+    old_evacuation_reserve = old_available - maximum_old_evacuation_reserve;\n@@ -328,0 +344,1 @@\n+\n@@ -331,1 +348,1 @@\n-  const size_t old_free_unfragmented = old_generation->free_unaffiliated_regions() * ShenandoahHeapRegion::region_size_bytes();\n+  const size_t old_free_unfragmented = old_generation->free_unaffiliated_regions() * region_size_bytes;\n@@ -335,4 +352,2 @@\n-    \/\/ Let promo consume fragments of old-gen memory if not global\n-    if (!is_global()) {\n-      old_promo_reserve += delta;\n-    }\n+    \/\/ Let promo consume fragments of old-gen memory\n+    old_promo_reserve += delta;\n@@ -345,0 +360,5 @@\n+  assert(consumed_by_advance_promotion <= old_promo_reserve, \"Do not promote more than budgeted\");\n+\n+  \/\/ The young evacuation reserve can be no larger than young_unaffiliated.  Planning to evacuate into partially consumed\n+  \/\/ young regions is doomed to failure if any of those partially consumed regions is selected for the collection set.\n+  size_t young_unaffiliated = young_generation->free_unaffiliated_regions() * region_size_bytes;\n@@ -349,1 +369,9 @@\n-  young_evacuation_reserve = MIN2(young_evacuation_reserve, young_generation->available_with_reserve());\n+  size_t young_evacuation_reserve = MIN2(maximum_young_evacuation_reserve, young_unaffiliated);\n+#ifdef KELVIN_DEBUG\n+  log_info(gc)(\" young_evacuation_reserve: %zu is MIN2(%zu, %zu)\",\n+               young_evacuation_reserve, maximum_young_evacuation_reserve, young_unaffiliated);\n+  log_info(gc)(\"   (previously, was bounded by %zu instead of %zu)\",\n+               young_generation->available_with_reserve(), young_unaffiliated);\n+  log_info(gc)(\" setting reserves to young: %zu, old evac: %zu, consumed_by_advance_promotin: %zu\",\n+               young_evacuation_reserve, old_evacuation_reserve, consumed_by_advance_promotion);\n+#endif\n@@ -364,1 +392,2 @@\n-void ShenandoahGeneration::adjust_evacuation_budgets(ShenandoahHeap* const heap, ShenandoahCollectionSet* const collection_set) {\n+void ShenandoahGeneration::adjust_evacuation_budgets(ShenandoahHeap* const heap,\n+                                                     ShenandoahCollectionSet* const collection_set, ssize_t regions_to_xfer) {\n@@ -389,0 +418,6 @@\n+#ifdef KELVIN_DEBUG\n+  log_info(gc)(\"adjust_evacuation_budgets\");\n+  log_info(gc)(\" old_evacuated: %zu, old_evacuated_committed: %zu, reserved: %zu\",\n+               old_evacuated, old_evacuated_committed, old_evacuation_reserve);\n+#endif\n+\n@@ -394,0 +429,3 @@\n+#ifdef KELVIN_DEBUG\n+    log_info(gc)(\" Truncating old_evacuated_committed to reserve due to round-off errors\");\n+#endif\n@@ -398,1 +436,2 @@\n-    log_debug(gc, cset)(\"Shrinking old evac reserve to match old_evac_commited: \" PROPERFMT, PROPERFMTARGS(old_evacuated_committed));\n+    log_debug(gc, cset)(\"Shrinking old evac reserve to match old_evac_commited: \" PROPERFMT,\n+                        PROPERFMTARGS(old_evacuated_committed));\n@@ -401,0 +440,3 @@\n+#ifdef KELVIN_DEBUG\n+    log_info(gc)(\" Shrinking old_evacuation reserve to %zu (use it or lose it)\", old_evacuation_reserve);\n+#endif\n@@ -409,1 +451,1 @@\n-  size_t total_young_available = young_generation->available_with_reserve();\n+  size_t total_young_available = young_generation->available_with_reserve() - regions_to_xfer * region_size_bytes;;\n@@ -411,1 +453,7 @@\n-\n+#ifdef KELVIN_DEBUG\n+  log_info(gc)(\" total_young_available: %zu computed from %zu - %zu * %zu\", total_young_available,\n+               young_generation->available_with_reserve(), regions_to_xfer, region_size_bytes);\n+  size_t alternative_young = young_generation->available_with_reserve() - collection_set->get_young_available_bytes_collected();\n+  log_info(gc)(\" alternative computation: %zu = %zu - %zu\", alternative_young,\n+                 young_generation->available_with_reserve(), collection_set->get_young_available_bytes_collected());\n+#endif\n@@ -414,1 +462,13 @@\n-  size_t old_available = old_generation->available();\n+  \/\/ We have not yet rebuilt the free set.  Memory that is available at this moment may not be available after the\n+  \/\/ collection set is constructed because some of the available memory may be contained within regions that are to be\n+  \/\/ selected for the collection set.  We were \n+\n+  size_t old_available =\n+    old_generation->available() + regions_to_xfer * region_size_bytes - collection_set->get_old_available_bytes_collected();\n+#ifdef KELVIN_DEBUG\n+  log_info(gc)(\" old_available computed as %zu (%zu + %zu * %zu - %zu)\",\n+               old_available, regions_to_xfer, region_size_bytes, old_generation->available(), collection_set->get_old_available_bytes_collected());\n+  log_info(gc)(\"   (previously computed as simply old_gen->available(): %zu)\", old_generation->available());\n+  log_info(gc)(\"   How can I be sure that cset regions are not in the available?\");\n+#endif\n+\n@@ -423,0 +483,6 @@\n+#ifdef KELVIN_DEBUG\n+    log_info(gc)(\" young_advance_promote_reserve_used: %zu, old_available: %zu, old_evacuated_committed: %zu, delta: %zu\",\n+                 young_advance_promoted_reserve_used, old_available, old_evacuated_committed,\n+                 old_available - old_evacuated_committed);\n+#endif\n+\n@@ -426,1 +492,14 @@\n-    young_advance_promoted_reserve_used = old_available - old_evacuated_committed;\n+    if (old_available > old_evacuated_committed) {\n+      young_advance_promoted_reserve_used = old_available - old_evacuated_committed;\n+#ifdef KELVIN_DEBUG\n+      log_info(gc)(\" overwriting young_advanced_promoted_reserved_used with updated value: %zu\",\n+                   young_advance_promoted_reserve_used);\n+#endif\n+    } else {\n+      young_advance_promoted_reserve_used = 0;\n+      old_evacuated_committed = old_available;\n+#ifdef KELVIN_DEBUG\n+      log_info(gc)(\" overwriting young_advanced_promoted_reserved_used with updated value: %zu\",\n+                   young_advance_promoted_reserve_used);\n+#endif\n+    }\n@@ -433,1 +512,1 @@\n-  size_t unaffiliated_old_regions = old_generation->free_unaffiliated_regions();\n+  size_t unaffiliated_old_regions = old_generation->free_unaffiliated_regions() + regions_to_xfer;\n@@ -435,3 +514,6 @@\n-  assert(old_available >= unaffiliated_old,\n-         \"Unaffiliated old (%zu is %zu * %zu) is a subset of old available (%zu)\",\n-         unaffiliated_old, unaffiliated_old_regions, region_size_bytes, old_available);\n+  assert(unaffiliated_old >= old_evacuated_committed, \"Do not evacuate (%zu) more than unaffiliated old (%zu)\",\n+         old_evacuated_committed, unaffiliated_old);\n+\n+#ifdef KELVIN_DEBUG\n+  log_info(gc)(\" unaffiliated_old: %zu should be >= old_evacuated_committed: %zu\", unaffiliated_old, old_evacuated_committed);\n+#endif\n@@ -446,0 +528,3 @@\n+#ifdef KELVIN_DEBUG\n+        log_info(gc)(\" giveaway_regions: %zu, excess_old: %zu\", giveaway_regions, excess_old);\n+#endif\n@@ -455,2 +540,2 @@\n-  \/\/ runway during evacuation and update-refs.\n-  size_t regions_to_xfer = 0;\n+  \/\/ runway during evacuation and update-refs.  We may make further adjustments to balance.\n+  regions_to_xfer = 0;\n@@ -461,0 +546,4 @@\n+#ifdef KELVIN_DEBUG\n+      log_info(gc)(\" Transferring %zu regions to Mutator because excess_old > unaffiliated_old and unaffiliated_regions > 0\",\n+                   regions_to_xfer);\n+#endif\n@@ -466,0 +555,4 @@\n+#ifdef KELVIN_DEBUG\n+    log_info(gc)(\" Transferring %zu regions to Mutator because excess_old <= unaffiliated_old and unaffiliated_regions > 0\",\n+                 regions_to_xfer);\n+#endif\n@@ -479,0 +572,5 @@\n+#ifdef KELVIN_DEBUG\n+  log_info(gc)(\" Adjusting total_promotion_reserve to %zu (expanding previous value by %zu)\", total_promotion_reserve, excess_old);\n+  log_info(gc)(\"   (regions are transferred to young because we shrunk the old evacuation reserve above)\");\n+#endif\n+\n@@ -791,1 +889,1 @@\n-      _heuristics->choose_collection_set(collection_set);\n+      ssize_t regions_to_xfer = _heuristics->choose_collection_set(collection_set);\n@@ -793,1 +891,1 @@\n-      adjust_evacuation_budgets(heap, collection_set);\n+      adjust_evacuation_budgets(heap, collection_set, regions_to_xfer);\n@@ -817,5 +915,4 @@\n-    \/\/ We are preparing for evacuation.  At this time, we ignore cset region tallies.\n-    size_t young_cset_regions, old_cset_regions, first_old, last_old, num_old;\n-    _free_set->prepare_to_rebuild(young_cset_regions, old_cset_regions, first_old, last_old, num_old);\n-    \/\/ Free set construction uses reserve quantities, because they are known to be valid here\n-    _free_set->finish_rebuild(young_cset_regions, old_cset_regions, num_old);\n+    \/\/ We are preparing for evacuation.\n+    size_t young_trashed_regions, old_trashed_regions, first_old, last_old, num_old;\n+    _free_set->prepare_to_rebuild(young_trashed_regions, old_trashed_regions, first_old, last_old, num_old);\n+    _free_set->finish_rebuild(young_trashed_regions, old_trashed_regions, num_old);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":129,"deletions":32,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -66,1 +66,2 @@\n-  \/\/ Adjust evacuation budgets after choosing collection set.\n+  \/\/ Adjust evacuation budgets after choosing collection set.  The argument regions_to_xfer represents regions to be\n+  \/\/ transfered to old based on decisions made in top_off_collection_set()\n@@ -68,1 +69,1 @@\n-                                 ShenandoahCollectionSet* collection_set);\n+                                 ShenandoahCollectionSet* collection_set, ssize_t regions_to_xfer);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -156,2 +156,5 @@\n-  \/\/ Invoke this in case we are able to transfer memory from OLD to YOUNG.\n-  heap->compute_old_generation_balance(0, 0, 0);\n+\n+  \/\/ Invoke this in case we are able to transfer memory from OLD to YOUNG\n+  size_t allocation_runway =\n+    heap->young_generation()->heuristics()->bytes_of_allocation_runway_before_gc_trigger(0L);\n+  heap->compute_old_generation_balance(allocation_runway, 0, 0);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalFullGC.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -601,1 +601,1 @@\n-                                                                size_t old_cset_regions, size_t young_cset_regions) {\n+                                                                size_t old_trashed_regions, size_t young_trashed_regions) {\n@@ -619,0 +619,5 @@\n+#define KELVIN_DEBUG\n+#ifdef KELVIN_DEBUG\n+  log_info(gc)(\"compute_old_generation_balance(%zu, %zu, %zu)\", mutator_xfer_limit, old_trashed_regions, young_trashed_regions);\n+#endif\n+\n@@ -626,1 +631,1 @@\n-  size_t old_available = ((old_capacity >= old_usage)? old_capacity - old_usage: 0) + old_cset_regions * region_size_bytes;\n+  size_t old_available = ((old_capacity >= old_usage)? old_capacity - old_usage: 0) + old_trashed_regions * region_size_bytes;\n@@ -636,1 +641,1 @@\n-  young_available += young_cset_regions * region_size_bytes;\n+  young_available += young_trashed_regions * region_size_bytes;\n@@ -654,1 +659,1 @@\n-    old_available - (old_generation()->free_unaffiliated_regions() + old_cset_regions) * region_size_bytes;\n+    old_available - (old_generation()->free_unaffiliated_regions() + old_trashed_regions) * region_size_bytes;\n@@ -727,1 +732,1 @@\n-    const size_t unaffiliated_old_regions = old_generation()->free_unaffiliated_regions() + old_cset_regions;\n+    const size_t unaffiliated_old_regions = old_generation()->free_unaffiliated_regions() + old_trashed_regions;\n@@ -729,0 +734,3 @@\n+#ifdef KELVIN_DEBUG\n+    log_info(gc)(\" setting region balance to surplus: %zd\", old_region_surplus);\n+#endif\n@@ -734,0 +742,3 @@\n+#ifdef KELVIN_DEBUG\n+    log_info(gc)(\" setting region balance to deficit: %zd\", old_region_deficit);\n+#endif\n@@ -773,0 +784,3 @@\n+#ifdef KELVIN_DEBUG\n+    log_info(gc)(\" setting region balance to deficit: %zd\", old_region_deficit);\n+#endif\n@@ -776,0 +790,5 @@\n+#ifdef KELVIN_DEBUG\n+  log_info(gc)(\"compute_old_generation_balance() setting evac_reserve: %zu, old evac reserve: %zu, promo reserve: %zu\",\n+               young_reserve, reserve_for_mixed, reserve_for_promo);\n+#endif\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":24,"deletions":5,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-  void compute_old_generation_balance(size_t old_xfer_limit, size_t old_cset_regions, size_t young_cset_regions);\n+  void compute_old_generation_balance(size_t old_xfer_limit, size_t old_trashed_regions, size_t young_trashed_regions);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -440,2 +440,2 @@\n-    size_t young_cset_regions, old_cset_regions, first_old, last_old, num_old;\n-    _free_set->prepare_to_rebuild(young_cset_regions, old_cset_regions, first_old, last_old, num_old);\n+    size_t young_trashed_regions, old_trashed_regions, first_old, last_old, num_old;\n+    _free_set->prepare_to_rebuild(young_trashed_regions, old_trashed_regions, first_old, last_old, num_old);\n@@ -448,1 +448,1 @@\n-      gen_heap->compute_old_generation_balance(allocation_runway, old_cset_regions, young_cset_regions);\n+      gen_heap->compute_old_generation_balance(allocation_runway, old_trashed_regions, young_trashed_regions);\n@@ -450,1 +450,1 @@\n-    _free_set->finish_rebuild(young_cset_regions, old_cset_regions, num_old);\n+    _free_set->finish_rebuild(young_trashed_regions, old_trashed_regions, num_old);\n@@ -2527,3 +2527,2 @@\n-  size_t young_cset_regions, old_cset_regions;\n-  size_t first_old_region, last_old_region, old_region_count;\n-  _free_set->prepare_to_rebuild(young_cset_regions, old_cset_regions, first_old_region, last_old_region, old_region_count);\n+  size_t young_trashed_regions, old_trashed_regions, first_old_region, last_old_region, old_region_count;\n+  _free_set->prepare_to_rebuild(young_trashed_regions, old_trashed_regions, first_old_region, last_old_region, old_region_count);\n@@ -2548,2 +2547,2 @@\n-      gen_heap->young_generation()->heuristics()->bytes_of_allocation_runway_before_gc_trigger(young_cset_regions);\n-    gen_heap->compute_old_generation_balance(allocation_runway, old_cset_regions, young_cset_regions);\n+      gen_heap->young_generation()->heuristics()->bytes_of_allocation_runway_before_gc_trigger(young_trashed_regions);\n+    gen_heap->compute_old_generation_balance(allocation_runway, old_trashed_regions, young_trashed_regions);\n@@ -2552,1 +2551,1 @@\n-  _free_set->finish_rebuild(young_cset_regions, old_cset_regions, old_region_count);\n+  _free_set->finish_rebuild(young_trashed_regions, old_trashed_regions, old_region_count);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -413,2 +413,1 @@\n-    size_t young_trash_regions, old_trash_regions;\n-    size_t first_old, last_old, num_old;\n+    size_t young_trash_regions, old_trash_regions, first_old, last_old, num_old;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -149,0 +149,4 @@\n+#undef KELVIN_VERBOSE\n+#ifdef KELVIN_VERBOSE\n+    log_info(gc)(\"old_generation->set_region_balance(%zd)\", balance);\n+#endif\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}