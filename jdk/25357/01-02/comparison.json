{"files":[{"patch":"@@ -775,1 +775,11 @@\n-  \/\/ If OldCollector partition is empty, leftmosts will both equal max, rightmosts will both equal zero.\n+  \/\/ Concurrent recycling of trash first recycles a region (changing its state from is_trash to is_empty without the heap lock),\n+  \/\/ then it acquires the heap lock, then it adjusts the partition for the newly recycled region and releases the lock.  After\n+  \/\/ all trashed regions have been recycled, we grab the heap lock again and clear the _old_trash_not_in_bounds flag.\n+  \/\/\n+  \/\/ Bottom line: if _old_trash_not_in_bounds, the ranges of old regions detected by examination of all region states may\n+  \/\/ be larger than the spans reported by leftmosts(OldColector) and rightmosts(OldCollector) and by the spans represented\n+  \/\/ by _leftmosts_empty[OldCollector] and _rightmosts_empty[OldCollector]\n+  \/\/ \n+\n+  \/\/ If OldCollector partition is empty and !old_trash_not_in_bounds:\n+  \/\/    leftmosts will both equal max, rightmosts will both equal zero.\n@@ -779,1 +789,1 @@\n-  assert (beg_off >= leftmost(ShenandoahFreeSetPartitionId::OldCollector),\n+  assert (old_trash_not_in_bounds || (beg_off >= leftmost(ShenandoahFreeSetPartitionId::OldCollector)),\n@@ -782,1 +792,1 @@\n-  assert (end_off <= rightmost(ShenandoahFreeSetPartitionId::OldCollector),\n+  assert (old_trash_not_in_bounds || (end_off <= rightmost(ShenandoahFreeSetPartitionId::OldCollector)),\n@@ -788,2 +798,2 @@\n-  assert (beg_off >= _leftmosts_empty[int(ShenandoahFreeSetPartitionId::OldCollector)],\n-          \"free empty region (%zd) before the leftmost bound %zd, old_trash_not_in_bounds: %s\",\n+  assert (old_trash_not_in_bounds || (beg_off >= _leftmosts_empty[int(ShenandoahFreeSetPartitionId::OldCollector)]),\n+          \"free empty region (%zd) before the leftmost bound %zd, old_trash_not_in_bounds: no, region %s trash\",\n@@ -791,3 +801,5 @@\n-          old_trash_not_in_bounds? \"yes\": \"no\");\n-  assert (end_off <= _rightmosts_empty[int(ShenandoahFreeSetPartitionId::OldCollector)],\n-          \"free empty region (%zd) past the rightmost bound %zd, old_trash_not_in_bounds: %s\",\n+          ((beg_off >= _max)? \"out of bounds is not\":\n+           (ShenandoahHeap::heap()->get_region(_leftmosts_empty[int(ShenandoahFreeSetPartitionId::OldCollector)])->is_trash()?\n+            \"is\": \"is not\")));\n+  assert (old_trash_not_in_bounds || (end_off <= _rightmosts_empty[int(ShenandoahFreeSetPartitionId::OldCollector)]),\n+          \"free empty region (%zd) past the rightmost bound %zd, old_trash_not_in_bounds: no, region %s trash\",\n@@ -795,1 +807,3 @@\n-          old_trash_not_in_bounds? \"yes\": \"no\");\n+          ((end_off < 0)? \"out of bounds is not\" :\n+           (ShenandoahHeap::heap()->get_region(_rightmosts_empty[int(ShenandoahFreeSetPartitionId::OldCollector)])->is_trash()?\n+            \"is\": \"is not\")));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":23,"deletions":9,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -237,1 +237,1 @@\n-  \/\/ For HumongousRegion:s it's more efficient to jump directly to the\n+  \/\/ For HumongousRegions it's more efficient to jump directly to the\n@@ -248,2 +248,0 @@\n-  HeapWord* p = nullptr;\n-  oop obj = cast_to_oop(p);\n@@ -265,1 +263,1 @@\n-  p = _rs->addr_for_card_index(cur_index) + offset;\n+  HeapWord* p = _rs->addr_for_card_index(cur_index) + offset;\n@@ -282,1 +280,1 @@\n-  NOT_PRODUCT(obj = cast_to_oop(p);)\n+  oop obj = cast_to_oop(p);\n@@ -284,1 +282,1 @@\n-#define WALK_FORWARD_IN_BLOCK_START false\n+#define WALK_FORWARD_IN_BLOCK_START true\n@@ -287,0 +285,2 @@\n+    obj = cast_to_oop(p);\n+    assert(oopDesc::is_oop(obj), \"Should be an object\");\n@@ -289,1 +289,11 @@\n-  assert(p + obj->size() > left, \"obj should end after left\");\n+#ifdef ASSERT\n+  if (p + obj->size() <= left) {\n+    const CardValue* const wtbm = _rs->card_table()->write_byte_map();\n+    const CardValue* const rtbm = _rs->card_table()->read_byte_map();\n+    log_info(gc)(\"Anticipating assert failure, card[%zu] is %s in read table, %s in write table\", cur_index, \n+                 (rtbm[cur_index] ==CardTable::dirty_card_val())? \"dirty\": \"clean\",\n+                 (wtbm[cur_index] ==CardTable::dirty_card_val())? \"dirty\": \"clean\");\n+  }\n+#endif\n+  assert(p < left, \"p should start before left end of card\");\n+  assert(p + obj->size() > left, \"obj should end after left end of card\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.cpp","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -231,0 +231,6 @@\n+#define KELVIN_DEBUG\n+#ifdef KELVIN_DEBUG\n+  inline ShenandoahCardTable* card_table() {\n+    return _card_table;\n+  }\n+#endif\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}