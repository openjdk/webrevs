{"files":[{"patch":"@@ -282,1 +282,1 @@\n-  \/\/ Let SOEP = ShenandoahOldEvacRatioPercent,\n+  \/\/ Let SOEP = ShenandoahOldEvacPercent,\n@@ -294,1 +294,1 @@\n-  assert(ShenandoahOldEvacRatioPercent <= 100, \"Error\");\n+  assert(ShenandoahOldEvacPercent <= 100, \"Error\");\n@@ -296,2 +296,2 @@\n-  const size_t maximum_old_evacuation_reserve = (ShenandoahOldEvacRatioPercent == 100) ?\n-    old_available : MIN2((maximum_young_evacuation_reserve * ShenandoahOldEvacRatioPercent) \/ (100 - ShenandoahOldEvacRatioPercent),\n+  const size_t maximum_old_evacuation_reserve = (ShenandoahOldEvacPercent == 100) ?\n+    old_available : MIN2((maximum_young_evacuation_reserve * ShenandoahOldEvacPercent) \/ (100 - ShenandoahOldEvacPercent),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -140,2 +140,2 @@\n-  log_info(gc, ergo)(\"Transfer %zu region(s) from %s to %s, yielding increased size: \" PROPERFMT,\n-                     regions, src->name(), dst->name(), PROPERFMTARGS(new_size));\n+  log_develop_debug(gc, ergo)(\"Transfer %zu region(s) from %s to %s, yielding increased size: \" PROPERFMT,\n+                              regions, src->name(), dst->name(), PROPERFMTARGS(new_size));\n@@ -181,0 +181,14 @@\n+\n+void ShenandoahGenerationSizer::force_transfer_to_old(size_t regions) const {\n+  ShenandoahGenerationalHeap* heap = ShenandoahGenerationalHeap::heap();\n+  ShenandoahGeneration* old_gen = heap->old_generation();\n+  ShenandoahGeneration* young_gen = heap->young_generation();\n+  const size_t bytes_to_transfer = regions * ShenandoahHeapRegion::region_size_bytes();\n+\n+  young_gen->decrease_capacity(bytes_to_transfer);\n+  old_gen->increase_capacity(bytes_to_transfer);\n+  const size_t new_size = old_gen->max_capacity();\n+  log_develop_debug(gc, ergo)(\"Forcing transfer of %zu region(s) from %s to %s, yielding increased size: \" PROPERFMT,\n+                              regions, young_gen->name(), old_gen->name(), PROPERFMTARGS(new_size));\n+}\n+\n@@ -183,1 +197,1 @@\n-void ShenandoahGenerationSizer::force_transfer_to_old(size_t regions) const {\n+void ShenandoahGenerationSizer::promote_regions_in_place(size_t regions) const {\n@@ -192,2 +206,2 @@\n-  log_info(gc, ergo)(\"Forcing transfer of %zu region(s) from %s to %s, yielding increased size: \" PROPERFMT,\n-                     regions, young_gen->name(), old_gen->name(), PROPERFMTARGS(new_size));\n+  log_develop_debug(gc, ergo)(\"Promoting %zu regions in place, changing affiliations from %s to %s, yielding size: \" PROPERFMT,\n+                              regions, young_gen->name(), old_gen->name(), PROPERFMTARGS(new_size));\n@@ -206,2 +220,3 @@\n-  log_info(gc)(\"Forcing transfer of %zu region(s) from %s to %s, yielding increased size: \" PROPERFMT,\n-          regions, old_gen->name(), young_gen->name(), PROPERFMTARGS(new_size));\n+  log_develop_debug(gc, ergo)\n+    (\"Rebalancing regions after rebuild free set, moving %zu region(s) from %s to %s, yielding increased size: \" PROPERFMT,\n+     regions, old_gen->name(), young_gen->name(), PROPERFMTARGS(new_size));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationSizer.cpp","additions":22,"deletions":7,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -89,1 +89,5 @@\n-  \/\/ Force transfer is used when we promote humongous objects or promote regular regions in place.\n+  \/\/ Use this to adjust generation sizes when we promote humongous objects or promote regular regions in place.\n+  \/\/ May violate min\/max limits on generation sizes.\n+  void promote_regions_in_place(size_t regions) const;\n+\n+  \/\/ Force transfer is used to adjust accounting of regions in generations after rebuilding free set.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationSizer.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -247,2 +247,2 @@\n-    \/\/ transfer_to_old() increases capacity of old and decreases capacity of young\n-    _heap->generation_sizer()->force_transfer_to_old(1);\n+    \/\/ promote_regions_in_place() increases capacity of old and decreases capacity of young\n+    _heap->generation_sizer()->promote_regions_in_place(1);\n@@ -289,2 +289,2 @@\n-    \/\/ transfer_to_old() increases capacity of old and decreases capacity of young\n-    _heap->generation_sizer()->force_transfer_to_old(spanned_regions);\n+    \/\/ promote_regions_in_place() increases capacity of old and decreases capacity of young\n+    _heap->generation_sizer()->promote_regions_in_place(spanned_regions);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalEvacuationTask.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -238,1 +238,1 @@\n-                                        ShenandoahAffiliation target_gen) {\n+                                                    ShenandoahAffiliation target_gen) {\n@@ -298,22 +298,5 @@\n-#ifdef KELVIN_ORIGINAL\n-      if (!is_promotion || !has_plab || (size > PLAB::min_size())) {\n-        ShenandoahAllocRequest req = ShenandoahAllocRequest::for_shared_gc(size, target_gen, is_promotion);\n-        copy = allocate_memory(req);\n-        alloc_from_lab = false;\n-      }\n-      \/\/ else, we leave copy equal to nullptr, signaling a promotion failure below if appropriate.\n-      \/\/ We choose not to promote objects smaller than PLAB::min_size() by way of shared allocations, as this is too\n-      \/\/ costly.  Instead, we'll simply \"evacuate\" to young-gen memory (using a GCLAB) and will promote in a future\n-      \/\/ evacuation pass.  This condition is denoted by: is_promotion && has_plab && (size <= PLAB::min_size())\n-#else\n-      \/\/ The value of this \"improvement\" has not yet been measured or quantified.  There is a suspicion that too much\n-      \/\/ promotion by shared allocation is resulting in degraded latency at all percentiles.  The only evidence observed\n-      \/\/ is that an 8G heap size with share-allocation reserves has higher latency in 75% OldEvacRatio than tip, even though\n-      \/\/ this PR branch has fewer concurret GC cycles, fewer mixed cycles, equal number of old GC cycles, and improvement\n-      \/\/ in every metric except pause-init-mark, which increased by 79%.  The dominant cost of pause-init-mark is known to\n-      \/\/ be copying of remembered set.  That this takes almost twice as long with 5% fewer GC cycles seems to suggest that\n-      \/\/ our branch typically has a much larger remembered set size (i.e. a larger old-gen size).  It seems plausible that\n-      \/\/ the branch is more successful with promoting by shared allocations.  We need to study this further.  May revert\n-      \/\/ this change depending on results of further analysis.\n-\n-      \/\/ Reduce, but do not totally eliminate promotion by shared allocation\n+\n+      \/\/ Reduce, but do not totally eliminate promotion by shared allocation.  Shared allocations are normally\n+      \/\/ not a good thing.  Usually is much better to evacuate into a young-gen GCLAB than promote to old-gen with a\n+      \/\/ shared allocation.  Objects above a particular threshold size (6 * min-size) are considered to be worth the\n+      \/\/ effort required to promote by shared allocation.\n@@ -330,1 +313,0 @@\n-#endif\n@@ -620,1 +602,1 @@\n-  \/\/ Let SOEP = ShenandoahOldEvacRatioPercent,\n+  \/\/ Let SOEP = ShenandoahOldEvacPercent,\n@@ -632,1 +614,1 @@\n-  assert(ShenandoahOldEvacRatioPercent <= 100, \"Error\");\n+  assert(ShenandoahOldEvacPercent <= 100, \"Error\");\n@@ -653,3 +635,3 @@\n-  \/\/ If ShenandoahOldEvacRatioPercent equals 100, max_old_reserve is limited only by mutator_xfer_limit and young_reserve\n-  const size_t bound_on_old_reserve = ((old_available + mutator_xfer_limit + young_reserve) * ShenandoahOldEvacRatioPercent) \/ 100;\n-  size_t proposed_max_old = ((ShenandoahOldEvacRatioPercent == 100)?\n+  \/\/ If ShenandoahOldEvacPercent equals 100, max_old_reserve is limited only by mutator_xfer_limit and young_reserve\n+  const size_t bound_on_old_reserve = ((old_available + mutator_xfer_limit + young_reserve) * ShenandoahOldEvacPercent) \/ 100;\n+  size_t proposed_max_old = ((ShenandoahOldEvacPercent == 100)?\n@@ -657,1 +639,1 @@\n-                             MIN2((young_reserve * ShenandoahOldEvacRatioPercent) \/ (100 - ShenandoahOldEvacRatioPercent),\n+                             MIN2((young_reserve * ShenandoahOldEvacPercent) \/ (100 - ShenandoahOldEvacPercent),\n@@ -750,1 +732,1 @@\n-    size_t old_entitlement = (available_reserves  * ShenandoahOldEvacRatioPercent) \/ 100;\n+    size_t old_entitlement = (available_reserves  * ShenandoahOldEvacPercent) \/ 100;\n@@ -799,13 +781,0 @@\n-void ShenandoahGenerationalHeap::TransferResult::print_on(const char* when, outputStream* ss) const {\n-  auto heap = ShenandoahGenerationalHeap::heap();\n-  ShenandoahYoungGeneration* const young_gen = heap->young_generation();\n-  ShenandoahOldGeneration* const old_gen = heap->old_generation();\n-  const size_t young_available = young_gen->available();\n-  const size_t old_available = old_gen->available();\n-  ss->print_cr(\"After %s, %s %zu regions to %s to prepare for next gc, old available: \"\n-                     PROPERFMT \", young_available: \" PROPERFMT,\n-                     when,\n-                     success? \"successfully transferred\": \"failed to transfer\", region_count, region_destination,\n-                     PROPERFMTARGS(old_available), PROPERFMTARGS(young_available));\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":13,"deletions":44,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -131,9 +131,0 @@\n-  \/\/ Used for logging the result of a region transfer outside the heap lock\n-  struct TransferResult {\n-    bool success;\n-    size_t region_count;\n-    const char* region_destination;\n-\n-    void print_on(const char* when, outputStream* ss) const;\n-  };\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1669,6 +1669,1 @@\n-  if (mode()->is_generational()) {\n-    \/\/ young-gen heuristics track young, bootstrap, and global GC cycle times\n-    young_generation()->heuristics()->record_cycle_start();\n-  } else {\n-    generation->heuristics()->record_cycle_start();\n-  }\n+  generation->heuristics()->record_cycle_start();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -279,4 +279,0 @@\n-  inline bool is_recycling() {\n-    return _recycling.is_set();\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -376,37 +376,14 @@\n-  product(uintx, ShenandoahOldEvacRatioPercent, 75, EXPERIMENTAL,           \\\n-          \"The maximum percent of memory that can be reserved for \"         \\\n-          \"evacuation into old generation.  With the default setting, \"     \\\n-          \"given a total evacuation budget of X, the amount of memory \"     \\\n-          \"reserved to hold objects evacuated to old generation is 0.75x.\"  \\\n-          \"This limits both the promotion of aged young regions and \"       \\\n-          \"the compaction of existing old regions.  It does not restrict \"  \\\n-          \"the collector from copying more objects into old-generation \"    \\\n-          \"memory if the young-generation collection set does not consume \" \\\n-          \"all of the memory originally reserved for young-generation \"     \\\n-          \"evacuation.  It also does not restrict the amount of memory \"    \\\n-          \"that can be promoted in place, by simply changing the \"          \\\n-          \"affiliation of the region from young to old.  If there is an \"   \\\n-          \"abundance of free memory, this will result in a larger total \"   \\\n-          \"evacuation effort, roughly quadrupling the amount of memory \"    \\\n-          \"normally evacuated during young evacuations (so that old \"       \\\n-          \"evacuates three times as much as young, and young evacuates its \"\\\n-          \"normal amount).  If free memory is in short supply, this may \"   \\\n-          \"result in paring back both young-gen and old-gen evacuations, \"  \\\n-          \"such that the fraction of old is 75% (in the default \"           \\\n-          \"configuration) of the total available evacuation reserve, \"      \\\n-          \"with young evacuating one fourth of its normal amount, \"         \\\n-          \"and old evacuating three times as much as young evacuates.  \"    \\\n-          \"Setting a larger value allows for quicker promotion and a \"      \\\n-          \"smaller number of mixed evacuations to process the entire list \" \\\n-          \"of old-gen collection candidates at the cost of increased \"      \\\n-          \"disruption of the normal young-gen collection cadence.  A \"      \\\n-          \"value of 100 allows a mixed evacuation to focus entirely \"       \\\n-          \"on old-gen memory, allowing no young-gen regions to be \"         \\\n-          \"collected.  This would likely result in subsequent allocation \"  \\\n-          \"failures because the young-gen allocation pool would not be \"    \\\n-          \"replenished.  A value of 0 prevents mixed evacuations \"          \\\n-          \"from defragmenting old-gen memory, likely resulting in \"         \\\n-          \"subsequent promotion failures and triggering of stop-the-world \" \\\n-          \"full GC events.  Faiure to defragment old-gen memory can also \"  \\\n-          \"result in unconstrained expansion of old-gen, and shrinkage of \" \\\n-          \"young gen, causing inefficient high frequency of young-gen GC.\") \\\n+  product(uintx, ShenandoahOldEvacPercent, 75, EXPERIMENTAL,                \\\n+          \"The maximum evacuation to old-gen expressed as a percent of \"    \\\n+          \"the total live memory within the collection set.  With the \"     \\\n+          \"default setting, if collection set evacuates X, no more than \"   \\\n+          \"75% of X may hold object evacuated from old or promoted to old \" \\\n+          \"from young.  A value of 100 allows the entire collection set \"   \\\n+          \"to be comprised of old-gen regions and young regions that have \" \\\n+          \"reached the tenure age.  Larger values allow fewer mixed \"       \\\n+          \"evacuations to reclaim all the garbage from old.  Smaller \"      \\\n+          \"values result in less variation in GC cycle times between \"      \\\n+          \"young vs. mixed cycles.  A value of 0 prevents mixed \"           \\\n+          \"evacations from running and blocks promotion of aged regions \"   \\\n+          \"by evacuation.  Setting the value to 0 does not prevent \"        \\\n+          \"regions from being promoted in place.\")                          \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":14,"deletions":37,"binary":false,"changes":51,"status":"modified"}]}