{"files":[{"patch":"@@ -560,0 +560,4 @@\n+  product(bool, HeapDumpRedacted, false, MANAGEABLE,                        \\\n+          \"Redact primitive type values from heap dump by setting \"         \\\n+          \"them to zero.\")                                                  \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -252,0 +252,3 @@\n+    const char* redact_str = op->arg(3);\n+    bool redact = redact_str != nullptr && strcmp(redact_str, \"true\") == 0;\n+\n@@ -257,1 +260,1 @@\n-    dumper.dump(path, out, level);\n+    dumper.dump(path, out, level, false, redact);\n","filename":"src\/hotspot\/share\/services\/attachListener.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-    arg_count_max = 3           \/\/ maximum number of arguments\n+    arg_count_max = 4           \/\/ maximum number of arguments\n","filename":"src\/hotspot\/share\/services\/attachListener.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -486,1 +486,2 @@\n-            \"INT\", false, \"1\") {\n+            \"INT\", false, \"1\"),\n+  _redact(\"-redact\", \"redact heap dump by setting primitives to zero\", \"BOOLEAN\", false, \"false\") {\n@@ -492,0 +493,1 @@\n+  _dcmdparser.add_dcmd_option(&_redact);\n@@ -523,1 +525,1 @@\n-  dumper.dump(_filename.value(), output(), (int) level, _overwrite.value(), (uint)parallel);\n+  dumper.dump(_filename.value(), output(), (int) level, _overwrite.value(), _redact.value(), (uint)parallel);\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -324,0 +324,1 @@\n+  DCmdArgument<bool> _redact;\n@@ -325,1 +326,1 @@\n-  static int num_arguments() { return 5; }\n+  static int num_arguments() { return 6; }\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -467,1 +467,1 @@\n-\/\/ write raw bytes\n+\/\/ write raw bytes, writes 0 if s is nullptr which is used for redaction\n@@ -477,2 +477,6 @@\n-    memcpy(buffer() + position(), s, to_write);\n-    s = (void*) ((char*) s + to_write);\n+    if (s == nullptr) {\n+      memset(buffer() + position(), 0, to_write);\n+    } else {\n+      memcpy(buffer() + position(), s, to_write);\n+      s = (void*) ((char*) s + to_write);\n+    }\n@@ -484,1 +488,5 @@\n-  memcpy(buffer() + position(), s, len);\n+  if (s == nullptr) {\n+    memset(buffer() + position(), 0, len);\n+  } else {\n+    memcpy(buffer() + position(), s, len);\n+  }\n@@ -754,1 +762,1 @@\n-  static void dump_field_value(AbstractDumpWriter* writer, char type, oop obj, int offset);\n+  static void dump_field_value(AbstractDumpWriter* writer, char type, oop obj, int offset, bool redact);\n@@ -758,1 +766,1 @@\n-  static void dump_static_fields(AbstractDumpWriter* writer, Klass* k);\n+  static void dump_static_fields(AbstractDumpWriter* writer, Klass* k, bool redact);\n@@ -760,1 +768,1 @@\n-  static void dump_instance_fields(AbstractDumpWriter* writer, oop o, DumperClassCacheTableEntry* class_cache_entry);\n+  static void dump_instance_fields(AbstractDumpWriter* writer, oop o, DumperClassCacheTableEntry* class_cache_entry, bool redact);\n@@ -766,1 +774,1 @@\n-  static void dump_instance(AbstractDumpWriter* writer, oop o, DumperClassCacheTable* class_cache);\n+  static void dump_instance(AbstractDumpWriter* writer, oop o, DumperClassCacheTable* class_cache, bool redact);\n@@ -768,1 +776,1 @@\n-  static void dump_instance_class(AbstractDumpWriter* writer, Klass* k);\n+  static void dump_instance_class(AbstractDumpWriter* writer, Klass* k, bool redact);\n@@ -775,1 +783,1 @@\n-  static void dump_prim_array(AbstractDumpWriter* writer, typeArrayOop array);\n+  static void dump_prim_array(AbstractDumpWriter* writer, typeArrayOop array, bool redact);\n@@ -991,1 +999,1 @@\n-void DumperSupport::dump_field_value(AbstractDumpWriter* writer, char type, oop obj, int offset) {\n+void DumperSupport::dump_field_value(AbstractDumpWriter* writer, char type, oop obj, int offset, bool redact) {\n@@ -1002,1 +1010,1 @@\n-      jbyte b = obj->byte_field(offset);\n+      jbyte b = redact ? 0 : obj->byte_field(offset);\n@@ -1007,1 +1015,1 @@\n-      jchar c = obj->char_field(offset);\n+      jchar c = redact ? 0 : obj->char_field(offset);\n@@ -1012,1 +1020,1 @@\n-      jshort s = obj->short_field(offset);\n+      jshort s = redact ? 0 : obj->short_field(offset);\n@@ -1017,1 +1025,1 @@\n-      jfloat f = obj->float_field(offset);\n+      jfloat f = redact ? 0 : obj->float_field(offset);\n@@ -1022,1 +1030,1 @@\n-      jdouble d = obj->double_field(offset);\n+      jdouble d = redact ? 0 : obj->double_field(offset);\n@@ -1027,1 +1035,1 @@\n-      jint i = obj->int_field(offset);\n+      jint i = redact ? 0 : obj->int_field(offset);\n@@ -1032,1 +1040,1 @@\n-      jlong l = obj->long_field(offset);\n+      jlong l = redact ? 0 : obj->long_field(offset);\n@@ -1037,1 +1045,1 @@\n-      jboolean b = obj->bool_field(offset);\n+      jboolean b = redact ? false : obj->bool_field(offset);\n@@ -1105,1 +1113,1 @@\n-void DumperSupport::dump_static_fields(AbstractDumpWriter* writer, Klass* k) {\n+void DumperSupport::dump_static_fields(AbstractDumpWriter* writer, Klass* k, bool redact) {\n@@ -1117,1 +1125,1 @@\n-      dump_field_value(writer, sig->char_at(0), ik->java_mirror(), fld.offset());\n+      dump_field_value(writer, sig->char_at(0), ik->java_mirror(), fld.offset(), redact);\n@@ -1148,1 +1156,1 @@\n-void DumperSupport::dump_instance_fields(AbstractDumpWriter* writer, oop o, DumperClassCacheTableEntry* class_cache_entry) {\n+void DumperSupport::dump_instance_fields(AbstractDumpWriter* writer, oop o, DumperClassCacheTableEntry* class_cache_entry, bool redact) {\n@@ -1151,1 +1159,1 @@\n-    dump_field_value(writer, class_cache_entry->sig_start(idx), o, class_cache_entry->offset(idx));\n+    dump_field_value(writer, class_cache_entry->sig_start(idx), o, class_cache_entry->offset(idx), redact);\n@@ -1182,1 +1190,1 @@\n-void DumperSupport::dump_instance(AbstractDumpWriter* writer, oop o, DumperClassCacheTable* class_cache) {\n+void DumperSupport::dump_instance(AbstractDumpWriter* writer, oop o, DumperClassCacheTable* class_cache, bool redact) {\n@@ -1201,1 +1209,1 @@\n-  dump_instance_fields(writer, o, cache_entry);\n+  dump_instance_fields(writer, o, cache_entry, redact);\n@@ -1207,1 +1215,1 @@\n-void DumperSupport::dump_instance_class(AbstractDumpWriter* writer, Klass* k) {\n+void DumperSupport::dump_instance_class(AbstractDumpWriter* writer, Klass* k, bool redact) {\n@@ -1253,1 +1261,1 @@\n-  dump_static_fields(writer, ik);\n+  dump_static_fields(writer, ik, redact);\n@@ -1355,1 +1363,1 @@\n-void DumperSupport::dump_prim_array(AbstractDumpWriter* writer, typeArrayOop array) {\n+void DumperSupport::dump_prim_array(AbstractDumpWriter* writer, typeArrayOop array, bool redact) {\n@@ -1377,8 +1385,12 @@\n-  \/\/ If the byte ordering is big endian then we can copy most types directly\n-\n-  switch (type) {\n-    case T_INT : {\n-      if (Endian::is_Java_byte_ordering_different()) {\n-        WRITE_ARRAY(array, int, u4, length);\n-      } else {\n-        writer->write_raw(array->int_at_addr(0), length_in_bytes);\n+  if (redact) {\n+    writer->write_raw(nullptr, length_in_bytes); \/\/nullptr to write zeros\n+  } else {\n+    \/\/ If the byte ordering is big endian then we can copy most types directly\n+    switch (type) {\n+      case T_INT : {\n+        if (Endian::is_Java_byte_ordering_different()) {\n+          WRITE_ARRAY(array, int, u4, length);\n+        } else {\n+          writer->write_raw(array->int_at_addr(0), length_in_bytes);\n+        }\n+        break;\n@@ -1386,11 +1398,3 @@\n-      break;\n-    }\n-    case T_BYTE : {\n-      writer->write_raw(array->byte_at_addr(0), length_in_bytes);\n-      break;\n-    }\n-    case T_CHAR : {\n-      if (Endian::is_Java_byte_ordering_different()) {\n-        WRITE_ARRAY(array, char, u2, length);\n-      } else {\n-        writer->write_raw(array->char_at_addr(0), length_in_bytes);\n+      case T_BYTE : {\n+        writer->write_raw(array->byte_at_addr(0), length_in_bytes);\n+        break;\n@@ -1398,7 +1402,7 @@\n-      break;\n-    }\n-    case T_SHORT : {\n-      if (Endian::is_Java_byte_ordering_different()) {\n-        WRITE_ARRAY(array, short, u2, length);\n-      } else {\n-        writer->write_raw(array->short_at_addr(0), length_in_bytes);\n+      case T_CHAR : {\n+        if (Endian::is_Java_byte_ordering_different()) {\n+          WRITE_ARRAY(array, char, u2, length);\n+        } else {\n+          writer->write_raw(array->char_at_addr(0), length_in_bytes);\n+        }\n+        break;\n@@ -1406,7 +1410,7 @@\n-      break;\n-    }\n-    case T_BOOLEAN : {\n-      if (Endian::is_Java_byte_ordering_different()) {\n-        WRITE_ARRAY(array, bool, u1, length);\n-      } else {\n-        writer->write_raw(array->bool_at_addr(0), length_in_bytes);\n+      case T_SHORT : {\n+        if (Endian::is_Java_byte_ordering_different()) {\n+          WRITE_ARRAY(array, short, u2, length);\n+        } else {\n+          writer->write_raw(array->short_at_addr(0), length_in_bytes);\n+        }\n+        break;\n@@ -1414,7 +1418,15 @@\n-      break;\n-    }\n-    case T_LONG : {\n-      if (Endian::is_Java_byte_ordering_different()) {\n-        WRITE_ARRAY(array, long, u8, length);\n-      } else {\n-        writer->write_raw(array->long_at_addr(0), length_in_bytes);\n+      case T_BOOLEAN : {\n+        if (Endian::is_Java_byte_ordering_different()) {\n+          WRITE_ARRAY(array, bool, u1, length);\n+        } else {\n+          writer->write_raw(array->bool_at_addr(0), length_in_bytes);\n+        }\n+        break;\n+      }\n+      case T_LONG : {\n+        if (Endian::is_Java_byte_ordering_different()) {\n+          WRITE_ARRAY(array, long, u8, length);\n+        } else {\n+          writer->write_raw(array->long_at_addr(0), length_in_bytes);\n+        }\n+        break;\n@@ -1422,2 +1434,0 @@\n-      break;\n-    }\n@@ -1425,3 +1435,3 @@\n-    \/\/ handle float\/doubles in a special value to ensure than NaNs are\n-    \/\/ written correctly. TO DO: Check if we can avoid this on processors that\n-    \/\/ use IEEE 754.\n+      \/\/ handle float\/doubles in a special value to ensure than NaNs are\n+      \/\/ written correctly. TO DO: Check if we can avoid this on processors that\n+      \/\/ use IEEE 754.\n@@ -1429,3 +1439,5 @@\n-    case T_FLOAT : {\n-      for (int i = 0; i < length; i++) {\n-        dump_float(writer, array->float_at(i));\n+      case T_FLOAT : {\n+        for (int i = 0; i < length; i++) {\n+          dump_float(writer, array->float_at(i));\n+        }\n+        break;\n@@ -1433,5 +1445,5 @@\n-      break;\n-    }\n-    case T_DOUBLE : {\n-      for (int i = 0; i < length; i++) {\n-        dump_double(writer, array->double_at(i));\n+      case T_DOUBLE : {\n+        for (int i = 0; i < length; i++) {\n+          dump_double(writer, array->double_at(i));\n+        }\n+        break;\n@@ -1439,1 +1451,1 @@\n-      break;\n+      default : ShouldNotReachHere();\n@@ -1441,1 +1453,0 @@\n-    default : ShouldNotReachHere();\n@@ -1502,0 +1513,1 @@\n+  bool _redact;\n@@ -1504,1 +1516,1 @@\n-  ClassDumper(AbstractDumpWriter* writer) : _writer(writer) {}\n+  ClassDumper(AbstractDumpWriter* writer, bool redact) : _writer(writer), _redact(redact) {}\n@@ -1508,1 +1520,1 @@\n-      DumperSupport::dump_instance_class(writer(), k);\n+      DumperSupport::dump_instance_class(writer(), k, _redact);\n@@ -1928,1 +1940,1 @@\n-\n+  bool _redact;\n@@ -1932,2 +1944,2 @@\n-  HeapObjectDumper(AbstractDumpWriter* writer, UnmountedVThreadDumper* vthread_dumper)\n-    : _writer(writer), _vthread_dumper(vthread_dumper) {}\n+  HeapObjectDumper(AbstractDumpWriter* writer, UnmountedVThreadDumper* vthread_dumper, bool redact)\n+    : _writer(writer), _vthread_dumper(vthread_dumper), _redact(redact) {}\n@@ -1953,1 +1965,1 @@\n-    DumperSupport::dump_instance(writer(), o, &_class_cache);\n+    DumperSupport::dump_instance(writer(), o, &_class_cache, _redact);\n@@ -1965,1 +1977,1 @@\n-    DumperSupport::dump_prim_array(writer(), typeArrayOop(o));\n+    DumperSupport::dump_prim_array(writer(), typeArrayOop(o), _redact);\n@@ -2199,0 +2211,1 @@\n+  bool                    _redact;\n@@ -2256,1 +2269,1 @@\n-  VM_HeapDumper(DumpWriter* writer, bool gc_before_heap_dump, bool oome, uint num_dump_threads) :\n+  VM_HeapDumper(DumpWriter* writer, bool gc_before_heap_dump, bool oome, uint num_dump_threads, bool redact) :\n@@ -2264,0 +2277,1 @@\n+    _redact = redact;\n@@ -2506,1 +2520,1 @@\n-      ClassDumper class_dumper(&segment_writer);\n+      ClassDumper class_dumper(&segment_writer, _redact);\n@@ -2534,1 +2548,1 @@\n-    HeapObjectDumper obj_dumper(&segment_writer, this);\n+    HeapObjectDumper obj_dumper(&segment_writer, this, _redact);\n@@ -2620,1 +2634,1 @@\n-int HeapDumper::dump(const char* path, outputStream* out, int compression, bool overwrite, uint num_dump_threads) {\n+int HeapDumper::dump(const char* path, outputStream* out, int compression, bool overwrite, bool redact, uint num_dump_threads) {\n@@ -2622,1 +2636,0 @@\n-\n@@ -2666,1 +2679,1 @@\n-  VM_HeapDumper dumper(&writer, _gc_before_heap_dump, _oome, num_dump_threads);\n+  VM_HeapDumper dumper(&writer, _gc_before_heap_dump, _oome, num_dump_threads, redact);\n@@ -2841,1 +2854,1 @@\n-  dumper.dump(my_path, tty, HeapDumpGzipLevel);\n+  dumper.dump(my_path, tty, HeapDumpGzipLevel, false, HeapDumpRedacted);\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":110,"deletions":97,"binary":false,"changes":207,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-  int dump(const char* path, outputStream* out = nullptr, int compression = -1, bool overwrite = false, uint parallel_thread_num = default_num_of_dump_threads());\n+  int dump(const char* path, outputStream* out = nullptr, int compression = -1, bool overwrite = false, bool redact = false, uint parallel_thread_num = default_num_of_dump_threads());\n","filename":"src\/hotspot\/share\/services\/heapDumper.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-        assert args.length <= 3;                \/\/ includes null\n+        assert args.length <= 4;                \/\/ includes null\n@@ -167,1 +167,1 @@\n-            for (int i = 0; i < 3; i++) {\n+            for (int i = 0; i < 4; i++) {\n","filename":"src\/jdk.attach\/aix\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-        assert args.length <= 3;                \/\/ includes null\n+        assert args.length <= 4;                \/\/ includes null\n@@ -171,1 +171,1 @@\n-            for (int i = 0; i < 3; i++) {\n+            for (int i = 0; i < 4; i++) {\n","filename":"src\/jdk.attach\/linux\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-        assert args.length <= 3;                \/\/ includes null\n+        assert args.length <= 4;                \/\/ includes null\n@@ -167,1 +167,1 @@\n-            for (int i = 0; i < 3; i++) {\n+            for (int i = 0; i < 4; i++) {\n","filename":"src\/jdk.attach\/macosx\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-        assert args.length <= 3;        \/\/ includes null\n+        assert args.length <= 4;        \/\/ includes null\n","filename":"src\/jdk.attach\/windows\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -209,0 +209,1 @@\n+        String redact = \"false\";\n@@ -229,0 +230,2 @@\n+            } else if (subopt.equals(\"redact\")) {\n+                redact = \"true\";\n@@ -243,1 +246,1 @@\n-        executeCommandForPid(pid, \"dumpheap\", filename, liveopt, compress_level);\n+        executeCommandForPid(pid, \"dumpheap\", filename, liveopt, compress_level, redact);\n@@ -310,0 +313,1 @@\n+        System.err.println(\"      redact       redact head dump by setting primitives to zero\");\n","filename":"src\/jdk.jcmd\/share\/classes\/sun\/tools\/jmap\/JMap.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,137 @@\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.io.IOException;\n+import java.util.List;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+\n+import jdk.test.lib.hprof.HprofParser;\n+import jdk.test.lib.hprof.parser.Reader;\n+import jdk.test.lib.hprof.model.JavaHeapObject;\n+import jdk.test.lib.hprof.model.*;\n+import java.util.Enumeration;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.dcmd.PidJcmdExecutor;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+\n+\n+\/*\n+ * @test\n+ * @summary  Test that primitive values in the heap dump are 0\n+ * @library \/test\/lib\n+ * @run main\/othervm HeapDumpRedactedTest\n+ *\/\n+\n+\n+ \/\/ test class with nonzero fields\n+ class PrimitiveTestTarget {\n+    byte byteTest = 0x1;\n+    char character = 'A';\n+    short shortInt = Short.MAX_VALUE;\n+    int integer = Integer.MAX_VALUE;\n+    long longInt = Long.MAX_VALUE;\n+    float floatValue = 123.456f;\n+    double doubleValue = 987.654;\n+    boolean bool = true;\n+\n+    \/\/ Array of primitive types\n+    byte[] byteArray = {0x1,0x2,0x3,0x4,0x5};\n+    char[] charArray = {'a','b','c','d','e'};\n+    short[] shortArray = {1,2,3,4,5};\n+    int[] intArray = {1,2,3,4,5};\n+    float[] floatArray = {1.0f,2.0f,3.0f,4.0f,5.0f};\n+    double[] doubleArray = {1.0,2.0,3.0,4.0,Double.NaN};\n+    long[] longArray = {1,2,3,4,5};\n+    boolean[] boolArray = {true,false,true,false,true};\n+\n+    static int staticInt = 100;\n+    String str = \"test_string\";\n+}\n+\n+public class HeapDumpRedactedTest {\n+    public static void main(String[] args) throws Exception {\n+        PrimitiveTestTarget target = new PrimitiveTestTarget();\n+        PidJcmdExecutor executor = new PidJcmdExecutor();\n+        File dump = new File(\"jcmd.gc.heap_dump.\" + System.currentTimeMillis() + \".hprof\");\n+\n+        if (dump.exists()) {\n+            dump.delete();\n+        }\n+\n+        executor.execute(\"GC.heap_dump \" + dump.getAbsolutePath() + \" -redact\");\n+        Snapshot snapshot = Reader.readFile(dump.getAbsolutePath(), true, 0);\n+        snapshot.resolve(false);\n+        Enumeration<JavaHeapObject> things = snapshot.getThings();\n+\n+        \/\/ Find the test object from heap dump\n+        String className = PrimitiveTestTarget.class.getName();\n+        JavaClass testClass = snapshot.findClass(className);\n+        if (testClass == null) {\n+            throw new RuntimeException(\"Class '\" + className + \"' not found\");\n+        }\n+        int instanceCount = testClass.getInstancesCount(false);\n+        if (instanceCount < 1) {\n+            throw new RuntimeException(\"No instances of '\" + className + \"' found\");\n+        }\n+        JavaObject targetObject = (JavaObject) testClass.getInstances(false).nextElement();\n+\n+        \/\/ primitives\n+        testPrimitive(\"byteTest\", targetObject, \"0x0\");\n+        testPrimitive(\"character\", targetObject , \"\"+'\\u0000');\n+        testPrimitive(\"shortInt\", targetObject, \"0\");\n+        testPrimitive(\"integer\", targetObject, \"0\");\n+        testPrimitive(\"longInt\", targetObject, \"0\");\n+        testPrimitive(\"floatValue\", targetObject, \"0.0\");\n+        testPrimitive(\"doubleValue\", targetObject, \"0.0\");\n+        testPrimitive(\"bool\", targetObject, \"false\");\n+\n+        \/\/ arrays\n+        testPrimitiveArray(\"byteArray\", targetObject, \"0x0\");\n+        testPrimitiveArray(\"charArray\", targetObject , \"\"+'\\u0000');\n+        testPrimitiveArray(\"shortArray\", targetObject, \"0\");\n+        testPrimitiveArray(\"intArray\", targetObject, \"0\");\n+        testPrimitiveArray(\"longArray\", targetObject, \"0\");\n+        testPrimitiveArray(\"floatArray\", targetObject, \"0.0\");\n+        testPrimitiveArray(\"doubleArray\", targetObject, \"0.0\");\n+        testPrimitiveArray(\"boolArray\", targetObject, \"false\");\n+\n+        \/\/static field\n+        JavaThing staticInt =  testClass.getStaticField(\"staticInt\");\n+        Asserts.assertTrue(staticInt instanceof JavaValue);\n+        JavaValue value = (JavaValue) staticInt;\n+        Asserts.assertEquals(value.toString(), \"0\");\n+\n+        \/\/ Object (String)\n+        JavaObject str = getObject(\"str\", targetObject);\n+        testPrimitiveArray(\"value\", str, \"0x0\"); \/\/ String.value is byte array\n+\n+        HprofParser.parseAndVerify(dump);\n+        dump.delete();\n+    }\n+\n+    private static void testPrimitive(String fieldName, JavaObject obj, String expected) {\n+        JavaThing field = obj.getField(fieldName);\n+        Asserts.assertTrue(field instanceof JavaValue);\n+        JavaValue value = (JavaValue) field;\n+        Asserts.assertEquals(expected, value.toString());\n+    }\n+\n+    private static void testPrimitiveArray(String fieldName, JavaObject obj, String expected) {\n+        JavaHeapObject field = (JavaHeapObject) obj.getField(fieldName);\n+        Asserts.assertTrue(field instanceof JavaValueArray);\n+        JavaValueArray array = (JavaValueArray) field;\n+        JavaThing[] elements = array.getElements();\n+        for (JavaThing element : elements) {\n+            Asserts.assertTrue(element instanceof JavaValue);\n+            JavaValue value = (JavaValue) element;\n+            Asserts.assertEquals(expected, value.toString());\n+        }\n+    }\n+\n+    private static JavaObject getObject(String fieldName, JavaObject obj) {\n+        JavaHeapObject f = (JavaHeapObject) obj.getField(fieldName);\n+        Asserts.assertTrue(f instanceof JavaObject);\n+        return (JavaObject) f;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/gc\/HeapDumpRedactedTest.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"}]}