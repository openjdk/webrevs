{"files":[{"patch":"@@ -561,1 +561,3 @@\n-          \"Redact primitive type values from heap dump by setting \"         \\\n+          \"When HeapDumpOnOutOfMemoryError, HeapDumpBeforeFullGC \"          \\\n+          \"or HeapDumpAfterFullGC is on, \"                                  \\\n+          \"redact primitive type values from heap dump by setting \"         \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -252,3 +252,0 @@\n-    const char* redact_str = op->arg(3);\n-    bool redact = redact_str != nullptr && strcmp(redact_str, \"true\") == 0;\n-\n@@ -260,1 +257,1 @@\n-    dumper.dump(path, out, level, false, redact);\n+    dumper.dump(path, out, level);\n","filename":"src\/hotspot\/share\/services\/attachListener.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-    arg_count_max = 4           \/\/ maximum number of arguments\n+    arg_count_max = 3           \/\/ maximum number of arguments\n","filename":"src\/hotspot\/share\/services\/attachListener.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -487,1 +487,1 @@\n-  _redact(\"-redact\", \"redact heap dump by setting primitives to zero\", \"BOOLEAN\", false, \"false\") {\n+  _redact(\"-redact\", \"Redact heap dump by setting primitives to zero\", \"BOOLEAN\", false, \"false\") {\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -762,1 +762,3 @@\n-  static void dump_field_value(AbstractDumpWriter* writer, char type, oop obj, int offset, bool redact);\n+  static void dump_field_value(AbstractDumpWriter* writer, char type, oop obj, int offset);\n+  \/\/ dumps the given field redacting all primitives\n+  static void dump_redacted_field_value(AbstractDumpWriter* writer, char type, oop obj, int offset);\n@@ -999,1 +1001,1 @@\n-void DumperSupport::dump_field_value(AbstractDumpWriter* writer, char type, oop obj, int offset, bool redact) {\n+void DumperSupport::dump_field_value(AbstractDumpWriter* writer, char type, oop obj, int offset) {\n@@ -1010,1 +1012,1 @@\n-      jbyte b = redact ? 0 : obj->byte_field(offset);\n+      jbyte b = obj->byte_field(offset);\n@@ -1015,1 +1017,1 @@\n-      jchar c = redact ? 0 : obj->char_field(offset);\n+      jchar c = obj->char_field(offset);\n@@ -1020,1 +1022,1 @@\n-      jshort s = redact ? 0 : obj->short_field(offset);\n+      jshort s = obj->short_field(offset);\n@@ -1025,1 +1027,1 @@\n-      jfloat f = redact ? 0 : obj->float_field(offset);\n+      jfloat f = obj->float_field(offset);\n@@ -1030,1 +1032,1 @@\n-      jdouble d = redact ? 0 : obj->double_field(offset);\n+      jdouble d = obj->double_field(offset);\n@@ -1035,1 +1037,1 @@\n-      jint i = redact ? 0 : obj->int_field(offset);\n+      jint i = obj->int_field(offset);\n@@ -1040,1 +1042,1 @@\n-      jlong l = redact ? 0 : obj->long_field(offset);\n+      jlong l = obj->long_field(offset);\n@@ -1045,1 +1047,1 @@\n-      jboolean b = redact ? false : obj->bool_field(offset);\n+      jboolean b = obj->bool_field(offset);\n@@ -1056,0 +1058,37 @@\n+void DumperSupport::dump_redacted_field_value(AbstractDumpWriter* writer, char type, oop obj, int offset) {\n+  switch (type) {\n+    case JVM_SIGNATURE_CLASS :\n+    case JVM_SIGNATURE_ARRAY : {\n+      oop o = obj->obj_field_access<ON_UNKNOWN_OOP_REF | AS_NO_KEEPALIVE>(offset);\n+      o = mask_dormant_archived_object(o, obj);\n+      assert(oopDesc::is_oop_or_null(o), \"Expected an oop or nullptr at \" PTR_FORMAT, p2i(o));\n+      writer->write_objectID(o);\n+      break;\n+    }\n+    case JVM_SIGNATURE_BOOLEAN :\n+    case JVM_SIGNATURE_BYTE : {\n+      writer->write_u1(0);\n+      break;\n+    }\n+    case JVM_SIGNATURE_CHAR :\n+    case JVM_SIGNATURE_SHORT : {\n+      writer->write_u2(0);\n+      break;\n+    }\n+    case JVM_SIGNATURE_FLOAT :\n+    case JVM_SIGNATURE_INT : {\n+      writer->write_u4(0);\n+      break;\n+    }\n+    case JVM_SIGNATURE_DOUBLE :\n+    case JVM_SIGNATURE_LONG : {\n+      writer->write_u8(0);\n+      break;\n+    }\n+    default : {\n+      ShouldNotReachHere();\n+      break;\n+    }\n+  }\n+}\n+\n@@ -1125,1 +1164,5 @@\n-      dump_field_value(writer, sig->char_at(0), ik->java_mirror(), fld.offset(), redact);\n+      if (redact) {\n+        dump_redacted_field_value(writer, sig->char_at(0), ik->java_mirror(), fld.offset());\n+      } else {\n+        dump_field_value(writer, sig->char_at(0), ik->java_mirror(), fld.offset());\n+      }\n@@ -1159,1 +1202,5 @@\n-    dump_field_value(writer, class_cache_entry->sig_start(idx), o, class_cache_entry->offset(idx), redact);\n+    if (redact) {\n+      dump_redacted_field_value(writer, class_cache_entry->sig_start(idx), o, class_cache_entry->offset(idx));\n+    } else {\n+      dump_field_value(writer, class_cache_entry->sig_start(idx), o, class_cache_entry->offset(idx));\n+    }\n@@ -1386,15 +1433,12 @@\n-    writer->write_raw(nullptr, length_in_bytes); \/\/nullptr to write zeros\n-  } else {\n-    \/\/ If the byte ordering is big endian then we can copy most types directly\n-    switch (type) {\n-      case T_INT : {\n-        if (Endian::is_Java_byte_ordering_different()) {\n-          WRITE_ARRAY(array, int, u4, length);\n-        } else {\n-          writer->write_raw(array->int_at_addr(0), length_in_bytes);\n-        }\n-        break;\n-      }\n-      case T_BYTE : {\n-        writer->write_raw(array->byte_at_addr(0), length_in_bytes);\n-        break;\n+    writer->write_raw(nullptr, length_in_bytes); \/\/ nullptr to write zeros\n+    writer->end_sub_record();\n+    return;\n+  }\n+\n+  \/\/ If the byte ordering is big endian then we can copy most types directly\n+  switch (type) {\n+    case T_INT : {\n+      if (Endian::is_Java_byte_ordering_different()) {\n+        WRITE_ARRAY(array, int, u4, length);\n+      } else {\n+        writer->write_raw(array->int_at_addr(0), length_in_bytes);\n@@ -1402,7 +1446,11 @@\n-      case T_CHAR : {\n-        if (Endian::is_Java_byte_ordering_different()) {\n-          WRITE_ARRAY(array, char, u2, length);\n-        } else {\n-          writer->write_raw(array->char_at_addr(0), length_in_bytes);\n-        }\n-        break;\n+      break;\n+    }\n+    case T_BYTE : {\n+      writer->write_raw(array->byte_at_addr(0), length_in_bytes);\n+      break;\n+    }\n+    case T_CHAR : {\n+      if (Endian::is_Java_byte_ordering_different()) {\n+        WRITE_ARRAY(array, char, u2, length);\n+      } else {\n+        writer->write_raw(array->char_at_addr(0), length_in_bytes);\n@@ -1410,7 +1458,7 @@\n-      case T_SHORT : {\n-        if (Endian::is_Java_byte_ordering_different()) {\n-          WRITE_ARRAY(array, short, u2, length);\n-        } else {\n-          writer->write_raw(array->short_at_addr(0), length_in_bytes);\n-        }\n-        break;\n+      break;\n+    }\n+    case T_SHORT : {\n+      if (Endian::is_Java_byte_ordering_different()) {\n+        WRITE_ARRAY(array, short, u2, length);\n+      } else {\n+        writer->write_raw(array->short_at_addr(0), length_in_bytes);\n@@ -1418,7 +1466,7 @@\n-      case T_BOOLEAN : {\n-        if (Endian::is_Java_byte_ordering_different()) {\n-          WRITE_ARRAY(array, bool, u1, length);\n-        } else {\n-          writer->write_raw(array->bool_at_addr(0), length_in_bytes);\n-        }\n-        break;\n+      break;\n+    }\n+    case T_BOOLEAN : {\n+      if (Endian::is_Java_byte_ordering_different()) {\n+        WRITE_ARRAY(array, bool, u1, length);\n+      } else {\n+        writer->write_raw(array->bool_at_addr(0), length_in_bytes);\n@@ -1426,7 +1474,7 @@\n-      case T_LONG : {\n-        if (Endian::is_Java_byte_ordering_different()) {\n-          WRITE_ARRAY(array, long, u8, length);\n-        } else {\n-          writer->write_raw(array->long_at_addr(0), length_in_bytes);\n-        }\n-        break;\n+      break;\n+    }\n+    case T_LONG : {\n+      if (Endian::is_Java_byte_ordering_different()) {\n+        WRITE_ARRAY(array, long, u8, length);\n+      } else {\n+        writer->write_raw(array->long_at_addr(0), length_in_bytes);\n@@ -1434,0 +1482,2 @@\n+      break;\n+    }\n@@ -1435,9 +1485,6 @@\n-      \/\/ handle float\/doubles in a special value to ensure than NaNs are\n-      \/\/ written correctly. TO DO: Check if we can avoid this on processors that\n-      \/\/ use IEEE 754.\n-\n-      case T_FLOAT : {\n-        for (int i = 0; i < length; i++) {\n-          dump_float(writer, array->float_at(i));\n-        }\n-        break;\n+    \/\/ handle float\/doubles in a special value to ensure than NaNs are\n+    \/\/ written correctly. TO DO: Check if we can avoid this on processors that\n+    \/\/ use IEEE 754.\n+    case T_FLOAT : {\n+      for (int i = 0; i < length; i++) {\n+        dump_float(writer, array->float_at(i));\n@@ -1445,5 +1492,5 @@\n-      case T_DOUBLE : {\n-        for (int i = 0; i < length; i++) {\n-          dump_double(writer, array->double_at(i));\n-        }\n-        break;\n+      break;\n+    }\n+    case T_DOUBLE : {\n+      for (int i = 0; i < length; i++) {\n+        dump_double(writer, array->double_at(i));\n@@ -1451,1 +1498,1 @@\n-      default : ShouldNotReachHere();\n+      break;\n@@ -1453,0 +1500,1 @@\n+    default : ShouldNotReachHere();\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":118,"deletions":70,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-        assert args.length <= 4;                \/\/ includes null\n+        assert args.length <= 3;                \/\/ includes null\n@@ -167,1 +167,1 @@\n-            for (int i = 0; i < 4; i++) {\n+            for (int i = 0; i < 3; i++) {\n","filename":"src\/jdk.attach\/aix\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-        assert args.length <= 4;                \/\/ includes null\n+        assert args.length <= 3;                \/\/ includes null\n@@ -171,1 +171,1 @@\n-            for (int i = 0; i < 4; i++) {\n+            for (int i = 0; i < 3; i++) {\n","filename":"src\/jdk.attach\/linux\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-        assert args.length <= 4;                \/\/ includes null\n+        assert args.length <= 3;                \/\/ includes null\n@@ -167,1 +167,1 @@\n-            for (int i = 0; i < 4; i++) {\n+            for (int i = 0; i < 3; i++) {\n","filename":"src\/jdk.attach\/macosx\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-        assert args.length <= 4;        \/\/ includes null\n+        assert args.length <= 3;        \/\/ includes null\n","filename":"src\/jdk.attach\/windows\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -209,1 +209,0 @@\n-        String redact = \"false\";\n@@ -230,2 +229,0 @@\n-            } else if (subopt.equals(\"redact\")) {\n-                redact = \"true\";\n@@ -246,1 +243,1 @@\n-        executeCommandForPid(pid, \"dumpheap\", filename, liveopt, compress_level, redact);\n+        executeCommandForPid(pid, \"dumpheap\", filename, liveopt, compress_level);\n@@ -313,1 +310,0 @@\n-        System.err.println(\"      redact       redact head dump by setting primitives to zero\");\n","filename":"src\/jdk.jcmd\/share\/classes\/sun\/tools\/jmap\/JMap.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -17,2 +17,0 @@\n-\n-\n@@ -26,3 +24,2 @@\n-\n- \/\/ test class with nonzero fields\n- class PrimitiveTestTarget {\n+\/\/ test class with nonzero fields\n+class PrimitiveTestTarget {\n@@ -39,8 +36,8 @@\n-    byte[] byteArray = {0x1,0x2,0x3,0x4,0x5};\n-    char[] charArray = {'a','b','c','d','e'};\n-    short[] shortArray = {1,2,3,4,5};\n-    int[] intArray = {1,2,3,4,5};\n-    float[] floatArray = {1.0f,2.0f,3.0f,4.0f,5.0f};\n-    double[] doubleArray = {1.0,2.0,3.0,4.0,Double.NaN};\n-    long[] longArray = {1,2,3,4,5};\n-    boolean[] boolArray = {true,false,true,false,true};\n+    byte[] byteArray = { 0x1, 0x2, 0x3, 0x4, 0x5 };\n+    char[] charArray = { 'a', 'b', 'c', 'd', 'e' };\n+    short[] shortArray = { 1, 2, 3, 4, 5 };\n+    int[] intArray = { 1, 2, 3, 4, 5 };\n+    float[] floatArray = { 1.0f, 2.0f, 3.0f, 4.0f, 5.0f };\n+    double[] doubleArray = { 1.0, 2.0, 3.0, 4.0, Double.NaN };\n+    long[] longArray = { 1, 2, 3, 4, 5 };\n+    boolean[] boolArray = { true, false, true, false, true };\n@@ -81,1 +78,1 @@\n-        testPrimitive(\"character\", targetObject , \"\"+'\\u0000');\n+        testPrimitive(\"character\", targetObject, \"\" + '\\u0000');\n@@ -91,1 +88,1 @@\n-        testPrimitiveArray(\"charArray\", targetObject , \"\"+'\\u0000');\n+        testPrimitiveArray(\"charArray\", targetObject, \"\" + '\\u0000');\n@@ -99,2 +96,2 @@\n-        \/\/static field\n-        JavaThing staticInt =  testClass.getStaticField(\"staticInt\");\n+        \/\/ static field\n+        JavaThing staticInt = testClass.getStaticField(\"staticInt\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/gc\/HeapDumpRedactedTest.java","additions":14,"deletions":17,"binary":false,"changes":31,"status":"modified"}]}