{"files":[{"patch":"@@ -560,0 +560,6 @@\n+  product(bool, HeapDumpRedacted, false, MANAGEABLE,                        \\\n+          \"When HeapDumpOnOutOfMemoryError, HeapDumpBeforeFullGC \"          \\\n+          \"or HeapDumpAfterFullGC is on, \"                                  \\\n+          \"redact primitive type values from heap dump by setting \"         \\\n+          \"them to zero.\")                                                  \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -486,1 +486,2 @@\n-            \"INT\", false, \"1\") {\n+            \"INT\", false, \"1\"),\n+  _redact(\"-redact\", \"Redact heap dump by setting primitives to zero\", \"BOOLEAN\", false, \"false\") {\n@@ -492,0 +493,1 @@\n+  _dcmdparser.add_dcmd_option(&_redact);\n@@ -523,1 +525,1 @@\n-  dumper.dump(_filename.value(), output(), (int) level, _overwrite.value(), (uint)parallel);\n+  dumper.dump(_filename.value(), output(), (int) level, _overwrite.value(), _redact.value(), (uint)parallel);\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -324,0 +324,1 @@\n+  DCmdArgument<bool> _redact;\n@@ -325,1 +326,1 @@\n-  static int num_arguments() { return 5; }\n+  static int num_arguments() { return 6; }\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -467,1 +467,1 @@\n-\/\/ write raw bytes\n+\/\/ write raw bytes, writes 0 if s is nullptr which is used for redaction\n@@ -477,2 +477,6 @@\n-    memcpy(buffer() + position(), s, to_write);\n-    s = (void*) ((char*) s + to_write);\n+    if (s == nullptr) {\n+      memset(buffer() + position(), 0, to_write);\n+    } else {\n+      memcpy(buffer() + position(), s, to_write);\n+      s = (void*) ((char*) s + to_write);\n+    }\n@@ -484,1 +488,5 @@\n-  memcpy(buffer() + position(), s, len);\n+  if (s == nullptr) {\n+    memset(buffer() + position(), 0, len);\n+  } else {\n+    memcpy(buffer() + position(), s, len);\n+  }\n@@ -755,0 +763,2 @@\n+  \/\/ dumps the given field redacting all primitives\n+  static void dump_redacted_field_value(AbstractDumpWriter* writer, char type, oop obj, int offset);\n@@ -758,1 +768,1 @@\n-  static void dump_static_fields(AbstractDumpWriter* writer, Klass* k);\n+  static void dump_static_fields(AbstractDumpWriter* writer, Klass* k, bool redact);\n@@ -760,1 +770,1 @@\n-  static void dump_instance_fields(AbstractDumpWriter* writer, oop o, DumperClassCacheTableEntry* class_cache_entry);\n+  static void dump_instance_fields(AbstractDumpWriter* writer, oop o, DumperClassCacheTableEntry* class_cache_entry, bool redact);\n@@ -766,1 +776,1 @@\n-  static void dump_instance(AbstractDumpWriter* writer, oop o, DumperClassCacheTable* class_cache);\n+  static void dump_instance(AbstractDumpWriter* writer, oop o, DumperClassCacheTable* class_cache, bool redact);\n@@ -768,1 +778,1 @@\n-  static void dump_instance_class(AbstractDumpWriter* writer, Klass* k);\n+  static void dump_instance_class(AbstractDumpWriter* writer, Klass* k, bool redact);\n@@ -775,1 +785,1 @@\n-  static void dump_prim_array(AbstractDumpWriter* writer, typeArrayOop array);\n+  static void dump_prim_array(AbstractDumpWriter* writer, typeArrayOop array, bool redact);\n@@ -1048,0 +1058,37 @@\n+void DumperSupport::dump_redacted_field_value(AbstractDumpWriter* writer, char type, oop obj, int offset) {\n+  switch (type) {\n+    case JVM_SIGNATURE_CLASS :\n+    case JVM_SIGNATURE_ARRAY : {\n+      oop o = obj->obj_field_access<ON_UNKNOWN_OOP_REF | AS_NO_KEEPALIVE>(offset);\n+      o = mask_dormant_archived_object(o, obj);\n+      assert(oopDesc::is_oop_or_null(o), \"Expected an oop or nullptr at \" PTR_FORMAT, p2i(o));\n+      writer->write_objectID(o);\n+      break;\n+    }\n+    case JVM_SIGNATURE_BOOLEAN :\n+    case JVM_SIGNATURE_BYTE : {\n+      writer->write_u1(0);\n+      break;\n+    }\n+    case JVM_SIGNATURE_CHAR :\n+    case JVM_SIGNATURE_SHORT : {\n+      writer->write_u2(0);\n+      break;\n+    }\n+    case JVM_SIGNATURE_FLOAT :\n+    case JVM_SIGNATURE_INT : {\n+      writer->write_u4(0);\n+      break;\n+    }\n+    case JVM_SIGNATURE_DOUBLE :\n+    case JVM_SIGNATURE_LONG : {\n+      writer->write_u8(0);\n+      break;\n+    }\n+    default : {\n+      ShouldNotReachHere();\n+      break;\n+    }\n+  }\n+}\n+\n@@ -1105,1 +1152,1 @@\n-void DumperSupport::dump_static_fields(AbstractDumpWriter* writer, Klass* k) {\n+void DumperSupport::dump_static_fields(AbstractDumpWriter* writer, Klass* k, bool redact) {\n@@ -1117,1 +1164,5 @@\n-      dump_field_value(writer, sig->char_at(0), ik->java_mirror(), fld.offset());\n+      if (redact) {\n+        dump_redacted_field_value(writer, sig->char_at(0), ik->java_mirror(), fld.offset());\n+      } else {\n+        dump_field_value(writer, sig->char_at(0), ik->java_mirror(), fld.offset());\n+      }\n@@ -1148,1 +1199,1 @@\n-void DumperSupport::dump_instance_fields(AbstractDumpWriter* writer, oop o, DumperClassCacheTableEntry* class_cache_entry) {\n+void DumperSupport::dump_instance_fields(AbstractDumpWriter* writer, oop o, DumperClassCacheTableEntry* class_cache_entry, bool redact) {\n@@ -1151,1 +1202,5 @@\n-    dump_field_value(writer, class_cache_entry->sig_start(idx), o, class_cache_entry->offset(idx));\n+    if (redact) {\n+      dump_redacted_field_value(writer, class_cache_entry->sig_start(idx), o, class_cache_entry->offset(idx));\n+    } else {\n+      dump_field_value(writer, class_cache_entry->sig_start(idx), o, class_cache_entry->offset(idx));\n+    }\n@@ -1182,1 +1237,1 @@\n-void DumperSupport::dump_instance(AbstractDumpWriter* writer, oop o, DumperClassCacheTable* class_cache) {\n+void DumperSupport::dump_instance(AbstractDumpWriter* writer, oop o, DumperClassCacheTable* class_cache, bool redact) {\n@@ -1201,1 +1256,1 @@\n-  dump_instance_fields(writer, o, cache_entry);\n+  dump_instance_fields(writer, o, cache_entry, redact);\n@@ -1207,1 +1262,1 @@\n-void DumperSupport::dump_instance_class(AbstractDumpWriter* writer, Klass* k) {\n+void DumperSupport::dump_instance_class(AbstractDumpWriter* writer, Klass* k, bool redact) {\n@@ -1253,1 +1308,1 @@\n-  dump_static_fields(writer, ik);\n+  dump_static_fields(writer, ik, redact);\n@@ -1355,1 +1410,1 @@\n-void DumperSupport::dump_prim_array(AbstractDumpWriter* writer, typeArrayOop array) {\n+void DumperSupport::dump_prim_array(AbstractDumpWriter* writer, typeArrayOop array, bool redact) {\n@@ -1377,1 +1432,5 @@\n-  \/\/ If the byte ordering is big endian then we can copy most types directly\n+  if (redact) {\n+    writer->write_raw(nullptr, length_in_bytes); \/\/ nullptr to write zeros\n+    writer->end_sub_record();\n+    return;\n+  }\n@@ -1379,0 +1438,1 @@\n+  \/\/ If the byte ordering is big endian then we can copy most types directly\n@@ -1428,1 +1488,0 @@\n-\n@@ -1502,0 +1561,1 @@\n+  bool _redact;\n@@ -1504,1 +1564,1 @@\n-  ClassDumper(AbstractDumpWriter* writer) : _writer(writer) {}\n+  ClassDumper(AbstractDumpWriter* writer, bool redact) : _writer(writer), _redact(redact) {}\n@@ -1508,1 +1568,1 @@\n-      DumperSupport::dump_instance_class(writer(), k);\n+      DumperSupport::dump_instance_class(writer(), k, _redact);\n@@ -1928,1 +1988,1 @@\n-\n+  bool _redact;\n@@ -1932,2 +1992,2 @@\n-  HeapObjectDumper(AbstractDumpWriter* writer, UnmountedVThreadDumper* vthread_dumper)\n-    : _writer(writer), _vthread_dumper(vthread_dumper) {}\n+  HeapObjectDumper(AbstractDumpWriter* writer, UnmountedVThreadDumper* vthread_dumper, bool redact)\n+    : _writer(writer), _vthread_dumper(vthread_dumper), _redact(redact) {}\n@@ -1953,1 +2013,1 @@\n-    DumperSupport::dump_instance(writer(), o, &_class_cache);\n+    DumperSupport::dump_instance(writer(), o, &_class_cache, _redact);\n@@ -1965,1 +2025,1 @@\n-    DumperSupport::dump_prim_array(writer(), typeArrayOop(o));\n+    DumperSupport::dump_prim_array(writer(), typeArrayOop(o), _redact);\n@@ -2199,0 +2259,1 @@\n+  bool                    _redact;\n@@ -2256,1 +2317,1 @@\n-  VM_HeapDumper(DumpWriter* writer, bool gc_before_heap_dump, bool oome, uint num_dump_threads) :\n+  VM_HeapDumper(DumpWriter* writer, bool gc_before_heap_dump, bool oome, uint num_dump_threads, bool redact) :\n@@ -2264,0 +2325,1 @@\n+    _redact = redact;\n@@ -2506,1 +2568,1 @@\n-      ClassDumper class_dumper(&segment_writer);\n+      ClassDumper class_dumper(&segment_writer, _redact);\n@@ -2534,1 +2596,1 @@\n-    HeapObjectDumper obj_dumper(&segment_writer, this);\n+    HeapObjectDumper obj_dumper(&segment_writer, this, _redact);\n@@ -2620,1 +2682,1 @@\n-int HeapDumper::dump(const char* path, outputStream* out, int compression, bool overwrite, uint num_dump_threads) {\n+int HeapDumper::dump(const char* path, outputStream* out, int compression, bool overwrite, bool redact, uint num_dump_threads) {\n@@ -2622,1 +2684,0 @@\n-\n@@ -2666,1 +2727,1 @@\n-  VM_HeapDumper dumper(&writer, _gc_before_heap_dump, _oome, num_dump_threads);\n+  VM_HeapDumper dumper(&writer, _gc_before_heap_dump, _oome, num_dump_threads, redact);\n@@ -2841,1 +2902,1 @@\n-  dumper.dump(my_path, tty, HeapDumpGzipLevel);\n+  dumper.dump(my_path, tty, HeapDumpGzipLevel, false, HeapDumpRedacted);\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":95,"deletions":34,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-  int dump(const char* path, outputStream* out = nullptr, int compression = -1, bool overwrite = false, uint parallel_thread_num = default_num_of_dump_threads());\n+  int dump(const char* path, outputStream* out = nullptr, int compression = -1, bool overwrite = false, bool redact = false, uint parallel_thread_num = default_num_of_dump_threads());\n","filename":"src\/hotspot\/share\/services\/heapDumper.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,134 @@\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.io.IOException;\n+import java.util.List;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+\n+import jdk.test.lib.hprof.HprofParser;\n+import jdk.test.lib.hprof.parser.Reader;\n+import jdk.test.lib.hprof.model.JavaHeapObject;\n+import jdk.test.lib.hprof.model.*;\n+import java.util.Enumeration;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.dcmd.PidJcmdExecutor;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+\/*\n+ * @test\n+ * @summary  Test that primitive values in the heap dump are 0\n+ * @library \/test\/lib\n+ * @run main\/othervm HeapDumpRedactedTest\n+ *\/\n+\n+\/\/ test class with nonzero fields\n+class PrimitiveTestTarget {\n+    byte byteTest = 0x1;\n+    char character = 'A';\n+    short shortInt = Short.MAX_VALUE;\n+    int integer = Integer.MAX_VALUE;\n+    long longInt = Long.MAX_VALUE;\n+    float floatValue = 123.456f;\n+    double doubleValue = 987.654;\n+    boolean bool = true;\n+\n+    \/\/ Array of primitive types\n+    byte[] byteArray = { 0x1, 0x2, 0x3, 0x4, 0x5 };\n+    char[] charArray = { 'a', 'b', 'c', 'd', 'e' };\n+    short[] shortArray = { 1, 2, 3, 4, 5 };\n+    int[] intArray = { 1, 2, 3, 4, 5 };\n+    float[] floatArray = { 1.0f, 2.0f, 3.0f, 4.0f, 5.0f };\n+    double[] doubleArray = { 1.0, 2.0, 3.0, 4.0, Double.NaN };\n+    long[] longArray = { 1, 2, 3, 4, 5 };\n+    boolean[] boolArray = { true, false, true, false, true };\n+\n+    static int staticInt = 100;\n+    String str = \"test_string\";\n+}\n+\n+public class HeapDumpRedactedTest {\n+    public static void main(String[] args) throws Exception {\n+        PrimitiveTestTarget target = new PrimitiveTestTarget();\n+        PidJcmdExecutor executor = new PidJcmdExecutor();\n+        File dump = new File(\"jcmd.gc.heap_dump.\" + System.currentTimeMillis() + \".hprof\");\n+\n+        if (dump.exists()) {\n+            dump.delete();\n+        }\n+\n+        executor.execute(\"GC.heap_dump \" + dump.getAbsolutePath() + \" -redact\");\n+        Snapshot snapshot = Reader.readFile(dump.getAbsolutePath(), true, 0);\n+        snapshot.resolve(false);\n+        Enumeration<JavaHeapObject> things = snapshot.getThings();\n+\n+        \/\/ Find the test object from heap dump\n+        String className = PrimitiveTestTarget.class.getName();\n+        JavaClass testClass = snapshot.findClass(className);\n+        if (testClass == null) {\n+            throw new RuntimeException(\"Class '\" + className + \"' not found\");\n+        }\n+        int instanceCount = testClass.getInstancesCount(false);\n+        if (instanceCount < 1) {\n+            throw new RuntimeException(\"No instances of '\" + className + \"' found\");\n+        }\n+        JavaObject targetObject = (JavaObject) testClass.getInstances(false).nextElement();\n+\n+        \/\/ primitives\n+        testPrimitive(\"byteTest\", targetObject, \"0x0\");\n+        testPrimitive(\"character\", targetObject, \"\" + '\\u0000');\n+        testPrimitive(\"shortInt\", targetObject, \"0\");\n+        testPrimitive(\"integer\", targetObject, \"0\");\n+        testPrimitive(\"longInt\", targetObject, \"0\");\n+        testPrimitive(\"floatValue\", targetObject, \"0.0\");\n+        testPrimitive(\"doubleValue\", targetObject, \"0.0\");\n+        testPrimitive(\"bool\", targetObject, \"false\");\n+\n+        \/\/ arrays\n+        testPrimitiveArray(\"byteArray\", targetObject, \"0x0\");\n+        testPrimitiveArray(\"charArray\", targetObject, \"\" + '\\u0000');\n+        testPrimitiveArray(\"shortArray\", targetObject, \"0\");\n+        testPrimitiveArray(\"intArray\", targetObject, \"0\");\n+        testPrimitiveArray(\"longArray\", targetObject, \"0\");\n+        testPrimitiveArray(\"floatArray\", targetObject, \"0.0\");\n+        testPrimitiveArray(\"doubleArray\", targetObject, \"0.0\");\n+        testPrimitiveArray(\"boolArray\", targetObject, \"false\");\n+\n+        \/\/ static field\n+        JavaThing staticInt = testClass.getStaticField(\"staticInt\");\n+        Asserts.assertTrue(staticInt instanceof JavaValue);\n+        JavaValue value = (JavaValue) staticInt;\n+        Asserts.assertEquals(value.toString(), \"0\");\n+\n+        \/\/ Object (String)\n+        JavaObject str = getObject(\"str\", targetObject);\n+        testPrimitiveArray(\"value\", str, \"0x0\"); \/\/ String.value is byte array\n+\n+        HprofParser.parseAndVerify(dump);\n+        dump.delete();\n+    }\n+\n+    private static void testPrimitive(String fieldName, JavaObject obj, String expected) {\n+        JavaThing field = obj.getField(fieldName);\n+        Asserts.assertTrue(field instanceof JavaValue);\n+        JavaValue value = (JavaValue) field;\n+        Asserts.assertEquals(expected, value.toString());\n+    }\n+\n+    private static void testPrimitiveArray(String fieldName, JavaObject obj, String expected) {\n+        JavaHeapObject field = (JavaHeapObject) obj.getField(fieldName);\n+        Asserts.assertTrue(field instanceof JavaValueArray);\n+        JavaValueArray array = (JavaValueArray) field;\n+        JavaThing[] elements = array.getElements();\n+        for (JavaThing element : elements) {\n+            Asserts.assertTrue(element instanceof JavaValue);\n+            JavaValue value = (JavaValue) element;\n+            Asserts.assertEquals(expected, value.toString());\n+        }\n+    }\n+\n+    private static JavaObject getObject(String fieldName, JavaObject obj) {\n+        JavaHeapObject f = (JavaHeapObject) obj.getField(fieldName);\n+        Asserts.assertTrue(f instanceof JavaObject);\n+        return (JavaObject) f;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/gc\/HeapDumpRedactedTest.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"}]}