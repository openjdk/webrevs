{"files":[{"patch":"@@ -1129,0 +1129,4 @@\n+\/\/ Figure out which register class each belongs in: rc_int, rc_float or\n+\/\/ rc_stack.\n+enum RC { rc_bad, rc_int, rc_float, rc_predicate, rc_stack };\n+\n@@ -1907,4 +1911,0 @@\n-\/\/ Figure out which register class each belongs in: rc_int, rc_float or\n-\/\/ rc_stack.\n-enum RC { rc_bad, rc_int, rc_float, rc_predicate, rc_stack };\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1084,0 +1084,29 @@\n+OptoReg::Name ZBarrierSetAssembler::encode_float_vector_register_size(const Node* node, OptoReg::Name opto_reg) {\n+  switch (node->ideal_reg()) {\n+    case Op_RegF:\n+      \/\/ No need to refine. The original encoding is already fine to distinguish.\n+      assert(opto_reg % 4 == 0, \"Float register should only occupy a single slot\");\n+      break;\n+    \/\/ Use different encoding values of the same fp\/vector register to help distinguish different sizes.\n+    \/\/ Such as V16. The OptoReg::name and its corresponding slot value are\n+    \/\/ \"V16\": 64, \"V16_H\": 65, \"V16_J\": 66, \"V16_K\": 67.\n+    case Op_RegD:\n+    case Op_VecD:\n+      opto_reg &= ~3;\n+      opto_reg |= 1;\n+      break;\n+    case Op_VecX:\n+      opto_reg &= ~3;\n+      opto_reg |= 2;\n+      break;\n+    case Op_VecA:\n+      opto_reg &= ~3;\n+      opto_reg |= 3;\n+      break;\n+    default:\n+      assert(false, \"unexpected ideal register\");\n+      ShouldNotReachHere();\n+  }\n+  return opto_reg;\n+}\n+\n@@ -1091,1 +1120,1 @@\n-    return opto_reg & ~1;\n+    opto_reg = encode_float_vector_register_size(node, opto_reg);\n@@ -1102,0 +1131,10 @@\n+  struct RegisterData {\n+    VMReg _reg;\n+    int   _slots; \/\/ slots occupied once pushed into stack\n+\n+    \/\/ Used by GrowableArray::find()\n+    bool operator == (const RegisterData& other) {\n+      return _reg == other._reg;\n+    }\n+  };\n+\n@@ -1105,0 +1144,2 @@\n+  FloatRegSet           _neon_regs;\n+  FloatRegSet           _sve_regs;\n@@ -1109,1 +1150,4 @@\n-    \/\/ Record registers that needs to be saved\/restored\n+    int index = -1;\n+    GrowableArray<RegisterData> registers;\n+    VMReg prev_vm_reg = VMRegImpl::Bad();\n+\n@@ -1112,6 +1156,41 @@\n-      const OptoReg::Name opto_reg = rmi.next();\n-      if (OptoReg::is_reg(opto_reg)) {\n-        const VMReg vm_reg = OptoReg::as_VMReg(opto_reg);\n-        if (vm_reg->is_Register()) {\n-          _gp_regs += RegSet::of(vm_reg->as_Register());\n-        } else if (vm_reg->is_FloatRegister()) {\n+      OptoReg::Name opto_reg = rmi.next();\n+      VMReg vm_reg = OptoReg::as_VMReg(opto_reg);\n+\n+      if (vm_reg->is_Register()) {\n+        \/\/ GPR may have one or two slots in regmask\n+        \/\/ Determine whether the current vm_reg is the same physical register as the previous one\n+        if (is_same_register(vm_reg, prev_vm_reg)) {\n+          registers.at(index)._slots++;\n+        } else {\n+          RegisterData reg_data = { vm_reg, 1 };\n+          index = registers.append(reg_data);\n+        }\n+      } else if (vm_reg->is_FloatRegister()) {\n+        \/\/ We have size encoding in OptoReg of stub->live()\n+        \/\/ After encoding, float\/neon\/sve register has only one slot in regmask\n+        \/\/ Decode it to get the actual size\n+        VMReg vm_reg_base = vm_reg->as_FloatRegister()->as_VMReg();\n+        int slots = decode_float_vector_register_size(opto_reg);\n+        RegisterData reg_data = { vm_reg_base, slots };\n+        index = registers.append(reg_data);\n+      } else if (vm_reg->is_PRegister()) {\n+        \/\/ PRegister has only one slot in regmask\n+        RegisterData reg_data = { vm_reg, 1 };\n+        index = registers.append(reg_data);\n+      } else {\n+        assert(false, \"Unknown register type\");\n+        ShouldNotReachHere();\n+      }\n+      prev_vm_reg = vm_reg;\n+    }\n+\n+    \/\/ Record registers that needs to be saved\/restored\n+    for (GrowableArrayIterator<RegisterData> it = registers.begin(); it != registers.end(); ++it) {\n+      RegisterData reg_data = *it;\n+      VMReg vm_reg = reg_data._reg;\n+      int slots = reg_data._slots;\n+      if (vm_reg->is_Register()) {\n+        assert(slots == 1 || slots == 2, \"Unexpected register save size\");\n+        _gp_regs += RegSet::of(vm_reg->as_Register());\n+      } else if (vm_reg->is_FloatRegister()) {\n+        if (slots == 1 || slots == 2) {\n@@ -1119,2 +1198,2 @@\n-        } else if (vm_reg->is_PRegister()) {\n-          _p_regs += PRegSet::of(vm_reg->as_PRegister());\n+        } else if (slots == 4) {\n+          _neon_regs += FloatRegSet::of(vm_reg->as_FloatRegister());\n@@ -1122,1 +1201,2 @@\n-          fatal(\"Unknown register type\");\n+          assert(slots == Matcher::scalable_vector_reg_size(T_FLOAT), \"Unexpected register save size\");\n+          _sve_regs += FloatRegSet::of(vm_reg->as_FloatRegister());\n@@ -1124,0 +1204,3 @@\n+      } else {\n+        assert(vm_reg->is_PRegister() && slots == 1, \"Unknown register type\");\n+        _p_regs += PRegSet::of(vm_reg->as_PRegister());\n@@ -1133,0 +1216,51 @@\n+\n+    \/\/ Remove C-ABI SOE fp registers\n+    _fp_regs -= FloatRegSet::range(v8, v15);\n+  }\n+\n+  static enum RC rc_class(VMReg reg) {\n+    if (reg->is_reg()) {\n+      if (reg->is_Register()) {\n+        return rc_int;\n+      } else if (reg->is_FloatRegister()) {\n+        return rc_float;\n+      } else if (reg->is_PRegister()) {\n+        return rc_predicate;\n+      }\n+    }\n+    if (reg->is_stack()) {\n+      return rc_stack;\n+    }\n+    return rc_bad;\n+  }\n+\n+  static bool is_same_register(VMReg reg1, VMReg reg2) {\n+    if (reg1 == reg2) {\n+      return true;\n+    }\n+    if (rc_class(reg1) == rc_class(reg2)) {\n+      if (reg1->is_Register()) {\n+        return reg1->as_Register() == reg2->as_Register();\n+      } else if (reg1->is_FloatRegister()) {\n+        return reg1->as_FloatRegister() == reg2->as_FloatRegister();\n+      } else if (reg1->is_PRegister()) {\n+        return reg1->as_PRegister() == reg2->as_PRegister();\n+      }\n+    }\n+    return false;\n+  }\n+\n+  static int decode_float_vector_register_size(OptoReg::Name opto_reg) {\n+    switch (opto_reg & 3) {\n+      case 0:\n+        return 1;\n+      case 1:\n+        return 2;\n+      case 2:\n+        return 4;\n+      case 3:\n+        return Matcher::scalable_vector_reg_size(T_FLOAT);\n+      default:\n+        ShouldNotReachHere();\n+        return 0;\n+    }\n@@ -1139,0 +1273,2 @@\n+      _neon_regs(),\n+      _sve_regs(),\n@@ -1146,1 +1282,3 @@\n-    __ push_fp(_fp_regs, sp);\n+    __ push_fp(_fp_regs, sp, MacroAssembler::PushPopFp);\n+    __ push_fp(_neon_regs, sp, MacroAssembler::PushPopNeon);\n+    __ push_fp(_sve_regs, sp, MacroAssembler::PushPopSVE);\n@@ -1153,1 +1291,3 @@\n-    __ pop_fp(_fp_regs, sp);\n+    __ pop_fp(_sve_regs, sp, MacroAssembler::PushPopSVE);\n+    __ pop_fp(_neon_regs, sp, MacroAssembler::PushPopNeon);\n+    __ pop_fp(_fp_regs, sp, MacroAssembler::PushPopFp);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zBarrierSetAssembler_aarch64.cpp","additions":154,"deletions":14,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -190,0 +190,3 @@\n+  OptoReg::Name encode_float_vector_register_size(const Node* node,\n+                                                  OptoReg::Name opto_reg);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zBarrierSetAssembler_aarch64.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2406,1 +2406,1 @@\n-int MacroAssembler::push_fp(unsigned int bitset, Register stack) {\n+int MacroAssembler::push_fp(unsigned int bitset, Register stack, FpPushPopMode mode) {\n@@ -2429,2 +2429,9 @@\n-  \/\/ SVE\n-  if (use_sve && sve_vector_size_in_bytes > 16) {\n+  if (mode == PushPopFull) {\n+    if (use_sve && sve_vector_size_in_bytes > 16) {\n+      mode = PushPopSVE;\n+    } else {\n+      mode = PushPopNeon;\n+    }\n+  }\n+\n+  if (mode == PushPopSVE) {\n@@ -2438,4 +2445,25 @@\n-  \/\/ NEON\n-  if (count == 1) {\n-    strq(as_FloatRegister(regs[0]), Address(pre(stack, -wordSize * 2)));\n-    return 2;\n+  if (mode == PushPopNeon) {\n+    if (count == 1) {\n+      strq(as_FloatRegister(regs[0]), Address(pre(stack, -wordSize * 2)));\n+      return 2;\n+    }\n+\n+    bool odd = (count & 1) == 1;\n+    int push_slots = count + (odd ? 1 : 0);\n+\n+    \/\/ Always pushing full 128 bit registers.\n+    stpq(as_FloatRegister(regs[0]), as_FloatRegister(regs[1]), Address(pre(stack, -push_slots * wordSize * 2)));\n+    words_pushed += 2;\n+\n+    for (int i = 2; i + 1 < count; i += 2) {\n+      stpq(as_FloatRegister(regs[i]), as_FloatRegister(regs[i+1]), Address(stack, i * wordSize * 2));\n+      words_pushed += 2;\n+    }\n+\n+    if (odd) {\n+      strq(as_FloatRegister(regs[count - 1]), Address(stack, (count - 1) * wordSize * 2));\n+      words_pushed++;\n+    }\n+\n+    assert(words_pushed == count, \"oops, pushed(%d) != count(%d)\", words_pushed, count);\n+    return count * 2;\n@@ -2444,2 +2472,3 @@\n-  bool odd = (count & 1) == 1;\n-  int push_slots = count + (odd ? 1 : 0);\n+  if (mode == PushPopFp) {\n+    bool odd = (count & 1) == 1;\n+    int push_slots = count + (odd ? 1 : 0);\n@@ -2447,3 +2476,5 @@\n-  \/\/ Always pushing full 128 bit registers.\n-  stpq(as_FloatRegister(regs[0]), as_FloatRegister(regs[1]), Address(pre(stack, -push_slots * wordSize * 2)));\n-  words_pushed += 2;\n+    if (count == 1) {\n+      \/\/ Stack pointer must be 16 bytes aligned\n+      strd(as_FloatRegister(regs[0]), Address(pre(stack, -push_slots * wordSize)));\n+      return 1;\n+    }\n@@ -2451,2 +2482,1 @@\n-  for (int i = 2; i + 1 < count; i += 2) {\n-    stpq(as_FloatRegister(regs[i]), as_FloatRegister(regs[i+1]), Address(stack, i * wordSize * 2));\n+    stpd(as_FloatRegister(regs[0]), as_FloatRegister(regs[1]), Address(pre(stack, -push_slots * wordSize)));\n@@ -2454,1 +2484,0 @@\n-  }\n@@ -2456,3 +2485,14 @@\n-  if (odd) {\n-    strq(as_FloatRegister(regs[count - 1]), Address(stack, (count - 1) * wordSize * 2));\n-    words_pushed++;\n+    for (int i = 2; i + 1 < count; i += 2) {\n+      stpd(as_FloatRegister(regs[i]), as_FloatRegister(regs[i+1]), Address(stack, i * wordSize));\n+      words_pushed += 2;\n+    }\n+\n+    if (odd) {\n+      \/\/ Stack pointer must be 16 bytes aligned\n+      strd(as_FloatRegister(regs[count - 1]), Address(stack, (count - 1) * wordSize));\n+      words_pushed++;\n+    }\n+\n+    assert(words_pushed == count, \"oops, pushed != count\");\n+\n+    return count;\n@@ -2461,2 +2501,1 @@\n-  assert(words_pushed == count, \"oops, pushed(%d) != count(%d)\", words_pushed, count);\n-  return count * 2;\n+  return 0;\n@@ -2466,1 +2505,1 @@\n-int MacroAssembler::pop_fp(unsigned int bitset, Register stack) {\n+int MacroAssembler::pop_fp(unsigned int bitset, Register stack, FpPushPopMode mode) {\n@@ -2488,2 +2527,9 @@\n-  \/\/ SVE\n-  if (use_sve && sve_vector_size_in_bytes > 16) {\n+  if (mode == PushPopFull) {\n+    if (use_sve && sve_vector_size_in_bytes > 16) {\n+      mode = PushPopSVE;\n+    } else {\n+      mode = PushPopNeon;\n+    }\n+  }\n+\n+  if (mode == PushPopSVE) {\n@@ -2497,5 +2543,5 @@\n-  \/\/ NEON\n-  if (count == 1) {\n-    ldrq(as_FloatRegister(regs[0]), Address(post(stack, wordSize * 2)));\n-    return 2;\n-  }\n+  if (mode == PushPopNeon) {\n+    if (count == 1) {\n+      ldrq(as_FloatRegister(regs[0]), Address(post(stack, wordSize * 2)));\n+      return 2;\n+    }\n@@ -2503,2 +2549,2 @@\n-  bool odd = (count & 1) == 1;\n-  int push_slots = count + (odd ? 1 : 0);\n+    bool odd = (count & 1) == 1;\n+    int push_slots = count + (odd ? 1 : 0);\n@@ -2506,4 +2552,4 @@\n-  if (odd) {\n-    ldrq(as_FloatRegister(regs[count - 1]), Address(stack, (count - 1) * wordSize * 2));\n-    words_pushed++;\n-  }\n+    if (odd) {\n+      ldrq(as_FloatRegister(regs[count - 1]), Address(stack, (count - 1) * wordSize * 2));\n+      words_pushed++;\n+    }\n@@ -2511,2 +2557,6 @@\n-  for (int i = 2; i + 1 < count; i += 2) {\n-    ldpq(as_FloatRegister(regs[i]), as_FloatRegister(regs[i+1]), Address(stack, i * wordSize * 2));\n+    for (int i = 2; i + 1 < count; i += 2) {\n+      ldpq(as_FloatRegister(regs[i]), as_FloatRegister(regs[i+1]), Address(stack, i * wordSize * 2));\n+      words_pushed += 2;\n+    }\n+\n+    ldpq(as_FloatRegister(regs[0]), as_FloatRegister(regs[1]), Address(post(stack, push_slots * wordSize * 2)));\n@@ -2514,0 +2564,4 @@\n+\n+    assert(words_pushed == count, \"oops, pushed(%d) != count(%d)\", words_pushed, count);\n+\n+    return count * 2;\n@@ -2516,2 +2570,13 @@\n-  ldpq(as_FloatRegister(regs[0]), as_FloatRegister(regs[1]), Address(post(stack, push_slots * wordSize * 2)));\n-  words_pushed += 2;\n+  if (mode == PushPopFp) {\n+    bool odd = (count & 1) == 1;\n+    int push_slots = count + (odd ? 1 : 0);\n+\n+    if (count == 1) {\n+      ldrd(as_FloatRegister(regs[0]), Address(post(stack, push_slots * wordSize)));\n+      return 1;\n+    }\n+\n+    if (odd) {\n+      ldrd(as_FloatRegister(regs[count - 1]), Address(stack, (count - 1) * wordSize));\n+      words_pushed++;\n+    }\n@@ -2519,1 +2584,12 @@\n-  assert(words_pushed == count, \"oops, pushed(%d) != count(%d)\", words_pushed, count);\n+    for (int i = 2; i + 1 < count; i += 2) {\n+      ldpd(as_FloatRegister(regs[i]), as_FloatRegister(regs[i+1]), Address(stack, i * wordSize));\n+      words_pushed += 2;\n+    }\n+\n+    ldpd(as_FloatRegister(regs[0]), as_FloatRegister(regs[1]), Address(post(stack, push_slots * wordSize)));\n+    words_pushed += 2;\n+\n+    assert(words_pushed == count, \"oops, pushed != count\");\n+\n+    return count;\n+  }\n@@ -2521,1 +2597,1 @@\n-  return count * 2;\n+  return 0;\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":116,"deletions":40,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -447,0 +447,9 @@\n+public:\n+\n+  enum FpPushPopMode {\n+    PushPopFull,\n+    PushPopSVE,\n+    PushPopNeon,\n+    PushPopFp\n+  };\n+\n@@ -456,2 +465,2 @@\n-  int push_fp(unsigned int bitset, Register stack);\n-  int pop_fp(unsigned int bitset, Register stack);\n+  int push_fp(unsigned int bitset, Register stack, FpPushPopMode mode);\n+  int pop_fp(unsigned int bitset, Register stack, FpPushPopMode mode);\n@@ -465,0 +474,1 @@\n+\n@@ -468,2 +478,2 @@\n-  void push_fp(FloatRegSet regs, Register stack) { if (regs.bits()) push_fp(regs.bits(), stack); }\n-  void pop_fp(FloatRegSet regs, Register stack) { if (regs.bits()) pop_fp(regs.bits(), stack); }\n+  void push_fp(FloatRegSet regs, Register stack, FpPushPopMode mode = PushPopFull) { if (regs.bits()) push_fp(regs.bits(), stack, mode); }\n+  void pop_fp(FloatRegSet regs, Register stack, FpPushPopMode mode = PushPopFull) { if (regs.bits()) pop_fp(regs.bits(), stack, mode); }\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-  assert( is_FloatRegister() && is_even(value()), \"must be\" );\n+  assert( is_FloatRegister(), \"must be\" );\n","filename":"src\/hotspot\/cpu\/aarch64\/vmreg_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}