{"files":[{"patch":"@@ -1530,30 +1530,0 @@\n-    \/**\n-     * Throws {@code UnsupportedOperationException}.\n-     *\n-     * @throws  UnsupportedOperationException always\n-     *\n-     * @deprecated This method was originally specified to \"stop\" a victim\n-     *       thread by causing the victim thread to throw a {@link ThreadDeath}.\n-     *       It was inherently unsafe. Stopping a thread caused it to unlock\n-     *       all of the monitors that it had locked (as a natural consequence\n-     *       of the {@code ThreadDeath} exception propagating up the stack). If\n-     *       any of the objects previously protected by these monitors were in\n-     *       an inconsistent state, the damaged objects became visible to\n-     *       other threads, potentially resulting in arbitrary behavior.\n-     *       Usages of {@code stop} should be replaced by code that simply\n-     *       modifies some variable to indicate that the target thread should\n-     *       stop running.  The target thread should check this variable\n-     *       regularly, and return from its run method in an orderly fashion\n-     *       if the variable indicates that it is to stop running.  If the\n-     *       target thread waits for long periods (on a condition variable,\n-     *       for example), the {@code interrupt} method should be used to\n-     *       interrupt the wait.\n-     *       For more information, see\n-     *       <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/threadPrimitiveDeprecation.html\">Why\n-     *       is Thread.stop deprecated and the ability to stop a thread removed?<\/a>.\n-     *\/\n-    @Deprecated(since=\"1.2\", forRemoval=true)\n-    public final void stop() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * by a victim thread when \"stopped\" with {@link Thread#stop()}.\n+ * by a victim thread when \"stopped\" with the {@link Thread} API.\n@@ -32,6 +32,4 @@\n- * @deprecated {@link Thread#stop()} was originally specified to \"stop\" a victim\n- *      thread by causing the victim thread to throw a {@code ThreadDeath}. It\n- *      was inherently unsafe and deprecated in an early JDK release. The ability\n- *      to \"stop\" a thread with {@code Thread.stop} has been removed and the\n- *      {@code Thread.stop} method changed to throw an exception. Consequently,\n- *      {@code ThreadDeath} is also deprecated, for removal.\n+ * @deprecated {@code Thread} originally specified a \"{@code stop}\" method to stop a\n+ *      victim thread by causing the victim thread to throw a {@code ThreadDeath}. It\n+ *      was inherently unsafe and deprecated in an early JDK release. The {@code stop}\n+ *      method has since been removed and {@code ThreadDeath} is deprecated, for removal.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ThreadDeath.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1,161 +0,0 @@\n-<!doctype html>\n-<!--\n- Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n- DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\n- This code is free software; you can redistribute it and\/or modify it\n- under the terms of the GNU General Public License version 2 only, as\n- published by the Free Software Foundation.  Oracle designates this\n- particular file as subject to the \"Classpath\" exception as provided\n- by Oracle in the LICENSE file that accompanied this code.\n-\n- This code is distributed in the hope that it will be useful, but WITHOUT\n- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- version 2 for more details (a copy is included in the LICENSE file that\n- accompanied this code).\n-\n- You should have received a copy of the GNU General Public License version\n- 2 along with this work; if not, write to the Free Software Foundation,\n- Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n- Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- or visit www.oracle.com if you need additional information or have any\n- questions.\n--->\n-<html lang=\"en\">\n-<head>\n-  <title>Java Thread Primitive Deprecation<\/title>\n-<\/head>\n-<body>\n-<h1>Java Thread Primitive Deprecation<\/h1>\n-<hr>\n-<h2>Why is <code>Thread.stop<\/code> deprecated and the ability to\n-stop a thread removed?<\/h2>\n-<p>Because it was inherently unsafe. Stopping a thread caused it to\n-unlock all the monitors that it had locked. (The monitors were\n-unlocked as the <code>ThreadDeath<\/code> exception propagated up\n-the stack.) If any of the objects previously protected by these\n-monitors were in an inconsistent state, other threads may have viewed\n-these objects in an inconsistent state. Such objects are said to be\n-<i>damaged<\/i>. When threads operate on damaged objects, arbitrary\n-behavior can result. This behavior may be subtle and difficult to\n-detect, or it may be pronounced. Unlike other unchecked exceptions,\n-<code>ThreadDeath<\/code> killed threads silently; thus, the user had\n-no warning that their program may be corrupted. The corruption could\n-manifest itself at any time after the actual damage occurs, even\n-hours or days in the future.<\/p>\n-<hr>\n-<h2>Couldn't I have just caught <code>ThreadDeath<\/code> and fixed\n-the damaged object?<\/h2>\n-<p>In theory, perhaps, but it would <em>vastly<\/em> complicate the\n-task of writing correct multithreaded code. The task would be\n-nearly insurmountable for two reasons:<\/p>\n-<ol>\n-<li>A thread could throw a <code>ThreadDeath<\/code> exception\n-<i>almost anywhere<\/i>. All synchronized methods and blocks would\n-have to be studied in great detail, with this in mind.<\/li>\n-<li>A thread could throw a second <code>ThreadDeath<\/code> exception\n-while cleaning up from the first (in the <code>catch<\/code> or\n-<code>finally<\/code> clause). Cleanup would have to be repeated till\n-it succeeded. The code to ensure this would be quite complex.<\/li>\n-<\/ol>\n-In sum, it just isn't practical.\n-<hr>\n-<h2>What should I use instead of <code>Thread.stop<\/code>?<\/h2>\n-<p>Most uses of <code>stop<\/code> should be replaced by code that\n-simply modifies some variable to indicate that the target thread\n-should stop running. The target thread should check this variable\n-regularly, and return from its run method in an orderly fashion if\n-the variable indicates that it is to stop running. To ensure prompt\n-communication of the stop-request, the variable must be\n-<code>volatile<\/code> (or access to the variable must be\n-synchronized).<\/p>\n-<p>For example, suppose your application contains the following\n-<code>start<\/code>, <code>stop<\/code> and <code>run<\/code>\n-methods:<\/p>\n-<pre>\n-    private Thread blinker;\n-\n-    public void start() {\n-        blinker = new Thread(this);\n-        blinker.start();\n-    }\n-\n-    public void stop() {\n-        blinker.stop();  \/\/ UNSAFE!\n-    }\n-\n-    public void run() {\n-        while (true) {\n-            try {\n-                Thread.sleep(interval);\n-            } catch (InterruptedException e){\n-            }\n-            blink();\n-        }\n-    }\n-<\/pre>\n-You can avoid the use of <code>Thread.stop<\/code> by replacing the\n-application's <code>stop<\/code> and <code>run<\/code> methods with:\n-<pre>\n-    private volatile Thread blinker;\n-\n-    public void stop() {\n-        blinker = null;\n-    }\n-\n-    public void run() {\n-        Thread thisThread = Thread.currentThread();\n-        while (blinker == thisThread) {\n-            try {\n-                Thread.sleep(interval);\n-            } catch (InterruptedException e){\n-            }\n-            blink();\n-        }\n-    }\n-<\/pre>\n-<hr>\n-<h2>How do I stop a thread that waits for long periods (e.g., for\n-input)?<\/h2>\n-<p>That's what the <code>Thread.interrupt<\/code> method is for. The\n-same \"state based\" signaling mechanism shown above can be used, but\n-the state change (<code>blinker = null<\/code>, in the previous\n-example) can be followed by a call to\n-<code>Thread.interrupt<\/code>, to interrupt the wait:<\/p>\n-<pre>\n-    public void stop() {\n-        Thread moribund = waiter;\n-        waiter = null;\n-        moribund.interrupt();\n-    }\n-<\/pre>\n-For this technique to work, it's critical that any method that\n-catches an interrupt exception and is not prepared to deal with it\n-immediately reasserts the exception. We say <em>reasserts<\/em>\n-rather than <em>rethrows<\/em>, because it is not always possible to\n-rethrow the exception. If the method that catches the\n-<code>InterruptedException<\/code> is not declared to throw this\n-(checked) exception, then it should \"reinterrupt itself\" with the\n-following incantation:\n-<pre>\n-    Thread.currentThread().interrupt();\n-<\/pre>\n-This ensures that the Thread will reraise the\n-<code>InterruptedException<\/code> as soon as it is able.\n-<hr>\n-<h2>What if a thread doesn't respond to\n-<code>Thread.interrupt<\/code>?<\/h2>\n-<p>In some cases, you can use application specific tricks. For\n-example, if a thread is waiting on a known socket, you can close\n-the socket to cause the thread to return immediately.\n-Unfortunately, there really isn't any technique that works in\n-general. <em>It should be noted that in all situations where a\n-waiting thread doesn't respond to <code>Thread.interrupt<\/code>, it\n-wouldn't respond to <code>Thread.stop<\/code> either.<\/em> Such\n-cases include deliberate denial-of-service attacks, and I\/O\n-operations for which thread.stop and thread.interrupt do not work\n-properly.<\/p>\n-<\/body>\n-<\/html>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/doc-files\/threadPrimitiveDeprecation.html","additions":0,"deletions":161,"binary":false,"changes":161,"status":"deleted"},{"patch":"@@ -1,112 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug 8289610 8249627 8205132 8320532\n- * @summary Test that Thread stops throws UOE\n- * @run junit ThreadStopTest\n- *\/\n-\n-import java.time.Duration;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.locks.LockSupport;\n-import org.junit.jupiter.api.Test;\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-class ThreadStopTest {\n-\n-    \/**\n-     * Test current thread calling Thread.stop on itself.\n-     *\/\n-    @Test\n-    void testCurrentThread() {\n-        var thread = Thread.currentThread();\n-        assertThrows(UnsupportedOperationException.class, thread::stop);\n-    }\n-\n-    \/**\n-     * Test Thread.stop on an unstarted thread.\n-     *\/\n-    @Test\n-    void testUnstartedThread() {\n-        Thread thread = new Thread(() -> { });\n-        assertThrows(UnsupportedOperationException.class, thread::stop);\n-        assertTrue(thread.getState() == Thread.State.NEW);\n-    }\n-\n-    \/**\n-     * Test Thread.stop on a thread spinning in a loop.\n-     *\/\n-    @Test\n-    void testRunnableThread() throws Exception {\n-        AtomicBoolean done = new AtomicBoolean();\n-        Thread thread = new Thread(() -> {\n-            while (!done.get()) {\n-                Thread.onSpinWait();\n-            }\n-        });\n-        thread.start();\n-        try {\n-            assertThrows(UnsupportedOperationException.class, thread::stop);\n-\n-            \/\/ thread should not terminate\n-            boolean terminated = thread.join(Duration.ofMillis(500));\n-            assertFalse(terminated);\n-        } finally {\n-            done.set(true);\n-            thread.join();\n-        }\n-    }\n-\n-    \/**\n-     * Test Thread.stop on a thread that is parked.\n-     *\/\n-    @Test\n-    void testWaitingThread() throws Exception {\n-        Thread thread = new Thread(LockSupport::park);\n-        thread.start();\n-        try {\n-            \/\/ wait for thread to park\n-            while ((thread.getState() != Thread.State.WAITING)) {\n-                Thread.sleep(10);\n-            }\n-            assertThrows(UnsupportedOperationException.class, thread::stop);\n-            assertTrue(thread.getState() == Thread.State.WAITING);\n-        } finally {\n-            LockSupport.unpark(thread);\n-            thread.join();\n-        }\n-    }\n-\n-    \/**\n-     * Test Thread.stop on a terminated thread.\n-     *\/\n-    @Test\n-    void testTerminatedThread() throws Exception {\n-        Thread thread = new Thread(() -> { });\n-        thread.start();\n-        thread.join();\n-        assertThrows(UnsupportedOperationException.class, thread::stop);\n-        assertTrue(thread.getState() == Thread.State.TERMINATED);\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/Thread\/ThreadStopTest.java","additions":0,"deletions":112,"binary":false,"changes":112,"status":"deleted"},{"patch":"@@ -255,29 +255,0 @@\n-    \/**\n-     * Test Thread::stop from current thread.\n-     *\/\n-    @Test\n-    void testStop1() throws Exception {\n-        VThreadRunner.run(() -> {\n-            Thread t = Thread.currentThread();\n-            assertThrows(UnsupportedOperationException.class, t::stop);\n-        });\n-    }\n-\n-    \/**\n-     * Test Thread::stop from another thread.\n-     *\/\n-    @Test\n-    void testStop2() throws Exception {\n-        var thread = Thread.ofVirtual().start(() -> {\n-            try {\n-                Thread.sleep(20*1000);\n-            } catch (InterruptedException e) { }\n-        });\n-        try {\n-            assertThrows(UnsupportedOperationException.class, thread::stop);\n-        } finally {\n-            thread.interrupt();\n-            thread.join();\n-        }\n-    }\n-\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ThreadAPI.java","additions":0,"deletions":29,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1649,3 +1649,3 @@\n-                thread1.stop();\n-                thread2.stop();\n-                thread3.stop();\n+                thread1.interrupt();\n+                thread2.interrupt();\n+                thread3.interrupt();\n","filename":"test\/jdk\/sun\/security\/krb5\/auto\/KDC.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}