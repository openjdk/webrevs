{"files":[{"patch":"@@ -1316,1 +1316,0 @@\n-    Label L;\n@@ -1324,2 +1323,0 @@\n-    ldrw(r3, Address(rthread, JavaThread::interp_only_mode_offset()));\n-    cbz(r3, L);\n@@ -1328,1 +1325,0 @@\n-    bind(L);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1591,1 +1591,0 @@\n-    Label L;\n@@ -1597,3 +1596,0 @@\n-    ldr_s32(Rtemp, Address(Rthread, JavaThread::interp_only_mode_offset()));\n-    cbz(Rtemp, L);\n-\n@@ -1631,2 +1627,0 @@\n-\n-    bind(L);\n","filename":"src\/hotspot\/cpu\/arm\/interp_masm_arm.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2362,5 +2362,0 @@\n-    Label jvmti_post_done;\n-\n-    lwz(R0, in_bytes(JavaThread::interp_only_mode_offset()), R16_thread);\n-    cmpwi(CR0, R0, 0);\n-    beq(CR0, jvmti_post_done);\n@@ -2372,1 +2367,0 @@\n-    bind(jvmti_post_done);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1384,1 +1384,0 @@\n-    Label L;\n@@ -1392,2 +1391,0 @@\n-    lwu(x13, Address(xthread, JavaThread::interp_only_mode_offset()));\n-    beqz(x13, L);\n@@ -1396,1 +1393,0 @@\n-    bind(L);\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2018,3 +2018,0 @@\n-    Label jvmti_post_done;\n-    MacroAssembler::load_and_test_int(Z_R0, Address(Z_thread, JavaThread::interp_only_mode_offset()));\n-    z_bre(jvmti_post_done);\n@@ -2024,1 +2021,0 @@\n-    bind(jvmti_post_done);\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1751,1 +1751,0 @@\n-    Label L;\n@@ -1759,3 +1758,0 @@\n-    movl(rdx, Address(rthread, JavaThread::interp_only_mode_offset()));\n-    testl(rdx, rdx);\n-    jcc(Assembler::zero, L);\n@@ -1764,1 +1760,0 @@\n-    bind(L);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1079,0 +1079,4 @@\n+\n+  if (JvmtiExport::can_post_frame_pop() && JvmtiExport::has_frame_pop_for_top_frame(current)) {\n+    return nullptr; \/\/ no OSR if there is a FramePop event request for top frame\n+  }\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3148,1 +3148,1 @@\n-    if (JVMTI_ENABLED && !suppress_exit_event && THREAD->is_interp_only_mode()) {\n+    if (JVMTI_ENABLED && !suppress_exit_event) {\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1366,0 +1366,21 @@\n+\n+  JavaThread* thread = state->is_virtual() ?\n+                       state->get_thread() :\n+                       state->get_thread_or_saved(); \/\/ saved is needed for a carrier thread\n+  frame fr = jvf->fr();\n+\n+  if (jvf->is_compiled_frame()) {\n+    if (!fr.can_be_deoptimized()) {\n+      return JVMTI_ERROR_OPAQUE_FRAME;\n+    }\n+\n+    if (state->is_virtual() && (thread == nullptr || !thread->is_vthread_mounted())) { \/\/ unmounted virtual thread\n+      \/\/ set pending frame deoptimization to process at mount transition\n+      state->get_vthread_pending_deopts()->append(frame_number);\n+    } else { \/\/ platform thread or mounted virtual thread\n+      if (fr.is_heap_frame()) {\n+        fr = jvf->stack_chunk()->derelativize(fr);\n+      }\n+      Deoptimization::deoptimize(thread, fr);\n+    }\n+  }\n@@ -2489,0 +2510,1 @@\n+    _state->check_and_clear_vthread_pending_deopts();\n@@ -2516,0 +2538,1 @@\n+    _state->check_and_clear_vthread_pending_deopts();\n@@ -2519,0 +2542,2 @@\n+  assert(_state->get_thread() == _target_jt, \"sanity check\");\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -256,1 +256,1 @@\n-  if (!jvmti_thread_state()->is_interp_only_mode() || _frame_pops == nullptr) {\n+  if (_frame_pops == nullptr) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvThreadState.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -579,4 +579,0 @@\n-  \/\/ JVMTI_EVENT_FRAME_POP can be disabled (in the case FRAME_POP_BIT is not set),\n-  \/\/ but we need to set interp_only if some JvmtiEnvThreadState has frame pop set\n-  \/\/ to clear the request\n-  bool has_frame_pops = false;\n@@ -591,1 +587,0 @@\n-      has_frame_pops |= ets->has_frame_pops();\n@@ -607,1 +602,1 @@\n-  bool should_be_interp = (any_env_enabled & INTERP_EVENT_BITS) != 0 || has_frame_pops;\n+  bool should_be_interp = (any_env_enabled & (INTERP_EVENT_BITS & ~FRAME_POP_BIT)) != 0;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1357,0 +1357,17 @@\n+bool JvmtiExport::has_frame_pop_for_top_frame(JavaThread *current) {\n+  assert(current == JavaThread::current(), \"must be\");\n+  JvmtiThreadState *state = current->jvmti_thread_state();\n+  if (state == nullptr) {\n+    return false;\n+  }\n+  JvmtiEnvThreadStateIterator it(state);\n+  int top_frame_num = state->count_frames();\n+  for (JvmtiEnvThreadState* ets = it.first(); ets != nullptr; ets = it.next(ets)) {\n+    if (ets->has_frame_pops() && ets->is_enabled(JVMTI_EVENT_FRAME_POP) &&\n+        ets->is_frame_pop(top_frame_num)) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -1893,1 +1910,1 @@\n-  bool interp_only; \/\/ might be changed in JRT_BLOCK_END\n+  bool need_processing;\n@@ -1896,2 +1913,2 @@\n-    interp_only = state != nullptr && state->is_interp_only_mode();\n-    if (interp_only) {\n+    need_processing = state != nullptr && current_frame.is_interpreted_frame();\n+    if (need_processing) {\n@@ -1912,1 +1929,1 @@\n-  if (interp_only) {\n+  if (need_processing) {\n@@ -2149,0 +2166,2 @@\n+    \/\/ The cached cur_stack_depth might have changed from the operations of frame pop or method exit.\n+    \/\/ We are not 100% sure the cached cur_stack_depth is still valid depth so invalidate it.\n@@ -2152,12 +2171,3 @@\n-      if(state->is_interp_only_mode()) {\n-        \/\/ method exit and frame pop events are posted only in interp mode.\n-        \/\/ When these events are enabled code should be in running in interp mode.\n-        jvalue no_value;\n-        no_value.j = 0L;\n-        JvmtiExport::post_method_exit_inner(thread, mh, state, true, thread->last_frame(), no_value);\n-        \/\/ The cached cur_stack_depth might have changed from the\n-        \/\/ operations of frame pop or method exit. We are not 100% sure\n-        \/\/ the cached cur_stack_depth is still valid depth so invalidate\n-        \/\/ it.\n-        state->invalidate_cur_stack_depth();\n-      }\n+      jvalue no_value;\n+      no_value.j = 0L;\n+      JvmtiExport::post_method_exit_inner(thread, mh, state, true, thread->last_frame(), no_value);\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":26,"deletions":16,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -322,0 +322,3 @@\n+\n+  \/\/ frame pop management\n+  static bool has_frame_pop_for_top_frame(JavaThread *current);\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/deoptimization.hpp\"\n@@ -77,0 +78,1 @@\n+  _vthread_pending_deopts = nullptr;\n@@ -140,0 +142,2 @@\n+  delete _vthread_pending_deopts;\n+\n@@ -663,0 +667,6 @@\n+\n+  \/\/ FramePop optimization support\n+  JvmtiThreadState* state = thread->jvmti_thread_state();\n+  if (state != nullptr && state->is_virtual() && state->is_enabled(JVMTI_EVENT_FRAME_POP)) {\n+    state->process_vthread_pending_deopts();\n+  }\n@@ -684,0 +694,35 @@\n+void\n+JvmtiThreadState::process_vthread_pending_deopts() {\n+  if (!has_vthread_pending_deopts()) {\n+    return;\n+  }\n+  JavaThread* thread = get_thread();\n+  ResourceMark rm;\n+  GrowableArray<int>* deopts = get_vthread_pending_deopts();\n+  javaVFrame* jvf = JvmtiEnvBase::get_vthread_jvf(thread->vthread());\n+  int frame_count = (int)JvmtiEnvBase::get_frame_count(jvf);\n+\n+  for (int idx = 0; idx  < deopts->length(); idx++) {\n+    int frame_number = deopts->at(idx);\n+    deopts->remove_at(idx);\n+    int depth = frame_count - frame_number;\n+    jvf = JvmtiEnvBase::jvf_for_thread_and_depth(thread, depth);\n+    frame fr = jvf->fr();\n+    if (fr.is_heap_frame()) {\n+      fr = jvf->stack_chunk()->derelativize(fr);\n+    }\n+    Deoptimization::deoptimize(thread, fr);\n+  }\n+}\n+\n+void\n+JvmtiThreadState::process_pending_interp_only(JavaThread* current) {\n+  JvmtiThreadState* state = current->jvmti_thread_state();\n+\n+  if (state != nullptr && (state->is_pending_interp_only_mode())) {\n+    MutexLocker mu(JvmtiThreadState_lock);\n+    if (state->is_pending_interp_only_mode()) {\n+      JvmtiEventController::enter_interp_only_mode(state);\n+    }\n+  }\n+}\n@@ -941,10 +986,8 @@\n-  if (is_interp_only_mode()) {\n-    \/\/ remove any frame pop notification request for the top frame\n-    \/\/ in any environment\n-    int popframe_number = cur_stack_depth();\n-    {\n-      JvmtiEnvThreadStateIterator it(this);\n-      for (JvmtiEnvThreadState* ets = it.first(); ets != nullptr; ets = it.next(ets)) {\n-        if (ets->is_frame_pop(popframe_number)) {\n-          ets->clear_frame_pop(popframe_number);\n-        }\n+  \/\/ remove any frame pop notification request for the top frame\n+  \/\/ in any environment\n+  int popframe_number = cur_stack_depth();\n+  {\n+    JvmtiEnvThreadStateIterator it(this);\n+    for (JvmtiEnvThreadState* ets = it.first(); ets != nullptr; ets = it.next(ets)) {\n+      if (ets->is_frame_pop(popframe_number)) {\n+        ets->clear_frame_pop(popframe_number);\n@@ -953,4 +996,0 @@\n-    \/\/ force stack depth to be recalculated\n-    invalidate_cur_stack_depth();\n-  } else {\n-    assert(!is_enabled(JVMTI_EVENT_FRAME_POP), \"Must have no framepops set\");\n@@ -958,0 +997,2 @@\n+  \/\/ force stack depth to be recalculated\n+  invalidate_cur_stack_depth();\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.cpp","additions":55,"deletions":14,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -216,0 +216,1 @@\n+  GrowableArray<int>*   _vthread_pending_deopts;\n@@ -285,0 +286,21 @@\n+  int has_vthread_pending_deopts() {\n+    return _vthread_pending_deopts != nullptr && _vthread_pending_deopts->length() > 0;\n+  }\n+\n+  void check_and_clear_vthread_pending_deopts() {\n+    if (_vthread_pending_deopts != nullptr) {\n+      delete _vthread_pending_deopts;\n+      _vthread_pending_deopts = nullptr;\n+    }\n+  }\n+\n+  GrowableArray<int>* get_vthread_pending_deopts() {\n+    if (_vthread_pending_deopts == nullptr) {\n+      _vthread_pending_deopts = new (mtServiceability) GrowableArray<int> (2, mtServiceability);\n+      assert(_vthread_pending_deopts != nullptr, \"sanity check\");\n+    }\n+    return _vthread_pending_deopts;\n+  }\n+\n+  void process_vthread_pending_deopts();\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.hpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -166,8 +166,0 @@\n-\n-inline void JvmtiThreadState::process_pending_interp_only(JavaThread* current) {\n-  JvmtiThreadState* state = current->jvmti_thread_state();\n-\n-  if (state != nullptr && state->is_pending_interp_only_mode()) {\n-    JvmtiEventController::enter_interp_only_mode(state);\n-  }\n-}\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.inline.hpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -369,0 +369,1 @@\n+#if 0\n@@ -380,0 +381,19 @@\n+#else\n+    frame fr = thread->last_frame();\n+    RegisterMap map(thread,\n+                    RegisterMap::UpdateMap::skip,\n+                    RegisterMap::ProcessFrames::include,\n+                    !is_heap_frame() ? RegisterMap::WalkContinuation::skip : RegisterMap::WalkContinuation::include);\n+    intptr_t* fr_id = fr.id();\n+    while (id() != fr_id) {\n+      fr = fr.sender(&map);\n+      if (fr.is_heap_frame()) {\n+        assert(is_heap_frame(), \"\");\n+        frame derel_fr = map.stack_chunk()->derelativize(fr);\n+        fr_id = derel_fr.id();\n+      } else {\n+        fr_id = fr.id();\n+      }\n+    }\n+    assert(fr.is_deoptimized_frame(), \"missed deopt\");\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -159,1 +159,3 @@\n-  LOG(\"\\nNotifyFramePop called for method %s\\n\", name);\n+\n+  LOG(\"\\nnotifyFramePop: requested FramePop event for frame with method: %s\\n\", name);\n+  print_stack_trace(jvmti, jni, thread);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/NotifyFramePopStressTest\/libNotifyFramePopStressTest.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+    private static native void setFramePopEvent(Thread thread);\n@@ -54,0 +55,4 @@\n+        for (int i = 0; i < 10; i++) {\n+            testGetThreadListStackTraces(Thread.currentThread());\n+            Thread.yield();\n+        }\n@@ -78,1 +83,7 @@\n-            Thread.sleep(10);\n+            Thread.sleep(50);\n+\n+            for (Thread t : virtualThreads) {\n+                if (tryCount % 4 == 0) {\n+                    setFramePopEvent(t);\n+                }\n+            }\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/ThreadStateTest\/ThreadStateTest.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,2 @@\n+static jrawMonitorID agent_event_lock = nullptr;\n+static int frame_pops_cnt = 0;\n@@ -44,0 +46,12 @@\n+static void JNICALL\n+FramePop(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread,\n+         jmethodID method, jboolean by_exception) {\n+  const char* tname = get_thread_name(jvmti, jni, thread);\n+  const char* mname = get_method_name(jvmti, jni, method);\n+\n+  RawMonitorLocker event_locker(jvmti, jni, agent_event_lock);\n+  LOG(\"FramePop event #%d: thread: %s method: %s\\n\", ++frame_pops_cnt, tname, mname);\n+  deallocate(jvmti, jni, (void*)tname);\n+  deallocate(jvmti, jni, (void*)mname);\n+}\n+\n@@ -51,1 +65,1 @@\n-  if (state != exp_state) {\n+  if ((state & ~JVMTI_THREAD_STATE_SUSPENDED) != exp_state) {\n@@ -62,0 +76,27 @@\n+JNIEXPORT void JNICALL\n+Java_ThreadStateTest_setFramePopEvent(JNIEnv* jni, jclass klass, jthread thread) {\n+  RawMonitorLocker event_locker(jvmti, jni, agent_event_lock);\n+\n+  jvmtiError err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FRAME_POP, thread);\n+  if (err != JVMTI_ERROR_NONE) {\n+    if (err == JVMTI_ERROR_THREAD_NOT_ALIVE || err == JVMTI_ERROR_NO_MORE_FRAMES) {\n+      return;\n+    } else {\n+      check_jvmti_status(jni, err, \"setFramePopEvent error in JVMTI SetEventNotificationMode for JVMTI_EVENT_FRAME_POP\");\n+    }\n+  }\n+  err = jvmti->SuspendThread(thread);\n+  if (err == JVMTI_ERROR_THREAD_NOT_ALIVE) {\n+    return;\n+  }\n+  check_jvmti_status(jni, err, \"setFramePopEvent error in JVMTI SuspendThread\");\n+\n+  err = jvmti->NotifyFramePop(thread, 4);\n+  if (err != JVMTI_ERROR_NO_MORE_FRAMES && err != JVMTI_ERROR_OPAQUE_FRAME) {\n+    check_jvmti_status(jni, err, \"setFramePopEvent error in JVMTI NotifyFramePop\");\n+  }\n+\n+  err = jvmti->ResumeThread(thread);\n+  check_jvmti_status(jni, err, \"setFramePopEvent error in JVMTI ResumeThread\");\n+}\n+\n@@ -114,0 +155,2 @@\n+  caps.can_generate_frame_pop_events = 1;\n+  caps.can_suspend = 1;\n@@ -123,1 +166,2 @@\n-  callbacks.SingleStep  = &SingleStep;\n+  callbacks.SingleStep = &SingleStep;\n+  callbacks.FramePop = &FramePop;\n@@ -129,0 +173,1 @@\n+  agent_event_lock = create_raw_monitor(jvmti, \"agent_event_lock\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/ThreadStateTest\/libThreadStateTest.cpp","additions":48,"deletions":3,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -3068,0 +3068,2 @@\n+        env.stepOverLine(thread); \/\/ needed to keep target thread interp-only, so dontinline_brkpt_iret is not inligned\n+\n","filename":"test\/jdk\/com\/sun\/jdi\/EATests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}