{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,0 +78,55 @@\n+ * <h2><a id=\"optional-services\">Optional Services<\/a><\/h2>\n+ *\n+ * Resolution requires that if a module {@code M} '{@code uses}' a service or\n+ * '{@code provides}' an implementation of a service, then the service must be available\n+ * to {@code M} at run time, either because {@code M} itself contains the service's\n+ * package or because {@code M} reads another module that exports the service's package.\n+ * However, it is sometimes desirable for the service's package to come from a module\n+ * that is optional at run time, as indicated by the use of 'requires static' in this\n+ * example:\n+ *\n+ * {@snippet :\n+ *     module M {\n+ *         requires static Y;\n+ *         uses p.S;\n+ *     }\n+ *\n+ *     module Y {\n+ *        exports p;\n+ *     }\n+ *  }\n+ *\n+ * Resolution is resilient when a service's package comes from a module that is optional\n+ * at run time. That is, if a module {@code M} has an optional dependency on some module\n+ * {@code Y}, but {@code Y} is not needed at run time ({@code Y} might be observable but\n+ * no-one reads it), then resolution at run time <i>assumes<\/i> that {@code Y} exported\n+ * the service's package at compile time. Resolution at run time does not attempt to\n+ * check whether {@code Y} is observable or (if it is observable) whether {@code Y}\n+ * exports the service's package.\n+ *\n+ * <p> The module that '{@code uses}' the service, or '{@code provides}' an implementation\n+ * of it, may depend directly on the optional module, as {@code M} does above, or may\n+ * depend indirectly on the optional module, as shown here:\n+ *\n+ *  {@snippet :\n+ *     module M {\n+ *         requires X;\n+ *         uses p.S;\n+ *     }\n+ *\n+ *     module X {\n+ *         requires static transitive Y;\n+ *     }\n+ *\n+ *     module Y {\n+ *         exports p;\n+ *     }\n+ * }\n+ *\n+ * In effect, the service that {@code M} '{@code uses}', or '{@code provides}' an\n+ * implementation of, is optional if it comes from an optional dependency. In this case,\n+ * code in {@code M} must be prepared to deal with the class or interface that denotes\n+ * the service being unavailable at run time. This is distinct from the more regular\n+ * case where the service is available but no implementations of the service are\n+ * available.\n+ *\n@@ -156,1 +211,0 @@\n-\n@@ -361,4 +415,11 @@\n-     *     <li><p> A module {@code M} declares that it \"{@code uses p.S}\" or\n-     *     \"{@code provides p.S with ...}\" but package {@code p} is neither in\n-     *     module {@code M} nor exported to {@code M} by any module that\n-     *     {@code M} reads. <\/p><\/li>\n+     *     <li><p> A module {@code M} declares that it '{@code uses p.S}' or\n+     *     '{@code provides p.S with ...}', but the package {@code p} is neither in\n+     *     module {@code M} nor exported to {@code M} by any module that {@code M}\n+     *     reads. Additionally, neither of the following is {@code true}:\n+     *     <ul>\n+     *         <li> {@code M} declares '{@code requires static}' for at least one\n+     *         module that is not in the readability graph. <\/li>\n+     *         <li> {@code M} reads another module that declares\n+     *         '{@code requires transitive static}' for at least one module that is\n+     *         not in the readability graph. <\/li>\n+     *     <\/ul> <\/li>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/module\/Configuration.java","additions":67,"deletions":6,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -692,1 +692,0 @@\n-\n@@ -757,1 +756,0 @@\n-\n@@ -767,3 +765,5 @@\n-                    if (!packageToExporter.containsKey(pn)) {\n-                        resolveFail(\"Module %s does not read a module that exports %s\",\n-                                    descriptor1.name(), pn);\n+                    if (!packageToExporter.containsKey(pn)\n+                            && !requiresStaticMissingModule(descriptor1, reads)) {\n+                        resolveFail(\"Module %s uses %s but does not read a module that exports %s to %s\",\n+                                    descriptor1.name(), service, pn, descriptor1.name());\n+\n@@ -776,3 +776,4 @@\n-                    if (!packageToExporter.containsKey(pn)) {\n-                        resolveFail(\"Module %s does not read a module that exports %s\",\n-                                    descriptor1.name(), pn);\n+                    if (!packageToExporter.containsKey(pn)\n+                            && !requiresStaticMissingModule(descriptor1, reads)) {\n+                        resolveFail(\"Module %s provides %s but does not read a module that exports %s to %s\",\n+                                    descriptor1.name(), provides.service(), pn, descriptor1.name());\n@@ -788,0 +789,28 @@\n+    \/**\n+     * Returns true if a module 'requires static' a module that is not in the\n+     * readability graph, or reads a module that 'requires static transitive'\n+     * a module that is not in the readability graph.\n+     *\/\n+    private boolean requiresStaticMissingModule(ModuleDescriptor descriptor,\n+                                                Set<ResolvedModule> reads) {\n+        Set<String> moduleNames = reads.stream()\n+                .map(ResolvedModule::name)\n+                .collect(Collectors.toSet());\n+        for (ModuleDescriptor.Requires r : descriptor.requires()) {\n+            if (r.modifiers().contains(Modifier.STATIC)\n+                    && !moduleNames.contains(r.name())) {\n+                return true;\n+            }\n+        }\n+        for (ResolvedModule rm : reads) {\n+            for (ModuleDescriptor.Requires r : rm.descriptor().requires()) {\n+                if (r.modifiers().contains(Modifier.STATIC)\n+                        && r.modifiers().contains(Modifier.TRANSITIVE)\n+                        && !moduleNames.contains(r.name())) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/module\/Resolver.java","additions":38,"deletions":9,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -194,0 +194,4 @@\n+ * <p> The {@linkplain java.lang.module.Configuration##optional-services Optional\n+ * Services} section of {@link java.lang.module.Configuration} shows how resolution\n+ * can be resilient when a service comes from a module that is optional at run time.\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/module\/package-info.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8142968 8299504\n@@ -32,1 +33,1 @@\n- * @run testng ConfigurationTest\n+ * @run junit ConfigurationTest\n@@ -50,0 +51,3 @@\n+import java.util.stream.Stream;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.module.ModuleTarget;\n@@ -54,5 +58,5 @@\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.module.ModuleTarget;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.CsvSource;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -60,2 +64,1 @@\n-@Test\n-public class ConfigurationTest {\n+class ConfigurationTest {\n@@ -76,1 +79,2 @@\n-    public void testBasic() {\n+    @Test\n+    void testBasic() {\n@@ -128,1 +132,2 @@\n-    public void testRequiresTransitive1() {\n+    @Test\n+    void testRequiresTransitive1() {\n@@ -180,1 +185,2 @@\n-    public void testRequiresTransitive2() {\n+    @Test\n+    void testRequiresTransitive2() {\n@@ -241,1 +247,2 @@\n-    public void testRequiresTransitive3() {\n+    @Test\n+    void testRequiresTransitive3() {\n@@ -303,1 +310,2 @@\n-    public void testRequiresTransitive4() {\n+    @Test\n+    void testRequiresTransitive4() {\n@@ -378,1 +386,2 @@\n-    public void testRequiresTransitive5() {\n+    @Test\n+    void testRequiresTransitive5() {\n@@ -455,1 +464,2 @@\n-    public void testRequiresStatic1() {\n+    @Test\n+    void testRequiresStatic1() {\n@@ -477,1 +487,2 @@\n-    public void testRequiresStatic2() {\n+    @Test\n+    void testRequiresStatic2() {\n@@ -502,1 +513,2 @@\n-    public void testRequiresStatic3() {\n+    @Test\n+    void testRequiresStatic3() {\n@@ -532,1 +544,2 @@\n-    public void testRequiresStatic4() {\n+    @Test\n+    void testRequiresStatic4() {\n@@ -573,1 +586,2 @@\n-    public void testRequiresStatic5() {\n+    @Test\n+    void testRequiresStatic5() {\n@@ -616,1 +630,2 @@\n-    public void testRequiresStatic6() {\n+    @Test\n+    void testRequiresStatic6() {\n@@ -653,1 +668,2 @@\n-    public void testRequiresStatic7() {\n+    @Test\n+    void testRequiresStatic7() {\n@@ -686,1 +702,2 @@\n-    public void testRequiresStatic8() {\n+    @Test\n+    void testRequiresStatic8() {\n@@ -725,2 +742,2 @@\n-    public void testServiceBinding1() {\n-\n+    @Test\n+    void testServiceBinding1() {\n@@ -765,2 +782,2 @@\n-    public void testServiceBinding2() {\n-\n+    @Test\n+    void testServiceBinding2() {\n@@ -819,2 +836,2 @@\n-    public void testServiceBindingWithConfigurations1() {\n-\n+    @Test\n+    void testServiceBindingWithConfigurations1() {\n@@ -865,2 +882,2 @@\n-    public void testServiceBindingWithConfigurations2() {\n-\n+    @Test\n+    void testServiceBindingWithConfigurations2() {\n@@ -933,2 +950,2 @@\n-    public void testServiceBindingWithConfigurations3() {\n-\n+    @Test\n+    void testServiceBindingWithConfigurations3() {\n@@ -955,1 +972,1 @@\n-        assertEquals(p.reference().descriptor(), provider_v1);\n+        assertEquals(provider_v1, p.reference().descriptor());\n@@ -983,1 +1000,1 @@\n-        assertEquals(p.reference().descriptor(), provider_v2);\n+        assertEquals(provider_v2, p.reference().descriptor());\n@@ -998,1 +1015,1 @@\n-        assertEquals(p.reference().descriptor(), provider_v1);\n+        assertEquals(provider_v1, p.reference().descriptor());\n@@ -1007,2 +1024,2 @@\n-    public void testWithTwoFinders1() {\n-\n+    @Test\n+    void testWithTwoFinders1() {\n@@ -1033,2 +1050,2 @@\n-        assertEquals(m1.reference().descriptor(), descriptor1);\n-        assertEquals(m2.reference().descriptor(), descriptor2_v1);\n+        assertEquals(descriptor1, m1.reference().descriptor());\n+        assertEquals(descriptor2_v1, m2.reference().descriptor());\n@@ -1044,2 +1061,2 @@\n-    public void testWithTwoFinders2() {\n-\n+    @Test\n+    void testWithTwoFinders2() {\n@@ -1073,2 +1090,2 @@\n-        assertEquals(m1.reference().descriptor(), descriptor1);\n-        assertEquals(m2.reference().descriptor(), descriptor2_v1);\n+        assertEquals(descriptor1, m1.reference().descriptor());\n+        assertEquals(descriptor2_v1, m2.reference().descriptor());\n@@ -1082,2 +1099,2 @@\n-    public void testResolvedInParent1() {\n-\n+    @Test\n+    void testResolvedInParent1() {\n@@ -1104,2 +1121,2 @@\n-    public void testResolvedInParent2() {\n-\n+    @Test\n+    void testResolvedInParent2() {\n@@ -1145,2 +1162,2 @@\n-    public void testResolvedInMultipleParents1() {\n-\n+    @Test\n+    void testResolvedInMultipleParents1() {\n@@ -1150,1 +1167,1 @@\n-        assertEquals(cf1.parents(), List.of(Configuration.empty()));\n+        assertEquals(List.of(Configuration.empty()), cf1.parents());\n@@ -1158,1 +1175,1 @@\n-        assertEquals(cf2.parents(), List.of(Configuration.empty()));\n+        assertEquals(List.of(Configuration.empty()), cf2.parents());\n@@ -1174,1 +1191,1 @@\n-        assertEquals(cf3.parents(), List.of(cf1, cf2));\n+        assertEquals(List.of(cf1, cf2), cf3.parents());\n@@ -1182,1 +1199,1 @@\n-        assertEquals(m3.reads(), Set.of(m1, m2));\n+        assertEquals(Set.of(m1, m2), m3.reads());\n@@ -1196,1 +1213,2 @@\n-    public void testResolvedInMultipleParents2() {\n+    @Test\n+    void testResolvedInMultipleParents2() {\n@@ -1200,1 +1218,1 @@\n-        assertEquals(cf1.parents(), List.of(Configuration.empty()));\n+        assertEquals( List.of(Configuration.empty()), cf1.parents());\n@@ -1214,1 +1232,1 @@\n-        assertEquals(cf2.parents(), List.of(cf1));\n+        assertEquals(List.of(cf1), cf2.parents());\n@@ -1228,1 +1246,1 @@\n-        assertEquals(cf3.parents(), List.of(cf1));\n+        assertEquals(List.of(cf1), cf3.parents());\n@@ -1244,1 +1262,1 @@\n-        assertEquals(cf4.parents(), List.of(cf2, cf3));\n+        assertEquals(List.of(cf2, cf3), cf4.parents());\n@@ -1251,3 +1269,3 @@\n-        assertEquals(m2.reads(), Set.of(m1));\n-        assertEquals(m3.reads(), Set.of(m1));\n-        assertEquals(m4.reads(), Set.of(m1, m2, m3));\n+        assertEquals(Set.of(m1), m2.reads());\n+        assertEquals(Set.of(m1), m3.reads());\n+        assertEquals(Set.of(m1, m2, m3), m4.reads());\n@@ -1267,1 +1285,2 @@\n-    public void testResolvedInMultipleParents3() {\n+    @Test\n+    void testResolvedInMultipleParents3() {\n@@ -1273,1 +1292,1 @@\n-        assertEquals(cf1.parents(), List.of(Configuration.empty()));\n+        assertEquals(List.of(Configuration.empty()), cf1.parents());\n@@ -1281,1 +1300,1 @@\n-        assertEquals(cf2.parents(), List.of(Configuration.empty()));\n+        assertEquals(List.of(Configuration.empty()), cf2.parents());\n@@ -1290,1 +1309,1 @@\n-        assertEquals(cf3.parents(), List.of(Configuration.empty()));\n+        assertEquals(List.of(Configuration.empty()), cf3.parents());\n@@ -1303,1 +1322,1 @@\n-        assertEquals(cf4.parents(), List.of(cf1, cf2, cf3));\n+        assertEquals(List.of(cf1, cf2, cf3), cf4.parents());\n@@ -1336,1 +1355,1 @@\n-        assertEquals(m4.reads(), Set.of(m1_1, m2_2, m3_3));\n+        assertEquals(Set.of(m1_1, m2_2, m3_3), m4.reads());\n@@ -1344,1 +1363,2 @@\n-    public void testOverriding1() {\n+    @Test\n+    void testOverriding1() {\n@@ -1362,1 +1382,2 @@\n-    public void testOverriding2() {\n+    @Test\n+    void testOverriding2() {\n@@ -1401,2 +1422,2 @@\n-    public void testOverriding3() {\n-\n+    @Test\n+    void testOverriding3() {\n@@ -1455,3 +1476,3 @@\n-    @Test(expectedExceptions = { FindException.class })\n-    public void testRootNotFound() {\n-        resolve(ModuleFinder.of(), \"m1\");\n+    @Test\n+    void testRootNotFound() {\n+        assertThrows(FindException.class, () -> resolve(ModuleFinder.of(), \"m1\"));\n@@ -1464,2 +1485,2 @@\n-    @Test(expectedExceptions = { FindException.class })\n-    public void testDirectDependencyNotFound() {\n+    @Test\n+    void testDirectDependencyNotFound() {\n@@ -1468,1 +1489,1 @@\n-        resolve(finder, \"m1\");\n+        assertThrows(FindException.class, () -> resolve(finder, \"m1\"));\n@@ -1475,2 +1496,2 @@\n-    @Test(expectedExceptions = { FindException.class })\n-    public void testTransitiveDependencyNotFound() {\n+    @Test\n+    void testTransitiveDependencyNotFound() {\n@@ -1480,1 +1501,1 @@\n-        resolve(finder, \"m1\");\n+        assertThrows(FindException.class, () -> resolve(finder, \"m1\"));\n@@ -1487,2 +1508,2 @@\n-    @Test(expectedExceptions = { FindException.class })\n-    public void testServiceProviderDependencyNotFound() {\n+    @Test\n+    void testServiceProviderDependencyNotFound() {\n@@ -1506,1 +1527,1 @@\n-        Configuration cf = resolveAndBind(finder, \"m1\");\n+        assertThrows(FindException.class, () -> resolveAndBind(finder, \"m1\"));\n@@ -1513,2 +1534,2 @@\n-    @Test(expectedExceptions = { ResolutionException.class })\n-    public void testSimpleCycle() {\n+    @Test\n+    void testSimpleCycle() {\n@@ -1518,3 +1539,2 @@\n-        ModuleFinder finder\n-            = ModuleUtils.finderOf(descriptor1, descriptor2, descriptor3);\n-        resolve(finder, \"m1\");\n+        ModuleFinder finder = ModuleUtils.finderOf(descriptor1, descriptor2, descriptor3);\n+        assertThrows(ResolutionException.class, () -> resolve(finder, \"m1\"));\n@@ -1526,3 +1546,2 @@\n-    @Test(expectedExceptions = { ResolutionException.class })\n-    public void testCycleInProvider() {\n-\n+    @Test\n+    void testCycleInProvider() {\n@@ -1546,1 +1565,1 @@\n-        resolveAndBind(finder, \"m1\");\n+        assertThrows(ResolutionException.class, () -> resolveAndBind(finder, \"m1\"));\n@@ -1557,2 +1576,2 @@\n-    @Test(expectedExceptions = { ResolutionException.class })\n-    public void testReadModuleWithSameNameAsSelf() {\n+    @Test\n+    void testReadModuleWithSameNameAsSelf() {\n@@ -1576,1 +1595,1 @@\n-        resolve(cf1, finder2, \"m1\");\n+        assertThrows(ResolutionException.class, () -> resolve(cf1, finder2, \"m1\"));\n@@ -1588,2 +1607,2 @@\n-    @Test(expectedExceptions = { ResolutionException.class })\n-    public void testReadTwoModuleWithSameName() {\n+    @Test\n+    void testReadTwoModuleWithSameName() {\n@@ -1616,1 +1635,5 @@\n-        Configuration.resolve(finder3, List.of(cf1, cf2), ModuleFinder.of(), Set.of(\"m4\"));\n+        assertThrows(ResolutionException.class,\n+                     () -> Configuration.resolve(finder3,\n+                                                 List.of(cf1, cf2),\n+                                                 ModuleFinder.of(),\n+                                                 Set.of(\"m4\")));\n@@ -1623,3 +1646,2 @@\n-    @Test(expectedExceptions = { ResolutionException.class })\n-    public void testPackageSuppliedByTwoOthers() {\n-\n+    @Test\n+    void testPackageSuppliedByTwoOthers() {\n@@ -1643,1 +1665,1 @@\n-        resolve(finder, \"m1\");\n+        assertThrows(ResolutionException.class, () -> resolve(finder, \"m1\"));\n@@ -1651,3 +1673,2 @@\n-    @Test(expectedExceptions = { ResolutionException.class })\n-    public void testPackageSuppliedBySelfAndOther() {\n-\n+    @Test\n+    void testPackageSuppliedBySelfAndOther() {\n@@ -1666,1 +1687,1 @@\n-        resolve(finder, \"m1\");\n+        assertThrows(ResolutionException.class, () -> resolve(finder, \"m1\"));\n@@ -1674,1 +1695,2 @@\n-    public void testContainsPackageInSelfAndOther() {\n+    @Test\n+    void testContainsPackageInSelfAndOther() {\n@@ -1705,2 +1727,2 @@\n-    @Test(expectedExceptions = { ResolutionException.class })\n-    public void testExportSamePackageAsBootLayer() {\n+    @Test\n+    void testExportSamePackageAsBootLayer() {\n@@ -1717,1 +1739,1 @@\n-        resolve(bootConfiguration, finder, \"m1\");\n+        assertThrows(ResolutionException.class, () -> resolve(bootConfiguration, finder, \"m1\"));\n@@ -1724,1 +1746,2 @@\n-    public void testContainsService1() {\n+    @Test\n+    void testContainsService1() {\n@@ -1742,2 +1765,2 @@\n-    @Test(expectedExceptions = { ResolutionException.class })\n-    public void testContainsService2() {\n+    @Test\n+    void testContainsService2() {\n@@ -1756,1 +1779,1 @@\n-        resolve(finder, \"m2\");\n+        assertThrows(ResolutionException.class, () -> resolve(finder, \"m2\"));\n@@ -1763,1 +1786,2 @@\n-    public void testContainsService3() {\n+    @Test\n+    void testContainsService3() {\n@@ -1781,2 +1805,2 @@\n-    @Test(expectedExceptions = { ResolutionException.class })\n-    public void testContainsService4() {\n+    @Test\n+    void testContainsService4() {\n@@ -1795,1 +1819,1 @@\n-        resolve(finder, \"m2\");\n+        assertThrows(ResolutionException.class, () -> resolve(finder, \"m2\"));\n@@ -1798,0 +1822,16 @@\n+    \/**\n+     * Test uses optional service.\n+     *\n+     *     module m1 { requires static m2; uses p.S; }\n+     *\/\n+    @Test\n+    void testUsesOptionalService1() {\n+        ModuleDescriptor descriptor1 = newBuilder(\"m1\")\n+                .requires(Set.of(Requires.Modifier.STATIC), \"m2\")\n+                .uses(\"p.S\")\n+                .build();\n+        ModuleFinder finder = ModuleUtils.finderOf(descriptor1);\n+        Configuration cf = resolve(finder, \"m1\");\n+        assertTrue(cf.modules().size() == 1);\n+        assertTrue(cf.findModule(\"m1\").isPresent());\n+    }\n@@ -1800,1 +1840,27 @@\n-     * Test \"uses p.S\" where p is not exported to the module.\n+     * Test uses optional service.\n+     *\n+     *     module m1 { requires m2; uses p.S; }\n+     *     module m2 { requires static transitive m3; }\n+     *\/\n+    @Test\n+    void testUsesOptionalService2() {\n+        ModuleDescriptor descriptor1 = newBuilder(\"m1\")\n+                .requires(\"m2\")\n+                .uses(\"p.S\")\n+                .build();\n+        ModuleDescriptor descriptor2 = newBuilder(\"m2\")\n+                .requires(Set.of(Requires.Modifier.STATIC, Requires.Modifier.TRANSITIVE), \"m3\")\n+                .build();\n+        ModuleFinder finder = ModuleUtils.finderOf(descriptor1, descriptor2);\n+        Configuration cf = resolve(finder, \"m1\");\n+        assertTrue(cf.modules().size() == 2);\n+        assertTrue(cf.findModule(\"m1\").isPresent());\n+        assertTrue(cf.findModule(\"m2\").isPresent());\n+    }\n+\n+    \/**\n+     * Test uses optional service.\n+     *\n+     *     module m1 { requires m2; uses p.S; }\n+     *     module m2 { requires transitive m3; }\n+     *     module m3 { requires static transitive m4; }\n@@ -1802,2 +1868,2 @@\n-    @Test(expectedExceptions = { ResolutionException.class })\n-    public void testServiceTypePackageNotExported1() {\n+    @Test\n+    void testUsesOptionalService3() {\n@@ -1805,0 +1871,1 @@\n+                .requires(\"m2\")\n@@ -1807,0 +1874,13 @@\n+        ModuleDescriptor descriptor2 = newBuilder(\"m2\")\n+                .requires(Set.of(Requires.Modifier.TRANSITIVE), \"m3\")\n+                .build();\n+        ModuleDescriptor descriptor3 = newBuilder(\"m3\")\n+                .requires(Set.of(Requires.Modifier.STATIC, Requires.Modifier.TRANSITIVE), \"m4\")\n+                .build();\n+        ModuleFinder finder = ModuleUtils.finderOf(descriptor1, descriptor2, descriptor3);\n+        Configuration cf = resolve(finder, \"m1\");\n+        assertTrue(cf.modules().size() == 3);\n+        assertTrue(cf.findModule(\"m1\").isPresent());\n+        assertTrue(cf.findModule(\"m2\").isPresent());\n+        assertTrue(cf.findModule(\"m3\").isPresent());\n+    }\n@@ -1808,0 +1888,11 @@\n+    \/**\n+     * Test provides optional service.\n+     *\n+     *     module m1 { requires static m2; provides p.S with q.P; }\n+     *\/\n+    @Test\n+    void testProvidesOptionalService1() {\n+        ModuleDescriptor descriptor1 = newBuilder(\"m1\")\n+                .requires(Set.of(Requires.Modifier.STATIC), \"m2\")\n+                .provides(\"p.S\", List.of(\"q.P\"))\n+                .build();\n@@ -1809,3 +1900,3 @@\n-\n-        \/\/ m1 does not read a module that exports p\n-        resolve(finder, \"m1\");\n+        Configuration cf = resolve(finder, \"m1\");\n+        assertTrue(cf.modules().size() == 1);\n+        assertTrue(cf.findModule(\"m1\").isPresent());\n@@ -1814,0 +1905,21 @@\n+    \/**\n+     * Test provides optional service.\n+     *\n+     *     module m1 { requires m2; provides p.S with q.P; }\n+     *     module m2 { requires static transitive m3; }\n+     *\/\n+    @Test\n+    void testProvidesOptionalService2() {\n+        ModuleDescriptor descriptor1 = newBuilder(\"m1\")\n+                .requires(\"m2\")\n+                .provides(\"p.S\", List.of(\"q.P\"))\n+                .build();\n+        ModuleDescriptor descriptor2 = newBuilder(\"m2\")\n+                .requires(Set.of(Requires.Modifier.STATIC, Requires.Modifier.TRANSITIVE), \"m3\")\n+                .build();\n+        ModuleFinder finder = ModuleUtils.finderOf(descriptor1, descriptor2);\n+        Configuration cf = resolve(finder, \"m1\");\n+        assertTrue(cf.modules().size() == 2);\n+        assertTrue(cf.findModule(\"m1\").isPresent());\n+        assertTrue(cf.findModule(\"m2\").isPresent());\n+    }\n@@ -1816,1 +1928,5 @@\n-     * Test \"provides p.S\" where p is not exported to the module.\n+     * Test provides optional service.\n+     *\n+     *     module m1 { requires m2; provides p.S with q.P; }\n+     *     module m2 { requires transitive m3; }\n+     *     module m3 { requires static transitive m4; }\n@@ -1818,2 +1934,2 @@\n-    @Test(expectedExceptions = { ResolutionException.class })\n-    public void testServiceTypePackageNotExported2() {\n+    @Test\n+    void testProvidesOptionalService3() {\n@@ -1821,1 +1937,5 @@\n-                .provides(\"p.S\", List.of(\"q.T\"))\n+                .requires(\"m2\")\n+                .provides(\"p.S\", List.of(\"q.P\"))\n+                .build();\n+        ModuleDescriptor descriptor2 = newBuilder(\"m2\")\n+                .requires(Set.of(Requires.Modifier.TRANSITIVE), \"m3\")\n@@ -1823,0 +1943,10 @@\n+        ModuleDescriptor descriptor3 = newBuilder(\"m3\")\n+                .requires(Set.of(Requires.Modifier.STATIC, Requires.Modifier.TRANSITIVE), \"m4\")\n+                .build();\n+        ModuleFinder finder = ModuleUtils.finderOf(descriptor1, descriptor2, descriptor3);\n+        Configuration cf = resolve(finder, \"m1\");\n+        assertTrue(cf.modules().size() == 3);\n+        assertTrue(cf.findModule(\"m1\").isPresent());\n+        assertTrue(cf.findModule(\"m2\").isPresent());\n+        assertTrue(cf.findModule(\"m3\").isPresent());\n+    }\n@@ -1824,0 +1954,8 @@\n+    \/**\n+     * Test \"uses p.S\" where p is not exported to the module.\n+     *\/\n+    @Test\n+    void testServiceTypePackageNotExported1() {\n+        ModuleDescriptor descriptor1 = newBuilder(\"m1\")\n+                .uses(\"p.S\")\n+                .build();\n@@ -1826,2 +1964,23 @@\n-        \/\/ m1 does not read a module that exports p\n-        resolve(finder, \"m1\");\n+        \/\/ m1 does not read a module that exports p to m1\n+        assertThrows(ResolutionException.class, () -> resolve(finder, \"m1\"));\n+    }\n+\n+    \/**\n+     * Test \"uses p.S\" where p is not exported to the module.\n+     *\n+     *     module m1 { requires m2; uses p.S; }\n+     *     module m2 { contains p; }\n+     *\/\n+    @Test\n+    void testServiceTypePackageNotExported2() {\n+        ModuleDescriptor descriptor1 = newBuilder(\"m1\")\n+                .requires(\"m2\")\n+                .uses(\"p.S\")\n+                .build();\n+        ModuleDescriptor descriptor2 = newBuilder(\"m2\")\n+                .packages(Set.of(\"p\"))\n+                .build();\n+        ModuleFinder finder = ModuleUtils.finderOf(descriptor1, descriptor2);\n+\n+        \/\/ m1 does not read a module that exports p to m1\n+        assertThrows(ResolutionException.class, () -> resolve(finder, \"m1\"));\n@@ -1834,1 +1993,2 @@\n-    public void testEmptyConfiguration() {\n+    @Test\n+    void testEmptyConfiguration() {\n@@ -1843,25 +2003,0 @@\n-\n-    \/\/ platform specific modules\n-\n-    @DataProvider(name = \"platformmatch\")\n-    public Object[][] createPlatformMatches() {\n-        return new Object[][]{\n-\n-            { \"\",              \"\" },\n-            { \"linux-arm\",     \"\" },\n-            { \"linux-arm\",     \"linux-arm\" },\n-\n-        };\n-\n-    };\n-\n-    @DataProvider(name = \"platformmismatch\")\n-    public Object[][] createBad() {\n-        return new Object[][] {\n-\n-            { \"linux-x64\",        \"linux-arm\" },\n-            { \"linux-x64\",        \"windows-x64\" },\n-\n-        };\n-    }\n-\n@@ -1871,3 +2006,3 @@\n-    @Test(dataProvider = \"platformmatch\")\n-    public void testPlatformMatch(String s1, String s2) throws IOException {\n-\n+    @ParameterizedTest\n+    @CsvSource({\",\", \"linux-aarch64,\", \"linux-aarch64,linux-aarch64\"})\n+    void testPlatformMatch(String targetPlatform1, String targetPlatform2) throws IOException {\n@@ -1880,1 +2015,1 @@\n-        Path dir1 = writeModule(descriptor1, s1);\n+        Path dir1 = writeModule(descriptor1, targetPlatform1);\n@@ -1883,1 +2018,1 @@\n-        Path dir2 = writeModule(descriptor2, s2);\n+        Path dir2 = writeModule(descriptor2, targetPlatform2);\n@@ -1896,2 +2031,1 @@\n-     * Test attempting to create a configuration with modules for different\n-     * platforms.\n+     * Test attempting to create a configuration with modules for different platforms.\n@@ -1899,4 +2033,5 @@\n-    @Test(dataProvider = \"platformmismatch\",\n-          expectedExceptions = FindException.class )\n-    public void testPlatformMisMatch(String s1, String s2) throws IOException {\n-        testPlatformMatch(s1, s2);\n+    @ParameterizedTest\n+    @CsvSource({\"linux-x64,linux-aarch64\", \"linux-x64,windows-x64\"})\n+    void testPlatformMisMatch(String targetPlatform1, String targetPlatform2) throws IOException {\n+        assertThrows(FindException.class,\n+                () -> testPlatformMatch(targetPlatform1, targetPlatform2));\n@@ -1907,2 +2042,2 @@\n-    @Test(expectedExceptions = { IllegalArgumentException.class })\n-    public void testResolveRequiresWithNoParents() {\n+    @Test\n+    void testResolveRequiresWithNoParents() {\n@@ -1910,1 +2045,2 @@\n-        Configuration.resolve(empty, List.of(), empty, Set.of());\n+        assertThrows(IllegalArgumentException.class,\n+                () -> Configuration.resolve(empty, List.of(), empty, Set.of()));\n@@ -1913,2 +2049,2 @@\n-    @Test(expectedExceptions = { IllegalArgumentException.class })\n-    public void testResolveRequiresAndUsesWithNoParents() {\n+    @Test\n+    void testResolveRequiresAndUsesWithNoParents() {\n@@ -1916,1 +2052,2 @@\n-        Configuration.resolveAndBind(empty, List.of(), empty, Set.of());\n+        assertThrows(IllegalArgumentException.class,\n+                () -> Configuration.resolveAndBind(empty, List.of(), empty, Set.of()));\n@@ -1921,5 +2058,5 @@\n-    @Test(dataProvider = \"platformmatch\")\n-    public void testResolveRequiresWithCompatibleParents(String s1, String s2)\n-        throws IOException\n-    {\n-        ModuleDescriptor base =  ModuleDescriptor.newModule(\"java.base\").build();\n+    @ParameterizedTest\n+    @CsvSource({\",\", \"linux-aarch64,\", \"linux-aarch64,linux-aarch64\"})\n+    void testResolveRequiresWithCompatibleParents(String targetPlatform1,\n+                                                  String targetPlatform2) throws IOException {\n+        ModuleDescriptor base = ModuleDescriptor.newModule(\"java.base\").build();\n@@ -1929,1 +2066,1 @@\n-        Path dir1 = writeModule(descriptor1, s1);\n+        Path dir1 = writeModule(descriptor1, targetPlatform1);\n@@ -1932,1 +2069,1 @@\n-        Path dir2 = writeModule(descriptor2, s2);\n+        Path dir2 = writeModule(descriptor2, targetPlatform2);\n@@ -1948,6 +2085,6 @@\n-    @Test(dataProvider = \"platformmismatch\",\n-          expectedExceptions = IllegalArgumentException.class )\n-    public void testResolveRequiresWithConflictingParents(String s1, String s2)\n-        throws IOException\n-    {\n-        testResolveRequiresWithCompatibleParents(s1, s2);\n+    @ParameterizedTest\n+    @CsvSource({\"linux-x64,linux-aarch64\", \"linux-x64,windows-x64\"})\n+    void testResolveRequiresWithConflictingParents(String targetPlatform1,\n+                                                   String targetPlatform2) throws IOException {\n+        assertThrows(IllegalArgumentException.class,\n+                () -> testResolveRequiresWithCompatibleParents(targetPlatform1, targetPlatform2));\n@@ -1959,6 +2096,4 @@\n-    \/\/ finder1, finder2, roots\n-\n-\n-    @Test(expectedExceptions = { NullPointerException.class })\n-    public void testResolveRequiresWithNull1() {\n-        resolve((ModuleFinder)null, ModuleFinder.of());\n+    @Test\n+    void testResolveRequiresWithNull1() {\n+        assertThrows(NullPointerException.class,\n+                () -> resolve((ModuleFinder) null, ModuleFinder.of()));\n@@ -1967,3 +2102,4 @@\n-    @Test(expectedExceptions = { NullPointerException.class })\n-    public void testResolveRequiresWithNull2() {\n-        resolve(ModuleFinder.of(), (ModuleFinder)null);\n+    @Test\n+    void testResolveRequiresWithNull2() {\n+        assertThrows(NullPointerException.class,\n+                () -> resolve(ModuleFinder.of(), (ModuleFinder) null));\n@@ -1972,2 +2108,2 @@\n-    @Test(expectedExceptions = { NullPointerException.class })\n-    public void testResolveRequiresWithNull3() {\n+    @Test\n+    void testResolveRequiresWithNull3() {\n@@ -1975,1 +2111,2 @@\n-        Configuration.resolve(null, List.of(empty),  ModuleFinder.of(), Set.of());\n+        assertThrows(NullPointerException.class,\n+                () -> Configuration.resolve(null, List.of(empty),  ModuleFinder.of(), Set.of()));\n@@ -1978,2 +2115,2 @@\n-    @Test(expectedExceptions = { NullPointerException.class })\n-    public void testResolveRequiresWithNull4() {\n+    @Test\n+    void testResolveRequiresWithNull4() {\n@@ -1981,1 +2118,2 @@\n-        Configuration.resolve(empty, null, empty, Set.of());\n+        assertThrows(NullPointerException.class,\n+                () -> Configuration.resolve(empty, null, empty, Set.of()));\n@@ -1984,2 +2122,2 @@\n-    @Test(expectedExceptions = { NullPointerException.class })\n-    public void testResolveRequiresWithNull5() {\n+    @Test\n+    void testResolveRequiresWithNull5() {\n@@ -1987,1 +2125,2 @@\n-        Configuration.resolve(ModuleFinder.of(), List.of(cf), null, Set.of());\n+        assertThrows(NullPointerException.class,\n+                () -> Configuration.resolve(ModuleFinder.of(), List.of(cf), null, Set.of()));\n@@ -1990,2 +2129,2 @@\n-    @Test(expectedExceptions = { NullPointerException.class })\n-    public void testResolveRequiresWithNull6() {\n+    @Test\n+    void testResolveRequiresWithNull6() {\n@@ -1994,1 +2133,2 @@\n-        Configuration.resolve(empty, List.of(cf), empty, null);\n+        assertThrows(NullPointerException.class,\n+                () -> Configuration.resolve(empty, List.of(cf), empty, null));\n@@ -1997,3 +2137,4 @@\n-    @Test(expectedExceptions = { NullPointerException.class })\n-    public void testResolveRequiresAndUsesWithNull1() {\n-        resolveAndBind((ModuleFinder) null, ModuleFinder.of());\n+    @Test\n+    void testResolveRequiresAndUsesWithNull1() {\n+        assertThrows(NullPointerException.class,\n+                () -> resolveAndBind((ModuleFinder) null, ModuleFinder.of()));\n@@ -2002,3 +2143,4 @@\n-    @Test(expectedExceptions = { NullPointerException.class })\n-    public void testResolveRequiresAndUsesWithNull2() {\n-        resolveAndBind(ModuleFinder.of(), (ModuleFinder) null);\n+    @Test\n+    void testResolveRequiresAndUsesWithNull2() {\n+        assertThrows(NullPointerException.class,\n+                () -> resolveAndBind(ModuleFinder.of(), (ModuleFinder) null));\n@@ -2007,2 +2149,2 @@\n-    @Test(expectedExceptions = { NullPointerException.class })\n-    public void testResolveRequiresAndUsesWithNull3() {\n+    @Test\n+    void testResolveRequiresAndUsesWithNull3() {\n@@ -2010,1 +2152,2 @@\n-        Configuration.resolveAndBind(null, List.of(empty), ModuleFinder.of(), Set.of());\n+        assertThrows(NullPointerException.class,\n+                () -> Configuration.resolveAndBind(null, List.of(empty), ModuleFinder.of(), Set.of()));\n@@ -2013,2 +2156,2 @@\n-    @Test(expectedExceptions = { NullPointerException.class })\n-    public void testResolveRequiresAndUsesWithNull4() {\n+    @Test\n+    void testResolveRequiresAndUsesWithNull4() {\n@@ -2016,1 +2159,2 @@\n-        Configuration.resolveAndBind(empty, null, empty, Set.of());\n+        assertThrows(NullPointerException.class,\n+                () -> Configuration.resolveAndBind(empty, null, empty, Set.of()));\n@@ -2019,2 +2163,2 @@\n-    @Test(expectedExceptions = { NullPointerException.class })\n-    public void testResolveRequiresAndUsesWithNull5() {\n+    @Test\n+    void testResolveRequiresAndUsesWithNull5() {\n@@ -2022,1 +2166,2 @@\n-        Configuration.resolveAndBind(ModuleFinder.of(), List.of(cf), null, Set.of());\n+        assertThrows(NullPointerException.class,\n+                () -> Configuration.resolveAndBind(ModuleFinder.of(), List.of(cf), null, Set.of()));\n@@ -2025,2 +2170,2 @@\n-    @Test(expectedExceptions = { NullPointerException.class })\n-    public void testResolveRequiresAndUsesWithNull6() {\n+    @Test\n+    void testResolveRequiresAndUsesWithNull6() {\n@@ -2029,1 +2174,2 @@\n-        Configuration.resolveAndBind(empty, List.of(cf), empty, null);\n+        assertThrows(NullPointerException.class,\n+                () -> Configuration.resolveAndBind(empty, List.of(cf), empty, null));\n@@ -2032,3 +2178,3 @@\n-    @Test(expectedExceptions = { NullPointerException.class })\n-    public void testFindModuleWithNull() {\n-        Configuration.empty().findModule(null);\n+    @Test\n+    void testFindModuleWithNull() {\n+        assertThrows(NullPointerException.class, () -> Configuration.empty().findModule(null));\n@@ -2039,20 +2185,6 @@\n-    @DataProvider(name = \"configurations\")\n-    public Object[][] configurations() {\n-        \/\/ empty, boot, and custom configurations\n-        return new Object[][] {\n-            { Configuration.empty(),              null },\n-            { ModuleLayer.boot().configuration(), null },\n-            { resolve(ModuleFinder.of()),         null },\n-        };\n-    }\n-\n-    @Test(dataProvider = \"configurations\",\n-            expectedExceptions = { UnsupportedOperationException.class })\n-    public void testUnmodifiableParents1(Configuration cf, Object ignore) {\n-        cf.parents().add(Configuration.empty());\n-    }\n-\n-    @Test(dataProvider = \"configurations\",\n-            expectedExceptions = { UnsupportedOperationException.class })\n-    public void testUnmodifiableParents2(Configuration cf, Object ignore) {\n-        cf.parents().remove(Configuration.empty());\n+    static Stream<Configuration> configurations() {\n+        return Stream.of(\n+                Configuration.empty(),\n+                ModuleLayer.boot().configuration(),\n+                resolve(ModuleFinder.of())\n+        );\n@@ -2061,8 +2193,7 @@\n-    @Test(dataProvider = \"configurations\",\n-            expectedExceptions = { UnsupportedOperationException.class })\n-    public void testUnmodifiableModules1(Configuration cf, Object ignore) {\n-        ResolvedModule module = ModuleLayer.boot()\n-                .configuration()\n-                .findModule(\"java.base\")\n-                .orElseThrow();\n-        cf.modules().add(module);\n+    @ParameterizedTest\n+    @MethodSource(\"configurations\")\n+    void testUnmodifiableParents(Configuration cf) {\n+        assertThrows(UnsupportedOperationException.class,\n+                () -> cf.parents().add(Configuration.empty()));\n+        assertThrows(UnsupportedOperationException.class,\n+                () -> cf.parents().remove(Configuration.empty()));\n@@ -2071,3 +2202,3 @@\n-    @Test(dataProvider = \"configurations\",\n-            expectedExceptions = { UnsupportedOperationException.class })\n-    public void testUnmodifiableModules2(Configuration cf, Object ignore) {\n+    @ParameterizedTest\n+    @MethodSource(\"configurations\")\n+    void testUnmodifiableModules(Configuration cf) {\n@@ -2078,1 +2209,4 @@\n-        cf.modules().remove(module);\n+        assertThrows(UnsupportedOperationException.class,\n+                () -> cf.modules().add(module));\n+        assertThrows(UnsupportedOperationException.class,\n+                () -> cf.modules().remove(module));\n@@ -2084,4 +2218,4 @@\n-    private Configuration resolve(Configuration parent,\n-                                  ModuleFinder before,\n-                                  ModuleFinder after,\n-                                  String... roots) {\n+    private static Configuration resolve(Configuration parent,\n+                                         ModuleFinder before,\n+                                         ModuleFinder after,\n+                                         String... roots) {\n@@ -2091,3 +2225,3 @@\n-    private Configuration resolve(Configuration parent,\n-                                  ModuleFinder before,\n-                                  String... roots) {\n+    private static Configuration resolve(Configuration parent,\n+                                         ModuleFinder before,\n+                                          String... roots) {\n@@ -2097,3 +2231,3 @@\n-    private Configuration resolve(ModuleFinder before,\n-                                  ModuleFinder after,\n-                                  String... roots) {\n+    private static Configuration resolve(ModuleFinder before,\n+                                         ModuleFinder after,\n+                                         String... roots) {\n@@ -2103,2 +2237,2 @@\n-    private Configuration resolve(ModuleFinder before,\n-                                  String... roots) {\n+    private static Configuration resolve(ModuleFinder before,\n+                                         String... roots) {\n@@ -2112,4 +2246,4 @@\n-    private Configuration resolveAndBind(Configuration parent,\n-                                         ModuleFinder before,\n-                                         ModuleFinder after,\n-                                         String... roots) {\n+    private static Configuration resolveAndBind(Configuration parent,\n+                                                ModuleFinder before,\n+                                                ModuleFinder after,\n+                                                String... roots) {\n@@ -2119,3 +2253,3 @@\n-    private Configuration resolveAndBind(Configuration parent,\n-                                         ModuleFinder before,\n-                                         String... roots) {\n+    private static Configuration resolveAndBind(Configuration parent,\n+                                                ModuleFinder before,\n+                                                String... roots) {\n@@ -2125,3 +2259,3 @@\n-    private Configuration resolveAndBind(ModuleFinder before,\n-                                         ModuleFinder after,\n-                                         String... roots) {\n+    private static Configuration resolveAndBind(ModuleFinder before,\n+                                                ModuleFinder after,\n+                                                String... roots) {\n@@ -2131,2 +2265,2 @@\n-    private Configuration resolveAndBind(ModuleFinder before,\n-                                         String... roots) {\n+    private static Configuration resolveAndBind(ModuleFinder before,\n+                                                String... roots) {\n@@ -2141,1 +2275,1 @@\n-    static Path writeModule(ModuleDescriptor descriptor, String targetPlatform)\n+    private static Path writeModule(ModuleDescriptor descriptor, String targetPlatform)\n","filename":"test\/jdk\/java\/lang\/module\/ConfigurationTest.java","additions":420,"deletions":286,"binary":false,"changes":706,"status":"modified"}]}