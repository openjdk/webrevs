{"files":[{"patch":"@@ -8240,0 +8240,18 @@\n+\/\/ ============================================================================\n+\/\/ VerifyVectorAlignment Instruction\n+\n+instruct verify_vector_alignment(iRegP addr, immL_positive_bitmaskI mask, rFlagsReg cr) %{\n+  match(Set addr (VerifyVectorAlignment addr mask));\n+  effect(KILL cr);\n+  format %{ \"verify_vector_alignment $addr $mask \\t! verify alignment\" %}\n+  ins_encode %{\n+    Label Lskip;\n+    \/\/ check if masked bits of addr are zero\n+    __ tst($addr$$Register, $mask$$constant);\n+    __ br(Assembler::EQ, Lskip);\n+    __ stop(\"verify_vector_alignment found a misaligned vector memory access\");\n+    __ bind(Lskip);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -8967,0 +8967,15 @@\n+instruct verify_vector_alignment(rRegP addr, immL32 mask, rFlagsReg cr) %{\n+  match(Set addr (VerifyVectorAlignment addr mask));\n+  effect(KILL cr);\n+  format %{ \"verify_vector_alignment $addr $mask \\t! verify alignment\" %}\n+  ins_encode %{\n+    Label Lskip;\n+    \/\/ check if masked bits of addr are zero\n+    __ testq($addr$$Register, $mask$$constant);\n+    __ jccb(Assembler::equal, Lskip);\n+    __ stop(\"verify_vector_alignment found a misaligned vector memory access\");\n+    __ bind(Lskip);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -797,0 +797,1 @@\n+       !strcmp(_matrule->_rChild->_opType,\"VerifyVectorAlignment\")||\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -96,0 +96,3 @@\n+  develop(bool, VerifyAlignVector, false,                                   \\\n+          \"Check that vector stores\/loads are aligned if AlignVector is on.\") \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"runtime\/globals_extension.hpp\"\n@@ -67,0 +68,7 @@\n+#ifdef ASSERT\n+  if (!AlignVector && VerifyAlignVector) {\n+    warning(\"VerifyAlignVector disabled because AlignVector is not enabled.\");\n+    FLAG_SET_CMDLINE(VerifyAlignVector, false);\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1797,0 +1797,7 @@\n+  if (derived->is_Mach() && derived->as_Mach()->ideal_Opcode() == Op_VerifyVectorAlignment) {\n+    \/\/ Bypass the verification node\n+    Node* base = find_base_for_derived(derived_base_map, derived->in(1), maxlrg);\n+    derived_base_map[derived->_idx] = base;\n+    return base;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -452,0 +452,1 @@\n+macro(VerifyVectorAlignment)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1053,1 +1053,1 @@\n-    if (has_method() && (_directive->VectorizeOption || _directive->VectorizeDebugOption)) {\n+    if (has_method() && _directive->VectorizeOption) {\n@@ -3689,0 +3689,25 @@\n+#ifdef ASSERT\n+    \/\/ Add VerifyVectorAlignment node between adr and load \/ store.\n+    if (VerifyAlignVector && Matcher::has_match_rule(Op_VerifyVectorAlignment)) {\n+      bool must_verify_alignment = n->is_LoadVector() ? n->as_LoadVector()->must_verify_alignment() :\n+                                                        n->as_StoreVector()->must_verify_alignment();\n+      if (must_verify_alignment) {\n+        jlong vector_width = n->is_LoadVector() ? n->as_LoadVector()->memory_size() :\n+                                                  n->as_StoreVector()->memory_size();\n+        \/\/ The memory access should be aligned to the vector width in bytes.\n+        \/\/ However, the underlying array is possibly less well aligned, but at least\n+        \/\/ to ObjectAlignmentInBytes. Hence, even if multiple arrays are accessed in\n+        \/\/ a loop we can expect at least the following alignment:\n+        jlong guaranteed_alignment = MIN2(vector_width, (jlong)ObjectAlignmentInBytes);\n+        assert(2 <= guaranteed_alignment && guaranteed_alignment <= 64, \"alignment must be in range\");\n+        assert(is_power_of_2(guaranteed_alignment), \"alignment must be power of 2\");\n+        \/\/ Create mask from alignment. e.g. 0b1000 -> 0b0111\n+        jlong mask = guaranteed_alignment - 1;\n+        Node* mask_con = ConLNode::make(mask);\n+        VerifyVectorAlignmentNode* va = new VerifyVectorAlignmentNode(n->in(MemNode::Address), mask_con);\n+        n->set_req(MemNode::Address, va);\n+      }\n+    }\n+#endif\n+    break;\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -360,0 +360,5 @@\n+  if (base != nullptr && base->is_Mach() && base->as_Mach()->ideal_Opcode() == Op_VerifyVectorAlignment) {\n+    \/\/ For VerifyVectorAlignment we just pass the type through\n+    return base->bottom_type()->is_ptr();\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -181,0 +181,1 @@\n+class VerifyVectorAlignmentNode;\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -560,2 +560,8 @@\n-  if (align_to_ref() == nullptr) {\n-    return false; \/\/ Did not find memory reference to align vectors\n+  if (_packset.length() == 0) {\n+#ifndef PRODUCT\n+    if (TraceSuperWord) {\n+      tty->print_cr(\"\\nNo pair packs generated, abort SuperWord.\");\n+      tty->cr();\n+    }\n+#endif\n+    return false;\n@@ -568,0 +574,2 @@\n+  filter_packs_for_alignment();\n+\n@@ -581,3 +589,3 @@\n-\/\/ This is the initial set of packs that will then be extended by\n-\/\/ following use->def and def->use links.  The align positions are\n-\/\/ assigned relative to the reference \"align_to_ref\"\n+\/\/ We can find adjacent memory references by comparing their relative\n+\/\/ alignment. If the final vectors can be aligned can not yet be determined,\n+\/\/ that is only done once all vectors are extended and combined.\n@@ -601,1 +609,0 @@\n-  Node_List align_to_refs;\n@@ -603,2 +610,5 @@\n-  int best_iv_adjustment = 0;\n-  MemNode* best_align_to_mem_ref = nullptr;\n+\n+  \/\/ Take the first mem_ref as the reference to align to. The pre-loop trip count is\n+  \/\/ modified to align this reference to a vector-aligned address. If strict alignment\n+  \/\/ is required, we may change the reference later (see filter_packs_for_alignment()).\n+  MemNode* align_to_mem_ref = nullptr;\n@@ -610,1 +620,0 @@\n-    align_to_refs.push(mem_ref);\n@@ -613,7 +622,3 @@\n-    if (best_align_to_mem_ref == nullptr) {\n-      \/\/ Set memory reference which is the best from all memory operations\n-      \/\/ to be used for alignment. The pre-loop trip count is modified to align\n-      \/\/ this reference to a vector-aligned address.\n-      best_align_to_mem_ref = mem_ref;\n-      best_iv_adjustment = iv_adjustment;\n-      NOT_PRODUCT(find_adjacent_refs_trace_1(best_align_to_mem_ref, best_iv_adjustment);)\n+    if (align_to_mem_ref == nullptr) {\n+      align_to_mem_ref = mem_ref;\n+      set_align_to_ref(align_to_mem_ref);\n@@ -636,72 +641,15 @@\n-    if (mem_ref_has_no_alignment_violation(mem_ref, iv_adjustment, align_to_ref_p,\n-                                           best_align_to_mem_ref, best_iv_adjustment,\n-                                           align_to_refs)) {\n-      \/\/ Create initial pack pairs of memory operations for which alignment was set.\n-      for (uint i = 0; i < memops.size(); i++) {\n-        Node* s1 = memops.at(i);\n-        int align = alignment(s1);\n-        if (align == top_align) continue;\n-        for (uint j = 0; j < memops.size(); j++) {\n-          Node* s2 = memops.at(j);\n-          if (alignment(s2) == top_align) continue;\n-          if (s1 != s2 && are_adjacent_refs(s1, s2)) {\n-            if (stmts_can_pack(s1, s2, align)) {\n-              Node_List* pair = new Node_List();\n-              pair->push(s1);\n-              pair->push(s2);\n-              if (!_do_vector_loop || same_origin_idx(s1, s2)) {\n-                _packset.append(pair);\n-              }\n-            }\n-          }\n-        }\n-      }\n-    } else {\n-      \/\/ Cannot create pairs for mem_ref. Reject all related memops forever.\n-\n-      \/\/ First, remove remaining memory ops of the same memory slice from the list.\n-      for (int i = memops.size() - 1; i >= 0; i--) {\n-        MemNode* s = memops.at(i)->as_Mem();\n-        if (same_memory_slice(s, mem_ref) || same_velt_type(s, mem_ref)) {\n-          memops.remove(i);\n-        }\n-      }\n-\n-      \/\/ Second, remove already constructed packs of the same memory slice.\n-      for (int i = _packset.length() - 1; i >= 0; i--) {\n-        Node_List* p = _packset.at(i);\n-        MemNode* s = p->at(0)->as_Mem();\n-        if (same_memory_slice(s, mem_ref) || same_velt_type(s, mem_ref)) {\n-          remove_pack_at(i);\n-        }\n-      }\n-\n-      \/\/ If needed find the best memory reference for loop alignment again.\n-      if (same_memory_slice(mem_ref, best_align_to_mem_ref) || same_velt_type(mem_ref, best_align_to_mem_ref)) {\n-        \/\/ Put memory ops from remaining packs back on memops list for\n-        \/\/ the best alignment search.\n-        uint orig_msize = memops.size();\n-        for (int i = 0; i < _packset.length(); i++) {\n-          Node_List* p = _packset.at(i);\n-          MemNode* s = p->at(0)->as_Mem();\n-          assert(!same_velt_type(s, mem_ref), \"sanity\");\n-          memops.push(s);\n-        }\n-        best_align_to_mem_ref = find_align_to_ref(memops, max_idx);\n-        if (best_align_to_mem_ref == nullptr) {\n-          if (TraceSuperWord) {\n-            tty->print_cr(\"SuperWord::find_adjacent_refs(): best_align_to_mem_ref == nullptr\");\n-          }\n-          \/\/ best_align_to_mem_ref will be used for adjusting the pre-loop limit in\n-          \/\/ SuperWord::align_initial_loop_index. Find one with the biggest vector size,\n-          \/\/ smallest data size and smallest iv offset from memory ops from remaining packs.\n-          if (_packset.length() > 0) {\n-            if (orig_msize == 0) {\n-              best_align_to_mem_ref = memops.at(max_idx)->as_Mem();\n-            } else {\n-              for (uint i = 0; i < orig_msize; i++) {\n-                memops.remove(0);\n-              }\n-              best_align_to_mem_ref = find_align_to_ref(memops, max_idx);\n-              assert(best_align_to_mem_ref == nullptr, \"sanity\");\n-              best_align_to_mem_ref = memops.at(max_idx)->as_Mem();\n+    \/\/ Create initial pack pairs of memory operations for which alignment was set.\n+    for (uint i = 0; i < memops.size(); i++) {\n+      Node* s1 = memops.at(i);\n+      int align = alignment(s1);\n+      if (align == top_align) continue;\n+      for (uint j = 0; j < memops.size(); j++) {\n+        Node* s2 = memops.at(j);\n+        if (alignment(s2) == top_align) continue;\n+        if (s1 != s2 && are_adjacent_refs(s1, s2)) {\n+          if (stmts_can_pack(s1, s2, align)) {\n+            Node_List* pair = new Node_List();\n+            pair->push(s1);\n+            pair->push(s2);\n+            if (!_do_vector_loop || same_origin_idx(s1, s2)) {\n+              _packset.append(pair);\n@@ -709,1 +657,0 @@\n-            assert(best_align_to_mem_ref != nullptr, \"sanity\");\n@@ -711,1 +658,0 @@\n-          break;\n@@ -713,5 +659,0 @@\n-        best_iv_adjustment = get_iv_adjustment(best_align_to_mem_ref);\n-        NOT_PRODUCT(find_adjacent_refs_trace_1(best_align_to_mem_ref, best_iv_adjustment);)\n-        \/\/ Restore list.\n-        while (memops.size() > orig_msize)\n-          (void)memops.pop();\n@@ -719,1 +660,1 @@\n-    } \/\/ unaligned memory accesses\n+    }\n@@ -728,0 +669,1 @@\n+  } \/\/ while (memops.size() != 0)\n@@ -729,2 +671,2 @@\n-  } \/\/ while (memops.size() != 0\n-  set_align_to_ref(best_align_to_mem_ref);\n+  assert(_packset.is_empty() || align_to_mem_ref != nullptr,\n+         \"packset empty or we find the alignment reference\");\n@@ -738,52 +680,0 @@\n-#ifndef PRODUCT\n-void SuperWord::find_adjacent_refs_trace_1(Node* best_align_to_mem_ref, int best_iv_adjustment) {\n-  if (is_trace_adjacent()) {\n-    tty->print(\"SuperWord::find_adjacent_refs best_align_to_mem_ref = %d, best_iv_adjustment = %d\",\n-       best_align_to_mem_ref->_idx, best_iv_adjustment);\n-       best_align_to_mem_ref->dump();\n-  }\n-}\n-#endif\n-\n-\/\/ If strict memory alignment is required (vectors_should_be_aligned), then check if\n-\/\/ mem_ref is aligned with best_align_to_mem_ref.\n-bool SuperWord::mem_ref_has_no_alignment_violation(MemNode* mem_ref, int iv_adjustment, VPointer& align_to_ref_p,\n-                                                   MemNode* best_align_to_mem_ref, int best_iv_adjustment,\n-                                                   Node_List &align_to_refs) {\n-  if (!vectors_should_be_aligned()) {\n-    \/\/ Alignment is not required by the hardware. No violation possible.\n-    return true;\n-  }\n-\n-  \/\/ All vectors need to be memory aligned, modulo their vector_width. This is more strict\n-  \/\/ than the hardware probably requires. Most hardware at most requires 4-byte alignment.\n-  \/\/\n-  \/\/ In the pre-loop, we align best_align_to_mem_ref to its vector_length. To ensure that\n-  \/\/ all mem_ref's are memory aligned modulo their vector_width, we only need to check that\n-  \/\/ they are all aligned to best_align_to_mem_ref, modulo their vector_width. For that,\n-  \/\/ we check the following 3 conditions.\n-\n-  \/\/ (1) All packs are aligned with best_align_to_mem_ref.\n-  if (memory_alignment(mem_ref, best_iv_adjustment) != 0) {\n-    return false;\n-  }\n-  \/\/ (2) All other vectors have vector_size less or equal to that of best_align_to_mem_ref.\n-  int vw = vector_width(mem_ref);\n-  int vw_best = vector_width(best_align_to_mem_ref);\n-  if (vw > vw_best) {\n-    \/\/ We only align to vector_width of best_align_to_mem_ref during pre-loop.\n-    \/\/ A mem_ref with a larger vector_width might thus not be vector_width aligned.\n-    return false;\n-  }\n-  \/\/ (3) Ensure that all vectors have the same invariant. We model memory accesses like this\n-  \/\/     address = base + k*iv + constant [+ invar]\n-  \/\/     memory_alignment ignores the invariant.\n-  VPointer p2(best_align_to_mem_ref, phase(), lpt(), nullptr, false);\n-  if (!align_to_ref_p.invar_equals(p2)) {\n-    \/\/ Do not vectorize memory accesses with different invariants\n-    \/\/ if unaligned memory accesses are not allowed.\n-    return false;\n-  }\n-  return true;\n-}\n-\n@@ -801,6 +691,0 @@\n-    \/\/ Only discard unalignable memory references if vector memory references\n-    \/\/ should be aligned on this platform.\n-    if (vectors_should_be_aligned() && !ref_is_alignable(p1)) {\n-      *cmp_ct.adr_at(i) = 0;\n-      continue;\n-    }\n@@ -895,89 +779,0 @@\n-\/\/------------------span_works_for_memory_size-----------------------------\n-static bool span_works_for_memory_size(MemNode* mem, int span, int mem_size, int offset) {\n-  bool span_matches_memory = false;\n-  if ((mem_size == type2aelembytes(T_BYTE) || mem_size == type2aelembytes(T_SHORT))\n-    && ABS(span) == type2aelembytes(T_INT)) {\n-    \/\/ There is a mismatch on span size compared to memory.\n-    for (DUIterator_Fast jmax, j = mem->fast_outs(jmax); j < jmax; j++) {\n-      Node* use = mem->fast_out(j);\n-      if (!VectorNode::is_type_transition_to_int(use)) {\n-        return false;\n-      }\n-    }\n-    \/\/ If all uses transition to integer, it means that we can successfully align even on mismatch.\n-    return true;\n-  }\n-  else {\n-    span_matches_memory = ABS(span) == mem_size;\n-  }\n-  return span_matches_memory && (ABS(offset) % mem_size) == 0;\n-}\n-\n-\/\/------------------------------ref_is_alignable---------------------------\n-\/\/ Can the preloop align the reference to position zero in the vector?\n-bool SuperWord::ref_is_alignable(VPointer& p) {\n-  if (!p.has_iv()) {\n-    return true;   \/\/ no induction variable\n-  }\n-  CountedLoopEndNode* pre_end = lp()->pre_loop_end();\n-  assert(pre_end->stride_is_con(), \"pre loop stride is constant\");\n-  int preloop_stride = pre_end->stride_con();\n-\n-  int span = preloop_stride * p.scale_in_bytes();\n-  int mem_size = p.memory_size();\n-  int offset   = p.offset_in_bytes();\n-  \/\/ Stride one accesses are alignable if offset is aligned to memory operation size.\n-  \/\/ Offset can be unaligned when UseUnalignedAccesses is used.\n-  if (span_works_for_memory_size(p.mem(), span, mem_size, offset)) {\n-    return true;\n-  }\n-  \/\/ If the initial offset from start of the object is computable,\n-  \/\/ check if the pre-loop can align the final offset accordingly.\n-  \/\/\n-  \/\/ In other words: Can we find an i such that the offset\n-  \/\/ after i pre-loop iterations is aligned to vw?\n-  \/\/   (init_offset + pre_loop) % vw == 0              (1)\n-  \/\/ where\n-  \/\/   pre_loop = i * span\n-  \/\/ is the number of bytes added to the offset by i pre-loop iterations.\n-  \/\/\n-  \/\/ For this to hold we need pre_loop to increase init_offset by\n-  \/\/   pre_loop = vw - (init_offset % vw)\n-  \/\/\n-  \/\/ This is only possible if pre_loop is divisible by span because each\n-  \/\/ pre-loop iteration increases the initial offset by 'span' bytes:\n-  \/\/   (vw - (init_offset % vw)) % span == 0\n-  \/\/\n-  int vw = vector_width_in_bytes(p.mem());\n-  assert(vw > 1, \"sanity\");\n-  Node* init_nd = pre_end->init_trip();\n-  if (init_nd->is_Con() && p.invar() == nullptr) {\n-    int init = init_nd->bottom_type()->is_int()->get_con();\n-    int init_offset = init * p.scale_in_bytes() + offset;\n-    if (init_offset < 0) { \/\/ negative offset from object start?\n-      return false;        \/\/ may happen in dead loop\n-    }\n-    if (vw % span == 0) {\n-      \/\/ If vm is a multiple of span, we use formula (1).\n-      if (span > 0) {\n-        return (vw - (init_offset % vw)) % span == 0;\n-      } else {\n-        assert(span < 0, \"nonzero stride * scale\");\n-        return (init_offset % vw) % -span == 0;\n-      }\n-    } else if (span % vw == 0) {\n-      \/\/ If span is a multiple of vw, we can simplify formula (1) to:\n-      \/\/   (init_offset + i * span) % vw == 0\n-      \/\/     =>\n-      \/\/   (init_offset % vw) + ((i * span) % vw) == 0\n-      \/\/     =>\n-      \/\/   init_offset % vw == 0\n-      \/\/\n-      \/\/ Because we add a multiple of vw to the initial offset, the final\n-      \/\/ offset is a multiple of vw if and only if init_offset is a multiple.\n-      \/\/\n-      return (init_offset % vw) == 0;\n-    }\n-  }\n-  return false;\n-}\n@@ -1029,4 +824,0 @@\n-    \/\/ iv_adjustment_in_bytes must be a multiple of elt_size if vector memory\n-    \/\/ references should be aligned on this platform.\n-    assert((ABS(iv_adjustment_in_bytes) % elt_size) == 0 || !vectors_should_be_aligned(),\n-           \"(%d) should be divisible by (%d)\", iv_adjustment_in_bytes, elt_size);\n@@ -1710,0 +1501,6 @@\n+#ifdef ASSERT\n+  for (int i = 0; i < _packset.length(); i++) {\n+    assert(_packset.at(i) != nullptr, \"no nullptr in packset\");\n+  }\n+#endif\n+\n@@ -1805,7 +1602,2 @@\n-  \/\/ Compress list.\n-  for (int i = _packset.length() - 1; i >= 0; i--) {\n-    Node_List* p1 = _packset.at(i);\n-    if (p1 == nullptr) {\n-      _packset.remove_at(i);\n-    }\n-  }\n+  \/\/ Remove all nullptr from packset\n+  compress_packset();\n@@ -1819,0 +1611,529 @@\n+#ifndef PRODUCT\n+void print_icon_or_idx(Node* n) {\n+  if (n == nullptr) {\n+    tty->print(\"(0)\");\n+  } else if (n->is_ConI()) {\n+    jint val = n->as_ConI()->get_int();\n+    tty->print(\"(%d)\", val);\n+  } else {\n+    tty->print(\"[%d]\", n->_idx);\n+  }\n+}\n+#endif\n+\n+\/\/ Find the set of alignment solutions for load\/store pack p.\n+AlignmentSolution SuperWord::pack_alignment_solution(Node_List* pack) {\n+  assert(pack != nullptr && (pack->at(0)->is_Load() || pack->at(0)->is_Store()), \"only load\/store packs\");\n+\n+  \/\/ All vector loads and stores need to be memory aligned. The alignment width (aw) in\n+  \/\/ principle is the vector_width. But when vector_width > ObjectAlignmentInBytes this is\n+  \/\/ too strict, since any memory object is only guaranteed to be ObjectAlignmentInBytes\n+  \/\/ aligned. For example, the relative offset between two arrays is only guaranteed to\n+  \/\/ be divisible by ObjectAlignmentInBytes.\n+  uint pack_size    = pack->size();\n+  MemNode* mem_ref  = pack->at(0)->as_Mem();\n+  int element_size  = mem_ref->memory_size();\n+  int vector_width  = pack_size * element_size;\n+  int aw            = MIN2(vector_width, ObjectAlignmentInBytes); \/\/ alignment_width\n+\n+  CountedLoopEndNode* pre_end = lp()->pre_loop_end();\n+  assert(pre_end->stride_is_con(), \"pre loop stride is constant\");\n+  int pre_stride    = pre_end->stride_con();\n+  int unroll_factor = _lp->unrolled_count();\n+  int main_stride   = iv_stride();\n+  Node* init_node   = pre_end->init_trip();\n+  assert(pre_stride * unroll_factor == main_stride, \"unrolled stride must be consistent\");\n+\n+  VPointer mem_ref_p(mem_ref, phase(), lpt(), nullptr, false);\n+  int scale         = mem_ref_p.scale_in_bytes();\n+  int offset        = mem_ref_p.offset_in_bytes();\n+  Node* base        = mem_ref_p.base();\n+  Node* invar       = mem_ref_p.invar();\n+  int invar_factor  = mem_ref_p.invar_factor();\n+\n+#ifndef PRODUCT\n+  if (is_trace_align_vector()) {\n+    tty->print(\" pack mem_ref:\");\n+    mem_ref->dump();\n+    tty->print_cr(\"  vector_width = pack_size(%d) * element_size(%d) = %d\",\n+                  pack_size, element_size, vector_width);\n+    tty->print_cr(\"  aw = alignment_width = min(vector_width(%d), ObjectAlignmentInBytes(%d)) = %d\",\n+                  vector_width, ObjectAlignmentInBytes, aw);\n+\n+    if (!init_node->is_ConI()) {\n+      tty->print(\"  init:\");\n+      init_node->dump();\n+    }\n+\n+    if (invar != nullptr) {\n+      tty->print(\"  invar:\");\n+      invar->dump();\n+    }\n+\n+    tty->print_cr(\"  invar_factor = %d\", invar_factor);\n+\n+    \/\/ iv = init + pre_iter * pre_stride + j * main_stride\n+    tty->print(\"  iv = init\");\n+    print_icon_or_idx(init_node);\n+    tty->print_cr(\" + pre_iter * pre_stride(%d) + j * main_stride(%d)\",\n+                  pre_stride, main_stride);\n+\n+    \/\/ adr = base + offset + invar + scale * iv\n+    tty->print(\"  adr = base\");\n+    print_icon_or_idx(base);\n+    tty->print(\" + offset(%d) + invar\", offset);\n+    print_icon_or_idx(invar);\n+    tty->print_cr(\" + scale(%d) * iv\", scale);\n+  }\n+#endif\n+\n+  \/\/ Out of simplicity: non power-of-2 stride not supported.\n+  if (!is_power_of_2(abs(pre_stride))) {\n+    return AlignmentSolution(\"non power-of-2 stride not supported\");\n+  }\n+  assert(is_power_of_2(abs(pre_stride)), \"pre_stride is power of 2\");\n+  assert(is_power_of_2(unroll_factor), \"unroll factor is power of 2\");\n+  assert(is_power_of_2(abs(main_stride)), \"main_stride is power of 2\");\n+  assert(aw > 0 && is_power_of_2(aw), \"aw must be power of 2\");\n+\n+  \/\/ Out of simplicity: non power-of-2 scale not supported.\n+  if (abs(scale) == 0 || !is_power_of_2(abs(scale))) {\n+    return AlignmentSolution(\"non power-of-2 scale not supported\");\n+  }\n+\n+  \/\/ We analyze the address of mem_ref. The idea is to disassemble it into a linear\n+  \/\/ expression, where we can use the constant factors as the basis for ensuring the\n+  \/\/ alignment of vector memory accesses.\n+  \/\/\n+  \/\/ The Simple form of the address is disassembled by VPointer into:\n+  \/\/\n+  \/\/   adr = base + offset + invar + scale * iv\n+  \/\/\n+  \/\/ Where the iv can be written as:\n+  \/\/\n+  \/\/   iv = init + pre_stride * pre_iter + main_stride * j\n+  \/\/\n+  \/\/ init:        value before pre-loop\n+  \/\/ pre_stride:  increment per pre-loop iteration\n+  \/\/ pre_iter:    number of pre-loop iterations (adjustable via pre-loop limit)\n+  \/\/ main_stride: increment per main-loop iteration (= pre_stride * unroll_factor)\n+  \/\/ j:           number of main-loop iterations (j >= 0)\n+  \/\/\n+  \/\/ In the following, we restate the simple form of the address expression, by first\n+  \/\/ expanding the iv variable. In a second step, we reshape the expression again, and\n+  \/\/ state it as a linear expression, consisting of 6 terms.\n+  \/\/\n+  \/\/          Simple form           Expansion of iv variable                  Reshaped with constants   Comments for terms\n+  \/\/          -----------           ------------------------                  -----------------------   ------------------\n+  \/\/   adr =  base               =  base                                   =  base                      (base mod aw = 0)\n+  \/\/        + offset              + offset                                  + C_const                   (sum of constant terms)\n+  \/\/        + invar               + invar_factor * var_invar                + C_invar * var_invar       (term for variable init)\n+  \/\/                          \/   + scale * init                            + C_init  * var_init        (term for invariant)\n+  \/\/        + scale * iv   -> |   + scale * pre_stride * pre_iter           + C_pre   * pre_iter        (adjustable pre-loop term)\n+  \/\/                          \\   + scale * main_stride * j                 + C_main  * j               (main-loop term, for any j >= 0)\n+  \/\/\n+  \/\/ We describe the 6 terms:\n+  \/\/   1) The \"base\" of the address is the address of a Java object (e.g. array),\n+  \/\/      and hence can be assumed to already be aw-aligned (base mod aw = 0).\n+  \/\/   2) The \"C_const\" term is the sum of all constant terms. This is \"offset\",\n+  \/\/      plus \"init\" if it is constant.\n+  \/\/   3) The \"C_invar * var_invar\" is the factorization of \"invar\" into a constant\n+  \/\/      and variable term. If there is no invariant, then \"C_invar\" is zero.\n+  \/\/   4) The \"C_init * var_init\" is the factorization of \"init\" into a constant\n+  \/\/      and a variable term. If \"init\" is constant, then \"C_init\" is zero, and\n+  \/\/      \"C_const\" accounts for \"init\" instead.\n+  \/\/   5) The \"C_pre * pre_iter\" term represents how much the iv is incremented\n+  \/\/      during the \"pre_iter\" pre-loop iterations. This term can be adjusted\n+  \/\/      by changing the pre-loop limit. This allows us to adjust the alignment\n+  \/\/      of the main-loop memory reference.\n+  \/\/   6) The \"C_main * j\" term represents how much the iv is increased during \"j\"\n+  \/\/      main-loop iterations.\n+\n+  int C_const_init = 0;\n+  int C_init = 0;\n+  if (init_node->is_ConI()) {\n+    \/\/ init is constant -> contribute init to the C_const term.\n+    C_const_init = init_node->as_ConI()->get_int();\n+    C_init = 0; \/\/ no C_init term\n+  } else {\n+    \/\/ init is variable -> contribute init to the C_init term.\n+    C_const_init = 0;\n+    C_init = scale;\n+  }\n+\n+  int C_invar = 0;\n+  if (invar != nullptr) {\n+    C_invar = abs(invar_factor);\n+  }\n+\n+  int C_const = offset + C_const_init * scale;\n+  int C_pre = scale * pre_stride;\n+  int C_main = scale * main_stride;\n+\n+#ifndef PRODUCT\n+  if (is_trace_align_vector()) {\n+    tty->print(\"      = base[%d] + \", base->_idx);\n+    tty->print_cr(\"C_const(%d) + C_invar(%d) * var_invar + C_init(%d) * var_init + C_pre(%d) * pre_iter + C_main(%d) * j\",\n+                  C_const, C_invar, C_init,  C_pre, C_main);\n+    if (init_node->is_ConI()) {\n+      tty->print_cr(\"  init is constant:\");\n+      tty->print_cr(\"    C_const_init = %d\", C_const_init);\n+      tty->print_cr(\"    C_init = %d\", C_init);\n+    } else {\n+      tty->print_cr(\"  init is variable:\");\n+      tty->print_cr(\"    C_const_init = %d\", C_const_init);\n+      tty->print_cr(\"    C_init = abs(scale)= %d\", C_init);\n+    }\n+    if (invar != nullptr) {\n+      tty->print_cr(\"  invariant present:\");\n+      tty->print_cr(\"    C_invar = abs(invar_factor) = %d\", C_invar);\n+    } else {\n+      tty->print_cr(\"  no invariant:\");\n+      tty->print_cr(\"    C_invar = %d\", C_invar);\n+    }\n+    tty->print_cr(\"  C_const = offset(%d) + scale(%d) * C_const_init(%d) = %d\",\n+                  offset, scale, C_const_init, C_const);\n+    tty->print_cr(\"  C_pre   = scale(%d) * pre_stride(%d) = %d\",\n+                  scale, pre_stride, C_pre);\n+    tty->print_cr(\"  C_main  = scale(%d) * main_stride(%d) = %d\",\n+                  scale, main_stride, C_main);\n+  }\n+#endif\n+\n+  \/\/ We must find a pre_iter, such that adr is aw aligned: adr % aw = 0.\n+  \/\/ Since \"base mod aw = 0\", we only need to ensure alignment of the other 5 terms:\n+  \/\/\n+  \/\/   C_const + C_invar * var_invar + C_init * var_init + C_pre * pre_iter + C_main * j = 0 (modulo aw)      (1)\n+  \/\/\n+  \/\/ Alignment must be maintained over all main-loop iterations, i.e. for any j >= 0, we require:\n+  \/\/\n+  \/\/   C_main % aw = 0                                                                                        (2*)\n+  \/\/\n+  int C_main_mod_aw = AlignmentSolution::mod(C_main, aw);\n+\n+#ifndef PRODUCT\n+  if (is_trace_align_vector()) {\n+    tty->print(\"  EQ(1  ): C_const(%d) + C_invar(%d) * var_invar + C_init(%d) * var_init\",\n+                  C_const, C_invar, C_init);\n+    tty->print(\" + C_pre(%d) * pre_iter + C_main(%d) * j = 0 (mod aw(%d))\",\n+                  C_pre, C_main, aw);\n+    tty->print_cr(\" (given base aligned -> align rest)\");\n+    tty->print(\"  EQ(2* ): C_main(%d) %% aw(%d) = scale(%d) * main_stride(%d) %% aw(%d) = %d = 0\",\n+               C_main, aw, scale, main_stride, aw, C_main_mod_aw);\n+    tty->print_cr(\" (alignment across iterations)\");\n+  }\n+#endif\n+\n+  if (C_main_mod_aw != 0) {\n+    return AlignmentSolution(\"EQ(2*) not satisfied (cannot align across main-loop iterations)\");\n+  }\n+\n+  \/\/ In what follows, we need to show that the C_const, init and invar terms can be aligned by\n+  \/\/ adjusting the pre-loop limit (pre-iter). We decompose pre_iter:\n+  \/\/\n+  \/\/   pre_iter = pre_iter_C_const + pre_iter_C_invar + pre_iter_C_init\n+  \/\/\n+  \/\/ where pre_iter_C_const, pre_iter_C_invar, and pre_iter_C_init are defined as the number of\n+  \/\/ pre-loop iterations required to align the C_const, init and invar terms individually.\n+  \/\/ Hence, we can rewrite:\n+  \/\/\n+  \/\/   C_const + C_invar * var_invar + C_init * var_init + C_pre * pre_iter\n+  \/\/   =  C_const             + C_pre * pre_iter_C_const\n+  \/\/    + C_invar * var_invar + C_pre * pre_iter_C_invar\n+  \/\/    + C_init  * var_init  + C_pre * pre_iter_C_init\n+  \/\/   = 0 (modulo aw)                                                           (3)\n+  \/\/\n+  \/\/ We strengthen the constraints by splitting the equation into 3 equations, where the C_const,\n+  \/\/ init, and invar term are aligned individually:\n+  \/\/\n+  \/\/   C_init  * var_init  + C_pre * pre_iter_C_init  = 0 (modulo aw)            (4a)\n+  \/\/   C_invar * var_invar + C_pre * pre_iter_C_invar = 0 (modulo aw)            (4b)\n+  \/\/   C_const             + C_pre * pre_iter_C_const = 0 (modulo aw)            (4c)\n+  \/\/\n+  \/\/ We can only guarantee solutions to (4a) and (4b) if:\n+  \/\/\n+  \/\/   C_init  % abs(C_pre) = 0                                                  (5a*)\n+  \/\/   C_invar % abs(C_pre) = 0                                                  (5b*)\n+  \/\/\n+  \/\/ Which means there are X and Y such that:\n+  \/\/\n+  \/\/   C_init  = C_pre * X       (X = 0 if C_init  = 0, else X = C_init  \/ C_pre)\n+  \/\/   C_invar = C_pre * Y       (Y = 0 if C_invar = 0, else Y = C_invar \/ C_pre)\n+  \/\/\n+  \/\/   C_init    * var_init  + C_pre * pre_iter_C_init  =\n+  \/\/   C_pre * X * var_init  + C_pre * pre_iter_C_init  =\n+  \/\/   C_pre * (X * var_init  + pre_iter_C_init)         = 0 (modulo aw)\n+  \/\/\n+  \/\/   C_invar   * var_invar + C_pre * pre_iter_C_invar =\n+  \/\/   C_pre * Y * var_invar + C_pre * pre_iter_C_invar =\n+  \/\/   C_pre * (Y * var_invar + pre_iter_C_invar)       = 0 (modulo aw)\n+  \/\/\n+  \/\/ And hence, we know that there are solutions for pre_iter_C_init and pre_iter_C_invar,\n+  \/\/ based on X, Y, var_init, and var_invar. We call them:\n+  \/\/\n+  \/\/   pre_iter_C_init  = alignment_init (X * var_init)\n+  \/\/   pre_iter_C_invar = alignment_invar(Y * var_invar)\n+  \/\/\n+  int C_init_mod_abs_C_pre  = AlignmentSolution::mod(C_init,  abs(C_pre));\n+  int C_invar_mod_abs_C_pre = AlignmentSolution::mod(C_invar, abs(C_pre));\n+\n+#ifndef PRODUCT\n+  if (is_trace_align_vector()) {\n+    tty->print_cr(\"  EQ(5a*): C_init(%d) %% abs(C_pre(%d)) = %d = 0   (if false: cannot align init)\",\n+                  C_init, C_pre, C_init_mod_abs_C_pre);\n+    tty->print_cr(\"  EQ(5b*): C_invar(%d) %% abs(C_pre(%d)) = %d = 0  (if false: cannot align invar)\",\n+                  C_invar, C_pre, C_invar_mod_abs_C_pre);\n+  }\n+#endif\n+\n+  if (C_init_mod_abs_C_pre != 0) {\n+    return AlignmentSolution(\"EQ(5a*) not satisfied (cannot align init)\");\n+  }\n+  if (C_invar_mod_abs_C_pre != 0) {\n+    return AlignmentSolution(\"EQ(5b*) not satisfied (cannot align invar)\");\n+  }\n+\n+  \/\/ Having solved (4a) and (4b), we now want to find solutions for (4c), i.e. we need\n+  \/\/ to show that the C_const term can be aligned with pre_iter_C_const.\n+  \/\/\n+  \/\/ We can assume that abs(C_pre) is a power of 2.\n+  \/\/\n+  \/\/ If abs(C_pre) >= aw, then:\n+  \/\/\n+  \/\/   for any pre_iter >= 0: C_pre * pre_iter = 0 (mod aw)\n+  \/\/   for any pre_iter_C_const >= 0: C_pre * pre_iter_C_const = 0 (mod aw)\n+  \/\/\n+  \/\/ which implies that C_iter (and pre_iter_C_const) have no effect on the alignment of\n+  \/\/ the C_const term. We thus either have a trivial solution, and any pre_iter aligns\n+  \/\/ the address, or there is no solution. To have the trivial solution, we require:\n+  \/\/\n+  \/\/   C_const % aw = 0                                                       (6*)\n+  \/\/\n+  assert(abs(C_pre) > 0 && is_power_of_2(abs(C_pre)), \"abs(C_pre) must be power of 2\");\n+  bool abs_C_pre_ge_aw = abs(C_pre) >= aw;\n+\n+#ifndef PRODUCT\n+  if (is_trace_align_vector()) {\n+    tty->print_cr(\"  abs(C_pre(%d)) >= aw(%d) -> %s\", C_pre, aw,\n+                  abs_C_pre_ge_aw ? \"true (pre-loop limit adjustment makes no difference)\" :\n+                                    \"false (pre-loop limit adjustment changes alignment)\");\n+  }\n+#endif\n+\n+  if (abs_C_pre_ge_aw) {\n+    int C_const_mod_aw = AlignmentSolution::mod(C_const, aw);\n+\n+#ifndef PRODUCT\n+    if (is_trace_align_vector()) {\n+      tty->print_cr(\"  EQ(6* ): C_const(%d) %% aw(%d) = %d = 0\",\n+                    C_const, aw, C_const_mod_aw);\n+    }\n+#endif\n+\n+    \/\/ The C_init and C_invar terms are trivially aligned.\n+    assert(AlignmentSolution::mod(C_init,  aw) == 0,  \"implied by abs(C_pre) >= aw and (5a*)\");\n+    assert(AlignmentSolution::mod(C_invar, aw) == 0,  \"implied by abs(C_pre) >= aw and (5b*)\");\n+\n+    if (C_const_mod_aw != 0) {\n+      return AlignmentSolution(\"EQ(6*) not satisfied: C_const not aligned\");\n+    } else {\n+      \/\/ Solution is trivial, holds for any pre-loop limit.\n+      return AlignmentSolution();\n+    }\n+  }\n+\n+  \/\/ Otherwise, if abs(C_pre) < aw, we find all solutions for pre_iter_C_const in (4c).\n+  \/\/ We state pre_iter_C_const in terms of the smallest possible pre_q and pre_r, such\n+  \/\/ that pre_q >= 0 and 0 <= pre_r < pre_q:\n+  \/\/\n+  \/\/   pre_iter_C_const = pre_r + pre_q * m  (for any m >= 0)                     (7)\n+  \/\/\n+  \/\/ We can now restate (4c) with (7):\n+  \/\/\n+  \/\/   C_const + C_pre * pre_r + C_pre * pre_q * m = 0 (modulo aw)                (8)\n+  \/\/\n+  \/\/ Since this holds for any m >= 0, we require:\n+  \/\/\n+  \/\/   C_pre * pre_q = 0 (modulo aw)                                              (9)\n+  \/\/   C_const + C_pre * pre_r = 0 (modulo aw)                                    (10*)\n+  \/\/\n+  \/\/ Given that abs(C_pre) is a powers of 2, and abs(C_pre) < aw:\n+  \/\/\n+  int  pre_q = aw \/ abs(C_pre);\n+  \/\/\n+  \/\/ We brute force the solution for pre_r by enumerating all values 0..pre_q-1 and\n+  \/\/ checking EQ(10*).\n+  \/\/\n+  \/\/ Assuming we found a solution for (4c), and also for (4a) and (4b), we know that\n+  \/\/ the solution to pre_iter is non-trivial:\n+  \/\/\n+  \/\/   pre_iter = pre_iter_C_const  + pre_iter_C_init              + pre_iter_C_invar\n+  \/\/            = pre_r + pre_q * m + alignment_init(X * var_init) + alignment_invar(Y * var_invar)\n+  \/\/\n+  \/\/ Hence, the solution depends on:\n+  \/\/   - Always: pre_r and pre_q\n+  \/\/   - If a variable init is present (i.e. C_init = scale), then we know that to\n+  \/\/     satisfy (5a*), we must have abs(pre_stride) = 1, X = 1 and C_pre = scale.\n+  \/\/     The solution thus depends on var_init = init \/ scale. We thus have a\n+  \/\/     dependency on scale. We could also add a dependency for init, but since\n+  \/\/     it is the same for all mem_refs in the loop this is unnecessary. If init\n+  \/\/     is constant, then we could add a dependency that there is no variable init.\n+  \/\/     But since init is the same for all mem_refs, this is unecessary.\n+  \/\/   - If an invariant is present (i.e. C_invar = abs(invar_factor)), then we know\n+  \/\/     from (5b*), that Y = abs(invar_factor) \/ (scale * pre_stride). The solution\n+  \/\/     depends on Y * var_invar = abs(invar_factor) * var_invar \/ (scale * pre_stride),\n+  \/\/     hence we have to add a dependency for invar, and scale (pre_stride is the\n+  \/\/     same for all mem_refs in the loop). If there is no invariant, then we add\n+  \/\/     a dependency that there is no invariant.\n+  \/\/\n+  \/\/ Other mem_refs must have solutions with  the same dependencies, otherwise we\n+  \/\/ cannot ensure that they require the same number of pre-loop iterations.\n+\n+#ifndef PRODUCT\n+  if (is_trace_align_vector()) {\n+    tty->print_cr(\"  Find alignment for C_const(%d), with:\", C_const);\n+    tty->print_cr(\"  pre_iter_C_const = pre_r + pre_q * m  (for any m >= 0)\");\n+    tty->print_cr(\"  C_const(%d) + C_pre(%d) * pre_r + C_pre(%d) * pre_q * m = 0 (modulo aw(%d)):\",\n+                  C_const, C_pre, C_pre, aw);\n+    tty->print_cr(\"  pre_q = aw(%d) \/ abs(C_pre(%d)) = %d\",\n+                  aw, C_pre, pre_q);\n+    tty->print_cr(\"  EQ(10*): brute force pre_r = 0..%d\", pre_q - 1);\n+  }\n+#endif\n+\n+  for (int pre_r = 0; pre_r < pre_q; pre_r++) {\n+    int EQ10_val = AlignmentSolution::mod(C_const + C_pre * pre_r, aw);\n+\n+#ifndef PRODUCT\n+    if (is_trace_align_vector()) {\n+      tty->print_cr(\"   try pre_r = %d: (C_const(%d) + C_pre(%d) * pre_r(%d)) %% aw(%d) = %d = 0\",\n+                    pre_r, C_const, C_pre, pre_r, aw, EQ10_val);\n+    }\n+#endif\n+\n+    if (EQ10_val == 0) {\n+      assert((C_init == 0) == init_node->is_ConI(), \"init consistent\");\n+      assert((C_invar == 0) == (invar == nullptr), \"invar consistent\");\n+\n+      Node* invar_dependency = invar;\n+      int scale_dependency  = (invar != nullptr || !init_node->is_ConI()) ? scale : 0;\n+      return AlignmentSolution(pre_r, pre_q, mem_ref, aw,\n+                               invar_dependency, scale_dependency);\n+    }\n+  }\n+  return AlignmentSolution(\"EQ(10*) has no solution for pre_r\");\n+}\n+\n+\/\/ Ensure that all packs can be aligned. We analyze each pack address, and if and how\n+\/\/ it can be aligned by adjusting the number of pre-loop iterations. This is how the\n+\/\/ pre-loop and unrolled main-loop look like for memref (adr):\n+\/\/\n+\/\/ iv = init\n+\/\/ i = 0 \/\/ single-iteration counter\n+\/\/\n+\/\/ pre-loop:\n+\/\/   iv = init + i * pre_stride\n+\/\/   adr = base + offset + invar + scale * iv\n+\/\/   adr = base + offset + invar + scale * (init + i * pre_stride)\n+\/\/   iv += pre_stride\n+\/\/   i++\n+\/\/\n+\/\/ pre_iter = i \/\/ number of iterations in the pre-loop\n+\/\/ iv = init + pre_iter * pre_stride\n+\/\/\n+\/\/ j = 0 \/\/ main-loop iteration counter\n+\/\/ main_stride = unroll_factor * pre_stride\n+\/\/\n+\/\/ main-loop:\n+\/\/   i = pre_iter + j * unroll_factor\n+\/\/   iv = init + i * pre_stride = init + pre_iter * pre_stride + j * unroll_factor * pre_stride\n+\/\/                              = init + pre_iter * pre_stride + j * main_stride\n+\/\/   adr = base + offset + invar + scale * iv \/\/ must be aligned\n+\/\/   iv += main_stride\n+\/\/   i  += unroll_factor\n+\/\/   j++\n+\/\/\n+\/\/ Find an alignment solution: find the set of pre_iter that memory align all packs.\n+\/\/ Start with the maximal set (pre_iter >= 0) and filter it with the constraints\n+\/\/ that the packs impose. If a pack is not compatible with the current solution, we\n+\/\/ remove it from the packset.\n+void SuperWord::filter_packs_for_alignment() {\n+  \/\/ We do not need to filter if no alignment is required.\n+  if (!vectors_should_be_aligned()) {\n+    return;\n+  }\n+\n+#ifndef PRODUCT\n+  if (TraceSuperWord || is_trace_align_vector()) {\n+    tty->print_cr(\"\\nfilter_packs_for_alignment:\");\n+  }\n+#endif\n+\n+  \/\/ Find an alignment solution: find the set of pre_iter that memory align all packs.\n+  \/\/ Start with the maximal set (pre_iter >= 0) and filter it with the constraints\n+  \/\/ that the packs impose.\n+  AlignmentSolution current; \/\/ trivial\n+  int mem_ops_count = 0;\n+  int mem_ops_rejected = 0;\n+  for (int i = 0; i < _packset.length(); i++) {\n+    Node_List* p = _packset.at(i);\n+    if (p != nullptr) {\n+      if (p->at(0)->is_Load() || p->at(0)->is_Store()) {\n+        mem_ops_count++;\n+        \/\/ Find solution for pack p, and filter with current solution.\n+        AlignmentSolution s = pack_alignment_solution(p);\n+        AlignmentSolution intersect = current.filter(s);\n+\n+#ifndef PRODUCT\n+        if (is_trace_align_vector()) {\n+          tty->print(\"  solution for pack:         \");\n+          s.print();\n+          tty->print(\"  intersection with current: \");\n+          intersect.print();\n+        }\n+#endif\n+\n+        if (intersect.is_valid()) {\n+          \/\/ Solution is compatible.\n+          current = intersect;\n+        } else {\n+          \/\/ Solution failed or is not compatible, remove pack i.\n+          _packset.at_put(i, nullptr);\n+          mem_ops_rejected++;\n+        }\n+      }\n+    }\n+  }\n+\n+#ifndef PRODUCT\n+  if (TraceSuperWord || is_trace_align_vector()) {\n+    tty->print(\"\\n final solution: \");\n+    current.print();\n+    tty->print_cr(\" rejected mem_ops packs: %d of %d\", mem_ops_rejected, mem_ops_count);\n+    tty->cr();\n+  }\n+#endif\n+\n+  assert(current.is_valid(), \"solution must be valid\");\n+  if (!current.is_trivial()) {\n+    \/\/ Solution is not trivial -> must change pre-limit to acheive alignment\n+    set_align_to_ref(current.mem_ref());\n+  }\n+\n+  \/\/ Remove all nullptr from packset\n+  compress_packset();\n+}\n+\n+\/\/ Compress packset, such that it has no nullptr entries\n+void SuperWord::compress_packset() {\n+  int j = 0;\n+  for (int i = 0; i < _packset.length(); i++) {\n+    Node_List* p = _packset.at(i);\n+    if (p != nullptr) {\n+      _packset.at_put(j, p);\n+      j++;\n+    }\n+  }\n+  _packset.trunc_to(j);\n+}\n+\n@@ -2492,3 +2813,1 @@\n-  \/\/ Ensure main loop's initial value is properly aligned\n-  \/\/  (iv_initial_value + min_iv_offset) % vector_width_in_bytes() == 0\n-  align_initial_loop_index(align_to_ref());\n+  adjust_pre_loop_limit_to_align_main_loop_vectors();\n@@ -2767,0 +3086,11 @@\n+#ifdef ASSERT\n+      \/\/ Mark Load\/Store Vector for alignment verification\n+      if (VerifyAlignVector) {\n+        if (vn->Opcode() == Op_LoadVector) {\n+          vn->as_LoadVector()->set_must_verify_alignment();\n+        } else if (vn->Opcode() == Op_StoreVector) {\n+          vn->as_StoreVector()->set_must_verify_alignment();\n+        }\n+      }\n+#endif\n+\n@@ -3550,0 +3880,8 @@\n+\/\/ Ensure that the main loop vectors are aligned by adjusting the pre loop limit. We memory align\n+\/\/ the address of \"align_to_ref\" to the maximal possible vector width. We adjust the pre-loop\n+\/\/ iteration count by adjusting the pre-loop limit.\n+void SuperWord::adjust_pre_loop_limit_to_align_main_loop_vectors() {\n+  MemNode* align_to_ref = _align_to_ref;\n+  assert(align_to_ref != nullptr, \"align_to_ref must be set\");\n+  assert(lp()->is_main_loop(), \"can only do alignment for main loop\");\n+  Opaque1Node* pre_opaq = lp()->pre_loop_end()->limit()->as_Opaque1();\n@@ -3551,10 +3889,1 @@\n-\/\/----------------------------align_initial_loop_index---------------------------\n-\/\/ Adjust pre-loop limit so that in main loop, a load\/store reference\n-\/\/ to align_to_ref will be a position zero in the vector.\n-\/\/   (iv + k) mod vector_align == 0\n-void SuperWord::align_initial_loop_index(MemNode* align_to_ref) {\n-  assert(lp()->is_main_loop(), \"\");\n-  CountedLoopEndNode* pre_end = lp()->pre_loop_end();\n-  Node* pre_opaq1 = pre_end->limit();\n-  assert(pre_opaq1->Opcode() == Op_Opaque1, \"\");\n-  Opaque1Node* pre_opaq = (Opaque1Node*)pre_opaq1;\n+  \/\/ Current pre-loop limit.\n@@ -3563,1 +3892,1 @@\n-  \/\/ Where we put new limit calculations\n+  \/\/ Where we put new limit calculations.\n@@ -3566,2 +3895,1 @@\n-  \/\/ Ensure the original loop limit is available from the\n-  \/\/ pre-loop Opaque1 node.\n+  \/\/ Ensure the original loop limit is available from the pre-loop Opaque1 node.\n@@ -3574,52 +3902,76 @@\n-  \/\/ Given:\n-  \/\/     lim0 == original pre loop limit\n-  \/\/     V == v_align (power of 2)\n-  \/\/     invar == extra invariant piece of the address expression\n-  \/\/     e == offset [ +\/- invar ]\n-  \/\/\n-  \/\/ When reassociating expressions involving '%' the basic rules are:\n-  \/\/     (a - b) % k == 0   =>  a % k == b % k\n-  \/\/ and:\n-  \/\/     (a + b) % k == 0   =>  a % k == (k - b) % k\n-  \/\/\n-  \/\/ For stride > 0 && scale > 0,\n-  \/\/   Derive the new pre-loop limit \"lim\" such that the two constraints:\n-  \/\/     (1) lim = lim0 + N           (where N is some positive integer < V)\n-  \/\/     (2) (e + lim) % V == 0\n-  \/\/   are true.\n-  \/\/\n-  \/\/   Substituting (1) into (2),\n-  \/\/     (e + lim0 + N) % V == 0\n-  \/\/   solve for N:\n-  \/\/     N = (V - (e + lim0)) % V\n-  \/\/   substitute back into (1), so that new limit\n-  \/\/     lim = lim0 + (V - (e + lim0)) % V\n-  \/\/\n-  \/\/ For stride > 0 && scale < 0\n-  \/\/   Constraints:\n-  \/\/     lim = lim0 + N\n-  \/\/     (e - lim) % V == 0\n-  \/\/   Solving for lim:\n-  \/\/     (e - lim0 - N) % V == 0\n-  \/\/     N = (e - lim0) % V\n-  \/\/     lim = lim0 + (e - lim0) % V\n-  \/\/\n-  \/\/ For stride < 0 && scale > 0\n-  \/\/   Constraints:\n-  \/\/     lim = lim0 - N\n-  \/\/     (e + lim) % V == 0\n-  \/\/   Solving for lim:\n-  \/\/     (e + lim0 - N) % V == 0\n-  \/\/     N = (e + lim0) % V\n-  \/\/     lim = lim0 - (e + lim0) % V\n-  \/\/\n-  \/\/ For stride < 0 && scale < 0\n-  \/\/   Constraints:\n-  \/\/     lim = lim0 - N\n-  \/\/     (e - lim) % V == 0\n-  \/\/   Solving for lim:\n-  \/\/     (e - lim0 + N) % V == 0\n-  \/\/     N = (V - (e - lim0)) % V\n-  \/\/     lim = lim0 - (V - (e - lim0)) % V\n-\n-  int vw = vector_width_in_bytes(align_to_ref);\n+  \/\/ We want to align the address of align_to_ref to some alignment width (aw, power of 2):\n+  \/\/\n+  \/\/   adr = base + offset + invar + scale * iv\n+  \/\/\n+  \/\/ The limit of the pre-loop needs to be adjusted.\n+  \/\/\n+  \/\/   lim0:     current pre-loop limit\n+  \/\/   lim:      new pre-loop limit\n+  \/\/   N:        difference between lim and lim0\n+  \/\/\n+  \/\/ We want to find N, such that:\n+  \/\/\n+  \/\/   iv = lim = lim0 + N   (exit when iv reaches the new limit)\n+  \/\/   adr % aw = 0          (adr is aligned aligned after pre-loop)\n+  \/\/\n+  \/\/ We can write:\n+  \/\/\n+  \/\/   E = base + offset + invar\n+  \/\/   adr = E + scale * lim\n+  \/\/       = E + scale * lim0 + scale * N\n+  \/\/\n+  \/\/   (E + scale * lim0 + scale * N) % aw = 0\n+  \/\/\n+  \/\/ In most cases, scale is the element size (elt_size), for example:\n+  \/\/\n+  \/\/   for (i = 0; i < a.length; i++) { a[i] = ...; }\n+  \/\/\n+  \/\/ It is thus reasonable to assume that both abs(scale) and abs(stride) are\n+  \/\/ strictly positive powers of 2. Further, they can be assumed to be non-zero,\n+  \/\/ otherwise the address does not depend on iv, and the alignment cannot be\n+  \/\/ affected by adjusting the pre-loop limit.\n+  \/\/\n+  \/\/ Further, if abs(scale) >= aw, then N has no effect on alignment, and we are not\n+  \/\/ able to affect the alignment at all. Hence, we require abs(scale) < aw.\n+  \/\/\n+  \/\/ Moreover, for alignment to be acheivabe, E must be a multiple of scale. We cannot\n+  \/\/ check this at compile time, and do not bother to do it at runtime either. If it\n+  \/\/ does not hold, we set a new limit, but it just does not ensure alignment.\n+  \/\/\n+  \/\/ In the following, we use:\n+  \/\/\n+  \/\/   V = aw \/ abs(scale)            (power of 2)\n+  \/\/   e = E \/ abs(scale)\n+  \/\/\n+  \/\/ Case 1: scale > 0 && stride > 0 (i.e. N >= 0)\n+  \/\/   (e + lim0 + N) % V = 0\n+  \/\/   N = (V - (e + lim0)) % V\n+  \/\/   lim = lim0 + (-e - lim0) % V\n+  \/\/\n+  \/\/ Case 2: scale < 0 && stride > 0 (i.e. N >= 0)\n+  \/\/   (e - lim0 - N) % V = 0\n+  \/\/   N = (e - lim0) % V\n+  \/\/   lim = lim0 + (+e - lim0) % V\n+  \/\/\n+  \/\/ Case 3: scale > 0 && stride < 0 (i.e. N <= 0)\n+  \/\/   (e + lim0 - abs(N)) % V = 0\n+  \/\/   abs(N) = (e + lim0) % V\n+  \/\/   lim = lim0 - (+e + lim0) % V\n+  \/\/\n+  \/\/ Case 4: scale < 0 && stride < 0 (i.e. N <= 0)\n+  \/\/   (e - lim0 + abs(N)) % V = 0\n+  \/\/   abs(N) = (lim0 - e) % V\n+  \/\/   lim = lim0 - (-e + lim0) % V\n+  \/\/\n+  \/\/ We generalize this with the following formula:\n+  \/\/   lim = lim0 +- (pm_e +- lim0) % V\n+  \/\/\n+  \/\/   pm_e = -+ E \/ abs(scale)\n+  \/\/        = pm_E \/ abs(scale)\n+  \/\/\n+  \/\/   pm_E = -+ (base + offset + invar)\n+  \/\/        = -+ offset -+ base -+ invar\n+\n+  \/\/ We chose an aw that is the maximal possible vector width for the type of\n+  \/\/ align_to_ref.\n+  int aw       = vector_width_in_bytes(align_to_ref);\n@@ -3628,11 +3980,57 @@\n-  int elt_size = align_to_ref_p.memory_size();\n-  int v_align  = vw \/ elt_size;\n-  assert(v_align > 1, \"sanity\");\n-  int offset   = align_to_ref_p.offset_in_bytes() \/ elt_size;\n-  Node *offsn  = _igvn.intcon(offset);\n-\n-  Node *e = offsn;\n-  if (align_to_ref_p.invar() != nullptr) {\n-    \/\/ incorporate any extra invariant piece producing (offset +\/- invar) >>> log2(elt)\n-    Node* log2_elt = _igvn.intcon(exact_log2(elt_size));\n-    Node* invar = align_to_ref_p.invar();\n+  int offset   = align_to_ref_p.offset_in_bytes();\n+  Node* base   = align_to_ref_p.adr();\n+  Node* invar  = align_to_ref_p.invar();\n+\n+#ifndef PRODUCT\n+  if (is_trace_align_vector()) {\n+    tty->print_cr(\"\\nadjust_pre_loop_limit_to_align_main_loop_vectors:\");\n+    tty->print(\" align_to_ref:\");\n+    align_to_ref->dump();\n+    tty->print_cr(\" aw:       %d\", aw);\n+    tty->print_cr(\" stride:   %d\", stride);\n+    tty->print_cr(\" scale:    %d\", scale);\n+    tty->print(\" base:\");\n+    base->dump();\n+    tty->print_cr(\" offset:   %d\", offset);\n+    if (invar == nullptr) {\n+      tty->print_cr(\" invar:     null\");\n+    } else {\n+      tty->print(\" invar:\");\n+      invar->dump();\n+    }\n+  }\n+#endif\n+\n+  if (stride == 0 || !is_power_of_2(abs(stride)) ||\n+      scale  == 0 || !is_power_of_2(abs(scale))  ||\n+      abs(scale) >= aw) {\n+#ifndef PRODUCT\n+    if (is_trace_align_vector()) {\n+      tty->print_cr(\" Alignment cannot be affected by changing pre-loop limit because\");\n+      tty->print_cr(\" stride or scale are not power of 2, or abs(scale) >= aw.\");\n+    }\n+#endif\n+    \/\/ Cannot affect alignment, abort.\n+    return;\n+  }\n+\n+  assert(stride != 0 && is_power_of_2(abs(stride)) &&\n+         scale  != 0 && is_power_of_2(abs(scale))  &&\n+         abs(scale) < aw, \"otherwise we cannot affect alignment with pre-loop\");\n+\n+  int V = aw \/ abs(scale);\n+\n+#ifndef PRODUCT\n+  if (is_trace_align_vector()) {\n+    tty->print_cr(\" V:        %d\", V);\n+  }\n+#endif\n+\n+  \/\/ 1: Compute pm_E\n+  bool is_minus = scale * stride > 0;\n+\n+  \/\/ 1.1: offset\n+  Node* pm_E = _igvn.intcon(is_minus ? -offset : offset);\n+\n+  \/\/ 1.2: invar (if it exists)\n+  if (invar != nullptr) {\n@@ -3646,6 +4044,7 @@\n-    Node* aref = new URShiftINode(invar, log2_elt);\n-    _igvn.register_new_node_with_optimizer(aref);\n-    _phase->set_ctrl(aref, pre_ctrl);\n-    e =  new AddINode(e, aref);\n-    _igvn.register_new_node_with_optimizer(e);\n-    _phase->set_ctrl(e, pre_ctrl);\n+    if (is_minus) {\n+      pm_E = new SubINode(pm_E, invar);\n+    } else {\n+      pm_E = new AddINode(pm_E, invar);\n+    }\n+    _igvn.register_new_node_with_optimizer(pm_E);\n+    _phase->set_ctrl(pm_E, pre_ctrl);\n@@ -3653,3 +4052,7 @@\n-  if (vw > ObjectAlignmentInBytes || align_to_ref_p.base()->is_top()) {\n-    \/\/ incorporate base e +\/- base && Mask >>> log2(elt)\n-    Node* xbase = new CastP2XNode(nullptr, align_to_ref_p.adr());\n+\n+  \/\/ 1.3: base (unless base is guaranteed aw aligned)\n+  if (aw > ObjectAlignmentInBytes || align_to_ref_p.base()->is_top()) {\n+    \/\/ The base is only aligned with ObjectAlignmentInBytes with arrays.\n+    \/\/ When the base() is top, we have no alignment guarantee at all.\n+    \/\/ Hence, we must now take the base into account for the calculation.\n+    Node* xbase = new CastP2XNode(nullptr, base);\n@@ -3661,15 +4064,19 @@\n-    Node* mask = _igvn.intcon(vw-1);\n-    Node* masked_xbase  = new AndINode(xbase, mask);\n-    _igvn.register_new_node_with_optimizer(masked_xbase);\n-    Node* log2_elt = _igvn.intcon(exact_log2(elt_size));\n-    Node* bref     = new URShiftINode(masked_xbase, log2_elt);\n-    _igvn.register_new_node_with_optimizer(bref);\n-    _phase->set_ctrl(bref, pre_ctrl);\n-    e = new AddINode(e, bref);\n-    _igvn.register_new_node_with_optimizer(e);\n-    _phase->set_ctrl(e, pre_ctrl);\n-  }\n-\n-  \/\/ compute e +\/- lim0\n-  if (scale < 0) {\n-    e = new SubINode(e, lim0);\n+    if (is_minus) {\n+      pm_E = new SubINode(pm_E, xbase);\n+    } else {\n+      pm_E = new AddINode(pm_E, xbase);\n+    }\n+    _igvn.register_new_node_with_optimizer(pm_E);\n+    _phase->set_ctrl(pm_E, pre_ctrl);\n+  }\n+\n+  \/\/ 2: compute pm_e by divide (shift) by abs(scale)\n+  Node* log2_abs_scale = _igvn.intcon(exact_log2(abs(scale)));\n+  Node* pm_e = new URShiftINode(pm_E, log2_abs_scale);\n+  _igvn.register_new_node_with_optimizer(pm_e);\n+  _phase->set_ctrl(pm_e, pre_ctrl);\n+\n+  \/\/ 3: add \/ subtract lim0\n+  Node* pm_e_pm_lim0 = nullptr;\n+  if (stride > 0) {\n+    pm_e_pm_lim0 = new SubINode(pm_e, lim0);\n@@ -3677,21 +4084,13 @@\n-    e = new AddINode(e, lim0);\n-  }\n-  _igvn.register_new_node_with_optimizer(e);\n-  _phase->set_ctrl(e, pre_ctrl);\n-\n-  if (stride * scale > 0) {\n-    \/\/ compute V - (e +\/- lim0)\n-    Node* va  = _igvn.intcon(v_align);\n-    e = new SubINode(va, e);\n-    _igvn.register_new_node_with_optimizer(e);\n-    _phase->set_ctrl(e, pre_ctrl);\n-  }\n-  \/\/ compute N = (exp) % V\n-  Node* va_msk = _igvn.intcon(v_align - 1);\n-  Node* N = new AndINode(e, va_msk);\n-  _igvn.register_new_node_with_optimizer(N);\n-  _phase->set_ctrl(N, pre_ctrl);\n-\n-  \/\/   substitute back into (1), so that new limit\n-  \/\/     lim = lim0 + N\n-  Node* lim;\n+    pm_e_pm_lim0 = new AddINode(pm_e, lim0);\n+  }\n+  _igvn.register_new_node_with_optimizer(pm_e_pm_lim0);\n+  _phase->set_ctrl(pm_e_pm_lim0, pre_ctrl);\n+\n+  \/\/ 4: modulo with V (mask with (V-1))\n+  Node* mask_V = _igvn.intcon(V-1);\n+  Node* pm_e_pm_lim0_mod_V = new AndINode(pm_e_pm_lim0, mask_V);\n+  _igvn.register_new_node_with_optimizer(pm_e_pm_lim0_mod_V);\n+  _phase->set_ctrl(pm_e_pm_lim0_mod_V, pre_ctrl);\n+\n+  \/\/ 5: compute new limit\n+  Node* lim = nullptr;\n@@ -3699,1 +4098,1 @@\n-    lim = new SubINode(lim0, N);\n+    lim = new SubINode(lim0, pm_e_pm_lim0_mod_V);\n@@ -3701,1 +4100,1 @@\n-    lim = new AddINode(lim0, N);\n+    lim = new AddINode(lim0, pm_e_pm_lim0_mod_V);\n@@ -3705,0 +4104,2 @@\n+\n+  \/\/ 6. Make sure not to exceed the original limit with the new limit\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":783,"deletions":382,"binary":false,"changes":1165,"status":"modified"},{"patch":"@@ -228,0 +228,159 @@\n+\/\/ When alignment is required, we must adjust the pre-loop iteration count pre_iter.\n+\/\/ We find the set of pre_iter which guarantee alignment:\n+\/\/\n+\/\/   pre_iter = pre_r + pre_q * m  (for any m >= 0)\n+\/\/\n+\/\/ Such that the address is aligned for any j >= 0:\n+\/\/\n+\/\/   adr = base + offset + invar + scale * init\n+\/\/                               + scale * pre_stride * pre_iter\n+\/\/                               + scale * main_stride * j\n+\/\/\n+\/\/ Two simplifying restrictions:\n+\/\/   1. In the presence of variable init, all solutions must have the same scale.\n+\/\/   2. In the presence of an invariant, all solutions must have the same invariant\n+\/\/      and the same scale.\n+\/\/\n+\/\/ A solution can be:\n+\/\/   1. Invalid with a failure reason.\n+\/\/   2. Trivial (any pre-loop limit guarantees alignment).\n+\/\/   3. Constrained (r, q, mem_ref, aw, scale, invar)\n+\/\/        Where scale is 0 if no scale dependency,\n+\/\/        and invar is nullptr if no invar dependency.\n+class AlignmentSolution {\n+private:\n+  bool _valid = false;\n+  const char* _reason = nullptr;\n+  bool _trivial = true;\n+  int _r = 0;\n+  int _q = 1;\n+  MemNode* _mem_ref = nullptr;\n+  int _aw = 0;\n+  Node* _invar_dependency = nullptr;\n+  int _scale_dependency = 0;\n+\n+public:\n+  \/\/ Invalid solution.\n+  AlignmentSolution(const char* reason) :\n+      _valid(false),\n+      _reason(reason),\n+      _trivial(false),\n+      _r(0),\n+      _q(1),\n+      _mem_ref(nullptr),\n+      _aw(1),\n+      _invar_dependency(nullptr),\n+      _scale_dependency(0) {\n+    assert(!is_trivial() && !is_valid(), \"must be invalid\");\n+  }\n+\n+  \/\/ Trivial Solution.\n+  AlignmentSolution() :\n+      _valid(true),\n+      _reason(nullptr),\n+      _trivial(true),\n+      _r(0),\n+      _q(1),\n+      _mem_ref(nullptr),\n+      _aw(1),\n+      _invar_dependency(nullptr),\n+      _scale_dependency(0) {\n+    assert(is_trivial() && is_valid(), \"must be trivial\");\n+  }\n+\n+  \/\/ Constrained solution.\n+  AlignmentSolution(const int r,\n+                    const int q,\n+                    MemNode* mem_ref,\n+                    int aw,\n+                    Node* invar_dependency,\n+                    int scale_dependency) :\n+      _valid(true),\n+      _reason(nullptr),\n+      _trivial(false),\n+      _r(r),\n+      _q(q),\n+      _mem_ref(mem_ref),\n+      _aw(aw),\n+      _invar_dependency(invar_dependency),\n+      _scale_dependency(scale_dependency) {\n+    assert(q > 1 && is_power_of_2(q), \"q must be power of 2\");\n+    assert(0 <= r && r < q, \"r must be in modulo space of q\");\n+    assert(!is_trivial() && is_valid(), \"must be constrained\");\n+    assert(_mem_ref != nullptr && _mem_ref->memory_size() <= _aw,\n+           \"must have mem_ref and aw\");\n+    assert(aw > 0 && is_power_of_2(aw), \"aw must be power of 2\");\n+  }\n+\n+  bool is_valid() const          { return _valid; }\n+  bool is_trivial() const        { return _trivial; }\n+  const char* reason() const     { assert(!is_valid(), \"only invalid has reason\"); return _reason; }\n+  int r() const                  { assert(is_valid(), \"only valid has solution\"); return _r; }\n+  int q() const                  { assert(is_valid(), \"only valid has solution\"); return _q; }\n+  MemNode* mem_ref() const       { assert(is_valid(), \"valid and not trivial\"); return _mem_ref; }\n+  int aw() const                 { assert(is_valid() && !is_trivial(), \"valid and not trivial\"); return _aw; }\n+  Node* invar_dependency() const { assert(is_valid() && !is_trivial(), \"valid and not trivial\"); return _invar_dependency; }\n+  int scale_dependency() const   { assert(is_valid() && !is_trivial(), \"valid and not trivial\"); return _scale_dependency; }\n+\n+  AlignmentSolution filter(const AlignmentSolution& other) const {\n+    \/\/ Solution invalid if either is invalid.\n+    if (!is_valid() || !other.is_valid()) {\n+      return AlignmentSolution(\"invalid solution input to filter\");\n+    }\n+    AlignmentSolution s1 = *this;\n+    AlignmentSolution s2 = other;\n+\n+    \/\/ If one is trivial, return the other.\n+    if (s1.is_trivial()) { return s2; }\n+    if (s2.is_trivial()) { return s1; }\n+\n+    \/\/ Combine two constrained solutions.\n+    if (s1.invar_dependency() != s2.invar_dependency()) {\n+      return AlignmentSolution(\"invar not identical\");\n+    }\n+    if (s1.scale_dependency() != s2.scale_dependency()) {\n+      return AlignmentSolution(\"different scale dependency (init \/ invar)\");\n+    }\n+    \/\/ Make s2 the bigger modulo space\n+    if (s1.q() > s2.q()) {\n+      swap(s1, s2);\n+    }\n+    assert(s1.q() <= s2.q(), \"s1 is a smaller modulo space than s2\");\n+    \/\/ Subset check:\n+    if (mod(s2.r(), s1.q()) != s1.r()) {\n+      \/\/ neither is subset of the other -> no intersection\n+      return AlignmentSolution(\"empty intersection (r and q)\");\n+    }\n+    \/\/ Now we know: \"s1 = r1 + m1 * q1\" is a superset of \"s2 = r2 + m2 * q2\"\n+    return s2; \/\/ return the subset\n+  }\n+\n+  void print() {\n+    if (is_valid()) {\n+      if (is_trivial()) {\n+        tty->print_cr(\"pre_iter >= 0 (trivial)\");\n+      } else {\n+        tty->print(\"pre_r(%d) + m * pre_q(%d), mem_ref[%d] %% aw(%d),\",\n+                      r(), q(), mem_ref()->_idx, aw());\n+        tty->print(\" scale = %d, \", scale_dependency());\n+        if (invar_dependency() == nullptr) {\n+          tty->print_cr(\"no invar\");\n+        } else {\n+          tty->print_cr(\"invar[%d]\", invar_dependency()->_idx);\n+        }\n+      }\n+    } else {\n+      tty->print_cr(\"no solution: %s\", reason());\n+    }\n+  }\n+\n+  \/\/ Compute modulo and ensure that we get a positive remainder\n+  static int mod(int i, int q) {\n+    assert(q >= 1, \"modulo value must be large enough\");\n+    int r = i % q;\n+    r = (r >= 0) ? r : r + q;\n+    assert(0 <= r && r < q, \"remainder must fit in modulo space\");\n+    return r;\n+  }\n+};\n+\n@@ -284,0 +443,1 @@\n+  bool     is_trace_align_vector() { return (_vector_loop_debug & 128) > 0; }\n@@ -444,9 +604,0 @@\n-  \/\/ Tracing support\n-  #ifndef PRODUCT\n-  void find_adjacent_refs_trace_1(Node* best_align_to_mem_ref, int best_iv_adjustment);\n-  #endif\n-  \/\/ If strict memory alignment is required (vectors_should_be_aligned), then check if\n-  \/\/ mem_ref is aligned with best_align_to_mem_ref.\n-  bool mem_ref_has_no_alignment_violation(MemNode* mem_ref, int iv_adjustment, VPointer& align_to_ref_p,\n-                                          MemNode* best_align_to_mem_ref, int best_iv_adjustment,\n-                                          Node_List &align_to_refs);\n@@ -457,2 +608,0 @@\n-  \/\/ Can the preloop align the reference to position zero in the vector?\n-  bool ref_is_alignable(VPointer& p);\n@@ -500,0 +649,6 @@\n+  \/\/ Ensure all packs are aligned, if AlignVector is on.\n+  void filter_packs_for_alignment();\n+  \/\/ Find the set of alignment solutions for load\/store pack p.\n+  AlignmentSolution pack_alignment_solution(Node_List* p);\n+  \/\/ Compress packset, such that it has no nullptr entries.\n+  void compress_packset();\n@@ -547,3 +702,2 @@\n-  \/\/ Adjust pre-loop limit so that in main loop, a load\/store reference\n-  \/\/ to align_to_ref will be a position zero in the vector.\n-  void align_initial_loop_index(MemNode* align_to_ref);\n+  \/\/ Ensure that the main loop vectors are aligned by adjusting the pre loop limit.\n+  void adjust_pre_loop_limit_to_align_main_loop_vectors();\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":168,"deletions":14,"binary":false,"changes":182,"status":"modified"},{"patch":"@@ -122,0 +122,16 @@\n+\/\/ Biggest detectable factor of the invariant.\n+int VPointer::invar_factor() {\n+  Node* n = invar();\n+  if (n == nullptr) {\n+    return 0;\n+  }\n+  int opc = n->Opcode();\n+  if (opc == Op_LShiftI && n->in(2)->is_Con()) {\n+    return 1 << n->in(2)->get_int();\n+  } else if (opc == Op_LShiftL && n->in(2)->is_Con()) {\n+    return 1 << n->in(2)->get_int();\n+  }\n+  \/\/ All our best-effort has failed.\n+  return 1;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -101,0 +101,3 @@\n+  \/\/ Biggest detectable factor of the invariant.\n+  int   invar_factor();\n+\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -850,0 +850,2 @@\n+ private:\n+  DEBUG_ONLY( bool _must_verify_alignment = false; );\n@@ -874,0 +876,11 @@\n+\n+  \/\/ Needed for proper cloning.\n+  virtual uint size_of() const { return sizeof(*this); }\n+\n+#ifdef ASSERT\n+  \/\/ When AlignVector is enabled, SuperWord only creates aligned vector loads and stores.\n+  \/\/ VerifyAlignVector verifies this. We need to mark the nodes created in SuperWord,\n+  \/\/ because nodes created elsewhere (i.e. VectorAPI) may still be misaligned.\n+  bool must_verify_alignment() const { return _must_verify_alignment; }\n+  void set_must_verify_alignment() { _must_verify_alignment = true; }\n+#endif\n@@ -897,0 +910,1 @@\n+  DEBUG_ONLY( bool _must_verify_alignment = false; );\n@@ -921,0 +935,8 @@\n+\n+#ifdef ASSERT\n+  \/\/ When AlignVector is enabled, SuperWord only creates aligned vector loads and stores.\n+  \/\/ VerifyAlignVector verifies this. We need to mark the nodes created in SuperWord,\n+  \/\/ because nodes created elsewhere (i.e. VectorAPI) may still be misaligned.\n+  bool must_verify_alignment() const { return _must_verify_alignment; }\n+  void set_must_verify_alignment() { _must_verify_alignment = true; }\n+#endif\n@@ -1020,0 +1042,20 @@\n+\/\/ Verify that memory address (adr) is alignemd. The mask specifies the\n+\/\/ least significant bits which have to be zero in the address.\n+\/\/\n+\/\/ if (adr & mask == 0) {\n+\/\/   return adr\n+\/\/ } else {\n+\/\/   stop(\"verify_vector_alignment found a misaligned vector memory access\")\n+\/\/ }\n+\/\/\n+\/\/ This node is used just before a vector load\/store with -XX:+VerifyAlignVector\n+class VerifyVectorAlignmentNode : public Node {\n+  virtual uint hash() const { return NO_HASH; };\n+public:\n+  VerifyVectorAlignmentNode(Node* adr, Node* mask) : Node(nullptr, adr, mask) {}\n+public:\n+  virtual int Opcode() const;\n+  virtual uint size_of() const { return sizeof(*this); }\n+  virtual const Type *bottom_type() const { return in(1)->bottom_type(); }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -53,6 +53,2 @@\n-        Object alignVector = wb.getVMFlag(\"AlignVector\");\n-        if (alignVector != null && !((Boolean)alignVector)) {\n-            if (ByteOrder.nativeOrder() != ByteOrder.LITTLE_ENDIAN) {\n-                throw new RuntimeException(\"fix test that was written for a little endian platform\");\n-            }\n-            TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\");\n+        if (ByteOrder.nativeOrder() != ByteOrder.LITTLE_ENDIAN) {\n+            throw new RuntimeException(\"fix test that was written for a little endian platform\");\n@@ -60,0 +56,1 @@\n+        TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\");\n@@ -192,1 +189,3 @@\n-    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" })\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" },\n+        applyIf = {\"AlignVector\", \"false\"})\n+    \/\/ AlignVector cannot guarantee that invar is aligned.\n@@ -326,1 +325,3 @@\n-    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" })\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" },\n+        applyIf = {\"AlignVector\", \"false\"})\n+    \/\/ AlignVector cannot guarantee that invar is aligned.\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorizationMismatchedAccess.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -138,0 +138,1 @@\n+                    \"AlignVector\",\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,1479 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Utils;\n+import jdk.test.whitebox.WhiteBox;\n+import jdk.internal.misc.Unsafe;\n+import java.lang.reflect.Array;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.Random;\n+import java.nio.ByteOrder;\n+\n+\/*\n+ * @test id=NoAlignVector\n+ * @bug 8310190\n+ * @summary Test AlignVector with various loop init, stride, scale, invar, etc.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @run driver compiler.loopopts.superword.TestAlignVector NoAlignVector\n+ *\/\n+\n+\/*\n+ * @test id=AlignVector\n+ * @bug 8310190\n+ * @summary Test AlignVector with various loop init, stride, scale, invar, etc.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @run driver compiler.loopopts.superword.TestAlignVector AlignVector\n+ *\/\n+\n+\/*\n+ * @test id=VerifyAlignVector\n+ * @bug 8310190\n+ * @summary Test AlignVector with various loop init, stride, scale, invar, etc.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @run driver compiler.loopopts.superword.TestAlignVector VerifyAlignVector\n+ *\/\n+\n+public class TestAlignVector {\n+    static int RANGE = 1024*8;\n+    static int RANGE_FINAL = 1024*8;\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    \/\/ Inputs\n+    byte[] aB;\n+    byte[] bB;\n+    byte mB = (byte)31;\n+    short[] aS;\n+    short[] bS;\n+    short mS = (short)0xF0F0;\n+    int[] aI;\n+    int[] bI;\n+    int mI = 0xF0F0F0F0;\n+    long[] aL;\n+    long[] bL;\n+    long mL = 0xF0F0F0F0F0F0F0F0L;\n+\n+    \/\/ List of tests\n+    Map<String,TestFunction> tests = new HashMap<String,TestFunction>();\n+\n+    \/\/ List of gold, the results from the first run before compilation\n+    Map<String,Object[]> golds = new HashMap<String,Object[]>();\n+\n+    interface TestFunction {\n+        Object[] run();\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework framework = new TestFramework(TestAlignVector.class);\n+        framework.addFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                           \"-XX:LoopUnrollLimit=250\");\n+\n+        switch (args[0]) {\n+            case \"NoAlignVector\"     -> { framework.addFlags(\"-XX:-AlignVector\"); }\n+            case \"AlignVector\"       -> { framework.addFlags(\"-XX:+AlignVector\"); }\n+            case \"VerifyAlignVector\" -> { framework.addFlags(\"-XX:+AlignVector\", \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+VerifyAlignVector\"); }\n+            default -> { throw new RuntimeException(\"Test argument not recognized: \" + args[0]); }\n+        }\n+        framework.start();\n+    }\n+\n+    public TestAlignVector() {\n+        \/\/ Generate input once\n+        aB = generateB();\n+        bB = generateB();\n+        aS = generateS();\n+        bS = generateS();\n+        aI = generateI();\n+        bI = generateI();\n+        aL = generateL();\n+        bL = generateL();\n+\n+        \/\/ Add all tests to list\n+        tests.put(\"test0\",       () -> { return test0(aB.clone(), bB.clone(), mB); });\n+        tests.put(\"test1\",       () -> { return test1(aB.clone(), bB.clone(), mB); });\n+        tests.put(\"test2\",       () -> { return test2(aB.clone(), bB.clone(), mB); });\n+        tests.put(\"test3\",       () -> { return test3(aB.clone(), bB.clone(), mB); });\n+        tests.put(\"test4\",       () -> { return test4(aB.clone(), bB.clone(), mB); });\n+        tests.put(\"test5\",       () -> { return test5(aB.clone(), bB.clone(), mB, 0); });\n+        tests.put(\"test6\",       () -> { return test6(aB.clone(), bB.clone(), mB); });\n+        tests.put(\"test7\",       () -> { return test7(aS.clone(), bS.clone(), mS); });\n+        tests.put(\"test8\",       () -> { return test8(aB.clone(), bB.clone(), mB, 0); });\n+        tests.put(\"test8\",       () -> { return test8(aB.clone(), bB.clone(), mB, 1); });\n+        tests.put(\"test9\",       () -> { return test9(aB.clone(), bB.clone(), mB); });\n+\n+        tests.put(\"test10a\",     () -> { return test10a(aB.clone(), bB.clone(), mB); });\n+        tests.put(\"test10b\",     () -> { return test10b(aB.clone(), bB.clone(), mB); });\n+        tests.put(\"test10c\",     () -> { return test10c(aS.clone(), bS.clone(), mS); });\n+        tests.put(\"test10d\",     () -> { return test10d(aS.clone(), bS.clone(), mS); });\n+\n+        tests.put(\"test11aB\",    () -> { return test11aB(aB.clone(), bB.clone(), mB); });\n+        tests.put(\"test11aS\",    () -> { return test11aS(aS.clone(), bS.clone(), mS); });\n+        tests.put(\"test11aI\",    () -> { return test11aI(aI.clone(), bI.clone(), mI); });\n+        tests.put(\"test11aL\",    () -> { return test11aL(aL.clone(), bL.clone(), mL); });\n+\n+        tests.put(\"test11bB\",    () -> { return test11bB(aB.clone(), bB.clone(), mB); });\n+        tests.put(\"test11bS\",    () -> { return test11bS(aS.clone(), bS.clone(), mS); });\n+        tests.put(\"test11bI\",    () -> { return test11bI(aI.clone(), bI.clone(), mI); });\n+        tests.put(\"test11bL\",    () -> { return test11bL(aL.clone(), bL.clone(), mL); });\n+\n+        tests.put(\"test11cB\",    () -> { return test11cB(aB.clone(), bB.clone(), mB); });\n+        tests.put(\"test11cS\",    () -> { return test11cS(aS.clone(), bS.clone(), mS); });\n+        tests.put(\"test11cI\",    () -> { return test11cI(aI.clone(), bI.clone(), mI); });\n+        tests.put(\"test11cL\",    () -> { return test11cL(aL.clone(), bL.clone(), mL); });\n+\n+        tests.put(\"test11dB\",    () -> { return test11dB(aB.clone(), bB.clone(), mB, 0); });\n+        tests.put(\"test11dS\",    () -> { return test11dS(aS.clone(), bS.clone(), mS, 0); });\n+        tests.put(\"test11dI\",    () -> { return test11dI(aI.clone(), bI.clone(), mI, 0); });\n+        tests.put(\"test11dL\",    () -> { return test11dL(aL.clone(), bL.clone(), mL, 0); });\n+\n+        tests.put(\"test12\",      () -> { return test12(aB.clone(), bB.clone(), mB); });\n+\n+        tests.put(\"test13aIL\",   () -> { return test13aIL(aI.clone(), aL.clone()); });\n+        tests.put(\"test13aIB\",   () -> { return test13aIB(aI.clone(), aB.clone()); });\n+        tests.put(\"test13aIS\",   () -> { return test13aIS(aI.clone(), aS.clone()); });\n+        tests.put(\"test13aBSIL\", () -> { return test13aBSIL(aB.clone(), aS.clone(), aI.clone(), aL.clone()); });\n+\n+        tests.put(\"test13bIL\",   () -> { return test13bIL(aI.clone(), aL.clone()); });\n+        tests.put(\"test13bIB\",   () -> { return test13bIB(aI.clone(), aB.clone()); });\n+        tests.put(\"test13bIS\",   () -> { return test13bIS(aI.clone(), aS.clone()); });\n+        tests.put(\"test13bBSIL\", () -> { return test13bBSIL(aB.clone(), aS.clone(), aI.clone(), aL.clone()); });\n+\n+        tests.put(\"test14aB\",    () -> { return test14aB(aB.clone()); });\n+        tests.put(\"test14bB\",    () -> { return test14bB(aB.clone()); });\n+        tests.put(\"test14cB\",    () -> { return test14cB(aB.clone()); });\n+\n+        tests.put(\"test15aB\",    () -> { return test15aB(aB.clone()); });\n+        tests.put(\"test15bB\",    () -> { return test15bB(aB.clone()); });\n+        tests.put(\"test15cB\",    () -> { return test15cB(aB.clone()); });\n+\n+        tests.put(\"test16a\",     () -> { return test16a(aB.clone(), aS.clone()); });\n+        tests.put(\"test16b\",     () -> { return test16b(aB.clone()); });\n+\n+        tests.put(\"test17a\",     () -> { return test17a(aL.clone()); });\n+        tests.put(\"test17b\",     () -> { return test17b(aL.clone()); });\n+        tests.put(\"test17c\",     () -> { return test17c(aL.clone()); });\n+        tests.put(\"test17d\",     () -> { return test17d(aL.clone()); });\n+\n+        tests.put(\"test18a\",     () -> { return test18a(aB.clone(), aI.clone()); });\n+        tests.put(\"test18b\",     () -> { return test18b(aB.clone(), aI.clone()); });\n+\n+        tests.put(\"test19\",      () -> { return test19(aI.clone(), bI.clone()); });\n+        tests.put(\"test20\",      () -> { return test20(aB.clone()); });\n+\n+        \/\/ Compute gold value for all test methods before compilation\n+        for (Map.Entry<String,TestFunction> entry : tests.entrySet()) {\n+            String name = entry.getKey();\n+            TestFunction test = entry.getValue();\n+            Object[] gold = test.run();\n+            golds.put(name, gold);\n+        }\n+    }\n+\n+    @Warmup(100)\n+    @Run(test = {\"test0\",\n+                 \"test1\",\n+                 \"test2\",\n+                 \"test3\",\n+                 \"test4\",\n+                 \"test5\",\n+                 \"test6\",\n+                 \"test7\",\n+                 \"test8\",\n+                 \"test9\",\n+                 \"test10a\",\n+                 \"test10b\",\n+                 \"test10c\",\n+                 \"test10d\",\n+                 \"test11aB\",\n+                 \"test11aS\",\n+                 \"test11aI\",\n+                 \"test11aL\",\n+                 \"test11bB\",\n+                 \"test11bS\",\n+                 \"test11bI\",\n+                 \"test11bL\",\n+                 \"test11cB\",\n+                 \"test11cS\",\n+                 \"test11cI\",\n+                 \"test11cL\",\n+                 \"test11dB\",\n+                 \"test11dS\",\n+                 \"test11dI\",\n+                 \"test11dL\",\n+                 \"test12\",\n+                 \"test13aIL\",\n+                 \"test13aIB\",\n+                 \"test13aIS\",\n+                 \"test13aBSIL\",\n+                 \"test13bIL\",\n+                 \"test13bIB\",\n+                 \"test13bIS\",\n+                 \"test13bBSIL\",\n+                 \"test14aB\",\n+                 \"test14bB\",\n+                 \"test14cB\",\n+                 \"test15aB\",\n+                 \"test15bB\",\n+                 \"test15cB\",\n+                 \"test16a\",\n+                 \"test16b\",\n+                 \"test17a\",\n+                 \"test17b\",\n+                 \"test17c\",\n+                 \"test17d\",\n+                 \"test18a\",\n+                 \"test18b\",\n+                 \"test19\",\n+                 \"test20\"})\n+    public void runTests() {\n+        for (Map.Entry<String,TestFunction> entry : tests.entrySet()) {\n+            String name = entry.getKey();\n+            TestFunction test = entry.getValue();\n+            \/\/ Recall gold value from before compilation\n+            Object[] gold = golds.get(name);\n+            \/\/ Compute new result\n+            Object[] result = test.run();\n+            \/\/ Compare gold and new result\n+            verify(name, gold, result);\n+        }\n+    }\n+\n+    static byte[] generateB() {\n+        byte[] a = new byte[RANGE];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = (byte)RANDOM.nextInt();\n+        }\n+        return a;\n+    }\n+\n+    static short[] generateS() {\n+        short[] a = new short[RANGE];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = (short)RANDOM.nextInt();\n+        }\n+        return a;\n+    }\n+\n+    static int[] generateI() {\n+        int[] a = new int[RANGE];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = RANDOM.nextInt();\n+        }\n+        return a;\n+    }\n+\n+    static long[] generateL() {\n+        long[] a = new long[RANGE];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = RANDOM.nextLong();\n+        }\n+        return a;\n+    }\n+\n+    static void verify(String name, Object[] gold, Object[] result) {\n+        if (gold.length != result.length) {\n+            throw new RuntimeException(\"verify \" + name + \": not the same number of outputs: gold.length = \" +\n+                                       gold.length + \", result.length = \" + result.length);\n+        }\n+        for (int i = 0; i < gold.length; i++) {\n+            Object g = gold[i];\n+            Object r = result[i];\n+            if (g.getClass() != r.getClass() || !g.getClass().isArray() || !r.getClass().isArray()) {\n+                throw new RuntimeException(\"verify \" + name + \": must both be array of same type:\" +\n+                                           \" gold[\" + i + \"].getClass() = \" + g.getClass().getSimpleName() +\n+                                           \" result[\" + i + \"].getClass() = \" + r.getClass().getSimpleName());\n+            }\n+            if (g == r) {\n+                throw new RuntimeException(\"verify \" + name + \": should be two separate arrays (with identical content):\" +\n+                                           \" gold[\" + i + \"] == result[\" + i + \"]\");\n+            }\n+            if (Array.getLength(g) != Array.getLength(r)) {\n+                    throw new RuntimeException(\"verify \" + name + \": arrays must have same length:\" +\n+                                           \" gold[\" + i + \"].length = \" + Array.getLength(g) +\n+                                           \" result[\" + i + \"].length = \" + Array.getLength(r));\n+            }\n+            Class c = g.getClass().getComponentType();\n+            if (c == byte.class) {\n+                verifyB(name, i, (byte[])g, (byte[])r);\n+            } else if (c == short.class) {\n+                verifyS(name, i, (short[])g, (short[])r);\n+            } else if (c == int.class) {\n+                verifyI(name, i, (int[])g, (int[])r);\n+            } else if (c == long.class) {\n+                verifyL(name, i, (long[])g, (long[])r);\n+            } else {\n+                throw new RuntimeException(\"verify \" + name + \": array type not supported for verify:\" +\n+                                       \" gold[\" + i + \"].getClass() = \" + g.getClass().getSimpleName() +\n+                                       \" result[\" + i + \"].getClass() = \" + r.getClass().getSimpleName());\n+            }\n+        }\n+    }\n+\n+    static void verifyB(String name, int i, byte[] g, byte[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verify \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    static void verifyS(String name, int i, short[] g, short[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verify \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    static void verifyI(String name, int i, int[] g, int[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verify \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    static void verifyL(String name, int i, long[] g, long[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verify \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VB,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">=8\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test0(byte[] a, byte[] b, byte mask) {\n+        for (int i = 0; i < RANGE; i+=8) {\n+            \/\/ Safe to vectorize with AlignVector\n+            b[i+0] = (byte)(a[i+0] & mask); \/\/ offset 0, align 0\n+            b[i+1] = (byte)(a[i+1] & mask);\n+            b[i+2] = (byte)(a[i+2] & mask);\n+            b[i+3] = (byte)(a[i+3] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.AND_VB, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test1(byte[] a, byte[] b, byte mask) {\n+        for (int i = 0; i < RANGE; i+=8) {\n+            \/\/ Safe to vectorize with AlignVector\n+            b[i+0] = (byte)(a[i+0] & mask); \/\/ offset 0, align 0\n+            b[i+1] = (byte)(a[i+1] & mask);\n+            b[i+2] = (byte)(a[i+2] & mask);\n+            b[i+3] = (byte)(a[i+3] & mask);\n+            b[i+4] = (byte)(a[i+4] & mask);\n+            b[i+5] = (byte)(a[i+5] & mask);\n+            b[i+6] = (byte)(a[i+6] & mask);\n+            b[i+7] = (byte)(a[i+7] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VB,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">=8\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.AND_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test2(byte[] a, byte[] b, byte mask) {\n+        for (int i = 0; i < RANGE; i+=8) {\n+            \/\/ Cannot align with AlignVector: 3 + x * 8 % 8 = 3\n+            b[i+3] = (byte)(a[i+3] & mask); \/\/ at alignment 3\n+            b[i+4] = (byte)(a[i+4] & mask);\n+            b[i+5] = (byte)(a[i+5] & mask);\n+            b[i+6] = (byte)(a[i+6] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VB,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">=8\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.AND_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test3(byte[] a, byte[] b, byte mask) {\n+        for (int i = 0; i < RANGE; i+=8) {\n+            \/\/ Cannot align with AlignVector: 3 + x * 8 % 8 = 3\n+\n+            \/\/ Problematic for AlignVector\n+            b[i+0] = (byte)(a[i+0] & mask); \/\/ best_memref, align 0\n+\n+            b[i+3] = (byte)(a[i+3] & mask); \/\/ pack at offset 3 bytes\n+            b[i+4] = (byte)(a[i+4] & mask);\n+            b[i+5] = (byte)(a[i+5] & mask);\n+            b[i+6] = (byte)(a[i+6] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_8, \"> 0\",\n+                  IRNode.AND_VB,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VB,        IRNode.VECTOR_SIZE_8, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">=16\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_8, \"= 0\",\/\/ unaligned\n+                  IRNode.AND_VB,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VB,        IRNode.VECTOR_SIZE_8, \"= 0\",\/\/ unaligned\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">=16\"})\n+    static Object[] test4(byte[] a, byte[] b, byte mask) {\n+        for (int i = 0; i < RANGE\/16; i++) {\n+            \/\/ Problematic for AlignVector\n+            b[i*16 + 0 ] = (byte)(a[i*16 + 0 ] & mask); \/\/ 4 pack, 0 aligned\n+            b[i*16 + 1 ] = (byte)(a[i*16 + 1 ] & mask);\n+            b[i*16 + 2 ] = (byte)(a[i*16 + 2 ] & mask);\n+            b[i*16 + 3 ] = (byte)(a[i*16 + 3 ] & mask);\n+\n+            b[i*16 + 5 ] = (byte)(a[i*16 + 5 ] & mask); \/\/ 8 pack, 5 aligned\n+            b[i*16 + 6 ] = (byte)(a[i*16 + 6 ] & mask);\n+            b[i*16 + 7 ] = (byte)(a[i*16 + 7 ] & mask);\n+            b[i*16 + 8 ] = (byte)(a[i*16 + 8 ] & mask);\n+            b[i*16 + 9 ] = (byte)(a[i*16 + 9 ] & mask);\n+            b[i*16 + 10] = (byte)(a[i*16 + 10] & mask);\n+            b[i*16 + 11] = (byte)(a[i*16 + 11] & mask);\n+            b[i*16 + 12] = (byte)(a[i*16 + 12] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VB,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">=8\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.AND_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test5(byte[] a, byte[] b, byte mask, int inv) {\n+        for (int i = 0; i < RANGE; i+=8) {\n+            \/\/ Cannot align with AlignVector because of invariant\n+            b[i+inv+0] = (byte)(a[i+inv+0] & mask);\n+\n+            b[i+inv+3] = (byte)(a[i+inv+3] & mask);\n+            b[i+inv+4] = (byte)(a[i+inv+4] & mask);\n+            b[i+inv+5] = (byte)(a[i+inv+5] & mask);\n+            b[i+inv+6] = (byte)(a[i+inv+6] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VB,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">=8\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.AND_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test6(byte[] a, byte[] b, byte mask) {\n+        for (int i = 0; i < RANGE\/8; i+=2) {\n+            \/\/ Cannot align with AlignVector because offset is odd\n+            b[i*4+0] = (byte)(a[i*4+0] & mask);\n+\n+            b[i*4+3] = (byte)(a[i*4+3] & mask);\n+            b[i*4+4] = (byte)(a[i*4+4] & mask);\n+            b[i*4+5] = (byte)(a[i*4+5] & mask);\n+            b[i*4+6] = (byte)(a[i*4+6] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VS,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">=16\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"= 0\",\n+                  IRNode.AND_VS, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test7(short[] a, short[] b, short mask) {\n+        for (int i = 0; i < RANGE\/8; i+=2) {\n+            \/\/ Cannot align with AlignVector because offset is odd\n+            b[i*4+0] = (short)(a[i*4+0] & mask);\n+\n+            b[i*4+3] = (short)(a[i*4+3] & mask);\n+            b[i*4+4] = (short)(a[i*4+4] & mask);\n+            b[i*4+5] = (short)(a[i*4+5] & mask);\n+            b[i*4+6] = (short)(a[i*4+6] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VB,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">=8\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.AND_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test8(byte[] a, byte[] b, byte mask, int init) {\n+        for (int i = init; i < RANGE; i+=8) {\n+            \/\/ Cannot align with AlignVector because of invariant (variable init becomes invar)\n+            b[i+0] = (byte)(a[i+0] & mask);\n+\n+            b[i+3] = (byte)(a[i+3] & mask);\n+            b[i+4] = (byte)(a[i+4] & mask);\n+            b[i+5] = (byte)(a[i+5] & mask);\n+            b[i+6] = (byte)(a[i+6] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VB,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">=8\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test9(byte[] a, byte[] b, byte mask) {\n+        \/\/ known non-zero init value does not affect offset, but has implicit effect on iv\n+        for (int i = 13; i < RANGE-8; i+=8) {\n+            b[i+0] = (byte)(a[i+0] & mask);\n+\n+            b[i+3] = (byte)(a[i+3] & mask);\n+            b[i+4] = (byte)(a[i+4] & mask);\n+            b[i+5] = (byte)(a[i+5] & mask);\n+            b[i+6] = (byte)(a[i+6] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VB,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">=8\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.AND_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test10a(byte[] a, byte[] b, byte mask) {\n+        \/\/ This is not alignable with pre-loop, because of odd init.\n+        for (int i = 3; i < RANGE-8; i+=8) {\n+            b[i+0] = (byte)(a[i+0] & mask);\n+            b[i+1] = (byte)(a[i+1] & mask);\n+            b[i+2] = (byte)(a[i+2] & mask);\n+            b[i+3] = (byte)(a[i+3] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VB,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">=8\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.AND_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test10b(byte[] a, byte[] b, byte mask) {\n+        \/\/ This is not alignable with pre-loop, because of odd init.\n+        \/\/ Seems not correctly handled.\n+        for (int i = 13; i < RANGE-8; i+=8) {\n+            b[i+0] = (byte)(a[i+0] & mask);\n+            b[i+1] = (byte)(a[i+1] & mask);\n+            b[i+2] = (byte)(a[i+2] & mask);\n+            b[i+3] = (byte)(a[i+3] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VS,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">=16\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"= 0\",\n+                  IRNode.AND_VS, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test10c(short[] a, short[] b, short mask) {\n+        \/\/ This is not alignable with pre-loop, because of odd init.\n+        \/\/ Seems not correctly handled with MaxVectorSize >= 32.\n+        for (int i = 13; i < RANGE-8; i+=8) {\n+            b[i+0] = (short)(a[i+0] & mask);\n+            b[i+1] = (short)(a[i+1] & mask);\n+            b[i+2] = (short)(a[i+2] & mask);\n+            b[i+3] = (short)(a[i+3] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VS,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">=16\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test10d(short[] a, short[] b, short mask) {\n+        for (int i = 13; i < RANGE-16; i+=8) {\n+            \/\/ init + offset -> aligned\n+            b[i+0+3] = (short)(a[i+0+3] & mask);\n+            b[i+1+3] = (short)(a[i+1+3] & mask);\n+            b[i+2+3] = (short)(a[i+2+3] & mask);\n+            b[i+3+3] = (short)(a[i+3+3] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.AND_VB, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test11aB(byte[] a, byte[] b, byte mask) {\n+        for (int i = 0; i < RANGE; i++) {\n+            \/\/ always alignable\n+            b[i+0] = (byte)(a[i+0] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.AND_VS, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test11aS(short[] a, short[] b, short mask) {\n+        for (int i = 0; i < RANGE; i++) {\n+            \/\/ always alignable\n+            b[i+0] = (short)(a[i+0] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.AND_VI, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test11aI(int[] a, int[] b, int mask) {\n+        for (int i = 0; i < RANGE; i++) {\n+            \/\/ always alignable\n+            b[i+0] = (int)(a[i+0] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\",\n+                  IRNode.AND_VL, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test11aL(long[] a, long[] b, long mask) {\n+        for (int i = 0; i < RANGE; i++) {\n+            \/\/ always alignable\n+            b[i+0] = (long)(a[i+0] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.AND_VB, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test11bB(byte[] a, byte[] b, byte mask) {\n+        for (int i = 1; i < RANGE; i++) {\n+            \/\/ always alignable\n+            b[i+0] = (byte)(a[i+0] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.AND_VS, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test11bS(short[] a, short[] b, short mask) {\n+        for (int i = 1; i < RANGE; i++) {\n+            \/\/ always alignable\n+            b[i+0] = (short)(a[i+0] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.AND_VI, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test11bI(int[] a, int[] b, int mask) {\n+        for (int i = 1; i < RANGE; i++) {\n+            \/\/ always alignable\n+            b[i+0] = (int)(a[i+0] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\",\n+                  IRNode.AND_VL, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test11bL(long[] a, long[] b, long mask) {\n+        for (int i = 1; i < RANGE; i++) {\n+            \/\/ always alignable\n+            b[i+0] = (long)(a[i+0] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.AND_VB, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.AND_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test11cB(byte[] a, byte[] b, byte mask) {\n+        for (int i = 1; i < RANGE-1; i++) {\n+            \/\/ 1 byte offset -> not alignable with AlignVector\n+            b[i+0] = (byte)(a[i+1] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.AND_VS, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"= 0\",\n+                  IRNode.AND_VS, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test11cS(short[] a, short[] b, short mask) {\n+        for (int i = 1; i < RANGE-1; i++) {\n+            \/\/ 2 byte offset -> not alignable with AlignVector\n+            b[i+0] = (short)(a[i+1] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.AND_VI, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+                  IRNode.AND_VI, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test11cI(int[] a, int[] b, int mask) {\n+        for (int i = 1; i < RANGE-1; i++) {\n+            \/\/ 4 byte offset -> not alignable with AlignVector\n+            b[i+0] = (int)(a[i+1] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\",\n+                  IRNode.AND_VL, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test11cL(long[] a, long[] b, long mask) {\n+        for (int i = 1; i < RANGE-1; i++) {\n+            \/\/ always alignable (8 byte offset)\n+            b[i+0] = (long)(a[i+1] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.AND_VB, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test11dB(byte[] a, byte[] b, byte mask, int invar) {\n+        for (int i = 0; i < RANGE; i++) {\n+            b[i+0+invar] = (byte)(a[i+0+invar] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.AND_VS, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test11dS(short[] a, short[] b, short mask, int invar) {\n+        for (int i = 0; i < RANGE; i++) {\n+            b[i+0+invar] = (short)(a[i+0+invar] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.AND_VI, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test11dI(int[] a, int[] b, int mask, int invar) {\n+        for (int i = 0; i < RANGE; i++) {\n+            b[i+0+invar] = (int)(a[i+0+invar] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\",\n+                  IRNode.AND_VL, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test11dL(long[] a, long[] b, long mask, int invar) {\n+        for (int i = 0; i < RANGE; i++) {\n+            b[i+0+invar] = (long)(a[i+0+invar] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.AND_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test12(byte[] a, byte[] b, byte mask) {\n+        for (int i = 0; i < RANGE\/16; i++) {\n+            \/\/ Currently does not vectorize at all\n+            b[i*6 + 0 ] = (byte)(a[i*6 + 0 ] & mask);\n+            b[i*6 + 1 ] = (byte)(a[i*6 + 1 ] & mask);\n+            b[i*6 + 2 ] = (byte)(a[i*6 + 2 ] & mask);\n+            b[i*6 + 3 ] = (byte)(a[i*6 + 3 ] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.LOAD_VECTOR_L, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.ADD_VI, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.ADD_VL, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\"})\n+    \/\/ require avx to ensure vectors are larger than what unrolling produces\n+    static Object[] test13aIL(int[] a, long[] b) {\n+        for (int i = 0; i < RANGE; i++) {\n+            a[i]++;\n+            b[i]++;\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.ADD_VB, \"> 0\",\n+                  IRNode.ADD_VI, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test13aIB(int[] a, byte[] b) {\n+        for (int i = 0; i < RANGE; i++) {\n+            a[i]++;\n+            b[i]++;\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.ADD_VI, \"> 0\",\n+                  IRNode.ADD_VS, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test13aIS(int[] a, short[] b) {\n+        for (int i = 0; i < RANGE; i++) {\n+            a[i]++;\n+            b[i]++;\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.LOAD_VECTOR_L, \"> 0\",\n+                  IRNode.ADD_VB, \"> 0\",\n+                  IRNode.ADD_VS, \"> 0\",\n+                  IRNode.ADD_VI, \"> 0\",\n+                  IRNode.ADD_VL, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test13aBSIL(byte[] a, short[] b, int[] c, long[] d) {\n+        for (int i = 0; i < RANGE; i++) {\n+            a[i]++;\n+            b[i]++;\n+            c[i]++;\n+            d[i]++;\n+        }\n+        return new Object[]{ a, b, c, d };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.LOAD_VECTOR_L, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.ADD_VI, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.ADD_VL, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\"})\n+    \/\/ require avx to ensure vectors are larger than what unrolling produces\n+    static Object[] test13bIL(int[] a, long[] b) {\n+        for (int i = 1; i < RANGE; i++) {\n+            a[i]++;\n+            b[i]++;\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.ADD_VB, \"> 0\",\n+                  IRNode.ADD_VI, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test13bIB(int[] a, byte[] b) {\n+        for (int i = 1; i < RANGE; i++) {\n+            a[i]++;\n+            b[i]++;\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.ADD_VI, \"> 0\",\n+                  IRNode.ADD_VS, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test13bIS(int[] a, short[] b) {\n+        for (int i = 1; i < RANGE; i++) {\n+            a[i]++;\n+            b[i]++;\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.LOAD_VECTOR_L, \"> 0\",\n+                  IRNode.ADD_VB, \"> 0\",\n+                  IRNode.ADD_VS, \"> 0\",\n+                  IRNode.ADD_VI, \"> 0\",\n+                  IRNode.ADD_VL, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test13bBSIL(byte[] a, short[] b, int[] c, long[] d) {\n+        for (int i = 1; i < RANGE; i++) {\n+            a[i]++;\n+            b[i]++;\n+            c[i]++;\n+            d[i]++;\n+        }\n+        return new Object[]{ a, b, c, d };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.ADD_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test14aB(byte[] a) {\n+        \/\/ non-power-of-2 stride\n+        for (int i = 0; i < RANGE-20; i+=9) {\n+            a[i+0]++;\n+            a[i+1]++;\n+            a[i+2]++;\n+            a[i+3]++;\n+            a[i+4]++;\n+            a[i+5]++;\n+            a[i+6]++;\n+            a[i+7]++;\n+            a[i+8]++;\n+            a[i+9]++;\n+            a[i+10]++;\n+            a[i+11]++;\n+            a[i+12]++;\n+            a[i+13]++;\n+            a[i+14]++;\n+            a[i+15]++;\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.ADD_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test14bB(byte[] a) {\n+        \/\/ non-power-of-2 stride\n+        for (int i = 0; i < RANGE-20; i+=3) {\n+            a[i+0]++;\n+            a[i+1]++;\n+            a[i+2]++;\n+            a[i+3]++;\n+            a[i+4]++;\n+            a[i+5]++;\n+            a[i+6]++;\n+            a[i+7]++;\n+            a[i+8]++;\n+            a[i+9]++;\n+            a[i+10]++;\n+            a[i+11]++;\n+            a[i+12]++;\n+            a[i+13]++;\n+            a[i+14]++;\n+            a[i+15]++;\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.ADD_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test14cB(byte[] a) {\n+        \/\/ non-power-of-2 stride\n+        for (int i = 0; i < RANGE-20; i+=5) {\n+            a[i+0]++;\n+            a[i+1]++;\n+            a[i+2]++;\n+            a[i+3]++;\n+            a[i+4]++;\n+            a[i+5]++;\n+            a[i+6]++;\n+            a[i+7]++;\n+            a[i+8]++;\n+            a[i+9]++;\n+            a[i+10]++;\n+            a[i+11]++;\n+            a[i+12]++;\n+            a[i+13]++;\n+            a[i+14]++;\n+            a[i+15]++;\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    \/\/ IR rules difficult because of modulo wrapping with offset after peeling.\n+    static Object[] test15aB(byte[] a) {\n+        \/\/ non-power-of-2 scale\n+        for (int i = 0; i < RANGE\/64-20; i++) {\n+            a[53*i+0]++;\n+            a[53*i+1]++;\n+            a[53*i+2]++;\n+            a[53*i+3]++;\n+            a[53*i+4]++;\n+            a[53*i+5]++;\n+            a[53*i+6]++;\n+            a[53*i+7]++;\n+            a[53*i+8]++;\n+            a[53*i+9]++;\n+            a[53*i+10]++;\n+            a[53*i+11]++;\n+            a[53*i+12]++;\n+            a[53*i+13]++;\n+            a[53*i+14]++;\n+            a[53*i+15]++;\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    \/\/ IR rules difficult because of modulo wrapping with offset after peeling.\n+    static Object[] test15bB(byte[] a) {\n+        \/\/ non-power-of-2 scale\n+        for (int i = 0; i < RANGE\/64-20; i++) {\n+            a[25*i+0]++;\n+            a[25*i+1]++;\n+            a[25*i+2]++;\n+            a[25*i+3]++;\n+            a[25*i+4]++;\n+            a[25*i+5]++;\n+            a[25*i+6]++;\n+            a[25*i+7]++;\n+            a[25*i+8]++;\n+            a[25*i+9]++;\n+            a[25*i+10]++;\n+            a[25*i+11]++;\n+            a[25*i+12]++;\n+            a[25*i+13]++;\n+            a[25*i+14]++;\n+            a[25*i+15]++;\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    \/\/ IR rules difficult because of modulo wrapping with offset after peeling.\n+    static Object[] test15cB(byte[] a) {\n+        \/\/ non-power-of-2 scale\n+        for (int i = 0; i < RANGE\/64-20; i++) {\n+            a[19*i+0]++;\n+            a[19*i+1]++;\n+            a[19*i+2]++;\n+            a[19*i+3]++;\n+            a[19*i+4]++;\n+            a[19*i+5]++;\n+            a[19*i+6]++;\n+            a[19*i+7]++;\n+            a[19*i+8]++;\n+            a[19*i+9]++;\n+            a[19*i+10]++;\n+            a[19*i+11]++;\n+            a[19*i+12]++;\n+            a[19*i+13]++;\n+            a[19*i+14]++;\n+            a[19*i+15]++;\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    static Object[] test16a(byte[] a, short[] b) {\n+        \/\/ infinite loop issues\n+        for (int i = 0; i < RANGE\/2-20; i++) {\n+            a[2*i+0]++;\n+            a[2*i+1]++;\n+            a[2*i+2]++;\n+            a[2*i+3]++;\n+            a[2*i+4]++;\n+            a[2*i+5]++;\n+            a[2*i+6]++;\n+            a[2*i+7]++;\n+            a[2*i+8]++;\n+            a[2*i+9]++;\n+            a[2*i+10]++;\n+            a[2*i+11]++;\n+            a[2*i+12]++;\n+            a[2*i+13]++;\n+            a[2*i+14]++;\n+\n+            b[2*i+0]++;\n+            b[2*i+1]++;\n+            b[2*i+2]++;\n+            b[2*i+3]++;\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    static Object[] test16b(byte[] a) {\n+        \/\/ infinite loop issues\n+        for (int i = 0; i < RANGE\/2-20; i++) {\n+            a[2*i+0]++;\n+            a[2*i+1]++;\n+            a[2*i+2]++;\n+            a[2*i+3]++;\n+            a[2*i+4]++;\n+            a[2*i+5]++;\n+            a[2*i+6]++;\n+            a[2*i+7]++;\n+            a[2*i+8]++;\n+            a[2*i+9]++;\n+            a[2*i+10]++;\n+            a[2*i+11]++;\n+            a[2*i+12]++;\n+            a[2*i+13]++;\n+            a[2*i+14]++;\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\",\n+                  IRNode.ADD_VL, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test17a(long[] a) {\n+        \/\/ Unsafe: vectorizes with profiling (not xcomp)\n+        for (int i = 0; i < RANGE; i++) {\n+            int adr = UNSAFE.ARRAY_LONG_BASE_OFFSET + 8 * i;\n+            long v = UNSAFE.getLongUnaligned(a, adr);\n+            UNSAFE.putLongUnaligned(a, adr, v + 1);\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    \/\/ Difficult to write good IR rule. Modulo calculus overflow can create non-power-of-2 packs.\n+    static Object[] test17b(long[] a) {\n+        \/\/ Not alignable\n+        for (int i = 0; i < RANGE-1; i++) {\n+            int adr = UNSAFE.ARRAY_LONG_BASE_OFFSET + 8 * i + 1;\n+            long v = UNSAFE.getLongUnaligned(a, adr);\n+            UNSAFE.putLongUnaligned(a, adr, v + 1);\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.ADD_VL,        IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test17c(long[] a) {\n+        \/\/ Unsafe: aligned vectorizes\n+        for (int i = 0; i < RANGE-1; i+=4) {\n+            int adr = UNSAFE.ARRAY_LONG_BASE_OFFSET + 8 * i;\n+            long v0 = UNSAFE.getLongUnaligned(a, adr + 0);\n+            long v1 = UNSAFE.getLongUnaligned(a, adr + 8);\n+            UNSAFE.putLongUnaligned(a, adr + 0, v0 + 1);\n+            UNSAFE.putLongUnaligned(a, adr + 8, v1 + 1);\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.ADD_VL,        IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"avx512\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">=64\"})\n+    \/\/ Ensure vector width is large enough to fit 64 byte for longs:\n+    \/\/ The offsets are: 25, 33, 57, 65\n+    \/\/ In modulo 32:    25,  1, 25,  1  -> does not vectorize\n+    \/\/ In modulo 64:    25, 33, 57,  1  -> at least first pair vectorizes\n+    \/\/ This problem is because we compute modulo vector width in memory_alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"= 0\",\n+                  IRNode.ADD_VL, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test17d(long[] a) {\n+        \/\/ Not alignable\n+        for (int i = 0; i < RANGE-1; i+=4) {\n+            int adr = UNSAFE.ARRAY_LONG_BASE_OFFSET + 8 * i + 1;\n+            long v0 = UNSAFE.getLongUnaligned(a, adr + 0);\n+            long v1 = UNSAFE.getLongUnaligned(a, adr + 8);\n+            UNSAFE.putLongUnaligned(a, adr + 0, v0 + 1);\n+            UNSAFE.putLongUnaligned(a, adr + 8, v1 + 1);\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    static Object[] test18a(byte[] a, int[] b) {\n+        \/\/ scale = 0  -->  no iv\n+        for (int i = 0; i < RANGE; i++) {\n+            a[0] = 1;\n+            b[i] = 2;\n+            a[1] = 1;\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    static Object[] test18b(byte[] a, int[] b) {\n+        \/\/ scale = 0  -->  no iv\n+        for (int i = 0; i < RANGE; i++) {\n+            a[1] = 1;\n+            b[i] = 2;\n+            a[2] = 1;\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    static Object[] test19(int[] a, int[] b) {\n+        for (int i = 5000; i > 0; i--) {\n+            a[RANGE_FINAL - i] = b[RANGE_FINAL - i];\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    static Object[] test20(byte[] a) {\n+        \/\/ Example where it is easy to pass alignment check,\n+        \/\/ but used to fail the alignment calculation\n+        for (int i = 1; i < RANGE\/2-50; i++) {\n+            a[2*i+0+30]++;\n+            a[2*i+1+30]++;\n+            a[2*i+2+30]++;\n+            a[2*i+3+30]++;\n+        }\n+        return new Object[]{ a };\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAlignVector.java","additions":1479,"deletions":0,"binary":false,"changes":1479,"status":"added"},{"patch":"@@ -0,0 +1,1353 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=Vanilla\n+ * @bug 8253191\n+ * @summary Fuzzing loops with different (random) init, limit, stride, scale etc. Do not force alignment.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @requires vm.compiler2.enabled\n+ * @key randomness\n+ * @run main\/bootclasspath\/othervm -XX:+IgnoreUnrecognizedVMOptions\n+ *                                 -XX:LoopUnrollLimit=250\n+ *                                 -XX:CompileCommand=printcompilation,compiler.loopopts.superword.TestAlignVectorFuzzer::*\n+ *                                 compiler.loopopts.superword.TestAlignVectorFuzzer\n+ *\/\n+\n+\/*\n+ * @test id=VerifyAlignVector\n+ * @bug 8253191\n+ * @summary Fuzzing loops with different (random) init, limit, stride, scale etc. Verify AlignVector.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @requires vm.compiler2.enabled\n+ * @key randomness\n+ * @run main\/bootclasspath\/othervm -XX:+IgnoreUnrecognizedVMOptions\n+ *                                 -XX:+AlignVector -XX:+VerifyAlignVector\n+ *                                 -XX:LoopUnrollLimit=250\n+ *                                 -XX:CompileCommand=printcompilation,compiler.loopopts.superword.TestAlignVectorFuzzer::*\n+ *                                 compiler.loopopts.superword.TestAlignVectorFuzzer\n+ *\/\n+\n+\/*\n+ * @test id=VerifyAlignVector-Align16\n+ * @bug 8253191\n+ * @summary Fuzzing loops with different (random) init, limit, stride, scale etc. Verify AlignVector.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @requires vm.compiler2.enabled\n+ * @requires vm.bits == 64\n+ * @key randomness\n+ * @run main\/bootclasspath\/othervm -XX:+IgnoreUnrecognizedVMOptions\n+ *                                 -XX:+AlignVector -XX:+VerifyAlignVector\n+ *                                 -XX:LoopUnrollLimit=250\n+ *                                 -XX:CompileCommand=printcompilation,compiler.loopopts.superword.TestAlignVectorFuzzer::*\n+ *                                 -XX:ObjectAlignmentInBytes=16\n+ *                                 compiler.loopopts.superword.TestAlignVectorFuzzer\n+ *\/\n+\n+\/*\n+ * @test id=VerifyAlignVector-NoTieredCompilation-Xbatch\n+ * @bug 8253191\n+ * @summary Fuzzing loops with different (random) init, limit, stride, scale etc. Verify AlignVector.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @requires vm.compiler2.enabled\n+ * @key randomness\n+ * @run main\/bootclasspath\/othervm -XX:+IgnoreUnrecognizedVMOptions\n+ *                                 -XX:+AlignVector -XX:+VerifyAlignVector\n+ *                                 -XX:LoopUnrollLimit=250\n+ *                                 -XX:CompileCommand=printcompilation,compiler.loopopts.superword.TestAlignVectorFuzzer::*\n+ *                                 -XX:-TieredCompilation -Xbatch\n+ *                                 compiler.loopopts.superword.TestAlignVectorFuzzer\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import java.lang.reflect.Array;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.lang.invoke.*;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+import jdk.internal.misc.Unsafe;\n+\n+public class TestAlignVectorFuzzer {\n+    static final int ITERATIONS_MAX = 5; \/\/ time allowance may lead to fewer iterations\n+    static final int RANGE_CON = 1024 * 8;\n+    static int ZERO = 0;\n+\n+    private static final Random random = Utils.getRandomInstance();\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    interface TestFunction {\n+        Object[] run();\n+    }\n+\n+    \/\/ Setup for variable compile-time constants:\n+    private static final CallSite INIT_CS    = new MutableCallSite(MethodType.methodType(int.class));\n+    private static final CallSite LIMIT_CS   = new MutableCallSite(MethodType.methodType(int.class));\n+    private static final CallSite STRIDE_CS  = new MutableCallSite(MethodType.methodType(int.class));\n+    private static final CallSite SCALE_CS   = new MutableCallSite(MethodType.methodType(int.class));\n+    private static final CallSite OFFSET1_CS = new MutableCallSite(MethodType.methodType(int.class));\n+    private static final CallSite OFFSET2_CS = new MutableCallSite(MethodType.methodType(int.class));\n+    private static final CallSite OFFSET3_CS = new MutableCallSite(MethodType.methodType(int.class));\n+    private static final MethodHandle INIT_MH    = INIT_CS.dynamicInvoker();\n+    private static final MethodHandle LIMIT_MH   = LIMIT_CS.dynamicInvoker();\n+    private static final MethodHandle STRIDE_MH  = STRIDE_CS.dynamicInvoker();\n+    private static final MethodHandle SCALE_MH   = SCALE_CS.dynamicInvoker();\n+    private static final MethodHandle OFFSET1_MH = OFFSET1_CS.dynamicInvoker();\n+    private static final MethodHandle OFFSET2_MH = OFFSET2_CS.dynamicInvoker();\n+    private static final MethodHandle OFFSET3_MH = OFFSET3_CS.dynamicInvoker();\n+\n+    \/\/ Toggle if init, limit and offset are constants or variables\n+    private static final CallSite INIT_IS_CON_CS   = new MutableCallSite(MethodType.methodType(boolean.class));\n+    private static final CallSite LIMIT_IS_CON_CS  = new MutableCallSite(MethodType.methodType(boolean.class));\n+    private static final CallSite OFFSET1_IS_CON_CS = new MutableCallSite(MethodType.methodType(boolean.class));\n+    private static final CallSite OFFSET2_IS_CON_CS = new MutableCallSite(MethodType.methodType(boolean.class));\n+    private static final CallSite OFFSET3_IS_CON_CS = new MutableCallSite(MethodType.methodType(boolean.class));\n+    private static final MethodHandle INIT_IS_CON_MH    = INIT_IS_CON_CS.dynamicInvoker();\n+    private static final MethodHandle LIMIT_IS_CON_MH   = LIMIT_IS_CON_CS.dynamicInvoker();\n+    private static final MethodHandle OFFSET1_IS_CON_MH = OFFSET1_IS_CON_CS.dynamicInvoker();\n+    private static final MethodHandle OFFSET2_IS_CON_MH = OFFSET2_IS_CON_CS.dynamicInvoker();\n+    private static final MethodHandle OFFSET3_IS_CON_MH = OFFSET3_IS_CON_CS.dynamicInvoker();\n+\n+    \/\/ Hand-Unrolling compile-constants\n+    private static final CallSite HAND_UNROLLING1_CS = new MutableCallSite(MethodType.methodType(int.class));\n+    private static final CallSite HAND_UNROLLING2_CS = new MutableCallSite(MethodType.methodType(int.class));\n+    private static final CallSite HAND_UNROLLING3_CS = new MutableCallSite(MethodType.methodType(int.class));\n+    private static final MethodHandle HAND_UNROLLING1_MH = HAND_UNROLLING1_CS.dynamicInvoker();\n+    private static final MethodHandle HAND_UNROLLING2_MH = HAND_UNROLLING2_CS.dynamicInvoker();\n+    private static final MethodHandle HAND_UNROLLING3_MH = HAND_UNROLLING3_CS.dynamicInvoker();\n+\n+    static void setConstant(CallSite cs, int value) {\n+        MethodHandle constant = MethodHandles.constant(int.class, value);\n+        cs.setTarget(constant);\n+    }\n+\n+    static void setConstant(CallSite cs, boolean value) {\n+        MethodHandle constant = MethodHandles.constant(boolean.class, value);\n+        cs.setTarget(constant);\n+    }\n+\n+    static int init_con() { \/\/ compile-time constant\n+        try {\n+            return (int) INIT_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static boolean init_is_con() { \/\/ compile-time constant\n+        try {\n+            return (boolean) INIT_IS_CON_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static int init_con_or_var() {\n+        int init = init_con();\n+        if (!init_is_con()) { \/\/ branch constant folds to true or false\n+            init += ZERO; \/\/ LoadI\n+        }\n+        return init;\n+    }\n+\n+    static int limit_con() { \/\/ compile-time constant\n+        try {\n+            return (int) LIMIT_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static boolean limit_is_con() { \/\/ compile-time constant\n+        try {\n+            return (boolean) LIMIT_IS_CON_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static int limit_con_or_var() {\n+        int limit = limit_con();\n+        if (!limit_is_con()) { \/\/ branch constant folds to true or false\n+            limit -= ZERO; \/\/ LoadI\n+        }\n+        return limit;\n+    }\n+\n+    static int stride_con() { \/\/ compile-time constant\n+        try {\n+            return (int) STRIDE_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static int scale_con() { \/\/ compile-time constant\n+        try {\n+            return (int) SCALE_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static int offset1_con() { \/\/ compile-time constant\n+        try {\n+            return (int) OFFSET1_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static int offset2_con() { \/\/ compile-time constant\n+        try {\n+            return (int) OFFSET2_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static int offset3_con() { \/\/ compile-time constant\n+        try {\n+            return (int) OFFSET3_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static boolean offset1_is_con() { \/\/ compile-time constant\n+        try {\n+            return (boolean) OFFSET1_IS_CON_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static boolean offset2_is_con() { \/\/ compile-time constant\n+        try {\n+            return (boolean) OFFSET2_IS_CON_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static boolean offset3_is_con() { \/\/ compile-time constant\n+        try {\n+            return (boolean) OFFSET3_IS_CON_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static int offset1_con_or_var() {\n+        int offset = offset1_con();\n+        if (!offset1_is_con()) { \/\/ branch constant folds to true or false\n+            offset += ZERO; \/\/ LoadI\n+        }\n+        return offset;\n+    }\n+\n+    static int offset2_con_or_var() {\n+        int offset = offset2_con();\n+        if (!offset2_is_con()) { \/\/ branch constant folds to true or false\n+            offset += ZERO; \/\/ LoadI\n+        }\n+        return offset;\n+    }\n+\n+    static int offset3_con_or_var() {\n+        int offset = offset3_con();\n+        if (!offset3_is_con()) { \/\/ branch constant folds to true or false\n+            offset += ZERO; \/\/ LoadI\n+        }\n+        return offset;\n+    }\n+\n+    static int opposite_direction_offset1_con_or_var() {\n+        \/\/ When indexing in the opposite direction to i, we Want to have:\n+        \/\/\n+        \/\/   a[x - i * scale]\n+        \/\/\n+        \/\/ So we want to fulfill these constraints:\n+        \/\/\n+        \/\/   x - init * scale  = offset + limit * scale\n+        \/\/   x - limit * scale = offset + init * scale\n+        \/\/\n+        \/\/ Hence:\n+        \/\/\n+        \/\/   x = offset + limit * scale + init * scale;\n+\n+        int offset = offset1_con_or_var();\n+        int init = init_con();\n+        int limit = limit_con();\n+        int scale = scale_con();\n+        return offset + limit * scale + init * scale;\n+    }\n+\n+    static int opposite_direction_offset2_con_or_var() {\n+        int offset = offset2_con_or_var();\n+        int init = init_con();\n+        int limit = limit_con();\n+        int scale = scale_con();\n+        return offset + limit * scale + init * scale;\n+    }\n+\n+    static int opposite_direction_offset3_con_or_var() {\n+        int offset = offset3_con_or_var();\n+        int init = init_con();\n+        int limit = limit_con();\n+        int scale = scale_con();\n+        return offset + limit * scale + init * scale;\n+    }\n+\n+    static int hand_unrolling1_con() { \/\/ compile-time constant\n+        try {\n+            return (int) HAND_UNROLLING1_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static int hand_unrolling2_con() { \/\/ compile-time constant\n+        try {\n+            return (int) HAND_UNROLLING2_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static int hand_unrolling3_con() { \/\/ compile-time constant\n+        try {\n+            return (int) HAND_UNROLLING3_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static int randomStride() {\n+        return switch (random.nextInt(6)) {\n+            case 0       -> random.nextInt(64) + 1; \/\/ [1..64]\n+            case 1, 2, 3 -> 1;\n+            default      -> 1 << random.nextInt(7); \/\/ powers of 2: 1..64\n+        };\n+    }\n+\n+    static int randomScale() {\n+        return switch (random.nextInt(6)) {\n+            case 0       -> random.nextInt(64) + 1; \/\/ [1..64]\n+            case 1, 2, 3 -> 1;\n+            default      -> 1 << random.nextInt(7); \/\/ powers of 2: 1..64\n+        };\n+    }\n+\n+    static int randomOffsetDiff() {\n+        return switch (random.nextInt(6)) {\n+            case 0       -> random.nextInt(256) + 128;\n+            case 1, 2, 3 -> 0;\n+            case 4       -> +(1 << random.nextInt(8)); \/\/ powers of 2: 1..128\n+            default      -> -(1 << random.nextInt(8)); \/\/ powers of 2: -1..-128\n+        };\n+    }\n+\n+    static int randomHandUnrolling() {\n+        return switch (random.nextInt(2)) {\n+            case 0       -> random.nextInt(16) + 1; \/\/ [1..16]\n+            default      -> 1 << random.nextInt(5); \/\/ powers of 2: 1..16\n+        };\n+    }\n+\n+    static void setRandomConstants() {\n+        \/\/ We want to create random constants for a loop, but they should never go out of bounds.\n+        \/\/ We constrain i to be in the range [init..limit], with init < limit. For simplicity, we\n+        \/\/ always generate:\n+        \/\/\n+        \/\/   1 <= scale  <= 64\n+        \/\/   1 <= stride <= 64\n+        \/\/\n+        \/\/ We work with this reference memory access:\n+        \/\/\n+        \/\/   a[offset + i * scale]\n+        \/\/\n+        \/\/ It is up to the test function to re-arrange the the given terms to iterate upward or\n+        \/\/ downward, to hand-unroll etc.\n+        \/\/\n+        \/\/ We must ensure that the first and last indices are in range:\n+        \/\/\n+        \/\/   0 + error <= offset + init * scale\n+        \/\/   offset + limit * scale < range - error\n+        \/\/\n+        \/\/ The \"error\" term is there such that the test functions have the freedom to slightly\n+        \/\/ diverge from the reference memory access pattern (for example modify the offset).\n+        \/\/\n+        \/\/ The values for scale and range are already fixed. We now want to generate values for\n+        \/\/ offset, init and limit.\n+        \/\/\n+        \/\/ (1) Fix offset:\n+        \/\/\n+        \/\/     init >= (error - offset) \/ scale\n+        \/\/     limit < (range - error - offset) \/ scale\n+        \/\/\n+        \/\/ (2) Fix init:\n+        \/\/\n+        \/\/     offset >= error - init * scale\n+        \/\/     limit < (range - error - offset) \/ scale\n+        \/\/\n+        \/\/ (3) Fix limit:\n+        \/\/\n+        \/\/     offset < range - error - limit * scale\n+        \/\/     init >= (error - offset) \/ scale\n+        \/\/\n+        \/\/ We can still slightly perturb the results in the direction permitted by the inequality.\n+\n+        int stride = randomStride();\n+        int scale = randomScale();\n+        int range = RANGE_CON;\n+        int error = 1024; \/\/ generous\n+        int init;\n+        int limit;\n+        int offset1;\n+        switch(random.nextInt(3)) {\n+            case 0 -> {\n+                offset1 = random.nextInt(2_000_000) - 1_000_000;\n+                init = (error - offset1) \/ scale + random.nextInt(64);\n+                limit = (range - error - offset1) \/ scale - random.nextInt(64);\n+            }\n+            case 1 -> {\n+                init = random.nextInt(2_000_000) - 1_000_000;\n+                offset1 = error - init * scale + random.nextInt(64);\n+                limit = (range - error - offset1) \/ scale - random.nextInt(64);\n+            }\n+            default -> {\n+                limit = random.nextInt(2_000_000) - 1_000_000;\n+                offset1 = range - error - limit * scale - random.nextInt(64);\n+                init = (error - offset1) \/ scale + random.nextInt(64);\n+            }\n+        }\n+\n+        int offset2 = offset1 + randomOffsetDiff();\n+        int offset3 = offset1 + randomOffsetDiff();\n+\n+        \/\/ We can toggle the init, limit and offset to either be constant or variable:\n+        boolean init_is_con   = random.nextInt(3) != 0;\n+        boolean limit_is_con  = random.nextInt(3) != 0;\n+        boolean offset1_is_con = random.nextInt(3) != 0;\n+        boolean offset2_is_con = random.nextInt(3) != 0;\n+        boolean offset3_is_con = random.nextInt(3) != 0;\n+\n+        int hand_unrolling1 = randomHandUnrolling();\n+        int hand_unrolling2 = randomHandUnrolling();\n+        int hand_unrolling3 = randomHandUnrolling();\n+\n+\/\/      Overwrite the fuzzed values below to reproduce a specific failure:\n+\/\/\n+\/\/        init = 1;\n+\/\/        limit = init + 3000;\n+\/\/        offset1 = 0;\n+\/\/        offset2 = 0;\n+\/\/        offset3 = 32 - 2*init;\n+\/\/        stride =  1;\n+\/\/        scale =   2;\n+\/\/        hand_unrolling1 = 0;\n+\/\/        hand_unrolling2 = 0;\n+\/\/        hand_unrolling3 = 4;\n+\/\/\n+\/\/        init_is_con    = true;\n+\/\/        limit_is_con   = true;\n+\/\/        offset1_is_con = true;\n+\/\/        offset2_is_con = true;\n+\/\/        offset3_is_con = true;\n+\n+        System.out.println(\"  init:    \" + init    + \" (con: \" + init_is_con + \")\");\n+        System.out.println(\"  limit:   \" + limit   + \" (con: \" + limit_is_con + \")\");\n+        System.out.println(\"  offset1: \" + offset1 + \" (con: \" + offset1_is_con + \")\");\n+        System.out.println(\"  offset2: \" + offset2 + \" (con: \" + offset2_is_con + \")\");\n+        System.out.println(\"  offset3: \" + offset3 + \" (con: \" + offset3_is_con + \")\");\n+        System.out.println(\"  stride:  \" + stride);\n+        System.out.println(\"  scale:   \" + scale);\n+        System.out.println(\"  hand_unrolling1: \" + hand_unrolling1);\n+        System.out.println(\"  hand_unrolling2: \" + hand_unrolling2);\n+        System.out.println(\"  hand_unrolling3: \" + hand_unrolling3);\n+        setConstant(INIT_CS,   init);\n+        setConstant(LIMIT_CS,  limit);\n+        setConstant(STRIDE_CS, stride);\n+        setConstant(SCALE_CS,  scale);\n+        setConstant(OFFSET1_CS, offset1);\n+        setConstant(OFFSET2_CS, offset2);\n+        setConstant(OFFSET3_CS, offset3);\n+        setConstant(INIT_IS_CON_CS,   init_is_con);\n+        setConstant(LIMIT_IS_CON_CS,  limit_is_con);\n+        setConstant(OFFSET1_IS_CON_CS, offset1_is_con);\n+        setConstant(OFFSET2_IS_CON_CS, offset2_is_con);\n+        setConstant(OFFSET3_IS_CON_CS, offset3_is_con);\n+        setConstant(HAND_UNROLLING1_CS, hand_unrolling1);\n+        setConstant(HAND_UNROLLING2_CS, hand_unrolling2);\n+        setConstant(HAND_UNROLLING3_CS, hand_unrolling3);\n+    }\n+\n+    public static void main(String[] args) {\n+        byte[] aB = generateB();\n+        byte[] bB = generateB();\n+        byte[] cB = generateB();\n+        short[] aS = generateS();\n+        short[] bS = generateS();\n+        short[] cS = generateS();\n+        char[] aC = generateC();\n+        char[] bC = generateC();\n+        char[] cC = generateC();\n+        int[] aI = generateI();\n+        int[] bI = generateI();\n+        int[] cI = generateI();\n+        long[] aL = generateL();\n+        long[] bL = generateL();\n+        long[] cL = generateL();\n+        float[] aF = generateF();\n+        float[] bF = generateF();\n+        float[] cF = generateF();\n+        double[] aD = generateD();\n+        double[] bD = generateD();\n+        double[] cD = generateD();\n+\n+        \/\/ Add all tests to list\n+        Map<String,TestFunction> tests = new HashMap<String,TestFunction>();\n+        tests.put(\"testUUB\", () -> { return testUUB(aB.clone()); });\n+        tests.put(\"testDDB\", () -> { return testDDB(aB.clone()); });\n+        tests.put(\"testUDB\", () -> { return testUDB(aB.clone()); });\n+        tests.put(\"testDUB\", () -> { return testDUB(aB.clone()); });\n+\n+        tests.put(\"testUUBH\", () -> { return testUUBH(aB.clone()); });\n+\n+        tests.put(\"testUUBBB\", () -> { return testUUBBB(aB.clone(), bB.clone(), cB.clone()); });\n+        tests.put(\"testUUBSI\", () -> { return testUUBSI(aB.clone(), bS.clone(), cI.clone()); });\n+\n+        tests.put(\"testUUBBBH\", () -> { return testUUBBBH(aB.clone(), bB.clone(), cB.clone()); });\n+\n+        tests.put(\"testUUBCFH\", () -> { return testUUBCFH(aB.clone(), bC.clone(), cF.clone()); });\n+        tests.put(\"testDDBCFH\", () -> { return testDDBCFH(aB.clone(), bC.clone(), cF.clone()); });\n+        tests.put(\"testUDBCFH\", () -> { return testUDBCFH(aB.clone(), bC.clone(), cF.clone()); });\n+        tests.put(\"testDUBCFH\", () -> { return testDUBCFH(aB.clone(), bC.clone(), cF.clone()); });\n+\n+        tests.put(\"testMMSFD\", () -> { return testMMSFD(aS.clone(), bF.clone(), cD.clone()); });\n+\n+        tests.put(\"testUU_unsafe_BasI\", () -> { return testUU_unsafe_BasI(aB.clone()); });\n+        tests.put(\"testUU_unsafe_BasIH\", () -> { return testUU_unsafe_BasIH(aB.clone(), bB.clone(), cB.clone()); });\n+\n+\n+        \/\/ Only run for 90% of the time, and subtract some margin. This ensures the shutdown has sufficient time,\n+        \/\/ even for very slow runs.\n+        long test_time_allowance = System.currentTimeMillis() +\n+                                   (long)(Utils.adjustTimeout(Utils.DEFAULT_TEST_TIMEOUT) * 0.9) -\n+                                   20_000;\n+        long test_hard_timeout = System.currentTimeMillis() +\n+                                Utils.adjustTimeout(Utils.DEFAULT_TEST_TIMEOUT);\n+\n+        for (int i = 1; i <= ITERATIONS_MAX; i++) {\n+            setRandomConstants();\n+            for (Map.Entry<String,TestFunction> entry : tests.entrySet()) {\n+                String name = entry.getKey();\n+                TestFunction test = entry.getValue();\n+                long allowance = test_time_allowance - System.currentTimeMillis();\n+                long until_timeout = test_hard_timeout - System.currentTimeMillis();\n+                System.out.println(\"ITERATION \" + i + \" of \" + ITERATIONS_MAX + \". Test \" + name +\n+                                   \", time allowance: \" + allowance + \", until timeout: \" + until_timeout);\n+\n+                \/\/ Compute gold value, probably deopt first if constants have changed.\n+                Object[] gold = test.run();\n+\n+                \/\/ Have enough iterations to (re)compile\n+                for (int j = 0; j < 10_000; j++) {\n+                    Object[] result = test.run();\n+                    verify(name, gold, result);\n+                }\n+\n+                if (System.currentTimeMillis() > test_time_allowance) {\n+                    allowance = test_time_allowance - System.currentTimeMillis();\n+                    until_timeout = test_hard_timeout - System.currentTimeMillis();\n+                    System.out.println(\"TEST PASSED: hit maximal time allownance during iteration \" + i +\n+                                       \", time allowance: \" + allowance + \", until timeout: \" + until_timeout);\n+                    return;\n+                }\n+            }\n+        }\n+        long allowance = test_time_allowance - System.currentTimeMillis();\n+        long until_timeout = test_hard_timeout - System.currentTimeMillis();\n+        System.out.println(\"TEST PASSED, time allowance: \" + allowance + \", until timeout: \" + until_timeout);\n+    }\n+\n+    \/\/ Test names:\n+    \/\/ test\n+    \/\/ {U: i goes up, D: i goes down, M: mixed}\n+    \/\/ {U: indexing goes up, D: indexing goes down, M: mixed}\n+    \/\/ BSCILFD (types used)\n+\n+    \/\/ -------------------- BASIC SINGLE --------------------\n+\n+    static Object[] testUUB(byte[] a) {\n+        int init   = init_con_or_var();\n+        int limit  = limit_con_or_var();\n+        int stride = stride_con();\n+        int scale  = scale_con();\n+        int offset = offset1_con_or_var();\n+\n+        for (int i = init; i < limit; i += stride) {\n+            a[offset + i * scale]++;\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    static Object[] testDDB(byte[] a) {\n+        int init   = init_con_or_var();\n+        int limit  = limit_con_or_var();\n+        int stride = stride_con();\n+        int scale  = scale_con();\n+        int offset = offset1_con_or_var();\n+\n+        for (int i = limit; i > init; i -= stride) {\n+            a[offset + i * scale]++;\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    static Object[] testUDB(byte[] a) {\n+        int init   = init_con_or_var();\n+        int limit  = limit_con_or_var();\n+        int stride = stride_con();\n+        int scale  = scale_con();\n+        int x = opposite_direction_offset1_con_or_var();\n+\n+        for (int i = init; i < limit; i += stride) {\n+           a[x - i * scale]++;\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    static Object[] testDUB(byte[] a) {\n+        int init   = init_con_or_var();\n+        int limit  = limit_con_or_var();\n+        int stride = stride_con();\n+        int scale  = scale_con();\n+        int x = opposite_direction_offset1_con_or_var();\n+\n+        for (int i = limit; i > init; i -= stride) {\n+           a[x - i * scale]++;\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    \/\/ -------------------- BASIC HAND UNROLL --------------------\n+\n+    static Object[] testUUBH(byte[] a) {\n+        int init   = init_con_or_var();\n+        int limit  = limit_con_or_var();\n+        int stride = stride_con();\n+        int scale  = scale_con();\n+        int offset = offset1_con_or_var();\n+\n+        \/\/ All if statements with constant h fold to true or false\n+        int h = hand_unrolling1_con();\n+\n+        for (int i = init; i < limit; i += stride) {\n+            if (h >=  1) { a[offset + i * scale +  0]++; }\n+            if (h >=  2) { a[offset + i * scale +  1]++; }\n+            if (h >=  3) { a[offset + i * scale +  2]++; }\n+            if (h >=  4) { a[offset + i * scale +  3]++; }\n+            if (h >=  5) { a[offset + i * scale +  4]++; }\n+            if (h >=  6) { a[offset + i * scale +  5]++; }\n+            if (h >=  7) { a[offset + i * scale +  6]++; }\n+            if (h >=  8) { a[offset + i * scale +  7]++; }\n+            if (h >=  9) { a[offset + i * scale +  8]++; }\n+            if (h >= 10) { a[offset + i * scale +  9]++; }\n+            if (h >= 11) { a[offset + i * scale + 10]++; }\n+            if (h >= 12) { a[offset + i * scale + 11]++; }\n+            if (h >= 13) { a[offset + i * scale + 12]++; }\n+            if (h >= 14) { a[offset + i * scale + 13]++; }\n+            if (h >= 15) { a[offset + i * scale + 14]++; }\n+            if (h >= 16) { a[offset + i * scale + 15]++; }\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    \/\/ -------------------- BASIC TRIPPLE --------------------\n+\n+    static Object[] testUUBBB(byte[] a, byte[] b, byte[] c) {\n+        int init    = init_con_or_var();\n+        int limit   = limit_con_or_var();\n+        int stride  = stride_con();\n+        int scale   = scale_con();\n+        int offset1 = offset1_con_or_var();\n+        int offset2 = offset2_con_or_var();\n+        int offset3 = offset3_con_or_var();\n+\n+        for (int i = init; i < limit; i += stride) {\n+            a[offset1 + i * scale]++;\n+            b[offset2 + i * scale]++;\n+            c[offset3 + i * scale]++;\n+        }\n+        return new Object[]{ a, b, c };\n+    }\n+\n+    static Object[] testUUBSI(byte[] a, short[] b, int[] c) {\n+        int init    = init_con_or_var();\n+        int limit   = limit_con_or_var();\n+        int stride  = stride_con();\n+        int scale   = scale_con();\n+        int offset1 = offset1_con_or_var();\n+        int offset2 = offset2_con_or_var();\n+        int offset3 = offset3_con_or_var();\n+\n+        for (int i = init; i < limit; i += stride) {\n+            a[offset1 + i * scale]++;\n+            b[offset2 + i * scale]++;\n+            c[offset3 + i * scale]++;\n+        }\n+        return new Object[]{ a, b, c };\n+    }\n+\n+    \/\/ -------------------- HAND UNROLL TRIPPLE --------------------\n+\n+    static Object[] testUUBBBH(byte[] a, byte[] b, byte[] c) {\n+        int init   = init_con_or_var();\n+        int limit  = limit_con_or_var();\n+        int stride = stride_con();\n+        int scale  = scale_con();\n+        int offset1 = offset1_con_or_var();\n+        int offset2 = offset2_con_or_var();\n+        int offset3 = offset3_con_or_var();\n+\n+        int h1 = hand_unrolling1_con();\n+        int h2 = hand_unrolling2_con();\n+        int h3 = hand_unrolling3_con();\n+\n+        for (int i = init; i < limit; i += stride) {\n+            if (h1 >=  1) { a[offset1 + i * scale +  0]++; }\n+            if (h1 >=  2) { a[offset1 + i * scale +  1]++; }\n+            if (h1 >=  3) { a[offset1 + i * scale +  2]++; }\n+            if (h1 >=  4) { a[offset1 + i * scale +  3]++; }\n+            if (h1 >=  5) { a[offset1 + i * scale +  4]++; }\n+            if (h1 >=  6) { a[offset1 + i * scale +  5]++; }\n+            if (h1 >=  7) { a[offset1 + i * scale +  6]++; }\n+            if (h1 >=  8) { a[offset1 + i * scale +  7]++; }\n+            if (h1 >=  9) { a[offset1 + i * scale +  8]++; }\n+            if (h1 >= 10) { a[offset1 + i * scale +  9]++; }\n+            if (h1 >= 11) { a[offset1 + i * scale + 10]++; }\n+            if (h1 >= 12) { a[offset1 + i * scale + 11]++; }\n+            if (h1 >= 13) { a[offset1 + i * scale + 12]++; }\n+            if (h1 >= 14) { a[offset1 + i * scale + 13]++; }\n+            if (h1 >= 15) { a[offset1 + i * scale + 14]++; }\n+            if (h1 >= 16) { a[offset1 + i * scale + 15]++; }\n+\n+            if (h2 >=  1) { b[offset2 + i * scale +  0]++; }\n+            if (h2 >=  2) { b[offset2 + i * scale +  1]++; }\n+            if (h2 >=  3) { b[offset2 + i * scale +  2]++; }\n+            if (h2 >=  4) { b[offset2 + i * scale +  3]++; }\n+            if (h2 >=  5) { b[offset2 + i * scale +  4]++; }\n+            if (h2 >=  6) { b[offset2 + i * scale +  5]++; }\n+            if (h2 >=  7) { b[offset2 + i * scale +  6]++; }\n+            if (h2 >=  8) { b[offset2 + i * scale +  7]++; }\n+            if (h2 >=  9) { b[offset2 + i * scale +  8]++; }\n+            if (h2 >= 10) { b[offset2 + i * scale +  9]++; }\n+            if (h2 >= 11) { b[offset2 + i * scale + 10]++; }\n+            if (h2 >= 12) { b[offset2 + i * scale + 11]++; }\n+            if (h2 >= 13) { b[offset2 + i * scale + 12]++; }\n+            if (h2 >= 14) { b[offset2 + i * scale + 13]++; }\n+            if (h2 >= 15) { b[offset2 + i * scale + 14]++; }\n+            if (h2 >= 16) { b[offset2 + i * scale + 15]++; }\n+\n+            if (h3 >=  1) { c[offset3 + i * scale +  0]++; }\n+            if (h3 >=  2) { c[offset3 + i * scale +  1]++; }\n+            if (h3 >=  3) { c[offset3 + i * scale +  2]++; }\n+            if (h3 >=  4) { c[offset3 + i * scale +  3]++; }\n+            if (h3 >=  5) { c[offset3 + i * scale +  4]++; }\n+            if (h3 >=  6) { c[offset3 + i * scale +  5]++; }\n+            if (h3 >=  7) { c[offset3 + i * scale +  6]++; }\n+            if (h3 >=  8) { c[offset3 + i * scale +  7]++; }\n+            if (h3 >=  9) { c[offset3 + i * scale +  8]++; }\n+            if (h3 >= 10) { c[offset3 + i * scale +  9]++; }\n+            if (h3 >= 11) { c[offset3 + i * scale + 10]++; }\n+            if (h3 >= 12) { c[offset3 + i * scale + 11]++; }\n+            if (h3 >= 13) { c[offset3 + i * scale + 12]++; }\n+            if (h3 >= 14) { c[offset3 + i * scale + 13]++; }\n+            if (h3 >= 15) { c[offset3 + i * scale + 14]++; }\n+            if (h3 >= 16) { c[offset3 + i * scale + 15]++; }\n+        }\n+        return new Object[]{ a, b, c };\n+    }\n+\n+    static Object[] testUUBCFH(byte[] a, char[] b, float[] c) {\n+        int init   = init_con_or_var();\n+        int limit  = limit_con_or_var();\n+        int stride = stride_con();\n+        int scale  = scale_con();\n+        int offset1 = offset1_con_or_var();\n+        int offset2 = offset2_con_or_var();\n+        int offset3 = offset3_con_or_var();\n+\n+        int h1 = hand_unrolling1_con();\n+        int h2 = hand_unrolling2_con();\n+        int h3 = hand_unrolling3_con();\n+\n+        for (int i = init; i < limit; i += stride) {\n+            if (h1 >=  1) { a[offset1 + i * scale +  0]++; }\n+            if (h1 >=  2) { a[offset1 + i * scale +  1]++; }\n+            if (h1 >=  3) { a[offset1 + i * scale +  2]++; }\n+            if (h1 >=  4) { a[offset1 + i * scale +  3]++; }\n+            if (h1 >=  5) { a[offset1 + i * scale +  4]++; }\n+            if (h1 >=  6) { a[offset1 + i * scale +  5]++; }\n+            if (h1 >=  7) { a[offset1 + i * scale +  6]++; }\n+            if (h1 >=  8) { a[offset1 + i * scale +  7]++; }\n+            if (h1 >=  9) { a[offset1 + i * scale +  8]++; }\n+            if (h1 >= 10) { a[offset1 + i * scale +  9]++; }\n+            if (h1 >= 11) { a[offset1 + i * scale + 10]++; }\n+            if (h1 >= 12) { a[offset1 + i * scale + 11]++; }\n+            if (h1 >= 13) { a[offset1 + i * scale + 12]++; }\n+            if (h1 >= 14) { a[offset1 + i * scale + 13]++; }\n+            if (h1 >= 15) { a[offset1 + i * scale + 14]++; }\n+            if (h1 >= 16) { a[offset1 + i * scale + 15]++; }\n+\n+            if (h2 >=  1) { b[offset2 + i * scale +  0]++; }\n+            if (h2 >=  2) { b[offset2 + i * scale +  1]++; }\n+            if (h2 >=  3) { b[offset2 + i * scale +  2]++; }\n+            if (h2 >=  4) { b[offset2 + i * scale +  3]++; }\n+            if (h2 >=  5) { b[offset2 + i * scale +  4]++; }\n+            if (h2 >=  6) { b[offset2 + i * scale +  5]++; }\n+            if (h2 >=  7) { b[offset2 + i * scale +  6]++; }\n+            if (h2 >=  8) { b[offset2 + i * scale +  7]++; }\n+            if (h2 >=  9) { b[offset2 + i * scale +  8]++; }\n+            if (h2 >= 10) { b[offset2 + i * scale +  9]++; }\n+            if (h2 >= 11) { b[offset2 + i * scale + 10]++; }\n+            if (h2 >= 12) { b[offset2 + i * scale + 11]++; }\n+            if (h2 >= 13) { b[offset2 + i * scale + 12]++; }\n+            if (h2 >= 14) { b[offset2 + i * scale + 13]++; }\n+            if (h2 >= 15) { b[offset2 + i * scale + 14]++; }\n+            if (h2 >= 16) { b[offset2 + i * scale + 15]++; }\n+\n+            if (h3 >=  1) { c[offset3 + i * scale +  0]++; }\n+            if (h3 >=  2) { c[offset3 + i * scale +  1]++; }\n+            if (h3 >=  3) { c[offset3 + i * scale +  2]++; }\n+            if (h3 >=  4) { c[offset3 + i * scale +  3]++; }\n+            if (h3 >=  5) { c[offset3 + i * scale +  4]++; }\n+            if (h3 >=  6) { c[offset3 + i * scale +  5]++; }\n+            if (h3 >=  7) { c[offset3 + i * scale +  6]++; }\n+            if (h3 >=  8) { c[offset3 + i * scale +  7]++; }\n+            if (h3 >=  9) { c[offset3 + i * scale +  8]++; }\n+            if (h3 >= 10) { c[offset3 + i * scale +  9]++; }\n+            if (h3 >= 11) { c[offset3 + i * scale + 10]++; }\n+            if (h3 >= 12) { c[offset3 + i * scale + 11]++; }\n+            if (h3 >= 13) { c[offset3 + i * scale + 12]++; }\n+            if (h3 >= 14) { c[offset3 + i * scale + 13]++; }\n+            if (h3 >= 15) { c[offset3 + i * scale + 14]++; }\n+            if (h3 >= 16) { c[offset3 + i * scale + 15]++; }\n+        }\n+        return new Object[]{ a, b, c };\n+    }\n+\n+    static Object[] testDDBCFH(byte[] a, char[] b, float[] c) {\n+        int init   = init_con_or_var();\n+        int limit  = limit_con_or_var();\n+        int stride = stride_con();\n+        int scale  = scale_con();\n+        int offset1 = offset1_con_or_var();\n+        int offset2 = offset2_con_or_var();\n+        int offset3 = offset3_con_or_var();\n+\n+        int h1 = hand_unrolling1_con();\n+        int h2 = hand_unrolling2_con();\n+        int h3 = hand_unrolling3_con();\n+\n+        for (int i = limit; i > init; i -= stride) {\n+            if (h1 >=  1) { a[offset1 + i * scale +  0]++; }\n+            if (h1 >=  2) { a[offset1 + i * scale +  1]++; }\n+            if (h1 >=  3) { a[offset1 + i * scale +  2]++; }\n+            if (h1 >=  4) { a[offset1 + i * scale +  3]++; }\n+            if (h1 >=  5) { a[offset1 + i * scale +  4]++; }\n+            if (h1 >=  6) { a[offset1 + i * scale +  5]++; }\n+            if (h1 >=  7) { a[offset1 + i * scale +  6]++; }\n+            if (h1 >=  8) { a[offset1 + i * scale +  7]++; }\n+            if (h1 >=  9) { a[offset1 + i * scale +  8]++; }\n+            if (h1 >= 10) { a[offset1 + i * scale +  9]++; }\n+            if (h1 >= 11) { a[offset1 + i * scale + 10]++; }\n+            if (h1 >= 12) { a[offset1 + i * scale + 11]++; }\n+            if (h1 >= 13) { a[offset1 + i * scale + 12]++; }\n+            if (h1 >= 14) { a[offset1 + i * scale + 13]++; }\n+            if (h1 >= 15) { a[offset1 + i * scale + 14]++; }\n+            if (h1 >= 16) { a[offset1 + i * scale + 15]++; }\n+\n+            if (h2 >=  1) { b[offset2 + i * scale +  0]++; }\n+            if (h2 >=  2) { b[offset2 + i * scale +  1]++; }\n+            if (h2 >=  3) { b[offset2 + i * scale +  2]++; }\n+            if (h2 >=  4) { b[offset2 + i * scale +  3]++; }\n+            if (h2 >=  5) { b[offset2 + i * scale +  4]++; }\n+            if (h2 >=  6) { b[offset2 + i * scale +  5]++; }\n+            if (h2 >=  7) { b[offset2 + i * scale +  6]++; }\n+            if (h2 >=  8) { b[offset2 + i * scale +  7]++; }\n+            if (h2 >=  9) { b[offset2 + i * scale +  8]++; }\n+            if (h2 >= 10) { b[offset2 + i * scale +  9]++; }\n+            if (h2 >= 11) { b[offset2 + i * scale + 10]++; }\n+            if (h2 >= 12) { b[offset2 + i * scale + 11]++; }\n+            if (h2 >= 13) { b[offset2 + i * scale + 12]++; }\n+            if (h2 >= 14) { b[offset2 + i * scale + 13]++; }\n+            if (h2 >= 15) { b[offset2 + i * scale + 14]++; }\n+            if (h2 >= 16) { b[offset2 + i * scale + 15]++; }\n+\n+            if (h3 >=  1) { c[offset3 + i * scale +  0]++; }\n+            if (h3 >=  2) { c[offset3 + i * scale +  1]++; }\n+            if (h3 >=  3) { c[offset3 + i * scale +  2]++; }\n+            if (h3 >=  4) { c[offset3 + i * scale +  3]++; }\n+            if (h3 >=  5) { c[offset3 + i * scale +  4]++; }\n+            if (h3 >=  6) { c[offset3 + i * scale +  5]++; }\n+            if (h3 >=  7) { c[offset3 + i * scale +  6]++; }\n+            if (h3 >=  8) { c[offset3 + i * scale +  7]++; }\n+            if (h3 >=  9) { c[offset3 + i * scale +  8]++; }\n+            if (h3 >= 10) { c[offset3 + i * scale +  9]++; }\n+            if (h3 >= 11) { c[offset3 + i * scale + 10]++; }\n+            if (h3 >= 12) { c[offset3 + i * scale + 11]++; }\n+            if (h3 >= 13) { c[offset3 + i * scale + 12]++; }\n+            if (h3 >= 14) { c[offset3 + i * scale + 13]++; }\n+            if (h3 >= 15) { c[offset3 + i * scale + 14]++; }\n+            if (h3 >= 16) { c[offset3 + i * scale + 15]++; }\n+        }\n+        return new Object[]{ a, b, c };\n+    }\n+\n+    static Object[] testUDBCFH(byte[] a, char[] b, float[] c) {\n+        int init   = init_con_or_var();\n+        int limit  = limit_con_or_var();\n+        int stride = stride_con();\n+        int scale  = scale_con();\n+        int x1 = opposite_direction_offset1_con_or_var();\n+        int x2 = opposite_direction_offset2_con_or_var();\n+        int x3 = opposite_direction_offset3_con_or_var();\n+\n+        int h1 = hand_unrolling1_con();\n+        int h2 = hand_unrolling2_con();\n+        int h3 = hand_unrolling3_con();\n+\n+        for (int i = init; i < limit; i += stride) {\n+            if (h1 >=  1) { a[x1 - i * scale +  0]++; }\n+            if (h1 >=  2) { a[x1 - i * scale +  1]++; }\n+            if (h1 >=  3) { a[x1 - i * scale +  2]++; }\n+            if (h1 >=  4) { a[x1 - i * scale +  3]++; }\n+            if (h1 >=  5) { a[x1 - i * scale +  4]++; }\n+            if (h1 >=  6) { a[x1 - i * scale +  5]++; }\n+            if (h1 >=  7) { a[x1 - i * scale +  6]++; }\n+            if (h1 >=  8) { a[x1 - i * scale +  7]++; }\n+            if (h1 >=  9) { a[x1 - i * scale +  8]++; }\n+            if (h1 >= 10) { a[x1 - i * scale +  9]++; }\n+            if (h1 >= 11) { a[x1 - i * scale + 10]++; }\n+            if (h1 >= 12) { a[x1 - i * scale + 11]++; }\n+            if (h1 >= 13) { a[x1 - i * scale + 12]++; }\n+            if (h1 >= 14) { a[x1 - i * scale + 13]++; }\n+            if (h1 >= 15) { a[x1 - i * scale + 14]++; }\n+            if (h1 >= 16) { a[x1 - i * scale + 15]++; }\n+\n+            if (h2 >=  1) { b[x2 - i * scale +  0]++; }\n+            if (h2 >=  2) { b[x2 - i * scale +  1]++; }\n+            if (h2 >=  3) { b[x2 - i * scale +  2]++; }\n+            if (h2 >=  4) { b[x2 - i * scale +  3]++; }\n+            if (h2 >=  5) { b[x2 - i * scale +  4]++; }\n+            if (h2 >=  6) { b[x2 - i * scale +  5]++; }\n+            if (h2 >=  7) { b[x2 - i * scale +  6]++; }\n+            if (h2 >=  8) { b[x2 - i * scale +  7]++; }\n+            if (h2 >=  9) { b[x2 - i * scale +  8]++; }\n+            if (h2 >= 10) { b[x2 - i * scale +  9]++; }\n+            if (h2 >= 11) { b[x2 - i * scale + 10]++; }\n+            if (h2 >= 12) { b[x2 - i * scale + 11]++; }\n+            if (h2 >= 13) { b[x2 - i * scale + 12]++; }\n+            if (h2 >= 14) { b[x2 - i * scale + 13]++; }\n+            if (h2 >= 15) { b[x2 - i * scale + 14]++; }\n+            if (h2 >= 16) { b[x2 - i * scale + 15]++; }\n+\n+            if (h3 >=  1) { c[x3 - i * scale +  0]++; }\n+            if (h3 >=  2) { c[x3 - i * scale +  1]++; }\n+            if (h3 >=  3) { c[x3 - i * scale +  2]++; }\n+            if (h3 >=  4) { c[x3 - i * scale +  3]++; }\n+            if (h3 >=  5) { c[x3 - i * scale +  4]++; }\n+            if (h3 >=  6) { c[x3 - i * scale +  5]++; }\n+            if (h3 >=  7) { c[x3 - i * scale +  6]++; }\n+            if (h3 >=  8) { c[x3 - i * scale +  7]++; }\n+            if (h3 >=  9) { c[x3 - i * scale +  8]++; }\n+            if (h3 >= 10) { c[x3 - i * scale +  9]++; }\n+            if (h3 >= 11) { c[x3 - i * scale + 10]++; }\n+            if (h3 >= 12) { c[x3 - i * scale + 11]++; }\n+            if (h3 >= 13) { c[x3 - i * scale + 12]++; }\n+            if (h3 >= 14) { c[x3 - i * scale + 13]++; }\n+            if (h3 >= 15) { c[x3 - i * scale + 14]++; }\n+            if (h3 >= 16) { c[x3 - i * scale + 15]++; }\n+        }\n+        return new Object[]{ a, b, c };\n+    }\n+\n+    static Object[] testDUBCFH(byte[] a, char[] b, float[] c) {\n+        int init   = init_con_or_var();\n+        int limit  = limit_con_or_var();\n+        int stride = stride_con();\n+        int scale  = scale_con();\n+        int x1 = opposite_direction_offset1_con_or_var();\n+        int x2 = opposite_direction_offset2_con_or_var();\n+        int x3 = opposite_direction_offset3_con_or_var();\n+\n+        int h1 = hand_unrolling1_con();\n+        int h2 = hand_unrolling2_con();\n+        int h3 = hand_unrolling3_con();\n+\n+        for (int i = limit; i > init; i -= stride) {\n+            if (h1 >=  1) { a[x1 - i * scale +  0]++; }\n+            if (h1 >=  2) { a[x1 - i * scale +  1]++; }\n+            if (h1 >=  3) { a[x1 - i * scale +  2]++; }\n+            if (h1 >=  4) { a[x1 - i * scale +  3]++; }\n+            if (h1 >=  5) { a[x1 - i * scale +  4]++; }\n+            if (h1 >=  6) { a[x1 - i * scale +  5]++; }\n+            if (h1 >=  7) { a[x1 - i * scale +  6]++; }\n+            if (h1 >=  8) { a[x1 - i * scale +  7]++; }\n+            if (h1 >=  9) { a[x1 - i * scale +  8]++; }\n+            if (h1 >= 10) { a[x1 - i * scale +  9]++; }\n+            if (h1 >= 11) { a[x1 - i * scale + 10]++; }\n+            if (h1 >= 12) { a[x1 - i * scale + 11]++; }\n+            if (h1 >= 13) { a[x1 - i * scale + 12]++; }\n+            if (h1 >= 14) { a[x1 - i * scale + 13]++; }\n+            if (h1 >= 15) { a[x1 - i * scale + 14]++; }\n+            if (h1 >= 16) { a[x1 - i * scale + 15]++; }\n+\n+            if (h2 >=  1) { b[x2 - i * scale +  0]++; }\n+            if (h2 >=  2) { b[x2 - i * scale +  1]++; }\n+            if (h2 >=  3) { b[x2 - i * scale +  2]++; }\n+            if (h2 >=  4) { b[x2 - i * scale +  3]++; }\n+            if (h2 >=  5) { b[x2 - i * scale +  4]++; }\n+            if (h2 >=  6) { b[x2 - i * scale +  5]++; }\n+            if (h2 >=  7) { b[x2 - i * scale +  6]++; }\n+            if (h2 >=  8) { b[x2 - i * scale +  7]++; }\n+            if (h2 >=  9) { b[x2 - i * scale +  8]++; }\n+            if (h2 >= 10) { b[x2 - i * scale +  9]++; }\n+            if (h2 >= 11) { b[x2 - i * scale + 10]++; }\n+            if (h2 >= 12) { b[x2 - i * scale + 11]++; }\n+            if (h2 >= 13) { b[x2 - i * scale + 12]++; }\n+            if (h2 >= 14) { b[x2 - i * scale + 13]++; }\n+            if (h2 >= 15) { b[x2 - i * scale + 14]++; }\n+            if (h2 >= 16) { b[x2 - i * scale + 15]++; }\n+\n+            if (h3 >=  1) { c[x3 - i * scale +  0]++; }\n+            if (h3 >=  2) { c[x3 - i * scale +  1]++; }\n+            if (h3 >=  3) { c[x3 - i * scale +  2]++; }\n+            if (h3 >=  4) { c[x3 - i * scale +  3]++; }\n+            if (h3 >=  5) { c[x3 - i * scale +  4]++; }\n+            if (h3 >=  6) { c[x3 - i * scale +  5]++; }\n+            if (h3 >=  7) { c[x3 - i * scale +  6]++; }\n+            if (h3 >=  8) { c[x3 - i * scale +  7]++; }\n+            if (h3 >=  9) { c[x3 - i * scale +  8]++; }\n+            if (h3 >= 10) { c[x3 - i * scale +  9]++; }\n+            if (h3 >= 11) { c[x3 - i * scale + 10]++; }\n+            if (h3 >= 12) { c[x3 - i * scale + 11]++; }\n+            if (h3 >= 13) { c[x3 - i * scale + 12]++; }\n+            if (h3 >= 14) { c[x3 - i * scale + 13]++; }\n+            if (h3 >= 15) { c[x3 - i * scale + 14]++; }\n+            if (h3 >= 16) { c[x3 - i * scale + 15]++; }\n+        }\n+        return new Object[]{ a, b, c };\n+    }\n+\n+    \/\/ -------------------- MIXED DIRECTION TRIPPLE --------------------\n+\n+    static Object[] testMMSFD(short[] a, float[] b, double[] c) {\n+        int init    = init_con_or_var();\n+        int limit   = limit_con_or_var();\n+        int stride  = stride_con();\n+        int scale   = scale_con();\n+        int offset1 = offset1_con_or_var();\n+        int offset2 = opposite_direction_offset2_con_or_var();\n+        int offset3 = offset3_con_or_var();\n+\n+        for (int i = init; i < limit; i += stride) {\n+            a[offset1 + i * scale]++;\n+            b[offset2 - i * scale]++;\n+            c[offset3 + i * scale]++;\n+        }\n+        return new Object[]{ a, b, c };\n+    }\n+\n+    \/\/ -------------------- UNSAFE --------------------\n+\n+    static Object[] testUU_unsafe_BasI(byte[] a) {\n+        int init   = init_con_or_var();\n+        int limit  = limit_con_or_var();\n+        int stride = stride_con();\n+        int scale  = scale_con();\n+        int offset = offset1_con_or_var();\n+\n+        for (int i = init; i < limit; i += stride) {\n+            int adr = UNSAFE.ARRAY_BYTE_BASE_OFFSET + offset + i * scale;\n+            int v = UNSAFE.getIntUnaligned(a, adr);\n+            UNSAFE.putIntUnaligned(a, adr, v + 1);\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    static Object[] testUU_unsafe_BasIH(byte[] a, byte[] b, byte[] c) {\n+        int init   = init_con_or_var();\n+        int limit  = limit_con_or_var();\n+        int stride = stride_con();\n+        int scale  = scale_con();\n+        int offset1 = offset1_con_or_var();\n+        int offset2 = offset2_con_or_var();\n+        int offset3 = offset3_con_or_var();\n+\n+        int h1 = hand_unrolling1_con();\n+        int h2 = hand_unrolling2_con();\n+        int h3 = hand_unrolling3_con();\n+\n+        for (int i = init; i < limit; i += stride) {\n+            int adr1 = UNSAFE.ARRAY_BYTE_BASE_OFFSET + offset1 + i * scale;\n+            int adr2 = UNSAFE.ARRAY_BYTE_BASE_OFFSET + offset2 + i * scale;\n+            int adr3 = UNSAFE.ARRAY_BYTE_BASE_OFFSET + offset3 + i * scale;\n+\n+            if (h1 >=  1) { UNSAFE.putIntUnaligned(a, adr1 +  0*4, UNSAFE.getIntUnaligned(a, adr1 +  0*4) + 1); }\n+            if (h1 >=  2) { UNSAFE.putIntUnaligned(a, adr1 +  1*4, UNSAFE.getIntUnaligned(a, adr1 +  1*4) + 1); }\n+            if (h1 >=  3) { UNSAFE.putIntUnaligned(a, adr1 +  2*4, UNSAFE.getIntUnaligned(a, adr1 +  2*4) + 1); }\n+            if (h1 >=  4) { UNSAFE.putIntUnaligned(a, adr1 +  3*4, UNSAFE.getIntUnaligned(a, adr1 +  3*4) + 1); }\n+            if (h1 >=  5) { UNSAFE.putIntUnaligned(a, adr1 +  4*4, UNSAFE.getIntUnaligned(a, adr1 +  4*4) + 1); }\n+            if (h1 >=  6) { UNSAFE.putIntUnaligned(a, adr1 +  5*4, UNSAFE.getIntUnaligned(a, adr1 +  5*4) + 1); }\n+            if (h1 >=  7) { UNSAFE.putIntUnaligned(a, adr1 +  6*4, UNSAFE.getIntUnaligned(a, adr1 +  6*4) + 1); }\n+            if (h1 >=  8) { UNSAFE.putIntUnaligned(a, adr1 +  7*4, UNSAFE.getIntUnaligned(a, adr1 +  7*4) + 1); }\n+            if (h1 >=  9) { UNSAFE.putIntUnaligned(a, adr1 +  8*4, UNSAFE.getIntUnaligned(a, adr1 +  8*4) + 1); }\n+            if (h1 >= 10) { UNSAFE.putIntUnaligned(a, adr1 +  9*4, UNSAFE.getIntUnaligned(a, adr1 +  9*4) + 1); }\n+            if (h1 >= 11) { UNSAFE.putIntUnaligned(a, adr1 + 10*4, UNSAFE.getIntUnaligned(a, adr1 + 10*4) + 1); }\n+            if (h1 >= 12) { UNSAFE.putIntUnaligned(a, adr1 + 11*4, UNSAFE.getIntUnaligned(a, adr1 + 11*4) + 1); }\n+            if (h1 >= 13) { UNSAFE.putIntUnaligned(a, adr1 + 12*4, UNSAFE.getIntUnaligned(a, adr1 + 12*4) + 1); }\n+            if (h1 >= 14) { UNSAFE.putIntUnaligned(a, adr1 + 13*4, UNSAFE.getIntUnaligned(a, adr1 + 13*4) + 1); }\n+            if (h1 >= 15) { UNSAFE.putIntUnaligned(a, adr1 + 14*4, UNSAFE.getIntUnaligned(a, adr1 + 14*4) + 1); }\n+            if (h1 >= 16) { UNSAFE.putIntUnaligned(a, adr1 + 15*4, UNSAFE.getIntUnaligned(a, adr1 + 15*4) + 1); }\n+\n+            if (h2 >=  1) { UNSAFE.putIntUnaligned(b, adr2 +  0*4, UNSAFE.getIntUnaligned(b, adr2 +  0*4) + 1); }\n+            if (h2 >=  2) { UNSAFE.putIntUnaligned(b, adr2 +  1*4, UNSAFE.getIntUnaligned(b, adr2 +  1*4) + 1); }\n+            if (h2 >=  3) { UNSAFE.putIntUnaligned(b, adr2 +  2*4, UNSAFE.getIntUnaligned(b, adr2 +  2*4) + 1); }\n+            if (h2 >=  4) { UNSAFE.putIntUnaligned(b, adr2 +  3*4, UNSAFE.getIntUnaligned(b, adr2 +  3*4) + 1); }\n+            if (h2 >=  5) { UNSAFE.putIntUnaligned(b, adr2 +  4*4, UNSAFE.getIntUnaligned(b, adr2 +  4*4) + 1); }\n+            if (h2 >=  6) { UNSAFE.putIntUnaligned(b, adr2 +  5*4, UNSAFE.getIntUnaligned(b, adr2 +  5*4) + 1); }\n+            if (h2 >=  7) { UNSAFE.putIntUnaligned(b, adr2 +  6*4, UNSAFE.getIntUnaligned(b, adr2 +  6*4) + 1); }\n+            if (h2 >=  8) { UNSAFE.putIntUnaligned(b, adr2 +  7*4, UNSAFE.getIntUnaligned(b, adr2 +  7*4) + 1); }\n+            if (h2 >=  9) { UNSAFE.putIntUnaligned(b, adr2 +  8*4, UNSAFE.getIntUnaligned(b, adr2 +  8*4) + 1); }\n+            if (h2 >= 10) { UNSAFE.putIntUnaligned(b, adr2 +  9*4, UNSAFE.getIntUnaligned(b, adr2 +  9*4) + 1); }\n+            if (h2 >= 11) { UNSAFE.putIntUnaligned(b, adr2 + 10*4, UNSAFE.getIntUnaligned(b, adr2 + 10*4) + 1); }\n+            if (h2 >= 12) { UNSAFE.putIntUnaligned(b, adr2 + 11*4, UNSAFE.getIntUnaligned(b, adr2 + 11*4) + 1); }\n+            if (h2 >= 13) { UNSAFE.putIntUnaligned(b, adr2 + 12*4, UNSAFE.getIntUnaligned(b, adr2 + 12*4) + 1); }\n+            if (h2 >= 14) { UNSAFE.putIntUnaligned(b, adr2 + 13*4, UNSAFE.getIntUnaligned(b, adr2 + 13*4) + 1); }\n+            if (h2 >= 15) { UNSAFE.putIntUnaligned(b, adr2 + 14*4, UNSAFE.getIntUnaligned(b, adr2 + 14*4) + 1); }\n+            if (h2 >= 16) { UNSAFE.putIntUnaligned(b, adr2 + 15*4, UNSAFE.getIntUnaligned(b, adr2 + 15*4) + 1); }\n+\n+            if (h3 >=  1) { UNSAFE.putIntUnaligned(c, adr3 +  0*4, UNSAFE.getIntUnaligned(c, adr3 +  0*4) + 1); }\n+            if (h3 >=  2) { UNSAFE.putIntUnaligned(c, adr3 +  1*4, UNSAFE.getIntUnaligned(c, adr3 +  1*4) + 1); }\n+            if (h3 >=  3) { UNSAFE.putIntUnaligned(c, adr3 +  2*4, UNSAFE.getIntUnaligned(c, adr3 +  2*4) + 1); }\n+            if (h3 >=  4) { UNSAFE.putIntUnaligned(c, adr3 +  3*4, UNSAFE.getIntUnaligned(c, adr3 +  3*4) + 1); }\n+            if (h3 >=  5) { UNSAFE.putIntUnaligned(c, adr3 +  4*4, UNSAFE.getIntUnaligned(c, adr3 +  4*4) + 1); }\n+            if (h3 >=  6) { UNSAFE.putIntUnaligned(c, adr3 +  5*4, UNSAFE.getIntUnaligned(c, adr3 +  5*4) + 1); }\n+            if (h3 >=  7) { UNSAFE.putIntUnaligned(c, adr3 +  6*4, UNSAFE.getIntUnaligned(c, adr3 +  6*4) + 1); }\n+            if (h3 >=  8) { UNSAFE.putIntUnaligned(c, adr3 +  7*4, UNSAFE.getIntUnaligned(c, adr3 +  7*4) + 1); }\n+            if (h3 >=  9) { UNSAFE.putIntUnaligned(c, adr3 +  8*4, UNSAFE.getIntUnaligned(c, adr3 +  8*4) + 1); }\n+            if (h3 >= 10) { UNSAFE.putIntUnaligned(c, adr3 +  9*4, UNSAFE.getIntUnaligned(c, adr3 +  9*4) + 1); }\n+            if (h3 >= 11) { UNSAFE.putIntUnaligned(c, adr3 + 10*4, UNSAFE.getIntUnaligned(c, adr3 + 10*4) + 1); }\n+            if (h3 >= 12) { UNSAFE.putIntUnaligned(c, adr3 + 11*4, UNSAFE.getIntUnaligned(c, adr3 + 11*4) + 1); }\n+            if (h3 >= 13) { UNSAFE.putIntUnaligned(c, adr3 + 12*4, UNSAFE.getIntUnaligned(c, adr3 + 12*4) + 1); }\n+            if (h3 >= 14) { UNSAFE.putIntUnaligned(c, adr3 + 13*4, UNSAFE.getIntUnaligned(c, adr3 + 13*4) + 1); }\n+            if (h3 >= 15) { UNSAFE.putIntUnaligned(c, adr3 + 14*4, UNSAFE.getIntUnaligned(c, adr3 + 14*4) + 1); }\n+            if (h3 >= 16) { UNSAFE.putIntUnaligned(c, adr3 + 15*4, UNSAFE.getIntUnaligned(c, adr3 + 15*4) + 1); }\n+        }\n+        return new Object[]{ a, b, c };\n+    }\n+\n+    static byte[] generateB() {\n+        byte[] a = new byte[RANGE_CON];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = (byte)random.nextInt();\n+        }\n+        return a;\n+    }\n+\n+    static char[] generateC() {\n+        char[] a = new char[RANGE_CON];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = (char)random.nextInt();\n+        }\n+        return a;\n+    }\n+\n+    static short[] generateS() {\n+        short[] a = new short[RANGE_CON];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = (short)random.nextInt();\n+        }\n+        return a;\n+    }\n+\n+    static int[] generateI() {\n+        int[] a = new int[RANGE_CON];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = random.nextInt();\n+        }\n+        return a;\n+    }\n+\n+    static long[] generateL() {\n+        long[] a = new long[RANGE_CON];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = random.nextLong();\n+        }\n+        return a;\n+    }\n+\n+    static float[] generateF() {\n+        float[] a = new float[RANGE_CON];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = Float.intBitsToFloat(random.nextInt());\n+        }\n+        return a;\n+    }\n+\n+    static double[] generateD() {\n+        double[] a = new double[RANGE_CON];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = Double.longBitsToDouble(random.nextLong());\n+        }\n+        return a;\n+    }\n+\n+    static void verify(String name, Object[] gold, Object[] result) {\n+        if (gold.length != result.length) {\n+            throw new RuntimeException(\"verify \" + name + \": not the same number of outputs: gold.length = \" +\n+                                       gold.length + \", result.length = \" + result.length);\n+        }\n+        for (int i = 0; i < gold.length; i++) {\n+            Object g = gold[i];\n+            Object r = result[i];\n+            if (g.getClass() != r.getClass() || !g.getClass().isArray() || !r.getClass().isArray()) {\n+                throw new RuntimeException(\"verify \" + name + \": must both be array of same type:\" +\n+                                           \" gold[\" + i + \"].getClass() = \" + g.getClass().getSimpleName() +\n+                                           \" result[\" + i + \"].getClass() = \" + r.getClass().getSimpleName());\n+            }\n+            if (g == r) {\n+                throw new RuntimeException(\"verify \" + name + \": should be two separate arrays (with identical content):\" +\n+                                           \" gold[\" + i + \"] == result[\" + i + \"]\");\n+            }\n+            if (Array.getLength(g) != Array.getLength(r)) {\n+                    throw new RuntimeException(\"verify \" + name + \": arrays must have same length:\" +\n+                                           \" gold[\" + i + \"].length = \" + Array.getLength(g) +\n+                                           \" result[\" + i + \"].length = \" + Array.getLength(r));\n+            }\n+            Class c = g.getClass().getComponentType();\n+            if (c == byte.class) {\n+                verifyB(name, i, (byte[])g, (byte[])r);\n+            } else if (c == char.class) {\n+                verifyC(name, i, (char[])g, (char[])r);\n+            } else if (c == short.class) {\n+                verifyS(name, i, (short[])g, (short[])r);\n+            } else if (c == int.class) {\n+                verifyI(name, i, (int[])g, (int[])r);\n+            } else if (c == long.class) {\n+                verifyL(name, i, (long[])g, (long[])r);\n+            } else if (c == float.class) {\n+                verifyF(name, i, (float[])g, (float[])r);\n+            } else if (c == double.class) {\n+                verifyD(name, i, (double[])g, (double[])r);\n+            } else {\n+                throw new RuntimeException(\"verify \" + name + \": array type not supported for verify:\" +\n+                                       \" gold[\" + i + \"].getClass() = \" + g.getClass().getSimpleName() +\n+                                       \" result[\" + i + \"].getClass() = \" + r.getClass().getSimpleName());\n+            }\n+        }\n+    }\n+\n+    static void verifyB(String name, int i, byte[] g, byte[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verifyB \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    static void verifyC(String name, int i, char[] g, char[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verifyC \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    static void verifyS(String name, int i, short[] g, short[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verifyS \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    static void verifyI(String name, int i, int[] g, int[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verifyI \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    static void verifyL(String name, int i, long[] g, long[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verifyL \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    static void verifyF(String name, int i, float[] g, float[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            int gv = UNSAFE.getInt(g, UNSAFE.ARRAY_FLOAT_BASE_OFFSET + 4 * j);\n+            int rv = UNSAFE.getInt(r, UNSAFE.ARRAY_FLOAT_BASE_OFFSET + 4 * j);\n+            if (gv != rv) {\n+                throw new RuntimeException(\"verifyF \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + gv +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + rv);\n+            }\n+        }\n+    }\n+\n+    static void verifyD(String name, int i, double[] g, double[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            long gv = UNSAFE.getLong(g, UNSAFE.ARRAY_DOUBLE_BASE_OFFSET + 8 * j);\n+            long rv = UNSAFE.getLong(r, UNSAFE.ARRAY_DOUBLE_BASE_OFFSET + 8 * j);\n+            if (gv != rv) {\n+                throw new RuntimeException(\"verifyF \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + gv +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + rv);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAlignVectorFuzzer.java","additions":1353,"deletions":0,"binary":false,"changes":1353,"status":"added"},{"patch":"@@ -30,1 +30,1 @@\n- *       https:\/\/bugs.openjdk.org\/browse\/JDK-8312570\n+ *       https:\/\/bugs.openjdk.org\/browse\/JDK-8310190\n@@ -52,2 +52,1 @@\n- * the CPU-features. Thus, we have a positive and negative IR rule per\n- * CPU-feature for each test.\n+ * the CPU-features.\n@@ -69,5 +68,1 @@\n- * With '-XX:+AlignVector', we would like to check that we vectorize exactly iff:\n- *     byte_offset % actual_vector_width == 0\n- * Because all vector_widths are powers of 2, this is equivalent to:\n- *     pow2_factor(byte_offset) >= actual_vector_width\n- * where pow2_factor computes the largest power of 2 that is a factor of the number.\n+ * With '-XX:+AlignVector' we do the following:\n@@ -75,2 +70,32 @@\n- * Under these assumptions, we know there must be vectorization:\n- *     pow2_factor(byte_offset) >= vector_width\n+ * Must vectorize cleanly if:\n+ *   1) guaranteed no misalignment AND\n+ *   2) guaratneed no cyclic dependency\n+ *\n+ * Must not vectorize at all if:\n+ *   1) guaranteed misalignment AND\n+ *   2) guaranteed no cyclic dependency\n+ *\n+ * We could imagine a case with cyclic dependency, where C2 detects\n+ * that only the first load is needed, and so no vectorization is\n+ * required for it, and hence the store vector can be aligned.\n+ *\n+ * The alignment criteria is\n+ *     byte_offset % aw == 0\n+ * where align width (aw) is\n+ *     aw = min(actual_vector_width, ObjectAlignmentInBytes)\n+ * For simplicity, we assume that ObjectAlignmentInBytes == 8,\n+ * which currently can only be changed manually and then no IR\n+ * rule is run.\n+ * This allows us to do the computation statically.\n+ * Further, we define:\n+ *     aw_min = min(min_vector_width, ObjectAlignmentInBytes)\n+ *     aw_max = min(vector_width, ObjectAlignmentInBytes)\n+ *     aw_min <= aw <= aw_max\n+ *\n+ * Again, we have no cyclic dependency, except when:\n+ *     byte_offset > 0 and p.vector_width > byte_offset\n+ * Here we must ensure that:\n+ *     byte_offset >= MaxVectorSize\n+ *\n+ * Guaranteed no misalignment:\n+ *     byte_offset % aw_max == 0\n@@ -78,3 +103,1 @@\n- *         pow2_factor(byte_offset) >= actual_vector_width\n- *     MaxVectorSize >= min_vector_size\n- *       else any vectorization is impossible.\n+ *         byte_offset % aw == 0\n@@ -82,4 +105,2 @@\n- * And under the following conditions no vectorization is possible:\n- *     byte_offset < 0: No cyclic dependency.\n- *       Cyclic dependency could lead to Load removals, then only the store is vectorized.\n- *     byte_offset % min_vector_width != 0\n+ * Guaranteed misalignment:\n+ *     byte_offset % aw_min != 0\n@@ -87,1 +108,1 @@\n- *         byte_offset % actual_vector_width != 0\n+ *         byte_offset % aw != 0\n@@ -93,1 +114,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -102,1 +123,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -111,1 +132,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -122,1 +143,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -133,1 +154,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -144,1 +165,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -155,1 +176,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -166,1 +187,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -177,1 +198,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -188,1 +209,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -199,1 +220,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -210,1 +231,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -221,1 +242,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -232,1 +253,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -243,1 +264,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -254,1 +275,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -265,1 +286,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -276,1 +297,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -287,1 +308,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -298,1 +319,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -309,1 +330,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -320,1 +341,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -331,1 +352,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -342,1 +363,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -353,1 +374,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -364,1 +385,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -375,1 +396,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -385,1 +406,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -395,1 +416,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -405,1 +426,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -415,1 +436,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -425,1 +446,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -435,1 +456,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -445,1 +466,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -455,1 +476,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -465,1 +486,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -1395,0 +1416,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -1399,0 +1424,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -1403,0 +1432,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -1407,0 +1440,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -1411,0 +1448,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -1431,1 +1472,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1439,1 +1480,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1447,1 +1488,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1455,1 +1496,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1463,1 +1504,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1486,0 +1527,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -1489,0 +1534,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -1492,0 +1541,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -1495,0 +1548,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -1498,0 +1555,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -1518,0 +1579,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -1522,0 +1587,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -1526,0 +1595,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -1530,0 +1603,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -1534,0 +1611,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -1553,1 +1634,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n@@ -1558,1 +1643,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n@@ -1563,1 +1652,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n@@ -1568,1 +1661,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n@@ -1573,1 +1670,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n@@ -1595,1 +1696,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1603,1 +1704,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1611,1 +1712,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1619,1 +1720,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1627,1 +1728,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1652,0 +1753,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -1657,0 +1762,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -1662,0 +1771,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -1667,0 +1780,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -1672,0 +1789,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -1692,0 +1813,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -1696,0 +1821,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -1700,0 +1829,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -1704,0 +1837,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -1708,0 +1845,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -1728,1 +1869,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -1737,0 +1878,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -1742,0 +1887,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -1746,1 +1895,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -1755,0 +1904,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -1775,1 +1928,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1783,1 +1936,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1791,1 +1944,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1799,1 +1952,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1807,1 +1960,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1831,0 +1984,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -1836,0 +1993,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 28\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -1841,0 +2002,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 28\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -1845,0 +2010,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -1850,0 +2019,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 28\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -1870,0 +2043,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -1874,0 +2051,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -1878,0 +2059,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -1882,0 +2067,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -1886,0 +2075,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -1906,1 +2099,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -1914,1 +2107,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -1923,0 +2116,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -1927,1 +2124,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -1936,0 +2133,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -1956,0 +2157,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -1960,0 +2165,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -1964,0 +2173,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -1968,0 +2181,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -1972,0 +2189,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -1992,0 +2213,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -1996,0 +2221,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2001,0 +2230,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 56\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2005,0 +2238,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -2010,0 +2247,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 56\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2030,0 +2271,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -2034,0 +2279,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2038,0 +2287,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2042,0 +2295,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -2046,0 +2303,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2066,1 +2327,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2074,1 +2335,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2082,1 +2343,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2090,1 +2351,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2099,0 +2360,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 64\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2119,0 +2384,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -2123,0 +2392,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2127,0 +2400,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2131,0 +2408,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -2135,0 +2416,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2155,0 +2440,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -2159,0 +2448,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2163,0 +2456,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2167,0 +2464,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -2172,0 +2473,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 72\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2192,0 +2497,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -2196,0 +2505,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2200,0 +2513,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2204,0 +2521,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -2208,0 +2529,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2228,1 +2553,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2236,0 +2561,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2240,0 +2569,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2244,1 +2577,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2253,0 +2586,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 80\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2273,1 +2610,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2281,1 +2618,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2289,1 +2626,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2297,1 +2634,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2305,1 +2642,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2329,0 +2666,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -2333,0 +2674,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2337,0 +2682,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2341,0 +2690,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -2346,0 +2699,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 124\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2366,0 +2723,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -2370,0 +2731,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2374,0 +2739,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2378,0 +2747,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -2382,0 +2755,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2402,1 +2779,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2410,1 +2787,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2418,1 +2795,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2426,1 +2803,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2435,0 +2812,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 128\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2455,1 +2836,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2463,1 +2844,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2471,1 +2852,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2479,1 +2860,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2487,1 +2868,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2511,0 +2892,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -2515,0 +2900,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2519,0 +2908,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2523,2 +2916,6 @@\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 252 can lead to cyclic dependency\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n+    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n+    \/\/   positive byte_offset 252 can lead to cyclic dependency\n@@ -2528,0 +2925,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 252\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2548,0 +2949,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -2552,0 +2957,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2556,0 +2965,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2560,0 +2973,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -2564,0 +2981,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2584,1 +3005,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2592,1 +3013,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2600,1 +3021,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2608,1 +3029,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2616,1 +3037,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2640,1 +3061,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2648,1 +3069,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2656,1 +3077,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2664,1 +3085,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2672,1 +3093,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2696,0 +3117,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -2700,0 +3125,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2704,0 +3133,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2708,0 +3141,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -2712,0 +3149,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2732,0 +3173,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -2736,0 +3181,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2740,0 +3189,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2744,0 +3197,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -2748,0 +3205,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2768,1 +3229,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2776,1 +3237,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2784,1 +3245,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2792,1 +3253,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2800,1 +3261,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2824,1 +3285,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2832,1 +3293,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2840,1 +3301,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2848,1 +3309,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2856,1 +3317,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2880,0 +3341,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -2884,0 +3349,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2888,0 +3357,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2892,0 +3365,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -2896,0 +3373,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2916,0 +3397,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -2920,0 +3405,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2924,0 +3413,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2928,0 +3421,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -2932,0 +3429,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2952,1 +3453,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2960,1 +3461,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2968,1 +3469,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2976,1 +3477,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2984,1 +3485,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3008,0 +3509,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -3012,0 +3517,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -3016,0 +3525,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3020,0 +3533,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -3024,0 +3541,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3044,3 +3565,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3052,3 +3573,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3060,3 +3581,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3068,3 +3589,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3076,3 +3597,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3099,0 +3620,2 @@\n+    \/\/   Expect alignment.\n+    \/\/   No positive IR rule: conditions impossible.\n@@ -3102,0 +3625,2 @@\n+    \/\/   Expect alignment.\n+    \/\/   No positive IR rule: conditions impossible.\n@@ -3105,0 +3630,2 @@\n+    \/\/   Expect alignment.\n+    \/\/   No positive IR rule: conditions impossible.\n@@ -3108,0 +3635,2 @@\n+    \/\/   Expect alignment.\n+    \/\/   No positive IR rule: conditions impossible.\n@@ -3111,0 +3640,2 @@\n+    \/\/   Expect alignment.\n+    \/\/   No positive IR rule: conditions impossible.\n@@ -3131,0 +3662,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -3135,0 +3670,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -3139,0 +3678,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3143,0 +3686,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -3147,0 +3694,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3167,1 +3718,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3174,1 +3725,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"16\"},\n@@ -3179,1 +3734,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"16\"},\n@@ -3185,1 +3744,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3192,1 +3751,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"16\"},\n@@ -3214,3 +3777,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3222,3 +3785,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3230,3 +3793,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3238,3 +3801,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3246,3 +3809,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3270,0 +3833,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -3275,0 +3842,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -3280,0 +3851,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3284,0 +3859,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -3289,0 +3868,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3309,0 +3892,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -3313,0 +3900,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -3317,0 +3908,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3321,0 +3916,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -3325,0 +3924,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3345,1 +3948,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3353,1 +3956,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3362,0 +3965,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3366,1 +3973,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3375,0 +3982,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3395,3 +4006,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3403,3 +4014,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3411,3 +4022,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3419,3 +4030,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3427,3 +4038,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3451,0 +4062,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -3455,0 +4070,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -3460,0 +4079,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 56\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3464,0 +4087,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -3469,0 +4096,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 56\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3489,0 +4120,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -3493,0 +4128,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -3497,0 +4136,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3501,0 +4144,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -3505,0 +4152,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3525,1 +4176,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3533,1 +4184,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3541,1 +4192,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3549,1 +4200,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3558,0 +4209,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 64\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3578,0 +4233,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -3582,0 +4241,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -3586,0 +4249,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3590,0 +4257,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -3594,0 +4265,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3614,1 +4289,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3622,0 +4297,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -3626,0 +4305,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3630,1 +4313,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3639,0 +4322,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 112\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3659,0 +4346,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -3663,1 +4354,5 @@\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n@@ -3667,0 +4362,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3671,0 +4370,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -3675,0 +4378,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3695,1 +4402,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3703,1 +4410,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3711,1 +4418,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3719,1 +4426,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3728,0 +4435,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 128\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3748,0 +4459,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -3752,0 +4467,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -3756,0 +4475,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3760,0 +4483,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -3764,0 +4491,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3784,1 +4515,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3792,0 +4523,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -3796,0 +4531,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3800,1 +4539,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3809,0 +4548,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 144\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3829,0 +4572,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -3833,0 +4580,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -3837,0 +4588,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3841,0 +4596,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -3845,0 +4604,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3865,1 +4628,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3873,1 +4636,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3881,0 +4644,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3885,1 +4652,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3894,0 +4661,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 160\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3914,3 +4685,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3922,3 +4693,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3930,3 +4701,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3938,3 +4709,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3946,3 +4717,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3970,0 +4741,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -3974,0 +4749,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -3978,0 +4757,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3982,0 +4765,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -3987,0 +4774,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 248\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -4007,0 +4798,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -4011,0 +4806,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -4015,0 +4814,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -4019,0 +4822,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -4023,0 +4830,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -4043,1 +4854,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4051,1 +4862,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4059,1 +4870,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4067,1 +4878,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4075,1 +4886,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4099,3 +4910,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4107,3 +4918,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4115,3 +4926,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4123,3 +4934,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4131,3 +4942,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4155,0 +4966,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -4159,0 +4974,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -4163,0 +4982,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -4167,0 +4990,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -4171,0 +4998,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -4191,0 +5022,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -4195,0 +5030,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -4199,0 +5038,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -4203,0 +5046,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -4207,0 +5054,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -4227,1 +5078,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4235,1 +5086,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4243,1 +5094,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4251,1 +5102,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4259,1 +5110,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4283,3 +5134,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4291,3 +5142,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4299,3 +5150,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4307,3 +5158,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4315,3 +5166,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4339,0 +5190,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -4343,0 +5198,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -4347,0 +5206,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -4351,0 +5214,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -4355,0 +5222,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -4375,0 +5246,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -4379,0 +5254,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -4383,0 +5262,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -4387,0 +5270,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -4391,0 +5278,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -4411,1 +5302,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4419,1 +5310,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4427,1 +5318,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4435,1 +5326,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4443,1 +5334,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4467,3 +5358,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4475,3 +5366,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4483,3 +5374,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4491,3 +5382,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4499,3 +5390,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4523,0 +5414,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -4527,0 +5422,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -4531,0 +5430,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -4535,0 +5438,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -4539,0 +5446,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -4559,0 +5470,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -4563,0 +5478,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -4567,0 +5486,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -4571,0 +5494,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -4575,0 +5502,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -4595,1 +5526,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4603,1 +5534,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4611,1 +5542,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4619,1 +5550,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4627,1 +5558,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4651,0 +5582,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -4655,0 +5590,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -4659,0 +5598,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -4663,0 +5606,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -4667,0 +5614,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -4687,1 +5638,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -4695,1 +5646,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -4703,1 +5654,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -4711,1 +5662,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -4719,1 +5670,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -4742,0 +5693,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -4745,0 +5700,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -4748,0 +5707,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -4751,0 +5714,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -4754,0 +5721,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -4774,0 +5745,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -4778,0 +5750,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -4782,0 +5755,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -4786,0 +5760,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -4790,0 +5765,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -4809,1 +5785,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -4811,0 +5787,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -4814,1 +5791,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -4816,0 +5793,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -4819,1 +5797,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -4821,0 +5799,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -4824,1 +5803,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -4826,0 +5805,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -4829,1 +5809,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -4831,0 +5811,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -4851,1 +5832,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -4859,1 +5840,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -4867,1 +5848,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -4875,1 +5856,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -4883,1 +5864,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -4908,0 +5889,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -4913,0 +5898,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -4918,0 +5907,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -4923,0 +5916,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -4928,0 +5925,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -4948,0 +5949,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -4952,0 +5957,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -4956,0 +5965,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -4960,0 +5973,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -4964,0 +5981,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -4985,0 +6006,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -4990,0 +6015,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -4995,0 +6024,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5000,0 +6033,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -5005,0 +6042,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5025,1 +6066,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5033,1 +6074,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5041,1 +6082,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5049,1 +6090,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5057,1 +6098,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5082,0 +6123,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -5087,0 +6132,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -5092,0 +6141,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5097,0 +6150,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -5102,0 +6159,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5122,0 +6183,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -5126,0 +6191,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -5130,0 +6199,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5134,0 +6207,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -5138,0 +6215,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5158,1 +6239,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -5167,0 +6248,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -5172,0 +6257,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5176,1 +6265,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -5185,0 +6274,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5205,0 +6298,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5209,0 +6303,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5213,0 +6308,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5217,0 +6313,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5221,0 +6318,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5241,0 +6339,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5246,0 +6345,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5251,0 +6351,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5255,0 +6356,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5260,0 +6362,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5280,0 +6383,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -5284,0 +6391,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -5288,0 +6399,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5292,0 +6407,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -5296,0 +6415,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5316,1 +6439,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -5324,1 +6447,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -5333,0 +6456,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5337,1 +6464,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -5346,0 +6473,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5366,0 +6497,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5370,0 +6502,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5374,0 +6507,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5378,0 +6512,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5382,0 +6517,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5402,0 +6538,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5406,0 +6543,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5411,0 +6549,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5415,0 +6554,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5420,0 +6560,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5440,0 +6581,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -5444,0 +6589,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -5448,0 +6597,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5452,0 +6605,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -5456,0 +6613,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5476,0 +6637,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -5480,0 +6645,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -5485,0 +6654,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 40\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5489,0 +6662,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -5494,0 +6671,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 40\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5514,1 +6695,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5522,1 +6703,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5530,1 +6711,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5538,1 +6719,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5546,1 +6727,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5570,0 +6751,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -5574,0 +6759,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -5579,0 +6768,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 62\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5583,0 +6776,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -5588,0 +6785,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 62\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5608,0 +6809,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -5612,0 +6817,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -5616,0 +6825,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5620,0 +6833,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -5624,0 +6841,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5644,1 +6865,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -5652,1 +6873,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -5660,1 +6881,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -5668,1 +6889,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -5677,0 +6898,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 64\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5697,1 +6922,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5705,1 +6930,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5713,1 +6938,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5721,1 +6946,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5729,1 +6954,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5753,0 +6978,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -5757,0 +6986,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -5761,0 +6994,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5765,0 +7002,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -5770,0 +7011,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 126\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5790,0 +7035,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -5794,0 +7043,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -5798,0 +7051,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5802,0 +7059,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -5806,0 +7067,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5826,1 +7091,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -5834,1 +7099,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -5842,1 +7107,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -5850,1 +7115,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -5859,0 +7124,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 128\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5879,1 +7148,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5887,1 +7156,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5895,1 +7164,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5903,1 +7172,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5911,1 +7180,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5935,0 +7204,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -5939,0 +7212,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -5943,0 +7220,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5947,0 +7228,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -5952,0 +7237,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 130\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5972,0 +7261,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -5976,0 +7269,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -5980,0 +7277,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5984,0 +7285,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -5988,0 +7293,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -6008,1 +7317,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6016,1 +7325,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6024,1 +7333,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6032,1 +7341,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6040,1 +7349,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6064,1 +7373,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6072,1 +7381,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6080,1 +7389,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6088,1 +7397,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6096,1 +7405,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6120,0 +7429,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -6124,0 +7437,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -6128,0 +7445,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -6132,0 +7453,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -6136,0 +7461,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -6156,0 +7485,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -6160,0 +7493,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -6164,0 +7501,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -6168,0 +7509,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -6172,0 +7517,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -6192,1 +7541,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6200,1 +7549,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6208,1 +7557,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6216,1 +7565,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6224,0 +7573,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -6244,0 +7597,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -6248,0 +7605,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -6252,0 +7613,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -6256,0 +7621,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -6260,2 +7629,6 @@\n-    public static void testCharP0(char[] data) {\n-        for (int j = 0; j < RANGE; j++) {\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n+    public static void testCharP0(char[] data) {\n+        for (int j = 0; j < RANGE; j++) {\n@@ -6280,1 +7653,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6288,1 +7661,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6296,1 +7669,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6304,1 +7677,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6312,1 +7685,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6335,0 +7708,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -6338,0 +7715,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -6341,0 +7722,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -6344,0 +7729,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -6347,0 +7736,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -6367,0 +7760,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6371,0 +7765,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6375,0 +7770,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6379,0 +7775,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6383,0 +7780,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6402,1 +7800,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -6404,0 +7802,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6407,1 +7806,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -6409,0 +7808,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6412,1 +7812,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -6414,0 +7814,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6417,1 +7818,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -6419,0 +7820,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6422,1 +7824,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -6424,0 +7826,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6444,1 +7847,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6452,1 +7855,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6460,1 +7863,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6468,1 +7871,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6476,1 +7879,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6501,0 +7904,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -6506,0 +7913,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -6511,0 +7922,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -6516,0 +7931,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -6521,0 +7940,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -6541,0 +7964,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -6545,0 +7972,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -6549,0 +7980,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -6553,0 +7988,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -6557,0 +7996,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -6578,0 +8021,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -6583,0 +8030,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -6588,0 +8039,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -6593,0 +8048,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -6598,0 +8057,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -6618,1 +8081,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6626,1 +8089,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6634,1 +8097,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6642,1 +8105,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6650,1 +8113,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6675,0 +8138,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -6680,0 +8147,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -6685,0 +8156,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -6690,0 +8165,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -6695,0 +8174,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -6715,0 +8198,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -6719,0 +8206,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -6723,0 +8214,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -6727,0 +8222,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -6731,0 +8230,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -6751,1 +8254,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6760,0 +8263,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -6765,0 +8272,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -6769,1 +8280,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6778,0 +8289,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -6798,0 +8313,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6802,0 +8318,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6806,0 +8323,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6810,0 +8328,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6814,0 +8333,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6834,0 +8354,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6839,0 +8360,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6844,0 +8366,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6848,0 +8371,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6853,0 +8377,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6873,0 +8398,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -6877,0 +8406,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -6881,0 +8414,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -6885,0 +8422,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -6889,0 +8430,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -6909,1 +8454,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6917,1 +8462,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6926,0 +8471,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -6930,1 +8479,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6939,0 +8488,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -6959,0 +8512,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6963,0 +8517,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6967,0 +8522,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6971,0 +8527,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6975,0 +8532,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6995,0 +8553,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6999,0 +8558,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -7004,0 +8564,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -7008,0 +8569,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -7013,0 +8575,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -7033,0 +8596,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -7037,0 +8604,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -7041,0 +8612,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -7045,0 +8620,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -7049,0 +8628,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7069,0 +8652,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -7073,0 +8660,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -7078,0 +8669,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 40\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -7082,0 +8677,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -7087,0 +8686,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 40\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7107,1 +8710,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7115,1 +8718,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7123,1 +8726,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7131,1 +8734,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7139,1 +8742,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7163,0 +8766,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -7167,0 +8774,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -7172,0 +8783,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 62\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -7176,0 +8791,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -7181,0 +8800,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 62\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7201,0 +8824,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -7205,0 +8832,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -7209,0 +8840,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -7213,0 +8848,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -7217,0 +8856,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7237,1 +8880,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7245,1 +8888,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7253,1 +8896,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7261,1 +8904,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7270,0 +8913,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 64\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7290,1 +8937,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7298,1 +8945,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7306,1 +8953,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7314,1 +8961,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7322,1 +8969,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7346,0 +8993,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -7350,0 +9001,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -7354,0 +9009,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -7358,0 +9017,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -7363,0 +9026,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 126\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7383,0 +9050,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -7387,0 +9058,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -7391,0 +9066,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -7395,0 +9074,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -7399,0 +9082,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7419,1 +9106,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7427,1 +9114,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7435,1 +9122,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7443,1 +9130,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7452,0 +9139,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 128\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7472,1 +9163,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7480,1 +9171,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7488,1 +9179,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7496,1 +9187,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7504,1 +9195,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7528,0 +9219,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -7532,0 +9227,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -7536,0 +9235,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -7540,0 +9243,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -7545,0 +9252,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 130\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7565,0 +9276,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -7569,0 +9284,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -7573,0 +9292,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -7577,0 +9300,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -7581,0 +9308,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7601,1 +9332,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7609,1 +9340,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7617,1 +9348,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7625,1 +9356,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7633,1 +9364,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7657,1 +9388,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7665,1 +9396,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7673,1 +9404,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7681,1 +9412,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7689,1 +9420,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7713,0 +9444,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -7717,0 +9452,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -7721,0 +9460,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -7725,0 +9468,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -7729,0 +9476,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7749,0 +9500,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -7753,0 +9508,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -7757,0 +9516,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -7761,0 +9524,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -7765,0 +9532,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7785,1 +9556,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7793,1 +9564,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7801,1 +9572,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7809,1 +9580,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7817,0 +9588,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7837,0 +9612,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -7841,1 +9620,1 @@\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    \/\/   Expect alignment.\n@@ -7843,1 +9622,9 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n@@ -7849,0 +9636,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -7853,0 +9644,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7873,1 +9668,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7881,1 +9676,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7889,1 +9684,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7897,1 +9692,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7905,1 +9700,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7928,0 +9723,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 1\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -7931,0 +9730,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 1\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -7934,0 +9737,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 1\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -7937,0 +9744,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 1\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -7940,0 +9751,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7960,1 +9775,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7968,1 +9783,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7976,1 +9791,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7984,1 +9799,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7992,1 +9807,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8015,0 +9830,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -8018,0 +9837,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -8021,0 +9844,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -8024,0 +9851,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -8027,0 +9858,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -8047,1 +9882,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8055,1 +9890,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8063,1 +9898,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8071,1 +9906,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8079,1 +9914,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8102,0 +9937,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 3\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -8105,0 +9944,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 3\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -8108,0 +9951,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 3\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -8111,0 +9958,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 3\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -8114,0 +9965,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 3\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -8134,0 +9989,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8138,0 +9994,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8142,0 +9999,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8146,0 +10004,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8150,0 +10009,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8169,1 +10029,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -8171,0 +10031,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8174,1 +10035,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -8176,0 +10037,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8179,1 +10041,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -8181,0 +10043,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8184,1 +10047,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -8186,0 +10049,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8189,1 +10053,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -8191,0 +10055,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8211,1 +10076,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8219,1 +10084,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8227,1 +10092,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8235,1 +10100,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8243,1 +10108,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8268,0 +10133,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 7\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -8273,0 +10142,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 7\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -8278,0 +10151,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 7\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -8283,0 +10160,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 7\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -8288,0 +10169,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 7\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -8308,0 +10193,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -8312,0 +10201,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -8316,0 +10209,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -8320,0 +10217,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -8324,0 +10225,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -8345,0 +10250,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -8350,0 +10259,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -8355,0 +10268,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -8360,0 +10277,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -8365,0 +10286,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -8385,1 +10310,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8393,1 +10318,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8401,1 +10326,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8409,1 +10334,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8417,1 +10342,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8442,0 +10367,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -8447,0 +10376,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -8452,0 +10385,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -8457,0 +10394,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -8462,0 +10403,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -8482,0 +10427,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -8486,0 +10435,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -8490,0 +10443,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -8494,0 +10451,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -8498,0 +10459,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -8518,1 +10483,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -8527,0 +10492,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -8532,0 +10501,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -8536,1 +10509,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -8545,0 +10518,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -8565,1 +10542,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8573,1 +10550,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8581,1 +10558,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8589,1 +10566,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8597,1 +10574,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8621,0 +10598,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -8626,0 +10607,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 18\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -8631,0 +10616,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 18\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -8635,0 +10624,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -8640,0 +10633,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 18\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -8660,0 +10657,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8664,0 +10662,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8668,0 +10667,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8672,0 +10672,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8676,0 +10677,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8696,0 +10698,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8701,0 +10704,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8706,0 +10710,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8710,0 +10715,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8715,0 +10721,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8735,1 +10742,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8743,1 +10750,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8751,1 +10758,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8759,1 +10766,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8767,1 +10774,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8791,0 +10798,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -8796,0 +10807,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 31\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -8801,0 +10816,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 31\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -8805,0 +10824,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -8810,0 +10833,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 31\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -8830,0 +10857,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -8834,0 +10865,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -8838,0 +10873,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -8842,0 +10881,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -8846,0 +10889,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -8866,1 +10913,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -8874,1 +10921,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -8883,0 +10930,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -8887,1 +10938,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -8896,0 +10947,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -8916,1 +10971,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8924,1 +10979,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8932,1 +10987,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8940,1 +10995,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8948,1 +11003,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8972,0 +11027,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -8976,0 +11035,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -8981,0 +11044,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 63\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -8985,0 +11052,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -8990,0 +11061,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 63\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9010,0 +11085,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -9014,0 +11093,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -9018,0 +11101,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -9022,0 +11109,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -9026,0 +11117,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9046,1 +11141,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9054,1 +11149,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9062,1 +11157,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9070,1 +11165,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9079,0 +11174,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 64\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9099,1 +11198,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9107,1 +11206,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9115,1 +11214,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9123,1 +11222,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9131,1 +11230,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9155,0 +11254,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -9159,0 +11262,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -9163,0 +11270,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -9167,0 +11278,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -9172,0 +11287,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 65\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9192,0 +11311,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -9196,0 +11319,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -9200,0 +11327,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -9204,0 +11335,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -9208,0 +11343,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9228,1 +11367,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9236,1 +11375,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9244,1 +11383,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9252,1 +11391,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9261,0 +11400,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 128\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9281,1 +11424,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9289,1 +11432,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9297,1 +11440,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9305,1 +11448,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9313,1 +11456,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9337,0 +11480,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -9341,0 +11488,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -9345,0 +11496,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -9349,0 +11504,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -9354,0 +11513,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 129\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9374,0 +11537,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -9378,0 +11545,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -9382,0 +11553,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -9386,0 +11561,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -9390,0 +11569,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9410,1 +11593,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9418,1 +11601,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9426,1 +11609,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9434,1 +11617,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9443,0 +11626,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 192\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9463,0 +11650,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -9467,0 +11658,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -9471,0 +11666,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -9475,1 +11674,1 @@\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n+    \/\/   Expect alignment.\n@@ -9477,1 +11676,9 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n+    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n@@ -9499,1 +11706,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9507,1 +11714,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9515,1 +11722,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9523,1 +11730,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9531,1 +11738,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9554,0 +11761,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -9557,0 +11768,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -9560,0 +11775,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -9563,0 +11782,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -9566,0 +11789,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9586,0 +11813,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -9590,0 +11821,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -9594,0 +11829,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -9598,0 +11837,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -9602,0 +11845,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9621,1 +11868,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n@@ -9626,1 +11877,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n@@ -9631,1 +11886,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n@@ -9636,1 +11895,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n@@ -9641,1 +11904,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n@@ -9663,1 +11930,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9671,1 +11938,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9679,1 +11946,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9687,1 +11954,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9695,1 +11962,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9720,0 +11987,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -9725,0 +11996,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -9730,0 +12005,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -9735,0 +12014,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -9740,0 +12023,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9760,0 +12047,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -9764,0 +12055,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -9768,0 +12063,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -9772,0 +12071,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -9776,0 +12079,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9796,1 +12103,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9805,0 +12112,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -9810,0 +12121,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -9814,1 +12129,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9823,0 +12138,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9843,1 +12162,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9851,1 +12170,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9859,1 +12178,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9867,1 +12186,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9875,1 +12194,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9899,0 +12218,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -9904,0 +12227,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 28\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -9909,0 +12236,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 28\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -9913,0 +12244,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -9918,0 +12253,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 28\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9938,0 +12277,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -9942,0 +12285,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -9946,0 +12293,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -9950,0 +12301,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -9954,0 +12309,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9974,1 +12333,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9982,1 +12341,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9991,0 +12350,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -9995,1 +12358,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10004,0 +12367,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10024,0 +12391,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10028,0 +12399,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10032,0 +12407,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10036,0 +12415,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -10040,0 +12423,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10060,0 +12447,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10064,0 +12455,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10069,0 +12464,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 56\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10073,0 +12472,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -10078,0 +12481,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 56\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10098,0 +12505,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10102,0 +12513,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10106,0 +12521,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10110,0 +12529,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -10114,0 +12537,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10134,1 +12561,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10142,1 +12569,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10150,1 +12577,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10158,1 +12585,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10167,0 +12594,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 64\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10187,0 +12618,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10191,0 +12626,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10195,0 +12634,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10199,0 +12642,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -10203,0 +12650,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10223,0 +12674,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10227,0 +12682,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10231,0 +12690,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10235,0 +12698,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -10240,0 +12707,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 72\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10260,0 +12731,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10264,0 +12739,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10268,0 +12747,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10272,0 +12755,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -10276,0 +12763,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10296,1 +12787,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10304,0 +12795,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10308,0 +12803,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10312,1 +12811,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10321,0 +12820,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 80\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10341,1 +12844,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10349,1 +12852,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10357,1 +12860,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10365,1 +12868,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10373,1 +12876,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10397,0 +12900,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10401,0 +12908,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10405,0 +12916,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10409,0 +12924,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -10414,0 +12933,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 124\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10434,0 +12957,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10438,0 +12965,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10442,0 +12973,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10446,0 +12981,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -10450,0 +12989,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10470,1 +13013,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10478,1 +13021,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10486,1 +13029,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10494,1 +13037,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10503,0 +13046,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 128\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10523,1 +13070,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10531,1 +13078,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10539,1 +13086,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10547,1 +13094,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10555,1 +13102,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10579,0 +13126,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10583,0 +13134,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10587,0 +13142,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10591,0 +13150,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -10596,0 +13159,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 252\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10616,0 +13183,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10620,0 +13191,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10624,0 +13199,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10628,0 +13207,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -10632,0 +13215,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10652,1 +13239,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10660,1 +13247,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10668,1 +13255,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10676,1 +13263,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10684,1 +13271,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10708,1 +13295,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10716,1 +13303,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10724,1 +13311,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10732,1 +13319,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10740,1 +13327,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10764,0 +13351,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10768,0 +13359,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10772,0 +13367,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10776,0 +13375,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -10780,0 +13383,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10800,0 +13407,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10804,0 +13415,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10808,0 +13423,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10812,0 +13431,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -10816,0 +13439,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10836,1 +13463,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10844,1 +13471,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10852,1 +13479,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10860,1 +13487,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10868,1 +13495,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10892,1 +13519,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10900,1 +13527,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10908,1 +13535,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10916,1 +13543,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10924,1 +13551,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10948,0 +13575,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10952,0 +13583,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10956,0 +13591,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10960,0 +13599,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -10964,0 +13607,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10984,0 +13631,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10988,0 +13639,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10992,0 +13647,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10996,0 +13655,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -11000,0 +13663,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11020,1 +13687,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11028,1 +13695,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11036,1 +13703,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11044,1 +13711,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11052,1 +13719,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11076,0 +13743,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -11080,0 +13751,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -11084,0 +13759,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11088,0 +13767,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -11092,0 +13775,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11112,3 +13799,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11120,3 +13807,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11128,3 +13815,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11136,3 +13823,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11144,3 +13831,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11167,0 +13854,2 @@\n+    \/\/   Expect alignment.\n+    \/\/   No positive IR rule: conditions impossible.\n@@ -11170,0 +13859,2 @@\n+    \/\/   Expect alignment.\n+    \/\/   No positive IR rule: conditions impossible.\n@@ -11173,0 +13864,2 @@\n+    \/\/   Expect alignment.\n+    \/\/   No positive IR rule: conditions impossible.\n@@ -11176,0 +13869,2 @@\n+    \/\/   Expect alignment.\n+    \/\/   No positive IR rule: conditions impossible.\n@@ -11179,0 +13874,2 @@\n+    \/\/   Expect alignment.\n+    \/\/   No positive IR rule: conditions impossible.\n@@ -11199,0 +13896,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -11203,0 +13904,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -11207,0 +13912,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11211,0 +13920,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -11215,0 +13928,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11235,1 +13952,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11242,1 +13959,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"16\"},\n@@ -11247,1 +13968,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"16\"},\n@@ -11253,1 +13978,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11260,1 +13985,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"16\"},\n@@ -11282,3 +14011,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11290,3 +14019,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11298,3 +14027,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11306,3 +14035,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11314,3 +14043,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11338,0 +14067,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -11343,0 +14076,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -11348,0 +14085,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11352,0 +14093,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -11357,0 +14102,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11377,0 +14126,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -11381,0 +14134,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -11385,0 +14142,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11389,0 +14150,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -11393,0 +14158,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11413,1 +14182,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11421,1 +14190,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11430,0 +14199,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11434,1 +14207,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11443,0 +14216,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11463,3 +14240,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11471,3 +14248,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11479,3 +14256,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11487,3 +14264,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11495,3 +14272,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11519,0 +14296,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -11523,0 +14304,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -11528,0 +14313,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 56\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11532,0 +14321,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -11537,0 +14330,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 56\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11557,0 +14354,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -11561,0 +14362,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -11565,0 +14370,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11569,0 +14378,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -11573,0 +14386,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11593,1 +14410,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11601,1 +14418,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11609,1 +14426,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11617,1 +14434,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11626,0 +14443,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 64\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11646,0 +14467,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -11650,0 +14475,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -11654,0 +14483,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11658,0 +14491,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -11662,0 +14499,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11682,1 +14523,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11690,0 +14531,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -11694,0 +14539,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11698,1 +14547,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11707,0 +14556,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 112\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11727,0 +14580,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -11731,0 +14588,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -11735,0 +14596,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11739,0 +14604,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -11743,0 +14612,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11763,1 +14636,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11771,1 +14644,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11779,1 +14652,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11787,1 +14660,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11796,0 +14669,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 128\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11816,0 +14693,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -11820,0 +14701,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -11824,0 +14709,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11828,0 +14717,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -11832,0 +14725,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11852,1 +14749,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11860,0 +14757,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -11864,0 +14765,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11868,1 +14773,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11877,0 +14782,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 144\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11897,0 +14806,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -11901,0 +14814,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -11905,0 +14822,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11909,0 +14830,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -11913,0 +14838,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11933,1 +14862,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11941,1 +14870,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11949,0 +14878,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11953,1 +14886,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11962,0 +14895,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 160\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11982,3 +14919,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11990,3 +14927,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11998,3 +14935,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12006,3 +14943,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12014,3 +14951,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12038,0 +14975,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -12042,0 +14983,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -12046,0 +14991,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -12050,0 +14999,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -12055,0 +15008,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 248\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -12075,0 +15032,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -12079,0 +15040,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -12083,0 +15048,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -12087,0 +15056,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -12091,0 +15064,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -12111,1 +15088,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12119,1 +15096,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12127,1 +15104,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12135,1 +15112,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12143,1 +15120,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12167,3 +15144,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12175,3 +15152,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12183,3 +15160,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12191,3 +15168,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12199,3 +15176,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12223,0 +15200,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -12227,0 +15208,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -12231,0 +15216,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -12235,0 +15224,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -12239,0 +15232,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -12259,0 +15256,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -12263,0 +15264,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -12267,0 +15272,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -12271,0 +15280,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -12275,0 +15288,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -12295,1 +15312,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12303,1 +15320,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12311,1 +15328,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12319,1 +15336,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12327,1 +15344,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12351,3 +15368,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12359,3 +15376,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12367,3 +15384,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12375,3 +15392,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12383,3 +15400,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12407,0 +15424,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -12411,0 +15432,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -12415,0 +15440,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -12419,0 +15448,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -12423,0 +15456,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -12443,0 +15480,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -12447,0 +15488,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -12451,0 +15496,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -12455,0 +15504,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -12459,0 +15512,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -12479,1 +15536,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12487,1 +15544,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12495,1 +15552,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12503,1 +15560,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12511,1 +15568,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12535,3 +15592,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12543,3 +15600,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12551,3 +15608,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12559,3 +15616,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12567,3 +15624,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12591,0 +15648,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -12595,0 +15656,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -12599,0 +15664,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -12603,0 +15672,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -12607,0 +15680,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -12627,0 +15704,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -12631,0 +15712,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -12635,0 +15720,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -12639,0 +15728,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -12643,0 +15736,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -12663,1 +15760,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12671,1 +15768,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12679,1 +15776,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12687,1 +15784,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12695,1 +15792,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestDependencyOffsets.java","additions":3792,"deletions":695,"binary":false,"changes":4487,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @requires vm.cpu.features ~= \".*avx2.*\"\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMovingLoadBeforeStore.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @requires os.arch == \"x86_64\" | os.arch == \"aarch64\"\n@@ -78,1 +77,2 @@\n-    @IR(applyIfCPUFeature = {\"sse2\", \"true\"}, applyIf = {\"UseUnalignedLoadStores\", \"true\"},\n+    @IR(applyIfCPUFeature = {\"sse2\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -80,7 +80,5 @@\n-    @IR(applyIfCPUFeature = {\"sse2\", \"true\"}, applyIf = {\"UseUnalignedLoadStores\", \"false\"},\n-        failOn = {IRNode.MUL_ADD_VS2VI}, \/\/ Can only pack LoadS if UseUnalignedLoadStores is true (default if sse4.2)\n-        counts = {IRNode.MUL_ADD_S2I, \"> 0\"})\n-    @IR(applyIfCPUFeature = {\"asimd\", \"true\"}, applyIf = {\"MaxVectorSize\", \"16\"}, \/\/ AD file requires vector_length = 16\n-            counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI, \"> 0\"})\n-    @IR(applyIfCPUFeature = {\"avx512_vnni\", \"true\"}, applyIf = {\"UseUnalignedLoadStores\", \"true\"},\n-            counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI_VNNI, \"> 0\"})\n+    @IR(applyIfCPUFeature = {\"asimd\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \"16\"}, \/\/ AD file requires vector_length = 16\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI, \"> 0\"})\n+    @IR(applyIfCPUFeature = {\"avx512_vnni\", \"true\"},\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI_VNNI, \"> 0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMulAddS2I.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8257531\n+ * @bug 8257531 8310190\n@@ -29,11 +29,2 @@\n- *\n- * @requires vm.flagless\n- * @requires vm.compiler2.enabled & vm.debug == true\n- * @requires os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n- *\n- * @run driver compiler.vectorization.TestBufferVectorization array\n- * @run driver compiler.vectorization.TestBufferVectorization arrayOffset\n- * @run driver compiler.vectorization.TestBufferVectorization buffer\n- * @run driver compiler.vectorization.TestBufferVectorization bufferHeap\n- * @run driver compiler.vectorization.TestBufferVectorization bufferDirect\n- * @run driver compiler.vectorization.TestBufferVectorization arrayView\n+ * @requires vm.compiler2.enabled\n+ * @run driver compiler.vectorization.TestBufferVectorization\n@@ -44,0 +35,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -51,4 +44,0 @@\n-import jdk.test.lib.Platform;\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n@@ -56,6 +45,2 @@\n-    final static int N = 500;\n-    final static int ITER = 1000;\n-    final static IntBuffer buffer = IntBuffer.allocate(N);\n-    final static int offset = buffer.arrayOffset();\n-    final static IntBuffer heap_buffer_byte_to_int = ByteBuffer.allocate(N * Integer.BYTES).order(ByteOrder.nativeOrder()).asIntBuffer();\n-    final static IntBuffer direct_buffer_byte_to_int = ByteBuffer.allocateDirect(N * Integer.BYTES).order(ByteOrder.nativeOrder()).asIntBuffer();\n+    final static int N = 1024*16;\n+    static int offset = 0;\n@@ -63,1 +48,0 @@\n-    final static String arch = System.getProperty(\"os.arch\");\n@@ -65,4 +49,2 @@\n-    interface Test {\n-        void init();\n-        void run();\n-        void verify();\n+    public static void main(String[] args) {\n+        TestFramework.run();\n@@ -71,2 +53,3 @@\n-    static class TestArray implements Test {\n-        final int[] array = new int[N];\n+    @Run(test = \"testArray\")\n+    public static void runArray() {\n+        int[] array = new int[N];\n@@ -74,4 +57,2 @@\n-        public void init() {\n-            for (int k = 0; k < array.length; k++) {\n-                array[k] = k;\n-            }\n+        for (int k = 0; k < array.length; k++) {\n+            array[k] = k;\n@@ -80,3 +61,5 @@\n-        public void run() {\n-            for(int k = 0; k < array.length; k++) {\n-                array[k] += 1;\n+        testArray(array);\n+\n+        for(int k = 0; k < array.length; k++) {\n+            if (array[k] != (k + 1)) {\n+                throw new RuntimeException(\" Invalid result: array[\" + k + \"]: \" + array[k] + \" != \" + (k + 1));\n@@ -85,0 +68,1 @@\n+    }\n@@ -86,8 +70,9 @@\n-        public void verify() {\n-            init(); \/\/ reset\n-            run();  \/\/ run compiled code\n-            for(int k = 0; k < array.length; k++) {\n-                if (array[k] != (k + 1)) {\n-                    throw new RuntimeException(\" Invalid result: array[\" + k + \"]: \" + array[k] + \" != \" + (k + 1));\n-                }\n-            }\n+    @Test\n+    @IR(counts = {IRNode.REPLICATE_I,   \">0\",\n+                  IRNode.LOAD_VECTOR_I, \">0\",\n+                  IRNode.ADD_VI,        \">0\",\n+                  IRNode.STORE_VECTOR,  \">0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    public static void testArray(int[] array) {\n+        for(int k = 0; k < array.length; k++) {\n+            array[k] += 1;\n@@ -97,3 +82,4 @@\n-    static class TestArrayOffset implements Test {\n-        final int offset;\n-        final int[] array = new int[N];\n+    @Run(test = \"testArrayOffset\")\n+    public static void runArrayOffset() {\n+        \/\/ Moving offset between 0..255\n+        offset = (offset + 1) % 256;\n@@ -101,3 +87,1 @@\n-        public TestArrayOffset(int off) {\n-            offset = off;\n-        }\n+        int[] array = new int[N];\n@@ -105,4 +89,2 @@\n-        public void init() {\n-            for (int k = 0; k < array.length; k++) {\n-                array[k] = k;\n-            }\n+        for (int k = 0; k < array.length; k++) {\n+            array[k] = k;\n@@ -111,6 +93,1 @@\n-        public void run() {\n-            int l = array.length - offset;\n-            for(int k = 0; k < l; k++) {\n-                array[k + offset] += 1;\n-            }\n-        }\n+        testArrayOffset(array, offset);\n@@ -118,8 +95,4 @@\n-        public void verify() {\n-            init(); \/\/ reset\n-            run();  \/\/ run compiled code\n-            int l = array.length - offset;\n-            for(int k = 0; k < l; k++) {\n-                if (array[k] != (k + 1)) {\n-                    throw new RuntimeException(\" Invalid result: arrayOffset[\" + k + \"]: \" + array[k] + \" != \" + (k + 1));\n-                }\n+        int l = array.length - offset;\n+        for(int k = 0; k < offset; k++) {\n+            if (array[k] != k) {\n+                throw new RuntimeException(\" Invalid result: arrayOffset[\" + k + \"]: \" + array[k] + \" != \" + (k + 1));\n@@ -127,4 +100,4 @@\n-            for(int k = l; k < array.length; k++) {\n-                if (array[k] != k) {\n-                    throw new RuntimeException(\" Invalid result: arrayOffset[\" + k + \"]: \" + array[k] + \" != \" + k);\n-                }\n+        }\n+        for(int k = offset; k < array.length; k++) {\n+            if (array[k] != (k + 1)) {\n+                throw new RuntimeException(\" Invalid result: arrayOffset[\" + k + \"]: \" + array[k] + \" != \" + k);\n@@ -135,11 +108,10 @@\n-    static class TestBuffer implements Test {\n-        final IntBuffer buffer;\n-\n-        public TestBuffer(IntBuffer buf) {\n-            buffer = buf;\n-        }\n-\n-        public void init() {\n-            for (int k = 0; k < buffer.limit(); k++) {\n-                buffer.put(k, k);\n-            }\n+    @Test\n+    @IR(counts = {IRNode.REPLICATE_I,   \">0\",\n+                  IRNode.LOAD_VECTOR_I, \">0\",\n+                  IRNode.ADD_VI,        \">0\",\n+                  IRNode.STORE_VECTOR,  \">0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    public static void testArrayOffset(int[] array, int offset) {\n+        int l = array.length - offset;\n+        for(int k = 0; k < l; k++) {\n+            array[k + offset] += 1;\n@@ -147,0 +119,1 @@\n+    }\n@@ -148,5 +121,7 @@\n-        public void run() {\n-            for (int k = 0; k < buffer.limit(); k++) {\n-                buffer.put(k, buffer.get(k) + 1);\n-            }\n-        }\n+    @Run(test = \"testBuffer\")\n+    public static void runBuffer() {\n+        IntBuffer buffer = IntBuffer.allocate(N);\n+        initBuffer(buffer);\n+        testBuffer(buffer);\n+        verifyBuffer(buffer);\n+    }\n@@ -154,8 +129,9 @@\n-        public void verify() {\n-            init(); \/\/ reset\n-            run();  \/\/ run compiled code\n-            for(int k = 0; k < buffer.limit(); k++) {\n-                if (buffer.get(k) != (k + 1)) {\n-                    throw new RuntimeException(\" Invalid result: buffer.get(\" + k + \"): \" + buffer.get(k) + \" != \" + (k + 1));\n-                }\n-            }\n+    @Test\n+    @IR(counts = {IRNode.REPLICATE_I,   \">0\",\n+                  IRNode.LOAD_VECTOR_I, \">0\",\n+                  IRNode.ADD_VI,        \">0\",\n+                  IRNode.STORE_VECTOR,  \">0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    public static void testBuffer(IntBuffer buffer) {\n+        for (int k = 0; k < buffer.limit(); k++) {\n+            buffer.put(k, buffer.get(k) + 1);\n@@ -165,2 +141,7 @@\n-    static class TestArrayView implements Test {\n-        final byte[] b_arr = new byte[N * Integer.BYTES];\n+    @Run(test = \"testBufferHeap\")\n+    public static void runBufferHeap() {\n+        IntBuffer buffer = ByteBuffer.allocate(N * Integer.BYTES).order(ByteOrder.nativeOrder()).asIntBuffer();\n+        initBuffer(buffer);\n+        testBufferHeap(buffer);\n+        verifyBuffer(buffer);\n+    }\n@@ -168,4 +149,18 @@\n-        public void init() {\n-            for (int k = 0; k < N; k++) {\n-                VH_arr_view.set(b_arr, k, k);\n-            }\n+    @Test\n+    @IR(counts = {IRNode.REPLICATE_I,   IRNode.VECTOR_SIZE_ANY, \">0\",\n+                  IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_ANY, \">0\",\n+                  IRNode.ADD_VI,        IRNode.VECTOR_SIZE_ANY, \">0\",\n+                  IRNode.STORE_VECTOR,                          \">0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"})\n+    \/\/ VECTOR_SIZE_ANY: Unrolling does not always seem to go far enough to reach maximum vector size.\n+    \/\/                  This looks like a BUG.\n+    \/\/ AlignVector: Buffer get\/put have an invariant that is in bytes (LoadL in ByteBufferAsIntBufferL::byteOffset).\n+    \/\/              This makes sense: we are accessing a byte buffer. But to be able to align the 4 byte ints,\n+    \/\/              we would require to know that the invariant is a multiple of 4. Without that, we cannot\n+    \/\/              guarantee alignment by adjusting the limit of the pre-loop with a stride of 4 bytes.\n+    \/\/ 64-bit: bufferHeap uses Long type for memory accesses which are not vectorized in 32-bit VM\n+    public static void testBufferHeap(IntBuffer buffer) {\n+        for (int k = 0; k < buffer.limit(); k++) {\n+            buffer.put(k, buffer.get(k) + 1);\n@@ -173,0 +168,1 @@\n+    }\n@@ -174,5 +170,14 @@\n-        public void run() {\n-            for (int k = 0; k < b_arr.length; k += 4) {\n-                int v = (int) VH_arr_view.get(b_arr, k);\n-                VH_arr_view.set(b_arr, k, v + 1);\n-            }\n+    @Run(test = \"testBufferDirect\")\n+    public static void runBufferDirect() {\n+        IntBuffer buffer = ByteBuffer.allocateDirect(N * Integer.BYTES).order(ByteOrder.nativeOrder()).asIntBuffer();\n+        initBuffer(buffer);\n+        testBufferDirect(buffer);\n+        verifyBuffer(buffer);\n+    }\n+\n+    @Test\n+    \/\/ bufferDirect uses Unsafe memory accesses which are not vectorized currently\n+    \/\/ We find a CastX2P in pointer analysis (VPointer)\n+    public static void testBufferDirect(IntBuffer buffer) {\n+        for (int k = 0; k < buffer.limit(); k++) {\n+            buffer.put(k, buffer.get(k) + 1);\n@@ -180,0 +185,1 @@\n+    }\n@@ -181,14 +187,3 @@\n-        public void verify() {\n-            init(); \/\/ reset\n-            \/\/ Save initial INT values\n-            final int[] i_arr = new int[N];\n-            for (int k = 0; k < i_arr.length; k++) {\n-                i_arr[k] = (int) VH_arr_view.get(b_arr, k * Integer.BYTES);\n-            }\n-            run();  \/\/ run compiled code\n-            for (int k = 0; k < i_arr.length; k++) {\n-                int v = (int) VH_arr_view.get(b_arr, k * Integer.BYTES);\n-                if (v != (i_arr[k] + 1)) {\n-                    throw new RuntimeException(\" Invalid result: VH_arr_view.get(b_arr, \" + (k * Integer.BYTES) + \"): \" + v + \" != \" + (i_arr[k] + 1));\n-                }\n-            }\n+    public static void initBuffer(IntBuffer buffer) {\n+        for (int k = 0; k < buffer.limit(); k++) {\n+            buffer.put(k, k);\n@@ -198,19 +193,4 @@\n-    public static void main(String[] args) {\n-        if (args.length == 0) {\n-            throw new RuntimeException(\" Missing test name: array, arrayOffset, buffer, bufferHeap, bufferDirect, arrayView\");\n-        } else if (args.length == 1) {\n-            verify_vectors(args[0]);\n-        } else {\n-            Test te = switch (args[0]) {\n-                case \"array\" -> new TestArray();\n-                case \"arrayOffset\" -> new TestArrayOffset(offset);\n-                case \"buffer\" -> new TestBuffer(buffer);\n-                case \"bufferHeap\" -> new TestBuffer(heap_buffer_byte_to_int);\n-                case \"bufferDirect\" -> new TestBuffer(direct_buffer_byte_to_int);\n-                case \"arrayView\" -> new TestArrayView();\n-                default -> throw new RuntimeException(\" Unknown test: \" + args[0]);\n-            };\n-\n-            te.init();\n-            for (int i = 0; i < ITER; i++) {\n-                te.run();\n+    public static void verifyBuffer(IntBuffer buffer) {\n+        for(int k = 0; k < buffer.limit(); k++) {\n+            if (buffer.get(k) != (k + 1)) {\n+                throw new RuntimeException(\" Invalid result: buffer.get(\" + k + \"): \" + buffer.get(k) + \" != \" + (k + 1));\n@@ -218,1 +198,0 @@\n-            te.verify();\n@@ -220,1 +199,0 @@\n-\n@@ -223,13 +201,3 @@\n-    static void verify_vectors(String testName) {\n-        ProcessBuilder pb;\n-        OutputAnalyzer out;\n-        try {\n-            pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:-BackgroundCompilation\",\n-                                                                  \"-XX:+TraceNewVectors\",\n-                                                                  \"compiler.vectorization.TestBufferVectorization\",\n-                                                                  testName,\n-                                                                  \"run\");\n-            out = new OutputAnalyzer(pb.start());\n-        } catch (Exception e) {\n-            throw new RuntimeException(\" Exception launching Java process: \" + e);\n-        }\n+    @Run(test = \"testArrayView\")\n+    public static void runArrayView() {\n+        byte[] b_arr = new byte[N * Integer.BYTES];\n@@ -237,1 +205,3 @@\n-        out.shouldHaveExitValue(0);\n+        for (int k = 0; k < N; k++) {\n+            VH_arr_view.set(b_arr, k, k);\n+        }\n@@ -239,2 +209,4 @@\n-        if (testName.equals(\"bufferDirect\")) {\n-            return; \/\/ bufferDirect uses Unsafe memory accesses which are not vectorized currently\n+        \/\/ Save initial INT values\n+        int[] i_arr = new int[N];\n+        for (int k = 0; k < i_arr.length; k++) {\n+            i_arr[k] = (int) VH_arr_view.get(b_arr, k * Integer.BYTES);\n@@ -242,0 +214,1 @@\n+        testArrayView(b_arr);\n@@ -243,2 +216,5 @@\n-        if (testName.equals(\"bufferHeap\") && (Platform.is32bit())) {\n-            return; \/\/ bufferHeap uses Long type for memory accesses which are not vectorized in 32-bit VM\n+        for (int k = 0; k < i_arr.length; k++) {\n+            int v = (int) VH_arr_view.get(b_arr, k * Integer.BYTES);\n+            if (v != (i_arr[k] + 1)) {\n+                throw new RuntimeException(\" Invalid result: VH_arr_view.get(b_arr, \" + (k * Integer.BYTES) + \"): \" + v + \" != \" + (i_arr[k] + 1));\n+            }\n@@ -246,0 +222,1 @@\n+    }\n@@ -247,4 +224,11 @@\n-        out.shouldContain(\"Replicate\");\n-        out.shouldContain(\"LoadVector\");\n-        out.shouldContain(\"AddVI\");\n-        out.shouldContain(\"StoreVector\");\n+    @Test\n+    @IR(counts = {IRNode.REPLICATE_I,   \">0\",\n+                  IRNode.LOAD_VECTOR_I, \">0\",\n+                  IRNode.ADD_VI,        \">0\",\n+                  IRNode.STORE_VECTOR,  \">0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    public static void testArrayView(byte[] b_arr) {\n+        for (int k = 0; k < b_arr.length; k += 4) {\n+            int v = (int) VH_arr_view.get(b_arr, k);\n+            VH_arr_view.set(b_arr, k, v + 1);\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestBufferVectorization.java","additions":148,"deletions":164,"binary":false,"changes":312,"status":"modified"}]}