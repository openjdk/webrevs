{"files":[{"patch":"@@ -8243,2 +8243,2 @@\n-instruct verify_vector_alignment(iRegP r, immL_positive_bitmaskI mask, rFlagsReg cr) %{\n-  match(Set r (VerifyVectorAlignment r mask));\n+instruct verify_vector_alignment(iRegP addr, immL_positive_bitmaskI mask, rFlagsReg cr) %{\n+  match(Set addr (VerifyVectorAlignment addr mask));\n@@ -8246,1 +8246,1 @@\n-  format %{ \"verify_vector_alignment $r $mask \\t! verify alignment\" %}\n+  format %{ \"verify_vector_alignment $addr $mask \\t! verify alignment\" %}\n@@ -8249,2 +8249,2 @@\n-    \/\/ check if masked bits of r are zero\n-    __ tst($r$$Register, $mask$$constant);\n+    \/\/ check if masked bits of addr are zero\n+    __ tst($addr$$Register, $mask$$constant);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -8967,2 +8967,2 @@\n-instruct verify_vector_alignment(rRegP r, immL32 mask, rFlagsReg cr) %{\n-  match(Set r (VerifyVectorAlignment r mask));\n+instruct verify_vector_alignment(rRegP addr, immL32 mask, rFlagsReg cr) %{\n+  match(Set addr (VerifyVectorAlignment addr mask));\n@@ -8970,1 +8970,1 @@\n-  format %{ \"verify_vector_alignment $r $mask \\t! verify alignment\" %}\n+  format %{ \"verify_vector_alignment $addr $mask \\t! verify alignment\" %}\n@@ -8973,2 +8973,2 @@\n-    \/\/ check if masked bits of r are zero\n-    __ testq($r$$Register, $mask$$constant);\n+    \/\/ check if masked bits of addr are zero\n+    __ testq($addr$$Register, $mask$$constant);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3695,3 +3695,3 @@\n-        jlong memory_size = n->is_LoadVector() ? n->as_LoadVector()->memory_size() :\n-                                                 n->as_StoreVector()->memory_size();\n-        \/\/ The memory access should be aligned to the vector length in bytes.\n+        jlong vector_width = n->is_LoadVector() ? n->as_LoadVector()->memory_size() :\n+                                                  n->as_StoreVector()->memory_size();\n+        \/\/ The memory access should be aligned to the vector width in bytes.\n@@ -3701,3 +3701,3 @@\n-        jlong alignment = MIN2(memory_size, (jlong)ObjectAlignmentInBytes);\n-        assert(2 <= alignment && alignment <= 64, \"alignment must be in range\");\n-        assert(is_power_of_2(alignment), \"alignment must be power of 2\");\n+        jlong guaranteed_alignment = MIN2(vector_width, (jlong)ObjectAlignmentInBytes);\n+        assert(2 <= guaranteed_alignment && guaranteed_alignment <= 64, \"alignment must be in range\");\n+        assert(is_power_of_2(guaranteed_alignment), \"alignment must be power of 2\");\n@@ -3705,1 +3705,1 @@\n-        jlong mask = alignment - 1;\n+        jlong mask = guaranteed_alignment - 1;\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -589,2 +589,3 @@\n-\/\/ This is the initial set of packs that will then be extended by\n-\/\/ following use->def and def->use links.\n+\/\/ We can find adjacent memory references by comparing their relative\n+\/\/ alignment. If the final vectors can be aligned can not yet be determined,\n+\/\/ that is only done once all vectors are extended and combined.\n@@ -623,0 +624,1 @@\n+      set_align_to_ref(align_to_mem_ref);\n@@ -669,1 +671,2 @@\n-  set_align_to_ref(align_to_mem_ref);\n+  assert(_packset.is_empty() || align_to_mem_ref != nullptr,\n+         \"packset empty or we find the alignment reference\");\n@@ -1498,0 +1501,6 @@\n+#ifdef ASSERT\n+  for (int i = 0; i < _packset.length(); i++) {\n+    assert(_packset.at(i) != nullptr, \"no nullptr in packset\");\n+  }\n+#endif\n+\n@@ -1742,5 +1751,2 @@\n-  \/\/ Trivial constants\n-  int C_const_init  = 0;\n-  int C_init  = 0;\n-  int C_invar = 0;\n-\n+  int C_const_init = 0;\n+  int C_init = 0;\n@@ -1748,0 +1754,1 @@\n+    \/\/ init is constant -> contribute init to the C_const term.\n@@ -1749,1 +1756,1 @@\n-    C_init = 0;\n+    C_init = 0; \/\/ no C_init term\n@@ -1751,1 +1758,2 @@\n-    C_const_init = 0\n+    \/\/ init is variable -> contribute init to the C_init term.\n+    C_const_init = 0;\n@@ -1755,0 +1763,1 @@\n+  int C_invar = 0;\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":19,"deletions":10,"binary":false,"changes":29,"status":"modified"}]}