{"files":[{"patch":"@@ -1612,1 +1612,1 @@\n-void print_icon_or_idx(const Node* n) {\n+void print_icon_or_idx_xxx(const Node* n) {\n@@ -1639,1 +1639,1 @@\n-  CountedLoopEndNode* pre_end = lp()->pre_loop_end();\n+  const CountedLoopEndNode* pre_end = lp()->pre_loop_end();\n@@ -1654,0 +1654,14 @@\n+  \/\/ TODO clean up args above\n+  AlignmentSolver solver(pack->at(0)->as_Mem(),\n+                         pack->size(),\n+                         mem_ref_p.base(),\n+                         mem_ref_p.offset_in_bytes(),\n+                         mem_ref_p.invar(),\n+                         mem_ref_p.invar_factor(),\n+                         mem_ref_p.scale_in_bytes(),\n+                         pre_end->init_trip(),\n+                         pre_end->stride_con(),\n+                         iv_stride()\n+                         DEBUG_ONLY(COMMA is_trace_align_vector()));\n+  solver.solve();\n+\n@@ -1677,1 +1691,1 @@\n-    print_icon_or_idx(init_node);\n+    print_icon_or_idx_xxx(init_node);\n@@ -1683,1 +1697,1 @@\n-    print_icon_or_idx(base);\n+    print_icon_or_idx_xxx(base);\n@@ -1685,1 +1699,1 @@\n-    print_icon_or_idx(invar);\n+    print_icon_or_idx_xxx(invar);\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -228,192 +228,0 @@\n-\/\/ When alignment is required, we must adjust the pre-loop iteration count pre_iter.\n-\/\/ We find the set of pre_iter which guarantee alignment:\n-\/\/\n-\/\/ TODO restate this a bit with since I changed the new proof!\n-\/\/\n-\/\/   pre_iter = pre_r + pre_q * m  (for any m >= 0)\n-\/\/\n-\/\/ Such that the address is aligned for any main_iter >= 0:\n-\/\/\n-\/\/   adr = base + offset + invar + scale * init\n-\/\/                               + scale * pre_stride * pre_iter\n-\/\/                               + scale * main_stride * main_iter\n-\/\/\n-\/\/ Two simplifying restrictions:\n-\/\/   1. In the presence of variable init, all solutions must have the same scale.\n-\/\/   2. In the presence of an invariant, all solutions must have the same invariant\n-\/\/      and the same scale.\n-\/\/\n-\/\/ A solution can be:\n-\/\/   1. Invalid with a failure reason.\n-\/\/   2. Trivial (any pre-loop limit guarantees alignment).\n-\/\/   3. Constrained (r, q, mem_ref, alignment_width, scale, invar)\n-\/\/        Where scale is 0 if no scale dependency,\n-\/\/        and invar is nullptr if no invar dependency.\n-class AlignmentSolution {\n-private:\n-  bool _valid = false;\n-  const char* _reason = nullptr;\n-  bool _trivial = true;\n-  int _r = 0;\n-  int _q = 1;\n-  const MemNode* _mem_ref = nullptr;\n-  int _alignment_width = 0;\n-  Node const* _invar_dependency = nullptr;\n-  int _scale_dependency = 0;\n-\n-public:\n-  \/\/ Invalid solution.\n-  AlignmentSolution(const char* reason) :\n-      _valid(false),\n-      _reason(reason),\n-      _trivial(false),\n-      _r(0),\n-      _q(1),\n-      _mem_ref(nullptr),\n-      _alignment_width(1),\n-      _invar_dependency(nullptr),\n-      _scale_dependency(0) {\n-    assert(!is_trivial() && !is_valid(), \"must be invalid\");\n-  }\n-\n-  \/\/ Trivial Solution.\n-  AlignmentSolution() :\n-      _valid(true),\n-      _reason(nullptr),\n-      _trivial(true),\n-      _r(0),\n-      _q(1),\n-      _mem_ref(nullptr),\n-      _alignment_width(1),\n-      _invar_dependency(nullptr),\n-      _scale_dependency(0) {\n-    assert(is_trivial() && is_valid(), \"must be trivial\");\n-  }\n-\n-  \/\/ Constrained solution.\n-  AlignmentSolution(const int r,\n-                    const int q,\n-                    const MemNode* mem_ref,\n-                    int alignment_width,\n-                    const Node* invar_dependency,\n-                    int scale_dependency) :\n-      _valid(true),\n-      _reason(nullptr),\n-      _trivial(false),\n-      _r(r),\n-      _q(q),\n-      _mem_ref(mem_ref),\n-      _alignment_width(alignment_width),\n-      _invar_dependency(invar_dependency),\n-      _scale_dependency(scale_dependency) {\n-    assert(q > 1 && is_power_of_2(q), \"q must be power of 2\");\n-    assert(0 <= r && r < q, \"r must be in modulo space of q\");\n-    assert(!is_trivial() && is_valid(), \"must be constrained\");\n-    assert(_mem_ref != nullptr &&\n-           _mem_ref->memory_size() <= _alignment_width,\n-           \"must have mem_ref and alignment_width\");\n-    assert(alignment_width > 0 &&\n-           is_power_of_2(alignment_width),\n-           \"alignment_width must be power of 2\");\n-  }\n-\n-  bool is_valid() const   { return _valid; }\n-  bool is_trivial() const { return _trivial; }\n-\n-  const char* reason() const {\n-    assert(!is_valid(), \"only invalid has reason\");\n-    return _reason;\n-  }\n-\n-  int r() const {\n-    assert(is_valid(), \"only valid has solution\");\n-    return _r;\n-  }\n-\n-  int q() const {\n-    assert(is_valid(), \"only valid has solution\");\n-    return _q;\n-  }\n-\n-  const MemNode* mem_ref() const {\n-    assert(is_valid(), \"valid and not trivial\");\n-    return _mem_ref;\n-  }\n-\n-  int alignment_width() const {\n-    assert(is_valid() && !is_trivial(), \"valid and not trivial\");\n-    return _alignment_width;\n-  }\n-\n-  const Node* invar_dependency() const {\n-    assert(is_valid() && !is_trivial(), \"valid and not trivial\");\n-    return _invar_dependency;\n-  }\n-\n-  int scale_dependency() const {\n-    assert(is_valid() && !is_trivial(), \"valid and not trivial\");\n-    return _scale_dependency;\n-  }\n-\n-  AlignmentSolution filter(const AlignmentSolution& other) const {\n-    \/\/ Solution invalid if either is invalid.\n-    if (!is_valid() || !other.is_valid()) {\n-      return AlignmentSolution(\"invalid solution input to filter\");\n-    }\n-    AlignmentSolution s1 = *this;\n-    AlignmentSolution s2 = other;\n-\n-    \/\/ If one is trivial, return the other.\n-    if (s1.is_trivial()) { return s2; }\n-    if (s2.is_trivial()) { return s1; }\n-\n-    \/\/ Combine two constrained solutions.\n-    if (s1.invar_dependency() != s2.invar_dependency()) {\n-      return AlignmentSolution(\"invar not identical\");\n-    }\n-    if (s1.scale_dependency() != s2.scale_dependency()) {\n-      return AlignmentSolution(\"different scale dependency (init \/ invar)\");\n-    }\n-    \/\/ Make s2 the bigger modulo space\n-    if (s1.q() > s2.q()) {\n-      swap(s1, s2);\n-    }\n-    assert(s1.q() <= s2.q(), \"s1 is a smaller modulo space than s2\");\n-    \/\/ Subset check:\n-    if (mod(s2.r(), s1.q()) != s1.r()) {\n-      \/\/ neither is subset of the other -> no intersection\n-      return AlignmentSolution(\"empty intersection (r and q)\");\n-    }\n-    \/\/ Now we know: \"s1 = r1 + m1 * q1\" is a superset of \"s2 = r2 + m2 * q2\"\n-    return s2; \/\/ return the subset\n-  }\n-\n-  void print() {\n-    if (is_valid()) {\n-      if (is_trivial()) {\n-        tty->print_cr(\"pre_iter >= 0 (trivial)\");\n-      } else {\n-        tty->print(\"pre_r(%d) + m * pre_q(%d), mem_ref[%d] %% alignment_width(%d),\",\n-                    r(), q(), mem_ref()->_idx, alignment_width());\n-        tty->print(\" scale = %d, \", scale_dependency());\n-        if (invar_dependency() == nullptr) {\n-          tty->print_cr(\"no invar\");\n-        } else {\n-          tty->print_cr(\"invar[%d]\", invar_dependency()->_idx);\n-        }\n-      }\n-    } else {\n-      tty->print_cr(\"no solution: %s\", reason());\n-    }\n-  }\n-\n-  \/\/ Compute modulo and ensure that we get a positive remainder\n-  static int mod(int i, int q) {\n-    assert(q >= 1, \"modulo value must be large enough\");\n-    int r = i % q;\n-    r = (r >= 0) ? r : r + q;\n-    assert(0 <= r && r < q, \"remainder must fit in modulo space\");\n-    return r;\n-  }\n-};\n-\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":0,"deletions":192,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -705,0 +705,186 @@\n+#endif\n+\n+AlignmentSolution AlignmentSolver::solve() const {\n+  DEBUG_ONLY( trace_start_solve(); )\n+\n+  \/\/ Out of simplicity: non power-of-2 stride not supported.\n+  if (!is_power_of_2(abs(_pre_stride))) {\n+    return AlignmentSolution(\"non power-of-2 stride not supported\");\n+  }\n+  assert(is_power_of_2(abs(_main_stride)), \"main_stride is power of 2\");\n+  assert(_aw > 0 && is_power_of_2(_aw), \"aw must be power of 2\");\n+\n+  \/\/ Out of simplicity: non power-of-2 scale not supported.\n+  if (abs(_scale) == 0 || !is_power_of_2(abs(_scale))) {\n+    return AlignmentSolution(\"non power-of-2 scale not supported\");\n+  }\n+\n+  \/\/ We analyze the address of mem_ref. The idea is to disassemble it into a linear\n+  \/\/ expression, where we can use the constant factors as the basis for ensuring the\n+  \/\/ alignment of vector memory accesses.\n+  \/\/\n+  \/\/ The Simple form of the address is disassembled by VPointer into:\n+  \/\/\n+  \/\/   adr = base + offset + invar + scale * iv\n+  \/\/\n+  \/\/ Where the iv can be written as:\n+  \/\/\n+  \/\/   iv = init + pre_stride * pre_iter + main_stride * main_iter\n+  \/\/\n+  \/\/ init:        value before pre-loop\n+  \/\/ pre_stride:  increment per pre-loop iteration\n+  \/\/ pre_iter:    number of pre-loop iterations (adjustable via pre-loop limit)\n+  \/\/ main_stride: increment per main-loop iteration (= pre_stride * unroll_factor)\n+  \/\/ main_iter:   number of main-loop iterations (main_iter >= 0)\n+  \/\/\n+  \/\/ In the following, we restate the simple form of the address expression, by first\n+  \/\/ expanding the iv variable. In a second step, we reshape the expression again, and\n+  \/\/ state it as a linear expression, consisting of 6 terms.\n+  \/\/\n+  \/\/          Simple form           Expansion of iv variable                  Reshaped with constants   Comments for terms\n+  \/\/          -----------           ------------------------                  -----------------------   ------------------\n+  \/\/   adr =  base               =  base                                   =  base                      (base % aw = 0)\n+  \/\/        + offset              + offset                                  + C_const                   (sum of constant terms)\n+  \/\/        + invar               + invar_factor * var_invar                + C_invar * var_invar       (term for invariant)\n+  \/\/                          \/   + scale * init                            + C_init  * var_init        (term for variable init)\n+  \/\/        + scale * iv   -> |   + scale * pre_stride * pre_iter           + C_pre   * pre_iter        (adjustable pre-loop term)\n+  \/\/                          \\   + scale * main_stride * main_iter         + C_main  * main_iter       (main-loop term)\n+  \/\/\n+  \/\/ We describe the 6 terms:\n+  \/\/   1) The \"base\" of the address is the address of a Java object (e.g. array),\n+  \/\/      and hence can be assumed to already be aw-aligned (base % aw = 0).\n+  \/\/   2) The \"C_const\" term is the sum of all constant terms. This is \"offset\",\n+  \/\/      plus \"init\" if it is constant.\n+  \/\/   3) The \"C_invar * var_invar\" is the factorization of \"invar\" into a constant\n+  \/\/      and variable term. If there is no invariant, then \"C_invar\" is zero.\n+  \/\/   4) The \"C_init * var_init\" is the factorization of \"scale * init\" into a\n+  \/\/      constant and a variable term. If \"init\" is constant, then \"C_init\" is\n+  \/\/      zero, and \"C_const\" accounts for \"init\" instead.\n+  \/\/   5) The \"C_pre * pre_iter\" term represents how much the iv is incremented\n+  \/\/      during the \"pre_iter\" pre-loop iterations. This term can be adjusted\n+  \/\/      by changing the pre-loop limit, which defines how many pre-loop iterations\n+  \/\/      are executed. This allows us to adjust the alignment of the main-loop\n+  \/\/      memory reference.\n+  \/\/   6) The \"C_main * main_iter\" term represents how much the iv is increased\n+  \/\/      during \"main_iter\" main-loop iterations.\n+\n+  \/\/ Attribute init either to C_const or to C_init term.\n+  const int C_const_init = _init_node->is_ConI() ? _init_node->as_ConI()->get_int() : 0;\n+  const int C_init =       _init_node->is_ConI() ? 0                                : _scale;\n+\n+  \/\/ Set C_invar depending on if invar is present\n+  const int C_invar = (_invar == nullptr) ? 0 : abs(_invar_factor);\n+\n+  const int C_const = _offset + C_const_init * _scale;\n+  const int C_pre = _scale * _pre_stride;\n+  const int C_main = _scale * _main_stride;\n+\n+  DEBUG_ONLY( trace_reshaped_form(C_const, C_const_init, C_invar, C_init, C_pre, C_main); )\n+\n+  \/\/ We must find a pre_iter, such that adr is aw aligned: adr % aw = 0.\n+  \/\/ Since \"base % aw = 0\", we only need to ensure alignment of the other 5 terms:\n+  \/\/\n+  \/\/   (C_const + C_invar * var_invar + C_init * var_init + C_pre * pre_iter + C_main * main_iter) % aw = 0      (1)\n+  \/\/\n+  \/\/ Alignment must be maintained over all main-loop iterations, i.e. for any main_iter >= 0, we require:\n+  \/\/\n+  \/\/   C_main % aw = 0                                                                                           (2*)\n+  \/\/\n+  const int C_main_mod_aw = AlignmentSolution::mod(C_main, _aw);\n+\n+  DEBUG_ONLY( trace_main_iteration_alignment(C_const, C_invar, C_init, C_pre, C_main, C_main_mod_aw); )\n+\n+  if (C_main_mod_aw != 0) {\n+    return AlignmentSolution(\"EQ(2*) not satisfied (cannot align across main-loop iterations)\");\n+  }\n+\n+  \/\/ In what follows, we need to show that the C_const, init and invar terms can be aligned by\n+  \/\/ adjusting the pre-loop limit (pre_iter). We decompose pre_iter:\n+  \/\/\n+  \/\/   pre_iter = pre_iter_C_const + pre_iter_C_invar + pre_iter_C_init\n+  \/\/\n+  \/\/ where pre_iter_C_const, pre_iter_C_invar, and pre_iter_C_init are defined as the number of\n+  \/\/ pre-loop iterations required to align the C_const, init and invar terms individually.\n+  \/\/ Hence, we can rewrite:\n+  \/\/\n+  \/\/     (C_const + C_invar * var_invar + C_init * var_init + C_pre * pre_iter) % aw\n+  \/\/   = ( C_const             + C_pre * pre_iter_C_const\n+  \/\/     + C_invar * var_invar + C_pre * pre_iter_C_invar\n+  \/\/     + C_init  * var_init  + C_pre * pre_iter_C_init ) % aw\n+  \/\/   = 0                                                                       (3)\n+  \/\/\n+  \/\/ We strengthen the constraints by splitting the equation into 3 equations, where the C_const,\n+  \/\/ init, and invar term are aligned individually:\n+  \/\/\n+  \/\/   (C_init  * var_init  + C_pre * pre_iter_C_init ) % aw = 0                 (4a)\n+  \/\/   (C_invar * var_invar + C_pre * pre_iter_C_invar) % aw = 0                 (4b)\n+  \/\/   (C_const             + C_pre * pre_iter_C_const) % aw = 0                 (4c)\n+  \/\/\n+  \/\/ We can only guarantee solutions to (4a) and (4b) if:\n+  \/\/\n+  \/\/   C_init  % abs(C_pre) = 0                                                  (5a*)\n+  \/\/   C_invar % abs(C_pre) = 0                                                  (5b*)\n+  \/\/\n+  \/\/ Which means there are X and Y such that:\n+  \/\/\n+  \/\/   C_init  = C_pre * X       (X = 0 if C_init  = 0, else X = C_init  \/ C_pre)\n+  \/\/   C_invar = C_pre * Y       (Y = 0 if C_invar = 0, else Y = C_invar \/ C_pre)\n+  \/\/\n+  \/\/   (C_init    * var_init  + C_pre * pre_iter_C_init ) % aw =\n+  \/\/   (C_pre * X * var_init  + C_pre * pre_iter_C_init ) % aw =\n+  \/\/   (C_pre * (X * var_init  + pre_iter_C_init)       ) % aw = 0\n+  \/\/\n+  \/\/   (C_invar   * var_invar + C_pre * pre_iter_C_invar) % aw =\n+  \/\/   (C_pre * Y * var_invar + C_pre * pre_iter_C_invar) % aw =\n+  \/\/   (C_pre * (Y * var_invar + pre_iter_C_invar)      ) % aw = 0\n+  \/\/\n+  \/\/ And hence, we know that there are solutions for pre_iter_C_init and pre_iter_C_invar,\n+  \/\/ based on X, Y, var_init, and var_invar. We call them:\n+  \/\/\n+  \/\/   pre_iter_C_init  = alignment_init (X * var_init)\n+  \/\/   pre_iter_C_invar = alignment_invar(Y * var_invar)\n+  \/\/\n+  const int C_init_mod_abs_C_pre  = AlignmentSolution::mod(C_init,  abs(C_pre));\n+  const int C_invar_mod_abs_C_pre = AlignmentSolution::mod(C_invar, abs(C_pre));\n+\n+  DEBUG_ONLY( trace_init_and_invar_alignment(C_invar, C_init, C_pre, C_invar_mod_abs_C_pre, C_init_mod_abs_C_pre); )\n+\n+\n+\n+\n+  \/\/ TODO continue\n+  return AlignmentSolution(\"TOOD remove me\");\n+}\n+\n+#ifdef ASSERT\n+void print_icon_or_idx(const Node* n) {\n+  if (n == nullptr) {\n+    tty->print(\"(0)\");\n+  } else if (n->is_ConI()) {\n+    jint val = n->as_ConI()->get_int();\n+    tty->print(\"(%d)\", val);\n+  } else {\n+    tty->print(\"[%d]\", n->_idx);\n+  }\n+}\n+\n+void AlignmentSolver::trace_start_solve() const {\n+  if (is_trace()) {\n+    tty->print(\" vector mem_ref:\");\n+    _mem_ref->dump();\n+    tty->print_cr(\"  vector_width = vector_length(%d) * element_size(%d) = %d\",\n+                  _vector_length, _element_size, _vector_width);\n+    tty->print_cr(\"  aw = alignment_width = min(vector_width(%d), ObjectAlignmentInBytes(%d)) = %d\",\n+                  _vector_width, ObjectAlignmentInBytes, _aw);\n+\n+    if (!_init_node->is_ConI()) {\n+      tty->print(\"  init:\");\n+      _init_node->dump();\n+    }\n+\n+    if (_invar != nullptr) {\n+      tty->print(\"  invar:\");\n+      _invar->dump();\n+    }\n+\n+    tty->print_cr(\"  invar_factor = %d\", _invar_factor);\n@@ -706,0 +892,83 @@\n+    \/\/ iv = init + pre_iter * pre_stride + main_iter * main_stride\n+    tty->print(\"  iv = init\");\n+    print_icon_or_idx(_init_node);\n+    tty->print_cr(\" + pre_iter * pre_stride(%d) + main_iter * main_stride(%d)\",\n+                  _pre_stride, _main_stride);\n+\n+    \/\/ adr = base + offset + invar + scale * iv\n+    tty->print(\"  adr = base\");\n+    print_icon_or_idx(_base);\n+    tty->print(\" + offset(%d) + invar\", _offset);\n+    print_icon_or_idx(_invar);\n+    tty->print_cr(\" + scale(%d) * iv\", _scale);\n+  }\n+}\n+\n+void AlignmentSolver::trace_reshaped_form(const int C_const,\n+                                          const int C_const_init,\n+                                          const int C_invar,\n+                                          const int C_init,\n+                                          const int C_pre,\n+                                          const int C_main) const\n+{\n+  if (is_trace()) {\n+    tty->print(\"      = base[%d] + \", _base->_idx);\n+    tty->print_cr(\"C_const(%d) + C_invar(%d) * var_invar + C_init(%d) * var_init + C_pre(%d) * pre_iter + C_main(%d) * main_iter\",\n+                  C_const, C_invar, C_init,  C_pre, C_main);\n+    if (_init_node->is_ConI()) {\n+      tty->print_cr(\"  init is constant:\");\n+      tty->print_cr(\"    C_const_init = %d\", C_const_init);\n+      tty->print_cr(\"    C_init = %d\", C_init);\n+    } else {\n+      tty->print_cr(\"  init is variable:\");\n+      tty->print_cr(\"    C_const_init = %d\", C_const_init);\n+      tty->print_cr(\"    C_init = abs(scale)= %d\", C_init);\n+    }\n+    if (_invar != nullptr) {\n+      tty->print_cr(\"  invariant present:\");\n+      tty->print_cr(\"    C_invar = abs(invar_factor) = %d\", C_invar);\n+    } else {\n+      tty->print_cr(\"  no invariant:\");\n+      tty->print_cr(\"    C_invar = %d\", C_invar);\n+    }\n+    tty->print_cr(\"  C_const = offset(%d) + scale(%d) * C_const_init(%d) = %d\",\n+                  _offset, _scale, C_const_init, C_const);\n+    tty->print_cr(\"  C_pre   = scale(%d) * pre_stride(%d) = %d\",\n+                  _scale, _pre_stride, C_pre);\n+    tty->print_cr(\"  C_main  = scale(%d) * main_stride(%d) = %d\",\n+                  _scale, _main_stride, C_main);\n+  }\n+}\n+\n+void AlignmentSolver::trace_main_iteration_alignment(const int C_const,\n+                                                     const int C_invar,\n+                                                     const int C_init,\n+                                                     const int C_pre,\n+                                                     const int C_main,\n+                                                     const int C_main_mod_aw) const\n+{\n+  if (is_trace()) {\n+    tty->print(\"  EQ(1  ): (C_const(%d) + C_invar(%d) * var_invar + C_init(%d) * var_init\",\n+                  C_const, C_invar, C_init);\n+    tty->print(\" + C_pre(%d) * pre_iter + C_main(%d) * main_iter) %% aw(%d) = 0\",\n+                  C_pre, C_main, _aw);\n+    tty->print_cr(\" (given base aligned -> align rest)\");\n+    tty->print(\"  EQ(2* ): C_main(%d) %% aw(%d) = %d = 0\",\n+               C_main, _aw, C_main_mod_aw);\n+    tty->print_cr(\" (alignment across iterations)\");\n+  }\n+}\n+\n+void AlignmentSolver::trace_init_and_invar_alignment(const int C_invar,\n+                                                     const int C_init,\n+                                                     const int C_pre,\n+                                                     const int C_invar_mod_abs_C_pre,\n+                                                     const int C_init_mod_abs_C_pre) const\n+{\n+  if (is_trace()) {\n+    tty->print_cr(\"  EQ(5a*): C_init(%d) %% abs(C_pre(%d)) = %d = 0   (if false: cannot align init)\",\n+                  C_init, C_pre, C_init_mod_abs_C_pre);\n+    tty->print_cr(\"  EQ(5b*): C_invar(%d) %% abs(C_pre(%d)) = %d = 0  (if false: cannot align invar)\",\n+                  C_invar, C_pre, C_invar_mod_abs_C_pre);\n+  }\n+}\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":269,"deletions":0,"binary":false,"changes":269,"status":"modified"},{"patch":"@@ -266,0 +266,294 @@\n+\/\/ When alignment is required, we must adjust the pre-loop iteration count pre_iter.\n+\/\/ We find the set of pre_iter which guarantee alignment:\n+\/\/\n+\/\/ TODO restate this a bit with since I changed the new proof!\n+\/\/\n+\/\/   pre_iter = pre_r + pre_q * m  (for any m >= 0)\n+\/\/\n+\/\/ Such that the address is aligned for any main_iter >= 0:\n+\/\/\n+\/\/   adr = base + offset + invar + scale * init\n+\/\/                               + scale * pre_stride * pre_iter\n+\/\/                               + scale * main_stride * main_iter\n+\/\/\n+\/\/ Two simplifying restrictions:\n+\/\/   1. In the presence of variable init, all solutions must have the same scale.\n+\/\/   2. In the presence of an invariant, all solutions must have the same invariant\n+\/\/      and the same scale.\n+\/\/\n+\/\/ A solution can be:\n+\/\/   1. Invalid with a failure reason.\n+\/\/   2. Trivial (any pre-loop limit guarantees alignment).\n+\/\/   3. Constrained (r, q, mem_ref, alignment_width, scale, invar)\n+\/\/        Where scale is 0 if no scale dependency,\n+\/\/        and invar is nullptr if no invar dependency.\n+class AlignmentSolution {\n+private:\n+  bool _valid = false;\n+  const char* _reason = nullptr;\n+  bool _trivial = true;\n+  int _r = 0;\n+  int _q = 1;\n+  const MemNode* _mem_ref = nullptr;\n+  int _alignment_width = 0;\n+  Node const* _invar_dependency = nullptr;\n+  int _scale_dependency = 0;\n+\n+public:\n+  \/\/ Invalid solution.\n+  AlignmentSolution(const char* reason) :\n+      _valid(false),\n+      _reason(reason),\n+      _trivial(false),\n+      _r(0),\n+      _q(1),\n+      _mem_ref(nullptr),\n+      _alignment_width(1),\n+      _invar_dependency(nullptr),\n+      _scale_dependency(0) {\n+    assert(!is_trivial() && !is_valid(), \"must be invalid\");\n+  }\n+\n+  \/\/ Trivial Solution.\n+  AlignmentSolution() :\n+      _valid(true),\n+      _reason(nullptr),\n+      _trivial(true),\n+      _r(0),\n+      _q(1),\n+      _mem_ref(nullptr),\n+      _alignment_width(1),\n+      _invar_dependency(nullptr),\n+      _scale_dependency(0) {\n+    assert(is_trivial() && is_valid(), \"must be trivial\");\n+  }\n+\n+  \/\/ Constrained solution.\n+  AlignmentSolution(const int r,\n+                    const int q,\n+                    const MemNode* mem_ref,\n+                    int alignment_width,\n+                    const Node* invar_dependency,\n+                    int scale_dependency) :\n+      _valid(true),\n+      _reason(nullptr),\n+      _trivial(false),\n+      _r(r),\n+      _q(q),\n+      _mem_ref(mem_ref),\n+      _alignment_width(alignment_width),\n+      _invar_dependency(invar_dependency),\n+      _scale_dependency(scale_dependency) {\n+    assert(q > 1 && is_power_of_2(q), \"q must be power of 2\");\n+    assert(0 <= r && r < q, \"r must be in modulo space of q\");\n+    assert(!is_trivial() && is_valid(), \"must be constrained\");\n+    assert(_mem_ref != nullptr &&\n+           _mem_ref->memory_size() <= _alignment_width,\n+           \"must have mem_ref and alignment_width\");\n+    assert(alignment_width > 0 &&\n+           is_power_of_2(alignment_width),\n+           \"alignment_width must be power of 2\");\n+  }\n+\n+  bool is_valid() const   { return _valid; }\n+  bool is_trivial() const { return _trivial; }\n+\n+  const char* reason() const {\n+    assert(!is_valid(), \"only invalid has reason\");\n+    return _reason;\n+  }\n+\n+  int r() const {\n+    assert(is_valid(), \"only valid has solution\");\n+    return _r;\n+  }\n+\n+  int q() const {\n+    assert(is_valid(), \"only valid has solution\");\n+    return _q;\n+  }\n+\n+  const MemNode* mem_ref() const {\n+    assert(is_valid(), \"valid and not trivial\");\n+    return _mem_ref;\n+  }\n+\n+  int alignment_width() const {\n+    assert(is_valid() && !is_trivial(), \"valid and not trivial\");\n+    return _alignment_width;\n+  }\n+\n+  const Node* invar_dependency() const {\n+    assert(is_valid() && !is_trivial(), \"valid and not trivial\");\n+    return _invar_dependency;\n+  }\n+\n+  int scale_dependency() const {\n+    assert(is_valid() && !is_trivial(), \"valid and not trivial\");\n+    return _scale_dependency;\n+  }\n+\n+  AlignmentSolution filter(const AlignmentSolution& other) const {\n+    \/\/ Solution invalid if either is invalid.\n+    if (!is_valid() || !other.is_valid()) {\n+      return AlignmentSolution(\"invalid solution input to filter\");\n+    }\n+    AlignmentSolution s1 = *this;\n+    AlignmentSolution s2 = other;\n+\n+    \/\/ If one is trivial, return the other.\n+    if (s1.is_trivial()) { return s2; }\n+    if (s2.is_trivial()) { return s1; }\n+\n+    \/\/ Combine two constrained solutions.\n+    if (s1.invar_dependency() != s2.invar_dependency()) {\n+      return AlignmentSolution(\"invar not identical\");\n+    }\n+    if (s1.scale_dependency() != s2.scale_dependency()) {\n+      return AlignmentSolution(\"different scale dependency (init \/ invar)\");\n+    }\n+    \/\/ Make s2 the bigger modulo space\n+    if (s1.q() > s2.q()) {\n+      swap(s1, s2);\n+    }\n+    assert(s1.q() <= s2.q(), \"s1 is a smaller modulo space than s2\");\n+    \/\/ Subset check:\n+    if (mod(s2.r(), s1.q()) != s1.r()) {\n+      \/\/ neither is subset of the other -> no intersection\n+      return AlignmentSolution(\"empty intersection (r and q)\");\n+    }\n+    \/\/ Now we know: \"s1 = r1 + m1 * q1\" is a superset of \"s2 = r2 + m2 * q2\"\n+    return s2; \/\/ return the subset\n+  }\n+\n+  void print() {\n+    if (is_valid()) {\n+      if (is_trivial()) {\n+        tty->print_cr(\"pre_iter >= 0 (trivial)\");\n+      } else {\n+        tty->print(\"pre_r(%d) + m * pre_q(%d), mem_ref[%d] %% alignment_width(%d),\",\n+                    r(), q(), mem_ref()->_idx, alignment_width());\n+        tty->print(\" scale = %d, \", scale_dependency());\n+        if (invar_dependency() == nullptr) {\n+          tty->print_cr(\"no invar\");\n+        } else {\n+          tty->print_cr(\"invar[%d]\", invar_dependency()->_idx);\n+        }\n+      }\n+    } else {\n+      tty->print_cr(\"no solution: %s\", reason());\n+    }\n+  }\n+\n+  \/\/ Compute modulo and ensure that we get a positive remainder\n+  static int mod(int i, int q) {\n+    assert(q >= 1, \"modulo value must be large enough\");\n+    int r = i % q;\n+    r = (r >= 0) ? r : r + q;\n+    assert(0 <= r && r < q, \"remainder must fit in modulo space\");\n+    return r;\n+  }\n+};\n+\n+\/\/ TODO description\n+class AlignmentSolver {\n+private:\n+  const MemNode* _mem_ref;       \/\/ first element\n+  const uint     _vector_length; \/\/ number of elements in vector\n+  const int      _element_size;\n+  const int      _vector_width;  \/\/ in bytes\n+\n+  \/\/ All vector loads and stores need to be memory aligned. The alignment width (aw) in\n+  \/\/ principle is the vector_width. But when vector_width > ObjectAlignmentInBytes this is\n+  \/\/ too strict, since any memory object is only guaranteed to be ObjectAlignmentInBytes\n+  \/\/ aligned. For example, the relative offset between two arrays is only guaranteed to\n+  \/\/ be divisible by ObjectAlignmentInBytes.\n+  const int      _aw;\n+\n+  \/\/ We analyze the address of mem_ref. The idea is to disassemble it into a linear\n+  \/\/ expression, where we can use the constant factors as the basis for ensuring the\n+  \/\/ alignment of vector memory accesses.\n+  \/\/\n+  \/\/ The Simple form of the address is disassembled by VPointer into:\n+  \/\/\n+  \/\/   adr = base + offset + invar + scale * iv\n+  \/\/\n+  \/\/ Where the iv can be written as:\n+  \/\/\n+  \/\/   iv = init + pre_stride * pre_iter + main_stride * main_iter\n+  \/\/\n+  \/\/ pre_iter:    number of pre-loop iterations (adjustable via pre-loop limit)\n+  \/\/ main_iter:   number of main-loop iterations (main_iter >= 0)\n+  \/\/\n+  const Node*    _base;           \/\/ base of address (e.g. Java array object, aw-aligned)\n+  const int      _offset;\n+  const Node*    _invar;\n+  const int      _invar_factor;   \/\/ known constant factor of invar\n+  const int      _scale;\n+  const Node*    _init_node;      \/\/ value of iv before pre-loop\n+  const int      _pre_stride;     \/\/ address increment per pre-loop iteration\n+  const int      _main_stride;    \/\/ address increment per main-loop iteration\n+\n+  DEBUG_ONLY( const bool _is_trace; );\n+\n+public:\n+  AlignmentSolver(const MemNode* mem_ref,\n+                  const uint vector_length,\n+                  const Node* base,\n+                  const int offset,\n+                  const Node* invar,\n+                  const int invar_factor,\n+                  const int scale,\n+                  const Node* init_node,\n+                  const int pre_stride,\n+                  const int main_stride\n+                  DEBUG_ONLY( COMMA const bool is_trace)\n+                  ) :\n+      _mem_ref(           mem_ref),\n+      _vector_length(     vector_length),\n+      _element_size(      mem_ref->memory_size()),\n+      _vector_width(      _vector_length * _element_size),\n+      _aw(                MIN2(_vector_width, ObjectAlignmentInBytes)),\n+      _base(              base),\n+      _offset(            offset),\n+      _invar(             invar),\n+      _invar_factor(      invar_factor),\n+      _scale(             scale),\n+      _init_node(         init_node),\n+      _pre_stride(        pre_stride),\n+      _main_stride(       main_stride)\n+      DEBUG_ONLY( COMMA _is_trace(is_trace) )\n+  {\n+    assert(_mem_ref != nullptr &&\n+           (_mem_ref->is_Load() || _mem_ref->is_Store()),\n+           \"only load or store vectors allowed\");\n+  }\n+\n+  AlignmentSolution solve() const;\n+\n+private:\n+#ifdef ASSERT\n+  bool is_trace() const { return _is_trace; }\n+  void trace_start_solve() const;\n+  void trace_reshaped_form(const int C_const,\n+                           const int C_const_init,\n+                           const int C_invar,\n+                           const int C_init,\n+                           const int C_pre,\n+                           const int C_main) const;\n+  void trace_main_iteration_alignment(const int C_const,\n+                                      const int C_invar,\n+                                      const int C_init,\n+                                      const int C_pre,\n+                                      const int C_main,\n+                                      const int C_main_mod_aw) const;\n+  void trace_init_and_invar_alignment(const int C_invar,\n+                                      const int C_init,\n+                                      const int C_pre,\n+                                      const int C_invar_mod_abs_C_pre,\n+                                      const int C_init_mod_abs_C_pre) const;\n+\n+\n+#endif\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":294,"deletions":0,"binary":false,"changes":294,"status":"modified"}]}