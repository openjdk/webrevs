{"files":[{"patch":"@@ -1624,5 +1624,5 @@\n-  uint psize       = p->size();\n-  MemNode* mem_ref = p->at(0)->as_Mem();\n-  int esize        = mem_ref->memory_size();\n-  int vw           = psize * esize;\n-  int aw           = MIN2(vw, ObjectAlignmentInBytes);\n+  uint pack_size    = p->size();\n+  MemNode* mem_ref  = p->at(0)->as_Mem();\n+  int element_size  = mem_ref->memory_size();\n+  int vw            = pack_size * element_size;         \/\/ vector_width\n+  int aw            = MIN2(vw, ObjectAlignmentInBytes); \/\/ alignment_width\n@@ -1632,5 +1632,5 @@\n-  int pre_stride   = pre_end->stride_con();\n-  int unroll       = _lp->unrolled_count();\n-  int main_stride  = iv_stride();\n-  Node* init_node  = pre_end->init_trip();\n-  assert(pre_stride * unroll == main_stride, \"unrolled stride must be consistent\");\n+  int pre_stride    = pre_end->stride_con();\n+  int unroll_factor = _lp->unrolled_count();\n+  int main_stride   = iv_stride();\n+  Node* init_node   = pre_end->init_trip();\n+  assert(pre_stride * unroll_factor == main_stride, \"unrolled stride must be consistent\");\n@@ -1639,5 +1639,5 @@\n-  int scale        = mem_ref_p.scale_in_bytes();\n-  int offset       = mem_ref_p.offset_in_bytes();\n-  Node* base       = mem_ref_p.base();\n-  Node* invar      = mem_ref_p.invar();\n-  int invar_factor = mem_ref_p.invar_factor();\n+  int scale         = mem_ref_p.scale_in_bytes();\n+  int offset        = mem_ref_p.offset_in_bytes();\n+  Node* base        = mem_ref_p.base();\n+  Node* invar       = mem_ref_p.invar();\n+  int invar_factor  = mem_ref_p.invar_factor();\n@@ -1649,2 +1649,2 @@\n-    tty->print_cr(\"  vw = psize(%d) * esize(%d) = %d\", psize, esize, vw);\n-    tty->print_cr(\"  aw = min(vw(%d), ObjectAlignmentInBytes(%d)) = %d\",\n+    tty->print_cr(\"  vw = vector_width    = pack_size(%d) * element_size(%d) = %d\", pack_size, element_size, vw);\n+    tty->print_cr(\"  aw = alignment_width = min(vw(%d), ObjectAlignmentInBytes(%d)) = %d\",\n@@ -1685,1 +1685,1 @@\n-  assert(is_power_of_2(unroll), \"unroll factor is power of 2\");\n+  assert(is_power_of_2(unroll_factor), \"unroll factor is power of 2\");\n@@ -1693,1 +1693,5 @@\n-  \/\/ We analyze the adress of the mem_ref:\n+  \/\/ We analyze the adress of the mem_ref. The idea is to disassemble it into a linear\n+  \/\/ expression, where we can use the constant factors as the basis for ensuring the\n+  \/\/ alignment of vector memory accesses.\n+  \/\/\n+  \/\/ The Simple form of the address is disassembled by VPointer into:\n@@ -1697,4 +1701,22 @@\n-  \/\/       = base + offset + invar_factor * invar_var\n-  \/\/                       + scale * init\n-  \/\/                       + scale * pre_iter * pre_stride\n-  \/\/                       + scale * j * main_stride\n+  \/\/ Where the iv can be written as:\n+  \/\/\n+  \/\/   iv = init + pre_stride * pre_iter + main_stride * j\n+  \/\/\n+  \/\/ init:        value before pre-loop\n+  \/\/ pre_stride:  increment per pre-loop iteration\n+  \/\/ pre_iter:    number of pre-loop iterations (adjustible via pre-loop limit)\n+  \/\/ main_stride: increment per main-loop iteration (= pre_stride * unroll_factor)\n+  \/\/ j:           number of main-loop iterations (j >= 0)\n+  \/\/\n+  \/\/ In the following, we restate the simple form of the address expression, by first\n+  \/\/ expanding the iv varialbe. In a second step, we reshape the expression again, and\n+  \/\/ state it as a linear expression, consisting of 6 terms.\n+  \/\/\n+  \/\/          Simple form           Expansion of iv variable                  Reshaped with constants   Comments for terms\n+  \/\/          -----------           ------------------------                  -----------------------   ------------------\n+  \/\/   adr =  base               =  base                                   =  base                      (base mod aw = 0)\n+  \/\/        + offset              + offset                                  + C_const                   (sum of constant terms)\n+  \/\/        + invar               + invar_factor * var_invar                + C_invar * var_invar       (term for variable init)\n+  \/\/                          \/   + scale * init                            + C_init  * var_init        (term for invariant)\n+  \/\/        + scale * iv   -> |   + scale * pre_stride * pre_iter           + C_pre   * pre_iter        (adjustable pre-loop term)\n+  \/\/                          \\   + scale * main_stride * j                 + C_main  * j               (main-loop term, for any j >= 0)\n@@ -1702,6 +1724,16 @@\n-  \/\/       = base                                (=0 mod aw)\n-  \/\/         + C0                                (const)\n-  \/\/         + C1_init  * var1                   (term from init, for any var1)\n-  \/\/         + C1_invar * var2                   (term from invar, for any var2)\n-  \/\/         + C2       * pre_iter               (adjustable term)\n-  \/\/         + C3       * j                      (for any j >= 0)\n+  \/\/ We describe the 6 terms:\n+  \/\/   1) The \"base\" of the address is the address of a java object (e.g. array),\n+  \/\/      and hence can be assumed to already be aw-aligned (base mod aw = 0).\n+  \/\/   2) The \"C_const\" term is the sum of all constant terms. This is \"offset\",\n+  \/\/      plus \"init\" if it is constant.\n+  \/\/   3) The \"C_invar * var_invar\" is the factorization of \"invar\" into a constant\n+  \/\/      and variable term. If there is no invariant, then \"C_invar\" is zero.\n+  \/\/   4) The \"C_init * var_init\" is the factorization of \"init\" into a constant\n+  \/\/      and a variable term. If \"init\" is constant, then \"C_init\" is zero, and\n+  \/\/      \"C_const\" accounts for \"init\" instead.\n+  \/\/   5) The \"C_pre * pre_iter\" term represents how much the iv is incremented\n+  \/\/      during the \"pre_iter\" many pre-loop iterations. This term can be adjusted\n+  \/\/      by changing the pre-loop limit. This allows us to adjust the alignment\n+  \/\/      of the main-loop memory reference.\n+  \/\/   6) The \"C_main * j\" term represents how much the iv is increased during \"j\"\n+  \/\/      \"j\" main-loop iterations.\n@@ -1710,3 +1742,3 @@\n-  int C0_init  = 0;\n-  int C1_init  = 0;\n-  int C1_invar = 0;\n+  int C_const_init  = 0;\n+  int C_init  = 0;\n+  int C_invar = 0;\n@@ -1715,1 +1747,1 @@\n-    C0_init = init_node->as_ConI()->get_int();\n+    C_const_init = init_node->as_ConI()->get_int();\n@@ -1717,1 +1749,1 @@\n-    C1_init = scale;\n+    C_init = scale;\n@@ -1721,1 +1753,1 @@\n-    C1_invar = abs(invar_factor);\n+    C_invar = abs(invar_factor);\n@@ -1724,3 +1756,3 @@\n-  int C0 = offset + C0_init * scale;\n-  int C2 = scale * pre_stride;\n-  int C3 = scale * main_stride;\n+  int C_const = offset + C_const_init * scale;\n+  int C_pre = scale * pre_stride;\n+  int C_main = scale * main_stride;\n@@ -1731,2 +1763,2 @@\n-    tty->print_cr(\"C0(%d) + C1_init(%d) * var1 + C1_invar(%d) * var2 + C2(%d) * pre_iter + C3(%d) * j\",\n-                  C0, C1_init, C1_invar, C2, C3);\n+    tty->print_cr(\"C_const(%d) + C_invar(%d) * var_invar + C_init(%d) * var_init + C_pre(%d) * pre_iter + C_main(%d) * j\",\n+                  C_const, C_invar, C_init,  C_pre, C_main);\n@@ -1735,2 +1767,2 @@\n-      tty->print_cr(\"    C0_init = %d\", C0_init);\n-      tty->print_cr(\"    C1_init = %d\", C1_init);\n+      tty->print_cr(\"    C_const_init = %d\", C_const_init);\n+      tty->print_cr(\"    C_init = %d\", C_init);\n@@ -1739,2 +1771,2 @@\n-      tty->print_cr(\"    C0_init = %d\", C0_init);\n-      tty->print_cr(\"    C1_init = abs(scale)= %d\", C1_init);\n+      tty->print_cr(\"    C_const_init = %d\", C_const_init);\n+      tty->print_cr(\"    C_init = abs(scale)= %d\", C_init);\n@@ -1744,1 +1776,1 @@\n-      tty->print_cr(\"    C1_invar = abs(invar_factor) = %d\", C1_invar);\n+      tty->print_cr(\"    C_invar = abs(invar_factor) = %d\", C_invar);\n@@ -1747,1 +1779,1 @@\n-      tty->print_cr(\"    C1_invar = %d\", C1_invar);\n+      tty->print_cr(\"    C_invar = %d\", C_invar);\n@@ -1749,6 +1781,6 @@\n-    tty->print_cr(\"  C0 = offset(%d) + scale(%d) * C0_init(%d) = %d\",\n-                  offset, scale, C0_init, C0);\n-    tty->print_cr(\"  C2 = scale(%d) * pre_stride(%d) = %d\",\n-                  scale, pre_stride, C2);\n-    tty->print_cr(\"  C3 = scale(%d) * main_stride(%d) = %d\",\n-                  scale, main_stride, C3);\n+    tty->print_cr(\"  C_const = offset(%d) + scale(%d) * C_const_init(%d) = %d\",\n+                  offset, scale, C_const_init, C_const);\n+    tty->print_cr(\"  C_pre   = scale(%d) * pre_stride(%d) = %d\",\n+                  scale, pre_stride, C_pre);\n+    tty->print_cr(\"  C_main  = scale(%d) * main_stride(%d) = %d\",\n+                  scale, main_stride, C_main);\n@@ -1758,2 +1790,2 @@\n-  \/\/ We must find a pre_iter, such that adr is aw aligned: adr % aw = 0\n-  \/\/ Since \"invar = 0\" and \"base % vw = 0\":\n+  \/\/ We must find a pre_iter, such that adr is aw aligned: adr % aw = 0.\n+  \/\/ Since \"base mod aw = 0\", we only need to ensure alignment of the other 5 terms:\n@@ -1761,1 +1793,1 @@\n-  \/\/   C0 + C1_init * var1 + C1_invar * var2 + C2 * pre_iter + C3 * j = 0 (modulo aw)        (1)\n+  \/\/   C_const + C_invar * var_invar + C_init * var_init + C_pre * pre_iter + C_main * j = 0 (modulo aw)      (1)\n@@ -1765,1 +1797,1 @@\n-  \/\/   C3 % aw = 0                                                                           (2*)\n+  \/\/   C_main % aw = 0                                                                                        (2*)\n@@ -1767,1 +1799,1 @@\n-  int C3_mod_aw = AlignmentSolution::mod(C3, aw);\n+  int C_main_mod_aw = AlignmentSolution::mod(C_main, aw);\n@@ -1771,4 +1803,4 @@\n-    tty->print(\"  EQ(1  ): C0(%d) + C1_init(%d) * var1 + C1_invar(%d) * var2\",\n-                  C0, C1_init, C1_invar);\n-    tty->print(\" + C2(%d) * pre_iter + C3(%d) * j = 0 (mod aw(%d))\",\n-                  C2, C3, aw);\n+    tty->print(\"  EQ(1  ): C_const(%d) + C_invar(%d) * var_invar + C_init(%d) * var_init\",\n+                  C_const, C_invar, C_init);\n+    tty->print(\" + C_pre(%d) * pre_iter + C_main(%d) * j = 0 (mod aw(%d))\",\n+                  C_pre, C_main, aw);\n@@ -1776,2 +1808,2 @@\n-    tty->print(\"  EQ(2* ): C3(%d) %% aw(%d) = scale(%d) * main_stride(%d) %% aw(%d) = %d = 0\",\n-               C3, aw, scale, main_stride, aw, C3_mod_aw);\n+    tty->print(\"  EQ(2* ): C_main(%d) %% aw(%d) = scale(%d) * main_stride(%d) %% aw(%d) = %d = 0\",\n+               C_main, aw, scale, main_stride, aw, C_main_mod_aw);\n@@ -1782,1 +1814,1 @@\n-  if (C3_mod_aw != 0) {\n+  if (C_main_mod_aw != 0) {\n@@ -1786,1 +1818,1 @@\n-  \/\/ In what follows, me must ensure that the C2 term can align the C0, C1_init and C1_invar terms,\n+  \/\/ In what follows, me must ensure that the C_pre term can align the C_const, C_init and C_invar terms,\n@@ -1789,2 +1821,2 @@\n-  \/\/   C1_init  % abs(C2) = 0                                          (3a*)\n-  \/\/   C1_invar % abs(C2) = 0                                          (3b*)\n+  \/\/   C_init  % abs(C_pre) = 0                                          (3a*)\n+  \/\/   C_invar % abs(C_pre) = 0                                          (3b*)\n@@ -1792,1 +1824,1 @@\n-  \/\/ to ensure that the variable term for init and invar can be aligned with the C2 term.\n+  \/\/ to ensure that the variable term for init and invar can be aligned with the C_pre term.\n@@ -1794,2 +1826,2 @@\n-  int C1_init_mod_abs_C2  = AlignmentSolution::mod(C1_init,  abs(C2));\n-  int C1_invar_mod_abs_C2 = AlignmentSolution::mod(C1_invar, abs(C2));\n+  int C_init_mod_abs_C_pre  = AlignmentSolution::mod(C_init,  abs(C_pre));\n+  int C_invar_mod_abs_C_pre = AlignmentSolution::mod(C_invar, abs(C_pre));\n@@ -1799,4 +1831,4 @@\n-    tty->print_cr(\"  EQ(3a*): C1_init(%d) %% abs(C2(%d)) = %d = 0   (if false: cannot align init)\",\n-                  C1_init, C2, C1_init_mod_abs_C2);\n-    tty->print_cr(\"  EQ(3b*): C1_invar(%d) %% abs(C2(%d)) = %d = 0  (if false: cannot align invar)\",\n-                  C1_invar, C2, C1_invar_mod_abs_C2);\n+    tty->print_cr(\"  EQ(3a*): C_init(%d) %% abs(C_pre(%d)) = %d = 0   (if false: cannot align init)\",\n+                  C_init, C_pre, C_init_mod_abs_C_pre);\n+    tty->print_cr(\"  EQ(3b*): C_invar(%d) %% abs(C_pre(%d)) = %d = 0  (if false: cannot align invar)\",\n+                  C_invar, C_pre, C_invar_mod_abs_C_pre);\n@@ -1806,1 +1838,1 @@\n-  if (C1_init_mod_abs_C2 != 0) {\n+  if (C_init_mod_abs_C_pre != 0) {\n@@ -1809,1 +1841,1 @@\n-  if (C1_invar_mod_abs_C2 != 0) {\n+  if (C_invar_mod_abs_C_pre != 0) {\n@@ -1813,1 +1845,1 @@\n-  \/\/ We must now show that the C0 term can be aligned.\n+  \/\/ We must now show that the C_const term can be aligned.\n@@ -1815,2 +1847,2 @@\n-  \/\/ We can assume that abs(C2) is a power of 2.\n-  \/\/ If abs(C2) >= aw, then for any pre_iter >= 0: C2 * pre_iter = 0 (mod aw),\n+  \/\/ We can assume that abs(C_pre) is a power of 2.\n+  \/\/ If abs(C_pre) >= aw, then for any pre_iter >= 0: C_pre * pre_iter = 0 (mod aw),\n@@ -1819,1 +1851,1 @@\n-  \/\/   C0 % aw = 0                                           (4*)\n+  \/\/   C_const % aw = 0                                           (4*)\n@@ -1821,1 +1853,1 @@\n-  assert(abs(C2) > 0 && is_power_of_2(abs(C2)), \"abs(C2) must be power of 2\");\n+  assert(abs(C_pre) > 0 && is_power_of_2(abs(C_pre)), \"abs(C_pre) must be power of 2\");\n@@ -1823,1 +1855,1 @@\n-  bool abs_C2_ge_aw = abs(C2) >= aw;\n+  bool abs_C_pre_ge_aw = abs(C_pre) >= aw;\n@@ -1827,3 +1859,3 @@\n-    tty->print_cr(\"  abs(C2(%d)) >= aw(%d) -> %s\", C2, aw,\n-                  abs_C2_ge_aw ? \"true (pre-loop limit adjustment makes no difference)\" :\n-                                 \"false (pre-loop limit adjustment changes alignment)\");\n+    tty->print_cr(\"  abs(C_pre(%d)) >= aw(%d) -> %s\", C_pre, aw,\n+                  abs_C_pre_ge_aw ? \"true (pre-loop limit adjustment makes no difference)\" :\n+                                    \"false (pre-loop limit adjustment changes alignment)\");\n@@ -1833,2 +1865,2 @@\n-  if (abs_C2_ge_aw) {\n-    int C0_mod_aw = AlignmentSolution::mod(C0, aw);\n+  if (abs_C_pre_ge_aw) {\n+    int C_const_mod_aw = AlignmentSolution::mod(C_const, aw);\n@@ -1838,2 +1870,2 @@\n-      tty->print_cr(\"  EQ(4* ): C0(%d) %% aw(%d) = %d = 0\",\n-                    C0, aw, C0_mod_aw);\n+      tty->print_cr(\"  EQ(4* ): C_const(%d) %% aw(%d) = %d = 0\",\n+                    C_const, aw, C_const_mod_aw);\n@@ -1843,3 +1875,3 @@\n-    \/\/ The C1 terms are trivially aligned.\n-    assert(AlignmentSolution::mod(C1_init,  aw) == 0,  \"implied by abs(C2) >= aw and (3a*)\");\n-    assert(AlignmentSolution::mod(C1_invar, aw) == 0,  \"implied by abs(C2) >= aw and (3b*)\");\n+    \/\/ The C_init and C_invar terms are trivially aligned.\n+    assert(AlignmentSolution::mod(C_init,  aw) == 0,  \"implied by abs(C_pre) >= aw and (3a*)\");\n+    assert(AlignmentSolution::mod(C_invar, aw) == 0,  \"implied by abs(C_pre) >= aw and (3b*)\");\n@@ -1847,2 +1879,2 @@\n-    if (C0_mod_aw != 0) {\n-      return AlignmentSolution(\"EQ(4*) not satisfied: C0 not aligned\");\n+    if (C_const_mod_aw != 0) {\n+      return AlignmentSolution(\"EQ(4*) not satisfied: C_const not aligned\");\n@@ -1855,2 +1887,2 @@\n-  \/\/ Otherwise, if abs(C2) < aw, we need to produce a solution that aligns\n-  \/\/ the C0, C1_init and C1_invar terms at the same time.\n+  \/\/ Otherwise, if abs(C_pre) < aw, we need to produce a solution that aligns\n+  \/\/ the C_const, C_init and C_invar terms at the same time.\n@@ -1858,1 +1890,1 @@\n-  \/\/   C0 + C1_init * var1 + C1_invar * var2 + C2 * pre_iter = 0 (modulo aw)        (5)\n+  \/\/   C_const + C_invar * var_invar + C_init * var_init + C_pre * pre_iter = 0 (modulo aw)       (5)\n@@ -1863,2 +1895,2 @@\n-  \/\/ 1. If a variable init is present (i.e. C1_init = scale), then we\n-  \/\/    make the solution dependent on scale and C2. Only solutions\n+  \/\/ 1. If a variable init is present (i.e. C_init = scale), then we\n+  \/\/    make the solution dependent on scale and C_pre. Only solutions\n@@ -1867,1 +1899,1 @@\n-  \/\/    to align the C1_init term.\n+  \/\/    to align the C_init term.\n@@ -1870,1 +1902,1 @@\n-  \/\/    on C2 and invar. Only solutions with tthe same dependenceis are\n+  \/\/    on C_pre and invar. Only solutions with tthe same dependenceis are\n@@ -1872,1 +1904,1 @@\n-  \/\/    number of pre-loop iterations to align the C1_invar term.\n+  \/\/    number of pre-loop iterations to align the C_invar term.\n@@ -1876,1 +1908,1 @@\n-  \/\/   pre_iter = pre_iter_C0 + pre_iter_C1_init + pre_iter_C1_invar\n+  \/\/   pre_iter = pre_iter_C_const + pre_iter_C_invar + pre_iter_C_init\n@@ -1879,1 +1911,1 @@\n-  \/\/ pre_iter_C1_init and pre_iter_C1_invar exist and are the same\n+  \/\/ pre_iter_C_init and pre_iter_C_invar exist and are the same\n@@ -1881,1 +1913,1 @@\n-  \/\/ We now have to show that thereis a pre_iter_C0, terms of the\n+  \/\/ We now have to show that there is a pre_iter_C_const, terms of the\n@@ -1884,2 +1916,2 @@\n-  \/\/   pre_iter_C0 = pre_r + pre_q * m  (for any m >= 0)                            (6)\n-  \/\/   C0 + C2 * pre_r + C2 * pre_q * m = 0 (modulo aw)                             (7)\n+  \/\/   pre_iter_C_const = pre_r + pre_q * m  (for any m >= 0)                     (6)\n+  \/\/   C_const + C_pre * pre_r + C_pre * pre_q * m = 0 (modulo aw)                (7)\n@@ -1889,2 +1921,2 @@\n-  \/\/   C2 * pre_q = 0 (modulo aw)                                                   (8)\n-  \/\/   C0 + C2 * pre_r = 0 (modulo aw)                                              (9*)\n+  \/\/   C_pre * pre_q = 0 (modulo aw)                                              (8)\n+  \/\/   C_const + C_pre * pre_r = 0 (modulo aw)                                    (9*)\n@@ -1892,1 +1924,1 @@\n-  \/\/ Given that abs(C2) is a powers of 2, and abs(C2) < aw:\n+  \/\/ Given that abs(C_pre) is a powers of 2, and abs(C_pre) < aw:\n@@ -1894,1 +1926,1 @@\n-  int  pre_q = aw \/ abs(C2);\n+  int  pre_q = aw \/ abs(C_pre);\n@@ -1901,2 +1933,6 @@\n-    tty->print_cr(\"  pre_q = aw(%d) \/ abs(C2(%d)) = %d\",\n-                  aw, C2, pre_q);\n+    tty->print_cr(\"  Find alignment for C_const(%d), with:\", C_const);\n+    tty->print_cr(\"  pre_iter_C_const = pre_r + pre_q * m  (for any m >= 0)\");\n+    tty->print_cr(\"  C_const(%d) + C_pre(%d) * pre_r + C_pre(%d) * pre_q * m = 0 (modulo aw(%d)):\",\n+                  C_const, C_pre, C_pre, aw);\n+    tty->print_cr(\"  pre_q = aw(%d) \/ abs(C_pre(%d)) = %d\",\n+                  aw, C_pre, pre_q);\n@@ -1908,1 +1944,1 @@\n-    int EQ9_val = AlignmentSolution::mod(C0 + C2 * pre_r, aw);\n+    int EQ9_val = AlignmentSolution::mod(C_const + C_pre * pre_r, aw);\n@@ -1912,2 +1948,2 @@\n-      tty->print_cr(\"   try pre_r = %d: (C0(%d) + C2(%d) * pre_r(%d)) %% aw(%d) = %d = 0\",\n-                    pre_r, C0, C2, pre_r, aw, EQ9_val);\n+      tty->print_cr(\"   try pre_r = %d: (C_const(%d) + C_pre(%d) * pre_r(%d)) %% aw(%d) = %d = 0\",\n+                    pre_r, C_const, C_pre, pre_r, aw, EQ9_val);\n@@ -1918,2 +1954,2 @@\n-      assert((C1_init == 0) == init_node->is_ConI(), \"init consistent\");\n-      assert((C1_invar == 0) == (invar == nullptr), \"invar consistent\");\n+      assert((C_init == 0) == init_node->is_ConI(), \"init consistent\");\n+      assert((C_invar == 0) == (invar == nullptr), \"invar consistent\");\n@@ -1922,1 +1958,1 @@\n-      \/\/ Note: if scale is the same, then C2 is the same.\n+      \/\/ Note: if scale is the same, then C_pre is the same.\n@@ -1950,1 +1986,1 @@\n-\/\/ main_stride = unroll * pre_stride\n+\/\/ main_stride = unroll_factor * pre_stride\n@@ -1953,2 +1989,2 @@\n-\/\/   i = pre_iter + j * unroll\n-\/\/   iv = init + i * pre_stride = init + pre_iter * pre_stride + j * unroll * pre_stride\n+\/\/   i = pre_iter + j * unroll_factor\n+\/\/   iv = init + i * pre_stride = init + pre_iter * pre_stride + j * unroll_factor * pre_stride\n@@ -1958,1 +1994,1 @@\n-\/\/   i  += unroll\n+\/\/   i  += unroll_factor\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":159,"deletions":123,"binary":false,"changes":282,"status":"modified"}]}