{"files":[{"patch":"@@ -1628,11 +1628,2 @@\n-  \/\/ All vector loads and stores need to be memory aligned. The alignment width (aw) in\n-  \/\/ principle is the vector_width. But when vector_width > ObjectAlignmentInBytes this is\n-  \/\/ too strict, since any memory object is only guaranteed to be ObjectAlignmentInBytes\n-  \/\/ aligned. For example, the relative offset between two arrays is only guaranteed to\n-  \/\/ be divisible by ObjectAlignmentInBytes.\n-  const uint pack_size    = pack->size();\n-  const MemNode* mem_ref  = pack->at(0)->as_Mem();\n-  const int element_size  = mem_ref->memory_size();\n-  const int vector_width  = pack_size * element_size;\n-  const int aw            = MIN2(vector_width, ObjectAlignmentInBytes); \/\/ alignment_width\n-\n+  const MemNode* mem_ref = pack->at(0)->as_Mem();\n+  VPointer mem_ref_p(mem_ref, phase(), lpt(), nullptr, false);\n@@ -1641,12 +1632,0 @@\n-  const int pre_stride    = pre_end->stride_con();\n-  const int unroll_factor = _lp->unrolled_count();\n-  const int main_stride   = iv_stride();\n-  const Node* init_node   = pre_end->init_trip();\n-  assert(pre_stride * unroll_factor == main_stride, \"unrolled stride must be consistent\");\n-\n-  VPointer mem_ref_p(mem_ref, phase(), lpt(), nullptr, false);\n-  const int scale         = mem_ref_p.scale_in_bytes();\n-  const int offset        = mem_ref_p.offset_in_bytes();\n-  const Node* base        = mem_ref_p.base();\n-  const Node* invar       = mem_ref_p.invar();\n-  const int invar_factor  = mem_ref_p.invar_factor();\n@@ -1654,1 +1633,0 @@\n-  \/\/ TODO clean up args above\n@@ -1666,363 +1644,1 @@\n-  solver.solve();\n-\n-#ifndef PRODUCT\n-  if (is_trace_align_vector()) {\n-    tty->print(\" pack mem_ref:\");\n-    mem_ref->dump();\n-    tty->print_cr(\"  vector_width = pack_size(%d) * element_size(%d) = %d\",\n-                  pack_size, element_size, vector_width);\n-    tty->print_cr(\"  aw = alignment_width = min(vector_width(%d), ObjectAlignmentInBytes(%d)) = %d\",\n-                  vector_width, ObjectAlignmentInBytes, aw);\n-\n-    if (!init_node->is_ConI()) {\n-      tty->print(\"  init:\");\n-      init_node->dump();\n-    }\n-\n-    if (invar != nullptr) {\n-      tty->print(\"  invar:\");\n-      invar->dump();\n-    }\n-\n-    tty->print_cr(\"  invar_factor = %d\", invar_factor);\n-\n-    \/\/ iv = init + pre_iter * pre_stride + main_iter * main_stride\n-    tty->print(\"  iv = init\");\n-    print_icon_or_idx_xxx(init_node);\n-    tty->print_cr(\" + pre_iter * pre_stride(%d) + main_iter * main_stride(%d)\",\n-                  pre_stride, main_stride);\n-\n-    \/\/ adr = base + offset + invar + scale * iv\n-    tty->print(\"  adr = base\");\n-    print_icon_or_idx_xxx(base);\n-    tty->print(\" + offset(%d) + invar\", offset);\n-    print_icon_or_idx_xxx(invar);\n-    tty->print_cr(\" + scale(%d) * iv\", scale);\n-  }\n-#endif\n-\n-  \/\/ Out of simplicity: non power-of-2 stride not supported.\n-  if (!is_power_of_2(abs(pre_stride))) {\n-    return AlignmentSolution(\"non power-of-2 stride not supported\");\n-  }\n-  assert(is_power_of_2(unroll_factor), \"unroll factor is power of 2\");\n-  assert(is_power_of_2(abs(main_stride)), \"main_stride is power of 2\");\n-  assert(aw > 0 && is_power_of_2(aw), \"aw must be power of 2\");\n-\n-  \/\/ Out of simplicity: non power-of-2 scale not supported.\n-  if (abs(scale) == 0 || !is_power_of_2(abs(scale))) {\n-    return AlignmentSolution(\"non power-of-2 scale not supported\");\n-  }\n-\n-  \/\/ We analyze the address of mem_ref. The idea is to disassemble it into a linear\n-  \/\/ expression, where we can use the constant factors as the basis for ensuring the\n-  \/\/ alignment of vector memory accesses.\n-  \/\/\n-  \/\/ The Simple form of the address is disassembled by VPointer into:\n-  \/\/\n-  \/\/   adr = base + offset + invar + scale * iv\n-  \/\/\n-  \/\/ Where the iv can be written as:\n-  \/\/\n-  \/\/   iv = init + pre_stride * pre_iter + main_stride * main_iter\n-  \/\/\n-  \/\/ init:        value before pre-loop\n-  \/\/ pre_stride:  increment per pre-loop iteration\n-  \/\/ pre_iter:    number of pre-loop iterations (adjustable via pre-loop limit)\n-  \/\/ main_stride: increment per main-loop iteration (= pre_stride * unroll_factor)\n-  \/\/ main_iter:   number of main-loop iterations (main_iter >= 0)\n-  \/\/\n-  \/\/ In the following, we restate the simple form of the address expression, by first\n-  \/\/ expanding the iv variable. In a second step, we reshape the expression again, and\n-  \/\/ state it as a linear expression, consisting of 6 terms.\n-  \/\/\n-  \/\/          Simple form           Expansion of iv variable                  Reshaped with constants   Comments for terms\n-  \/\/          -----------           ------------------------                  -----------------------   ------------------\n-  \/\/   adr =  base               =  base                                   =  base                      (base % aw = 0)\n-  \/\/        + offset              + offset                                  + C_const                   (sum of constant terms)\n-  \/\/        + invar               + invar_factor * var_invar                + C_invar * var_invar       (term for invariant)\n-  \/\/                          \/   + scale * init                            + C_init  * var_init        (term for variable init)\n-  \/\/        + scale * iv   -> |   + scale * pre_stride * pre_iter           + C_pre   * pre_iter        (adjustable pre-loop term)\n-  \/\/                          \\   + scale * main_stride * main_iter         + C_main  * main_iter       (main-loop term)\n-  \/\/\n-  \/\/ We describe the 6 terms:\n-  \/\/   1) The \"base\" of the address is the address of a Java object (e.g. array),\n-  \/\/      and hence can be assumed to already be aw-aligned (base % aw = 0).\n-  \/\/   2) The \"C_const\" term is the sum of all constant terms. This is \"offset\",\n-  \/\/      plus \"init\" if it is constant.\n-  \/\/   3) The \"C_invar * var_invar\" is the factorization of \"invar\" into a constant\n-  \/\/      and variable term. If there is no invariant, then \"C_invar\" is zero.\n-  \/\/   4) The \"C_init * var_init\" is the factorization of \"scale * init\" into a\n-  \/\/      constant and a variable term. If \"init\" is constant, then \"C_init\" is\n-  \/\/      zero, and \"C_const\" accounts for \"init\" instead.\n-  \/\/   5) The \"C_pre * pre_iter\" term represents how much the iv is incremented\n-  \/\/      during the \"pre_iter\" pre-loop iterations. This term can be adjusted\n-  \/\/      by changing the pre-loop limit, which defines how many pre-loop iterations\n-  \/\/      are executed. This allows us to adjust the alignment of the main-loop\n-  \/\/      memory reference.\n-  \/\/   6) The \"C_main * main_iter\" term represents how much the iv is increased\n-  \/\/      during \"main_iter\" main-loop iterations.\n-\n-  \/\/ Attribute init either to C_const or to C_init term.\n-  const int C_const_init = init_node->is_ConI() ? init_node->as_ConI()->get_int() : 0;\n-  const int C_init =       init_node->is_ConI() ? 0                               : scale;\n-\n-  \/\/ Set C_invar depending on if invar is present\n-  const int C_invar = (invar == nullptr) ? 0 : abs(invar_factor);\n-\n-  const int C_const = offset + C_const_init * scale;\n-  const int C_pre = scale * pre_stride;\n-  const int C_main = scale * main_stride;\n-\n-#ifndef PRODUCT\n-  if (is_trace_align_vector()) {\n-    tty->print(\"      = base[%d] + \", base->_idx);\n-    tty->print_cr(\"C_const(%d) + C_invar(%d) * var_invar + C_init(%d) * var_init + C_pre(%d) * pre_iter + C_main(%d) * main_iter\",\n-                  C_const, C_invar, C_init,  C_pre, C_main);\n-    if (init_node->is_ConI()) {\n-      tty->print_cr(\"  init is constant:\");\n-      tty->print_cr(\"    C_const_init = %d\", C_const_init);\n-      tty->print_cr(\"    C_init = %d\", C_init);\n-    } else {\n-      tty->print_cr(\"  init is variable:\");\n-      tty->print_cr(\"    C_const_init = %d\", C_const_init);\n-      tty->print_cr(\"    C_init = abs(scale)= %d\", C_init);\n-    }\n-    if (invar != nullptr) {\n-      tty->print_cr(\"  invariant present:\");\n-      tty->print_cr(\"    C_invar = abs(invar_factor) = %d\", C_invar);\n-    } else {\n-      tty->print_cr(\"  no invariant:\");\n-      tty->print_cr(\"    C_invar = %d\", C_invar);\n-    }\n-    tty->print_cr(\"  C_const = offset(%d) + scale(%d) * C_const_init(%d) = %d\",\n-                  offset, scale, C_const_init, C_const);\n-    tty->print_cr(\"  C_pre   = scale(%d) * pre_stride(%d) = %d\",\n-                  scale, pre_stride, C_pre);\n-    tty->print_cr(\"  C_main  = scale(%d) * main_stride(%d) = %d\",\n-                  scale, main_stride, C_main);\n-  }\n-#endif\n-\n-  \/\/ We must find a pre_iter, such that adr is aw aligned: adr % aw = 0.\n-  \/\/ Since \"base % aw = 0\", we only need to ensure alignment of the other 5 terms:\n-  \/\/\n-  \/\/   (C_const + C_invar * var_invar + C_init * var_init + C_pre * pre_iter + C_main * main_iter) % aw = 0      (1)\n-  \/\/\n-  \/\/ Alignment must be maintained over all main-loop iterations, i.e. for any main_iter >= 0, we require:\n-  \/\/\n-  \/\/   C_main % aw = 0                                                                                           (2*)\n-  \/\/\n-  const int C_main_mod_aw = AlignmentSolution::mod(C_main, aw);\n-\n-#ifndef PRODUCT\n-  if (is_trace_align_vector()) {\n-    tty->print(\"  EQ(1  ): (C_const(%d) + C_invar(%d) * var_invar + C_init(%d) * var_init\",\n-                  C_const, C_invar, C_init);\n-    tty->print(\" + C_pre(%d) * pre_iter + C_main(%d) * main_iter) %% aw(%d) = 0\",\n-                  C_pre, C_main, aw);\n-    tty->print_cr(\" (given base aligned -> align rest)\");\n-    tty->print(\"  EQ(2* ): C_main(%d) %% aw(%d) = scale(%d) * main_stride(%d) %% aw(%d) = %d = 0\",\n-               C_main, aw, scale, main_stride, aw, C_main_mod_aw);\n-    tty->print_cr(\" (alignment across iterations)\");\n-  }\n-#endif\n-\n-  if (C_main_mod_aw != 0) {\n-    return AlignmentSolution(\"EQ(2*) not satisfied (cannot align across main-loop iterations)\");\n-  }\n-\n-  \/\/ In what follows, we need to show that the C_const, init and invar terms can be aligned by\n-  \/\/ adjusting the pre-loop limit (pre_iter). We decompose pre_iter:\n-  \/\/\n-  \/\/   pre_iter = pre_iter_C_const + pre_iter_C_invar + pre_iter_C_init\n-  \/\/\n-  \/\/ where pre_iter_C_const, pre_iter_C_invar, and pre_iter_C_init are defined as the number of\n-  \/\/ pre-loop iterations required to align the C_const, init and invar terms individually.\n-  \/\/ Hence, we can rewrite:\n-  \/\/\n-  \/\/     (C_const + C_invar * var_invar + C_init * var_init + C_pre * pre_iter) % aw\n-  \/\/   = ( C_const             + C_pre * pre_iter_C_const\n-  \/\/     + C_invar * var_invar + C_pre * pre_iter_C_invar\n-  \/\/     + C_init  * var_init  + C_pre * pre_iter_C_init ) % aw\n-  \/\/   = 0                                                                       (3)\n-  \/\/\n-  \/\/ We strengthen the constraints by splitting the equation into 3 equations, where the C_const,\n-  \/\/ init, and invar term are aligned individually:\n-  \/\/\n-  \/\/   (C_init  * var_init  + C_pre * pre_iter_C_init ) % aw = 0                 (4a)\n-  \/\/   (C_invar * var_invar + C_pre * pre_iter_C_invar) % aw = 0                 (4b)\n-  \/\/   (C_const             + C_pre * pre_iter_C_const) % aw = 0                 (4c)\n-  \/\/\n-  \/\/ We can only guarantee solutions to (4a) and (4b) if:\n-  \/\/\n-  \/\/   C_init  % abs(C_pre) = 0                                                  (5a*)\n-  \/\/   C_invar % abs(C_pre) = 0                                                  (5b*)\n-  \/\/\n-  \/\/ Which means there are X and Y such that:\n-  \/\/\n-  \/\/   C_init  = C_pre * X       (X = 0 if C_init  = 0, else X = C_init  \/ C_pre)\n-  \/\/   C_invar = C_pre * Y       (Y = 0 if C_invar = 0, else Y = C_invar \/ C_pre)\n-  \/\/\n-  \/\/   (C_init    * var_init  + C_pre * pre_iter_C_init ) % aw =\n-  \/\/   (C_pre * X * var_init  + C_pre * pre_iter_C_init ) % aw =\n-  \/\/   (C_pre * (X * var_init  + pre_iter_C_init)       ) % aw = 0\n-  \/\/\n-  \/\/   (C_invar   * var_invar + C_pre * pre_iter_C_invar) % aw =\n-  \/\/   (C_pre * Y * var_invar + C_pre * pre_iter_C_invar) % aw =\n-  \/\/   (C_pre * (Y * var_invar + pre_iter_C_invar)      ) % aw = 0\n-  \/\/\n-  \/\/ And hence, we know that there are solutions for pre_iter_C_init and pre_iter_C_invar,\n-  \/\/ based on X, Y, var_init, and var_invar. We call them:\n-  \/\/\n-  \/\/   pre_iter_C_init  = alignment_init (X * var_init)\n-  \/\/   pre_iter_C_invar = alignment_invar(Y * var_invar)\n-  \/\/\n-  const int C_init_mod_abs_C_pre  = AlignmentSolution::mod(C_init,  abs(C_pre));\n-  const int C_invar_mod_abs_C_pre = AlignmentSolution::mod(C_invar, abs(C_pre));\n-\n-#ifndef PRODUCT\n-  if (is_trace_align_vector()) {\n-    tty->print_cr(\"  EQ(5a*): C_init(%d) %% abs(C_pre(%d)) = %d = 0   (if false: cannot align init)\",\n-                  C_init, C_pre, C_init_mod_abs_C_pre);\n-    tty->print_cr(\"  EQ(5b*): C_invar(%d) %% abs(C_pre(%d)) = %d = 0  (if false: cannot align invar)\",\n-                  C_invar, C_pre, C_invar_mod_abs_C_pre);\n-  }\n-#endif\n-\n-  if (C_init_mod_abs_C_pre != 0) {\n-    return AlignmentSolution(\"EQ(5a*) not satisfied (cannot align init)\");\n-  }\n-  if (C_invar_mod_abs_C_pre != 0) {\n-    return AlignmentSolution(\"EQ(5b*) not satisfied (cannot align invar)\");\n-  }\n-\n-  \/\/ Having solved (4a) and (4b), we now want to find solutions for (4c), i.e. we need\n-  \/\/ to show that the C_const term can be aligned with pre_iter_C_const.\n-  \/\/\n-  \/\/ We can assume that abs(C_pre) as well as aw are both powers of 2.\n-  \/\/\n-  \/\/ If abs(C_pre) >= aw, then:\n-  \/\/\n-  \/\/   for any pre_iter >= 0:         (C_pre * pre_iter        ) % aw = 0\n-  \/\/   for any pre_iter_C_const >= 0: (C_pre * pre_iter_C_const) % aw = 0\n-  \/\/\n-  \/\/ which implies that pre_iter (and pre_iter_C_const) have no effect on the alignment of\n-  \/\/ the C_const term. We thus either have a trivial solution, and any pre_iter aligns\n-  \/\/ the address, or there is no solution. To have the trivial solution, we require:\n-  \/\/\n-  \/\/   C_const % aw = 0                                                       (6*)\n-  \/\/\n-  assert(abs(C_pre) > 0 && is_power_of_2(abs(C_pre)), \"abs(C_pre) must be power of 2\");\n-  const bool abs_C_pre_ge_aw = abs(C_pre) >= aw;\n-\n-#ifndef PRODUCT\n-  if (is_trace_align_vector()) {\n-    tty->print_cr(\"  abs(C_pre(%d)) >= aw(%d) -> %s\", C_pre, aw,\n-                  abs_C_pre_ge_aw ? \"true (pre-loop limit adjustment makes no difference)\" :\n-                                    \"false (pre-loop limit adjustment changes alignment)\");\n-  }\n-#endif\n-\n-  if (abs_C_pre_ge_aw) {\n-    const int C_const_mod_aw = AlignmentSolution::mod(C_const, aw);\n-\n-#ifndef PRODUCT\n-    if (is_trace_align_vector()) {\n-      tty->print_cr(\"  EQ(6* ): C_const(%d) %% aw(%d) = %d = 0\",\n-                    C_const, aw, C_const_mod_aw);\n-    }\n-#endif\n-\n-    \/\/ The C_init and C_invar terms are trivially aligned.\n-    assert(AlignmentSolution::mod(C_init,  aw) == 0,  \"implied by abs(C_pre) >= aw and (5a*)\");\n-    assert(AlignmentSolution::mod(C_invar, aw) == 0,  \"implied by abs(C_pre) >= aw and (5b*)\");\n-\n-    if (C_const_mod_aw != 0) {\n-      return AlignmentSolution(\"EQ(6*) not satisfied: C_const not aligned\");\n-    } else {\n-      \/\/ Solution is trivial, holds for any pre-loop limit.\n-      return AlignmentSolution();\n-    }\n-  }\n-\n-  \/\/ Otherwise, if abs(C_pre) < aw, we find all solutions for pre_iter_C_const in (4c).\n-  \/\/ We state pre_iter_C_const in terms of the smallest possible pre_q and pre_r, such\n-  \/\/ that pre_q >= 0 and 0 <= pre_r < pre_q:\n-  \/\/\n-  \/\/   pre_iter_C_const = pre_r + pre_q * m  (for any m >= 0)                     (7)\n-  \/\/\n-  \/\/ We can now restate (4c) with (7):\n-  \/\/\n-  \/\/   (C_const + C_pre * pre_r + C_pre * pre_q * m) % aw = 0                     (8)\n-  \/\/\n-  \/\/ Since this holds for any m >= 0, we require:\n-  \/\/\n-  \/\/   (C_pre * pre_q) % aw = 0                                                   (9)\n-  \/\/   (C_const + C_pre * pre_r) % aw = 0                                         (10*)\n-  \/\/\n-  \/\/ Given that abs(C_pre) is a powers of 2, and abs(C_pre) < aw:\n-  \/\/\n-  const int  pre_q = aw \/ abs(C_pre);\n-  \/\/\n-  \/\/ We brute force the solution for pre_r by enumerating all values 0..pre_q-1 and\n-  \/\/ checking EQ(10*).\n-  \/\/\n-  \/\/ Assuming we found a solution for (4c), and also for (4a) and (4b), we know that\n-  \/\/ the solution to pre_iter is non-trivial:\n-  \/\/\n-  \/\/   pre_iter = pre_iter_C_const  + pre_iter_C_init              + pre_iter_C_invar\n-  \/\/            = pre_r + pre_q * m + alignment_init(X * var_init) + alignment_invar(Y * var_invar)\n-  \/\/\n-  \/\/ Hence, the solution depends on:\n-  \/\/   - Always: pre_r and pre_q\n-  \/\/   - If a variable init is present (i.e. C_init = scale), then we know that to\n-  \/\/     satisfy (5a*), we must have abs(pre_stride) = 1, X = 1 and C_pre = scale.\n-  \/\/     The solution thus depends on var_init = init \/ scale. We thus have a\n-  \/\/     dependency on scale. We could also add a dependency for init, but since\n-  \/\/     it is the same for all mem_refs in the loop this is unnecessary. If init\n-  \/\/     is constant, then we could add a dependency that there is no variable init.\n-  \/\/     But since init is the same for all mem_refs, this is unecessary.\n-  \/\/   - If an invariant is present (i.e. C_invar = abs(invar_factor)), then we know\n-  \/\/     from (5b*), that Y = abs(invar_factor) \/ (scale * pre_stride). The solution\n-  \/\/     depends on Y * var_invar = abs(invar_factor) * var_invar \/ (scale * pre_stride),\n-  \/\/     hence we have to add a dependency for invar, and scale (pre_stride is the\n-  \/\/     same for all mem_refs in the loop). If there is no invariant, then we add\n-  \/\/     a dependency that there is no invariant.\n-  \/\/\n-  \/\/ Other mem_refs must have solutions with  the same dependencies, otherwise we\n-  \/\/ cannot ensure that they require the same number of pre-loop iterations.\n-\n-#ifndef PRODUCT\n-  if (is_trace_align_vector()) {\n-    tty->print_cr(\"  Find alignment for C_const(%d), with:\", C_const);\n-    tty->print_cr(\"  pre_iter_C_const = pre_r + pre_q * m  (for any m >= 0)\");\n-    tty->print_cr(\"  (C_const(%d) + C_pre(%d) * pre_r + C_pre(%d) * pre_q * m) %% aw(%d) = 0:\",\n-                  C_const, C_pre, C_pre, aw);\n-    tty->print_cr(\"  pre_q = aw(%d) \/ abs(C_pre(%d)) = %d\",\n-                  aw, C_pre, pre_q);\n-    tty->print_cr(\"  EQ(10*): brute force pre_r = 0..%d\", pre_q - 1);\n-  }\n-#endif\n-\n-  for (int pre_r = 0; pre_r < pre_q; pre_r++) {\n-    const int EQ10_val = AlignmentSolution::mod(C_const + C_pre * pre_r, aw);\n-\n-#ifndef PRODUCT\n-    if (is_trace_align_vector()) {\n-      tty->print_cr(\"   try pre_r = %d: (C_const(%d) + C_pre(%d) * pre_r(%d)) %% aw(%d) = %d = 0\",\n-                    pre_r, C_const, C_pre, pre_r, aw, EQ10_val);\n-    }\n-#endif\n-\n-    if (EQ10_val == 0) {\n-      assert((C_init == 0) == init_node->is_ConI(), \"init consistent\");\n-      assert((C_invar == 0) == (invar == nullptr), \"invar consistent\");\n-\n-      const Node* invar_dependency = invar;\n-      const int scale_dependency  = (invar != nullptr || !init_node->is_ConI()) ? scale : 0;\n-      return AlignmentSolution(pre_r, pre_q, mem_ref, aw,\n-                               invar_dependency, scale_dependency);\n-    }\n-  }\n-  return AlignmentSolution(\"EQ(10*) has no solution for pre_r\");\n+  return solver.solve();\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":3,"deletions":387,"binary":false,"changes":390,"status":"modified"},{"patch":"@@ -852,0 +852,93 @@\n+  if (C_init_mod_abs_C_pre != 0) {\n+    return AlignmentSolution(\"EQ(5a*) not satisfied (cannot align init)\");\n+  }\n+  if (C_invar_mod_abs_C_pre != 0) {\n+    return AlignmentSolution(\"EQ(5b*) not satisfied (cannot align invar)\");\n+  }\n+\n+  \/\/ Having solved (4a) and (4b), we now want to find solutions for (4c), i.e. we need\n+  \/\/ to show that the C_const term can be aligned with pre_iter_C_const.\n+  \/\/\n+  \/\/ We can assume that abs(C_pre) as well as aw are both powers of 2.\n+  \/\/\n+  \/\/ If abs(C_pre) >= aw, then:\n+  \/\/\n+  \/\/   for any pre_iter >= 0:         (C_pre * pre_iter        ) % aw = 0\n+  \/\/   for any pre_iter_C_const >= 0: (C_pre * pre_iter_C_const) % aw = 0\n+  \/\/\n+  \/\/ which implies that pre_iter (and pre_iter_C_const) have no effect on the alignment of\n+  \/\/ the C_const term. We thus either have a trivial solution, and any pre_iter aligns\n+  \/\/ the address, or there is no solution. To have the trivial solution, we require:\n+  \/\/\n+  \/\/   C_const % aw = 0                                                       (6*)\n+  \/\/\n+  assert(abs(C_pre) > 0 && is_power_of_2(abs(C_pre)), \"abs(C_pre) must be power of 2\");\n+  const bool abs_C_pre_ge_aw = abs(C_pre) >= _aw;\n+\n+  DEBUG_ONLY( trace_abs_C_pre_ge_aw(C_pre, abs_C_pre_ge_aw); )\n+\n+  if (abs_C_pre_ge_aw) {\n+    const int C_const_mod_aw = AlignmentSolution::mod(C_const, _aw);\n+\n+    DEBUG_ONLY( trace_C_const_mod_aw(C_const, C_const_mod_aw); )\n+\n+    \/\/ The C_init and C_invar terms are trivially aligned.\n+    assert(AlignmentSolution::mod(C_init,  _aw) == 0,  \"implied by abs(C_pre) >= aw and (5a*)\");\n+    assert(AlignmentSolution::mod(C_invar, _aw) == 0,  \"implied by abs(C_pre) >= aw and (5b*)\");\n+\n+    if (C_const_mod_aw != 0) {\n+      return AlignmentSolution(\"EQ(6*) not satisfied: C_const not aligned\");\n+    } else {\n+      \/\/ Solution is trivial, holds for any pre-loop limit.\n+      return AlignmentSolution();\n+    }\n+  }\n+\n+  \/\/ Otherwise, if abs(C_pre) < aw, we find all solutions for pre_iter_C_const in (4c).\n+  \/\/ We state pre_iter_C_const in terms of the smallest possible pre_q and pre_r, such\n+  \/\/ that pre_q >= 0 and 0 <= pre_r < pre_q:\n+  \/\/\n+  \/\/   pre_iter_C_const = pre_r + pre_q * m  (for any m >= 0)                     (7)\n+  \/\/\n+  \/\/ We can now restate (4c) with (7):\n+  \/\/\n+  \/\/   (C_const + C_pre * pre_r + C_pre * pre_q * m) % aw = 0                     (8)\n+  \/\/\n+  \/\/ Since this holds for any m >= 0, we require:\n+  \/\/\n+  \/\/   (C_pre * pre_q) % aw = 0                                                   (9)\n+  \/\/   (C_const + C_pre * pre_r) % aw = 0                                         (10*)\n+  \/\/\n+  \/\/ Given that abs(C_pre) is a powers of 2, and abs(C_pre) < aw:\n+  \/\/\n+  const int  pre_q = _aw \/ abs(C_pre);\n+  \/\/\n+  \/\/ We brute force the solution for pre_r by enumerating all values 0..pre_q-1 and\n+  \/\/ checking EQ(10*).\n+  \/\/\n+  \/\/ Assuming we found a solution for (4c), and also for (4a) and (4b), we know that\n+  \/\/ the solution to pre_iter is non-trivial:\n+  \/\/\n+  \/\/   pre_iter = pre_iter_C_const  + pre_iter_C_init              + pre_iter_C_invar\n+  \/\/            = pre_r + pre_q * m + alignment_init(X * var_init) + alignment_invar(Y * var_invar)\n+  \/\/\n+  \/\/ Hence, the solution depends on:\n+  \/\/   - Always: pre_r and pre_q\n+  \/\/   - If a variable init is present (i.e. C_init = scale), then we know that to\n+  \/\/     satisfy (5a*), we must have abs(pre_stride) = 1, X = 1 and C_pre = scale.\n+  \/\/     The solution thus depends on var_init = init \/ scale. We thus have a\n+  \/\/     dependency on scale. We could also add a dependency for init, but since\n+  \/\/     it is the same for all mem_refs in the loop this is unnecessary. If init\n+  \/\/     is constant, then we could add a dependency that there is no variable init.\n+  \/\/     But since init is the same for all mem_refs, this is unecessary.\n+  \/\/   - If an invariant is present (i.e. C_invar = abs(invar_factor)), then we know\n+  \/\/     from (5b*), that Y = abs(invar_factor) \/ (scale * pre_stride). The solution\n+  \/\/     depends on Y * var_invar = abs(invar_factor) * var_invar \/ (scale * pre_stride),\n+  \/\/     hence we have to add a dependency for invar, and scale (pre_stride is the\n+  \/\/     same for all mem_refs in the loop). If there is no invariant, then we add\n+  \/\/     a dependency that there is no invariant.\n+  \/\/\n+  \/\/ Other mem_refs must have solutions with  the same dependencies, otherwise we\n+  \/\/ cannot ensure that they require the same number of pre-loop iterations.\n+\n+  DEBUG_ONLY( trace_find_pre_q(C_const, C_pre, pre_q); )\n@@ -853,0 +946,2 @@\n+  for (int pre_r = 0; pre_r < pre_q; pre_r++) {\n+    const int eq10_val = AlignmentSolution::mod(C_const + C_pre * pre_r, _aw);\n@@ -854,0 +949,1 @@\n+    DEBUG_ONLY( trace_find_pre_r(C_const, C_pre, pre_q, pre_r, eq10_val); )\n@@ -855,2 +951,11 @@\n-  \/\/ TODO continue\n-  return AlignmentSolution(\"TOOD remove me\");\n+    if (eq10_val == 0) {\n+      assert((C_init == 0) == _init_node->is_ConI(), \"init consistent\");\n+      assert((C_invar == 0) == (_invar == nullptr), \"invar consistent\");\n+\n+      const Node* invar_dependency = _invar;\n+      const int scale_dependency  = (_invar != nullptr || !_init_node->is_ConI()) ? _scale : 0;\n+      return AlignmentSolution(pre_r, pre_q, _mem_ref, _aw,\n+                               invar_dependency, scale_dependency);\n+    }\n+  }\n+  return AlignmentSolution(\"EQ(10*) has no solution for pre_r\");\n@@ -975,0 +1080,46 @@\n+\n+void AlignmentSolver::trace_abs_C_pre_ge_aw(const int C_pre,\n+                                            const bool abs_C_pre_ge_aw) const\n+{\n+  if (is_trace()) {\n+    tty->print_cr(\"  abs(C_pre(%d)) >= aw(%d) -> %s\", C_pre, _aw,\n+                  abs_C_pre_ge_aw ? \"true (pre-loop limit adjustment makes no difference)\" :\n+                                    \"false (pre-loop limit adjustment changes alignment)\");\n+  }\n+}\n+\n+void AlignmentSolver::trace_C_const_mod_aw(const int C_const,\n+                                           const int C_const_mod_aw) const\n+{\n+  if (is_trace()) {\n+      tty->print_cr(\"  EQ(6* ): C_const(%d) %% aw(%d) = %d = 0 (if true: trivial, else no solution)\",\n+                    C_const, _aw, C_const_mod_aw);\n+  }\n+}\n+\n+void AlignmentSolver::trace_find_pre_q(const int C_const,\n+                                       const int C_pre,\n+                                       const int pre_q) const\n+{\n+  if (is_trace()) {\n+    tty->print_cr(\"  Find alignment for C_const(%d), with:\", C_const);\n+    tty->print_cr(\"  pre_iter_C_const = pre_r + pre_q * m  (for any m >= 0)\");\n+    tty->print_cr(\"  (C_const(%d) + C_pre(%d) * pre_r + C_pre(%d) * pre_q * m) %% aw(%d) = 0:\",\n+                  C_const, C_pre, C_pre, _aw);\n+    tty->print_cr(\"  pre_q = aw(%d) \/ abs(C_pre(%d)) = %d\",\n+                  _aw, C_pre, pre_q);\n+    tty->print_cr(\"  EQ(10*): brute force pre_r = 0..%d\", pre_q - 1);\n+  }\n+}\n+\n+void AlignmentSolver::trace_find_pre_r(const int C_const,\n+                                       const int C_pre,\n+                                       const int pre_q,\n+                                       const int pre_r,\n+                                       const int eq10_val) const\n+{\n+  if (is_trace()) {\n+      tty->print_cr(\"   try pre_r = %d: (C_const(%d) + C_pre(%d) * pre_r(%d)) %% aw(%d) = %d = 0\",\n+                    pre_r, C_const, C_pre, pre_r, _aw, eq10_val);\n+  }\n+}\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":153,"deletions":2,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -555,2 +555,12 @@\n-\n-\n+  void trace_abs_C_pre_ge_aw(const int C_pre,\n+                             const bool abs_C_pre_ge_aw) const;\n+  void trace_C_const_mod_aw(const int C_const,\n+                            const int C_const_mod_aw) const;\n+  void trace_find_pre_q(const int C_const,\n+                        const int C_pre,\n+                        const int pre_q) const;\n+  void trace_find_pre_r(const int C_const,\n+                        const int C_pre,\n+                        const int pre_q,\n+                        const int pre_r,\n+                        const int eq10_val) const;\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"}]}