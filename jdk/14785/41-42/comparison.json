{"files":[{"patch":"@@ -3489,1 +3489,5 @@\n-  \/\/ We want to align the address of align_to_ref to some alignment width (aw, power of 2):\n+  \/\/ For the main-loop, we want the address of align_to_ref to be memory aligned\n+  \/\/ with some alignment width (aw, a power of 2). When we enter the main-loop,\n+  \/\/ we know that iv is equals to the pre-loop limit. If we adjust the pre-loop\n+  \/\/ limit by executing adjust_pre_iter many extra iterations, we can change the\n+  \/\/ alignment of the address.\n@@ -3491,1 +3495,1 @@\n-  \/\/   adr = base + offset + invar + scale * iv\n+  \/\/   adr = base + offset + invar + scale * iv                               (1)\n@@ -3493,1 +3497,1 @@\n-  \/\/ The limit of the pre-loop needs to be adjusted.\n+  \/\/ The limit of the pre-loop needs to be adjusted:\n@@ -3495,3 +3499,3 @@\n-  \/\/   old_limit:   current pre-loop limit\n-  \/\/   new_limit:   new pre-loop limit\n-  \/\/   diff_limits: difference between new_limit and old_limit\n+  \/\/   old_limit:       current pre-loop limit\n+  \/\/   new_limit:       new pre-loop limit\n+  \/\/   adjust_pre_iter: additional pre-loop iterations for alignment adjustment\n@@ -3499,1 +3503,2 @@\n-  \/\/ We want to find diff_limits, such that:\n+  \/\/ We want to find adjust_pre_iter, such that the address is aligned when entering\n+  \/\/ the main-loop:\n@@ -3501,2 +3506,3 @@\n-  \/\/   iv = new_limit = old_limit + diff_limits   (exit when iv reaches the new limit)\n-  \/\/   adr % aw = 0          (adr is aligned aligned after pre-loop)\n+  \/\/   iv = new_limit = old_limit + adjust_pre_iter                           (2a, stride > 0)\n+  \/\/   iv = new_limit = old_limit - adjust_pre_iter                           (2b, stride < 0)\n+  \/\/   adr % aw = 0                                                           (3)\n@@ -3504,1 +3510,1 @@\n-  \/\/ We can write:\n+  \/\/ We define boi as:\n@@ -3506,3 +3512,1 @@\n-  \/\/   E = base + offset + invar\n-  \/\/   adr = E + scale * new_limit\n-  \/\/       = E + scale * old_limit + scale * diff_limits\n+  \/\/   boi = base + offset + invar                                            (4)\n@@ -3510,1 +3514,10 @@\n-  \/\/   (E + scale * old_limit + scale * diff_limits) % aw = 0\n+  \/\/ And now we can simplify the address, using (1), (2), and (4):\n+  \/\/\n+  \/\/   adr = boi + scale * new_limit\n+  \/\/   adr = boi + scale * old_limit + scale * adjust_pre_iter                (5a, stride > 0)\n+  \/\/   adr = boi + scale * old_limit - scale * adjust_pre_iter                (5b, stride < 0)\n+  \/\/\n+  \/\/ And hence we can restate (3) with (5), and solve the equation for adjust_pre_iter:\n+  \/\/\n+  \/\/   (boi + scale * old_limit + scale * adjust_pre_iter) % aw = 0           (6a, stride > 0)\n+  \/\/   (boi + scale * old_limit - scale * adjust_pre_iter) % aw = 0           (6b, stride < 0)\n@@ -3521,1 +3534,1 @@\n-  \/\/ Further, if abs(scale) >= aw, then diff_limits has no effect on alignment, and\n+  \/\/ Further, if abs(scale) >= aw, then adjust_pre_iter has no effect on alignment, and\n@@ -3524,3 +3537,19 @@\n-  \/\/ Moreover, for alignment to be acheivabe, E must be a multiple of scale. We cannot\n-  \/\/ check this at compile time, and do not bother to do it at runtime either. If it\n-  \/\/ does not hold, we set a new limit, but it just does not ensure alignment.\n+  \/\/ Moreover, for alignment to be acheivabe, boi must be a multiple of scale. If strict\n+  \/\/ alignment is required (i.e. -XX:+AlignVector), this is guaranteed by the filtering\n+  \/\/ done with the AlignmentSolver \/ AlignmentSolution. If strict alignment is not\n+  \/\/ required, then alignment is still preferrable for performance, but not necessary.\n+  \/\/ In many cases boi will be a multiple of scale, but if it is not, then the adjustment\n+  \/\/ does not guarantee alignment, but the code is still correct.\n+  \/\/\n+  \/\/ Hence, in what follows we assume that boi is a multiple of scale, and in fact all\n+  \/\/ terms in (6) are multiples of scale. Therefore we divide all terms by scale:\n+  \/\/\n+  \/\/   AW = aw \/ abs(scale)            (power of 2)                           (7)\n+  \/\/   BOI = boi \/ abs(scale)                                                 (8)\n+  \/\/\n+  \/\/ and restate (6), using (7) and (8), i.e. we divide (6) by abs(scale):\n+  \/\/\n+  \/\/   (BOI + sign(scale) * old_limit + sign(scale) * adjust_pre_iter) % AW = 0  (9a, stride > 0)\n+  \/\/   (BOI + sign(scale) * old_limit - sign(scale) * adjust_pre_iter) % AW = 0  (9b, stride < 0)\n+  \/\/\n+  \/\/   where: sign(scale) = scale \/ abs(scale) = (scale > 0 ? 1 : -1)\n@@ -3528,1 +3557,3 @@\n-  \/\/ In the following, we use:\n+  \/\/ Note, (9) allows for periodic solutons of adjust_pre_iter, with periodicity AW.\n+  \/\/ But we would like to spend as few iterations in the pre-loop as possible,\n+  \/\/ hence we want the smallest adjust_pre_iter, and so:\n@@ -3530,2 +3561,1 @@\n-  \/\/   V = aw \/ abs(scale)            (power of 2)\n-  \/\/   e = E \/ abs(scale)\n+  \/\/   0 <= adjust_pre_iter < AW                                              (10)\n@@ -3533,4 +3563,1 @@\n-  \/\/ Case 1: scale > 0 && stride > 0 (i.e. diff_limits >= 0)\n-  \/\/   (e + old_limit + diff_limits) % V = 0\n-  \/\/   diff_limits = (V - (e + old_limit)) % V\n-  \/\/   new_limit = old_limit + (-e - old_limit) % V\n+  \/\/ We solve (9) for adjust_pre_iter, in the following 4 cases:\n@@ -3538,4 +3565,3 @@\n-  \/\/ Case 2: scale < 0 && stride > 0 (i.e. diff_limits >= 0)\n-  \/\/   (e - old_limit - diff_limits) % V = 0\n-  \/\/   diff_limits = (e - old_limit) % V\n-  \/\/   new_limit = old_limit + (+e - old_limit) % V\n+  \/\/ Case A: scale > 0 && stride > 0 (i.e. adjust_pre_iter >= 0)\n+  \/\/   (BOI + old_limit + adjust_pre_iter) % AW = 0\n+  \/\/   adjust_pre_iter = (-BOI - old_limit) % AW                              (11a)\n@@ -3543,4 +3569,3 @@\n-  \/\/ Case 3: scale > 0 && stride < 0 (i.e. diff_limits <= 0)\n-  \/\/   (e + old_limit - abs(diff_limits)) % V = 0\n-  \/\/   abs(diff_limits) = (e + old_limit) % V\n-  \/\/   new_limit = old_limit - (+e + old_limit) % V\n+  \/\/ Case B: scale < 0 && stride > 0 (i.e. adjust_pre_iter >= 0)\n+  \/\/   (BOI - old_limit - adjust_pre_iter) % AW = 0\n+  \/\/   adjust_pre_iter = (BOI - old_limit) % AW                               (11b)\n@@ -3548,4 +3573,3 @@\n-  \/\/ Case 4: scale < 0 && stride < 0 (i.e. diff_limits <= 0)\n-  \/\/   (e - old_limit + abs(diff_limits)) % V = 0\n-  \/\/   abs(diff_limits) = (old_limit - e) % V\n-  \/\/   new_limit = old_limit - (-e + old_limit) % V\n+  \/\/ Case C: scale > 0 && stride < 0 (i.e. adjust_pre_iter <= 0)\n+  \/\/   (BOI + old_limit - adjust_pre_iter) % AW = 0\n+  \/\/   adjust_pre_iter = (BOI + old_limit) % AW                               (11c)\n@@ -3553,2 +3577,3 @@\n-  \/\/ We generalize this with the following formula:\n-  \/\/   new_limit = old_limit +- (pm_e +- old_limit) % V\n+  \/\/ Case D: scale < 0 && stride < 0 (i.e. adjust_pre_iter <= 0)\n+  \/\/   (BOI - old_limit + adjust_pre_iter) % AW = 0\n+  \/\/   adjust_pre_iter = (-BOI + old_limit) % AW                              (11d)\n@@ -3556,2 +3581,1 @@\n-  \/\/   pm_e = -+ E \/ abs(scale)\n-  \/\/        = pm_E \/ abs(scale)\n+  \/\/ We now generalize (11), using:\n@@ -3559,2 +3583,17 @@\n-  \/\/   pm_E = -+ (base + offset + invar)\n-  \/\/        = -+ offset -+ base -+ invar\n+  \/\/   OP:   (stride         > 0) ? SUB   : ADD\n+  \/\/   XBOI: (stride * scale > 0) ? -BOI  : BOI\n+  \/\/\n+  \/\/   adjust_pre_iter = (XBOI OP old_limit) % AW                             (12)\n+  \/\/\n+  \/\/ And we construct XBOI, where:\n+  \/\/\n+  \/\/   xboi = -boi = (-base - offset - invar)                                 (13a, stride * scale > 0)\n+  \/\/   xboi = +boi = (+base + offset + invar)                                 (13a, stride * scale < 0)\n+  \/\/\n+  \/\/   XBOI = -BOI\n+  \/\/       = -boi \/ abs(scale)\n+  \/\/       = xboi \/ abs(scale)                                                (14a, stride * scale > 0)\n+  \/\/\n+  \/\/   XBOI = BOI\n+  \/\/       = boi \/ abs(scale)\n+  \/\/       = xboi \/ abs(scale)                                                (14b, stride * scale < 0)\n@@ -3608,1 +3647,1 @@\n-  const int V = aw \/ abs(scale);\n+  const int AW = aw \/ abs(scale);\n@@ -3612,1 +3651,1 @@\n-    tty->print_cr(\" V:        %d\", V);\n+    tty->print_cr(\" AW:        %d\", AW);\n@@ -3616,2 +3655,4 @@\n-  \/\/ 1: Compute pm_E\n-  const bool is_minus = scale * stride > 0;\n+  \/\/ 1: Compute:\n+  \/\/    xboi = (-base - offset - invar)         (stride * scale > 0)\n+  \/\/    xboi = (+base + offset + invar)         (stride * scale < 0)\n+  const bool is_sub = scale * stride > 0;\n@@ -3620,1 +3661,1 @@\n-  Node* pm_E = _igvn.intcon(is_minus ? -offset : offset);\n+  Node* xboi = _igvn.intcon(is_sub ? -offset : offset);\n@@ -3631,2 +3672,2 @@\n-    if (is_minus) {\n-      pm_E = new SubINode(pm_E, invar);\n+    if (is_sub) {\n+      xboi = new SubINode(xboi, invar);\n@@ -3634,1 +3675,1 @@\n-      pm_E = new AddINode(pm_E, invar);\n+      xboi = new AddINode(xboi, invar);\n@@ -3636,2 +3677,2 @@\n-    _igvn.register_new_node_with_optimizer(pm_E);\n-    _phase->set_ctrl(pm_E, pre_ctrl);\n+    _igvn.register_new_node_with_optimizer(xboi);\n+    _phase->set_ctrl(xboi, pre_ctrl);\n@@ -3651,2 +3692,2 @@\n-    if (is_minus) {\n-      pm_E = new SubINode(pm_E, xbase);\n+    if (is_sub) {\n+      xboi = new SubINode(xboi, xbase);\n@@ -3654,1 +3695,1 @@\n-      pm_E = new AddINode(pm_E, xbase);\n+      xboi = new AddINode(xboi, xbase);\n@@ -3656,2 +3697,2 @@\n-    _igvn.register_new_node_with_optimizer(pm_E);\n-    _phase->set_ctrl(pm_E, pre_ctrl);\n+    _igvn.register_new_node_with_optimizer(xboi);\n+    _phase->set_ctrl(xboi, pre_ctrl);\n@@ -3660,1 +3701,2 @@\n-  \/\/ 2: compute pm_e by divide (shift) by abs(scale)\n+  \/\/ 2: Compute: XBOI = xboi \/ abs(scale)\n+  \/\/    The division is executed as shift\n@@ -3662,3 +3704,3 @@\n-  Node* pm_e = new URShiftINode(pm_E, log2_abs_scale);\n-  _igvn.register_new_node_with_optimizer(pm_e);\n-  _phase->set_ctrl(pm_e, pre_ctrl);\n+  Node* XBOI = new URShiftINode(xboi, log2_abs_scale);\n+  _igvn.register_new_node_with_optimizer(XBOI);\n+  _phase->set_ctrl(XBOI, pre_ctrl);\n@@ -3666,2 +3708,2 @@\n-  \/\/ 3: add \/ subtract old_limit\n-  Node* pm_e_pm_old_limit = nullptr;\n+  \/\/ 3: Compute: XBOI_OP_old_limit = XBOI OP old_limit\n+  Node* XBOI_OP_old_limit = nullptr;\n@@ -3669,1 +3711,1 @@\n-    pm_e_pm_old_limit = new SubINode(pm_e, old_limit);\n+    XBOI_OP_old_limit = new SubINode(XBOI, old_limit);\n@@ -3671,12 +3713,19 @@\n-    pm_e_pm_old_limit = new AddINode(pm_e, old_limit);\n-  }\n-  _igvn.register_new_node_with_optimizer(pm_e_pm_old_limit);\n-  _phase->set_ctrl(pm_e_pm_old_limit, pre_ctrl);\n-\n-  \/\/ 4: modulo with V (mask with (V-1))\n-  Node* mask_V = _igvn.intcon(V-1);\n-  Node* pm_e_pm_old_limit_mod_V = new AndINode(pm_e_pm_old_limit, mask_V);\n-  _igvn.register_new_node_with_optimizer(pm_e_pm_old_limit_mod_V);\n-  _phase->set_ctrl(pm_e_pm_old_limit_mod_V, pre_ctrl);\n-\n-  \/\/ 5: compute new limit\n+    XBOI_OP_old_limit = new AddINode(XBOI, old_limit);\n+  }\n+  _igvn.register_new_node_with_optimizer(XBOI_OP_old_limit);\n+  _phase->set_ctrl(XBOI_OP_old_limit, pre_ctrl);\n+\n+  \/\/ 4: Compute:\n+  \/\/    adjust_pre_iter = (XBOI OP old_limit) % AW\n+  \/\/                    = XBOI_OP_old_limit % AW\n+  \/\/                    = XBOI_OP_old_limit AND (AW - 1)\n+  \/\/    Since AW is a power of 2, the modulo operation can be replaced with\n+  \/\/    a bit mask operation.\n+  Node* mask_AW = _igvn.intcon(AW-1);\n+  Node* adjust_pre_iter = new AndINode(XBOI_OP_old_limit, mask_AW);\n+  _igvn.register_new_node_with_optimizer(adjust_pre_iter);\n+  _phase->set_ctrl(adjust_pre_iter, pre_ctrl);\n+\n+  \/\/ 5: Compute:\n+  \/\/    new_limit = old_limit + adjust_pre_iter     (stride > 0)\n+  \/\/    new_limit = old_limit - adjust_pre_iter     (stride < 0)\n@@ -3685,1 +3734,1 @@\n-    new_limit = new SubINode(old_limit, pm_e_pm_old_limit_mod_V);\n+    new_limit = new SubINode(old_limit, adjust_pre_iter);\n@@ -3687,1 +3736,1 @@\n-    new_limit = new AddINode(old_limit, pm_e_pm_old_limit_mod_V);\n+    new_limit = new AddINode(old_limit, adjust_pre_iter);\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":128,"deletions":79,"binary":false,"changes":207,"status":"modified"}]}