{"files":[{"patch":"@@ -1624,1 +1624,1 @@\n-\/\/ Find the set of alignment solutions for load\/store pack p.\n+\/\/ Find the set of alignment solutions for load\/store pack.\n@@ -1647,29 +1647,1 @@\n-\/\/ Ensure that all packs can be aligned. We analyze each pack address, and if and how\n-\/\/ it can be aligned by adjusting the number of pre-loop iterations. This is how the\n-\/\/ pre-loop and unrolled main-loop look like for memref (adr):\n-\/\/\n-\/\/ iv = init\n-\/\/ i = 0 \/\/ single-iteration counter\n-\/\/\n-\/\/ pre-loop:\n-\/\/   iv = init + i * pre_stride\n-\/\/   adr = base + offset + invar + scale * iv\n-\/\/   adr = base + offset + invar + scale * (init + i * pre_stride)\n-\/\/   iv += pre_stride\n-\/\/   i++\n-\/\/\n-\/\/ pre_iter = i \/\/ number of iterations in the pre-loop\n-\/\/ iv = init + pre_iter * pre_stride\n-\/\/\n-\/\/ main_iter = 0 \/\/ main-loop iteration counter\n-\/\/ main_stride = unroll_factor * pre_stride\n-\/\/\n-\/\/ main-loop:\n-\/\/   i = pre_iter + main_iter * unroll_factor\n-\/\/   iv = init + i * pre_stride = init + pre_iter * pre_stride + main_iter * unroll_factor * pre_stride\n-\/\/                              = init + pre_iter * pre_stride + main_iter * main_stride\n-\/\/   adr = base + offset + invar + scale * iv \/\/ must be aligned\n-\/\/   iv += main_stride\n-\/\/   i  += unroll_factor\n-\/\/   main_iter++\n-\/\/\n+\/\/ Ensure all packs are aligned, if AlignVector is on.\n@@ -1678,2 +1650,1 @@\n-\/\/ that the packs impose. If a pack is not compatible with the current solution, we\n-\/\/ remove it from the packset.\n+\/\/ that the packs impose. Remove packs that do not have a compatible solution.\n@@ -1692,3 +1663,0 @@\n-  \/\/ Find an alignment solution: find the set of pre_iter that memory align all packs.\n-  \/\/ Start with the maximal set (pre_iter >= 0) and filter it with the constraints\n-  \/\/ that the packs impose.\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":3,"deletions":35,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -492,2 +492,2 @@\n-  \/\/ Find the set of alignment solutions for load\/store pack p.\n-  AlignmentSolution pack_alignment_solution(Node_List* p);\n+  \/\/ Find the set of alignment solutions for load\/store pack.\n+  AlignmentSolution pack_alignment_solution(Node_List* pack);\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -707,0 +707,1 @@\n+\n@@ -941,1 +942,1 @@\n-  \/\/ Other mem_refs must have solutions with  the same dependencies, otherwise we\n+  \/\/ Other mem_refs must have solutions with the same dependencies, otherwise we\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -266,8 +266,2 @@\n-\/\/ When alignment is required, we must adjust the pre-loop iteration count pre_iter.\n-\/\/ We find the set of pre_iter which guarantee alignment:\n-\/\/\n-\/\/ TODO restate this a bit with since I changed the new proof!\n-\/\/\n-\/\/   pre_iter = pre_r + pre_q * m  (for any m >= 0)\n-\/\/\n-\/\/ Such that the address is aligned for any main_iter >= 0:\n+\/\/ When alignment is required, we must adjust the pre-loop iteration count pre_iter,\n+\/\/ such that the address is aligned for any main_iter >= 0:\n@@ -279,6 +273,1 @@\n-\/\/ Two simplifying restrictions:\n-\/\/   1. In the presence of variable init, all solutions must have the same scale.\n-\/\/   2. In the presence of an invariant, all solutions must have the same invariant\n-\/\/      and the same scale.\n-\/\/\n-\/\/ A solution can be:\n+\/\/ The AlignmentSolver generates solutions of the following forms:\n@@ -290,0 +279,12 @@\n+\/\/\n+\/\/ The Constrained solution is of the following form:\n+\/\/\n+\/\/   pre_iter = pre_iter_C_const  + pre_iter_C_init              + pre_iter_C_invar\n+\/\/            = pre_r + pre_q * m + alignment_init(X * var_init) + alignment_invar(Y * var_invar)\n+\/\/\n+\/\/ Essentially, we get a periodic solution for the C_const term, which\n+\/\/ is shifted by the init and the invar terms. For two solutions to be\n+\/\/ compatible, they must have the same periodic part (or subset), which\n+\/\/ we can easily check with p an q. Compatible solutions must also have\n+\/\/ the same shifting, which we can check with the scale and invar dependency.\n+\/\/\n@@ -458,1 +459,37 @@\n-\/\/ TODO description\n+\/\/ When strict alignment is required (e.g. -XX:+AlignVector), then we must ensure\n+\/\/ that all vector memory accesses can be aligned. We acheive this alignment by\n+\/\/ adjusting the pre-loop limit, which adjusts the number of iterations executed\n+\/\/ in the pre-loop.\n+\/\/\n+\/\/ This is how the pre-loop and unrolled main-loop look like for a memref (adr):\n+\/\/\n+\/\/ iv = init\n+\/\/ i = 0 \/\/ single-iteration counter\n+\/\/\n+\/\/ pre-loop:\n+\/\/   iv = init + i * pre_stride\n+\/\/   adr = base + offset + invar + scale * iv\n+\/\/   adr = base + offset + invar + scale * (init + i * pre_stride)\n+\/\/   iv += pre_stride\n+\/\/   i++\n+\/\/\n+\/\/ pre_iter = i \/\/ number of iterations in the pre-loop\n+\/\/ iv = init + pre_iter * pre_stride\n+\/\/\n+\/\/ main_iter = 0 \/\/ main-loop iteration counter\n+\/\/ main_stride = unroll_factor * pre_stride\n+\/\/\n+\/\/ main-loop:\n+\/\/   i = pre_iter + main_iter * unroll_factor\n+\/\/   iv = init + i * pre_stride = init + pre_iter * pre_stride + main_iter * unroll_factor * pre_stride\n+\/\/                              = init + pre_iter * pre_stride + main_iter * main_stride\n+\/\/   adr = base + offset + invar + scale * iv \/\/ must be aligned\n+\/\/   iv += main_stride\n+\/\/   i  += unroll_factor\n+\/\/   main_iter++\n+\/\/\n+\/\/ For each vector memory access, we can find the set of pre_iter (number of pre-loop\n+\/\/ iterations) which would align its address. The AlignmentSolver finds such a\n+\/\/ AlignmentSolution. We can then check which solutions are compatible, and thus\n+\/\/ decide if we have to (partially) reject vectorization if not all vectors have\n+\/\/ a compatible solutions.\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":52,"deletions":15,"binary":false,"changes":67,"status":"modified"}]}