{"files":[{"patch":"@@ -3498,0 +3498,5 @@\n+  \/\/ Note, that we are defining the modulo operator \"%\" such that the remainder is\n+  \/\/ always positive, see AlignmentSolution::mod(i, q). Since we are only computing\n+  \/\/ modulo with powers of 2, we can instead simply use the last log2(q) bits of\n+  \/\/ a number i, to get \"i % q\". This is performed with a bitmask.\n+  \/\/\n@@ -3737,1 +3742,1 @@\n-  \/\/    a bit mask operation.\n+  \/\/    a bitmask operation.\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -798,1 +798,3 @@\n-  \/\/ We must find a pre_iter, such that adr is aw aligned: adr % aw = 0.\n+  \/\/ We must find a pre_iter, such that adr is aw aligned: adr % aw = 0. Note, that we are defining the\n+  \/\/ modulo operator \"%\" such that the remainder is always positive, see AlignmentSolution::mod(i, q).\n+  \/\/\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -313,0 +313,3 @@\n+\n+    \/\/ Modulo operator: Get positive 0 <= r < q  for positive i, but\n+    \/\/                  get negative 0 >= r > -q for negative i.\n@@ -314,0 +317,2 @@\n+\n+    \/\/ Make negative r into positive ones:\n@@ -315,0 +320,1 @@\n+\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}