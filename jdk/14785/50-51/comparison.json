{"files":[{"patch":"@@ -124,1 +124,1 @@\n-int VPointer::invar_factor() {\n+int VPointer::invar_factor() const {\n@@ -756,1 +756,6 @@\n-  \/\/      and hence can be assumed to already be aw-aligned (base % aw = 0).\n+  \/\/      and as such  ObjectAlignmentInBytes (a power of 2) aligned. We have\n+  \/\/      defined aw = MIN(vector_width, ObjectAlignmentInBytes), which is also\n+  \/\/      a power of 2. And hence we know that \"base\" is thus also aw-aligned:\n+  \/\/\n+  \/\/        base % ObjectAlignmentInBytes = 0     ==>    base % aw = 0\n+  \/\/\n@@ -762,1 +767,1 @@\n-  \/\/        invar = C_invar * var_invar                                                                          (FAC_INVAR)\n+  \/\/        invar = C_invar * var_invar                                             (FAC_INVAR)\n@@ -768,1 +773,1 @@\n-  \/\/        scale * init = C_init * var_init + scale * C_const_init                                              (FAC_INIT)\n+  \/\/        scale * init = C_init * var_init + scale * C_const_init                 (FAC_INIT)\n@@ -893,2 +898,47 @@\n-  \/\/   abs(C_pre) >= aw  AND  C_const % aw == 0\n-  \/\/   -> Adjustment has no effect, C_const aw aligned    -> trivial\n+  \/\/   abs(C_pre) >= aw\n+  \/\/   -> Since abs(C_pre) is a power of two, we have C_pre % aw = 0. Therefore:\n+  \/\/\n+  \/\/        For any pre_iter_C_const: (C_pre * pre_iter_C_const) % aw = 0\n+  \/\/\n+  \/\/        (C_const + C_pre * pre_iter_C_const) % aw = 0\n+  \/\/         C_const                             % aw = 0\n+  \/\/\n+  \/\/      Hence, we can only satisfy (4a) if C_Const is aw aligned:\n+  \/\/\n+  \/\/      C_const % aw == 0:\n+  \/\/      -> (4a) has a trivial solution since we can choose any value for pre_iter_C_Const.\n+  \/\/\n+  \/\/      C_const % aw != 0:\n+  \/\/      -> (4a) has an empty solution since no pre_iter_C_Const can achieve aw alignment.\n+  \/\/\n+  \/\/   abs(C_pre) < aw:\n+  \/\/   -> Since both abs(C_pre) and aw are powers of two, we know:\n+  \/\/\n+  \/\/        There exists integer x > 1: aw = abs(C_pre) * x\n+  \/\/\n+  \/\/      C_const % abs(C_pre) == 0:\n+  \/\/      -> Exists integer z: C_const = C_pre * z\n+  \/\/\n+  \/\/          (C_const   + C_pre * pre_iter_C_const) % aw               = 0\n+  \/\/          ==>\n+  \/\/          (C_pre * z + C_pre * pre_iter_C_const) % aw               = 0\n+  \/\/          ==>\n+  \/\/          (C_pre * z + C_pre * pre_iter_C_const) % (abs(C_pre) * x) = 0\n+  \/\/          ==>\n+  \/\/          (        z +         pre_iter_C_const) %               x  = 0\n+  \/\/          ==>\n+  \/\/          for any m: pre_iter_C_const = m * x - z\n+  \/\/\n+  \/\/        Hence, pre_iter_C_const has a non-trivial (because x > 1) periodic (periodicity x)\n+  \/\/        solution, i.e it has a constrained solution.\n+  \/\/\n+  \/\/      C_const % abs(C_pre) != 0:\n+  \/\/        There exists integer x > 1: aw = abs(C_pre) * x\n+  \/\/\n+  \/\/           C_const                             %  abs(C_pre)      != 0\n+  \/\/          ==>\n+  \/\/          (C_const + C_pre * pre_iter_C_const) %  abs(C_pre)      != 0\n+  \/\/          ==>\n+  \/\/          (C_const + C_pre * pre_iter_C_const) % (abs(C_pre) * x) != 0\n+  \/\/          ==>\n+  \/\/          (C_const + C_pre * pre_iter_C_const) % aw               != 0\n@@ -896,2 +946,2 @@\n-  \/\/   abs(C_pre) >= aw  AND  C_const % aw != 0\n-  \/\/   -> Adjustment has no effect, C_const not aligned   -> empty\n+  \/\/        This is in constradiction with (4a), and therefore there cannot be any solution,\n+  \/\/        i.e. we have an empty solution.\n@@ -899,4 +949,1 @@\n-  \/\/   abs(C_pre) <  aw  AND  C_const % abs(C_pre) == 0\n-  \/\/   -> alignment has effect\n-  \/\/   -> C_const can be aligned with C_pre\n-  \/\/   -> Not trivial, because abs(C_pre) < aw            -> constrained\n+  \/\/ In summary, for (4a):\n@@ -904,3 +951,4 @@\n-  \/\/   abs(C_pre) <  aw  AND  C_const % abs(C_pre) != 0\n-  \/\/   -> alignment has effect\n-  \/\/   -> But C_const cannot be aligned with C_pre        -> empty\n+  \/\/   abs(C_pre) >= aw  AND  C_const % aw == 0          -> trivial\n+  \/\/   abs(C_pre) >= aw  AND  C_const % aw != 0          -> empty\n+  \/\/   abs(C_pre) <  aw  AND  C_const % abs(C_pre) == 0  -> constrained\n+  \/\/   abs(C_pre) <  aw  AND  C_const % abs(C_pre) != 0  -> empty\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":63,"deletions":15,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -90,11 +90,11 @@\n-  bool valid()  { return _adr != nullptr; }\n-  bool has_iv() { return _scale != 0; }\n-\n-  Node* base()             { return _base; }\n-  Node* adr()              { return _adr; }\n-  const MemNode* mem()     { return _mem; }\n-  int   scale_in_bytes()   { return _scale; }\n-  Node* invar()            { return _invar; }\n-  int   offset_in_bytes()  { return _offset; }\n-  int   memory_size()      { return _mem->memory_size(); }\n-  Node_Stack* node_stack() { return _nstack; }\n+  bool valid()             const { return _adr != nullptr; }\n+  bool has_iv()            const { return _scale != 0; }\n+\n+  Node* base()             const { return _base; }\n+  Node* adr()              const { return _adr; }\n+  const MemNode* mem()     const { return _mem; }\n+  int   scale_in_bytes()   const { return _scale; }\n+  Node* invar()            const { return _invar; }\n+  int   offset_in_bytes()  const { return _offset; }\n+  int   memory_size()      const { return _mem->memory_size(); }\n+  Node_Stack* node_stack() const { return _nstack; }\n@@ -103,1 +103,1 @@\n-  int   invar_factor();\n+  int   invar_factor() const;\n@@ -560,0 +560,5 @@\n+  static const MemNode* mem_ref_not_null(const MemNode* mem_ref) {\n+    assert(mem_ref != nullptr, \"not nullptr\");\n+    return mem_ref;\n+  }\n+\n@@ -573,1 +578,1 @@\n-      _mem_ref(           mem_ref),\n+      _mem_ref(           mem_ref_not_null(mem_ref)),\n@@ -575,1 +580,1 @@\n-      _element_size(      mem_ref->memory_size()),\n+      _element_size(      _mem_ref->memory_size()),\n@@ -597,17 +602,17 @@\n-    private:\n-      const int _C_const;\n-      const int _C_invar;\n-      const int _C_init;\n-      const int _C_pre;\n-      const int _aw;\n-\n-    public:\n-      EQ4(const int C_const, const int C_invar, const int C_init, const int C_pre, const int aw) :\n-      _C_const(C_const), _C_invar(C_invar), _C_init(C_init), _C_pre(C_pre), _aw(aw) {}\n-\n-      enum State { TRIVIAL, CONSTRAINED, EMPTY };\n-\n-      State eq4a_state() const {\n-        return (abs(_C_pre) >= _aw) ? ( (C_const_mod_aw() == 0       ) ? TRIVIAL     : EMPTY)\n-                                    : ( (C_const_mod_abs_C_pre() == 0) ? CONSTRAINED : EMPTY);\n-      }\n+   private:\n+    const int _C_const;\n+    const int _C_invar;\n+    const int _C_init;\n+    const int _C_pre;\n+    const int _aw;\n+\n+   public:\n+    EQ4(const int C_const, const int C_invar, const int C_init, const int C_pre, const int aw) :\n+    _C_const(C_const), _C_invar(C_invar), _C_init(C_init), _C_pre(C_pre), _aw(aw) {}\n+\n+    enum State { TRIVIAL, CONSTRAINED, EMPTY };\n+\n+    State eq4a_state() const {\n+      return (abs(_C_pre) >= _aw) ? ( (C_const_mod_aw() == 0       ) ? TRIVIAL     : EMPTY)\n+                                  : ( (C_const_mod_abs_C_pre() == 0) ? CONSTRAINED : EMPTY);\n+    }\n@@ -615,4 +620,4 @@\n-      State eq4b_state() const {\n-        return (abs(_C_pre) >= _aw) ? ( (C_invar_mod_aw() == 0       ) ? TRIVIAL     : EMPTY)\n-                                    : ( (C_invar_mod_abs_C_pre() == 0) ? CONSTRAINED : EMPTY);\n-      }\n+    State eq4b_state() const {\n+      return (abs(_C_pre) >= _aw) ? ( (C_invar_mod_aw() == 0       ) ? TRIVIAL     : EMPTY)\n+                                  : ( (C_invar_mod_abs_C_pre() == 0) ? CONSTRAINED : EMPTY);\n+    }\n@@ -620,4 +625,4 @@\n-      State eq4c_state() const {\n-        return (abs(_C_pre) >= _aw) ? ( (C_init__mod_aw() == 0       ) ? TRIVIAL     : EMPTY)\n-                                    : ( (C_init__mod_abs_C_pre() == 0) ? CONSTRAINED : EMPTY);\n-      }\n+    State eq4c_state() const {\n+      return (abs(_C_pre) >= _aw) ? ( (C_init_mod_aw() == 0       )  ? TRIVIAL     : EMPTY)\n+                                  : ( (C_init_mod_abs_C_pre() == 0)  ? CONSTRAINED : EMPTY);\n+    }\n@@ -625,6 +630,7 @@\n-      int C_const_mod_aw() const        { return AlignmentSolution::mod(_C_const, _aw); }\n-      int C_invar_mod_aw() const        { return AlignmentSolution::mod(_C_invar, _aw); }\n-      int C_init__mod_aw() const        { return AlignmentSolution::mod(_C_init,  _aw); }\n-      int C_const_mod_abs_C_pre() const { return AlignmentSolution::mod(_C_const, abs(_C_pre)); }\n-      int C_invar_mod_abs_C_pre() const { return AlignmentSolution::mod(_C_invar, abs(_C_pre)); }\n-      int C_init__mod_abs_C_pre() const { return AlignmentSolution::mod(_C_init,  abs(_C_pre)); }\n+   private:\n+    int C_const_mod_aw() const        { return AlignmentSolution::mod(_C_const, _aw); }\n+    int C_invar_mod_aw() const        { return AlignmentSolution::mod(_C_invar, _aw); }\n+    int C_init_mod_aw() const         { return AlignmentSolution::mod(_C_init,  _aw); }\n+    int C_const_mod_abs_C_pre() const { return AlignmentSolution::mod(_C_const, abs(_C_pre)); }\n+    int C_invar_mod_abs_C_pre() const { return AlignmentSolution::mod(_C_invar, abs(_C_pre)); }\n+    int C_init_mod_abs_C_pre() const  { return AlignmentSolution::mod(_C_init,  abs(_C_pre)); }\n@@ -632,1 +638,0 @@\n-    public:\n@@ -634,6 +639,9 @@\n-      void trace() const;\n-      const char* state_to_str(State s) const {\n-        if (s == TRIVIAL)     { return \"trivial\"; }\n-        if (s == CONSTRAINED) { return \"constrained\"; }\n-        return \"empty\";\n-      }\n+   public:\n+    void trace() const;\n+\n+   private:\n+    static const char* state_to_str(State s) {\n+      if (s == TRIVIAL)     { return \"trivial\"; }\n+      if (s == CONSTRAINED) { return \"constrained\"; }\n+      return \"empty\";\n+    }\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":60,"deletions":52,"binary":false,"changes":112,"status":"modified"}]}