{"files":[{"patch":"@@ -1653,1 +1653,1 @@\n-  AlignmentSolution const* current = new AlignmentSolutionTrivial();\n+  AlignmentSolution const* current = new TrivialAlignmentSolution();\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -713,1 +713,1 @@\n-    return new AlignmentSolutionEmpty(\"non power-of-2 stride not supported\");\n+    return new EmptyAlignmentSolution(\"non power-of-2 stride not supported\");\n@@ -720,1 +720,1 @@\n-    return new AlignmentSolutionEmpty(\"non power-of-2 scale not supported\");\n+    return new EmptyAlignmentSolution(\"non power-of-2 scale not supported\");\n@@ -761,0 +761,3 @@\n+  \/\/\n+  \/\/        invar = C_invar * var_invar                                                                          (FAC_INVAR)\n+  \/\/\n@@ -764,0 +767,5 @@\n+  \/\/\n+  \/\/        scale * init = C_init * var_init + scale * C_const_init                                              (FAC_INIT)\n+  \/\/        C_init       = (init is constant) ? 0    : (scale * init \/ var_init)\n+  \/\/        C_const_init = (init is constant) ? init : 0\n+  \/\/\n@@ -792,1 +800,1 @@\n-  \/\/   C_main % aw = 0                                                                                           (2*)\n+  \/\/   C_main % aw = 0                                                                                           (2)\n@@ -799,1 +807,1 @@\n-    return new AlignmentSolutionEmpty(\"EQ(2*) not satisfied (cannot align across main-loop iterations)\");\n+    return new EmptyAlignmentSolution(\"EQ(2) not satisfied (cannot align across main-loop iterations)\");\n@@ -821,1 +829,1 @@\n-  \/\/   (C_init  * var_init  + C_pre * pre_iter_C_init ) % aw = 0                 (4a)\n+  \/\/   (C_const             + C_pre * pre_iter_C_const) % aw = 0                 (4a)\n@@ -823,1 +831,1 @@\n-  \/\/   (C_const             + C_pre * pre_iter_C_const) % aw = 0                 (4c)\n+  \/\/   (C_init  * var_init  + C_pre * pre_iter_C_init ) % aw = 0                 (4c)\n@@ -830,2 +838,5 @@\n-  \/\/ We can only guarantee solutions to (4a) and (4b) if C_init and C_invar are zero or\n-  \/\/ multiples of C_pre:\n+  \/\/ Equations (4a, b, c) can have one of these states:\n+  \/\/\n+  \/\/   trivial:     The solution can be any integer.\n+  \/\/   constrained: There is a (periodic) solution, but it is not trivial.\n+  \/\/   empty:       Statically we cannot guarantee a solution for all var_invar and var_init.\n@@ -833,2 +844,1 @@\n-  \/\/   C_init  % abs(C_pre) = 0                                                  (5a*)\n-  \/\/   C_invar % abs(C_pre) = 0                                                  (5b*)\n+  \/\/ We look at (4a):\n@@ -836,1 +846,2 @@\n-  \/\/ Which means there are integers X and Y such that:\n+  \/\/   abs(C_pre) >= aw  AND  C_const % aw == 0\n+  \/\/   -> Adjustment has no effect, C_const aw aligned    -> trivial\n@@ -838,2 +849,2 @@\n-  \/\/   C_init  = C_pre * X       (X = 0 if C_init  = 0, else X = C_init  \/ C_pre)\n-  \/\/   C_invar = C_pre * Y       (Y = 0 if C_invar = 0, else Y = C_invar \/ C_pre)\n+  \/\/   abs(C_pre) >= aw  AND  C_const % aw != 0\n+  \/\/   -> Adjustment has no effect, C_const not aligned   -> empty\n@@ -841,3 +852,4 @@\n-  \/\/   (C_init    * var_init  + C_pre * pre_iter_C_init ) % aw =\n-  \/\/   (C_pre * X * var_init  + C_pre * pre_iter_C_init ) % aw =\n-  \/\/   (C_pre * (X * var_init  + pre_iter_C_init)       ) % aw = 0\n+  \/\/   abs(C_pre) <  aw  AND  C_const % abs(C_pre) == 0\n+  \/\/   -> alignment has effect\n+  \/\/   -> C_const can be aligned with C_pre\n+  \/\/   -> Not trivial, because abs(C_pre) < aw            -> constrained\n@@ -845,3 +857,3 @@\n-  \/\/   (C_invar   * var_invar + C_pre * pre_iter_C_invar) % aw =\n-  \/\/   (C_pre * Y * var_invar + C_pre * pre_iter_C_invar) % aw =\n-  \/\/   (C_pre * (Y * var_invar + pre_iter_C_invar)      ) % aw = 0\n+  \/\/   abs(C_pre) <  aw  AND  C_const % abs(C_pre) != 0\n+  \/\/   -> alignment has effect\n+  \/\/   -> But C_const cannot be aligned with C_pre        -> empty\n@@ -849,2 +861,1 @@\n-  \/\/ And hence, we know that there are solutions for pre_iter_C_init and pre_iter_C_invar,\n-  \/\/ based on X, Y, var_init, and var_invar. We call them:\n+  \/\/ With analogue argumentation for (4b):\n@@ -852,2 +863,4 @@\n-  \/\/   pre_iter_C_init  = alignment_init (X * var_init)\n-  \/\/   pre_iter_C_invar = alignment_invar(Y * var_invar)\n+  \/\/   abs(C_pre) >= aw  AND  C_invar % aw == 0           -> trivial\n+  \/\/   abs(C_pre) >= aw  AND  C_invar % aw != 0           -> empty\n+  \/\/   abs(C_pre) <  aw  AND  C_invar % abs(C_pre) == 0   -> constrained\n+  \/\/   abs(C_pre) <  aw  AND  C_invar % abs(C_pre) != 0   -> empty\n@@ -855,2 +868,13 @@\n-  const int C_init_mod_abs_C_pre  = AlignmentSolution::mod(C_init,  abs(C_pre));\n-  const int C_invar_mod_abs_C_pre = AlignmentSolution::mod(C_invar, abs(C_pre));\n+  \/\/ With analogue argumentation for (4c):\n+  \/\/\n+  \/\/   abs(C_pre) >= aw  AND  C_init  % aw == 0           -> trivial\n+  \/\/   abs(C_pre) >= aw  AND  C_init  % aw != 0           -> empty\n+  \/\/   abs(C_pre) <  aw  AND  C_init  % abs(C_pre) == 0   -> constrained\n+  \/\/   abs(C_pre) <  aw  AND  C_init  % abs(C_pre) != 0   -> empty\n+  \/\/\n+  \/\/ Out of these states follows the state for the solution of pre_iter:\n+  \/\/\n+  \/\/   Trivial:     If (4a, b, c) are all trivial.\n+  \/\/   Empty:       If any of (4a, b, c) is empty, because then we cannot guarantee a solution\n+  \/\/                for pre_iter, for all possible invar and init values.\n+  \/\/   Constrained: Else. Incidentally, (4a, b, c) are all constrained themselves, as we argue below.\n@@ -858,1 +882,10 @@\n-  DEBUG_ONLY( trace_init_and_invar_alignment(C_invar, C_init, C_pre, C_invar_mod_abs_C_pre, C_init_mod_abs_C_pre); )\n+  const EQ4 eq4(C_const, C_invar, C_init, C_pre, _aw);\n+  const EQ4::State eq4a_state = eq4.eq4a_state();\n+  const EQ4::State eq4b_state = eq4.eq4b_state();\n+  const EQ4::State eq4c_state = eq4.eq4c_state();\n+\n+#ifdef ASSERT\n+  if (is_trace()) {\n+    eq4.trace();\n+  }\n+#endif\n@@ -860,2 +893,5 @@\n-  if (C_init_mod_abs_C_pre != 0) {\n-    return new AlignmentSolutionEmpty(\"EQ(5a*) not satisfied (cannot align init)\");\n+  \/\/ If (4a, b, c) are all trivial, then also the solution for pre_iter is trivial:\n+  if (eq4a_state == EQ4::State::TRIVIAL &&\n+      eq4b_state == EQ4::State::TRIVIAL &&\n+      eq4c_state == EQ4::State::TRIVIAL) {\n+    return new TrivialAlignmentSolution();\n@@ -863,2 +899,7 @@\n-  if (C_invar_mod_abs_C_pre != 0) {\n-    return new AlignmentSolutionEmpty(\"EQ(5b*) not satisfied (cannot align invar)\");\n+\n+  \/\/ If any of (4a, b, c) is empty, then we also cannot guarantee a solution for pre_iter, for\n+  \/\/ any init and invar, hence the solution for pre_iter is empty:\n+  if (eq4a_state == EQ4::State::EMPTY ||\n+      eq4b_state == EQ4::State::EMPTY ||\n+      eq4c_state == EQ4::State::EMPTY) {\n+    return new EmptyAlignmentSolution(\"EQ(4a, b, c) not all non-empty: cannot align const, invar and init terms individually\");\n@@ -867,2 +908,3 @@\n-  \/\/ Having solved (4a) and (4b), we now want to find solutions for (4c), i.e. we need\n-  \/\/ to show that the C_const term can be aligned with pre_iter_C_const.\n+  \/\/ If abs(C_pre) >= aw, then the solutions to (4a, b, c) are all either trivial or empty, and\n+  \/\/ hence we would have found the solution to pre_iter above as either trivial or empty. Thus\n+  \/\/ we now know that:\n@@ -870,1 +912,1 @@\n-  \/\/ We can assume that abs(C_pre) as well as aw are both powers of 2.\n+  \/\/   abs(C_pre) < aw\n@@ -872,1 +914,9 @@\n-  \/\/ If abs(C_pre) >= aw, then:\n+  assert(abs(C_pre) < _aw, \"implied by constrained case\");\n+\n+  \/\/ And since abs(C_pre) < aw, the solutions of (4a, b, c) can now only be constrained or empty.\n+  \/\/ But since we already handled the empty case, the solutions are now all constrained.\n+  assert(eq4a_state == EQ4::State::CONSTRAINED &&\n+         eq4a_state == EQ4::State::CONSTRAINED &&\n+         eq4a_state == EQ4::State::CONSTRAINED, \"all must be constrained now\");\n+\n+  \/\/ And since they are all constrained, we must have:\n@@ -874,2 +924,3 @@\n-  \/\/   for any pre_iter >= 0:         (C_pre * pre_iter        ) % aw = 0\n-  \/\/   for any pre_iter_C_const >= 0: (C_pre * pre_iter_C_const) % aw = 0\n+  \/\/   C_const % abs(C_pre) = 0                                                  (5a)\n+  \/\/   C_invar % abs(C_pre) = 0                                                  (5b)\n+  \/\/   C_init  % abs(C_pre) = 0                                                  (5c)\n@@ -877,3 +928,5 @@\n-  \/\/ which implies that pre_iter (and pre_iter_C_const) have no effect on the alignment of\n-  \/\/ the C_const term. We thus either have a trivial solution, and any pre_iter aligns\n-  \/\/ the address, or there is no solution. To have the trivial solution, we require:\n+  assert(AlignmentSolution::mod(C_const, abs(C_pre)) == 0, \"EQ(5a): C_const must be alignable\");\n+  assert(AlignmentSolution::mod(C_invar, abs(C_pre)) == 0, \"EQ(5b): C_invar must be alignable\");\n+  assert(AlignmentSolution::mod(C_init,  abs(C_pre)) == 0, \"EQ(5c): C_init  must be alignable\");\n+\n+  \/\/ With (5a, b, c), we know that there are integers X, Y, Z:\n@@ -881,1 +934,3 @@\n-  \/\/   C_const % aw = 0                                                       (6*)\n+  \/\/   C_const = X * abs(C_pre)   ==>   X = C_const \/ abs(C_pre)                 (6a)\n+  \/\/   C_invar = Y * abs(C_pre)   ==>   Y = C_invar \/ abs(C_pre)                 (6b)\n+  \/\/   C_init  = Z * abs(C_pre)   ==>   Z = C_init  \/ abs(C_pre)                 (6c)\n@@ -883,13 +938,9 @@\n-  assert(abs(C_pre) > 0 && is_power_of_2(abs(C_pre)), \"abs(C_pre) must be power of 2\");\n-  const bool abs_C_pre_ge_aw = abs(C_pre) >= _aw;\n-\n-  DEBUG_ONLY( trace_abs_C_pre_ge_aw(C_pre, abs_C_pre_ge_aw); )\n-\n-  if (abs_C_pre_ge_aw) {\n-    const int C_const_mod_aw = AlignmentSolution::mod(C_const, _aw);\n-\n-    DEBUG_ONLY( trace_C_const_mod_aw(C_const, C_const_mod_aw); )\n-\n-    \/\/ The C_init and C_invar terms are trivially aligned.\n-    assert(AlignmentSolution::mod(C_init,  _aw) == 0,  \"implied by abs(C_pre) >= aw and (5a*)\");\n-    assert(AlignmentSolution::mod(C_invar, _aw) == 0,  \"implied by abs(C_pre) >= aw and (5b*)\");\n+  \/\/ Futher, we define:\n+  \/\/\n+  \/\/   sign(C_pre) = C_pre \/ abs(C_pre) = (C_pre > 0) ? 1 : -1,                  (7)\n+  \/\/\n+  \/\/ We know that abs(C_pre) as well as aw are a powers of 2, and since (5) we can define integer q:\n+  \/\/\n+  \/\/   q = aw \/ abs(C_pre)                                                       (8)\n+  \/\/\n+  const int q = _aw \/ abs(C_pre);\n@@ -897,7 +948,1 @@\n-    if (C_const_mod_aw != 0) {\n-      return new AlignmentSolutionEmpty(\"EQ(6*) not satisfied: C_const not aligned\");\n-    } else {\n-      \/\/ Solution is trivial, holds for any pre-loop limit.\n-      return new AlignmentSolutionTrivial();\n-    }\n-  }\n+  assert(q >= 2, \"implied by constrained solution\");\n@@ -905,3 +950,1 @@\n-  \/\/ Otherwise, if abs(C_pre) < aw, we find all solutions for pre_iter_C_const in (4c).\n-  \/\/ We state pre_iter_C_const in terms of the smallest possible pre_q and pre_r, such\n-  \/\/ that 0 <= pre_r < pre_q:\n+  \/\/ We now know that all terms in (4a, b, c) are divisible by abs(C_pre):\n@@ -909,1 +952,3 @@\n-  \/\/   pre_iter_C_const = pre_r + pre_q * m  (for any m >= 0)                     (7)\n+  \/\/   (C_const                    \/ abs(C_pre) + C_pre * pre_iter_C_const \/  abs(C_pre)) % (aw \/ abs(C_pre)) =\n+  \/\/   (X * abs(C_pre)             \/ abs(C_pre) + C_pre * pre_iter_C_const \/  abs(C_pre)) % (aw \/ abs(C_pre)) =\n+  \/\/   (X                                       +         pre_iter_C_const * sign(C_pre)) % q                 = 0  (9a)\n@@ -911,1 +956,3 @@\n-  \/\/ We can now restate (4c) with (7):\n+  \/\/   -> pre_iter_C_const * sign(C_pre) = mx1 * q -               X\n+  \/\/   -> pre_iter_C_const               = mx2 * q - sign(C_pre) * X                                               (10a)\n+  \/\/      (for any integers mx1, mx2)\n@@ -913,3 +960,3 @@\n-  \/\/   (C_const + C_pre * pre_iter_C_const         ) % aw = 0                     (take (4c))\n-  \/\/   (C_const + C_pre * (pre_r + pre_q * m)      ) % aw = 0                     (apply (7))\n-  \/\/   (C_const + C_pre * pre_r + C_pre * pre_q * m) % aw = 0                     (8)\n+  \/\/   (C_invar        * var_invar \/ abs(C_pre) + C_pre * pre_iter_C_invar \/  abs(C_pre)) % (aw \/ abs(C_pre)) =\n+  \/\/   (Y * abs(C_pre) * var_invar \/ abs(C_pre) + C_pre * pre_iter_C_invar \/  abs(C_pre)) % (aw \/ abs(C_pre)) =\n+  \/\/   (Y              * var_invar              +         pre_iter_C_invar * sign(C_pre)) % q                 = 0  (9b)\n@@ -917,1 +964,3 @@\n-  \/\/ Since this holds for any m >= 0, we require:\n+  \/\/   -> pre_iter_C_invar * sign(C_pre) = my1 * q -               Y * var_invar\n+  \/\/   -> pre_iter_C_invar               = my2 * q - sign(C_pre) * Y * var_invar                                   (10b)\n+  \/\/      (for any integers my1, my2)\n@@ -919,2 +968,3 @@\n-  \/\/   (C_pre * pre_q) % aw = 0                                                   (9)\n-  \/\/   (C_const + C_pre * pre_r) % aw = 0                                         (10*)\n+  \/\/   (C_init          * var_init  \/ abs(C_pre) + C_pre * pre_iter_C_init \/  abs(C_pre)) % (aw \/ abs(C_pre)) =\n+  \/\/   (Z * abs(C_pre)  * var_init  \/ abs(C_pre) + C_pre * pre_iter_C_init \/  abs(C_pre)) % (aw \/ abs(C_pre)) =\n+  \/\/   (Z * var_init                             +         pre_iter_C_init * sign(C_pre)) % q                 = 0  (9c)\n@@ -922,1 +972,3 @@\n-  \/\/ Given that abs(C_pre) is a powers of 2, and abs(C_pre) < aw:\n+  \/\/   -> pre_iter_C_init  * sign(C_pre) = mz1 * q -               Z * var_init\n+  \/\/   -> pre_iter_C_init                = mz2 * q - sign(C_pre) * Z * var_init                                    (10c)\n+  \/\/      (for any integers mz1, mz2)\n@@ -924,1 +976,0 @@\n-  const int pre_q = _aw \/ abs(C_pre);\n@@ -926,2 +977,2 @@\n-  \/\/ We brute force the solution for pre_r by enumerating all values 0..pre_q-1 and\n-  \/\/ checking EQ(10*).\n+  \/\/ Having solved the equations using the division, we can re-substitute X, Y, and Z, and apply (FAC_INVAR) as\n+  \/\/ well as (FAC_INIT):\n@@ -929,2 +980,4 @@\n-  \/\/ Assuming we found a solution for (4c), and also for (4a) and (4b), we know that\n-  \/\/ the solution to pre_iter is non-trivial:\n+  \/\/   pre_iter_C_const = mx2 * q - sign(C_pre) * X\n+  \/\/                    = mx2 * q - sign(C_pre) * C_const             \/ abs(C_pre)\n+  \/\/                    = mx2 * q - C_const \/ C_pre\n+  \/\/                    = mx2 * q - C_const \/ (scale * pre_stride)                                  (11a)\n@@ -932,2 +985,1 @@\n-  \/\/   pre_iter = pre_iter_C_const  + pre_iter_C_init              + pre_iter_C_invar\n-  \/\/            = pre_r + pre_q * m + alignment_init(X * var_init) + alignment_invar(Y * var_invar)\n+  \/\/ If there is an invariant:\n@@ -935,15 +987,5 @@\n-  \/\/ Hence, the solution for pre_iter depends on:\n-  \/\/   - Always: pre_r and pre_q\n-  \/\/   - If a variable init is present (i.e. C_init = scale), then we know that to\n-  \/\/     satisfy (5a*), we must have abs(pre_stride) = 1, X = 1 and C_pre = scale.\n-  \/\/     The solution thus depends on var_init = init \/ scale. We thus have a\n-  \/\/     dependency on scale. We could also add a dependency for init, but since\n-  \/\/     it is the same for all mem_refs in the loop this is unnecessary. If init\n-  \/\/     is constant, then we could add a dependency that there is no variable init.\n-  \/\/     But since init is the same for all mem_refs, this is unecessary.\n-  \/\/   - If an invariant is present (i.e. C_invar = abs(invar_factor)), then we know\n-  \/\/     from (5b*), that Y = abs(invar_factor) \/ (scale * pre_stride). The solution\n-  \/\/     depends on Y * var_invar = abs(invar_factor) * var_invar \/ (scale * pre_stride),\n-  \/\/     hence we have to add a dependency for invar, and scale (pre_stride is the\n-  \/\/     same for all mem_refs in the loop). If there is no invariant, then we add\n-  \/\/     a dependency that there is no invariant.\n+  \/\/   pre_iter_C_invar = my2 * q - sign(C_pre) * Y       * var_invar\n+  \/\/                    = my2 * q - sign(C_pre) * C_invar * var_invar \/ abs(C_pre)\n+  \/\/                    = my2 * q - sign(C_pre) * invar               \/ abs(C_pre)\n+  \/\/                    = my2 * q - invar \/ C_pre\n+  \/\/                    = my2 * q - invar \/ (scale * pre_stride)                                    (11b, with invar)\n@@ -951,7 +993,46 @@\n-  \/\/ Other mem_refs must have solutions with the same dependencies, otherwise we\n-  \/\/ cannot ensure that they require the same number of pre-loop iterations.\n-\n-  DEBUG_ONLY( trace_find_pre_q(C_const, C_pre, pre_q); )\n-\n-  for (int pre_r = 0; pre_r < pre_q; pre_r++) {\n-    const int eq10_val = AlignmentSolution::mod(C_const + C_pre * pre_r, _aw);\n+  \/\/ If there is no invariant (i.e. C_invar = 0 ==> Y = 0):\n+  \/\/\n+  \/\/   pre_iter_C_invar = my2 * q                                                                   (11b, no invar)\n+  \/\/\n+  \/\/ If init is variable (i.e. C_init = scale * init \/ var_init):\n+  \/\/\n+  \/\/   pre_iter_C_init  = mz2 * q - sign(C_pre) * Z       * var_init\n+  \/\/                    = mz2 * q - sign(C_pre) * C_init  * var_init  \/ abs(C_pre)\n+  \/\/                    = mz2 * q - sign(C_pre) * scale * init        \/ abs(C_pre)\n+  \/\/                    = mz2 * q - scale * init \/ C_pre\n+  \/\/                    = mz2 * q - scale * init \/ (scale * pre_stride)\n+  \/\/                    = mz2 * q - init \/ pre_stride                                               (11c, variable init)\n+  \/\/\n+  \/\/ If init is variable (i.e. C_init = 0 ==> Z = 0):\n+  \/\/\n+  \/\/   pre_iter_C_init  = mz2 * q                                                                   (11c, constant init)\n+  \/\/\n+  \/\/ Note, that the solutions found by (11a, b, c) are all periodic with periodicity q. We combine them,\n+  \/\/ with m = mx2 + my2 + mz2:\n+  \/\/\n+  \/\/   pre_iter =   pre_iter_C_const + pre_iter_C_invar + pre_iter_C_init\n+  \/\/            =   mx2 * q  - C_const \/ (scale * pre_stride)\n+  \/\/              + my2 * q [- invar \/ (scale * pre_stride) ]\n+  \/\/              + mz2 * q [- init \/ pre_stride            ]\n+  \/\/\n+  \/\/            =   m * q                                 (periodic part)\n+  \/\/              - C_const \/ (scale * pre_stride)        (align constant term)\n+  \/\/             [- invar \/ (scale * pre_stride)   ]      (align invariant term, if present)\n+  \/\/             [- init \/ pre_stride              ]      (align variable init term, if present)    (12)\n+  \/\/\n+  \/\/ We can still simply simplifiy this solution, with:\n+  \/\/\n+  \/\/   r = (-C_const \/ (scale * pre_stride)) % q                                                    (13)\n+  \/\/\n+  const int r = AlignmentSolution::mod(-C_const \/ (_scale * _pre_stride), q);\n+  \/\/\n+  \/\/   pre_iter = m * q + r\n+  \/\/                   [- invar \/ (scale * pre_stride)  ]\n+  \/\/                   [- init \/ pre_stride             ]                                           (14)\n+  \/\/\n+  \/\/ We thus get a solution that can be stated in terms of:\n+  \/\/\n+  \/\/   q (periodicity), r (constant alignment), invar, scale, pre_stride, init\n+  \/\/\n+  \/\/ However, pre_stride and init are shared by all mem_ref in the loop, hence we do not need to provide\n+  \/\/ them in the solution description.\n@@ -959,1 +1040,1 @@\n-    DEBUG_ONLY( trace_find_pre_r(C_const, C_pre, pre_q, pre_r, eq10_val); )\n+  DEBUG_ONLY( trace_constrained_solution(C_const, C_invar, C_init, C_pre, q, r); )\n@@ -961,3 +1042,1 @@\n-    if (eq10_val == 0) {\n-      assert((C_init == 0) == _init_node->is_ConI(), \"init consistent\");\n-      assert((C_invar == 0) == (_invar == nullptr), \"invar consistent\");\n+  return new ConstrainedAlignmentSolution(_mem_ref, q, r, _invar, _scale);\n@@ -965,7 +1044,51 @@\n-      const Node* invar_dependency = _invar;\n-      const int scale_dependency  = (_invar != nullptr || !_init_node->is_ConI()) ? _scale : 0;\n-      return new AlignmentSolutionConstrained(pre_r, pre_q, _mem_ref,\n-                                              invar_dependency, scale_dependency);\n-    }\n-  }\n-  return new AlignmentSolutionEmpty(\"EQ(10*) has no solution for pre_r\");\n+  \/\/ APPENDIX:\n+  \/\/ We can now verify the success of the solution given by (12):\n+  \/\/\n+  \/\/   adr % aw =\n+  \/\/\n+  \/\/   -> Simple form\n+  \/\/   (base + offset + invar + scale * iv) % aw =\n+  \/\/\n+  \/\/   -> Expand iv\n+  \/\/   (base + offset + invar + scale * (init + pre_stride * pre_iter + main_stride * main_iter)) % aw =\n+  \/\/\n+  \/\/   -> Reshape\n+  \/\/   (base + offset + invar\n+  \/\/         + scale * init\n+  \/\/         + scale * pre_stride * pre_iter\n+  \/\/         + scale * main_stride * main_iter)) % aw =\n+  \/\/\n+  \/\/   -> base aligned: base % aw = 0\n+  \/\/   -> main-loop iterations aligned (2): C_main % aw = (scale * main_stride) % aw = 0\n+  \/\/   (offset + invar + scale * init + scale * pre_stride * pre_iter) % aw =\n+  \/\/\n+  \/\/   -> apply (12)\n+  \/\/   (offset + invar + scale * init\n+  \/\/           + scale * pre_stride * (m * q - C_const \/ (scale * pre_stride)\n+  \/\/                                        [- invar \/ (scale * pre_stride) ]\n+  \/\/                                        [- init \/ pre_stride            ]\n+  \/\/                                  )\n+  \/\/   ) % aw =\n+  \/\/\n+  \/\/   -> expand C_const = offset [+ init * scale]  (if init const)\n+  \/\/   (offset + invar + scale * init\n+  \/\/           + scale * pre_stride * (m * q - offset \/ (scale * pre_stride)\n+  \/\/                                        [- init \/ pre_stride            ]             (if init constant)\n+  \/\/                                        [- invar \/ (scale * pre_stride) ]             (if invar present)\n+  \/\/                                        [- init \/ pre_stride            ]             (if init variable)\n+  \/\/                                  )\n+  \/\/   ) % aw =\n+  \/\/\n+  \/\/   -> assuming invar = 0 if it is not present\n+  \/\/   -> merge the two init terms (variable or constant)\n+  \/\/   -> apply (8): q = aw \/ (abs(C_pre)) = aw \/ abs(scale * pre_stride)\n+  \/\/   -> and hence: (scale * pre_stride * q) % aw = 0\n+  \/\/   -> all terms are cancled out\n+  \/\/   (offset + invar + scale * init\n+  \/\/           + scale * pre_stride * m * q                             -> aw aligned\n+  \/\/           - scale * pre_stride * offset \/ (scale * pre_stride)     -> = offset\n+  \/\/           - scale * pre_stride * init \/ pre_stride                 -> = scale * init\n+  \/\/           - scale * pre_stride * invar \/ (scale * pre_stride)      -> = invar\n+  \/\/   ) % aw = 0\n+  \/\/\n+  \/\/ The solution given by (12) does indeed guarantee alignment.\n@@ -1066,1 +1189,1 @@\n-    tty->print(\"  EQ(1  ): (C_const(%d) + C_invar(%d) * var_invar + C_init(%d) * var_init\",\n+    tty->print(\"  EQ(1 ): (C_const(%d) + C_invar(%d) * var_invar + C_init(%d) * var_init\",\n@@ -1071,1 +1194,1 @@\n-    tty->print(\"  EQ(2* ): C_main(%d) %% aw(%d) = %d = 0\",\n+    tty->print(\"  EQ(2 ): C_main(%d) %% aw(%d) = %d = 0\",\n@@ -1077,13 +1200,4 @@\n-void AlignmentSolver::trace_init_and_invar_alignment(const int C_invar,\n-                                                     const int C_init,\n-                                                     const int C_pre,\n-                                                     const int C_invar_mod_abs_C_pre,\n-                                                     const int C_init_mod_abs_C_pre) const\n-{\n-  if (is_trace()) {\n-    tty->print_cr(\"  EQ(5a*): C_init(%d) %% abs(C_pre(%d)) = %d = 0   (if false: cannot align init)\",\n-                  C_init, C_pre, C_init_mod_abs_C_pre);\n-    tty->print_cr(\"  EQ(5b*): C_invar(%d) %% abs(C_pre(%d)) = %d = 0  (if false: cannot align invar)\",\n-                  C_invar, C_pre, C_invar_mod_abs_C_pre);\n-  }\n-}\n+void AlignmentSolver::EQ4::trace() const {\n+  tty->print_cr(\"  EQ(4a): (C_const(%3d)             + C_pre(%d) * pre_iter_C_const) %% aw(%d) = 0  (align const term individually)\",\n+                _C_const, _C_pre, _aw);\n+  tty->print_cr(\"          -> %s\", state_to_str(eq4a_state()));\n@@ -1091,9 +1205,3 @@\n-void AlignmentSolver::trace_abs_C_pre_ge_aw(const int C_pre,\n-                                            const bool abs_C_pre_ge_aw) const\n-{\n-  if (is_trace()) {\n-    tty->print_cr(\"  abs(C_pre(%d)) >= aw(%d) -> %s\", C_pre, _aw,\n-                  abs_C_pre_ge_aw ? \"true (pre-loop limit adjustment makes no difference)\" :\n-                                    \"false (pre-loop limit adjustment changes alignment)\");\n-  }\n-}\n+  tty->print_cr(\"  EQ(4a): (C_invar(%3d) * var_invar + C_pre(%d) * pre_iter_C_invar) %% aw(%d) = 0  (align invar term individually)\",\n+                _C_invar, _C_pre, _aw);\n+  tty->print_cr(\"          -> %s\", state_to_str(eq4b_state()));\n@@ -1101,7 +1209,3 @@\n-void AlignmentSolver::trace_C_const_mod_aw(const int C_const,\n-                                           const int C_const_mod_aw) const\n-{\n-  if (is_trace()) {\n-      tty->print_cr(\"  EQ(6* ): C_const(%d) %% aw(%d) = %d = 0 (if true: trivial, else no solution)\",\n-                    C_const, _aw, C_const_mod_aw);\n-  }\n+  tty->print_cr(\"  EQ(4a): (C_init( %3d) * var_init  + C_pre(%d) * pre_iter_C_init ) %% aw(%d) = 0  (align init term individually)\",\n+                _C_init, _C_pre, _aw);\n+  tty->print_cr(\"          -> %s\", state_to_str(eq4c_state()));\n@@ -1110,3 +1214,6 @@\n-void AlignmentSolver::trace_find_pre_q(const int C_const,\n-                                       const int C_pre,\n-                                       const int pre_q) const\n+void AlignmentSolver::trace_constrained_solution(const int C_const,\n+                                                 const int C_invar,\n+                                                 const int C_init,\n+                                                 const int C_pre,\n+                                                 const int q,\n+                                                 const int r) const\n@@ -1115,19 +1222,36 @@\n-    tty->print_cr(\"  Find alignment for C_const(%d), with:\", C_const);\n-    tty->print_cr(\"  pre_iter_C_const = pre_r + pre_q * m  (for any m >= 0)\");\n-    tty->print_cr(\"  (C_const(%d) + C_pre(%d) * pre_r + C_pre(%d) * pre_q * m) %% aw(%d) = 0:\",\n-                  C_const, C_pre, C_pre, _aw);\n-    tty->print_cr(\"  pre_q = aw(%d) \/ abs(C_pre(%d)) = %d\",\n-                  _aw, C_pre, pre_q);\n-    tty->print_cr(\"  EQ(10*): brute force pre_r = 0..%d\", pre_q - 1);\n-  }\n-}\n-\n-void AlignmentSolver::trace_find_pre_r(const int C_const,\n-                                       const int C_pre,\n-                                       const int pre_q,\n-                                       const int pre_r,\n-                                       const int eq10_val) const\n-{\n-  if (is_trace()) {\n-      tty->print_cr(\"   try pre_r = %d: (C_const(%d) + C_pre(%d) * pre_r(%d)) %% aw(%d) = %d = 0\",\n-                    pre_r, C_const, C_pre, pre_r, _aw, eq10_val);\n+    tty->print_cr(\"  EQ(4a, b, c) all constrained, hence:\");\n+    tty->print_cr(\"  EQ(5a): C_const(%3d) %% abs(C_pre(%d)) = 0\", C_const, C_pre);\n+    tty->print_cr(\"  EQ(5b): C_invar(%3d) %% abs(C_pre(%d)) = 0\", C_invar, C_pre);\n+    tty->print_cr(\"  EQ(5c): C_init( %3d) %% abs(C_pre(%d)) = 0\", C_init,  C_pre);\n+\n+    tty->print_cr(\"  All terms in EQ(4a, b, c) are divisible by abs(C_pre(%d)).\", C_pre);\n+    const int X    = C_const \/ abs(C_pre);\n+    const int Y    = C_invar \/ abs(C_pre);\n+    const int Z    = C_init  \/ abs(C_pre);\n+    const int sign = (C_pre > 0) ? 1 : -1;\n+    tty->print_cr(\"  X = C_const(%3d) \/ abs(C_pre(%d)) = %d       (6a)\", C_const, C_pre, X);\n+    tty->print_cr(\"  Y = C_invar(%3d) \/ abs(C_pre(%d)) = %d       (6b)\", C_invar, C_pre, Y);\n+    tty->print_cr(\"  Z = C_init( %3d) \/ abs(C_pre(%d)) = %d       (6c)\", C_init , C_pre, Z);\n+    tty->print_cr(\"  q = aw(     %3d) \/ abs(C_pre(%d)) = %d       (8)\",  _aw,     C_pre, q);\n+    tty->print_cr(\"  sign(C_pre) = (C_pre(%d) > 0) ? 1 : -1 = %d  (7)\",  C_pre,   sign);\n+\n+    tty->print_cr(\"  EQ(9a): (X(%3d)             + pre_iter_C_const * sign(C_pre)) %% q(%d) = 0\", X, q);\n+    tty->print_cr(\"  EQ(9b): (Y(%3d) * var_invar + pre_iter_C_invar * sign(C_pre)) %% q(%d) = 0\", Y, q);\n+    tty->print_cr(\"  EQ(9c): (Z(%3d) * var_init  + pre_iter_C_init  * sign(C_pre)) %% q(%d) = 0\", Z, q);\n+\n+    tty->print_cr(\"  EQ(10a): pre_iter_C_const = mx2 * q(%d) - sign(C_pre) * X(%d)\",             q, X);\n+    tty->print_cr(\"  EQ(10b): pre_iter_C_invar = my2 * q(%d) - sign(C_pre) * Y(%d) * var_invar\", q, Y);\n+    tty->print_cr(\"  EQ(10c): pre_iter_C_init  = mz2 * q(%d) - sign(C_pre) * Z(%d) * var_init \", q, Z);\n+\n+    tty->print_cr(\"  r = (-C_const(%d) \/ (scale(%d) * pre_stride(%d)) %% q(%d) = %d\",\n+                  C_const, _scale, _pre_stride, q, r);\n+\n+    tty->print_cr(\"  EQ(14):  pre_iter = m * q(%3d) - r(%d)\", q, r);\n+    if (_invar != nullptr) {\n+      tty->print_cr(\"                                 - invar \/ (scale(%d) * pre_stride(%d))\",\n+                    _scale, _pre_stride);\n+    }\n+    if (!_init_node->is_ConI()) {\n+      tty->print_cr(\"                                 - init \/ pre_stride(%d)\",\n+                    _pre_stride);\n+    }\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":289,"deletions":165,"binary":false,"changes":454,"status":"modified"},{"patch":"@@ -274,5 +274,3 @@\n-\/\/   1. Empty with a failure reason.\n-\/\/   2. Trivial (any pre-loop limit guarantees alignment).\n-\/\/   3. Constrained (r, q, mem_ref, scale, invar)\n-\/\/        Where scale is 0 if no scale dependency,\n-\/\/        and invar is nullptr if no invar dependency.\n+\/\/   1. Empty:       No pre_iter guarantees alignment.\n+\/\/   2. Trivial:     Any pre_iter guarantees alignment.\n+\/\/   3. Constrained: There is a periodic solution, but it is not trivial.\n@@ -282,2 +280,3 @@\n-\/\/   pre_iter = pre_iter_C_const  + pre_iter_C_init              + pre_iter_C_invar\n-\/\/            = pre_r + pre_q * m + alignment_init(X * var_init) + alignment_invar(Y * var_invar)\n+\/\/   pre_iter = m * q + r                                    (for any integer m)\n+\/\/                   [- invar \/ (scale * pre_stride)  ]      (if there is an invariant)\n+\/\/                   [- init \/ pre_stride             ]      (if init is variable)\n@@ -285,5 +284,3 @@\n-\/\/ Essentially, we get a periodic solution for the C_const term, which\n-\/\/ is shifted by the init and the invar terms. For two solutions to be\n-\/\/ compatible, they must have the same periodic part (or subset), which\n-\/\/ we can easily check with p an q. Compatible solutions must also have\n-\/\/ the same shifting, which we can check with the scale and invar dependency.\n+\/\/ The solution is periodic with periodicity q, which is guaranteed to be a power of 2.\n+\/\/ This periodic solution is \"rotated\" by three alignment terms: one for constants (r),\n+\/\/ one for the invariant (if present), and one for init (if it is variable).\n@@ -291,3 +288,6 @@\n-class AlignmentSolutionEmpty;\n-class AlignmentSolutionTrivial;\n-class AlignmentSolutionConstrained;\n+\/\/ The \"filter\" method combines the solutions of two mem_refs, such that the new set of\n+\/\/ values for pre_iter guarantees alignment for both mem_refs.\n+\/\/\n+class EmptyAlignmentSolution;\n+class TrivialAlignmentSolution;\n+class ConstrainedAlignmentSolution;\n@@ -301,1 +301,1 @@\n-  virtual const AlignmentSolutionConstrained* as_constrained() const {\n+  virtual const ConstrainedAlignmentSolution* as_constrained() const {\n@@ -320,1 +320,1 @@\n-class AlignmentSolutionEmpty : public AlignmentSolution {\n+class EmptyAlignmentSolution : public AlignmentSolution {\n@@ -324,1 +324,1 @@\n-  AlignmentSolutionEmpty(const char* reason) :  _reason(reason) {}\n+  EmptyAlignmentSolution(const char* reason) :  _reason(reason) {}\n@@ -331,1 +331,3 @@\n-    return new AlignmentSolutionEmpty(\"empty solution input to filter\");\n+    \/\/ If \"this\" cannot be guaranteed to be aligned, then we also cannot guarantee to align\n+    \/\/ \"this\" and \"other\" together.\n+    return new EmptyAlignmentSolution(\"empty solution input to filter\");\n@@ -339,1 +341,1 @@\n-class AlignmentSolutionTrivial : public AlignmentSolution {\n+class TrivialAlignmentSolution : public AlignmentSolution {\n@@ -341,1 +343,1 @@\n-  AlignmentSolutionTrivial() {}\n+  TrivialAlignmentSolution() {}\n@@ -348,1 +350,3 @@\n-      return new AlignmentSolutionEmpty(\"empty solution input to filter\");\n+      \/\/ If \"other\" cannot be guaranteed to be aligned, then we also cannot guarantee to align\n+      \/\/ \"this\" and \"other\".\n+      return new EmptyAlignmentSolution(\"empty solution input to filter\");\n@@ -350,0 +354,2 @@\n+    \/\/ Since \"this\" is trivial (no constraints), the solution of \"other\" guarantees alignment\n+    \/\/ of both.\n@@ -358,1 +364,1 @@\n-class AlignmentSolutionConstrained : public AlignmentSolution {\n+class ConstrainedAlignmentSolution : public AlignmentSolution {\n@@ -360,2 +366,0 @@\n-  const int _r = 0;\n-  const int _q = 1;\n@@ -363,2 +367,4 @@\n-  const Node* _invar_dependency = nullptr;\n-  const int _scale_dependency = 0;\n+  const int _q = 1;\n+  const int _r = 0;\n+  const Node* _invar = nullptr;\n+  const int _scale = 0;\n@@ -366,1 +372,1 @@\n-  AlignmentSolutionConstrained(const int r,\n+  ConstrainedAlignmentSolution(const MemNode* mem_ref,\n@@ -368,5 +374,3 @@\n-                               const MemNode* mem_ref,\n-                               const Node* invar_dependency,\n-                               int scale_dependency) :\n-      _r(r),\n-      _q(q),\n+                               const int r,\n+                               const Node* invar,\n+                               int scale) :\n@@ -374,2 +378,4 @@\n-      _invar_dependency(invar_dependency),\n-      _scale_dependency(scale_dependency) {\n+      _q(q),\n+      _r(r),\n+      _invar(invar),\n+      _scale(scale) {\n@@ -387,1 +393,1 @@\n-  virtual const AlignmentSolutionConstrained* as_constrained() const override final { return this; }\n+  virtual const ConstrainedAlignmentSolution* as_constrained() const override final { return this; }\n@@ -391,1 +397,3 @@\n-      return new AlignmentSolutionEmpty(\"empty solution input to filter\");\n+      \/\/ If \"other\" cannot be guaranteed to be aligned, then we also cannot guarantee to align\n+      \/\/ \"this\" and \"other\" together.\n+      return new EmptyAlignmentSolution(\"empty solution input to filter\");\n@@ -393,0 +401,2 @@\n+    \/\/ Since \"other\" is trivial (no constraints), the solution of \"this\" guarantees alignment\n+    \/\/ of both.\n@@ -397,6 +407,26 @@\n-    \/\/ Both are constrained -> find the intersection\n-    AlignmentSolutionConstrained const* s1 = this;\n-    AlignmentSolutionConstrained const* s2 = other->as_constrained();\n-\n-    if (s1->_invar_dependency != s2->_invar_dependency) {\n-      return new AlignmentSolutionEmpty(\"invar not identical\");\n+    \/\/ Both solutions are constrained:\n+    ConstrainedAlignmentSolution const* s1 = this;\n+    ConstrainedAlignmentSolution const* s2 = other->as_constrained();\n+\n+    \/\/ Thus, pre_iter is the intersection of two sets, i.e. constrained by these two equations,\n+    \/\/ for any integers m1 and m2:\n+    \/\/\n+    \/\/   pre_iter = m1 * q1 + r1\n+    \/\/                     [- invar1 \/ (scale1 * pre_stride)  ]\n+    \/\/                     [- init \/ pre_stride               ]\n+    \/\/\n+    \/\/   pre_iter = m2 * q2 + r2\n+    \/\/                     [- invar2 \/ (scale2 * pre_stride)  ]\n+    \/\/                     [- init \/ pre_stride               ]\n+    \/\/\n+    \/\/ Note: pre_stride and init are idential for all mem_refs in the loop.\n+    \/\/\n+    \/\/ The init alignment term either does not exist for both mem_refs, or exists identically\n+    \/\/ for both. The init alignment term is thus triviall identical.\n+    \/\/\n+    \/\/ The invar alignment term is identical if either:\n+    \/\/   - both mem_refs have no invariant.\n+    \/\/   - both mem_refs have the same invariant and the same scale.\n+    \/\/\n+    if (s1->_invar != s2->_invar) {\n+      return new EmptyAlignmentSolution(\"invar not identical\");\n@@ -404,2 +434,2 @@\n-    if (s1->_scale_dependency != s2->_scale_dependency) {\n-      return new AlignmentSolutionEmpty(\"different scale dependency (init \/ invar)\");\n+    if (s1->_invar != nullptr && s1->_scale != s2->_scale) {\n+      return new EmptyAlignmentSolution(\"has invar with different scale\");\n@@ -408,1 +438,9 @@\n-    \/\/ Make s2 the bigger modulo space\n+    \/\/ Now, we have reduced the problem to:\n+    \/\/\n+    \/\/   pre_iter = m1 * q1 + r1 [- x]       (S1)\n+    \/\/   pre_iter = m2 * q2 + r2 [- x]       (S2)\n+    \/\/\n+\n+    \/\/ Make s2 the bigger modulo space, i.e. has larger periodicity q.\n+    \/\/ This guarantees that S2 is either identical to, a subset of,\n+    \/\/ or disjunct from S1 (but cannot be a strict superset of S1).\n@@ -414,1 +452,12 @@\n-    \/\/ Subset check:\n+    \/\/ Is S2 subset of (or equal to) S1?\n+    \/\/\n+    \/\/ for any m2, there are integers a, b, m1: m2 * q2     + r2          =\n+    \/\/                                          m2 * a * q1 + b * q1 + r1 =\n+    \/\/                                          (m2 * a + b) * q1 + r1\n+    \/\/\n+    \/\/ Since q1 and q2 are both powers of 2, and q1 <= q2, we know there\n+    \/\/ is an integer a: a * q1 = q1. Thus, it remains to check if there\n+    \/\/ is an integer b: b * q1 + r1 = r2. This is equivalent to checking:\n+    \/\/\n+    \/\/   r1 = r1 % q1 = r2 % q1\n+    \/\/\n@@ -416,2 +465,2 @@\n-      \/\/ neither is subset of the other -> no intersection\n-      return new AlignmentSolutionEmpty(\"empty intersection (r and q)\");\n+      \/\/ Neither is subset of the other -> no intersection\n+      return new EmptyAlignmentSolution(\"empty intersection (r and q)\");\n@@ -420,1 +469,2 @@\n-    \/\/ Now we know: \"s1 = r1 + m1 * q1\" is a superset of \"s2 = r2 + m2 * q2\"\n+    \/\/ Now we know: \"s1 = m1 * q1 + r1\" is a superset of \"s2 = m2 * q2 + r2\"\n+    \/\/ Hence, any solution of S2 guarantees alignment for both mem_refs.\n@@ -425,7 +475,3 @@\n-    tty->print(\"pre_r(%d) + m * pre_q(%d), mem_ref[%d],\",\n-                _r, _q, mem_ref()->_idx);\n-    tty->print(\" scale = %d, \", _scale_dependency);\n-    if (_invar_dependency == nullptr) {\n-      tty->print_cr(\"no invar\");\n-    } else {\n-      tty->print_cr(\"invar[%d]\", _invar_dependency->_idx);\n+    tty->print(\"m * q(%d) + r(%d)\", _q, _r);\n+    if (_invar != nullptr) {\n+      tty->print(\" - invar[%d] \/ (scale(%d) * pre_stride)\", _invar->_idx, _scale);\n@@ -433,0 +479,1 @@\n+    tty->print_cr(\" [- init \/ pre_stride], mem_ref[%d]\", mem_ref()->_idx);\n@@ -549,0 +596,47 @@\n+  class EQ4 {\n+    private:\n+      const int _C_const;\n+      const int _C_invar;\n+      const int _C_init;\n+      const int _C_pre;\n+      const int _aw;\n+\n+    public:\n+      EQ4(const int C_const, const int C_invar, const int C_init, const int C_pre, const int aw) :\n+      _C_const(C_const), _C_invar(C_invar), _C_init(C_init), _C_pre(C_pre), _aw(aw) {}\n+\n+      enum State { TRIVIAL, CONSTRAINED, EMPTY };\n+\n+      State eq4a_state() const {\n+        return (abs(_C_pre) >= _aw) ? ( (C_const_mod_aw() == 0       ) ? TRIVIAL     : EMPTY)\n+                                    : ( (C_const_mod_abs_C_pre() == 0) ? CONSTRAINED : EMPTY);\n+      }\n+\n+      State eq4b_state() const {\n+        return (abs(_C_pre) >= _aw) ? ( (C_invar_mod_aw() == 0       ) ? TRIVIAL     : EMPTY)\n+                                    : ( (C_invar_mod_abs_C_pre() == 0) ? CONSTRAINED : EMPTY);\n+      }\n+\n+      State eq4c_state() const {\n+        return (abs(_C_pre) >= _aw) ? ( (C_init__mod_aw() == 0       ) ? TRIVIAL     : EMPTY)\n+                                    : ( (C_init__mod_abs_C_pre() == 0) ? CONSTRAINED : EMPTY);\n+      }\n+\n+      int C_const_mod_aw() const        { return AlignmentSolution::mod(_C_const, _aw); }\n+      int C_invar_mod_aw() const        { return AlignmentSolution::mod(_C_invar, _aw); }\n+      int C_init__mod_aw() const        { return AlignmentSolution::mod(_C_init,  _aw); }\n+      int C_const_mod_abs_C_pre() const { return AlignmentSolution::mod(_C_const, abs(_C_pre)); }\n+      int C_invar_mod_abs_C_pre() const { return AlignmentSolution::mod(_C_invar, abs(_C_pre)); }\n+      int C_init__mod_abs_C_pre() const { return AlignmentSolution::mod(_C_init,  abs(_C_pre)); }\n+\n+    public:\n+#ifdef ASSERT\n+      void trace() const;\n+      const char* state_to_str(State s) const {\n+        if (s == TRIVIAL)     { return \"trivial\"; }\n+        if (s == CONSTRAINED) { return \"constrained\"; }\n+        return \"empty\";\n+      }\n+#endif\n+  };\n+\n@@ -564,17 +658,6 @@\n-  void trace_init_and_invar_alignment(const int C_invar,\n-                                      const int C_init,\n-                                      const int C_pre,\n-                                      const int C_invar_mod_abs_C_pre,\n-                                      const int C_init_mod_abs_C_pre) const;\n-  void trace_abs_C_pre_ge_aw(const int C_pre,\n-                             const bool abs_C_pre_ge_aw) const;\n-  void trace_C_const_mod_aw(const int C_const,\n-                            const int C_const_mod_aw) const;\n-  void trace_find_pre_q(const int C_const,\n-                        const int C_pre,\n-                        const int pre_q) const;\n-  void trace_find_pre_r(const int C_const,\n-                        const int C_pre,\n-                        const int pre_q,\n-                        const int pre_r,\n-                        const int eq10_val) const;\n+  void trace_constrained_solution(const int C_const,\n+                                  const int C_invar,\n+                                  const int C_init,\n+                                  const int C_pre,\n+                                  const int q,\n+                                  const int r) const;\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":157,"deletions":74,"binary":false,"changes":231,"status":"modified"}]}