{"files":[{"patch":"@@ -1687,0 +1687,1 @@\n+  assert(aw > 0 && is_power_of_2(aw), \"aw must be power of 2\");\n@@ -1735,1 +1736,1 @@\n-  \/\/      during the \"pre_iter\" many pre-loop iterations. This term can be adjusted\n+  \/\/      during the \"pre_iter\" pre-loop iterations. This term can be adjusted\n@@ -1739,1 +1740,1 @@\n-  \/\/      \"j\" main-loop iterations.\n+  \/\/      main-loop iterations.\n@@ -1818,2 +1819,39 @@\n-  \/\/ In what follows, me must ensure that the C_pre term can align the C_const, C_init and C_invar terms,\n-  \/\/ by adjusting the pre-loop limit (pre_iter). We must check\n+  \/\/ In what follows, we need to show that the C_const, init and invar terms can be aligned by\n+  \/\/ adjusting the pre-loop limit (pre-iter). We decompose pre_iter:\n+  \/\/\n+  \/\/   pre_iter = pre_iter_C_const + pre_iter_C_invar + pre_iter_C_init\n+  \/\/\n+  \/\/ where pre_iter_C_const, pre_iter_C_invar, and pre_iter_C_init are defined as the number of\n+  \/\/ pre-loop iterations required to align the C_const, init and invar terms individually.\n+  \/\/ Hence, we can rewrite:\n+  \/\/\n+  \/\/   C_const + C_invar * var_invar + C_init * var_init + C_pre * pre_iter\n+  \/\/   =  C_const             + C_pre * pre_iter_C_const\n+  \/\/    + C_invar * var_invar + C_pre * pre_iter_C_invar\n+  \/\/    + C_init  * var_init  + C_pre * pre_iter_C_init\n+  \/\/   = 0 (modulo aw)                                                           (3)\n+  \/\/\n+  \/\/ We strengthen the constraints by splitting the equation into 3 equations, where the C_const,\n+  \/\/ init, and invar term are aligned individually:\n+  \/\/\n+  \/\/   C_init  * var_init  + C_pre * pre_iter_C_init  = 0 (modulo aw)            (4a)\n+  \/\/   C_invar * var_invar + C_pre * pre_iter_C_invar = 0 (modulo aw)            (4b)\n+  \/\/   C_const             + C_pre * pre_iter_C_const = 0 (modulo aw)            (4c)\n+  \/\/\n+  \/\/ We can only guarantee solutions to (4a) and (4b) if:\n+  \/\/\n+  \/\/   C_init  % abs(C_pre) = 0                                                  (5a*)\n+  \/\/   C_invar % abs(C_pre) = 0                                                  (5b*)\n+  \/\/\n+  \/\/ Which means there are X and Y such that:\n+  \/\/\n+  \/\/   C_init  = C_pre * X       (X = 0 if C_init  = 0, else X = C_init  \/ C_pre)\n+  \/\/   C_invar = C_pre * Y       (Y = 0 if C_invar = 0, else Y = C_invar \/ C_pre)\n+  \/\/\n+  \/\/   C_init    * var_init  + C_pre * pre_iter_C_init  =\n+  \/\/   C_pre * X * var_init  + C_pre * pre_iter_C_init  =\n+  \/\/   C_pre * (X * var_init  + pre_iter_C_init)         = 0 (modulo aw)\n+  \/\/\n+  \/\/   C_invar   * var_invar + C_pre * pre_iter_C_invar =\n+  \/\/   C_pre * Y * var_invar + C_pre * pre_iter_C_invar =\n+  \/\/   C_pre * (Y * var_invar + pre_iter_C_invar)       = 0 (modulo aw)\n@@ -1821,2 +1859,2 @@\n-  \/\/   C_init  % abs(C_pre) = 0                                          (3a*)\n-  \/\/   C_invar % abs(C_pre) = 0                                          (3b*)\n+  \/\/ And hence, we know that there are solutions for pre_iter_C_init and pre_iter_C_invar,\n+  \/\/ based on X, Y, var_init, and var_invar. We call them:\n@@ -1824,1 +1862,2 @@\n-  \/\/ to ensure that the variable term for init and invar can be aligned with the C_pre term.\n+  \/\/   pre_iter_C_init  = alignment_init (X * var_init)\n+  \/\/   pre_iter_C_invar = alignment_invar(Y * var_invar)\n@@ -1831,1 +1870,1 @@\n-    tty->print_cr(\"  EQ(3a*): C_init(%d) %% abs(C_pre(%d)) = %d = 0   (if false: cannot align init)\",\n+    tty->print_cr(\"  EQ(5a*): C_init(%d) %% abs(C_pre(%d)) = %d = 0   (if false: cannot align init)\",\n@@ -1833,1 +1872,1 @@\n-    tty->print_cr(\"  EQ(3b*): C_invar(%d) %% abs(C_pre(%d)) = %d = 0  (if false: cannot align invar)\",\n+    tty->print_cr(\"  EQ(5b*): C_invar(%d) %% abs(C_pre(%d)) = %d = 0  (if false: cannot align invar)\",\n@@ -1839,1 +1878,1 @@\n-    return AlignmentSolution(\"EQ(3a*) not satisfied (cannot align init)\");\n+    return AlignmentSolution(\"EQ(5a*) not satisfied (cannot align init)\");\n@@ -1842,1 +1881,1 @@\n-    return AlignmentSolution(\"EQ(3b*) not satisfied (cannot align invar)\");\n+    return AlignmentSolution(\"EQ(5b*) not satisfied (cannot align invar)\");\n@@ -1845,1 +1884,2 @@\n-  \/\/ We must now show that the C_const term can be aligned.\n+  \/\/ Having solved (4a) and (4b), we now want to find solutions for (4c), i.e. we need\n+  \/\/ to show that the C_const term can be aligned with pre_iter_C_const.\n@@ -1848,2 +1888,0 @@\n-  \/\/ If abs(C_pre) >= aw, then for any pre_iter >= 0: C_pre * pre_iter = 0 (mod aw),\n-  \/\/ and hence we require (else there is no solution):\n@@ -1851,1 +1889,10 @@\n-  \/\/   C_const % aw = 0                                           (4*)\n+  \/\/ If abs(C_pre) >= aw, then:\n+  \/\/\n+  \/\/   for any pre_iter >= 0: C_pre * pre_iter = 0 (mod aw)\n+  \/\/   for any pre_iter_C_const >= 0: C_pre * pre_iter_C_const = 0 (mod aw)\n+  \/\/\n+  \/\/ which implies that C_iter (and pre_iter_C_const) have no effect on the alignment of\n+  \/\/ the C_const term. We thus either have a trivial solution, and any pre_iter aligns\n+  \/\/ the address, or there is no solution. To have the trivial solution, we require:\n+  \/\/\n+  \/\/   C_const % aw = 0                                                       (6*)\n@@ -1854,1 +1901,0 @@\n-  assert(aw > 0 && is_power_of_2(aw), \"aw must be power of 2\");\n@@ -1870,1 +1916,1 @@\n-      tty->print_cr(\"  EQ(4* ): C_const(%d) %% aw(%d) = %d = 0\",\n+      tty->print_cr(\"  EQ(6* ): C_const(%d) %% aw(%d) = %d = 0\",\n@@ -1876,2 +1922,2 @@\n-    assert(AlignmentSolution::mod(C_init,  aw) == 0,  \"implied by abs(C_pre) >= aw and (3a*)\");\n-    assert(AlignmentSolution::mod(C_invar, aw) == 0,  \"implied by abs(C_pre) >= aw and (3b*)\");\n+    assert(AlignmentSolution::mod(C_init,  aw) == 0,  \"implied by abs(C_pre) >= aw and (5a*)\");\n+    assert(AlignmentSolution::mod(C_invar, aw) == 0,  \"implied by abs(C_pre) >= aw and (5b*)\");\n@@ -1880,1 +1926,1 @@\n-      return AlignmentSolution(\"EQ(4*) not satisfied: C_const not aligned\");\n+      return AlignmentSolution(\"EQ(6*) not satisfied: C_const not aligned\");\n@@ -1887,2 +1933,3 @@\n-  \/\/ Otherwise, if abs(C_pre) < aw, we need to produce a solution that aligns\n-  \/\/ the C_const, C_init and C_invar terms at the same time.\n+  \/\/ Otherwise, if abs(C_pre) < aw, we find all solutions for pre_iter_C_const in (4c).\n+  \/\/ We state pre_iter_C_const in terms of the smallest possible pre_q and pre_r, such\n+  \/\/ that pre_q >= 0 and 0 <= pre_r < pre_q:\n@@ -1890,1 +1937,1 @@\n-  \/\/   C_const + C_invar * var_invar + C_init * var_init + C_pre * pre_iter = 0 (modulo aw)       (5)\n+  \/\/   pre_iter_C_const = pre_r + pre_q * m  (for any m >= 0)                     (7)\n@@ -1892,2 +1939,1 @@\n-  \/\/ In general, this is not an easy task at compile time. We add two\n-  \/\/ simplifying restrictions:\n+  \/\/ We can now restate (4c) with (7):\n@@ -1895,5 +1941,1 @@\n-  \/\/ 1. If a variable init is present (i.e. C_init = scale), then we\n-  \/\/    make the solution dependent on scale and C_pre. Only solutions\n-  \/\/    with the same dependencies are compatible. This ensures that\n-  \/\/    all solutions require the same number of pre-loop iterations\n-  \/\/    to align the C_init term.\n+  \/\/   C_const + C_pre * pre_r + C_pre * pre_q * m = 0 (modulo aw)                (8)\n@@ -1901,6 +1943,1 @@\n-  \/\/ 2. If a invariant is present, then we make the solution dependent\n-  \/\/    on C_pre and invar. Only solutions with tthe same dependenceis are\n-  \/\/    compatible. This ensures that all solutions require the same\n-  \/\/    number of pre-loop iterations to align the C_invar term.\n-  \/\/\n-  \/\/ With these assumptions, we can find a solution:\n+  \/\/ Since this holds for any m >= 0, we require:\n@@ -1908,1 +1945,2 @@\n-  \/\/   pre_iter = pre_iter_C_const + pre_iter_C_invar + pre_iter_C_init\n+  \/\/   C_pre * pre_q = 0 (modulo aw)                                              (9)\n+  \/\/   C_const + C_pre * pre_r = 0 (modulo aw)                                    (10*)\n@@ -1910,5 +1948,1 @@\n-  \/\/ From (3b*) and the two simplifying assumptions, we know that\n-  \/\/ pre_iter_C_init and pre_iter_C_invar exist and are the same\n-  \/\/ for all compatible solutions.\n-  \/\/ We now have to show that there is a pre_iter_C_const, terms of the\n-  \/\/ smallest possible pre_q >= 0 and 0 <= pre_r < pre_q:\n+  \/\/ Given that abs(C_pre) is a powers of 2, and abs(C_pre) < aw:\n@@ -1916,2 +1950,1 @@\n-  \/\/   pre_iter_C_const = pre_r + pre_q * m  (for any m >= 0)                     (6)\n-  \/\/   C_const + C_pre * pre_r + C_pre * pre_q * m = 0 (modulo aw)                (7)\n+  int  pre_q = aw \/ abs(C_pre);\n@@ -1919,1 +1952,2 @@\n-  \/\/ Since this holds for any m >= 0, we require:\n+  \/\/ We brute force the solution for pre_r by enumerating all values 0..pre_q-1 and\n+  \/\/ checking EQ(10*).\n@@ -1921,2 +1955,2 @@\n-  \/\/   C_pre * pre_q = 0 (modulo aw)                                              (8)\n-  \/\/   C_const + C_pre * pre_r = 0 (modulo aw)                                    (9*)\n+  \/\/ Assuming we found a solution for (4c), and also for (4a) and (4b), we know that\n+  \/\/ the solution to pre_iter is non-trivial:\n@@ -1924,1 +1958,2 @@\n-  \/\/ Given that abs(C_pre) is a powers of 2, and abs(C_pre) < aw:\n+  \/\/   pre_iter = pre_iter_C_const  + pre_iter_C_init              + pre_iter_C_invar\n+  \/\/            = pre_r + pre_q * m + alignment_init(X * var_init) + alignment_invar(Y * var_invar)\n@@ -1926,1 +1961,15 @@\n-  int  pre_q = aw \/ abs(C_pre);\n+  \/\/ Hence, the solution depends on:\n+  \/\/   - Always: pre_r and pre_q\n+  \/\/   - If a variable init is present (i.e. C_init = scale), then we know that to\n+  \/\/     satisfy (5a*), we must have abs(pre_stride) = 1, X = 1 and C_pre = scale.\n+  \/\/     The solution thus depends on var_init = init \/ scale. We thus have a\n+  \/\/     dependency on scale. We could also add a dependency for init, but since\n+  \/\/     it is the same for all mem_refs in the loop this is unnecessary. If init\n+  \/\/     is constant, then we could add a dependency that there is no variable init.\n+  \/\/     But since init is the same for all mem_refs, this is unecessary.\n+  \/\/   - If an invariant is present (i.e. C_invar = abs(invar_factor)), then we know\n+  \/\/     from (5b*), that Y = abs(invar_factor) \/ (scale * pre_stride). The solution\n+  \/\/     depends on Y * var_invar = abs(invar_factor) * var_invar \/ (scale * pre_stride),\n+  \/\/     hence we have to add a dependency for invar, and scale (pre_stride is the\n+  \/\/     same for all mem_refs in the loop). If there is no invariant, then we add\n+  \/\/     a dependency that there is no invariant.\n@@ -1928,2 +1977,2 @@\n-  \/\/ We brute force the solution for pre_r by enumerating\n-  \/\/ all values 0..pre_q-1 and checking EQ(9*).\n+  \/\/ Other mem_refs must have solutions with  the same dependencies, otherwise we\n+  \/\/ cannot ensure that they require the same number of pre-loop iterations.\n@@ -1939,1 +1988,1 @@\n-    tty->print_cr(\"  EQ(9*): brute force pre_r = 0..%d\", pre_q - 1);\n+    tty->print_cr(\"  EQ(10*): brute force pre_r = 0..%d\", pre_q - 1);\n@@ -1944,1 +1993,1 @@\n-    int EQ9_val = AlignmentSolution::mod(C_const + C_pre * pre_r, aw);\n+    int EQ10_val = AlignmentSolution::mod(C_const + C_pre * pre_r, aw);\n@@ -1949,1 +1998,1 @@\n-                    pre_r, C_const, C_pre, pre_r, aw, EQ9_val);\n+                    pre_r, C_const, C_pre, pre_r, aw, EQ10_val);\n@@ -1953,1 +2002,1 @@\n-    if (EQ9_val == 0) {\n+    if (EQ10_val == 0) {\n@@ -1957,2 +2006,0 @@\n-      \/\/ Dependencies given by the two simplifying assumptions.\n-      \/\/ Note: if scale is the same, then C_pre is the same.\n@@ -1965,1 +2012,1 @@\n-  return AlignmentSolution(\"EQ(9*) has no solution for pre_r\");\n+  return AlignmentSolution(\"EQ(10*) has no solution for pre_r\");\n@@ -3874,0 +3921,1 @@\n+  \/\/\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":106,"deletions":58,"binary":false,"changes":164,"status":"modified"}]}