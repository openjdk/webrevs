{"files":[{"patch":"@@ -1612,1 +1612,1 @@\n-void print_icon_or_idx(Node* n) {\n+void print_icon_or_idx(const Node* n) {\n@@ -1633,1 +1633,1 @@\n-  uint pack_size    = pack->size();\n+  const uint pack_size    = pack->size();\n@@ -1635,3 +1635,3 @@\n-  int element_size  = mem_ref->memory_size();\n-  int vector_width  = pack_size * element_size;\n-  int aw            = MIN2(vector_width, ObjectAlignmentInBytes); \/\/ alignment_width\n+  const int element_size  = mem_ref->memory_size();\n+  const int vector_width  = pack_size * element_size;\n+  const int aw            = MIN2(vector_width, ObjectAlignmentInBytes); \/\/ alignment_width\n@@ -1641,4 +1641,4 @@\n-  int pre_stride    = pre_end->stride_con();\n-  int unroll_factor = _lp->unrolled_count();\n-  int main_stride   = iv_stride();\n-  Node* init_node   = pre_end->init_trip();\n+  const int pre_stride    = pre_end->stride_con();\n+  const int unroll_factor = _lp->unrolled_count();\n+  const int main_stride   = iv_stride();\n+  const Node* init_node   = pre_end->init_trip();\n@@ -1648,5 +1648,5 @@\n-  int scale         = mem_ref_p.scale_in_bytes();\n-  int offset        = mem_ref_p.offset_in_bytes();\n-  Node* base        = mem_ref_p.base();\n-  Node* invar       = mem_ref_p.invar();\n-  int invar_factor  = mem_ref_p.invar_factor();\n+  const int scale         = mem_ref_p.scale_in_bytes();\n+  const int offset        = mem_ref_p.offset_in_bytes();\n+  const Node* base        = mem_ref_p.base();\n+  Node* invar             = mem_ref_p.invar();\n+  const int invar_factor  = mem_ref_p.invar_factor();\n@@ -1752,11 +1752,3 @@\n-  int C_const_init = 0;\n-  int C_init = 0;\n-  if (init_node->is_ConI()) {\n-    \/\/ init is constant -> contribute init to the C_const term.\n-    C_const_init = init_node->as_ConI()->get_int();\n-    C_init = 0; \/\/ no C_init term\n-  } else {\n-    \/\/ init is variable -> contribute init to the C_init term.\n-    C_const_init = 0;\n-    C_init = scale;\n-  }\n+  \/\/ Attribute init either to C_const or to C_init term.\n+  const int C_const_init = init_node->is_ConI() ? init_node->as_ConI()->get_int() : 0;\n+  const int C_init =       init_node->is_ConI() ? 0                               : scale;\n@@ -1764,4 +1756,2 @@\n-  int C_invar = 0;\n-  if (invar != nullptr) {\n-    C_invar = abs(invar_factor);\n-  }\n+  \/\/ Set C_invar depending on if invar is present\n+  const int C_invar = (invar == nullptr) ? 0 : abs(invar_factor);\n@@ -1769,3 +1759,3 @@\n-  int C_const = offset + C_const_init * scale;\n-  int C_pre = scale * pre_stride;\n-  int C_main = scale * main_stride;\n+  const int C_const = offset + C_const_init * scale;\n+  const int C_pre = scale * pre_stride;\n+  const int C_main = scale * main_stride;\n@@ -1812,1 +1802,1 @@\n-  int C_main_mod_aw = AlignmentSolution::mod(C_main, aw);\n+  const int C_main_mod_aw = AlignmentSolution::mod(C_main, aw);\n@@ -1877,2 +1867,2 @@\n-  int C_init_mod_abs_C_pre  = AlignmentSolution::mod(C_init,  abs(C_pre));\n-  int C_invar_mod_abs_C_pre = AlignmentSolution::mod(C_invar, abs(C_pre));\n+  const int C_init_mod_abs_C_pre  = AlignmentSolution::mod(C_init,  abs(C_pre));\n+  const int C_invar_mod_abs_C_pre = AlignmentSolution::mod(C_invar, abs(C_pre));\n@@ -1913,1 +1903,1 @@\n-  bool abs_C_pre_ge_aw = abs(C_pre) >= aw;\n+  const bool abs_C_pre_ge_aw = abs(C_pre) >= aw;\n@@ -1924,1 +1914,1 @@\n-    int C_const_mod_aw = AlignmentSolution::mod(C_const, aw);\n+    const int C_const_mod_aw = AlignmentSolution::mod(C_const, aw);\n@@ -1962,1 +1952,1 @@\n-  int  pre_q = aw \/ abs(C_pre);\n+  const int  pre_q = aw \/ abs(C_pre);\n@@ -2005,1 +1995,1 @@\n-    int EQ10_val = AlignmentSolution::mod(C_const + C_pre * pre_r, aw);\n+    const int EQ10_val = AlignmentSolution::mod(C_const + C_pre * pre_r, aw);\n@@ -2019,1 +2009,1 @@\n-      int scale_dependency  = (invar != nullptr || !init_node->is_ConI()) ? scale : 0;\n+      const int scale_dependency  = (invar != nullptr || !init_node->is_ConI()) ? scale : 0;\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":30,"deletions":40,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -315,9 +315,37 @@\n-  bool is_valid() const          { return _valid; }\n-  bool is_trivial() const        { return _trivial; }\n-  const char* reason() const     { assert(!is_valid(), \"only invalid has reason\"); return _reason; }\n-  int r() const                  { assert(is_valid(), \"only valid has solution\"); return _r; }\n-  int q() const                  { assert(is_valid(), \"only valid has solution\"); return _q; }\n-  MemNode* mem_ref() const       { assert(is_valid(), \"valid and not trivial\"); return _mem_ref; }\n-  int aw() const                 { assert(is_valid() && !is_trivial(), \"valid and not trivial\"); return _aw; }\n-  Node* invar_dependency() const { assert(is_valid() && !is_trivial(), \"valid and not trivial\"); return _invar_dependency; }\n-  int scale_dependency() const   { assert(is_valid() && !is_trivial(), \"valid and not trivial\"); return _scale_dependency; }\n+  bool is_valid() const   { return _valid; }\n+  bool is_trivial() const { return _trivial; }\n+\n+  const char* reason() const {\n+    assert(!is_valid(), \"only invalid has reason\");\n+    return _reason;\n+  }\n+\n+  int r() const {\n+    assert(is_valid(), \"only valid has solution\");\n+    return _r;\n+  }\n+\n+  int q() const {\n+    assert(is_valid(), \"only valid has solution\");\n+    return _q;\n+  }\n+\n+  MemNode* mem_ref() const {\n+    assert(is_valid(), \"valid and not trivial\");\n+    return _mem_ref;\n+  }\n+\n+  int aw() const {\n+    assert(is_valid() && !is_trivial(), \"valid and not trivial\");\n+    return _aw;\n+  }\n+\n+  Node* invar_dependency() const {\n+    assert(is_valid() && !is_trivial(), \"valid and not trivial\");\n+    return _invar_dependency;\n+  }\n+\n+  int scale_dependency() const {\n+    assert(is_valid() && !is_trivial(), \"valid and not trivial\");\n+    return _scale_dependency;\n+  }\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":37,"deletions":9,"binary":false,"changes":46,"status":"modified"}]}