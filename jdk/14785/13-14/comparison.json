{"files":[{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8257531\n+ * @bug 8257531 8310190\n@@ -29,11 +29,2 @@\n- *\n- * @requires vm.flagless\n- * @requires vm.compiler2.enabled & vm.debug == true\n- * @requires os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n- *\n- * @run driver compiler.vectorization.TestBufferVectorization array\n- * @run driver compiler.vectorization.TestBufferVectorization arrayOffset\n- * @run driver compiler.vectorization.TestBufferVectorization buffer\n- * @run driver compiler.vectorization.TestBufferVectorization bufferHeap\n- * @run driver compiler.vectorization.TestBufferVectorization bufferDirect\n- * @run driver compiler.vectorization.TestBufferVectorization arrayView\n+ * @requires vm.compiler2.enabled\n+ * @run driver compiler.vectorization.TestBufferVectorization\n@@ -44,0 +35,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -51,4 +44,0 @@\n-import jdk.test.lib.Platform;\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n@@ -56,6 +45,2 @@\n-    final static int N = 500;\n-    final static int ITER = 1000;\n-    final static IntBuffer buffer = IntBuffer.allocate(N);\n-    final static int offset = buffer.arrayOffset();\n-    final static IntBuffer heap_buffer_byte_to_int = ByteBuffer.allocate(N * Integer.BYTES).order(ByteOrder.nativeOrder()).asIntBuffer();\n-    final static IntBuffer direct_buffer_byte_to_int = ByteBuffer.allocateDirect(N * Integer.BYTES).order(ByteOrder.nativeOrder()).asIntBuffer();\n+    final static int N = 1024*16;\n+    static int offset = 0;\n@@ -63,1 +48,0 @@\n-    final static String arch = System.getProperty(\"os.arch\");\n@@ -65,4 +49,2 @@\n-    interface Test {\n-        void init();\n-        void run();\n-        void verify();\n+    public static void main(String[] args) {\n+        TestFramework.run();\n@@ -71,2 +53,3 @@\n-    static class TestArray implements Test {\n-        final int[] array = new int[N];\n+    @Run(test = \"testArray\")\n+    public static void runArray() {\n+        int[] array = new int[N];\n@@ -74,4 +57,2 @@\n-        public void init() {\n-            for (int k = 0; k < array.length; k++) {\n-                array[k] = k;\n-            }\n+        for (int k = 0; k < array.length; k++) {\n+            array[k] = k;\n@@ -80,3 +61,5 @@\n-        public void run() {\n-            for(int k = 0; k < array.length; k++) {\n-                array[k] += 1;\n+        testArray(array);\n+\n+        for(int k = 0; k < array.length; k++) {\n+            if (array[k] != (k + 1)) {\n+                throw new RuntimeException(\" Invalid result: array[\" + k + \"]: \" + array[k] + \" != \" + (k + 1));\n@@ -85,0 +68,1 @@\n+    }\n@@ -86,8 +70,9 @@\n-        public void verify() {\n-            init(); \/\/ reset\n-            run();  \/\/ run compiled code\n-            for(int k = 0; k < array.length; k++) {\n-                if (array[k] != (k + 1)) {\n-                    throw new RuntimeException(\" Invalid result: array[\" + k + \"]: \" + array[k] + \" != \" + (k + 1));\n-                }\n-            }\n+    @Test\n+    @IR(counts = {IRNode.REPLICATE_I,   \">0\",\n+                  IRNode.LOAD_VECTOR_I, \">0\",\n+                  IRNode.ADD_VI,        \">0\",\n+                  IRNode.STORE_VECTOR,  \">0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    public static void testArray(int[] array) {\n+        for(int k = 0; k < array.length; k++) {\n+            array[k] += 1;\n@@ -97,3 +82,4 @@\n-    static class TestArrayOffset implements Test {\n-        final int offset;\n-        final int[] array = new int[N];\n+    @Run(test = \"testArrayOffset\")\n+    public static void runArrayOffset() {\n+        \/\/ Moving offset between 0..255\n+        offset = (offset + 1) % 256;\n@@ -101,3 +87,1 @@\n-        public TestArrayOffset(int off) {\n-            offset = off;\n-        }\n+        int[] array = new int[N];\n@@ -105,4 +89,2 @@\n-        public void init() {\n-            for (int k = 0; k < array.length; k++) {\n-                array[k] = k;\n-            }\n+        for (int k = 0; k < array.length; k++) {\n+            array[k] = k;\n@@ -111,6 +93,1 @@\n-        public void run() {\n-            int l = array.length - offset;\n-            for(int k = 0; k < l; k++) {\n-                array[k + offset] += 1;\n-            }\n-        }\n+        testArrayOffset(array, offset);\n@@ -118,8 +95,4 @@\n-        public void verify() {\n-            init(); \/\/ reset\n-            run();  \/\/ run compiled code\n-            int l = array.length - offset;\n-            for(int k = 0; k < l; k++) {\n-                if (array[k] != (k + 1)) {\n-                    throw new RuntimeException(\" Invalid result: arrayOffset[\" + k + \"]: \" + array[k] + \" != \" + (k + 1));\n-                }\n+        int l = array.length - offset;\n+        for(int k = 0; k < offset; k++) {\n+            if (array[k] != k) {\n+                throw new RuntimeException(\" Invalid result: arrayOffset[\" + k + \"]: \" + array[k] + \" != \" + (k + 1));\n@@ -127,4 +100,4 @@\n-            for(int k = l; k < array.length; k++) {\n-                if (array[k] != k) {\n-                    throw new RuntimeException(\" Invalid result: arrayOffset[\" + k + \"]: \" + array[k] + \" != \" + k);\n-                }\n+        }\n+        for(int k = offset; k < array.length; k++) {\n+            if (array[k] != (k + 1)) {\n+                throw new RuntimeException(\" Invalid result: arrayOffset[\" + k + \"]: \" + array[k] + \" != \" + k);\n@@ -135,11 +108,10 @@\n-    static class TestBuffer implements Test {\n-        final IntBuffer buffer;\n-\n-        public TestBuffer(IntBuffer buf) {\n-            buffer = buf;\n-        }\n-\n-        public void init() {\n-            for (int k = 0; k < buffer.limit(); k++) {\n-                buffer.put(k, k);\n-            }\n+    @Test\n+    @IR(counts = {IRNode.REPLICATE_I,   \">0\",\n+                  IRNode.LOAD_VECTOR_I, \">0\",\n+                  IRNode.ADD_VI,        \">0\",\n+                  IRNode.STORE_VECTOR,  \">0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    public static void testArrayOffset(int[] array, int offset) {\n+        int l = array.length - offset;\n+        for(int k = 0; k < l; k++) {\n+            array[k + offset] += 1;\n@@ -147,0 +119,1 @@\n+    }\n@@ -148,5 +121,7 @@\n-        public void run() {\n-            for (int k = 0; k < buffer.limit(); k++) {\n-                buffer.put(k, buffer.get(k) + 1);\n-            }\n-        }\n+    @Run(test = \"testBuffer\")\n+    public static void runBuffer() {\n+        IntBuffer buffer = IntBuffer.allocate(N);\n+        initBuffer(buffer);\n+        testBuffer(buffer);\n+        verifyBuffer(buffer);\n+    }\n@@ -154,8 +129,9 @@\n-        public void verify() {\n-            init(); \/\/ reset\n-            run();  \/\/ run compiled code\n-            for(int k = 0; k < buffer.limit(); k++) {\n-                if (buffer.get(k) != (k + 1)) {\n-                    throw new RuntimeException(\" Invalid result: buffer.get(\" + k + \"): \" + buffer.get(k) + \" != \" + (k + 1));\n-                }\n-            }\n+    @Test\n+    @IR(counts = {IRNode.REPLICATE_I,   \">0\",\n+                  IRNode.LOAD_VECTOR_I, \">0\",\n+                  IRNode.ADD_VI,        \">0\",\n+                  IRNode.STORE_VECTOR,  \">0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    public static void testBuffer(IntBuffer buffer) {\n+        for (int k = 0; k < buffer.limit(); k++) {\n+            buffer.put(k, buffer.get(k) + 1);\n@@ -165,2 +141,7 @@\n-    static class TestArrayView implements Test {\n-        final byte[] b_arr = new byte[N * Integer.BYTES];\n+    @Run(test = \"testBufferHeap\")\n+    public static void runBufferHeap() {\n+        IntBuffer buffer = ByteBuffer.allocate(N * Integer.BYTES).order(ByteOrder.nativeOrder()).asIntBuffer();\n+        initBuffer(buffer);\n+        testBufferHeap(buffer);\n+        verifyBuffer(buffer);\n+    }\n@@ -168,4 +149,18 @@\n-        public void init() {\n-            for (int k = 0; k < N; k++) {\n-                VH_arr_view.set(b_arr, k, k);\n-            }\n+    @Test\n+    @IR(counts = {IRNode.REPLICATE_I,   IRNode.VECTOR_SIZE_ANY, \">0\",\n+                  IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_ANY, \">0\",\n+                  IRNode.ADD_VI,        IRNode.VECTOR_SIZE_ANY, \">0\",\n+                  IRNode.STORE_VECTOR,                          \">0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"})\n+    \/\/ VECTOR_SIZE_ANY: Unrolling does not always seem to go far enough to reach maximum vector size.\n+    \/\/                  This looks like a BUG.\n+    \/\/ AlignVector: Buffer get\/put have an invariant that is in bytes (LoadL in ByteBufferAsIntBufferL::byteOffset).\n+    \/\/              This makes sense: we are accessing a byte buffer. But to be able to align the 4 byte ints,\n+    \/\/              we would require to know that the invariant is a multiple of 4. Without that, we cannot\n+    \/\/              guarantee alignment by adjusting the limit of the pre-loop with a stride of 4 bytes.\n+    \/\/ 64-bit: bufferHeap uses Long type for memory accesses which are not vectorized in 32-bit VM\n+    public static void testBufferHeap(IntBuffer buffer) {\n+        for (int k = 0; k < buffer.limit(); k++) {\n+            buffer.put(k, buffer.get(k) + 1);\n@@ -173,0 +168,1 @@\n+    }\n@@ -174,5 +170,14 @@\n-        public void run() {\n-            for (int k = 0; k < b_arr.length; k += 4) {\n-                int v = (int) VH_arr_view.get(b_arr, k);\n-                VH_arr_view.set(b_arr, k, v + 1);\n-            }\n+    @Run(test = \"testBufferDirect\")\n+    public static void runBufferDirect() {\n+        IntBuffer buffer = ByteBuffer.allocateDirect(N * Integer.BYTES).order(ByteOrder.nativeOrder()).asIntBuffer();\n+        initBuffer(buffer);\n+        testBufferDirect(buffer);\n+        verifyBuffer(buffer);\n+    }\n+\n+    @Test\n+    \/\/ bufferDirect uses Unsafe memory accesses which are not vectorized currently\n+    \/\/ We find a CastX2P in pointer analysis (VPointer)\n+    public static void testBufferDirect(IntBuffer buffer) {\n+        for (int k = 0; k < buffer.limit(); k++) {\n+            buffer.put(k, buffer.get(k) + 1);\n@@ -180,0 +185,1 @@\n+    }\n@@ -181,14 +187,3 @@\n-        public void verify() {\n-            init(); \/\/ reset\n-            \/\/ Save initial INT values\n-            final int[] i_arr = new int[N];\n-            for (int k = 0; k < i_arr.length; k++) {\n-                i_arr[k] = (int) VH_arr_view.get(b_arr, k * Integer.BYTES);\n-            }\n-            run();  \/\/ run compiled code\n-            for (int k = 0; k < i_arr.length; k++) {\n-                int v = (int) VH_arr_view.get(b_arr, k * Integer.BYTES);\n-                if (v != (i_arr[k] + 1)) {\n-                    throw new RuntimeException(\" Invalid result: VH_arr_view.get(b_arr, \" + (k * Integer.BYTES) + \"): \" + v + \" != \" + (i_arr[k] + 1));\n-                }\n-            }\n+    public static void initBuffer(IntBuffer buffer) {\n+        for (int k = 0; k < buffer.limit(); k++) {\n+            buffer.put(k, k);\n@@ -198,19 +193,4 @@\n-    public static void main(String[] args) {\n-        if (args.length == 0) {\n-            throw new RuntimeException(\" Missing test name: array, arrayOffset, buffer, bufferHeap, bufferDirect, arrayView\");\n-        } else if (args.length == 1) {\n-            verify_vectors(args[0]);\n-        } else {\n-            Test te = switch (args[0]) {\n-                case \"array\" -> new TestArray();\n-                case \"arrayOffset\" -> new TestArrayOffset(offset);\n-                case \"buffer\" -> new TestBuffer(buffer);\n-                case \"bufferHeap\" -> new TestBuffer(heap_buffer_byte_to_int);\n-                case \"bufferDirect\" -> new TestBuffer(direct_buffer_byte_to_int);\n-                case \"arrayView\" -> new TestArrayView();\n-                default -> throw new RuntimeException(\" Unknown test: \" + args[0]);\n-            };\n-\n-            te.init();\n-            for (int i = 0; i < ITER; i++) {\n-                te.run();\n+    public static void verifyBuffer(IntBuffer buffer) {\n+        for(int k = 0; k < buffer.limit(); k++) {\n+            if (buffer.get(k) != (k + 1)) {\n+                throw new RuntimeException(\" Invalid result: buffer.get(\" + k + \"): \" + buffer.get(k) + \" != \" + (k + 1));\n@@ -218,1 +198,0 @@\n-            te.verify();\n@@ -220,1 +199,0 @@\n-\n@@ -223,13 +201,3 @@\n-    static void verify_vectors(String testName) {\n-        ProcessBuilder pb;\n-        OutputAnalyzer out;\n-        try {\n-            pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:-BackgroundCompilation\",\n-                                                                  \"-XX:+TraceNewVectors\",\n-                                                                  \"compiler.vectorization.TestBufferVectorization\",\n-                                                                  testName,\n-                                                                  \"run\");\n-            out = new OutputAnalyzer(pb.start());\n-        } catch (Exception e) {\n-            throw new RuntimeException(\" Exception launching Java process: \" + e);\n-        }\n+    @Run(test = \"testArrayView\")\n+    public static void runArrayView() {\n+        byte[] b_arr = new byte[N * Integer.BYTES];\n@@ -237,1 +205,3 @@\n-        out.shouldHaveExitValue(0);\n+        for (int k = 0; k < N; k++) {\n+            VH_arr_view.set(b_arr, k, k);\n+        }\n@@ -239,2 +209,4 @@\n-        if (testName.equals(\"bufferDirect\")) {\n-            return; \/\/ bufferDirect uses Unsafe memory accesses which are not vectorized currently\n+        \/\/ Save initial INT values\n+        int[] i_arr = new int[N];\n+        for (int k = 0; k < i_arr.length; k++) {\n+            i_arr[k] = (int) VH_arr_view.get(b_arr, k * Integer.BYTES);\n@@ -242,0 +214,1 @@\n+        testArrayView(b_arr);\n@@ -243,2 +216,5 @@\n-        if (testName.equals(\"bufferHeap\") && (Platform.is32bit())) {\n-            return; \/\/ bufferHeap uses Long type for memory accesses which are not vectorized in 32-bit VM\n+        for (int k = 0; k < i_arr.length; k++) {\n+            int v = (int) VH_arr_view.get(b_arr, k * Integer.BYTES);\n+            if (v != (i_arr[k] + 1)) {\n+                throw new RuntimeException(\" Invalid result: VH_arr_view.get(b_arr, \" + (k * Integer.BYTES) + \"): \" + v + \" != \" + (i_arr[k] + 1));\n+            }\n@@ -246,0 +222,1 @@\n+    }\n@@ -247,4 +224,11 @@\n-        out.shouldContain(\"Replicate\");\n-        out.shouldContain(\"LoadVector\");\n-        out.shouldContain(\"AddVI\");\n-        out.shouldContain(\"StoreVector\");\n+    @Test\n+    @IR(counts = {IRNode.REPLICATE_I,   \">0\",\n+                  IRNode.LOAD_VECTOR_I, \">0\",\n+                  IRNode.ADD_VI,        \">0\",\n+                  IRNode.STORE_VECTOR,  \">0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    public static void testArrayView(byte[] b_arr) {\n+        for (int k = 0; k < b_arr.length; k += 4) {\n+            int v = (int) VH_arr_view.get(b_arr, k);\n+            VH_arr_view.set(b_arr, k, v + 1);\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestBufferVectorization.java","additions":148,"deletions":164,"binary":false,"changes":312,"status":"modified"}]}