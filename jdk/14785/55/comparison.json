{"files":[{"patch":"@@ -8240,0 +8240,18 @@\n+\/\/ ============================================================================\n+\/\/ VerifyVectorAlignment Instruction\n+\n+instruct verify_vector_alignment(iRegP addr, immL_positive_bitmaskI mask, rFlagsReg cr) %{\n+  match(Set addr (VerifyVectorAlignment addr mask));\n+  effect(KILL cr);\n+  format %{ \"verify_vector_alignment $addr $mask \\t! verify alignment\" %}\n+  ins_encode %{\n+    Label Lskip;\n+    \/\/ check if masked bits of addr are zero\n+    __ tst($addr$$Register, $mask$$constant);\n+    __ br(Assembler::EQ, Lskip);\n+    __ stop(\"verify_vector_alignment found a misaligned vector memory access\");\n+    __ bind(Lskip);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -8980,0 +8980,15 @@\n+instruct verify_vector_alignment(rRegP addr, immL32 mask, rFlagsReg cr) %{\n+  match(Set addr (VerifyVectorAlignment addr mask));\n+  effect(KILL cr);\n+  format %{ \"verify_vector_alignment $addr $mask \\t! verify alignment\" %}\n+  ins_encode %{\n+    Label Lskip;\n+    \/\/ check if masked bits of addr are zero\n+    __ testq($addr$$Register, $mask$$constant);\n+    __ jccb(Assembler::equal, Lskip);\n+    __ stop(\"verify_vector_alignment found a misaligned vector memory access\");\n+    __ bind(Lskip);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -797,0 +797,1 @@\n+       !strcmp(_matrule->_rChild->_opType,\"VerifyVectorAlignment\")||\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -96,0 +96,4 @@\n+  develop(bool, VerifyAlignVector, false,                                   \\\n+          \"Check that vector stores\/loads are aligned if AlignVector\"       \\\n+          \"is enabled.\")                                                    \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"runtime\/globals_extension.hpp\"\n@@ -67,0 +68,7 @@\n+#ifdef ASSERT\n+  if (!AlignVector && VerifyAlignVector) {\n+    warning(\"VerifyAlignVector disabled because AlignVector is not enabled.\");\n+    FLAG_SET_CMDLINE(VerifyAlignVector, false);\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1797,0 +1797,7 @@\n+  if (derived->is_Mach() && derived->as_Mach()->ideal_Opcode() == Op_VerifyVectorAlignment) {\n+    \/\/ Bypass the verification node\n+    Node* base = find_base_for_derived(derived_base_map, derived->in(1), maxlrg);\n+    derived_base_map[derived->_idx] = base;\n+    return base;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -452,0 +452,1 @@\n+macro(VerifyVectorAlignment)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1059,1 +1059,1 @@\n-    if (has_method() && (_directive->VectorizeOption || _directive->VectorizeDebugOption)) {\n+    if (has_method() && _directive->VectorizeOption) {\n@@ -3701,0 +3701,25 @@\n+#ifdef ASSERT\n+    \/\/ Add VerifyVectorAlignment node between adr and load \/ store.\n+    if (VerifyAlignVector && Matcher::has_match_rule(Op_VerifyVectorAlignment)) {\n+      bool must_verify_alignment = n->is_LoadVector() ? n->as_LoadVector()->must_verify_alignment() :\n+                                                        n->as_StoreVector()->must_verify_alignment();\n+      if (must_verify_alignment) {\n+        jlong vector_width = n->is_LoadVector() ? n->as_LoadVector()->memory_size() :\n+                                                  n->as_StoreVector()->memory_size();\n+        \/\/ The memory access should be aligned to the vector width in bytes.\n+        \/\/ However, the underlying array is possibly less well aligned, but at least\n+        \/\/ to ObjectAlignmentInBytes. Hence, even if multiple arrays are accessed in\n+        \/\/ a loop we can expect at least the following alignment:\n+        jlong guaranteed_alignment = MIN2(vector_width, (jlong)ObjectAlignmentInBytes);\n+        assert(2 <= guaranteed_alignment && guaranteed_alignment <= 64, \"alignment must be in range\");\n+        assert(is_power_of_2(guaranteed_alignment), \"alignment must be power of 2\");\n+        \/\/ Create mask from alignment. e.g. 0b1000 -> 0b0111\n+        jlong mask = guaranteed_alignment - 1;\n+        Node* mask_con = ConLNode::make(mask);\n+        VerifyVectorAlignmentNode* va = new VerifyVectorAlignmentNode(n->in(MemNode::Address), mask_con);\n+        n->set_req(MemNode::Address, va);\n+      }\n+    }\n+#endif\n+    break;\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -360,0 +360,5 @@\n+  if (base != nullptr && base->is_Mach() && base->as_Mach()->ideal_Opcode() == Op_VerifyVectorAlignment) {\n+    \/\/ For VerifyVectorAlignment we just pass the type through\n+    return base->bottom_type()->is_ptr();\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -181,0 +181,1 @@\n+class VerifyVectorAlignmentNode;\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -560,2 +560,8 @@\n-  if (align_to_ref() == nullptr) {\n-    return false; \/\/ Did not find memory reference to align vectors\n+  if (_packset.length() == 0) {\n+#ifndef PRODUCT\n+    if (TraceSuperWord) {\n+      tty->print_cr(\"\\nNo pair packs generated, abort SuperWord.\");\n+      tty->cr();\n+    }\n+#endif\n+    return false;\n@@ -568,0 +574,2 @@\n+  filter_packs_for_alignment();\n+\n@@ -581,3 +589,3 @@\n-\/\/ This is the initial set of packs that will then be extended by\n-\/\/ following use->def and def->use links.  The align positions are\n-\/\/ assigned relative to the reference \"align_to_ref\"\n+\/\/ We can find adjacent memory references by comparing their relative\n+\/\/ alignment. Whether the final vectors can be aligned is determined later\n+\/\/ once all vectors are extended and combined.\n@@ -601,1 +609,0 @@\n-  Node_List align_to_refs;\n@@ -603,2 +610,5 @@\n-  int best_iv_adjustment = 0;\n-  MemNode* best_align_to_mem_ref = nullptr;\n+\n+  \/\/ Take the first mem_ref as the reference to align to. The pre-loop trip count is\n+  \/\/ modified to align this reference to a vector-aligned address. If strict alignment\n+  \/\/ is required, we may change the reference later (see filter_packs_for_alignment()).\n+  MemNode* align_to_mem_ref = nullptr;\n@@ -610,1 +620,0 @@\n-    align_to_refs.push(mem_ref);\n@@ -613,7 +622,3 @@\n-    if (best_align_to_mem_ref == nullptr) {\n-      \/\/ Set memory reference which is the best from all memory operations\n-      \/\/ to be used for alignment. The pre-loop trip count is modified to align\n-      \/\/ this reference to a vector-aligned address.\n-      best_align_to_mem_ref = mem_ref;\n-      best_iv_adjustment = iv_adjustment;\n-      NOT_PRODUCT(find_adjacent_refs_trace_1(best_align_to_mem_ref, best_iv_adjustment);)\n+    if (align_to_mem_ref == nullptr) {\n+      align_to_mem_ref = mem_ref;\n+      set_align_to_ref(align_to_mem_ref);\n@@ -636,72 +641,15 @@\n-    if (mem_ref_has_no_alignment_violation(mem_ref, iv_adjustment, align_to_ref_p,\n-                                           best_align_to_mem_ref, best_iv_adjustment,\n-                                           align_to_refs)) {\n-      \/\/ Create initial pack pairs of memory operations for which alignment was set.\n-      for (uint i = 0; i < memops.size(); i++) {\n-        Node* s1 = memops.at(i);\n-        int align = alignment(s1);\n-        if (align == top_align) continue;\n-        for (uint j = 0; j < memops.size(); j++) {\n-          Node* s2 = memops.at(j);\n-          if (alignment(s2) == top_align) continue;\n-          if (s1 != s2 && are_adjacent_refs(s1, s2)) {\n-            if (stmts_can_pack(s1, s2, align)) {\n-              Node_List* pair = new Node_List();\n-              pair->push(s1);\n-              pair->push(s2);\n-              if (!_do_vector_loop || same_origin_idx(s1, s2)) {\n-                _packset.append(pair);\n-              }\n-            }\n-          }\n-        }\n-      }\n-    } else {\n-      \/\/ Cannot create pairs for mem_ref. Reject all related memops forever.\n-\n-      \/\/ First, remove remaining memory ops of the same memory slice from the list.\n-      for (int i = memops.size() - 1; i >= 0; i--) {\n-        MemNode* s = memops.at(i)->as_Mem();\n-        if (same_memory_slice(s, mem_ref) || same_velt_type(s, mem_ref)) {\n-          memops.remove(i);\n-        }\n-      }\n-\n-      \/\/ Second, remove already constructed packs of the same memory slice.\n-      for (int i = _packset.length() - 1; i >= 0; i--) {\n-        Node_List* p = _packset.at(i);\n-        MemNode* s = p->at(0)->as_Mem();\n-        if (same_memory_slice(s, mem_ref) || same_velt_type(s, mem_ref)) {\n-          remove_pack_at(i);\n-        }\n-      }\n-\n-      \/\/ If needed find the best memory reference for loop alignment again.\n-      if (same_memory_slice(mem_ref, best_align_to_mem_ref) || same_velt_type(mem_ref, best_align_to_mem_ref)) {\n-        \/\/ Put memory ops from remaining packs back on memops list for\n-        \/\/ the best alignment search.\n-        uint orig_msize = memops.size();\n-        for (int i = 0; i < _packset.length(); i++) {\n-          Node_List* p = _packset.at(i);\n-          MemNode* s = p->at(0)->as_Mem();\n-          assert(!same_velt_type(s, mem_ref), \"sanity\");\n-          memops.push(s);\n-        }\n-        best_align_to_mem_ref = find_align_to_ref(memops, max_idx);\n-        if (best_align_to_mem_ref == nullptr) {\n-          if (TraceSuperWord) {\n-            tty->print_cr(\"SuperWord::find_adjacent_refs(): best_align_to_mem_ref == nullptr\");\n-          }\n-          \/\/ best_align_to_mem_ref will be used for adjusting the pre-loop limit in\n-          \/\/ SuperWord::align_initial_loop_index. Find one with the biggest vector size,\n-          \/\/ smallest data size and smallest iv offset from memory ops from remaining packs.\n-          if (_packset.length() > 0) {\n-            if (orig_msize == 0) {\n-              best_align_to_mem_ref = memops.at(max_idx)->as_Mem();\n-            } else {\n-              for (uint i = 0; i < orig_msize; i++) {\n-                memops.remove(0);\n-              }\n-              best_align_to_mem_ref = find_align_to_ref(memops, max_idx);\n-              assert(best_align_to_mem_ref == nullptr, \"sanity\");\n-              best_align_to_mem_ref = memops.at(max_idx)->as_Mem();\n+    \/\/ Create initial pack pairs of memory operations for which alignment was set.\n+    for (uint i = 0; i < memops.size(); i++) {\n+      Node* s1 = memops.at(i);\n+      int align = alignment(s1);\n+      if (align == top_align) continue;\n+      for (uint j = 0; j < memops.size(); j++) {\n+        Node* s2 = memops.at(j);\n+        if (alignment(s2) == top_align) continue;\n+        if (s1 != s2 && are_adjacent_refs(s1, s2)) {\n+          if (stmts_can_pack(s1, s2, align)) {\n+            Node_List* pair = new Node_List();\n+            pair->push(s1);\n+            pair->push(s2);\n+            if (!_do_vector_loop || same_origin_idx(s1, s2)) {\n+              _packset.append(pair);\n@@ -709,1 +657,0 @@\n-            assert(best_align_to_mem_ref != nullptr, \"sanity\");\n@@ -711,1 +658,0 @@\n-          break;\n@@ -713,5 +659,0 @@\n-        best_iv_adjustment = get_iv_adjustment(best_align_to_mem_ref);\n-        NOT_PRODUCT(find_adjacent_refs_trace_1(best_align_to_mem_ref, best_iv_adjustment);)\n-        \/\/ Restore list.\n-        while (memops.size() > orig_msize)\n-          (void)memops.pop();\n@@ -719,1 +660,1 @@\n-    } \/\/ unaligned memory accesses\n+    }\n@@ -728,0 +669,1 @@\n+  } \/\/ while (memops.size() != 0)\n@@ -729,2 +671,2 @@\n-  } \/\/ while (memops.size() != 0\n-  set_align_to_ref(best_align_to_mem_ref);\n+  assert(_packset.is_empty() || align_to_mem_ref != nullptr,\n+         \"packset empty or we find the alignment reference\");\n@@ -738,52 +680,0 @@\n-#ifndef PRODUCT\n-void SuperWord::find_adjacent_refs_trace_1(Node* best_align_to_mem_ref, int best_iv_adjustment) {\n-  if (is_trace_adjacent()) {\n-    tty->print(\"SuperWord::find_adjacent_refs best_align_to_mem_ref = %d, best_iv_adjustment = %d\",\n-       best_align_to_mem_ref->_idx, best_iv_adjustment);\n-       best_align_to_mem_ref->dump();\n-  }\n-}\n-#endif\n-\n-\/\/ If strict memory alignment is required (vectors_should_be_aligned), then check if\n-\/\/ mem_ref is aligned with best_align_to_mem_ref.\n-bool SuperWord::mem_ref_has_no_alignment_violation(MemNode* mem_ref, int iv_adjustment, VPointer& align_to_ref_p,\n-                                                   MemNode* best_align_to_mem_ref, int best_iv_adjustment,\n-                                                   Node_List &align_to_refs) {\n-  if (!vectors_should_be_aligned()) {\n-    \/\/ Alignment is not required by the hardware. No violation possible.\n-    return true;\n-  }\n-\n-  \/\/ All vectors need to be memory aligned, modulo their vector_width. This is more strict\n-  \/\/ than the hardware probably requires. Most hardware at most requires 4-byte alignment.\n-  \/\/\n-  \/\/ In the pre-loop, we align best_align_to_mem_ref to its vector_length. To ensure that\n-  \/\/ all mem_ref's are memory aligned modulo their vector_width, we only need to check that\n-  \/\/ they are all aligned to best_align_to_mem_ref, modulo their vector_width. For that,\n-  \/\/ we check the following 3 conditions.\n-\n-  \/\/ (1) All packs are aligned with best_align_to_mem_ref.\n-  if (memory_alignment(mem_ref, best_iv_adjustment) != 0) {\n-    return false;\n-  }\n-  \/\/ (2) All other vectors have vector_size less or equal to that of best_align_to_mem_ref.\n-  int vw = vector_width(mem_ref);\n-  int vw_best = vector_width(best_align_to_mem_ref);\n-  if (vw > vw_best) {\n-    \/\/ We only align to vector_width of best_align_to_mem_ref during pre-loop.\n-    \/\/ A mem_ref with a larger vector_width might thus not be vector_width aligned.\n-    return false;\n-  }\n-  \/\/ (3) Ensure that all vectors have the same invariant. We model memory accesses like this\n-  \/\/     address = base + k*iv + constant [+ invar]\n-  \/\/     memory_alignment ignores the invariant.\n-  VPointer p2(best_align_to_mem_ref, phase(), lpt(), nullptr, false);\n-  if (!align_to_ref_p.invar_equals(p2)) {\n-    \/\/ Do not vectorize memory accesses with different invariants\n-    \/\/ if unaligned memory accesses are not allowed.\n-    return false;\n-  }\n-  return true;\n-}\n-\n@@ -801,6 +691,0 @@\n-    \/\/ Only discard unalignable memory references if vector memory references\n-    \/\/ should be aligned on this platform.\n-    if (vectors_should_be_aligned() && !ref_is_alignable(p1)) {\n-      *cmp_ct.adr_at(i) = 0;\n-      continue;\n-    }\n@@ -895,89 +779,0 @@\n-\/\/------------------span_works_for_memory_size-----------------------------\n-static bool span_works_for_memory_size(MemNode* mem, int span, int mem_size, int offset) {\n-  bool span_matches_memory = false;\n-  if ((mem_size == type2aelembytes(T_BYTE) || mem_size == type2aelembytes(T_SHORT))\n-    && ABS(span) == type2aelembytes(T_INT)) {\n-    \/\/ There is a mismatch on span size compared to memory.\n-    for (DUIterator_Fast jmax, j = mem->fast_outs(jmax); j < jmax; j++) {\n-      Node* use = mem->fast_out(j);\n-      if (!VectorNode::is_type_transition_to_int(use)) {\n-        return false;\n-      }\n-    }\n-    \/\/ If all uses transition to integer, it means that we can successfully align even on mismatch.\n-    return true;\n-  }\n-  else {\n-    span_matches_memory = ABS(span) == mem_size;\n-  }\n-  return span_matches_memory && (ABS(offset) % mem_size) == 0;\n-}\n-\n-\/\/------------------------------ref_is_alignable---------------------------\n-\/\/ Can the preloop align the reference to position zero in the vector?\n-bool SuperWord::ref_is_alignable(VPointer& p) {\n-  if (!p.has_iv()) {\n-    return true;   \/\/ no induction variable\n-  }\n-  CountedLoopEndNode* pre_end = lp()->pre_loop_end();\n-  assert(pre_end->stride_is_con(), \"pre loop stride is constant\");\n-  int preloop_stride = pre_end->stride_con();\n-\n-  int span = preloop_stride * p.scale_in_bytes();\n-  int mem_size = p.memory_size();\n-  int offset   = p.offset_in_bytes();\n-  \/\/ Stride one accesses are alignable if offset is aligned to memory operation size.\n-  \/\/ Offset can be unaligned when UseUnalignedAccesses is used.\n-  if (span_works_for_memory_size(p.mem(), span, mem_size, offset)) {\n-    return true;\n-  }\n-  \/\/ If the initial offset from start of the object is computable,\n-  \/\/ check if the pre-loop can align the final offset accordingly.\n-  \/\/\n-  \/\/ In other words: Can we find an i such that the offset\n-  \/\/ after i pre-loop iterations is aligned to vw?\n-  \/\/   (init_offset + pre_loop) % vw == 0              (1)\n-  \/\/ where\n-  \/\/   pre_loop = i * span\n-  \/\/ is the number of bytes added to the offset by i pre-loop iterations.\n-  \/\/\n-  \/\/ For this to hold we need pre_loop to increase init_offset by\n-  \/\/   pre_loop = vw - (init_offset % vw)\n-  \/\/\n-  \/\/ This is only possible if pre_loop is divisible by span because each\n-  \/\/ pre-loop iteration increases the initial offset by 'span' bytes:\n-  \/\/   (vw - (init_offset % vw)) % span == 0\n-  \/\/\n-  int vw = vector_width_in_bytes(p.mem());\n-  assert(vw > 1, \"sanity\");\n-  Node* init_nd = pre_end->init_trip();\n-  if (init_nd->is_Con() && p.invar() == nullptr) {\n-    int init = init_nd->bottom_type()->is_int()->get_con();\n-    int init_offset = init * p.scale_in_bytes() + offset;\n-    if (init_offset < 0) { \/\/ negative offset from object start?\n-      return false;        \/\/ may happen in dead loop\n-    }\n-    if (vw % span == 0) {\n-      \/\/ If vm is a multiple of span, we use formula (1).\n-      if (span > 0) {\n-        return (vw - (init_offset % vw)) % span == 0;\n-      } else {\n-        assert(span < 0, \"nonzero stride * scale\");\n-        return (init_offset % vw) % -span == 0;\n-      }\n-    } else if (span % vw == 0) {\n-      \/\/ If span is a multiple of vw, we can simplify formula (1) to:\n-      \/\/   (init_offset + i * span) % vw == 0\n-      \/\/     =>\n-      \/\/   (init_offset % vw) + ((i * span) % vw) == 0\n-      \/\/     =>\n-      \/\/   init_offset % vw == 0\n-      \/\/\n-      \/\/ Because we add a multiple of vw to the initial offset, the final\n-      \/\/ offset is a multiple of vw if and only if init_offset is a multiple.\n-      \/\/\n-      return (init_offset % vw) == 0;\n-    }\n-  }\n-  return false;\n-}\n@@ -1029,4 +824,0 @@\n-    \/\/ iv_adjustment_in_bytes must be a multiple of elt_size if vector memory\n-    \/\/ references should be aligned on this platform.\n-    assert((ABS(iv_adjustment_in_bytes) % elt_size) == 0 || !vectors_should_be_aligned(),\n-           \"(%d) should be divisible by (%d)\", iv_adjustment_in_bytes, elt_size);\n@@ -1710,0 +1501,6 @@\n+#ifdef ASSERT\n+  for (int i = 0; i < _packset.length(); i++) {\n+    assert(_packset.at(i) != nullptr, \"no nullptr in packset\");\n+  }\n+#endif\n+\n@@ -1805,7 +1602,2 @@\n-  \/\/ Compress list.\n-  for (int i = _packset.length() - 1; i >= 0; i--) {\n-    Node_List* p1 = _packset.at(i);\n-    if (p1 == nullptr) {\n-      _packset.remove_at(i);\n-    }\n-  }\n+  \/\/ Remove all nullptr from packset\n+  compress_packset();\n@@ -1819,0 +1611,108 @@\n+\/\/ Find the set of alignment solutions for load\/store pack.\n+const AlignmentSolution* SuperWord::pack_alignment_solution(Node_List* pack) {\n+  assert(pack != nullptr && (pack->at(0)->is_Load() || pack->at(0)->is_Store()), \"only load\/store packs\");\n+\n+  const MemNode* mem_ref = pack->at(0)->as_Mem();\n+  VPointer mem_ref_p(mem_ref, phase(), lpt(), nullptr, false);\n+  const CountedLoopEndNode* pre_end = lp()->pre_loop_end();\n+  assert(pre_end->stride_is_con(), \"pre loop stride is constant\");\n+\n+  AlignmentSolver solver(pack->at(0)->as_Mem(),\n+                         pack->size(),\n+                         mem_ref_p.base(),\n+                         mem_ref_p.offset_in_bytes(),\n+                         mem_ref_p.invar(),\n+                         mem_ref_p.invar_factor(),\n+                         mem_ref_p.scale_in_bytes(),\n+                         pre_end->init_trip(),\n+                         pre_end->stride_con(),\n+                         iv_stride()\n+                         DEBUG_ONLY(COMMA is_trace_align_vector()));\n+  return solver.solve();\n+}\n+\n+\/\/ Ensure all packs are aligned, if AlignVector is on.\n+\/\/ Find an alignment solution: find the set of pre_iter that memory align all packs.\n+\/\/ Start with the maximal set (pre_iter >= 0) and filter it with the constraints\n+\/\/ that the packs impose. Remove packs that do not have a compatible solution.\n+void SuperWord::filter_packs_for_alignment() {\n+  \/\/ We do not need to filter if no alignment is required.\n+  if (!vectors_should_be_aligned()) {\n+    return;\n+  }\n+\n+#ifndef PRODUCT\n+  if (TraceSuperWord || is_trace_align_vector()) {\n+    tty->print_cr(\"\\nfilter_packs_for_alignment:\");\n+  }\n+#endif\n+\n+  ResourceMark rm;\n+\n+  \/\/ Start with trivial (unconstrained) solution space\n+  AlignmentSolution const* current = new TrivialAlignmentSolution();\n+  int mem_ops_count = 0;\n+  int mem_ops_rejected = 0;\n+  for (int i = 0; i < _packset.length(); i++) {\n+    Node_List* p = _packset.at(i);\n+    if (p != nullptr) {\n+      if (p->at(0)->is_Load() || p->at(0)->is_Store()) {\n+        mem_ops_count++;\n+        \/\/ Find solution for pack p, and filter with current solution.\n+        const AlignmentSolution* s = pack_alignment_solution(p);\n+        const AlignmentSolution* intersect = current->filter(s);\n+\n+#ifndef PRODUCT\n+        if (is_trace_align_vector()) {\n+          tty->print(\"  solution for pack:         \");\n+          s->print();\n+          tty->print(\"  intersection with current: \");\n+          intersect->print();\n+        }\n+#endif\n+\n+        if (intersect->is_empty()) {\n+          \/\/ Solution failed or is not compatible, remove pack i.\n+          _packset.at_put(i, nullptr);\n+          mem_ops_rejected++;\n+        } else {\n+          \/\/ Solution is compatible.\n+          current = intersect;\n+        }\n+      }\n+    }\n+  }\n+\n+#ifndef PRODUCT\n+  if (TraceSuperWord || is_trace_align_vector()) {\n+    tty->print(\"\\n final solution: \");\n+    current->print();\n+    tty->print_cr(\" rejected mem_ops packs: %d of %d\", mem_ops_rejected, mem_ops_count);\n+    tty->cr();\n+  }\n+#endif\n+\n+  assert(!current->is_empty(), \"solution must be non-empty\");\n+  if (current->is_constrained()) {\n+    \/\/ Solution is constrained (not trivial)\n+    \/\/ -> must change pre-limit to acheive alignment\n+    set_align_to_ref(current->as_constrained()->mem_ref());\n+  }\n+\n+  \/\/ Remove all nullptr from packset\n+  compress_packset();\n+}\n+\n+\/\/ Compress packset, such that it has no nullptr entries\n+void SuperWord::compress_packset() {\n+  int j = 0;\n+  for (int i = 0; i < _packset.length(); i++) {\n+    Node_List* p = _packset.at(i);\n+    if (p != nullptr) {\n+      _packset.at_put(j, p);\n+      j++;\n+    }\n+  }\n+  _packset.trunc_to(j);\n+}\n+\n@@ -2496,3 +2396,1 @@\n-  \/\/ Ensure main loop's initial value is properly aligned\n-  \/\/  (iv_initial_value + min_iv_offset) % vector_width_in_bytes() == 0\n-  align_initial_loop_index(align_to_ref());\n+  adjust_pre_loop_limit_to_align_main_loop_vectors();\n@@ -2771,0 +2669,11 @@\n+#ifdef ASSERT\n+      \/\/ Mark Load\/Store Vector for alignment verification\n+      if (VerifyAlignVector) {\n+        if (vn->Opcode() == Op_LoadVector) {\n+          vn->as_LoadVector()->set_must_verify_alignment();\n+        } else if (vn->Opcode() == Op_StoreVector) {\n+          vn->as_StoreVector()->set_must_verify_alignment();\n+        }\n+      }\n+#endif\n+\n@@ -3556,0 +3465,19 @@\n+#define TRACE_ALIGN_VECTOR_NODE(node) { \\\n+  DEBUG_ONLY(                           \\\n+    if (is_trace_align_vector()) {      \\\n+      tty->print(\"  \" #node \": \");      \\\n+      node->dump();                     \\\n+    }                                   \\\n+  )                                     \\\n+}                                       \\\n+\n+\/\/ Ensure that the main loop vectors are aligned by adjusting the pre loop limit. We memory-align\n+\/\/ the address of \"align_to_ref\" to the maximal possible vector width. We adjust the pre-loop\n+\/\/ iteration count by adjusting the pre-loop limit.\n+void SuperWord::adjust_pre_loop_limit_to_align_main_loop_vectors() {\n+  const MemNode* align_to_ref = _align_to_ref;\n+  assert(align_to_ref != nullptr, \"align_to_ref must be set\");\n+  assert(lp()->is_main_loop(), \"can only do alignment for main loop\");\n+\n+  \/\/ The opaque node for the limit, where we adjust the input\n+  Opaque1Node* pre_opaq = lp()->pre_loop_end()->limit()->as_Opaque1();\n@@ -3557,11 +3485,2 @@\n-\/\/----------------------------align_initial_loop_index---------------------------\n-\/\/ Adjust pre-loop limit so that in main loop, a load\/store reference\n-\/\/ to align_to_ref will be a position zero in the vector.\n-\/\/   (iv + k) mod vector_align == 0\n-void SuperWord::align_initial_loop_index(MemNode* align_to_ref) {\n-  assert(lp()->is_main_loop(), \"\");\n-  CountedLoopEndNode* pre_end = lp()->pre_loop_end();\n-  Node* pre_opaq1 = pre_end->limit();\n-  assert(pre_opaq1->Opcode() == Op_Opaque1, \"\");\n-  Opaque1Node* pre_opaq = (Opaque1Node*)pre_opaq1;\n-  Node* lim0 = pre_opaq->in(1);\n+  \/\/ Current pre-loop limit.\n+  Node* old_limit = pre_opaq->in(1);\n@@ -3569,1 +3488,1 @@\n-  \/\/ Where we put new limit calculations\n+  \/\/ Where we put new limit calculations.\n@@ -3572,2 +3491,1 @@\n-  \/\/ Ensure the original loop limit is available from the\n-  \/\/ pre-loop Opaque1 node.\n+  \/\/ Ensure the original loop limit is available from the pre-loop Opaque1 node.\n@@ -3580,5 +3498,5 @@\n-  \/\/ Given:\n-  \/\/     lim0 == original pre loop limit\n-  \/\/     V == v_align (power of 2)\n-  \/\/     invar == extra invariant piece of the address expression\n-  \/\/     e == offset [ +\/- invar ]\n+  \/\/ For the main-loop, we want the address of align_to_ref to be memory aligned\n+  \/\/ with some alignment width (aw, a power of 2). When we enter the main-loop,\n+  \/\/ we know that iv is equal to the pre-loop limit. If we adjust the pre-loop\n+  \/\/ limit by executing adjust_pre_iter many extra iterations, we can change the\n+  \/\/ alignment of the address.\n@@ -3586,4 +3504,2 @@\n-  \/\/ When reassociating expressions involving '%' the basic rules are:\n-  \/\/     (a - b) % k == 0   =>  a % k == b % k\n-  \/\/ and:\n-  \/\/     (a + b) % k == 0   =>  a % k == (k - b) % k\n+  \/\/   adr = base + offset + invar + scale * iv                               (1)\n+  \/\/   adr % aw = 0                                                           (2)\n@@ -3591,5 +3507,4 @@\n-  \/\/ For stride > 0 && scale > 0,\n-  \/\/   Derive the new pre-loop limit \"lim\" such that the two constraints:\n-  \/\/     (1) lim = lim0 + N           (where N is some positive integer < V)\n-  \/\/     (2) (e + lim) % V == 0\n-  \/\/   are true.\n+  \/\/ Note, that we are defining the modulo operator \"%\" such that the remainder is\n+  \/\/ always positive, see AlignmentSolution::mod(i, q). Since we are only computing\n+  \/\/ modulo with powers of 2, we can instead simply use the last log2(q) bits of\n+  \/\/ a number i, to get \"i % q\". This is performed with a bitmask.\n@@ -3597,6 +3512,1 @@\n-  \/\/   Substituting (1) into (2),\n-  \/\/     (e + lim0 + N) % V == 0\n-  \/\/   solve for N:\n-  \/\/     N = (V - (e + lim0)) % V\n-  \/\/   substitute back into (1), so that new limit\n-  \/\/     lim = lim0 + (V - (e + lim0)) % V\n+  \/\/ The limit of the pre-loop needs to be adjusted:\n@@ -3604,8 +3514,3 @@\n-  \/\/ For stride > 0 && scale < 0\n-  \/\/   Constraints:\n-  \/\/     lim = lim0 + N\n-  \/\/     (e - lim) % V == 0\n-  \/\/   Solving for lim:\n-  \/\/     (e - lim0 - N) % V == 0\n-  \/\/     N = (e - lim0) % V\n-  \/\/     lim = lim0 + (e - lim0) % V\n+  \/\/   old_limit:       current pre-loop limit\n+  \/\/   new_limit:       new pre-loop limit\n+  \/\/   adjust_pre_iter: additional pre-loop iterations for alignment adjustment\n@@ -3613,8 +3518,2 @@\n-  \/\/ For stride < 0 && scale > 0\n-  \/\/   Constraints:\n-  \/\/     lim = lim0 - N\n-  \/\/     (e + lim) % V == 0\n-  \/\/   Solving for lim:\n-  \/\/     (e + lim0 - N) % V == 0\n-  \/\/     N = (e + lim0) % V\n-  \/\/     lim = lim0 - (e + lim0) % V\n+  \/\/ We want to find adjust_pre_iter, such that the address is aligned when entering\n+  \/\/ the main-loop:\n@@ -3622,23 +3521,173 @@\n-  \/\/ For stride < 0 && scale < 0\n-  \/\/   Constraints:\n-  \/\/     lim = lim0 - N\n-  \/\/     (e - lim) % V == 0\n-  \/\/   Solving for lim:\n-  \/\/     (e - lim0 + N) % V == 0\n-  \/\/     N = (V - (e - lim0)) % V\n-  \/\/     lim = lim0 - (V - (e - lim0)) % V\n-\n-  int vw = vector_width_in_bytes(align_to_ref);\n-  int stride   = iv_stride();\n-  int scale    = align_to_ref_p.scale_in_bytes();\n-  int elt_size = align_to_ref_p.memory_size();\n-  int v_align  = vw \/ elt_size;\n-  assert(v_align > 1, \"sanity\");\n-  int offset   = align_to_ref_p.offset_in_bytes() \/ elt_size;\n-  Node *offsn  = _igvn.intcon(offset);\n-\n-  Node *e = offsn;\n-  if (align_to_ref_p.invar() != nullptr) {\n-    \/\/ incorporate any extra invariant piece producing (offset +\/- invar) >>> log2(elt)\n-    Node* log2_elt = _igvn.intcon(exact_log2(elt_size));\n-    Node* invar = align_to_ref_p.invar();\n+  \/\/   iv = new_limit = old_limit + adjust_pre_iter                           (3a, stride > 0)\n+  \/\/   iv = new_limit = old_limit - adjust_pre_iter                           (3b, stride < 0)\n+  \/\/\n+  \/\/ We define boi as:\n+  \/\/\n+  \/\/   boi = base + offset + invar                                            (4)\n+  \/\/\n+  \/\/ And now we can simplify the address using (1), (3), and (4):\n+  \/\/\n+  \/\/   adr = boi + scale * new_limit\n+  \/\/   adr = boi + scale * (old_limit + adjust_pre_iter)                      (5a, stride > 0)\n+  \/\/   adr = boi + scale * (old_limit - adjust_pre_iter)                      (5b, stride < 0)\n+  \/\/\n+  \/\/ And hence we can restate (2) with (5), and solve the equation for adjust_pre_iter:\n+  \/\/\n+  \/\/   (boi + scale * (old_limit + adjust_pre_iter) % aw = 0                  (6a, stride > 0)\n+  \/\/   (boi + scale * (old_limit - adjust_pre_iter) % aw = 0                  (6b, stride < 0)\n+  \/\/\n+  \/\/ In most cases, scale is the element size, for example:\n+  \/\/\n+  \/\/   for (i = 0; i < a.length; i++) { a[i] = ...; }\n+  \/\/\n+  \/\/ It is thus reasonable to assume that both abs(scale) and abs(stride) are\n+  \/\/ strictly positive powers of 2. Further, they can be assumed to be non-zero,\n+  \/\/ otherwise the address does not depend on iv, and the alignment cannot be\n+  \/\/ affected by adjusting the pre-loop limit.\n+  \/\/\n+  \/\/ Further, if abs(scale) >= aw, then adjust_pre_iter has no effect on alignment, and\n+  \/\/ we are not able to affect the alignment at all. Hence, we require abs(scale) < aw.\n+  \/\/\n+  \/\/ Moreover, for alignment to be achievable, boi must be a multiple of scale. If strict\n+  \/\/ alignment is required (i.e. -XX:+AlignVector), this is guaranteed by the filtering\n+  \/\/ done with the AlignmentSolver \/ AlignmentSolution. If strict alignment is not\n+  \/\/ required, then alignment is still preferable for performance, but not necessary.\n+  \/\/ In many cases boi will be a multiple of scale, but if it is not, then the adjustment\n+  \/\/ does not guarantee alignment, but the code is still correct.\n+  \/\/\n+  \/\/ Hence, in what follows we assume that boi is a multiple of scale, and in fact all\n+  \/\/ terms in (6) are multiples of scale. Therefore we divide all terms by scale:\n+  \/\/\n+  \/\/   AW = aw \/ abs(scale)            (power of 2)                           (7)\n+  \/\/   BOI = boi \/ abs(scale)                                                 (8)\n+  \/\/\n+  \/\/ and restate (6), using (7) and (8), i.e. we divide (6) by abs(scale):\n+  \/\/\n+  \/\/   (BOI + sign(scale) * (old_limit + adjust_pre_iter) % AW = 0           (9a, stride > 0)\n+  \/\/   (BOI + sign(scale) * (old_limit - adjust_pre_iter) % AW = 0           (9b, stride < 0)\n+  \/\/\n+  \/\/   where: sign(scale) = scale \/ abs(scale) = (scale > 0 ? 1 : -1)\n+  \/\/\n+  \/\/ Note, (9) allows for periodic solutions of adjust_pre_iter, with periodicity AW.\n+  \/\/ But we would like to spend as few iterations in the pre-loop as possible,\n+  \/\/ hence we want the smallest adjust_pre_iter, and so:\n+  \/\/\n+  \/\/   0 <= adjust_pre_iter < AW                                              (10)\n+  \/\/\n+  \/\/ We solve (9) for adjust_pre_iter, in the following 4 cases:\n+  \/\/\n+  \/\/ Case A: scale > 0 && stride > 0 (i.e. sign(scale) =  1)\n+  \/\/   (BOI + old_limit + adjust_pre_iter) % AW = 0\n+  \/\/   adjust_pre_iter = (-BOI - old_limit) % AW                              (11a)\n+  \/\/\n+  \/\/ Case B: scale < 0 && stride > 0 (i.e. sign(scale) = -1)\n+  \/\/   (BOI - old_limit - adjust_pre_iter) % AW = 0\n+  \/\/   adjust_pre_iter = (BOI - old_limit) % AW                               (11b)\n+  \/\/\n+  \/\/ Case C: scale > 0 && stride < 0 (i.e. sign(scale) =  1)\n+  \/\/   (BOI + old_limit - adjust_pre_iter) % AW = 0\n+  \/\/   adjust_pre_iter = (BOI + old_limit) % AW                               (11c)\n+  \/\/\n+  \/\/ Case D: scale < 0 && stride < 0 (i.e. sign(scale) = -1)\n+  \/\/   (BOI - old_limit + adjust_pre_iter) % AW = 0\n+  \/\/   adjust_pre_iter = (-BOI + old_limit) % AW                              (11d)\n+  \/\/\n+  \/\/ We now generalize the equations (11*) by using:\n+  \/\/\n+  \/\/   OP:   (stride         > 0) ? SUB   : ADD\n+  \/\/   XBOI: (stride * scale > 0) ? -BOI  : BOI\n+  \/\/\n+  \/\/ which gives us the final pre-loop limit adjustment:\n+  \/\/\n+  \/\/   adjust_pre_iter = (XBOI OP old_limit) % AW                             (12)\n+  \/\/\n+  \/\/ We can construct XBOI by additionally defining:\n+  \/\/\n+  \/\/   xboi = (stride * scale > 0) ? -boi              : boi                  (13)\n+  \/\/\n+  \/\/ which gives us:\n+  \/\/\n+  \/\/   XBOI = (stride * scale > 0) ? -BOI              : BOI\n+  \/\/        = (stride * scale > 0) ? -boi \/ abs(scale) : boi \/ abs(scale)\n+  \/\/        = xboi \/ abs(scale)                                               (14)\n+  \/\/\n+  \/\/ When we have computed adjust_pre_iter, we update the pre-loop limit\n+  \/\/ with (3a, b). However, we have to make sure that the adjust_pre_iter\n+  \/\/ additional pre-loop iterations do not lead the pre-loop to execute\n+  \/\/ iterations that would step over the original limit (orig_limit) of\n+  \/\/ the loop. Hence, we must constrain the updated limit as follows:\n+  \/\/\n+  \/\/ constrained_limit = MIN(old_limit + adjust_pre_iter, orig_limit)\n+  \/\/                   = MIN(new_limit,                   orig_limit)         (15a, stride > 0)\n+  \/\/ constrained_limit = MAX(old_limit - adjust_pre_iter, orig_limit)\n+  \/\/                   = MAX(new_limit,                   orig_limit)         (15a, stride < 0)\n+\n+  \/\/ We chose an aw that is the maximal possible vector width for the type of\n+  \/\/ align_to_ref.\n+  const int aw       = vector_width_in_bytes(align_to_ref);\n+  const int stride   = iv_stride();\n+  const int scale    = align_to_ref_p.scale_in_bytes();\n+  const int offset   = align_to_ref_p.offset_in_bytes();\n+  Node* base         = align_to_ref_p.adr();\n+  Node* invar        = align_to_ref_p.invar();\n+\n+#ifdef ASSERT\n+  if (is_trace_align_vector()) {\n+    tty->print_cr(\"\\nadjust_pre_loop_limit_to_align_main_loop_vectors:\");\n+    tty->print(\"  align_to_ref:\");\n+    align_to_ref->dump();\n+    tty->print_cr(\"  aw:       %d\", aw);\n+    tty->print_cr(\"  stride:   %d\", stride);\n+    tty->print_cr(\"  scale:    %d\", scale);\n+    tty->print_cr(\"  offset:   %d\", offset);\n+    tty->print(\"  base:\");\n+    base->dump();\n+    if (invar == nullptr) {\n+      tty->print_cr(\"  invar:     null\");\n+    } else {\n+      tty->print(\"  invar:\");\n+      invar->dump();\n+    }\n+    tty->print(\"  old_limit: \");\n+    old_limit->dump();\n+    tty->print(\"  orig_limit: \");\n+    orig_limit->dump();\n+  }\n+#endif\n+\n+  if (stride == 0 || !is_power_of_2(abs(stride)) ||\n+      scale  == 0 || !is_power_of_2(abs(scale))  ||\n+      abs(scale) >= aw) {\n+#ifdef ASSERT\n+    if (is_trace_align_vector()) {\n+      tty->print_cr(\" Alignment cannot be affected by changing pre-loop limit because\");\n+      tty->print_cr(\" stride or scale are not power of 2, or abs(scale) >= aw.\");\n+    }\n+#endif\n+    \/\/ Cannot affect alignment, abort.\n+    return;\n+  }\n+\n+  assert(stride != 0 && is_power_of_2(abs(stride)) &&\n+         scale  != 0 && is_power_of_2(abs(scale))  &&\n+         abs(scale) < aw, \"otherwise we cannot affect alignment with pre-loop\");\n+\n+  const int AW = aw \/ abs(scale);\n+\n+#ifdef ASSERT\n+  if (is_trace_align_vector()) {\n+    tty->print_cr(\"  AW = aw(%d) \/ abs(scale(%d)) = %d\", aw, scale, AW);\n+  }\n+#endif\n+\n+  \/\/ 1: Compute (13a, b):\n+  \/\/    xboi = -boi = (-base - offset - invar)         (stride * scale > 0)\n+  \/\/    xboi = +boi = (+base + offset + invar)         (stride * scale < 0)\n+  const bool is_sub = scale * stride > 0;\n+\n+  \/\/ 1.1: offset\n+  Node* xboi = _igvn.intcon(is_sub ? -offset : offset);\n+  TRACE_ALIGN_VECTOR_NODE(xboi);\n+\n+  \/\/ 1.2: invar (if it exists)\n+  if (invar != nullptr) {\n@@ -3651,0 +3700,6 @@\n+      TRACE_ALIGN_VECTOR_NODE(invar);\n+   }\n+    if (is_sub) {\n+      xboi = new SubINode(xboi, invar);\n+    } else {\n+      xboi = new AddINode(xboi, invar);\n@@ -3652,6 +3707,3 @@\n-    Node* aref = new URShiftINode(invar, log2_elt);\n-    _igvn.register_new_node_with_optimizer(aref);\n-    _phase->set_ctrl(aref, pre_ctrl);\n-    e =  new AddINode(e, aref);\n-    _igvn.register_new_node_with_optimizer(e);\n-    _phase->set_ctrl(e, pre_ctrl);\n+    _igvn.register_new_node_with_optimizer(xboi);\n+    _phase->set_ctrl(xboi, pre_ctrl);\n+    TRACE_ALIGN_VECTOR_NODE(xboi);\n@@ -3659,3 +3711,7 @@\n-  if (vw > ObjectAlignmentInBytes || align_to_ref_p.base()->is_top()) {\n-    \/\/ incorporate base e +\/- base && Mask >>> log2(elt)\n-    Node* xbase = new CastP2XNode(nullptr, align_to_ref_p.adr());\n+\n+  \/\/ 1.3: base (unless base is guaranteed aw aligned)\n+  if (aw > ObjectAlignmentInBytes || align_to_ref_p.base()->is_top()) {\n+    \/\/ The base is only aligned with ObjectAlignmentInBytes with arrays.\n+    \/\/ When the base() is top, we have no alignment guarantee at all.\n+    \/\/ Hence, we must now take the base into account for the calculation.\n+    Node* xbase = new CastP2XNode(nullptr, base);\n@@ -3663,0 +3719,1 @@\n+    TRACE_ALIGN_VECTOR_NODE(xbase);\n@@ -3666,0 +3723,1 @@\n+    TRACE_ALIGN_VECTOR_NODE(xbase);\n@@ -3667,15 +3725,27 @@\n-    Node* mask = _igvn.intcon(vw-1);\n-    Node* masked_xbase  = new AndINode(xbase, mask);\n-    _igvn.register_new_node_with_optimizer(masked_xbase);\n-    Node* log2_elt = _igvn.intcon(exact_log2(elt_size));\n-    Node* bref     = new URShiftINode(masked_xbase, log2_elt);\n-    _igvn.register_new_node_with_optimizer(bref);\n-    _phase->set_ctrl(bref, pre_ctrl);\n-    e = new AddINode(e, bref);\n-    _igvn.register_new_node_with_optimizer(e);\n-    _phase->set_ctrl(e, pre_ctrl);\n-  }\n-\n-  \/\/ compute e +\/- lim0\n-  if (scale < 0) {\n-    e = new SubINode(e, lim0);\n+    if (is_sub) {\n+      xboi = new SubINode(xboi, xbase);\n+    } else {\n+      xboi = new AddINode(xboi, xbase);\n+    }\n+    _igvn.register_new_node_with_optimizer(xboi);\n+    _phase->set_ctrl(xboi, pre_ctrl);\n+    TRACE_ALIGN_VECTOR_NODE(xboi);\n+  }\n+\n+  \/\/ 2: Compute (14):\n+  \/\/    XBOI = xboi \/ abs(scale)\n+  \/\/    The division is executed as shift\n+  Node* log2_abs_scale = _igvn.intcon(exact_log2(abs(scale)));\n+  Node* XBOI = new URShiftINode(xboi, log2_abs_scale);\n+  _igvn.register_new_node_with_optimizer(XBOI);\n+  _phase->set_ctrl(XBOI, pre_ctrl);\n+  TRACE_ALIGN_VECTOR_NODE(log2_abs_scale);\n+  TRACE_ALIGN_VECTOR_NODE(XBOI);\n+\n+  \/\/ 3: Compute (12):\n+  \/\/    adjust_pre_iter = (XBOI OP old_limit) % AW\n+  \/\/\n+  \/\/ 3.1: XBOI_OP_old_limit = XBOI OP old_limit\n+  Node* XBOI_OP_old_limit = nullptr;\n+  if (stride > 0) {\n+    XBOI_OP_old_limit = new SubINode(XBOI, old_limit);\n@@ -3683,21 +3753,23 @@\n-    e = new AddINode(e, lim0);\n-  }\n-  _igvn.register_new_node_with_optimizer(e);\n-  _phase->set_ctrl(e, pre_ctrl);\n-\n-  if (stride * scale > 0) {\n-    \/\/ compute V - (e +\/- lim0)\n-    Node* va  = _igvn.intcon(v_align);\n-    e = new SubINode(va, e);\n-    _igvn.register_new_node_with_optimizer(e);\n-    _phase->set_ctrl(e, pre_ctrl);\n-  }\n-  \/\/ compute N = (exp) % V\n-  Node* va_msk = _igvn.intcon(v_align - 1);\n-  Node* N = new AndINode(e, va_msk);\n-  _igvn.register_new_node_with_optimizer(N);\n-  _phase->set_ctrl(N, pre_ctrl);\n-\n-  \/\/   substitute back into (1), so that new limit\n-  \/\/     lim = lim0 + N\n-  Node* lim;\n+    XBOI_OP_old_limit = new AddINode(XBOI, old_limit);\n+  }\n+  _igvn.register_new_node_with_optimizer(XBOI_OP_old_limit);\n+  _phase->set_ctrl(XBOI_OP_old_limit, pre_ctrl);\n+  TRACE_ALIGN_VECTOR_NODE(XBOI_OP_old_limit);\n+\n+  \/\/ 3.2: Compute:\n+  \/\/    adjust_pre_iter = (XBOI OP old_limit) % AW\n+  \/\/                    = XBOI_OP_old_limit % AW\n+  \/\/                    = XBOI_OP_old_limit AND (AW - 1)\n+  \/\/    Since AW is a power of 2, the modulo operation can be replaced with\n+  \/\/    a bitmask operation.\n+  Node* mask_AW = _igvn.intcon(AW-1);\n+  Node* adjust_pre_iter = new AndINode(XBOI_OP_old_limit, mask_AW);\n+  _igvn.register_new_node_with_optimizer(adjust_pre_iter);\n+  _phase->set_ctrl(adjust_pre_iter, pre_ctrl);\n+  TRACE_ALIGN_VECTOR_NODE(mask_AW);\n+  TRACE_ALIGN_VECTOR_NODE(adjust_pre_iter);\n+\n+  \/\/ 4: Compute (3a, b):\n+  \/\/    new_limit = old_limit + adjust_pre_iter     (stride > 0)\n+  \/\/    new_limit = old_limit - adjust_pre_iter     (stride < 0)\n+  Node* new_limit = nullptr;\n@@ -3705,1 +3777,1 @@\n-    lim = new SubINode(lim0, N);\n+    new_limit = new SubINode(old_limit, adjust_pre_iter);\n@@ -3707,10 +3779,17 @@\n-    lim = new AddINode(lim0, N);\n-  }\n-  _igvn.register_new_node_with_optimizer(lim);\n-  _phase->set_ctrl(lim, pre_ctrl);\n-  Node* constrained =\n-    (stride > 0) ? (Node*) new MinINode(lim, orig_limit)\n-                 : (Node*) new MaxINode(lim, orig_limit);\n-  _igvn.register_new_node_with_optimizer(constrained);\n-  _phase->set_ctrl(constrained, pre_ctrl);\n-  _igvn.replace_input_of(pre_opaq, 1, constrained);\n+    new_limit = new AddINode(old_limit, adjust_pre_iter);\n+  }\n+  _igvn.register_new_node_with_optimizer(new_limit);\n+  _phase->set_ctrl(new_limit, pre_ctrl);\n+  TRACE_ALIGN_VECTOR_NODE(new_limit);\n+\n+  \/\/ 5: Compute (15a, b):\n+  \/\/    Prevent pre-loop from going past the original limit of the loop.\n+  Node* constrained_limit =\n+    (stride > 0) ? (Node*) new MinINode(new_limit, orig_limit)\n+                 : (Node*) new MaxINode(new_limit, orig_limit);\n+  _igvn.register_new_node_with_optimizer(constrained_limit);\n+  _phase->set_ctrl(constrained_limit, pre_ctrl);\n+  TRACE_ALIGN_VECTOR_NODE(constrained_limit);\n+\n+  \/\/ 6: Hack the pre-loop limit\n+  _igvn.replace_input_of(pre_opaq, 1, constrained_limit);\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":467,"deletions":388,"binary":false,"changes":855,"status":"modified"},{"patch":"@@ -250,1 +250,1 @@\n-  MemNode* _align_to_ref;                \/\/ Memory reference that pre-loop will align to\n+  MemNode const* _align_to_ref;          \/\/ Memory reference that pre-loop will align to\n@@ -284,0 +284,1 @@\n+  bool     is_trace_align_vector() { return (_vector_loop_debug & 128) > 0; }\n@@ -318,1 +319,1 @@\n-  int vector_width(Node* n) {\n+  int vector_width(const Node* n) const {\n@@ -322,1 +323,1 @@\n-  int vector_width_in_bytes(Node* n) {\n+  int vector_width_in_bytes(const Node* n) const {\n@@ -327,2 +328,2 @@\n-  MemNode* align_to_ref()            { return _align_to_ref; }\n-  void  set_align_to_ref(MemNode* m) { _align_to_ref = m; }\n+  const MemNode* align_to_ref() const { return _align_to_ref; }\n+  void set_align_to_ref(const MemNode* m) { _align_to_ref = m; }\n@@ -363,2 +364,2 @@\n-  const Type* velt_type(Node* n)             { return _node_info.adr_at(bb_idx(n))->_velt_type; }\n-  BasicType velt_basic_type(Node* n)         { return velt_type(n)->array_element_basic_type(); }\n+  const Type* velt_type(const Node* n) const { return _node_info.adr_at(bb_idx(n))->_velt_type; }\n+  BasicType velt_basic_type(const Node* n) const { return velt_type(n)->array_element_basic_type(); }\n@@ -444,9 +445,0 @@\n-  \/\/ Tracing support\n-  #ifndef PRODUCT\n-  void find_adjacent_refs_trace_1(Node* best_align_to_mem_ref, int best_iv_adjustment);\n-  #endif\n-  \/\/ If strict memory alignment is required (vectors_should_be_aligned), then check if\n-  \/\/ mem_ref is aligned with best_align_to_mem_ref.\n-  bool mem_ref_has_no_alignment_violation(MemNode* mem_ref, int iv_adjustment, VPointer& align_to_ref_p,\n-                                          MemNode* best_align_to_mem_ref, int best_iv_adjustment,\n-                                          Node_List &align_to_refs);\n@@ -457,2 +449,0 @@\n-  \/\/ Can the preloop align the reference to position zero in the vector?\n-  bool ref_is_alignable(VPointer& p);\n@@ -500,0 +490,6 @@\n+  \/\/ Ensure all packs are aligned, if AlignVector is on.\n+  void filter_packs_for_alignment();\n+  \/\/ Find the set of alignment solutions for load\/store pack.\n+  const AlignmentSolution* pack_alignment_solution(Node_List* pack);\n+  \/\/ Compress packset, such that it has no nullptr entries.\n+  void compress_packset();\n@@ -547,3 +543,2 @@\n-  \/\/ Adjust pre-loop limit so that in main loop, a load\/store reference\n-  \/\/ to align_to_ref will be a position zero in the vector.\n-  void align_initial_loop_index(MemNode* align_to_ref);\n+  \/\/ Ensure that the main loop vectors are aligned by adjusting the pre loop limit.\n+  void adjust_pre_loop_limit_to_align_main_loop_vectors();\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":16,"deletions":21,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -38,1 +38,2 @@\n-VPointer::VPointer(MemNode* mem, PhaseIdealLoop* phase, IdealLoopTree* lpt,\n+VPointer::VPointer(const MemNode* mem,\n+                   PhaseIdealLoop* phase, IdealLoopTree* lpt,\n@@ -122,0 +123,16 @@\n+\/\/ Biggest detectable factor of the invariant.\n+int VPointer::invar_factor() const {\n+  Node* n = invar();\n+  if (n == nullptr) {\n+    return 0;\n+  }\n+  int opc = n->Opcode();\n+  if (opc == Op_LShiftI && n->in(2)->is_Con()) {\n+    return 1 << n->in(2)->get_int();\n+  } else if (opc == Op_LShiftL && n->in(2)->is_Con()) {\n+    return 1 << n->in(2)->get_int();\n+  }\n+  \/\/ All our best-effort has failed.\n+  return 1;\n+}\n+\n@@ -420,1 +437,1 @@\n-void VPointer::Tracer::ctor_1(Node* mem) {\n+void VPointer::Tracer::ctor_1(const Node* mem) {\n@@ -462,1 +479,1 @@\n-void VPointer::Tracer::ctor_6(Node* mem) {\n+void VPointer::Tracer::ctor_6(const Node* mem) {\n@@ -688,0 +705,487 @@\n+#endif\n+\n+\n+AlignmentSolution* AlignmentSolver::solve() const {\n+  DEBUG_ONLY( trace_start_solve(); )\n+\n+  \/\/ Out of simplicity: non power-of-2 stride not supported.\n+  if (!is_power_of_2(abs(_pre_stride))) {\n+    return new EmptyAlignmentSolution(\"non power-of-2 stride not supported\");\n+  }\n+  assert(is_power_of_2(abs(_main_stride)), \"main_stride is power of 2\");\n+  assert(_aw > 0 && is_power_of_2(_aw), \"aw must be power of 2\");\n+\n+  \/\/ Out of simplicity: non power-of-2 scale not supported.\n+  if (abs(_scale) == 0 || !is_power_of_2(abs(_scale))) {\n+    return new EmptyAlignmentSolution(\"non power-of-2 scale not supported\");\n+  }\n+\n+  \/\/ We analyze the address of mem_ref. The idea is to disassemble it into a linear\n+  \/\/ expression, where we can use the constant factors as the basis for ensuring the\n+  \/\/ alignment of vector memory accesses.\n+  \/\/\n+  \/\/ The Simple form of the address is disassembled by VPointer into:\n+  \/\/\n+  \/\/   adr = base + offset + invar + scale * iv\n+  \/\/\n+  \/\/ Where the iv can be written as:\n+  \/\/\n+  \/\/   iv = init + pre_stride * pre_iter + main_stride * main_iter\n+  \/\/\n+  \/\/ init:        value before pre-loop\n+  \/\/ pre_stride:  increment per pre-loop iteration\n+  \/\/ pre_iter:    number of pre-loop iterations (adjustable via pre-loop limit)\n+  \/\/ main_stride: increment per main-loop iteration (= pre_stride * unroll_factor)\n+  \/\/ main_iter:   number of main-loop iterations (main_iter >= 0)\n+  \/\/\n+  \/\/ In the following, we restate the Simple form of the address expression, by first\n+  \/\/ expanding the iv variable. In a second step, we reshape the expression again, and\n+  \/\/ state it as a linear expression, consisting of 6 terms.\n+  \/\/\n+  \/\/          Simple form           Expansion of iv variable                  Reshaped with constants   Comments for terms\n+  \/\/          -----------           ------------------------                  -----------------------   ------------------\n+  \/\/   adr =  base               =  base                                   =  base                      (base % aw = 0)\n+  \/\/        + offset              + offset                                  + C_const                   (sum of constant terms)\n+  \/\/        + invar               + invar_factor * var_invar                + C_invar * var_invar       (term for invariant)\n+  \/\/                          \/   + scale * init                            + C_init  * var_init        (term for variable init)\n+  \/\/        + scale * iv   -> |   + scale * pre_stride * pre_iter           + C_pre   * pre_iter        (adjustable pre-loop term)\n+  \/\/                          \\   + scale * main_stride * main_iter         + C_main  * main_iter       (main-loop term)\n+  \/\/\n+  \/\/ We describe the 6 terms:\n+  \/\/   1) The \"base\" of the address is the address of a Java object (e.g. array),\n+  \/\/      and as such  ObjectAlignmentInBytes (a power of 2) aligned. We have\n+  \/\/      defined aw = MIN(vector_width, ObjectAlignmentInBytes), which is also\n+  \/\/      a power of 2. And hence we know that \"base\" is thus also aw-aligned:\n+  \/\/\n+  \/\/        base % ObjectAlignmentInBytes = 0     ==>    base % aw = 0\n+  \/\/\n+  \/\/   2) The \"C_const\" term is the sum of all constant terms. This is \"offset\",\n+  \/\/      plus \"scale * init\" if it is constant.\n+  \/\/   3) The \"C_invar * var_invar\" is the factorization of \"invar\" into a constant\n+  \/\/      and variable term. If there is no invariant, then \"C_invar\" is zero.\n+  \/\/\n+  \/\/        invar = C_invar * var_invar                                             (FAC_INVAR)\n+  \/\/\n+  \/\/   4) The \"C_init * var_init\" is the factorization of \"scale * init\" into a\n+  \/\/      constant and a variable term. If \"init\" is constant, then \"C_init\" is\n+  \/\/      zero, and \"C_const\" accounts for \"init\" instead.\n+  \/\/\n+  \/\/        scale * init = C_init * var_init + scale * C_const_init                 (FAC_INIT)\n+  \/\/        C_init       = (init is constant) ? 0    : scale\n+  \/\/        C_const_init = (init is constant) ? init : 0\n+  \/\/\n+  \/\/   5) The \"C_pre * pre_iter\" term represents how much the iv is incremented\n+  \/\/      during the \"pre_iter\" pre-loop iterations. This term can be adjusted\n+  \/\/      by changing the pre-loop limit, which defines how many pre-loop iterations\n+  \/\/      are executed. This allows us to adjust the alignment of the main-loop\n+  \/\/      memory reference.\n+  \/\/   6) The \"C_main * main_iter\" term represents how much the iv is increased\n+  \/\/      during \"main_iter\" main-loop iterations.\n+\n+  \/\/ Attribute init (i.e. _init_node) either to C_const or to C_init term.\n+  const int C_const_init = _init_node->is_ConI() ? _init_node->as_ConI()->get_int() : 0;\n+  const int C_const =      _offset + C_const_init * _scale;\n+\n+  \/\/ Set C_invar depending on if invar is present\n+  const int C_invar = (_invar == nullptr) ? 0 : abs(_invar_factor);\n+\n+  const int C_init = _init_node->is_ConI() ? 0 : _scale;\n+  const int C_pre =  _scale * _pre_stride;\n+  const int C_main = _scale * _main_stride;\n+\n+  DEBUG_ONLY( trace_reshaped_form(C_const, C_const_init, C_invar, C_init, C_pre, C_main); )\n+\n+  \/\/ We must find a pre_iter, such that adr is aw aligned: adr % aw = 0. Note, that we are defining the\n+  \/\/ modulo operator \"%\" such that the remainder is always positive, see AlignmentSolution::mod(i, q).\n+  \/\/\n+  \/\/ Since \"base % aw = 0\", we only need to ensure alignment of the other 5 terms:\n+  \/\/\n+  \/\/   (C_const + C_invar * var_invar + C_init * var_init + C_pre * pre_iter + C_main * main_iter) % aw = 0      (1)\n+  \/\/\n+  \/\/ Alignment must be maintained over all main-loop iterations, i.e. for any main_iter >= 0, we require:\n+  \/\/\n+  \/\/   C_main % aw = 0                                                                                           (2)\n+  \/\/\n+  const int C_main_mod_aw = AlignmentSolution::mod(C_main, _aw);\n+\n+  DEBUG_ONLY( trace_main_iteration_alignment(C_const, C_invar, C_init, C_pre, C_main, C_main_mod_aw); )\n+\n+  if (C_main_mod_aw != 0) {\n+    return new EmptyAlignmentSolution(\"EQ(2) not satisfied (cannot align across main-loop iterations)\");\n+  }\n+\n+  \/\/ In what follows, we need to show that the C_const, init and invar terms can be aligned by\n+  \/\/ adjusting the pre-loop iteration count (pre_iter), which is controlled by the pre-loop\n+  \/\/ limit.\n+  \/\/\n+  \/\/     (C_const + C_invar * var_invar + C_init * var_init + C_pre * pre_iter) % aw = 0                         (3)\n+  \/\/\n+  \/\/ We strengthen the constraints by splitting the equation into 3 equations, where we\n+  \/\/ want to find integer solutions for pre_iter_C_const, pre_iter_C_invar, and\n+  \/\/ pre_iter_C_init, which means that the C_const, init and invar terms can be aligned\n+  \/\/ independently:\n+  \/\/\n+  \/\/   (C_const             + C_pre * pre_iter_C_const) % aw = 0                 (4a)\n+  \/\/   (C_invar * var_invar + C_pre * pre_iter_C_invar) % aw = 0                 (4b)\n+  \/\/   (C_init  * var_init  + C_pre * pre_iter_C_init ) % aw = 0                 (4c)\n+  \/\/\n+  \/\/ We now prove that (4a, b, c) are sufficient as well as necessary to guarantee (3)\n+  \/\/ for any runtime value of var_invar and var_init (i.e. for any invar and init).\n+  \/\/ This tells us that the \"strengthening\" does not restrict the algorithm more than\n+  \/\/ necessary.\n+  \/\/\n+  \/\/ Sufficient (i.e (4a, b, c) imply (3)):\n+  \/\/\n+  \/\/   pre_iter = pre_iter_C_const + pre_iter_C_invar + pre_iter_C_init\n+  \/\/\n+  \/\/ Adding up (4a, b, c):\n+  \/\/\n+  \/\/   0 = (  C_const             + C_pre * pre_iter_C_const\n+  \/\/        + C_invar * var_invar + C_pre * pre_iter_C_invar\n+  \/\/        + C_init  * var_init  + C_pre * pre_iter_C_init  ) % aw\n+  \/\/\n+  \/\/     = (  C_const + C_invar * var_invar + C_init * var_init\n+  \/\/        + C_pre * (pre_iter_C_const + pre_iter_C_invar + pre_iter_C_init)) % aw\n+  \/\/\n+  \/\/     = (  C_const + C_invar * var_invar + C_init * var_init\n+  \/\/        + C_pre * pre_iter) % aw\n+  \/\/\n+  \/\/ Necessary (i.e. (3) implies (4a, b, c)):\n+  \/\/  (4a): Set var_invar = var_init = 0 at runtime. Applying this to (3), we get:\n+  \/\/\n+  \/\/        0 =\n+  \/\/          = (C_const + C_invar * var_invar + C_init * var_init + C_pre * pre_iter) % aw\n+  \/\/          = (C_const + C_invar * 0         + C_init * 0        + C_pre * pre_iter) % aw\n+  \/\/          = (C_const                                           + C_pre * pre_iter) % aw\n+  \/\/\n+  \/\/        This is of the same form as (4a), and we have a solution:\n+  \/\/        pre_iter_C_const = pre_iter\n+  \/\/\n+  \/\/  (4b): Set var_init = 0, and assume (4a), which we just proved is implied by (3).\n+  \/\/        Subtract (4a) from (3):\n+  \/\/\n+  \/\/        0 =\n+  \/\/          =  (C_const + C_invar * var_invar + C_init * var_init + C_pre * pre_iter) % aw\n+  \/\/           - (C_const + C_pre * pre_iter_C_const) % aw\n+  \/\/          =  (C_invar * var_invar + C_init * var_init + C_pre * pre_iter - C_pre * pre_iter_C_const) % aw\n+  \/\/          =  (C_invar * var_invar + C_init * 0        + C_pre * (pre_iter - pre_iter_C_const)) % aw\n+  \/\/          =  (C_invar * var_invar +                   + C_pre * (pre_iter - pre_iter_C_const)) % aw\n+  \/\/\n+  \/\/        This is of the same form as (4b), and we have a solution:\n+  \/\/        pre_iter_C_invar = pre_iter - pre_iter_C_const\n+  \/\/\n+  \/\/  (4c): Set var_invar = 0, and assume (4a), which we just proved is implied by (3).\n+  \/\/        Subtract (4a) from (3):\n+  \/\/\n+  \/\/        0 =\n+  \/\/          =  (C_const + C_invar * var_invar + C_init * var_init + C_pre * pre_iter) % aw\n+  \/\/           - (C_const + C_pre * pre_iter_C_const) % aw\n+  \/\/          =  (C_invar * var_invar + C_init * var_init + C_pre * pre_iter - C_pre * pre_iter_C_const) % aw\n+  \/\/          =  (C_invar * 0         + C_init * var_init + C_pre * (pre_iter - pre_iter_C_const)) % aw\n+  \/\/          =  (                    + C_init * var_init + C_pre * (pre_iter - pre_iter_C_const)) % aw\n+  \/\/\n+  \/\/        This is of the same form as (4c), and we have a solution:\n+  \/\/        pre_iter_C_invar = pre_iter - pre_iter_C_const\n+  \/\/\n+  \/\/ The solutions of Equations (4a, b, c) for pre_iter_C_const, pre_iter_C_invar, and pre_iter_C_init\n+  \/\/ respectively, can have one of these states:\n+  \/\/\n+  \/\/   trivial:     The solution can be any integer.\n+  \/\/   constrained: There is a (periodic) solution, but it is not trivial.\n+  \/\/   empty:       Statically we cannot guarantee a solution for all var_invar and var_init.\n+  \/\/\n+  \/\/ We look at (4a):\n+  \/\/\n+  \/\/   abs(C_pre) >= aw\n+  \/\/   -> Since abs(C_pre) is a power of two, we have C_pre % aw = 0. Therefore:\n+  \/\/\n+  \/\/        For any pre_iter_C_const: (C_pre * pre_iter_C_const) % aw = 0\n+  \/\/\n+  \/\/        (C_const + C_pre * pre_iter_C_const) % aw = 0\n+  \/\/         C_const                             % aw = 0\n+  \/\/\n+  \/\/      Hence, we can only satisfy (4a) if C_Const is aw aligned:\n+  \/\/\n+  \/\/      C_const % aw == 0:\n+  \/\/      -> (4a) has a trivial solution since we can choose any value for pre_iter_C_Const.\n+  \/\/\n+  \/\/      C_const % aw != 0:\n+  \/\/      -> (4a) has an empty solution since no pre_iter_C_Const can achieve aw alignment.\n+  \/\/\n+  \/\/   abs(C_pre) < aw:\n+  \/\/   -> Since both abs(C_pre) and aw are powers of two, we know:\n+  \/\/\n+  \/\/        There exists integer x > 1: aw = abs(C_pre) * x\n+  \/\/\n+  \/\/      C_const % abs(C_pre) == 0:\n+  \/\/      -> Exists integer z: C_const = C_pre * z\n+  \/\/\n+  \/\/          (C_const   + C_pre * pre_iter_C_const) % aw               = 0\n+  \/\/          ==>\n+  \/\/          (C_pre * z + C_pre * pre_iter_C_const) % aw               = 0\n+  \/\/          ==>\n+  \/\/          (C_pre * z + C_pre * pre_iter_C_const) % (abs(C_pre) * x) = 0\n+  \/\/          ==>\n+  \/\/          (        z +         pre_iter_C_const) %               x  = 0\n+  \/\/          ==>\n+  \/\/          for any m: pre_iter_C_const = m * x - z\n+  \/\/\n+  \/\/        Hence, pre_iter_C_const has a non-trivial (because x > 1) periodic (periodicity x)\n+  \/\/        solution, i.e it has a constrained solution.\n+  \/\/\n+  \/\/      C_const % abs(C_pre) != 0:\n+  \/\/        There exists integer x > 1: aw = abs(C_pre) * x\n+  \/\/\n+  \/\/           C_const                             %  abs(C_pre)      != 0\n+  \/\/          ==>\n+  \/\/          (C_const + C_pre * pre_iter_C_const) %  abs(C_pre)      != 0\n+  \/\/          ==>\n+  \/\/          (C_const + C_pre * pre_iter_C_const) % (abs(C_pre) * x) != 0\n+  \/\/          ==>\n+  \/\/          (C_const + C_pre * pre_iter_C_const) % aw               != 0\n+  \/\/\n+  \/\/        This is in constradiction with (4a), and therefore there cannot be any solution,\n+  \/\/        i.e. we have an empty solution.\n+  \/\/\n+  \/\/ In summary, for (4a):\n+  \/\/\n+  \/\/   abs(C_pre) >= aw  AND  C_const % aw == 0          -> trivial\n+  \/\/   abs(C_pre) >= aw  AND  C_const % aw != 0          -> empty\n+  \/\/   abs(C_pre) <  aw  AND  C_const % abs(C_pre) == 0  -> constrained\n+  \/\/   abs(C_pre) <  aw  AND  C_const % abs(C_pre) != 0  -> empty\n+  \/\/\n+  \/\/ With analogue argumentation for (4b):\n+  \/\/\n+  \/\/   abs(C_pre) >= aw  AND  C_invar % aw == 0           -> trivial\n+  \/\/   abs(C_pre) >= aw  AND  C_invar % aw != 0           -> empty\n+  \/\/   abs(C_pre) <  aw  AND  C_invar % abs(C_pre) == 0   -> constrained\n+  \/\/   abs(C_pre) <  aw  AND  C_invar % abs(C_pre) != 0   -> empty\n+  \/\/\n+  \/\/ With analogue argumentation for (4c):\n+  \/\/\n+  \/\/   abs(C_pre) >= aw  AND  C_init  % aw == 0           -> trivial\n+  \/\/   abs(C_pre) >= aw  AND  C_init  % aw != 0           -> empty\n+  \/\/   abs(C_pre) <  aw  AND  C_init  % abs(C_pre) == 0   -> constrained\n+  \/\/   abs(C_pre) <  aw  AND  C_init  % abs(C_pre) != 0   -> empty\n+  \/\/\n+  \/\/ Out of these states follows the state for the solution of pre_iter:\n+  \/\/\n+  \/\/   Trivial:     If (4a, b, c) are all trivial.\n+  \/\/   Empty:       If any of (4a, b, c) is empty, because then we cannot guarantee a solution\n+  \/\/                for pre_iter, for all possible invar and init values.\n+  \/\/   Constrained: Else. Incidentally, (4a, b, c) are all constrained themselves, as we argue below.\n+\n+  const EQ4 eq4(C_const, C_invar, C_init, C_pre, _aw);\n+  const EQ4::State eq4a_state = eq4.eq4a_state();\n+  const EQ4::State eq4b_state = eq4.eq4b_state();\n+  const EQ4::State eq4c_state = eq4.eq4c_state();\n+\n+#ifdef ASSERT\n+  if (is_trace()) {\n+    eq4.trace();\n+  }\n+#endif\n+\n+  \/\/ If (4a, b, c) are all trivial, then also the solution for pre_iter is trivial:\n+  if (eq4a_state == EQ4::State::TRIVIAL &&\n+      eq4b_state == EQ4::State::TRIVIAL &&\n+      eq4c_state == EQ4::State::TRIVIAL) {\n+    return new TrivialAlignmentSolution();\n+  }\n+\n+  \/\/ If any of (4a, b, c) is empty, then we also cannot guarantee a solution for pre_iter, for\n+  \/\/ any init and invar, hence the solution for pre_iter is empty:\n+  if (eq4a_state == EQ4::State::EMPTY ||\n+      eq4b_state == EQ4::State::EMPTY ||\n+      eq4c_state == EQ4::State::EMPTY) {\n+    return new EmptyAlignmentSolution(\"EQ(4a, b, c) not all non-empty: cannot align const, invar and init terms individually\");\n+  }\n+\n+  \/\/ If abs(C_pre) >= aw, then the solutions to (4a, b, c) are all either trivial or empty, and\n+  \/\/ hence we would have found the solution to pre_iter above as either trivial or empty. Thus\n+  \/\/ we now know that:\n+  \/\/\n+  \/\/   abs(C_pre) < aw\n+  \/\/\n+  assert(abs(C_pre) < _aw, \"implied by constrained case\");\n+\n+  \/\/ And since abs(C_pre) < aw, the solutions of (4a, b, c) can now only be constrained or empty.\n+  \/\/ But since we already handled the empty case, the solutions are now all constrained.\n+  assert(eq4a_state == EQ4::State::CONSTRAINED &&\n+         eq4a_state == EQ4::State::CONSTRAINED &&\n+         eq4a_state == EQ4::State::CONSTRAINED, \"all must be constrained now\");\n+\n+  \/\/ And since they are all constrained, we must have:\n+  \/\/\n+  \/\/   C_const % abs(C_pre) = 0                                                  (5a)\n+  \/\/   C_invar % abs(C_pre) = 0                                                  (5b)\n+  \/\/   C_init  % abs(C_pre) = 0                                                  (5c)\n+  \/\/\n+  assert(AlignmentSolution::mod(C_const, abs(C_pre)) == 0, \"EQ(5a): C_const must be alignable\");\n+  assert(AlignmentSolution::mod(C_invar, abs(C_pre)) == 0, \"EQ(5b): C_invar must be alignable\");\n+  assert(AlignmentSolution::mod(C_init,  abs(C_pre)) == 0, \"EQ(5c): C_init  must be alignable\");\n+\n+  \/\/ With (5a, b, c), we know that there are integers X, Y, Z:\n+  \/\/\n+  \/\/   C_const = X * abs(C_pre)   ==>   X = C_const \/ abs(C_pre)                 (6a)\n+  \/\/   C_invar = Y * abs(C_pre)   ==>   Y = C_invar \/ abs(C_pre)                 (6b)\n+  \/\/   C_init  = Z * abs(C_pre)   ==>   Z = C_init  \/ abs(C_pre)                 (6c)\n+  \/\/\n+  \/\/ Further, we define:\n+  \/\/\n+  \/\/   sign(C_pre) = C_pre \/ abs(C_pre) = (C_pre > 0) ? 1 : -1,                  (7)\n+  \/\/\n+  \/\/ We know that abs(C_pre) as well as aw are a powers of 2, and since (5) we can define integer q:\n+  \/\/\n+  \/\/   q = aw \/ abs(C_pre)                                                       (8)\n+  \/\/\n+  const int q = _aw \/ abs(C_pre);\n+\n+  assert(q >= 2, \"implied by constrained solution\");\n+\n+  \/\/ We now know that all terms in (4a, b, c) are divisible by abs(C_pre):\n+  \/\/\n+  \/\/   (C_const                    \/ abs(C_pre) + C_pre * pre_iter_C_const \/  abs(C_pre)) % (aw \/ abs(C_pre)) =\n+  \/\/   (X * abs(C_pre)             \/ abs(C_pre) + C_pre * pre_iter_C_const \/  abs(C_pre)) % (aw \/ abs(C_pre)) =\n+  \/\/   (X                                       +         pre_iter_C_const * sign(C_pre)) % q                 = 0  (9a)\n+  \/\/\n+  \/\/   -> pre_iter_C_const * sign(C_pre) = mx1 * q -               X\n+  \/\/   -> pre_iter_C_const               = mx2 * q - sign(C_pre) * X                                               (10a)\n+  \/\/      (for any integers mx1, mx2)\n+  \/\/\n+  \/\/   (C_invar        * var_invar \/ abs(C_pre) + C_pre * pre_iter_C_invar \/  abs(C_pre)) % (aw \/ abs(C_pre)) =\n+  \/\/   (Y * abs(C_pre) * var_invar \/ abs(C_pre) + C_pre * pre_iter_C_invar \/  abs(C_pre)) % (aw \/ abs(C_pre)) =\n+  \/\/   (Y              * var_invar              +         pre_iter_C_invar * sign(C_pre)) % q                 = 0  (9b)\n+  \/\/\n+  \/\/   -> pre_iter_C_invar * sign(C_pre) = my1 * q -               Y * var_invar\n+  \/\/   -> pre_iter_C_invar               = my2 * q - sign(C_pre) * Y * var_invar                                   (10b)\n+  \/\/      (for any integers my1, my2)\n+  \/\/\n+  \/\/   (C_init          * var_init  \/ abs(C_pre) + C_pre * pre_iter_C_init \/  abs(C_pre)) % (aw \/ abs(C_pre)) =\n+  \/\/   (Z * abs(C_pre)  * var_init  \/ abs(C_pre) + C_pre * pre_iter_C_init \/  abs(C_pre)) % (aw \/ abs(C_pre)) =\n+  \/\/   (Z * var_init                             +         pre_iter_C_init * sign(C_pre)) % q                 = 0  (9c)\n+  \/\/\n+  \/\/   -> pre_iter_C_init  * sign(C_pre) = mz1 * q -               Z * var_init\n+  \/\/   -> pre_iter_C_init                = mz2 * q - sign(C_pre) * Z * var_init                                    (10c)\n+  \/\/      (for any integers mz1, mz2)\n+  \/\/\n+  \/\/\n+  \/\/ Having solved the equations using the division, we can re-substitute X, Y, and Z, and apply (FAC_INVAR) as\n+  \/\/ well as (FAC_INIT). We use the fact that sign(x) == 1 \/ sign(x) and sign(x) * abs(x) == x:\n+  \/\/\n+  \/\/   pre_iter_C_const = mx2 * q - sign(C_pre) * X\n+  \/\/                    = mx2 * q - sign(C_pre) * C_const             \/ abs(C_pre)\n+  \/\/                    = mx2 * q - C_const \/ C_pre\n+  \/\/                    = mx2 * q - C_const \/ (scale * pre_stride)                                  (11a)\n+  \/\/\n+  \/\/ If there is an invariant:\n+  \/\/\n+  \/\/   pre_iter_C_invar = my2 * q - sign(C_pre) * Y       * var_invar\n+  \/\/                    = my2 * q - sign(C_pre) * C_invar * var_invar \/ abs(C_pre)\n+  \/\/                    = my2 * q - sign(C_pre) * invar               \/ abs(C_pre)\n+  \/\/                    = my2 * q - invar \/ C_pre\n+  \/\/                    = my2 * q - invar \/ (scale * pre_stride)                                    (11b, with invar)\n+  \/\/\n+  \/\/ If there is no invariant (i.e. C_invar = 0 ==> Y = 0):\n+  \/\/\n+  \/\/   pre_iter_C_invar = my2 * q                                                                   (11b, no invar)\n+  \/\/\n+  \/\/ If init is variable (i.e. C_init = scale, init = var_init):\n+  \/\/\n+  \/\/   pre_iter_C_init  = mz2 * q - sign(C_pre) * Z       * var_init\n+  \/\/                    = mz2 * q - sign(C_pre) * C_init  * var_init  \/ abs(C_pre)\n+  \/\/                    = mz2 * q - sign(C_pre) * scale   * init      \/ abs(C_pre)\n+  \/\/                    = mz2 * q - scale * init \/ C_pre\n+  \/\/                    = mz2 * q - scale * init \/ (scale * pre_stride)\n+  \/\/                    = mz2 * q - init \/ pre_stride                                               (11c, variable init)\n+  \/\/\n+  \/\/ If init is constant (i.e. C_init = 0 ==> Z = 0):\n+  \/\/\n+  \/\/   pre_iter_C_init  = mz2 * q                                                                   (11c, constant init)\n+  \/\/\n+  \/\/ Note, that the solutions found by (11a, b, c) are all periodic with periodicity q. We combine them,\n+  \/\/ with m = mx2 + my2 + mz2:\n+  \/\/\n+  \/\/   pre_iter =   pre_iter_C_const + pre_iter_C_invar + pre_iter_C_init\n+  \/\/            =   mx2 * q  - C_const \/ (scale * pre_stride)\n+  \/\/              + my2 * q [- invar \/ (scale * pre_stride) ]\n+  \/\/              + mz2 * q [- init \/ pre_stride            ]\n+  \/\/\n+  \/\/            =   m * q                                 (periodic part)\n+  \/\/              - C_const \/ (scale * pre_stride)        (align constant term)\n+  \/\/             [- invar \/ (scale * pre_stride)   ]      (align invariant term, if present)\n+  \/\/             [- init \/ pre_stride              ]      (align variable init term, if present)    (12)\n+  \/\/\n+  \/\/ We can further simplify this solution by introducing integer 0 <= r < q:\n+  \/\/\n+  \/\/   r = (-C_const \/ (scale * pre_stride)) % q                                                    (13)\n+  \/\/\n+  const int r = AlignmentSolution::mod(-C_const \/ (_scale * _pre_stride), q);\n+  \/\/\n+  \/\/   pre_iter = m * q + r\n+  \/\/                   [- invar \/ (scale * pre_stride)  ]\n+  \/\/                   [- init \/ pre_stride             ]                                           (14)\n+  \/\/\n+  \/\/ We thus get a solution that can be stated in terms of:\n+  \/\/\n+  \/\/   q (periodicity), r (constant alignment), invar, scale, pre_stride, init\n+  \/\/\n+  \/\/ However, pre_stride and init are shared by all mem_ref in the loop, hence we do not need to provide\n+  \/\/ them in the solution description.\n+\n+  DEBUG_ONLY( trace_constrained_solution(C_const, C_invar, C_init, C_pre, q, r); )\n+\n+  return new ConstrainedAlignmentSolution(_mem_ref, q, r, _invar, _scale);\n+\n+  \/\/ APPENDIX:\n+  \/\/ We can now verify the success of the solution given by (12):\n+  \/\/\n+  \/\/   adr % aw =\n+  \/\/\n+  \/\/   -> Simple form\n+  \/\/   (base + offset + invar + scale * iv) % aw =\n+  \/\/\n+  \/\/   -> Expand iv\n+  \/\/   (base + offset + invar + scale * (init + pre_stride * pre_iter + main_stride * main_iter)) % aw =\n+  \/\/\n+  \/\/   -> Reshape\n+  \/\/   (base + offset + invar\n+  \/\/         + scale * init\n+  \/\/         + scale * pre_stride * pre_iter\n+  \/\/         + scale * main_stride * main_iter)) % aw =\n+  \/\/\n+  \/\/   -> base aligned: base % aw = 0\n+  \/\/   -> main-loop iterations aligned (2): C_main % aw = (scale * main_stride) % aw = 0\n+  \/\/   (offset + invar + scale * init + scale * pre_stride * pre_iter) % aw =\n+  \/\/\n+  \/\/   -> apply (12)\n+  \/\/   (offset + invar + scale * init\n+  \/\/           + scale * pre_stride * (m * q - C_const \/ (scale * pre_stride)\n+  \/\/                                        [- invar \/ (scale * pre_stride) ]\n+  \/\/                                        [- init \/ pre_stride            ]\n+  \/\/                                  )\n+  \/\/   ) % aw =\n+  \/\/\n+  \/\/   -> expand C_const = offset [+ init * scale]  (if init const)\n+  \/\/   (offset + invar + scale * init\n+  \/\/           + scale * pre_stride * (m * q - offset \/ (scale * pre_stride)\n+  \/\/                                        [- init \/ pre_stride            ]             (if init constant)\n+  \/\/                                        [- invar \/ (scale * pre_stride) ]             (if invar present)\n+  \/\/                                        [- init \/ pre_stride            ]             (if init variable)\n+  \/\/                                  )\n+  \/\/   ) % aw =\n+  \/\/\n+  \/\/   -> assuming invar = 0 if it is not present\n+  \/\/   -> merge the two init terms (variable or constant)\n+  \/\/   -> apply (8): q = aw \/ (abs(C_pre)) = aw \/ abs(scale * pre_stride)\n+  \/\/   -> and hence: (scale * pre_stride * q) % aw = 0\n+  \/\/   -> all terms are canceled out\n+  \/\/   (offset + invar + scale * init\n+  \/\/           + scale * pre_stride * m * q                             -> aw aligned\n+  \/\/           - scale * pre_stride * offset \/ (scale * pre_stride)     -> = offset\n+  \/\/           - scale * pre_stride * init \/ pre_stride                 -> = scale * init\n+  \/\/           - scale * pre_stride * invar \/ (scale * pre_stride)      -> = invar\n+  \/\/   ) % aw = 0\n+  \/\/\n+  \/\/ The solution given by (12) does indeed guarantee alignment.\n+}\n@@ -689,0 +1193,163 @@\n+#ifdef ASSERT\n+void print_con_or_idx(const Node* n) {\n+  if (n == nullptr) {\n+    tty->print(\"(0)\");\n+  } else if (n->is_ConI()) {\n+    jint val = n->as_ConI()->get_int();\n+    tty->print(\"(%d)\", val);\n+  } else {\n+    tty->print(\"[%d]\", n->_idx);\n+  }\n+}\n+\n+void AlignmentSolver::trace_start_solve() const {\n+  if (is_trace()) {\n+    tty->print(\" vector mem_ref:\");\n+    _mem_ref->dump();\n+    tty->print_cr(\"  vector_width = vector_length(%d) * element_size(%d) = %d\",\n+                  _vector_length, _element_size, _vector_width);\n+    tty->print_cr(\"  aw = alignment_width = min(vector_width(%d), ObjectAlignmentInBytes(%d)) = %d\",\n+                  _vector_width, ObjectAlignmentInBytes, _aw);\n+\n+    if (!_init_node->is_ConI()) {\n+      tty->print(\"  init:\");\n+      _init_node->dump();\n+    }\n+\n+    if (_invar != nullptr) {\n+      tty->print(\"  invar:\");\n+      _invar->dump();\n+    }\n+\n+    tty->print_cr(\"  invar_factor = %d\", _invar_factor);\n+\n+    \/\/ iv = init + pre_iter * pre_stride + main_iter * main_stride\n+    tty->print(\"  iv = init\");\n+    print_con_or_idx(_init_node);\n+    tty->print_cr(\" + pre_iter * pre_stride(%d) + main_iter * main_stride(%d)\",\n+                  _pre_stride, _main_stride);\n+\n+    \/\/ adr = base + offset + invar + scale * iv\n+    tty->print(\"  adr = base\");\n+    print_con_or_idx(_base);\n+    tty->print(\" + offset(%d) + invar\", _offset);\n+    print_con_or_idx(_invar);\n+    tty->print_cr(\" + scale(%d) * iv\", _scale);\n+  }\n+}\n+\n+void AlignmentSolver::trace_reshaped_form(const int C_const,\n+                                          const int C_const_init,\n+                                          const int C_invar,\n+                                          const int C_init,\n+                                          const int C_pre,\n+                                          const int C_main) const\n+{\n+  if (is_trace()) {\n+    tty->print(\"      = base[%d] + \", _base->_idx);\n+    tty->print_cr(\"C_const(%d) + C_invar(%d) * var_invar + C_init(%d) * var_init + C_pre(%d) * pre_iter + C_main(%d) * main_iter\",\n+                  C_const, C_invar, C_init,  C_pre, C_main);\n+    if (_init_node->is_ConI()) {\n+      tty->print_cr(\"  init is constant:\");\n+      tty->print_cr(\"    C_const_init = %d\", C_const_init);\n+      tty->print_cr(\"    C_init = %d\", C_init);\n+    } else {\n+      tty->print_cr(\"  init is variable:\");\n+      tty->print_cr(\"    C_const_init = %d\", C_const_init);\n+      tty->print_cr(\"    C_init = abs(scale)= %d\", C_init);\n+    }\n+    if (_invar != nullptr) {\n+      tty->print_cr(\"  invariant present:\");\n+      tty->print_cr(\"    C_invar = abs(invar_factor) = %d\", C_invar);\n+    } else {\n+      tty->print_cr(\"  no invariant:\");\n+      tty->print_cr(\"    C_invar = %d\", C_invar);\n+    }\n+    tty->print_cr(\"  C_const = offset(%d) + scale(%d) * C_const_init(%d) = %d\",\n+                  _offset, _scale, C_const_init, C_const);\n+    tty->print_cr(\"  C_pre   = scale(%d) * pre_stride(%d) = %d\",\n+                  _scale, _pre_stride, C_pre);\n+    tty->print_cr(\"  C_main  = scale(%d) * main_stride(%d) = %d\",\n+                  _scale, _main_stride, C_main);\n+  }\n+}\n+\n+void AlignmentSolver::trace_main_iteration_alignment(const int C_const,\n+                                                     const int C_invar,\n+                                                     const int C_init,\n+                                                     const int C_pre,\n+                                                     const int C_main,\n+                                                     const int C_main_mod_aw) const\n+{\n+  if (is_trace()) {\n+    tty->print(\"  EQ(1 ): (C_const(%d) + C_invar(%d) * var_invar + C_init(%d) * var_init\",\n+                  C_const, C_invar, C_init);\n+    tty->print(\" + C_pre(%d) * pre_iter + C_main(%d) * main_iter) %% aw(%d) = 0\",\n+                  C_pre, C_main, _aw);\n+    tty->print_cr(\" (given base aligned -> align rest)\");\n+    tty->print(\"  EQ(2 ): C_main(%d) %% aw(%d) = %d = 0\",\n+               C_main, _aw, C_main_mod_aw);\n+    tty->print_cr(\" (alignment across iterations)\");\n+  }\n+}\n+\n+void AlignmentSolver::EQ4::trace() const {\n+  tty->print_cr(\"  EQ(4a): (C_const(%3d)             + C_pre(%d) * pre_iter_C_const) %% aw(%d) = 0  (align const term individually)\",\n+                _C_const, _C_pre, _aw);\n+  tty->print_cr(\"          -> %s\", state_to_str(eq4a_state()));\n+\n+  tty->print_cr(\"  EQ(4b): (C_invar(%3d) * var_invar + C_pre(%d) * pre_iter_C_invar) %% aw(%d) = 0  (align invar term individually)\",\n+                _C_invar, _C_pre, _aw);\n+  tty->print_cr(\"          -> %s\", state_to_str(eq4b_state()));\n+\n+  tty->print_cr(\"  EQ(4c): (C_init( %3d) * var_init  + C_pre(%d) * pre_iter_C_init ) %% aw(%d) = 0  (align init term individually)\",\n+                _C_init, _C_pre, _aw);\n+  tty->print_cr(\"          -> %s\", state_to_str(eq4c_state()));\n+}\n+\n+void AlignmentSolver::trace_constrained_solution(const int C_const,\n+                                                 const int C_invar,\n+                                                 const int C_init,\n+                                                 const int C_pre,\n+                                                 const int q,\n+                                                 const int r) const\n+{\n+  if (is_trace()) {\n+    tty->print_cr(\"  EQ(4a, b, c) all constrained, hence:\");\n+    tty->print_cr(\"  EQ(5a): C_const(%3d) %% abs(C_pre(%d)) = 0\", C_const, C_pre);\n+    tty->print_cr(\"  EQ(5b): C_invar(%3d) %% abs(C_pre(%d)) = 0\", C_invar, C_pre);\n+    tty->print_cr(\"  EQ(5c): C_init( %3d) %% abs(C_pre(%d)) = 0\", C_init,  C_pre);\n+\n+    tty->print_cr(\"  All terms in EQ(4a, b, c) are divisible by abs(C_pre(%d)).\", C_pre);\n+    const int X    = C_const \/ abs(C_pre);\n+    const int Y    = C_invar \/ abs(C_pre);\n+    const int Z    = C_init  \/ abs(C_pre);\n+    const int sign = (C_pre > 0) ? 1 : -1;\n+    tty->print_cr(\"  X = C_const(%3d) \/ abs(C_pre(%d)) = %d       (6a)\", C_const, C_pre, X);\n+    tty->print_cr(\"  Y = C_invar(%3d) \/ abs(C_pre(%d)) = %d       (6b)\", C_invar, C_pre, Y);\n+    tty->print_cr(\"  Z = C_init( %3d) \/ abs(C_pre(%d)) = %d       (6c)\", C_init , C_pre, Z);\n+    tty->print_cr(\"  q = aw(     %3d) \/ abs(C_pre(%d)) = %d       (8)\",  _aw,     C_pre, q);\n+    tty->print_cr(\"  sign(C_pre) = (C_pre(%d) > 0) ? 1 : -1 = %d  (7)\",  C_pre,   sign);\n+\n+    tty->print_cr(\"  EQ(9a): (X(%3d)             + pre_iter_C_const * sign(C_pre)) %% q(%d) = 0\", X, q);\n+    tty->print_cr(\"  EQ(9b): (Y(%3d) * var_invar + pre_iter_C_invar * sign(C_pre)) %% q(%d) = 0\", Y, q);\n+    tty->print_cr(\"  EQ(9c): (Z(%3d) * var_init  + pre_iter_C_init  * sign(C_pre)) %% q(%d) = 0\", Z, q);\n+\n+    tty->print_cr(\"  EQ(10a): pre_iter_C_const = mx2 * q(%d) - sign(C_pre) * X(%d)\",             q, X);\n+    tty->print_cr(\"  EQ(10b): pre_iter_C_invar = my2 * q(%d) - sign(C_pre) * Y(%d) * var_invar\", q, Y);\n+    tty->print_cr(\"  EQ(10c): pre_iter_C_init  = mz2 * q(%d) - sign(C_pre) * Z(%d) * var_init \", q, Z);\n+\n+    tty->print_cr(\"  r = (-C_const(%d) \/ (scale(%d) * pre_stride(%d)) %% q(%d) = %d\",\n+                  C_const, _scale, _pre_stride, q, r);\n+\n+    tty->print_cr(\"  EQ(14):  pre_iter = m * q(%3d) - r(%d)\", q, r);\n+    if (_invar != nullptr) {\n+      tty->print_cr(\"                                 - invar \/ (scale(%d) * pre_stride(%d))\",\n+                    _scale, _pre_stride);\n+    }\n+    if (!_init_node->is_ConI()) {\n+      tty->print_cr(\"                                 - init \/ pre_stride(%d)\",\n+                    _pre_stride);\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":670,"deletions":3,"binary":false,"changes":673,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-  MemNode*        _mem;      \/\/ My memory reference node\n+  const MemNode*  _mem;      \/\/ My memory reference node\n@@ -83,2 +83,3 @@\n-  VPointer(MemNode* mem, PhaseIdealLoop* phase, IdealLoopTree* lpt,\n-            Node_Stack* nstack, bool analyze_only);\n+  VPointer(const MemNode* mem,\n+           PhaseIdealLoop* phase, IdealLoopTree* lpt,\n+           Node_Stack* nstack, bool analyze_only);\n@@ -89,2 +90,2 @@\n-  bool valid()  { return _adr != nullptr; }\n-  bool has_iv() { return _scale != 0; }\n+  bool valid()             const { return _adr != nullptr; }\n+  bool has_iv()            const { return _scale != 0; }\n@@ -92,8 +93,11 @@\n-  Node* base()             { return _base; }\n-  Node* adr()              { return _adr; }\n-  MemNode* mem()           { return _mem; }\n-  int   scale_in_bytes()   { return _scale; }\n-  Node* invar()            { return _invar; }\n-  int   offset_in_bytes()  { return _offset; }\n-  int   memory_size()      { return _mem->memory_size(); }\n-  Node_Stack* node_stack() { return _nstack; }\n+  Node* base()             const { return _base; }\n+  Node* adr()              const { return _adr; }\n+  const MemNode* mem()     const { return _mem; }\n+  int   scale_in_bytes()   const { return _scale; }\n+  Node* invar()            const { return _invar; }\n+  int   offset_in_bytes()  const { return _offset; }\n+  int   memory_size()      const { return _mem->memory_size(); }\n+  Node_Stack* node_stack() const { return _nstack; }\n+\n+  \/\/ Biggest detectable factor of the invariant.\n+  int   invar_factor() const;\n@@ -168,1 +172,1 @@\n-    void ctor_1(Node* mem);\n+    void ctor_1(const Node* mem);\n@@ -173,1 +177,1 @@\n-    void ctor_6(Node* mem);\n+    void ctor_6(const Node* mem);\n@@ -262,0 +266,415 @@\n+\/\/ When alignment is required, we must adjust the pre-loop iteration count pre_iter,\n+\/\/ such that the address is aligned for any main_iter >= 0:\n+\/\/\n+\/\/   adr = base + offset + invar + scale * init\n+\/\/                               + scale * pre_stride * pre_iter\n+\/\/                               + scale * main_stride * main_iter\n+\/\/\n+\/\/ The AlignmentSolver generates solutions of the following forms:\n+\/\/   1. Empty:       No pre_iter guarantees alignment.\n+\/\/   2. Trivial:     Any pre_iter guarantees alignment.\n+\/\/   3. Constrained: There is a periodic solution, but it is not trivial.\n+\/\/\n+\/\/ The Constrained solution is of the following form:\n+\/\/\n+\/\/   pre_iter = m * q + r                                    (for any integer m)\n+\/\/                   [- invar \/ (scale * pre_stride)  ]      (if there is an invariant)\n+\/\/                   [- init \/ pre_stride             ]      (if init is variable)\n+\/\/\n+\/\/ The solution is periodic with periodicity q, which is guaranteed to be a power of 2.\n+\/\/ This periodic solution is \"rotated\" by three alignment terms: one for constants (r),\n+\/\/ one for the invariant (if present), and one for init (if it is variable).\n+\/\/\n+\/\/ The \"filter\" method combines the solutions of two mem_refs, such that the new set of\n+\/\/ values for pre_iter guarantees alignment for both mem_refs.\n+\/\/\n+class EmptyAlignmentSolution;\n+class TrivialAlignmentSolution;\n+class ConstrainedAlignmentSolution;\n+\n+class AlignmentSolution : public ResourceObj {\n+public:\n+  virtual bool is_empty() const = 0;\n+  virtual bool is_trivial() const = 0;\n+  virtual bool is_constrained() const = 0;\n+\n+  virtual const ConstrainedAlignmentSolution* as_constrained() const {\n+    assert(is_constrained(), \"must be constrained\");\n+    return nullptr;\n+  }\n+\n+  \/\/ Implemented by each subclass\n+  virtual const AlignmentSolution* filter(const AlignmentSolution* other) const = 0;\n+  virtual void print() const = 0;\n+\n+  \/\/ Compute modulo and ensure that we get a positive remainder\n+  static int mod(int i, int q) {\n+    assert(q >= 1, \"modulo value must be large enough\");\n+\n+    \/\/ Modulo operator: Get positive 0 <= r < q  for positive i, but\n+    \/\/                  get negative 0 >= r > -q for negative i.\n+    int r = i % q;\n+\n+    \/\/ Make negative r into positive ones:\n+    r = (r >= 0) ? r : r + q;\n+\n+    assert(0 <= r && r < q, \"remainder must fit in modulo space\");\n+    return r;\n+  }\n+};\n+\n+class EmptyAlignmentSolution : public AlignmentSolution {\n+private:\n+  const char* _reason;\n+public:\n+  EmptyAlignmentSolution(const char* reason) :  _reason(reason) {}\n+  virtual bool is_empty() const override final       { return true; }\n+  virtual bool is_trivial() const override final     { return false; }\n+  virtual bool is_constrained() const override final { return false; }\n+  const char* reason() const { return _reason; }\n+\n+  virtual const AlignmentSolution* filter(const AlignmentSolution* other) const override final {\n+    \/\/ If \"this\" cannot be guaranteed to be aligned, then we also cannot guarantee to align\n+    \/\/ \"this\" and \"other\" together.\n+    return new EmptyAlignmentSolution(\"empty solution input to filter\");\n+  }\n+\n+  virtual void print() const override final {\n+    tty->print_cr(\"empty solution: %s\", reason());\n+  };\n+};\n+\n+class TrivialAlignmentSolution : public AlignmentSolution {\n+public:\n+  TrivialAlignmentSolution() {}\n+  virtual bool is_empty() const override final       { return false; }\n+  virtual bool is_trivial() const override final     { return true; }\n+  virtual bool is_constrained() const override final { return false; }\n+\n+  virtual const AlignmentSolution* filter(const AlignmentSolution* other) const override final {\n+    if (other->is_empty()) {\n+      \/\/ If \"other\" cannot be guaranteed to be aligned, then we also cannot guarantee to align\n+      \/\/ \"this\" and \"other\".\n+      return new EmptyAlignmentSolution(\"empty solution input to filter\");\n+    }\n+    \/\/ Since \"this\" is trivial (no constraints), the solution of \"other\" guarantees alignment\n+    \/\/ of both.\n+    return other;\n+  }\n+\n+  virtual void print() const override final {\n+    tty->print_cr(\"pre_iter >= 0 (trivial)\");\n+  };\n+};\n+\n+class ConstrainedAlignmentSolution : public AlignmentSolution {\n+private:\n+  const MemNode* _mem_ref;\n+  const int _q;\n+  const int _r;\n+  const Node* _invar;\n+  const int _scale;\n+public:\n+  ConstrainedAlignmentSolution(const MemNode* mem_ref,\n+                               const int q,\n+                               const int r,\n+                               const Node* invar,\n+                               int scale) :\n+      _mem_ref(mem_ref),\n+      _q(q),\n+      _r(r),\n+      _invar(invar),\n+      _scale(scale) {\n+    assert(q > 1 && is_power_of_2(q), \"q must be power of 2\");\n+    assert(0 <= r && r < q, \"r must be in modulo space of q\");\n+    assert(_mem_ref != nullptr, \"must have mem_ref\");\n+  }\n+\n+  virtual bool is_empty() const override final       { return false; }\n+  virtual bool is_trivial() const override final     { return false; }\n+  virtual bool is_constrained() const override final { return true; }\n+\n+  const MemNode* mem_ref() const        { return _mem_ref; }\n+\n+  virtual const ConstrainedAlignmentSolution* as_constrained() const override final { return this; }\n+\n+  virtual const AlignmentSolution* filter(const AlignmentSolution* other) const override final {\n+    if (other->is_empty()) {\n+      \/\/ If \"other\" cannot be guaranteed to be aligned, then we also cannot guarantee to align\n+      \/\/ \"this\" and \"other\" together.\n+      return new EmptyAlignmentSolution(\"empty solution input to filter\");\n+    }\n+    \/\/ Since \"other\" is trivial (no constraints), the solution of \"this\" guarantees alignment\n+    \/\/ of both.\n+    if (other->is_trivial()) {\n+      return this;\n+    }\n+\n+    \/\/ Both solutions are constrained:\n+    ConstrainedAlignmentSolution const* s1 = this;\n+    ConstrainedAlignmentSolution const* s2 = other->as_constrained();\n+\n+    \/\/ Thus, pre_iter is the intersection of two sets, i.e. constrained by these two equations,\n+    \/\/ for any integers m1 and m2:\n+    \/\/\n+    \/\/   pre_iter = m1 * q1 + r1\n+    \/\/                     [- invar1 \/ (scale1 * pre_stride)  ]\n+    \/\/                     [- init \/ pre_stride               ]\n+    \/\/\n+    \/\/   pre_iter = m2 * q2 + r2\n+    \/\/                     [- invar2 \/ (scale2 * pre_stride)  ]\n+    \/\/                     [- init \/ pre_stride               ]\n+    \/\/\n+    \/\/ Note: pre_stride and init are identical for all mem_refs in the loop.\n+    \/\/\n+    \/\/ The init alignment term either does not exist for both mem_refs, or exists identically\n+    \/\/ for both. The init alignment term is thus trivially identical.\n+    \/\/\n+    \/\/ The invar alignment term is identical if either:\n+    \/\/   - both mem_refs have no invariant.\n+    \/\/   - both mem_refs have the same invariant and the same scale.\n+    \/\/\n+    if (s1->_invar != s2->_invar) {\n+      return new EmptyAlignmentSolution(\"invar not identical\");\n+    }\n+    if (s1->_invar != nullptr && s1->_scale != s2->_scale) {\n+      return new EmptyAlignmentSolution(\"has invar with different scale\");\n+    }\n+\n+    \/\/ Now, we have reduced the problem to:\n+    \/\/\n+    \/\/   pre_iter = m1 * q1 + r1 [- x]       (S1)\n+    \/\/   pre_iter = m2 * q2 + r2 [- x]       (S2)\n+    \/\/\n+\n+    \/\/ Make s2 the bigger modulo space, i.e. has larger periodicity q.\n+    \/\/ This guarantees that S2 is either identical to, a subset of,\n+    \/\/ or disjunct from S1 (but cannot be a strict superset of S1).\n+    if (s1->_q > s2->_q) {\n+      swap(s1, s2);\n+    }\n+    assert(s1->_q <= s2->_q, \"s1 is a smaller modulo space than s2\");\n+\n+    \/\/ Is S2 subset of (or equal to) S1?\n+    \/\/\n+    \/\/ for any m2, there are integers a, b, m1: m2 * q2     + r2          =\n+    \/\/                                          m2 * a * q1 + b * q1 + r1 =\n+    \/\/                                          (m2 * a + b) * q1 + r1\n+    \/\/\n+    \/\/ Since q1 and q2 are both powers of 2, and q1 <= q2, we know there\n+    \/\/ is an integer a: a * q1 = q2. Thus, it remains to check if there\n+    \/\/ is an integer b: b * q1 + r1 = r2. This is equivalent to checking:\n+    \/\/\n+    \/\/   r1 = r1 % q1 = r2 % q1\n+    \/\/\n+    if (mod(s2->_r, s1->_q) != s1->_r) {\n+      \/\/ Neither is subset of the other -> no intersection\n+      return new EmptyAlignmentSolution(\"empty intersection (r and q)\");\n+    }\n+\n+    \/\/ Now we know: \"s1 = m1 * q1 + r1\" is a superset of \"s2 = m2 * q2 + r2\"\n+    \/\/ Hence, any solution of S2 guarantees alignment for both mem_refs.\n+    return s2; \/\/ return the subset\n+  }\n+\n+  virtual void print() const override final {\n+    tty->print(\"m * q(%d) + r(%d)\", _q, _r);\n+    if (_invar != nullptr) {\n+      tty->print(\" - invar[%d] \/ (scale(%d) * pre_stride)\", _invar->_idx, _scale);\n+    }\n+    tty->print_cr(\" [- init \/ pre_stride], mem_ref[%d]\", mem_ref()->_idx);\n+  };\n+};\n+\n+\/\/ When strict alignment is required (e.g. -XX:+AlignVector), then we must ensure\n+\/\/ that all vector memory accesses can be aligned. We achieve this alignment by\n+\/\/ adjusting the pre-loop limit, which adjusts the number of iterations executed\n+\/\/ in the pre-loop.\n+\/\/\n+\/\/ This is how the pre-loop and unrolled main-loop look like for a memref (adr):\n+\/\/\n+\/\/ iv = init\n+\/\/ i = 0 \/\/ single-iteration counter\n+\/\/\n+\/\/ pre-loop:\n+\/\/   iv = init + i * pre_stride\n+\/\/   adr = base + offset + invar + scale * iv\n+\/\/   adr = base + offset + invar + scale * (init + i * pre_stride)\n+\/\/   iv += pre_stride\n+\/\/   i++\n+\/\/\n+\/\/ pre_iter = i \/\/ number of iterations in the pre-loop\n+\/\/ iv = init + pre_iter * pre_stride\n+\/\/\n+\/\/ main_iter = 0 \/\/ main-loop iteration counter\n+\/\/ main_stride = unroll_factor * pre_stride\n+\/\/\n+\/\/ main-loop:\n+\/\/   i = pre_iter + main_iter * unroll_factor\n+\/\/   iv = init + i * pre_stride = init + pre_iter * pre_stride + main_iter * unroll_factor * pre_stride\n+\/\/                              = init + pre_iter * pre_stride + main_iter * main_stride\n+\/\/   adr = base + offset + invar + scale * iv \/\/ must be aligned\n+\/\/   iv += main_stride\n+\/\/   i  += unroll_factor\n+\/\/   main_iter++\n+\/\/\n+\/\/ For each vector memory access, we can find the set of pre_iter (number of pre-loop\n+\/\/ iterations) which would align its address. The AlignmentSolver finds such an\n+\/\/ AlignmentSolution. We can then check which solutions are compatible, and thus\n+\/\/ decide if we have to (partially) reject vectorization if not all vectors have\n+\/\/ a compatible solutions.\n+class AlignmentSolver {\n+private:\n+  const MemNode* _mem_ref;       \/\/ first element\n+  const uint     _vector_length; \/\/ number of elements in vector\n+  const int      _element_size;\n+  const int      _vector_width;  \/\/ in bytes\n+\n+  \/\/ All vector loads and stores need to be memory aligned. The alignment width (aw) in\n+  \/\/ principle is the vector_width. But when vector_width > ObjectAlignmentInBytes this is\n+  \/\/ too strict, since any memory object is only guaranteed to be ObjectAlignmentInBytes\n+  \/\/ aligned. For example, the relative offset between two arrays is only guaranteed to\n+  \/\/ be divisible by ObjectAlignmentInBytes.\n+  const int      _aw;\n+\n+  \/\/ We analyze the address of mem_ref. The idea is to disassemble it into a linear\n+  \/\/ expression, where we can use the constant factors as the basis for ensuring the\n+  \/\/ alignment of vector memory accesses.\n+  \/\/\n+  \/\/ The Simple form of the address is disassembled by VPointer into:\n+  \/\/\n+  \/\/   adr = base + offset + invar + scale * iv\n+  \/\/\n+  \/\/ Where the iv can be written as:\n+  \/\/\n+  \/\/   iv = init + pre_stride * pre_iter + main_stride * main_iter\n+  \/\/\n+  \/\/ pre_iter:    number of pre-loop iterations (adjustable via pre-loop limit)\n+  \/\/ main_iter:   number of main-loop iterations (main_iter >= 0)\n+  \/\/\n+  const Node*    _base;           \/\/ base of address (e.g. Java array object, aw-aligned)\n+  const int      _offset;\n+  const Node*    _invar;\n+  const int      _invar_factor;   \/\/ known constant factor of invar\n+  const int      _scale;\n+  const Node*    _init_node;      \/\/ value of iv before pre-loop\n+  const int      _pre_stride;     \/\/ address increment per pre-loop iteration\n+  const int      _main_stride;    \/\/ address increment per main-loop iteration\n+\n+  DEBUG_ONLY( const bool _is_trace; );\n+\n+  static const MemNode* mem_ref_not_null(const MemNode* mem_ref) {\n+    assert(mem_ref != nullptr, \"not nullptr\");\n+    return mem_ref;\n+  }\n+\n+public:\n+  AlignmentSolver(const MemNode* mem_ref,\n+                  const uint vector_length,\n+                  const Node* base,\n+                  const int offset,\n+                  const Node* invar,\n+                  const int invar_factor,\n+                  const int scale,\n+                  const Node* init_node,\n+                  const int pre_stride,\n+                  const int main_stride\n+                  DEBUG_ONLY( COMMA const bool is_trace)\n+                  ) :\n+      _mem_ref(           mem_ref_not_null(mem_ref)),\n+      _vector_length(     vector_length),\n+      _element_size(      _mem_ref->memory_size()),\n+      _vector_width(      _vector_length * _element_size),\n+      _aw(                MIN2(_vector_width, ObjectAlignmentInBytes)),\n+      _base(              base),\n+      _offset(            offset),\n+      _invar(             invar),\n+      _invar_factor(      invar_factor),\n+      _scale(             scale),\n+      _init_node(         init_node),\n+      _pre_stride(        pre_stride),\n+      _main_stride(       main_stride)\n+      DEBUG_ONLY( COMMA _is_trace(is_trace) )\n+  {\n+    assert(_mem_ref != nullptr &&\n+           (_mem_ref->is_Load() || _mem_ref->is_Store()),\n+           \"only load or store vectors allowed\");\n+  }\n+\n+  AlignmentSolution* solve() const;\n+\n+private:\n+  class EQ4 {\n+   private:\n+    const int _C_const;\n+    const int _C_invar;\n+    const int _C_init;\n+    const int _C_pre;\n+    const int _aw;\n+\n+   public:\n+    EQ4(const int C_const, const int C_invar, const int C_init, const int C_pre, const int aw) :\n+    _C_const(C_const), _C_invar(C_invar), _C_init(C_init), _C_pre(C_pre), _aw(aw) {}\n+\n+    enum State { TRIVIAL, CONSTRAINED, EMPTY };\n+\n+    State eq4a_state() const {\n+      return (abs(_C_pre) >= _aw) ? ( (C_const_mod_aw() == 0       ) ? TRIVIAL     : EMPTY)\n+                                  : ( (C_const_mod_abs_C_pre() == 0) ? CONSTRAINED : EMPTY);\n+    }\n+\n+    State eq4b_state() const {\n+      return (abs(_C_pre) >= _aw) ? ( (C_invar_mod_aw() == 0       ) ? TRIVIAL     : EMPTY)\n+                                  : ( (C_invar_mod_abs_C_pre() == 0) ? CONSTRAINED : EMPTY);\n+    }\n+\n+    State eq4c_state() const {\n+      return (abs(_C_pre) >= _aw) ? ( (C_init_mod_aw() == 0       )  ? TRIVIAL     : EMPTY)\n+                                  : ( (C_init_mod_abs_C_pre() == 0)  ? CONSTRAINED : EMPTY);\n+    }\n+\n+   private:\n+    int C_const_mod_aw() const        { return AlignmentSolution::mod(_C_const, _aw); }\n+    int C_invar_mod_aw() const        { return AlignmentSolution::mod(_C_invar, _aw); }\n+    int C_init_mod_aw() const         { return AlignmentSolution::mod(_C_init,  _aw); }\n+    int C_const_mod_abs_C_pre() const { return AlignmentSolution::mod(_C_const, abs(_C_pre)); }\n+    int C_invar_mod_abs_C_pre() const { return AlignmentSolution::mod(_C_invar, abs(_C_pre)); }\n+    int C_init_mod_abs_C_pre() const  { return AlignmentSolution::mod(_C_init,  abs(_C_pre)); }\n+\n+#ifdef ASSERT\n+   public:\n+    void trace() const;\n+\n+   private:\n+    static const char* state_to_str(State s) {\n+      if (s == TRIVIAL)     { return \"trivial\"; }\n+      if (s == CONSTRAINED) { return \"constrained\"; }\n+      return \"empty\";\n+    }\n+#endif\n+  };\n+\n+#ifdef ASSERT\n+  bool is_trace() const { return _is_trace; }\n+  void trace_start_solve() const;\n+  void trace_reshaped_form(const int C_const,\n+                           const int C_const_init,\n+                           const int C_invar,\n+                           const int C_init,\n+                           const int C_pre,\n+                           const int C_main) const;\n+  void trace_main_iteration_alignment(const int C_const,\n+                                      const int C_invar,\n+                                      const int C_init,\n+                                      const int C_pre,\n+                                      const int C_main,\n+                                      const int C_main_mod_aw) const;\n+  void trace_constrained_solution(const int C_const,\n+                                  const int C_invar,\n+                                  const int C_init,\n+                                  const int C_pre,\n+                                  const int q,\n+                                  const int r) const;\n+#endif\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":434,"deletions":15,"binary":false,"changes":449,"status":"modified"},{"patch":"@@ -850,0 +850,2 @@\n+ private:\n+  DEBUG_ONLY( bool _must_verify_alignment = false; );\n@@ -874,0 +876,11 @@\n+\n+  \/\/ Needed for proper cloning.\n+  virtual uint size_of() const { return sizeof(*this); }\n+\n+#ifdef ASSERT\n+  \/\/ When AlignVector is enabled, SuperWord only creates aligned vector loads and stores.\n+  \/\/ VerifyAlignVector verifies this. We need to mark the nodes created in SuperWord,\n+  \/\/ because nodes created elsewhere (i.e. VectorAPI) may still be misaligned.\n+  bool must_verify_alignment() const { return _must_verify_alignment; }\n+  void set_must_verify_alignment() { _must_verify_alignment = true; }\n+#endif\n@@ -897,0 +910,1 @@\n+  DEBUG_ONLY( bool _must_verify_alignment = false; );\n@@ -921,0 +935,8 @@\n+\n+#ifdef ASSERT\n+  \/\/ When AlignVector is enabled, SuperWord only creates aligned vector loads and stores.\n+  \/\/ VerifyAlignVector verifies this. We need to mark the nodes created in SuperWord,\n+  \/\/ because nodes created elsewhere (i.e. VectorAPI) may still be misaligned.\n+  bool must_verify_alignment() const { return _must_verify_alignment; }\n+  void set_must_verify_alignment() { _must_verify_alignment = true; }\n+#endif\n@@ -1020,0 +1042,19 @@\n+\/\/ Verify that memory address (adr) is aligned. The mask specifies the\n+\/\/ least significant bits which have to be zero in the address.\n+\/\/\n+\/\/ if (adr & mask == 0) {\n+\/\/   return adr\n+\/\/ } else {\n+\/\/   stop(\"verify_vector_alignment found a misaligned vector memory access\")\n+\/\/ }\n+\/\/\n+\/\/ This node is used just before a vector load\/store with -XX:+VerifyAlignVector\n+class VerifyVectorAlignmentNode : public Node {\n+  virtual uint hash() const { return NO_HASH; };\n+public:\n+  VerifyVectorAlignmentNode(Node* adr, Node* mask) : Node(nullptr, adr, mask) {}\n+  virtual int Opcode() const;\n+  virtual uint size_of() const { return sizeof(*this); }\n+  virtual const Type *bottom_type() const { return in(1)->bottom_type(); }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":41,"deletions":0,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -53,6 +53,2 @@\n-        Object alignVector = wb.getVMFlag(\"AlignVector\");\n-        if (alignVector != null && !((Boolean)alignVector)) {\n-            if (ByteOrder.nativeOrder() != ByteOrder.LITTLE_ENDIAN) {\n-                throw new RuntimeException(\"fix test that was written for a little endian platform\");\n-            }\n-            TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\");\n+        if (ByteOrder.nativeOrder() != ByteOrder.LITTLE_ENDIAN) {\n+            throw new RuntimeException(\"fix test that was written for a little endian platform\");\n@@ -60,0 +56,1 @@\n+        TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\");\n@@ -192,1 +189,3 @@\n-    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" })\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" },\n+        applyIf = {\"AlignVector\", \"false\"})\n+    \/\/ AlignVector cannot guarantee that invar is aligned.\n@@ -326,1 +325,3 @@\n-    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" })\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" },\n+        applyIf = {\"AlignVector\", \"false\"})\n+    \/\/ AlignVector cannot guarantee that invar is aligned.\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorizationMismatchedAccess.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -138,0 +138,1 @@\n+                    \"AlignVector\",\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,1479 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Utils;\n+import jdk.test.whitebox.WhiteBox;\n+import jdk.internal.misc.Unsafe;\n+import java.lang.reflect.Array;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.Random;\n+import java.nio.ByteOrder;\n+\n+\/*\n+ * @test id=NoAlignVector\n+ * @bug 8310190\n+ * @summary Test AlignVector with various loop init, stride, scale, invar, etc.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @run driver compiler.loopopts.superword.TestAlignVector NoAlignVector\n+ *\/\n+\n+\/*\n+ * @test id=AlignVector\n+ * @bug 8310190\n+ * @summary Test AlignVector with various loop init, stride, scale, invar, etc.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @run driver compiler.loopopts.superword.TestAlignVector AlignVector\n+ *\/\n+\n+\/*\n+ * @test id=VerifyAlignVector\n+ * @bug 8310190\n+ * @summary Test AlignVector with various loop init, stride, scale, invar, etc.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @run driver compiler.loopopts.superword.TestAlignVector VerifyAlignVector\n+ *\/\n+\n+public class TestAlignVector {\n+    static int RANGE = 1024*8;\n+    static int RANGE_FINAL = 1024*8;\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    \/\/ Inputs\n+    byte[] aB;\n+    byte[] bB;\n+    byte mB = (byte)31;\n+    short[] aS;\n+    short[] bS;\n+    short mS = (short)0xF0F0;\n+    int[] aI;\n+    int[] bI;\n+    int mI = 0xF0F0F0F0;\n+    long[] aL;\n+    long[] bL;\n+    long mL = 0xF0F0F0F0F0F0F0F0L;\n+\n+    \/\/ List of tests\n+    Map<String,TestFunction> tests = new HashMap<String,TestFunction>();\n+\n+    \/\/ List of gold, the results from the first run before compilation\n+    Map<String,Object[]> golds = new HashMap<String,Object[]>();\n+\n+    interface TestFunction {\n+        Object[] run();\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework framework = new TestFramework(TestAlignVector.class);\n+        framework.addFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                           \"-XX:LoopUnrollLimit=250\");\n+\n+        switch (args[0]) {\n+            case \"NoAlignVector\"     -> { framework.addFlags(\"-XX:-AlignVector\"); }\n+            case \"AlignVector\"       -> { framework.addFlags(\"-XX:+AlignVector\"); }\n+            case \"VerifyAlignVector\" -> { framework.addFlags(\"-XX:+AlignVector\", \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+VerifyAlignVector\"); }\n+            default -> { throw new RuntimeException(\"Test argument not recognized: \" + args[0]); }\n+        }\n+        framework.start();\n+    }\n+\n+    public TestAlignVector() {\n+        \/\/ Generate input once\n+        aB = generateB();\n+        bB = generateB();\n+        aS = generateS();\n+        bS = generateS();\n+        aI = generateI();\n+        bI = generateI();\n+        aL = generateL();\n+        bL = generateL();\n+\n+        \/\/ Add all tests to list\n+        tests.put(\"test0\",       () -> { return test0(aB.clone(), bB.clone(), mB); });\n+        tests.put(\"test1\",       () -> { return test1(aB.clone(), bB.clone(), mB); });\n+        tests.put(\"test2\",       () -> { return test2(aB.clone(), bB.clone(), mB); });\n+        tests.put(\"test3\",       () -> { return test3(aB.clone(), bB.clone(), mB); });\n+        tests.put(\"test4\",       () -> { return test4(aB.clone(), bB.clone(), mB); });\n+        tests.put(\"test5\",       () -> { return test5(aB.clone(), bB.clone(), mB, 0); });\n+        tests.put(\"test6\",       () -> { return test6(aB.clone(), bB.clone(), mB); });\n+        tests.put(\"test7\",       () -> { return test7(aS.clone(), bS.clone(), mS); });\n+        tests.put(\"test8\",       () -> { return test8(aB.clone(), bB.clone(), mB, 0); });\n+        tests.put(\"test8\",       () -> { return test8(aB.clone(), bB.clone(), mB, 1); });\n+        tests.put(\"test9\",       () -> { return test9(aB.clone(), bB.clone(), mB); });\n+\n+        tests.put(\"test10a\",     () -> { return test10a(aB.clone(), bB.clone(), mB); });\n+        tests.put(\"test10b\",     () -> { return test10b(aB.clone(), bB.clone(), mB); });\n+        tests.put(\"test10c\",     () -> { return test10c(aS.clone(), bS.clone(), mS); });\n+        tests.put(\"test10d\",     () -> { return test10d(aS.clone(), bS.clone(), mS); });\n+\n+        tests.put(\"test11aB\",    () -> { return test11aB(aB.clone(), bB.clone(), mB); });\n+        tests.put(\"test11aS\",    () -> { return test11aS(aS.clone(), bS.clone(), mS); });\n+        tests.put(\"test11aI\",    () -> { return test11aI(aI.clone(), bI.clone(), mI); });\n+        tests.put(\"test11aL\",    () -> { return test11aL(aL.clone(), bL.clone(), mL); });\n+\n+        tests.put(\"test11bB\",    () -> { return test11bB(aB.clone(), bB.clone(), mB); });\n+        tests.put(\"test11bS\",    () -> { return test11bS(aS.clone(), bS.clone(), mS); });\n+        tests.put(\"test11bI\",    () -> { return test11bI(aI.clone(), bI.clone(), mI); });\n+        tests.put(\"test11bL\",    () -> { return test11bL(aL.clone(), bL.clone(), mL); });\n+\n+        tests.put(\"test11cB\",    () -> { return test11cB(aB.clone(), bB.clone(), mB); });\n+        tests.put(\"test11cS\",    () -> { return test11cS(aS.clone(), bS.clone(), mS); });\n+        tests.put(\"test11cI\",    () -> { return test11cI(aI.clone(), bI.clone(), mI); });\n+        tests.put(\"test11cL\",    () -> { return test11cL(aL.clone(), bL.clone(), mL); });\n+\n+        tests.put(\"test11dB\",    () -> { return test11dB(aB.clone(), bB.clone(), mB, 0); });\n+        tests.put(\"test11dS\",    () -> { return test11dS(aS.clone(), bS.clone(), mS, 0); });\n+        tests.put(\"test11dI\",    () -> { return test11dI(aI.clone(), bI.clone(), mI, 0); });\n+        tests.put(\"test11dL\",    () -> { return test11dL(aL.clone(), bL.clone(), mL, 0); });\n+\n+        tests.put(\"test12\",      () -> { return test12(aB.clone(), bB.clone(), mB); });\n+\n+        tests.put(\"test13aIL\",   () -> { return test13aIL(aI.clone(), aL.clone()); });\n+        tests.put(\"test13aIB\",   () -> { return test13aIB(aI.clone(), aB.clone()); });\n+        tests.put(\"test13aIS\",   () -> { return test13aIS(aI.clone(), aS.clone()); });\n+        tests.put(\"test13aBSIL\", () -> { return test13aBSIL(aB.clone(), aS.clone(), aI.clone(), aL.clone()); });\n+\n+        tests.put(\"test13bIL\",   () -> { return test13bIL(aI.clone(), aL.clone()); });\n+        tests.put(\"test13bIB\",   () -> { return test13bIB(aI.clone(), aB.clone()); });\n+        tests.put(\"test13bIS\",   () -> { return test13bIS(aI.clone(), aS.clone()); });\n+        tests.put(\"test13bBSIL\", () -> { return test13bBSIL(aB.clone(), aS.clone(), aI.clone(), aL.clone()); });\n+\n+        tests.put(\"test14aB\",    () -> { return test14aB(aB.clone()); });\n+        tests.put(\"test14bB\",    () -> { return test14bB(aB.clone()); });\n+        tests.put(\"test14cB\",    () -> { return test14cB(aB.clone()); });\n+\n+        tests.put(\"test15aB\",    () -> { return test15aB(aB.clone()); });\n+        tests.put(\"test15bB\",    () -> { return test15bB(aB.clone()); });\n+        tests.put(\"test15cB\",    () -> { return test15cB(aB.clone()); });\n+\n+        tests.put(\"test16a\",     () -> { return test16a(aB.clone(), aS.clone()); });\n+        tests.put(\"test16b\",     () -> { return test16b(aB.clone()); });\n+\n+        tests.put(\"test17a\",     () -> { return test17a(aL.clone()); });\n+        tests.put(\"test17b\",     () -> { return test17b(aL.clone()); });\n+        tests.put(\"test17c\",     () -> { return test17c(aL.clone()); });\n+        tests.put(\"test17d\",     () -> { return test17d(aL.clone()); });\n+\n+        tests.put(\"test18a\",     () -> { return test18a(aB.clone(), aI.clone()); });\n+        tests.put(\"test18b\",     () -> { return test18b(aB.clone(), aI.clone()); });\n+\n+        tests.put(\"test19\",      () -> { return test19(aI.clone(), bI.clone()); });\n+        tests.put(\"test20\",      () -> { return test20(aB.clone()); });\n+\n+        \/\/ Compute gold value for all test methods before compilation\n+        for (Map.Entry<String,TestFunction> entry : tests.entrySet()) {\n+            String name = entry.getKey();\n+            TestFunction test = entry.getValue();\n+            Object[] gold = test.run();\n+            golds.put(name, gold);\n+        }\n+    }\n+\n+    @Warmup(100)\n+    @Run(test = {\"test0\",\n+                 \"test1\",\n+                 \"test2\",\n+                 \"test3\",\n+                 \"test4\",\n+                 \"test5\",\n+                 \"test6\",\n+                 \"test7\",\n+                 \"test8\",\n+                 \"test9\",\n+                 \"test10a\",\n+                 \"test10b\",\n+                 \"test10c\",\n+                 \"test10d\",\n+                 \"test11aB\",\n+                 \"test11aS\",\n+                 \"test11aI\",\n+                 \"test11aL\",\n+                 \"test11bB\",\n+                 \"test11bS\",\n+                 \"test11bI\",\n+                 \"test11bL\",\n+                 \"test11cB\",\n+                 \"test11cS\",\n+                 \"test11cI\",\n+                 \"test11cL\",\n+                 \"test11dB\",\n+                 \"test11dS\",\n+                 \"test11dI\",\n+                 \"test11dL\",\n+                 \"test12\",\n+                 \"test13aIL\",\n+                 \"test13aIB\",\n+                 \"test13aIS\",\n+                 \"test13aBSIL\",\n+                 \"test13bIL\",\n+                 \"test13bIB\",\n+                 \"test13bIS\",\n+                 \"test13bBSIL\",\n+                 \"test14aB\",\n+                 \"test14bB\",\n+                 \"test14cB\",\n+                 \"test15aB\",\n+                 \"test15bB\",\n+                 \"test15cB\",\n+                 \"test16a\",\n+                 \"test16b\",\n+                 \"test17a\",\n+                 \"test17b\",\n+                 \"test17c\",\n+                 \"test17d\",\n+                 \"test18a\",\n+                 \"test18b\",\n+                 \"test19\",\n+                 \"test20\"})\n+    public void runTests() {\n+        for (Map.Entry<String,TestFunction> entry : tests.entrySet()) {\n+            String name = entry.getKey();\n+            TestFunction test = entry.getValue();\n+            \/\/ Recall gold value from before compilation\n+            Object[] gold = golds.get(name);\n+            \/\/ Compute new result\n+            Object[] result = test.run();\n+            \/\/ Compare gold and new result\n+            verify(name, gold, result);\n+        }\n+    }\n+\n+    static byte[] generateB() {\n+        byte[] a = new byte[RANGE];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = (byte)RANDOM.nextInt();\n+        }\n+        return a;\n+    }\n+\n+    static short[] generateS() {\n+        short[] a = new short[RANGE];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = (short)RANDOM.nextInt();\n+        }\n+        return a;\n+    }\n+\n+    static int[] generateI() {\n+        int[] a = new int[RANGE];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = RANDOM.nextInt();\n+        }\n+        return a;\n+    }\n+\n+    static long[] generateL() {\n+        long[] a = new long[RANGE];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = RANDOM.nextLong();\n+        }\n+        return a;\n+    }\n+\n+    static void verify(String name, Object[] gold, Object[] result) {\n+        if (gold.length != result.length) {\n+            throw new RuntimeException(\"verify \" + name + \": not the same number of outputs: gold.length = \" +\n+                                       gold.length + \", result.length = \" + result.length);\n+        }\n+        for (int i = 0; i < gold.length; i++) {\n+            Object g = gold[i];\n+            Object r = result[i];\n+            if (g.getClass() != r.getClass() || !g.getClass().isArray() || !r.getClass().isArray()) {\n+                throw new RuntimeException(\"verify \" + name + \": must both be array of same type:\" +\n+                                           \" gold[\" + i + \"].getClass() = \" + g.getClass().getSimpleName() +\n+                                           \" result[\" + i + \"].getClass() = \" + r.getClass().getSimpleName());\n+            }\n+            if (g == r) {\n+                throw new RuntimeException(\"verify \" + name + \": should be two separate arrays (with identical content):\" +\n+                                           \" gold[\" + i + \"] == result[\" + i + \"]\");\n+            }\n+            if (Array.getLength(g) != Array.getLength(r)) {\n+                    throw new RuntimeException(\"verify \" + name + \": arrays must have same length:\" +\n+                                           \" gold[\" + i + \"].length = \" + Array.getLength(g) +\n+                                           \" result[\" + i + \"].length = \" + Array.getLength(r));\n+            }\n+            Class c = g.getClass().getComponentType();\n+            if (c == byte.class) {\n+                verifyB(name, i, (byte[])g, (byte[])r);\n+            } else if (c == short.class) {\n+                verifyS(name, i, (short[])g, (short[])r);\n+            } else if (c == int.class) {\n+                verifyI(name, i, (int[])g, (int[])r);\n+            } else if (c == long.class) {\n+                verifyL(name, i, (long[])g, (long[])r);\n+            } else {\n+                throw new RuntimeException(\"verify \" + name + \": array type not supported for verify:\" +\n+                                       \" gold[\" + i + \"].getClass() = \" + g.getClass().getSimpleName() +\n+                                       \" result[\" + i + \"].getClass() = \" + r.getClass().getSimpleName());\n+            }\n+        }\n+    }\n+\n+    static void verifyB(String name, int i, byte[] g, byte[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verify \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    static void verifyS(String name, int i, short[] g, short[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verify \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    static void verifyI(String name, int i, int[] g, int[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verify \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    static void verifyL(String name, int i, long[] g, long[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verify \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VB,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">=8\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test0(byte[] a, byte[] b, byte mask) {\n+        for (int i = 0; i < RANGE; i+=8) {\n+            \/\/ Safe to vectorize with AlignVector\n+            b[i+0] = (byte)(a[i+0] & mask); \/\/ offset 0, align 0\n+            b[i+1] = (byte)(a[i+1] & mask);\n+            b[i+2] = (byte)(a[i+2] & mask);\n+            b[i+3] = (byte)(a[i+3] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.AND_VB, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test1(byte[] a, byte[] b, byte mask) {\n+        for (int i = 0; i < RANGE; i+=8) {\n+            \/\/ Safe to vectorize with AlignVector\n+            b[i+0] = (byte)(a[i+0] & mask); \/\/ offset 0, align 0\n+            b[i+1] = (byte)(a[i+1] & mask);\n+            b[i+2] = (byte)(a[i+2] & mask);\n+            b[i+3] = (byte)(a[i+3] & mask);\n+            b[i+4] = (byte)(a[i+4] & mask);\n+            b[i+5] = (byte)(a[i+5] & mask);\n+            b[i+6] = (byte)(a[i+6] & mask);\n+            b[i+7] = (byte)(a[i+7] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VB,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">=8\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.AND_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test2(byte[] a, byte[] b, byte mask) {\n+        for (int i = 0; i < RANGE; i+=8) {\n+            \/\/ Cannot align with AlignVector: 3 + x * 8 % 8 = 3\n+            b[i+3] = (byte)(a[i+3] & mask); \/\/ at alignment 3\n+            b[i+4] = (byte)(a[i+4] & mask);\n+            b[i+5] = (byte)(a[i+5] & mask);\n+            b[i+6] = (byte)(a[i+6] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VB,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">=8\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.AND_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test3(byte[] a, byte[] b, byte mask) {\n+        for (int i = 0; i < RANGE; i+=8) {\n+            \/\/ Cannot align with AlignVector: 3 + x * 8 % 8 = 3\n+\n+            \/\/ Problematic for AlignVector\n+            b[i+0] = (byte)(a[i+0] & mask); \/\/ best_memref, align 0\n+\n+            b[i+3] = (byte)(a[i+3] & mask); \/\/ pack at offset 3 bytes\n+            b[i+4] = (byte)(a[i+4] & mask);\n+            b[i+5] = (byte)(a[i+5] & mask);\n+            b[i+6] = (byte)(a[i+6] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_8, \"> 0\",\n+                  IRNode.AND_VB,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VB,        IRNode.VECTOR_SIZE_8, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">=16\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_8, \"= 0\",\/\/ unaligned\n+                  IRNode.AND_VB,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VB,        IRNode.VECTOR_SIZE_8, \"= 0\",\/\/ unaligned\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">=16\"})\n+    static Object[] test4(byte[] a, byte[] b, byte mask) {\n+        for (int i = 0; i < RANGE\/16; i++) {\n+            \/\/ Problematic for AlignVector\n+            b[i*16 + 0 ] = (byte)(a[i*16 + 0 ] & mask); \/\/ 4 pack, 0 aligned\n+            b[i*16 + 1 ] = (byte)(a[i*16 + 1 ] & mask);\n+            b[i*16 + 2 ] = (byte)(a[i*16 + 2 ] & mask);\n+            b[i*16 + 3 ] = (byte)(a[i*16 + 3 ] & mask);\n+\n+            b[i*16 + 5 ] = (byte)(a[i*16 + 5 ] & mask); \/\/ 8 pack, 5 aligned\n+            b[i*16 + 6 ] = (byte)(a[i*16 + 6 ] & mask);\n+            b[i*16 + 7 ] = (byte)(a[i*16 + 7 ] & mask);\n+            b[i*16 + 8 ] = (byte)(a[i*16 + 8 ] & mask);\n+            b[i*16 + 9 ] = (byte)(a[i*16 + 9 ] & mask);\n+            b[i*16 + 10] = (byte)(a[i*16 + 10] & mask);\n+            b[i*16 + 11] = (byte)(a[i*16 + 11] & mask);\n+            b[i*16 + 12] = (byte)(a[i*16 + 12] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VB,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">=8\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.AND_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test5(byte[] a, byte[] b, byte mask, int inv) {\n+        for (int i = 0; i < RANGE; i+=8) {\n+            \/\/ Cannot align with AlignVector because of invariant\n+            b[i+inv+0] = (byte)(a[i+inv+0] & mask);\n+\n+            b[i+inv+3] = (byte)(a[i+inv+3] & mask);\n+            b[i+inv+4] = (byte)(a[i+inv+4] & mask);\n+            b[i+inv+5] = (byte)(a[i+inv+5] & mask);\n+            b[i+inv+6] = (byte)(a[i+inv+6] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VB,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">=8\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.AND_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test6(byte[] a, byte[] b, byte mask) {\n+        for (int i = 0; i < RANGE\/8; i+=2) {\n+            \/\/ Cannot align with AlignVector because offset is odd\n+            b[i*4+0] = (byte)(a[i*4+0] & mask);\n+\n+            b[i*4+3] = (byte)(a[i*4+3] & mask);\n+            b[i*4+4] = (byte)(a[i*4+4] & mask);\n+            b[i*4+5] = (byte)(a[i*4+5] & mask);\n+            b[i*4+6] = (byte)(a[i*4+6] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VS,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">=16\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"= 0\",\n+                  IRNode.AND_VS, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test7(short[] a, short[] b, short mask) {\n+        for (int i = 0; i < RANGE\/8; i+=2) {\n+            \/\/ Cannot align with AlignVector because offset is odd\n+            b[i*4+0] = (short)(a[i*4+0] & mask);\n+\n+            b[i*4+3] = (short)(a[i*4+3] & mask);\n+            b[i*4+4] = (short)(a[i*4+4] & mask);\n+            b[i*4+5] = (short)(a[i*4+5] & mask);\n+            b[i*4+6] = (short)(a[i*4+6] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VB,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">=8\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.AND_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test8(byte[] a, byte[] b, byte mask, int init) {\n+        for (int i = init; i < RANGE; i+=8) {\n+            \/\/ Cannot align with AlignVector because of invariant (variable init becomes invar)\n+            b[i+0] = (byte)(a[i+0] & mask);\n+\n+            b[i+3] = (byte)(a[i+3] & mask);\n+            b[i+4] = (byte)(a[i+4] & mask);\n+            b[i+5] = (byte)(a[i+5] & mask);\n+            b[i+6] = (byte)(a[i+6] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VB,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">=8\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test9(byte[] a, byte[] b, byte mask) {\n+        \/\/ known non-zero init value does not affect offset, but has implicit effect on iv\n+        for (int i = 13; i < RANGE-8; i+=8) {\n+            b[i+0] = (byte)(a[i+0] & mask);\n+\n+            b[i+3] = (byte)(a[i+3] & mask);\n+            b[i+4] = (byte)(a[i+4] & mask);\n+            b[i+5] = (byte)(a[i+5] & mask);\n+            b[i+6] = (byte)(a[i+6] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VB,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">=8\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.AND_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test10a(byte[] a, byte[] b, byte mask) {\n+        \/\/ This is not alignable with pre-loop, because of odd init.\n+        for (int i = 3; i < RANGE-8; i+=8) {\n+            b[i+0] = (byte)(a[i+0] & mask);\n+            b[i+1] = (byte)(a[i+1] & mask);\n+            b[i+2] = (byte)(a[i+2] & mask);\n+            b[i+3] = (byte)(a[i+3] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VB,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">=8\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.AND_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test10b(byte[] a, byte[] b, byte mask) {\n+        \/\/ This is not alignable with pre-loop, because of odd init.\n+        \/\/ Seems not correctly handled.\n+        for (int i = 13; i < RANGE-8; i+=8) {\n+            b[i+0] = (byte)(a[i+0] & mask);\n+            b[i+1] = (byte)(a[i+1] & mask);\n+            b[i+2] = (byte)(a[i+2] & mask);\n+            b[i+3] = (byte)(a[i+3] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VS,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">=16\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"= 0\",\n+                  IRNode.AND_VS, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test10c(short[] a, short[] b, short mask) {\n+        \/\/ This is not alignable with pre-loop, because of odd init.\n+        \/\/ Seems not correctly handled with MaxVectorSize >= 32.\n+        for (int i = 13; i < RANGE-8; i+=8) {\n+            b[i+0] = (short)(a[i+0] & mask);\n+            b[i+1] = (short)(a[i+1] & mask);\n+            b[i+2] = (short)(a[i+2] & mask);\n+            b[i+3] = (short)(a[i+3] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VS,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">=16\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test10d(short[] a, short[] b, short mask) {\n+        for (int i = 13; i < RANGE-16; i+=8) {\n+            \/\/ init + offset -> aligned\n+            b[i+0+3] = (short)(a[i+0+3] & mask);\n+            b[i+1+3] = (short)(a[i+1+3] & mask);\n+            b[i+2+3] = (short)(a[i+2+3] & mask);\n+            b[i+3+3] = (short)(a[i+3+3] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.AND_VB, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test11aB(byte[] a, byte[] b, byte mask) {\n+        for (int i = 0; i < RANGE; i++) {\n+            \/\/ always alignable\n+            b[i+0] = (byte)(a[i+0] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.AND_VS, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test11aS(short[] a, short[] b, short mask) {\n+        for (int i = 0; i < RANGE; i++) {\n+            \/\/ always alignable\n+            b[i+0] = (short)(a[i+0] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.AND_VI, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test11aI(int[] a, int[] b, int mask) {\n+        for (int i = 0; i < RANGE; i++) {\n+            \/\/ always alignable\n+            b[i+0] = (int)(a[i+0] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\",\n+                  IRNode.AND_VL, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test11aL(long[] a, long[] b, long mask) {\n+        for (int i = 0; i < RANGE; i++) {\n+            \/\/ always alignable\n+            b[i+0] = (long)(a[i+0] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.AND_VB, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test11bB(byte[] a, byte[] b, byte mask) {\n+        for (int i = 1; i < RANGE; i++) {\n+            \/\/ always alignable\n+            b[i+0] = (byte)(a[i+0] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.AND_VS, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test11bS(short[] a, short[] b, short mask) {\n+        for (int i = 1; i < RANGE; i++) {\n+            \/\/ always alignable\n+            b[i+0] = (short)(a[i+0] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.AND_VI, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test11bI(int[] a, int[] b, int mask) {\n+        for (int i = 1; i < RANGE; i++) {\n+            \/\/ always alignable\n+            b[i+0] = (int)(a[i+0] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\",\n+                  IRNode.AND_VL, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test11bL(long[] a, long[] b, long mask) {\n+        for (int i = 1; i < RANGE; i++) {\n+            \/\/ always alignable\n+            b[i+0] = (long)(a[i+0] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.AND_VB, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.AND_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test11cB(byte[] a, byte[] b, byte mask) {\n+        for (int i = 1; i < RANGE-1; i++) {\n+            \/\/ 1 byte offset -> not alignable with AlignVector\n+            b[i+0] = (byte)(a[i+1] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.AND_VS, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"= 0\",\n+                  IRNode.AND_VS, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test11cS(short[] a, short[] b, short mask) {\n+        for (int i = 1; i < RANGE-1; i++) {\n+            \/\/ 2 byte offset -> not alignable with AlignVector\n+            b[i+0] = (short)(a[i+1] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.AND_VI, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+                  IRNode.AND_VI, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test11cI(int[] a, int[] b, int mask) {\n+        for (int i = 1; i < RANGE-1; i++) {\n+            \/\/ 4 byte offset -> not alignable with AlignVector\n+            b[i+0] = (int)(a[i+1] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\",\n+                  IRNode.AND_VL, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test11cL(long[] a, long[] b, long mask) {\n+        for (int i = 1; i < RANGE-1; i++) {\n+            \/\/ always alignable (8 byte offset)\n+            b[i+0] = (long)(a[i+1] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.AND_VB, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test11dB(byte[] a, byte[] b, byte mask, int invar) {\n+        for (int i = 0; i < RANGE; i++) {\n+            b[i+0+invar] = (byte)(a[i+0+invar] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.AND_VS, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test11dS(short[] a, short[] b, short mask, int invar) {\n+        for (int i = 0; i < RANGE; i++) {\n+            b[i+0+invar] = (short)(a[i+0+invar] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.AND_VI, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test11dI(int[] a, int[] b, int mask, int invar) {\n+        for (int i = 0; i < RANGE; i++) {\n+            b[i+0+invar] = (int)(a[i+0+invar] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\",\n+                  IRNode.AND_VL, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test11dL(long[] a, long[] b, long mask, int invar) {\n+        for (int i = 0; i < RANGE; i++) {\n+            b[i+0+invar] = (long)(a[i+0+invar] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.AND_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test12(byte[] a, byte[] b, byte mask) {\n+        for (int i = 0; i < RANGE\/16; i++) {\n+            \/\/ Currently does not vectorize at all\n+            b[i*6 + 0 ] = (byte)(a[i*6 + 0 ] & mask);\n+            b[i*6 + 1 ] = (byte)(a[i*6 + 1 ] & mask);\n+            b[i*6 + 2 ] = (byte)(a[i*6 + 2 ] & mask);\n+            b[i*6 + 3 ] = (byte)(a[i*6 + 3 ] & mask);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.LOAD_VECTOR_L, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.ADD_VI, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.ADD_VL, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\"})\n+    \/\/ require avx to ensure vectors are larger than what unrolling produces\n+    static Object[] test13aIL(int[] a, long[] b) {\n+        for (int i = 0; i < RANGE; i++) {\n+            a[i]++;\n+            b[i]++;\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.ADD_VB, \"> 0\",\n+                  IRNode.ADD_VI, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test13aIB(int[] a, byte[] b) {\n+        for (int i = 0; i < RANGE; i++) {\n+            a[i]++;\n+            b[i]++;\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.ADD_VI, \"> 0\",\n+                  IRNode.ADD_VS, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test13aIS(int[] a, short[] b) {\n+        for (int i = 0; i < RANGE; i++) {\n+            a[i]++;\n+            b[i]++;\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.LOAD_VECTOR_L, \"> 0\",\n+                  IRNode.ADD_VB, \"> 0\",\n+                  IRNode.ADD_VS, \"> 0\",\n+                  IRNode.ADD_VI, \"> 0\",\n+                  IRNode.ADD_VL, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test13aBSIL(byte[] a, short[] b, int[] c, long[] d) {\n+        for (int i = 0; i < RANGE; i++) {\n+            a[i]++;\n+            b[i]++;\n+            c[i]++;\n+            d[i]++;\n+        }\n+        return new Object[]{ a, b, c, d };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.LOAD_VECTOR_L, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.ADD_VI, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.ADD_VL, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\"})\n+    \/\/ require avx to ensure vectors are larger than what unrolling produces\n+    static Object[] test13bIL(int[] a, long[] b) {\n+        for (int i = 1; i < RANGE; i++) {\n+            a[i]++;\n+            b[i]++;\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.ADD_VB, \"> 0\",\n+                  IRNode.ADD_VI, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test13bIB(int[] a, byte[] b) {\n+        for (int i = 1; i < RANGE; i++) {\n+            a[i]++;\n+            b[i]++;\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.ADD_VI, \"> 0\",\n+                  IRNode.ADD_VS, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test13bIS(int[] a, short[] b) {\n+        for (int i = 1; i < RANGE; i++) {\n+            a[i]++;\n+            b[i]++;\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.LOAD_VECTOR_L, \"> 0\",\n+                  IRNode.ADD_VB, \"> 0\",\n+                  IRNode.ADD_VS, \"> 0\",\n+                  IRNode.ADD_VI, \"> 0\",\n+                  IRNode.ADD_VL, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test13bBSIL(byte[] a, short[] b, int[] c, long[] d) {\n+        for (int i = 1; i < RANGE; i++) {\n+            a[i]++;\n+            b[i]++;\n+            c[i]++;\n+            d[i]++;\n+        }\n+        return new Object[]{ a, b, c, d };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.ADD_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test14aB(byte[] a) {\n+        \/\/ non-power-of-2 stride\n+        for (int i = 0; i < RANGE-20; i+=9) {\n+            a[i+0]++;\n+            a[i+1]++;\n+            a[i+2]++;\n+            a[i+3]++;\n+            a[i+4]++;\n+            a[i+5]++;\n+            a[i+6]++;\n+            a[i+7]++;\n+            a[i+8]++;\n+            a[i+9]++;\n+            a[i+10]++;\n+            a[i+11]++;\n+            a[i+12]++;\n+            a[i+13]++;\n+            a[i+14]++;\n+            a[i+15]++;\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.ADD_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test14bB(byte[] a) {\n+        \/\/ non-power-of-2 stride\n+        for (int i = 0; i < RANGE-20; i+=3) {\n+            a[i+0]++;\n+            a[i+1]++;\n+            a[i+2]++;\n+            a[i+3]++;\n+            a[i+4]++;\n+            a[i+5]++;\n+            a[i+6]++;\n+            a[i+7]++;\n+            a[i+8]++;\n+            a[i+9]++;\n+            a[i+10]++;\n+            a[i+11]++;\n+            a[i+12]++;\n+            a[i+13]++;\n+            a[i+14]++;\n+            a[i+15]++;\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.ADD_VB, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test14cB(byte[] a) {\n+        \/\/ non-power-of-2 stride\n+        for (int i = 0; i < RANGE-20; i+=5) {\n+            a[i+0]++;\n+            a[i+1]++;\n+            a[i+2]++;\n+            a[i+3]++;\n+            a[i+4]++;\n+            a[i+5]++;\n+            a[i+6]++;\n+            a[i+7]++;\n+            a[i+8]++;\n+            a[i+9]++;\n+            a[i+10]++;\n+            a[i+11]++;\n+            a[i+12]++;\n+            a[i+13]++;\n+            a[i+14]++;\n+            a[i+15]++;\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    \/\/ IR rules difficult because of modulo wrapping with offset after peeling.\n+    static Object[] test15aB(byte[] a) {\n+        \/\/ non-power-of-2 scale\n+        for (int i = 0; i < RANGE\/64-20; i++) {\n+            a[53*i+0]++;\n+            a[53*i+1]++;\n+            a[53*i+2]++;\n+            a[53*i+3]++;\n+            a[53*i+4]++;\n+            a[53*i+5]++;\n+            a[53*i+6]++;\n+            a[53*i+7]++;\n+            a[53*i+8]++;\n+            a[53*i+9]++;\n+            a[53*i+10]++;\n+            a[53*i+11]++;\n+            a[53*i+12]++;\n+            a[53*i+13]++;\n+            a[53*i+14]++;\n+            a[53*i+15]++;\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    \/\/ IR rules difficult because of modulo wrapping with offset after peeling.\n+    static Object[] test15bB(byte[] a) {\n+        \/\/ non-power-of-2 scale\n+        for (int i = 0; i < RANGE\/64-20; i++) {\n+            a[25*i+0]++;\n+            a[25*i+1]++;\n+            a[25*i+2]++;\n+            a[25*i+3]++;\n+            a[25*i+4]++;\n+            a[25*i+5]++;\n+            a[25*i+6]++;\n+            a[25*i+7]++;\n+            a[25*i+8]++;\n+            a[25*i+9]++;\n+            a[25*i+10]++;\n+            a[25*i+11]++;\n+            a[25*i+12]++;\n+            a[25*i+13]++;\n+            a[25*i+14]++;\n+            a[25*i+15]++;\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    \/\/ IR rules difficult because of modulo wrapping with offset after peeling.\n+    static Object[] test15cB(byte[] a) {\n+        \/\/ non-power-of-2 scale\n+        for (int i = 0; i < RANGE\/64-20; i++) {\n+            a[19*i+0]++;\n+            a[19*i+1]++;\n+            a[19*i+2]++;\n+            a[19*i+3]++;\n+            a[19*i+4]++;\n+            a[19*i+5]++;\n+            a[19*i+6]++;\n+            a[19*i+7]++;\n+            a[19*i+8]++;\n+            a[19*i+9]++;\n+            a[19*i+10]++;\n+            a[19*i+11]++;\n+            a[19*i+12]++;\n+            a[19*i+13]++;\n+            a[19*i+14]++;\n+            a[19*i+15]++;\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    static Object[] test16a(byte[] a, short[] b) {\n+        \/\/ infinite loop issues\n+        for (int i = 0; i < RANGE\/2-20; i++) {\n+            a[2*i+0]++;\n+            a[2*i+1]++;\n+            a[2*i+2]++;\n+            a[2*i+3]++;\n+            a[2*i+4]++;\n+            a[2*i+5]++;\n+            a[2*i+6]++;\n+            a[2*i+7]++;\n+            a[2*i+8]++;\n+            a[2*i+9]++;\n+            a[2*i+10]++;\n+            a[2*i+11]++;\n+            a[2*i+12]++;\n+            a[2*i+13]++;\n+            a[2*i+14]++;\n+\n+            b[2*i+0]++;\n+            b[2*i+1]++;\n+            b[2*i+2]++;\n+            b[2*i+3]++;\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    static Object[] test16b(byte[] a) {\n+        \/\/ infinite loop issues\n+        for (int i = 0; i < RANGE\/2-20; i++) {\n+            a[2*i+0]++;\n+            a[2*i+1]++;\n+            a[2*i+2]++;\n+            a[2*i+3]++;\n+            a[2*i+4]++;\n+            a[2*i+5]++;\n+            a[2*i+6]++;\n+            a[2*i+7]++;\n+            a[2*i+8]++;\n+            a[2*i+9]++;\n+            a[2*i+10]++;\n+            a[2*i+11]++;\n+            a[2*i+12]++;\n+            a[2*i+13]++;\n+            a[2*i+14]++;\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\",\n+                  IRNode.ADD_VL, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test17a(long[] a) {\n+        \/\/ Unsafe: vectorizes with profiling (not xcomp)\n+        for (int i = 0; i < RANGE; i++) {\n+            int adr = UNSAFE.ARRAY_LONG_BASE_OFFSET + 8 * i;\n+            long v = UNSAFE.getLongUnaligned(a, adr);\n+            UNSAFE.putLongUnaligned(a, adr, v + 1);\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    \/\/ Difficult to write good IR rule. Modulo calculus overflow can create non-power-of-2 packs.\n+    static Object[] test17b(long[] a) {\n+        \/\/ Not alignable\n+        for (int i = 0; i < RANGE-1; i++) {\n+            int adr = UNSAFE.ARRAY_LONG_BASE_OFFSET + 8 * i + 1;\n+            long v = UNSAFE.getLongUnaligned(a, adr);\n+            UNSAFE.putLongUnaligned(a, adr, v + 1);\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.ADD_VL,        IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] test17c(long[] a) {\n+        \/\/ Unsafe: aligned vectorizes\n+        for (int i = 0; i < RANGE-1; i+=4) {\n+            int adr = UNSAFE.ARRAY_LONG_BASE_OFFSET + 8 * i;\n+            long v0 = UNSAFE.getLongUnaligned(a, adr + 0);\n+            long v1 = UNSAFE.getLongUnaligned(a, adr + 8);\n+            UNSAFE.putLongUnaligned(a, adr + 0, v0 + 1);\n+            UNSAFE.putLongUnaligned(a, adr + 8, v1 + 1);\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.ADD_VL,        IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"avx512\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">=64\"})\n+    \/\/ Ensure vector width is large enough to fit 64 byte for longs:\n+    \/\/ The offsets are: 25, 33, 57, 65\n+    \/\/ In modulo 32:    25,  1, 25,  1  -> does not vectorize\n+    \/\/ In modulo 64:    25, 33, 57,  1  -> at least first pair vectorizes\n+    \/\/ This problem is because we compute modulo vector width in memory_alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"= 0\",\n+                  IRNode.ADD_VL, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"})\n+    static Object[] test17d(long[] a) {\n+        \/\/ Not alignable\n+        for (int i = 0; i < RANGE-1; i+=4) {\n+            int adr = UNSAFE.ARRAY_LONG_BASE_OFFSET + 8 * i + 1;\n+            long v0 = UNSAFE.getLongUnaligned(a, adr + 0);\n+            long v1 = UNSAFE.getLongUnaligned(a, adr + 8);\n+            UNSAFE.putLongUnaligned(a, adr + 0, v0 + 1);\n+            UNSAFE.putLongUnaligned(a, adr + 8, v1 + 1);\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    static Object[] test18a(byte[] a, int[] b) {\n+        \/\/ scale = 0  -->  no iv\n+        for (int i = 0; i < RANGE; i++) {\n+            a[0] = 1;\n+            b[i] = 2;\n+            a[1] = 1;\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    static Object[] test18b(byte[] a, int[] b) {\n+        \/\/ scale = 0  -->  no iv\n+        for (int i = 0; i < RANGE; i++) {\n+            a[1] = 1;\n+            b[i] = 2;\n+            a[2] = 1;\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    static Object[] test19(int[] a, int[] b) {\n+        for (int i = 5000; i > 0; i--) {\n+            a[RANGE_FINAL - i] = b[RANGE_FINAL - i];\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    static Object[] test20(byte[] a) {\n+        \/\/ Example where it is easy to pass alignment check,\n+        \/\/ but used to fail the alignment calculation\n+        for (int i = 1; i < RANGE\/2-50; i++) {\n+            a[2*i+0+30]++;\n+            a[2*i+1+30]++;\n+            a[2*i+2+30]++;\n+            a[2*i+3+30]++;\n+        }\n+        return new Object[]{ a };\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAlignVector.java","additions":1479,"deletions":0,"binary":false,"changes":1479,"status":"added"},{"patch":"@@ -0,0 +1,1353 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=Vanilla\n+ * @bug 8253191\n+ * @summary Fuzzing loops with different (random) init, limit, stride, scale etc. Do not force alignment.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @requires vm.compiler2.enabled\n+ * @key randomness\n+ * @run main\/bootclasspath\/othervm -XX:+IgnoreUnrecognizedVMOptions\n+ *                                 -XX:LoopUnrollLimit=250\n+ *                                 -XX:CompileCommand=printcompilation,compiler.loopopts.superword.TestAlignVectorFuzzer::*\n+ *                                 compiler.loopopts.superword.TestAlignVectorFuzzer\n+ *\/\n+\n+\/*\n+ * @test id=VerifyAlignVector\n+ * @bug 8253191\n+ * @summary Fuzzing loops with different (random) init, limit, stride, scale etc. Verify AlignVector.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @requires vm.compiler2.enabled\n+ * @key randomness\n+ * @run main\/bootclasspath\/othervm -XX:+IgnoreUnrecognizedVMOptions\n+ *                                 -XX:+AlignVector -XX:+VerifyAlignVector\n+ *                                 -XX:LoopUnrollLimit=250\n+ *                                 -XX:CompileCommand=printcompilation,compiler.loopopts.superword.TestAlignVectorFuzzer::*\n+ *                                 compiler.loopopts.superword.TestAlignVectorFuzzer\n+ *\/\n+\n+\/*\n+ * @test id=VerifyAlignVector-Align16\n+ * @bug 8253191\n+ * @summary Fuzzing loops with different (random) init, limit, stride, scale etc. Verify AlignVector.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @requires vm.compiler2.enabled\n+ * @requires vm.bits == 64\n+ * @key randomness\n+ * @run main\/bootclasspath\/othervm -XX:+IgnoreUnrecognizedVMOptions\n+ *                                 -XX:+AlignVector -XX:+VerifyAlignVector\n+ *                                 -XX:LoopUnrollLimit=250\n+ *                                 -XX:CompileCommand=printcompilation,compiler.loopopts.superword.TestAlignVectorFuzzer::*\n+ *                                 -XX:ObjectAlignmentInBytes=16\n+ *                                 compiler.loopopts.superword.TestAlignVectorFuzzer\n+ *\/\n+\n+\/*\n+ * @test id=VerifyAlignVector-NoTieredCompilation-Xbatch\n+ * @bug 8253191\n+ * @summary Fuzzing loops with different (random) init, limit, stride, scale etc. Verify AlignVector.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @requires vm.compiler2.enabled\n+ * @key randomness\n+ * @run main\/bootclasspath\/othervm -XX:+IgnoreUnrecognizedVMOptions\n+ *                                 -XX:+AlignVector -XX:+VerifyAlignVector\n+ *                                 -XX:LoopUnrollLimit=250\n+ *                                 -XX:CompileCommand=printcompilation,compiler.loopopts.superword.TestAlignVectorFuzzer::*\n+ *                                 -XX:-TieredCompilation -Xbatch\n+ *                                 compiler.loopopts.superword.TestAlignVectorFuzzer\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import java.lang.reflect.Array;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.lang.invoke.*;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+import jdk.internal.misc.Unsafe;\n+\n+public class TestAlignVectorFuzzer {\n+    static final int ITERATIONS_MAX = 5; \/\/ time allowance may lead to fewer iterations\n+    static final int RANGE_CON = 1024 * 8;\n+    static int ZERO = 0;\n+\n+    private static final Random random = Utils.getRandomInstance();\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    interface TestFunction {\n+        Object[] run();\n+    }\n+\n+    \/\/ Setup for variable compile-time constants:\n+    private static final CallSite INIT_CS    = new MutableCallSite(MethodType.methodType(int.class));\n+    private static final CallSite LIMIT_CS   = new MutableCallSite(MethodType.methodType(int.class));\n+    private static final CallSite STRIDE_CS  = new MutableCallSite(MethodType.methodType(int.class));\n+    private static final CallSite SCALE_CS   = new MutableCallSite(MethodType.methodType(int.class));\n+    private static final CallSite OFFSET1_CS = new MutableCallSite(MethodType.methodType(int.class));\n+    private static final CallSite OFFSET2_CS = new MutableCallSite(MethodType.methodType(int.class));\n+    private static final CallSite OFFSET3_CS = new MutableCallSite(MethodType.methodType(int.class));\n+    private static final MethodHandle INIT_MH    = INIT_CS.dynamicInvoker();\n+    private static final MethodHandle LIMIT_MH   = LIMIT_CS.dynamicInvoker();\n+    private static final MethodHandle STRIDE_MH  = STRIDE_CS.dynamicInvoker();\n+    private static final MethodHandle SCALE_MH   = SCALE_CS.dynamicInvoker();\n+    private static final MethodHandle OFFSET1_MH = OFFSET1_CS.dynamicInvoker();\n+    private static final MethodHandle OFFSET2_MH = OFFSET2_CS.dynamicInvoker();\n+    private static final MethodHandle OFFSET3_MH = OFFSET3_CS.dynamicInvoker();\n+\n+    \/\/ Toggle if init, limit and offset are constants or variables\n+    private static final CallSite INIT_IS_CON_CS   = new MutableCallSite(MethodType.methodType(boolean.class));\n+    private static final CallSite LIMIT_IS_CON_CS  = new MutableCallSite(MethodType.methodType(boolean.class));\n+    private static final CallSite OFFSET1_IS_CON_CS = new MutableCallSite(MethodType.methodType(boolean.class));\n+    private static final CallSite OFFSET2_IS_CON_CS = new MutableCallSite(MethodType.methodType(boolean.class));\n+    private static final CallSite OFFSET3_IS_CON_CS = new MutableCallSite(MethodType.methodType(boolean.class));\n+    private static final MethodHandle INIT_IS_CON_MH    = INIT_IS_CON_CS.dynamicInvoker();\n+    private static final MethodHandle LIMIT_IS_CON_MH   = LIMIT_IS_CON_CS.dynamicInvoker();\n+    private static final MethodHandle OFFSET1_IS_CON_MH = OFFSET1_IS_CON_CS.dynamicInvoker();\n+    private static final MethodHandle OFFSET2_IS_CON_MH = OFFSET2_IS_CON_CS.dynamicInvoker();\n+    private static final MethodHandle OFFSET3_IS_CON_MH = OFFSET3_IS_CON_CS.dynamicInvoker();\n+\n+    \/\/ Hand-Unrolling compile-constants\n+    private static final CallSite HAND_UNROLLING1_CS = new MutableCallSite(MethodType.methodType(int.class));\n+    private static final CallSite HAND_UNROLLING2_CS = new MutableCallSite(MethodType.methodType(int.class));\n+    private static final CallSite HAND_UNROLLING3_CS = new MutableCallSite(MethodType.methodType(int.class));\n+    private static final MethodHandle HAND_UNROLLING1_MH = HAND_UNROLLING1_CS.dynamicInvoker();\n+    private static final MethodHandle HAND_UNROLLING2_MH = HAND_UNROLLING2_CS.dynamicInvoker();\n+    private static final MethodHandle HAND_UNROLLING3_MH = HAND_UNROLLING3_CS.dynamicInvoker();\n+\n+    static void setConstant(CallSite cs, int value) {\n+        MethodHandle constant = MethodHandles.constant(int.class, value);\n+        cs.setTarget(constant);\n+    }\n+\n+    static void setConstant(CallSite cs, boolean value) {\n+        MethodHandle constant = MethodHandles.constant(boolean.class, value);\n+        cs.setTarget(constant);\n+    }\n+\n+    static int init_con() { \/\/ compile-time constant\n+        try {\n+            return (int) INIT_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static boolean init_is_con() { \/\/ compile-time constant\n+        try {\n+            return (boolean) INIT_IS_CON_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static int init_con_or_var() {\n+        int init = init_con();\n+        if (!init_is_con()) { \/\/ branch constant folds to true or false\n+            init += ZERO; \/\/ LoadI\n+        }\n+        return init;\n+    }\n+\n+    static int limit_con() { \/\/ compile-time constant\n+        try {\n+            return (int) LIMIT_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static boolean limit_is_con() { \/\/ compile-time constant\n+        try {\n+            return (boolean) LIMIT_IS_CON_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static int limit_con_or_var() {\n+        int limit = limit_con();\n+        if (!limit_is_con()) { \/\/ branch constant folds to true or false\n+            limit -= ZERO; \/\/ LoadI\n+        }\n+        return limit;\n+    }\n+\n+    static int stride_con() { \/\/ compile-time constant\n+        try {\n+            return (int) STRIDE_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static int scale_con() { \/\/ compile-time constant\n+        try {\n+            return (int) SCALE_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static int offset1_con() { \/\/ compile-time constant\n+        try {\n+            return (int) OFFSET1_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static int offset2_con() { \/\/ compile-time constant\n+        try {\n+            return (int) OFFSET2_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static int offset3_con() { \/\/ compile-time constant\n+        try {\n+            return (int) OFFSET3_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static boolean offset1_is_con() { \/\/ compile-time constant\n+        try {\n+            return (boolean) OFFSET1_IS_CON_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static boolean offset2_is_con() { \/\/ compile-time constant\n+        try {\n+            return (boolean) OFFSET2_IS_CON_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static boolean offset3_is_con() { \/\/ compile-time constant\n+        try {\n+            return (boolean) OFFSET3_IS_CON_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static int offset1_con_or_var() {\n+        int offset = offset1_con();\n+        if (!offset1_is_con()) { \/\/ branch constant folds to true or false\n+            offset += ZERO; \/\/ LoadI\n+        }\n+        return offset;\n+    }\n+\n+    static int offset2_con_or_var() {\n+        int offset = offset2_con();\n+        if (!offset2_is_con()) { \/\/ branch constant folds to true or false\n+            offset += ZERO; \/\/ LoadI\n+        }\n+        return offset;\n+    }\n+\n+    static int offset3_con_or_var() {\n+        int offset = offset3_con();\n+        if (!offset3_is_con()) { \/\/ branch constant folds to true or false\n+            offset += ZERO; \/\/ LoadI\n+        }\n+        return offset;\n+    }\n+\n+    static int opposite_direction_offset1_con_or_var() {\n+        \/\/ When indexing in the opposite direction to i, we Want to have:\n+        \/\/\n+        \/\/   a[x - i * scale]\n+        \/\/\n+        \/\/ So we want to fulfill these constraints:\n+        \/\/\n+        \/\/   x - init * scale  = offset + limit * scale\n+        \/\/   x - limit * scale = offset + init * scale\n+        \/\/\n+        \/\/ Hence:\n+        \/\/\n+        \/\/   x = offset + limit * scale + init * scale;\n+\n+        int offset = offset1_con_or_var();\n+        int init = init_con();\n+        int limit = limit_con();\n+        int scale = scale_con();\n+        return offset + limit * scale + init * scale;\n+    }\n+\n+    static int opposite_direction_offset2_con_or_var() {\n+        int offset = offset2_con_or_var();\n+        int init = init_con();\n+        int limit = limit_con();\n+        int scale = scale_con();\n+        return offset + limit * scale + init * scale;\n+    }\n+\n+    static int opposite_direction_offset3_con_or_var() {\n+        int offset = offset3_con_or_var();\n+        int init = init_con();\n+        int limit = limit_con();\n+        int scale = scale_con();\n+        return offset + limit * scale + init * scale;\n+    }\n+\n+    static int hand_unrolling1_con() { \/\/ compile-time constant\n+        try {\n+            return (int) HAND_UNROLLING1_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static int hand_unrolling2_con() { \/\/ compile-time constant\n+        try {\n+            return (int) HAND_UNROLLING2_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static int hand_unrolling3_con() { \/\/ compile-time constant\n+        try {\n+            return (int) HAND_UNROLLING3_MH.invokeExact();\n+        } catch (Throwable t) {\n+            throw new InternalError(t); \/\/ should NOT happen\n+        }\n+    }\n+\n+    static int randomStride() {\n+        return switch (random.nextInt(6)) {\n+            case 0       -> random.nextInt(64) + 1; \/\/ [1..64]\n+            case 1, 2, 3 -> 1;\n+            default      -> 1 << random.nextInt(7); \/\/ powers of 2: 1..64\n+        };\n+    }\n+\n+    static int randomScale() {\n+        return switch (random.nextInt(6)) {\n+            case 0       -> random.nextInt(64) + 1; \/\/ [1..64]\n+            case 1, 2, 3 -> 1;\n+            default      -> 1 << random.nextInt(7); \/\/ powers of 2: 1..64\n+        };\n+    }\n+\n+    static int randomOffsetDiff() {\n+        return switch (random.nextInt(6)) {\n+            case 0       -> random.nextInt(256) + 128;\n+            case 1, 2, 3 -> 0;\n+            case 4       -> +(1 << random.nextInt(8)); \/\/ powers of 2: 1..128\n+            default      -> -(1 << random.nextInt(8)); \/\/ powers of 2: -1..-128\n+        };\n+    }\n+\n+    static int randomHandUnrolling() {\n+        return switch (random.nextInt(2)) {\n+            case 0       -> random.nextInt(16) + 1; \/\/ [1..16]\n+            default      -> 1 << random.nextInt(5); \/\/ powers of 2: 1..16\n+        };\n+    }\n+\n+    static void setRandomConstants() {\n+        \/\/ We want to create random constants for a loop, but they should never go out of bounds.\n+        \/\/ We constrain i to be in the range [init..limit], with init < limit. For simplicity, we\n+        \/\/ always generate:\n+        \/\/\n+        \/\/   1 <= scale  <= 64\n+        \/\/   1 <= stride <= 64\n+        \/\/\n+        \/\/ We work with this reference memory access:\n+        \/\/\n+        \/\/   a[offset + i * scale]\n+        \/\/\n+        \/\/ It is up to the test function to re-arrange the the given terms to iterate upward or\n+        \/\/ downward, to hand-unroll etc.\n+        \/\/\n+        \/\/ We must ensure that the first and last indices are in range:\n+        \/\/\n+        \/\/   0 + error <= offset + init * scale\n+        \/\/   offset + limit * scale < range - error\n+        \/\/\n+        \/\/ The \"error\" term is there such that the test functions have the freedom to slightly\n+        \/\/ diverge from the reference memory access pattern (for example modify the offset).\n+        \/\/\n+        \/\/ The values for scale and range are already fixed. We now want to generate values for\n+        \/\/ offset, init and limit.\n+        \/\/\n+        \/\/ (1) Fix offset:\n+        \/\/\n+        \/\/     init >= (error - offset) \/ scale\n+        \/\/     limit < (range - error - offset) \/ scale\n+        \/\/\n+        \/\/ (2) Fix init:\n+        \/\/\n+        \/\/     offset >= error - init * scale\n+        \/\/     limit < (range - error - offset) \/ scale\n+        \/\/\n+        \/\/ (3) Fix limit:\n+        \/\/\n+        \/\/     offset < range - error - limit * scale\n+        \/\/     init >= (error - offset) \/ scale\n+        \/\/\n+        \/\/ We can still slightly perturb the results in the direction permitted by the inequality.\n+\n+        int stride = randomStride();\n+        int scale = randomScale();\n+        int range = RANGE_CON;\n+        int error = 1024; \/\/ generous\n+        int init;\n+        int limit;\n+        int offset1;\n+        switch(random.nextInt(3)) {\n+            case 0 -> {\n+                offset1 = random.nextInt(2_000_000) - 1_000_000;\n+                init = (error - offset1) \/ scale + random.nextInt(64);\n+                limit = (range - error - offset1) \/ scale - random.nextInt(64);\n+            }\n+            case 1 -> {\n+                init = random.nextInt(2_000_000) - 1_000_000;\n+                offset1 = error - init * scale + random.nextInt(64);\n+                limit = (range - error - offset1) \/ scale - random.nextInt(64);\n+            }\n+            default -> {\n+                limit = random.nextInt(2_000_000) - 1_000_000;\n+                offset1 = range - error - limit * scale - random.nextInt(64);\n+                init = (error - offset1) \/ scale + random.nextInt(64);\n+            }\n+        }\n+\n+        int offset2 = offset1 + randomOffsetDiff();\n+        int offset3 = offset1 + randomOffsetDiff();\n+\n+        \/\/ We can toggle the init, limit and offset to either be constant or variable:\n+        boolean init_is_con   = random.nextInt(3) != 0;\n+        boolean limit_is_con  = random.nextInt(3) != 0;\n+        boolean offset1_is_con = random.nextInt(3) != 0;\n+        boolean offset2_is_con = random.nextInt(3) != 0;\n+        boolean offset3_is_con = random.nextInt(3) != 0;\n+\n+        int hand_unrolling1 = randomHandUnrolling();\n+        int hand_unrolling2 = randomHandUnrolling();\n+        int hand_unrolling3 = randomHandUnrolling();\n+\n+\/\/      Overwrite the fuzzed values below to reproduce a specific failure:\n+\/\/\n+\/\/        init = 1;\n+\/\/        limit = init + 3000;\n+\/\/        offset1 = 0;\n+\/\/        offset2 = 0;\n+\/\/        offset3 = 32 - 2*init;\n+\/\/        stride =  1;\n+\/\/        scale =   2;\n+\/\/        hand_unrolling1 = 0;\n+\/\/        hand_unrolling2 = 0;\n+\/\/        hand_unrolling3 = 4;\n+\/\/\n+\/\/        init_is_con    = true;\n+\/\/        limit_is_con   = true;\n+\/\/        offset1_is_con = true;\n+\/\/        offset2_is_con = true;\n+\/\/        offset3_is_con = true;\n+\n+        System.out.println(\"  init:    \" + init    + \" (con: \" + init_is_con + \")\");\n+        System.out.println(\"  limit:   \" + limit   + \" (con: \" + limit_is_con + \")\");\n+        System.out.println(\"  offset1: \" + offset1 + \" (con: \" + offset1_is_con + \")\");\n+        System.out.println(\"  offset2: \" + offset2 + \" (con: \" + offset2_is_con + \")\");\n+        System.out.println(\"  offset3: \" + offset3 + \" (con: \" + offset3_is_con + \")\");\n+        System.out.println(\"  stride:  \" + stride);\n+        System.out.println(\"  scale:   \" + scale);\n+        System.out.println(\"  hand_unrolling1: \" + hand_unrolling1);\n+        System.out.println(\"  hand_unrolling2: \" + hand_unrolling2);\n+        System.out.println(\"  hand_unrolling3: \" + hand_unrolling3);\n+        setConstant(INIT_CS,   init);\n+        setConstant(LIMIT_CS,  limit);\n+        setConstant(STRIDE_CS, stride);\n+        setConstant(SCALE_CS,  scale);\n+        setConstant(OFFSET1_CS, offset1);\n+        setConstant(OFFSET2_CS, offset2);\n+        setConstant(OFFSET3_CS, offset3);\n+        setConstant(INIT_IS_CON_CS,   init_is_con);\n+        setConstant(LIMIT_IS_CON_CS,  limit_is_con);\n+        setConstant(OFFSET1_IS_CON_CS, offset1_is_con);\n+        setConstant(OFFSET2_IS_CON_CS, offset2_is_con);\n+        setConstant(OFFSET3_IS_CON_CS, offset3_is_con);\n+        setConstant(HAND_UNROLLING1_CS, hand_unrolling1);\n+        setConstant(HAND_UNROLLING2_CS, hand_unrolling2);\n+        setConstant(HAND_UNROLLING3_CS, hand_unrolling3);\n+    }\n+\n+    public static void main(String[] args) {\n+        byte[] aB = generateB();\n+        byte[] bB = generateB();\n+        byte[] cB = generateB();\n+        short[] aS = generateS();\n+        short[] bS = generateS();\n+        short[] cS = generateS();\n+        char[] aC = generateC();\n+        char[] bC = generateC();\n+        char[] cC = generateC();\n+        int[] aI = generateI();\n+        int[] bI = generateI();\n+        int[] cI = generateI();\n+        long[] aL = generateL();\n+        long[] bL = generateL();\n+        long[] cL = generateL();\n+        float[] aF = generateF();\n+        float[] bF = generateF();\n+        float[] cF = generateF();\n+        double[] aD = generateD();\n+        double[] bD = generateD();\n+        double[] cD = generateD();\n+\n+        \/\/ Add all tests to list\n+        Map<String,TestFunction> tests = new HashMap<String,TestFunction>();\n+        tests.put(\"testUUB\", () -> { return testUUB(aB.clone()); });\n+        tests.put(\"testDDB\", () -> { return testDDB(aB.clone()); });\n+        tests.put(\"testUDB\", () -> { return testUDB(aB.clone()); });\n+        tests.put(\"testDUB\", () -> { return testDUB(aB.clone()); });\n+\n+        tests.put(\"testUUBH\", () -> { return testUUBH(aB.clone()); });\n+\n+        tests.put(\"testUUBBB\", () -> { return testUUBBB(aB.clone(), bB.clone(), cB.clone()); });\n+        tests.put(\"testUUBSI\", () -> { return testUUBSI(aB.clone(), bS.clone(), cI.clone()); });\n+\n+        tests.put(\"testUUBBBH\", () -> { return testUUBBBH(aB.clone(), bB.clone(), cB.clone()); });\n+\n+        tests.put(\"testUUBCFH\", () -> { return testUUBCFH(aB.clone(), bC.clone(), cF.clone()); });\n+        tests.put(\"testDDBCFH\", () -> { return testDDBCFH(aB.clone(), bC.clone(), cF.clone()); });\n+        tests.put(\"testUDBCFH\", () -> { return testUDBCFH(aB.clone(), bC.clone(), cF.clone()); });\n+        tests.put(\"testDUBCFH\", () -> { return testDUBCFH(aB.clone(), bC.clone(), cF.clone()); });\n+\n+        tests.put(\"testMMSFD\", () -> { return testMMSFD(aS.clone(), bF.clone(), cD.clone()); });\n+\n+        tests.put(\"testUU_unsafe_BasI\", () -> { return testUU_unsafe_BasI(aB.clone()); });\n+        tests.put(\"testUU_unsafe_BasIH\", () -> { return testUU_unsafe_BasIH(aB.clone(), bB.clone(), cB.clone()); });\n+\n+\n+        \/\/ Only run for 90% of the time, and subtract some margin. This ensures the shutdown has sufficient time,\n+        \/\/ even for very slow runs.\n+        long test_time_allowance = System.currentTimeMillis() +\n+                                   (long)(Utils.adjustTimeout(Utils.DEFAULT_TEST_TIMEOUT) * 0.9) -\n+                                   20_000;\n+        long test_hard_timeout = System.currentTimeMillis() +\n+                                Utils.adjustTimeout(Utils.DEFAULT_TEST_TIMEOUT);\n+\n+        for (int i = 1; i <= ITERATIONS_MAX; i++) {\n+            setRandomConstants();\n+            for (Map.Entry<String,TestFunction> entry : tests.entrySet()) {\n+                String name = entry.getKey();\n+                TestFunction test = entry.getValue();\n+                long allowance = test_time_allowance - System.currentTimeMillis();\n+                long until_timeout = test_hard_timeout - System.currentTimeMillis();\n+                System.out.println(\"ITERATION \" + i + \" of \" + ITERATIONS_MAX + \". Test \" + name +\n+                                   \", time allowance: \" + allowance + \", until timeout: \" + until_timeout);\n+\n+                \/\/ Compute gold value, probably deopt first if constants have changed.\n+                Object[] gold = test.run();\n+\n+                \/\/ Have enough iterations to (re)compile\n+                for (int j = 0; j < 10_000; j++) {\n+                    Object[] result = test.run();\n+                    verify(name, gold, result);\n+                }\n+\n+                if (System.currentTimeMillis() > test_time_allowance) {\n+                    allowance = test_time_allowance - System.currentTimeMillis();\n+                    until_timeout = test_hard_timeout - System.currentTimeMillis();\n+                    System.out.println(\"TEST PASSED: hit maximal time allownance during iteration \" + i +\n+                                       \", time allowance: \" + allowance + \", until timeout: \" + until_timeout);\n+                    return;\n+                }\n+            }\n+        }\n+        long allowance = test_time_allowance - System.currentTimeMillis();\n+        long until_timeout = test_hard_timeout - System.currentTimeMillis();\n+        System.out.println(\"TEST PASSED, time allowance: \" + allowance + \", until timeout: \" + until_timeout);\n+    }\n+\n+    \/\/ Test names:\n+    \/\/ test\n+    \/\/ {U: i goes up, D: i goes down, M: mixed}\n+    \/\/ {U: indexing goes up, D: indexing goes down, M: mixed}\n+    \/\/ BSCILFD (types used)\n+\n+    \/\/ -------------------- BASIC SINGLE --------------------\n+\n+    static Object[] testUUB(byte[] a) {\n+        int init   = init_con_or_var();\n+        int limit  = limit_con_or_var();\n+        int stride = stride_con();\n+        int scale  = scale_con();\n+        int offset = offset1_con_or_var();\n+\n+        for (int i = init; i < limit; i += stride) {\n+            a[offset + i * scale]++;\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    static Object[] testDDB(byte[] a) {\n+        int init   = init_con_or_var();\n+        int limit  = limit_con_or_var();\n+        int stride = stride_con();\n+        int scale  = scale_con();\n+        int offset = offset1_con_or_var();\n+\n+        for (int i = limit; i > init; i -= stride) {\n+            a[offset + i * scale]++;\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    static Object[] testUDB(byte[] a) {\n+        int init   = init_con_or_var();\n+        int limit  = limit_con_or_var();\n+        int stride = stride_con();\n+        int scale  = scale_con();\n+        int x = opposite_direction_offset1_con_or_var();\n+\n+        for (int i = init; i < limit; i += stride) {\n+           a[x - i * scale]++;\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    static Object[] testDUB(byte[] a) {\n+        int init   = init_con_or_var();\n+        int limit  = limit_con_or_var();\n+        int stride = stride_con();\n+        int scale  = scale_con();\n+        int x = opposite_direction_offset1_con_or_var();\n+\n+        for (int i = limit; i > init; i -= stride) {\n+           a[x - i * scale]++;\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    \/\/ -------------------- BASIC HAND UNROLL --------------------\n+\n+    static Object[] testUUBH(byte[] a) {\n+        int init   = init_con_or_var();\n+        int limit  = limit_con_or_var();\n+        int stride = stride_con();\n+        int scale  = scale_con();\n+        int offset = offset1_con_or_var();\n+\n+        \/\/ All if statements with constant h fold to true or false\n+        int h = hand_unrolling1_con();\n+\n+        for (int i = init; i < limit; i += stride) {\n+            if (h >=  1) { a[offset + i * scale +  0]++; }\n+            if (h >=  2) { a[offset + i * scale +  1]++; }\n+            if (h >=  3) { a[offset + i * scale +  2]++; }\n+            if (h >=  4) { a[offset + i * scale +  3]++; }\n+            if (h >=  5) { a[offset + i * scale +  4]++; }\n+            if (h >=  6) { a[offset + i * scale +  5]++; }\n+            if (h >=  7) { a[offset + i * scale +  6]++; }\n+            if (h >=  8) { a[offset + i * scale +  7]++; }\n+            if (h >=  9) { a[offset + i * scale +  8]++; }\n+            if (h >= 10) { a[offset + i * scale +  9]++; }\n+            if (h >= 11) { a[offset + i * scale + 10]++; }\n+            if (h >= 12) { a[offset + i * scale + 11]++; }\n+            if (h >= 13) { a[offset + i * scale + 12]++; }\n+            if (h >= 14) { a[offset + i * scale + 13]++; }\n+            if (h >= 15) { a[offset + i * scale + 14]++; }\n+            if (h >= 16) { a[offset + i * scale + 15]++; }\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    \/\/ -------------------- BASIC TRIPPLE --------------------\n+\n+    static Object[] testUUBBB(byte[] a, byte[] b, byte[] c) {\n+        int init    = init_con_or_var();\n+        int limit   = limit_con_or_var();\n+        int stride  = stride_con();\n+        int scale   = scale_con();\n+        int offset1 = offset1_con_or_var();\n+        int offset2 = offset2_con_or_var();\n+        int offset3 = offset3_con_or_var();\n+\n+        for (int i = init; i < limit; i += stride) {\n+            a[offset1 + i * scale]++;\n+            b[offset2 + i * scale]++;\n+            c[offset3 + i * scale]++;\n+        }\n+        return new Object[]{ a, b, c };\n+    }\n+\n+    static Object[] testUUBSI(byte[] a, short[] b, int[] c) {\n+        int init    = init_con_or_var();\n+        int limit   = limit_con_or_var();\n+        int stride  = stride_con();\n+        int scale   = scale_con();\n+        int offset1 = offset1_con_or_var();\n+        int offset2 = offset2_con_or_var();\n+        int offset3 = offset3_con_or_var();\n+\n+        for (int i = init; i < limit; i += stride) {\n+            a[offset1 + i * scale]++;\n+            b[offset2 + i * scale]++;\n+            c[offset3 + i * scale]++;\n+        }\n+        return new Object[]{ a, b, c };\n+    }\n+\n+    \/\/ -------------------- HAND UNROLL TRIPPLE --------------------\n+\n+    static Object[] testUUBBBH(byte[] a, byte[] b, byte[] c) {\n+        int init   = init_con_or_var();\n+        int limit  = limit_con_or_var();\n+        int stride = stride_con();\n+        int scale  = scale_con();\n+        int offset1 = offset1_con_or_var();\n+        int offset2 = offset2_con_or_var();\n+        int offset3 = offset3_con_or_var();\n+\n+        int h1 = hand_unrolling1_con();\n+        int h2 = hand_unrolling2_con();\n+        int h3 = hand_unrolling3_con();\n+\n+        for (int i = init; i < limit; i += stride) {\n+            if (h1 >=  1) { a[offset1 + i * scale +  0]++; }\n+            if (h1 >=  2) { a[offset1 + i * scale +  1]++; }\n+            if (h1 >=  3) { a[offset1 + i * scale +  2]++; }\n+            if (h1 >=  4) { a[offset1 + i * scale +  3]++; }\n+            if (h1 >=  5) { a[offset1 + i * scale +  4]++; }\n+            if (h1 >=  6) { a[offset1 + i * scale +  5]++; }\n+            if (h1 >=  7) { a[offset1 + i * scale +  6]++; }\n+            if (h1 >=  8) { a[offset1 + i * scale +  7]++; }\n+            if (h1 >=  9) { a[offset1 + i * scale +  8]++; }\n+            if (h1 >= 10) { a[offset1 + i * scale +  9]++; }\n+            if (h1 >= 11) { a[offset1 + i * scale + 10]++; }\n+            if (h1 >= 12) { a[offset1 + i * scale + 11]++; }\n+            if (h1 >= 13) { a[offset1 + i * scale + 12]++; }\n+            if (h1 >= 14) { a[offset1 + i * scale + 13]++; }\n+            if (h1 >= 15) { a[offset1 + i * scale + 14]++; }\n+            if (h1 >= 16) { a[offset1 + i * scale + 15]++; }\n+\n+            if (h2 >=  1) { b[offset2 + i * scale +  0]++; }\n+            if (h2 >=  2) { b[offset2 + i * scale +  1]++; }\n+            if (h2 >=  3) { b[offset2 + i * scale +  2]++; }\n+            if (h2 >=  4) { b[offset2 + i * scale +  3]++; }\n+            if (h2 >=  5) { b[offset2 + i * scale +  4]++; }\n+            if (h2 >=  6) { b[offset2 + i * scale +  5]++; }\n+            if (h2 >=  7) { b[offset2 + i * scale +  6]++; }\n+            if (h2 >=  8) { b[offset2 + i * scale +  7]++; }\n+            if (h2 >=  9) { b[offset2 + i * scale +  8]++; }\n+            if (h2 >= 10) { b[offset2 + i * scale +  9]++; }\n+            if (h2 >= 11) { b[offset2 + i * scale + 10]++; }\n+            if (h2 >= 12) { b[offset2 + i * scale + 11]++; }\n+            if (h2 >= 13) { b[offset2 + i * scale + 12]++; }\n+            if (h2 >= 14) { b[offset2 + i * scale + 13]++; }\n+            if (h2 >= 15) { b[offset2 + i * scale + 14]++; }\n+            if (h2 >= 16) { b[offset2 + i * scale + 15]++; }\n+\n+            if (h3 >=  1) { c[offset3 + i * scale +  0]++; }\n+            if (h3 >=  2) { c[offset3 + i * scale +  1]++; }\n+            if (h3 >=  3) { c[offset3 + i * scale +  2]++; }\n+            if (h3 >=  4) { c[offset3 + i * scale +  3]++; }\n+            if (h3 >=  5) { c[offset3 + i * scale +  4]++; }\n+            if (h3 >=  6) { c[offset3 + i * scale +  5]++; }\n+            if (h3 >=  7) { c[offset3 + i * scale +  6]++; }\n+            if (h3 >=  8) { c[offset3 + i * scale +  7]++; }\n+            if (h3 >=  9) { c[offset3 + i * scale +  8]++; }\n+            if (h3 >= 10) { c[offset3 + i * scale +  9]++; }\n+            if (h3 >= 11) { c[offset3 + i * scale + 10]++; }\n+            if (h3 >= 12) { c[offset3 + i * scale + 11]++; }\n+            if (h3 >= 13) { c[offset3 + i * scale + 12]++; }\n+            if (h3 >= 14) { c[offset3 + i * scale + 13]++; }\n+            if (h3 >= 15) { c[offset3 + i * scale + 14]++; }\n+            if (h3 >= 16) { c[offset3 + i * scale + 15]++; }\n+        }\n+        return new Object[]{ a, b, c };\n+    }\n+\n+    static Object[] testUUBCFH(byte[] a, char[] b, float[] c) {\n+        int init   = init_con_or_var();\n+        int limit  = limit_con_or_var();\n+        int stride = stride_con();\n+        int scale  = scale_con();\n+        int offset1 = offset1_con_or_var();\n+        int offset2 = offset2_con_or_var();\n+        int offset3 = offset3_con_or_var();\n+\n+        int h1 = hand_unrolling1_con();\n+        int h2 = hand_unrolling2_con();\n+        int h3 = hand_unrolling3_con();\n+\n+        for (int i = init; i < limit; i += stride) {\n+            if (h1 >=  1) { a[offset1 + i * scale +  0]++; }\n+            if (h1 >=  2) { a[offset1 + i * scale +  1]++; }\n+            if (h1 >=  3) { a[offset1 + i * scale +  2]++; }\n+            if (h1 >=  4) { a[offset1 + i * scale +  3]++; }\n+            if (h1 >=  5) { a[offset1 + i * scale +  4]++; }\n+            if (h1 >=  6) { a[offset1 + i * scale +  5]++; }\n+            if (h1 >=  7) { a[offset1 + i * scale +  6]++; }\n+            if (h1 >=  8) { a[offset1 + i * scale +  7]++; }\n+            if (h1 >=  9) { a[offset1 + i * scale +  8]++; }\n+            if (h1 >= 10) { a[offset1 + i * scale +  9]++; }\n+            if (h1 >= 11) { a[offset1 + i * scale + 10]++; }\n+            if (h1 >= 12) { a[offset1 + i * scale + 11]++; }\n+            if (h1 >= 13) { a[offset1 + i * scale + 12]++; }\n+            if (h1 >= 14) { a[offset1 + i * scale + 13]++; }\n+            if (h1 >= 15) { a[offset1 + i * scale + 14]++; }\n+            if (h1 >= 16) { a[offset1 + i * scale + 15]++; }\n+\n+            if (h2 >=  1) { b[offset2 + i * scale +  0]++; }\n+            if (h2 >=  2) { b[offset2 + i * scale +  1]++; }\n+            if (h2 >=  3) { b[offset2 + i * scale +  2]++; }\n+            if (h2 >=  4) { b[offset2 + i * scale +  3]++; }\n+            if (h2 >=  5) { b[offset2 + i * scale +  4]++; }\n+            if (h2 >=  6) { b[offset2 + i * scale +  5]++; }\n+            if (h2 >=  7) { b[offset2 + i * scale +  6]++; }\n+            if (h2 >=  8) { b[offset2 + i * scale +  7]++; }\n+            if (h2 >=  9) { b[offset2 + i * scale +  8]++; }\n+            if (h2 >= 10) { b[offset2 + i * scale +  9]++; }\n+            if (h2 >= 11) { b[offset2 + i * scale + 10]++; }\n+            if (h2 >= 12) { b[offset2 + i * scale + 11]++; }\n+            if (h2 >= 13) { b[offset2 + i * scale + 12]++; }\n+            if (h2 >= 14) { b[offset2 + i * scale + 13]++; }\n+            if (h2 >= 15) { b[offset2 + i * scale + 14]++; }\n+            if (h2 >= 16) { b[offset2 + i * scale + 15]++; }\n+\n+            if (h3 >=  1) { c[offset3 + i * scale +  0]++; }\n+            if (h3 >=  2) { c[offset3 + i * scale +  1]++; }\n+            if (h3 >=  3) { c[offset3 + i * scale +  2]++; }\n+            if (h3 >=  4) { c[offset3 + i * scale +  3]++; }\n+            if (h3 >=  5) { c[offset3 + i * scale +  4]++; }\n+            if (h3 >=  6) { c[offset3 + i * scale +  5]++; }\n+            if (h3 >=  7) { c[offset3 + i * scale +  6]++; }\n+            if (h3 >=  8) { c[offset3 + i * scale +  7]++; }\n+            if (h3 >=  9) { c[offset3 + i * scale +  8]++; }\n+            if (h3 >= 10) { c[offset3 + i * scale +  9]++; }\n+            if (h3 >= 11) { c[offset3 + i * scale + 10]++; }\n+            if (h3 >= 12) { c[offset3 + i * scale + 11]++; }\n+            if (h3 >= 13) { c[offset3 + i * scale + 12]++; }\n+            if (h3 >= 14) { c[offset3 + i * scale + 13]++; }\n+            if (h3 >= 15) { c[offset3 + i * scale + 14]++; }\n+            if (h3 >= 16) { c[offset3 + i * scale + 15]++; }\n+        }\n+        return new Object[]{ a, b, c };\n+    }\n+\n+    static Object[] testDDBCFH(byte[] a, char[] b, float[] c) {\n+        int init   = init_con_or_var();\n+        int limit  = limit_con_or_var();\n+        int stride = stride_con();\n+        int scale  = scale_con();\n+        int offset1 = offset1_con_or_var();\n+        int offset2 = offset2_con_or_var();\n+        int offset3 = offset3_con_or_var();\n+\n+        int h1 = hand_unrolling1_con();\n+        int h2 = hand_unrolling2_con();\n+        int h3 = hand_unrolling3_con();\n+\n+        for (int i = limit; i > init; i -= stride) {\n+            if (h1 >=  1) { a[offset1 + i * scale +  0]++; }\n+            if (h1 >=  2) { a[offset1 + i * scale +  1]++; }\n+            if (h1 >=  3) { a[offset1 + i * scale +  2]++; }\n+            if (h1 >=  4) { a[offset1 + i * scale +  3]++; }\n+            if (h1 >=  5) { a[offset1 + i * scale +  4]++; }\n+            if (h1 >=  6) { a[offset1 + i * scale +  5]++; }\n+            if (h1 >=  7) { a[offset1 + i * scale +  6]++; }\n+            if (h1 >=  8) { a[offset1 + i * scale +  7]++; }\n+            if (h1 >=  9) { a[offset1 + i * scale +  8]++; }\n+            if (h1 >= 10) { a[offset1 + i * scale +  9]++; }\n+            if (h1 >= 11) { a[offset1 + i * scale + 10]++; }\n+            if (h1 >= 12) { a[offset1 + i * scale + 11]++; }\n+            if (h1 >= 13) { a[offset1 + i * scale + 12]++; }\n+            if (h1 >= 14) { a[offset1 + i * scale + 13]++; }\n+            if (h1 >= 15) { a[offset1 + i * scale + 14]++; }\n+            if (h1 >= 16) { a[offset1 + i * scale + 15]++; }\n+\n+            if (h2 >=  1) { b[offset2 + i * scale +  0]++; }\n+            if (h2 >=  2) { b[offset2 + i * scale +  1]++; }\n+            if (h2 >=  3) { b[offset2 + i * scale +  2]++; }\n+            if (h2 >=  4) { b[offset2 + i * scale +  3]++; }\n+            if (h2 >=  5) { b[offset2 + i * scale +  4]++; }\n+            if (h2 >=  6) { b[offset2 + i * scale +  5]++; }\n+            if (h2 >=  7) { b[offset2 + i * scale +  6]++; }\n+            if (h2 >=  8) { b[offset2 + i * scale +  7]++; }\n+            if (h2 >=  9) { b[offset2 + i * scale +  8]++; }\n+            if (h2 >= 10) { b[offset2 + i * scale +  9]++; }\n+            if (h2 >= 11) { b[offset2 + i * scale + 10]++; }\n+            if (h2 >= 12) { b[offset2 + i * scale + 11]++; }\n+            if (h2 >= 13) { b[offset2 + i * scale + 12]++; }\n+            if (h2 >= 14) { b[offset2 + i * scale + 13]++; }\n+            if (h2 >= 15) { b[offset2 + i * scale + 14]++; }\n+            if (h2 >= 16) { b[offset2 + i * scale + 15]++; }\n+\n+            if (h3 >=  1) { c[offset3 + i * scale +  0]++; }\n+            if (h3 >=  2) { c[offset3 + i * scale +  1]++; }\n+            if (h3 >=  3) { c[offset3 + i * scale +  2]++; }\n+            if (h3 >=  4) { c[offset3 + i * scale +  3]++; }\n+            if (h3 >=  5) { c[offset3 + i * scale +  4]++; }\n+            if (h3 >=  6) { c[offset3 + i * scale +  5]++; }\n+            if (h3 >=  7) { c[offset3 + i * scale +  6]++; }\n+            if (h3 >=  8) { c[offset3 + i * scale +  7]++; }\n+            if (h3 >=  9) { c[offset3 + i * scale +  8]++; }\n+            if (h3 >= 10) { c[offset3 + i * scale +  9]++; }\n+            if (h3 >= 11) { c[offset3 + i * scale + 10]++; }\n+            if (h3 >= 12) { c[offset3 + i * scale + 11]++; }\n+            if (h3 >= 13) { c[offset3 + i * scale + 12]++; }\n+            if (h3 >= 14) { c[offset3 + i * scale + 13]++; }\n+            if (h3 >= 15) { c[offset3 + i * scale + 14]++; }\n+            if (h3 >= 16) { c[offset3 + i * scale + 15]++; }\n+        }\n+        return new Object[]{ a, b, c };\n+    }\n+\n+    static Object[] testUDBCFH(byte[] a, char[] b, float[] c) {\n+        int init   = init_con_or_var();\n+        int limit  = limit_con_or_var();\n+        int stride = stride_con();\n+        int scale  = scale_con();\n+        int x1 = opposite_direction_offset1_con_or_var();\n+        int x2 = opposite_direction_offset2_con_or_var();\n+        int x3 = opposite_direction_offset3_con_or_var();\n+\n+        int h1 = hand_unrolling1_con();\n+        int h2 = hand_unrolling2_con();\n+        int h3 = hand_unrolling3_con();\n+\n+        for (int i = init; i < limit; i += stride) {\n+            if (h1 >=  1) { a[x1 - i * scale +  0]++; }\n+            if (h1 >=  2) { a[x1 - i * scale +  1]++; }\n+            if (h1 >=  3) { a[x1 - i * scale +  2]++; }\n+            if (h1 >=  4) { a[x1 - i * scale +  3]++; }\n+            if (h1 >=  5) { a[x1 - i * scale +  4]++; }\n+            if (h1 >=  6) { a[x1 - i * scale +  5]++; }\n+            if (h1 >=  7) { a[x1 - i * scale +  6]++; }\n+            if (h1 >=  8) { a[x1 - i * scale +  7]++; }\n+            if (h1 >=  9) { a[x1 - i * scale +  8]++; }\n+            if (h1 >= 10) { a[x1 - i * scale +  9]++; }\n+            if (h1 >= 11) { a[x1 - i * scale + 10]++; }\n+            if (h1 >= 12) { a[x1 - i * scale + 11]++; }\n+            if (h1 >= 13) { a[x1 - i * scale + 12]++; }\n+            if (h1 >= 14) { a[x1 - i * scale + 13]++; }\n+            if (h1 >= 15) { a[x1 - i * scale + 14]++; }\n+            if (h1 >= 16) { a[x1 - i * scale + 15]++; }\n+\n+            if (h2 >=  1) { b[x2 - i * scale +  0]++; }\n+            if (h2 >=  2) { b[x2 - i * scale +  1]++; }\n+            if (h2 >=  3) { b[x2 - i * scale +  2]++; }\n+            if (h2 >=  4) { b[x2 - i * scale +  3]++; }\n+            if (h2 >=  5) { b[x2 - i * scale +  4]++; }\n+            if (h2 >=  6) { b[x2 - i * scale +  5]++; }\n+            if (h2 >=  7) { b[x2 - i * scale +  6]++; }\n+            if (h2 >=  8) { b[x2 - i * scale +  7]++; }\n+            if (h2 >=  9) { b[x2 - i * scale +  8]++; }\n+            if (h2 >= 10) { b[x2 - i * scale +  9]++; }\n+            if (h2 >= 11) { b[x2 - i * scale + 10]++; }\n+            if (h2 >= 12) { b[x2 - i * scale + 11]++; }\n+            if (h2 >= 13) { b[x2 - i * scale + 12]++; }\n+            if (h2 >= 14) { b[x2 - i * scale + 13]++; }\n+            if (h2 >= 15) { b[x2 - i * scale + 14]++; }\n+            if (h2 >= 16) { b[x2 - i * scale + 15]++; }\n+\n+            if (h3 >=  1) { c[x3 - i * scale +  0]++; }\n+            if (h3 >=  2) { c[x3 - i * scale +  1]++; }\n+            if (h3 >=  3) { c[x3 - i * scale +  2]++; }\n+            if (h3 >=  4) { c[x3 - i * scale +  3]++; }\n+            if (h3 >=  5) { c[x3 - i * scale +  4]++; }\n+            if (h3 >=  6) { c[x3 - i * scale +  5]++; }\n+            if (h3 >=  7) { c[x3 - i * scale +  6]++; }\n+            if (h3 >=  8) { c[x3 - i * scale +  7]++; }\n+            if (h3 >=  9) { c[x3 - i * scale +  8]++; }\n+            if (h3 >= 10) { c[x3 - i * scale +  9]++; }\n+            if (h3 >= 11) { c[x3 - i * scale + 10]++; }\n+            if (h3 >= 12) { c[x3 - i * scale + 11]++; }\n+            if (h3 >= 13) { c[x3 - i * scale + 12]++; }\n+            if (h3 >= 14) { c[x3 - i * scale + 13]++; }\n+            if (h3 >= 15) { c[x3 - i * scale + 14]++; }\n+            if (h3 >= 16) { c[x3 - i * scale + 15]++; }\n+        }\n+        return new Object[]{ a, b, c };\n+    }\n+\n+    static Object[] testDUBCFH(byte[] a, char[] b, float[] c) {\n+        int init   = init_con_or_var();\n+        int limit  = limit_con_or_var();\n+        int stride = stride_con();\n+        int scale  = scale_con();\n+        int x1 = opposite_direction_offset1_con_or_var();\n+        int x2 = opposite_direction_offset2_con_or_var();\n+        int x3 = opposite_direction_offset3_con_or_var();\n+\n+        int h1 = hand_unrolling1_con();\n+        int h2 = hand_unrolling2_con();\n+        int h3 = hand_unrolling3_con();\n+\n+        for (int i = limit; i > init; i -= stride) {\n+            if (h1 >=  1) { a[x1 - i * scale +  0]++; }\n+            if (h1 >=  2) { a[x1 - i * scale +  1]++; }\n+            if (h1 >=  3) { a[x1 - i * scale +  2]++; }\n+            if (h1 >=  4) { a[x1 - i * scale +  3]++; }\n+            if (h1 >=  5) { a[x1 - i * scale +  4]++; }\n+            if (h1 >=  6) { a[x1 - i * scale +  5]++; }\n+            if (h1 >=  7) { a[x1 - i * scale +  6]++; }\n+            if (h1 >=  8) { a[x1 - i * scale +  7]++; }\n+            if (h1 >=  9) { a[x1 - i * scale +  8]++; }\n+            if (h1 >= 10) { a[x1 - i * scale +  9]++; }\n+            if (h1 >= 11) { a[x1 - i * scale + 10]++; }\n+            if (h1 >= 12) { a[x1 - i * scale + 11]++; }\n+            if (h1 >= 13) { a[x1 - i * scale + 12]++; }\n+            if (h1 >= 14) { a[x1 - i * scale + 13]++; }\n+            if (h1 >= 15) { a[x1 - i * scale + 14]++; }\n+            if (h1 >= 16) { a[x1 - i * scale + 15]++; }\n+\n+            if (h2 >=  1) { b[x2 - i * scale +  0]++; }\n+            if (h2 >=  2) { b[x2 - i * scale +  1]++; }\n+            if (h2 >=  3) { b[x2 - i * scale +  2]++; }\n+            if (h2 >=  4) { b[x2 - i * scale +  3]++; }\n+            if (h2 >=  5) { b[x2 - i * scale +  4]++; }\n+            if (h2 >=  6) { b[x2 - i * scale +  5]++; }\n+            if (h2 >=  7) { b[x2 - i * scale +  6]++; }\n+            if (h2 >=  8) { b[x2 - i * scale +  7]++; }\n+            if (h2 >=  9) { b[x2 - i * scale +  8]++; }\n+            if (h2 >= 10) { b[x2 - i * scale +  9]++; }\n+            if (h2 >= 11) { b[x2 - i * scale + 10]++; }\n+            if (h2 >= 12) { b[x2 - i * scale + 11]++; }\n+            if (h2 >= 13) { b[x2 - i * scale + 12]++; }\n+            if (h2 >= 14) { b[x2 - i * scale + 13]++; }\n+            if (h2 >= 15) { b[x2 - i * scale + 14]++; }\n+            if (h2 >= 16) { b[x2 - i * scale + 15]++; }\n+\n+            if (h3 >=  1) { c[x3 - i * scale +  0]++; }\n+            if (h3 >=  2) { c[x3 - i * scale +  1]++; }\n+            if (h3 >=  3) { c[x3 - i * scale +  2]++; }\n+            if (h3 >=  4) { c[x3 - i * scale +  3]++; }\n+            if (h3 >=  5) { c[x3 - i * scale +  4]++; }\n+            if (h3 >=  6) { c[x3 - i * scale +  5]++; }\n+            if (h3 >=  7) { c[x3 - i * scale +  6]++; }\n+            if (h3 >=  8) { c[x3 - i * scale +  7]++; }\n+            if (h3 >=  9) { c[x3 - i * scale +  8]++; }\n+            if (h3 >= 10) { c[x3 - i * scale +  9]++; }\n+            if (h3 >= 11) { c[x3 - i * scale + 10]++; }\n+            if (h3 >= 12) { c[x3 - i * scale + 11]++; }\n+            if (h3 >= 13) { c[x3 - i * scale + 12]++; }\n+            if (h3 >= 14) { c[x3 - i * scale + 13]++; }\n+            if (h3 >= 15) { c[x3 - i * scale + 14]++; }\n+            if (h3 >= 16) { c[x3 - i * scale + 15]++; }\n+        }\n+        return new Object[]{ a, b, c };\n+    }\n+\n+    \/\/ -------------------- MIXED DIRECTION TRIPPLE --------------------\n+\n+    static Object[] testMMSFD(short[] a, float[] b, double[] c) {\n+        int init    = init_con_or_var();\n+        int limit   = limit_con_or_var();\n+        int stride  = stride_con();\n+        int scale   = scale_con();\n+        int offset1 = offset1_con_or_var();\n+        int offset2 = opposite_direction_offset2_con_or_var();\n+        int offset3 = offset3_con_or_var();\n+\n+        for (int i = init; i < limit; i += stride) {\n+            a[offset1 + i * scale]++;\n+            b[offset2 - i * scale]++;\n+            c[offset3 + i * scale]++;\n+        }\n+        return new Object[]{ a, b, c };\n+    }\n+\n+    \/\/ -------------------- UNSAFE --------------------\n+\n+    static Object[] testUU_unsafe_BasI(byte[] a) {\n+        int init   = init_con_or_var();\n+        int limit  = limit_con_or_var();\n+        int stride = stride_con();\n+        int scale  = scale_con();\n+        int offset = offset1_con_or_var();\n+\n+        for (int i = init; i < limit; i += stride) {\n+            int adr = UNSAFE.ARRAY_BYTE_BASE_OFFSET + offset + i * scale;\n+            int v = UNSAFE.getIntUnaligned(a, adr);\n+            UNSAFE.putIntUnaligned(a, adr, v + 1);\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    static Object[] testUU_unsafe_BasIH(byte[] a, byte[] b, byte[] c) {\n+        int init   = init_con_or_var();\n+        int limit  = limit_con_or_var();\n+        int stride = stride_con();\n+        int scale  = scale_con();\n+        int offset1 = offset1_con_or_var();\n+        int offset2 = offset2_con_or_var();\n+        int offset3 = offset3_con_or_var();\n+\n+        int h1 = hand_unrolling1_con();\n+        int h2 = hand_unrolling2_con();\n+        int h3 = hand_unrolling3_con();\n+\n+        for (int i = init; i < limit; i += stride) {\n+            int adr1 = UNSAFE.ARRAY_BYTE_BASE_OFFSET + offset1 + i * scale;\n+            int adr2 = UNSAFE.ARRAY_BYTE_BASE_OFFSET + offset2 + i * scale;\n+            int adr3 = UNSAFE.ARRAY_BYTE_BASE_OFFSET + offset3 + i * scale;\n+\n+            if (h1 >=  1) { UNSAFE.putIntUnaligned(a, adr1 +  0*4, UNSAFE.getIntUnaligned(a, adr1 +  0*4) + 1); }\n+            if (h1 >=  2) { UNSAFE.putIntUnaligned(a, adr1 +  1*4, UNSAFE.getIntUnaligned(a, adr1 +  1*4) + 1); }\n+            if (h1 >=  3) { UNSAFE.putIntUnaligned(a, adr1 +  2*4, UNSAFE.getIntUnaligned(a, adr1 +  2*4) + 1); }\n+            if (h1 >=  4) { UNSAFE.putIntUnaligned(a, adr1 +  3*4, UNSAFE.getIntUnaligned(a, adr1 +  3*4) + 1); }\n+            if (h1 >=  5) { UNSAFE.putIntUnaligned(a, adr1 +  4*4, UNSAFE.getIntUnaligned(a, adr1 +  4*4) + 1); }\n+            if (h1 >=  6) { UNSAFE.putIntUnaligned(a, adr1 +  5*4, UNSAFE.getIntUnaligned(a, adr1 +  5*4) + 1); }\n+            if (h1 >=  7) { UNSAFE.putIntUnaligned(a, adr1 +  6*4, UNSAFE.getIntUnaligned(a, adr1 +  6*4) + 1); }\n+            if (h1 >=  8) { UNSAFE.putIntUnaligned(a, adr1 +  7*4, UNSAFE.getIntUnaligned(a, adr1 +  7*4) + 1); }\n+            if (h1 >=  9) { UNSAFE.putIntUnaligned(a, adr1 +  8*4, UNSAFE.getIntUnaligned(a, adr1 +  8*4) + 1); }\n+            if (h1 >= 10) { UNSAFE.putIntUnaligned(a, adr1 +  9*4, UNSAFE.getIntUnaligned(a, adr1 +  9*4) + 1); }\n+            if (h1 >= 11) { UNSAFE.putIntUnaligned(a, adr1 + 10*4, UNSAFE.getIntUnaligned(a, adr1 + 10*4) + 1); }\n+            if (h1 >= 12) { UNSAFE.putIntUnaligned(a, adr1 + 11*4, UNSAFE.getIntUnaligned(a, adr1 + 11*4) + 1); }\n+            if (h1 >= 13) { UNSAFE.putIntUnaligned(a, adr1 + 12*4, UNSAFE.getIntUnaligned(a, adr1 + 12*4) + 1); }\n+            if (h1 >= 14) { UNSAFE.putIntUnaligned(a, adr1 + 13*4, UNSAFE.getIntUnaligned(a, adr1 + 13*4) + 1); }\n+            if (h1 >= 15) { UNSAFE.putIntUnaligned(a, adr1 + 14*4, UNSAFE.getIntUnaligned(a, adr1 + 14*4) + 1); }\n+            if (h1 >= 16) { UNSAFE.putIntUnaligned(a, adr1 + 15*4, UNSAFE.getIntUnaligned(a, adr1 + 15*4) + 1); }\n+\n+            if (h2 >=  1) { UNSAFE.putIntUnaligned(b, adr2 +  0*4, UNSAFE.getIntUnaligned(b, adr2 +  0*4) + 1); }\n+            if (h2 >=  2) { UNSAFE.putIntUnaligned(b, adr2 +  1*4, UNSAFE.getIntUnaligned(b, adr2 +  1*4) + 1); }\n+            if (h2 >=  3) { UNSAFE.putIntUnaligned(b, adr2 +  2*4, UNSAFE.getIntUnaligned(b, adr2 +  2*4) + 1); }\n+            if (h2 >=  4) { UNSAFE.putIntUnaligned(b, adr2 +  3*4, UNSAFE.getIntUnaligned(b, adr2 +  3*4) + 1); }\n+            if (h2 >=  5) { UNSAFE.putIntUnaligned(b, adr2 +  4*4, UNSAFE.getIntUnaligned(b, adr2 +  4*4) + 1); }\n+            if (h2 >=  6) { UNSAFE.putIntUnaligned(b, adr2 +  5*4, UNSAFE.getIntUnaligned(b, adr2 +  5*4) + 1); }\n+            if (h2 >=  7) { UNSAFE.putIntUnaligned(b, adr2 +  6*4, UNSAFE.getIntUnaligned(b, adr2 +  6*4) + 1); }\n+            if (h2 >=  8) { UNSAFE.putIntUnaligned(b, adr2 +  7*4, UNSAFE.getIntUnaligned(b, adr2 +  7*4) + 1); }\n+            if (h2 >=  9) { UNSAFE.putIntUnaligned(b, adr2 +  8*4, UNSAFE.getIntUnaligned(b, adr2 +  8*4) + 1); }\n+            if (h2 >= 10) { UNSAFE.putIntUnaligned(b, adr2 +  9*4, UNSAFE.getIntUnaligned(b, adr2 +  9*4) + 1); }\n+            if (h2 >= 11) { UNSAFE.putIntUnaligned(b, adr2 + 10*4, UNSAFE.getIntUnaligned(b, adr2 + 10*4) + 1); }\n+            if (h2 >= 12) { UNSAFE.putIntUnaligned(b, adr2 + 11*4, UNSAFE.getIntUnaligned(b, adr2 + 11*4) + 1); }\n+            if (h2 >= 13) { UNSAFE.putIntUnaligned(b, adr2 + 12*4, UNSAFE.getIntUnaligned(b, adr2 + 12*4) + 1); }\n+            if (h2 >= 14) { UNSAFE.putIntUnaligned(b, adr2 + 13*4, UNSAFE.getIntUnaligned(b, adr2 + 13*4) + 1); }\n+            if (h2 >= 15) { UNSAFE.putIntUnaligned(b, adr2 + 14*4, UNSAFE.getIntUnaligned(b, adr2 + 14*4) + 1); }\n+            if (h2 >= 16) { UNSAFE.putIntUnaligned(b, adr2 + 15*4, UNSAFE.getIntUnaligned(b, adr2 + 15*4) + 1); }\n+\n+            if (h3 >=  1) { UNSAFE.putIntUnaligned(c, adr3 +  0*4, UNSAFE.getIntUnaligned(c, adr3 +  0*4) + 1); }\n+            if (h3 >=  2) { UNSAFE.putIntUnaligned(c, adr3 +  1*4, UNSAFE.getIntUnaligned(c, adr3 +  1*4) + 1); }\n+            if (h3 >=  3) { UNSAFE.putIntUnaligned(c, adr3 +  2*4, UNSAFE.getIntUnaligned(c, adr3 +  2*4) + 1); }\n+            if (h3 >=  4) { UNSAFE.putIntUnaligned(c, adr3 +  3*4, UNSAFE.getIntUnaligned(c, adr3 +  3*4) + 1); }\n+            if (h3 >=  5) { UNSAFE.putIntUnaligned(c, adr3 +  4*4, UNSAFE.getIntUnaligned(c, adr3 +  4*4) + 1); }\n+            if (h3 >=  6) { UNSAFE.putIntUnaligned(c, adr3 +  5*4, UNSAFE.getIntUnaligned(c, adr3 +  5*4) + 1); }\n+            if (h3 >=  7) { UNSAFE.putIntUnaligned(c, adr3 +  6*4, UNSAFE.getIntUnaligned(c, adr3 +  6*4) + 1); }\n+            if (h3 >=  8) { UNSAFE.putIntUnaligned(c, adr3 +  7*4, UNSAFE.getIntUnaligned(c, adr3 +  7*4) + 1); }\n+            if (h3 >=  9) { UNSAFE.putIntUnaligned(c, adr3 +  8*4, UNSAFE.getIntUnaligned(c, adr3 +  8*4) + 1); }\n+            if (h3 >= 10) { UNSAFE.putIntUnaligned(c, adr3 +  9*4, UNSAFE.getIntUnaligned(c, adr3 +  9*4) + 1); }\n+            if (h3 >= 11) { UNSAFE.putIntUnaligned(c, adr3 + 10*4, UNSAFE.getIntUnaligned(c, adr3 + 10*4) + 1); }\n+            if (h3 >= 12) { UNSAFE.putIntUnaligned(c, adr3 + 11*4, UNSAFE.getIntUnaligned(c, adr3 + 11*4) + 1); }\n+            if (h3 >= 13) { UNSAFE.putIntUnaligned(c, adr3 + 12*4, UNSAFE.getIntUnaligned(c, adr3 + 12*4) + 1); }\n+            if (h3 >= 14) { UNSAFE.putIntUnaligned(c, adr3 + 13*4, UNSAFE.getIntUnaligned(c, adr3 + 13*4) + 1); }\n+            if (h3 >= 15) { UNSAFE.putIntUnaligned(c, adr3 + 14*4, UNSAFE.getIntUnaligned(c, adr3 + 14*4) + 1); }\n+            if (h3 >= 16) { UNSAFE.putIntUnaligned(c, adr3 + 15*4, UNSAFE.getIntUnaligned(c, adr3 + 15*4) + 1); }\n+        }\n+        return new Object[]{ a, b, c };\n+    }\n+\n+    static byte[] generateB() {\n+        byte[] a = new byte[RANGE_CON];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = (byte)random.nextInt();\n+        }\n+        return a;\n+    }\n+\n+    static char[] generateC() {\n+        char[] a = new char[RANGE_CON];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = (char)random.nextInt();\n+        }\n+        return a;\n+    }\n+\n+    static short[] generateS() {\n+        short[] a = new short[RANGE_CON];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = (short)random.nextInt();\n+        }\n+        return a;\n+    }\n+\n+    static int[] generateI() {\n+        int[] a = new int[RANGE_CON];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = random.nextInt();\n+        }\n+        return a;\n+    }\n+\n+    static long[] generateL() {\n+        long[] a = new long[RANGE_CON];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = random.nextLong();\n+        }\n+        return a;\n+    }\n+\n+    static float[] generateF() {\n+        float[] a = new float[RANGE_CON];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = Float.intBitsToFloat(random.nextInt());\n+        }\n+        return a;\n+    }\n+\n+    static double[] generateD() {\n+        double[] a = new double[RANGE_CON];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = Double.longBitsToDouble(random.nextLong());\n+        }\n+        return a;\n+    }\n+\n+    static void verify(String name, Object[] gold, Object[] result) {\n+        if (gold.length != result.length) {\n+            throw new RuntimeException(\"verify \" + name + \": not the same number of outputs: gold.length = \" +\n+                                       gold.length + \", result.length = \" + result.length);\n+        }\n+        for (int i = 0; i < gold.length; i++) {\n+            Object g = gold[i];\n+            Object r = result[i];\n+            if (g.getClass() != r.getClass() || !g.getClass().isArray() || !r.getClass().isArray()) {\n+                throw new RuntimeException(\"verify \" + name + \": must both be array of same type:\" +\n+                                           \" gold[\" + i + \"].getClass() = \" + g.getClass().getSimpleName() +\n+                                           \" result[\" + i + \"].getClass() = \" + r.getClass().getSimpleName());\n+            }\n+            if (g == r) {\n+                throw new RuntimeException(\"verify \" + name + \": should be two separate arrays (with identical content):\" +\n+                                           \" gold[\" + i + \"] == result[\" + i + \"]\");\n+            }\n+            if (Array.getLength(g) != Array.getLength(r)) {\n+                    throw new RuntimeException(\"verify \" + name + \": arrays must have same length:\" +\n+                                           \" gold[\" + i + \"].length = \" + Array.getLength(g) +\n+                                           \" result[\" + i + \"].length = \" + Array.getLength(r));\n+            }\n+            Class c = g.getClass().getComponentType();\n+            if (c == byte.class) {\n+                verifyB(name, i, (byte[])g, (byte[])r);\n+            } else if (c == char.class) {\n+                verifyC(name, i, (char[])g, (char[])r);\n+            } else if (c == short.class) {\n+                verifyS(name, i, (short[])g, (short[])r);\n+            } else if (c == int.class) {\n+                verifyI(name, i, (int[])g, (int[])r);\n+            } else if (c == long.class) {\n+                verifyL(name, i, (long[])g, (long[])r);\n+            } else if (c == float.class) {\n+                verifyF(name, i, (float[])g, (float[])r);\n+            } else if (c == double.class) {\n+                verifyD(name, i, (double[])g, (double[])r);\n+            } else {\n+                throw new RuntimeException(\"verify \" + name + \": array type not supported for verify:\" +\n+                                       \" gold[\" + i + \"].getClass() = \" + g.getClass().getSimpleName() +\n+                                       \" result[\" + i + \"].getClass() = \" + r.getClass().getSimpleName());\n+            }\n+        }\n+    }\n+\n+    static void verifyB(String name, int i, byte[] g, byte[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verifyB \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    static void verifyC(String name, int i, char[] g, char[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verifyC \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    static void verifyS(String name, int i, short[] g, short[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verifyS \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    static void verifyI(String name, int i, int[] g, int[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verifyI \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    static void verifyL(String name, int i, long[] g, long[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verifyL \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    static void verifyF(String name, int i, float[] g, float[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            int gv = UNSAFE.getInt(g, UNSAFE.ARRAY_FLOAT_BASE_OFFSET + 4 * j);\n+            int rv = UNSAFE.getInt(r, UNSAFE.ARRAY_FLOAT_BASE_OFFSET + 4 * j);\n+            if (gv != rv) {\n+                throw new RuntimeException(\"verifyF \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + gv +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + rv);\n+            }\n+        }\n+    }\n+\n+    static void verifyD(String name, int i, double[] g, double[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            long gv = UNSAFE.getLong(g, UNSAFE.ARRAY_DOUBLE_BASE_OFFSET + 8 * j);\n+            long rv = UNSAFE.getLong(r, UNSAFE.ARRAY_DOUBLE_BASE_OFFSET + 8 * j);\n+            if (gv != rv) {\n+                throw new RuntimeException(\"verifyF \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + gv +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + rv);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAlignVectorFuzzer.java","additions":1353,"deletions":0,"binary":false,"changes":1353,"status":"added"},{"patch":"@@ -30,1 +30,1 @@\n- *       https:\/\/bugs.openjdk.org\/browse\/JDK-8312570\n+ *       https:\/\/bugs.openjdk.org\/browse\/JDK-8310190\n@@ -52,2 +52,1 @@\n- * the CPU-features. Thus, we have a positive and negative IR rule per\n- * CPU-feature for each test.\n+ * the CPU-features.\n@@ -69,5 +68,1 @@\n- * With '-XX:+AlignVector', we would like to check that we vectorize exactly iff:\n- *     byte_offset % actual_vector_width == 0\n- * Because all vector_widths are powers of 2, this is equivalent to:\n- *     pow2_factor(byte_offset) >= actual_vector_width\n- * where pow2_factor computes the largest power of 2 that is a factor of the number.\n+ * With '-XX:+AlignVector' we do the following:\n@@ -75,2 +70,32 @@\n- * Under these assumptions, we know there must be vectorization:\n- *     pow2_factor(byte_offset) >= vector_width\n+ * Must vectorize cleanly if:\n+ *   1) guaranteed no misalignment AND\n+ *   2) guaratneed no cyclic dependency\n+ *\n+ * Must not vectorize at all if:\n+ *   1) guaranteed misalignment AND\n+ *   2) guaranteed no cyclic dependency\n+ *\n+ * We could imagine a case with cyclic dependency, where C2 detects\n+ * that only the first load is needed, and so no vectorization is\n+ * required for it, and hence the store vector can be aligned.\n+ *\n+ * The alignment criteria is\n+ *     byte_offset % aw == 0\n+ * where align width (aw) is\n+ *     aw = min(actual_vector_width, ObjectAlignmentInBytes)\n+ * For simplicity, we assume that ObjectAlignmentInBytes == 8,\n+ * which currently can only be changed manually and then no IR\n+ * rule is run.\n+ * This allows us to do the computation statically.\n+ * Further, we define:\n+ *     aw_min = min(min_vector_width, ObjectAlignmentInBytes)\n+ *     aw_max = min(vector_width, ObjectAlignmentInBytes)\n+ *     aw_min <= aw <= aw_max\n+ *\n+ * Again, we have no cyclic dependency, except when:\n+ *     byte_offset > 0 and p.vector_width > byte_offset\n+ * Here we must ensure that:\n+ *     byte_offset >= MaxVectorSize\n+ *\n+ * Guaranteed no misalignment:\n+ *     byte_offset % aw_max == 0\n@@ -78,3 +103,1 @@\n- *         pow2_factor(byte_offset) >= actual_vector_width\n- *     MaxVectorSize >= min_vector_size\n- *       else any vectorization is impossible.\n+ *         byte_offset % aw == 0\n@@ -82,4 +105,2 @@\n- * And under the following conditions no vectorization is possible:\n- *     byte_offset < 0: No cyclic dependency.\n- *       Cyclic dependency could lead to Load removals, then only the store is vectorized.\n- *     byte_offset % min_vector_width != 0\n+ * Guaranteed misalignment:\n+ *     byte_offset % aw_min != 0\n@@ -87,1 +108,1 @@\n- *         byte_offset % actual_vector_width != 0\n+ *         byte_offset % aw != 0\n@@ -93,1 +114,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -102,1 +123,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -111,1 +132,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -122,1 +143,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -133,1 +154,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -144,1 +165,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -155,1 +176,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -166,1 +187,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -177,1 +198,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -188,1 +209,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -199,1 +220,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -210,1 +231,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -221,1 +242,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -232,1 +253,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -243,1 +264,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -254,1 +275,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -265,1 +286,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -276,1 +297,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -287,1 +308,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -298,1 +319,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -309,1 +330,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -320,1 +341,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -331,1 +352,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -342,1 +363,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -353,1 +374,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -364,1 +385,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -375,1 +396,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -385,1 +406,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -395,1 +416,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -405,1 +426,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -415,1 +436,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -425,1 +446,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -435,1 +456,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -445,1 +466,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -455,1 +476,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -465,1 +486,1 @@\n- * @bug 8298935 8308606 8310308 8312570\n+ * @bug 8298935 8308606 8310308 8312570 8310190\n@@ -1395,0 +1416,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -1399,0 +1424,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -1403,0 +1432,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -1407,0 +1440,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -1411,0 +1448,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -1431,1 +1472,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1439,1 +1480,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1447,1 +1488,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1455,1 +1496,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1463,1 +1504,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1486,0 +1527,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -1489,0 +1534,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -1492,0 +1541,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -1495,0 +1548,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -1498,0 +1555,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -1518,0 +1579,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -1522,0 +1587,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -1526,0 +1595,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -1530,0 +1603,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -1534,0 +1611,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -1553,1 +1634,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n@@ -1558,1 +1643,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n@@ -1563,1 +1652,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n@@ -1568,1 +1661,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n@@ -1573,1 +1670,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n@@ -1595,1 +1696,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1603,1 +1704,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1611,1 +1712,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1619,1 +1720,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1627,1 +1728,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1652,0 +1753,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -1657,0 +1762,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -1662,0 +1771,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -1667,0 +1780,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -1672,0 +1789,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -1692,0 +1813,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -1696,0 +1821,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -1700,0 +1829,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -1704,0 +1837,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -1708,0 +1845,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -1728,1 +1869,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -1737,0 +1878,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -1742,0 +1887,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -1746,1 +1895,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -1755,0 +1904,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -1775,1 +1928,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1783,1 +1936,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1791,1 +1944,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1799,1 +1952,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1807,1 +1960,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -1831,0 +1984,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -1836,0 +1993,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 28\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -1841,0 +2002,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 28\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -1845,0 +2010,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -1850,0 +2019,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 28\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -1870,0 +2043,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -1874,0 +2051,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -1878,0 +2059,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -1882,0 +2067,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -1886,0 +2075,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -1906,1 +2099,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -1914,1 +2107,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -1923,0 +2116,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -1927,1 +2124,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -1936,0 +2133,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -1956,0 +2157,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -1960,0 +2165,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -1964,0 +2173,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -1968,0 +2181,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -1972,0 +2189,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -1992,0 +2213,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -1996,0 +2221,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2001,0 +2230,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 56\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2005,0 +2238,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -2010,0 +2247,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 56\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2030,0 +2271,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -2034,0 +2279,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2038,0 +2287,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2042,0 +2295,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -2046,0 +2303,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2066,1 +2327,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2074,1 +2335,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2082,1 +2343,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2090,1 +2351,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2099,0 +2360,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 64\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2119,0 +2384,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -2123,0 +2392,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2127,0 +2400,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2131,0 +2408,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -2135,0 +2416,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2155,0 +2440,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -2159,0 +2448,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2163,0 +2456,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2167,0 +2464,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -2172,0 +2473,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 72\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2192,0 +2497,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -2196,0 +2505,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2200,0 +2513,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2204,0 +2521,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -2208,0 +2529,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2228,1 +2553,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2236,0 +2561,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2240,0 +2569,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2244,1 +2577,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2253,0 +2586,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 80\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2273,1 +2610,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2281,1 +2618,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2289,1 +2626,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2297,1 +2634,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2305,1 +2642,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2329,0 +2666,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -2333,0 +2674,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2337,0 +2682,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2341,0 +2690,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -2346,0 +2699,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 124\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2366,0 +2723,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -2370,0 +2731,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2374,0 +2739,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2378,0 +2747,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -2382,0 +2755,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2402,1 +2779,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2410,1 +2787,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2418,1 +2795,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2426,1 +2803,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2435,0 +2812,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 128\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2455,1 +2836,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2463,1 +2844,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2471,1 +2852,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2479,1 +2860,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2487,1 +2868,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2511,0 +2892,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -2515,0 +2900,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2519,0 +2908,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2523,2 +2916,6 @@\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 252 can lead to cyclic dependency\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n+    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n+    \/\/   positive byte_offset 252 can lead to cyclic dependency\n@@ -2528,0 +2925,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 252\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2548,0 +2949,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -2552,0 +2957,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2556,0 +2965,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2560,0 +2973,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -2564,0 +2981,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2584,1 +3005,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2592,1 +3013,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2600,1 +3021,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2608,1 +3029,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2616,1 +3037,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2640,1 +3061,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2648,1 +3069,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2656,1 +3077,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2664,1 +3085,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2672,1 +3093,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2696,0 +3117,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -2700,0 +3125,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2704,0 +3133,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2708,0 +3141,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -2712,0 +3149,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2732,0 +3173,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -2736,0 +3181,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2740,0 +3189,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2744,0 +3197,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -2748,0 +3205,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2768,1 +3229,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2776,1 +3237,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2784,1 +3245,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2792,1 +3253,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2800,1 +3261,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2824,1 +3285,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2832,1 +3293,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2840,1 +3301,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2848,1 +3309,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2856,1 +3317,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -2880,0 +3341,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -2884,0 +3349,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2888,0 +3357,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2892,0 +3365,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -2896,0 +3373,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2916,0 +3397,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -2920,0 +3405,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -2924,0 +3413,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -2928,0 +3421,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -2932,0 +3429,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -2952,1 +3453,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2960,1 +3461,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2968,1 +3469,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2976,1 +3477,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -2984,1 +3485,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3008,0 +3509,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -3012,0 +3517,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -3016,0 +3525,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3020,0 +3533,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -3024,0 +3541,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3044,3 +3565,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3052,3 +3573,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3060,3 +3581,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3068,3 +3589,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3076,3 +3597,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3099,0 +3620,2 @@\n+    \/\/   Expect alignment.\n+    \/\/   No positive IR rule: conditions impossible.\n@@ -3102,0 +3625,2 @@\n+    \/\/   Expect alignment.\n+    \/\/   No positive IR rule: conditions impossible.\n@@ -3105,0 +3630,2 @@\n+    \/\/   Expect alignment.\n+    \/\/   No positive IR rule: conditions impossible.\n@@ -3108,0 +3635,2 @@\n+    \/\/   Expect alignment.\n+    \/\/   No positive IR rule: conditions impossible.\n@@ -3111,0 +3640,2 @@\n+    \/\/   Expect alignment.\n+    \/\/   No positive IR rule: conditions impossible.\n@@ -3131,0 +3662,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -3135,0 +3670,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -3139,0 +3678,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3143,0 +3686,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -3147,0 +3694,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3167,1 +3718,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3174,1 +3725,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"16\"},\n@@ -3179,1 +3734,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"16\"},\n@@ -3185,1 +3744,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3192,1 +3751,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"16\"},\n@@ -3214,3 +3777,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3222,3 +3785,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3230,3 +3793,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3238,3 +3801,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3246,3 +3809,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3270,0 +3833,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -3275,0 +3842,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -3280,0 +3851,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3284,0 +3859,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -3289,0 +3868,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3309,0 +3892,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -3313,0 +3900,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -3317,0 +3908,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3321,0 +3916,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -3325,0 +3924,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3345,1 +3948,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3353,1 +3956,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3362,0 +3965,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3366,1 +3973,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3375,0 +3982,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3395,3 +4006,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3403,3 +4014,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3411,3 +4022,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3419,3 +4030,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3427,3 +4038,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3451,0 +4062,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -3455,0 +4070,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -3460,0 +4079,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 56\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3464,0 +4087,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -3469,0 +4096,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 56\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3489,0 +4120,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -3493,0 +4128,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -3497,0 +4136,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3501,0 +4144,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -3505,0 +4152,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3525,1 +4176,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3533,1 +4184,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3541,1 +4192,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3549,1 +4200,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3558,0 +4209,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 64\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3578,0 +4233,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -3582,0 +4241,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -3586,0 +4249,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3590,0 +4257,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -3594,0 +4265,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3614,1 +4289,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3622,0 +4297,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -3626,0 +4305,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3630,1 +4313,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3639,0 +4322,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 112\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3659,0 +4346,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -3663,1 +4354,5 @@\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n@@ -3667,0 +4362,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3671,0 +4370,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -3675,0 +4378,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3695,1 +4402,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3703,1 +4410,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3711,1 +4418,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3719,1 +4426,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3728,0 +4435,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 128\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3748,0 +4459,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -3752,0 +4467,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -3756,0 +4475,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3760,0 +4483,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -3764,0 +4491,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3784,1 +4515,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3792,0 +4523,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -3796,0 +4531,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3800,1 +4539,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3809,0 +4548,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 144\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3829,0 +4572,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -3833,0 +4580,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -3837,0 +4588,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3841,0 +4596,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -3845,0 +4604,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3865,1 +4628,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3873,1 +4636,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3881,0 +4644,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3885,1 +4652,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -3894,0 +4661,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 160\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -3914,3 +4685,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3922,3 +4693,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3930,3 +4701,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3938,3 +4709,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3946,3 +4717,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -3970,0 +4741,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -3974,0 +4749,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -3978,0 +4757,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -3982,0 +4765,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -3987,0 +4774,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 248\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -4007,0 +4798,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -4011,0 +4806,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -4015,0 +4814,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -4019,0 +4822,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -4023,0 +4830,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -4043,1 +4854,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4051,1 +4862,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4059,1 +4870,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4067,1 +4878,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4075,1 +4886,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4099,3 +4910,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4107,3 +4918,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4115,3 +4926,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4123,3 +4934,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4131,3 +4942,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4155,0 +4966,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -4159,0 +4974,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -4163,0 +4982,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -4167,0 +4990,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -4171,0 +4998,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -4191,0 +5022,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -4195,0 +5030,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -4199,0 +5038,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -4203,0 +5046,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -4207,0 +5054,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -4227,1 +5078,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4235,1 +5086,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4243,1 +5094,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4251,1 +5102,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4259,1 +5110,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4283,3 +5134,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4291,3 +5142,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4299,3 +5150,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4307,3 +5158,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4315,3 +5166,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4339,0 +5190,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -4343,0 +5198,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -4347,0 +5206,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -4351,0 +5214,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -4355,0 +5222,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -4375,0 +5246,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -4379,0 +5254,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -4383,0 +5262,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -4387,0 +5270,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -4391,0 +5278,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -4411,1 +5302,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4419,1 +5310,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4427,1 +5318,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4435,1 +5326,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4443,1 +5334,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4467,3 +5358,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4475,3 +5366,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4483,3 +5374,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4491,3 +5382,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4499,3 +5390,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_L, IRNode.ADD_VL, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -4523,0 +5414,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -4527,0 +5422,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -4531,0 +5430,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -4535,0 +5438,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -4539,0 +5446,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -4559,0 +5470,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -4563,0 +5478,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n@@ -4567,0 +5486,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -4571,0 +5494,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -4575,0 +5502,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -4595,1 +5526,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4603,1 +5534,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4611,1 +5542,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4619,1 +5550,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4627,1 +5558,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -4651,0 +5582,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -4655,0 +5590,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -4659,0 +5598,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -4663,0 +5606,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -4667,0 +5614,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -4687,1 +5638,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -4695,1 +5646,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -4703,1 +5654,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -4711,1 +5662,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -4719,1 +5670,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -4742,0 +5693,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -4745,0 +5700,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -4748,0 +5707,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -4751,0 +5714,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -4754,0 +5721,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -4774,0 +5745,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -4778,0 +5750,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -4782,0 +5755,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -4786,0 +5760,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -4790,0 +5765,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -4809,1 +5785,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -4811,0 +5787,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -4814,1 +5791,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -4816,0 +5793,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -4819,1 +5797,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -4821,0 +5799,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -4824,1 +5803,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -4826,0 +5805,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -4829,1 +5809,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -4831,0 +5811,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -4851,1 +5832,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -4859,1 +5840,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -4867,1 +5848,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -4875,1 +5856,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -4883,1 +5864,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -4908,0 +5889,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -4913,0 +5898,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -4918,0 +5907,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -4923,0 +5916,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -4928,0 +5925,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -4948,0 +5949,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -4952,0 +5957,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -4956,0 +5965,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -4960,0 +5973,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -4964,0 +5981,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -4985,0 +6006,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -4990,0 +6015,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -4995,0 +6024,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5000,0 +6033,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -5005,0 +6042,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5025,1 +6066,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5033,1 +6074,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5041,1 +6082,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5049,1 +6090,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5057,1 +6098,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5082,0 +6123,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -5087,0 +6132,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -5092,0 +6141,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5097,0 +6150,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -5102,0 +6159,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5122,0 +6183,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -5126,0 +6191,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -5130,0 +6199,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5134,0 +6207,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -5138,0 +6215,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5158,1 +6239,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -5167,0 +6248,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -5172,0 +6257,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5176,1 +6265,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -5185,0 +6274,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5205,0 +6298,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5209,0 +6303,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5213,0 +6308,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5217,0 +6313,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5221,0 +6318,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5241,0 +6339,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5246,0 +6345,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5251,0 +6351,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5255,0 +6356,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5260,0 +6362,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5280,0 +6383,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -5284,0 +6391,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -5288,0 +6399,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5292,0 +6407,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -5296,0 +6415,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5316,1 +6439,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -5324,1 +6447,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -5333,0 +6456,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5337,1 +6464,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -5346,0 +6473,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5366,0 +6497,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5370,0 +6502,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5374,0 +6507,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5378,0 +6512,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5382,0 +6517,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5402,0 +6538,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5406,0 +6543,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5411,0 +6549,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5415,0 +6554,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5420,0 +6560,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -5440,0 +6581,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -5444,0 +6589,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -5448,0 +6597,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5452,0 +6605,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -5456,0 +6613,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5476,0 +6637,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -5480,0 +6645,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -5485,0 +6654,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 40\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5489,0 +6662,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -5494,0 +6671,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 40\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5514,1 +6695,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5522,1 +6703,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5530,1 +6711,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5538,1 +6719,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5546,1 +6727,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5570,0 +6751,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -5574,0 +6759,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -5579,0 +6768,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 62\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5583,0 +6776,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -5588,0 +6785,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 62\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5608,0 +6809,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -5612,0 +6817,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -5616,0 +6825,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5620,0 +6833,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -5624,0 +6841,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5644,1 +6865,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -5652,1 +6873,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -5660,1 +6881,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -5668,1 +6889,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -5677,0 +6898,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 64\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5697,1 +6922,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5705,1 +6930,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5713,1 +6938,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5721,1 +6946,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5729,1 +6954,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5753,0 +6978,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -5757,0 +6986,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -5761,0 +6994,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5765,0 +7002,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -5770,0 +7011,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 126\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5790,0 +7035,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -5794,0 +7043,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -5798,0 +7051,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5802,0 +7059,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -5806,0 +7067,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5826,1 +7091,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -5834,1 +7099,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -5842,1 +7107,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -5850,1 +7115,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -5859,0 +7124,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 128\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5879,1 +7148,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5887,1 +7156,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5895,1 +7164,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5903,1 +7172,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5911,1 +7180,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -5935,0 +7204,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -5939,0 +7212,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -5943,0 +7220,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5947,0 +7228,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -5952,0 +7237,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 130\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -5972,0 +7261,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -5976,0 +7269,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -5980,0 +7277,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -5984,0 +7285,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -5988,0 +7293,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -6008,1 +7317,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6016,1 +7325,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6024,1 +7333,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6032,1 +7341,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6040,1 +7349,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6064,1 +7373,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6072,1 +7381,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6080,1 +7389,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6088,1 +7397,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6096,1 +7405,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6120,0 +7429,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -6124,0 +7437,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -6128,0 +7445,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -6132,0 +7453,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -6136,0 +7461,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -6156,0 +7485,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -6160,0 +7493,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -6164,0 +7501,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -6168,0 +7509,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -6172,0 +7517,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -6192,1 +7541,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6200,1 +7549,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6208,1 +7557,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6216,1 +7565,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6224,0 +7573,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -6244,0 +7597,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -6248,0 +7605,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -6252,0 +7613,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -6256,0 +7621,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -6260,2 +7629,6 @@\n-    public static void testCharP0(char[] data) {\n-        for (int j = 0; j < RANGE; j++) {\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n+    public static void testCharP0(char[] data) {\n+        for (int j = 0; j < RANGE; j++) {\n@@ -6280,1 +7653,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6288,1 +7661,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6296,1 +7669,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6304,1 +7677,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6312,1 +7685,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6335,0 +7708,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -6338,0 +7715,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -6341,0 +7722,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -6344,0 +7729,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -6347,0 +7736,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -6367,0 +7760,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6371,0 +7765,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6375,0 +7770,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6379,0 +7775,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6383,0 +7780,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6402,1 +7800,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -6404,0 +7802,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6407,1 +7806,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -6409,0 +7808,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6412,1 +7812,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -6414,0 +7814,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6417,1 +7818,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -6419,0 +7820,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6422,1 +7824,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -6424,0 +7826,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6444,1 +7847,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6452,1 +7855,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6460,1 +7863,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6468,1 +7871,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6476,1 +7879,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6501,0 +7904,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -6506,0 +7913,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -6511,0 +7922,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -6516,0 +7931,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -6521,0 +7940,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -6541,0 +7964,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -6545,0 +7972,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -6549,0 +7980,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -6553,0 +7988,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -6557,0 +7996,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -6578,0 +8021,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -6583,0 +8030,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -6588,0 +8039,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -6593,0 +8048,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -6598,0 +8057,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -6618,1 +8081,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6626,1 +8089,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6634,1 +8097,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6642,1 +8105,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6650,1 +8113,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -6675,0 +8138,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -6680,0 +8147,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -6685,0 +8156,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -6690,0 +8165,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -6695,0 +8174,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -6715,0 +8198,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -6719,0 +8206,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -6723,0 +8214,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -6727,0 +8222,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -6731,0 +8230,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -6751,1 +8254,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6760,0 +8263,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -6765,0 +8272,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -6769,1 +8280,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6778,0 +8289,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -6798,0 +8313,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6802,0 +8318,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6806,0 +8323,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6810,0 +8328,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6814,0 +8333,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6834,0 +8354,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6839,0 +8360,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6844,0 +8366,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6848,0 +8371,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6853,0 +8377,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6873,0 +8398,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -6877,0 +8406,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -6881,0 +8414,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -6885,0 +8422,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -6889,0 +8430,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -6909,1 +8454,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6917,1 +8462,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6926,0 +8471,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -6930,1 +8479,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -6939,0 +8488,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -6959,0 +8512,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6963,0 +8517,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6967,0 +8522,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6971,0 +8527,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6975,0 +8532,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6995,0 +8553,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -6999,0 +8558,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -7004,0 +8564,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -7008,0 +8569,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -7013,0 +8575,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -7033,0 +8596,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -7037,0 +8604,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -7041,0 +8612,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -7045,0 +8620,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -7049,0 +8628,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7069,0 +8652,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -7073,0 +8660,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -7078,0 +8669,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 40\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -7082,0 +8677,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -7087,0 +8686,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 40\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7107,1 +8710,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7115,1 +8718,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7123,1 +8726,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7131,1 +8734,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7139,1 +8742,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7163,0 +8766,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -7167,0 +8774,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -7172,0 +8783,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 62\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -7176,0 +8791,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -7181,0 +8800,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 62\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7201,0 +8824,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -7205,0 +8832,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -7209,0 +8840,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -7213,0 +8848,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -7217,0 +8856,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7237,1 +8880,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7245,1 +8888,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7253,1 +8896,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7261,1 +8904,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7270,0 +8913,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 64\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7290,1 +8937,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7298,1 +8945,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7306,1 +8953,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7314,1 +8961,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7322,1 +8969,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7346,0 +8993,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -7350,0 +9001,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -7354,0 +9009,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -7358,0 +9017,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -7363,0 +9026,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 126\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7383,0 +9050,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -7387,0 +9058,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -7391,0 +9066,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -7395,0 +9074,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -7399,0 +9082,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7419,1 +9106,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7427,1 +9114,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7435,1 +9122,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7443,1 +9130,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7452,0 +9139,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 128\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7472,1 +9163,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7480,1 +9171,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7488,1 +9179,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7496,1 +9187,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7504,1 +9195,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7528,0 +9219,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -7532,0 +9227,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -7536,0 +9235,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -7540,0 +9243,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -7545,0 +9252,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 130\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7565,0 +9276,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -7569,0 +9284,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -7573,0 +9292,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -7577,0 +9300,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -7581,0 +9308,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7601,1 +9332,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7609,1 +9340,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7617,1 +9348,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7625,1 +9356,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7633,1 +9364,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7657,1 +9388,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7665,1 +9396,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7673,1 +9404,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7681,1 +9412,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7689,1 +9420,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7713,0 +9444,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -7717,0 +9452,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -7721,0 +9460,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -7725,0 +9468,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -7729,0 +9476,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7749,0 +9500,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -7753,0 +9508,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -7757,0 +9516,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -7761,0 +9524,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -7765,0 +9532,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7785,1 +9556,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7793,1 +9564,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7801,1 +9572,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7809,1 +9580,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -7817,0 +9588,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7837,0 +9612,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -7841,1 +9620,1 @@\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    \/\/   Expect alignment.\n@@ -7843,1 +9622,9 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n@@ -7849,0 +9636,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -7853,0 +9644,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7873,1 +9668,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7881,1 +9676,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7889,1 +9684,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7897,1 +9692,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7905,1 +9700,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7928,0 +9723,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 1\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -7931,0 +9730,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 1\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -7934,0 +9737,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 1\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -7937,0 +9744,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 1\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -7940,0 +9751,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 1\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -7960,1 +9775,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7968,1 +9783,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7976,1 +9791,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7984,1 +9799,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -7992,1 +9807,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8015,0 +9830,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -8018,0 +9837,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -8021,0 +9844,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -8024,0 +9851,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -8027,0 +9858,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -8047,1 +9882,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8055,1 +9890,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8063,1 +9898,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8071,1 +9906,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8079,1 +9914,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8102,0 +9937,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 3\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -8105,0 +9944,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 3\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -8108,0 +9951,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 3\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -8111,0 +9958,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 3\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -8114,0 +9965,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 3\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -8134,0 +9989,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8138,0 +9994,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8142,0 +9999,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8146,0 +10004,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8150,0 +10009,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8169,1 +10029,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -8171,0 +10031,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8174,1 +10035,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -8176,0 +10037,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8179,1 +10041,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -8181,0 +10043,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8184,1 +10047,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -8186,0 +10049,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8189,1 +10053,1 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n@@ -8191,0 +10055,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8211,1 +10076,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8219,1 +10084,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8227,1 +10092,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8235,1 +10100,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8243,1 +10108,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8268,0 +10133,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 7\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -8273,0 +10142,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 7\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -8278,0 +10151,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 7\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -8283,0 +10160,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 7\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -8288,0 +10169,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 7\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -8308,0 +10193,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -8312,0 +10201,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -8316,0 +10209,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -8320,0 +10217,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -8324,0 +10225,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -8345,0 +10250,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -8350,0 +10259,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -8355,0 +10268,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -8360,0 +10277,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -8365,0 +10286,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -8385,1 +10310,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8393,1 +10318,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8401,1 +10326,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8409,1 +10334,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8417,1 +10342,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8442,0 +10367,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -8447,0 +10376,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -8452,0 +10385,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -8457,0 +10394,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -8462,0 +10403,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -8482,0 +10427,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -8486,0 +10435,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -8490,0 +10443,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -8494,0 +10451,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -8498,0 +10459,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -8518,1 +10483,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -8527,0 +10492,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -8532,0 +10501,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -8536,1 +10509,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -8545,0 +10518,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -8565,1 +10542,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8573,1 +10550,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8581,1 +10558,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8589,1 +10566,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8597,1 +10574,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8621,0 +10598,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -8626,0 +10607,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 18\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -8631,0 +10616,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 18\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -8635,0 +10624,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -8640,0 +10633,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 18\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -8660,0 +10657,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8664,0 +10662,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8668,0 +10667,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8672,0 +10672,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8676,0 +10677,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8696,0 +10698,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8701,0 +10704,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8706,0 +10710,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8710,0 +10715,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8715,0 +10721,1 @@\n+    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n@@ -8735,1 +10742,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8743,1 +10750,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8751,1 +10758,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8759,1 +10766,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8767,1 +10774,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8791,0 +10798,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -8796,0 +10807,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 31\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -8801,0 +10816,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 31\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -8805,0 +10824,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -8810,0 +10833,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 31\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -8830,0 +10857,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -8834,0 +10865,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -8838,0 +10873,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -8842,0 +10881,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -8846,0 +10889,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -8866,1 +10913,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -8874,1 +10921,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -8883,0 +10930,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -8887,1 +10938,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -8896,0 +10947,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -8916,1 +10971,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8924,1 +10979,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8932,1 +10987,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8940,1 +10995,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8948,1 +11003,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -8972,0 +11027,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -8976,0 +11035,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -8981,0 +11044,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 63\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -8985,0 +11052,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -8990,0 +11061,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 63\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9010,0 +11085,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -9014,0 +11093,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -9018,0 +11101,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -9022,0 +11109,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -9026,0 +11117,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9046,1 +11141,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9054,1 +11149,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9062,1 +11157,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9070,1 +11165,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9079,0 +11174,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 64\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9099,1 +11198,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9107,1 +11206,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9115,1 +11214,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9123,1 +11222,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9131,1 +11230,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9155,0 +11254,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -9159,0 +11262,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -9163,0 +11270,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -9167,0 +11278,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -9172,0 +11287,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 65\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9192,0 +11311,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -9196,0 +11319,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -9200,0 +11327,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -9204,0 +11335,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -9208,0 +11343,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9228,1 +11367,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9236,1 +11375,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9244,1 +11383,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9252,1 +11391,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9261,0 +11400,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 128\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9281,1 +11424,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9289,1 +11432,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9297,1 +11440,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9305,1 +11448,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9313,1 +11456,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9337,0 +11480,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -9341,0 +11488,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -9345,0 +11496,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -9349,0 +11504,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -9354,0 +11513,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 129\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9374,0 +11537,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n@@ -9378,0 +11545,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n@@ -9382,0 +11553,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n@@ -9386,0 +11561,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -9390,0 +11569,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9410,1 +11593,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9418,1 +11601,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9426,1 +11609,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9434,1 +11617,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9443,0 +11626,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 192\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9463,0 +11650,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -9467,0 +11658,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -9471,0 +11666,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -9475,1 +11674,1 @@\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n+    \/\/   Expect alignment.\n@@ -9477,1 +11676,9 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n+    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n@@ -9499,1 +11706,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9507,1 +11714,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9515,1 +11722,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9523,1 +11730,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9531,1 +11738,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9554,0 +11761,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -9557,0 +11768,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -9560,0 +11775,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -9563,0 +11782,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -9566,0 +11789,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9586,0 +11813,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -9590,0 +11821,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -9594,0 +11829,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -9598,0 +11837,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -9602,0 +11845,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9621,1 +11868,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n@@ -9626,1 +11877,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n@@ -9631,1 +11886,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n@@ -9636,1 +11895,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n@@ -9641,1 +11904,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n@@ -9663,1 +11930,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9671,1 +11938,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9679,1 +11946,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9687,1 +11954,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9695,1 +11962,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9720,0 +11987,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -9725,0 +11996,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -9730,0 +12005,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -9735,0 +12014,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -9740,0 +12023,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9760,0 +12047,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -9764,0 +12055,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -9768,0 +12063,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -9772,0 +12071,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -9776,0 +12079,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9796,1 +12103,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9805,0 +12112,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -9810,0 +12121,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -9814,1 +12129,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9823,0 +12138,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9843,1 +12162,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9851,1 +12170,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9859,1 +12178,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9867,1 +12186,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9875,1 +12194,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -9899,0 +12218,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -9904,0 +12227,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 28\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -9909,0 +12236,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 28\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -9913,0 +12244,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -9918,0 +12253,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 28\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9938,0 +12277,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -9942,0 +12285,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -9946,0 +12293,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -9950,0 +12301,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -9954,0 +12309,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -9974,1 +12333,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9982,1 +12341,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -9991,0 +12350,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -9995,1 +12358,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10004,0 +12367,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10024,0 +12391,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10028,0 +12399,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10032,0 +12407,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10036,0 +12415,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -10040,0 +12423,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10060,0 +12447,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10064,0 +12455,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10069,0 +12464,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 56\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10073,0 +12472,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -10078,0 +12481,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 56\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10098,0 +12505,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10102,0 +12513,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10106,0 +12521,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10110,0 +12529,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -10114,0 +12537,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10134,1 +12561,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10142,1 +12569,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10150,1 +12577,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10158,1 +12585,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10167,0 +12594,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 64\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10187,0 +12618,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10191,0 +12626,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10195,0 +12634,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10199,0 +12642,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -10203,0 +12650,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10223,0 +12674,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10227,0 +12682,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10231,0 +12690,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10235,0 +12698,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -10240,0 +12707,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 72\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10260,0 +12731,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10264,0 +12739,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10268,0 +12747,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10272,0 +12755,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -10276,0 +12763,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10296,1 +12787,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10304,0 +12795,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10308,0 +12803,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10312,1 +12811,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10321,0 +12820,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 80\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10341,1 +12844,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10349,1 +12852,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10357,1 +12860,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10365,1 +12868,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10373,1 +12876,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10397,0 +12900,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10401,0 +12908,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10405,0 +12916,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10409,0 +12924,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -10414,0 +12933,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 124\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10434,0 +12957,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10438,0 +12965,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10442,0 +12973,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10446,0 +12981,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -10450,0 +12989,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10470,1 +13013,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10478,1 +13021,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10486,1 +13029,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10494,1 +13037,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10503,0 +13046,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 128\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10523,1 +13070,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10531,1 +13078,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10539,1 +13086,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10547,1 +13094,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10555,1 +13102,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10579,0 +13126,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10583,0 +13134,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10587,0 +13142,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10591,0 +13150,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -10596,0 +13159,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 252\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10616,0 +13183,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10620,0 +13191,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10624,0 +13199,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10628,0 +13207,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -10632,0 +13215,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10652,1 +13239,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10660,1 +13247,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10668,1 +13255,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10676,1 +13263,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10684,1 +13271,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10708,1 +13295,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10716,1 +13303,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10724,1 +13311,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10732,1 +13319,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10740,1 +13327,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10764,0 +13351,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10768,0 +13359,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10772,0 +13367,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10776,0 +13375,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -10780,0 +13383,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10800,0 +13407,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10804,0 +13415,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10808,0 +13423,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10812,0 +13431,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -10816,0 +13439,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10836,1 +13463,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10844,1 +13471,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10852,1 +13479,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10860,1 +13487,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10868,1 +13495,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -10892,1 +13519,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10900,1 +13527,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10908,1 +13535,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10916,1 +13543,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10924,1 +13551,1 @@\n-    \/\/   Strict alignment not possible.\n+    \/\/   Expect misalignment.\n@@ -10948,0 +13575,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10952,0 +13583,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10956,0 +13591,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10960,0 +13599,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -10964,0 +13607,4 @@\n+    \/\/   Expect misalignment.\n+    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -10984,0 +13631,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -10988,0 +13639,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -10992,0 +13647,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -10996,0 +13655,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -11000,0 +13663,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11020,1 +13687,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11028,1 +13695,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11036,1 +13703,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11044,1 +13711,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11052,1 +13719,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11076,0 +13743,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -11080,0 +13751,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -11084,0 +13759,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11088,0 +13767,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -11092,0 +13775,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11112,3 +13799,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11120,3 +13807,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11128,3 +13815,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11136,3 +13823,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11144,3 +13831,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11167,0 +13854,2 @@\n+    \/\/   Expect alignment.\n+    \/\/   No positive IR rule: conditions impossible.\n@@ -11170,0 +13859,2 @@\n+    \/\/   Expect alignment.\n+    \/\/   No positive IR rule: conditions impossible.\n@@ -11173,0 +13864,2 @@\n+    \/\/   Expect alignment.\n+    \/\/   No positive IR rule: conditions impossible.\n@@ -11176,0 +13869,2 @@\n+    \/\/   Expect alignment.\n+    \/\/   No positive IR rule: conditions impossible.\n@@ -11179,0 +13874,2 @@\n+    \/\/   Expect alignment.\n+    \/\/   No positive IR rule: conditions impossible.\n@@ -11199,0 +13896,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -11203,0 +13904,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -11207,0 +13912,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11211,0 +13920,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -11215,0 +13928,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11235,1 +13952,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11242,1 +13959,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"16\"},\n@@ -11247,1 +13968,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"16\"},\n@@ -11253,1 +13978,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11260,1 +13985,5 @@\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"16\"},\n@@ -11282,3 +14011,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11290,3 +14019,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11298,3 +14027,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11306,3 +14035,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11314,3 +14043,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11338,0 +14067,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -11343,0 +14076,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -11348,0 +14085,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11352,0 +14093,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -11357,0 +14102,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11377,0 +14126,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -11381,0 +14134,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -11385,0 +14142,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11389,0 +14150,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -11393,0 +14158,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11413,1 +14182,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11421,1 +14190,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11430,0 +14199,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11434,1 +14207,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11443,0 +14216,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11463,3 +14240,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11471,3 +14248,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11479,3 +14256,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11487,3 +14264,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11495,3 +14272,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11519,0 +14296,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -11523,0 +14304,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -11528,0 +14313,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 56\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11532,0 +14321,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -11537,0 +14330,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 56\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11557,0 +14354,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -11561,0 +14362,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -11565,0 +14370,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11569,0 +14378,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -11573,0 +14386,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11593,1 +14410,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11601,1 +14418,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11609,1 +14426,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11617,1 +14434,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11626,0 +14443,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 64\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11646,0 +14467,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -11650,0 +14475,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -11654,0 +14483,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11658,0 +14491,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -11662,0 +14499,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11682,1 +14523,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11690,0 +14531,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -11694,0 +14539,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11698,1 +14547,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11707,0 +14556,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 112\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11727,0 +14580,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -11731,0 +14588,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -11735,0 +14596,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11739,0 +14604,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -11743,0 +14612,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11763,1 +14636,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11771,1 +14644,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11779,1 +14652,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11787,1 +14660,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11796,0 +14669,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 128\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11816,0 +14693,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -11820,0 +14701,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -11824,0 +14709,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11828,0 +14717,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -11832,0 +14725,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11852,1 +14749,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11860,0 +14757,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -11864,0 +14765,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11868,1 +14773,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11877,0 +14782,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 144\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11897,0 +14806,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -11901,0 +14814,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -11905,0 +14822,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11909,0 +14830,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -11913,0 +14838,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11933,1 +14862,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11941,1 +14870,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11949,0 +14878,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -11953,1 +14886,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -11962,0 +14895,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 160\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -11982,3 +14919,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11990,3 +14927,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -11998,3 +14935,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12006,3 +14943,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12014,3 +14951,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12038,0 +14975,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -12042,0 +14983,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -12046,0 +14991,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -12050,0 +14999,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -12055,0 +15008,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 248\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -12075,0 +15032,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -12079,0 +15040,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -12083,0 +15048,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -12087,0 +15056,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -12091,0 +15064,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -12111,1 +15088,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12119,1 +15096,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12127,1 +15104,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12135,1 +15112,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12143,1 +15120,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12167,3 +15144,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12175,3 +15152,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12183,3 +15160,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12191,3 +15168,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12199,3 +15176,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12223,0 +15200,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -12227,0 +15208,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -12231,0 +15216,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -12235,0 +15224,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -12239,0 +15232,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -12259,0 +15256,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -12263,0 +15264,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -12267,0 +15272,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -12271,0 +15280,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -12275,0 +15288,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -12295,1 +15312,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12303,1 +15320,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12311,1 +15328,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12319,1 +15336,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12327,1 +15344,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12351,3 +15368,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12359,3 +15376,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12367,3 +15384,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12375,3 +15392,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12383,3 +15400,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12407,0 +15424,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -12411,0 +15432,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -12415,0 +15440,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -12419,0 +15448,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -12423,0 +15456,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -12443,0 +15480,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -12447,0 +15488,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -12451,0 +15496,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -12455,0 +15504,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -12459,0 +15512,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -12479,1 +15536,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12487,1 +15544,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12495,1 +15552,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12503,1 +15560,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12511,1 +15568,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12535,3 +15592,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12543,3 +15600,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12551,3 +15608,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12559,3 +15616,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12567,3 +15624,3 @@\n-    \/\/   Strict alignment not possible.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_D, IRNode.MUL_VD, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n@@ -12591,0 +15648,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -12595,0 +15656,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -12599,0 +15664,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -12603,0 +15672,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -12607,0 +15680,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -12627,0 +15704,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n@@ -12631,0 +15712,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n@@ -12635,0 +15720,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n@@ -12639,0 +15728,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n@@ -12643,0 +15736,4 @@\n+    \/\/   Expect alignment.\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n@@ -12663,1 +15760,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12671,1 +15768,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12679,1 +15776,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12687,1 +15784,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n@@ -12695,1 +15792,1 @@\n-    \/\/   Vectorize when strict alignment guaranteed.\n+    \/\/   Expect alignment.\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestDependencyOffsets.java","additions":3792,"deletions":695,"binary":false,"changes":4487,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @requires vm.cpu.features ~= \".*avx2.*\"\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMovingLoadBeforeStore.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @requires os.arch == \"x86_64\" | os.arch == \"aarch64\"\n@@ -78,1 +77,2 @@\n-    @IR(applyIfCPUFeature = {\"sse2\", \"true\"}, applyIf = {\"UseUnalignedLoadStores\", \"true\"},\n+    @IR(applyIfCPUFeature = {\"sse2\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -80,7 +80,5 @@\n-    @IR(applyIfCPUFeature = {\"sse2\", \"true\"}, applyIf = {\"UseUnalignedLoadStores\", \"false\"},\n-        failOn = {IRNode.MUL_ADD_VS2VI}, \/\/ Can only pack LoadS if UseUnalignedLoadStores is true (default if sse4.2)\n-        counts = {IRNode.MUL_ADD_S2I, \"> 0\"})\n-    @IR(applyIfCPUFeature = {\"asimd\", \"true\"}, applyIf = {\"MaxVectorSize\", \"16\"}, \/\/ AD file requires vector_length = 16\n-            counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI, \"> 0\"})\n-    @IR(applyIfCPUFeature = {\"avx512_vnni\", \"true\"}, applyIf = {\"UseUnalignedLoadStores\", \"true\"},\n-            counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI_VNNI, \"> 0\"})\n+    @IR(applyIfCPUFeature = {\"asimd\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \"16\"}, \/\/ AD file requires vector_length = 16\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI, \"> 0\"})\n+    @IR(applyIfCPUFeature = {\"avx512_vnni\", \"true\"},\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI_VNNI, \"> 0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMulAddS2I.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8257531\n+ * @bug 8257531 8310190\n@@ -29,11 +29,2 @@\n- *\n- * @requires vm.flagless\n- * @requires vm.compiler2.enabled & vm.debug == true\n- * @requires os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n- *\n- * @run driver compiler.vectorization.TestBufferVectorization array\n- * @run driver compiler.vectorization.TestBufferVectorization arrayOffset\n- * @run driver compiler.vectorization.TestBufferVectorization buffer\n- * @run driver compiler.vectorization.TestBufferVectorization bufferHeap\n- * @run driver compiler.vectorization.TestBufferVectorization bufferDirect\n- * @run driver compiler.vectorization.TestBufferVectorization arrayView\n+ * @requires vm.compiler2.enabled\n+ * @run driver compiler.vectorization.TestBufferVectorization\n@@ -44,0 +35,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -51,4 +44,0 @@\n-import jdk.test.lib.Platform;\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n@@ -56,6 +45,2 @@\n-    final static int N = 500;\n-    final static int ITER = 1000;\n-    final static IntBuffer buffer = IntBuffer.allocate(N);\n-    final static int offset = buffer.arrayOffset();\n-    final static IntBuffer heap_buffer_byte_to_int = ByteBuffer.allocate(N * Integer.BYTES).order(ByteOrder.nativeOrder()).asIntBuffer();\n-    final static IntBuffer direct_buffer_byte_to_int = ByteBuffer.allocateDirect(N * Integer.BYTES).order(ByteOrder.nativeOrder()).asIntBuffer();\n+    final static int N = 1024*16;\n+    static int offset = 0;\n@@ -63,1 +48,0 @@\n-    final static String arch = System.getProperty(\"os.arch\");\n@@ -65,4 +49,2 @@\n-    interface Test {\n-        void init();\n-        void run();\n-        void verify();\n+    public static void main(String[] args) {\n+        TestFramework.run();\n@@ -71,2 +53,3 @@\n-    static class TestArray implements Test {\n-        final int[] array = new int[N];\n+    @Run(test = \"testArray\")\n+    public static void runArray() {\n+        int[] array = new int[N];\n@@ -74,4 +57,2 @@\n-        public void init() {\n-            for (int k = 0; k < array.length; k++) {\n-                array[k] = k;\n-            }\n+        for (int k = 0; k < array.length; k++) {\n+            array[k] = k;\n@@ -80,3 +61,5 @@\n-        public void run() {\n-            for(int k = 0; k < array.length; k++) {\n-                array[k] += 1;\n+        testArray(array);\n+\n+        for(int k = 0; k < array.length; k++) {\n+            if (array[k] != (k + 1)) {\n+                throw new RuntimeException(\" Invalid result: array[\" + k + \"]: \" + array[k] + \" != \" + (k + 1));\n@@ -85,0 +68,1 @@\n+    }\n@@ -86,8 +70,9 @@\n-        public void verify() {\n-            init(); \/\/ reset\n-            run();  \/\/ run compiled code\n-            for(int k = 0; k < array.length; k++) {\n-                if (array[k] != (k + 1)) {\n-                    throw new RuntimeException(\" Invalid result: array[\" + k + \"]: \" + array[k] + \" != \" + (k + 1));\n-                }\n-            }\n+    @Test\n+    @IR(counts = {IRNode.REPLICATE_I,   \">0\",\n+                  IRNode.LOAD_VECTOR_I, \">0\",\n+                  IRNode.ADD_VI,        \">0\",\n+                  IRNode.STORE_VECTOR,  \">0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    public static void testArray(int[] array) {\n+        for(int k = 0; k < array.length; k++) {\n+            array[k] += 1;\n@@ -97,3 +82,4 @@\n-    static class TestArrayOffset implements Test {\n-        final int offset;\n-        final int[] array = new int[N];\n+    @Run(test = \"testArrayOffset\")\n+    public static void runArrayOffset() {\n+        \/\/ Moving offset between 0..255\n+        offset = (offset + 1) % 256;\n@@ -101,3 +87,1 @@\n-        public TestArrayOffset(int off) {\n-            offset = off;\n-        }\n+        int[] array = new int[N];\n@@ -105,4 +89,2 @@\n-        public void init() {\n-            for (int k = 0; k < array.length; k++) {\n-                array[k] = k;\n-            }\n+        for (int k = 0; k < array.length; k++) {\n+            array[k] = k;\n@@ -111,6 +93,1 @@\n-        public void run() {\n-            int l = array.length - offset;\n-            for(int k = 0; k < l; k++) {\n-                array[k + offset] += 1;\n-            }\n-        }\n+        testArrayOffset(array, offset);\n@@ -118,8 +95,4 @@\n-        public void verify() {\n-            init(); \/\/ reset\n-            run();  \/\/ run compiled code\n-            int l = array.length - offset;\n-            for(int k = 0; k < l; k++) {\n-                if (array[k] != (k + 1)) {\n-                    throw new RuntimeException(\" Invalid result: arrayOffset[\" + k + \"]: \" + array[k] + \" != \" + (k + 1));\n-                }\n+        int l = array.length - offset;\n+        for(int k = 0; k < offset; k++) {\n+            if (array[k] != k) {\n+                throw new RuntimeException(\" Invalid result: arrayOffset[\" + k + \"]: \" + array[k] + \" != \" + (k + 1));\n@@ -127,4 +100,4 @@\n-            for(int k = l; k < array.length; k++) {\n-                if (array[k] != k) {\n-                    throw new RuntimeException(\" Invalid result: arrayOffset[\" + k + \"]: \" + array[k] + \" != \" + k);\n-                }\n+        }\n+        for(int k = offset; k < array.length; k++) {\n+            if (array[k] != (k + 1)) {\n+                throw new RuntimeException(\" Invalid result: arrayOffset[\" + k + \"]: \" + array[k] + \" != \" + k);\n@@ -135,11 +108,10 @@\n-    static class TestBuffer implements Test {\n-        final IntBuffer buffer;\n-\n-        public TestBuffer(IntBuffer buf) {\n-            buffer = buf;\n-        }\n-\n-        public void init() {\n-            for (int k = 0; k < buffer.limit(); k++) {\n-                buffer.put(k, k);\n-            }\n+    @Test\n+    @IR(counts = {IRNode.REPLICATE_I,   \">0\",\n+                  IRNode.LOAD_VECTOR_I, \">0\",\n+                  IRNode.ADD_VI,        \">0\",\n+                  IRNode.STORE_VECTOR,  \">0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    public static void testArrayOffset(int[] array, int offset) {\n+        int l = array.length - offset;\n+        for(int k = 0; k < l; k++) {\n+            array[k + offset] += 1;\n@@ -147,0 +119,1 @@\n+    }\n@@ -148,5 +121,7 @@\n-        public void run() {\n-            for (int k = 0; k < buffer.limit(); k++) {\n-                buffer.put(k, buffer.get(k) + 1);\n-            }\n-        }\n+    @Run(test = \"testBuffer\")\n+    public static void runBuffer() {\n+        IntBuffer buffer = IntBuffer.allocate(N);\n+        initBuffer(buffer);\n+        testBuffer(buffer);\n+        verifyBuffer(buffer);\n+    }\n@@ -154,8 +129,9 @@\n-        public void verify() {\n-            init(); \/\/ reset\n-            run();  \/\/ run compiled code\n-            for(int k = 0; k < buffer.limit(); k++) {\n-                if (buffer.get(k) != (k + 1)) {\n-                    throw new RuntimeException(\" Invalid result: buffer.get(\" + k + \"): \" + buffer.get(k) + \" != \" + (k + 1));\n-                }\n-            }\n+    @Test\n+    @IR(counts = {IRNode.REPLICATE_I,   \">0\",\n+                  IRNode.LOAD_VECTOR_I, \">0\",\n+                  IRNode.ADD_VI,        \">0\",\n+                  IRNode.STORE_VECTOR,  \">0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    public static void testBuffer(IntBuffer buffer) {\n+        for (int k = 0; k < buffer.limit(); k++) {\n+            buffer.put(k, buffer.get(k) + 1);\n@@ -165,2 +141,7 @@\n-    static class TestArrayView implements Test {\n-        final byte[] b_arr = new byte[N * Integer.BYTES];\n+    @Run(test = \"testBufferHeap\")\n+    public static void runBufferHeap() {\n+        IntBuffer buffer = ByteBuffer.allocate(N * Integer.BYTES).order(ByteOrder.nativeOrder()).asIntBuffer();\n+        initBuffer(buffer);\n+        testBufferHeap(buffer);\n+        verifyBuffer(buffer);\n+    }\n@@ -168,4 +149,18 @@\n-        public void init() {\n-            for (int k = 0; k < N; k++) {\n-                VH_arr_view.set(b_arr, k, k);\n-            }\n+    @Test\n+    @IR(counts = {IRNode.REPLICATE_I,   IRNode.VECTOR_SIZE_ANY, \">0\",\n+                  IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_ANY, \">0\",\n+                  IRNode.ADD_VI,        IRNode.VECTOR_SIZE_ANY, \">0\",\n+                  IRNode.STORE_VECTOR,                          \">0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"})\n+    \/\/ VECTOR_SIZE_ANY: Unrolling does not always seem to go far enough to reach maximum vector size.\n+    \/\/                  This looks like a BUG.\n+    \/\/ AlignVector: Buffer get\/put have an invariant that is in bytes (LoadL in ByteBufferAsIntBufferL::byteOffset).\n+    \/\/              This makes sense: we are accessing a byte buffer. But to be able to align the 4 byte ints,\n+    \/\/              we would require to know that the invariant is a multiple of 4. Without that, we cannot\n+    \/\/              guarantee alignment by adjusting the limit of the pre-loop with a stride of 4 bytes.\n+    \/\/ 64-bit: bufferHeap uses Long type for memory accesses which are not vectorized in 32-bit VM\n+    public static void testBufferHeap(IntBuffer buffer) {\n+        for (int k = 0; k < buffer.limit(); k++) {\n+            buffer.put(k, buffer.get(k) + 1);\n@@ -173,0 +168,1 @@\n+    }\n@@ -174,5 +170,14 @@\n-        public void run() {\n-            for (int k = 0; k < b_arr.length; k += 4) {\n-                int v = (int) VH_arr_view.get(b_arr, k);\n-                VH_arr_view.set(b_arr, k, v + 1);\n-            }\n+    @Run(test = \"testBufferDirect\")\n+    public static void runBufferDirect() {\n+        IntBuffer buffer = ByteBuffer.allocateDirect(N * Integer.BYTES).order(ByteOrder.nativeOrder()).asIntBuffer();\n+        initBuffer(buffer);\n+        testBufferDirect(buffer);\n+        verifyBuffer(buffer);\n+    }\n+\n+    @Test\n+    \/\/ bufferDirect uses Unsafe memory accesses which are not vectorized currently\n+    \/\/ We find a CastX2P in pointer analysis (VPointer)\n+    public static void testBufferDirect(IntBuffer buffer) {\n+        for (int k = 0; k < buffer.limit(); k++) {\n+            buffer.put(k, buffer.get(k) + 1);\n@@ -180,0 +185,1 @@\n+    }\n@@ -181,14 +187,3 @@\n-        public void verify() {\n-            init(); \/\/ reset\n-            \/\/ Save initial INT values\n-            final int[] i_arr = new int[N];\n-            for (int k = 0; k < i_arr.length; k++) {\n-                i_arr[k] = (int) VH_arr_view.get(b_arr, k * Integer.BYTES);\n-            }\n-            run();  \/\/ run compiled code\n-            for (int k = 0; k < i_arr.length; k++) {\n-                int v = (int) VH_arr_view.get(b_arr, k * Integer.BYTES);\n-                if (v != (i_arr[k] + 1)) {\n-                    throw new RuntimeException(\" Invalid result: VH_arr_view.get(b_arr, \" + (k * Integer.BYTES) + \"): \" + v + \" != \" + (i_arr[k] + 1));\n-                }\n-            }\n+    public static void initBuffer(IntBuffer buffer) {\n+        for (int k = 0; k < buffer.limit(); k++) {\n+            buffer.put(k, k);\n@@ -198,19 +193,4 @@\n-    public static void main(String[] args) {\n-        if (args.length == 0) {\n-            throw new RuntimeException(\" Missing test name: array, arrayOffset, buffer, bufferHeap, bufferDirect, arrayView\");\n-        } else if (args.length == 1) {\n-            verify_vectors(args[0]);\n-        } else {\n-            Test te = switch (args[0]) {\n-                case \"array\" -> new TestArray();\n-                case \"arrayOffset\" -> new TestArrayOffset(offset);\n-                case \"buffer\" -> new TestBuffer(buffer);\n-                case \"bufferHeap\" -> new TestBuffer(heap_buffer_byte_to_int);\n-                case \"bufferDirect\" -> new TestBuffer(direct_buffer_byte_to_int);\n-                case \"arrayView\" -> new TestArrayView();\n-                default -> throw new RuntimeException(\" Unknown test: \" + args[0]);\n-            };\n-\n-            te.init();\n-            for (int i = 0; i < ITER; i++) {\n-                te.run();\n+    public static void verifyBuffer(IntBuffer buffer) {\n+        for(int k = 0; k < buffer.limit(); k++) {\n+            if (buffer.get(k) != (k + 1)) {\n+                throw new RuntimeException(\" Invalid result: buffer.get(\" + k + \"): \" + buffer.get(k) + \" != \" + (k + 1));\n@@ -218,1 +198,0 @@\n-            te.verify();\n@@ -220,1 +199,0 @@\n-\n@@ -223,13 +201,3 @@\n-    static void verify_vectors(String testName) {\n-        ProcessBuilder pb;\n-        OutputAnalyzer out;\n-        try {\n-            pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:-BackgroundCompilation\",\n-                                                                  \"-XX:+TraceNewVectors\",\n-                                                                  \"compiler.vectorization.TestBufferVectorization\",\n-                                                                  testName,\n-                                                                  \"run\");\n-            out = new OutputAnalyzer(pb.start());\n-        } catch (Exception e) {\n-            throw new RuntimeException(\" Exception launching Java process: \" + e);\n-        }\n+    @Run(test = \"testArrayView\")\n+    public static void runArrayView() {\n+        byte[] b_arr = new byte[N * Integer.BYTES];\n@@ -237,1 +205,3 @@\n-        out.shouldHaveExitValue(0);\n+        for (int k = 0; k < N; k++) {\n+            VH_arr_view.set(b_arr, k, k);\n+        }\n@@ -239,2 +209,4 @@\n-        if (testName.equals(\"bufferDirect\")) {\n-            return; \/\/ bufferDirect uses Unsafe memory accesses which are not vectorized currently\n+        \/\/ Save initial INT values\n+        int[] i_arr = new int[N];\n+        for (int k = 0; k < i_arr.length; k++) {\n+            i_arr[k] = (int) VH_arr_view.get(b_arr, k * Integer.BYTES);\n@@ -242,0 +214,1 @@\n+        testArrayView(b_arr);\n@@ -243,2 +216,5 @@\n-        if (testName.equals(\"bufferHeap\") && (Platform.is32bit())) {\n-            return; \/\/ bufferHeap uses Long type for memory accesses which are not vectorized in 32-bit VM\n+        for (int k = 0; k < i_arr.length; k++) {\n+            int v = (int) VH_arr_view.get(b_arr, k * Integer.BYTES);\n+            if (v != (i_arr[k] + 1)) {\n+                throw new RuntimeException(\" Invalid result: VH_arr_view.get(b_arr, \" + (k * Integer.BYTES) + \"): \" + v + \" != \" + (i_arr[k] + 1));\n+            }\n@@ -246,0 +222,1 @@\n+    }\n@@ -247,4 +224,11 @@\n-        out.shouldContain(\"Replicate\");\n-        out.shouldContain(\"LoadVector\");\n-        out.shouldContain(\"AddVI\");\n-        out.shouldContain(\"StoreVector\");\n+    @Test\n+    @IR(counts = {IRNode.REPLICATE_I,   \">0\",\n+                  IRNode.LOAD_VECTOR_I, \">0\",\n+                  IRNode.ADD_VI,        \">0\",\n+                  IRNode.STORE_VECTOR,  \">0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    public static void testArrayView(byte[] b_arr) {\n+        for (int k = 0; k < b_arr.length; k += 4) {\n+            int v = (int) VH_arr_view.get(b_arr, k);\n+            VH_arr_view.set(b_arr, k, v + 1);\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestBufferVectorization.java","additions":148,"deletions":164,"binary":false,"changes":312,"status":"modified"}]}