{"files":[{"patch":"@@ -812,1 +812,19 @@\n-  \/\/ limit. We decompose pre_iter:\n+  \/\/ limit.\n+  \/\/\n+  \/\/     (C_const + C_invar * var_invar + C_init * var_init + C_pre * pre_iter) % aw = 0                         (3)\n+  \/\/\n+  \/\/ We strengthen the constraints by splitting the equation into 3 equations, where we\n+  \/\/ want to find integer solutions for pre_iter_C_const, pre_iter_C_invar, and\n+  \/\/ pre_iter_C_init, which means that the C_const, init and invar terms can be aligned\n+  \/\/ independently:\n+  \/\/\n+  \/\/   (C_const             + C_pre * pre_iter_C_const) % aw = 0                 (4a)\n+  \/\/   (C_invar * var_invar + C_pre * pre_iter_C_invar) % aw = 0                 (4b)\n+  \/\/   (C_init  * var_init  + C_pre * pre_iter_C_init ) % aw = 0                 (4c)\n+  \/\/\n+  \/\/ We now prove that (4a, b, c) are sufficient as well as necessary go guarantee (3)\n+  \/\/ for any runtime value of var_invar and var_init (i.e. for any invar and init).\n+  \/\/ This tells us that the \"strengthening\" did not restrict the algorithm more than\n+  \/\/ necessary.\n+  \/\/\n+  \/\/ Sufficient (i.e (4a, b, c) imply (3)):\n@@ -816,3 +834,1 @@\n-  \/\/ where pre_iter_C_const, pre_iter_C_invar, and pre_iter_C_init are rationals (rational numbers),\n-  \/\/ and define how many pre-loop iterations (or fractions thereof) are required to align the\n-  \/\/ C_const, init and invar terms individually. Hence, we can rewrite:\n+  \/\/ Adding up (4a, b, c):\n@@ -820,5 +836,4 @@\n-  \/\/     (C_const + C_invar * var_invar + C_init * var_init + C_pre * pre_iter) % aw\n-  \/\/   = ( C_const             + C_pre * pre_iter_C_const\n-  \/\/     + C_invar * var_invar + C_pre * pre_iter_C_invar\n-  \/\/     + C_init  * var_init  + C_pre * pre_iter_C_init ) % aw\n-  \/\/   = 0                                                                       (3)\n+  \/\/   0\n+  \/\/   = (  C_const             + C_pre * pre_iter_C_const\n+  \/\/      + C_invar * var_invar + C_pre * pre_iter_C_invar\n+  \/\/      + C_init  * var_init  + C_pre * pre_iter_C_init  ) % aw\n@@ -826,2 +841,2 @@\n-  \/\/ While we can now attribute the (fractional) amount of iterations required for the C_const,\n-  \/\/ invar and init terms, this does not give us a way to align these terms independendly.\n+  \/\/   = (  C_const + C_invar * var_invar + C_init * var_init\n+  \/\/      + C_pre * (pre_iter_C_const + pre_iter_C_invar + pre_iter_C_init)) % aw\n@@ -829,3 +844,2 @@\n-  \/\/ We strengthen the constraints by splitting the equation into 3 equations, and require that\n-  \/\/ pre_iter_C_const, pre_iter_C_invar, and pre_iter_C_init are integers (not just rationals),\n-  \/\/ which means that the C_const, init and invar terms can be aligned independently:\n+  \/\/   = (  C_const + C_invar * var_invar + C_init * var_init\n+  \/\/      + C_pre * pre_iter) % aw\n@@ -833,3 +847,33 @@\n-  \/\/   (C_const             + C_pre * pre_iter_C_const) % aw = 0                 (4a)\n-  \/\/   (C_invar * var_invar + C_pre * pre_iter_C_invar) % aw = 0                 (4b)\n-  \/\/   (C_init  * var_init  + C_pre * pre_iter_C_init ) % aw = 0                 (4c)\n+  \/\/ Necessary (i.e. (3) implies (4a, b, c)):\n+  \/\/  (4a): Set var_invar = var_init = 0 at runtime. Applying this to (3), we get:\n+  \/\/\n+  \/\/        0 =\n+  \/\/          = (C_const + C_invar * var_invar + C_init * var_init + C_pre * pre_iter) % aw\n+  \/\/          = (C_const + C_invar * 0         + C_init * 0        + C_pre * pre_iter) % aw\n+  \/\/          = (C_const                                           + C_pre * pre_iter) % aw\n+  \/\/\n+  \/\/        This is of the same form as (4a), and we have a solution:\n+  \/\/        pre_iter_C_const = pre_iter\n+  \/\/\n+  \/\/  (4b): Set var_init = 0, and assume (4a), which we just proved is implied by (3).\n+  \/\/        Subtract (4a) from (3):\n+  \/\/\n+  \/\/        0 =\n+  \/\/          =  (C_const + C_invar * var_invar + C_init * var_init + C_pre * pre_iter) % aw\n+  \/\/           - (C_const + C_pre * pre_iter_C_const) % aw\n+  \/\/          =  (C_invar * var_invar + C_init * var_init + C_pre * pre_iter - C_pre * pre_iter_C_const) % aw\n+  \/\/          =  (C_invar * var_invar + C_init * 0        + C_pre * (pre_iter - pre_iter_C_const)) % aw\n+  \/\/          =  (C_invar * var_invar +                   + C_pre * (pre_iter - pre_iter_C_const)) % aw\n+  \/\/\n+  \/\/        This is of the same form as (4b), and we have a solution:\n+  \/\/        pre_iter_C_invar = pre_iter - pre_iter_C_const\n+  \/\/\n+  \/\/  (4c): Set var_invar = 0, and assume (4a), which we just proved is implied by (3).\n+  \/\/        Subtract (4a) from (3):\n+  \/\/\n+  \/\/        0 =\n+  \/\/          =  (C_const + C_invar * var_invar + C_init * var_init + C_pre * pre_iter) % aw\n+  \/\/           - (C_const + C_pre * pre_iter_C_const) % aw\n+  \/\/          =  (C_invar * var_invar + C_init * var_init + C_pre * pre_iter - C_pre * pre_iter_C_const) % aw\n+  \/\/          =  (C_invar * 0         + C_init * var_init + C_pre * (pre_iter - pre_iter_C_const)) % aw\n+  \/\/          =  (                    + C_init * var_init + C_pre * (pre_iter - pre_iter_C_const)) % aw\n@@ -837,4 +881,2 @@\n-  \/\/ If we cannot prove that the C_const, init and invar terms can be aligned independently, then\n-  \/\/ we can always modify init (by 1) or invar (by var_invar), and hence invalidate (3). Hence,\n-  \/\/ this strengthening is necessary to guarantee statically that (3) has a solution, i.e. that\n-  \/\/ we can ensure alignment for any runtime value of init or invar.\n+  \/\/        This is of the same form as (4c), and we have a solution:\n+  \/\/        pre_iter_C_invar = pre_iter - pre_iter_C_const\n@@ -842,1 +884,2 @@\n-  \/\/ Equations (4a, b, c) can have one of these states:\n+  \/\/ The solutions of Equations (4a, b, c) for pre_iter_C_const, pre_iter_C_invar, and pre_iter_C_init\n+  \/\/ respectively, can have one of these states:\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":65,"deletions":22,"binary":false,"changes":87,"status":"modified"}]}