{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -172,0 +172,4 @@\n+  if (gvn().type(unbox)->isa_vect() == nullptr) {\n+    assert(gvn().type(unbox) == Type::TOP, \"sanity\");\n+    return nullptr; \/\/ not a vector\n+  }\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1922,0 +1922,9 @@\n+    \/\/ Skip the optimization if the mask is dead.\n+    if (phase->type(mask) == Type::TOP) {\n+      return nullptr;\n+    }\n+    \/\/ If the ideal graph is transformed correctly, the input mask should be a\n+    \/\/ vector type node. Following optimization can ignore the mismatched type\n+    \/\/ issue. But we still keep the sanity check for the mask type by using\n+    \/\/ \"is_vect()\" in the assertion below, so that there can be less optimizations\n+    \/\/ evolved before the compiler finally runs into a problem.\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"}]}