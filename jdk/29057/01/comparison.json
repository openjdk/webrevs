{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -625,1 +625,2 @@\n-  if (!Matcher::mask_op_prefers_predicate(mopc, mask_vec->bottom_type()->is_vect())) {\n+  const TypeVect* mask_vt = TypeVect::makemask(elem_bt, num_elem);\n+  if (!Matcher::mask_op_prefers_predicate(mopc, mask_vt)) {\n@@ -2548,1 +2549,2 @@\n-      if (!Matcher::mask_op_prefers_predicate(Op_VectorMaskToLong, opd->bottom_type()->is_vect())) {\n+      const TypeVect* mask_vt = TypeVect::makemask(elem_bt, num_elem);\n+      if (!Matcher::mask_op_prefers_predicate(Op_VectorMaskToLong, mask_vt)) {\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1922,0 +1922,9 @@\n+    \/\/ Skip the optimization if the mask is dead.\n+    if (phase->type(mask) == Type::TOP) {\n+      return nullptr;\n+    }\n+    \/\/ If the ideal graph is transformed correctly, the input mask should be a\n+    \/\/ vector type node. Following optimization can ignore the mismatched type\n+    \/\/ issue. But we still keep the sanity check for the mask type by using\n+    \/\/ \"is_vect()\" in the assertion below, so that there can be less optimizations\n+    \/\/ evolved before the compiler finally runs into a problem.\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"}]}