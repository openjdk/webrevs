{"files":[{"patch":"@@ -1727,1 +1727,1 @@\n-                digitList, false, false, status);\n+                digitList, false, false, status).fullPos();\n@@ -1735,20 +1735,0 @@\n-\n-        \/\/ If parse integer only is true and the parsing is broken at\n-        \/\/ decimal point, then pass\/ignore all digits and move pointer\n-        \/\/ at the start of suffix, to process the suffix part\n-        if (isParseIntegerOnly() && position < text.length()\n-                && text.charAt(position) == symbols.getDecimalSeparator()) {\n-            position++; \/\/ Pass decimal character\n-            for (; position < text.length(); ++position) {\n-                char ch = text.charAt(position);\n-                int digit = ch - symbols.getZeroDigit();\n-                if (digit < 0 || digit > 9) {\n-                    digit = Character.digit(ch, 10);\n-                    \/\/ Parse all digit characters\n-                    if (!(digit >= 0 && digit <= 9)) {\n-                        break;\n-                    }\n-                }\n-            }\n-        }\n-\n@@ -2375,0 +2355,2 @@\n+     * @implSpec This implementation does not set the {@code ParsePosition} index\n+     * to the position of the decimal symbol, but rather the end of the string.\n","filename":"src\/java.base\/share\/classes\/java\/text\/CompactNumberFormat.java","additions":3,"deletions":21,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2153,4 +2153,1 @@\n-     *   <li> {@link #isParseIntegerOnly()} returns {@code true}, and the decimal\n-     *   separator is found\n-     *   <li> {@link #isGroupingUsed()} returns {@code true} and {@link\n-     *   #isParseIntegerOnly()} returns {@code false}, and the grouping\n+     *   <li> {@link #isGroupingUsed()} returns {@code true} and the grouping\n@@ -2382,1 +2379,2 @@\n-        position = subparseNumber(text, position, digits, true, isExponent, status);\n+        Position pos = subparseNumber(text, position, digits, true, isExponent, status);\n+        position = pos.fullPos;\n@@ -2425,3 +2423,9 @@\n-            \/\/ No failures, thus increment the index by the suffix\n-            parsePosition.index = position +\n-                    (gotPositive ? positiveSuffix.length() : negativeSuffix.length());\n+            \/\/ When parsing integer only, index should be int pos\n+            \/\/ If intPos is 0, the entire value was integer\n+            if (isParseIntegerOnly() && pos.intPos > 0) {\n+                parsePosition.index = pos.intPos;\n+            } else {\n+                \/\/ increment the index by the suffix\n+                parsePosition.index = position +\n+                        (gotPositive ? positiveSuffix.length() : negativeSuffix.length());\n+            }\n@@ -2440,0 +2444,3 @@\n+    \/\/ To track the full parse index as well as the integer portion\n+    record Position(int intPos, int fullPos) {}\n+\n@@ -2455,1 +2462,1 @@\n-    int subparseNumber(String text, int position,\n+    Position subparseNumber(String text, int position,\n@@ -2460,0 +2467,1 @@\n+        int intIndex = 0;\n@@ -2519,1 +2527,1 @@\n-                    return position;\n+                    return new Position(intIndex, position);\n@@ -2541,1 +2549,3 @@\n-                        digits.append((char)(digit + '0'));\n+                        if (!sawDecimal || !isParseIntegerOnly()) {\n+                            digits.append((char)(digit + '0'));\n+                        }\n@@ -2546,1 +2556,3 @@\n-                    digits.append((char)(digit + '0'));\n+                    if (!sawDecimal || !isParseIntegerOnly()) {\n+                        digits.append((char) (digit + '0'));\n+                    }\n@@ -2553,1 +2565,1 @@\n-                        return groupingViolationIndex(position, prevSeparatorIndex);\n+                        return new Position(intIndex, groupingViolationIndex(position, prevSeparatorIndex));\n@@ -2557,1 +2569,1 @@\n-                    if (isParseIntegerOnly() || sawDecimal) {\n+                    if (sawDecimal) {\n@@ -2560,0 +2572,1 @@\n+                    intIndex = position;\n@@ -2566,1 +2579,1 @@\n-                            return startPos;\n+                            return new Position(intIndex, startPos);\n@@ -2571,1 +2584,1 @@\n-                            return groupingViolationIndex(position, prevSeparatorIndex);\n+                            return new Position(intIndex, groupingViolationIndex(position, prevSeparatorIndex));\n@@ -2624,1 +2637,1 @@\n-                    return groupingViolationIndex(position - 1, prevSeparatorIndex);\n+                    return new Position(intIndex, groupingViolationIndex(position - 1, prevSeparatorIndex));\n@@ -2639,2 +2652,3 @@\n-            \/\/ Adjust for exponent, if any\n-            if (exponent != 0) {\n+            \/\/ If parsing integer only, adjust exponent if it occurs\n+            \/\/ in integer portion, otherwise ignore it\n+            if (!sawDecimal || !isParseIntegerOnly()) {\n@@ -2649,1 +2663,1 @@\n-                return -1;\n+                return new Position(intIndex, -1);\n@@ -2652,1 +2666,1 @@\n-        return position;\n+        return new Position(intIndex, position);\n@@ -2920,1 +2934,2 @@\n-     * \"123\" is parsed into 1.23.\n+     * \"123\" is parsed into 1.23. If {@code isParseIntegerOnly()} returns {@code true},\n+     * \"123\" is parsed into 1.\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormat.java","additions":37,"deletions":22,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -471,1 +471,3 @@\n-     * Returns true if this format will parse numbers as integers only.\n+     * Returns {@code true} if this format will parse numbers as integers only.\n+     * The {@code ParsePosition} index will be set to the position of the decimal\n+     * symbol. The exact format accepted by the parse operation is locale dependent.\n@@ -473,4 +475,1 @@\n-     * string \"1234.\" would be parsed as the integer value 1234 and parsing\n-     * would stop at the \".\" character.  Of course, the exact format accepted\n-     * by the parse operation is locale dependent and determined by sub-classes\n-     * of NumberFormat.\n+     * string \"123.45\" would be parsed as the integer value 123.\n","filename":"src\/java.base\/share\/classes\/java\/text\/NumberFormat.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 4018937 8008577 8174269\n+ * @bug 4018937 8008577 8174269 8333755\n@@ -32,2 +32,6 @@\n-import java.text.*;\n-import java.util.*;\n+import java.text.DecimalFormat;\n+import java.text.Format;\n+import java.text.MessageFormat;\n+import java.text.NumberFormat;\n+import java.text.ParsePosition;\n+import java.util.Locale;\n@@ -546,1 +550,5 @@\n-         * DecimalFormat.parse() for some cases.\n+         * DecimalFormat.parse() for some cases. This is because parsing integer\n+         * only will return a successful parse for the subformat, but since the index\n+         * returned is not equal to the length, at the MessageFormat level, this\n+         * will be interpreted as a failed parse, and so the DecimalFormat index\n+         * should be reflected as the MessageFormat errorIndex.\n@@ -551,5 +559,3 @@\n-        {2, 0},         \/\/ parsing stopped at '(' because cannot find ')'\n-        {2, 0},         \/\/ parsing stopped at the first numeric\n-                        \/\/ because cannot find '%'\n-        {2, 0},         \/\/ parsing stopped at the first numeric\n-                        \/\/ because cannot find '%'\n+        {30, 0},        \/\/ parsing stopped at '.'\n+        {31, 0},        \/\/ parsing stopped at '.'\n+        {32, 0},        \/\/ parsing stopped at '.'\n@@ -558,1 +564,0 @@\n-\n@@ -561,2 +566,1 @@\n-                        \/\/ because cannot find '%'\n-        {2, 0},         \/\/ parsing stopped at '(' because cannot find ')'\n+        {57, 0},        \/\/ parsing stopped at '.'\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/BigDecimalParse.java","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8327640 8331485\n+ * @bug 8327640 8331485 8333755\n@@ -37,0 +37,1 @@\n+import org.junit.jupiter.api.BeforeEach;\n@@ -75,11 +76,12 @@\n-\n-\n-    \/\/ All NumberFormats should parse strictly\n-    static {\n-        dFmt.setStrict(true);\n-        pFmt.setStrict(true);\n-        cFmt.setStrict(true);\n-        cmpctFmt.setStrict(true);\n-        \/\/ To effectively test strict compactNumberFormat parsing\n-        cmpctFmt.setParseIntegerOnly(false);\n-        cmpctFmt.setGroupingUsed(true);\n+    private static final NumberFormat[] FORMATS = new NumberFormat[]{dFmt, cFmt, pFmt, cmpctFmt};\n+\n+    \/\/ Restore defaults before runs\n+    @BeforeEach\n+    void beforeEach() {\n+        for (NumberFormat fmt : FORMATS) {\n+            fmt.setStrict(true);\n+            fmt.setParseIntegerOnly(false);\n+            fmt.setGroupingUsed(true);\n+        }\n+        \/\/ Grouping Size is not defined at NumberFormat level\n+        \/\/ Compact needs to manually init grouping size\n@@ -117,0 +119,14 @@\n+\n+    \/\/ 8333755: Check that parsing with integer only against a suffix value works\n+    @Test \/\/ Non-localized, run once\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    public void integerOnlyParseWithSuffixTest() {\n+        \/\/ Some pattern with a suffix\n+        DecimalFormat fmt = new DecimalFormat(\"0.00b\");\n+        fmt.setParseIntegerOnly(true);\n+        assertEquals(5d, successParse(fmt, \"5.55b\", 1));\n+        assertEquals(5d, successParse(fmt, \"5b\", 2));\n+        assertEquals(5555d, successParse(fmt, \"5,555.55b\", 5));\n+        assertEquals(5d, successParse(fmt, \"5.55E55b\", 1));\n+    }\n+\n@@ -173,1 +189,0 @@\n-        dFmt.setGroupingUsed(true);\n@@ -176,2 +191,3 @@\n-    \/\/ Exception should be thrown if decimal separator occurs anywhere\n-    \/\/ Don't pass badParseStrings for same reason as previous method.\n+    \/\/ 8333755: Parsing behavior should follow normal strict behavior\n+    \/\/ However the index returned, should be before decimal point\n+    \/\/ and the value parsed equal to the integer portion\n@@ -179,4 +195,2 @@\n-    @MethodSource({\"validParseStrings\", \"integerOnlyParseStrings\"})\n-    public void numFmtStrictIntegerOnlyUsed(String toParse) {\n-        \/\/ When integer only is true, if a decimal separator is found,\n-        \/\/ a failure should occur\n+    @MethodSource(\"validIntegerOnlyParseStrings\")\n+    public void numFmtStrictIntegerOnlyUsedTest(String toParse, Number expVal) {\n@@ -184,3 +198,3 @@\n-        int failIndex = toParse.indexOf(dfs.getDecimalSeparator());\n-        if (failIndex > -1) {\n-            failParse(dFmt, toParse, failIndex);\n+        int expectedIndex = toParse.indexOf(dfs.getDecimalSeparator());\n+        if (expectedIndex > -1) {\n+            assertEquals(successParse(dFmt, toParse, expectedIndex), expVal);\n@@ -188,1 +202,1 @@\n-            successParse(dFmt, toParse);\n+            assertEquals(successParse(dFmt, toParse), expVal);\n@@ -190,1 +204,9 @@\n-        dFmt.setParseIntegerOnly(false);\n+    }\n+\n+    \/\/ 8333755: Parsing behavior should follow normal strict behavior\n+    \/\/ when it comes to failures.\n+    @ParameterizedTest\n+    @MethodSource(\"badParseStrings\")\n+    public void numFmtStrictIntegerOnlyUsedFailTest(String toParse, int expectedErrorIndex) {\n+        dFmt.setParseIntegerOnly(true);\n+        failParse(dFmt, toParse, expectedErrorIndex);\n@@ -273,0 +295,12 @@\n+    @ParameterizedTest\n+    @MethodSource({\"validIntegerOnlyParseStrings\", \"compactValidIntegerOnlyParseStrings\"})\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    public void compactFmtSuccessParseIntOnlyTest(String toParse, double expectedValue) {\n+        \/\/ compact does not accept exponents\n+        if (toParse.indexOf('E') > -1) {\n+            return;\n+        }\n+        cmpctFmt.setParseIntegerOnly(true);\n+        assertEquals(expectedValue, successParse(cmpctFmt, toParse, toParse.length()));\n+    }\n+\n@@ -282,1 +316,7 @@\n-    private double successParse(NumberFormat fmt, String toParse) {\n+    private Number successParse(NumberFormat fmt, String toParse) {\n+        return successParse(fmt, toParse, toParse.length());\n+    }\n+\n+    \/\/ Overloaded method used for integer only parsing, where the expected\n+    \/\/ index should occur at the decimal point, if one exists\n+    private Number successParse(NumberFormat fmt, String toParse, int expectedIndex) {\n@@ -295,1 +335,1 @@\n-        assertEquals(toParse.length(), pp.getIndex(),\n+        assertEquals(expectedIndex, pp.getIndex(),\n@@ -391,1 +431,3 @@\n-                Arguments.of(\"1,234,a\", 5))\n+                Arguments.of(\"1,234,a\", 5),\n+                \/\/ Double decimal\n+                Arguments.of(\"1,234..5\", 5))\n@@ -400,0 +442,2 @@\n+                Arguments.of(\"1,234.55\", 1234.55d),\n+                Arguments.of(\"1,234.5\", 1234.5d),\n@@ -417,4 +461,3 @@\n-    \/\/ Separate test data set for integer only. Can not use \"badParseStrings\", as\n-    \/\/ there is test data where the failure may occur from some other issue,\n-    \/\/ not related to grouping\n-    private static Stream<Arguments> integerOnlyParseStrings() {\n+    \/\/ Separate test data set for integer only.\n+    \/\/ Valid parse strings, that would parse successfully for integer\/non-integer parse\n+    private static Stream<Arguments> validIntegerOnlyParseStrings() {\n@@ -422,6 +465,9 @@\n-                Arguments.of(\"234.a\"),\n-                Arguments.of(\"234.a1\"),\n-                Arguments.of(\"234.1\"),\n-                Arguments.of(\"234.1a\"),\n-                Arguments.of(\"234.\"))\n-                .map(args -> Arguments.of(localizeText(String.valueOf(args.get()[0]))));\n+                Arguments.of(\"234\", 234d),\n+                Arguments.of(\"234.\", 234d),\n+                Arguments.of(\"234.1\", 234d),\n+                Arguments.of(\"1,234.1\", 1234d),\n+                Arguments.of(\"234.12345\", 234d),\n+                Arguments.of(\"234.543E23\", 234d),\n+                Arguments.of(\"234,000.55E22\", 234000d),\n+                Arguments.of(\"234E22\", 234E22))\n+                .map(args -> Arguments.of(localizeText(String.valueOf(args.get()[0])), args.get()[1]));\n@@ -517,0 +563,6 @@\n+    private static Stream<Arguments> compactValidIntegerOnlyParseStrings() {\n+        return validIntegerOnlyParseStrings().map(args -> Arguments.of(\n+                args.get()[0] + \"K\", (double) args.get()[1] * 1000)\n+        );\n+    }\n+\n@@ -529,1 +581,4 @@\n-            } else if (c == '0') {\n+            } else if (c == 'E') {\n+                sb.append(dfs.getExponentSeparator());\n+            }\n+            else if (c == '0') {\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/StrictParseTest.java","additions":93,"deletions":38,"binary":false,"changes":131,"status":"modified"}]}