{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,7 @@\n- * attempt to create a new file.  For example, if an annotation\n+ * attempt to create a new file.\n+ * In other words, the originating elements are intended to have the\n+ * granularity of <em>compilation units<\/em> (JLS section {@jls 7.3}),\n+ * essentially file-level granularity, rather than finer-scale\n+ * granularity of, say, a method or field declaration.\n+ *\n+ * <p>For example, if an annotation\n","filename":"src\/java.compiler\/share\/classes\/javax\/annotation\/processing\/Filer.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -134,0 +134,6 @@\n+    \/**\n+     * {@return the class or interface defining the executable}\n+     *\/\n+    @Override\n+    Element getEnclosingElement();\n+\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/ExecutableElement.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,13 +39,14 @@\n- * <p>When used in the context of annotation processing, an accurate\n- * model of the element being represented must be returned.  As this\n- * is a language model, the source code provides the fiducial\n- * (reference) representation of the construct in question rather than\n- * a representation in an executable output like a class file.\n- * Executable output may serve as the basis for creating a modeling\n- * element.  However, the process of translating source code to\n- * executable output may not permit recovering some aspects of the\n- * source code representation.  For example, annotations with\n- * {@linkplain java.lang.annotation.RetentionPolicy#SOURCE source}\n- * {@linkplain java.lang.annotation.Retention retention} cannot be\n- * recovered from class files and class files might not be able to\n- * provide source position information.\n+ * <p id=\"accurate_model\">When used in the context of annotation\n+ * processing, an accurate model of the element being represented must\n+ * be returned.  As this is a language model, the source code provides\n+ * the fiducial (reference) representation of the construct in\n+ * question rather than a representation in an executable output like\n+ * a class file.  Executable output may serve as the basis for\n+ * creating a modeling element.  However, the process of translating\n+ * source code to executable output may not permit recovering some\n+ * aspects of the source code representation.  For example,\n+ * annotations with {@linkplain\n+ * java.lang.annotation.RetentionPolicy#SOURCE source} {@linkplain\n+ * java.lang.annotation.Retention retention} cannot be recovered from\n+ * class files and class files might not be able to provide source\n+ * position information.\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/package-info.java","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -764,0 +764,96 @@\n+\n+    \/**\n+     * {@return the file object for this element or {@code null} if\n+     * there is no such file object}\n+     *\n+     * <p>The returned file object is for the <a\n+     * href=\"..\/element\/package-summary.html#accurate_model\">reference\n+     * representation<\/a> of the information used to construct the\n+     * element. For example, if during compilation or annotation\n+     * processing, a source file for class {@code Foo} is compiled\n+     * into a class file, the file object returned for the element\n+     * representing {@code Foo} would be for the source file and\n+     * <em>not<\/em> for the class file.\n+     *\n+     * <p>An implementation may choose to not support the\n+     * functionality of this method, in which case {@link\n+     * UnsupportedOperationException} is thrown.\n+     *\n+     * <p>In the context of annotation processing, a non-{@code null}\n+     * value is returned if the element was included as part of the\n+     * initial inputs or the containing file was created during the\n+     * run of the annotation processing tool. Otherwise, a {@code\n+     * null} may be returned. In annotation processing, if a\n+     * {@linkplain javax.annotation.processing.Filer#createClassFile\n+     * class file is created}, that class file can serve as the\n+     * reference representation for elements.\n+     *\n+     * <p>If it has a file object, the file object for a package will\n+     * be a {@code package-info} file. A package may exist and not\n+     * have any {@code package-info} file even if the package is\n+     * (implicitly) created during an annotation processing run from\n+     * the creation of source or class files in that package.  An\n+     * {@linkplain PackageElement#isUnnamed unnamed package} will have\n+     * a {@code null} file since it cannot be declared in a\n+     * compilation unit.\n+     *\n+     * <p>If it has a file object, the file object for a module will\n+     * be a {@code module-info} file.  An {@linkplain\n+     * ModuleElement#isUnnamed unnamed module} will have a {@code\n+     * null} file since it cannot be declared in a compilation unit.\n+     * An {@linkplain #isAutomaticModule automatic module} will have a\n+     * {@code null} file since it is implicitly declared.\n+     *\n+     * <p>If it has a file object, the file object for a top-level\n+     * {@code public} class or interface will be a source or class\n+     * file corresponding to that class or interface. In this case,\n+     * typically the leading portion of the name of the file will\n+     * match the name of the class or interface. A single compilation\n+     * unit can define multiple top-level classes and interfaces, such\n+     * as a primary {@code public} class or interfaces whose name\n+     * corresponds to the file name and one or more <em>auxiliary<\/em>\n+     * classes or interfaces whose names do not correspond to the file\n+     * name. If a source file is providing the reference\n+     * representation of an auxiliary class or interface, the file for\n+     * the primary class is returned. (An auxiliary class or interface\n+     * can also be defined in a {@code package-info} source file, in\n+     * which case the file for the {@code package-info} file is\n+     * returned.)  If a class file is providing the reference\n+     * representation of an auxiliary class or interface, the separate\n+     * class file for the auxiliary class is returned.\n+     *\n+     * <p>For a nested class or interface, if it has a file object:\n+     *\n+     * <ul>\n+     *\n+     * <li>if a source file is providing the reference representation,\n+     * the file object will be that of the {@linkplain\n+     * #getOutermostTypeElement(Element) outermost enclosing} class or\n+     * interface\n+     *\n+     * <li>if a class file is providing the reference representation,\n+     * the file object will be that of the nested class or interface\n+     * itself\n+     *\n+     * <\/ul>\n+     *\n+     * <p>For other lexically enclosed elements, such as {@linkplain\n+     * VariableElement#getEnclosingElement() variables}, {@linkplain\n+     * ExecutableElement#getEnclosingElement() methods, and\n+     * constructors}, if they have a file object, the file object will\n+     * be the object associated with the {@linkplain\n+     * Element#getEnclosingElement() enclosing element} of the\n+     * lexically enclosed element.\n+     *\n+     * @implSpec The default implementation unconditionally throws\n+     * {@link UnsupportedOperationException}.\n+     *\n+     * @throws UnsupportedOperationException if this functionality is\n+     * not supported\n+     *\n+     * @param e the element to find a file object for\n+     * @since 18\n+     *\/\n+    default javax.tools.JavaFileObject getFileObjectOf(Element e) {\n+        throw new UnsupportedOperationException();\n+    }\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Elements.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -379,1 +379,1 @@\n-                c.sourcefile = tree.sourcefile;\n+                c.classfile = c.sourcefile = tree.sourcefile;\n@@ -498,1 +498,1 @@\n-        c.sourcefile = env.toplevel.sourcefile;\n+        c.classfile = c.sourcefile = env.toplevel.sourcefile;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Enter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -332,1 +332,1 @@\n-            sym.module_info.sourcefile = toplevel.sourcefile;\n+            sym.module_info.classfile = sym.module_info.sourcefile = toplevel.sourcefile;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Modules.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -730,0 +730,24 @@\n+    @Override @DefinedBy(Api.LANGUAGE_MODEL)\n+    public JavaFileObject getFileObjectOf(Element e) {\n+        Symbol sym = (Symbol) e;\n+        return switch(sym.kind) {\n+            case PCK -> {\n+                PackageSymbol psym = (PackageSymbol) sym;\n+                if (psym.package_info == null) {\n+                    yield null;\n+                }\n+                yield psym.package_info.classfile;\n+            }\n+\n+            case MDL -> {\n+                ModuleSymbol msym = (ModuleSymbol) sym;\n+                if (msym.module_info == null) {\n+                    yield null;\n+                }\n+                yield msym.module_info.classfile;\n+            }\n+            case TYP -> ((ClassSymbol) sym).classfile;\n+            default -> sym.enclClass().classfile;\n+        };\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/model\/JavacElements.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,596 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8224922\n+ * @summary Verify the behavior of the Elements.getFileObjectOf\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.jdeps\/com.sun.tools.classfile\n+ * @build toolbox.ToolBox toolbox.JavacTask toolbox.TestRunner\n+ * @build TestFileObjectOf\n+ * @run main TestFileObjectOf\n+ *\/\n+\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.util.TreePath;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayDeque;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.Set;\n+\n+import javax.annotation.processing.*;\n+import javax.lang.model.SourceVersion;\n+import javax.lang.model.element.*;\n+import javax.lang.model.util.Elements;\n+\n+import com.sun.source.util.TreePathScanner;\n+import com.sun.source.util.Trees;\n+import javax.tools.JavaFileObject;\n+import toolbox.JarTask;\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+\n+public class TestFileObjectOf extends TestRunner {\n+\n+    private final ToolBox tb;\n+\n+    TestFileObjectOf() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        new TestFileObjectOf().runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testSourceFiles(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          module m {}\n+                          \"\"\",\n+                          \"\"\"\n+                          package test;\n+                          \"\"\",\n+                          \"\"\"\n+                          package test;\n+                          public class TestClass {\n+                              int fieldTestClass;\n+                              TestClass() { }\n+                              void methodTestClass(int parameterTestClass) {\n+                                  int localTestClass;\n+                              }\n+                              public static class InnerClass {\n+                                  int fieldInnerClass;\n+                                  InnerClass() {}\n+                                  void methodInnerClass(int parameterInnerClass) {\n+                                      int localInnerClass;\n+                                  }\n+                              }\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package test;\n+                          public enum TestEnum {\n+                              CONSTANT;\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package test2;\n+                          public class TestClass2 {}\n+                          \"\"\");\n+        Path classes = base.resolve(\"classes\").resolve(\"m\");\n+        tb.createDirectories(classes);\n+\n+        \/\/from source, implicit:\n+        {\n+            String moduleInfoSource = src.resolve(\"module-info.java\").toUri().toString();\n+            String packageInfoSource = src.resolve(\"test\").resolve(\"package-info.java\").toUri().toString();\n+            String testClassSource = src.resolve(\"test\").resolve(\"TestClass.java\").toUri().toString();\n+            String testEnumSource = src.resolve(\"test\").resolve(\"TestEnum.java\").toUri().toString();\n+            String testClass2Source = src.resolve(\"test2\").resolve(\"TestClass2.java\").toUri().toString();\n+\n+            List<String> log;\n+\n+            log = new JavacTask(tb)\n+                .options(\"-Xpkginfo:always\",\n+                         \"-processorpath\", System.getProperty(\"test.classes\"),\n+                         \"-processor\", PrintFiles.class.getName(),\n+                         \"-sourcepath\", src.toString())\n+                .outdir(classes)\n+                .classes(\"java.lang.Object\")\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.STDOUT);\n+\n+            List<String> expected = List.of(\n+                    \"m: \" + moduleInfoSource,\n+                    \"test: \" + packageInfoSource,\n+                    \"test2: \" + \"<null>\",\n+                    \"TestClass: \" + testClassSource,\n+                    \"TestEnum: \" + testEnumSource,\n+                    \"TestClass2: \" + testClass2Source,\n+                    \"<init>: \" + testClassSource,\n+                    \"InnerClass: \" + testClassSource,\n+                    \"fieldTestClass: \" + testClassSource,\n+                    \"methodTestClass: \" + testClassSource,\n+                    \"parameterTestClass: \" + testClassSource,\n+                    \"localTestClass: \" + testClassSource,\n+                    \"<init>: \" + testEnumSource,\n+                    \"CONSTANT: \" + testEnumSource,\n+                    \"valueOf: \" + testEnumSource,\n+                    \"values: \" + testEnumSource,\n+                    \"<init>: \" + testClass2Source,\n+                    \"<init>: \" + testClassSource,\n+                    \"fieldInnerClass: \" + testClassSource,\n+                    \"methodInnerClass: \" + testClassSource,\n+                    \"parameterInnerClass: \" + testClassSource,\n+                    \"localInnerClass: \" + testClassSource\n+            );\n+\n+            if (!expected.equals(log))\n+                throw new AssertionError(\"expected output not found: \" + log);\n+        }\n+\n+        tb.cleanDirectory(classes);\n+\n+        \/\/from source, explicit:\n+        {\n+            String moduleInfoSource = src.resolve(\"module-info.java\").toUri().toString();\n+            String packageInfoSource = src.resolve(\"test\").resolve(\"package-info.java\").toUri().toString();\n+            String testClassSource = src.resolve(\"test\").resolve(\"TestClass.java\").toUri().toString();\n+            String testEnumSource = src.resolve(\"test\").resolve(\"TestEnum.java\").toUri().toString();\n+            String testClass2Source = src.resolve(\"test2\").resolve(\"TestClass2.java\").toUri().toString();\n+\n+            List<String> log;\n+\n+            log = new JavacTask(tb)\n+                .options(\"-Xpkginfo:always\",\n+                         \"-processorpath\", System.getProperty(\"test.classes\"),\n+                         \"-processor\", PrintFiles.class.getName())\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.STDOUT);\n+\n+            List<String> expected = List.of(\n+                    \"m: \" + moduleInfoSource,\n+                    \"test: \" + packageInfoSource,\n+                    \"test2: \" + \"<null>\",\n+                    \"TestClass: \" + testClassSource,\n+                    \"TestEnum: \" + testEnumSource,\n+                    \"TestClass2: \" + testClass2Source,\n+                    \"<init>: \" + testClassSource,\n+                    \"InnerClass: \" + testClassSource,\n+                    \"fieldTestClass: \" + testClassSource,\n+                    \"methodTestClass: \" + testClassSource,\n+                    \"parameterTestClass: \" + testClassSource,\n+                    \"localTestClass: \" + testClassSource,\n+                    \"<init>: \" + testEnumSource,\n+                    \"CONSTANT: \" + testEnumSource,\n+                    \"valueOf: \" + testEnumSource,\n+                    \"values: \" + testEnumSource,\n+                    \"<init>: \" + testClass2Source,\n+                    \"<init>: \" + testClassSource,\n+                    \"fieldInnerClass: \" + testClassSource,\n+                    \"methodInnerClass: \" + testClassSource,\n+                    \"parameterInnerClass: \" + testClassSource,\n+                    \"localInnerClass: \" + testClassSource\n+            );\n+\n+            if (!expected.equals(log))\n+                throw new AssertionError(\"expected output not found: \" + log);\n+        }\n+\n+        \/\/from class:\n+        {\n+            String moduleInfoSource = classes.resolve(\"module-info.class\").toUri().toString();\n+            String packageInfoSource = classes.resolve(\"test\").resolve(\"package-info.class\").toUri().toString();\n+            String testClassSource = classes.resolve(\"test\").resolve(\"TestClass.class\").toUri().toString();\n+            String testInnerClassSource = classes.resolve(\"test\").resolve(\"TestClass$InnerClass.class\").toUri().toString();\n+            String testEnumSource = classes.resolve(\"test\").resolve(\"TestEnum.class\").toUri().toString();\n+            String testClass2Source = classes.resolve(\"test2\").resolve(\"TestClass2.class\").toUri().toString();\n+\n+            List<String> log;\n+\n+            log = new JavacTask(tb)\n+                .options(\"-processorpath\", System.getProperty(\"test.classes\"),\n+                         \"-processor\", PrintFiles.class.getName(),\n+                         \"--module-path\", classes.toString(),\n+                         \"--add-modules\", \"m\")\n+                .outdir(classes)\n+                .classes(\"java.lang.Object\")\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.STDOUT);\n+\n+            List<String> expected = List.of(\n+                    \"m: \" + moduleInfoSource,\n+                    \"test: \" + packageInfoSource,\n+                    \"test2: \" + \"<null>\",\n+                    \"TestClass: \" + testClassSource,\n+                    \"TestEnum: \" + testEnumSource,\n+                    \"TestClass2: \" + testClass2Source,\n+                    \"<init>: \" + testClassSource,\n+                    \"InnerClass: \" + testInnerClassSource,\n+                    \"fieldTestClass: \" + testClassSource,\n+                    \"methodTestClass: \" + testClassSource,\n+                    \"<clinit>: \" + testEnumSource,\n+                    \"<init>: \" + testEnumSource,\n+                    \"CONSTANT: \" + testEnumSource,\n+                    \"valueOf: \" + testEnumSource,\n+                    \"values: \" + testEnumSource,\n+                    \"<init>: \" + testClass2Source,\n+                    \"<init>: \" + testInnerClassSource,\n+                    \"fieldInnerClass: \" + testInnerClassSource,\n+                    \"methodInnerClass: \" + testInnerClassSource\n+            );\n+\n+            if (!expected.equals(log))\n+                throw new AssertionError(\"expected output not found: \" + log);\n+        }\n+    }\n+\n+    @SupportedAnnotationTypes(\"*\")\n+    @SupportedOptions(\"fromClass\")\n+    public static final class PrintFiles extends AbstractProcessor {\n+\n+        @Override\n+        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+            if (!roundEnv.processingOver())\n+                return false;\n+\n+            Elements elements = processingEnv.getElementUtils();\n+            Trees trees = Trees.instance(processingEnv);\n+            Queue<Element> q = new ArrayDeque<>();\n+            q.add(elements.getModuleElement(\"m\"));\n+\n+            while (!q.isEmpty()) {\n+                Element currentElement = q.remove();\n+\n+                handleDeclaration(currentElement);\n+\n+                switch (currentElement.getKind()) {\n+                    case METHOD -> {\n+                        ExecutableElement method = (ExecutableElement) currentElement;\n+                        TreePath tp = trees.getPath(method);\n+                        if (tp != null) {\n+                            new TreePathScanner<>() {\n+                                @Override\n+                                public Object visitVariable(VariableTree node, Object p) {\n+                                    Element el = trees.getElement(getCurrentPath());\n+                                    handleDeclaration(el);\n+                                    return super.visitVariable(node, p);\n+                                }\n+                            }.scan(tp, null);\n+                        }\n+                    }\n+                    case MODULE -> {\n+                        q.add(elements.getPackageElement(\"test\"));\n+                        q.add(elements.getPackageElement(\"test2\"));\n+                    }\n+                    default ->\n+                        currentElement.getEnclosedElements()\n+                                      .stream()\n+                                      .sorted((e1, e2) -> e1.getSimpleName().toString().compareTo(e2.getSimpleName().toString()))\n+                                      .forEach(q::add);\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        void handleDeclaration(Element el) {\n+            Elements elements = processingEnv.getElementUtils();\n+            JavaFileObject fileObjects = elements.getFileObjectOf(el);\n+            System.out.println(el.getSimpleName() + \": \" + (fileObjects != null ? fileObjects.toUri().toString() : \"<null>\"));\n+        }\n+\n+        @Override\n+        public SourceVersion getSupportedSourceVersion() {\n+            return SourceVersion.latestSupported();\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testUnnamed(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          public class TestClass {\n+                          }\n+                          \"\"\");\n+        Path classes = base.resolve(\"classes\");\n+        tb.createDirectories(classes);\n+\n+        \/\/from source, implicit:\n+        {\n+            String testClassSource = src.resolve(\"TestClass.java\").toUri().toString();\n+\n+            List<String> log;\n+\n+            log = new JavacTask(tb)\n+                .options(\"-Xpkginfo:always\",\n+                         \"-classpath\", \"\",\n+                         \"-processorpath\", System.getProperty(\"test.classes\"),\n+                         \"-processor\", UnnamedPrintFiles.class.getName(),\n+                         \"-sourcepath\", src.toString())\n+                .outdir(classes)\n+                .classes(\"java.lang.Object\")\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.STDOUT);\n+\n+            List<String> expected = List.of(\n+                    \": \" + \"<null>\",\n+                    \": \" + \"<null>\",\n+                    \"TestClass: \" + testClassSource,\n+                    \"<init>: \" + testClassSource\n+            );\n+\n+            if (!expected.equals(log))\n+                throw new AssertionError(\"expected output not found: \" + log);\n+        }\n+\n+        tb.cleanDirectory(classes);\n+\n+        \/\/from source, explicit:\n+        {\n+            String testClassSource = src.resolve(\"TestClass.java\").toUri().toString();\n+\n+            List<String> log;\n+\n+            log = new JavacTask(tb)\n+                .options(\"-Xpkginfo:always\",\n+                         \"-classpath\", \"\",\n+                         \"-processorpath\", System.getProperty(\"test.classes\"),\n+                         \"-processor\", UnnamedPrintFiles.class.getName())\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.STDOUT);\n+\n+            List<String> expected = List.of(\n+                    \": \" + \"<null>\",\n+                    \": \" + \"<null>\",\n+                    \"TestClass: \" + testClassSource,\n+                    \"<init>: \" + testClassSource\n+            );\n+\n+            if (!expected.equals(log))\n+                throw new AssertionError(\"expected output not found: \" + log);\n+        }\n+\n+        \/\/from class:\n+        {\n+            String testClassSource = classes.resolve(\"TestClass.class\").toUri().toString();\n+\n+            List<String> log;\n+\n+            log = new JavacTask(tb)\n+                .options(\"-processorpath\", System.getProperty(\"test.classes\"),\n+                         \"-processor\", UnnamedPrintFiles.class.getName(),\n+                         \"-classpath\", classes.toString())\n+                .outdir(classes)\n+                .classes(\"java.lang.Object\")\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.STDOUT);\n+\n+            List<String> expected = List.of(\n+                    \": \" + \"<null>\",\n+                    \": \" + \"<null>\",\n+                    \"TestClass: \" + testClassSource,\n+                    \"<init>: \" + testClassSource\n+            );\n+\n+            if (!expected.equals(log))\n+                throw new AssertionError(\"expected output not found: \" + log);\n+        }\n+    }\n+\n+    @SupportedAnnotationTypes(\"*\")\n+    @SupportedOptions(\"fromClass\")\n+    public static final class UnnamedPrintFiles extends AbstractProcessor {\n+\n+        @Override\n+        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+            if (!roundEnv.processingOver())\n+                return false;\n+\n+            Elements elements = processingEnv.getElementUtils();\n+            Trees trees = Trees.instance(processingEnv);\n+            Queue<Element> q = new ArrayDeque<>();\n+            q.add(elements.getModuleElement(\"\"));\n+\n+            while (!q.isEmpty()) {\n+                Element currentElement = q.remove();\n+\n+                handleDeclaration(currentElement);\n+\n+                switch (currentElement.getKind()) {\n+                    case METHOD -> {\n+                        ExecutableElement method = (ExecutableElement) currentElement;\n+                        TreePath tp = trees.getPath(method);\n+                        if (tp != null) {\n+                            new TreePathScanner<>() {\n+                                @Override\n+                                public Object visitVariable(VariableTree node, Object p) {\n+                                    Element el = trees.getElement(getCurrentPath());\n+                                    handleDeclaration(el);\n+                                    return super.visitVariable(node, p);\n+                                }\n+                            }.scan(tp, null);\n+                        }\n+                    }\n+                    case MODULE -> {\n+                        q.add(elements.getPackageElement(\"\"));\n+                    }\n+                    default ->\n+                        currentElement.getEnclosedElements()\n+                                      .stream()\n+                                      .sorted((e1, e2) -> e1.getSimpleName().toString().compareTo(e2.getSimpleName().toString()))\n+                                      .forEach(q::add);\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        void handleDeclaration(Element el) {\n+            Elements elements = processingEnv.getElementUtils();\n+            JavaFileObject fileObjects = elements.getFileObjectOf(el);\n+            System.out.println(el.getSimpleName() + \": \" + (fileObjects != null ? fileObjects.toUri().toString() : \"<null>\"));\n+        }\n+\n+        @Override\n+        public SourceVersion getSupportedSourceVersion() {\n+            return SourceVersion.latestSupported();\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testAutomaticModule(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          package test;\n+                          public class TestClass {\n+                          }\n+                          \"\"\");\n+        Path classes = base.resolve(\"classes\");\n+        tb.createDirectories(classes);\n+\n+        Path module = base.resolve(\"m.jar\");\n+\n+        new JavacTask(tb)\n+            .options(\"-classpath\", \"\")\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run()\n+            .writeAll();\n+        new JarTask(tb, module)\n+            .baseDir(classes)\n+            .files(\".\")\n+            .run();\n+\n+        String testClassSource = \"jar:\" + module.toUri().toString() + \"!\/test\/TestClass.class\";\n+\n+        List<String> log;\n+\n+        log = new JavacTask(tb)\n+            .options(\"-processorpath\", System.getProperty(\"test.classes\"),\n+                     \"-processor\", AutomaticModulePrintFiles.class.getName(),\n+                     \"--module-path\", module.toString(),\n+                     \"--add-modules\", \"m\")\n+            .outdir(classes)\n+            .classes(\"java.lang.Object\")\n+            .run()\n+            .writeAll()\n+            .getOutputLines(Task.OutputKind.STDOUT);\n+\n+        List<String> expected = List.of(\n+                \"m: \" + \"<null>\",\n+                \"test: \" + \"<null>\",\n+                \"TestClass: \" + testClassSource,\n+                \"<init>: \" + testClassSource\n+        );\n+\n+        if (!expected.equals(log))\n+            throw new AssertionError(\"expected output not found: \" + log);\n+    }\n+\n+    @SupportedAnnotationTypes(\"*\")\n+    @SupportedOptions(\"fromClass\")\n+    public static final class AutomaticModulePrintFiles extends AbstractProcessor {\n+\n+        @Override\n+        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+            if (!roundEnv.processingOver())\n+                return false;\n+\n+            Elements elements = processingEnv.getElementUtils();\n+            Trees trees = Trees.instance(processingEnv);\n+            Queue<Element> q = new ArrayDeque<>();\n+            q.add(elements.getModuleElement(\"m\"));\n+\n+            while (!q.isEmpty()) {\n+                Element currentElement = q.remove();\n+\n+                handleDeclaration(currentElement);\n+\n+                switch (currentElement.getKind()) {\n+                    case METHOD -> {\n+                        ExecutableElement method = (ExecutableElement) currentElement;\n+                        TreePath tp = trees.getPath(method);\n+                        if (tp != null) {\n+                            new TreePathScanner<>() {\n+                                @Override\n+                                public Object visitVariable(VariableTree node, Object p) {\n+                                    Element el = trees.getElement(getCurrentPath());\n+                                    handleDeclaration(el);\n+                                    return super.visitVariable(node, p);\n+                                }\n+                            }.scan(tp, null);\n+                        }\n+                    }\n+                    case MODULE -> {\n+                        q.add(elements.getPackageElement(\"test\"));\n+                    }\n+                    default ->\n+                        currentElement.getEnclosedElements()\n+                                      .stream()\n+                                      .sorted((e1, e2) -> e1.getSimpleName().toString().compareTo(e2.getSimpleName().toString()))\n+                                      .forEach(q::add);\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        void handleDeclaration(Element el) {\n+            Elements elements = processingEnv.getElementUtils();\n+            JavaFileObject fileObjects = elements.getFileObjectOf(el);\n+            System.out.println(el.getSimpleName() + \": \" + (fileObjects != null ? fileObjects.toUri().toString() : \"<null>\"));\n+        }\n+\n+        @Override\n+        public SourceVersion getSupportedSourceVersion() {\n+            return SourceVersion.latestSupported();\n+        }\n+\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestFileObjectOf.java","additions":596,"deletions":0,"binary":false,"changes":596,"status":"added"},{"patch":"@@ -92,1 +92,2 @@\n-            \"javax.annotation.processing.SupportedSourceVersion\"\n+            \"javax.annotation.processing.SupportedSourceVersion\",\n+            \"javax.tools.JavaFileObject\"\n","filename":"test\/langtools\/tools\/javac\/tree\/NoPrivateTypesExported.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}