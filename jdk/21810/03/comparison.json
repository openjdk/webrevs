{"files":[{"patch":"@@ -44,2 +44,1 @@\n-    static final VarHandle ASYNC_RELEASE_COUNT= MhUtil.findVarHandle(\n-            MethodHandles.lookup(), \"asyncReleaseCount\", int.class);\n+    static final VarHandle ASYNC_RELEASE_COUNT= MhUtil.findVarHandle(MethodHandles.lookup(), \"asyncReleaseCount\", int.class);\n@@ -55,1 +54,1 @@\n-        if (state == MAX_FORKS) {\n+        if (acquireCount == MAX_FORKS) {\n@@ -58,1 +57,1 @@\n-        state++;\n+        acquireCount++;\n@@ -65,1 +64,1 @@\n-            state--;\n+            acquireCount--;\n@@ -78,2 +77,2 @@\n-        if ((state == 0 && asyncCount == 0)\n-                || ((state - asyncCount) == 0)) {\n+        int acquire = acquireCount - asyncCount;\n+        if (acquire == 0) {\n@@ -82,1 +81,1 @@\n-            throw alreadyAcquired(state - asyncCount);\n+            throw alreadyAcquired(acquire);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ConfinedSession.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+        this.state = NONCLOSEABLE;\n@@ -53,5 +54,0 @@\n-    @Override\n-    public boolean isCloseable() {\n-        return false;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/GlobalSession.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+        this.state = NONCLOSEABLE;\n@@ -58,5 +59,0 @@\n-    @Override\n-    public boolean isCloseable() {\n-        return false;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ImplicitSession.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -58,0 +59,7 @@\n+\n+    \/**\n+     * The value of the {@code state} of a {@code MemorySessionImpl}. The only possible transition\n+     * is OPEN -> CLOSED. As a result, the states CLOSED and UNCLOSEABLE are stable. This allows us\n+     * to annotate {@code state} with {@link Stable} and elide liveness check on non-closeable\n+     * constant scopes, such as {@code GLOBAL_SESSION}.\n+     *\/\n@@ -60,0 +68,1 @@\n+    static final int NONCLOSEABLE = 1;\n@@ -61,2 +70,2 @@\n-    static final VarHandle STATE = MhUtil.findVarHandle(\n-            MethodHandles.lookup(), \"state\", int.class);\n+    static final VarHandle STATE = MhUtil.findVarHandle(MethodHandles.lookup(), \"state\", int.class);\n+    static final VarHandle ACQUIRE_COUNT = MhUtil.findVarHandle(MethodHandles.lookup(), \"acquireCount\", int.class);\n@@ -73,1 +82,5 @@\n-    int state = OPEN;\n+\n+    @Stable\n+    int state;\n+\n+    int acquireCount;\n@@ -217,2 +230,2 @@\n-    public boolean isCloseable() {\n-        return true;\n+    public final boolean isCloseable() {\n+        return state <= OPEN;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySessionImpl.java","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -47,0 +47,2 @@\n+    private static final int CLOSED_ACQUIRE_COUNT = -1;\n+\n@@ -56,2 +58,2 @@\n-            value = (int) STATE.getVolatile(this);\n-            if (value < OPEN) {\n+            value = (int) ACQUIRE_COUNT.getVolatile(this);\n+            if (value < 0) {\n@@ -59,1 +61,1 @@\n-                throw alreadyClosed();\n+                throw sharedSessionAlreadyClosed();\n@@ -64,1 +66,1 @@\n-        } while (!STATE.compareAndSet(this, value, value + 1));\n+        } while (!ACQUIRE_COUNT.compareAndSet(this, value, value + 1));\n@@ -72,2 +74,2 @@\n-            value = (int) STATE.getVolatile(this);\n-            if (value <= OPEN) {\n+            value = (int) ACQUIRE_COUNT.getVolatile(this);\n+            if (value <= 0) {\n@@ -75,1 +77,1 @@\n-                throw alreadyClosed();\n+                throw sharedSessionAlreadyClosed();\n@@ -77,1 +79,1 @@\n-        } while (!STATE.compareAndSet(this, value, value - 1));\n+        } while (!ACQUIRE_COUNT.compareAndSet(this, value, value - 1));\n@@ -81,5 +83,5 @@\n-        int prevState = (int) STATE.compareAndExchange(this, OPEN, CLOSED);\n-        if (prevState < 0) {\n-            throw alreadyClosed();\n-        } else if (prevState != OPEN) {\n-            throw alreadyAcquired(prevState);\n+        int acquireCount = (int) ACQUIRE_COUNT.compareAndExchange(this, 0, CLOSED_ACQUIRE_COUNT);\n+        if (acquireCount < 0) {\n+            throw sharedSessionAlreadyClosed();\n+        } else if (acquireCount > 0) {\n+            throw alreadyAcquired(acquireCount);\n@@ -87,0 +89,2 @@\n+\n+        STATE.setOpaque(this, CLOSED);\n@@ -90,0 +94,9 @@\n+    private IllegalStateException sharedSessionAlreadyClosed() {\n+        \/\/ To avoid the situation where a scope fails to be acquired or closed but still reports as\n+        \/\/ alive afterward, we wait for the state to change before throwing the exception\n+        while ((int) STATE.getVolatile(this) == OPEN) {\n+            Thread.onSpinWait();\n+        }\n+        return alreadyClosed();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SharedSession.java","additions":26,"deletions":13,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.TearDown;\n+import sun.misc.Unsafe;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n+public class LoopOverRandom extends JavaLayouts {\n+\n+    static final long ELEM_SIZE = ValueLayout.JAVA_INT.byteSize();\n+    static final int ELEM_COUNT = 1_000;\n+    static final long ALLOC_SIZE = ELEM_COUNT * ELEM_SIZE;\n+\n+    static final Unsafe unsafe = Utils.unsafe;\n+\n+    Arena arena;\n+    MemorySegment segment;\n+    int[] indices;\n+\n+    static final MemorySegment ALL = MemorySegment.NULL.reinterpret(Long.MAX_VALUE);\n+\n+    @Setup\n+    public void setup() {\n+        indices = new Random().ints(0, ELEM_COUNT).limit(ELEM_COUNT).toArray();\n+        arena = Arena.ofConfined();\n+        segment = arena.allocate(ALLOC_SIZE);\n+        for (int i = 0; i < ELEM_COUNT; i++) {\n+            segment.setAtIndex(ValueLayout.JAVA_INT, i, i);\n+        }\n+    }\n+\n+    @TearDown\n+    public void tearDown() {\n+        arena.close();\n+    }\n+\n+    @Benchmark\n+    public long segment_loop() {\n+        int sum = 0;\n+        for (int i = 0; i < ELEM_COUNT; i++) {\n+            sum += segment.getAtIndex(ValueLayout.JAVA_INT_UNALIGNED, indices[i]);\n+            target_dontInline();\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public long segment_loop_all() {\n+        int sum = 0;\n+        for (int i = 0; i < ELEM_COUNT; i++) {\n+            sum += ALL.get(ValueLayout.JAVA_INT_UNALIGNED, segment.address() + indices[i] * ELEM_SIZE);\n+            target_dontInline();\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public long segment_loop_asUnchecked() {\n+        int sum = 0;\n+        for (int i = 0; i < ELEM_COUNT; i++) {\n+            sum += asUnchecked(segment).getAtIndex(ValueLayout.JAVA_INT_UNALIGNED, indices[i]);\n+            target_dontInline();\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public long unsafe_loop() {\n+        int sum = 0;\n+        for (int i = 0; i < ELEM_COUNT; i++) {\n+            sum += unsafe.getInt(segment.address() + indices[i] * ELEM_SIZE);\n+            target_dontInline();\n+        }\n+        return sum;\n+    }\n+\n+    MemorySegment asUnchecked(MemorySegment segment) {\n+        return MemorySegment.ofAddress(segment.address()).reinterpret(Long.MAX_VALUE);\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void target_dontInline() {\n+        \/\/ this method was intentionally left blank\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverRandom.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"}]}