{"files":[{"patch":"@@ -62,2 +62,2 @@\n-     * is OPEN -> CLOSED. As a result, the states CLOSED and UNCLOSEABLE are stable. This allows us\n-     * to annotate {@code state} with {@link Stable} and elide liveness check on non-closeable\n+     * is OPEN -> CLOSED. As a result, the states CLOSED and NONCLOSEABLE are stable. This allows\n+     * us to annotate {@code state} with {@link Stable} and elide liveness check on non-closeable\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySessionImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-        STATE.setOpaque(this, CLOSED);\n+        STATE.setVolatile(this, CLOSED);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SharedSession.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,6 +31,0 @@\n-\n-import jdk.internal.foreign.MemorySessionImpl;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n-\n@@ -44,0 +38,5 @@\n+import jdk.internal.foreign.MemorySessionImpl;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.*;\n@@ -322,0 +321,64 @@\n+    \/**\n+     * Test that a thread failing to acquire a scope will not observe it as alive afterwards.\n+     *\/\n+    @Test\n+    public void testAcquireCloseRace() throws InterruptedException {\n+        int iteration = 1000;\n+        AtomicInteger lock = new AtomicInteger();\n+        boolean[] result = new boolean[1];\n+        lock.set(-2);\n+        MemorySessionImpl[] scopes = new MemorySessionImpl[iteration];\n+        for (int i = 0; i < iteration; i++) {\n+            scopes[i] = MemorySessionImpl.toMemorySession(Arena.ofShared());\n+        }\n+\n+        \/\/ This thread tries to close the scopes\n+        Thread t1 = new Thread(() -> {\n+            for (int i = 0; i < iteration; i++) {\n+                MemorySessionImpl scope = scopes[i];\n+                while (true) {\n+                    try {\n+                        scope.close();\n+                        break;\n+                    } catch (IllegalStateException e) {}\n+                }\n+                \/\/ Keep the 2 threads operating on the same scope\n+                int k = lock.getAndAdd(1) + 1;\n+                while (k != i * 2) {\n+                    Thread.onSpinWait();\n+                    k = lock.get();\n+                }\n+            }\n+        });\n+\n+        \/\/ This thread tries to acquire the scopes, then check if it is alive after an acquire failure\n+        Thread t2 = new Thread(() -> {\n+            for (int i = 0; i < iteration; i++) {\n+                MemorySessionImpl scope = scopes[i];\n+                while (true) {\n+                    try {\n+                        scope.acquire0();\n+                    } catch (IllegalStateException e) {\n+                        if (scope.isAlive()) {\n+                            result[0] = true;\n+                        }\n+                        break;\n+                    }\n+                    scope.release0();\n+                }\n+                \/\/ Keep the 2 threads operating on the same scope\n+                int k = lock.getAndAdd(1) + 1;\n+                while (k != i * 2) {\n+                    Thread.onSpinWait();\n+                    k = lock.get();\n+                }\n+            }\n+        });\n+\n+        t1.start();\n+        t2.start();\n+        t1.join();\n+        t2.join();\n+        assertFalse(result[0]);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestMemorySession.java","additions":70,"deletions":7,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+    static final int SEED = 0;\n@@ -65,1 +66,1 @@\n-        indices = new Random().ints(0, ELEM_COUNT).limit(ELEM_COUNT).toArray();\n+        indices = new Random(SEED).ints(0, ELEM_COUNT).limit(ELEM_COUNT).toArray();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverRandom.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}