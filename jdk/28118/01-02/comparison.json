{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import static java.util.stream.Collectors.toCollection;\n@@ -35,0 +36,1 @@\n+import java.io.UncheckedIOException;\n@@ -38,0 +40,1 @@\n+import java.nio.file.LinkOption;\n@@ -39,1 +42,0 @@\n-import java.security.MessageDigest;\n@@ -44,1 +46,0 @@\n-import java.util.HexFormat;\n@@ -53,0 +54,1 @@\n+import java.util.TreeSet;\n@@ -350,1 +352,1 @@\n-    };\n+    }\n@@ -1075,1 +1077,1 @@\n-                        return Map.entry(e.getKey(), e.getValue().stream().map(TKit.PathSnapshot.build()::create).toList());\n+                        return Map.entry(e.getKey(), e.getValue().stream().map(TKit.PathSnapshot::new).toList());\n@@ -1233,5 +1235,3 @@\n-                Function<Path, String> computeDigest = ThrowingFunction.toFunction(path -> {\n-                    var md = MessageDigest.getInstance(\"MD5\");\n-                    md.update(Files.readAllBytes(path));\n-                    return HexFormat.of().formatHex(md.digest());\n-                });\n+                TKit.trace(String.format(\n+                        \"Check contents of the predefined app image [%s] copied verbatim\",\n+                        predefinedAppImage));\n@@ -1239,12 +1239,1 @@\n-                var snapshotBuilder = TKit.PathSnapshot.build().hasher(computeDigest);\n-\n-                if (!cmd.expectAppImageFile()) {\n-                    var appImageFile = AppImageFile.getPathInAppImage(predefinedAppImage);\n-                    \/\/ Exclude \".jpackage.xml\" as it should no be in the output bundle.\n-                    var pred = Predicate.<Path>isEqual(appImageFile).negate();\n-                    if (TKit.isOSX()) {\n-                        \/\/ On MacOS exclude files that can be signed as their digests change.\n-                        pred = pred.and(path -> {\n-                            return MacHelper.isVerbatimCopyFromPredefinedAppImage(cmd, path);\n-                        });\n-                    }\n+                var outputAppImageDir = cmd.pathToUnpackedPackageFile(cmd.appInstallationDirectory());\n@@ -1252,2 +1241,15 @@\n-                    snapshotBuilder.filter(pred);\n-                }\n+                try (var walk = Files.walk(predefinedAppImage)) {\n+                    var filteredWalk = walk;\n+                    if (!cmd.expectAppImageFile()) {\n+                        var appImageFile = AppImageFile.getPathInAppImage(predefinedAppImage);\n+                        \/\/ Exclude \".jpackage.xml\" as it should no be in the output bundle.\n+                        var pred = Predicate.<Path>isEqual(appImageFile).negate();\n+                        if (TKit.isOSX()) {\n+                            \/\/ On MacOS exclude files that can be signed as their digests change.\n+                            pred = pred.and(path -> {\n+                                return MacHelper.isVerbatimCopyFromPredefinedAppImage(cmd, path);\n+                            });\n+                        }\n+\n+                        filteredWalk = walk.filter(pred);\n+                    }\n@@ -1255,1 +1257,1 @@\n-                var fromSnapshot = snapshotBuilder.create(predefinedAppImage);\n+                    var verbatimPaths = filteredWalk.collect(toCollection(TreeSet::new));\n@@ -1257,1 +1259,2 @@\n-                var outputAppImageDir = cmd.pathToUnpackedPackageFile(cmd.appInstallationDirectory());\n+                    \/\/ Remove nonempty directories for the collection of paths copied verbatim.\n+                    verbatimPaths.removeAll(verbatimPaths.stream().map(Path::getParent).toList());\n@@ -1259,10 +1262,10 @@\n-                var toSnapshot = new TKit.PathSnapshot(fromSnapshot.contentHashes().stream().map(pathHash -> {\n-                    if (pathHash.hash().isEmpty()) {\n-                        \/\/ path is a directory\n-                        return pathHash;\n-                    } else {\n-                        return new TKit.PathSnapshot.PathHash(\n-                                pathHash.path(),\n-                                computeDigest.apply(outputAppImageDir.resolve(pathHash.path())));\n-                    }\n-                }).toList());\n+                    verbatimPaths.forEach(ThrowingConsumer.toConsumer(p -> {\n+                        if (Files.isDirectory(p, LinkOption.NOFOLLOW_LINKS)) {\n+                            TKit.assertDirectoryExists(p);\n+                        } else {\n+                            TKit.assertSameFileContent(p, outputAppImageDir.resolve(predefinedAppImage.relativize(p)));\n+                        }\n+                    }));\n+                } catch (IOException ex) {\n+                    throw new UncheckedIOException(ex);\n+                }\n@@ -1270,3 +1273,1 @@\n-                toSnapshot.assertEquals(fromSnapshot,\n-                        String.format(\"Check contents of the predefined app image [%s] copied verbatim\",\n-                                predefinedAppImage));\n+                TKit.trace(\"Done\");\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":39,"deletions":38,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -67,1 +67,0 @@\n-import java.util.function.Function;\n@@ -1274,1 +1273,1 @@\n-    public record PathSnapshot(List<PathHash> contentHashes) {\n+    public record PathSnapshot(List<String> contentHashes) {\n@@ -1279,2 +1278,2 @@\n-        public void assertEquals(PathSnapshot other, String msg) {\n-            assertStringListEquals(toStringList(), other.toStringList(), msg);\n+        public PathSnapshot(Path path) {\n+            this(hashRecursive(path));\n@@ -1283,41 +1282,2 @@\n-        public record PathHash(Path path, String hash) {\n-            public PathHash {\n-                Objects.requireNonNull(path);\n-                Objects.requireNonNull(hash);\n-            }\n-\n-            @Override\n-            public String toString() {\n-                return String.format(\"%s#%s\", path, hash);\n-            }\n-        }\n-\n-        public static Builder build() {\n-            return new Builder();\n-        }\n-\n-        public static final class Builder {\n-\n-            public PathSnapshot create(Path path) {\n-                return new PathSnapshot(hashRecursive(\n-                        path,\n-                        Optional.ofNullable(hasher).orElse(PathSnapshot::lastModifiedTime),\n-                        Optional.ofNullable(filter)));\n-            }\n-\n-            public Builder filter(Predicate<Path> v) {\n-                filter = v;\n-                return this;\n-            }\n-\n-            public Builder hasher(Function<Path, String> v) {\n-                hasher = v;\n-                return this;\n-            }\n-\n-            private Predicate<Path> filter;\n-            private Function<Path, String> hasher;\n-        }\n-\n-        private List<String> toStringList() {\n-            return contentHashes.stream().map(PathHash::toString).toList();\n+        public void assertEquals(PathSnapshot other, String msg) {\n+            assertStringListEquals(contentHashes(), other.contentHashes(), msg);\n@@ -1326,4 +1286,1 @@\n-        private static List<PathHash> hashRecursive(Path path, Function<Path, String> hasher, Optional<Predicate<Path>> pathFilter) {\n-            Objects.requireNonNull(path);\n-            Objects.requireNonNull(hasher);\n-            Objects.requireNonNull(pathFilter);\n+        private static List<String> hashRecursive(Path path) {\n@@ -1332,1 +1289,1 @@\n-                    return pathFilter.map(walk::filter).orElse(walk).sorted().map(p -> {\n+                    return walk.sorted().map(p -> {\n@@ -1337,1 +1294,1 @@\n-                            hash = hasher.apply(p);\n+                            hash = hashFile(p);\n@@ -1339,1 +1296,1 @@\n-                        return new PathHash(path.relativize(p), hash);\n+                        return String.format(\"%s#%s\", path.relativize(p), hash);\n@@ -1347,1 +1304,1 @@\n-        private static String lastModifiedTime(Path path) {\n+        private static String hashFile(Path path) {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TKit.java","additions":10,"deletions":53,"binary":false,"changes":63,"status":"modified"}]}