{"files":[{"patch":"@@ -605,0 +605,5 @@\n+  \/\/ Xcomp has no reasonable profiling information, enable inlining cold methods\n+  if (Arguments::is_compiler_only() && FLAG_IS_DEFAULT(InlineColdMethods)) {\n+    FLAG_SET_DEFAULT(InlineColdMethods, true);\n+  }\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -392,2 +392,3 @@\n-          \"Inline cold methods that would otherwise be rejected based\"      \\\n-          \"on profile information. Only useful for compiler testing.\")      \\\n+          \"Inline cold methods that would otherwise be rejected due to \"    \\\n+          \"cold profile counters. Useful for compiler testing to expose \"   \\\n+          \"more code to compilers.\")                                        \\\n","filename":"src\/hotspot\/share\/compiler\/compiler_globals.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -298,1 +298,1 @@\n-  \/\/ accept cold methods if requested\n+  \/\/ accept cold methods in CTW or -Xcomp\n@@ -303,7 +303,5 @@\n-  \/\/ don't use counts with -Xcomp\n-  if (UseInterpreter) {\n-    if (!callee_method->has_compiled_code() &&\n-        !callee_method->was_executed_more_than(0)) {\n-      set_msg(\"never executed\");\n-      return true;\n-    }\n+  if (!callee_method->has_compiled_code() &&\n+      !callee_method->was_executed_more_than(0)) {\n+    set_msg(\"never executed\");\n+    return true;\n+  }\n@@ -311,4 +309,4 @@\n-    if (is_init_with_ea(callee_method, caller_method, C)) {\n-      \/\/ Escape Analysis: inline all executed constructors\n-      return false;\n-    }\n+  if (is_init_with_ea(callee_method, caller_method, C)) {\n+    \/\/ Escape Analysis: inline all executed constructors\n+    return false;\n+  }\n@@ -316,13 +314,12 @@\n-    if (MinInlineFrequencyRatio > 0) {\n-      int call_site_count  = caller_method->scale_count(profile.count());\n-      int invoke_count     = caller_method->interpreter_invocation_count();\n-      assert(invoke_count != 0, \"require invocation count greater than zero\");\n-      double freq = (double)call_site_count \/ (double)invoke_count;\n-      \/\/ avoid division by 0, set divisor to at least 1\n-      int cp_min_inv = MAX2(1, CompilationPolicy::min_invocations());\n-      double min_freq = MAX2(MinInlineFrequencyRatio, 1.0 \/ cp_min_inv);\n-\n-      if (freq < min_freq) {\n-        set_msg(\"low call site frequency\");\n-        return true;\n-      }\n+  if (MinInlineFrequencyRatio > 0) {\n+    int call_site_count  = caller_method->scale_count(profile.count());\n+    int invoke_count     = caller_method->interpreter_invocation_count();\n+    assert(invoke_count != 0, \"require invocation count greater than zero\");\n+    double freq = (double)call_site_count \/ (double)invoke_count;\n+    \/\/ avoid division by 0, set divisor to at least 1\n+    int cp_min_inv = MAX2(1, CompilationPolicy::min_invocations());\n+    double min_freq = MAX2(MinInlineFrequencyRatio, 1.0 \/ cp_min_inv);\n+\n+    if (freq < min_freq) {\n+      set_msg(\"low call site frequency\");\n+      return true;\n@@ -336,3 +333,0 @@\n-  if (!UseInterpreter) {\n-    return false; \/\/ -Xcomp\n-  }\n@@ -340,1 +334,1 @@\n-    return false; \/\/ CTW\n+    return false; \/\/ CTW or -Xcomp\n@@ -414,1 +408,1 @@\n-    if (!UseInterpreter &&\n+    if (InlineColdMethods &&\n","filename":"src\/hotspot\/share\/opto\/bytecodeInfo.cpp","additions":24,"deletions":30,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -284,16 +284,4 @@\n-        if (use != nn || use->is_CFG() || use->is_Phi() || use->is_Mach()) {\n-          if (j < use->req()) {\n-            use->set_req(j, nn);\n-          } else {\n-            use->set_prec(j, nn);\n-          }\n-        } else {\n-          \/\/ Avoid linking node with itself, drop the input instead.\n-          \/\/ Roll the IV back a bit to revisit the now-j-th node.\n-          if (j < use->req()) {\n-            use->del_req(j);\n-          } else {\n-            use->rm_prec(j);\n-          }\n-          j--;\n-        }\n+        if (j < use->req())\n+          use->set_req(j, nn);\n+        else\n+          use->set_prec(j, nn);\n@@ -2113,0 +2101,1 @@\n+  assert(_late_inlines.length() > 0, \"should have been checked by caller\");\n@@ -2224,0 +2213,4 @@\n+    if (_late_inlines.length() == 0) {\n+      break; \/\/ no more progress\n+    }\n+\n@@ -2234,4 +2227,0 @@\n-\n-    if (_late_inlines.length() == 0) {\n-      break; \/\/ no more progress\n-    }\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":9,"deletions":20,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -496,3 +496,3 @@\n-  \/\/ Remove all elements in the range [0; end). The order is preserved.\n-  void remove_till(int end) {\n-    remove_range(0, end);\n+  \/\/ Remove all elements up to the index (exclusive). The order is preserved.\n+  void remove_till(int idx) {\n+    remove_range(0, idx);\n@@ -501,1 +501,1 @@\n-  \/\/ Remove all elements in the range [start; end). The order is preserved.\n+  \/\/ Remove all elements in the range [start - end). The order is preserved.\n@@ -504,2 +504,2 @@\n-    assert(start <= end && end <= this->_len,\n-           \"erase called with invalid range [%d, %d) for length %d\",\n+    assert(start < end && end <= this->_len,\n+           \"erase called with invalid range (%d, %d) for length %d\",\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -235,97 +235,0 @@\n-  template <typename ArrayClass>\n-  static void test_remove_range(ArrayClass* a) {\n-    \/\/ Seed initial\n-    for (int i = 0; i < 10; i++) {\n-      a->append(i);\n-    }\n-    ASSERT_EQ(a->length(), 10);\n-\n-    \/\/ Remove empty range from the non-empty list, should not modify the list.\n-    a->remove_range(0, 0);\n-    ASSERT_EQ(a->length(), 10);\n-\n-    \/\/ Remove one element from head, should result in [1 ... 9]\n-    a->remove_range(0, 1);\n-    ASSERT_EQ(a->length(), 9);\n-    for (int i = 0; i < a->length(); i++) {\n-      ASSERT_EQ(a->at(i), i + 1);\n-    }\n-\n-    \/\/ Remove one element from tail, should result in [1 ... 8]\n-    a->remove_range(8, 9);\n-    ASSERT_EQ(a->length(), 8);\n-    for (int i = 0; i < a->length(); i++) {\n-      ASSERT_EQ(a->at(i), i + 1);\n-    }\n-\n-    \/\/ Remove another empty range from the non-empty list, should not modify\n-    a->remove_range(1, 1);\n-    ASSERT_EQ(a->length(), 8);\n-\n-    \/\/ Remove some elements from the middle, should result in [1 2 7 8]\n-    a->remove_range(2, 6);\n-    ASSERT_EQ(a->length(), 4);\n-    ASSERT_EQ(a->at(0), 1);\n-    ASSERT_EQ(a->at(1), 2);\n-    ASSERT_EQ(a->at(2), 7);\n-    ASSERT_EQ(a->at(3), 8);\n-\n-    \/\/ Remove the rest of the elements one by one\n-    a->remove_range(0, 1);\n-    ASSERT_EQ(a->length(), 3);\n-    ASSERT_EQ(a->at(0), 2);\n-    ASSERT_EQ(a->at(1), 7);\n-    ASSERT_EQ(a->at(2), 8);\n-\n-    a->remove_range(0, 1);\n-    ASSERT_EQ(a->length(), 2);\n-    ASSERT_EQ(a->at(0), 7);\n-    ASSERT_EQ(a->at(1), 8);\n-\n-    a->remove_range(0, 1);\n-    ASSERT_EQ(a->length(), 1);\n-    ASSERT_EQ(a->at(0), 8);\n-\n-    a->remove_range(0, 1);\n-    ASSERT_EQ(a->length(), 0);\n-\n-    \/\/ Remove elements from empty list with empty range, should be accepted\n-    a->remove_range(0, 0);\n-    ASSERT_EQ(a->length(), 0);\n-  }\n-\n-  template <typename ArrayClass>\n-  static void test_remove_till(ArrayClass* a) {\n-    \/\/ Seed initial\n-    for (int i = 0; i < 10; i++) {\n-      a->append(i);\n-    }\n-    ASSERT_EQ(a->length(), 10);\n-\n-    \/\/ Remove empty range from non-empty list, should work\n-    a->remove_till(0);\n-    ASSERT_EQ(a->length(), 10);\n-\n-    \/\/ Remove one element from head, should result in [1 ... 9]\n-    a->remove_till(1);\n-    ASSERT_EQ(a->length(), 9);\n-    for (int i = 0; i < a->length(); i++) {\n-      ASSERT_EQ(a->at(i), i + 1);\n-    }\n-\n-    \/\/ Remove two elements from head, should result in [3 ... 9]\n-    a->remove_till(2);\n-    ASSERT_EQ(a->length(), 7);\n-    for (int i = 0; i < a->length(); i++) {\n-      ASSERT_EQ(a->at(i), i + 3);\n-    }\n-\n-    \/\/ Remove remaining elements, should result in []\n-    a->remove_till(a->length());\n-    ASSERT_EQ(a->length(), 0);\n-\n-    \/\/ Remove empty range from empty list, should work\n-    a->remove_till(0);\n-    ASSERT_EQ(a->length(), 0);\n-  }\n-\n@@ -337,3 +240,1 @@\n-    Iterator,\n-    RemoveRange,\n-    RemoveTill\n+    Iterator\n@@ -361,8 +262,0 @@\n-      case RemoveRange:\n-        test_remove_range(a);\n-        break;\n-\n-      case RemoveTill:\n-        test_remove_till(a);\n-        break;\n-\n@@ -561,8 +454,0 @@\n-TEST_VM_F(GrowableArrayTest, remove_range) {\n-  with_all_types_all_0(RemoveRange);\n-}\n-\n-TEST_VM_F(GrowableArrayTest, remove_till) {\n-  with_all_types_all_0(RemoveTill);\n-}\n-\n","filename":"test\/hotspot\/gtest\/utilities\/test_growableArray.cpp","additions":1,"deletions":116,"binary":false,"changes":117,"status":"modified"}]}