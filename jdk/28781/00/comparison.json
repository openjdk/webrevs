{"files":[{"patch":"@@ -124,6 +124,0 @@\n-  if (_use_dfs) {\n-    assert(_current_parent != nullptr, \"invariant\");\n-    DFSClosure::find_leaks_from_edge(_edge_store, _mark_bits, _current_parent);\n-    return;\n-  }\n-\n@@ -131,0 +125,7 @@\n+\n+    if (_use_dfs) {\n+      assert(_current_parent != nullptr, \"invariant\");\n+      DFSClosure::find_leaks_from_edge(_edge_store, _mark_bits, _current_parent);\n+      return;\n+    }\n+\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/bfsClosure.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,195 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.jcmd;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedObject;\n+import jdk.jfr.consumer.RecordingFile;\n+import jdk.jfr.internal.test.WhiteBox;\n+import jdk.test.lib.jfr.EventNames;\n+\n+\/**\n+ * @test id=dfs-only\n+ * @summary Test dumping with path-to-gc-roots and DFS only\n+ * @bug 8373490\n+ * @requires vm.hasJFR & vm.flagless\n+ * @modules jdk.jfr\/jdk.jfr.internal.test\n+ * @library \/test\/lib \/test\/jdk\n+ *\n+ * @run main\/othervm -XX:TLABSize=2k -Xmx256m jdk.jfr.jcmd.TestJcmdDumpPathToGCRootsBFSDFS dfs-only\n+ *\/\n+\n+\/**\n+ * @test id=bfs-only\n+ * @summary Test dumping with path-to-gc-roots and BFS only\n+ * @bug 8373490\n+ * @requires vm.hasJFR & vm.flagless\n+ * @modules jdk.jfr\/jdk.jfr.internal.test\n+ * @library \/test\/lib \/test\/jdk\n+ *\n+ * @run main\/othervm -XX:TLABSize=2k -Xmx256m jdk.jfr.jcmd.TestJcmdDumpPathToGCRootsBFSDFS bfs-only\n+ *\/\n+\n+\/**\n+ * @test id=bfsdfs\n+ * @summary Test dumping with path-to-gc-roots and mixed BFS+DFS\n+ * @bug 8373490\n+ * @requires vm.hasJFR & vm.flagless\n+ * @modules jdk.jfr\/jdk.jfr.internal.test\n+ * @library \/test\/lib \/test\/jdk\n+ *\n+ * @run main\/othervm -XX:TLABSize=2k -Xmx256m jdk.jfr.jcmd.TestJcmdDumpPathToGCRootsBFSDFS bfsdfs\n+ *\/\n+public class TestJcmdDumpPathToGCRootsBFSDFS {\n+\n+    \/\/ Note:\n+    \/\/ - We start with a small heap of 256M in order to get the minimum Edge Queue size in BFS (lower cap is 32MB, enough to hold ~2mio edges)\n+    \/\/ - We build a leak with an array containing more than 2mio entries\n+    \/\/ That will hit BFS first, then fall back to DFS, showing the performance problem JDK-8373490 describes.\n+    \/\/ DFS-only mode should work well, and so should BFS-only mode.\n+\n+    \/\/ The minimum size of the edge queue in BFS (keep in sync with hotspot)\n+    private final static int minimumEdgeQueueSizeCap = 32 * 1024 * 1024;\n+    \/\/ The size of the Edge structure (keep in sync with hotspot)\n+    private final static int edgeSizeBytes = 16;\n+\n+    public static List<Object[]> leak;\n+\n+    public static void main(String[] args) throws Exception {\n+        WhiteBox.setWriteAllObjectSamples(true);\n+        String settingName = EventNames.OldObjectSample + \"#\" + \"cutoff\";\n+\n+        int edgesPerMinSizedQueue = minimumEdgeQueueSizeCap \/ 16;\n+        int lower = 1_000_000;\n+        int upper = 3_000_000;\n+        int fudge = 250_000;\n+        if (edgesPerMinSizedQueue < (lower + fudge)) {\n+            throw new RuntimeException(\"edgesPerMinSizedQueue lower bound wrong?\");\n+        }\n+        if (edgesPerMinSizedQueue > (upper - fudge)) {\n+            throw new RuntimeException(\"edgesPerMinSizedQueue upper bound wrong?\");\n+        }\n+\n+        int leakedObjectCount;\n+        boolean skipBFS;\n+        switch (args[0]) {\n+            case \"bfsdfs\" -> {\n+                \/\/ Mixed mode: enough objects to saturate BFS queue\n+                leakedObjectCount = upper;\n+                skipBFS = false;\n+            }\n+            case \"dfs-only\" -> {\n+                \/\/ DFS-only mode: object count does not matter, we enter DFS right away\n+                leakedObjectCount = upper;\n+                skipBFS = true;\n+            }\n+            case \"bfs-only\" -> {\n+                \/\/ BFS-only mode: not enough objects to saturate BFS queue\n+                leakedObjectCount = lower;\n+                skipBFS = false;\n+            }\n+            default -> {\n+                throw new RuntimeException(\"Invalid argument\");\n+            }\n+        };\n+\n+        WhiteBox.setSkipBFS(skipBFS);\n+\n+        testDump(\"path-to-gc-roots=true\", Collections.singletonMap(settingName, \"infinity\"), leakedObjectCount, true);\n+    }\n+\n+    private static void testDump(String pathToGcRoots, Map<String, String> settings, int leakedObjectCount, boolean expectedChains) throws Exception {\n+        while (true) {\n+            try (Recording r = new Recording()) {\n+                Map<String, String> p = new HashMap<>(settings);\n+                p.put(EventNames.OldObjectSample + \"#\" + Enabled.NAME, \"true\");\n+                r.setName(\"dodo\");\n+                r.setSettings(p);\n+                r.setToDisk(true);\n+                r.start();\n+                clearLeak();\n+                System.out.println(\"Recording id: \" + r.getId());\n+                System.out.println(\"Settings: \" + settings.toString());\n+                System.out.println(\"Command: JFR.dump \" + pathToGcRoots);\n+                System.out.println(\"Chains expected: \" + expectedChains);\n+                buildLeak(leakedObjectCount);\n+                System.gc();\n+                System.gc();\n+                File recording = new File(\"TestJcmdDumpPathToGCRoots\" + r.getId() + \".jfr\");\n+                recording.delete();\n+                JcmdHelper.jcmd(\"JFR.dump\", \"name=dodo\", pathToGcRoots, \"filename=\" + recording.getAbsolutePath());\n+                r.setSettings(Collections.emptyMap());\n+                List<RecordedEvent> events = RecordingFile.readAllEvents(recording.toPath());\n+                if (events.isEmpty()) {\n+                    System.out.println(\"No events found in recording. Retrying.\");\n+                    continue;\n+                }\n+                boolean chains = hasChains(events);\n+                if (expectedChains && !chains) {\n+                    System.out.println(events);\n+                    System.out.println(\"Expected chains but found none. Retrying.\");\n+                    continue;\n+                }\n+                if (!expectedChains && chains) {\n+                    System.out.println(events);\n+                    System.out.println(\"Didn't expect chains but found some. Retrying.\");\n+                    continue;\n+                }\n+                return; \/\/ Success\n+            }\n+        }\n+    }\n+\n+    private static void clearLeak() {\n+      leak = null;\n+      System.gc();\n+    }\n+\n+    private static boolean hasChains(List<RecordedEvent> events) throws IOException {\n+        for (RecordedEvent e : events) {\n+            RecordedObject ro = e.getValue(\"object\");\n+            if (ro.getValue(\"referrer\") != null) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static void buildLeak(int objectCount) {\n+        leak = new ArrayList<Object[]>(objectCount);\n+        for (int i = 0; i < objectCount;i ++) {\n+            leak.add(new Object[0]);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jcmd\/TestJcmdDumpPathToGCRootsBFSDFS.java","additions":195,"deletions":0,"binary":false,"changes":195,"status":"added"}]}