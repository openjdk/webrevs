{"files":[{"patch":"@@ -30,1 +30,3 @@\n-ShenandoahAgeCensus::ShenandoahAgeCensus() {\n+ShenandoahAgeCensus::ShenandoahAgeCensus()\n+  : ShenandoahAgeCensus(ShenandoahHeap::heap()->max_workers())\n+{\n@@ -32,0 +34,5 @@\n+}\n+\n+ShenandoahAgeCensus::ShenandoahAgeCensus(uint max_workers)\n+  : _max_workers(max_workers)\n+{\n@@ -42,0 +49,3 @@\n+  CENSUS_NOISE(_skipped = 0);\n+  NOT_PRODUCT(_counted = 0);\n+  NOT_PRODUCT(_total = 0);\n@@ -51,2 +61,1 @@\n-    size_t max_workers = ShenandoahHeap::heap()->max_workers();\n-    _local_age_table = NEW_C_HEAP_ARRAY(AgeTable*, max_workers, mtGC);\n+    _local_age_table = NEW_C_HEAP_ARRAY(AgeTable*, _max_workers, mtGC);\n@@ -54,1 +63,1 @@\n-    for (uint i = 0; i < max_workers; i++) {\n+    for (uint i = 0; i < _max_workers; i++) {\n@@ -64,0 +73,16 @@\n+ShenandoahAgeCensus::~ShenandoahAgeCensus() {\n+  for (uint i = 0; i < MAX_SNAPSHOTS; i++) {\n+    delete _global_age_table[i];\n+  }\n+  FREE_C_HEAP_ARRAY(AgeTable*, _global_age_table);\n+  FREE_C_HEAP_ARRAY(uint, _tenuring_threshold);\n+  CENSUS_NOISE(FREE_C_HEAP_ARRAY(ShenandoahNoiseStats, _global_noise));\n+  if (_local_age_table) {\n+    for (uint i = 0; i < _max_workers; i++) {\n+      delete _local_age_table[i];\n+    }\n+    FREE_C_HEAP_ARRAY(AgeTable*, _local_age_table);\n+    CENSUS_NOISE(FREE_C_HEAP_ARRAY(ShenandoahNoiseStats, _local_noise));\n+  }\n+}\n+\n@@ -134,1 +159,1 @@\n-    _global_age_table[_epoch]->add((uint)0, age0_pop);\n+    _global_age_table[_epoch]->add(0u, age0_pop);\n@@ -136,1 +161,0 @@\n-    size_t max_workers = ShenandoahHeap::heap()->max_workers();\n@@ -139,1 +163,1 @@\n-    for (uint i = 0; i < max_workers; i++) {\n+    for (uint i = 0; i < _max_workers; i++) {\n@@ -180,2 +204,1 @@\n-  size_t max_workers = ShenandoahHeap::heap()->max_workers();\n-  for (uint i = 0; i < max_workers; i++) {\n+  for (uint i = 0; i < _max_workers; i++) {\n@@ -207,2 +230,1 @@\n-  size_t max_workers = ShenandoahHeap::heap()->max_workers();\n-  for (uint i = 0; i < max_workers; i++) {\n+  for (uint i = 0; i < _max_workers; i++) {\n@@ -282,3 +304,4 @@\n-     \/\/ We stay below the computed tenuring threshold for the last cycle plus 1,\n-     \/\/ ignoring the mortality rates of any older cohorts.\n-     upper_bound = MIN2(upper_bound, prev_tt + 1);\n+     \/\/ We stay below the computed tenuring threshold for the last cycle,\n+     \/\/ ignoring the mortality rates of any older cohorts (which may see\n+     \/\/ higher mortality rates due to promotions).\n+     upper_bound = MIN2(upper_bound, prev_tt);\n@@ -288,1 +311,1 @@\n-  const uint lower_bound = MAX2((uint)ShenandoahGenerationalMinTenuringAge, (uint)1);\n+  const uint lower_bound = MAX2((uint)ShenandoahGenerationalMinTenuringAge, 1u);\n@@ -306,1 +329,1 @@\n-      assert(tenuring_threshold == i+1 || tenuring_threshold == upper_bound, \"Error\");\n+      assert(tenuring_threshold == i + 1 || tenuring_threshold == upper_bound, \"Error\");\n@@ -308,1 +331,1 @@\n-      return tenuring_threshold;\n+      return i + 1;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAgeCensus.cpp","additions":40,"deletions":17,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-\/\/ evacuation). These are cleared after each marking (resectively, evacuation) cycle,\n+\/\/ evacuation). These are cleared after each marking (respectively, evacuation) cycle,\n@@ -118,0 +118,2 @@\n+  uint _max_workers;                 \/\/ Maximum number of workers for parallel tasks\n+\n@@ -168,0 +170,2 @@\n+  ShenandoahAgeCensus(uint max_workers);\n+  ~ShenandoahAgeCensus();\n@@ -171,2 +175,7 @@\n-  AgeTable* get_local_age_table(uint worker_id) {\n-    return (AgeTable*) _local_age_table[worker_id];\n+  AgeTable* get_local_age_table(uint worker_id) const {\n+    return _local_age_table[worker_id];\n+  }\n+\n+  \/\/ Return true if this age is above the tenuring threshold.\n+  bool is_tenurable(uint age) const {\n+    return age > tenuring_threshold();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAgeCensus.hpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -219,1 +219,1 @@\n-    } else if (r->age() + mark.age() >= age_census()->tenuring_threshold()) {\n+    } else if (age_census()->is_tenurable(r->age() + mark.age())) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"gc\/shenandoah\/shenandoahAgeCensus.hpp\"\n+#include \"unittest.hpp\"\n+\n+class ShenandoahAgeCensusTest : public ::testing::Test {\n+protected:\n+  static constexpr size_t MinimumPopulationSize = 4*K;\n+  static constexpr size_t InitialPopulationSize = MinimumPopulationSize * 1000;\n+\n+  size_t _cohorts_count = ShenandoahAgeCensus::MAX_COHORTS;\n+  double _mortality_rates[ShenandoahAgeCensus::MAX_COHORTS];\n+  size_t _cohort_populations[ShenandoahAgeCensus::MAX_COHORTS];\n+\n+  ShenandoahAgeCensusTest()\n+  : _mortality_rates{0.9, 0.7, 0.5, 0.3, 0.09, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}\n+  {\n+    build_cohort_populations(_mortality_rates, _cohort_populations, _cohorts_count);\n+  }\n+\n+  static void add_population(ShenandoahAgeCensus& census, const uint age, const size_t population_words) {\n+    CENSUS_NOISE(census.add(age, 0, 0, population_words, 0));\n+    NO_CENSUS_NOISE(census.add(age, 0, population_words, 0));\n+  }\n+\n+  void update(ShenandoahAgeCensus& census, size_t cohorts) const {\n+    for (uint i = 1; i < cohorts; i++) {\n+      add_population(census, i, _cohort_populations[i]);\n+    }\n+    census.update_census(_cohort_populations[0]);\n+  }\n+\n+  void update(ShenandoahAgeCensus& census) const {\n+    update(census, _cohorts_count);\n+  }\n+\n+  size_t get_total_population_older_than(const size_t min_cohort_age) const {\n+    size_t total = 0;\n+    for (size_t i = 0; i < _cohorts_count; i++) {\n+      if (i >= min_cohort_age) {\n+        total += _cohort_populations[i];\n+      }\n+    }\n+    return total;\n+  }\n+\n+  void promote_all_tenurable(const size_t tenuring_threshold) {\n+    for (size_t i = 0; i < _cohorts_count; i++) {\n+      if (i > tenuring_threshold) {\n+        _cohort_populations[i] = 0;\n+      }\n+    }\n+  }\n+\n+  static void build_cohort_populations(const double mortality_rates[], size_t cohort_populations[], const size_t cohorts) {\n+    cohort_populations[0] = InitialPopulationSize;\n+    for (size_t i = 1; i < cohorts; i++) {\n+      cohort_populations[i] = cohort_populations[i - 1] * (1.0 - mortality_rates[i - 1]);\n+    }\n+  }\n+};\n+\n+TEST_F(ShenandoahAgeCensusTest, initialize) {\n+  const ShenandoahAgeCensus census(1);\n+  EXPECT_EQ(census.tenuring_threshold(), ShenandoahAgeCensus::MAX_COHORTS);\n+}\n+\n+TEST_F(ShenandoahAgeCensusTest, ignore_small_populations) {\n+  \/\/ Small populations are ignored so we do not return early before reaching the youngest cohort.\n+  ShenandoahAgeCensus census(1);\n+  add_population(census,1, 32);\n+  add_population(census,1, 32);\n+  census.update_census(64);\n+  EXPECT_EQ(1u, census.tenuring_threshold());\n+}\n+\n+TEST_F(ShenandoahAgeCensusTest, find_high_mortality_rate) {\n+  ShenandoahAgeCensus census(1);\n+\n+  \/\/ Initial threshold, no data\n+  EXPECT_EQ(16u, census.tenuring_threshold());\n+\n+  \/\/ Provide population data for 1st cohort. Previous epoch has no population data so our\n+  \/\/ algorithm skips over all cohorts, leaving tenuring threshold at 1.\n+  update(census, 1);\n+  EXPECT_EQ(1u, census.tenuring_threshold());\n+\n+  \/\/ Mortality rate of 1st cohort at age 1 is 0.9, we don't want to promote here. Move threshold to 2.\n+  update(census, 2);\n+  EXPECT_EQ(2u, census.tenuring_threshold());\n+\n+  \/\/ Mortality rate of 1st cohort at age 2 is 0.7, we don't want to promote here. Move threshold to 3.\n+  update(census, 3);\n+  EXPECT_EQ(3u, census.tenuring_threshold());\n+\n+  \/\/ Mortality rate of 1st cohort at age 3 is 0.5, we don't want to promote here. Move threshold to 4.\n+  update(census, 4);\n+  EXPECT_EQ(4u, census.tenuring_threshold());\n+\n+  \/\/ Mortality rate of 1st cohort at age 4 is 0.3, we don't want to promote here. Move threshold to 5.\n+  update(census, 5);\n+  EXPECT_EQ(5u, census.tenuring_threshold());\n+\n+  \/\/ Mortality rate of 1st cohort at age 5 is 0.09, this is less than the mortality rate threshold. It\n+  \/\/ is okay to tenure objects older than 5 now. Keep threshold at 5.\n+  update(census, 6);\n+  EXPECT_EQ(5u, census.tenuring_threshold());\n+\n+  \/\/ Mortality rate at this age is 0. Keep tenuring threshold at 5.\n+  update(census, 7);\n+  EXPECT_EQ(5u, census.tenuring_threshold());\n+}\n+\n+TEST_F(ShenandoahAgeCensusTest, ignore_mortality_caused_by_promotions) {\n+  ShenandoahAgeCensus census(1);\n+\n+  \/\/ Simulate a sequence of censuses with the same mortality rate. Each one will see a\n+  \/\/ mortality rate above the tenuring threshold and raise the tenuring threshold by one.\n+  update(census, 1);\n+  update(census, 2);\n+  update(census, 3);\n+  update(census, 4);\n+  update(census, 5);\n+\n+  EXPECT_EQ(5u, census.tenuring_threshold());\n+\n+  \/\/ Simulate the effect of promoting all objects above the tenuring threshold\n+  \/\/ out of the young generation. This will look like a very high (100%) mortality\n+  \/\/ rate for these cohorts. However, we do _not_ want to raise the threshold in\n+  \/\/ this case because these objects haven't really \"died\", they have just been\n+  \/\/ tenured.\n+  promote_all_tenurable(census.tenuring_threshold());\n+  update(census);\n+\n+  \/\/ We want this to stay at 5 - the mortality in 1st cohort at age 6 was caused by expected promotions.\n+  EXPECT_EQ(5u, census.tenuring_threshold());\n+}\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahAgeCensus.cpp","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"}]}