{"files":[{"patch":"@@ -101,0 +101,1 @@\n+  \/\/ - returns end if not found.\n@@ -104,1 +105,9 @@\n-  \/\/ Values for find_first_bit_impl flip parameter.\n+  \/\/ Helper for find_last_{set,clear}_bit variants.\n+  \/\/ - flip designates whether searching for 1s or 0s.  Must be one of\n+  \/\/   find_{zeros,ones}_flip.\n+  \/\/ - aligned_left is true if beg is a priori on a bm_word_t boundary.\n+  \/\/ - returns end if not found.\n+  template<bm_word_t flip, bool aligned_left>\n+  inline idx_t find_last_bit_impl(idx_t beg, idx_t end) const;\n+\n+  \/\/ Values for find_{first,last}_bit_impl flip parameter.\n@@ -290,3 +299,3 @@\n-  \/\/ Looking for 1's and 0's at indices equal to or greater than \"beg\",\n-  \/\/ stopping if none has been found before \"end\", and returning\n-  \/\/ \"end\" (which must be at most \"size\") in that case.\n+  \/\/ Return the index of the first set (or clear) bit in the range [beg, end),\n+  \/\/ or end if none found.\n+  \/\/ precondition: beg and end form a valid range for the bitmap.\n@@ -306,0 +315,17 @@\n+\n+  \/\/ Return the index of the last set (or clear) bit in the range [beg, end),\n+  \/\/ or end if none found.\n+  \/\/ precondition: beg and end form a valid range for the bitmap.\n+  idx_t find_last_set_bit(idx_t beg, idx_t end) const;\n+  idx_t find_last_clear_bit(idx_t beg, idx_t end) const;\n+\n+  idx_t find_last_set_bit(idx_t beg) const {\n+    return find_last_set_bit(beg, size());\n+  }\n+  idx_t find_last_clear_bit(idx_t beg) const {\n+    return find_last_clear_bit(beg, size());\n+  }\n+\n+  \/\/ Like \"find_last_set_bit\", except requires that \"beg\" is\n+  \/\/ aligned to bitsizeof(bm_word_t).\n+  idx_t find_last_set_bit_aligned_left(idx_t beg, idx_t end) const;\n","filename":"src\/hotspot\/share\/utilities\/bitMap.hpp","additions":30,"deletions":4,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"utilities\/count_leading_zeros.hpp\"\n@@ -33,0 +34,1 @@\n+#include \"utilities\/powerOfTwo.hpp\"\n@@ -168,0 +170,28 @@\n+\/\/ General notes regarding find_{first,last}_bit_impl.\n+\/\/\n+\/\/ The first (last) word often contains an interesting bit, either due to\n+\/\/ density or because of features of the calling algorithm.  So it's important\n+\/\/ to examine that word with a minimum of fuss, minimizing setup time for\n+\/\/ additional words that will be wasted if the that word is indeed\n+\/\/ interesting.\n+\/\/\n+\/\/ The first (last) bit is similarly often interesting.  When it matters\n+\/\/ (density or features of the calling algorithm make it likely that bit is\n+\/\/ set), going straight to counting bits compares poorly to examining that bit\n+\/\/ first; the counting operations can be relatively expensive, plus there is\n+\/\/ the additional range check (unless aligned).  But when that bit isn't set,\n+\/\/ the cost of having tested for it is relatively small compared to the rest\n+\/\/ of the search.\n+\/\/\n+\/\/ The benefit from aligned_right being true is relatively small.  It saves an\n+\/\/ operation in the setup of the word search loop.  It also eliminates the\n+\/\/ range check on the final result.  However, callers often have a comparison\n+\/\/ with end, and inlining may allow the two comparisons to be combined.  It is\n+\/\/ important when !aligned_right that return paths either return end or a\n+\/\/ value dominated by a comparison with end.  aligned_right is still helpful\n+\/\/ when the caller doesn't have a range check because features of the calling\n+\/\/ algorithm guarantee an interesting bit will be present.\n+\/\/\n+\/\/ The benefit from aligned_left is even smaller, as there is no savings in\n+\/\/ the setup of the word search loop.\n+\n@@ -174,17 +204,0 @@\n-  \/\/ The first word often contains an interesting bit, either due to\n-  \/\/ density or because of features of the calling algorithm.  So it's\n-  \/\/ important to examine that first word with a minimum of fuss,\n-  \/\/ minimizing setup time for later words that will be wasted if the\n-  \/\/ first word is indeed interesting.\n-\n-  \/\/ The benefit from aligned_right being true is relatively small.\n-  \/\/ It saves an operation in the setup for the word search loop.\n-  \/\/ It also eliminates the range check on the final result.\n-  \/\/ However, callers often have a comparison with end, and\n-  \/\/ inlining often allows the two comparisons to be combined; it is\n-  \/\/ important when !aligned_right that return paths either return\n-  \/\/ end or a value dominated by a comparison with end.\n-  \/\/ aligned_right is still helpful when the caller doesn't have a\n-  \/\/ range check because features of the calling algorithm guarantee\n-  \/\/ an interesting bit will be present.\n-\n@@ -192,1 +205,1 @@\n-    \/\/ Get the word containing beg, and shift out low bits.\n+    \/\/ Get the word containing beg.\n@@ -194,9 +207,4 @@\n-    bm_word_t cword = flipped_word(word_index, flip) >> bit_in_word(beg);\n-    if ((cword & 1) != 0) {\n-      \/\/ The first bit is similarly often interesting. When it matters\n-      \/\/ (density or features of the calling algorithm make it likely\n-      \/\/ the first bit is set), going straight to the next clause compares\n-      \/\/ poorly with doing this check first; count_trailing_zeros can be\n-      \/\/ relatively expensive, plus there is the additional range check.\n-      \/\/ But when the first bit isn't set, the cost of having tested for\n-      \/\/ it is relatively small compared to the rest of the search.\n+    bm_word_t cword = flipped_word(word_index, flip);\n+    \/\/ Shift out low bits so beg bit is bit 0 of cword.\n+    cword >>= bit_in_word(beg);\n+    if ((cword & 1) != 0) {     \/\/ Test the beg bit.\n@@ -204,2 +212,1 @@\n-    } else if (cword != 0) {\n-      \/\/ Flipped and shifted first word is non-zero.\n+    } else if (cword != 0) {    \/\/ Test for other bits in the first word.\n@@ -231,0 +238,39 @@\n+template<BitMap::bm_word_t flip, bool aligned_left>\n+inline BitMap::idx_t BitMap::find_last_bit_impl(idx_t beg, idx_t end) const {\n+  STATIC_ASSERT(flip == find_ones_flip || flip == find_zeros_flip);\n+  verify_range(beg, end);\n+  assert(!aligned_left || is_aligned(beg, BitsPerWord), \"beg not aligned\");\n+\n+  if (beg < end) {\n+    \/\/ Get the last partial and flipped word in the range.\n+    idx_t last_bit_index = end - 1;\n+    idx_t word_index = to_words_align_down(last_bit_index);\n+    bm_word_t cword = flipped_word(word_index, flip);\n+    \/\/ Shift out high bits so last bit of range is in the sign position of cword.\n+    cword <<= (bit_index(word_index + 1) - end);\n+    if ((cword & bit_mask(BitsPerWord - 1)) != 0) { \/\/ Test the last bit.\n+      return last_bit_index;\n+    } else if (cword != 0) {    \/\/ Test for other bits in the last word.\n+      idx_t result = last_bit_index - count_leading_zeros(cword);\n+      if (aligned_left || (result >= beg)) return result;\n+      \/\/ Result is below range bound; return end.\n+    } else {\n+      \/\/ Flipped and shifted last word is zero.  Word search through\n+      \/\/ aligned down beg for a non-zero flipped word.\n+      idx_t word_limit = to_words_align_down(beg);\n+      while (word_index-- > word_limit) {\n+        cword = flipped_word(word_index, flip);\n+        if (cword != 0) {\n+          idx_t result = bit_index(word_index) + log2i(cword);\n+          if (aligned_left || (result >= beg)) return result;\n+          \/\/ Result is below range bound; return end.\n+          assert(word_index == word_limit, \"invariant\");\n+          break;\n+        }\n+      }\n+      \/\/ No bits in range; return end.\n+    }\n+  }\n+  return end;\n+}\n+\n@@ -246,0 +292,15 @@\n+inline BitMap::idx_t\n+BitMap::find_last_set_bit(idx_t beg, idx_t end) const {\n+  return find_last_bit_impl<find_ones_flip, false>(beg, end);\n+}\n+\n+inline BitMap::idx_t\n+BitMap::find_last_clear_bit(idx_t beg, idx_t end) const {\n+  return find_last_bit_impl<find_zeros_flip, false>(beg, end);\n+}\n+\n+inline BitMap::idx_t\n+BitMap::find_last_set_bit_aligned_left(idx_t beg, idx_t end) const {\n+  return find_last_bit_impl<find_ones_flip, true>(beg, end);\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/bitMap.inline.hpp","additions":90,"deletions":29,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -94,13 +94,27 @@\n-static idx_t compute_expected(idx_t search_start,\n-                                         idx_t search_end,\n-                                         idx_t left_bit,\n-                                         idx_t right_bit) {\n-  idx_t expected = search_end;\n-  if (search_start <= left_bit) {\n-    if (left_bit < search_end) {\n-      expected = left_bit;\n-    }\n-  } else if (search_start <= right_bit) {\n-    if (right_bit < search_end) {\n-      expected = right_bit;\n-    }\n+static bool is_bit_in_range(idx_t bit, idx_t beg, idx_t end) {\n+  return (beg <= bit) && (bit < end);\n+}\n+\n+static idx_t compute_first_expected(idx_t search_start,\n+                                    idx_t search_end,\n+                                    idx_t left_bit,\n+                                    idx_t right_bit) {\n+  if (is_bit_in_range(left_bit, search_start, search_end)) {\n+    return left_bit;\n+  } else if (is_bit_in_range(right_bit, search_start, search_end)) {\n+    return right_bit;\n+  } else {\n+    return search_end;\n+  }\n+}\n+\n+static idx_t compute_last_expected(idx_t search_start,\n+                                   idx_t search_end,\n+                                   idx_t left_bit,\n+                                   idx_t right_bit) {\n+  if (is_bit_in_range(right_bit, search_start, search_end)) {\n+    return right_bit;\n+  } else if (is_bit_in_range(left_bit, search_start, search_end)) {\n+    return left_bit;\n+  } else {\n+    return search_end;\n@@ -108,1 +122,0 @@\n-  return expected;\n@@ -130,0 +143,15 @@\n+  \/\/ Test find_last_set_bit with full range of map.\n+  EXPECT_EQ(right, test_ones.find_last_set_bit(0));\n+  EXPECT_EQ(left, test_ones.find_last_set_bit(0, right));\n+  EXPECT_EQ(left, test_ones.find_last_set_bit(0, left));\n+\n+  \/\/ Test find_last_set_bit_aligned_left with full range of map.\n+  EXPECT_EQ(right, test_ones.find_last_set_bit_aligned_left(0, BITMAP_SIZE));\n+  EXPECT_EQ(left, test_ones.find_last_set_bit_aligned_left(0, right));\n+  EXPECT_EQ(left, test_ones.find_last_set_bit_aligned_left(0, left));\n+\n+  \/\/ Test find_last_clear_bit with full range of map.\n+  EXPECT_EQ(right, test_zeros.find_last_clear_bit(0));\n+  EXPECT_EQ(left, test_zeros.find_last_clear_bit(0, right));\n+  EXPECT_EQ(left, test_zeros.find_last_clear_bit(0, left));\n+\n@@ -168,0 +196,1 @@\n+          bool aligned_left = search_offsets[o_start] == 0;\n@@ -171,1 +200,2 @@\n-          idx_t expected = compute_expected(start, end, left, right);\n+          idx_t first_expected = compute_first_expected(start, end, left, right);\n+          idx_t last_expected = compute_last_expected(start, end, left, right);\n@@ -173,2 +203,2 @@\n-          EXPECT_EQ(expected, test_ones.find_first_set_bit(start, end));\n-          EXPECT_EQ(expected, test_zeros.find_first_clear_bit(start, end));\n+          EXPECT_EQ(first_expected, test_ones.find_first_set_bit(start, end));\n+          EXPECT_EQ(first_expected, test_zeros.find_first_clear_bit(start, end));\n@@ -177,1 +207,1 @@\n-              expected,\n+              first_expected,\n@@ -181,2 +211,10 @@\n-          idx_t start2 = MIN2(expected + 1, end);\n-          idx_t expected2 = compute_expected(start2, end, left, right);\n+          EXPECT_EQ(last_expected, test_ones.find_last_set_bit(start, end));\n+          EXPECT_EQ(last_expected, test_zeros.find_last_clear_bit(start, end));\n+          if (aligned_left) {\n+            EXPECT_EQ(\n+              last_expected,\n+              test_ones.find_last_set_bit_aligned_left(start, end));\n+          }\n+\n+          idx_t start2 = MIN2(first_expected + 1, end);\n+          idx_t first_expected2 = compute_first_expected(start2, end, left, right);\n@@ -184,2 +222,5 @@\n-          EXPECT_EQ(expected2, test_ones.find_first_set_bit(start2, end));\n-          EXPECT_EQ(expected2, test_zeros.find_first_clear_bit(start2, end));\n+          idx_t end2 = MAX2(start, last_expected);\n+          idx_t last_expected2 = compute_last_expected(start, end2, left, right);\n+\n+          EXPECT_EQ(first_expected2, test_ones.find_first_set_bit(start2, end));\n+          EXPECT_EQ(first_expected2, test_zeros.find_first_clear_bit(start2, end));\n@@ -188,1 +229,1 @@\n-              expected2,\n+              first_expected2,\n@@ -191,0 +232,8 @@\n+\n+          EXPECT_EQ(last_expected2, test_ones.find_last_set_bit(start, end2));\n+          EXPECT_EQ(last_expected2, test_zeros.find_last_clear_bit(start, end2));\n+          if (aligned_left) {\n+            EXPECT_EQ(\n+              last_expected2,\n+              test_ones.find_last_set_bit_aligned_left(start, end2));\n+          }\n","filename":"test\/hotspot\/gtest\/utilities\/test_bitMap_search.cpp","additions":72,"deletions":23,"binary":false,"changes":95,"status":"modified"}]}