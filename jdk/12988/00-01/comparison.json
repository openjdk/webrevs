{"files":[{"patch":"@@ -32,1 +32,0 @@\n-#include \"utilities\/count_leading_zeros.hpp\"\n@@ -205,1 +204,1 @@\n-    \/\/ Get the word containing beg.\n+    \/\/ Get the word containing beg, and shift out low bits.\n@@ -207,3 +206,1 @@\n-    bm_word_t cword = flipped_word(word_index, flip);\n-    \/\/ Shift out low bits so beg bit is bit 0 of cword.\n-    cword >>= bit_in_word(beg);\n+    bm_word_t cword = flipped_word(word_index, flip) >> bit_in_word(beg);\n@@ -212,6 +209,5 @@\n-    } else if (cword != 0) {    \/\/ Test for other bits in the first word.\n-      idx_t result = beg + count_trailing_zeros(cword);\n-      if (aligned_right || (result < end)) return result;\n-      \/\/ Result is beyond range bound; return end.\n-    } else {\n-      \/\/ Flipped and shifted first word is zero.  Word search through\n+    }\n+    \/\/ Position of bit0 of cword in the bitmap.  Initially for shifted first word.\n+    idx_t cword_pos = beg;\n+    if (cword == 0) {           \/\/ Test other bits in the first word.\n+      \/\/ First word had no interesting bits.  Word search through\n@@ -225,4 +221,3 @@\n-          idx_t result = bit_index(word_index) + count_trailing_zeros(cword);\n-          if (aligned_right || (result < end)) return result;\n-          \/\/ Result is beyond range bound; return end.\n-          assert((word_index + 1) == word_limit, \"invariant\");\n+          \/\/ Update for found non-zero word, and join common tail to compute\n+          \/\/ result from cword_pos and non-zero cword.\n+          cword_pos = bit_index(word_index);\n@@ -232,1 +227,9 @@\n-      \/\/ No bits in range; return end.\n+    }\n+    \/\/ For all paths reaching here, (cword != 0) is already known, so we\n+    \/\/ expect the compiler to not generate any code for it.  Either first word\n+    \/\/ was non-zero, or found a non-zero word in range, or fully scanned range\n+    \/\/ (so cword is zero).\n+    if (cword != 0) {\n+      idx_t result = cword_pos + count_trailing_zeros(cword);\n+      if (aligned_right || (result < end)) return result;\n+      \/\/ Result is beyond range bound; return end.\n@@ -249,3 +252,3 @@\n-    \/\/ Shift out high bits so last bit of range is in the sign position of cword.\n-    cword <<= (bit_index(word_index + 1) - end);\n-    if ((cword & bit_mask(BitsPerWord - 1)) != 0) { \/\/ Test the last bit.\n+    \/\/ Mask for extracting and testing bits of last word.\n+    bm_word_t last_bit_mask = bm_word_t(1) << bit_in_word(last_bit_index);\n+    if ((cword & last_bit_mask) != 0) { \/\/ Test last bit.\n@@ -253,6 +256,5 @@\n-    } else if (cword != 0) {    \/\/ Test for other bits in the last word.\n-      idx_t result = last_bit_index - count_leading_zeros(cword);\n-      if (aligned_left || (result >= beg)) return result;\n-      \/\/ Result is below range bound; return end.\n-    } else {\n-      \/\/ Flipped and shifted last word is zero.  Word search through\n+    }\n+    \/\/ Extract prior bits, clearing those above last_bit_index.\n+    cword &= (last_bit_mask - 1);\n+    if (cword == 0) {           \/\/ Test other bits in the last word.\n+      \/\/ Last word had no interesting bits.  Word search through\n@@ -263,7 +265,1 @@\n-        if (cword != 0) {\n-          idx_t result = bit_index(word_index) + log2i(cword);\n-          if (aligned_left || (result >= beg)) return result;\n-          \/\/ Result is below range bound; return end.\n-          assert(word_index == word_limit, \"invariant\");\n-          break;\n-        }\n+        if (cword != 0) break;\n@@ -271,1 +267,9 @@\n-      \/\/ No bits in range; return end.\n+    }\n+    \/\/ For all paths reaching here, (cword != 0) is already known, so we\n+    \/\/ expect the compiler to not generate any code for it.  Either last word\n+    \/\/ was non-zero, or found a non-zero word in range, or fully scanned range\n+    \/\/ (so cword is zero).\n+    if (cword != 0) {\n+      idx_t result = bit_index(word_index) + log2i(cword);\n+      if (aligned_left || (result >= beg)) return result;\n+      \/\/ Result is below range bound; return end.\n","filename":"src\/hotspot\/share\/utilities\/bitMap.inline.hpp","additions":37,"deletions":33,"binary":false,"changes":70,"status":"modified"}]}