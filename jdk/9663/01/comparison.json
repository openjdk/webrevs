{"files":[{"patch":"@@ -2189,22 +2189,0 @@\n-  int fd;\n-\n-  fd = ::open(path, oflag, mode);\n-  if (fd == -1) return -1;\n-\n-  \/\/ If the open succeeded, the file might still be a directory\n-  {\n-    struct stat buf;\n-    int ret = ::fstat(fd, &buf);\n-    int st_mode = buf.st_mode;\n-\n-    if (ret != -1) {\n-      if ((st_mode & S_IFMT) == S_IFDIR) {\n-        errno = EISDIR;\n-        ::close(fd);\n-        return -1;\n-      }\n-    } else {\n-      ::close(fd);\n-      return -1;\n-    }\n-  }\n@@ -2233,1 +2211,8 @@\n-#ifdef FD_CLOEXEC\n+\n+  \/\/ O_CLOEXEC is preferable to using FD_CLOEXEC on an open file descriptor\n+  \/\/ because it saves a system call and removes a small window where the flag\n+  \/\/ is unset.\n+  int fd = ::open(path, oflag|O_CLOEXEC, mode);\n+  if (fd == -1) return -1;\n+\n+  \/\/ If the open succeeded, the file might still be a directory\n@@ -2235,3 +2220,13 @@\n-    int flags = ::fcntl(fd, F_GETFD);\n-    if (flags != -1) {\n-      ::fcntl(fd, F_SETFD, flags | FD_CLOEXEC);\n+    struct stat buf;\n+    int ret = ::fstat(fd, &buf);\n+    int st_mode = buf.st_mode;\n+\n+    if (ret != -1) {\n+      if ((st_mode & S_IFMT) == S_IFDIR) {\n+        errno = EISDIR;\n+        ::close(fd);\n+        return -1;\n+      }\n+    } else {\n+      ::close(fd);\n+      return -1;\n@@ -2240,1 +2235,0 @@\n-#endif\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":21,"deletions":27,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -890,0 +890,10 @@\n+\n+TEST_VM(os, open_O_CLOEXEC) {\n+#if defined(__APPLE__)\n+  int fd = os::open(\"gtest.cmdline\", 0, O_RDONLY); \/\/ open will use O_CLOEXEC\n+  EXPECT_TRUE(fd > 0);\n+  int flags = ::fcntl(fd, F_GETFD);\n+  EXPECT_TRUE((flags & FD_CLOEXEC) != 0); \/\/ if O_CLOEXEC worked, then FD_CLOEXEC should be ON\n+  ::close(fd);\n+#endif\n+}\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}