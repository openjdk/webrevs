{"files":[{"patch":"@@ -158,0 +158,1 @@\n+ * <tr><th scope=\"row\">n<sup>th<\/sup> root<\/th><td>ceil((double) radicand.scale()\/n)<\/td>\n@@ -2146,0 +2147,46 @@\n+        return rootn(2, mc);\n+    }\n+\n+    \/**\n+     * Returns an approximation to the {@code n}<sup>th<\/sup> root of {@code this}\n+     * with rounding according to the context settings.\n+     *\n+     * <p>The preferred scale of the returned result is equal to\n+     * {@code Math.ceilDiv(this.scale(), n)}. The value of the returned result is\n+     * always within one ulp of the exact decimal value for the\n+     * precision in question.  If the rounding mode is {@link\n+     * RoundingMode#HALF_UP HALF_UP}, {@link RoundingMode#HALF_DOWN\n+     * HALF_DOWN}, or {@link RoundingMode#HALF_EVEN HALF_EVEN}, the\n+     * result is within one half an ulp of the exact decimal value.\n+     *\n+     * <p>Special case:\n+     * <ul>\n+     * <li> The {@code n}<sup>th<\/sup> root of a number numerically equal to {@code\n+     * ZERO} is numerically equal to {@code ZERO} with a preferred\n+     * scale according to the general rule above. In particular, for\n+     * {@code ZERO}, {@code ZERO.rootn(n, mc).equals(ZERO)} is true with\n+     * any {@code MathContext} as an argument.\n+     * <\/ul>\n+     *\n+     * @param n the root degree\n+     * @param mc the context to use.\n+     * @return the {@code n}<sup>th<\/sup> root of {@code this}.\n+     * @throws ArithmeticException if {@code n == 0 || n == Integer.MIN_VALUE}.\n+     * @throws ArithmeticException if {@code n} is even and {@code this} is negative.\n+     * @throws ArithmeticException if {@code n} is negative and {@code this} is zero.\n+     * @throws ArithmeticException if an exact result is requested\n+     * ({@code mc.getPrecision() == 0}) and there is no finite decimal\n+     * expansion of the exact result\n+     * @throws ArithmeticException if\n+     * {@code (mc.getRoundingMode() == RoundingMode.UNNECESSARY}) and\n+     * the exact result cannot fit in {@code mc.getPrecision()} digits.\n+     * @see #sqrt(MathContext)\n+     * @see BigInteger#nthRoot(int)\n+     * @since 26\n+     * @apiNote Note that calling {@code rootn(2, mc)} is equivalent to calling {@code sqrt(mc)}.\n+     *\/\n+    public BigDecimal rootn(int n, MathContext mc) {\n+        \/\/ Special cases\n+        if (n == 0)\n+            throw new ArithmeticException(\"Zero root degree\");\n+\n@@ -2147,10 +2194,9 @@\n-        if (signum != 1) {\n-            switch (signum) {\n-            case -1 -> throw new ArithmeticException(\"Attempted square root of negative BigDecimal\");\n-            case 0 -> {\n-                BigDecimal result = valueOf(0L, scale\/2);\n-                assert squareRootResultAssertions(result, mc);\n-                return result;\n-            }\n-            default -> throw new AssertionError(\"Bad value from signum\");\n-            }\n+        if (signum < 0 && (n & 1) == 0)\n+            throw new ArithmeticException(\"Negative radicand with even root degree\");\n+\n+        final int preferredScale = saturateLong(Math.ceilDiv((long) this.scale, n));\n+        if (signum == 0) {\n+            if (n < 0)\n+                throw new ArithmeticException(\"Zero radicand with negative root degree\");\n+\n+            return zeroValueOf(preferredScale);\n@@ -2158,0 +2204,1 @@\n+\n@@ -2161,1 +2208,1 @@\n-         * using the following relations:\n+         * using the following relations, assuming n > 0:\n@@ -2164,2 +2211,2 @@\n-         * sqrt(x) = sqrt(y) * 10^(exp \/ 2) if exp is even\n-         * sqrt(x) = sqrt(y*10) * 10^((exp-1)\/2) is exp is odd\n+         * nthRoot(x, n) = nthRoot(y, n) * 10^(exp \/ n) if exp mod n == 0\n+         * nthRoot(x, n) = nthRoot(y*10^(exp mod n), n) * 10^((exp - (exp mod n))\/n) otherwise\n@@ -2167,1 +2214,3 @@\n-         * Then use BigInteger.sqrt() on the reduced value to compute\n+         * where exp mod n == Math.floorMod(exp, n).\n+         *\n+         * Then use BigInteger.nthRoot() on the reduced value to compute\n@@ -2174,5 +2223,1 @@\n-\n-        \/\/ The code below favors relative simplicity over checking\n-        \/\/ for special cases that could run faster.\n-        final int preferredScale = Math.ceilDiv(this.scale, 2);\n-\n+        final int nAbs = Math.absExact(n);\n@@ -2183,4 +2228,0 @@\n-            final int strippedScale = stripped.scale;\n-\n-            if ((strippedScale & 1) != 0) \/\/ 10*stripped.unscaledValue() can't be an exact square\n-                throw new ArithmeticException(\"Computed square root not exact.\");\n@@ -2188,7 +2229,4 @@\n-            \/\/ Check for even powers of 10. Numerically sqrt(10^2N) = 10^N\n-            if (stripped.isPowerOfTen()) {\n-                result = valueOf(1L, strippedScale >> 1);\n-                \/\/ Adjust to requested precision and preferred\n-                \/\/ scale as appropriate.\n-                return result.adjustToPreferredScale(preferredScale, mc.precision);\n-            }\n+            \/\/ if stripped.scale is not a multiple of n,\n+            \/\/ 10^((-stripped.scale) mod n)*stripped.unscaledValue() can't be an exact power\n+            if (stripped.scale % n != 0)\n+                throw new ArithmeticException(\"Computed root not exact.\");\n@@ -2201,12 +2239,20 @@\n-            \/\/ precision for the cohort of the numerical value and the scale is even.\n-            BigInteger[] sqrtRem = stripped.unscaledValue().sqrtAndRemainder();\n-            result = new BigDecimal(sqrtRem[0], strippedScale >> 1);\n-\n-            \/\/ If result*result != this numerically or requires too high precision,\n-            \/\/ the square root isn't exact\n-            if (sqrtRem[1].signum != 0 || mc.precision != 0 && result.precision() > mc.precision)\n-                throw new ArithmeticException(\"Computed square root not exact.\");\n-\n-            \/\/ Test numerical properties at full precision before any\n-            \/\/ scale adjustments.\n-            assert squareRootResultAssertions(result, mc);\n+            \/\/ precision for the cohort of the numerical value and the scale is a multiple of n.\n+            BigInteger[] rootRem = stripped.unscaledValue().nthRootAndRemainder(nAbs);\n+            result = new BigDecimal(rootRem[0], stripped.scale \/ nAbs);\n+            \/\/ If result^nAbs != this numerically, the root isn't exact\n+            if (rootRem[1].signum != 0)\n+                throw new ArithmeticException(\"Computed root not exact.\");\n+\n+            if (n > 0) {\n+                \/\/ If result requires too high precision, the root isn't exact\n+                if (mc.precision != 0 && result.precision() > mc.precision)\n+                    throw new ArithmeticException(\"Computed root not exact.\");\n+            } else {\n+                try {\n+                    result = ONE.divide(result, mc);\n+                } catch (ArithmeticException e) {\n+                    \/\/ The exact result requires too high precision,\n+                    \/\/ including non-terminating decimal expansions\n+                    throw new ArithmeticException(\"Computed root not exact.\");\n+                }\n+            }\n@@ -2217,3 +2263,15 @@\n-        \/\/ To allow BigInteger.sqrt() to be used to get the square\n-        \/\/ root, it is necessary to normalize the input so that\n-        \/\/ its integer part is sufficient to get the square root\n+\n+        \/\/ Handle negative radicands\n+        BigDecimal x = this;\n+        if (signum < 0) {\n+            x = x.negate();\n+            if (mc.roundingMode == RoundingMode.FLOOR) {\n+                mc = new MathContext(mc.precision, RoundingMode.UP);\n+            } else if (mc.roundingMode == RoundingMode.CEILING) {\n+                mc = new MathContext(mc.precision, RoundingMode.DOWN);\n+            }\n+        }\n+\n+        \/\/ To allow BigInteger.nthRoot() to be used to get the root,\n+        \/\/ it is necessary to normalize the input so that\n+        \/\/ its integer part is sufficient to get the root\n@@ -2223,3 +2281,5 @@\n-        \/\/ To obtain a square root with N digits,\n-        \/\/ the radicand must have at least 2*(N-1)+1 == 2*N-1 digits.\n-        final long minWorkingPrec = ((mc.precision + (halfWay ? 1L : 0L)) << 1) - 1L;\n+        \/\/ If n < 0, add a digit to speed up correct rounding\n+        final long rootDigits = mc.precision + (halfWay ? 1L : 0L) + (n < 0 ? 1L : 0L);\n+        \/\/ To obtain an n-th root with k digits,\n+        \/\/ the radicand must have at least n*(k-1)+1 digits.\n+        final long minWorkingPrec = nAbs * (rootDigits - 1L) + 1L;\n@@ -2227,2 +2287,4 @@\n-        long normScale = minWorkingPrec - this.precision() + this.scale;\n-        normScale += normScale & 1L; \/\/ the scale for normalizing must be even\n+        long normScale = minWorkingPrec - x.precision() + x.scale;\n+        int mod = Math.floorMod(normScale, nAbs);\n+        if (mod != 0) \/\/ the scale for normalizing must be a multiple of nAbs\n+            normScale += nAbs - mod;\n@@ -2230,5 +2292,1 @@\n-        final long workingScale = this.scale - normScale;\n-        if (workingScale != (int) workingScale)\n-            throw new ArithmeticException(\"Overflow\");\n-\n-        BigDecimal working = new BigDecimal(this.intVal, this.intCompact, (int) workingScale, this.precision);\n+        BigDecimal working = new BigDecimal(x.intVal, x.intCompact, checkScaleNonZero(x.scale - normScale), x.precision);\n@@ -2237,20 +2295,15 @@\n-        BigInteger sqrt;\n-        long resultScale = normScale >> 1;\n-        \/\/ Round sqrt with the specified settings\n-        if (halfWay) { \/\/ half-way rounding\n-            BigInteger workingSqrt = workingInt.sqrt();\n-            \/\/ remove the one-tenth digit\n-            BigInteger[] quotRem10 = workingSqrt.divideAndRemainder(BigInteger.TEN);\n-            sqrt = quotRem10[0];\n-            resultScale--;\n-\n-            boolean increment = false;\n-            int digit = quotRem10[1].intValue();\n-            if (digit > 5) {\n-                increment = true;\n-            } else if (digit == 5) {\n-                if (mc.roundingMode == RoundingMode.HALF_UP\n-                        || mc.roundingMode == RoundingMode.HALF_EVEN && sqrt.testBit(0)\n-                        \/\/ Check if remainder is non-zero\n-                        || !workingInt.equals(workingSqrt.multiply(workingSqrt))\n-                        || !working.isInteger()) {\n+        \/\/ Compute and round the root\n+        BigInteger root;\n+        long resultScale = normScale \/ nAbs;\n+        if (n > 0) {\n+            \/\/ Round the root with the specified settings\n+            if (halfWay) { \/\/ half-way rounding\n+                BigInteger[] rootRem = workingInt.nthRootAndRemainder(nAbs);\n+                \/\/ remove the one-tenth digit\n+                BigInteger[] quotRem10 = rootRem[0].divideAndRemainder(BigInteger.TEN);\n+                root = quotRem10[0];\n+                resultScale--;\n+\n+                boolean increment = false;\n+                int digit = quotRem10[1].intValue();\n+                if (digit > 5) {\n@@ -2258,0 +2311,24 @@\n+                } else if (digit == 5) {\n+                    if (mc.roundingMode == RoundingMode.HALF_UP\n+                            || mc.roundingMode == RoundingMode.HALF_EVEN && root.testBit(0)\n+                            \/\/ Check if remainder is non-zero\n+                            || rootRem[1].signum != 0 || !working.isInteger()) {\n+                        increment = true;\n+                    }\n+                }\n+\n+                if (increment)\n+                    root = root.add(1L);\n+            } else {\n+                switch (mc.roundingMode) {\n+                case DOWN, FLOOR -> root = workingInt.nthRoot(nAbs); \/\/ No need to round\n+\n+                case UP, CEILING -> {\n+                    BigInteger[] rootRem = workingInt.nthRootAndRemainder(nAbs);\n+                    root = rootRem[0];\n+                    \/\/ Check if remainder is non-zero\n+                    if (rootRem[1].signum != 0 || !working.isInteger())\n+                        root = root.add(1L);\n+                }\n+\n+                default -> throw new AssertionError(\"Unexpected value for RoundingMode: \" + mc.roundingMode);\n@@ -2261,12 +2338,22 @@\n-            if (increment)\n-                sqrt = sqrt.add(1L);\n-        } else {\n-            switch (mc.roundingMode) {\n-            case DOWN, FLOOR -> sqrt = workingInt.sqrt(); \/\/ No need to round\n-\n-            case UP, CEILING -> {\n-                BigInteger[] sqrtRem = workingInt.sqrtAndRemainder();\n-                sqrt = sqrtRem[0];\n-                \/\/ Check if remainder is non-zero\n-                if (sqrtRem[1].signum != 0 || !working.isInteger())\n-                    sqrt = sqrt.add(1L);\n+            result = new BigDecimal(root, checkScale(root, resultScale), mc); \/\/ mc ensures no increase of precision\n+        } else { \/\/ Handle negative degrees\n+            root = workingInt.nthRoot(nAbs);\n+            final BigDecimal scaledRoot = new BigDecimal(root, checkScaleNonZero(resultScale));\n+            final long resPrec = mc.precision + (halfWay ? 1L : 0L);\n+            final int fracZeros = (int) rootDigits - 1 - (scaledRoot.isPowerOfTen() ? 1 : 0);\n+            \/\/ Ensure result's precision is exactly resPrec\n+            result = ONE.divide(scaledRoot, checkScaleNonZero(fracZeros - resultScale + resPrec), RoundingMode.DOWN);\n+\n+            BigDecimal inverse = ONE.divide(x, checkScaleNonZero((long) result.scale * nAbs), RoundingMode.DOWN);\n+            \/\/ (1\/(root*10^(-normScale \/ nAbs)))^nAbs >= 1\/x, and since result is rounded down,\n+            \/\/ either result^nAbs > inverse, or else all result's digits are correct\n+\n+            int cmp;\n+            BigDecimal ulp = result.ulp();\n+            while ((cmp = result.pow(nAbs).compareMagnitude(inverse)) > 0) {\n+                \/\/ if result's scale will increase, increase also inverse's scale\n+                if (result.isPowerOfTen()) {\n+                    ulp = ulp.scaleByPowerOfTen(-1);\n+                    inverse = ONE.divide(x, checkScaleNonZero((long) ulp.scale * nAbs), RoundingMode.DOWN);\n+                }\n+                result = result.subtract(ulp);\n@@ -2275,1 +2362,32 @@\n-            default -> throw new AssertionError(\"Unexpected value for RoundingMode: \" + mc.roundingMode);\n+            if (halfWay) {\n+                \/\/ remove the one-tenth digit from result\n+                BigInteger[] quotRem10 = result.unscaledValue().divideAndRemainder(BigInteger.TEN);\n+                result = new BigDecimal(quotRem10[0], checkScaleNonZero(result.scale - 1L));\n+\n+                boolean increment = false;\n+                int digit = quotRem10[1].intValue();\n+                if (digit > 5) {\n+                    increment = true;\n+                } else if (digit == 5) {\n+                    if (mc.roundingMode == RoundingMode.HALF_UP\n+                            || mc.roundingMode == RoundingMode.HALF_EVEN && quotRem10[0].testBit(0)\n+                            \/\/ Check if remainder is non-zero\n+                            || cmp != 0 || ONE.compareMagnitude(inverse.multiply(x)) != 0) {\n+                        increment = true;\n+                    }\n+                }\n+\n+                if (increment)\n+                    result = result.add(result.ulp());\n+            } else {\n+                switch (mc.roundingMode) {\n+                case DOWN, FLOOR -> {} \/\/ result is already rounded down\n+\n+                case UP, CEILING -> {\n+                    \/\/ Check if remainder is non-zero\n+                    if (cmp != 0 || ONE.compareMagnitude(inverse.multiply(x)) != 0)\n+                        result = result.add(result.ulp());\n+                }\n+\n+                default -> throw new AssertionError(\"Unexpected value for RoundingMode: \" + mc.roundingMode);\n+                }\n@@ -2278,8 +2396,2 @@\n-\n-        result = new BigDecimal(sqrt, checkScale(sqrt, resultScale), mc); \/\/ mc ensures no increase of precision\n-        \/\/ Test numerical properties at full precision before any\n-        \/\/ scale adjustments.\n-        assert squareRootResultAssertions(result, mc);\n-        \/\/ Adjust to requested precision and preferred\n-        \/\/ scale as appropriate.\n-        if (result.scale > preferredScale) \/\/ else can't increase the result's precision to fit the preferred scale\n+        \/\/ Adjust to requested precision and preferred scale as appropriate.\n+        if (result.scale > preferredScale) \/\/ else can't increase result's precision to fit the preferred scale\n@@ -2288,1 +2400,1 @@\n-        return result;\n+        return signum > 0 ? result : result.negate();\n@@ -2319,4 +2431,0 @@\n-    private BigDecimal square() {\n-        return this.multiply(this);\n-    }\n-\n@@ -2324,97 +2432,1 @@\n-        return BigInteger.ONE.equals(this.unscaledValue());\n-    }\n-\n-    \/**\n-     * For nonzero values, check numerical correctness properties of\n-     * the computed result for the chosen rounding mode.\n-     *\n-     * For the directed rounding modes:\n-     *\n-     * <ul>\n-     *\n-     * <li> For DOWN and FLOOR, result^2 must be {@code <=} the input\n-     * and (result+ulp)^2 must be {@code >} the input.\n-     *\n-     * <li>Conversely, for UP and CEIL, result^2 must be {@code >=}\n-     * the input and (result-ulp)^2 must be {@code <} the input.\n-     * <\/ul>\n-     *\/\n-    private boolean squareRootResultAssertions(BigDecimal result, MathContext mc) {\n-        if (result.signum() == 0) {\n-            return squareRootZeroResultAssertions(result, mc);\n-        } else {\n-            RoundingMode rm = mc.getRoundingMode();\n-            BigDecimal ulp = result.ulp();\n-            BigDecimal neighborUp   = result.add(ulp);\n-            \/\/ Make neighbor down accurate even for powers of ten\n-            if (result.isPowerOfTen()) {\n-                ulp = ulp.divide(TEN);\n-            }\n-            BigDecimal neighborDown = result.subtract(ulp);\n-\n-            \/\/ Both the starting value and result should be nonzero and positive.\n-            assert (result.signum() == 1 &&\n-                    this.signum() == 1) :\n-                \"Bad signum of this and\/or its sqrt.\";\n-\n-            switch (rm) {\n-            case DOWN:\n-            case FLOOR:\n-                assert\n-                    result.square().compareTo(this)     <= 0 &&\n-                    neighborUp.square().compareTo(this) > 0:\n-                \"Square of result out for bounds rounding \" + rm;\n-                return true;\n-\n-            case UP:\n-            case CEILING:\n-                assert\n-                    result.square().compareTo(this)       >= 0 &&\n-                    neighborDown.square().compareTo(this) < 0:\n-                \"Square of result out for bounds rounding \" + rm;\n-                return true;\n-\n-\n-            case HALF_DOWN:\n-            case HALF_EVEN:\n-            case HALF_UP:\n-                BigDecimal err = result.square().subtract(this).abs();\n-                BigDecimal errUp = neighborUp.square().subtract(this);\n-                BigDecimal errDown =  this.subtract(neighborDown.square());\n-                \/\/ All error values should be positive so don't need to\n-                \/\/ compare absolute values.\n-\n-                int err_comp_errUp = err.compareTo(errUp);\n-                int err_comp_errDown = err.compareTo(errDown);\n-\n-                assert\n-                    errUp.signum()   == 1 &&\n-                    errDown.signum() == 1 :\n-                \"Errors of neighbors squared don't have correct signs\";\n-\n-                \/\/ For breaking a half-way tie, the return value may\n-                \/\/ have a larger error than one of the neighbors. For\n-                \/\/ example, the square root of 2.25 to a precision of\n-                \/\/ 1 digit is either 1 or 2 depending on how the exact\n-                \/\/ value of 1.5 is rounded. If 2 is returned, it will\n-                \/\/ have a larger rounding error than its neighbor 1.\n-                assert\n-                    err_comp_errUp   <= 0 ||\n-                    err_comp_errDown <= 0 :\n-                \"Computed square root has larger error than neighbors for \" + rm;\n-\n-                assert\n-                    ((err_comp_errUp   == 0 ) ? err_comp_errDown < 0 : true) &&\n-                    ((err_comp_errDown == 0 ) ? err_comp_errUp   < 0 : true) :\n-                        \"Incorrect error relationships\";\n-                \/\/ && could check for digit conditions for ties too\n-                return true;\n-\n-            default: \/\/ Definition of UNNECESSARY already verified.\n-                return true;\n-            }\n-        }\n-    }\n-\n-    private boolean squareRootZeroResultAssertions(BigDecimal result, MathContext mc) {\n-        return this.compareTo(ZERO) == 0;\n+        return this.stripTrailingZeros().unscaledValue().equals(BigInteger.ONE);\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":210,"deletions":198,"binary":false,"changes":408,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-            BigDecimal expected = BigDecimal.valueOf(0L, i\/2);\n+            BigDecimal expected = BigDecimal.valueOf(0L, Math.ceilDiv(i, 2));\n","filename":"test\/jdk\/java\/math\/BigDecimal\/SquareRootTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}