{"files":[{"patch":"@@ -2343,3 +2343,3 @@\n-            long invPrecL = mc.precision + (halfWay ? 1L : 0L);\n-            int invPrec = (int) invPrecL;\n-            if (invPrec != invPrecL)\n+            final long resPrecL = mc.precision + (halfWay ? 1L : 0L);\n+            final int resPrec = (int) resPrecL;\n+            if (resPrec != resPrecL)\n@@ -2349,1 +2349,0 @@\n-            BigDecimal[] invRem = ONE.divideAndRemainder(x, new MathContext(invPrec, RoundingMode.DOWN));\n@@ -2351,2 +2350,1 @@\n-                    invRem[0].scale, RoundingMode.DOWN);\n-            \/\/ 1\/(root*10^(-normScale \/ nAbs)) >= 1\/x, so result >= invRem[0]\n+                    new MathContext(resPrec, RoundingMode.DOWN));\n@@ -2354,1 +2352,0 @@\n-            int cmp;\n@@ -2356,1 +2353,9 @@\n-            while ((cmp = result.pow(nAbs).compareMagnitude(invRem[0])) > 0)\n+            \/\/ if unscaled value is a power of 10, result must maintain the same precision\n+            if (result.stripTrailingZeros().unscaledValue().equals(BigInteger.ONE))\n+                ulp = ulp.scaleByPowerOfTen(-1);\n+\n+            BigDecimal inverse = ONE.divide(x, checkScaleNonZero((long) ulp.scale * nAbs), RoundingMode.DOWN);\n+            \/\/ 1\/(root*10^(-normScale \/ nAbs)) >= 1\/x, so result >= inverse\n+\n+            int cmp;\n+            while ((cmp = result.pow(nAbs).compareMagnitude(inverse)) > 0)\n@@ -2372,1 +2377,1 @@\n-                            || cmp != 0 || invRem[1].signum() != 0) {\n+                            || cmp != 0 || ONE.compareMagnitude(inverse.multiply(x)) != 0) {\n@@ -2385,1 +2390,1 @@\n-                    if (cmp != 0 || invRem[1].signum() != 0)\n+                    if (cmp != 0 || ONE.compareMagnitude(inverse.multiply(x)) != 0)\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"}]}