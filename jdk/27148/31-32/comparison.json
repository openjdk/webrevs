{"files":[{"patch":"@@ -2282,2 +2282,1 @@\n-        \/\/ If n < 0, add a digit to speed up correct rounding\n-        final long rootDigits = mc.precision + (halfWay ? 1L : 0L) + (n < 0 ? 1L : 0L);\n+        final long rootDigits = mc.precision + (halfWay ? 1L : 0L);\n@@ -2287,5 +2286,0 @@\n-        \/\/ normScale is the number of digits to take from the fraction of the input\n-        long normScale = minWorkingPrec - x.precision() + x.scale;\n-        int mod = Math.floorMod(normScale, nAbs);\n-        if (mod != 0) \/\/ the scale for normalizing must be a multiple of nAbs\n-            normScale += nAbs - mod;\n@@ -2293,2 +2287,26 @@\n-        BigDecimal working = new BigDecimal(x.intVal, x.intCompact, checkScaleNonZero(x.scale - normScale), x.precision);\n-        BigInteger workingInt = working.toBigInteger();\n+        long normScale; \/\/ the number of digits to take from the fraction of the input\n+        BigDecimal working = null, xInv = null;\n+        BigInteger workingInt;\n+        if (n > 0) {\n+            normScale = minWorkingPrec - x.precision() + x.scale;\n+            int mod = Math.floorMod(normScale, n);\n+            if (mod != 0) \/\/ the scale for normalizing must be a multiple of n\n+                normScale += n - mod;\n+\n+            working = new BigDecimal(x.intVal, x.intCompact, checkScaleNonZero(x.scale - normScale), x.precision);\n+            workingInt = working.toBigInteger();\n+        } else { \/\/ Handle negative degrees\n+            \/* Computing the n-th root of x is equivalent\n+             * to computing the (-n)-th root of 1\/x.\n+             *\/\n+            \/\/ Compute the scale for xInv, in order to ensure\n+            \/\/ that xInv's precision is at least minWorkingPrec\n+            final int fracZeros = x.precision() - 1 - (x.isPowerOfTen() ? 1 : 0);\n+            normScale = minWorkingPrec + fracZeros - x.scale;\n+            int mod = Math.floorMod(normScale, nAbs);\n+            if (mod != 0)\n+                normScale += nAbs - mod;\n+\n+            xInv = ONE.divide(x, checkScaleNonZero(normScale), RoundingMode.DOWN);\n+            workingInt = xInv.unscaledValue();\n+        }\n@@ -2296,1 +2314,1 @@\n-        \/\/ Compute and round the root\n+        \/\/ Compute and round the root with the specified settings\n@@ -2299,12 +2317,17 @@\n-        if (n > 0) {\n-            \/\/ Round the root with the specified settings\n-            boolean increment = false;\n-            if (halfWay) { \/\/ half-way rounding\n-                BigInteger[] rootRem = workingInt.rootnAndRemainder(nAbs);\n-                \/\/ remove the one-tenth digit\n-                BigInteger[] quotRem10 = rootRem[0].divideAndRemainder(BigInteger.TEN);\n-                root = quotRem10[0];\n-                resultScale--;\n-\n-                int digit = quotRem10[1].intValue();\n-                if (digit > 5) {\n+        boolean increment = false;\n+        if (halfWay) { \/\/ half-way rounding\n+            BigInteger[] rootRem = workingInt.rootnAndRemainder(nAbs);\n+            \/\/ remove the one-tenth digit\n+            BigInteger[] quotRem10 = rootRem[0].divideAndRemainder(BigInteger.TEN);\n+            root = quotRem10[0];\n+            resultScale--;\n+\n+            int digit = quotRem10[1].intValue();\n+            if (digit > 5) {\n+                increment = true;\n+            } else if (digit == 5) {\n+                if (mc.roundingMode == RoundingMode.HALF_UP\n+                        || mc.roundingMode == RoundingMode.HALF_EVEN && root.testBit(0)\n+                        \/\/ Check if remainder is non-zero\n+                        || rootRem[1].signum != 0\n+                        || (n > 0 ? !working.isInteger() : xInv.multiply(x).compareMagnitude(ONE) != 0)) {\n@@ -2312,18 +2335,0 @@\n-                } else if (digit == 5) {\n-                    if (mc.roundingMode == RoundingMode.HALF_UP\n-                            || mc.roundingMode == RoundingMode.HALF_EVEN && root.testBit(0)\n-                            \/\/ Check if remainder is non-zero\n-                            || rootRem[1].signum != 0 || !working.isInteger()) {\n-                        increment = true;\n-                    }\n-                }\n-            } else {\n-                switch (mc.roundingMode) {\n-                case DOWN, FLOOR -> root = workingInt.rootn(nAbs); \/\/ No need to round\n-\n-                case UP, CEILING -> {\n-                    BigInteger[] rootRem = workingInt.rootnAndRemainder(nAbs);\n-                    root = rootRem[0];\n-                    \/\/ Check if remainder is non-zero\n-                    if (rootRem[1].signum != 0 || !working.isInteger())\n-                        increment = true;\n@@ -2331,26 +2336,0 @@\n-\n-                default -> throw new AssertionError(\"Unexpected value for RoundingMode: \" + mc.roundingMode);\n-                }\n-            }\n-            if (increment) {\n-                root = root.add(1L);\n-            }\n-\n-            result = new BigDecimal(root, checkScale(root, resultScale), mc); \/\/ mc ensures no increase of precision\n-        } else { \/\/ Handle negative degrees\n-            root = workingInt.rootn(nAbs);\n-            final BigDecimal scaledRoot = new BigDecimal(root, checkScaleNonZero(resultScale));\n-            final long resPrec = mc.precision + (halfWay ? 1L : 0L);\n-            final int fracZeros = (int) rootDigits - 1 - (scaledRoot.isPowerOfTen() ? 1 : 0);\n-            \/\/ Ensure result's precision is exactly resPrec\n-            result = ONE.divide(scaledRoot, checkScaleNonZero(fracZeros - resultScale + resPrec), RoundingMode.DOWN);\n-            \/\/ (1\/(root*10^(-normScale \/ nAbs)))^nAbs >= 1\/x, and since result is rounded down,\n-            \/\/ either result^nAbs > 1\/x, or else all result's digits are correct\n-\n-            int cmp;\n-            BigDecimal ulp = result.ulp();\n-            while ((cmp = result.pow(nAbs).multiply(x).compareMagnitude(ONE)) > 0) { \/\/ result^nAbs > 1\/x\n-                if (result.isPowerOfTen()) \/\/ Ensure no decrease of precision\n-                    ulp = ulp.scaleByPowerOfTen(-1);\n-\n-                result = result.subtract(ulp);\n@@ -2358,0 +2337,3 @@\n+        } else {\n+            switch (mc.roundingMode) {\n+            case DOWN, FLOOR -> root = workingInt.rootn(nAbs); \/\/ No need to round\n@@ -2359,8 +2341,6 @@\n-            boolean increment = false;\n-            if (halfWay) {\n-                \/\/ remove the one-tenth digit from result\n-                BigInteger[] quotRem10 = result.unscaledValue().divideAndRemainder(BigInteger.TEN);\n-                result = new BigDecimal(quotRem10[0], checkScaleNonZero(result.scale - 1L));\n-\n-                int digit = quotRem10[1].intValue();\n-                if (digit > 5) {\n+            case UP, CEILING -> {\n+                BigInteger[] rootRem = workingInt.rootnAndRemainder(nAbs);\n+                root = rootRem[0];\n+                \/\/ Check if remainder is non-zero\n+                if (rootRem[1].signum != 0\n+                        || (n > 0 ? !working.isInteger() : xInv.multiply(x).compareMagnitude(ONE) != 0))\n@@ -2368,18 +2348,0 @@\n-                } else if (digit == 5) {\n-                    if (mc.roundingMode == RoundingMode.HALF_UP\n-                            || mc.roundingMode == RoundingMode.HALF_EVEN && quotRem10[0].testBit(0)\n-                            || cmp != 0) { \/\/ Check if remainder is non-zero\n-                        increment = true;\n-                    }\n-                }\n-            } else {\n-                switch (mc.roundingMode) {\n-                case DOWN, FLOOR -> {} \/\/ result is already rounded down\n-\n-                case UP, CEILING -> {\n-                    if (cmp != 0) \/\/ Check if remainder is non-zero\n-                        increment = true;\n-                }\n-\n-                default -> throw new AssertionError(\"Unexpected value for RoundingMode: \" + mc.roundingMode);\n-                }\n@@ -2387,2 +2349,2 @@\n-            if (increment) {\n-                result = result.add(result.ulp(), mc); \/\/ mc ensures no increase of precision\n+\n+            default -> throw new AssertionError(\"Unexpected value for RoundingMode: \" + mc.roundingMode);\n@@ -2391,0 +2353,5 @@\n+        if (increment) {\n+            root = root.add(1L);\n+        }\n+\n+        result = new BigDecimal(root, checkScale(root, resultScale), mc); \/\/ mc ensures no increase of precision\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":61,"deletions":94,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -175,1 +175,0 @@\n-                        System.err.println(minus_bd + \", \" + n + \", \" + mc);\n@@ -184,1 +183,0 @@\n-                        System.err.println(minus_bd + \", \" + n + \", \" + mc);\n","filename":"test\/jdk\/java\/math\/BigDecimal\/SquareRootTests.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}