{"files":[{"patch":"@@ -158,0 +158,1 @@\n+ * <tr><th scope=\"row\">n<sup>th<\/sup> root<\/th><td>ceil((double) radicand.scale()\/n)<\/td>\n@@ -2155,3 +2156,2 @@\n-     * always within 1.1 ulps of the exact decimal value for the\n-     * precision in question, and if {@code n > 0}, the result is within\n-     * one ulp of the exact decimal value.  If the rounding mode is {@link\n+     * always within one ulp of the exact decimal value for the\n+     * precision in question.  If the rounding mode is {@link\n@@ -2160,2 +2160,1 @@\n-     * result is within 0.55 ulps of the exact decimal value, and if {@code n > 0},\n-     * the result is within one half an ulp of the exact decimal value.\n+     * result is within one half an ulp of the exact decimal value.\n@@ -2276,13 +2275,0 @@\n-        \/\/ Handle negative degrees\n-        RoundingMode workingRM = mc.roundingMode;\n-        if (n < 0) {\n-            \/\/ Swap rounding mode as the root will be inverted\n-            workingRM = switch (workingRM) {\n-            case DOWN, FLOOR -> RoundingMode.UP;\n-            case UP, CEILING -> RoundingMode.DOWN;\n-            case HALF_DOWN   -> RoundingMode.HALF_UP;\n-            case HALF_UP     -> RoundingMode.HALF_DOWN;\n-            case HALF_EVEN   -> RoundingMode.HALF_EVEN;\n-            default -> throw new AssertionError(\"Unexpected value for RoundingMode: \" + workingRM);\n-            };\n-        }\n@@ -2294,6 +2280,2 @@\n-        final boolean halfWay = isHalfWay(workingRM);\n-        \/* If n < 0 and no halfway rounding, the root's inversion gives an error of 1 ulp,\n-         * so we add one more digit to the integer root, so that it has an error of 0.1 ulps,\n-         * and therefore the error of the inverted root is 1+0.1 ulps.\n-         * Same reasoning for halfway rounding yields to half of the error just found.\n-         *\/\n+        final boolean halfWay = isHalfWay(mc.roundingMode);\n+        \/\/ If n < 0, add a digit to speed up correct rounding\n@@ -2313,20 +2295,14 @@\n-        BigInteger root;\n-        long resultScale = normScale \/ nAbs;\n-        \/\/ Round the root with the specified settings\n-        if (halfWay) { \/\/ half-way rounding\n-            BigInteger[] rootRem = workingInt.nthRootAndRemainder(nAbs);\n-            \/\/ remove the one-tenth digit\n-            BigInteger[] quotRem10 = rootRem[0].divideAndRemainder(BigInteger.TEN);\n-            root = quotRem10[0];\n-            resultScale--;\n-\n-            boolean increment = false;\n-            int digit = quotRem10[1].intValue();\n-            if (digit > 5) {\n-                increment = true;\n-            } else if (digit == 5) {\n-                if (workingRM == RoundingMode.HALF_UP\n-                        || workingRM == RoundingMode.HALF_EVEN && root.testBit(0)\n-                        \/\/ Check if remainder is non-zero\n-                        || rootRem[1].signum != 0\n-                        || !working.isInteger()) {\n+        if (n > 0) {\n+            BigInteger root;\n+            long resultScale = normScale \/ nAbs;\n+            \/\/ Round the root with the specified settings\n+            if (halfWay) { \/\/ half-way rounding\n+                BigInteger[] rootRem = workingInt.nthRootAndRemainder(nAbs);\n+                \/\/ remove the one-tenth digit\n+                BigInteger[] quotRem10 = rootRem[0].divideAndRemainder(BigInteger.TEN);\n+                root = quotRem10[0];\n+                resultScale--;\n+\n+                boolean increment = false;\n+                int digit = quotRem10[1].intValue();\n+                if (digit > 5) {\n@@ -2334,0 +2310,7 @@\n+                } else if (digit == 5) {\n+                    if (mc.roundingMode == RoundingMode.HALF_UP\n+                            || mc.roundingMode == RoundingMode.HALF_EVEN && root.testBit(0)\n+                            \/\/ Check if remainder is non-zero\n+                            || rootRem[1].signum != 0 || !working.isInteger()) {\n+                        increment = true;\n+                    }\n@@ -2335,7 +2318,0 @@\n-            }\n-\n-            if (increment)\n-                root = root.add(1L);\n-        } else {\n-            switch (workingRM) {\n-            case DOWN, FLOOR -> root = workingInt.nthRoot(nAbs); \/\/ No need to round\n@@ -2343,5 +2319,1 @@\n-            case UP, CEILING -> {\n-                BigInteger[] rootRem = workingInt.nthRootAndRemainder(nAbs);\n-                root = rootRem[0];\n-                \/\/ Check if remainder is non-zero\n-                if (rootRem[1].signum != 0 || !working.isInteger())\n+                if (increment)\n@@ -2349,1 +2321,11 @@\n-            }\n+            } else {\n+                switch (mc.roundingMode) {\n+                case DOWN, FLOOR -> root = workingInt.nthRoot(nAbs); \/\/ No need to round\n+\n+                case UP, CEILING -> {\n+                    BigInteger[] rootRem = workingInt.nthRootAndRemainder(nAbs);\n+                    root = rootRem[0];\n+                    \/\/ Check if remainder is non-zero\n+                    if (rootRem[1].signum != 0 || !working.isInteger())\n+                        root = root.add(1L);\n+                }\n@@ -2351,1 +2333,2 @@\n-            default -> throw new AssertionError(\"Unexpected value for RoundingMode: \" + workingRM);\n+                default -> throw new AssertionError(\"Unexpected value for RoundingMode: \" + mc.roundingMode);\n+                }\n@@ -2353,1 +2336,0 @@\n-        }\n@@ -2355,1 +2337,0 @@\n-        if (n > 0) {\n@@ -2361,2 +2342,51 @@\n-        } else {\n-            result = ONE.divide(new BigDecimal(root, checkScaleNonZero(resultScale)), mc);\n+        } else { \/\/ Handle negative degrees\n+            long invPrecL = mc.precision + (halfWay ? 1L : 0L);\n+            int invPrec = (int) invPrecL;\n+            if (invPrec != invPrecL)\n+                throw new ArithmeticException(\"Overflow\");\n+\n+            MathContext roundMc = new MathContext(invPrec, RoundingMode.DOWN);\n+            BigInteger[] rootRem = workingInt.nthRootAndRemainder(nAbs);\n+            BigDecimal[] invRem = ONE.divideAndRemainder(working, roundMc);\n+            result = ONE.divide(new BigDecimal(rootRem[0], checkScaleNonZero(normScale \/ nAbs)), roundMc);\n+            \/\/ 1\/rootRem[0] >= 1\/working, so result >= invRem[0]\n+\n+            int cmp;\n+            BigDecimal ulp = result.ulp();\n+            while ((cmp = result.pow(nAbs).compareMagnitude(invRem[0])) > 0)\n+                result = result.subtract(ulp);\n+\n+            if (halfWay) {\n+                \/\/ remove the one-tenth digit from result\n+                BigInteger[] quotRem10 = result.unscaledValue().divideAndRemainder(BigInteger.TEN);\n+                result = new BigDecimal(quotRem10[0], checkScaleNonZero(result.scale - 1L));\n+\n+                boolean increment = false;\n+                int digit = quotRem10[1].intValue();\n+                if (digit > 5) {\n+                    increment = true;\n+                } else if (digit == 5) {\n+                    if (mc.roundingMode == RoundingMode.HALF_UP\n+                            || mc.roundingMode == RoundingMode.HALF_EVEN && quotRem10[0].testBit(0)\n+                            \/\/ Check if remainder is non-zero\n+                            || cmp != 0 || invRem[1].signum() != 0) {\n+                        increment = true;\n+                    }\n+                }\n+\n+                if (increment)\n+                    result = result.add(ulp);\n+            } else {\n+                switch (mc.roundingMode) {\n+                case DOWN, FLOOR -> {} \/\/ result is already rounded down\n+\n+                case UP, CEILING -> {\n+                    \/\/ Check if remainder is non-zero\n+                    if (cmp != 0 || invRem[1].signum() != 0)\n+                        result = result.add(ulp);\n+                }\n+\n+                default -> throw new AssertionError(\"Unexpected value for RoundingMode: \" + mc.roundingMode);\n+                }\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":92,"deletions":62,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-            BigDecimal expected = BigDecimal.valueOf(0L, i\/2);\n+            BigDecimal expected = BigDecimal.valueOf(0L, Math.ceilDiv(i, 2));\n","filename":"test\/jdk\/java\/math\/BigDecimal\/SquareRootTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}