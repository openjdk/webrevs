{"files":[{"patch":"@@ -2259,2 +2259,3 @@\n-            \/\/ Adjust to requested precision and preferred\n-            \/\/ scale as appropriate.\n+            \/\/ Test numerical properties at full precision before any scale adjustments.\n+            assert rootnResultAssertions(result, mc, n);\n+            \/\/ Adjust to requested precision and preferred scale as appropriate.\n@@ -2320,1 +2321,1 @@\n-                if (increment)\n+                if (increment) {\n@@ -2322,0 +2323,1 @@\n+                }\n@@ -2337,1 +2339,0 @@\n-\n@@ -2380,1 +2381,1 @@\n-                if (increment)\n+                if (increment) {\n@@ -2382,0 +2383,1 @@\n+                }\n@@ -2396,0 +2398,2 @@\n+        \/\/ Test numerical properties at full precision before any scale adjustments.\n+        assert rootnResultAssertions(result, mc, n);\n@@ -2435,0 +2439,90 @@\n+    \/**\n+     * For nonzero values, check numerical correctness properties of\n+     * the computed result for the chosen rounding mode.\n+     *\n+     * For the directed rounding modes:\n+     *\n+     * <ul>\n+     *\n+     * <li> For DOWN and FLOOR, |result|^n must be {@code <=} |input|\n+     * and (|result|+ulp)^n must be {@code >} |input|.\n+     *\n+     * <li>Conversely, for UP and CEIL, |result|^n must be {@code >=}\n+     * |input| and (|result|-ulp)^n must be {@code <} |input|.\n+     * <\/ul>\n+     *\/\n+    private boolean rootnResultAssertions(BigDecimal result, MathContext mc, int n) {\n+        \/\/ The starting value and result should be nonzero and have the same sign.\n+        assert (result.signum() != 0 &&\n+                this.signum() == result.signum()) :\n+            \"Bad signum of this and\/or its root.\";\n+\n+        BigDecimal thisAbs = this.abs(), resAbs = result.abs();\n+\n+        RoundingMode rm = mc.roundingMode;\n+        BigDecimal ulp = resAbs.ulp();\n+        BigDecimal neighborUp = resAbs.add(ulp);\n+        \/\/ Make neighbor down accurate even for powers of ten\n+        if (resAbs.isPowerOfTen()) {\n+            ulp = ulp.scaleByPowerOfTen(-1);\n+        }\n+        BigDecimal neighborDown = resAbs.subtract(ulp);\n+\n+        switch (rm) {\n+        case DOWN:\n+        case FLOOR:\n+            assert\n+                resAbs.pow(n).compareTo(thisAbs)     <= 0 &&\n+                neighborUp.pow(n).compareTo(thisAbs) > 0:\n+            \"Power of result out for bounds rounding \" + rm;\n+            return true;\n+\n+        case UP:\n+        case CEILING:\n+            assert\n+                resAbs.pow(n).compareTo(thisAbs)       >= 0 &&\n+                neighborDown.pow(n).compareTo(thisAbs) < 0:\n+            \"Power of result out for bounds rounding \" + rm;\n+            return true;\n+\n+\n+        case HALF_DOWN:\n+        case HALF_EVEN:\n+        case HALF_UP:\n+            BigDecimal err = resAbs.pow(n).subtract(thisAbs).abs();\n+            BigDecimal errUp = neighborUp.pow(n).subtract(thisAbs);\n+            BigDecimal errDown =  thisAbs.subtract(neighborDown.pow(n));\n+            \/\/ All error values should be positive so don't need to\n+            \/\/ compare absolute values.\n+\n+            int err_comp_errUp = err.compareTo(errUp);\n+            int err_comp_errDown = err.compareTo(errDown);\n+\n+            assert\n+                errUp.signum()   == 1 &&\n+                errDown.signum() == 1 :\n+            \"Errors of neighbors powered don't have correct signs\";\n+\n+            \/\/ For breaking a half-way tie, the return value may\n+            \/\/ have a larger error than one of the neighbors. For\n+            \/\/ example, the square root of 2.25 to a precision of\n+            \/\/ 1 digit is either 1 or 2 depending on how the exact\n+            \/\/ value of 1.5 is rounded. If 2 is returned, it will\n+            \/\/ have a larger rounding error than its neighbor 1.\n+            assert\n+                err_comp_errUp   <= 0 ||\n+                err_comp_errDown <= 0 :\n+            \"Computed root has larger error than neighbors for \" + rm;\n+\n+            assert\n+                ((err_comp_errUp   == 0 ) ? err_comp_errDown < 0 : true) &&\n+                ((err_comp_errDown == 0 ) ? err_comp_errUp   < 0 : true) :\n+                    \"Incorrect error relationships\";\n+            \/\/ && could check for digit conditions for ties too\n+            return true;\n+\n+        default: \/\/ Definition of UNNECESSARY already verified.\n+            return true;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":99,"deletions":5,"binary":false,"changes":104,"status":"modified"}]}