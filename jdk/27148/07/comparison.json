{"files":[{"patch":"@@ -2146,0 +2146,48 @@\n+        return nthRoot(2, mc);\n+    }\n+\n+    \/**\n+     * Returns an approximation to the {@code n}<sup>th<\/sup> root of {@code this}\n+     * with rounding according to the context settings.\n+     *\n+     * <p>The preferred scale of the returned result is equal to\n+     * {@code Math.ceilDiv(this.scale(), n)}. The value of the returned result is\n+     * always within 1.1 ulps of the exact decimal value for the\n+     * precision in question, and if {@code n > 0}, the result is within\n+     * one ulp of the exact decimal value.  If the rounding mode is {@link\n+     * RoundingMode#HALF_UP HALF_UP}, {@link RoundingMode#HALF_DOWN\n+     * HALF_DOWN}, or {@link RoundingMode#HALF_EVEN HALF_EVEN}, the\n+     * result is within 0.55 ulps of the exact decimal value, and if {@code n > 0},\n+     * the result is within one half an ulp of the exact decimal value.\n+     *\n+     * <p>Special case:\n+     * <ul>\n+     * <li> The {@code n}<sup>th<\/sup> root of a number numerically equal to {@code\n+     * ZERO} is numerically equal to {@code ZERO} with a preferred\n+     * scale according to the general rule above. In particular, for\n+     * {@code ZERO}, {@code ZERO.rootn(n, mc).equals(ZERO)} is true with\n+     * any {@code MathContext} as an argument.\n+     * <\/ul>\n+     *\n+     * @param n the root degree\n+     * @param mc the context to use.\n+     * @return the {@code n}<sup>th<\/sup> root of {@code this}.\n+     * @throws ArithmeticException if {@code n == 0 || n == Integer.MIN_VALUE}.\n+     * @throws ArithmeticException if {@code n} is even and {@code this} is negative.\n+     * @throws ArithmeticException if {@code n} is negative and {@code this} is zero.\n+     * @throws ArithmeticException if an exact result is requested\n+     * ({@code mc.getPrecision() == 0}) and there is no finite decimal\n+     * expansion of the exact result\n+     * @throws ArithmeticException if\n+     * {@code (mc.getRoundingMode() == RoundingMode.UNNECESSARY}) and\n+     * the exact result cannot fit in {@code mc.getPrecision()} digits.\n+     * @see #sqrt(MathContext)\n+     * @see BigInteger#nthRoot(int)\n+     * @since 26\n+     * @apiNote Note that calling {@code rootn(2, mc)} is equivalent to calling {@code sqrt(mc)}.\n+     *\/\n+    public BigDecimal rootn(int n, MathContext mc) {\n+        \/\/ Special cases\n+        if (n == 0)\n+            throw new ArithmeticException(\"Zero root degree\");\n+\n@@ -2147,10 +2195,9 @@\n-        if (signum != 1) {\n-            switch (signum) {\n-            case -1 -> throw new ArithmeticException(\"Attempted square root of negative BigDecimal\");\n-            case 0 -> {\n-                BigDecimal result = valueOf(0L, scale\/2);\n-                assert squareRootResultAssertions(result, mc);\n-                return result;\n-            }\n-            default -> throw new AssertionError(\"Bad value from signum\");\n-            }\n+        if (signum < 0 && (n & 1) == 0)\n+            throw new ArithmeticException(\"Negative radicand with even root degree\");\n+\n+        final int preferredScale = saturateLong(Math.ceilDiv((long) this.scale, n));\n+        if (signum == 0) {\n+            if (n < 0)\n+                throw new ArithmeticException(\"Zero radicand with negative root degree\");\n+\n+            return zeroValueOf(preferredScale);\n@@ -2158,0 +2205,1 @@\n+\n@@ -2161,1 +2209,1 @@\n-         * using the following relations:\n+         * using the following relations, assuming n > 0:\n@@ -2164,2 +2212,4 @@\n-         * sqrt(x) = sqrt(y) * 10^(exp \/ 2) if exp is even\n-         * sqrt(x) = sqrt(y*10) * 10^((exp-1)\/2) is exp is odd\n+         * nthRoot(x, n) = nthRoot(y, n) * 10^(exp \/ n) if exp mod n == 0\n+         * nthRoot(x, n) = nthRoot(y*10^(exp mod n), n) * 10^((exp - (exp mod n))\/n) otherwise\n+         *\n+         * where exp mod n == Math.floorMod(exp, n).\n@@ -2167,1 +2217,1 @@\n-         * Then use BigInteger.sqrt() on the reduced value to compute\n+         * Then use BigInteger.nthRoot() on the reduced value to compute\n@@ -2174,5 +2224,1 @@\n-\n-        \/\/ The code below favors relative simplicity over checking\n-        \/\/ for special cases that could run faster.\n-        final int preferredScale = Math.ceilDiv(this.scale, 2);\n-\n+        final int nAbs = Math.absExact(n);\n@@ -2183,1 +2229,0 @@\n-            final int strippedScale = stripped.scale;\n@@ -2185,10 +2230,4 @@\n-            if ((strippedScale & 1) != 0) \/\/ 10*stripped.unscaledValue() can't be an exact square\n-                throw new ArithmeticException(\"Computed square root not exact.\");\n-\n-            \/\/ Check for even powers of 10. Numerically sqrt(10^2N) = 10^N\n-            if (stripped.isPowerOfTen()) {\n-                result = valueOf(1L, strippedScale >> 1);\n-                \/\/ Adjust to requested precision and preferred\n-                \/\/ scale as appropriate.\n-                return result.adjustToPreferredScale(preferredScale, mc.precision);\n-            }\n+            \/\/ if stripped.scale is not a multiple of n,\n+            \/\/ 10^((-stripped.scale) mod n)*stripped.unscaledValue() can't be an exact power\n+            if (stripped.scale % n != 0)\n+                throw new ArithmeticException(\"Computed root not exact.\");\n@@ -2201,12 +2240,20 @@\n-            \/\/ precision for the cohort of the numerical value and the scale is even.\n-            BigInteger[] sqrtRem = stripped.unscaledValue().sqrtAndRemainder();\n-            result = new BigDecimal(sqrtRem[0], strippedScale >> 1);\n-\n-            \/\/ If result*result != this numerically or requires too high precision,\n-            \/\/ the square root isn't exact\n-            if (sqrtRem[1].signum != 0 || mc.precision != 0 && result.precision() > mc.precision)\n-                throw new ArithmeticException(\"Computed square root not exact.\");\n-\n-            \/\/ Test numerical properties at full precision before any\n-            \/\/ scale adjustments.\n-            assert squareRootResultAssertions(result, mc);\n+            \/\/ precision for the cohort of the numerical value and the scale is a multiple of n.\n+            BigInteger[] rootRem = stripped.unscaledValue().nthRootAndRemainder(nAbs);\n+            result = new BigDecimal(rootRem[0], stripped.scale \/ nAbs);\n+            \/\/ If result^nAbs != this numerically, the root isn't exact\n+            if (rootRem[1].signum != 0)\n+                throw new ArithmeticException(\"Computed root not exact.\");\n+\n+            if (n > 0) {\n+                \/\/ If result requires too high precision, the root isn't exact\n+                if (mc.precision != 0 && result.precision() > mc.precision)\n+                    throw new ArithmeticException(\"Computed root not exact.\");\n+            } else {\n+                try {\n+                    result = ONE.divide(result, mc);\n+                } catch (ArithmeticException e) {\n+                    \/\/ The exact result requires too high precision,\n+                    \/\/ including non-terminating decimal expansions\n+                    throw new ArithmeticException(\"Computed root not exact.\");\n+                }\n+            }\n@@ -2217,3 +2264,28 @@\n-        \/\/ To allow BigInteger.sqrt() to be used to get the square\n-        \/\/ root, it is necessary to normalize the input so that\n-        \/\/ its integer part is sufficient to get the square root\n+\n+        \/\/ Handle negative radicands\n+        BigDecimal x = this;\n+        if (signum < 0) {\n+            x = x.negate();\n+            if (mc.roundingMode == RoundingMode.FLOOR) {\n+                mc = new MathContext(mc.precision, RoundingMode.UP);\n+            } else if (mc.roundingMode == RoundingMode.CEILING) {\n+                mc = new MathContext(mc.precision, RoundingMode.DOWN);\n+            }\n+        }\n+\n+        \/\/ Handle negative degrees\n+        RoundingMode workingRM = mc.roundingMode;\n+        if (n < 0) {\n+            \/\/ Swap rounding mode as the root will be inverted\n+            workingRM = switch (workingRM) {\n+            case DOWN, FLOOR -> RoundingMode.UP;\n+            case UP, CEILING -> RoundingMode.DOWN;\n+            case HALF_DOWN   -> RoundingMode.HALF_UP;\n+            case HALF_UP     -> RoundingMode.HALF_DOWN;\n+            case HALF_EVEN   -> RoundingMode.HALF_EVEN;\n+            default -> throw new AssertionError(\"Unexpected value for RoundingMode: \" + workingRM);\n+            };\n+        }\n+        \/\/ To allow BigInteger.nthRoot() to be used to get the root,\n+        \/\/ it is necessary to normalize the input so that\n+        \/\/ its integer part is sufficient to get the root\n@@ -2222,4 +2294,10 @@\n-        final boolean halfWay = isHalfWay(mc.roundingMode);\n-        \/\/ To obtain a square root with N digits,\n-        \/\/ the radicand must have at least 2*(N-1)+1 == 2*N-1 digits.\n-        final long minWorkingPrec = ((mc.precision + (halfWay ? 1L : 0L)) << 1) - 1L;\n+        final boolean halfWay = isHalfWay(workingRM);\n+        \/* If n < 0 and no halfway rounding, the root's inversion gives an error of 1 ulp,\n+         * so we add one more digit to the integer root, so that it has an error of 0.1 ulps,\n+         * and therefore the error of the inverted root is 1+0.1 ulps.\n+         * Same reasoning for halfway rounding yields to half of the error just found.\n+         *\/\n+        final long rootDigits = mc.precision + (halfWay ? 1L : 0L) + (n < 0 ? 1L : 0L);\n+        \/\/ To obtain an n-th root with k digits,\n+        \/\/ the radicand must have at least n*(k-1)+1 digits.\n+        final long minWorkingPrec = nAbs * (rootDigits - 1L) + 1L;\n@@ -2227,6 +2305,4 @@\n-        long normScale = minWorkingPrec - this.precision() + this.scale;\n-        normScale += normScale & 1L; \/\/ the scale for normalizing must be even\n-\n-        final long workingScale = this.scale - normScale;\n-        if (workingScale != (int) workingScale)\n-            throw new ArithmeticException(\"Overflow\");\n+        long normScale = minWorkingPrec - x.precision() + x.scale;\n+        int mod = Math.floorMod(normScale, nAbs);\n+        if (mod != 0) \/\/ the scale for normalizing must be a multiple of nAbs\n+            normScale += nAbs - mod;\n@@ -2234,1 +2310,1 @@\n-        BigDecimal working = new BigDecimal(this.intVal, this.intCompact, (int) workingScale, this.precision);\n+        BigDecimal working = new BigDecimal(x.intVal, x.intCompact, checkScaleNonZero(x.scale - normScale), x.precision);\n@@ -2237,3 +2313,3 @@\n-        BigInteger sqrt;\n-        long resultScale = normScale >> 1;\n-        \/\/ Round sqrt with the specified settings\n+        BigInteger root;\n+        long resultScale = normScale \/ nAbs;\n+        \/\/ Round the root with the specified settings\n@@ -2241,1 +2317,1 @@\n-            BigInteger workingSqrt = workingInt.sqrt();\n+            BigInteger[] rootRem = workingInt.nthRootAndRemainder(nAbs);\n@@ -2243,2 +2319,2 @@\n-            BigInteger[] quotRem10 = workingSqrt.divideAndRemainder(BigInteger.TEN);\n-            sqrt = quotRem10[0];\n+            BigInteger[] quotRem10 = rootRem[0].divideAndRemainder(BigInteger.TEN);\n+            root = quotRem10[0];\n@@ -2252,2 +2328,2 @@\n-                if (mc.roundingMode == RoundingMode.HALF_UP\n-                        || mc.roundingMode == RoundingMode.HALF_EVEN && sqrt.testBit(0)\n+                if (workingRM == RoundingMode.HALF_UP\n+                        || workingRM == RoundingMode.HALF_EVEN && root.testBit(0)\n@@ -2255,1 +2331,1 @@\n-                        || !workingInt.equals(workingSqrt.multiply(workingSqrt))\n+                        || rootRem[1].signum != 0\n@@ -2262,1 +2338,1 @@\n-                sqrt = sqrt.add(1L);\n+                root = root.add(1L);\n@@ -2264,2 +2340,2 @@\n-            switch (mc.roundingMode) {\n-            case DOWN, FLOOR -> sqrt = workingInt.sqrt(); \/\/ No need to round\n+            switch (workingRM) {\n+            case DOWN, FLOOR -> root = workingInt.nthRoot(nAbs); \/\/ No need to round\n@@ -2268,2 +2344,2 @@\n-                BigInteger[] sqrtRem = workingInt.sqrtAndRemainder();\n-                sqrt = sqrtRem[0];\n+                BigInteger[] rootRem = workingInt.nthRootAndRemainder(nAbs);\n+                root = rootRem[0];\n@@ -2271,2 +2347,2 @@\n-                if (sqrtRem[1].signum != 0 || !working.isInteger())\n-                    sqrt = sqrt.add(1L);\n+                if (rootRem[1].signum != 0 || !working.isInteger())\n+                    root = root.add(1L);\n@@ -2275,1 +2351,1 @@\n-            default -> throw new AssertionError(\"Unexpected value for RoundingMode: \" + mc.roundingMode);\n+            default -> throw new AssertionError(\"Unexpected value for RoundingMode: \" + workingRM);\n@@ -2279,10 +2355,13 @@\n-        result = new BigDecimal(sqrt, checkScale(sqrt, resultScale), mc); \/\/ mc ensures no increase of precision\n-        \/\/ Test numerical properties at full precision before any\n-        \/\/ scale adjustments.\n-        assert squareRootResultAssertions(result, mc);\n-        \/\/ Adjust to requested precision and preferred\n-        \/\/ scale as appropriate.\n-        if (result.scale > preferredScale) \/\/ else can't increase the result's precision to fit the preferred scale\n-            result = stripZerosToMatchScale(result.intVal, result.intCompact, result.scale, preferredScale);\n-\n-        return result;\n+        if (n > 0) {\n+            result = new BigDecimal(root, checkScale(root, resultScale), mc); \/\/ mc ensures no increase of precision\n+            \/\/ Adjust to requested precision and preferred\n+            \/\/ scale as appropriate.\n+            if (result.scale > preferredScale) \/\/ else can't increase result's precision to fit the preferred scale\n+                result = stripZerosToMatchScale(result.intVal, result.intCompact, result.scale, preferredScale);\n+        } else {\n+            result = ONE.divide(new BigDecimal(root, checkScaleNonZero(resultScale)), mc);\n+            \/\/ Adjust to requested precision and preferred\n+            \/\/ scale as appropriate.\n+            result = result.adjustToPreferredScale(preferredScale, mc.precision);\n+        }\n+        return signum > 0 ? result : result.negate();\n@@ -2319,104 +2398,0 @@\n-    private BigDecimal square() {\n-        return this.multiply(this);\n-    }\n-\n-    private boolean isPowerOfTen() {\n-        return BigInteger.ONE.equals(this.unscaledValue());\n-    }\n-\n-    \/**\n-     * For nonzero values, check numerical correctness properties of\n-     * the computed result for the chosen rounding mode.\n-     *\n-     * For the directed rounding modes:\n-     *\n-     * <ul>\n-     *\n-     * <li> For DOWN and FLOOR, result^2 must be {@code <=} the input\n-     * and (result+ulp)^2 must be {@code >} the input.\n-     *\n-     * <li>Conversely, for UP and CEIL, result^2 must be {@code >=}\n-     * the input and (result-ulp)^2 must be {@code <} the input.\n-     * <\/ul>\n-     *\/\n-    private boolean squareRootResultAssertions(BigDecimal result, MathContext mc) {\n-        if (result.signum() == 0) {\n-            return squareRootZeroResultAssertions(result, mc);\n-        } else {\n-            RoundingMode rm = mc.getRoundingMode();\n-            BigDecimal ulp = result.ulp();\n-            BigDecimal neighborUp   = result.add(ulp);\n-            \/\/ Make neighbor down accurate even for powers of ten\n-            if (result.isPowerOfTen()) {\n-                ulp = ulp.divide(TEN);\n-            }\n-            BigDecimal neighborDown = result.subtract(ulp);\n-\n-            \/\/ Both the starting value and result should be nonzero and positive.\n-            assert (result.signum() == 1 &&\n-                    this.signum() == 1) :\n-                \"Bad signum of this and\/or its sqrt.\";\n-\n-            switch (rm) {\n-            case DOWN:\n-            case FLOOR:\n-                assert\n-                    result.square().compareTo(this)     <= 0 &&\n-                    neighborUp.square().compareTo(this) > 0:\n-                \"Square of result out for bounds rounding \" + rm;\n-                return true;\n-\n-            case UP:\n-            case CEILING:\n-                assert\n-                    result.square().compareTo(this)       >= 0 &&\n-                    neighborDown.square().compareTo(this) < 0:\n-                \"Square of result out for bounds rounding \" + rm;\n-                return true;\n-\n-\n-            case HALF_DOWN:\n-            case HALF_EVEN:\n-            case HALF_UP:\n-                BigDecimal err = result.square().subtract(this).abs();\n-                BigDecimal errUp = neighborUp.square().subtract(this);\n-                BigDecimal errDown =  this.subtract(neighborDown.square());\n-                \/\/ All error values should be positive so don't need to\n-                \/\/ compare absolute values.\n-\n-                int err_comp_errUp = err.compareTo(errUp);\n-                int err_comp_errDown = err.compareTo(errDown);\n-\n-                assert\n-                    errUp.signum()   == 1 &&\n-                    errDown.signum() == 1 :\n-                \"Errors of neighbors squared don't have correct signs\";\n-\n-                \/\/ For breaking a half-way tie, the return value may\n-                \/\/ have a larger error than one of the neighbors. For\n-                \/\/ example, the square root of 2.25 to a precision of\n-                \/\/ 1 digit is either 1 or 2 depending on how the exact\n-                \/\/ value of 1.5 is rounded. If 2 is returned, it will\n-                \/\/ have a larger rounding error than its neighbor 1.\n-                assert\n-                    err_comp_errUp   <= 0 ||\n-                    err_comp_errDown <= 0 :\n-                \"Computed square root has larger error than neighbors for \" + rm;\n-\n-                assert\n-                    ((err_comp_errUp   == 0 ) ? err_comp_errDown < 0 : true) &&\n-                    ((err_comp_errDown == 0 ) ? err_comp_errUp   < 0 : true) :\n-                        \"Incorrect error relationships\";\n-                \/\/ && could check for digit conditions for ties too\n-                return true;\n-\n-            default: \/\/ Definition of UNNECESSARY already verified.\n-                return true;\n-            }\n-        }\n-    }\n-\n-    private boolean squareRootZeroResultAssertions(BigDecimal result, MathContext mc) {\n-        return this.compareTo(ZERO) == 0;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":162,"deletions":187,"binary":false,"changes":349,"status":"modified"}]}