{"files":[{"patch":"@@ -2301,0 +2301,1 @@\n+            boolean increment = false;\n@@ -2308,1 +2309,0 @@\n-                boolean increment = false;\n@@ -2320,4 +2320,0 @@\n-\n-                if (increment) {\n-                    root = root.add(1L);\n-                }\n@@ -2333,1 +2329,1 @@\n-                        root = root.add(1L);\n+                        increment = true;\n@@ -2339,0 +2335,4 @@\n+            if (increment) {\n+                root = root.add(1L);\n+            }\n+\n@@ -2363,0 +2363,1 @@\n+            boolean increment = false;\n@@ -2368,1 +2369,0 @@\n-                boolean increment = false;\n@@ -2380,4 +2380,0 @@\n-\n-                if (increment) {\n-                    result = result.add(result.ulp());\n-                }\n@@ -2391,1 +2387,1 @@\n-                        result = result.add(result.ulp());\n+                        increment = true;\n@@ -2397,0 +2393,3 @@\n+            if (increment) {\n+                result = result.add(result.ulp(), mc); \/\/ mc ensures no increase of precision\n+            }\n@@ -2468,0 +2467,1 @@\n+        BigDecimal divisor = null;\n@@ -2469,1 +2469,3 @@\n-            rad = ONE.divide(rad, result.scale * nAbs, RoundingMode.DOWN);\n+            divisor = rad;\n+            int inverseScale = checkScale((result.scale + (resAbs.isPowerOfTen() ? 1L : 0L)) * nAbs);\n+            rad = ONE.divide(divisor, inverseScale, RoundingMode.DOWN);\n@@ -2483,0 +2485,1 @@\n+            int neighborUpToN_comp_rad = neighborUp.pow(nAbs).compareTo(rad);\n@@ -2484,4 +2487,5 @@\n-                resAbs.pow(nAbs).compareTo(rad)     <= 0 &&\n-                (n > 0\n-                        ? neighborUp.pow(nAbs).compareTo(rad) >  0\n-                        : neighborUp.pow(nAbs).compareTo(rad) >= 0) \/\/ Inverse radicand is not exact\n+                resAbs.pow(nAbs).compareTo(rad) <= 0 &&\n+               (neighborUpToN_comp_rad           > 0 ||\n+                neighborUpToN_comp_rad          == 0 && n < 0 &&\n+                \/\/ Inverse radicand must not be exact\n+                rad.multiply(divisor).compareTo(ONE) != 0)\n@@ -2493,0 +2497,1 @@\n+            int neighborDownToN_comp_rad = neighborDown.pow(nAbs).compareTo(rad);\n@@ -2494,4 +2499,5 @@\n-                resAbs.pow(nAbs).compareTo(rad)       >= 0 &&\n-                (n > 0\n-                        ? neighborDown.pow(nAbs).compareTo(rad) <  0\n-                        : neighborDown.pow(nAbs).compareTo(rad) <= 0) \/\/ Inverse radicand is not exact\n+                 resAbs.pow(nAbs).compareTo(rad) >= 0 &&\n+                (neighborDownToN_comp_rad         < 0 ||\n+                 neighborDownToN_comp_rad == 0 && n < 0 &&\n+                 \/\/ Inverse radicand must not be exact\n+                 rad.multiply(divisor).compareTo(ONE) != 0)\n@@ -2507,3 +2513,3 @@\n-            BigDecimal errDown =  rad.subtract(neighborDown.pow(nAbs));\n-            \/\/ All error values should be positive so don't need to\n-            \/\/ compare absolute values.\n+            BigDecimal errDown = rad.subtract(neighborDown.pow(nAbs));\n+            \/\/ All error values should be positive or non-negative\n+            \/\/ so don't need to compare absolute values.\n@@ -2515,3 +2521,6 @@\n-                errUp.signum()   == 1 &&\n-                errDown.signum() == 1 :\n-            \"Errors of neighbors powered don't have correct signs\";\n+                 errUp.signum()   == 1 &&\n+                (errDown.signum() == 1 ||\n+                 errDown.signum() == 0 && n < 0 &&\n+                 \/\/ Inverse radicand must not be exact\n+                 rad.multiply(divisor).compareTo(ONE) != 0)\n+            : \"Errors of neighbors powered don't have correct signs\";\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":36,"deletions":27,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -58,2 +58,2 @@\n-        failures += squareRootTwoTests();\n-        failures += lowPrecisionPerfectSquares();\n+        failures += rootTwoTests();\n+        failures += lowPrecisionPerfectPowers();\n@@ -151,0 +151,6 @@\n+    private static List<RoundingMode> roundingModes() {\n+        List<RoundingMode> modes = new ArrayList<>(Arrays.asList(RoundingMode.values()));\n+        modes.remove(RoundingMode.UNNECESSARY);\n+        return modes;\n+    }\n+\n@@ -153,1 +159,1 @@\n-     * values scaled by 10^-1, ±0.1, ... ±0.9.\n+     * values scaled by 10^-1, ±0.1 ... ±0.9.\n@@ -159,2 +165,1 @@\n-        List<RoundingMode> modes = new ArrayList<>(Arrays.asList(RoundingMode.values()));\n-        modes.remove(RoundingMode.UNNECESSARY);\n+        List<RoundingMode> modes = roundingModes();\n@@ -169,3 +174,5 @@\n-                    System.out.println(minus_bd + \" \" + mc);\n-                    failures += compare(minus_bd.rootn( 3, mc), bd.rootn( 3, positiveMC).negate(), true, \"one digit\");\n-                    failures += compare(minus_bd.rootn(-3, mc), bd.rootn(-3, positiveMC).negate(), true, \"one digit\");\n+                    for (int n = 1; n < 11; n += 2) {\n+                        System.err.println(minus_bd + \", \" + n + \", \" + mc);\n+                        failures += compare(minus_bd.rootn( n, mc), bd.rootn( n, positiveMC).negate(), true, \"one digit\");\n+                        failures += compare(minus_bd.rootn(-n, mc), bd.rootn(-n, positiveMC).negate(), true, \"one digit\");\n+                    }\n@@ -176,2 +183,5 @@\n-                    failures += compare(minus_bd.rootn( 3, mc), bd.rootn( 3, positiveMC).negate(), true, \"one digit\");\n-                    failures += compare(minus_bd.rootn(-3, mc), bd.rootn(-3, positiveMC).negate(), true, \"one digit\");\n+                    for (int n = 1; n < 11; n += 2) {\n+                        System.err.println(minus_bd + \", \" + n + \", \" + mc);\n+                        failures += compare(minus_bd.rootn( n, mc), bd.rootn( n, positiveMC).negate(), true, \"one digit\");\n+                        failures += compare(minus_bd.rootn(-n, mc), bd.rootn(-n, positiveMC).negate(), true, \"one digit\");\n+                    }\n@@ -186,3 +196,3 @@\n-     * Probe inputs with two digits of precision, (10 ... 99) and\n-     * those values scaled by 10^-1 (1, ... 9.9) and scaled by 10^-2\n-     * (0.1 ... 0.99).\n+     * Probe inputs with two digits of precision, (±10 ... ±99) and\n+     * those values scaled by 10^-1 (±1 ... ±9.9) and scaled by 10^-2\n+     * (±0.1 ... ±0.99).\n@@ -193,4 +203,1 @@\n-        List<RoundingMode> modes =\n-            List.of(RoundingMode.UP,      RoundingMode.DOWN,\n-                    RoundingMode.CEILING, RoundingMode.FLOOR,\n-                    RoundingMode.HALF_UP, RoundingMode.HALF_DOWN, RoundingMode.HALF_EVEN);\n+        List<RoundingMode> modes = roundingModes();\n@@ -200,2 +207,2 @@\n-            BigDecimal bd1 = bd0.multiply(ONE_TENTH);\n-            BigDecimal bd2 = bd1.multiply(ONE_TENTH);\n+            BigDecimal bd1 = bd0.scaleByPowerOfTen(-1);\n+            BigDecimal bd2 = bd1.scaleByPowerOfTen(-1);\n@@ -207,0 +214,1 @@\n+                        MathContext positiveMC = new MathContext(prec, positiveRoundingMode(rm));\n@@ -208,0 +216,6 @@\n+\n+                        BigDecimal minus_bd = bd.negate();\n+                        for (int n = 1; n < 11; n += 2) {\n+                            failures += compare(minus_bd.rootn( n, mc), bd.rootn( n, positiveMC).negate(), true, \"two digits\");\n+                            failures += compare(minus_bd.rootn(-n, mc), bd.rootn(-n, positiveMC).negate(), true, \"two digits\");\n+                        }\n@@ -349,1 +363,1 @@\n-    private static int squareRootTwoTests() {\n+    private static int rootTwoTests() {\n@@ -353,1 +367,1 @@\n-        BigDecimal highPrecisionRoot2 =\n+        BigDecimal highPrecisionSqrt2 =\n@@ -355,0 +369,3 @@\n+        \/\/ Cube root of 2 truncated to 65 digits\n+        BigDecimal highPrecisionCbrt2 =\n+            new BigDecimal(\"1.25992104989487316476721060727822835057025146470150798008197511215\");\n@@ -356,5 +373,1 @@\n-        RoundingMode[] modes = {\n-            RoundingMode.UP,       RoundingMode.DOWN,\n-            RoundingMode.CEILING, RoundingMode.FLOOR,\n-            RoundingMode.HALF_UP, RoundingMode.HALF_DOWN, RoundingMode.HALF_EVEN\n-        };\n+        List<RoundingMode> modes = roundingModes();\n@@ -365,2 +378,3 @@\n-        \/\/ highPrecisionRoot2.round(mc) and the alternative internal high-precision\n-        \/\/ implementation of square root.\n+        \/\/ highPrecisionSqrt2.round(mc) and the alternative internal high-precision\n+        \/\/ implementation of square root, and compare TWO.rootn(3, mc) to\n+        \/\/ highPrecisionCbrt2.round(mc).\n@@ -370,3 +384,6 @@\n-                BigDecimal expected = highPrecisionRoot2.round(mc);\n-                BigDecimal computed = TWO.sqrt(mc);\n-                BigDecimal altComputed = BigSquareRoot.sqrt(TWO, mc);\n+                BigDecimal expectedSqrt = highPrecisionSqrt2.round(mc);\n+                BigDecimal computedSqrt = TWO.sqrt(mc);\n+                BigDecimal altComputedSqrt = BigSquareRoot.sqrt(TWO, mc);\n+\n+                failures += equalNumerically(expectedSqrt, computedSqrt, \"sqrt(2)\");\n+                failures += equalNumerically(computedSqrt, altComputedSqrt, \"computed & altComputed\");\n@@ -374,2 +391,4 @@\n-                failures += equalNumerically(expected, computed, \"sqrt(2)\");\n-                failures += equalNumerically(computed, altComputed, \"computed & altComputed\");\n+                BigDecimal expectedCbrt = highPrecisionCbrt2.round(mc);\n+                BigDecimal computedCbrt = TWO.rootn(3, mc);\n+\n+                failures += equalNumerically(expectedCbrt, computedCbrt, \"rootn(2, 3)\");\n@@ -382,1 +401,1 @@\n-    private static int lowPrecisionPerfectSquares() {\n+    private static int lowPrecisionPerfectPowers() {\n@@ -385,32 +404,22 @@\n-        \/\/ For 5^2 through 9^2, if the input is rounded to one digit\n-        \/\/ first before the root is computed, the wrong answer will\n-        \/\/ result. Verify results and scale for different rounding\n-        \/\/ modes and precisions.\n-        long[][] squaresWithOneDigitRoot = {{ 4, 2},\n-                                            { 9, 3},\n-                                            {25, 5},\n-                                            {36, 6},\n-                                            {49, 7},\n-                                            {64, 8},\n-                                            {81, 9}};\n-\n-        for (long[] squareAndRoot : squaresWithOneDigitRoot) {\n-            BigDecimal square     = new BigDecimal(squareAndRoot[0]);\n-            BigDecimal expected   = new BigDecimal(squareAndRoot[1]);\n-\n-            for (int scale = 0; scale <= 4; scale++) {\n-                BigDecimal scaledSquare = square.setScale(scale, RoundingMode.UNNECESSARY);\n-                int expectedScale = Math.ceilDiv(scale, 2);\n-                for (int precision = 0; precision <= 5; precision++) {\n-                    for (RoundingMode rm : RoundingMode.values()) {\n-                        MathContext mc = new MathContext(precision, rm);\n-                        BigDecimal computedRoot = scaledSquare.sqrt(mc);\n-                        failures += equalNumerically(expected, computedRoot, \"simple squares\");\n-                        int computedScale = computedRoot.scale();\n-                        if (precision >=  expectedScale + 1 &&\n-                            computedScale != expectedScale) {\n-                            System.err.printf(\"%s\\tprecision=%d\\trm=%s%n\",\n-                                              computedRoot.toString(), precision, rm);\n-                            failures++;\n-                            System.err.printf(\"\\t%s does not have expected scale of %d%n.\",\n-                                              computedRoot, expectedScale);\n+        for (int i = -9; i <= 9; i++) {\n+            for (int n = 1; n < 10; n++) {\n+                BigDecimal expected = BigDecimal.valueOf(n % 2 != 0 ? i : Math.abs(i));\n+                BigDecimal pow = BigDecimal.valueOf(Math.powExact(i, n));\n+\n+                for (int scale = 0; scale <= 4; scale++) {\n+                    BigDecimal scaledPow = pow.setScale(scale);\n+                    int expectedScale = Math.ceilDiv(scale, n);\n+                    for (int precision = 0; precision <= 5; precision++) {\n+                        for (RoundingMode rm : RoundingMode.values()) {\n+                            MathContext mc = new MathContext(precision, rm);\n+                            BigDecimal computedRoot = scaledPow.rootn(n, mc);\n+                            failures += equalNumerically(expected, computedRoot, \"simple powers\");\n+                            int computedScale = computedRoot.scale();\n+                            if (precision >=  expectedScale + 1 &&\n+                                computedScale != expectedScale) {\n+                                System.err.printf(\"%s\\tprecision=%d\\trm=%s%n\",\n+                                                  computedRoot.toString(), precision, rm);\n+                                failures++;\n+                                System.err.printf(\"\\t%s does not have expected scale of %d%n.\",\n+                                                  computedRoot, expectedScale);\n+                            }\n@@ -427,1 +436,1 @@\n-     * Test around 3.9999 that the sqrt doesn't improperly round-up to\n+     * Test around 2^n-0.000...1 that the root doesn't improperly round-up to\n@@ -435,1 +444,0 @@\n-\n@@ -441,1 +449,12 @@\n-            failures += (result.compareTo(TWO) < 0) ? 0  : 1 ;\n+            failures += (result.compareTo(TWO) < 0) ? 0 : 1;\n+        }\n+\n+        BigDecimal ulp = nearFour.ulp();\n+        for (int n = 1; n < 10; n++) {\n+            BigDecimal near2ToN = BigDecimal.valueOf(Math.powExact(2, n)).subtract(ulp);\n+            \/\/ Root is 1.9999...\n+            for (int i = 1; i < 64; i++) {\n+                MathContext mc = new MathContext(i, RoundingMode.FLOOR);\n+                BigDecimal result = near2ToN.rootn(n, mc);\n+                failures += (result.compareTo(TWO) < 0) ? 0 : 1;\n+            }\n@@ -448,1 +467,1 @@\n-     * Test around 4.000...1 that the sqrt doesn't improperly\n+     * Test around 2^n+0.000...1 that the root doesn't improperly\n@@ -456,1 +475,0 @@\n-\n@@ -462,1 +480,12 @@\n-            failures += (result.compareTo(TWO) > 0) ? 0  : 1 ;\n+            failures += (result.compareTo(TWO) > 0) ? 0 : 1;\n+        }\n+\n+        BigDecimal ulp = nearFour.ulp();\n+        for (int n = 1; n < 10; n++) {\n+            BigDecimal near2ToN = BigDecimal.valueOf(Math.powExact(2, n)).add(ulp);\n+            \/\/ Root is 2.0000....<non-zero digits>\n+            for (int i = 1; i < 64; i++) {\n+                MathContext mc = new MathContext(i, RoundingMode.CEILING);\n+                BigDecimal result = near2ToN.rootn(n, mc);\n+                failures += (result.compareTo(TWO) > 0) ? 0 : 1;\n+            }\n@@ -471,1 +500,1 @@\n-         BigDecimal near10 = new BigDecimal(\"9.99999999999999999999\");\n+        BigDecimal near10 = new BigDecimal(\"9.99999999999999999999\");\n@@ -473,1 +502,1 @@\n-         BigDecimal near10sq = near10.multiply(near10);\n+        BigDecimal near10sq = near10.multiply(near10);\n@@ -475,1 +504,1 @@\n-         BigDecimal near10sq_ulp = near10sq.add(near10sq.ulp());\n+        BigDecimal near10sq_ulp = near10sq.add(near10sq.ulp());\n@@ -551,0 +580,21 @@\n+        for (int n = 1; n < 10; n++) {\n+            for (BigDecimal halfWayCase : halfWayCases) {\n+                \/\/ Round result to next-to-last place\n+                int precision = halfWayCase.precision() - 1;\n+                BigDecimal pow = halfWayCase.pow(n);\n+\n+                for (RoundingMode rm : List.of(RoundingMode.HALF_EVEN,\n+                                               RoundingMode.HALF_UP,\n+                                               RoundingMode.HALF_DOWN)) {\n+                    MathContext mc = new MathContext(precision, rm);\n+\n+                    System.out.println(\"\\nRounding mode \" + rm);\n+                    System.out.println(\"\\t\" + halfWayCase.round(mc) + \"\\t\" + halfWayCase);\n+\n+                    failures += equalNumerically(pow.rootn(n, mc),\n+                                                 halfWayCase.round(mc),\n+                                                 \"Rounding halway \" + rm);\n+                }\n+            }\n+        }\n+\n","filename":"test\/jdk\/java\/math\/BigDecimal\/SquareRootTests.java","additions":125,"deletions":75,"binary":false,"changes":200,"status":"modified"}]}