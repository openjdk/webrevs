{"files":[{"patch":"@@ -158,0 +158,1 @@\n+ * <tr><th scope=\"row\">n<sup>th<\/sup> root<\/th><td>ceil((double) radicand.scale()\/n)<\/td>\n@@ -2146,0 +2147,46 @@\n+        return rootn(2, mc);\n+    }\n+\n+    \/**\n+     * Returns an approximation to the {@code n}<sup>th<\/sup> root of {@code this}\n+     * with rounding according to the context settings.\n+     *\n+     * <p>The preferred scale of the returned result is equal to\n+     * {@code Math.ceilDiv(this.scale(), n)}. The value of the returned result is\n+     * always within one ulp of the exact decimal value for the\n+     * precision in question.  If the rounding mode is {@link\n+     * RoundingMode#HALF_UP HALF_UP}, {@link RoundingMode#HALF_DOWN\n+     * HALF_DOWN}, or {@link RoundingMode#HALF_EVEN HALF_EVEN}, the\n+     * result is within one half an ulp of the exact decimal value.\n+     *\n+     * <p>Special case:\n+     * <ul>\n+     * <li> The {@code n}<sup>th<\/sup> root of a number numerically equal to {@code\n+     * ZERO} is numerically equal to {@code ZERO} with a preferred\n+     * scale according to the general rule above. In particular, for\n+     * {@code ZERO}, {@code ZERO.rootn(n, mc).equals(ZERO)} is true with\n+     * any {@code MathContext} as an argument.\n+     * <\/ul>\n+     *\n+     * @param n the root degree\n+     * @param mc the context to use.\n+     * @return the {@code n}<sup>th<\/sup> root of {@code this}.\n+     * @throws ArithmeticException if {@code n == 0 || n == Integer.MIN_VALUE}.\n+     * @throws ArithmeticException if {@code n} is even and {@code this} is negative.\n+     * @throws ArithmeticException if {@code n} is negative and {@code this} is zero.\n+     * @throws ArithmeticException if an exact result is requested\n+     * ({@code mc.getPrecision() == 0}) and there is no finite decimal\n+     * expansion of the exact result\n+     * @throws ArithmeticException if\n+     * {@code (mc.getRoundingMode() == RoundingMode.UNNECESSARY}) and\n+     * the exact result cannot fit in {@code mc.getPrecision()} digits.\n+     * @see #sqrt(MathContext)\n+     * @see BigInteger#rootn(int)\n+     * @since 27\n+     * @apiNote Note that calling {@code rootn(2, mc)} is equivalent to calling {@code sqrt(mc)}.\n+     *\/\n+    public BigDecimal rootn(int n, MathContext mc) {\n+        \/\/ Special cases\n+        if (n == 0)\n+            throw new ArithmeticException(\"Zero root degree\");\n+\n@@ -2147,10 +2194,9 @@\n-        if (signum != 1) {\n-            switch (signum) {\n-            case -1 -> throw new ArithmeticException(\"Attempted square root of negative BigDecimal\");\n-            case 0 -> {\n-                BigDecimal result = valueOf(0L, scale\/2);\n-                assert squareRootResultAssertions(result, mc);\n-                return result;\n-            }\n-            default -> throw new AssertionError(\"Bad value from signum\");\n-            }\n+        if (signum < 0 && (n & 1) == 0)\n+            throw new ArithmeticException(\"Negative radicand with even root degree\");\n+\n+        final int preferredScale = saturateLong(Math.ceilDiv((long) this.scale, n));\n+        if (signum == 0) {\n+            if (n < 0)\n+                throw new ArithmeticException(\"Zero radicand with negative root degree\");\n+\n+            return zeroValueOf(preferredScale);\n@@ -2158,0 +2204,1 @@\n+\n@@ -2161,1 +2208,1 @@\n-         * using the following relations:\n+         * using the following relations, assuming n > 0:\n@@ -2164,2 +2211,4 @@\n-         * sqrt(x) = sqrt(y) * 10^(exp \/ 2) if exp is even\n-         * sqrt(x) = sqrt(y*10) * 10^((exp-1)\/2) is exp is odd\n+         * rootn(x, n) = rootn(y, n) * 10^(exp \/ n) if exp mod n == 0\n+         * rootn(x, n) = rootn(y*10^(exp mod n), n) * 10^((exp - (exp mod n))\/n) otherwise\n+         *\n+         * where exp mod n == Math.floorMod(exp, n).\n@@ -2167,1 +2216,1 @@\n-         * Then use BigInteger.sqrt() on the reduced value to compute\n+         * Then use BigInteger.rootn() on the reduced value to compute\n@@ -2174,5 +2223,1 @@\n-\n-        \/\/ The code below favors relative simplicity over checking\n-        \/\/ for special cases that could run faster.\n-        final int preferredScale = Math.ceilDiv(this.scale, 2);\n-\n+        final int nAbs = Math.absExact(n);\n@@ -2183,1 +2228,0 @@\n-            final int strippedScale = stripped.scale;\n@@ -2185,10 +2229,4 @@\n-            if ((strippedScale & 1) != 0) \/\/ 10*stripped.unscaledValue() can't be an exact square\n-                throw new ArithmeticException(\"Computed square root not exact.\");\n-\n-            \/\/ Check for even powers of 10. Numerically sqrt(10^2N) = 10^N\n-            if (stripped.isPowerOfTen()) {\n-                result = valueOf(1L, strippedScale >> 1);\n-                \/\/ Adjust to requested precision and preferred\n-                \/\/ scale as appropriate.\n-                return result.adjustToPreferredScale(preferredScale, mc.precision);\n-            }\n+            \/\/ if stripped.scale is not a multiple of n,\n+            \/\/ 10^((-stripped.scale) mod n)*stripped.unscaledValue() can't be an exact power\n+            if (stripped.scale % n != 0)\n+                throw new ArithmeticException(\"Computed root not exact.\");\n@@ -2201,14 +2239,23 @@\n-            \/\/ precision for the cohort of the numerical value and the scale is even.\n-            BigInteger[] sqrtRem = stripped.unscaledValue().sqrtAndRemainder();\n-            result = new BigDecimal(sqrtRem[0], strippedScale >> 1);\n-\n-            \/\/ If result*result != this numerically or requires too high precision,\n-            \/\/ the square root isn't exact\n-            if (sqrtRem[1].signum != 0 || mc.precision != 0 && result.precision() > mc.precision)\n-                throw new ArithmeticException(\"Computed square root not exact.\");\n-\n-            \/\/ Test numerical properties at full precision before any\n-            \/\/ scale adjustments.\n-            assert squareRootResultAssertions(result, mc);\n-            \/\/ Adjust to requested precision and preferred\n-            \/\/ scale as appropriate.\n+            \/\/ precision for the cohort of the numerical value and the scale is a multiple of n.\n+            BigInteger[] rootRem = stripped.unscaledValue().rootnAndRemainder(nAbs);\n+            result = new BigDecimal(rootRem[0], stripped.scale \/ nAbs);\n+            \/\/ If result^nAbs != this numerically, the root isn't exact\n+            if (rootRem[1].signum != 0)\n+                throw new ArithmeticException(\"Computed root not exact.\");\n+\n+            if (n > 0) {\n+                \/\/ If result requires too high precision, the root isn't exact\n+                if (mc.precision != 0 && result.precision() > mc.precision)\n+                    throw new ArithmeticException(\"Computed root not exact.\");\n+            } else {\n+                try {\n+                    result = ONE.divide(result, mc);\n+                } catch (ArithmeticException e) {\n+                    \/\/ The exact result requires too high precision,\n+                    \/\/ including non-terminating decimal expansions\n+                    throw new ArithmeticException(\"Computed root not exact.\");\n+                }\n+            }\n+            \/\/ Test numerical properties at full precision before any scale adjustments.\n+            assert rootnResultAssertions(result, mc, n);\n+            \/\/ Adjust to requested precision and preferred scale as appropriate.\n@@ -2217,3 +2264,15 @@\n-        \/\/ To allow BigInteger.sqrt() to be used to get the square\n-        \/\/ root, it is necessary to normalize the input so that\n-        \/\/ its integer part is sufficient to get the square root\n+\n+        \/\/ Handle negative radicands\n+        BigDecimal x = this;\n+        if (signum < 0) {\n+            x = x.negate();\n+            if (mc.roundingMode == RoundingMode.FLOOR) {\n+                mc = new MathContext(mc.precision, RoundingMode.UP);\n+            } else if (mc.roundingMode == RoundingMode.CEILING) {\n+                mc = new MathContext(mc.precision, RoundingMode.DOWN);\n+            }\n+        }\n+\n+        \/\/ To allow BigInteger.rootn() to be used to get the root,\n+        \/\/ it is necessary to normalize the input so that\n+        \/\/ its integer part is sufficient to get the root\n@@ -2223,17 +2282,36 @@\n-        \/\/ To obtain a square root with N digits,\n-        \/\/ the radicand must have at least 2*(N-1)+1 == 2*N-1 digits.\n-        final long minWorkingPrec = ((mc.precision + (halfWay ? 1L : 0L)) << 1) - 1L;\n-        \/\/ normScale is the number of digits to take from the fraction of the input\n-        long normScale = minWorkingPrec - this.precision() + this.scale;\n-        normScale += normScale & 1L; \/\/ the scale for normalizing must be even\n-\n-        final long workingScale = this.scale - normScale;\n-        if (workingScale != (int) workingScale)\n-            throw new ArithmeticException(\"Overflow\");\n-\n-        BigDecimal working = new BigDecimal(this.intVal, this.intCompact, (int) workingScale, this.precision);\n-        BigInteger workingInt = working.toBigInteger();\n-\n-        BigInteger sqrt;\n-        long resultScale = normScale >> 1;\n-        \/\/ Round sqrt with the specified settings\n+        final long rootDigits = mc.precision + (halfWay ? 1L : 0L);\n+        \/\/ To obtain an n-th root with k digits,\n+        \/\/ the radicand must have at least n*(k-1)+1 digits.\n+        final long minWorkingPrec = nAbs * (rootDigits - 1L) + 1L;\n+\n+        long normScale; \/\/ the number of digits to take from the fraction of the input\n+        BigDecimal working = null, xInv = null;\n+        BigInteger workingInt;\n+        if (n > 0) {\n+            normScale = minWorkingPrec - x.precision() + x.scale;\n+            int mod = Math.floorMod(normScale, n);\n+            if (mod != 0) \/\/ the scale for normalizing must be a multiple of n\n+                normScale += n - mod;\n+\n+            working = new BigDecimal(x.intVal, x.intCompact, checkScaleNonZero(x.scale - normScale), x.precision);\n+            workingInt = working.toBigInteger();\n+        } else { \/\/ Handle negative degrees\n+            \/* Computing the n-th root of x is equivalent\n+             * to computing the (-n)-th root of 1\/x.\n+             *\/\n+            \/\/ Compute the scale for xInv, in order to ensure\n+            \/\/ that xInv's precision is at least minWorkingPrec\n+            final int fracZeros = x.precision() - 1 - (x.isPowerOfTen() ? 1 : 0);\n+            normScale = minWorkingPrec + fracZeros - x.scale;\n+            int mod = Math.floorMod(normScale, nAbs);\n+            if (mod != 0)\n+                normScale += nAbs - mod;\n+\n+            xInv = ONE.divide(x, checkScaleNonZero(normScale), RoundingMode.DOWN);\n+            workingInt = xInv.unscaledValue();\n+        }\n+\n+        \/\/ Compute and round the root with the specified settings\n+        BigInteger root;\n+        long resultScale = normScale \/ nAbs;\n+        boolean increment = false;\n@@ -2241,1 +2319,1 @@\n-            BigInteger workingSqrt = workingInt.sqrt();\n+            BigInteger[] rootRem = workingInt.rootnAndRemainder(nAbs);\n@@ -2243,2 +2321,2 @@\n-            BigInteger[] quotRem10 = workingSqrt.divideAndRemainder(BigInteger.TEN);\n-            sqrt = quotRem10[0];\n+            BigInteger[] quotRem10 = rootRem[0].divideAndRemainder(BigInteger.TEN);\n+            root = quotRem10[0];\n@@ -2247,1 +2325,0 @@\n-            boolean increment = false;\n@@ -2253,1 +2330,1 @@\n-                        || mc.roundingMode == RoundingMode.HALF_EVEN && sqrt.testBit(0)\n+                        || mc.roundingMode == RoundingMode.HALF_EVEN && root.testBit(0)\n@@ -2255,2 +2332,2 @@\n-                        || !workingInt.equals(workingSqrt.multiply(workingSqrt))\n-                        || !working.isInteger()) {\n+                        || rootRem[1].signum != 0\n+                        || (n > 0 ? !working.isInteger() : xInv.multiply(x).compareMagnitude(ONE) != 0)) {\n@@ -2260,3 +2337,0 @@\n-\n-            if (increment)\n-                sqrt = sqrt.add(1L);\n@@ -2265,1 +2339,1 @@\n-            case DOWN, FLOOR -> sqrt = workingInt.sqrt(); \/\/ No need to round\n+            case DOWN, FLOOR -> root = workingInt.rootn(nAbs); \/\/ No need to round\n@@ -2268,2 +2342,2 @@\n-                BigInteger[] sqrtRem = workingInt.sqrtAndRemainder();\n-                sqrt = sqrtRem[0];\n+                BigInteger[] rootRem = workingInt.rootnAndRemainder(nAbs);\n+                root = rootRem[0];\n@@ -2271,2 +2345,3 @@\n-                if (sqrtRem[1].signum != 0 || !working.isInteger())\n-                    sqrt = sqrt.add(1L);\n+                if (rootRem[1].signum != 0\n+                        || (n > 0 ? !working.isInteger() : xInv.multiply(x).compareMagnitude(ONE) != 0))\n+                    increment = true;\n@@ -2278,0 +2353,3 @@\n+        if (increment) {\n+            root = root.add(1L);\n+        }\n@@ -2279,7 +2357,5 @@\n-        result = new BigDecimal(sqrt, checkScale(sqrt, resultScale), mc); \/\/ mc ensures no increase of precision\n-        \/\/ Test numerical properties at full precision before any\n-        \/\/ scale adjustments.\n-        assert squareRootResultAssertions(result, mc);\n-        \/\/ Adjust to requested precision and preferred\n-        \/\/ scale as appropriate.\n-        if (result.scale > preferredScale) \/\/ else can't increase the result's precision to fit the preferred scale\n+        result = new BigDecimal(root, checkScale(root, resultScale), mc); \/\/ mc ensures no increase of precision\n+        \/\/ Test numerical properties at full precision before any scale adjustments.\n+        assert rootnResultAssertions(result, mc, n);\n+        \/\/ Adjust to requested precision and preferred scale as appropriate.\n+        if (result.scale > preferredScale) \/\/ else can't increase result's precision to fit the preferred scale\n@@ -2288,1 +2364,1 @@\n-        return result;\n+        return signum > 0 ? result : result.negate();\n@@ -2319,4 +2395,0 @@\n-    private BigDecimal square() {\n-        return this.multiply(this);\n-    }\n-\n@@ -2324,1 +2396,1 @@\n-        return BigInteger.ONE.equals(this.unscaledValue());\n+        return this.stripTrailingZeros().unscaledValue().equals(BigInteger.ONE);\n@@ -2335,2 +2407,3 @@\n-     * <li> For DOWN and FLOOR, result^2 must be {@code <=} the input\n-     * and (result+ulp)^2 must be {@code >} the input.\n+     * <li> For DOWN and FLOOR if input > 0 and CEIL if input < 0,\n+     * |result|^n must be {@code <=} |input|\n+     * and (|result|+ulp)^n must be {@code >} |input|.\n@@ -2338,2 +2411,3 @@\n-     * <li>Conversely, for UP and CEIL, result^2 must be {@code >=}\n-     * the input and (result-ulp)^2 must be {@code <} the input.\n+     * <li>Conversely, for UP and FLOOR if input < 0 and CEIL if input > 0,\n+     * |result|^n must be {@code >=} |input|\n+     * and (|result|-ulp)^n must be {@code <} |input|.\n@@ -2342,73 +2416,8 @@\n-    private boolean squareRootResultAssertions(BigDecimal result, MathContext mc) {\n-        if (result.signum() == 0) {\n-            return squareRootZeroResultAssertions(result, mc);\n-        } else {\n-            RoundingMode rm = mc.getRoundingMode();\n-            BigDecimal ulp = result.ulp();\n-            BigDecimal neighborUp   = result.add(ulp);\n-            \/\/ Make neighbor down accurate even for powers of ten\n-            if (result.isPowerOfTen()) {\n-                ulp = ulp.divide(TEN);\n-            }\n-            BigDecimal neighborDown = result.subtract(ulp);\n-\n-            \/\/ Both the starting value and result should be nonzero and positive.\n-            assert (result.signum() == 1 &&\n-                    this.signum() == 1) :\n-                \"Bad signum of this and\/or its sqrt.\";\n-\n-            switch (rm) {\n-            case DOWN:\n-            case FLOOR:\n-                assert\n-                    result.square().compareTo(this)     <= 0 &&\n-                    neighborUp.square().compareTo(this) > 0:\n-                \"Square of result out for bounds rounding \" + rm;\n-                return true;\n-\n-            case UP:\n-            case CEILING:\n-                assert\n-                    result.square().compareTo(this)       >= 0 &&\n-                    neighborDown.square().compareTo(this) < 0:\n-                \"Square of result out for bounds rounding \" + rm;\n-                return true;\n-\n-\n-            case HALF_DOWN:\n-            case HALF_EVEN:\n-            case HALF_UP:\n-                BigDecimal err = result.square().subtract(this).abs();\n-                BigDecimal errUp = neighborUp.square().subtract(this);\n-                BigDecimal errDown =  this.subtract(neighborDown.square());\n-                \/\/ All error values should be positive so don't need to\n-                \/\/ compare absolute values.\n-\n-                int err_comp_errUp = err.compareTo(errUp);\n-                int err_comp_errDown = err.compareTo(errDown);\n-\n-                assert\n-                    errUp.signum()   == 1 &&\n-                    errDown.signum() == 1 :\n-                \"Errors of neighbors squared don't have correct signs\";\n-\n-                \/\/ For breaking a half-way tie, the return value may\n-                \/\/ have a larger error than one of the neighbors. For\n-                \/\/ example, the square root of 2.25 to a precision of\n-                \/\/ 1 digit is either 1 or 2 depending on how the exact\n-                \/\/ value of 1.5 is rounded. If 2 is returned, it will\n-                \/\/ have a larger rounding error than its neighbor 1.\n-                assert\n-                    err_comp_errUp   <= 0 ||\n-                    err_comp_errDown <= 0 :\n-                \"Computed square root has larger error than neighbors for \" + rm;\n-\n-                assert\n-                    ((err_comp_errUp   == 0 ) ? err_comp_errDown < 0 : true) &&\n-                    ((err_comp_errDown == 0 ) ? err_comp_errUp   < 0 : true) :\n-                        \"Incorrect error relationships\";\n-                \/\/ && could check for digit conditions for ties too\n-                return true;\n-\n-            default: \/\/ Definition of UNNECESSARY already verified.\n-                return true;\n+    private boolean rootnResultAssertions(BigDecimal result, MathContext mc, int n) {\n+        BigDecimal rad = this.abs(), resAbs = result.abs();\n+        RoundingMode rm = mc.roundingMode;\n+        if (this.signum() < 0) {\n+            if (rm == RoundingMode.FLOOR) {\n+                rm = RoundingMode.UP;\n+            } else if (rm == RoundingMode.CEILING) {\n+                rm = RoundingMode.DOWN;\n@@ -2417,1 +2426,0 @@\n-    }\n@@ -2419,2 +2427,76 @@\n-    private boolean squareRootZeroResultAssertions(BigDecimal result, MathContext mc) {\n-        return this.compareTo(ZERO) == 0;\n+        int nAbs = Math.abs(n);\n+        BigDecimal ulp = resAbs.ulp();\n+        BigDecimal neighborUp = resAbs.add(ulp);\n+        \/\/ Make neighbor down accurate even for powers of ten\n+        if (resAbs.isPowerOfTen()) {\n+            ulp = ulp.scaleByPowerOfTen(-1);\n+        }\n+        BigDecimal neighborDown = resAbs.subtract(ulp);\n+\n+        switch (rm) {\n+        case DOWN:\n+        case FLOOR:\n+            assert\n+            (n > 0 ? resAbs.pow(nAbs).compareTo(rad)    <= 0 &&\n+                     neighborUp.pow(nAbs).compareTo(rad) > 0\n+                   : resAbs.pow(nAbs).multiply(rad).compareTo(ONE)    <= 0 &&\n+                     neighborUp.pow(nAbs).multiply(rad).compareTo(ONE) > 0)\n+                : \"Power of result out for bounds rounding \" + rm;\n+            return true;\n+\n+        case UP:\n+        case CEILING:\n+            assert\n+            (n > 0 ? resAbs.pow(nAbs).compareTo(rad)      >= 0 &&\n+                     neighborDown.pow(nAbs).compareTo(rad) < 0\n+                   : resAbs.pow(nAbs).multiply(rad).compareTo(ONE)      >= 0 &&\n+                     neighborDown.pow(nAbs).multiply(rad).compareTo(ONE) < 0)\n+                : \"Power of result out for bounds rounding \" + rm;\n+            return true;\n+\n+\n+        case HALF_DOWN:\n+        case HALF_EVEN:\n+        case HALF_UP:\n+            BigDecimal err, errUp, errDown;\n+            if (n > 0) {\n+                err = resAbs.pow(nAbs).subtract(rad).abs();\n+                errUp = neighborUp.pow(nAbs).subtract(rad);\n+                errDown = rad.subtract(neighborDown.pow(nAbs));\n+            } else {\n+                err = resAbs.pow(nAbs).multiply(rad).subtract(ONE).abs();\n+                errUp = neighborUp.pow(nAbs).multiply(rad).subtract(ONE);\n+                errDown = ONE.subtract(neighborDown.pow(nAbs).multiply(rad));\n+            }\n+\n+            \/\/ All error values should be positive\n+            \/\/ so don't need to compare absolute values.\n+            int err_comp_errUp = err.compareTo(errUp);\n+            int err_comp_errDown = err.compareTo(errDown);\n+\n+            assert\n+                 errUp.signum()   == 1 &&\n+                 errDown.signum() == 1\n+            : \"Errors of neighbors powered don't have correct signs\";\n+\n+            \/\/ For breaking a half-way tie, the return value may\n+            \/\/ have a larger error than one of the neighbors. For\n+            \/\/ example, the square root of 2.25 to a precision of\n+            \/\/ 1 digit is either 1 or 2 depending on how the exact\n+            \/\/ value of 1.5 is rounded. If 2 is returned, it will\n+            \/\/ have a larger rounding error than its neighbor 1.\n+            assert\n+                err_comp_errUp   <= 0 ||\n+                err_comp_errDown <= 0 :\n+            \"Computed root has larger error than neighbors for \" + rm;\n+\n+            assert\n+                ((err_comp_errUp   == 0 ) ? err_comp_errDown < 0 : true) &&\n+                ((err_comp_errDown == 0 ) ? err_comp_errUp   < 0 : true) :\n+                    \"Incorrect error relationships\";\n+            \/\/ && could check for digit conditions for ties too\n+            return true;\n+\n+        default: \/\/ Definition of UNNECESSARY already verified.\n+            return true;\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":254,"deletions":172,"binary":false,"changes":426,"status":"modified"},{"patch":"@@ -34,1 +34,2 @@\n-import java.util.List;\n+import java.util.*;\n+import java.util.stream.IntStream;\n@@ -51,1 +52,2 @@\n-        failures += negativeTests();\n+        failures += zerothRootTests();\n+        failures += negativeWithEvenDegreeTests();\n@@ -56,2 +58,2 @@\n-        failures += squareRootTwoTests();\n-        failures += lowPrecisionPerfectSquares();\n+        failures += rootTwoTests();\n+        failures += lowPrecisionPerfectPowers();\n@@ -72,1 +74,1 @@\n-    private static int negativeTests() {\n+    private static int zerothRootTests() {\n@@ -75,1 +77,1 @@\n-        for (long i = -10; i < 0; i++) {\n+        for (long i = -5; i < 5; i++) {\n@@ -79,3 +81,3 @@\n-                    BigDecimal result = input.sqrt(MathContext.DECIMAL64);\n-                    System.err.println(\"Unexpected sqrt of negative: (\" +\n-                                       input + \").sqrt()  = \" + result );\n+                    BigDecimal result = input.rootn(0, MathContext.DECIMAL64);\n+                    System.err.println(\"Unexpected 0th root: (\" +\n+                                       input + \").rootn(0)  = \" + result );\n@@ -92,0 +94,22 @@\n+    private static int negativeWithEvenDegreeTests() {\n+        int failures = 0;\n+\n+        for (long i = -10; i < 0; i++) {\n+            for (int j = -5; j < 5; j++) {\n+                BigDecimal input = BigDecimal.valueOf(i, j);\n+                for (int n = -4; n <= 4; n += 2) {\n+                    try {\n+                        BigDecimal result = input.sqrt(MathContext.DECIMAL64);\n+                        System.err.println(\"Unexpected nth root of negative: (\" +\n+                                           input + \").rootn(\" + n + \")  = \" + result );\n+                        failures += 1;\n+                    } catch (ArithmeticException e) {\n+                        ; \/\/ Expected\n+                    }\n+                }\n+            }\n+        }\n+\n+        return failures;\n+    }\n+\n@@ -96,4 +120,11 @@\n-            BigDecimal expected = BigDecimal.valueOf(0L, i\/2);\n-            \/\/ These results are independent of rounding mode\n-            failures += compare(BigDecimal.valueOf(0L, i).sqrt(MathContext.UNLIMITED),\n-                                expected, true, \"zeros\");\n+            BigDecimal input = BigDecimal.valueOf(0L, i);\n+            for (int n = -10; n <= 0; n++) {\n+                try {\n+                    BigDecimal result = input.rootn(n, MathContext.DECIMAL64);\n+                    System.err.println(\"Unexpected nth root of zero: (\" +\n+                                       input + \").rootn(\" + n + \")  = \" + result );\n+                    failures += 1;\n+                } catch (ArithmeticException e) {\n+                    ; \/\/ Expected\n+                }\n+            }\n@@ -101,2 +132,9 @@\n-            failures += compare(BigDecimal.valueOf(0L, i).sqrt(MathContext.DECIMAL64),\n-                                expected, true, \"zeros\");\n+            for (int n = 1; n < 10; n++) {\n+                BigDecimal expected = BigDecimal.valueOf(0L, Math.ceilDiv(i, n));\n+                \/\/ These results are independent of rounding mode\n+                failures += compare(input.rootn(n, MathContext.UNLIMITED),\n+                                    expected, true, \"zeros\");\n+\n+                failures += compare(input.rootn(n, MathContext.DECIMAL64),\n+                                    expected, true, \"zeros\");\n+            }\n@@ -108,0 +146,11 @@\n+    private static RoundingMode positiveRoundingMode(RoundingMode rm) {\n+        return rm == RoundingMode.FLOOR   ? RoundingMode.UP :\n+               rm == RoundingMode.CEILING ? RoundingMode.DOWN : rm;\n+    }\n+\n+    private static List<RoundingMode> roundingModes() {\n+        List<RoundingMode> modes = new ArrayList<>(Arrays.asList(RoundingMode.values()));\n+        modes.remove(RoundingMode.UNNECESSARY);\n+        return modes;\n+    }\n+\n@@ -109,2 +158,2 @@\n-     * Probe inputs with one digit of precision, 1 ... 9 and those\n-     * values scaled by 10^-1, 0.1, ... 0.9.\n+     * Probe inputs with one digit of precision, ±1 ... ±9 and those\n+     * values scaled by 10^-1, ±0.1 ... ±0.9.\n@@ -115,9 +164,2 @@\n-        List<BigDecimal> oneToNine =\n-            List.of(ONE,        TWO,        valueOf(3),\n-                    valueOf(4), valueOf(5), valueOf(6),\n-                    valueOf(7), valueOf(8), valueOf(9));\n-\n-        List<RoundingMode> modes =\n-            List.of(RoundingMode.UP,      RoundingMode.DOWN,\n-                    RoundingMode.CEILING, RoundingMode.FLOOR,\n-                    RoundingMode.HALF_UP, RoundingMode.HALF_DOWN, RoundingMode.HALF_EVEN);\n+        List<BigDecimal> oneToNine = IntStream.rangeClosed(1, 9).mapToObj(BigDecimal::valueOf).toList();\n+        List<RoundingMode> modes = roundingModes();\n@@ -127,0 +169,2 @@\n+                MathContext mc = new MathContext(i, rm);\n+                MathContext positiveMC = new MathContext(i, positiveRoundingMode(rm));\n@@ -128,2 +172,0 @@\n-                    MathContext mc = new MathContext(i, rm);\n-\n@@ -131,1 +173,7 @@\n-                    bd = bd.multiply(ONE_TENTH);\n+                    BigDecimal minus_bd = bd.negate();\n+                    for (int n = 1; n < 11; n += 2) {\n+                        failures += compare(minus_bd.rootn( n, mc), bd.rootn( n, positiveMC).negate(), true, \"one digit\");\n+                        failures += compare(minus_bd.rootn(-n, mc), bd.rootn(-n, positiveMC).negate(), true, \"one digit\");\n+                    }\n+\n+                    bd = bd.scaleByPowerOfTen(-1);\n@@ -133,0 +181,5 @@\n+                    minus_bd = bd.negate();\n+                    for (int n = 1; n < 11; n += 2) {\n+                        failures += compare(minus_bd.rootn( n, mc), bd.rootn( n, positiveMC).negate(), true, \"one digit\");\n+                        failures += compare(minus_bd.rootn(-n, mc), bd.rootn(-n, positiveMC).negate(), true, \"one digit\");\n+                    }\n@@ -141,3 +194,3 @@\n-     * Probe inputs with two digits of precision, (10 ... 99) and\n-     * those values scaled by 10^-1 (1, ... 9.9) and scaled by 10^-2\n-     * (0.1 ... 0.99).\n+     * Probe inputs with two digits of precision, (±10 ... ±99) and\n+     * those values scaled by 10^-1 (±1 ... ±9.9) and scaled by 10^-2\n+     * (±0.1 ... ±0.99).\n@@ -148,4 +201,1 @@\n-        List<RoundingMode> modes =\n-            List.of(RoundingMode.UP,      RoundingMode.DOWN,\n-                    RoundingMode.CEILING, RoundingMode.FLOOR,\n-                    RoundingMode.HALF_UP, RoundingMode.HALF_DOWN, RoundingMode.HALF_EVEN);\n+        List<RoundingMode> modes = roundingModes();\n@@ -155,2 +205,2 @@\n-            BigDecimal bd1 = bd0.multiply(ONE_TENTH);\n-            BigDecimal bd2 = bd1.multiply(ONE_TENTH);\n+            BigDecimal bd1 = bd0.scaleByPowerOfTen(-1);\n+            BigDecimal bd2 = bd1.scaleByPowerOfTen(-1);\n@@ -159,1 +209,1 @@\n-                for (int precision = 1; i < 20; i++) {\n+                for (int prec = 1; prec < 20; prec++) {\n@@ -161,1 +211,2 @@\n-                        MathContext mc = new MathContext(precision, rm);\n+                        MathContext mc = new MathContext(prec, rm);\n+                        MathContext positiveMC = new MathContext(prec, positiveRoundingMode(rm));\n@@ -163,0 +214,6 @@\n+\n+                        BigDecimal minus_bd = bd.negate();\n+                        for (int n = 1; n < 11; n += 2) {\n+                            failures += compare(minus_bd.rootn( n, mc), bd.rootn( n, positiveMC).negate(), true, \"two digits\");\n+                            failures += compare(minus_bd.rootn(-n, mc), bd.rootn(-n, positiveMC).negate(), true, \"two digits\");\n+                        }\n@@ -181,5 +238,7 @@\n-        BigDecimal[] errCases = {\n-                \/\/ (strippedScale & 1) != 0\n-                BigDecimal.TEN,\n-                \/\/ (strippedScale & 1) == 0 && !stripped.isPowerOfTen() && sqrtRem[1].signum != 0\n-                BigDecimal.TWO,\n+        Object[][] errCases = {\n+                \/\/ strippedScale % n != 0\n+                { BigDecimal.TEN, 2 },\n+                \/\/ strippedScale % n == 0 && sqrtRem[1].signum != 0\n+                { BigDecimal.TWO, 2 },\n+                \/\/ sqrtRem[1].signum == 0 && n < 0\n+                { BigDecimal.valueOf(9L), -2 },\n@@ -188,1 +247,3 @@\n-        for (BigDecimal input : errCases) {\n+        for (Object[] errCase : errCases) {\n+            BigDecimal input = (BigDecimal) errCase[0];\n+            int n = (int) errCase[1];\n@@ -192,2 +253,3 @@\n-                result = input.sqrt(unnecessary);\n-                System.err.println(\"Unexpected sqrt with UNNECESSARY RoundingMode: (\" + input + \").sqrt() = \" + result);\n+                result = input.rootn(n, unnecessary);\n+                System.err.println(\"Unexpected nth root with UNNECESSARY RoundingMode: (\"\n+                + input + \").rootn(\" + n + \") = \" + result);\n@@ -201,2 +263,3 @@\n-                result = input.sqrt(arbitrary);\n-                System.err.println(\"Unexpected sqrt with mc.precision == 0: (\" + input + \").sqrt() = \" + result);\n+                result = input.rootn(n, arbitrary);\n+                System.err.println(\"Unexpected nth root with mc.precision == 0: (\"\n+                + input + \").rootn(\" + n + \") = \" + result);\n@@ -209,1 +272,1 @@\n-        \/\/ (strippedScale & 1) == 0\n+        \/\/ strippedScale % n == 0\n@@ -211,1 +274,1 @@\n-        \/\/ !stripped.isPowerOfTen() && sqrtRem[1].signum == 0 && (mc.precision != 0 && result.precision() > mc.precision)\n+        \/\/ sqrtRem[1].signum == 0 && n > 0 && (mc.precision != 0 && result.precision() > mc.precision)\n@@ -222,1 +285,1 @@\n-        BigDecimal four = BigDecimal.valueOf(4);\n+        BigDecimal four = BigDecimal.valueOf(4), oneHalf = BigDecimal.valueOf(5, 1);\n@@ -224,11 +287,7 @@\n-                \/\/ stripped.isPowerOfTen() && mc.roundingMode == RoundingMode.UNNECESSARY\n-                { BigDecimal.ONE, unnecessary, BigDecimal.ONE },\n-                \/\/ stripped.isPowerOfTen() && mc.roundingMode != RoundingMode.UNNECESSARY && mc.precision == 0\n-                { BigDecimal.ONE, arbitrary, BigDecimal.ONE },\n-                \/\/ !stripped.isPowerOfTen() && mc.roundingMode == RoundingMode.UNNECESSARY\n-                \/\/ && sqrtRem[1].signum == 0 && mc.precision == 0\n-                { four, new MathContext(0, RoundingMode.UNNECESSARY), BigDecimal.TWO },\n-                \/\/ !stripped.isPowerOfTen() && mc.roundingMode != RoundingMode.UNNECESSARY\n-                \/\/ && sqrtRem[1].signum == 0 && mc.precision == 0\n-                { four, arbitrary, BigDecimal.TWO },\n-                \/\/ !stripped.isPowerOfTen() && sqrtRem[1].signum == 0\n+                \/\/ mc.roundingMode == RoundingMode.UNNECESSARY && sqrtRem[1].signum == 0 && n > 0\n+                \/\/ && mc.precision == 0\n+                { four, 2, new MathContext(0, RoundingMode.UNNECESSARY), BigDecimal.TWO },\n+                \/\/ mc.roundingMode != RoundingMode.UNNECESSARY && sqrtRem[1].signum == 0 && n > 0\n+                \/\/ && mc.precision == 0\n+                { four, 2, arbitrary, BigDecimal.TWO },\n+                \/\/ sqrtRem[1].signum == 0 && n > 0\n@@ -236,1 +295,6 @@\n-                { four, unnecessary, BigDecimal.TWO },\n+                { four, 2, unnecessary, BigDecimal.TWO },\n+                \/\/ mc.roundingMode == RoundingMode.UNNECESSARY && sqrtRem[1].signum == 0 && n < 0\n+                { four, -2, unnecessary, oneHalf },\n+                \/\/ mc.roundingMode != RoundingMode.UNNECESSARY && sqrtRem[1].signum == 0 && n < 0\n+                \/\/ && mc.precision == 0\n+                { four, -2, arbitrary, oneHalf },\n@@ -240,2 +304,2 @@\n-            BigDecimal expected = (BigDecimal) testCase[2];\n-            BigDecimal result = ((BigDecimal) testCase[0]).sqrt((MathContext) testCase[1]);\n+            BigDecimal expected = (BigDecimal) testCase[3];\n+            BigDecimal result = ((BigDecimal) testCase[0]).rootn((int) testCase[1], (MathContext) testCase[2]);\n@@ -297,1 +361,1 @@\n-    private static int squareRootTwoTests() {\n+    private static int rootTwoTests() {\n@@ -301,1 +365,1 @@\n-        BigDecimal highPrecisionRoot2 =\n+        BigDecimal highPrecisionSqrt2 =\n@@ -303,0 +367,3 @@\n+        \/\/ Cube root of 2 truncated to 65 digits\n+        BigDecimal highPrecisionCbrt2 =\n+            new BigDecimal(\"1.25992104989487316476721060727822835057025146470150798008197511215\");\n@@ -304,5 +371,1 @@\n-        RoundingMode[] modes = {\n-            RoundingMode.UP,       RoundingMode.DOWN,\n-            RoundingMode.CEILING, RoundingMode.FLOOR,\n-            RoundingMode.HALF_UP, RoundingMode.HALF_DOWN, RoundingMode.HALF_EVEN\n-        };\n+        List<RoundingMode> modes = roundingModes();\n@@ -313,2 +376,3 @@\n-        \/\/ highPrecisionRoot2.round(mc) and the alternative internal high-precision\n-        \/\/ implementation of square root.\n+        \/\/ highPrecisionSqrt2.round(mc) and the alternative internal high-precision\n+        \/\/ implementation of square root, and compare TWO.rootn(3, mc) to\n+        \/\/ highPrecisionCbrt2.round(mc).\n@@ -318,3 +382,9 @@\n-                BigDecimal expected = highPrecisionRoot2.round(mc);\n-                BigDecimal computed = TWO.sqrt(mc);\n-                BigDecimal altComputed = BigSquareRoot.sqrt(TWO, mc);\n+                BigDecimal expectedSqrt = highPrecisionSqrt2.round(mc);\n+                BigDecimal computedSqrt = TWO.sqrt(mc);\n+                BigDecimal altComputedSqrt = BigSquareRoot.sqrt(TWO, mc);\n+\n+                failures += equalNumerically(expectedSqrt, computedSqrt, \"sqrt(2)\");\n+                failures += equalNumerically(computedSqrt, altComputedSqrt, \"computed & altComputed\");\n+\n+                BigDecimal expectedCbrt = highPrecisionCbrt2.round(mc);\n+                BigDecimal computedCbrt = TWO.rootn(3, mc);\n@@ -322,2 +392,1 @@\n-                failures += equalNumerically(expected, computed, \"sqrt(2)\");\n-                failures += equalNumerically(computed, altComputed, \"computed & altComputed\");\n+                failures += equalNumerically(expectedCbrt, computedCbrt, \"rootn(2, 3)\");\n@@ -330,1 +399,1 @@\n-    private static int lowPrecisionPerfectSquares() {\n+    private static int lowPrecisionPerfectPowers() {\n@@ -333,32 +402,22 @@\n-        \/\/ For 5^2 through 9^2, if the input is rounded to one digit\n-        \/\/ first before the root is computed, the wrong answer will\n-        \/\/ result. Verify results and scale for different rounding\n-        \/\/ modes and precisions.\n-        long[][] squaresWithOneDigitRoot = {{ 4, 2},\n-                                            { 9, 3},\n-                                            {25, 5},\n-                                            {36, 6},\n-                                            {49, 7},\n-                                            {64, 8},\n-                                            {81, 9}};\n-\n-        for (long[] squareAndRoot : squaresWithOneDigitRoot) {\n-            BigDecimal square     = new BigDecimal(squareAndRoot[0]);\n-            BigDecimal expected   = new BigDecimal(squareAndRoot[1]);\n-\n-            for (int scale = 0; scale <= 4; scale++) {\n-                BigDecimal scaledSquare = square.setScale(scale, RoundingMode.UNNECESSARY);\n-                int expectedScale = Math.ceilDiv(scale, 2);\n-                for (int precision = 0; precision <= 5; precision++) {\n-                    for (RoundingMode rm : RoundingMode.values()) {\n-                        MathContext mc = new MathContext(precision, rm);\n-                        BigDecimal computedRoot = scaledSquare.sqrt(mc);\n-                        failures += equalNumerically(expected, computedRoot, \"simple squares\");\n-                        int computedScale = computedRoot.scale();\n-                        if (precision >=  expectedScale + 1 &&\n-                            computedScale != expectedScale) {\n-                            System.err.printf(\"%s\\tprecision=%d\\trm=%s%n\",\n-                                              computedRoot.toString(), precision, rm);\n-                            failures++;\n-                            System.err.printf(\"\\t%s does not have expected scale of %d%n.\",\n-                                              computedRoot, expectedScale);\n+        for (int i = -9; i <= 9; i++) {\n+            for (int n = 1; n < 10; n++) {\n+                BigDecimal expected = BigDecimal.valueOf(n % 2 != 0 ? i : Math.abs(i));\n+                BigDecimal pow = BigDecimal.valueOf(Math.powExact(i, n));\n+\n+                for (int scale = 0; scale <= 4; scale++) {\n+                    BigDecimal scaledPow = pow.setScale(scale);\n+                    int expectedScale = Math.ceilDiv(scale, n);\n+                    for (int precision = 0; precision <= 5; precision++) {\n+                        for (RoundingMode rm : RoundingMode.values()) {\n+                            MathContext mc = new MathContext(precision, rm);\n+                            BigDecimal computedRoot = scaledPow.rootn(n, mc);\n+                            failures += equalNumerically(expected, computedRoot, \"simple powers\");\n+                            int computedScale = computedRoot.scale();\n+                            if (precision >=  expectedScale + 1 &&\n+                                computedScale != expectedScale) {\n+                                System.err.printf(\"%s\\tprecision=%d\\trm=%s%n\",\n+                                                  computedRoot.toString(), precision, rm);\n+                                failures++;\n+                                System.err.printf(\"\\t%s does not have expected scale of %d%n.\",\n+                                                  computedRoot, expectedScale);\n+                            }\n@@ -375,1 +434,1 @@\n-     * Test around 3.9999 that the sqrt doesn't improperly round-up to\n+     * Test around 2^n-0.000...1 that the root doesn't improperly round-up to\n@@ -383,1 +442,0 @@\n-\n@@ -389,1 +447,12 @@\n-            failures += (result.compareTo(TWO) < 0) ? 0  : 1 ;\n+            failures += (result.compareTo(TWO) < 0) ? 0 : 1;\n+        }\n+\n+        BigDecimal ulp = nearFour.ulp();\n+        for (int n = 1; n < 10; n++) {\n+            BigDecimal near2ToN = BigDecimal.valueOf(Math.powExact(2, n)).subtract(ulp);\n+            \/\/ Root is 1.9999...\n+            for (int i = 1; i < 64; i++) {\n+                MathContext mc = new MathContext(i, RoundingMode.FLOOR);\n+                BigDecimal result = near2ToN.rootn(n, mc);\n+                failures += (result.compareTo(TWO) < 0) ? 0 : 1;\n+            }\n@@ -396,1 +465,1 @@\n-     * Test around 4.000...1 that the sqrt doesn't improperly\n+     * Test around 2^n+0.000...1 that the root doesn't improperly\n@@ -404,1 +473,0 @@\n-\n@@ -410,1 +478,12 @@\n-            failures += (result.compareTo(TWO) > 0) ? 0  : 1 ;\n+            failures += (result.compareTo(TWO) > 0) ? 0 : 1;\n+        }\n+\n+        BigDecimal ulp = nearFour.ulp();\n+        for (int n = 1; n < 10; n++) {\n+            BigDecimal near2ToN = BigDecimal.valueOf(Math.powExact(2, n)).add(ulp);\n+            \/\/ Root is 2.0000....<non-zero digits>\n+            for (int i = 1; i < 64; i++) {\n+                MathContext mc = new MathContext(i, RoundingMode.CEILING);\n+                BigDecimal result = near2ToN.rootn(n, mc);\n+                failures += (result.compareTo(TWO) > 0) ? 0 : 1;\n+            }\n@@ -419,1 +498,1 @@\n-         BigDecimal near10 = new BigDecimal(\"9.99999999999999999999\");\n+        BigDecimal near10 = new BigDecimal(\"9.99999999999999999999\");\n@@ -421,1 +500,1 @@\n-         BigDecimal near10sq = near10.multiply(near10);\n+        BigDecimal near10sq = near10.multiply(near10);\n@@ -423,1 +502,1 @@\n-         BigDecimal near10sq_ulp = near10sq.add(near10sq.ulp());\n+        BigDecimal near10sq_ulp = near10sq.add(near10sq.ulp());\n@@ -499,0 +578,21 @@\n+        for (int n = 1; n < 10; n++) {\n+            for (BigDecimal halfWayCase : halfWayCases) {\n+                \/\/ Round result to next-to-last place\n+                int precision = halfWayCase.precision() - 1;\n+                BigDecimal pow = halfWayCase.pow(n);\n+\n+                for (RoundingMode rm : List.of(RoundingMode.HALF_EVEN,\n+                                               RoundingMode.HALF_UP,\n+                                               RoundingMode.HALF_DOWN)) {\n+                    MathContext mc = new MathContext(precision, rm);\n+\n+                    System.out.println(\"\\nRounding mode \" + rm);\n+                    System.out.println(\"\\t\" + halfWayCase.round(mc) + \"\\t\" + halfWayCase);\n+\n+                    failures += equalNumerically(pow.rootn(n, mc),\n+                                                 halfWayCase.round(mc),\n+                                                 \"Rounding halway \" + rm);\n+                }\n+            }\n+        }\n+\n","filename":"test\/jdk\/java\/math\/BigDecimal\/SquareRootTests.java","additions":223,"deletions":123,"binary":false,"changes":346,"status":"modified"}]}