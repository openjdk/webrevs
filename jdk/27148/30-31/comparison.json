{"files":[{"patch":"@@ -2461,7 +2461,0 @@\n-        BigDecimal divisor = null;\n-        if (n < 0) {\n-            divisor = rad;\n-            int inverseScale = checkScale((result.scale + (resAbs.isPowerOfTen() ? 1L : 0L)) * nAbs);\n-            rad = ONE.divide(divisor, inverseScale, RoundingMode.DOWN);\n-        }\n-\n@@ -2479,1 +2472,0 @@\n-            int neighborUpToN_comp_rad = neighborUp.pow(nAbs).compareTo(rad);\n@@ -2481,5 +2473,4 @@\n-                resAbs.pow(nAbs).compareTo(rad) <= 0 &&\n-               (neighborUpToN_comp_rad           > 0 ||\n-                neighborUpToN_comp_rad          == 0 && n < 0 &&\n-                \/\/ Inverse radicand must not be exact\n-                rad.multiply(divisor).compareTo(ONE) != 0)\n+            (n > 0 ? resAbs.pow(nAbs).compareTo(rad)    <= 0 &&\n+                     neighborUp.pow(nAbs).compareTo(rad) > 0\n+                   : resAbs.pow(nAbs).multiply(rad).compareTo(ONE)    <= 0 &&\n+                     neighborUp.pow(nAbs).multiply(rad).compareTo(ONE) > 0)\n@@ -2491,1 +2482,0 @@\n-            int neighborDownToN_comp_rad = neighborDown.pow(nAbs).compareTo(rad);\n@@ -2493,5 +2483,4 @@\n-                 resAbs.pow(nAbs).compareTo(rad) >= 0 &&\n-                (neighborDownToN_comp_rad         < 0 ||\n-                 neighborDownToN_comp_rad == 0 && n < 0 &&\n-                 \/\/ Inverse radicand must not be exact\n-                 rad.multiply(divisor).compareTo(ONE) != 0)\n+            (n > 0 ? resAbs.pow(nAbs).compareTo(rad)      >= 0 &&\n+                     neighborDown.pow(nAbs).compareTo(rad) < 0\n+                   : resAbs.pow(nAbs).multiply(rad).compareTo(ONE)      >= 0 &&\n+                     neighborDown.pow(nAbs).multiply(rad).compareTo(ONE) < 0)\n@@ -2505,5 +2494,10 @@\n-            BigDecimal err = resAbs.pow(nAbs).subtract(rad).abs();\n-            BigDecimal errUp = neighborUp.pow(nAbs).subtract(rad);\n-            BigDecimal errDown = rad.subtract(neighborDown.pow(nAbs));\n-            \/\/ All error values should be positive or non-negative\n-            \/\/ so don't need to compare absolute values.\n+            BigDecimal err, errUp, errDown;\n+            if (n > 0) {\n+                err = resAbs.pow(nAbs).subtract(rad).abs();\n+                errUp = neighborUp.pow(nAbs).subtract(rad);\n+                errDown = rad.subtract(neighborDown.pow(nAbs));\n+            } else {\n+                err = resAbs.pow(nAbs).multiply(rad).subtract(ONE).abs();\n+                errUp = neighborUp.pow(nAbs).multiply(rad).subtract(ONE);\n+                errDown = ONE.subtract(neighborDown.pow(nAbs).multiply(rad));\n+            }\n@@ -2511,0 +2505,2 @@\n+            \/\/ All error values should be positive\n+            \/\/ so don't need to compare absolute values.\n@@ -2516,4 +2512,1 @@\n-                (errDown.signum() == 1 ||\n-                 errDown.signum() == 0 && n < 0 &&\n-                 \/\/ Inverse radicand must not be exact\n-                 rad.multiply(divisor).compareTo(ONE) != 0)\n+                 errDown.signum() == 1\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":21,"deletions":28,"binary":false,"changes":49,"status":"modified"}]}