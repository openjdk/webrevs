{"files":[{"patch":"@@ -158,0 +158,1 @@\n+ * <tr><th scope=\"row\">n<sup>th<\/sup> root<\/th><td>ceil((double) radicand.scale()\/n)<\/td>\n@@ -2146,0 +2147,46 @@\n+        return rootn(2, mc);\n+    }\n+\n+    \/**\n+     * Returns an approximation to the {@code n}<sup>th<\/sup> root of {@code this}\n+     * with rounding according to the context settings.\n+     *\n+     * <p>The preferred scale of the returned result is equal to\n+     * {@code Math.ceilDiv(this.scale(), n)}. The value of the returned result is\n+     * always within one ulp of the exact decimal value for the\n+     * precision in question.  If the rounding mode is {@link\n+     * RoundingMode#HALF_UP HALF_UP}, {@link RoundingMode#HALF_DOWN\n+     * HALF_DOWN}, or {@link RoundingMode#HALF_EVEN HALF_EVEN}, the\n+     * result is within one half an ulp of the exact decimal value.\n+     *\n+     * <p>Special case:\n+     * <ul>\n+     * <li> The {@code n}<sup>th<\/sup> root of a number numerically equal to {@code\n+     * ZERO} is numerically equal to {@code ZERO} with a preferred\n+     * scale according to the general rule above. In particular, for\n+     * {@code ZERO}, {@code ZERO.rootn(n, mc).equals(ZERO)} is true with\n+     * any {@code MathContext} as an argument.\n+     * <\/ul>\n+     *\n+     * @param n the root degree\n+     * @param mc the context to use.\n+     * @return the {@code n}<sup>th<\/sup> root of {@code this}.\n+     * @throws ArithmeticException if {@code n == 0 || n == Integer.MIN_VALUE}.\n+     * @throws ArithmeticException if {@code n} is even and {@code this} is negative.\n+     * @throws ArithmeticException if {@code n} is negative and {@code this} is zero.\n+     * @throws ArithmeticException if an exact result is requested\n+     * ({@code mc.getPrecision() == 0}) and there is no finite decimal\n+     * expansion of the exact result\n+     * @throws ArithmeticException if\n+     * {@code (mc.getRoundingMode() == RoundingMode.UNNECESSARY}) and\n+     * the exact result cannot fit in {@code mc.getPrecision()} digits.\n+     * @see #sqrt(MathContext)\n+     * @see BigInteger#rootn(int)\n+     * @since 26\n+     * @apiNote Note that calling {@code rootn(2, mc)} is equivalent to calling {@code sqrt(mc)}.\n+     *\/\n+    public BigDecimal rootn(int n, MathContext mc) {\n+        \/\/ Special cases\n+        if (n == 0)\n+            throw new ArithmeticException(\"Zero root degree\");\n+\n@@ -2147,10 +2194,9 @@\n-        if (signum != 1) {\n-            switch (signum) {\n-            case -1 -> throw new ArithmeticException(\"Attempted square root of negative BigDecimal\");\n-            case 0 -> {\n-                BigDecimal result = valueOf(0L, scale\/2);\n-                assert squareRootResultAssertions(result, mc);\n-                return result;\n-            }\n-            default -> throw new AssertionError(\"Bad value from signum\");\n-            }\n+        if (signum < 0 && (n & 1) == 0)\n+            throw new ArithmeticException(\"Negative radicand with even root degree\");\n+\n+        final int preferredScale = saturateLong(Math.ceilDiv((long) this.scale, n));\n+        if (signum == 0) {\n+            if (n < 0)\n+                throw new ArithmeticException(\"Zero radicand with negative root degree\");\n+\n+            return zeroValueOf(preferredScale);\n@@ -2158,0 +2204,1 @@\n+\n@@ -2161,1 +2208,1 @@\n-         * using the following relations:\n+         * using the following relations, assuming n > 0:\n@@ -2164,2 +2211,4 @@\n-         * sqrt(x) = sqrt(y) * 10^(exp \/ 2) if exp is even\n-         * sqrt(x) = sqrt(y*10) * 10^((exp-1)\/2) is exp is odd\n+         * rootn(x, n) = rootn(y, n) * 10^(exp \/ n) if exp mod n == 0\n+         * rootn(x, n) = rootn(y*10^(exp mod n), n) * 10^((exp - (exp mod n))\/n) otherwise\n+         *\n+         * where exp mod n == Math.floorMod(exp, n).\n@@ -2167,1 +2216,1 @@\n-         * Then use BigInteger.sqrt() on the reduced value to compute\n+         * Then use BigInteger.rootn() on the reduced value to compute\n@@ -2174,5 +2223,1 @@\n-\n-        \/\/ The code below favors relative simplicity over checking\n-        \/\/ for special cases that could run faster.\n-        final int preferredScale = Math.ceilDiv(this.scale, 2);\n-\n+        final int nAbs = Math.absExact(n);\n@@ -2183,4 +2228,0 @@\n-            final int strippedScale = stripped.scale;\n-\n-            if ((strippedScale & 1) != 0) \/\/ 10*stripped.unscaledValue() can't be an exact square\n-                throw new ArithmeticException(\"Computed square root not exact.\");\n@@ -2188,7 +2229,4 @@\n-            \/\/ Check for even powers of 10. Numerically sqrt(10^2N) = 10^N\n-            if (stripped.isPowerOfTen()) {\n-                result = valueOf(1L, strippedScale >> 1);\n-                \/\/ Adjust to requested precision and preferred\n-                \/\/ scale as appropriate.\n-                return result.adjustToPreferredScale(preferredScale, mc.precision);\n-            }\n+            \/\/ if stripped.scale is not a multiple of n,\n+            \/\/ 10^((-stripped.scale) mod n)*stripped.unscaledValue() can't be an exact power\n+            if (stripped.scale % n != 0)\n+                throw new ArithmeticException(\"Computed root not exact.\");\n@@ -2201,14 +2239,23 @@\n-            \/\/ precision for the cohort of the numerical value and the scale is even.\n-            BigInteger[] sqrtRem = stripped.unscaledValue().sqrtAndRemainder();\n-            result = new BigDecimal(sqrtRem[0], strippedScale >> 1);\n-\n-            \/\/ If result*result != this numerically or requires too high precision,\n-            \/\/ the square root isn't exact\n-            if (sqrtRem[1].signum != 0 || mc.precision != 0 && result.precision() > mc.precision)\n-                throw new ArithmeticException(\"Computed square root not exact.\");\n-\n-            \/\/ Test numerical properties at full precision before any\n-            \/\/ scale adjustments.\n-            assert squareRootResultAssertions(result, mc);\n-            \/\/ Adjust to requested precision and preferred\n-            \/\/ scale as appropriate.\n+            \/\/ precision for the cohort of the numerical value and the scale is a multiple of n.\n+            BigInteger[] rootRem = stripped.unscaledValue().rootnAndRemainder(nAbs);\n+            result = new BigDecimal(rootRem[0], stripped.scale \/ nAbs);\n+            \/\/ If result^nAbs != this numerically, the root isn't exact\n+            if (rootRem[1].signum != 0)\n+                throw new ArithmeticException(\"Computed root not exact.\");\n+\n+            if (n > 0) {\n+                \/\/ If result requires too high precision, the root isn't exact\n+                if (mc.precision != 0 && result.precision() > mc.precision)\n+                    throw new ArithmeticException(\"Computed root not exact.\");\n+            } else {\n+                try {\n+                    result = ONE.divide(result, mc);\n+                } catch (ArithmeticException e) {\n+                    \/\/ The exact result requires too high precision,\n+                    \/\/ including non-terminating decimal expansions\n+                    throw new ArithmeticException(\"Computed root not exact.\");\n+                }\n+            }\n+            \/\/ Test numerical properties at full precision before any scale adjustments.\n+            assert rootnResultAssertions(result, mc, n);\n+            \/\/ Adjust to requested precision and preferred scale as appropriate.\n@@ -2217,3 +2264,15 @@\n-        \/\/ To allow BigInteger.sqrt() to be used to get the square\n-        \/\/ root, it is necessary to normalize the input so that\n-        \/\/ its integer part is sufficient to get the square root\n+\n+        \/\/ Handle negative radicands\n+        BigDecimal x = this;\n+        if (signum < 0) {\n+            x = x.negate();\n+            if (mc.roundingMode == RoundingMode.FLOOR) {\n+                mc = new MathContext(mc.precision, RoundingMode.UP);\n+            } else if (mc.roundingMode == RoundingMode.CEILING) {\n+                mc = new MathContext(mc.precision, RoundingMode.DOWN);\n+            }\n+        }\n+\n+        \/\/ To allow BigInteger.rootn() to be used to get the root,\n+        \/\/ it is necessary to normalize the input so that\n+        \/\/ its integer part is sufficient to get the root\n@@ -2223,3 +2282,5 @@\n-        \/\/ To obtain a square root with N digits,\n-        \/\/ the radicand must have at least 2*(N-1)+1 == 2*N-1 digits.\n-        final long minWorkingPrec = ((mc.precision + (halfWay ? 1L : 0L)) << 1) - 1L;\n+        \/\/ If n < 0, add a digit to speed up correct rounding\n+        final long rootDigits = mc.precision + (halfWay ? 1L : 0L) + (n < 0 ? 1L : 0L);\n+        \/\/ To obtain an n-th root with k digits,\n+        \/\/ the radicand must have at least n*(k-1)+1 digits.\n+        final long minWorkingPrec = nAbs * (rootDigits - 1L) + 1L;\n@@ -2227,2 +2288,4 @@\n-        long normScale = minWorkingPrec - this.precision() + this.scale;\n-        normScale += normScale & 1L; \/\/ the scale for normalizing must be even\n+        long normScale = minWorkingPrec - x.precision() + x.scale;\n+        int mod = Math.floorMod(normScale, nAbs);\n+        if (mod != 0) \/\/ the scale for normalizing must be a multiple of nAbs\n+            normScale += nAbs - mod;\n@@ -2230,5 +2293,1 @@\n-        final long workingScale = this.scale - normScale;\n-        if (workingScale != (int) workingScale)\n-            throw new ArithmeticException(\"Overflow\");\n-\n-        BigDecimal working = new BigDecimal(this.intVal, this.intCompact, (int) workingScale, this.precision);\n+        BigDecimal working = new BigDecimal(x.intVal, x.intCompact, checkScaleNonZero(x.scale - normScale), x.precision);\n@@ -2237,10 +2296,5 @@\n-        BigInteger sqrt;\n-        long resultScale = normScale >> 1;\n-        \/\/ Round sqrt with the specified settings\n-        if (halfWay) { \/\/ half-way rounding\n-            BigInteger workingSqrt = workingInt.sqrt();\n-            \/\/ remove the one-tenth digit\n-            BigInteger[] quotRem10 = workingSqrt.divideAndRemainder(BigInteger.TEN);\n-            sqrt = quotRem10[0];\n-            resultScale--;\n-\n+        \/\/ Compute and round the root\n+        BigInteger root;\n+        long resultScale = normScale \/ nAbs;\n+        if (n > 0) {\n+            \/\/ Round the root with the specified settings\n@@ -2248,9 +2302,9 @@\n-            int digit = quotRem10[1].intValue();\n-            if (digit > 5) {\n-                increment = true;\n-            } else if (digit == 5) {\n-                if (mc.roundingMode == RoundingMode.HALF_UP\n-                        || mc.roundingMode == RoundingMode.HALF_EVEN && sqrt.testBit(0)\n-                        \/\/ Check if remainder is non-zero\n-                        || !workingInt.equals(workingSqrt.multiply(workingSqrt))\n-                        || !working.isInteger()) {\n+            if (halfWay) { \/\/ half-way rounding\n+                BigInteger[] rootRem = workingInt.rootnAndRemainder(nAbs);\n+                \/\/ remove the one-tenth digit\n+                BigInteger[] quotRem10 = rootRem[0].divideAndRemainder(BigInteger.TEN);\n+                root = quotRem10[0];\n+                resultScale--;\n+\n+                int digit = quotRem10[1].intValue();\n+                if (digit > 5) {\n@@ -2258,0 +2312,21 @@\n+                } else if (digit == 5) {\n+                    if (mc.roundingMode == RoundingMode.HALF_UP\n+                            || mc.roundingMode == RoundingMode.HALF_EVEN && root.testBit(0)\n+                            \/\/ Check if remainder is non-zero\n+                            || rootRem[1].signum != 0 || !working.isInteger()) {\n+                        increment = true;\n+                    }\n+                }\n+            } else {\n+                switch (mc.roundingMode) {\n+                case DOWN, FLOOR -> root = workingInt.rootn(nAbs); \/\/ No need to round\n+\n+                case UP, CEILING -> {\n+                    BigInteger[] rootRem = workingInt.rootnAndRemainder(nAbs);\n+                    root = rootRem[0];\n+                    \/\/ Check if remainder is non-zero\n+                    if (rootRem[1].signum != 0 || !working.isInteger())\n+                        increment = true;\n+                }\n+\n+                default -> throw new AssertionError(\"Unexpected value for RoundingMode: \" + mc.roundingMode);\n@@ -2260,0 +2335,3 @@\n+            if (increment) {\n+                root = root.add(1L);\n+            }\n@@ -2261,12 +2339,22 @@\n-            if (increment)\n-                sqrt = sqrt.add(1L);\n-        } else {\n-            switch (mc.roundingMode) {\n-            case DOWN, FLOOR -> sqrt = workingInt.sqrt(); \/\/ No need to round\n-\n-            case UP, CEILING -> {\n-                BigInteger[] sqrtRem = workingInt.sqrtAndRemainder();\n-                sqrt = sqrtRem[0];\n-                \/\/ Check if remainder is non-zero\n-                if (sqrtRem[1].signum != 0 || !working.isInteger())\n-                    sqrt = sqrt.add(1L);\n+            result = new BigDecimal(root, checkScale(root, resultScale), mc); \/\/ mc ensures no increase of precision\n+        } else { \/\/ Handle negative degrees\n+            root = workingInt.rootn(nAbs);\n+            final BigDecimal scaledRoot = new BigDecimal(root, checkScaleNonZero(resultScale));\n+            final long resPrec = mc.precision + (halfWay ? 1L : 0L);\n+            final int fracZeros = (int) rootDigits - 1 - (scaledRoot.isPowerOfTen() ? 1 : 0);\n+            \/\/ Ensure result's precision is exactly resPrec\n+            result = ONE.divide(scaledRoot, checkScaleNonZero(fracZeros - resultScale + resPrec), RoundingMode.DOWN);\n+\n+            BigDecimal inverse = ONE.divide(x, checkScaleNonZero((long) result.scale * nAbs), RoundingMode.DOWN);\n+            \/\/ (1\/(root*10^(-normScale \/ nAbs)))^nAbs >= 1\/x, and since result is rounded down,\n+            \/\/ either result^nAbs > inverse, or else all result's digits are correct\n+\n+            int cmp;\n+            BigDecimal ulp = result.ulp();\n+            while ((cmp = result.pow(nAbs).compareMagnitude(inverse)) > 0) {\n+                \/\/ if result's scale will increase, increase also inverse's scale\n+                if (result.isPowerOfTen()) {\n+                    ulp = ulp.scaleByPowerOfTen(-1);\n+                    inverse = ONE.divide(x, checkScaleNonZero((long) ulp.scale * nAbs), RoundingMode.DOWN);\n+                }\n+                result = result.subtract(ulp);\n@@ -2275,1 +2363,32 @@\n-            default -> throw new AssertionError(\"Unexpected value for RoundingMode: \" + mc.roundingMode);\n+            boolean increment = false;\n+            if (halfWay) {\n+                \/\/ remove the one-tenth digit from result\n+                BigInteger[] quotRem10 = result.unscaledValue().divideAndRemainder(BigInteger.TEN);\n+                result = new BigDecimal(quotRem10[0], checkScaleNonZero(result.scale - 1L));\n+\n+                int digit = quotRem10[1].intValue();\n+                if (digit > 5) {\n+                    increment = true;\n+                } else if (digit == 5) {\n+                    if (mc.roundingMode == RoundingMode.HALF_UP\n+                            || mc.roundingMode == RoundingMode.HALF_EVEN && quotRem10[0].testBit(0)\n+                            \/\/ Check if remainder is non-zero\n+                            || cmp != 0 || ONE.compareMagnitude(inverse.multiply(x)) != 0) {\n+                        increment = true;\n+                    }\n+                }\n+            } else {\n+                switch (mc.roundingMode) {\n+                case DOWN, FLOOR -> {} \/\/ result is already rounded down\n+\n+                case UP, CEILING -> {\n+                    \/\/ Check if remainder is non-zero\n+                    if (cmp != 0 || ONE.compareMagnitude(inverse.multiply(x)) != 0)\n+                        increment = true;\n+                }\n+\n+                default -> throw new AssertionError(\"Unexpected value for RoundingMode: \" + mc.roundingMode);\n+                }\n+            }\n+            if (increment) {\n+                result = result.add(result.ulp(), mc); \/\/ mc ensures no increase of precision\n@@ -2278,8 +2397,4 @@\n-\n-        result = new BigDecimal(sqrt, checkScale(sqrt, resultScale), mc); \/\/ mc ensures no increase of precision\n-        \/\/ Test numerical properties at full precision before any\n-        \/\/ scale adjustments.\n-        assert squareRootResultAssertions(result, mc);\n-        \/\/ Adjust to requested precision and preferred\n-        \/\/ scale as appropriate.\n-        if (result.scale > preferredScale) \/\/ else can't increase the result's precision to fit the preferred scale\n+        \/\/ Test numerical properties at full precision before any scale adjustments.\n+        assert rootnResultAssertions(result, mc, n);\n+        \/\/ Adjust to requested precision and preferred scale as appropriate.\n+        if (result.scale > preferredScale) \/\/ else can't increase result's precision to fit the preferred scale\n@@ -2288,1 +2403,1 @@\n-        return result;\n+        return signum > 0 ? result : result.negate();\n@@ -2319,4 +2434,0 @@\n-    private BigDecimal square() {\n-        return this.multiply(this);\n-    }\n-\n@@ -2324,1 +2435,1 @@\n-        return BigInteger.ONE.equals(this.unscaledValue());\n+        return this.stripTrailingZeros().unscaledValue().equals(BigInteger.ONE);\n@@ -2335,2 +2446,3 @@\n-     * <li> For DOWN and FLOOR, result^2 must be {@code <=} the input\n-     * and (result+ulp)^2 must be {@code >} the input.\n+     * <li> For DOWN and FLOOR if input > 0 and CEIL if input < 0,\n+     * |result|^n must be {@code <=} |input|\n+     * and (|result|+ulp)^n must be {@code >} |input|.\n@@ -2338,2 +2450,3 @@\n-     * <li>Conversely, for UP and CEIL, result^2 must be {@code >=}\n-     * the input and (result-ulp)^2 must be {@code <} the input.\n+     * <li>Conversely, for UP and FLOOR if input < 0 and CEIL if input > 0,\n+     * |result|^n must be {@code >=} |input|\n+     * and (|result|-ulp)^n must be {@code <} |input|.\n@@ -2342,73 +2455,8 @@\n-    private boolean squareRootResultAssertions(BigDecimal result, MathContext mc) {\n-        if (result.signum() == 0) {\n-            return squareRootZeroResultAssertions(result, mc);\n-        } else {\n-            RoundingMode rm = mc.getRoundingMode();\n-            BigDecimal ulp = result.ulp();\n-            BigDecimal neighborUp   = result.add(ulp);\n-            \/\/ Make neighbor down accurate even for powers of ten\n-            if (result.isPowerOfTen()) {\n-                ulp = ulp.divide(TEN);\n-            }\n-            BigDecimal neighborDown = result.subtract(ulp);\n-\n-            \/\/ Both the starting value and result should be nonzero and positive.\n-            assert (result.signum() == 1 &&\n-                    this.signum() == 1) :\n-                \"Bad signum of this and\/or its sqrt.\";\n-\n-            switch (rm) {\n-            case DOWN:\n-            case FLOOR:\n-                assert\n-                    result.square().compareTo(this)     <= 0 &&\n-                    neighborUp.square().compareTo(this) > 0:\n-                \"Square of result out for bounds rounding \" + rm;\n-                return true;\n-\n-            case UP:\n-            case CEILING:\n-                assert\n-                    result.square().compareTo(this)       >= 0 &&\n-                    neighborDown.square().compareTo(this) < 0:\n-                \"Square of result out for bounds rounding \" + rm;\n-                return true;\n-\n-\n-            case HALF_DOWN:\n-            case HALF_EVEN:\n-            case HALF_UP:\n-                BigDecimal err = result.square().subtract(this).abs();\n-                BigDecimal errUp = neighborUp.square().subtract(this);\n-                BigDecimal errDown =  this.subtract(neighborDown.square());\n-                \/\/ All error values should be positive so don't need to\n-                \/\/ compare absolute values.\n-\n-                int err_comp_errUp = err.compareTo(errUp);\n-                int err_comp_errDown = err.compareTo(errDown);\n-\n-                assert\n-                    errUp.signum()   == 1 &&\n-                    errDown.signum() == 1 :\n-                \"Errors of neighbors squared don't have correct signs\";\n-\n-                \/\/ For breaking a half-way tie, the return value may\n-                \/\/ have a larger error than one of the neighbors. For\n-                \/\/ example, the square root of 2.25 to a precision of\n-                \/\/ 1 digit is either 1 or 2 depending on how the exact\n-                \/\/ value of 1.5 is rounded. If 2 is returned, it will\n-                \/\/ have a larger rounding error than its neighbor 1.\n-                assert\n-                    err_comp_errUp   <= 0 ||\n-                    err_comp_errDown <= 0 :\n-                \"Computed square root has larger error than neighbors for \" + rm;\n-\n-                assert\n-                    ((err_comp_errUp   == 0 ) ? err_comp_errDown < 0 : true) &&\n-                    ((err_comp_errDown == 0 ) ? err_comp_errUp   < 0 : true) :\n-                        \"Incorrect error relationships\";\n-                \/\/ && could check for digit conditions for ties too\n-                return true;\n-\n-            default: \/\/ Definition of UNNECESSARY already verified.\n-                return true;\n+    private boolean rootnResultAssertions(BigDecimal result, MathContext mc, int n) {\n+        BigDecimal rad = this.abs(), resAbs = result.abs();\n+        RoundingMode rm = mc.roundingMode;\n+        if (this.signum() < 0) {\n+            if (rm == RoundingMode.FLOOR) {\n+                rm = RoundingMode.UP;\n+            } else if (rm == RoundingMode.CEILING) {\n+                rm = RoundingMode.DOWN;\n@@ -2417,1 +2465,0 @@\n-    }\n@@ -2419,2 +2466,83 @@\n-    private boolean squareRootZeroResultAssertions(BigDecimal result, MathContext mc) {\n-        return this.compareTo(ZERO) == 0;\n+        int nAbs = Math.abs(n);\n+        BigDecimal divisor = null;\n+        if (n < 0) {\n+            divisor = rad;\n+            int inverseScale = checkScale((result.scale + (resAbs.isPowerOfTen() ? 1L : 0L)) * nAbs);\n+            rad = ONE.divide(divisor, inverseScale, RoundingMode.DOWN);\n+        }\n+\n+        BigDecimal ulp = resAbs.ulp();\n+        BigDecimal neighborUp = resAbs.add(ulp);\n+        \/\/ Make neighbor down accurate even for powers of ten\n+        if (resAbs.isPowerOfTen()) {\n+            ulp = ulp.scaleByPowerOfTen(-1);\n+        }\n+        BigDecimal neighborDown = resAbs.subtract(ulp);\n+\n+        switch (rm) {\n+        case DOWN:\n+        case FLOOR:\n+            int neighborUpToN_comp_rad = neighborUp.pow(nAbs).compareTo(rad);\n+            assert\n+                resAbs.pow(nAbs).compareTo(rad) <= 0 &&\n+               (neighborUpToN_comp_rad           > 0 ||\n+                neighborUpToN_comp_rad          == 0 && n < 0 &&\n+                \/\/ Inverse radicand must not be exact\n+                rad.multiply(divisor).compareTo(ONE) != 0)\n+                : \"Power of result out for bounds rounding \" + rm;\n+            return true;\n+\n+        case UP:\n+        case CEILING:\n+            int neighborDownToN_comp_rad = neighborDown.pow(nAbs).compareTo(rad);\n+            assert\n+                 resAbs.pow(nAbs).compareTo(rad) >= 0 &&\n+                (neighborDownToN_comp_rad         < 0 ||\n+                 neighborDownToN_comp_rad == 0 && n < 0 &&\n+                 \/\/ Inverse radicand must not be exact\n+                 rad.multiply(divisor).compareTo(ONE) != 0)\n+                : \"Power of result out for bounds rounding \" + rm;\n+            return true;\n+\n+\n+        case HALF_DOWN:\n+        case HALF_EVEN:\n+        case HALF_UP:\n+            BigDecimal err = resAbs.pow(nAbs).subtract(rad).abs();\n+            BigDecimal errUp = neighborUp.pow(nAbs).subtract(rad);\n+            BigDecimal errDown = rad.subtract(neighborDown.pow(nAbs));\n+            \/\/ All error values should be positive or non-negative\n+            \/\/ so don't need to compare absolute values.\n+\n+            int err_comp_errUp = err.compareTo(errUp);\n+            int err_comp_errDown = err.compareTo(errDown);\n+\n+            assert\n+                 errUp.signum()   == 1 &&\n+                (errDown.signum() == 1 ||\n+                 errDown.signum() == 0 && n < 0 &&\n+                 \/\/ Inverse radicand must not be exact\n+                 rad.multiply(divisor).compareTo(ONE) != 0)\n+            : \"Errors of neighbors powered don't have correct signs\";\n+\n+            \/\/ For breaking a half-way tie, the return value may\n+            \/\/ have a larger error than one of the neighbors. For\n+            \/\/ example, the square root of 2.25 to a precision of\n+            \/\/ 1 digit is either 1 or 2 depending on how the exact\n+            \/\/ value of 1.5 is rounded. If 2 is returned, it will\n+            \/\/ have a larger rounding error than its neighbor 1.\n+            assert\n+                err_comp_errUp   <= 0 ||\n+                err_comp_errDown <= 0 :\n+            \"Computed root has larger error than neighbors for \" + rm;\n+\n+            assert\n+                ((err_comp_errUp   == 0 ) ? err_comp_errDown < 0 : true) &&\n+                ((err_comp_errDown == 0 ) ? err_comp_errUp   < 0 : true) :\n+                    \"Incorrect error relationships\";\n+            \/\/ && could check for digit conditions for ties too\n+            return true;\n+\n+        default: \/\/ Definition of UNNECESSARY already verified.\n+            return true;\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":311,"deletions":183,"binary":false,"changes":494,"status":"modified"},{"patch":"@@ -34,1 +34,2 @@\n-import java.util.List;\n+import java.util.*;\n+import java.util.stream.IntStream;\n@@ -51,1 +52,2 @@\n-        failures += negativeTests();\n+        failures += zerothRootTests();\n+        failures += negativeWithEvenDegreeTests();\n@@ -56,2 +58,2 @@\n-        failures += squareRootTwoTests();\n-        failures += lowPrecisionPerfectSquares();\n+        failures += rootTwoTests();\n+        failures += lowPrecisionPerfectPowers();\n@@ -72,1 +74,1 @@\n-    private static int negativeTests() {\n+    private static int zerothRootTests() {\n@@ -75,1 +77,1 @@\n-        for (long i = -10; i < 0; i++) {\n+        for (long i = -5; i < 5; i++) {\n@@ -79,3 +81,3 @@\n-                    BigDecimal result = input.sqrt(MathContext.DECIMAL64);\n-                    System.err.println(\"Unexpected sqrt of negative: (\" +\n-                                       input + \").sqrt()  = \" + result );\n+                    BigDecimal result = input.rootn(0, MathContext.DECIMAL64);\n+                    System.err.println(\"Unexpected 0th root: (\" +\n+                                       input + \").rootn(0)  = \" + result );\n@@ -92,0 +94,22 @@\n+    private static int negativeWithEvenDegreeTests() {\n+        int failures = 0;\n+\n+        for (long i = -10; i < 0; i++) {\n+            for (int j = -5; j < 5; j++) {\n+                BigDecimal input = BigDecimal.valueOf(i, j);\n+                for (int n = -4; n <= 4; n += 2) {\n+                    try {\n+                        BigDecimal result = input.sqrt(MathContext.DECIMAL64);\n+                        System.err.println(\"Unexpected nth root of negative: (\" +\n+                                           input + \").rootn(\" + n + \")  = \" + result );\n+                        failures += 1;\n+                    } catch (ArithmeticException e) {\n+                        ; \/\/ Expected\n+                    }\n+                }\n+            }\n+        }\n+\n+        return failures;\n+    }\n+\n@@ -96,4 +120,11 @@\n-            BigDecimal expected = BigDecimal.valueOf(0L, i\/2);\n-            \/\/ These results are independent of rounding mode\n-            failures += compare(BigDecimal.valueOf(0L, i).sqrt(MathContext.UNLIMITED),\n-                                expected, true, \"zeros\");\n+            BigDecimal input = BigDecimal.valueOf(0L, i);\n+            for (int n = -10; n <= 0; n++) {\n+                try {\n+                    BigDecimal result = input.rootn(n, MathContext.DECIMAL64);\n+                    System.err.println(\"Unexpected nth root of zero: (\" +\n+                                       input + \").rootn(\" + n + \")  = \" + result );\n+                    failures += 1;\n+                } catch (ArithmeticException e) {\n+                    ; \/\/ Expected\n+                }\n+            }\n@@ -101,2 +132,9 @@\n-            failures += compare(BigDecimal.valueOf(0L, i).sqrt(MathContext.DECIMAL64),\n-                                expected, true, \"zeros\");\n+            for (int n = 1; n < 10; n++) {\n+                BigDecimal expected = BigDecimal.valueOf(0L, Math.ceilDiv(i, n));\n+                \/\/ These results are independent of rounding mode\n+                failures += compare(input.rootn(n, MathContext.UNLIMITED),\n+                                    expected, true, \"zeros\");\n+\n+                failures += compare(input.rootn(n, MathContext.DECIMAL64),\n+                                    expected, true, \"zeros\");\n+            }\n@@ -108,0 +146,11 @@\n+    private static RoundingMode positiveRoundingMode(RoundingMode rm) {\n+        return rm == RoundingMode.FLOOR   ? RoundingMode.UP :\n+               rm == RoundingMode.CEILING ? RoundingMode.DOWN : rm;\n+    }\n+\n+    private static List<RoundingMode> roundingModes() {\n+        List<RoundingMode> modes = new ArrayList<>(Arrays.asList(RoundingMode.values()));\n+        modes.remove(RoundingMode.UNNECESSARY);\n+        return modes;\n+    }\n+\n@@ -109,2 +158,2 @@\n-     * Probe inputs with one digit of precision, 1 ... 9 and those\n-     * values scaled by 10^-1, 0.1, ... 0.9.\n+     * Probe inputs with one digit of precision, ±1 ... ±9 and those\n+     * values scaled by 10^-1, ±0.1 ... ±0.9.\n@@ -115,9 +164,2 @@\n-        List<BigDecimal> oneToNine =\n-            List.of(ONE,        TWO,        valueOf(3),\n-                    valueOf(4), valueOf(5), valueOf(6),\n-                    valueOf(7), valueOf(8), valueOf(9));\n-\n-        List<RoundingMode> modes =\n-            List.of(RoundingMode.UP,      RoundingMode.DOWN,\n-                    RoundingMode.CEILING, RoundingMode.FLOOR,\n-                    RoundingMode.HALF_UP, RoundingMode.HALF_DOWN, RoundingMode.HALF_EVEN);\n+        List<BigDecimal> oneToNine = IntStream.rangeClosed(1, 9).mapToObj(BigDecimal::valueOf).toList();\n+        List<RoundingMode> modes = roundingModes();\n@@ -127,0 +169,2 @@\n+                MathContext mc = new MathContext(i, rm);\n+                MathContext positiveMC = new MathContext(i, positiveRoundingMode(rm));\n@@ -128,2 +172,0 @@\n-                    MathContext mc = new MathContext(i, rm);\n-\n@@ -131,1 +173,8 @@\n-                    bd = bd.multiply(ONE_TENTH);\n+                    BigDecimal minus_bd = bd.negate();\n+                    for (int n = 1; n < 11; n += 2) {\n+                        System.err.println(minus_bd + \", \" + n + \", \" + mc);\n+                        failures += compare(minus_bd.rootn( n, mc), bd.rootn( n, positiveMC).negate(), true, \"one digit\");\n+                        failures += compare(minus_bd.rootn(-n, mc), bd.rootn(-n, positiveMC).negate(), true, \"one digit\");\n+                    }\n+\n+                    bd = bd.scaleByPowerOfTen(-1);\n@@ -133,0 +182,6 @@\n+                    minus_bd = bd.negate();\n+                    for (int n = 1; n < 11; n += 2) {\n+                        System.err.println(minus_bd + \", \" + n + \", \" + mc);\n+                        failures += compare(minus_bd.rootn( n, mc), bd.rootn( n, positiveMC).negate(), true, \"one digit\");\n+                        failures += compare(minus_bd.rootn(-n, mc), bd.rootn(-n, positiveMC).negate(), true, \"one digit\");\n+                    }\n@@ -141,3 +196,3 @@\n-     * Probe inputs with two digits of precision, (10 ... 99) and\n-     * those values scaled by 10^-1 (1, ... 9.9) and scaled by 10^-2\n-     * (0.1 ... 0.99).\n+     * Probe inputs with two digits of precision, (±10 ... ±99) and\n+     * those values scaled by 10^-1 (±1 ... ±9.9) and scaled by 10^-2\n+     * (±0.1 ... ±0.99).\n@@ -148,4 +203,1 @@\n-        List<RoundingMode> modes =\n-            List.of(RoundingMode.UP,      RoundingMode.DOWN,\n-                    RoundingMode.CEILING, RoundingMode.FLOOR,\n-                    RoundingMode.HALF_UP, RoundingMode.HALF_DOWN, RoundingMode.HALF_EVEN);\n+        List<RoundingMode> modes = roundingModes();\n@@ -155,2 +207,2 @@\n-            BigDecimal bd1 = bd0.multiply(ONE_TENTH);\n-            BigDecimal bd2 = bd1.multiply(ONE_TENTH);\n+            BigDecimal bd1 = bd0.scaleByPowerOfTen(-1);\n+            BigDecimal bd2 = bd1.scaleByPowerOfTen(-1);\n@@ -159,1 +211,1 @@\n-                for (int precision = 1; i < 20; i++) {\n+                for (int prec = 1; prec < 20; prec++) {\n@@ -161,1 +213,2 @@\n-                        MathContext mc = new MathContext(precision, rm);\n+                        MathContext mc = new MathContext(prec, rm);\n+                        MathContext positiveMC = new MathContext(prec, positiveRoundingMode(rm));\n@@ -163,0 +216,6 @@\n+\n+                        BigDecimal minus_bd = bd.negate();\n+                        for (int n = 1; n < 11; n += 2) {\n+                            failures += compare(minus_bd.rootn( n, mc), bd.rootn( n, positiveMC).negate(), true, \"two digits\");\n+                            failures += compare(minus_bd.rootn(-n, mc), bd.rootn(-n, positiveMC).negate(), true, \"two digits\");\n+                        }\n@@ -181,5 +240,7 @@\n-        BigDecimal[] errCases = {\n-                \/\/ (strippedScale & 1) != 0\n-                BigDecimal.TEN,\n-                \/\/ (strippedScale & 1) == 0 && !stripped.isPowerOfTen() && sqrtRem[1].signum != 0\n-                BigDecimal.TWO,\n+        Object[][] errCases = {\n+                \/\/ strippedScale % n != 0\n+                { BigDecimal.TEN, 2 },\n+                \/\/ strippedScale % n == 0 && sqrtRem[1].signum != 0\n+                { BigDecimal.TWO, 2 },\n+                \/\/ sqrtRem[1].signum == 0 && n < 0\n+                { BigDecimal.valueOf(9L), -2 },\n@@ -188,1 +249,3 @@\n-        for (BigDecimal input : errCases) {\n+        for (Object[] errCase : errCases) {\n+            BigDecimal input = (BigDecimal) errCase[0];\n+            int n = (int) errCase[1];\n@@ -192,2 +255,3 @@\n-                result = input.sqrt(unnecessary);\n-                System.err.println(\"Unexpected sqrt with UNNECESSARY RoundingMode: (\" + input + \").sqrt() = \" + result);\n+                result = input.rootn(n, unnecessary);\n+                System.err.println(\"Unexpected nth root with UNNECESSARY RoundingMode: (\"\n+                + input + \").rootn(\" + n + \") = \" + result);\n@@ -201,2 +265,3 @@\n-                result = input.sqrt(arbitrary);\n-                System.err.println(\"Unexpected sqrt with mc.precision == 0: (\" + input + \").sqrt() = \" + result);\n+                result = input.rootn(n, arbitrary);\n+                System.err.println(\"Unexpected nth root with mc.precision == 0: (\"\n+                + input + \").rootn(\" + n + \") = \" + result);\n@@ -209,1 +274,1 @@\n-        \/\/ (strippedScale & 1) == 0\n+        \/\/ strippedScale % n == 0\n@@ -211,1 +276,1 @@\n-        \/\/ !stripped.isPowerOfTen() && sqrtRem[1].signum == 0 && (mc.precision != 0 && result.precision() > mc.precision)\n+        \/\/ sqrtRem[1].signum == 0 && n > 0 && (mc.precision != 0 && result.precision() > mc.precision)\n@@ -222,1 +287,1 @@\n-        BigDecimal four = BigDecimal.valueOf(4);\n+        BigDecimal four = BigDecimal.valueOf(4), oneHalf = BigDecimal.valueOf(5, 1);\n@@ -224,11 +289,7 @@\n-                \/\/ stripped.isPowerOfTen() && mc.roundingMode == RoundingMode.UNNECESSARY\n-                { BigDecimal.ONE, unnecessary, BigDecimal.ONE },\n-                \/\/ stripped.isPowerOfTen() && mc.roundingMode != RoundingMode.UNNECESSARY && mc.precision == 0\n-                { BigDecimal.ONE, arbitrary, BigDecimal.ONE },\n-                \/\/ !stripped.isPowerOfTen() && mc.roundingMode == RoundingMode.UNNECESSARY\n-                \/\/ && sqrtRem[1].signum == 0 && mc.precision == 0\n-                { four, new MathContext(0, RoundingMode.UNNECESSARY), BigDecimal.TWO },\n-                \/\/ !stripped.isPowerOfTen() && mc.roundingMode != RoundingMode.UNNECESSARY\n-                \/\/ && sqrtRem[1].signum == 0 && mc.precision == 0\n-                { four, arbitrary, BigDecimal.TWO },\n-                \/\/ !stripped.isPowerOfTen() && sqrtRem[1].signum == 0\n+                \/\/ mc.roundingMode == RoundingMode.UNNECESSARY && sqrtRem[1].signum == 0 && n > 0\n+                \/\/ && mc.precision == 0\n+                { four, 2, new MathContext(0, RoundingMode.UNNECESSARY), BigDecimal.TWO },\n+                \/\/ mc.roundingMode != RoundingMode.UNNECESSARY && sqrtRem[1].signum == 0 && n > 0\n+                \/\/ && mc.precision == 0\n+                { four, 2, arbitrary, BigDecimal.TWO },\n+                \/\/ sqrtRem[1].signum == 0 && n > 0\n@@ -236,1 +297,6 @@\n-                { four, unnecessary, BigDecimal.TWO },\n+                { four, 2, unnecessary, BigDecimal.TWO },\n+                \/\/ mc.roundingMode == RoundingMode.UNNECESSARY && sqrtRem[1].signum == 0 && n < 0\n+                { four, -2, unnecessary, oneHalf },\n+                \/\/ mc.roundingMode != RoundingMode.UNNECESSARY && sqrtRem[1].signum == 0 && n < 0\n+                \/\/ && mc.precision == 0\n+                { four, -2, arbitrary, oneHalf },\n@@ -240,2 +306,2 @@\n-            BigDecimal expected = (BigDecimal) testCase[2];\n-            BigDecimal result = ((BigDecimal) testCase[0]).sqrt((MathContext) testCase[1]);\n+            BigDecimal expected = (BigDecimal) testCase[3];\n+            BigDecimal result = ((BigDecimal) testCase[0]).rootn((int) testCase[1], (MathContext) testCase[2]);\n@@ -297,1 +363,1 @@\n-    private static int squareRootTwoTests() {\n+    private static int rootTwoTests() {\n@@ -301,1 +367,1 @@\n-        BigDecimal highPrecisionRoot2 =\n+        BigDecimal highPrecisionSqrt2 =\n@@ -303,0 +369,3 @@\n+        \/\/ Cube root of 2 truncated to 65 digits\n+        BigDecimal highPrecisionCbrt2 =\n+            new BigDecimal(\"1.25992104989487316476721060727822835057025146470150798008197511215\");\n@@ -304,5 +373,1 @@\n-        RoundingMode[] modes = {\n-            RoundingMode.UP,       RoundingMode.DOWN,\n-            RoundingMode.CEILING, RoundingMode.FLOOR,\n-            RoundingMode.HALF_UP, RoundingMode.HALF_DOWN, RoundingMode.HALF_EVEN\n-        };\n+        List<RoundingMode> modes = roundingModes();\n@@ -313,2 +378,3 @@\n-        \/\/ highPrecisionRoot2.round(mc) and the alternative internal high-precision\n-        \/\/ implementation of square root.\n+        \/\/ highPrecisionSqrt2.round(mc) and the alternative internal high-precision\n+        \/\/ implementation of square root, and compare TWO.rootn(3, mc) to\n+        \/\/ highPrecisionCbrt2.round(mc).\n@@ -318,3 +384,9 @@\n-                BigDecimal expected = highPrecisionRoot2.round(mc);\n-                BigDecimal computed = TWO.sqrt(mc);\n-                BigDecimal altComputed = BigSquareRoot.sqrt(TWO, mc);\n+                BigDecimal expectedSqrt = highPrecisionSqrt2.round(mc);\n+                BigDecimal computedSqrt = TWO.sqrt(mc);\n+                BigDecimal altComputedSqrt = BigSquareRoot.sqrt(TWO, mc);\n+\n+                failures += equalNumerically(expectedSqrt, computedSqrt, \"sqrt(2)\");\n+                failures += equalNumerically(computedSqrt, altComputedSqrt, \"computed & altComputed\");\n+\n+                BigDecimal expectedCbrt = highPrecisionCbrt2.round(mc);\n+                BigDecimal computedCbrt = TWO.rootn(3, mc);\n@@ -322,2 +394,1 @@\n-                failures += equalNumerically(expected, computed, \"sqrt(2)\");\n-                failures += equalNumerically(computed, altComputed, \"computed & altComputed\");\n+                failures += equalNumerically(expectedCbrt, computedCbrt, \"rootn(2, 3)\");\n@@ -330,1 +401,1 @@\n-    private static int lowPrecisionPerfectSquares() {\n+    private static int lowPrecisionPerfectPowers() {\n@@ -333,32 +404,22 @@\n-        \/\/ For 5^2 through 9^2, if the input is rounded to one digit\n-        \/\/ first before the root is computed, the wrong answer will\n-        \/\/ result. Verify results and scale for different rounding\n-        \/\/ modes and precisions.\n-        long[][] squaresWithOneDigitRoot = {{ 4, 2},\n-                                            { 9, 3},\n-                                            {25, 5},\n-                                            {36, 6},\n-                                            {49, 7},\n-                                            {64, 8},\n-                                            {81, 9}};\n-\n-        for (long[] squareAndRoot : squaresWithOneDigitRoot) {\n-            BigDecimal square     = new BigDecimal(squareAndRoot[0]);\n-            BigDecimal expected   = new BigDecimal(squareAndRoot[1]);\n-\n-            for (int scale = 0; scale <= 4; scale++) {\n-                BigDecimal scaledSquare = square.setScale(scale, RoundingMode.UNNECESSARY);\n-                int expectedScale = Math.ceilDiv(scale, 2);\n-                for (int precision = 0; precision <= 5; precision++) {\n-                    for (RoundingMode rm : RoundingMode.values()) {\n-                        MathContext mc = new MathContext(precision, rm);\n-                        BigDecimal computedRoot = scaledSquare.sqrt(mc);\n-                        failures += equalNumerically(expected, computedRoot, \"simple squares\");\n-                        int computedScale = computedRoot.scale();\n-                        if (precision >=  expectedScale + 1 &&\n-                            computedScale != expectedScale) {\n-                            System.err.printf(\"%s\\tprecision=%d\\trm=%s%n\",\n-                                              computedRoot.toString(), precision, rm);\n-                            failures++;\n-                            System.err.printf(\"\\t%s does not have expected scale of %d%n.\",\n-                                              computedRoot, expectedScale);\n+        for (int i = -9; i <= 9; i++) {\n+            for (int n = 1; n < 10; n++) {\n+                BigDecimal expected = BigDecimal.valueOf(n % 2 != 0 ? i : Math.abs(i));\n+                BigDecimal pow = BigDecimal.valueOf(Math.powExact(i, n));\n+\n+                for (int scale = 0; scale <= 4; scale++) {\n+                    BigDecimal scaledPow = pow.setScale(scale);\n+                    int expectedScale = Math.ceilDiv(scale, n);\n+                    for (int precision = 0; precision <= 5; precision++) {\n+                        for (RoundingMode rm : RoundingMode.values()) {\n+                            MathContext mc = new MathContext(precision, rm);\n+                            BigDecimal computedRoot = scaledPow.rootn(n, mc);\n+                            failures += equalNumerically(expected, computedRoot, \"simple powers\");\n+                            int computedScale = computedRoot.scale();\n+                            if (precision >=  expectedScale + 1 &&\n+                                computedScale != expectedScale) {\n+                                System.err.printf(\"%s\\tprecision=%d\\trm=%s%n\",\n+                                                  computedRoot.toString(), precision, rm);\n+                                failures++;\n+                                System.err.printf(\"\\t%s does not have expected scale of %d%n.\",\n+                                                  computedRoot, expectedScale);\n+                            }\n@@ -375,1 +436,1 @@\n-     * Test around 3.9999 that the sqrt doesn't improperly round-up to\n+     * Test around 2^n-0.000...1 that the root doesn't improperly round-up to\n@@ -383,1 +444,0 @@\n-\n@@ -389,1 +449,12 @@\n-            failures += (result.compareTo(TWO) < 0) ? 0  : 1 ;\n+            failures += (result.compareTo(TWO) < 0) ? 0 : 1;\n+        }\n+\n+        BigDecimal ulp = nearFour.ulp();\n+        for (int n = 1; n < 10; n++) {\n+            BigDecimal near2ToN = BigDecimal.valueOf(Math.powExact(2, n)).subtract(ulp);\n+            \/\/ Root is 1.9999...\n+            for (int i = 1; i < 64; i++) {\n+                MathContext mc = new MathContext(i, RoundingMode.FLOOR);\n+                BigDecimal result = near2ToN.rootn(n, mc);\n+                failures += (result.compareTo(TWO) < 0) ? 0 : 1;\n+            }\n@@ -396,1 +467,1 @@\n-     * Test around 4.000...1 that the sqrt doesn't improperly\n+     * Test around 2^n+0.000...1 that the root doesn't improperly\n@@ -404,1 +475,0 @@\n-\n@@ -410,1 +480,12 @@\n-            failures += (result.compareTo(TWO) > 0) ? 0  : 1 ;\n+            failures += (result.compareTo(TWO) > 0) ? 0 : 1;\n+        }\n+\n+        BigDecimal ulp = nearFour.ulp();\n+        for (int n = 1; n < 10; n++) {\n+            BigDecimal near2ToN = BigDecimal.valueOf(Math.powExact(2, n)).add(ulp);\n+            \/\/ Root is 2.0000....<non-zero digits>\n+            for (int i = 1; i < 64; i++) {\n+                MathContext mc = new MathContext(i, RoundingMode.CEILING);\n+                BigDecimal result = near2ToN.rootn(n, mc);\n+                failures += (result.compareTo(TWO) > 0) ? 0 : 1;\n+            }\n@@ -419,1 +500,1 @@\n-         BigDecimal near10 = new BigDecimal(\"9.99999999999999999999\");\n+        BigDecimal near10 = new BigDecimal(\"9.99999999999999999999\");\n@@ -421,1 +502,1 @@\n-         BigDecimal near10sq = near10.multiply(near10);\n+        BigDecimal near10sq = near10.multiply(near10);\n@@ -423,1 +504,1 @@\n-         BigDecimal near10sq_ulp = near10sq.add(near10sq.ulp());\n+        BigDecimal near10sq_ulp = near10sq.add(near10sq.ulp());\n@@ -499,0 +580,21 @@\n+        for (int n = 1; n < 10; n++) {\n+            for (BigDecimal halfWayCase : halfWayCases) {\n+                \/\/ Round result to next-to-last place\n+                int precision = halfWayCase.precision() - 1;\n+                BigDecimal pow = halfWayCase.pow(n);\n+\n+                for (RoundingMode rm : List.of(RoundingMode.HALF_EVEN,\n+                                               RoundingMode.HALF_UP,\n+                                               RoundingMode.HALF_DOWN)) {\n+                    MathContext mc = new MathContext(precision, rm);\n+\n+                    System.out.println(\"\\nRounding mode \" + rm);\n+                    System.out.println(\"\\t\" + halfWayCase.round(mc) + \"\\t\" + halfWayCase);\n+\n+                    failures += equalNumerically(pow.rootn(n, mc),\n+                                                 halfWayCase.round(mc),\n+                                                 \"Rounding halway \" + rm);\n+                }\n+            }\n+        }\n+\n","filename":"test\/jdk\/java\/math\/BigDecimal\/SquareRootTests.java","additions":225,"deletions":123,"binary":false,"changes":348,"status":"modified"}]}