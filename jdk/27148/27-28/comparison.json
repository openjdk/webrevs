{"files":[{"patch":"@@ -2457,5 +2457,0 @@\n-        \/\/ The starting value and result should be nonzero and have the same sign.\n-        assert (result.signum() != 0 &&\n-                this.signum() == result.signum()) :\n-            \"Bad signum of this and\/or its root.\";\n-\n@@ -2467,1 +2462,1 @@\n-            } else if (mc.roundingMode == RoundingMode.CEILING) {\n+            } else if (rm == RoundingMode.CEILING) {\n@@ -2472,0 +2467,1 @@\n+        int nAbs = Math.abs(n);\n@@ -2473,2 +2469,1 @@\n-            n = -n;\n-            rad = ONE.divide(rad, result.scale * n, RoundingMode.DOWN);\n+            rad = ONE.divide(rad, result.scale * nAbs, RoundingMode.DOWN);\n@@ -2489,3 +2484,5 @@\n-                resAbs.pow(n).compareTo(rad)     <= 0 &&\n-                neighborUp.pow(n).compareTo(rad) > 0:\n-            \"Power of result out for bounds rounding \" + rm;\n+                resAbs.pow(nAbs).compareTo(rad)     <= 0 &&\n+                (n > 0\n+                        ? neighborUp.pow(nAbs).compareTo(rad) >  0\n+                        : neighborUp.pow(nAbs).compareTo(rad) >= 0) \/\/ Inverse radicand is not exact\n+                : \"Power of result out for bounds rounding \" + rm;\n@@ -2497,3 +2494,5 @@\n-                resAbs.pow(n).compareTo(rad)       >= 0 &&\n-                neighborDown.pow(n).compareTo(rad) < 0:\n-            \"Power of result out for bounds rounding \" + rm;\n+                resAbs.pow(nAbs).compareTo(rad)       >= 0 &&\n+                (n > 0\n+                        ? neighborDown.pow(nAbs).compareTo(rad) <  0\n+                        : neighborDown.pow(nAbs).compareTo(rad) <= 0) \/\/ Inverse radicand is not exact\n+                : \"Power of result out for bounds rounding \" + rm;\n@@ -2506,3 +2505,3 @@\n-            BigDecimal err = resAbs.pow(n).subtract(rad).abs();\n-            BigDecimal errUp = neighborUp.pow(n).subtract(rad);\n-            BigDecimal errDown =  rad.subtract(neighborDown.pow(n));\n+            BigDecimal err = resAbs.pow(nAbs).subtract(rad).abs();\n+            BigDecimal errUp = neighborUp.pow(nAbs).subtract(rad);\n+            BigDecimal errDown =  rad.subtract(neighborDown.pow(nAbs));\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":16,"deletions":17,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -34,1 +34,2 @@\n-import java.util.List;\n+import java.util.*;\n+import java.util.stream.IntStream;\n@@ -145,0 +146,5 @@\n+    private static RoundingMode positiveRoundingMode(RoundingMode rm) {\n+        return rm == RoundingMode.FLOOR   ? RoundingMode.UP :\n+               rm == RoundingMode.CEILING ? RoundingMode.DOWN : rm;\n+    }\n+\n@@ -146,2 +152,2 @@\n-     * Probe inputs with one digit of precision, 1 ... 9 and those\n-     * values scaled by 10^-1, 0.1, ... 0.9.\n+     * Probe inputs with one digit of precision, ±1 ... ±9 and those\n+     * values scaled by 10^-1, ±0.1, ... ±0.9.\n@@ -152,9 +158,3 @@\n-        List<BigDecimal> oneToNine =\n-            List.of(ONE,        TWO,        valueOf(3),\n-                    valueOf(4), valueOf(5), valueOf(6),\n-                    valueOf(7), valueOf(8), valueOf(9));\n-\n-        List<RoundingMode> modes =\n-            List.of(RoundingMode.UP,      RoundingMode.DOWN,\n-                    RoundingMode.CEILING, RoundingMode.FLOOR,\n-                    RoundingMode.HALF_UP, RoundingMode.HALF_DOWN, RoundingMode.HALF_EVEN);\n+        List<BigDecimal> oneToNine = IntStream.rangeClosed(1, 9).mapToObj(BigDecimal::valueOf).toList();\n+        List<RoundingMode> modes = new ArrayList<>(Arrays.asList(RoundingMode.values()));\n+        modes.remove(RoundingMode.UNNECESSARY);\n@@ -164,0 +164,2 @@\n+                MathContext mc = new MathContext(i, rm);\n+                MathContext positiveMC = new MathContext(i, positiveRoundingMode(rm));\n@@ -165,2 +167,0 @@\n-                    MathContext mc = new MathContext(i, rm);\n-\n@@ -168,1 +168,6 @@\n-                    bd = bd.multiply(ONE_TENTH);\n+                    BigDecimal minus_bd = bd.negate();\n+                    System.out.println(minus_bd + \" \" + mc);\n+                    failures += compare(minus_bd.rootn( 3, mc), bd.rootn( 3, positiveMC).negate(), true, \"one digit\");\n+                    failures += compare(minus_bd.rootn(-3, mc), bd.rootn(-3, positiveMC).negate(), true, \"one digit\");\n+\n+                    bd = bd.scaleByPowerOfTen(-1);\n@@ -170,0 +175,3 @@\n+                    minus_bd = bd.negate();\n+                    failures += compare(minus_bd.rootn( 3, mc), bd.rootn( 3, positiveMC).negate(), true, \"one digit\");\n+                    failures += compare(minus_bd.rootn(-3, mc), bd.rootn(-3, positiveMC).negate(), true, \"one digit\");\n@@ -196,1 +204,1 @@\n-                for (int precision = 1; i < 20; i++) {\n+                for (int prec = 1; prec < 20; prec++) {\n@@ -198,1 +206,1 @@\n-                        MathContext mc = new MathContext(precision, rm);\n+                        MathContext mc = new MathContext(prec, rm);\n","filename":"test\/jdk\/java\/math\/BigDecimal\/SquareRootTests.java","additions":25,"deletions":17,"binary":false,"changes":42,"status":"modified"}]}