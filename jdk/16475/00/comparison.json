{"files":[{"patch":"@@ -994,10 +994,0 @@\n-  buffer_fixed  = false;\n-  buffer_max    = bufmax;\n-  truncated     = false;\n-}\n-\n-bufferedStream::bufferedStream(char* fixed_buffer, size_t fixed_buffer_size, size_t bufmax) : outputStream() {\n-  buffer_length = fixed_buffer_size;\n-  buffer        = fixed_buffer;\n-  buffer_pos    = 0;\n-  buffer_fixed  = true;\n@@ -1020,31 +1010,21 @@\n-    if (buffer_fixed) {\n-      \/\/ if buffer cannot resize, silently truncate\n-      len = buffer_length - buffer_pos - 1;\n-      truncated = true;\n-    } else {\n-      \/\/ For small overruns, double the buffer.  For larger ones,\n-      \/\/ increase to the requested size.\n-      if (end < buffer_length * 2) {\n-        end = buffer_length * 2;\n-      }\n-      \/\/ Impose a cap beyond which the buffer cannot grow - a size which\n-      \/\/ in all probability indicates a real error, e.g. faulty printing\n-      \/\/ code looping, while not affecting cases of just-very-large-but-its-normal\n-      \/\/ output.\n-      const size_t reasonable_cap = MAX2(100 * M, buffer_max * 2);\n-      if (end > reasonable_cap) {\n-        \/\/ In debug VM, assert right away.\n-        assert(false, \"Exceeded max buffer size for this string.\");\n-        \/\/ Release VM: silently truncate. We do this since these kind of errors\n-        \/\/ are both difficult to predict with testing (depending on logging content)\n-        \/\/ and usually not serious enough to kill a production VM for it.\n-        end = reasonable_cap;\n-        size_t remaining = end - buffer_pos;\n-        if (len >= remaining) {\n-          len = remaining - 1;\n-          truncated = true;\n-        }\n-      }\n-      if (buffer_length < end) {\n-        buffer = REALLOC_C_HEAP_ARRAY(char, buffer, end, mtInternal);\n-        buffer_length = end;\n+    \/\/ For small overruns, double the buffer.  For larger ones,\n+    \/\/ increase to the requested size.\n+    if (end < buffer_length * 2) {\n+      end = buffer_length * 2;\n+    }\n+    \/\/ Impose a cap beyond which the buffer cannot grow - a size which\n+    \/\/ in all probability indicates a real error, e.g. faulty printing\n+    \/\/ code looping, while not affecting cases of just-very-large-but-its-normal\n+    \/\/ output.\n+    const size_t reasonable_cap = MAX2(100 * M, buffer_max * 2);\n+    if (end > reasonable_cap) {\n+      \/\/ In debug VM, assert right away.\n+      assert(false, \"Exceeded max buffer size for this string.\");\n+      \/\/ Release VM: silently truncate. We do this since these kind of errors\n+      \/\/ are both difficult to predict with testing (depending on logging content)\n+      \/\/ and usually not serious enough to kill a production VM for it.\n+      end = reasonable_cap;\n+      size_t remaining = end - buffer_pos;\n+      if (len >= remaining) {\n+        len = remaining - 1;\n+        truncated = true;\n@@ -1053,0 +1033,4 @@\n+    if (buffer_length < end) {\n+      buffer = REALLOC_C_HEAP_ARRAY(char, buffer, end, mtInternal);\n+      buffer_length = end;\n+    }\n@@ -1069,3 +1053,1 @@\n-  if (!buffer_fixed) {\n-    FREE_C_HEAP_ARRAY(char, buffer);\n-  }\n+  FREE_C_HEAP_ARRAY(char, buffer);\n","filename":"src\/hotspot\/share\/utilities\/ostream.cpp","additions":26,"deletions":44,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -296,1 +296,0 @@\n-  bool   buffer_fixed;\n@@ -300,1 +299,0 @@\n-  bufferedStream(char* fixed_buffer, size_t fixed_buffer_size, size_t bufmax = 1024*1024*10);\n","filename":"src\/hotspot\/share\/utilities\/ostream.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -96,18 +96,0 @@\n-TEST_VM(ostream, bufferedStream_static) {\n-  char buf[100 + 1];\n-  char* canary_at = buf + sizeof(buf) - 1;\n-  *canary_at = 'X';\n-  size_t stream_buf_size = sizeof(buf) - 1;\n-  bufferedStream bs(buf, stream_buf_size);\n-  size_t written = 0;\n-  for (int i = 0; i < 100; i ++) {\n-    written += print_lorem(&bs);\n-    if (written < stream_buf_size) {\n-      ASSERT_EQ(bs.size(), written);\n-    } else {\n-      ASSERT_EQ(bs.size(), stream_buf_size - 1);\n-    }\n-  }\n-  ASSERT_EQ(*canary_at, 'X'); \/\/ canary\n-}\n-\n","filename":"test\/hotspot\/gtest\/utilities\/test_ostream.cpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"}]}