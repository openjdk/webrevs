{"files":[{"patch":"@@ -117,0 +117,1 @@\n+  NOT_PRODUCT(if (C->igv_printer()) C->igv_printer()->set_congraph(congraph);)\n@@ -122,0 +123,1 @@\n+  NOT_PRODUCT(if (C->igv_printer()) C->igv_printer()->set_congraph(nullptr);)\n@@ -129,0 +131,2 @@\n+\n+  C->print_method(PHASE_AFTER_EA, 2);\n@@ -284,0 +288,2 @@\n+  _compile->print_method(PHASE_EA_AFTER_INITIAL_CONGRAPH, 4);\n+\n@@ -294,0 +300,2 @@\n+  _compile->print_method(PHASE_EA_AFTER_COMPLETE_CONGRAPH, 4);\n+\n@@ -315,0 +323,1 @@\n+    _compile->print_method(PHASE_EA_ADJUST_SCALAR_REPLACEABLE_ITER, 6);\n@@ -353,0 +362,1 @@\n+  _compile->print_method(PHASE_EA_AFTER_PROPAGATE_NSR, 4);\n@@ -390,0 +400,2 @@\n+  _compile->print_method(PHASE_EA_AFTER_GRAPH_OPTIMIZATION, 4);\n+\n@@ -401,1 +413,0 @@\n-    C->print_method(PHASE_AFTER_EA, 2);\n@@ -416,0 +427,2 @@\n+  _compile->print_method(PHASE_EA_AFTER_SPLIT_UNIQUE_TYPES, 4);\n+\n@@ -457,0 +470,2 @@\n+  _compile->print_method(PHASE_EA_AFTER_REDUCE_PHI_ON_SAFEPOINTS, 4);\n+\n@@ -1305,0 +1320,2 @@\n+  _compile->print_method(PHASE_EA_BEFORE_PHI_REDUCTION, 5);\n+\n@@ -1310,0 +1327,1 @@\n+    _compile->print_method(PHASE_EA_AFTER_PHI_CASTPP_REDUCTION, 6);\n@@ -1320,0 +1338,2 @@\n+\n+    _compile->print_method(PHASE_EA_AFTER_PHI_ADDPP_CMP_REDUCTION, 6);\n@@ -2420,0 +2440,1 @@\n+      _compile->print_method(PHASE_EA_COMPLETE_CONNECTION_GRAPH_ITER, 5);\n@@ -2493,1 +2514,2 @@\n-                                               GrowableArray<JavaObjectNode*>& non_escaped_allocs_worklist) {\n+                                               GrowableArray<JavaObjectNode*>& non_escaped_allocs_worklist,\n+                                               bool verify) {\n@@ -2553,0 +2575,3 @@\n+      if (!verify) {\n+        _compile->print_method(PHASE_EA_CONNECTION_GRAPH_PROPAGATE_ITER, 6);\n+      }\n@@ -3128,0 +3153,1 @@\n+              _compile->print_method(PHASE_EA_PROPAGATE_NSR_ITER, 5);\n@@ -3162,1 +3188,1 @@\n-  find_non_escaped_objects(ptnodes_worklist, non_escaped_allocs_worklist);\n+  find_non_escaped_objects(ptnodes_worklist, non_escaped_allocs_worklist, \/*verify=*\/ true);\n@@ -4723,0 +4749,2 @@\n+  _compile->print_method(PHASE_EA_AFTER_SPLIT_UNIQUE_TYPES_1, 5);\n+\n@@ -4923,0 +4951,2 @@\n+  _compile->print_method(PHASE_EA_AFTER_SPLIT_UNIQUE_TYPES_3, 5);\n+\n@@ -4991,0 +5021,1 @@\n+  _compile->print_method(PHASE_EA_AFTER_SPLIT_UNIQUE_TYPES_4, 5);\n@@ -5173,1 +5204,0 @@\n-\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":34,"deletions":4,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"opto\/idealGraphPrinter.hpp\"\n@@ -324,0 +325,1 @@\n+  friend class IdealGraphPrinter;\n@@ -470,1 +472,2 @@\n-                                GrowableArray<JavaObjectNode*>& non_escaped_worklist);\n+                                GrowableArray<JavaObjectNode*>& non_escaped_worklist,\n+                                bool verify = false);\n","filename":"src\/hotspot\/share\/opto\/escape.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"opto\/escape.hpp\"\n@@ -164,0 +165,1 @@\n+  _congraph = nullptr;\n@@ -640,0 +642,23 @@\n+    \/\/ Dump escape analysis state for relevant nodes.\n+    if (node->is_Allocate()) {\n+      AllocateNode* alloc = node->as_Allocate();\n+       if (alloc->_is_scalar_replaceable) {\n+         print_prop(\"is_scalar_replaceable\", \"true\");\n+       }\n+       if (alloc->_is_non_escaping) {\n+         print_prop(\"is_non_escaping\", \"true\");\n+       }\n+       if (alloc->does_not_escape_thread()) {\n+         print_prop(\"does_not_escape_thread\", \"true\");\n+       }\n+    }\n+    if (node->is_SafePoint() && node->as_SafePoint()->has_ea_local_in_scope()) {\n+      print_prop(\"has_ea_local_in_scope\", \"true\");\n+    }\n+    if (node->is_CallJava() && node->as_CallJava()->arg_escape()) {\n+      print_prop(\"arg_escape\", \"true\");\n+    }\n+    if (node->is_Initialize() && node->as_Initialize()->does_not_escape()) {\n+      print_prop(\"does_not_escape\", \"true\");\n+    }\n+\n@@ -734,0 +759,15 @@\n+    if (_congraph && node->_idx < _congraph->nodes_size()) {\n+      PointsToNode* ptn = _congraph->ptnode_adr(node->_idx);\n+      if (ptn) {\n+        print_prop(\"ea_node\", ptn->is_JavaObject() ? \"javaobject\" :\n+                              ptn->is_LocalVar() ? \"localvar\" :\n+                              ptn->is_Field() ? \"field\" :\n+                              \"\");\n+        print_prop(\"escape\", ptn->escape_state() == PointsToNode::EscapeState::NoEscape ? \"no_escape\" :\n+                             ptn->escape_state() == PointsToNode::EscapeState::ArgEscape ? \"arg_escape\" :\n+                             ptn->escape_state() == PointsToNode::EscapeState::GlobalEscape ? \"global_escape\" :\n+                             \"\");\n+        print_prop(\"replaceable\", ptn->scalar_replaceable() ? \"true\" : \"\");\n+      }\n+    }\n+\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.cpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+class ConnectionGraph;\n@@ -119,0 +120,1 @@\n+  ConnectionGraph* _congraph;\n@@ -168,0 +170,1 @@\n+  void set_congraph(ConnectionGraph* congraph) { _congraph = congraph; }\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -53,0 +53,16 @@\n+  flags(EA_AFTER_INITIAL_CONGRAPH,          \"EA: 1. Intial Connection Graph\") \\\n+  flags(EA_CONNECTION_GRAPH_PROPAGATE_ITER, \"EA: 2. Connection Graph Propagate Iter\") \\\n+  flags(EA_COMPLETE_CONNECTION_GRAPH_ITER,  \"EA: 2. Complete Connection Graph Iter\") \\\n+  flags(EA_AFTER_COMPLETE_CONGRAPH,         \"EA: 2. Complete Connection Graph\") \\\n+  flags(EA_ADJUST_SCALAR_REPLACEABLE_ITER,  \"EA: 3. Adjust scalar_replaceable State Iter\") \\\n+  flags(EA_PROPAGATE_NSR_ITER,              \"EA: 3. Propagate NSR Iter\") \\\n+  flags(EA_AFTER_PROPAGATE_NSR,             \"EA: 3. Propagate NSR\") \\\n+  flags(EA_AFTER_GRAPH_OPTIMIZATION,        \"EA: 4. After Graph Optimization\") \\\n+  flags(EA_AFTER_SPLIT_UNIQUE_TYPES_1,      \"EA: 5. After split_unique_types Phase 1\") \\\n+  flags(EA_AFTER_SPLIT_UNIQUE_TYPES_3,      \"EA: 5. After split_unique_types Phase 3\") \\\n+  flags(EA_AFTER_SPLIT_UNIQUE_TYPES_4,      \"EA: 5. After split_unique_types Phase 4\") \\\n+  flags(EA_AFTER_SPLIT_UNIQUE_TYPES,        \"EA: 5. After split_unique_types\") \\\n+  flags(EA_AFTER_REDUCE_PHI_ON_SAFEPOINTS,  \"EA: 6. After reduce_phi_on_safepoints\") \\\n+  flags(EA_BEFORE_PHI_REDUCTION,            \"EA: 5. Before Phi Reduction\") \\\n+  flags(EA_AFTER_PHI_CASTPP_REDUCTION,      \"EA: 5. Phi -> CastPP Reduction\") \\\n+  flags(EA_AFTER_PHI_ADDPP_CMP_REDUCTION,   \"EA: 5. Phi -> AddPP\/Cmp Reduction\") \\\n","filename":"src\/hotspot\/share\/opto\/phasetype.hpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/\/ Color allocation nodes to indicate the result of scape analysis.\n+\/\/ This filter is relevant between the first EA phase and \"After Macro\n+\/\/ Expansion\".\n+\n+var bestColor   = java.awt.Color.decode(\"#6aa84f\"); \/\/ Green.\n+var betterColor = java.awt.Color.decode(\"#f1c232\"); \/\/ Yellow.\n+var worseColor  = java.awt.Color.decode(\"#e69138\"); \/\/ Orange.\n+var worstColor  = java.awt.Color.decode(\"#cc0000\"); \/\/ Red.\n+\n+\/\/ Object does not escape compilation unit and is scalar replaceable.\n+colorize(and([hasProperty(\"is_non_escaping\"),\n+              hasProperty(\"is_scalar_replaceable\")]),\n+         bestColor);\n+colorize(and([matches(\"escape\", \"no_escape\"),\n+              hasProperty(\"replaceable\")]),\n+         bestColor);\n+\n+\/\/ Object does not escape compilation unit but is not scalar replaceable,\n+\/\/ due to of scalar replacement limitations. We can at least elide locks.\n+colorize(and([hasProperty(\"is_non_escaping\"),\n+              not(hasProperty(\"is_scalar_replaceable\"))]),\n+         betterColor);\n+colorize(and([matches(\"escape\", \"no_escape\"),\n+              not(hasProperty(\"replaceable\"))]),\n+         betterColor);\n+\n+\/\/ Object may escape compilation unit but does not escape thread.\n+\/\/ We can at least elide locks.\n+colorize(and([hasProperty(\"does_not_escape_thread\"),\n+              not(hasProperty(\"is_non_escaping\"))]),\n+         worseColor);\n+colorize(and([matches(\"escape\", \"arg_escape\"),\n+              not(hasProperty(\"replaceable\"))]),\n+         worseColor);\n+\n+\/\/ Object may escape compilation unit and thread. Nothing to do.\n+colorize(and([matches(\"name\", \"Allocate\"),\n+              not(hasProperty(\"is_non_escaping\")),\n+              not(hasProperty(\"does_not_escape_thread\"))]),\n+         worstColor);\n+colorize(and([matches(\"escape\", \"global_escape\"),\n+              not(hasProperty(\"replaceable\"))]),\n+         worstColor);\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/resources\/com\/sun\/hotspot\/igv\/servercompiler\/filters\/colorEscapeAnalysis.filter","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,20 @@\n+\/\/ This filter appends simplified type information to the (possibly already\n+\/\/ existing) extra-label line.\n+\/\/ If the phase type is available, show it. If the bottom type is available and\n+\/\/ differs from the bottom type, show it too (prefixed with 'B:').\n+\n+\/\/ Merge a possibly existing extra label, bottom type, and phase type into a\n+\/\/ new, single extra label. For memory nodes, add an extra label with the memory\n+\/\/ slice, extracted from the dump_spec field.\n+function mergeAndAppendTypeInfo(extra_label, ea_node) {\n+  new_extra_label = extra_label == null ? \"\" : (extra_label + \" \");\n+  return new_extra_label + ea_node;\n+}\n+\n+editProperty(or([matches(\"ea_node\", \"javaobject\"),\n+                 matches(\"ea_node\", \"localvar\"),\n+                 matches(\"ea_node\", \"field\")]),\n+             [\"extra_label\", \"ea_node\"],\n+             \"extra_label\",\n+             function(propertyValues) {return mergeAndAppendTypeInfo(propertyValues[0], propertyValues[1]);});\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/resources\/com\/sun\/hotspot\/igv\/servercompiler\/filters\/showConnectionNodes.filter","additions":20,"deletions":0,"binary":false,"changes":20,"status":"added"},{"patch":"@@ -24,0 +24,4 @@\n+        <file name=\"Show connection graph nodes.js\" url=\"filters\/showConnectionNodes.filter\">\n+            <attr name=\"enabled\" boolvalue=\"false\"\/>\n+            <attr name=\"after\" stringvalue=\"Show connection node types\"\/>\n+        <\/file>\n@@ -88,0 +92,4 @@\n+        <file name=\"Color by escape analysis state.js\" url=\"filters\/colorEscapeAnalysis.filter\">\n+            <attr name=\"enabled\" boolvalue=\"false\"\/>\n+            <attr name=\"after\" stringvalue=\"Color by escape analysis state\"\/>\n+        <\/file>\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/resources\/com\/sun\/hotspot\/igv\/servercompiler\/layer.xml","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"}]}