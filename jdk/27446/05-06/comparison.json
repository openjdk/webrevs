{"files":[{"patch":"@@ -66,1 +66,1 @@\n-TOOL_BLOCKED_CERTS = $(JAVA_SMALL) -cp $(BUILDTOOLS_OUTPUTDIR)\/jdk_tools_classes \\\n+TOOL_BLOCKED_CERTS = $(JAVA_SMALL) -Xlog:disable -cp $(BUILDTOOLS_OUTPUTDIR)\/jdk_tools_classes \\\n","filename":"make\/ToolsJdk.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -600,3 +600,1 @@\n-  CREATE_BUILDJDK=false\n-  EXTERNAL_BUILDJDK=false\n-  BUILD_JDK_FOUND=\"no\"\n+  EXTERNAL_BUILDJDK_PATH=\"\"\n@@ -604,0 +602,1 @@\n+    BUILD_JDK_FOUND=no\n@@ -611,11 +610,1 @@\n-    EXTERNAL_BUILDJDK=true\n-  else\n-    if test \"x$COMPILE_TYPE\" = \"xcross\"; then\n-      BUILD_JDK=\"\\$(BUILDJDK_OUTPUTDIR)\/jdk\"\n-      BUILD_JDK_FOUND=yes\n-      CREATE_BUILDJDK=true\n-      AC_MSG_CHECKING([for Build JDK])\n-      AC_MSG_RESULT([yes, will build it for the host platform])\n-    else\n-      BUILD_JDK=\"\\$(JDK_OUTPUTDIR)\"\n-      BUILD_JDK_FOUND=yes\n+    if test \"x$BUILD_JDK_FOUND\" != \"xyes\"; then\n@@ -623,1 +612,2 @@\n-      AC_MSG_RESULT([yes, will use output dir])\n+      AC_MSG_RESULT([no])\n+      AC_MSG_ERROR([Could not find a suitable Build JDK])\n@@ -625,0 +615,1 @@\n+    EXTERNAL_BUILDJDK_PATH=\"$BUILD_JDK\"\n@@ -627,18 +618,1 @@\n-  # Since these tools do not yet exist, we cannot use UTIL_FIXUP_EXECUTABLE to\n-  # detect the need of fixpath\n-  JMOD=\"$BUILD_JDK\/bin\/jmod\"\n-  UTIL_ADD_FIXPATH(JMOD)\n-  JLINK=\"$BUILD_JDK\/bin\/jlink\"\n-  UTIL_ADD_FIXPATH(JLINK)\n-  AC_SUBST(JMOD)\n-  AC_SUBST(JLINK)\n-\n-  if test \"x$BUILD_JDK_FOUND\" != \"xyes\"; then\n-    AC_MSG_CHECKING([for Build JDK])\n-    AC_MSG_RESULT([no])\n-    AC_MSG_ERROR([Could not find a suitable Build JDK])\n-  fi\n-\n-  AC_SUBST(CREATE_BUILDJDK)\n-  AC_SUBST(BUILD_JDK)\n-  AC_SUBST(EXTERNAL_BUILDJDK)\n+  AC_SUBST(EXTERNAL_BUILDJDK_PATH)\n","filename":"make\/autoconf\/boot-jdk.m4","additions":7,"deletions":33,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-        -Wl,-bernotok -Wl,-bdatapsize:64k -Wl,-btextpsize:64k -Wl,-bstackpsize:64k\"\n+        -Wl,-bernotok -Wl,-bcdtors:mbr::s -Wl,-bdatapsize:64k -Wl,-btextpsize:64k -Wl,-bstackpsize:64k\"\n","filename":"make\/autoconf\/flags-ldflags.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -568,0 +568,4 @@\n+  # In the ubsan case we have to link every binary with the C++-compiler as linker, because inherently\n+  # the C-Compiler and the C++-compiler used as linker provide a different set of ubsan exports.\n+  # Linking an executable with the C-compiler and one of its shared libraries with the C++-compiler\n+  # leeds to unresolved symbols.\n@@ -569,2 +573,3 @@\n-      UBSAN_CFLAGS=\"$UBSAN_CFLAGS -fno-sanitize=function,vptr -DLLVM_SYMBOLIZER=$(dirname $(dirname $CC))\/tools\/ibm-llvm-symbolizer\"\n-      UBSAN_LDFLAGS=\"$UBSAN_LDFLAGS -fno-sanitize=function,vptr -Wl,-bbigtoc\"\n+    UBSAN_CFLAGS=\"$UBSAN_CFLAGS -DLLVM_SYMBOLIZER=$(dirname $(dirname $CC))\/tools\/ibm-llvm-symbolizer\"\n+    UBSAN_LDFLAGS=\"$UBSAN_LDFLAGS -Wl,-bbigtoc\"\n+    LD=\"$LDCXX\"\n","filename":"make\/autoconf\/jdk-options.m4","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -139,1 +139,1 @@\n-  # librt for legacy clock_gettime\n+  # librt - for timers (timer_* functions)\n@@ -141,4 +141,0 @@\n-    # Hotspot needs to link librt to get the clock_* functions.\n-    # But once our supported minimum build and runtime platform\n-    # has glibc 2.17, this can be removed as the functions are\n-    # in libc.\n","filename":"make\/autoconf\/libraries.m4","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -389,3 +389,16 @@\n-BUILD_JDK := @BUILD_JDK@\n-CREATE_BUILDJDK := @CREATE_BUILDJDK@\n-EXTERNAL_BUILDJDK := @EXTERNAL_BUILDJDK@\n+EXTERNAL_BUILDJDK_PATH := @EXTERNAL_BUILDJDK_PATH@\n+\n+ifneq ($(EXTERNAL_BUILDJDK_PATH), )\n+  EXTERNAL_BUILDJDK := true\n+  CREATE_BUILDJDK := false\n+  BUILD_JDK := $(EXTERNAL_BUILDJDK_PATH)\n+else\n+  EXTERNAL_BUILDJDK := false\n+  ifeq ($(COMPILE_TYPE), cross)\n+    CREATE_BUILDJDK := true\n+    BUILD_JDK := $(BUILDJDK_OUTPUTDIR)\/jdk\n+  else\n+    CREATE_BUILDJDK := false\n+    BUILD_JDK := $(JDK_OUTPUTDIR)\n+  endif\n+endif\n@@ -650,2 +663,2 @@\n-JLINK_CMD := @JLINK@\n-JMOD_CMD := @JMOD@\n+JLINK_CMD := @FIXPATH@ $(BUILD_JDK)\/bin\/jlink\n+JMOD_CMD := @FIXPATH@ $(BUILD_JDK)\/bin\/jmod\n","filename":"make\/autoconf\/spec.gmk.template","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -152,1 +152,1 @@\n-  $1_VARDEPS_FILE := $$(call DependOnVariable, $1_VARDEPS)\n+  $1_VARDEPS_FILE := $$(call DependOnVariable, $1_VARDEPS, $$($1_BASE)_exec.vardeps)\n","filename":"make\/common\/Execute.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+\t\t\"jdk.serverVmOptions\": [\"-Xmx2G\"], \/\/ prevent out of memory\n","filename":"make\/ide\/vscode\/hotspot\/template-workspace.jsonc","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -157,0 +157,2 @@\n+## The LIBDL dependency on Linux is needed to dynamically access libdl symbols,\n+## which may be needed as part of resolving some standard symbols\n@@ -199,1 +201,1 @@\n-      LIBS_linux := $(LIBDL) $(LIBM), \\\n+      LIBS_linux := $(LIBM), \\\n","filename":"make\/modules\/java.base\/Lib.gmk","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-    LIBS_unix := $(LIBDL) $(LIBM), \\\n+    LIBS_unix := $(LIBM), \\\n@@ -267,1 +267,1 @@\n-      LIBS_linux := $(LIBDL) $(X_LIBS) -lX11 -lXext, \\\n+      LIBS_linux := $(X_LIBS) -lX11 -lXext, \\\n","filename":"make\/modules\/java.desktop\/lib\/ClientLibraries.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,2 +46,0 @@\n-    LIBS_linux := $(LIBDL), \\\n-    LIBS_aix := $(LIBDL), \\\n","filename":"make\/modules\/java.instrument\/Lib.gmk","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-      LIBS_linux := $(LIBDL) $(LIBPTHREAD), \\\n+      LIBS_linux := $(LIBDL), \\\n","filename":"make\/modules\/jdk.sctp\/Lib.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -219,4 +219,4 @@\n-  if (_compute_lock) {\n-    \/\/ lock_reg was destroyed by fast unlocking attempt => recompute it\n-    ce->monitor_address(_monitor_ix, _lock_reg);\n-  }\n+\n+  \/\/ lock_reg was destroyed by fast unlocking attempt => recompute it\n+  ce->monitor_address(_monitor_ix, _lock_reg);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_CodeStubs_aarch64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -412,1 +412,1 @@\n-    stub = new MonitorExitStub(FrameMap::r0_opr, true, 0);\n+    stub = new MonitorExitStub(FrameMap::r0_opr, 0);\n@@ -2484,1 +2484,0 @@\n-    assert(BasicLock::displaced_header_offset_in_bytes() == 0, \"lock_reg must point to the displaced header\");\n@@ -2492,1 +2491,0 @@\n-    assert(BasicLock::displaced_header_offset_in_bytes() == 0, \"lock_reg must point to the displaced header\");\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -62,2 +62,2 @@\n-int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Register temp, Label& slow_case) {\n-  assert_different_registers(hdr, obj, disp_hdr, temp, rscratch2);\n+int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register basic_lock, Register temp, Label& slow_case) {\n+  assert_different_registers(hdr, obj, basic_lock, temp, rscratch2);\n@@ -69,1 +69,1 @@\n-  str(obj, Address(disp_hdr, BasicObjectLock::obj_offset()));\n+  str(obj, Address(basic_lock, BasicObjectLock::obj_offset()));\n@@ -73,1 +73,1 @@\n-  lightweight_lock(disp_hdr, obj, hdr, temp, rscratch2, slow_case);\n+  lightweight_lock(basic_lock, obj, hdr, temp, rscratch2, slow_case);\n@@ -79,2 +79,2 @@\n-void C1_MacroAssembler::unlock_object(Register hdr, Register obj, Register disp_hdr, Register temp, Label& slow_case) {\n-  assert_different_registers(hdr, obj, disp_hdr, temp, rscratch2);\n+void C1_MacroAssembler::unlock_object(Register hdr, Register obj, Register basic_lock, Register temp, Label& slow_case) {\n+  assert_different_registers(hdr, obj, basic_lock, temp, rscratch2);\n@@ -83,1 +83,1 @@\n-  ldr(obj, Address(disp_hdr, BasicObjectLock::obj_offset()));\n+  ldr(obj, Address(basic_lock, BasicObjectLock::obj_offset()));\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,4 +58,4 @@\n-  \/\/ hdr     : must be r0, contents destroyed\n-  \/\/ obj     : must point to the object to lock, contents preserved\n-  \/\/ disp_hdr: must point to the displaced header location, contents preserved\n-  \/\/ temp    : temporary register, must not be rscratch1 or rscratch2\n+  \/\/ hdr       : must be r0, contents destroyed\n+  \/\/ obj       : must point to the object to lock, contents preserved\n+  \/\/ basic_lock: must point to the basic lock, contents preserved\n+  \/\/ temp      : temporary register, must not be rscratch1 or rscratch2\n@@ -63,1 +63,1 @@\n-  int lock_object  (Register swap, Register obj, Register disp_hdr, Register temp, Label& slow_case);\n+  int lock_object  (Register swap, Register obj, Register basic_lock, Register temp, Label& slow_case);\n@@ -66,5 +66,5 @@\n-  \/\/ hdr     : contents destroyed\n-  \/\/ obj     : must point to the object to lock, contents preserved\n-  \/\/ disp_hdr: must be r0 & must point to the displaced header location, contents destroyed\n-  \/\/ temp    : temporary register, must not be rscratch1 or rscratch2\n-  void unlock_object(Register swap, Register obj, Register lock, Register temp, Label& slow_case);\n+  \/\/ hdr       : contents destroyed\n+  \/\/ obj       : must point to the object to lock, contents preserved\n+  \/\/ basic_lock: must be r0 & must point to the basic lock, contents destroyed\n+  \/\/ temp      : temporary register, must not be rscratch1 or rscratch2\n+  void unlock_object(Register swap, Register obj, Register basic_lock, Register temp, Label& slow_case);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.hpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -235,8 +235,8 @@\n-static void generate_post_barrier_fast_path(MacroAssembler* masm,\n-                                            const Register store_addr,\n-                                            const Register new_val,\n-                                            const Register thread,\n-                                            const Register tmp1,\n-                                            const Register tmp2,\n-                                            Label& done,\n-                                            bool new_val_may_be_null) {\n+static void generate_post_barrier(MacroAssembler* masm,\n+                                  const Register store_addr,\n+                                  const Register new_val,\n+                                  const Register thread,\n+                                  const Register tmp1,\n+                                  const Register tmp2,\n+                                  Label& done,\n+                                  bool new_val_may_be_null) {\n@@ -276,1 +276,1 @@\n-  generate_post_barrier_fast_path(masm, store_addr, new_val, thread, tmp1, tmp2, done, false \/* new_val_may_be_null *\/);\n+  generate_post_barrier(masm, store_addr, new_val, thread, tmp1, tmp2, done, false \/* new_val_may_be_null *\/);\n@@ -338,1 +338,1 @@\n-  generate_post_barrier_fast_path(masm, store_addr, new_val, thread, tmp1, tmp2, done, new_val_may_be_null);\n+  generate_post_barrier(masm, store_addr, new_val, thread, tmp1, tmp2, done, new_val_may_be_null);\n@@ -444,1 +444,1 @@\n-  generate_post_barrier_fast_path(masm, store_addr, new_val, thread, tmp1, tmp2, done, true \/* new_val_may_be_null *\/);\n+  generate_post_barrier(masm, store_addr, new_val, thread, tmp1, tmp2, done, true \/* new_val_may_be_null *\/);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/g1\/g1BarrierSetAssembler_aarch64.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -401,0 +401,2 @@\n+    case Op_RegI: \/\/ RA may place scalar values (Op_RegI\/N\/L\/P) in FP registers when UseFPUForSpilling is enabled\n+    case Op_RegN:\n@@ -402,1 +404,1 @@\n-      assert(opto_reg % 4 == 0, \"Float register should only occupy a single slot\");\n+      assert(opto_reg % 4 == 0, \"32-bit register should only occupy a single slot\");\n@@ -409,0 +411,2 @@\n+    case Op_RegL:\n+    case Op_RegP:\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -278,1 +278,0 @@\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zBarrierSetAssembler_aarch64.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -242,1 +242,0 @@\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/z_aarch64.ad","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -686,2 +686,2 @@\n-                                            AdapterHandlerEntry* handler) {\n-  address i2c_entry = __ pc();\n+                                            address entry_address[AdapterBlob::ENTRY_COUNT]) {\n+  entry_address[AdapterBlob::I2C] = __ pc();\n@@ -691,1 +691,1 @@\n-  address c2i_unverified_entry = __ pc();\n+  entry_address[AdapterBlob::C2I_Unverified] = __ pc();\n@@ -721,1 +721,1 @@\n-  address c2i_entry = __ pc();\n+  entry_address[AdapterBlob::C2I] = __ pc();\n@@ -724,1 +724,1 @@\n-  address c2i_no_clinit_check_entry = nullptr;\n+  entry_address[AdapterBlob::C2I_No_Clinit_Check] = nullptr;\n@@ -739,1 +739,1 @@\n-    c2i_no_clinit_check_entry = __ pc();\n+    entry_address[AdapterBlob::C2I_No_Clinit_Check] = __ pc();\n@@ -746,2 +746,0 @@\n-\n-  handler->set_entry_points(i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);\n@@ -1766,3 +1764,0 @@\n-    Label count;\n-    const int mark_word_offset = BasicLock::displaced_header_offset_in_bytes();\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -203,3 +203,4 @@\n-  if (_compute_lock) {\n-    ce->monitor_address(_monitor_ix, _lock_reg);\n-  }\n+\n+  \/\/ lock_reg was destroyed by fast unlocking attempt => recompute it\n+  ce->monitor_address(_monitor_ix, _lock_reg);\n+\n","filename":"src\/hotspot\/cpu\/arm\/c1_CodeStubs_arm.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -248,1 +248,1 @@\n-    stub = new MonitorExitStub(FrameMap::R0_opr, true, 0);\n+    stub = new MonitorExitStub(FrameMap::R0_opr, 0);\n@@ -2430,1 +2430,0 @@\n-    assert(BasicLock::displaced_header_offset_in_bytes() == 0, \"lock_reg must point to the displaced header\");\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -179,1 +179,1 @@\n-int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case) {\n+int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register basic_lock, Label& slow_case) {\n@@ -183,1 +183,1 @@\n-  assert_different_registers(hdr, obj, disp_hdr, tmp2);\n+  assert_different_registers(hdr, obj, basic_lock, tmp2);\n@@ -189,1 +189,1 @@\n-  str(obj, Address(disp_hdr, BasicObjectLock::obj_offset()));\n+  str(obj, Address(basic_lock, BasicObjectLock::obj_offset()));\n@@ -200,3 +200,3 @@\n-  Register t1 = disp_hdr; \/\/ Needs saving, probably\n-  Register t2 = hdr;      \/\/ blow\n-  Register t3 = Rtemp;    \/\/ blow\n+  Register t1 = basic_lock; \/\/ Needs saving, probably\n+  Register t2 = hdr;        \/\/ blow\n+  Register t3 = Rtemp;      \/\/ blow\n@@ -209,2 +209,2 @@\n-void C1_MacroAssembler::unlock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case) {\n-  assert_different_registers(hdr, obj, disp_hdr, Rtemp);\n+void C1_MacroAssembler::unlock_object(Register hdr, Register obj, Register basic_lock, Label& slow_case) {\n+  assert_different_registers(hdr, obj, basic_lock, Rtemp);\n@@ -215,1 +215,1 @@\n-  ldr(obj, Address(disp_hdr, BasicObjectLock::obj_offset()));\n+  ldr(obj, Address(basic_lock, BasicObjectLock::obj_offset()));\n@@ -217,3 +217,3 @@\n-  Register t1 = disp_hdr; \/\/ Needs saving, probably\n-  Register t2 = hdr;      \/\/ blow\n-  Register t3 = Rtemp;    \/\/ blow\n+  Register t1 = basic_lock; \/\/ Needs saving, probably\n+  Register t2 = hdr;        \/\/ blow\n+  Register t3 = Rtemp;      \/\/ blow\n","filename":"src\/hotspot\/cpu\/arm\/c1_MacroAssembler_arm.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-  int lock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case);\n+  int lock_object(Register hdr, Register obj, Register basic_lock, Label& slow_case);\n@@ -64,1 +64,1 @@\n-  void unlock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case);\n+  void unlock_object(Register hdr, Register obj, Register basic_lock, Label& slow_case);\n","filename":"src\/hotspot\/cpu\/arm\/c1_MacroAssembler_arm.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -201,8 +201,8 @@\n-static void generate_post_barrier_fast_path(MacroAssembler* masm,\n-                                            const Register store_addr,\n-                                            const Register new_val,\n-                                            const Register thread,\n-                                            const Register tmp1,\n-                                            const Register tmp2,\n-                                            Label& done,\n-                                            bool new_val_may_be_null) {\n+static void generate_post_barrier(MacroAssembler* masm,\n+                                  const Register store_addr,\n+                                  const Register new_val,\n+                                  const Register thread,\n+                                  const Register tmp1,\n+                                  const Register tmp2,\n+                                  Label& done,\n+                                  bool new_val_may_be_null) {\n@@ -248,1 +248,1 @@\n-  generate_post_barrier_fast_path(masm, store_addr, new_val, Rthread, tmp1, tmp2, done, true \/* new_val_may_be_null *\/);\n+  generate_post_barrier(masm, store_addr, new_val, Rthread, tmp1, tmp2, done, true \/* new_val_may_be_null *\/);\n@@ -310,1 +310,1 @@\n-  generate_post_barrier_fast_path(masm, store_addr, new_val, thread, tmp1, tmp2, done, new_val_may_be_null);\n+  generate_post_barrier(masm, store_addr, new_val, thread, tmp1, tmp2, done, new_val_may_be_null);\n@@ -411,1 +411,1 @@\n-  generate_post_barrier_fast_path(masm, store_addr, new_val, thread, tmp1, tmp2, done, true \/* new_val_may_be_null *\/);\n+  generate_post_barrier(masm, store_addr, new_val, thread, tmp1, tmp2, done, true \/* new_val_may_be_null *\/);\n","filename":"src\/hotspot\/cpu\/arm\/gc\/g1\/g1BarrierSetAssembler_arm.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -620,2 +620,2 @@\n-                                            AdapterHandlerEntry* handler) {\n-  address i2c_entry = __ pc();\n+                                            address entry_address[AdapterBlob::ENTRY_COUNT]) {\n+  entry_address[AdapterBlob::I2C] = __ pc();\n@@ -624,1 +624,1 @@\n-  address c2i_unverified_entry = __ pc();\n+  entry_address[AdapterBlob::C2I_Unverified] = __ pc();\n@@ -637,1 +637,2 @@\n-  address c2i_entry = __ pc();\n+  entry_address[AdapterBlob::C2I] = __ pc();\n+  entry_address[AdapterBlob::C2I_No_Clinit_Check] = nullptr;\n@@ -639,2 +640,0 @@\n-\n-  handler->set_entry_points(i2c_entry, c2i_entry, c2i_unverified_entry, nullptr);\n@@ -1132,1 +1131,1 @@\n-  const Register disp_hdr    = altFP_7_11;\n+  const Register basic_lock  = altFP_7_11;\n@@ -1143,1 +1142,1 @@\n-    __ lightweight_lock(sync_obj \/* object *\/, disp_hdr \/* t1 *\/, tmp \/* t2 *\/, Rtemp \/* t3 *\/,\n+    __ lightweight_lock(sync_obj \/* object *\/, basic_lock \/* t1 *\/, tmp \/* t2 *\/, Rtemp \/* t3 *\/,\n@@ -1258,1 +1257,1 @@\n-    __ mov(R1, disp_hdr);\n+    __ mov(R1, basic_lock);\n@@ -1273,1 +1272,1 @@\n-    assert_different_registers(Rtmp_save1, sync_obj, disp_hdr);\n+    assert_different_registers(Rtmp_save1, sync_obj, basic_lock);\n@@ -1278,1 +1277,1 @@\n-    __ mov(R1, disp_hdr);\n+    __ mov(R1, basic_lock);\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -271,3 +271,4 @@\n-  if (_compute_lock) {\n-    ce->monitor_address(_monitor_ix, _lock_reg);\n-  }\n+\n+  \/\/ lock_reg was destroyed by fast unlocking attempt => recompute it\n+  ce->monitor_address(_monitor_ix, _lock_reg);\n+\n","filename":"src\/hotspot\/cpu\/ppc\/c1_CodeStubs_ppc.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -230,1 +230,1 @@\n-    stub = new MonitorExitStub(FrameMap::R4_opr, true, 0);\n+    stub = new MonitorExitStub(FrameMap::R4_opr, 0);\n@@ -2617,1 +2617,0 @@\n-    assert(BasicLock::displaced_header_offset_in_bytes() == 0, \"lock_reg must point to the displaced header\");\n@@ -2629,1 +2628,0 @@\n-    assert(BasicLock::displaced_header_offset_in_bytes() == 0, \"lock_reg must point to the displaced header\");\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -232,8 +232,8 @@\n-static void generate_post_barrier_fast_path(MacroAssembler* masm,\n-                                            const Register store_addr,\n-                                            const Register new_val,\n-                                            const Register thread,\n-                                            const Register tmp1,\n-                                            const Register tmp2,\n-                                            Label& done,\n-                                            bool new_val_may_be_null) {\n+static void generate_post_barrier(MacroAssembler* masm,\n+                                  const Register store_addr,\n+                                  const Register new_val,\n+                                  const Register thread,\n+                                  const Register tmp1,\n+                                  const Register tmp2,\n+                                  Label& done,\n+                                  bool new_val_may_be_null) {\n@@ -276,1 +276,1 @@\n-  generate_post_barrier_fast_path(masm, store_addr, new_val, R16_thread, tmp1, tmp2, done, !not_null);\n+  generate_post_barrier(masm, store_addr, new_val, R16_thread, tmp1, tmp2, done, !not_null);\n@@ -453,1 +453,1 @@\n-  generate_post_barrier_fast_path(masm, store_addr, new_val_decoded, R16_thread, tmp1, tmp2, done, new_val_may_be_null);\n+  generate_post_barrier(masm, store_addr, new_val_decoded, R16_thread, tmp1, tmp2, done, new_val_may_be_null);\n@@ -501,1 +501,1 @@\n-  generate_post_barrier_fast_path(masm, store_addr, new_val, thread, tmp1, tmp2, done, true \/* new_val_may_be_null *\/);\n+  generate_post_barrier(masm, store_addr, new_val, thread, tmp1, tmp2, done, true \/* new_val_may_be_null *\/);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/g1\/g1BarrierSetAssembler_ppc.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -117,1 +117,0 @@\n-\n@@ -564,1 +563,0 @@\n-\n@@ -586,1 +584,0 @@\n-\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/z\/zBarrierSetAssembler_ppc.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1202,6 +1202,1 @@\n-                                            AdapterHandlerEntry* handler) {\n-  address i2c_entry;\n-  address c2i_unverified_entry;\n-  address c2i_entry;\n-\n-\n+                                            address entry_address[AdapterBlob::ENTRY_COUNT]) {\n@@ -1211,1 +1206,1 @@\n-  i2c_entry = __ pc();\n+  entry_address[AdapterBlob::I2C] = __ pc();\n@@ -1219,1 +1214,1 @@\n-  c2i_unverified_entry = __ pc();\n+  entry_address[AdapterBlob::C2I_Unverified] = __ pc();\n@@ -1247,1 +1242,1 @@\n-  c2i_entry = __ pc();\n+  entry_address[AdapterBlob::C2I] = __ pc();\n@@ -1250,1 +1245,1 @@\n-  address c2i_no_clinit_check_entry = nullptr;\n+  entry_address[AdapterBlob::C2I_No_Clinit_Check] = nullptr;\n@@ -1269,1 +1264,1 @@\n-    c2i_no_clinit_check_entry = __ pc();\n+    entry_address[AdapterBlob::C2I_No_Clinit_Check] = __ pc();\n@@ -1276,2 +1271,0 @@\n-\n-  handler->set_entry_points(i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":6,"deletions":13,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -207,4 +207,4 @@\n-  if (_compute_lock) {\n-    \/\/ lock_reg was destroyed by fast unlocking attempt => recompute it\n-    ce->monitor_address(_monitor_ix, _lock_reg);\n-  }\n+\n+  \/\/ lock_reg was destroyed by fast unlocking attempt => recompute it\n+  ce->monitor_address(_monitor_ix, _lock_reg);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c1_CodeStubs_riscv.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -341,1 +341,1 @@\n-    stub = new MonitorExitStub(FrameMap::r10_opr, true, 0);\n+    stub = new MonitorExitStub(FrameMap::r10_opr, 0);\n@@ -1497,1 +1497,0 @@\n-    assert(BasicLock::displaced_header_offset_in_bytes() == 0, \"lock_reg must point to the displaced header\");\n@@ -1504,1 +1503,0 @@\n-    assert(BasicLock::displaced_header_offset_in_bytes() == 0, \"lock_reg must point to the displaced header\");\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -51,2 +51,2 @@\n-int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Register temp, Label& slow_case) {\n-  assert_different_registers(hdr, obj, disp_hdr, temp, t0, t1);\n+int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register basic_lock, Register temp, Label& slow_case) {\n+  assert_different_registers(hdr, obj, basic_lock, temp, t0, t1);\n@@ -58,1 +58,1 @@\n-  sd(obj, Address(disp_hdr, BasicObjectLock::obj_offset()));\n+  sd(obj, Address(basic_lock, BasicObjectLock::obj_offset()));\n@@ -62,1 +62,1 @@\n-  lightweight_lock(disp_hdr, obj, hdr, temp, t1, slow_case);\n+  lightweight_lock(basic_lock, obj, hdr, temp, t1, slow_case);\n@@ -67,2 +67,2 @@\n-void C1_MacroAssembler::unlock_object(Register hdr, Register obj, Register disp_hdr, Register temp, Label& slow_case) {\n-  assert_different_registers(hdr, obj, disp_hdr, temp, t0, t1);\n+void C1_MacroAssembler::unlock_object(Register hdr, Register obj, Register basic_lock, Register temp, Label& slow_case) {\n+  assert_different_registers(hdr, obj, basic_lock, temp, t0, t1);\n@@ -71,1 +71,1 @@\n-  ld(obj, Address(disp_hdr, BasicObjectLock::obj_offset()));\n+  ld(obj, Address(basic_lock, BasicObjectLock::obj_offset()));\n","filename":"src\/hotspot\/cpu\/riscv\/c1_MacroAssembler_riscv.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,4 +59,4 @@\n-  \/\/ hdr     : must be x10, contents destroyed\n-  \/\/ obj     : must point to the object to lock, contents preserved\n-  \/\/ disp_hdr: must point to the displaced header location, contents preserved\n-  \/\/ temp : temporary register, must not be scratch register t0 or t1\n+  \/\/ hdr       : must be x10, contents destroyed\n+  \/\/ obj       : must point to the object to lock, contents preserved\n+  \/\/ basic_lock: must point to the basic_lock, contents preserved\n+  \/\/ temp      : temporary register, must not be scratch register t0 or t1\n@@ -64,1 +64,1 @@\n-  int lock_object(Register swap, Register obj, Register disp_hdr, Register temp, Label& slow_case);\n+  int lock_object(Register swap, Register obj, Register basic_lock, Register temp, Label& slow_case);\n@@ -67,5 +67,5 @@\n-  \/\/ hdr     : contents destroyed\n-  \/\/ obj     : must point to the object to lock, contents preserved\n-  \/\/ disp_hdr: must be x10 & must point to the displaced header location, contents destroyed\n-  \/\/ temp : temporary register, must not be scratch register t0 or t1\n-  void unlock_object(Register swap, Register obj, Register lock, Register temp, Label& slow_case);\n+  \/\/ hdr       : contents destroyed\n+  \/\/ obj       : must point to the object to lock, contents preserved\n+  \/\/ basic_lock: must be x10 & must point to the basic lock, contents destroyed\n+  \/\/ temp      : temporary register, must not be scratch register t0 or t1\n+  void unlock_object(Register swap, Register obj, Register basic_lock, Register temp, Label& slow_case);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_MacroAssembler_riscv.hpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -231,8 +231,8 @@\n-static void generate_post_barrier_fast_path(MacroAssembler* masm,\n-                                            const Register store_addr,\n-                                            const Register new_val,\n-                                            const Register thread,\n-                                            const Register tmp1,\n-                                            const Register tmp2,\n-                                            Label& done,\n-                                            bool new_val_may_be_null) {\n+static void generate_post_barrier(MacroAssembler* masm,\n+                                  const Register store_addr,\n+                                  const Register new_val,\n+                                  const Register thread,\n+                                  const Register tmp1,\n+                                  const Register tmp2,\n+                                  Label& done,\n+                                  bool new_val_may_be_null) {\n@@ -274,1 +274,1 @@\n-  generate_post_barrier_fast_path(masm, store_addr, new_val, thread, tmp1, tmp2, done, true \/* new_val_may_be_null *\/);\n+  generate_post_barrier(masm, store_addr, new_val, thread, tmp1, tmp2, done, true \/* new_val_may_be_null *\/);\n@@ -336,1 +336,1 @@\n-  generate_post_barrier_fast_path(masm, store_addr, new_val, thread, tmp1, tmp2, done, new_val_may_be_null);\n+  generate_post_barrier(masm, store_addr, new_val, thread, tmp1, tmp2, done, new_val_may_be_null);\n@@ -441,1 +441,1 @@\n-  generate_post_barrier_fast_path(masm, store_addr, new_val, thread, tmp1, tmp2, done, true \/* new_val_may_be_null *\/);\n+  generate_post_barrier(masm, store_addr, new_val, thread, tmp1, tmp2, done, true \/* new_val_may_be_null *\/);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/g1\/g1BarrierSetAssembler_riscv.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -605,2 +605,2 @@\n-                                            AdapterHandlerEntry* handler) {\n-  address i2c_entry = __ pc();\n+                                            address entry_address[AdapterBlob::ENTRY_COUNT]) {\n+  entry_address[AdapterBlob::I2C] = __ pc();\n@@ -609,1 +609,1 @@\n-  address c2i_unverified_entry = __ pc();\n+  entry_address[AdapterBlob::C2I_Unverified] = __ pc();\n@@ -636,1 +636,1 @@\n-  address c2i_entry = __ pc();\n+  entry_address[AdapterBlob::C2I] = __ pc();\n@@ -639,1 +639,1 @@\n-  address c2i_no_clinit_check_entry = nullptr;\n+  entry_address[AdapterBlob::C2I_No_Clinit_Check] = nullptr;\n@@ -654,1 +654,1 @@\n-    c2i_no_clinit_check_entry = __ pc();\n+    entry_address[AdapterBlob::C2I_No_Clinit_Check] = __ pc();\n@@ -661,2 +661,0 @@\n-\n-  handler->set_entry_points(i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);\n@@ -1682,2 +1680,0 @@\n-    const int mark_word_offset = BasicLock::displaced_header_offset_in_bytes();\n-\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -38,8 +38,17 @@\n-#define DEF_RV_FEATURE(NAME, PRETTY, BIT, FSTRING, FLAGF)       \\\n-VM_Version::NAME##RVFeatureValue VM_Version::NAME(PRETTY, BIT, FSTRING);\n-RV_FEATURE_FLAGS(DEF_RV_FEATURE)\n-\n-#define ADD_RV_FEATURE_IN_LIST(NAME, PRETTY, BIT, FSTRING, FLAGF) \\\n-    &VM_Version::NAME,\n-VM_Version::RVFeatureValue* VM_Version::_feature_list[] = {\n-RV_FEATURE_FLAGS(ADD_RV_FEATURE_IN_LIST)\n+#define DEF_RV_EXT_FEATURE(NAME, PRETTY, LINUX_BIT, FSTRING, FLAGF) \\\n+VM_Version::NAME##RVExtFeatureValue VM_Version::NAME;\n+RV_EXT_FEATURE_FLAGS(DEF_RV_EXT_FEATURE)\n+#undef DEF_RV_EXT_FEATURE\n+\n+#define DEF_RV_NON_EXT_FEATURE(NAME, PRETTY, LINUX_BIT, FSTRING, FLAGF) \\\n+VM_Version::NAME##RVNonExtFeatureValue VM_Version::NAME;\n+RV_NON_EXT_FEATURE_FLAGS(DEF_RV_NON_EXT_FEATURE)\n+#undef DEF_RV_NON_EXT_FEATURE\n+\n+#define ADD_RV_EXT_FEATURE_IN_LIST(NAME, PRETTY, LINUX_BIT, FSTRING, FLAGF) \\\n+     &VM_Version::NAME,\n+#define ADD_RV_NON_EXT_FEATURE_IN_LIST(NAME, PRETTY, LINUX_BIT, FSTRING, FLAGF) \\\n+     &VM_Version::NAME,\n+ VM_Version::RVFeatureValue* VM_Version::_feature_list[] = {\n+ RV_EXT_FEATURE_FLAGS(ADD_RV_EXT_FEATURE_IN_LIST)\n+ RV_NON_EXT_FEATURE_FLAGS(ADD_RV_NON_EXT_FEATURE_IN_LIST)\n@@ -47,0 +56,4 @@\n+#undef ADD_RV_NON_EXT_FEATURE_IN_LIST\n+#undef ADD_RV_EXT_FEATURE_IN_LIST\n+\n+VM_Version::RVExtFeatures* VM_Version::_rv_ext_features = new VM_Version::RVExtFeatures();\n@@ -480,4 +493,0 @@\n-\n-  if (FLAG_IS_DEFAULT(AlignVector)) {\n-    FLAG_SET_DEFAULT(AlignVector, AvoidUnalignedAccesses);\n-  }\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":21,"deletions":12,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -49,0 +49,2 @@\n+  class RVExtFeatures;\n+\n@@ -52,2 +54,1 @@\n-    const uint64_t    _feature_bit;\n-    bool              _enabled;\n+    const uint64_t    _linux_feature_bit;\n@@ -56,3 +57,3 @@\n-    RVFeatureValue(const char* pretty, int bit_num, bool fstring) :\n-      _pretty(pretty), _feature_string(fstring), _feature_bit(nth_bit(bit_num)),\n-      _enabled(false), _value(-1) {\n+    RVFeatureValue(const char* pretty, int linux_bit_num, bool fstring) :\n+      _pretty(pretty), _feature_string(fstring), _linux_feature_bit(nth_bit(linux_bit_num)),\n+      _value(-1) {\n@@ -60,2 +61,1 @@\n-    void enable_feature(int64_t value = 0) {\n-      _enabled = true;\n+    virtual void enable_feature(int64_t value = 0) {\n@@ -64,2 +64,1 @@\n-    void disable_feature() {\n-      _enabled = false;\n+    virtual void disable_feature() {\n@@ -69,1 +68,1 @@\n-    uint64_t feature_bit()       { return _feature_bit; }\n+    uint64_t feature_bit()       { return _linux_feature_bit; }\n@@ -71,1 +70,0 @@\n-    bool enabled()               { return _enabled; }\n@@ -73,0 +71,1 @@\n+    virtual bool enabled() = 0;\n@@ -114,0 +113,39 @@\n+\n+  class RVExtFeatureValue : public RVFeatureValue {\n+    const uint32_t _cpu_feature_index;\n+   public:\n+    RVExtFeatureValue(const char* pretty, int linux_bit_num, uint32_t cpu_feature_index, bool fstring) :\n+      RVFeatureValue(pretty, linux_bit_num, fstring),\n+      _cpu_feature_index(cpu_feature_index) {\n+    }\n+    bool enabled() {\n+      return RVExtFeatures::current()->support_feature(_cpu_feature_index);\n+    }\n+    void enable_feature(int64_t value = 0) {\n+      RVFeatureValue::enable_feature(value);\n+      RVExtFeatures::current()->set_feature(_cpu_feature_index);\n+    }\n+    void disable_feature() {\n+      RVFeatureValue::disable_feature();\n+      RVExtFeatures::current()->clear_feature(_cpu_feature_index);\n+    }\n+  };\n+\n+  class RVNonExtFeatureValue : public RVFeatureValue {\n+    bool _enabled;\n+   public:\n+    RVNonExtFeatureValue(const char* pretty, int linux_bit_num, bool fstring) :\n+      RVFeatureValue(pretty, linux_bit_num, fstring),\n+      _enabled(false) {\n+    }\n+    bool enabled()               { return _enabled; }\n+    void enable_feature(int64_t value = 0) {\n+      RVFeatureValue::enable_feature(value);\n+      _enabled = true;\n+    }\n+    void disable_feature() {\n+      RVFeatureValue::disable_feature();\n+      _enabled = false;\n+    }\n+  };\n+\n@@ -164,52 +202,134 @@\n-  \/\/ declaration name  , extension name, bit pos       ,in str, mapped flag)\n-  #define RV_FEATURE_FLAGS(decl)                                                                        \\\n-  decl(ext_I            , \"i\"              ,    ('I' - 'A'), true , NO_UPDATE_DEFAULT)                  \\\n-  decl(ext_M            , \"m\"              ,    ('M' - 'A'), true , NO_UPDATE_DEFAULT)                  \\\n-  decl(ext_A            , \"a\"              ,    ('A' - 'A'), true , NO_UPDATE_DEFAULT)                  \\\n-  decl(ext_F            , \"f\"              ,    ('F' - 'A'), true , NO_UPDATE_DEFAULT)                  \\\n-  decl(ext_D            , \"d\"              ,    ('D' - 'A'), true , NO_UPDATE_DEFAULT)                  \\\n-  decl(ext_C            , \"c\"              ,    ('C' - 'A'), true , UPDATE_DEFAULT(UseRVC))             \\\n-  decl(ext_Q            , \"q\"              ,    ('Q' - 'A'), true , NO_UPDATE_DEFAULT)                  \\\n-  decl(ext_H            , \"h\"              ,    ('H' - 'A'), true , NO_UPDATE_DEFAULT)                  \\\n-  decl(ext_V            , \"v\"              ,    ('V' - 'A'), true , UPDATE_DEFAULT(UseRVV))             \\\n-  decl(ext_Zicbom       , \"Zicbom\"         , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZicbom))          \\\n-  decl(ext_Zicboz       , \"Zicboz\"         , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZicboz))          \\\n-  decl(ext_Zicbop       , \"Zicbop\"         , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZicbop))          \\\n-  decl(ext_Zba          , \"Zba\"            , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZba))             \\\n-  decl(ext_Zbb          , \"Zbb\"            , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZbb))             \\\n-  decl(ext_Zbc          , \"Zbc\"            , RV_NO_FLAG_BIT, true , NO_UPDATE_DEFAULT)                  \\\n-  decl(ext_Zbs          , \"Zbs\"            , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZbs))             \\\n-  decl(ext_Zbkb         , \"Zbkb\"           , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZbkb))            \\\n-  decl(ext_Zcb          , \"Zcb\"            , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZcb))             \\\n-  decl(ext_Zfa          , \"Zfa\"            , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZfa))             \\\n-  decl(ext_Zfh          , \"Zfh\"            , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZfh))             \\\n-  decl(ext_Zfhmin       , \"Zfhmin\"         , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZfhmin))          \\\n-  decl(ext_Zicsr        , \"Zicsr\"          , RV_NO_FLAG_BIT, true , NO_UPDATE_DEFAULT)                  \\\n-  decl(ext_Zicntr       , \"Zicntr\"         , RV_NO_FLAG_BIT, true , NO_UPDATE_DEFAULT)                  \\\n-  decl(ext_Zifencei     , \"Zifencei\"       , RV_NO_FLAG_BIT, true , NO_UPDATE_DEFAULT)                  \\\n-  decl(ext_Zic64b       , \"Zic64b\"         , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZic64b))          \\\n-  decl(ext_Ztso         , \"Ztso\"           , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZtso))            \\\n-  decl(ext_Zihintpause  , \"Zihintpause\"    , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZihintpause))     \\\n-  decl(ext_Zacas        , \"Zacas\"          , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZacas))           \\\n-  decl(ext_Zvbb         , \"Zvbb\"           , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT_DEP(UseZvbb, ext_V)) \\\n-  decl(ext_Zvbc         , \"Zvbc\"           , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT_DEP(UseZvbc, ext_V)) \\\n-  decl(ext_Zvfh         , \"Zvfh\"           , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT_DEP(UseZvfh, ext_V)) \\\n-  decl(ext_Zvkn         , \"Zvkn\"           , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT_DEP(UseZvkn, ext_V)) \\\n-  decl(ext_Zicond       , \"Zicond\"         , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZicond))          \\\n-  decl(mvendorid        , \"VendorId\"       , RV_NO_FLAG_BIT, false, NO_UPDATE_DEFAULT)                  \\\n-  decl(marchid          , \"ArchId\"         , RV_NO_FLAG_BIT, false, NO_UPDATE_DEFAULT)                  \\\n-  decl(mimpid           , \"ImpId\"          , RV_NO_FLAG_BIT, false, NO_UPDATE_DEFAULT)                  \\\n-  decl(unaligned_access , \"Unaligned\"      , RV_NO_FLAG_BIT, false, NO_UPDATE_DEFAULT)                  \\\n-  decl(satp_mode        , \"SATP\"           , RV_NO_FLAG_BIT, false, NO_UPDATE_DEFAULT)                  \\\n-  decl(zicboz_block_size, \"ZicbozBlockSize\", RV_NO_FLAG_BIT, false, NO_UPDATE_DEFAULT)                  \\\n-\n-  #define DECLARE_RV_FEATURE(NAME, PRETTY, BIT, FSTRING, FLAGF)        \\\n-  struct NAME##RVFeatureValue : public RVFeatureValue {                \\\n-    NAME##RVFeatureValue(const char* pretty, int bit, bool fstring) :  \\\n-      RVFeatureValue(pretty, bit, fstring) {}                          \\\n-    FLAGF;                                                             \\\n-  };                                                                   \\\n-  static NAME##RVFeatureValue NAME;                                    \\\n-\n-  RV_FEATURE_FLAGS(DECLARE_RV_FEATURE)\n-  #undef DECLARE_RV_FEATURE\n+  \/\/\n+  \/\/ Fields description in `decl`:\n+  \/\/    declaration name, extension name, bit value from linux, feature string?, mapped flag)\n+  #define RV_EXT_FEATURE_FLAGS(decl)                                                                   \\\n+  decl(ext_I            ,  i           ,     ('I' - 'A'),  true ,  NO_UPDATE_DEFAULT)                  \\\n+  decl(ext_M            ,  m           ,     ('M' - 'A'),  true ,  NO_UPDATE_DEFAULT)                  \\\n+  decl(ext_A            ,  a           ,     ('A' - 'A'),  true ,  NO_UPDATE_DEFAULT)                  \\\n+  decl(ext_F            ,  f           ,     ('F' - 'A'),  true ,  NO_UPDATE_DEFAULT)                  \\\n+  decl(ext_D            ,  d           ,     ('D' - 'A'),  true ,  NO_UPDATE_DEFAULT)                  \\\n+  decl(ext_C            ,  c           ,     ('C' - 'A'),  true ,  UPDATE_DEFAULT(UseRVC))             \\\n+  decl(ext_Q            ,  q           ,     ('Q' - 'A'),  true ,  NO_UPDATE_DEFAULT)                  \\\n+  decl(ext_H            ,  h           ,     ('H' - 'A'),  true ,  NO_UPDATE_DEFAULT)                  \\\n+  decl(ext_V            ,  v           ,     ('V' - 'A'),  true ,  UPDATE_DEFAULT(UseRVV))             \\\n+  decl(ext_Zicbom       ,  Zicbom      ,  RV_NO_FLAG_BIT,  true ,  UPDATE_DEFAULT(UseZicbom))          \\\n+  decl(ext_Zicboz       ,  Zicboz      ,  RV_NO_FLAG_BIT,  true ,  UPDATE_DEFAULT(UseZicboz))          \\\n+  decl(ext_Zicbop       ,  Zicbop      ,  RV_NO_FLAG_BIT,  true ,  UPDATE_DEFAULT(UseZicbop))          \\\n+  decl(ext_Zba          ,  Zba         ,  RV_NO_FLAG_BIT,  true ,  UPDATE_DEFAULT(UseZba))             \\\n+  decl(ext_Zbb          ,  Zbb         ,  RV_NO_FLAG_BIT,  true ,  UPDATE_DEFAULT(UseZbb))             \\\n+  decl(ext_Zbc          ,  Zbc         ,  RV_NO_FLAG_BIT,  true ,  NO_UPDATE_DEFAULT)                  \\\n+  decl(ext_Zbs          ,  Zbs         ,  RV_NO_FLAG_BIT,  true ,  UPDATE_DEFAULT(UseZbs))             \\\n+  decl(ext_Zbkb         ,  Zbkb        ,  RV_NO_FLAG_BIT,  true ,  UPDATE_DEFAULT(UseZbkb))            \\\n+  decl(ext_Zcb          ,  Zcb         ,  RV_NO_FLAG_BIT,  true ,  UPDATE_DEFAULT(UseZcb))             \\\n+  decl(ext_Zfa          ,  Zfa         ,  RV_NO_FLAG_BIT,  true ,  UPDATE_DEFAULT(UseZfa))             \\\n+  decl(ext_Zfh          ,  Zfh         ,  RV_NO_FLAG_BIT,  true ,  UPDATE_DEFAULT(UseZfh))             \\\n+  decl(ext_Zfhmin       ,  Zfhmin      ,  RV_NO_FLAG_BIT,  true ,  UPDATE_DEFAULT(UseZfhmin))          \\\n+  decl(ext_Zicsr        ,  Zicsr       ,  RV_NO_FLAG_BIT,  true ,  NO_UPDATE_DEFAULT)                  \\\n+  decl(ext_Zicntr       ,  Zicntr      ,  RV_NO_FLAG_BIT,  true ,  NO_UPDATE_DEFAULT)                  \\\n+  decl(ext_Zifencei     ,  Zifencei    ,  RV_NO_FLAG_BIT,  true ,  NO_UPDATE_DEFAULT)                  \\\n+  decl(ext_Zic64b       ,  Zic64b      ,  RV_NO_FLAG_BIT,  true ,  UPDATE_DEFAULT(UseZic64b))          \\\n+  decl(ext_Ztso         ,  Ztso        ,  RV_NO_FLAG_BIT,  true ,  UPDATE_DEFAULT(UseZtso))            \\\n+  decl(ext_Zihintpause  ,  Zihintpause ,  RV_NO_FLAG_BIT,  true ,  UPDATE_DEFAULT(UseZihintpause))     \\\n+  decl(ext_Zacas        ,  Zacas       ,  RV_NO_FLAG_BIT,  true ,  UPDATE_DEFAULT(UseZacas))           \\\n+  decl(ext_Zvbb         ,  Zvbb        ,  RV_NO_FLAG_BIT,  true ,  UPDATE_DEFAULT_DEP(UseZvbb, ext_V)) \\\n+  decl(ext_Zvbc         ,  Zvbc        ,  RV_NO_FLAG_BIT,  true ,  UPDATE_DEFAULT_DEP(UseZvbc, ext_V)) \\\n+  decl(ext_Zvfh         ,  Zvfh        ,  RV_NO_FLAG_BIT,  true ,  UPDATE_DEFAULT_DEP(UseZvfh, ext_V)) \\\n+  decl(ext_Zvkn         ,  Zvkn        ,  RV_NO_FLAG_BIT,  true ,  UPDATE_DEFAULT_DEP(UseZvkn, ext_V)) \\\n+  decl(ext_Zicond       ,  Zicond      ,  RV_NO_FLAG_BIT,  true ,  UPDATE_DEFAULT(UseZicond))          \\\n+\n+  #define DECLARE_RV_EXT_FEATURE(NAME, PRETTY, LINUX_BIT, FSTRING, FLAGF)               \\\n+  struct NAME##RVExtFeatureValue : public RVExtFeatureValue {                           \\\n+    NAME##RVExtFeatureValue() :                                                         \\\n+      RVExtFeatureValue(#PRETTY, LINUX_BIT, RVExtFeatures::CPU_##NAME, FSTRING) {}      \\\n+    FLAGF;                                                                              \\\n+  };                                                                                    \\\n+  static NAME##RVExtFeatureValue NAME;                                                  \\\n+\n+  RV_EXT_FEATURE_FLAGS(DECLARE_RV_EXT_FEATURE)\n+  #undef DECLARE_RV_EXT_FEATURE\n+\n+  \/\/ Non-extension features\n+  \/\/\n+  #define RV_NON_EXT_FEATURE_FLAGS(decl)                                                       \\\n+  decl(unaligned_access ,  Unaligned       ,  RV_NO_FLAG_BIT,  false,  NO_UPDATE_DEFAULT)      \\\n+  decl(mvendorid        ,  VendorId        ,  RV_NO_FLAG_BIT,  false,  NO_UPDATE_DEFAULT)      \\\n+  decl(marchid          ,  ArchId          ,  RV_NO_FLAG_BIT,  false,  NO_UPDATE_DEFAULT)      \\\n+  decl(mimpid           ,  ImpId           ,  RV_NO_FLAG_BIT,  false,  NO_UPDATE_DEFAULT)      \\\n+  decl(satp_mode        ,  SATP            ,  RV_NO_FLAG_BIT,  false,  NO_UPDATE_DEFAULT)      \\\n+  decl(zicboz_block_size,  ZicbozBlockSize ,  RV_NO_FLAG_BIT,  false,  NO_UPDATE_DEFAULT)      \\\n+\n+  #define DECLARE_RV_NON_EXT_FEATURE(NAME, PRETTY, LINUX_BIT, FSTRING, FLAGF)      \\\n+  struct NAME##RVNonExtFeatureValue : public RVNonExtFeatureValue {                \\\n+    NAME##RVNonExtFeatureValue() :                                                 \\\n+      RVNonExtFeatureValue(#PRETTY, LINUX_BIT, FSTRING) {}                         \\\n+    FLAGF;                                                                         \\\n+  };                                                                               \\\n+  static NAME##RVNonExtFeatureValue NAME;                                          \\\n+\n+  RV_NON_EXT_FEATURE_FLAGS(DECLARE_RV_NON_EXT_FEATURE)\n+  #undef DECLARE_RV_NON_EXT_FEATURE\n+\n+private:\n+  \/\/ Utility for AOT CPU feature store\/check.\n+  class RVExtFeatures : public CHeapObj<mtCode> {\n+   public:\n+    enum RVFeatureIndex {\n+      #define DECLARE_RV_FEATURE_ENUM(NAME, PRETTY, LINUX_BIT, FSTRING, FLAGF) CPU_##NAME,\n+\n+      RV_EXT_FEATURE_FLAGS(DECLARE_RV_FEATURE_ENUM)\n+      MAX_CPU_FEATURE_INDEX\n+      #undef DECLARE_RV_FEATURE_ENUM\n+    };\n+   private:\n+    uint64_t _features_bitmap[(MAX_CPU_FEATURE_INDEX \/ BitsPerLong) + 1];\n+    STATIC_ASSERT(sizeof(_features_bitmap) * BitsPerByte >= MAX_CPU_FEATURE_INDEX);\n+\n+    \/\/ Number of 8-byte elements in _features_bitmap.\n+    constexpr static int element_count() {\n+      return sizeof(_features_bitmap) \/ sizeof(uint64_t);\n+    }\n+\n+    static int element_index(RVFeatureIndex feature) {\n+      int idx = feature \/ BitsPerLong;\n+      assert(idx < element_count(), \"Features array index out of bounds\");\n+      return idx;\n+    }\n+\n+    static uint64_t feature_bit(RVFeatureIndex feature) {\n+      return (1ULL << (feature % BitsPerLong));\n+    }\n+\n+    static RVFeatureIndex convert(uint32_t index) {\n+      assert(index < MAX_CPU_FEATURE_INDEX, \"must\");\n+      return (RVFeatureIndex)index;\n+    }\n+\n+   public:\n+    static RVExtFeatures* current() {\n+      return _rv_ext_features;\n+    }\n+\n+    RVExtFeatures() {\n+      for (int i = 0; i < element_count(); i++) {\n+        _features_bitmap[i] = 0;\n+      }\n+    }\n+\n+    void set_feature(uint32_t feature) {\n+      RVFeatureIndex f = convert(feature);\n+      int idx = element_index(f);\n+      _features_bitmap[idx] |= feature_bit(f);\n+    }\n+\n+    void clear_feature(uint32_t feature) {\n+      RVFeatureIndex f = convert(feature);\n+      int idx = element_index(f);\n+      _features_bitmap[idx] &= ~feature_bit(f);\n+    }\n+\n+    bool support_feature(uint32_t feature) {\n+      RVFeatureIndex f = convert(feature);\n+      int idx = element_index(f);\n+      return (_features_bitmap[idx] & feature_bit(f)) != 0;\n+    }\n+  };\n@@ -289,0 +409,1 @@\n+  static RVExtFeatures* _rv_ext_features;\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":184,"deletions":63,"binary":false,"changes":247,"status":"modified"},{"patch":"@@ -237,6 +237,4 @@\n-  if (_compute_lock) {\n-    \/\/ Lock_reg was destroyed by fast unlocking attempt => recompute it.\n-    ce->monitor_address(_monitor_ix, FrameMap::as_opr(Z_R1_scratch));\n-  } else {\n-    __ lgr_if_needed(Z_R1_scratch, _lock_reg->as_register());\n-  }\n+\n+  \/\/ Lock_reg was destroyed by fast unlocking attempt => recompute it.\n+  ce->monitor_address(_monitor_ix, FrameMap::as_opr(Z_R1_scratch));\n+\n","filename":"src\/hotspot\/cpu\/s390\/c1_CodeStubs_s390.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -231,1 +231,1 @@\n-    stub = new MonitorExitStub(lock, true, 0);\n+    stub = new MonitorExitStub(lock, 0);\n@@ -2714,1 +2714,0 @@\n-    assert(BasicLock::displaced_header_offset_in_bytes() == 0, \"lock_reg must point to the displaced header\");\n@@ -2722,1 +2721,0 @@\n-    assert(BasicLock::displaced_header_offset_in_bytes() == 0, \"lock_reg must point to the displaced header\");\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,2 +48,1 @@\n-\/\/ 10 prevents spill-split-recycle sanity check in JVM2008.xml.transform.\n-define_pd_global(intx, InteriorEntryAlignment,       2);\n+define_pd_global(intx, InteriorEntryAlignment,       4);\n","filename":"src\/hotspot\/cpu\/s390\/c2_globals_s390.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -207,8 +207,8 @@\n-static void generate_post_barrier_fast_path(MacroAssembler* masm,\n-                                            const Register store_addr,\n-                                            const Register new_val,\n-                                            const Register thread,\n-                                            const Register tmp1,\n-                                            const Register tmp2,\n-                                            Label& done,\n-                                            bool new_val_may_be_null) {\n+static void generate_post_barrier(MacroAssembler* masm,\n+                                  const Register store_addr,\n+                                  const Register new_val,\n+                                  const Register thread,\n+                                  const Register tmp1,\n+                                  const Register tmp2,\n+                                  Label& done,\n+                                  bool new_val_may_be_null) {\n@@ -216,1 +216,1 @@\n-  __ block_comment(\"generate_post_barrier_fast_path {\");\n+  __ block_comment(\"generate_post_barrier {\");\n@@ -255,1 +255,1 @@\n-  __ block_comment(\"} generate_post_barrier_fast_path\");\n+  __ block_comment(\"} generate_post_barrier\");\n@@ -267,1 +267,1 @@\n-  generate_post_barrier_fast_path(masm, store_addr, new_val, thread, tmp1, tmp2, done, new_val_may_be_null);\n+  generate_post_barrier(masm, store_addr, new_val, thread, tmp1, tmp2, done, new_val_may_be_null);\n@@ -421,1 +421,1 @@\n-  generate_post_barrier_fast_path(masm, Rstore_addr, Rnew_val, Z_thread, Rtmp1, Rtmp2, done, !not_null);\n+  generate_post_barrier(masm, Rstore_addr, Rnew_val, Z_thread, Rtmp1, Rtmp2, done, !not_null);\n@@ -503,1 +503,1 @@\n-   generate_post_barrier_fast_path(masm, store_addr, new_val, thread, tmp1, tmp2, done, true \/* new_val_may_be_null *\/);\n+   generate_post_barrier(masm, store_addr, new_val, thread, tmp1, tmp2, done, true \/* new_val_may_be_null *\/);\n","filename":"src\/hotspot\/cpu\/s390\/gc\/g1\/g1BarrierSetAssembler_s390.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1950,0 +1950,1 @@\n+  \/\/ 10 prevents spill-split-recycle sanity check in JVM2008.xml.transform.\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2350,1 +2350,1 @@\n-                                            AdapterHandlerEntry* handler) {\n+                                            address entry_address[AdapterBlob::ENTRY_COUNT]) {\n@@ -2352,1 +2352,1 @@\n-  address i2c_entry = __ pc();\n+  entry_address[AdapterBlob::I2C] = __ pc();\n@@ -2355,2 +2355,0 @@\n-  address c2i_unverified_entry;\n-\n@@ -2366,1 +2364,1 @@\n-    c2i_unverified_entry = __ pc();\n+    entry_address[AdapterBlob::C2I_Unverified] = __ pc();\n@@ -2379,1 +2377,1 @@\n-  address c2i_entry = __ pc();\n+  entry_address[AdapterBlob::C2I] = __ pc();\n@@ -2382,1 +2380,1 @@\n-  address c2i_no_clinit_check_entry = nullptr;\n+  entry_address[AdapterBlob::C2I_No_Clinit_Check] = nullptr;\n@@ -2399,1 +2397,1 @@\n-    c2i_no_clinit_check_entry = __ pc();\n+    entry_address[AdapterBlob::C2I_No_Clinit_Check] = __ pc();\n@@ -2403,2 +2401,0 @@\n-\n-  handler->set_entry_points(i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2228,0 +2228,38 @@\n+void Assembler::evcvttss2sisl(Register dst, XMMRegister src) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x6D, (0xC0 | encode));\n+}\n+\n+void Assembler::evcvttss2sisl(Register dst, Address src) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_32bit);\n+  attributes.set_is_evex_instruction();\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8((unsigned char)0x6D);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evcvttss2sisq(Register dst, XMMRegister src) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x6D, (0xC0 | encode));\n+}\n+\n+void Assembler::evcvttss2sisq(Register dst, Address src) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_32bit);\n+  attributes.set_is_evex_instruction();\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8((unsigned char)0x6D);\n+  emit_operand(dst, src, 0);\n+}\n+\n@@ -2313,0 +2351,19 @@\n+void Assembler::evcvttps2dqs(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x6D, (0xC0 | encode));\n+}\n+\n+void Assembler::evcvttps2dqs(XMMRegister dst, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_32bit);\n+  attributes.set_is_evex_instruction();\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8((unsigned char)0x6D);\n+  emit_operand(dst, src, 0);\n+}\n+\n@@ -2320,0 +2377,19 @@\n+void Assembler::evcvttpd2dqs(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x6D, (0xC0 | encode));\n+}\n+\n+void Assembler::evcvttpd2dqs(XMMRegister dst, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_64bit);\n+  attributes.set_is_evex_instruction();\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8((unsigned char)0x6D);\n+  emit_operand(dst, src, 0);\n+}\n+\n@@ -2335,0 +2411,19 @@\n+void Assembler::evcvttps2qqs(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x6D, (0xC0 | encode));\n+}\n+\n+void Assembler::evcvttps2qqs(XMMRegister dst, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_HV, \/* input_size_in_bits *\/ EVEX_32bit);\n+  attributes.set_is_evex_instruction();\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8((unsigned char)0x6D);\n+  emit_operand(dst, src, 0);\n+}\n+\n@@ -2359,0 +2454,19 @@\n+void Assembler::evcvttpd2qqs(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x6D, (0xC0 | encode));\n+}\n+\n+void Assembler::evcvttpd2qqs(XMMRegister dst, Address src, int vector_len) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_64bit);\n+  attributes.set_is_evex_instruction();\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8((unsigned char)0x6D);\n+  emit_operand(dst, src, 0);\n+}\n+\n@@ -14991,0 +15105,38 @@\n+void Assembler::evcvttsd2sisl(Register dst, XMMRegister src) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F2, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x6D, (0xC0 | encode));\n+}\n+\n+void Assembler::evcvttsd2sisl(Register dst, Address src) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_64bit);\n+  attributes.set_is_evex_instruction();\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_F2, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8((unsigned char)0x6D);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evcvttsd2sisq(Register dst, XMMRegister src) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F2, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x6D, (0xC0 | encode));\n+}\n+\n+void Assembler::evcvttsd2sisq(Register dst, Address src) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_64bit);\n+  attributes.set_is_evex_instruction();\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_F2, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8((unsigned char)0x6D);\n+  emit_operand(dst, src, 0);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":152,"deletions":0,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -1319,0 +1319,4 @@\n+  void evcvttsd2sisl(Register dst, XMMRegister src);\n+  void evcvttsd2sisl(Register dst, Address src);\n+  void evcvttsd2sisq(Register dst, XMMRegister src);\n+  void evcvttsd2sisq(Register dst, Address src);\n@@ -1324,0 +1328,4 @@\n+  void evcvttss2sisl(Register dst, XMMRegister src);\n+  void evcvttss2sisl(Register dst, Address src);\n+  void evcvttss2sisq(Register dst, XMMRegister src);\n+  void evcvttss2sisq(Register dst, Address src);\n@@ -1335,0 +1343,2 @@\n+  void evcvttps2dqs(XMMRegister dst, XMMRegister src, int vector_len);\n+  void evcvttps2dqs(XMMRegister dst, Address src, int vector_len);\n@@ -1336,0 +1346,2 @@\n+  void evcvttps2qqs(XMMRegister dst, XMMRegister src, int vector_len);\n+  void evcvttps2qqs(XMMRegister dst, Address src, int vector_len);\n@@ -1344,0 +1356,2 @@\n+  void evcvttpd2qqs(XMMRegister dst, XMMRegister src, int vector_len);\n+  void evcvttpd2qqs(XMMRegister dst, Address src, int vector_len);\n@@ -1347,0 +1361,2 @@\n+  void evcvttpd2dqs(XMMRegister dst, XMMRegister src, int vector_len);\n+  void evcvttpd2dqs(XMMRegister dst, Address src, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -210,4 +210,4 @@\n-  if (_compute_lock) {\n-    \/\/ lock_reg was destroyed by fast unlocking attempt => recompute it\n-    ce->monitor_address(_monitor_ix, _lock_reg);\n-  }\n+\n+  \/\/ lock_reg was destroyed by fast unlocking attempt => recompute it\n+  ce->monitor_address(_monitor_ix, _lock_reg);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c1_CodeStubs_x86.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -415,1 +415,1 @@\n-    stub = new MonitorExitStub(FrameMap::rax_opr, true, 0);\n+    stub = new MonitorExitStub(FrameMap::rax_opr, 0);\n@@ -2733,1 +2733,0 @@\n-    assert(BasicLock::displaced_header_offset_in_bytes() == 0, \"lock_reg must point to the displaced header\");\n@@ -2742,1 +2741,0 @@\n-    assert(BasicLock::displaced_header_offset_in_bytes() == 0, \"lock_reg must point to the displaced header\");\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Register tmp, Label& slow_case) {\n+int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register basic_lock, Register tmp, Label& slow_case) {\n@@ -46,1 +46,1 @@\n-  assert_different_registers(hdr, obj, disp_hdr, tmp);\n+  assert_different_registers(hdr, obj, basic_lock, tmp);\n@@ -52,1 +52,1 @@\n-  movptr(Address(disp_hdr, BasicObjectLock::obj_offset()), obj);\n+  movptr(Address(basic_lock, BasicObjectLock::obj_offset()), obj);\n@@ -56,1 +56,1 @@\n-  lightweight_lock(disp_hdr, obj, hdr, tmp, slow_case);\n+  lightweight_lock(basic_lock, obj, hdr, tmp, slow_case);\n@@ -61,3 +61,3 @@\n-void C1_MacroAssembler::unlock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case) {\n-  assert(disp_hdr == rax, \"disp_hdr must be rax, for the cmpxchg instruction\");\n-  assert(hdr != obj && hdr != disp_hdr && obj != disp_hdr, \"registers must be different\");\n+void C1_MacroAssembler::unlock_object(Register hdr, Register obj, Register basic_lock, Label& slow_case) {\n+  assert(basic_lock == rax, \"basic_lock must be rax, for the cmpxchg instruction\");\n+  assert(hdr != obj && hdr != basic_lock && obj != basic_lock, \"registers must be different\");\n@@ -66,1 +66,1 @@\n-  movptr(obj, Address(disp_hdr, BasicObjectLock::obj_offset()));\n+  movptr(obj, Address(basic_lock, BasicObjectLock::obj_offset()));\n@@ -69,1 +69,1 @@\n-  lightweight_unlock(obj, disp_hdr, hdr, slow_case);\n+  lightweight_unlock(obj, rax, hdr, slow_case);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,3 +49,3 @@\n-  \/\/ hdr     : must be rax, contents destroyed\n-  \/\/ obj     : must point to the object to lock, contents preserved\n-  \/\/ disp_hdr: must point to the displaced header location, contents preserved\n+  \/\/ hdr       : must be rax, contents destroyed\n+  \/\/ obj       : must point to the object to lock, contents preserved\n+  \/\/ basic_lock: must point to the basic lock, contents preserved\n@@ -53,1 +53,1 @@\n-  int lock_object  (Register swap, Register obj, Register disp_hdr, Register tmp, Label& slow_case);\n+  int lock_object  (Register swap, Register obj, Register basic_lock, Register tmp, Label& slow_case);\n@@ -56,4 +56,4 @@\n-  \/\/ hdr     : contents destroyed\n-  \/\/ obj     : must point to the object to lock, contents preserved\n-  \/\/ disp_hdr: must be eax & must point to the displaced header location, contents destroyed\n-  void unlock_object(Register swap, Register obj, Register lock, Label& slow_case);\n+  \/\/ hdr       : contents destroyed\n+  \/\/ obj       : must point to the object to lock, contents preserved\n+  \/\/ basic_lock: must be eax & must point to the basic lock, contents destroyed\n+  void unlock_object(Register swap, Register obj, Register basic_lock, Label& slow_case);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -5056,1 +5056,1 @@\n-    default: assert(false, \"%s\", type2name(to_elem_bt));\n+    default: assert(false, \"Unexpected basic type for target of vector cast int to subword: %s\", type2name(to_elem_bt));\n@@ -5061,1 +5061,1 @@\n- * Algorithm for vector D2L and F2I conversions:-\n+ * Algorithm for vector D2L and F2I conversions (AVX 10.2 unsupported):-\n@@ -5099,1 +5099,1 @@\n-    default: assert(false, \"%s\", type2name(to_elem_bt));\n+    default: assert(false, \"Unexpected basic type for target of vector castF2X EVEX: %s\", type2name(to_elem_bt));\n@@ -5146,1 +5146,1 @@\n-      default: assert(false, \"%s\", type2name(to_elem_bt));\n+      default: assert(false, \"Unexpected basic type for target of vector castD2X AVX512DQ EVEX: %s\", type2name(to_elem_bt));\n@@ -5161,1 +5161,1 @@\n-      default: assert(false, \"%s\", type2name(to_elem_bt));\n+      default: assert(false, \"Unexpected basic type for target of vector castD2X EVEX: %s\", type2name(to_elem_bt));\n@@ -5166,0 +5166,80 @@\n+void C2_MacroAssembler::vector_castF2X_avx10(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, int vec_enc) {\n+  switch(to_elem_bt) {\n+    case T_LONG:\n+      evcvttps2qqs(dst, src, vec_enc);\n+      break;\n+    case T_INT:\n+      evcvttps2dqs(dst, src, vec_enc);\n+      break;\n+    case T_SHORT:\n+      evcvttps2dqs(dst, src, vec_enc);\n+      evpmovdw(dst, dst, vec_enc);\n+      break;\n+    case T_BYTE:\n+      evcvttps2dqs(dst, src, vec_enc);\n+      evpmovdb(dst, dst, vec_enc);\n+      break;\n+    default: assert(false, \"Unexpected basic type for target of vector castF2X AVX10 (reg src): %s\", type2name(to_elem_bt));\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_castF2X_avx10(BasicType to_elem_bt, XMMRegister dst, Address src, int vec_enc) {\n+  switch(to_elem_bt) {\n+    case T_LONG:\n+      evcvttps2qqs(dst, src, vec_enc);\n+      break;\n+    case T_INT:\n+      evcvttps2dqs(dst, src, vec_enc);\n+      break;\n+    case T_SHORT:\n+      evcvttps2dqs(dst, src, vec_enc);\n+      evpmovdw(dst, dst, vec_enc);\n+      break;\n+    case T_BYTE:\n+      evcvttps2dqs(dst, src, vec_enc);\n+      evpmovdb(dst, dst, vec_enc);\n+      break;\n+    default: assert(false, \"Unexpected basic type for target of vector castF2X AVX10 (mem src): %s\", type2name(to_elem_bt));\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_castD2X_avx10(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, int vec_enc) {\n+  switch(to_elem_bt) {\n+    case T_LONG:\n+      evcvttpd2qqs(dst, src, vec_enc);\n+      break;\n+    case T_INT:\n+      evcvttpd2dqs(dst, src, vec_enc);\n+      break;\n+    case T_SHORT:\n+      evcvttpd2dqs(dst, src, vec_enc);\n+      evpmovdw(dst, dst, vec_enc);\n+      break;\n+    case T_BYTE:\n+      evcvttpd2dqs(dst, src, vec_enc);\n+      evpmovdb(dst, dst, vec_enc);\n+      break;\n+    default: assert(false, \"Unexpected basic type for target of vector castD2X AVX10 (reg src): %s\", type2name(to_elem_bt));\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_castD2X_avx10(BasicType to_elem_bt, XMMRegister dst, Address src, int vec_enc) {\n+  switch(to_elem_bt) {\n+    case T_LONG:\n+      evcvttpd2qqs(dst, src, vec_enc);\n+      break;\n+    case T_INT:\n+      evcvttpd2dqs(dst, src, vec_enc);\n+      break;\n+    case T_SHORT:\n+      evcvttpd2dqs(dst, src, vec_enc);\n+      evpmovdw(dst, dst, vec_enc);\n+      break;\n+    case T_BYTE:\n+      evcvttpd2dqs(dst, src, vec_enc);\n+      evpmovdb(dst, dst, vec_enc);\n+      break;\n+    default: assert(false, \"Unexpected basic type for target of vector castD2X AVX10 (mem src): %s\", type2name(to_elem_bt));\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":85,"deletions":5,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -350,0 +350,7 @@\n+  void vector_castF2X_avx10(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, int vec_enc);\n+\n+  void vector_castF2X_avx10(BasicType to_elem_bt, XMMRegister dst, Address src, int vec_enc);\n+\n+  void vector_castD2X_avx10(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, int vec_enc);\n+\n+  void vector_castD2X_avx10(BasicType to_elem_bt, XMMRegister dst, Address src, int vec_enc);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -271,6 +271,6 @@\n-static void generate_post_barrier_fast_path(MacroAssembler* masm,\n-                                            const Register store_addr,\n-                                            const Register new_val,\n-                                            const Register tmp1,\n-                                            Label& done,\n-                                            bool new_val_may_be_null) {\n+static void generate_post_barrier(MacroAssembler* masm,\n+                                  const Register store_addr,\n+                                  const Register new_val,\n+                                  const Register tmp1,\n+                                  Label& done,\n+                                  bool new_val_may_be_null) {\n@@ -313,1 +313,1 @@\n-  generate_post_barrier_fast_path(masm, store_addr, new_val, tmp, done, true \/* new_val_may_be_null *\/);\n+  generate_post_barrier(masm, store_addr, new_val, tmp, done, true \/* new_val_may_be_null *\/);\n@@ -378,1 +378,1 @@\n-  generate_post_barrier_fast_path(masm, store_addr, new_val, tmp, done, new_val_may_be_null);\n+  generate_post_barrier(masm, store_addr, new_val, tmp, done, new_val_may_be_null);\n@@ -469,1 +469,1 @@\n-  generate_post_barrier_fast_path(masm, store_addr, new_val, tmp1, done, true \/* new_val_may_be_null *\/);\n+  generate_post_barrier(masm, store_addr, new_val, tmp1, done, true \/* new_val_may_be_null *\/);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/g1\/g1BarrierSetAssembler_x86.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1413,1 +1413,0 @@\n-\n@@ -1417,1 +1416,0 @@\n-\n","filename":"src\/hotspot\/cpu\/x86\/gc\/z\/zBarrierSetAssembler_x86.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2900,1 +2900,2 @@\n-  bool blend_emulation = EnableX86ECoreOpts && UseAVX > 1;\n+  bool blend_emulation = EnableX86ECoreOpts && UseAVX > 1 &&\n+                         !(VM_Version::is_intel_darkmont() && (dst == src1)); \/\/ partially fixed on Darkmont\n@@ -2924,1 +2925,2 @@\n-  bool blend_emulation = EnableX86ECoreOpts && UseAVX > 1;\n+  bool blend_emulation = EnableX86ECoreOpts && UseAVX > 1 &&\n+                         !(VM_Version::is_intel_darkmont() && (dst == src1)); \/\/ partially fixed on Darkmont\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1010,2 +1010,2 @@\n-                                            AdapterHandlerEntry* handler) {\n-  address i2c_entry = __ pc();\n+                                            address entry_address[AdapterBlob::ENTRY_COUNT]) {\n+  entry_address[AdapterBlob::I2C] = __ pc();\n@@ -1024,1 +1024,1 @@\n-  address c2i_unverified_entry = __ pc();\n+  entry_address[AdapterBlob::C2I_Unverified] = __ pc();\n@@ -1042,1 +1042,1 @@\n-  address c2i_entry = __ pc();\n+  entry_address[AdapterBlob::C2I] = __ pc();\n@@ -1045,1 +1045,1 @@\n-  address c2i_no_clinit_check_entry = nullptr;\n+  entry_address[AdapterBlob::C2I_No_Clinit_Check] = nullptr;\n@@ -1064,1 +1064,1 @@\n-    c2i_no_clinit_check_entry = __ pc();\n+    entry_address[AdapterBlob::C2I_No_Clinit_Check] = __ pc();\n@@ -1071,2 +1071,0 @@\n-\n-  handler->set_entry_points(i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2096,0 +2096,4 @@\n+bool VM_Version::is_intel_darkmont() {\n+  return is_intel() && is_intel_server_family() && (_model == 0xCC || _model == 0xDD);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -941,0 +941,2 @@\n+  static bool is_intel_darkmont();\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7667,2 +7667,5 @@\n-  predicate(!VM_Version::supports_avx512vl() && Matcher::vector_length_in_bytes(n->in(1)) < 64 &&\n-            type2aelembytes(Matcher::vector_element_basic_type(n)) <= 4);\n+  predicate(!VM_Version::supports_avx10_2() &&\n+            !VM_Version::supports_avx512vl() &&\n+            Matcher::vector_length_in_bytes(n->in(1)) < 64 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) <= 4 &&\n+            is_integral_type(Matcher::vector_element_basic_type(n)));\n@@ -7690,1 +7693,2 @@\n-  predicate((VM_Version::supports_avx512vl() || Matcher::vector_length_in_bytes(n->in(1)) == 64) &&\n+  predicate(!VM_Version::supports_avx10_2() &&\n+            (VM_Version::supports_avx512vl() || Matcher::vector_length_in_bytes(n->in(1)) == 64) &&\n@@ -7712,0 +7716,27 @@\n+instruct castFtoX_reg_avx10(vec dst, vec src) %{\n+  predicate(VM_Version::supports_avx10_2() &&\n+            is_integral_type(Matcher::vector_element_basic_type(n)));\n+  match(Set dst (VectorCastF2X src));\n+  format %{ \"vector_cast_f2x_avx10 $dst, $src\\t!\" %}\n+  ins_encode %{\n+    BasicType to_elem_bt = Matcher::vector_element_basic_type(this);\n+    int vlen_enc = (to_elem_bt == T_LONG) ? vector_length_encoding(this) : vector_length_encoding(this, $src);\n+    __ vector_castF2X_avx10(to_elem_bt, $dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct castFtoX_mem_avx10(vec dst, memory src) %{\n+  predicate(VM_Version::supports_avx10_2() &&\n+            is_integral_type(Matcher::vector_element_basic_type(n)));\n+  match(Set dst (VectorCastF2X (LoadVector src)));\n+  format %{ \"vector_cast_f2x_avx10 $dst, $src\\t!\" %}\n+  ins_encode %{\n+    int vlen = Matcher::vector_length(this);\n+    BasicType to_elem_bt = Matcher::vector_element_basic_type(this);\n+    int vlen_enc = (to_elem_bt == T_LONG) ? vector_length_encoding(this) : vector_length_encoding(vlen * sizeof(jfloat));\n+    __ vector_castF2X_avx10(to_elem_bt, $dst$$XMMRegister, $src$$Address, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -7724,1 +7755,3 @@\n-  predicate(!VM_Version::supports_avx512vl() && Matcher::vector_length_in_bytes(n->in(1)) < 64 &&\n+  predicate(!VM_Version::supports_avx10_2() &&\n+            !VM_Version::supports_avx512vl() &&\n+            Matcher::vector_length_in_bytes(n->in(1)) < 64 &&\n@@ -7740,1 +7773,2 @@\n-  predicate((VM_Version::supports_avx512vl() || Matcher::vector_length_in_bytes(n->in(1)) == 64) &&\n+  predicate(!VM_Version::supports_avx10_2() &&\n+            (VM_Version::supports_avx512vl() || Matcher::vector_length_in_bytes(n->in(1)) == 64) &&\n@@ -7756,0 +7790,27 @@\n+instruct castDtoX_reg_avx10(vec dst, vec src) %{\n+  predicate(VM_Version::supports_avx10_2() &&\n+            is_integral_type(Matcher::vector_element_basic_type(n)));\n+  match(Set dst (VectorCastD2X src));\n+  format %{ \"vector_cast_d2x_avx10 $dst, $src\\t!\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    BasicType to_elem_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_castD2X_avx10(to_elem_bt, $dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct castDtoX_mem_avx10(vec dst, memory src) %{\n+  predicate(VM_Version::supports_avx10_2() &&\n+            is_integral_type(Matcher::vector_element_basic_type(n)));\n+  match(Set dst (VectorCastD2X (LoadVector src)));\n+  format %{ \"vector_cast_d2x_avx10 $dst, $src\\t!\" %}\n+  ins_encode %{\n+    int vlen = Matcher::vector_length(this);\n+    int vlen_enc = vector_length_encoding(vlen * sizeof(jdouble));\n+    BasicType to_elem_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_castD2X_avx10(to_elem_bt, $dst$$XMMRegister, $src$$Address, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":66,"deletions":5,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -11715,0 +11715,1 @@\n+  predicate(!VM_Version::supports_avx10_2());\n@@ -11724,0 +11725,22 @@\n+instruct convF2I_reg_reg_avx10(rRegI dst, regF src)\n+%{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (ConvF2I src));\n+  format %{ \"evcvttss2sisl $dst, $src\" %}\n+  ins_encode %{\n+    __ evcvttss2sisl($dst$$Register, $src$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct convF2I_reg_mem_avx10(rRegI dst, memory src)\n+%{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (ConvF2I (LoadF src)));\n+  format %{ \"evcvttss2sisl $dst, $src\" %}\n+  ins_encode %{\n+    __ evcvttss2sisl($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -11726,0 +11749,1 @@\n+  predicate(!VM_Version::supports_avx10_2());\n@@ -11735,0 +11759,22 @@\n+instruct convF2L_reg_reg_avx10(rRegL dst, regF src)\n+%{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (ConvF2L src));\n+  format %{ \"evcvttss2sisq $dst, $src\" %}\n+  ins_encode %{\n+    __ evcvttss2sisq($dst$$Register, $src$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct convF2L_reg_mem_avx10(rRegL dst, memory src)\n+%{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (ConvF2L (LoadF src)));\n+  format %{ \"evcvttss2sisq $dst, $src\" %}\n+  ins_encode %{\n+    __ evcvttss2sisq($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -11737,0 +11783,1 @@\n+  predicate(!VM_Version::supports_avx10_2());\n@@ -11746,0 +11793,22 @@\n+instruct convD2I_reg_reg_avx10(rRegI dst, regD src)\n+%{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (ConvD2I src));\n+  format %{ \"evcvttsd2sisl $dst, $src\" %}\n+  ins_encode %{\n+    __ evcvttsd2sisl($dst$$Register, $src$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct convD2I_reg_mem_avx10(rRegI dst, memory src)\n+%{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (ConvD2I (LoadD src)));\n+  format %{ \"evcvttsd2sisl $dst, $src\" %}\n+  ins_encode %{\n+    __ evcvttsd2sisl($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -11748,0 +11817,1 @@\n+  predicate(!VM_Version::supports_avx10_2());\n@@ -11757,0 +11827,22 @@\n+instruct convD2L_reg_reg_avx10(rRegL dst, regD src)\n+%{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (ConvD2L src));\n+  format %{ \"evcvttsd2sisq $dst, $src\" %}\n+  ins_encode %{\n+    __ evcvttsd2sisq($dst$$Register, $src$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct convD2L_reg_mem_avx10(rRegL dst, memory src)\n+%{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (ConvD2L (LoadD src)));\n+  format %{ \"evcvttsd2sisq $dst, $src\" %}\n+  ins_encode %{\n+    __ evcvttsd2sisq($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":92,"deletions":0,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -41,6 +41,0 @@\n-\n-static address zero_null_code_stub() {\n-  address start = ShouldNotCallThisStub();\n-  return start;\n-}\n-\n@@ -58,6 +52,3 @@\n-                                            AdapterHandlerEntry* handler) {\n-  \/\/ foil any attempt to call the i2c, c2i or unverified c2i entries\n-  handler->set_entry_points(CAST_FROM_FN_PTR(address,zero_null_code_stub),\n-                            CAST_FROM_FN_PTR(address,zero_null_code_stub),\n-                            CAST_FROM_FN_PTR(address,zero_null_code_stub),\n-                            nullptr);\n+                                            address entry_address[AdapterBlob::ENTRY_COUNT]) {\n+  ShouldNotCallThis();\n+  return;\n","filename":"src\/hotspot\/cpu\/zero\/sharedRuntime_zero.cpp","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -163,1 +163,0 @@\n-int (*os::Linux::_pthread_setname_np)(pthread_t, const char*) = nullptr;\n@@ -863,4 +862,1 @@\n-    int lgrp_id = os::numa_get_group_id();\n-    if (lgrp_id != -1) {\n-      thread->set_lgrp_id(lgrp_id);\n-    }\n+    thread->update_lgrp_id();\n@@ -868,0 +864,1 @@\n+\n@@ -1194,4 +1191,1 @@\n-    int lgrp_id = os::numa_get_group_id();\n-    if (lgrp_id != -1) {\n-      thread->set_lgrp_id(lgrp_id);\n-    }\n+    thread->update_lgrp_id();\n@@ -4379,4 +4373,0 @@\n-  \/\/ retrieve entry point for pthread_setname_np\n-  Linux::_pthread_setname_np =\n-    (int(*)(pthread_t, const char*))dlsym(RTLD_DEFAULT, \"pthread_setname_np\");\n-\n@@ -4859,8 +4849,18 @@\n-  if (Linux::_pthread_setname_np) {\n-    char buf [16]; \/\/ according to glibc manpage, 16 chars incl. '\/0'\n-    (void) os::snprintf(buf, sizeof(buf), \"%s\", name);\n-    buf[sizeof(buf) - 1] = '\\0';\n-    const int rc = Linux::_pthread_setname_np(pthread_self(), buf);\n-    \/\/ ERANGE should not happen; all other errors should just be ignored.\n-    assert(rc != ERANGE, \"pthread_setname_np failed\");\n-  }\n+  char buf[16]; \/\/ according to glibc manpage, 16 chars incl. '\/0'\n+  \/\/ We may need to truncate the thread name. Since a common pattern\n+  \/\/ for thread names is to be both longer than 15 chars and have a\n+  \/\/ trailing number (\"DispatcherWorkerThread21\", \"C2 CompilerThread#54\" etc),\n+  \/\/ we preserve the end of the thread name by truncating the middle\n+  \/\/ (e.g. \"Dispatc..read21\").\n+  const size_t len = strlen(name);\n+  if (len < sizeof(buf)) {\n+    strcpy(buf, name);\n+  } else {\n+    (void) os::snprintf(buf, sizeof(buf), \"%.7s..%.6s\", name, name + len - 6);\n+  }\n+  \/\/ Note: we use the system call here instead of calling pthread_setname_np\n+  \/\/ since this is the only way to make ASAN aware of our thread names. Even\n+  \/\/ though ASAN intercepts both prctl and pthread_setname_np, it only processes\n+  \/\/ the thread name given to the former.\n+  int rc = prctl(PR_SET_NAME, buf);\n+  assert(rc == 0, \"prctl(PR_SET_NAME) failed\");\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-  static int (*_pthread_setname_np)(pthread_t, const char*);\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,3 +37,0 @@\n-\/\/ Aix does not have NUMA support but need these for compilation.\n-inline bool os::numa_has_group_homing()     { AIX_ONLY(ShouldNotReachHere();) return false;  }\n-\n","filename":"src\/hotspot\/os\/posix\/os_posix.inline.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -537,7 +537,0 @@\n-  if (UseNUMA) {\n-    int lgrp_id = os::numa_get_group_id();\n-    if (lgrp_id != -1) {\n-      thread->set_lgrp_id(lgrp_id);\n-    }\n-  }\n-\n@@ -601,7 +594,0 @@\n-  if (UseNUMA) {\n-    int lgrp_id = os::numa_get_group_id();\n-    if (lgrp_id != -1) {\n-      thread->set_lgrp_id(lgrp_id);\n-    }\n-  }\n-\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,2 +65,0 @@\n-inline bool os::numa_has_group_homing()     { return false;  }\n-\n","filename":"src\/hotspot\/os\/windows\/os_windows.inline.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/gc\/z\/zSyscall_linux_ppc.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -165,0 +165,5 @@\n+\/\/ Compute the least number of words required for registers in register masks.\n+int RegisterForm::words_for_regs() {\n+  return (_reg_ctr + 31) >> 5;\n+}\n+\n@@ -167,7 +172,4 @@\n-  \/\/ Need at least this many words\n-  int words_for_regs = (_reg_ctr + 31)>>5;\n-  \/\/ The array of Register Mask bits should be large enough to cover\n-  \/\/ all the machine registers and all parameters that need to be passed\n-  \/\/ on the stack (stack registers) up to some interesting limit.  Methods\n-  \/\/ that need more parameters will NOT be compiled.  On Intel, the limit\n-  \/\/ is something like 90+ parameters.\n+  \/\/ The array of Register Mask bits should be large enough to cover all the\n+  \/\/ machine registers, as well as a certain number of parameters that need to\n+  \/\/ be passed on the stack (stack registers). The number of parameters that can\n+  \/\/ fit in the mask should be dimensioned to cover most common cases.\n@@ -180,1 +182,1 @@\n-  return (words_for_regs + 3 + 1 + 1) & ~1;\n+  return (words_for_regs() + 3 + 1 + 1) & ~1;\n@@ -372,1 +374,1 @@\n-  fprintf(fp,\" 0x%x );\\n\", regs_in_word(i, false));\n+  fprintf(fp, \" 0x%x, false );\\n\", regs_in_word(i, false));\n@@ -379,1 +381,1 @@\n-    fprintf(fp,\" 0x%x );\\n\", regs_in_word(i, true));\n+    fprintf(fp, \" 0x%x, true );\\n\", regs_in_word(i, true));\n","filename":"src\/hotspot\/share\/adlc\/formsopt.cpp","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -96,0 +96,2 @@\n+  static int  words_for_regs(); \/\/ Compute the least number of words required for\n+                                \/\/ registers in register masks.\n","filename":"src\/hotspot\/share\/adlc\/formsopt.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -102,0 +102,2 @@\n+  fprintf(fp_hpp, \"\/\/ Minimum size of register-mask in ints\\n\");\n+  fprintf(fp_hpp, \"#define RM_SIZE_IN_INTS_MIN %d\\n\", RegisterForm::words_for_regs());\n","filename":"src\/hotspot\/share\/adlc\/output_h.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -374,1 +374,0 @@\n-  bool _compute_lock;\n@@ -378,1 +377,1 @@\n-  MonitorExitStub(LIR_Opr lock_reg, bool compute_lock, int monitor_ix)\n+  MonitorExitStub(LIR_Opr lock_reg, int monitor_ix)\n@@ -380,1 +379,1 @@\n-      _compute_lock(compute_lock), _monitor_ix(monitor_ix) { }\n+      _monitor_ix(monitor_ix) { }\n@@ -384,5 +383,1 @@\n-    if (_compute_lock) {\n-      visitor->do_temp(_lock_reg);\n-    } else {\n-      visitor->do_input(_lock_reg);\n-    }\n+    visitor->do_temp(_lock_reg);\n","filename":"src\/hotspot\/share\/c1\/c1_CodeStubs.hpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -638,1 +638,1 @@\n-  CodeStub* slow_path = new MonitorExitStub(lock, true, monitor_no);\n+  CodeStub* slow_path = new MonitorExitStub(lock, monitor_no);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotLinkedClassBulkLoader.hpp\"\n@@ -50,0 +51,2 @@\n+  check_aot_annotations(ik);\n+\n@@ -51,0 +54,5 @@\n+    if (ik->has_aot_safe_initializer()) {\n+      ResourceMark rm;\n+      log_info(aot, init)(\"Class %s is annotated with @AOTSafeClassInitializer but has not been initialized\",\n+                          ik->external_name());\n+    }\n@@ -247,0 +255,50 @@\n+template <typename FUNCTION>\n+void require_annotation_for_super_types(InstanceKlass* ik, const char* annotation, FUNCTION func) {\n+  if (log_is_enabled(Info, aot, init)) {\n+    ResourceMark rm;\n+    log_info(aot, init)(\"Found %s class %s\", annotation, ik->external_name());\n+  }\n+\n+  \/\/ Since ik has this annotation, we require that\n+  \/\/   - all super classes must have this annotation\n+  \/\/   - all super interfaces that are interface_needs_clinit_execution_as_super()\n+  \/\/     must have this annotation\n+  \/\/ This avoid the situation where in the production run, we run the <clinit>\n+  \/\/ of a supertype but not the <clinit> of ik\n+\n+  InstanceKlass* super = ik->java_super();\n+  if (super != nullptr && !func(super)) {\n+    ResourceMark rm;\n+    log_error(aot, init)(\"Missing %s in superclass %s for class %s\",\n+                         annotation, super->external_name(), ik->external_name());\n+    AOTMetaspace::unrecoverable_writing_error();\n+  }\n+\n+  int len = ik->local_interfaces()->length();\n+  for (int i = 0; i < len; i++) {\n+    InstanceKlass* intf = ik->local_interfaces()->at(i);\n+    if (intf->interface_needs_clinit_execution_as_super() && !func(intf)) {\n+      ResourceMark rm;\n+      log_error(aot, init)(\"Missing %s in superinterface %s for class %s\",\n+                           annotation, intf->external_name(), ik->external_name());\n+      AOTMetaspace::unrecoverable_writing_error();\n+    }\n+  }\n+}\n+\n+void AOTClassInitializer::check_aot_annotations(InstanceKlass* ik) {\n+  if (ik->has_aot_safe_initializer()) {\n+    require_annotation_for_super_types(ik, \"@AOTSafeClassInitializer\", [&] (const InstanceKlass* supertype) {\n+      return supertype->has_aot_safe_initializer();\n+    });\n+  } else {\n+    \/\/ @AOTRuntimeSetup only meaningful in @AOTSafeClassInitializer\n+    if (ik->is_runtime_setup_required()) {\n+      ResourceMark rm;\n+      log_error(aot, init)(\"@AOTRuntimeSetup meaningless in non-@AOTSafeClassInitializer class %s\",\n+                           ik->external_name());\n+    }\n+  }\n+}\n+\n+\n","filename":"src\/hotspot\/share\/cds\/aotClassInitializer.cpp","additions":58,"deletions":0,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -34,0 +34,3 @@\n+\n+  static void check_aot_annotations(InstanceKlass* ik);\n+\n","filename":"src\/hotspot\/share\/cds\/aotClassInitializer.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -195,1 +195,1 @@\n-    table->set_boot(write_classes(nullptr, true));\n+    table->set_boot1(write_classes(nullptr, true));\n","filename":"src\/hotspot\/share\/cds\/aotClassLinker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+#include \"classfile\/classLoaderDataShared.hpp\"\n+#include \"classfile\/javaClasses.hpp\"\n@@ -44,5 +46,0 @@\n-bool AOTLinkedClassBulkLoader::_boot2_completed = false;\n-bool AOTLinkedClassBulkLoader::_platform_completed = false;\n-bool AOTLinkedClassBulkLoader::_app_completed = false;\n-bool AOTLinkedClassBulkLoader::_all_completed = false;\n-\n@@ -53,8 +50,10 @@\n-bool AOTLinkedClassBulkLoader::class_preloading_finished() {\n-  if (!CDSConfig::is_using_aot_linked_classes()) {\n-    return true;\n-  } else {\n-    \/\/ The ConstantPools of preloaded classes have references to other preloaded classes. We don't\n-    \/\/ want any Java code (including JVMCI compiler) to use these classes until all of them\n-    \/\/ are loaded.\n-    return AtomicAccess::load_acquire(&_all_completed);\n+\/\/ This function is called before the VM executes any Java code (include AOT-compiled Java methods).\n+\/\/\n+\/\/ We populate the boot\/platform\/app class loaders with classes from the AOT cache. This is a fundamental\n+\/\/ step in restoring the JVM's state from the snapshot recorded in the AOT cache: other AOT optimizations\n+\/\/ such as AOT compiled methods can make direct references to the preloaded classes, knowing that\n+\/\/ these classes are guaranteed to be in at least the \"loaded\" state.\n+void AOTLinkedClassBulkLoader::preload_classes(JavaThread* current) {\n+  preload_classes_impl(current);\n+  if (current->has_pending_exception()) {\n+    exit_on_exception(current);\n@@ -64,3 +63,20 @@\n-void AOTLinkedClassBulkLoader::load_javabase_classes(JavaThread* current) {\n-  assert(CDSConfig::is_using_aot_linked_classes(), \"sanity\");\n-  load_classes_in_loader(current, AOTLinkedClassCategory::BOOT1, nullptr); \/\/ only java.base classes\n+void AOTLinkedClassBulkLoader::preload_classes_impl(TRAPS) {\n+  precond(CDSConfig::is_using_aot_linked_classes());\n+\n+  ClassLoaderDataShared::restore_archived_modules_for_preloading_classes(THREAD);\n+  Handle h_platform_loader(THREAD, SystemDictionary::java_platform_loader());\n+  Handle h_system_loader(THREAD, SystemDictionary::java_system_loader());\n+\n+  AOTLinkedClassTable* table = AOTLinkedClassTable::get();\n+\n+  preload_classes_in_table(table->boot1(), \"boot1\", Handle(), CHECK);\n+  preload_classes_in_table(table->boot2(), \"boot2\", Handle(), CHECK);\n+\n+  initiate_loading(THREAD, \"plat\", h_platform_loader, table->boot1());\n+  initiate_loading(THREAD, \"plat\", h_platform_loader, table->boot2());\n+  preload_classes_in_table(table->platform(), \"plat\", h_platform_loader, CHECK);\n+\n+  initiate_loading(THREAD, \"app\", h_system_loader, table->boot1());\n+  initiate_loading(THREAD, \"app\", h_system_loader, table->boot2());\n+  initiate_loading(THREAD, \"app\", h_system_loader, table->platform());\n+  preload_classes_in_table(table->app(), \"app\", h_system_loader, CHECK);\n@@ -69,2 +85,5 @@\n-void AOTLinkedClassBulkLoader::load_non_javabase_classes(JavaThread* current) {\n-  assert(CDSConfig::is_using_aot_linked_classes(), \"sanity\");\n+void AOTLinkedClassBulkLoader::preload_classes_in_table(Array<InstanceKlass*>* classes,\n+                                                        const char* category_name, Handle loader, TRAPS) {\n+  if (classes == nullptr) {\n+    return;\n+  }\n@@ -72,6 +91,9 @@\n-  \/\/ is_using_aot_linked_classes() requires is_using_full_module_graph(). As a result,\n-  \/\/ the platform\/system class loader should already have been initialized as part\n-  \/\/ of the FMG support.\n-  assert(CDSConfig::is_using_full_module_graph(), \"must be\");\n-  assert(SystemDictionary::java_platform_loader() != nullptr, \"must be\");\n-  assert(SystemDictionary::java_system_loader() != nullptr,   \"must be\");\n+  for (int i = 0; i < classes->length(); i++) {\n+    InstanceKlass* ik = classes->at(i);\n+    if (log_is_enabled(Info, aot, load)) {\n+      ResourceMark rm(THREAD);\n+      log_info(aot, load)(\"%-5s %s%s\", category_name, ik->external_name(),\n+                          ik->is_hidden() ? \" (hidden)\" : \"\");\n+    }\n+\n+    SystemDictionary::preload_class(loader, ik, CHECK);\n@@ -79,2 +101,13 @@\n-  load_classes_in_loader(current, AOTLinkedClassCategory::BOOT2, nullptr); \/\/ all boot classes outside of java.base\n-  _boot2_completed = true;\n+    if (ik->is_hidden()) {\n+      DEBUG_ONLY({\n+        \/\/ Make sure we don't make this hidden class available by name, even if we don't\n+        \/\/ use any special ClassLoaderData.\n+        ResourceMark rm(THREAD);\n+        assert(SystemDictionary::find_instance_klass(THREAD, ik->name(), loader) == nullptr,\n+               \"hidden classes cannot be accessible by name: %s\", ik->external_name());\n+      });\n+    } else {\n+      precond(SystemDictionary::find_instance_klass(THREAD, ik->name(), loader) == ik);\n+    }\n+  }\n+}\n@@ -82,2 +115,7 @@\n-  load_classes_in_loader(current, AOTLinkedClassCategory::PLATFORM, SystemDictionary::java_platform_loader());\n-  _platform_completed = true;\n+#ifdef ASSERT\n+void AOTLinkedClassBulkLoader::validate_module_of_preloaded_classes() {\n+  oop javabase_module_oop = ModuleEntryTable::javabase_moduleEntry()->module_oop();\n+  for (int i = T_BOOLEAN; i < T_LONG+1; i++) {\n+    TypeArrayKlass* tak = Universe::typeArrayKlass((BasicType)i);\n+    validate_module(tak, \"boot1\", javabase_module_oop);\n+  }\n@@ -85,1 +123,4 @@\n-  load_classes_in_loader(current, AOTLinkedClassCategory::APP, SystemDictionary::java_system_loader());\n+  JavaThread* current = JavaThread::current();\n+  Handle h_platform_loader(current, SystemDictionary::java_platform_loader());\n+  Handle h_system_loader(current, SystemDictionary::java_system_loader());\n+  AOTLinkedClassTable* table = AOTLinkedClassTable::get();\n@@ -87,3 +128,24 @@\n-  if (AOTPrintTrainingInfo) {\n-    tty->print_cr(\"==================== archived_training_data ** after all classes preloaded ====================\");\n-    TrainingData::print_archived_training_data_on(tty);\n+  validate_module_of_preloaded_classes_in_table(table->boot1(), \"boot1\", Handle());\n+  validate_module_of_preloaded_classes_in_table(table->boot2(), \"boot2\", Handle());\n+  validate_module_of_preloaded_classes_in_table(table->platform(), \"plat\", h_platform_loader);\n+  validate_module_of_preloaded_classes_in_table(table->app(), \"app\", h_system_loader);\n+}\n+\n+void AOTLinkedClassBulkLoader::validate_module_of_preloaded_classes_in_table(Array<InstanceKlass*>* classes,\n+                                                                             const char* category_name, Handle loader) {\n+  if (classes == nullptr) {\n+    return;\n+  }\n+\n+  ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(loader());\n+  for (int i = 0; i < classes->length(); i++) {\n+    InstanceKlass* ik = classes->at(i);\n+    PackageEntry* pkg_entry = ik->package();\n+    oop module_oop;\n+    if (pkg_entry == nullptr) {\n+      module_oop = loader_data->unnamed_module()->module_oop();\n+    } else {\n+      module_oop = pkg_entry->module()->module_oop();\n+    }\n+\n+    validate_module(ik, category_name, module_oop);\n@@ -91,0 +153,4 @@\n+}\n+\n+void AOTLinkedClassBulkLoader::validate_module(Klass* k, const char* category_name, oop module_oop) {\n+  assert(module_oop != nullptr, \"module system must have been initialized\");\n@@ -92,2 +158,15 @@\n-  _app_completed = true;\n-  AtomicAccess::release_store(&_all_completed, true);\n+  if (log_is_enabled(Debug, aot, module)) {\n+    ResourceMark rm;\n+    log_debug(aot, module)(\"Validate module of %-5s %s\", category_name, k->external_name());\n+  }\n+  precond(java_lang_Class::module(k->java_mirror()) == module_oop);\n+\n+  ArrayKlass* ak = k->array_klass_or_null();\n+  while (ak != nullptr) {\n+    if (log_is_enabled(Debug, aot, module)) {\n+      ResourceMark rm;\n+      log_debug(aot, module)(\"Validate module of %-5s %s\", category_name, ak->external_name());\n+    }\n+    precond(java_lang_Class::module(ak->java_mirror()) == module_oop);\n+    ak = ak->array_klass_or_null();\n+  }\n@@ -95,0 +174,1 @@\n+#endif\n@@ -96,2 +176,4 @@\n-void AOTLinkedClassBulkLoader::load_classes_in_loader(JavaThread* current, AOTLinkedClassCategory class_category, oop class_loader_oop) {\n-  load_classes_in_loader_impl(class_category, class_loader_oop, current);\n+\/\/ Link all java.base classes in the AOTLinkedClassTable. Of those classes,\n+\/\/ move the ones that have been AOT-initialized to the \"initialized\" state.\n+void AOTLinkedClassBulkLoader::link_or_init_javabase_classes(JavaThread* current) {\n+  link_or_init_classes_for_loader(Handle(), AOTLinkedClassTable::get()->boot1(), current);\n@@ -99,2 +181,0 @@\n-    \/\/ We cannot continue, as we might have loaded some of the aot-linked classes, which\n-    \/\/ may have dangling C++ pointers to other aot-linked classes that we have failed to load.\n@@ -105,9 +185,6 @@\n-void AOTLinkedClassBulkLoader::exit_on_exception(JavaThread* current) {\n-  assert(current->has_pending_exception(), \"precondition\");\n-  ResourceMark rm(current);\n-  if (current->pending_exception()->is_a(vmClasses::OutOfMemoryError_klass())) {\n-    log_error(aot)(\"Out of memory. Please run with a larger Java heap, current MaxHeapSize = \"\n-                   \"%zuM\", MaxHeapSize\/M);\n-  } else {\n-    log_error(aot)(\"%s: %s\", current->pending_exception()->klass()->external_name(),\n-                   java_lang_String::as_utf8_string(java_lang_Throwable::message(current->pending_exception())));\n+\/\/ Do the same thing as link_or_init_javabase_classes(), but for the classes that are not\n+\/\/ in the java.base module.\n+void AOTLinkedClassBulkLoader::link_or_init_non_javabase_classes(JavaThread* current) {\n+  link_or_init_non_javabase_classes_impl(current);\n+  if (current->has_pending_exception()) {\n+    exit_on_exception(current);\n@@ -115,1 +192,0 @@\n-  vm_exit_during_initialization(\"Unexpected exception when loading aot-linked classes.\");\n@@ -118,2 +194,16 @@\n-void AOTLinkedClassBulkLoader::load_classes_in_loader_impl(AOTLinkedClassCategory class_category, oop class_loader_oop, TRAPS) {\n-  Handle h_loader(THREAD, class_loader_oop);\n+void AOTLinkedClassBulkLoader::link_or_init_non_javabase_classes_impl(TRAPS) {\n+  assert(CDSConfig::is_using_aot_linked_classes(), \"sanity\");\n+\n+  DEBUG_ONLY(validate_module_of_preloaded_classes());\n+\n+  \/\/ is_using_aot_linked_classes() requires is_using_full_module_graph(). As a result,\n+  \/\/ the platform\/system class loader should already have been initialized as part\n+  \/\/ of the FMG support.\n+  assert(CDSConfig::is_using_full_module_graph(), \"must be\");\n+\n+  Handle h_platform_loader(THREAD, SystemDictionary::java_platform_loader());\n+  Handle h_system_loader(THREAD, SystemDictionary::java_system_loader());\n+\n+  assert(h_platform_loader() != nullptr, \"must be\");\n+  assert(h_system_loader() != nullptr,   \"must be\");\n+\n@@ -121,22 +211,3 @@\n-  load_table(table, class_category, h_loader, CHECK);\n-\n-  \/\/ Initialize the InstanceKlasses of all archived heap objects that are reachable from the\n-  \/\/ archived java class mirrors.\n-  switch (class_category) {\n-  case AOTLinkedClassCategory::BOOT1:\n-    \/\/ Delayed until finish_loading_javabase_classes(), as the VM is not ready to\n-    \/\/ execute some of the <clinit> methods.\n-    break;\n-  case AOTLinkedClassCategory::BOOT2:\n-    init_required_classes_for_loader(h_loader, table->boot2(), CHECK);\n-    break;\n-  case AOTLinkedClassCategory::PLATFORM:\n-    init_required_classes_for_loader(h_loader, table->platform(), CHECK);\n-    break;\n-  case AOTLinkedClassCategory::APP:\n-    init_required_classes_for_loader(h_loader, table->app(), CHECK);\n-    break;\n-  case AOTLinkedClassCategory::UNREGISTERED:\n-    ShouldNotReachHere();\n-    break;\n-  }\n+  link_or_init_classes_for_loader(Handle(), table->boot2(), CHECK);\n+  link_or_init_classes_for_loader(h_platform_loader, table->platform(), CHECK);\n+  link_or_init_classes_for_loader(h_system_loader, table->app(), CHECK);\n@@ -149,6 +220,0 @@\n-}\n-\n-void AOTLinkedClassBulkLoader::load_table(AOTLinkedClassTable* table, AOTLinkedClassCategory class_category, Handle loader, TRAPS) {\n-  if (class_category != AOTLinkedClassCategory::BOOT1) {\n-    assert(Universe::is_module_initialized(), \"sanity\");\n-  }\n@@ -156,29 +221,3 @@\n-  const char* category_name = AOTClassLinker::class_category_name(class_category);\n-  switch (class_category) {\n-  case AOTLinkedClassCategory::BOOT1:\n-    load_classes_impl(class_category, table->boot(), category_name, loader, CHECK);\n-    break;\n-\n-  case AOTLinkedClassCategory::BOOT2:\n-    load_classes_impl(class_category, table->boot2(), category_name, loader, CHECK);\n-    break;\n-\n-  case AOTLinkedClassCategory::PLATFORM:\n-    {\n-      initiate_loading(THREAD, category_name, loader, table->boot());\n-      initiate_loading(THREAD, category_name, loader, table->boot2());\n-      load_classes_impl(class_category, table->platform(), category_name, loader, CHECK);\n-    }\n-    break;\n-  case AOTLinkedClassCategory::APP:\n-    {\n-      initiate_loading(THREAD, category_name, loader, table->boot());\n-      initiate_loading(THREAD, category_name, loader, table->boot2());\n-      initiate_loading(THREAD, category_name, loader, table->platform());\n-      load_classes_impl(class_category, table->app(), category_name, loader, CHECK);\n-    }\n-    break;\n-  case AOTLinkedClassCategory::UNREGISTERED:\n-  default:\n-    ShouldNotReachHere(); \/\/ Currently aot-linked classes are not supported for this category.\n-    break;\n+  if (AOTPrintTrainingInfo) {\n+    tty->print_cr(\"==================== archived_training_data ** after all classes preloaded ====================\");\n+    TrainingData::print_archived_training_data_on(tty);\n@@ -188,16 +227,10 @@\n-void AOTLinkedClassBulkLoader::load_classes_impl(AOTLinkedClassCategory class_category, Array<InstanceKlass*>* classes,\n-                                                 const char* category_name, Handle loader, TRAPS) {\n-  if (classes == nullptr) {\n-    return;\n-  }\n-\n-  ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(loader());\n-\n-  for (int i = 0; i < classes->length(); i++) {\n-    InstanceKlass* ik = classes->at(i);\n-    if (log_is_enabled(Info, aot, load)) {\n-      ResourceMark rm(THREAD);\n-      log_info(aot, load)(\"%-5s %s%s%s\", category_name, ik->external_name(),\n-                          ik->is_loaded() ? \" (already loaded)\" : \"\",\n-                          ik->is_hidden() ? \" (hidden)\" : \"\");\n-    }\n+\/\/ For the AOT cache to function properly, all classes in the AOTLinkedClassTable\n+\/\/ must be loaded and linked. In addition, AOT-initialized classes must be moved to\n+\/\/ the initialized state.\n+\/\/\n+\/\/ We can encounter a failure during the loading, linking, or initialization of\n+\/\/ classes in the AOTLinkedClassTable only if:\n+\/\/   - We ran out of memory,\n+\/\/   - There is a serious error in the VM implemenation\n+\/\/ When this happens, the VM may be in an inconsistent state (e.g., we have a cached\n+\/\/ heap object of class X, but X is not linked). We must exit the JVM now.\n@@ -205,21 +238,9 @@\n-    if (!ik->is_loaded()) {\n-      if (ik->is_hidden()) {\n-        load_hidden_class(loader_data, ik, CHECK);\n-      } else {\n-        InstanceKlass* actual;\n-        if (loader_data == ClassLoaderData::the_null_class_loader_data()) {\n-          actual = SystemDictionary::load_instance_class(ik->name(), loader, CHECK);\n-        } else {\n-          actual = SystemDictionaryShared::find_or_load_shared_class(ik->name(), loader, CHECK);\n-        }\n-\n-        if (actual != ik) {\n-          ResourceMark rm(THREAD);\n-          log_error(aot)(\"Unable to resolve %s class from %s: %s\", category_name, CDSConfig::type_of_archive_being_loaded(), ik->external_name());\n-          log_error(aot)(\"Expected: \" INTPTR_FORMAT \", actual: \" INTPTR_FORMAT, p2i(ik), p2i(actual));\n-          log_error(aot)(\"JVMTI class retransformation is not supported when archive was generated with -XX:+AOTClassLinking.\");\n-          AOTMetaspace::unrecoverable_loading_error();\n-        }\n-        assert(actual->is_loaded(), \"must be\");\n-      }\n-    }\n+void AOTLinkedClassBulkLoader::exit_on_exception(JavaThread* current) {\n+  assert(current->has_pending_exception(), \"precondition\");\n+  ResourceMark rm(current);\n+  if (current->pending_exception()->is_a(vmClasses::OutOfMemoryError_klass())) {\n+    log_error(aot)(\"Out of memory. Please run with a larger Java heap, current MaxHeapSize = \"\n+                   \"%zuM\", MaxHeapSize\/M);\n+  } else {\n+    log_error(aot)(\"%s: %s\", current->pending_exception()->klass()->external_name(),\n+                   java_lang_String::as_utf8_string(java_lang_Throwable::message(current->pending_exception())));\n@@ -227,0 +248,1 @@\n+  vm_exit_during_initialization(\"Unexpected exception when loading aot-linked classes.\");\n@@ -258,1 +280,1 @@\n-        log_info(aot, load)(\"%s %s (initiated, defined by %s)\", category_name, ik->external_name(),\n+        log_info(aot, load)(\"%-5s %s (initiated, defined by %s)\", category_name, ik->external_name(),\n@@ -266,70 +288,0 @@\n-\/\/ Currently, we archive only three types of hidden classes:\n-\/\/    - LambdaForms\n-\/\/    - lambda proxy classes\n-\/\/    - StringConcat classes\n-\/\/ See HeapShared::is_archivable_hidden_klass().\n-\/\/\n-\/\/ LambdaForm classes (with names like java\/lang\/invoke\/LambdaForm$MH+0x800000015) logically\n-\/\/ belong to the boot loader, but they are usually stored in their own special ClassLoaderData to\n-\/\/ facilitate class unloading, as a LambdaForm may refer to a class loaded by a custom loader\n-\/\/ that may be unloaded.\n-\/\/\n-\/\/ We only support AOT-resolution of indys in the boot\/platform\/app loader, so there's no need\n-\/\/ to support class unloading. For simplicity, we put all archived LambdaForm classes in the\n-\/\/ \"main\" ClassLoaderData of the boot loader.\n-\/\/\n-\/\/ (Even if we were to support other loaders, we would still feel free to ignore any requirement\n-\/\/ of class unloading, for any class asset in the AOT cache.  Anything that makes it into the AOT\n-\/\/ cache has a lifetime dispensation from unloading.  After all, the AOT cache never grows, and\n-\/\/ we can assume that the user is content with its size, and doesn't need its footprint to shrink.)\n-\/\/\n-\/\/ Lambda proxy classes are normally stored in the same ClassLoaderData as their nest hosts, and\n-\/\/ StringConcat are normally stored in the main ClassLoaderData of the boot class loader. We\n-\/\/ do the same for the archived copies of such classes.\n-void AOTLinkedClassBulkLoader::load_hidden_class(ClassLoaderData* loader_data, InstanceKlass* ik, TRAPS) {\n-  assert(HeapShared::is_lambda_form_klass(ik) ||\n-         HeapShared::is_lambda_proxy_klass(ik) ||\n-         HeapShared::is_string_concat_klass(ik), \"sanity\");\n-  DEBUG_ONLY({\n-      assert(ik->super()->is_loaded(), \"must be\");\n-      for (int i = 0; i < ik->local_interfaces()->length(); i++) {\n-        assert(ik->local_interfaces()->at(i)->is_loaded(), \"must be\");\n-      }\n-    });\n-\n-  Handle pd;\n-  PackageEntry* pkg_entry = nullptr;\n-\n-  \/\/ Since a hidden class does not have a name, it cannot be reloaded\n-  \/\/ normally via the system dictionary. Instead, we have to finish the\n-  \/\/ loading job here.\n-\n-  if (HeapShared::is_lambda_proxy_klass(ik)) {\n-    InstanceKlass* nest_host = ik->nest_host_not_null();\n-    assert(nest_host->is_loaded(), \"must be\");\n-    pd = Handle(THREAD, nest_host->protection_domain());\n-    pkg_entry = nest_host->package();\n-  }\n-\n-  ik->restore_unshareable_info(loader_data, pd, pkg_entry, CHECK);\n-  SystemDictionary::load_shared_class_misc(ik, loader_data);\n-  ik->add_to_hierarchy(THREAD);\n-  assert(ik->is_loaded(), \"Must be in at least loaded state\");\n-\n-  DEBUG_ONLY({\n-      \/\/ Make sure we don't make this hidden class available by name, even if we don't\n-      \/\/ use any special ClassLoaderData.\n-      Handle loader(THREAD, loader_data->class_loader());\n-      ResourceMark rm(THREAD);\n-      assert(SystemDictionary::resolve_or_null(ik->name(), loader, THREAD) == nullptr,\n-             \"hidden classes cannot be accessible by name: %s\", ik->external_name());\n-      if (HAS_PENDING_EXCEPTION) {\n-        CLEAR_PENDING_EXCEPTION;\n-      }\n-    });\n-}\n-\n-void AOTLinkedClassBulkLoader::finish_loading_javabase_classes(TRAPS) {\n-  init_required_classes_for_loader(Handle(), AOTLinkedClassTable::get()->boot(), CHECK);\n-}\n-\n@@ -340,1 +292,1 @@\n-void AOTLinkedClassBulkLoader::init_required_classes_for_loader(Handle class_loader, Array<InstanceKlass*>* classes, TRAPS) {\n+void AOTLinkedClassBulkLoader::link_or_init_classes_for_loader(Handle class_loader, Array<InstanceKlass*>* classes, TRAPS) {\n@@ -364,50 +316,0 @@\n-bool AOTLinkedClassBulkLoader::is_pending_aot_linked_class(Klass* k) {\n-  if (!CDSConfig::is_using_aot_linked_classes()) {\n-    return false;\n-  }\n-\n-  if (_all_completed) { \/\/ no more pending aot-linked classes\n-    return false;\n-  }\n-\n-  if (k->is_objArray_klass()) {\n-    k = ObjArrayKlass::cast(k)->bottom_klass();\n-  }\n-  if (!k->is_instance_klass()) {\n-    \/\/ type array klasses (and their higher dimensions),\n-    \/\/ must have been loaded before a GC can ever happen.\n-    return false;\n-  }\n-\n-  \/\/ There's a small window during VM start-up where a not-yet loaded aot-linked\n-  \/\/ class k may be discovered by the GC during VM initialization. This can happen\n-  \/\/ when the heap contains an aot-cached instance of k, but k is not ready to be\n-  \/\/ loaded yet. (TODO: JDK-8342429 eliminates this possibility)\n-  \/\/\n-  \/\/ The following checks try to limit this window as much as possible for each of\n-  \/\/ the four AOTLinkedClassCategory of classes that can be aot-linked.\n-\n-  InstanceKlass* ik = InstanceKlass::cast(k);\n-  if (ik->defined_by_boot_loader()) {\n-    if (ik->module() != nullptr && ik->in_javabase_module()) {\n-      \/\/ AOTLinkedClassCategory::BOOT1 -- all aot-linked classes in\n-      \/\/ java.base must have been loaded before a GC can ever happen.\n-      return false;\n-    } else {\n-      \/\/ AOTLinkedClassCategory::BOOT2 classes cannot be loaded until\n-      \/\/ module system is ready.\n-      return !_boot2_completed;\n-    }\n-  } else if (ik->defined_by_platform_loader()) {\n-    \/\/ AOTLinkedClassCategory::PLATFORM classes cannot be loaded until\n-    \/\/ the platform class loader is initialized.\n-    return !_platform_completed;\n-  } else if (ik->defined_by_app_loader()) {\n-    \/\/ AOTLinkedClassCategory::APP cannot be loaded until the app class loader\n-    \/\/ is initialized.\n-    return !_app_completed;\n-  } else {\n-    return false;\n-  }\n-}\n-\n@@ -428,1 +330,1 @@\n-    replay_training_at_init(table->boot(),     CHECK);\n+    replay_training_at_init(table->boot1(),    CHECK);\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassBulkLoader.cpp","additions":169,"deletions":267,"binary":false,"changes":436,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n-\/\/ a AOTLinkedClassTable into their respective ClassLoaders. This happens very early\n-\/\/ in the JVM bootstrap stage, before any application code is executed.\n+\/\/ the AOTLinkedClassTable into their respective ClassLoaders. This happens very early\n+\/\/ in the JVM bootstrap stage, before any Java bytecode is executed.\n@@ -45,0 +45,6 @@\n+\/\/ IMPLEMENTATION NOTES:\n+\/\/ We also proactively link all the classes in the AOTLinkedClassTable, and move\n+\/\/ the AOT-initialized classes to the \"initialized\" state. Due to limitations\n+\/\/ of the current JVM bootstrap sequence, link_or_init_javabase_classes() and\n+\/\/ link_or_init_non_javabase_classes() need to be called after some Java bytecodes are\n+\/\/ executed. Future RFEs will move these calls to earlier stages.\n@@ -46,12 +52,7 @@\n-  static bool _boot2_completed;\n-  static bool _platform_completed;\n-  static bool _app_completed;\n-  static bool _all_completed;\n-  static void load_classes_in_loader(JavaThread* current, AOTLinkedClassCategory class_category, oop class_loader_oop);\n-  static void load_classes_in_loader_impl(AOTLinkedClassCategory class_category, oop class_loader_oop, TRAPS);\n-  static void load_table(AOTLinkedClassTable* table, AOTLinkedClassCategory class_category, Handle loader, TRAPS);\n-  static void initiate_loading(JavaThread* current, const char* category, Handle initiating_loader, Array<InstanceKlass*>* classes);\n-  static void load_classes_impl(AOTLinkedClassCategory class_category, Array<InstanceKlass*>* classes,\n-                                const char* category_name, Handle loader, TRAPS);\n-  static void load_hidden_class(ClassLoaderData* loader_data, InstanceKlass* ik, TRAPS);\n-  static void init_required_classes_for_loader(Handle class_loader, Array<InstanceKlass*>* classes, TRAPS);\n+  static void preload_classes_impl(TRAPS);\n+  static void preload_classes_in_table(Array<InstanceKlass*>* classes,\n+                                       const char* category_name, Handle loader, TRAPS);\n+  static void initiate_loading(JavaThread* current, const char* category, Handle initiating_loader,\n+                               Array<InstanceKlass*>* classes);\n+  static void link_or_init_non_javabase_classes_impl(TRAPS);\n+  static void link_or_init_classes_for_loader(Handle class_loader, Array<InstanceKlass*>* classes, TRAPS);\n@@ -59,0 +60,8 @@\n+\n+#ifdef ASSERT\n+  static void validate_module_of_preloaded_classes();\n+  static void validate_module_of_preloaded_classes_in_table(Array<InstanceKlass*>* classes,\n+                                                            const char* category_name, Handle loader);\n+  static void validate_module(Klass* k, const char* category_name, oop module_oop);\n+#endif\n+\n@@ -61,4 +70,3 @@\n-\n-  static void load_javabase_classes(JavaThread* current) NOT_CDS_RETURN;\n-  static void load_non_javabase_classes(JavaThread* current) NOT_CDS_RETURN;\n-  static void finish_loading_javabase_classes(TRAPS) NOT_CDS_RETURN;\n+  static void preload_classes(JavaThread* current);\n+  static void link_or_init_javabase_classes(JavaThread* current) NOT_CDS_RETURN;\n+  static void link_or_init_non_javabase_classes(JavaThread* current) NOT_CDS_RETURN;\n@@ -68,2 +76,0 @@\n-  static bool class_preloading_finished();\n-  static bool is_pending_aot_linked_class(Klass* k) NOT_CDS_RETURN_(false);\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassBulkLoader.hpp","additions":26,"deletions":20,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-  soc->do_ptr((void**)&_boot);\n+  soc->do_ptr((void**)&_boot1);\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassTable.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,2 +44,3 @@\n-  Array<InstanceKlass*>* _boot;  \/\/ only java.base classes\n-  Array<InstanceKlass*>* _boot2; \/\/ boot classes in other modules\n+  Array<InstanceKlass*>* _boot1; \/\/ boot classes in java.base module\n+  Array<InstanceKlass*>* _boot2; \/\/ boot classes in all other (named and unnamed) modules,\n+                                 \/\/ including classes from -Xbootclasspath\/a\n@@ -51,1 +52,1 @@\n-    _boot(nullptr), _boot2(nullptr),\n+    _boot1(nullptr), _boot2(nullptr),\n@@ -58,1 +59,1 @@\n-  Array<InstanceKlass*>* boot()     const { return _boot;     }\n+  Array<InstanceKlass*>* boot1()    const { return _boot1;    }\n@@ -63,1 +64,1 @@\n-  void set_boot    (Array<InstanceKlass*>* value) { _boot     = value; }\n+  void set_boot1   (Array<InstanceKlass*>* value) { _boot1    = value; }\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassTable.hpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -127,1 +127,1 @@\n-\/\/ [0] All classes are loaded in AOTMetaspace::preload_classes(). All metadata are\n+\/\/ [0] All classes are loaded in AOTMetaspace::load_classes(). All metadata are\n@@ -807,0 +807,17 @@\n+  if (CDSConfig::is_dumping_final_static_archive()) {\n+    \/\/ - Load and link all classes used in the training run.\n+    \/\/ - Initialize @AOTSafeClassInitializer classes that were\n+    \/\/   initialized in the training run.\n+    \/\/ - Perform per-class optimization such as AOT-resolution of\n+    \/\/   constant pool entries that were resolved during the training run.\n+    FinalImageRecipes::apply_recipes(CHECK);\n+\n+    \/\/ Because the AOT assembly phase does not run the same exact code as in the\n+    \/\/ training run (e.g., we use different lambda form invoker classes;\n+    \/\/ generated lambda form classes are not recorded in FinalImageRecipes),\n+    \/\/ the recipes do not cover all classes that have been loaded so far. As\n+    \/\/ a result, we might have some unlinked classes at this point. Since we\n+    \/\/ require cached classes to be linked, all such classes will be linked\n+    \/\/ by the following step.\n+  }\n+\n@@ -820,4 +837,0 @@\n-\n-  if (CDSConfig::is_dumping_final_static_archive()) {\n-    FinalImageRecipes::apply_recipes(CHECK);\n-  }\n@@ -826,3 +839,1 @@\n-\/\/ Preload classes from a list, populate the shared spaces and dump to a\n-\/\/ file.\n-void AOTMetaspace::preload_and_dump(TRAPS) {\n+void AOTMetaspace::dump_static_archive(TRAPS) {\n@@ -831,1 +842,1 @@\n- HandleMark hm(THREAD);\n+  HandleMark hm(THREAD);\n@@ -839,1 +850,1 @@\n-  preload_and_dump_impl(builder, THREAD);\n+  dump_static_archive_impl(builder, THREAD);\n@@ -905,1 +916,1 @@\n-void AOTMetaspace::preload_classes(TRAPS) {\n+void AOTMetaspace::load_classes(TRAPS) {\n@@ -932,2 +943,2 @@\n-  \/\/ Some classes are used at CDS runtime but are not loaded, and therefore archived, at\n-  \/\/ dumptime. We can perform dummmy calls to these classes at dumptime to ensure they\n+  \/\/ Some classes are used at CDS runtime but are not yet loaded at this point.\n+  \/\/ We can perform dummmy calls to these classes at dumptime to ensure they\n@@ -949,1 +960,1 @@\n-void AOTMetaspace::preload_and_dump_impl(StaticArchiveBuilder& builder, TRAPS) {\n+void AOTMetaspace::dump_static_archive_impl(StaticArchiveBuilder& builder, TRAPS) {\n@@ -952,1 +963,1 @@\n-    preload_classes(CHECK);\n+    load_classes(CHECK);\n","filename":"src\/hotspot\/share\/cds\/aotMetaspace.cpp","additions":26,"deletions":15,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-  static void preload_and_dump(TRAPS) NOT_CDS_RETURN;\n+  static void dump_static_archive(TRAPS) NOT_CDS_RETURN;\n@@ -82,2 +82,2 @@\n-  static void preload_and_dump_impl(StaticArchiveBuilder& builder, TRAPS) NOT_CDS_RETURN;\n-  static void preload_classes(TRAPS) NOT_CDS_RETURN;\n+  static void dump_static_archive_impl(StaticArchiveBuilder& builder, TRAPS) NOT_CDS_RETURN;\n+  static void load_classes(TRAPS) NOT_CDS_RETURN;\n","filename":"src\/hotspot\/share\/cds\/aotMetaspace.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"cds\/aotMetaspace.hpp\"\n+#include \"cds\/aotOopChecker.hpp\"\n+#include \"cds\/heapShared.hpp\"\n+#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/symbolTable.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n+#include \"oops\/instanceKlass.inline.hpp\"\n+#include \"runtime\/fieldDescriptor.inline.hpp\"\n+#include \"utilities\/debug.hpp\"\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+\n+oop AOTOopChecker::get_oop_field(oop obj, const char* name, const char* sig) {\n+  Symbol* name_sym = SymbolTable::probe(name, checked_cast<int>(strlen(name)));\n+  assert(name_sym != nullptr, \"Symbol must have been resolved for an existing field of this obj\");\n+  Symbol* sig_sym = SymbolTable::probe(sig, checked_cast<int>(strlen(sig)));\n+  assert(sig_sym != nullptr, \"Symbol must have been resolved for an existing field of this obj\");\n+\n+  fieldDescriptor fd;\n+  Klass* k = InstanceKlass::cast(obj->klass())->find_field(name_sym, sig_sym, &fd);\n+  assert(k != nullptr, \"field must exist\");\n+  precond(!fd.is_static());\n+  precond(fd.field_type() == T_OBJECT || fd.field_type() == T_ARRAY);\n+  return obj->obj_field(fd.offset());\n+}\n+\n+\/\/ Make sure we are not caching objects with assumptions that can be violated in\n+\/\/ the production run.\n+void AOTOopChecker::check(oop obj) {\n+  \/\/ Currently we only check URL objects, but more rules may be added in the future.\n+\n+  if (obj->klass()->is_subclass_of(vmClasses::URL_klass())) {\n+    \/\/ If URL could be subclassed, obj may have new fields that we don't know about.\n+    precond(vmClasses::URL_klass()->is_final());\n+\n+    \/\/ URLs are referenced by the CodeSources\/ProtectDomains that are cached\n+    \/\/ for AOT-linked classes loaded by the platform\/app loaders.\n+    \/\/\n+    \/\/ Do not cache any URLs whose URLStreamHandler can be overridden by the application.\n+    \/\/ - \"jrt\" and \"file\" will always use the built-in URLStreamHandler. See\n+    \/\/   java.net.URL::isOverrideable().\n+    \/\/ -  When an AOT-linked class is loaded from a JAR file, its URL is something\n+    \/\/    like file:HelloWorl.jar, and does NOT use the \"jar\" protocol.\n+    oop protocol = get_oop_field(obj, \"protocol\", \"Ljava\/lang\/String;\");\n+    if (!java_lang_String::equals(protocol, \"jrt\", 3) &&\n+        !java_lang_String::equals(protocol, \"file\", 4)) {\n+      ResourceMark rm;\n+      log_error(aot)(\"Must cache only URLs with jrt\/file protocols but got: %s\",\n+                     java_lang_String::as_quoted_ascii(protocol));\n+      HeapShared::debug_trace();\n+      AOTMetaspace::unrecoverable_writing_error();\n+    }\n+  }\n+}\n+\n+#endif \/\/INCLUDE_CDS_JAVA_HEAP\n","filename":"src\/hotspot\/share\/cds\/aotOopChecker.cpp","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CDS_AOTOOPCHECKER_HPP\n+#define SHARE_CDS_AOTOOPCHECKER_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+\n+class AOTOopChecker : AllStatic {\n+  static oop get_oop_field(oop obj, const char* name, const char* sig);\n+\n+public:\n+  \/\/ obj is an object that's about to be stored into the AOT cache. Check if it\n+  \/\/ can be safely cached.\n+  static void check(oop obj);\n+};\n+\n+#endif \/\/ SHARE_CDS_AOTOOPCHECKER_HPP\n","filename":"src\/hotspot\/share\/cds\/aotOopChecker.hpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -70,1 +70,2 @@\n-  return (is_dumping_archive()              ? IS_DUMPING_ARCHIVE : 0) |\n+  return (is_dumping_aot_linked_classes()   ? IS_DUMPING_AOT_LINKED_CLASSES : 0) |\n+         (is_dumping_archive()              ? IS_DUMPING_ARCHIVE : 0) |\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -83,5 +83,6 @@\n-  static const int IS_DUMPING_ARCHIVE              = 1 << 0;\n-  static const int IS_DUMPING_METHOD_HANDLES       = 1 << 1;\n-  static const int IS_DUMPING_STATIC_ARCHIVE       = 1 << 2;\n-  static const int IS_LOGGING_LAMBDA_FORM_INVOKERS = 1 << 3;\n-  static const int IS_USING_ARCHIVE                = 1 << 4;\n+  static const int IS_DUMPING_AOT_LINKED_CLASSES   = 1 << 0;\n+  static const int IS_DUMPING_ARCHIVE              = 1 << 1;\n+  static const int IS_DUMPING_METHOD_HANDLES       = 1 << 2;\n+  static const int IS_DUMPING_STATIC_ARCHIVE       = 1 << 3;\n+  static const int IS_LOGGING_LAMBDA_FORM_INVOKERS = 1 << 4;\n+  static const int IS_USING_ARCHIVE                = 1 << 5;\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.hpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -43,1 +43,3 @@\n-\/\/ -- Handling of Enum objects\n+\/\/ !!! This is legacy support for enum classes before JEP 483. This file is not used when\n+\/\/ !!! CDSConfig::is_initing_classes_at_dump_time()==true.\n+\/\/\n@@ -65,0 +67,1 @@\n+  assert(!CDSConfig::is_initing_classes_at_dump_time(), \"only for legacy support of enums\");\n","filename":"src\/hotspot\/share\/cds\/cdsEnumKlass.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,2 @@\n+\/\/ This is legacy support for enum classes before JEP 483. This code is not needed when\n+\/\/ CDSConfig::is_initing_classes_at_dump_time()==true.\n","filename":"src\/hotspot\/share\/cds\/cdsEnumKlass.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-  ADD_EXCL(\"java\/lang\/ClassLoader\",                      \"scl\");                   \/\/ A\n+  ADD_EXCL(\"java\/lang\/ClassLoader$Holder\",               \"scl\");                   \/\/ A\n@@ -150,0 +150,4 @@\n+  if (CDSConfig::is_dumping_aot_linked_classes()) {\n+    ADD_EXCL(\"java\/lang\/Package$VersionInfo\",             \"NULL_VERSION_INFO\");    \/\/ D\n+  }\n+\n@@ -231,4 +235,10 @@\n-        if (field_ik == vmClasses::internal_Unsafe_klass() && ArchiveUtils::has_aot_initialized_mirror(field_ik)) {\n-          \/\/ There's only a single instance of jdk\/internal\/misc\/Unsafe, so all references will\n-          \/\/ be pointing to this singleton, which has been archived.\n-          return;\n+        if (ArchiveUtils::has_aot_initialized_mirror(field_ik)) {\n+          if (field_ik == vmClasses::internal_Unsafe_klass()) {\n+            \/\/ There's only a single instance of jdk\/internal\/misc\/Unsafe, so all references will\n+            \/\/ be pointing to this singleton, which has been archived.\n+            return;\n+          }\n+          if (field_ik == vmClasses::Boolean_klass()) {\n+            \/\/ TODO: check if is TRUE or FALSE\n+            return;\n+          }\n","filename":"src\/hotspot\/share\/cds\/cdsHeapVerifier.cpp","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-        SystemDictionaryShared::warn_excluded(k, \"Class loader not alive\");\n+        SystemDictionaryShared::log_exclusion(k, \"Class loader not alive\");\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -441,2 +441,0 @@\n-      assert(!oak->is_typeArray_klass(), \"all type array classes must be in static archive\");\n-\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-  GrowableArray<int> tmp_cp_flags;\n+  GrowableArray<int> tmp_flags;\n@@ -73,0 +73,4 @@\n+      if (ik->is_initialized()) {\n+        flags |= WAS_INITED;\n+      }\n+\n@@ -78,1 +82,1 @@\n-            flags |= HAS_CLASS;\n+            flags |= CP_RESOLVE_CLASS;\n@@ -91,1 +95,1 @@\n-              flags |= HAS_FIELD_AND_METHOD;\n+              flags |= CP_RESOLVE_FIELD_AND_METHOD;\n@@ -106,1 +110,1 @@\n-              flags |= HAS_FIELD_AND_METHOD;\n+              flags |= CP_RESOLVE_FIELD_AND_METHOD;\n@@ -118,1 +122,1 @@\n-              flags |= HAS_INDY;\n+              flags |= CP_RESOLVE_INDY;\n@@ -130,1 +134,1 @@\n-    tmp_cp_flags.append(flags);\n+    tmp_flags.append(flags);\n@@ -136,2 +140,2 @@\n-  _cp_flags = ArchiveUtils::archive_array(&tmp_cp_flags);\n-  ArchivePtrMarker::mark_pointer(&_cp_flags);\n+  _flags = ArchiveUtils::archive_array(&tmp_flags);\n+  ArchivePtrMarker::mark_pointer(&_flags);\n@@ -145,1 +149,1 @@\n-    int flags = _cp_flags->at(i);\n+    int flags = _flags->at(i);\n@@ -155,1 +159,1 @@\n-        if ((flags & HAS_CLASS) != 0) {\n+        if ((flags & CP_RESOLVE_CLASS) != 0) {\n@@ -158,1 +162,1 @@\n-        if ((flags & HAS_FIELD_AND_METHOD) != 0) {\n+        if ((flags & CP_RESOLVE_FIELD_AND_METHOD) != 0) {\n@@ -161,1 +165,1 @@\n-        if ((flags & HAS_INDY) != 0) {\n+        if ((flags & CP_RESOLVE_INDY) != 0) {\n@@ -174,0 +178,1 @@\n+    int flags = _flags->at(i);\n@@ -191,0 +196,5 @@\n+\n+        if (ik->has_aot_safe_initializer() && (flags & WAS_INITED) != 0) {\n+          assert(ik->class_loader() == nullptr, \"supported only for boot classes for now\");\n+          ik->initialize(CHECK);\n+        }\n","filename":"src\/hotspot\/share\/cds\/finalImageRecipes.cpp","additions":22,"deletions":12,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -45,3 +45,4 @@\n-  static constexpr int HAS_CLASS            = 0x1;\n-  static constexpr int HAS_FIELD_AND_METHOD = 0x2;\n-  static constexpr int HAS_INDY             = 0x4;\n+  static constexpr int CP_RESOLVE_CLASS            = 0x1 << 0; \/\/ CP has preresolved class entries\n+  static constexpr int CP_RESOLVE_FIELD_AND_METHOD = 0x1 << 1; \/\/ CP has preresolved field\/method entries\n+  static constexpr int CP_RESOLVE_INDY             = 0x1 << 2; \/\/ CP has preresolved indy entries\n+  static constexpr int WAS_INITED                  = 0x1 << 3; \/\/ Class was initialized during training run\n@@ -53,2 +54,2 @@\n-  \/\/ For each klass k _all_klasses->at(i), _cp_recipes->at(i) lists all the {klass,field,method,indy}\n-  \/\/ cp indices that were resolved for k during the training run.\n+  \/\/ For each klass k _all_klasses->at(i): _cp_recipes->at(i) lists all the {klass,field,method,indy}\n+  \/\/ cp indices that were resolved for k during the training run; _flags->at(i) has extra info about k.\n@@ -56,1 +57,1 @@\n-  Array<int>* _cp_flags;\n+  Array<int>* _flags;\n@@ -58,1 +59,1 @@\n-  FinalImageRecipes() : _all_klasses(nullptr), _cp_recipes(nullptr), _cp_flags(nullptr) {}\n+  FinalImageRecipes() : _all_klasses(nullptr), _cp_recipes(nullptr), _flags(nullptr) {}\n","filename":"src\/hotspot\/share\/cds\/finalImageRecipes.hpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"cds\/aotOopChecker.hpp\"\n@@ -328,0 +329,2 @@\n+    AOTOopChecker::check(obj); \/\/ Make sure contents of this oop are safe.\n+\n@@ -615,1 +618,1 @@\n-static void copy_java_mirror_hashcode(oop orig_mirror, oop scratch_m) {\n+void HeapShared::copy_java_mirror(oop orig_mirror, oop scratch_m) {\n@@ -631,0 +634,5 @@\n+\n+  if (CDSConfig::is_dumping_aot_linked_classes()) {\n+    java_lang_Class::set_module(scratch_m, java_lang_Class::module(orig_mirror));\n+    java_lang_Class::set_protection_domain(scratch_m, java_lang_Class::protection_domain(orig_mirror));\n+  }\n@@ -730,1 +738,1 @@\n-    copy_java_mirror_hashcode(orig_mirror, m);\n+    copy_java_mirror(orig_mirror, m);\n@@ -1641,2 +1649,2 @@\n-    \/\/ The enum klasses are archived with aot-initialized mirror.\n-    \/\/ See AOTClassInitializer::can_archive_initialized_mirror().\n+    \/\/ The classes of all archived enum instances have been marked as aot-init,\n+    \/\/ so there's nothing else to be done in the production run.\n@@ -1644,0 +1652,2 @@\n+    \/\/ This is legacy support for enum classes before JEP 483 -- we cannot rerun\n+    \/\/ the enum's <clinit> in the production run, so special handling is needed.\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -346,0 +346,1 @@\n+  static void copy_java_mirror(oop orig_mirror, oop scratch_m);\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -203,1 +203,1 @@\n-      ClassFileStream st((u1*)buf, len, nullptr);\n+      ClassFileStream st((u1*)buf, len, \"jrt:\/java.base\");\n","filename":"src\/hotspot\/share\/cds\/lambdaFormInvokers.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2448,1 +2448,1 @@\n-      if (!vmClasses::Parameter_klass_loaded())\n+      if (!vmClasses::reflect_Parameter_klass_is_loaded())\n@@ -3982,1 +3982,1 @@\n-  if (vmClasses::Cloneable_klass_loaded()) {\n+  if (vmClasses::Cloneable_klass_is_loaded()) {\n@@ -5166,40 +5166,0 @@\n-  \/\/ AOT-related checks.\n-  \/\/ Note we cannot check this in general due to instrumentation or module patching\n-  if (CDSConfig::is_initing_classes_at_dump_time()) {\n-    \/\/ Check the aot initialization safe status.\n-    \/\/ @AOTSafeClassInitializer is used only to support ahead-of-time initialization of classes\n-    \/\/ in the AOT assembly phase.\n-    if (ik->has_aot_safe_initializer()) {\n-      \/\/ If a type is included in the tables inside can_archive_initialized_mirror(), we require that\n-      \/\/   - all super classes must be included\n-      \/\/   - all super interfaces that have <clinit> must be included.\n-      \/\/ This ensures that in the production run, we don't run the <clinit> of a supertype but skips\n-      \/\/ ik's <clinit>.\n-      if (_super_klass != nullptr) {\n-        guarantee_property(_super_klass->has_aot_safe_initializer(),\n-                           \"Missing @AOTSafeClassInitializer in superclass %s for class %s\",\n-                           _super_klass->external_name(),\n-                           CHECK);\n-      }\n-\n-      int len = _local_interfaces->length();\n-      for (int i = 0; i < len; i++) {\n-        InstanceKlass* intf = _local_interfaces->at(i);\n-        guarantee_property(intf->class_initializer() == nullptr || intf->has_aot_safe_initializer(),\n-                           \"Missing @AOTSafeClassInitializer in superinterface %s for class %s\",\n-                           intf->external_name(),\n-                           CHECK);\n-      }\n-\n-      if (log_is_enabled(Info, aot, init)) {\n-        ResourceMark rm;\n-        log_info(aot, init)(\"Found @AOTSafeClassInitializer class %s\", ik->external_name());\n-      }\n-    } else {\n-      \/\/ @AOTRuntimeSetup only meaningful in @AOTClassInitializer\n-      guarantee_property(!ik->is_runtime_setup_required(),\n-                         \"@AOTRuntimeSetup meaningless in non-@AOTSafeClassInitializer class %s\",\n-                         CHECK);\n-    }\n-  }\n-\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":2,"deletions":42,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -1195,4 +1195,1 @@\n-    if (loader == nullptr) {\n-      \/\/ JFR classes\n-      ik->set_shared_classpath_index(0);\n-    }\n+    ik->set_shared_classpath_index(-1); \/\/ unsupported location\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -283,0 +283,13 @@\n+\/\/ This is called before AOTLinkedClassBulkLoader starts preloading classes. It makes sure that\n+\/\/ when we preload any class, its module is already valid.\n+void ClassLoaderDataShared::restore_archived_modules_for_preloading_classes(JavaThread* current) {\n+  precond(CDSConfig::is_using_aot_linked_classes());\n+\n+  precond(_platform_loader_root_index >= 0);\n+  precond(_system_loader_root_index >= 0);\n+\n+  Handle h_platform_loader(current, HeapShared::get_root(_platform_loader_root_index));\n+  Handle h_system_loader(current, HeapShared::get_root(_system_loader_root_index));\n+  Modules::init_archived_modules(current, h_platform_loader, h_system_loader);\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataShared.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/macros.hpp\"\n@@ -40,0 +41,1 @@\n+  static void restore_archived_modules_for_preloading_classes(JavaThread* current) NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataShared.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1016,0 +1016,9 @@\n+  if (CDSConfig::is_using_aot_linked_classes()) {\n+    oop archived_module = java_lang_Class::module(mirror());\n+    if (archived_module != nullptr) {\n+      precond(module() == nullptr || module() == archived_module);\n+      precond(AOTMetaspace::in_aot_cache_static_region((void*)k));\n+      return;\n+    }\n+  }\n+\n@@ -1022,0 +1031,4 @@\n+    \/\/ With AOT-linked classes, java.base should have been defined before the\n+    \/\/ VM loads any classes.\n+    precond(!CDSConfig::is_using_aot_linked_classes());\n+\n@@ -1055,7 +1068,13 @@\n-  GrowableArray<Klass*>* mirror_list =\n-    new (mtClass) GrowableArray<Klass*>(40, mtClass);\n-  set_fixup_mirror_list(mirror_list);\n-\n-  GrowableArray<Klass*>* module_list =\n-    new (mtModule) GrowableArray<Klass*>(500, mtModule);\n-  set_fixup_module_field_list(module_list);\n+  if (!CDSConfig::is_using_aot_linked_classes()) {\n+    \/\/ fixup_mirror_list() is not used when we have preloaded classes. See\n+    \/\/ Universe::fixup_mirrors().\n+    GrowableArray<Klass*>* mirror_list =\n+      new (mtClass) GrowableArray<Klass*>(40, mtClass);\n+    set_fixup_mirror_list(mirror_list);\n+\n+    \/\/ With AOT-linked classes, java.base module is defined before any class\n+    \/\/ is loaded, so there's no need for fixup_module_field_list().\n+    GrowableArray<Klass*>* module_list =\n+      new (mtModule) GrowableArray<Klass*>(500, mtModule);\n+    set_fixup_module_field_list(module_list);\n+  }\n@@ -1134,1 +1153,1 @@\n-  if (vmClasses::Class_klass_loaded()) {\n+  if (vmClasses::Class_klass_is_loaded()) {\n@@ -1161,0 +1180,1 @@\n+    assert(!CDSConfig::is_using_aot_linked_classes(), \"should not come here\");\n@@ -1206,1 +1226,1 @@\n-  if (!vmClasses::Class_klass_loaded()) {\n+  if (!vmClasses::Class_klass_is_loaded() && !CDSConfig::is_using_aot_linked_classes()) {\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":29,"deletions":9,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -237,0 +237,1 @@\n+  friend class HeapShared;\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -700,0 +700,2 @@\n+  assert(!CDSConfig::is_using_aot_linked_classes(), \"patching is not necessary with AOT-linked classes\");\n+\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -703,0 +703,20 @@\n+  if (h_platform_loader.is_null()) {\n+    THROW_MSG(vmSymbols::java_lang_NullPointerException(), \"Null platform loader object\");\n+  }\n+\n+  if (h_system_loader.is_null()) {\n+    THROW_MSG(vmSymbols::java_lang_NullPointerException(), \"Null system loader object\");\n+  }\n+\n+  if (CDSConfig::is_using_aot_linked_classes()) {\n+    \/\/ Already initialized\n+    precond(SystemDictionary::java_platform_loader() == h_platform_loader());\n+    precond(SystemDictionary::java_system_loader() == h_system_loader());\n+  } else {\n+    init_archived_modules(THREAD, h_platform_loader, h_system_loader);\n+  }\n+}\n+\n+void Modules::init_archived_modules(JavaThread* current, Handle h_platform_loader, Handle h_system_loader) {\n+  assert(CDSConfig::is_using_full_module_graph(), \"must be\");\n+  ExceptionMark em(current);\n@@ -711,6 +731,3 @@\n-  Handle java_base_module(THREAD, ClassLoaderDataShared::restore_archived_oops_for_null_class_loader_data());\n-  \/\/ Patch any previously loaded class's module field with java.base's java.lang.Module.\n-  ModuleEntryTable::patch_javabase_entries(THREAD, java_base_module);\n-\n-  if (h_platform_loader.is_null()) {\n-    THROW_MSG(vmSymbols::java_lang_NullPointerException(), \"Null platform loader object\");\n+  if (CDSConfig::is_using_aot_linked_classes()) {\n+    ClassLoaderData* boot_loader_data = ClassLoaderData::the_null_class_loader_data();\n+    ClassLoaderDataShared::archived_boot_unnamed_module()->restore_archived_oops(boot_loader_data);\n@@ -719,2 +736,4 @@\n-  if (h_system_loader.is_null()) {\n-    THROW_MSG(vmSymbols::java_lang_NullPointerException(), \"Null system loader object\");\n+  Handle java_base_module(current, ClassLoaderDataShared::restore_archived_oops_for_null_class_loader_data());\n+  if (!CDSConfig::is_using_aot_linked_classes()) {\n+    \/\/ Patch any previously loaded class's module field with java.base's java.lang.Module.\n+    ModuleEntryTable::patch_javabase_entries(current, java_base_module);\n@@ -780,1 +799,3 @@\n-    unnamed_module->restore_archived_oops(boot_loader_data);\n+    if (!CDSConfig::is_using_aot_linked_classes()) {\n+      unnamed_module->restore_archived_oops(boot_loader_data);\n+    }\n","filename":"src\/hotspot\/share\/classfile\/modules.cpp","additions":30,"deletions":9,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -60,0 +60,2 @@\n+  static void init_archived_modules(JavaThread* current, Handle h_platform_loader, Handle h_system_loader)\n+                                   NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/classfile\/modules.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -199,3 +199,5 @@\n-  assert(_java_system_loader.is_empty(), \"already set!\");\n-  _java_system_loader = cld->class_loader_handle();\n-\n+  if (_java_system_loader.is_empty()) {\n+    _java_system_loader = cld->class_loader_handle();\n+  } else {\n+    assert(_java_system_loader.resolve() == cld->class_loader(), \"sanity\");\n+  }\n@@ -205,2 +207,5 @@\n-  assert(_java_platform_loader.is_empty(), \"already set!\");\n-  _java_platform_loader = cld->class_loader_handle();\n+  if (_java_platform_loader.is_empty()) {\n+    _java_platform_loader = cld->class_loader_handle();\n+  } else {\n+    assert(_java_platform_loader.resolve() == cld->class_loader(), \"sanity\");\n+  }\n@@ -1152,0 +1157,52 @@\n+\/\/ This is much more lightweight than SystemDictionary::resolve_or_null\n+\/\/ - There's only a single Java thread at this point. No need for placeholder.\n+\/\/ - All supertypes of ik have been loaded\n+\/\/ - There's no circularity (checked in AOT assembly phase)\n+\/\/ - There's no need to call java.lang.ClassLoader::load_class() because the boot\/platform\/app\n+\/\/   loaders are well-behaved\n+void SystemDictionary::preload_class(Handle class_loader, InstanceKlass* ik, TRAPS) {\n+  precond(Universe::is_bootstrapping());\n+  precond(java_platform_loader() != nullptr && java_system_loader() != nullptr);\n+  precond(class_loader() == nullptr || class_loader() == java_platform_loader() ||class_loader() == java_system_loader());\n+  precond(CDSConfig::is_using_aot_linked_classes());\n+  precond(AOTMetaspace::in_aot_cache_static_region((void*)ik));\n+  precond(!ik->is_loaded());\n+\n+#ifdef ASSERT\n+  \/\/ preload_class() must be called in the correct order -- all super types must have\n+  \/\/ already been loaded.\n+  if (ik->java_super() != nullptr) {\n+    assert(ik->java_super()->is_loaded(), \"must be\");\n+  }\n+\n+  Array<InstanceKlass*>* interfaces = ik->local_interfaces();\n+  int num_interfaces = interfaces->length();\n+  for (int index = 0; index < num_interfaces; index++) {\n+    assert(interfaces->at(index)->is_loaded(), \"must be\");\n+  }\n+#endif\n+\n+  ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());\n+  oop java_mirror = ik->archived_java_mirror();\n+  precond(java_mirror != nullptr);\n+\n+  Handle pd(THREAD, java_lang_Class::protection_domain(java_mirror));\n+  PackageEntry* pkg_entry = ik->package();\n+  assert(pkg_entry != nullptr || ClassLoader::package_from_class_name(ik->name()) == nullptr,\n+         \"non-empty packages must have been archived\");\n+\n+  \/\/ TODO: the following assert requires JDK-8365580\n+  \/\/ assert(is_shared_class_visible(ik->name(), ik, pkg_entry, class_loader), \"must be\");\n+\n+  ik->restore_unshareable_info(loader_data, pd, pkg_entry, CHECK);\n+  load_shared_class_misc(ik, loader_data);\n+  ik->add_to_hierarchy(THREAD);\n+\n+  if (!ik->is_hidden()) {\n+    update_dictionary(THREAD, ik, loader_data);\n+  }\n+\n+  assert(java_lang_Class::module(java_mirror) != nullptr, \"must have been archived\");\n+  assert(ik->is_loaded(), \"Must be in at least loaded state\");\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":62,"deletions":5,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -329,1 +329,1 @@\n-  \/\/ Used by SystemDictionaryShared and LambdaProxyClassDictionary\n+  \/\/ Used by AOTLinkedClassBulkLoader, LambdaProxyClassDictionary, and SystemDictionaryShared\n@@ -340,0 +340,1 @@\n+  static void preload_class(Handle class_loader, InstanceKlass* ik, TRAPS);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -357,2 +357,1 @@\n-\/\/ Returns true so the caller can do:    return warn_excluded(\".....\");\n-bool SystemDictionaryShared::warn_excluded(InstanceKlass* k, const char* reason) {\n+void SystemDictionaryShared::log_exclusion(InstanceKlass* k, const char* reason, bool is_warning) {\n@@ -360,2 +359,5 @@\n-  aot_log_warning(aot)(\"Skipping %s: %s\", k->name()->as_C_string(), reason);\n-  return true;\n+  if (is_warning) {\n+    aot_log_warning(aot)(\"Skipping %s: %s\", k->name()->as_C_string(), reason);\n+  } else {\n+    aot_log_info(aot)(\"Skipping %s: %s\", k->name()->as_C_string(), reason);\n+  }\n@@ -380,0 +382,11 @@\n+  bool log_warning = false;\n+  const char* error = check_self_exclusion_helper(k, log_warning);\n+  if (error != nullptr) {\n+    log_exclusion(k, error, log_warning);\n+    return true; \/\/ Should be excluded\n+  } else {\n+    return false; \/\/ Should not be excluded\n+  }\n+}\n+\n+const char* SystemDictionaryShared::check_self_exclusion_helper(InstanceKlass* k, bool& log_warning) {\n@@ -383,1 +396,1 @@\n-    return false; \/\/ Do not exclude: unregistered classes are passed from preimage to final image.\n+    return nullptr; \/\/ Do not exclude: unregistered classes are passed from preimage to final image.\n@@ -387,1 +400,2 @@\n-    return warn_excluded(k, \"In error state\");\n+    log_warning = true;\n+    return \"In error state\";\n@@ -390,1 +404,1 @@\n-    return warn_excluded(k, \"A scratch class\");\n+    return \"A scratch class\";\n@@ -393,1 +407,1 @@\n-    return warn_excluded(k, \"Not in loaded state\");\n+    return \"Not in loaded state\";\n@@ -396,1 +410,1 @@\n-    return warn_excluded(k, \"Has been redefined\");\n+    return \"Has been redefined\";\n@@ -404,3 +418,1 @@\n-        ResourceMark rm;\n-        aot_log_info(aot)(\"Skipping %s because it is dynamically generated\", k->name()->as_C_string());\n-        return true; \/\/ exclude without warning\n+        return \"dynamically generated\";\n@@ -411,1 +423,1 @@\n-      return warn_excluded(k, \"Unsupported location\");\n+      return \"Unsupported location\";\n@@ -418,1 +430,1 @@\n-    return warn_excluded(k, \"Signed JAR\");\n+    return \"Signed JAR\";\n@@ -425,1 +437,1 @@\n-    return warn_excluded(k, \"JFR event class\");\n+    return \"JFR event class\";\n@@ -430,1 +442,2 @@\n-      return warn_excluded(k, \"Failed verification\");\n+      log_warning = true;\n+      return \"Failed verification\";\n@@ -436,1 +449,1 @@\n-      return warn_excluded(k, \"Unlinked class not supported by AOTClassLinking\");\n+      return \"Unlinked class not supported by AOTClassLinking\";\n@@ -440,1 +453,1 @@\n-      return warn_excluded(k, \"Unlinked class not supported by AOTConfiguration\");\n+      return \"Unlinked class not supported by AOTConfiguration\";\n@@ -450,1 +463,1 @@\n-      return warn_excluded(k, \"Old class has been linked\");\n+      return \"Old class has been linked\";\n@@ -455,3 +468,1 @@\n-    ResourceMark rm;\n-    aot_log_info(aot)(\"Skipping %s: used only when dumping CDS archive\", k->name()->as_C_string());\n-    return true;\n+    return \"used only when dumping CDS archive\";\n@@ -460,1 +471,1 @@\n-  return false;\n+  return nullptr;\n@@ -514,1 +525,1 @@\n-    aot_log_warning(aot)(\"Skipping %s: %s %s is excluded\", k->name()->as_C_string(), type, dependency->name()->as_C_string());\n+    aot_log_info(aot)(\"Skipping %s: %s %s is excluded\", k->name()->as_C_string(), type, dependency->name()->as_C_string());\n@@ -841,1 +852,1 @@\n-        SystemDictionaryShared::warn_excluded(k, \"Duplicated unregistered class\");\n+        SystemDictionaryShared::log_exclusion(k, \"Duplicated unregistered class\");\n@@ -970,1 +981,1 @@\n-  warn_excluded(ik, \"From ClassFileLoadHook\");\n+  log_exclusion(ik, \"From ClassFileLoadHook\");\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":37,"deletions":26,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -183,0 +183,1 @@\n+  static const char* check_self_exclusion_helper(InstanceKlass* k, bool& log_warning);\n@@ -280,1 +281,1 @@\n-  static bool warn_excluded(InstanceKlass* k, const char* reason);\n+  static void log_exclusion(InstanceKlass* k, const char* reason, bool is_warning = false);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -240,1 +240,1 @@\n-        SystemDictionaryShared::warn_excluded(klass, \"Verified with old verifier\");\n+        SystemDictionaryShared::log_exclusion(klass, \"Verified with old verifier\");\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,1 +104,5 @@\n-    resolve(id, CHECK);\n+    if (CDSConfig::is_using_aot_linked_classes()) {\n+      precond(klass_at(id)->is_loaded());\n+    } else {\n+      resolve(id, CHECK);\n+    }\n@@ -112,1 +116,1 @@\n-  assert(!Object_klass_loaded(), \"well-known classes should only be initialized once\");\n+  assert(!Object_klass_is_loaded(), \"well-known classes should only be initialized once\");\n@@ -118,0 +122,4 @@\n+  if (CDSConfig::is_using_aot_linked_classes()) {\n+    AOTLinkedClassBulkLoader::preload_classes(THREAD);\n+  }\n+\n@@ -213,3 +221,0 @@\n-  if (CDSConfig::is_using_aot_linked_classes()) {\n-    AOTLinkedClassBulkLoader::load_javabase_classes(THREAD);\n-  }\n","filename":"src\/hotspot\/share\/classfile\/vmClasses.cpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -105,6 +105,0 @@\n-\n-  static bool Object_klass_loaded()         { return is_loaded(VM_CLASS_AT(Object_klass));             }\n-  static bool Class_klass_loaded()          { return is_loaded(VM_CLASS_AT(Class_klass));              }\n-  static bool Cloneable_klass_loaded()      { return is_loaded(VM_CLASS_AT(Cloneable_klass));          }\n-  static bool Parameter_klass_loaded()      { return is_loaded(VM_CLASS_AT(reflect_Parameter_klass));  }\n-  static bool ClassLoader_klass_loaded()    { return is_loaded(VM_CLASS_AT(ClassLoader_klass));        }\n","filename":"src\/hotspot\/share\/classfile\/vmClasses.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -451,1 +451,2 @@\n-  assert(entry_offset[0] == 0, \"sanity check\");\n+  assert(entry_offset[I2C] == 0, \"sanity check\");\n+#ifdef ASSERT\n@@ -454,3 +455,4 @@\n-    assert((entry_offset[i] > 0 && entry_offset[i] < cb->insts()->size()) ||\n-           (entry_offset[i] == -1),\n-           \"invalid entry offset[%d] = 0x%x\", i, entry_offset[i]);\n+    int offset = entry_offset[i];\n+    assert((offset > 0 && offset < cb->insts()->size()) ||\n+           (i >= C2I_No_Clinit_Check && offset == -1),\n+           \"invalid entry offset[%d] = 0x%x\", i, offset);\n@@ -458,3 +460,4 @@\n-  _c2i_offset = entry_offset[1];\n-  _c2i_unverified_offset = entry_offset[2];\n-  _c2i_no_clinit_check_offset = entry_offset[3];\n+#endif \/\/ ASSERT\n+  _c2i_offset = entry_offset[C2I];\n+  _c2i_unverified_offset = entry_offset[C2I_Unverified];\n+  _c2i_no_clinit_check_offset = entry_offset[C2I_No_Clinit_Check];\n@@ -481,7 +484,0 @@\n-void AdapterBlob::get_offsets(int entry_offset[ENTRY_COUNT]) {\n-  entry_offset[0] = 0;\n-  entry_offset[1] = _c2i_offset;\n-  entry_offset[2] = _c2i_unverified_offset;\n-  entry_offset[3] = _c2i_no_clinit_check_offset;\n-}\n-\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":10,"deletions":14,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -408,1 +408,7 @@\n-  static const int ENTRY_COUNT = 4;\n+  enum Entry {\n+    I2C,\n+    C2I,\n+    C2I_Unverified,\n+    C2I_No_Clinit_Check,\n+    ENTRY_COUNT\n+  };\n@@ -418,1 +424,4 @@\n-  void get_offsets(int entry_offset[ENTRY_COUNT]);\n+  address i2c_entry() { return code_begin(); }\n+  address c2i_entry() { return i2c_entry() + _c2i_offset; }\n+  address c2i_unverified_entry() { return i2c_entry() + _c2i_unverified_offset; }\n+  address c2i_no_clinit_check_entry() { return _c2i_no_clinit_check_offset == -1 ? nullptr : i2c_entry() + _c2i_no_clinit_check_offset; }\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -794,5 +794,0 @@\n-\n-static void clean_ic_if_metadata_is_dead(CompiledIC *ic) {\n-  ic->clean_metadata();\n-}\n-\n@@ -801,2 +796,1 @@\n-static void clean_if_nmethod_is_unloaded(CallsiteT* callsite, nmethod* from,\n-                                         bool clean_all) {\n+static void clean_if_nmethod_is_unloaded(CallsiteT* callsite, bool clean_all) {\n@@ -877,1 +871,1 @@\n-        clean_ic_if_metadata_is_dead(CompiledIC_at(&iter));\n+        CompiledIC_at(&iter)->clean_metadata();\n@@ -880,1 +874,1 @@\n-      clean_if_nmethod_is_unloaded(CompiledIC_at(&iter), this, clean_all);\n+      clean_if_nmethod_is_unloaded(CompiledIC_at(&iter), clean_all);\n@@ -885,1 +879,1 @@\n-      clean_if_nmethod_is_unloaded(CompiledDirectCall::at(iter.reloc()), this, clean_all);\n+      clean_if_nmethod_is_unloaded(CompiledDirectCall::at(iter.reloc()), clean_all);\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1083,0 +1083,9 @@\n+struct NMethodMarkingScope : StackObj {\n+  NMethodMarkingScope() {\n+    nmethod::oops_do_marking_prologue();\n+  }\n+  ~NMethodMarkingScope() {\n+    nmethod::oops_do_marking_epilogue();\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -855,7 +855,0 @@\n-#if INCLUDE_JVMCI\n-  if (EnableJVMCI && UseJVMCICompiler &&\n-      comp_level == CompLevel_full_optimization CDS_ONLY(&& !AOTLinkedClassBulkLoader::class_preloading_finished())) {\n-    return nullptr;\n-  }\n-#endif\n-\n@@ -1455,6 +1448,1 @@\n-#if INCLUDE_JVMCI\n-  if (EnableJVMCI && UseJVMCICompiler &&\n-      next_level == CompLevel_full_optimization CDS_ONLY(&& !AOTLinkedClassBulkLoader::class_preloading_finished())) {\n-    next_level = cur_level;\n-  }\n-#endif\n+\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.cpp","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -483,0 +483,5 @@\n+\n+    if (is_shutting_down()) {\n+      stall_for_vm_shutdown();\n+      return nullptr;\n+    }\n@@ -717,0 +722,5 @@\n+\n+    if (is_shutting_down()) {\n+      stall_for_vm_shutdown();\n+      return nullptr;\n+    }\n@@ -1554,4 +1564,0 @@\n-bool G1CollectedHeap::concurrent_mark_is_terminating() const {\n-  return _cm_thread->should_terminate();\n-}\n-\n@@ -1884,1 +1890,1 @@\n-    if (op.terminating()) {\n+    if (is_shutting_down()) {\n@@ -2514,7 +2520,1 @@\n-  \/\/ Clear current young cset group to allow adding.\n-  \/\/ It is fine to clear it this late - evacuation does not add any remembered sets\n-  \/\/ by itself, but only marks cards.\n-  \/\/ The regions had their association to this group already removed earlier.\n-  young_regions_cset_group()->clear();\n-\n-  collection_set()->start_incremental_building();\n+  collection_set()->start();\n@@ -2876,6 +2876,1 @@\n-  collection_set()->clear();\n-  collection_set()->stop_incremental_building();\n-\n-  collection_set()->abandon_all_candidates();\n-\n-  young_regions_cset_group()->clear(true \/* uninstall_group_cardset *\/);\n+  collection_set()->abandon();\n@@ -3244,6 +3239,0 @@\n-\n-void G1CollectedHeap::prepare_group_cardsets_for_scan() {\n-  young_regions_cardset()->reset_table_scanner_for_groups();\n-\n-  collection_set()->prepare_for_scan();\n-}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":13,"deletions":24,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -808,5 +808,0 @@\n-  G1CardSet* young_regions_cardset() { return _young_regions_cset_group.card_set(); };\n-\n-  G1MonotonicArenaMemoryStats young_regions_card_set_memory_stats() { return _young_regions_cset_group.card_set_memory_stats(); }\n-\n-  void prepare_group_cardsets_for_scan();\n@@ -917,3 +912,0 @@\n-  \/\/ Returns whether concurrent mark threads (and the VM) are about to terminate.\n-  bool concurrent_mark_is_terminating() const;\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -102,0 +102,8 @@\n+void G1CollectionSet::abandon() {\n+  _g1h->young_regions_cset_group()->clear(true \/* uninstall_cset_group *\/);\n+  clear();\n+  abandon_all_candidates();\n+\n+  stop_incremental_building();\n+}\n+\n@@ -108,0 +116,1 @@\n+  _g1h->young_regions_cset_group()->card_set()->reset_table_scanner_for_groups();\n@@ -130,1 +139,1 @@\n-void G1CollectionSet::start_incremental_building() {\n+void G1CollectionSet::start() {\n@@ -136,0 +145,3 @@\n+\n+  G1CSetCandidateGroup* young_group = _g1h->young_regions_cset_group();\n+  young_group->clear();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -230,0 +230,1 @@\n+\n@@ -237,0 +238,2 @@\n+  \/\/ Drop the collection set and collection set candidates.\n+  void abandon();\n@@ -264,0 +267,2 @@\n+  uint groups_increment_length() const;\n+\n@@ -269,2 +274,2 @@\n-  \/\/ Initialize incremental collection set info.\n-  void start_incremental_building();\n+  \/\/ Start a new collection set for the next mutator phase.\n+  void start();\n@@ -285,2 +290,0 @@\n-  uint groups_increment_length() const;\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-  uint length = groups_increment_length();\n@@ -36,1 +35,6 @@\n-  if (length == 0) {\n+  if (offset == 0) {\n+    G1HeapRegionRemSet::iterate_for_merge(_g1h->young_regions_cset_group()->card_set(), cl);\n+  }\n+\n+  uint next_increment_length = groups_increment_length();\n+  if (next_increment_length == 0) {\n@@ -40,1 +44,1 @@\n-  uint start_pos = (worker_id * length) \/ num_workers;\n+  uint start_pos = (worker_id * next_increment_length) \/ num_workers;\n@@ -47,1 +51,1 @@\n-    if (cur_pos == length) {\n+    if (cur_pos == next_increment_length) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.inline.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -125,0 +125,4 @@\n+  size_t cards_occupied() const {\n+    return _card_set.occupied();\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-#include \"gc\/shared\/strongRootsScope.hpp\"\n@@ -1887,1 +1886,1 @@\n-  if (!cm_thread()->in_progress() && !_g1h->concurrent_mark_is_terminating()) {\n+  if (!cm_thread()->in_progress() && !_g1h->is_shutting_down()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+  _mark_stats_cache.reset();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -57,5 +57,11 @@\n-  if ((G1PeriodicGCSystemLoadThreshold > 0.0f) &&\n-      (os::loadavg(&recent_load, 1) == -1 || recent_load > G1PeriodicGCSystemLoadThreshold)) {\n-    log_debug(gc, periodic)(\"Load %1.2f is higher than threshold %1.2f. Skipping.\",\n-                            recent_load, G1PeriodicGCSystemLoadThreshold);\n-    return false;\n+  if (G1PeriodicGCSystemLoadThreshold > 0.0) {\n+    if (os::loadavg(&recent_load, 1) == -1) {\n+      G1PeriodicGCSystemLoadThreshold = 0.0;\n+      log_warning(gc, periodic)(\"System loadavg() call failed, \"\n+                                \"disabling G1PeriodicGCSystemLoadThreshold check.\");\n+      \/\/ Fall through and start the periodic GC.\n+    } else if (recent_load > G1PeriodicGCSystemLoadThreshold) {\n+      log_debug(gc, periodic)(\"Load %1.2f is higher than threshold %1.2f. Skipping.\",\n+                              recent_load, G1PeriodicGCSystemLoadThreshold);\n+      return false;\n+    }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1PeriodicGCTask.cpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -672,0 +672,1 @@\n+  assert(!_g1h->is_shutting_down(), \"Invariant!\");\n@@ -1278,1 +1279,1 @@\n-  if (_g1h->concurrent_mark_is_terminating()) {\n+  if (_g1h->is_shutting_down()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-  reset();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionMarkStatsCache.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -106,0 +106,2 @@\n+  \/\/ Initialize cache. Does not reset the cache immediately to avoid the cost\n+  \/\/ during startup.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionMarkStatsCache.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1027,1 +1027,1 @@\n-              _g1h->concurrent_mark_is_terminating()) &&\n+              _g1h->is_shutting_down()) &&\n@@ -1169,4 +1169,0 @@\n-        if (_initial_evacuation) {\n-          G1HeapRegionRemSet::iterate_for_merge(g1h->young_regions_cardset(), merge);\n-        }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -67,1 +67,0 @@\n-  _terminating(false),\n@@ -86,3 +85,0 @@\n-  \/\/ Record for handling by caller.\n-  _terminating = g1h->concurrent_mark_is_terminating();\n-\n@@ -92,7 +88,1 @@\n-  if (_terminating && GCCause::is_user_requested_gc(_gc_cause)) {\n-    \/\/ When terminating, the request to initiate a concurrent cycle will be\n-    \/\/ ignored by do_collection_pause_at_safepoint; instead it will just do\n-    \/\/ a young-only or mixed GC (depending on phase).  For a user request\n-    \/\/ there's no point in even doing that much, so done.  For some non-user\n-    \/\/ requests the alternative GC might still be needed.\n-  } else if (!g1h->policy()->force_concurrent_start_if_outside_cycle(_gc_cause)) {\n+  if (!g1h->policy()->force_concurrent_start_if_outside_cycle(_gc_cause)) {\n@@ -122,1 +112,0 @@\n-\n@@ -159,0 +148,8 @@\n+  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+  if (g1h->is_shutting_down()) {\n+    Heap_lock->unlock();\n+    \/\/ JVM shutdown has started. This ensures that any further operations will be properly aborted\n+    \/\/ and will not interfere with the shutdown process.\n+    g1h->concurrent_mark()->abort_marking_threads();\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.cpp","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-  bool _terminating;\n@@ -66,1 +65,0 @@\n-  bool terminating() const { return _terminating; }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -509,1 +509,1 @@\n-    _g1h->prepare_group_cardsets_for_scan();\n+    _g1h->collection_set()->prepare_for_scan();\n@@ -519,1 +519,1 @@\n-    sampled_card_set_stats.add(_g1h->young_regions_card_set_memory_stats());\n+    sampled_card_set_stats.add(_g1h->young_regions_cset_group()->card_set_memory_stats());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -121,3 +121,8 @@\n-int MutableNUMASpace::lgrp_space_index(int lgrp_id) const {\n-  return lgrp_spaces()->find_if([&](LGRPSpace* space) {\n-    return space->lgrp_id() == checked_cast<uint>(lgrp_id);\n+MutableNUMASpace::LGRPSpace *MutableNUMASpace::lgrp_space_for_thread(Thread* thr) const {\n+  guarantee(thr != nullptr, \"No thread\");\n+\n+  int lgrp_id = thr->lgrp_id();\n+  assert(lgrp_id != -1, \"lgrp_id must be set during thread creation\");\n+\n+  int lgrp_spaces_index = lgrp_spaces()->find_if([&](LGRPSpace* space) {\n+    return space->lgrp_id() == (uint)lgrp_id;\n@@ -125,0 +130,3 @@\n+\n+  assert(lgrp_spaces_index != -1, \"must have created spaces for all lgrp_ids\");\n+  return lgrp_spaces()->at(lgrp_spaces_index);\n@@ -128,21 +136,1 @@\n-  guarantee(thr != nullptr, \"No thread\");\n-  int lgrp_id = thr->lgrp_id();\n-  if (lgrp_id == -1) {\n-    \/\/ This case can occur after the topology of the system has\n-    \/\/ changed. Thread can change their location, the new home\n-    \/\/ group will be determined during the first allocation\n-    \/\/ attempt. For now we can safely assume that all spaces\n-    \/\/ have equal size because the whole space will be reinitialized.\n-    if (lgrp_spaces()->length() > 0) {\n-      return capacity_in_bytes() \/ lgrp_spaces()->length();\n-    } else {\n-      assert(false, \"There should be at least one locality group\");\n-      return 0;\n-    }\n-  }\n-  \/\/ That's the normal case, where we know the locality group of the thread.\n-  int i = lgrp_space_index(lgrp_id);\n-  if (i == -1) {\n-    return 0;\n-  }\n-  return lgrp_spaces()->at(i)->space()->capacity_in_bytes();\n+  return lgrp_space_for_thread(thr)->space()->capacity_in_bytes();\n@@ -152,16 +140,1 @@\n-  \/\/ Please see the comments for tlab_capacity().\n-  guarantee(thr != nullptr, \"No thread\");\n-  int lgrp_id = thr->lgrp_id();\n-  if (lgrp_id == -1) {\n-    if (lgrp_spaces()->length() > 0) {\n-      return (used_in_bytes()) \/ lgrp_spaces()->length();\n-    } else {\n-      assert(false, \"There should be at least one locality group\");\n-      return 0;\n-    }\n-  }\n-  int i = lgrp_space_index(lgrp_id);\n-  if (i == -1) {\n-    return 0;\n-  }\n-  return lgrp_spaces()->at(i)->space()->used_in_bytes();\n+  return lgrp_space_for_thread(thr)->space()->used_in_bytes();\n@@ -170,1 +143,0 @@\n-\n@@ -172,16 +144,1 @@\n-  \/\/ Please see the comments for tlab_capacity().\n-  guarantee(thr != nullptr, \"No thread\");\n-  int lgrp_id = thr->lgrp_id();\n-  if (lgrp_id == -1) {\n-    if (lgrp_spaces()->length() > 0) {\n-      return free_in_bytes() \/ lgrp_spaces()->length();\n-    } else {\n-      assert(false, \"There should be at least one locality group\");\n-      return 0;\n-    }\n-  }\n-  int i = lgrp_space_index(lgrp_id);\n-  if (i == -1) {\n-    return 0;\n-  }\n-  return lgrp_spaces()->at(i)->space()->free_in_bytes();\n+  return lgrp_space_for_thread(thr)->space()->free_in_bytes();\n@@ -531,11 +488,0 @@\n-\/*\n-   Linux supports static memory binding, therefore the most part of the\n-   logic dealing with the possible invalid page allocation is effectively\n-   disabled. Besides there is no notion of the home node in Linux. A\n-   thread is allowed to migrate freely. Although the scheduler is rather\n-   reluctant to move threads between the nodes. We check for the current\n-   node every allocation. And with a high probability a thread stays on\n-   the same node for some time allowing local access to recently allocated\n-   objects.\n- *\/\n-\n@@ -543,6 +489,1 @@\n-  Thread* thr = Thread::current();\n-  int lgrp_id = thr->lgrp_id();\n-  if (lgrp_id == -1 || !os::numa_has_group_homing()) {\n-    lgrp_id = os::numa_get_group_id();\n-    thr->set_lgrp_id(lgrp_id);\n-  }\n+  Thread *thr = Thread::current();\n@@ -550,7 +491,4 @@\n-  int i = lgrp_space_index(lgrp_id);\n-  \/\/ It is possible that a new CPU has been hotplugged and\n-  \/\/ we haven't reshaped the space accordingly.\n-  if (i == -1) {\n-    i = os::random() % lgrp_spaces()->length();\n-  }\n-  LGRPSpace *ls = lgrp_spaces()->at(i);\n+  \/\/ Update the locality group to match where the thread actually is.\n+  thr->update_lgrp_id();\n+\n+  LGRPSpace *ls = lgrp_space_for_thread(thr);\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.cpp","additions":19,"deletions":81,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-  int lgrp_space_index(int lgrp_id) const;\n+  LGRPSpace *lgrp_space_for_thread(Thread *thr) const;\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -329,0 +329,5 @@\n+\n+      if (is_shutting_down()) {\n+        stall_for_vm_shutdown();\n+        return nullptr;\n+      }\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1663,1 +1663,0 @@\n-  uint _num_workers;\n@@ -1669,1 +1668,0 @@\n-      _num_workers(active_workers),\n@@ -1674,1 +1672,1 @@\n-    {\n+    if (worker_id == 0) {\n@@ -1676,2 +1674,2 @@\n-      PSParallelCompact::fill_dead_objs_in_dense_prefix(worker_id, _num_workers);\n-      log_trace(gc, phases)(\"Fill dense prefix by worker %u: %.3f ms\", worker_id, (Ticks::now() - start).seconds() * 1000);\n+      PSParallelCompact::fill_dead_objs_in_dense_prefix();\n+      log_trace(gc, phases)(\"Fill dense prefix by worker 0: %.3f ms\", (Ticks::now() - start).seconds() * 1000);\n@@ -1690,0 +1688,1 @@\n+      \/\/ The preceding live obj.\n@@ -1691,2 +1690,2 @@\n-      HeapWord* after_obj = obj_start + cast_to_oop(obj_start)->size();\n-      assert(after_obj == start, \"precondition\");\n+      HeapWord* obj_end = obj_start + cast_to_oop(obj_start)->size();\n+      assert(obj_end == start, \"precondition\");\n@@ -1706,1 +1705,1 @@\n-void PSParallelCompact::fill_dead_objs_in_dense_prefix(uint worker_id, uint num_workers) {\n+void PSParallelCompact::fill_dead_objs_in_dense_prefix() {\n@@ -1712,12 +1711,1 @@\n-  if (bottom == prefix_end) {\n-    return;\n-  }\n-\n-  size_t bottom_region = _summary_data.addr_to_region_idx(bottom);\n-  size_t prefix_end_region = _summary_data.addr_to_region_idx(prefix_end);\n-\n-  size_t start_region;\n-  size_t end_region;\n-  split_regions_for_worker(bottom_region, prefix_end_region,\n-                           worker_id, num_workers,\n-                           &start_region, &end_region);\n+  const size_t region_size = ParallelCompactData::RegionSize;\n@@ -1725,3 +1713,3 @@\n-  if (start_region == end_region) {\n-    return;\n-  }\n+  \/\/ Fill dead space in [start_addr, end_addr)\n+  HeapWord* const start_addr = bottom;\n+  HeapWord* const end_addr   = prefix_end;\n@@ -1729,2 +1717,11 @@\n-  HeapWord* const start_addr = _summary_data.region_to_addr(start_region);\n-  HeapWord* const end_addr = _summary_data.region_to_addr(end_region);\n+  for (HeapWord* cur_addr = start_addr; cur_addr < end_addr; \/* empty *\/) {\n+    RegionData* cur_region_ptr = _summary_data.addr_to_region_ptr(cur_addr);\n+    if (cur_region_ptr->data_size() == region_size) {\n+      \/\/ Full; no dead space. Next region.\n+      if (_summary_data.is_region_aligned(cur_addr)) {\n+        cur_addr += region_size;\n+      } else {\n+        cur_addr = _summary_data.region_align_up(cur_addr);\n+      }\n+      continue;\n+    }\n@@ -1732,10 +1729,4 @@\n-  \/\/ Skip live partial obj (if any) from previous region.\n-  HeapWord* cur_addr;\n-  RegionData* start_region_ptr = _summary_data.region(start_region);\n-  if (start_region_ptr->partial_obj_size() != 0) {\n-    HeapWord* partial_obj_start = start_region_ptr->partial_obj_addr();\n-    assert(bitmap->is_marked(partial_obj_start), \"inv\");\n-    cur_addr = partial_obj_start + cast_to_oop(partial_obj_start)->size();\n-  } else {\n-    cur_addr = start_addr;\n-  }\n+    \/\/ Fill dead space inside cur_region.\n+    if (_summary_data.is_region_aligned(cur_addr)) {\n+      cur_addr += cur_region_ptr->partial_obj_size();\n+    }\n@@ -1743,7 +1734,7 @@\n-  \/\/ end_addr is inclusive to handle regions starting with dead space.\n-  while (cur_addr <= end_addr) {\n-    \/\/ Use prefix_end to handle trailing obj in each worker region-chunk.\n-    HeapWord* live_start = bitmap->find_obj_beg(cur_addr, prefix_end);\n-    if (cur_addr != live_start) {\n-      \/\/ Only worker 0 handles proceeding dead space.\n-      if (cur_addr != start_addr || worker_id == 0) {\n+    HeapWord* region_end_addr = _summary_data.region_align_up(cur_addr + 1);\n+    assert(region_end_addr <= end_addr, \"inv\");\n+    while (cur_addr < region_end_addr) {\n+      \/\/ Use end_addr to allow filler-obj to cross region boundary.\n+      HeapWord* live_start = bitmap->find_obj_beg(cur_addr, end_addr);\n+      if (cur_addr != live_start) {\n+        \/\/ Found dead space [cur_addr, live_start).\n@@ -1752,0 +1743,6 @@\n+      if (live_start >= region_end_addr) {\n+        cur_addr = live_start;\n+        break;\n+      }\n+      assert(bitmap->is_marked(live_start), \"inv\");\n+      cur_addr = live_start + cast_to_oop(live_start)->size();\n@@ -1753,5 +1750,0 @@\n-    if (live_start >= end_addr) {\n-      break;\n-    }\n-    assert(bitmap->is_marked(live_start), \"inv\");\n-    cur_addr = live_start + cast_to_oop(live_start)->size();\n@@ -1790,7 +1782,31 @@\n-  HeapWord* cur_addr = bottom;\n-  while (cur_addr < dense_prefix_end) {\n-    oop obj = cast_to_oop(cur_addr);\n-    oopDesc::verify(obj);\n-    if (!mark_bitmap()->is_marked(cur_addr)) {\n-      Klass* k = cast_to_oop(cur_addr)->klass();\n-      assert(k == Universe::fillerArrayKlass() || k == vmClasses::FillerObject_klass(), \"inv\");\n+\n+  const size_t region_size = ParallelCompactData::RegionSize;\n+\n+  for (HeapWord* cur_addr = bottom; cur_addr < dense_prefix_end; \/* empty *\/) {\n+    RegionData* cur_region_ptr = _summary_data.addr_to_region_ptr(cur_addr);\n+    if (cur_region_ptr->data_size() == region_size) {\n+      \/\/ Full; no dead space. Next region.\n+      if (_summary_data.is_region_aligned(cur_addr)) {\n+        cur_addr += region_size;\n+      } else {\n+        cur_addr = _summary_data.region_align_up(cur_addr);\n+      }\n+      continue;\n+    }\n+\n+    \/\/ This region contains filler objs.\n+    if (_summary_data.is_region_aligned(cur_addr)) {\n+      cur_addr += cur_region_ptr->partial_obj_size();\n+    }\n+\n+    HeapWord* region_end_addr = _summary_data.region_align_up(cur_addr + 1);\n+    assert(region_end_addr <= dense_prefix_end, \"inv\");\n+\n+    while (cur_addr < region_end_addr) {\n+      oop obj = cast_to_oop(cur_addr);\n+      oopDesc::verify(obj);\n+      if (!mark_bitmap()->is_marked(cur_addr)) {\n+        Klass* k = cast_to_oop(cur_addr)->klass();\n+        assert(k == Universe::fillerArrayKlass() || k == vmClasses::FillerObject_klass(), \"inv\");\n+      }\n+      cur_addr += obj->size();\n@@ -1798,1 +1814,0 @@\n-    cur_addr += obj->size();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":70,"deletions":55,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -758,1 +758,1 @@\n-  static void fill_dead_objs_in_dense_prefix(uint worker_id, uint num_workers);\n+  static void fill_dead_objs_in_dense_prefix();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-#include \"gc\/shared\/strongRootsScope.hpp\"\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -317,1 +317,1 @@\n-  assert(result, \"inv\");\n+  assert(result || UseNUMA, \"inv\");\n","filename":"src\/hotspot\/share\/gc\/parallel\/psYoungGen.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -810,1 +810,1 @@\n-void DefNewGeneration::gc_epilogue(bool full) {\n+void DefNewGeneration::gc_epilogue() {\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-  void gc_epilogue(bool full);\n+  void gc_epilogue();\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-#include \"gc\/shared\/strongRootsScope.hpp\"\n@@ -486,3 +485,1 @@\n-    StrongRootsScope srs(0);\n-\n-    MarkingNMethodClosure mark_code_closure(&follow_root_closure);\n+    GCTraceTime(Debug, gc, phases) tm_m(\"Marking From Roots\", gc_timer());\n@@ -497,2 +494,7 @@\n-    \/\/ 2. Threads stack frames and active nmethods in them.\n-    Threads::oops_do(&follow_root_closure, &mark_code_closure);\n+    {\n+      \/\/ 2. Threads stack frames and active nmethods in them.\n+      NMethodMarkingScope nmethod_marking_scope;\n+      MarkingNMethodClosure mark_code_closure(&follow_root_closure);\n+\n+      Threads::oops_do(&follow_root_closure, &mark_code_closure);\n+    }\n","filename":"src\/hotspot\/share\/gc\/serial\/serialFullGC.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -343,0 +343,5 @@\n+    if (is_shutting_down()) {\n+      stall_for_vm_shutdown();\n+      return nullptr;\n+    }\n+\n@@ -777,1 +782,1 @@\n-  _young_gen->gc_epilogue(full);\n+  _young_gen->gc_epilogue();\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1223,1 +1223,1 @@\n-    if (new_live.is_NotEmpty()) {\n+    if (!new_live.is_Empty()) {\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -388,0 +388,6 @@\n+\n+    if (is_shutting_down()) {\n+      stall_for_vm_shutdown();\n+      return nullptr;\n+    }\n+\n@@ -606,0 +612,17 @@\n+bool CollectedHeap::is_shutting_down() const {\n+  return Universe::is_shutting_down();\n+}\n+\n+void CollectedHeap::stall_for_vm_shutdown() {\n+  assert(is_shutting_down(), \"Precondition\");\n+  \/\/ Stall the thread (2 seconds) instead of an indefinite wait to avoid deadlock\n+  \/\/ if the VM shutdown triggers a GC.\n+  \/\/ The 2-seconds sleep is:\n+  \/\/   - long enough to keep daemon threads stalled, while the shutdown\n+  \/\/     sequence completes in the common case.\n+  \/\/   - short enough to avoid excessive stall time if the shutdown itself\n+  \/\/     triggers a GC.\n+  JavaThread::current()->sleep(2 * MILLIUNITS);\n+  log_warning(gc, alloc)(\"%s: Stall for VM-Shutdown timed out; allocation may fail with OOME\", Thread::current()->name());\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -249,0 +249,7 @@\n+  bool is_shutting_down() const;\n+\n+  \/\/ If the VM is shutting down, we may have skipped VM_CollectForAllocation.\n+  \/\/ In this case, stall the allocation request briefly in the hope that\n+  \/\/ the VM shutdown completes before the allocation request returns.\n+  void stall_for_vm_shutdown();\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-typedef uint64_t GCThreadLocalData[43]; \/\/ 344 bytes\n+typedef uint64_t GCThreadLocalData[40]; \/\/ 320 bytes\n","filename":"src\/hotspot\/share\/gc\/shared\/gcThreadLocalData.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-  if (skip_operation()) {\n+  if (skip_operation() || Universe::is_shutting_down()) {\n","filename":"src\/hotspot\/share\/gc\/shared\/gcVMOperations.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -243,0 +243,3 @@\n+  \/\/ Track allocation rate even if we decide to start a cycle for other reasons.\n+  double rate = _allocation_rate.sample(allocated);\n+\n@@ -248,2 +251,0 @@\n-  \/\/ Track allocation rate even if we decide to start a cycle for other reasons.\n-  double rate = _allocation_rate.sample(allocated);\n@@ -363,0 +364,19 @@\n+double ShenandoahAllocationRate::force_sample(size_t allocated, size_t &unaccounted_bytes_allocated) {\n+  const double MinSampleTime = 0.002;    \/\/ Do not sample if time since last update is less than 2 ms\n+  double now = os::elapsedTime();\n+  double time_since_last_update = now -_last_sample_time;\n+  if (time_since_last_update < MinSampleTime) {\n+    unaccounted_bytes_allocated = allocated - _last_sample_value;\n+    _last_sample_value = 0;\n+    return 0.0;\n+  } else {\n+    double rate = instantaneous_rate(now, allocated);\n+    _rate.add(rate);\n+    _rate_avg.add(_rate.avg());\n+    _last_sample_time = now;\n+    _last_sample_value = allocated;\n+    unaccounted_bytes_allocated = 0;\n+    return rate;\n+  }\n+}\n+\n@@ -367,6 +387,3 @@\n-    if (allocated >= _last_sample_value) {\n-      rate = instantaneous_rate(now, allocated);\n-      _rate.add(rate);\n-      _rate_avg.add(_rate.avg());\n-    }\n-\n+    rate = instantaneous_rate(now, allocated);\n+    _rate.add(rate);\n+    _rate_avg.add(_rate.avg());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":25,"deletions":8,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+  double force_sample(size_t allocated, size_t &unaccounted_bytes_allocated);\n@@ -44,0 +45,1 @@\n+\n@@ -74,1 +76,1 @@\n-                                                     size_t actual_free);\n+                                                     size_t actual_free) override;\n@@ -76,4 +78,4 @@\n-  void record_cycle_start();\n-  void record_success_concurrent();\n-  void record_success_degenerated();\n-  void record_success_full();\n+  virtual void record_cycle_start() override;\n+  virtual void record_success_concurrent() override;\n+  virtual void record_success_degenerated() override;\n+  virtual void record_success_full() override;\n@@ -81,1 +83,1 @@\n-  virtual bool should_start_gc();\n+  virtual bool should_start_gc() override;\n@@ -83,3 +85,3 @@\n-  virtual const char* name()     { return \"Adaptive\"; }\n-  virtual bool is_diagnostic()   { return false; }\n-  virtual bool is_experimental() { return false; }\n+  virtual const char* name() override     { return \"Adaptive\"; }\n+  virtual bool is_diagnostic() override   { return false; }\n+  virtual bool is_experimental() override { return false; }\n@@ -153,0 +155,7 @@\n+\n+public:\n+  virtual size_t force_alloc_rate_sample(size_t bytes_allocated) override {\n+    size_t unaccounted_bytes;\n+    _allocation_rate.force_sample(bytes_allocated, unaccounted_bytes);\n+    return unaccounted_bytes;\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp","additions":18,"deletions":9,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -244,0 +244,5 @@\n+  virtual size_t force_alloc_rate_sample(size_t bytes_allocated) {\n+    \/\/ do nothing\n+    return 0;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -44,0 +44,4 @@\n+\n+  \/\/ Return an approximation of the bytes allocated since GC start.  The value returned is monotonically non-decreasing\n+  \/\/ in time within each GC cycle.  For certain GC cycles, the value returned may include some bytes allocated before\n+  \/\/ the start of the current GC cycle.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahSpaceInfo.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-  _global_age_table = NEW_C_HEAP_ARRAY(AgeTable*, MAX_SNAPSHOTS, mtGC);\n+  _global_age_tables = NEW_C_HEAP_ARRAY(AgeTable*, MAX_SNAPSHOTS, mtGC);\n@@ -55,1 +55,1 @@\n-    _global_age_table[i] = new AgeTable(false);\n+    _global_age_tables[i] = new AgeTable(false);\n@@ -61,1 +61,1 @@\n-    _local_age_table = NEW_C_HEAP_ARRAY(AgeTable*, _max_workers, mtGC);\n+    _local_age_tables = NEW_C_HEAP_ARRAY(AgeTable*, _max_workers, mtGC);\n@@ -64,1 +64,1 @@\n-      _local_age_table[i] = new AgeTable(false);\n+      _local_age_tables[i] = new AgeTable(false);\n@@ -68,1 +68,6 @@\n-    _local_age_table = nullptr;\n+    _local_age_tables = nullptr;\n+  }\n+  _epoch = MAX_SNAPSHOTS - 1;  \/\/ see prepare_for_census_update()\n+\n+  if (!ShenandoahGenerationalAdaptiveTenuring) {\n+    _tenuring_threshold[_epoch] = InitialTenuringThreshold;\n@@ -70,1 +75,0 @@\n-  _epoch = MAX_SNAPSHOTS - 1;  \/\/ see update_epoch()\n@@ -75,1 +79,1 @@\n-    delete _global_age_table[i];\n+    delete _global_age_tables[i];\n@@ -77,1 +81,1 @@\n-  FREE_C_HEAP_ARRAY(AgeTable*, _global_age_table);\n+  FREE_C_HEAP_ARRAY(AgeTable*, _global_age_tables);\n@@ -80,1 +84,1 @@\n-  if (_local_age_table) {\n+  if (_local_age_tables) {\n@@ -82,1 +86,1 @@\n-      delete _local_age_table[i];\n+      delete _local_age_tables[i];\n@@ -84,1 +88,1 @@\n-    FREE_C_HEAP_ARRAY(AgeTable*, _local_age_table);\n+    FREE_C_HEAP_ARRAY(AgeTable*, _local_age_tables);\n@@ -145,1 +149,1 @@\n-  _global_age_table[_epoch]->clear();\n+  _global_age_tables[_epoch]->clear();\n@@ -151,1 +155,1 @@\n-void ShenandoahAgeCensus::update_census(size_t age0_pop, AgeTable* pv1, AgeTable* pv2) {\n+void ShenandoahAgeCensus::update_census(size_t age0_pop) {\n@@ -153,1 +157,2 @@\n-  assert(_global_age_table[_epoch]->is_clear(), \"Dirty decks\");\n+  assert(ShenandoahGenerationalAdaptiveTenuring, \"Only update census when adaptive tenuring is enabled\");\n+  assert(_global_age_tables[_epoch]->is_clear(), \"Dirty decks\");\n@@ -155,5 +160,0 @@\n-  if (ShenandoahGenerationalAdaptiveTenuring) {\n-    assert(pv1 == nullptr && pv2 == nullptr, \"Error, check caller\");\n-    \/\/ Seed cohort 0 with population that may have been missed during\n-    \/\/ regular census.\n-    _global_age_table[_epoch]->add(0u, age0_pop);\n@@ -161,15 +161,13 @@\n-    \/\/ Merge data from local age tables into the global age table for the epoch,\n-    \/\/ clearing the local tables.\n-    for (uint i = 0; i < _max_workers; i++) {\n-      \/\/ age stats\n-      _global_age_table[_epoch]->merge(_local_age_table[i]);\n-      _local_age_table[i]->clear();   \/\/ clear for next census\n-      \/\/ Merge noise stats\n-      CENSUS_NOISE(_global_noise[_epoch].merge(_local_noise[i]);)\n-      CENSUS_NOISE(_local_noise[i].clear();)\n-    }\n-  } else {\n-    \/\/ census during evac\n-    assert(pv1 != nullptr && pv2 != nullptr, \"Error, check caller\");\n-    _global_age_table[_epoch]->merge(pv1);\n-    _global_age_table[_epoch]->merge(pv2);\n+  \/\/ Seed cohort 0 with population that may have been missed during\n+  \/\/ regular census.\n+  _global_age_tables[_epoch]->add(0u, age0_pop);\n+\n+  \/\/ Merge data from local age tables into the global age table for the epoch,\n+  \/\/ clearing the local tables.\n+  for (uint i = 0; i < _max_workers; i++) {\n+    \/\/ age stats\n+    _global_age_tables[_epoch]->merge(_local_age_tables[i]);\n+    _local_age_tables[i]->clear();   \/\/ clear for next census\n+    \/\/ Merge noise stats\n+    CENSUS_NOISE(_global_noise[_epoch].merge(_local_noise[i]);)\n+    CENSUS_NOISE(_local_noise[i].clear();)\n@@ -191,1 +189,1 @@\n-    _global_age_table[i]->clear();\n+    _global_age_tables[i]->clear();\n@@ -201,1 +199,1 @@\n-    assert(_local_age_table == nullptr, \"Error\");\n+    assert(_local_age_tables == nullptr, \"Error\");\n@@ -205,1 +203,1 @@\n-    _local_age_table[i]->clear();\n+    _local_age_tables[i]->clear();\n@@ -215,1 +213,1 @@\n-    bool clear = _global_age_table[i]->is_clear();\n+    bool clear = _global_age_tables[i]->is_clear();\n@@ -227,1 +225,1 @@\n-    assert(_local_age_table == nullptr, \"Error\");\n+    assert(_local_age_tables == nullptr, \"Error\");\n@@ -231,1 +229,1 @@\n-    bool clear = _local_age_table[i]->is_clear();\n+    bool clear = _local_age_tables[i]->is_clear();\n@@ -243,1 +241,1 @@\n-  const AgeTable* pv = _global_age_table[snap];\n+  const AgeTable* pv = _global_age_tables[snap];\n@@ -263,7 +261,5 @@\n-  if (!ShenandoahGenerationalAdaptiveTenuring) {\n-    _tenuring_threshold[_epoch] = InitialTenuringThreshold;\n-  } else {\n-    uint tt = compute_tenuring_threshold();\n-    assert(tt <= MAX_COHORTS, \"Out of bounds\");\n-    _tenuring_threshold[_epoch] = tt;\n-  }\n+  assert(ShenandoahGenerationalAdaptiveTenuring, \"Only update when adaptive tenuring is enabled\");\n+  uint tt = compute_tenuring_threshold();\n+  assert(tt <= MAX_COHORTS, \"Out of bounds\");\n+  _tenuring_threshold[_epoch] = tt;\n+\n@@ -299,2 +295,2 @@\n-  const AgeTable* cur_pv = _global_age_table[cur_epoch];\n-  const AgeTable* prev_pv = _global_age_table[prev_epoch];\n+  const AgeTable* cur_pv = _global_age_tables[cur_epoch];\n+  const AgeTable* prev_pv = _global_age_tables[prev_epoch];\n@@ -375,2 +371,2 @@\n-  const AgeTable* cur_pv = _global_age_table[cur_epoch];\n-  const AgeTable* prev_pv = _global_age_table[prev_epoch];\n+  const AgeTable* cur_pv = _global_age_tables[cur_epoch];\n+  const AgeTable* prev_pv = _global_age_tables[prev_epoch];\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAgeCensus.cpp","additions":48,"deletions":52,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -100,2 +100,2 @@\n-  AgeTable** _global_age_table;      \/\/ Global age table used for adapting tenuring threshold, one per snapshot\n-  AgeTable** _local_age_table;       \/\/ Local scratch age tables to track object ages, one per worker\n+  AgeTable** _global_age_tables;      \/\/ Global age tables used for adapting tenuring threshold, one per snapshot\n+  AgeTable** _local_age_tables;       \/\/ Local scratch age tables to track object ages, one per worker\n@@ -178,1 +178,1 @@\n-    return _local_age_table[worker_id];\n+    return _local_age_tables[worker_id];\n@@ -212,5 +212,1 @@\n-  \/\/ Optional parameters, pv1 and pv2 are population vectors that together\n-  \/\/ provide object census data (only) for the case when\n-  \/\/ ShenandoahGenerationalCensusAtEvac. In this case, the age0_pop\n-  \/\/ is 0, because the evacuated objects have all had their ages incremented.\n-  void update_census(size_t age0_pop, AgeTable* pv1 = nullptr, AgeTable* pv2 = nullptr);\n+  void update_census(size_t age0_pop);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAgeCensus.hpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+  _consecutive_degenerated_gcs_without_progress(0),\n@@ -70,1 +71,1 @@\n-  _consecutive_degenerated_gcs = 0;\n+  reset_consecutive_degenerated_gcs();\n@@ -77,1 +78,1 @@\n-  _consecutive_degenerated_gcs = 0;\n+  reset_consecutive_degenerated_gcs();\n@@ -98,1 +99,1 @@\n-void ShenandoahCollectorPolicy::record_success_degenerated(bool is_young, bool is_abbreviated) {\n+void ShenandoahCollectorPolicy::record_degenerated(bool is_young, bool is_abbreviated, bool progress) {\n@@ -103,0 +104,7 @@\n+\n+  if (progress) {\n+    _consecutive_degenerated_gcs_without_progress = 0;\n+  } else {\n+    _consecutive_degenerated_gcs_without_progress++;\n+  }\n+\n@@ -117,1 +125,1 @@\n-  _consecutive_degenerated_gcs = 0;\n+  reset_consecutive_degenerated_gcs();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectorPolicy.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+  uint _consecutive_degenerated_gcs_without_progress;\n@@ -58,0 +59,4 @@\n+  void reset_consecutive_degenerated_gcs() {\n+    _consecutive_degenerated_gcs = 0;\n+    _consecutive_degenerated_gcs_without_progress = 0;\n+  }\n@@ -60,0 +65,13 @@\n+  \/\/ The most common scenario for lack of good progress following a degenerated GC is an accumulation of floating\n+  \/\/ garbage during the most recently aborted concurrent GC effort.  With generational GC, it is far more effective to\n+  \/\/ reclaim this floating garbage with another degenerated cycle (which focuses on young generation and might require\n+  \/\/ a pause of 200 ms) rather than a full GC cycle (which may require over 2 seconds with a 10 GB old generation).\n+  \/\/\n+  \/\/ In generational mode, we'll only upgrade to full GC if we've done two degen cycles in a row and both indicated\n+  \/\/ bad progress.  In non-generational mode, we'll preserve the original behavior, which is to upgrade to full\n+  \/\/ immediately following a degenerated cycle with bad progress.  This preserves original behavior of non-generational\n+  \/\/ Shenandoah to avoid introducing \"surprising new behavior.\"  It also makes less sense with non-generational\n+  \/\/ Shenandoah to replace a full GC with a degenerated GC, because both have similar pause times in non-generational\n+  \/\/ mode.\n+  static constexpr size_t GENERATIONAL_CONSECUTIVE_BAD_DEGEN_PROGRESS_THRESHOLD = 2;\n+\n@@ -72,1 +90,6 @@\n-  void record_success_degenerated(bool is_young, bool is_abbreviated);\n+\n+  \/\/ Record that a degenerated cycle has been completed. Note that such a cycle may or\n+  \/\/ may not make \"progress\". We separately track the total number of degenerated cycles,\n+  \/\/ the number of consecutive degenerated cycles and the number of consecutive cycles that\n+  \/\/ fail to make good progress.\n+  void record_degenerated(bool is_young, bool is_abbreviated, bool progress);\n@@ -97,0 +120,5 @@\n+  \/\/ Genshen will only upgrade to a full gc after the configured number of futile degenerated cycles.\n+  bool generational_should_upgrade_degenerated_gc() const {\n+    return _consecutive_degenerated_gcs_without_progress >= GENERATIONAL_CONSECUTIVE_BAD_DEGEN_PROGRESS_THRESHOLD;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectorPolicy.hpp","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -204,20 +204,2 @@\n-      \/\/ Commit worker statistics to cycle data\n-      heap->phase_timings()->flush_par_workers_to_cycle();\n-\n-      \/\/ Print GC stats for current cycle\n-      {\n-        LogTarget(Info, gc, stats) lt;\n-        if (lt.is_enabled()) {\n-          ResourceMark rm;\n-          LogStream ls(lt);\n-          heap->phase_timings()->print_cycle_on(&ls);\n-          if (ShenandoahEvacTracking) {\n-            ShenandoahEvacuationTracker* evac_tracker = heap->evac_tracker();\n-            ShenandoahCycleStats         evac_stats   = evac_tracker->flush_cycle_to_global();\n-            evac_tracker->print_evacuations_on(&ls, &evac_stats.workers, &evac_stats.mutators);\n-          }\n-        }\n-      }\n-\n-      \/\/ Commit statistics to globals\n-      heap->phase_timings()->flush_cycle_to_global();\n+      \/\/ Manage and print gc stats\n+      heap->process_gc_stats();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":2,"deletions":20,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -52,2 +52,1 @@\n-  _abbreviated(false),\n-  _consecutive_degen_with_bad_progress(0) {\n+  _abbreviated(false) {\n@@ -250,1 +249,0 @@\n-              heap->cancel_gc(GCCause::_shenandoah_upgrade_to_full_gc);\n@@ -315,21 +313,5 @@\n-  \/\/ The most common scenario for lack of good progress following a degenerated GC is an accumulation of floating\n-  \/\/ garbage during the most recently aborted concurrent GC effort.  With generational GC, it is far more effective to\n-  \/\/ reclaim this floating garbage with another degenerated cycle (which focuses on young generation and might require\n-  \/\/ a pause of 200 ms) rather than a full GC cycle (which may require over 2 seconds with a 10 GB old generation).\n-  \/\/\n-  \/\/ In generational mode, we'll only upgrade to full GC if we've done two degen cycles in a row and both indicated\n-  \/\/ bad progress.  In non-generational mode, we'll preserve the original behavior, which is to upgrade to full\n-  \/\/ immediately following a degenerated cycle with bad progress.  This preserves original behavior of non-generational\n-  \/\/ Shenandoah so as to avoid introducing \"surprising new behavior.\"  It also makes less sense with non-generational\n-  \/\/ Shenandoah to replace a full GC with a degenerated GC, because both have similar pause times in non-generational\n-  \/\/ mode.\n-  if (!metrics.is_good_progress(_generation)) {\n-    _consecutive_degen_with_bad_progress++;\n-  } else {\n-    _consecutive_degen_with_bad_progress = 0;\n-  }\n-  if (!heap->mode()->is_generational() ||\n-      ((heap->shenandoah_policy()->consecutive_degenerated_gc_count() > 1) && (_consecutive_degen_with_bad_progress >= 2))) {\n-    heap->cancel_gc(GCCause::_shenandoah_upgrade_to_full_gc);\n-    op_degenerated_futile();\n-  } else {\n+  \/\/ Decide if this cycle made good progress, and, if not, should it upgrade to a full GC.\n+  const bool progress = metrics.is_good_progress(_generation);\n+  ShenandoahCollectorPolicy* policy = heap->shenandoah_policy();\n+  policy->record_degenerated(_generation->is_young(), _abbreviated, progress);\n+  if (progress) {\n@@ -337,2 +319,2 @@\n-    heap->shenandoah_policy()->record_success_degenerated(_generation->is_young(), _abbreviated);\n-    _generation->heuristics()->record_success_degenerated();\n+  } else if (!heap->mode()->is_generational() || policy->generational_should_upgrade_degenerated_gc()) {\n+    op_degenerated_futile();\n@@ -486,0 +468,1 @@\n+  heap->cancel_gc(GCCause::_shenandoah_upgrade_to_full_gc);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":9,"deletions":26,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-  size_t _consecutive_degen_with_bad_progress;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"gc\/shenandoah\/shenandoahAgeCensus.hpp\"\n@@ -47,13 +46,0 @@\n-ShenandoahEvacuationStats::ShenandoahEvacuationStats()\n-  : _use_age_table(!ShenandoahGenerationalAdaptiveTenuring),\n-    _age_table(nullptr) {\n-  if (_use_age_table) {\n-    _age_table = new AgeTable(false);\n-  }\n-}\n-\n-AgeTable* ShenandoahEvacuationStats::age_table() const {\n-  assert(_use_age_table, \"Don't call\");\n-  return _age_table;\n-}\n-\n@@ -73,7 +59,0 @@\n-void ShenandoahEvacuationStats::record_age(size_t bytes, uint age) {\n-  assert(_use_age_table, \"Don't call!\");\n-  if (age <= markWord::max_age) { \/\/ Filter age sentinel.\n-    _age_table->add(age, bytes >> LogBytesPerWord);\n-  }\n-}\n-\n@@ -84,4 +63,0 @@\n-\n-  if (_use_age_table) {\n-    _age_table->merge(other->age_table());\n-  }\n@@ -94,4 +69,0 @@\n-\n-  if (_use_age_table) {\n-    _age_table->clear();\n-  }\n@@ -115,4 +86,0 @@\n-\n-  if (_use_age_table) {\n-    _age_table->print_on(st);\n-  }\n@@ -128,22 +95,7 @@\n-  if (ShenandoahEvacTracking) {\n-    st->print_cr(\"Workers: \");\n-    workers->print_on(st);\n-    st->cr();\n-    st->print_cr(\"Mutators: \");\n-    mutators->print_on(st);\n-    st->cr();\n-  }\n-\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-  if (heap->mode()->is_generational()) {\n-    AgeTable young_region_ages(false);\n-    for (uint i = 0; i < heap->num_regions(); ++i) {\n-      ShenandoahHeapRegion* r = heap->get_region(i);\n-      if (r->is_young()) {\n-        young_region_ages.add(r->age(), r->get_live_data_words());\n-      }\n-    }\n-    st->print(\"Young regions: \");\n-    young_region_ages.print_on(st);\n-    st->cr();\n-  }\n+  assert(ShenandoahEvacTracking, \"Only when evac tracking is enabled\");\n+  st->print_cr(\"Workers: \");\n+  workers->print_on(st);\n+  st->cr();\n+  st->print_cr(\"Mutators: \");\n+  mutators->print_on(st);\n+  st->cr();\n@@ -176,9 +128,0 @@\n-  if (!ShenandoahGenerationalAdaptiveTenuring) {\n-    \/\/ Ingest mutator & worker collected population vectors into the heap's\n-    \/\/ global census data, and use it to compute an appropriate tenuring threshold\n-    \/\/ for use in the next cycle.\n-    \/\/ The first argument is used for any age 0 cohort population that we may otherwise have\n-    \/\/ missed during the census. This is non-zero only when census happens at marking.\n-    ShenandoahGenerationalHeap::heap()->age_census()->update_census(0, mutators.age_table(), workers.age_table());\n-  }\n-\n@@ -195,4 +138,0 @@\n-\n-void ShenandoahEvacuationTracker::record_age(Thread* thread, size_t bytes, uint age) {\n-  ShenandoahThreadLocalData::record_age(thread, bytes, age);\n-}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahEvacTracker.cpp","additions":7,"deletions":68,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -69,3 +69,0 @@\n-  bool      _use_age_table;\n-  AgeTable* _age_table;\n-\n@@ -73,4 +70,0 @@\n-  ShenandoahEvacuationStats();\n-\n-  AgeTable* age_table() const;\n-\n@@ -82,1 +75,0 @@\n-  void record_age(size_t bytes, uint age);\n@@ -109,1 +101,0 @@\n-  void record_age(Thread* thread, size_t bytes, uint age);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahEvacTracker.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -154,2 +154,2 @@\n-void ShenandoahGeneration::reset_bytes_allocated_since_gc_start() {\n-  AtomicAccess::store(&_bytes_allocated_since_gc_start, (size_t)0);\n+void ShenandoahGeneration::reset_bytes_allocated_since_gc_start(size_t initial_bytes_allocated) {\n+  AtomicAccess::store(&_bytes_allocated_since_gc_start, initial_bytes_allocated);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-  void reset_bytes_allocated_since_gc_start();\n+  void reset_bytes_allocated_since_gc_start(size_t initial_bytes_allocated);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -204,0 +204,18 @@\n+void ShenandoahGenerationalControlThread::maybe_print_young_region_ages() const {\n+  LogTarget(Debug, gc, age) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+    AgeTable young_region_ages(false);\n+    for (uint i = 0; i < _heap->num_regions(); ++i) {\n+      const ShenandoahHeapRegion* r = _heap->get_region(i);\n+      if (r->is_young()) {\n+        young_region_ages.add(r->age(), r->get_live_data_words());\n+      }\n+    }\n+\n+    ls.print(\"Young regions: \");\n+    young_region_ages.print_on(&ls);\n+    ls.cr();\n+  }\n+}\n+\n@@ -301,1 +319,5 @@\n-  process_phase_timings();\n+  \/\/ Manage and print gc stats\n+  _heap->process_gc_stats();\n+\n+  \/\/ Print table for young region ages if log is enabled\n+  maybe_print_young_region_ages();\n@@ -320,23 +342,0 @@\n-void ShenandoahGenerationalControlThread::process_phase_timings() const {\n-  \/\/ Commit worker statistics to cycle data\n-  _heap->phase_timings()->flush_par_workers_to_cycle();\n-\n-  ShenandoahEvacuationTracker* evac_tracker = _heap->evac_tracker();\n-  ShenandoahCycleStats         evac_stats   = evac_tracker->flush_cycle_to_global();\n-\n-  \/\/ Print GC stats for current cycle\n-  {\n-    LogTarget(Info, gc, stats) lt;\n-    if (lt.is_enabled()) {\n-      ResourceMark rm;\n-      LogStream ls(lt);\n-      _heap->phase_timings()->print_cycle_on(&ls);\n-      evac_tracker->print_evacuations_on(&ls, &evac_stats.workers,\n-                                              &evac_stats.mutators);\n-    }\n-  }\n-\n-  \/\/ Commit statistics to globals\n-  _heap->phase_timings()->flush_cycle_to_global();\n-}\n-\n@@ -420,1 +419,1 @@\n-      process_phase_timings();\n+      _heap->process_gc_stats();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.cpp","additions":24,"deletions":25,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -132,3 +132,0 @@\n-  \/\/ Flushes cycle timings to global timings and prints the phase timings for the last completed cycle.\n-  void process_phase_timings() const;\n-\n@@ -163,0 +160,3 @@\n+\n+  \/\/ Print table for young region ages if log is enabled\n+  void maybe_print_young_region_ages() const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -363,5 +363,0 @@\n-      \/\/ We record this census only when simulating pre-adaptive tenuring behavior, or\n-      \/\/ when we have been asked to record the census at evacuation rather than at mark\n-      if (!ShenandoahGenerationalAdaptiveTenuring) {\n-        evac_tracker()->record_age(thread, size * HeapWordSize, ShenandoahHeap::get_object_age(copy_val));\n-      }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1444,0 +1444,21 @@\n+void ShenandoahHeap::process_gc_stats() const {\n+  \/\/ Commit worker statistics to cycle data\n+  phase_timings()->flush_par_workers_to_cycle();\n+\n+  \/\/ Print GC stats for current cycle\n+  LogTarget(Info, gc, stats) lt;\n+  if (lt.is_enabled()) {\n+    ResourceMark rm;\n+    LogStream ls(lt);\n+    phase_timings()->print_cycle_on(&ls);\n+    if (ShenandoahEvacTracking) {\n+      ShenandoahCycleStats  evac_stats = evac_tracker()->flush_cycle_to_global();\n+      evac_tracker()->print_evacuations_on(&ls, &evac_stats.workers,\n+                                               &evac_stats.mutators);\n+    }\n+  }\n+\n+  \/\/ Commit statistics to globals\n+  phase_timings()->flush_cycle_to_global();\n+}\n+\n@@ -2322,0 +2343,9 @@\n+  \/\/ It is important to force_alloc_rate_sample() before the associated generation's bytes_allocated has been reset.\n+  \/\/ Note that there is no lock to prevent additional alloations between sampling bytes_allocated_since_gc_start() and\n+  \/\/ reset_bytes_allocated_since_gc_start().  If additional allocations happen, they will be ignored in the average\n+  \/\/ allocation rate computations.  This effect is considered to be be negligible.\n+\n+  \/\/ unaccounted_bytes is the bytes not accounted for by our forced sample.  If the sample interval is too short,\n+  \/\/ the \"forced sample\" will not happen, and any recently allocated bytes are \"unaccounted for\".  We pretend these\n+  \/\/ bytes are allocated after the start of subsequent gc.\n+  size_t unaccounted_bytes;\n@@ -2323,2 +2353,9 @@\n-    young_generation()->reset_bytes_allocated_since_gc_start();\n-    old_generation()->reset_bytes_allocated_since_gc_start();\n+    size_t bytes_allocated = young_generation()->bytes_allocated_since_gc_start();\n+    unaccounted_bytes = young_generation()->heuristics()->force_alloc_rate_sample(bytes_allocated);\n+    young_generation()->reset_bytes_allocated_since_gc_start(unaccounted_bytes);\n+    unaccounted_bytes = 0;\n+    old_generation()->reset_bytes_allocated_since_gc_start(unaccounted_bytes);\n+  } else {\n+    size_t bytes_allocated = global_generation()->bytes_allocated_since_gc_start();\n+    \/\/ Single-gen Shenandoah uses global heuristics.\n+    unaccounted_bytes = heuristics()->force_alloc_rate_sample(bytes_allocated);\n@@ -2326,2 +2363,1 @@\n-\n-  global_generation()->reset_bytes_allocated_since_gc_start();\n+  global_generation()->reset_bytes_allocated_since_gc_start(unaccounted_bytes);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":40,"deletions":4,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -209,1 +209,1 @@\n-  void print_gc_on(outputStream *st)           const override;\n+  void print_gc_on(outputStream* st)           const override;\n@@ -212,0 +212,3 @@\n+  \/\/ Flushes cycle timings to global timings and prints the phase timings for the last completed cycle.\n+  void process_gc_stats() const;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -138,8 +138,6 @@\n-    if ((cword & 1) != 0) {\n-      \/\/ The first bit is similarly often interesting. When it matters\n-      \/\/ (density or features of the calling algorithm make it likely\n-      \/\/ the first bit is set), going straight to the next clause compares\n-      \/\/ poorly with doing this check first; count_trailing_zeros can be\n-      \/\/ relatively expensive, plus there is the additional range check.\n-      \/\/ But when the first bit isn't set, the cost of having tested for\n-      \/\/ it is relatively small compared to the rest of the search.\n+    if ((cword & 0x03) != 0) {\n+      \/\/ The first bits (representing weak mark or strong mark) are similarly often interesting. When it matters\n+      \/\/ (density or features of the calling algorithm make it likely the first bits are set), going straight to\n+      \/\/ the next clause compares poorly with doing this check first; count_trailing_zeros can be relatively expensive,\n+      \/\/ plus there is the additional range check.  But when the first bits are not set, the cost of having tested for\n+      \/\/ them is relatively small compared to the rest of the search.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkBitMap.inline.hpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -169,4 +169,0 @@\n-  static void record_age(Thread* thread, size_t bytes, uint age) {\n-    data(thread)->_evacuation_stats->record_age(bytes, age);\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahThreadLocalData.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-    \/\/ as it can cause flakyness in the number of GC threads used, in order to keep\n+    \/\/ as it can cause flakiness in the number of GC threads used, in order to keep\n","filename":"src\/hotspot\/share\/gc\/z\/zArguments.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,2 +74,0 @@\n-void z_assert_is_barrier_safe();\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrier.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,0 +24,2 @@\n+#include \"gc\/z\/zAddress.inline.hpp\"\n+#include \"gc\/z\/zBarrier.inline.hpp\"\n@@ -33,0 +35,1 @@\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -49,0 +52,90 @@\n+class ZColorStoreGoodOopClosure : public BasicOopIterateClosure {\n+public:\n+  virtual void do_oop(oop* p_) {\n+    volatile zpointer* const p = (volatile zpointer*)p_;\n+    const zpointer ptr = ZBarrier::load_atomic(p);\n+    const zaddress addr = ZPointer::uncolor(ptr);\n+    AtomicAccess::store(p, ZAddress::store_good(addr));\n+  }\n+\n+  virtual void do_oop(narrowOop* p) {\n+    ShouldNotReachHere();\n+  }\n+};\n+\n+class ZLoadBarrierOopClosure : public BasicOopIterateClosure {\n+public:\n+  virtual void do_oop(oop* p) {\n+    ZBarrier::load_barrier_on_oop_field((zpointer*)p);\n+  }\n+\n+  virtual void do_oop(narrowOop* p) {\n+    ShouldNotReachHere();\n+  }\n+};\n+\n+void ZBarrierSet::load_barrier_all(oop src, size_t size) {\n+  check_is_valid_zaddress(src);\n+\n+  ZLoadBarrierOopClosure cl;\n+  ZIterator::oop_iterate(src, &cl);\n+}\n+\n+void ZBarrierSet::color_store_good_all(oop dst, size_t size) {\n+  check_is_valid_zaddress(dst);\n+  assert(dst->is_typeArray() || ZHeap::heap()->is_young(to_zaddress(dst)), \"ZColorStoreGoodOopClosure is only valid for young objects\");\n+\n+  ZColorStoreGoodOopClosure cl_sg;\n+  ZIterator::oop_iterate(dst, &cl_sg);\n+}\n+\n+zaddress ZBarrierSet::load_barrier_on_oop_field_preloaded(volatile zpointer* p, zpointer o) {\n+  return ZBarrier::load_barrier_on_oop_field_preloaded(p, o);\n+}\n+\n+zaddress ZBarrierSet::no_keep_alive_load_barrier_on_weak_oop_field_preloaded(volatile zpointer* p, zpointer o) {\n+  return ZBarrier::no_keep_alive_load_barrier_on_weak_oop_field_preloaded(p, o);\n+}\n+\n+zaddress ZBarrierSet::no_keep_alive_load_barrier_on_phantom_oop_field_preloaded(volatile zpointer* p, zpointer o) {\n+  return ZBarrier::no_keep_alive_load_barrier_on_phantom_oop_field_preloaded(p, o);\n+}\n+\n+zaddress ZBarrierSet::load_barrier_on_weak_oop_field_preloaded(volatile zpointer* p, zpointer o) {\n+  return ZBarrier::load_barrier_on_weak_oop_field_preloaded(p, o);\n+}\n+\n+zaddress ZBarrierSet::load_barrier_on_phantom_oop_field_preloaded(volatile zpointer* p, zpointer o) {\n+  return ZBarrier::load_barrier_on_phantom_oop_field_preloaded(p, o);\n+}\n+\n+void ZBarrierSet::store_barrier_on_heap_oop_field(volatile zpointer* p, bool heal) {\n+  ZBarrier::store_barrier_on_heap_oop_field(p, heal);\n+}\n+\n+void ZBarrierSet::no_keep_alive_store_barrier_on_heap_oop_field(volatile zpointer* p) {\n+  ZBarrier::no_keep_alive_store_barrier_on_heap_oop_field(p);\n+}\n+\n+void ZBarrierSet::store_barrier_on_native_oop_field(volatile zpointer* p, bool heal) {\n+  ZBarrier::store_barrier_on_native_oop_field(p, heal);\n+}\n+\n+zaddress ZBarrierSet::load_barrier_on_oop_field(volatile zpointer* p) {\n+  return ZBarrier::load_barrier_on_oop_field(p);\n+}\n+\n+void ZBarrierSet::clone_obj_array(objArrayOop src_obj, objArrayOop dst_obj) {\n+  volatile zpointer* src = (volatile zpointer*)src_obj->base();\n+  volatile zpointer* dst = (volatile zpointer*)dst_obj->base();\n+  const int length = src_obj->length();\n+\n+  for (const volatile zpointer* const end = src + length; src < end; src++, dst++) {\n+    zaddress elem = ZBarrier::load_barrier_on_oop_field(src);\n+    \/\/ We avoid healing here because the store below colors the pointer store good,\n+    \/\/ hence avoiding the cost of a CAS.\n+    ZBarrier::store_barrier_on_heap_oop_field(dst, false \/* heal *\/);\n+    AtomicAccess::store(dst, ZAddress::store_good(elem));\n+  }\n+}\n+\n@@ -120,1 +213,1 @@\n-    \/\/ intepreter deal with it.\n+    \/\/ interpreter deal with it.\n@@ -156,14 +249,0 @@\n-void ZBarrierSet::clone_obj_array(objArrayOop src_obj, objArrayOop dst_obj) {\n-  volatile zpointer* src = (volatile zpointer*)src_obj->base();\n-  volatile zpointer* dst = (volatile zpointer*)dst_obj->base();\n-  const int length = src_obj->length();\n-\n-  for (const volatile zpointer* const end = src + length; src < end; src++, dst++) {\n-    zaddress elem = ZBarrier::load_barrier_on_oop_field(src);\n-    \/\/ We avoid healing here because the store below colors the pointer store good,\n-    \/\/ hence avoiding the cost of a CAS.\n-    ZBarrier::store_barrier_on_heap_oop_field(dst, false \/* heal *\/);\n-    AtomicAccess::store(dst, ZAddress::store_good(elem));\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSet.cpp","additions":94,"deletions":15,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -36,0 +36,17 @@\n+  static void load_barrier_all(oop src, size_t size);\n+  static void color_store_good_all(oop dst, size_t size);\n+\n+  static zaddress load_barrier_on_oop_field_preloaded(volatile zpointer* p, zpointer o);\n+  static zaddress no_keep_alive_load_barrier_on_weak_oop_field_preloaded(volatile zpointer* p, zpointer o);\n+  static zaddress no_keep_alive_load_barrier_on_phantom_oop_field_preloaded(volatile zpointer* p, zpointer o);\n+  static zaddress load_barrier_on_weak_oop_field_preloaded(volatile zpointer* p, zpointer o);\n+  static zaddress load_barrier_on_phantom_oop_field_preloaded(volatile zpointer* p, zpointer o);\n+\n+  static void store_barrier_on_heap_oop_field(volatile zpointer* p, bool heal);\n+  static void no_keep_alive_store_barrier_on_heap_oop_field(volatile zpointer* p);\n+  static void store_barrier_on_native_oop_field(volatile zpointer* p, bool heal);\n+\n+  static zaddress load_barrier_on_oop_field(volatile zpointer* p);\n+\n+  static void clone_obj_array(objArrayOop src, objArrayOop dst);\n+\n@@ -42,2 +59,0 @@\n-  static void clone_obj_array(objArrayOop src, objArrayOop dst);\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSet.hpp","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -31,2 +31,1 @@\n-#include \"gc\/z\/zBarrier.inline.hpp\"\n-#include \"gc\/z\/zIterator.inline.hpp\"\n+#include \"gc\/z\/zHeap.hpp\"\n@@ -34,1 +33,1 @@\n-#include \"memory\/iterator.inline.hpp\"\n+#include \"oops\/objArrayOop.hpp\"\n@@ -71,1 +70,1 @@\n-      return ZBarrier::load_barrier_on_oop_field_preloaded(p, o);\n+      return ZBarrierSet::load_barrier_on_oop_field_preloaded(p, o);\n@@ -73,1 +72,1 @@\n-      return ZBarrier::no_keep_alive_load_barrier_on_weak_oop_field_preloaded(p, o);\n+      return ZBarrierSet::no_keep_alive_load_barrier_on_weak_oop_field_preloaded(p, o);\n@@ -76,1 +75,1 @@\n-      return ZBarrier::no_keep_alive_load_barrier_on_phantom_oop_field_preloaded(p, o);\n+      return ZBarrierSet::no_keep_alive_load_barrier_on_phantom_oop_field_preloaded(p, o);\n@@ -80,1 +79,1 @@\n-      return ZBarrier::load_barrier_on_oop_field_preloaded(p, o);\n+      return ZBarrierSet::load_barrier_on_oop_field_preloaded(p, o);\n@@ -82,1 +81,1 @@\n-      return ZBarrier::load_barrier_on_weak_oop_field_preloaded(p, o);\n+      return ZBarrierSet::load_barrier_on_weak_oop_field_preloaded(p, o);\n@@ -85,1 +84,1 @@\n-      return ZBarrier::load_barrier_on_phantom_oop_field_preloaded(p, o);\n+      return ZBarrierSet::load_barrier_on_phantom_oop_field_preloaded(p, o);\n@@ -100,1 +99,1 @@\n-      return ZBarrier::load_barrier_on_oop_field_preloaded(p, o);\n+      return ZBarrierSet::load_barrier_on_oop_field_preloaded(p, o);\n@@ -102,1 +101,1 @@\n-      return ZBarrier::no_keep_alive_load_barrier_on_weak_oop_field_preloaded(p, o);\n+      return ZBarrierSet::no_keep_alive_load_barrier_on_weak_oop_field_preloaded(p, o);\n@@ -105,1 +104,1 @@\n-      return ZBarrier::no_keep_alive_load_barrier_on_phantom_oop_field_preloaded(p, o);\n+      return ZBarrierSet::no_keep_alive_load_barrier_on_phantom_oop_field_preloaded(p, o);\n@@ -109,1 +108,1 @@\n-      return ZBarrier::load_barrier_on_oop_field_preloaded(p, o);\n+      return ZBarrierSet::load_barrier_on_oop_field_preloaded(p, o);\n@@ -111,1 +110,1 @@\n-      return ZBarrier::load_barrier_on_weak_oop_field_preloaded(p, o);\n+      return ZBarrierSet::load_barrier_on_weak_oop_field_preloaded(p, o);\n@@ -114,1 +113,1 @@\n-      return ZBarrier::load_barrier_on_phantom_oop_field_preloaded(p, o);\n+      return ZBarrierSet::load_barrier_on_phantom_oop_field_preloaded(p, o);\n@@ -129,1 +128,1 @@\n-    ZBarrier::store_barrier_on_heap_oop_field(p, true \/* heal *\/);\n+    ZBarrierSet::store_barrier_on_heap_oop_field(p, true \/* heal *\/);\n@@ -138,1 +137,1 @@\n-    ZBarrier::store_barrier_on_heap_oop_field(p, false \/* heal *\/);\n+    ZBarrierSet::store_barrier_on_heap_oop_field(p, false \/* heal *\/);\n@@ -145,1 +144,1 @@\n-    ZBarrier::no_keep_alive_store_barrier_on_heap_oop_field(p);\n+    ZBarrierSet::no_keep_alive_store_barrier_on_heap_oop_field(p);\n@@ -152,1 +151,1 @@\n-    ZBarrier::store_barrier_on_native_oop_field(p, true \/* heal *\/);\n+    ZBarrierSet::store_barrier_on_native_oop_field(p, true \/* heal *\/);\n@@ -161,1 +160,1 @@\n-    ZBarrier::store_barrier_on_native_oop_field(p, false \/* heal *\/);\n+    ZBarrierSet::store_barrier_on_native_oop_field(p, false \/* heal *\/);\n@@ -328,1 +327,1 @@\n-  return ZBarrier::load_barrier_on_oop_field(src);\n+  return ZBarrierSet::load_barrier_on_oop_field(src);\n@@ -352,1 +351,0 @@\n-\n@@ -406,25 +404,0 @@\n-class ZColorStoreGoodOopClosure : public BasicOopIterateClosure {\n-public:\n-  virtual void do_oop(oop* p_) {\n-    volatile zpointer* const p = (volatile zpointer*)p_;\n-    const zpointer ptr = ZBarrier::load_atomic(p);\n-    const zaddress addr = ZPointer::uncolor(ptr);\n-    AtomicAccess::store(p, ZAddress::store_good(addr));\n-  }\n-\n-  virtual void do_oop(narrowOop* p) {\n-    ShouldNotReachHere();\n-  }\n-};\n-\n-class ZLoadBarrierOopClosure : public BasicOopIterateClosure {\n-public:\n-  virtual void do_oop(oop* p) {\n-    ZBarrier::load_barrier_on_oop_field((zpointer*)p);\n-  }\n-\n-  virtual void do_oop(narrowOop* p) {\n-    ShouldNotReachHere();\n-  }\n-};\n-\n@@ -447,2 +420,1 @@\n-  ZLoadBarrierOopClosure cl;\n-  ZIterator::oop_iterate(src, &cl);\n+  ZBarrierSet::load_barrier_all(src, size);\n@@ -453,2 +425,0 @@\n-  assert(dst->is_typeArray() || ZHeap::heap()->is_young(to_zaddress(dst)), \"ZColorStoreGoodOopClosure is only valid for young objects\");\n-\n@@ -456,2 +426,1 @@\n-  ZColorStoreGoodOopClosure cl_sg;\n-  ZIterator::oop_iterate(dst, &cl_sg);\n+  ZBarrierSet::color_store_good_all(dst, size);\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSet.inline.hpp","additions":22,"deletions":53,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -305,1 +305,1 @@\n-  \/\/ that takes away CPU power to the hopefullt more profitable major colelction.\n+  \/\/ that takes away CPU power to the hopefully more profitable major collection.\n@@ -309,2 +309,1 @@\n-template <typename PrintFn = void(*)(size_t, double)>\n-static bool is_high_usage(const ZDirectorStats& stats, PrintFn* print_function = nullptr) {\n+static bool is_high_usage(const ZDirectorStats& stats, bool log = false) {\n@@ -319,2 +318,3 @@\n-  if (print_function != nullptr) {\n-    (*print_function)(free, free_percent);\n+  if (log) {\n+    log_debug(gc, director)(\"Rule Minor: High Usage, Free: %zuMB(%.1f%%)\",\n+                            free \/ M, free_percent);\n@@ -380,13 +380,1 @@\n-\n-  const size_t soft_max_capacity = stats._heap._soft_max_heap_size;\n-  const size_t used = stats._heap._used;\n-  const size_t free_including_headroom = soft_max_capacity - MIN2(soft_max_capacity, used);\n-  const size_t free = free_including_headroom - MIN2(free_including_headroom, ZHeuristics::relocation_headroom());\n-  const double free_percent = percent_of(free, soft_max_capacity);\n-\n-  auto print_function = [&](size_t free, double free_percent) {\n-    log_debug(gc, director)(\"Rule Minor: High Usage, Free: %zuMB(%.1f%%)\",\n-                            free \/ M, free_percent);\n-  };\n-\n-  return is_high_usage(stats, &print_function);\n+  return is_high_usage(stats, true \/* log *\/);\n","filename":"src\/hotspot\/share\/gc\/z\/zDirector.cpp","additions":6,"deletions":18,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -664,1 +664,0 @@\n-\n@@ -705,1 +704,0 @@\n-  size_t last_populated_live = 0;\n@@ -711,1 +709,0 @@\n-      last_populated_live = young_live;\n@@ -725,1 +722,0 @@\n-  const size_t young_used_at_mark_start = ZGeneration::young()->stat_heap()->used_generation_at_mark_start();\n@@ -1323,1 +1319,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -90,1 +90,0 @@\n-  void flip_age_pages(const ZArray<ZPage*>* pages);\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -367,1 +367,1 @@\n-    \/\/ before the concurrent processign of the code cache, make sure that\n+    \/\/ before the concurrent processing of the code cache, make sure that\n","filename":"src\/hotspot\/share\/gc\/z\/zHeapIterator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -163,1 +163,1 @@\n-        \/\/ Nofity blocked\n+        \/\/ Notify blocked\n","filename":"src\/hotspot\/share\/gc\/z\/zJNICritical.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -391,1 +391,0 @@\n-\n@@ -793,1 +792,0 @@\n-  ZMark* const                  _mark;\n@@ -804,1 +802,1 @@\n-  ZMarkOldRootsTask(ZMark* mark)\n+  ZMarkOldRootsTask()\n@@ -806,1 +804,0 @@\n-      _mark(mark),\n@@ -851,1 +848,0 @@\n-  ZMark* const               _mark;\n@@ -862,1 +858,1 @@\n-  ZMarkYoungRootsTask(ZMark* mark)\n+  ZMarkYoungRootsTask()\n@@ -864,1 +860,0 @@\n-      _mark(mark),\n@@ -932,1 +927,1 @@\n-  ZMarkYoungRootsTask task(this);\n+  ZMarkYoungRootsTask task;\n@@ -938,1 +933,1 @@\n-  ZMarkOldRootsTask task(this);\n+  ZMarkOldRootsTask task;\n","filename":"src\/hotspot\/share\/gc\/z\/zMark.cpp","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -317,1 +317,1 @@\n-  \/\/ until we are more consistent with our const corectness.\n+  \/\/ until we are more consistent with our const correctness.\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethod.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,3 +46,0 @@\n-  static ZNMethodTableEntry* create(size_t size);\n-  static void destroy(ZNMethodTableEntry* table);\n-\n@@ -70,3 +67,0 @@\n-\n-  static void unlink(ZWorkers* workers, bool unloading_occurred);\n-  static void purge(ZWorkers* workers);\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethodTable.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+#include \"gc\/z\/zGeneration.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zObjArrayAllocator.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -371,1 +371,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zPage.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1054,1 +1054,0 @@\n-\n@@ -1064,1 +1063,0 @@\n-  const ZVirtualMemory already_committed_vmem = vmem.first_part(already_committed);\n@@ -1426,1 +1424,0 @@\n-  const size_t committed = stats._total_committed_capacity;\n@@ -1967,3 +1964,0 @@\n-    \/\/ Remove the harvested part\n-    const ZVirtualMemory non_harvest_vmem = partial_vmem.last_part(allocation->harvested());\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/z\/zGranuleMap.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zPhysicalMemoryManager.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/z\/zArray.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zRangeRegistry.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -674,1 +674,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-  uintptr_t              _uncolor_mask;\n@@ -54,1 +53,0 @@\n-      _uncolor_mask(0),\n","filename":"src\/hotspot\/share\/gc\/z\/zThreadLocalData.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -241,1 +241,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zValue.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zVirtualMemoryManager.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -171,1 +171,1 @@\n-  volatile_nonstatic_field(BasicLock,          _metadata,                              uintptr_t)                                    \\\n+  volatile_nonstatic_field(BasicLock,          _monitor,                               ObjectMonitor*)                               \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -107,0 +107,1 @@\n+  FN(regmask,     C2 Short-Lived Register Mask Arena) \\\n","filename":"src\/hotspot\/share\/memory\/arena.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-#include \"cds\/aotLinkedClassBulkLoader.hpp\"\n@@ -54,6 +53,1 @@\n-  ClassLoaderData* cld = k->class_loader_data();\n-  if (cld != nullptr) {\n-    ClaimMetadataVisitingOopIterateClosure::do_cld(cld);\n-  } else {\n-    assert(AOTLinkedClassBulkLoader::is_pending_aot_linked_class(k), \"sanity\");\n-  }\n+  ClaimMetadataVisitingOopIterateClosure::do_cld(k->class_loader_data());\n","filename":"src\/hotspot\/share\/memory\/iterator.inline.hpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -107,1 +107,0 @@\n-\n@@ -109,5 +108,2 @@\n-  if (klass->is_array_klass()) {\n-    return ArrayKlass::cast(klass)->allocate_arrayArray(1, length, THREAD);\n-  } else {\n-    return InstanceKlass::cast(klass)->allocate_objArray(1, length, THREAD);\n-  }\n+  ArrayKlass* ak = klass->array_klass(CHECK_NULL);\n+  return ObjArrayKlass::cast(ak)->allocate_instance(length, THREAD);\n","filename":"src\/hotspot\/share\/memory\/oopFactory.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -186,0 +186,1 @@\n+volatile bool   Universe::_is_shutting_down = false;\n@@ -506,1 +507,1 @@\n-  \/\/ for Object_klass_loaded in objArrayKlassKlass::allocate_objArray_klass_impl.\n+  \/\/ for Object_klass_is_loaded in ObjArrayKlass::allocate_objArray_klass.\n@@ -586,0 +587,5 @@\n+  if (CDSConfig::is_using_aot_linked_classes()) {\n+    \/\/ All mirrors of preloaded classes are already restored. No need to fix up.\n+    return;\n+  }\n+\n@@ -590,1 +596,1 @@\n-  assert(vmClasses::Class_klass_loaded(), \"java.lang.Class should be loaded\");\n+  assert(vmClasses::Class_klass_is_loaded(), \"java.lang.Class should be loaded\");\n@@ -1347,1 +1353,8 @@\n-  log_cpu_time();\n+  {\n+    \/\/ Acquire the Heap_lock to synchronize with VM_Heap_Sync_Operations,\n+    \/\/ which may depend on the value of _is_shutting_down flag.\n+    MutexLocker hl(Heap_lock);\n+    log_cpu_time();\n+    AtomicAccess::release_store(&_is_shutting_down, true);\n+  }\n+\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -131,0 +131,3 @@\n+  \/\/ Shutdown\n+  static volatile bool _is_shutting_down;\n+\n@@ -327,0 +330,2 @@\n+  static bool is_shutting_down()                  { return  AtomicAccess::load_acquire(&_is_shutting_down); }\n+\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -186,10 +186,0 @@\n-objArrayOop ArrayKlass::allocate_arrayArray(int n, int length, TRAPS) {\n-  check_array_allocation_length(length, arrayOopDesc::max_array_length(T_ARRAY), CHECK_NULL);\n-  size_t size = objArrayOopDesc::object_size(length);\n-  ArrayKlass* ak = array_klass(n + dimension(), CHECK_NULL);\n-  objArrayOop o = (objArrayOop)Universe::heap()->array_allocate(ak, size, length,\n-                                                                \/* do_zero *\/ true, CHECK_NULL);\n-  \/\/ initialization to null not necessary, area already cleared\n-  return o;\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -88,1 +88,0 @@\n-  objArrayOop allocate_arrayArray(int n, int length, TRAPS);\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-      LP64_ONLY(p2u(_base) + (uintptr_t)nth_bit(narrow_klass_pointer_bits() + _shift))\n+      LP64_ONLY((p2u(_base) + (uintptr_t)nth_bit(narrow_klass_pointer_bits() + _shift)))\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -398,1 +398,1 @@\n-  if (vmClasses::Object_klass_loaded()) {\n+  if (vmClasses::Object_klass_is_loaded()) {\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-  if (vmClasses::ClassLoader_klass_loaded()) {\n+  if (vmClasses::ClassLoader_klass_is_loaded()) {\n@@ -1558,9 +1558,0 @@\n-objArrayOop InstanceKlass::allocate_objArray(int n, int length, TRAPS) {\n-  check_array_allocation_length(length, arrayOopDesc::max_array_length(T_OBJECT), CHECK_NULL);\n-  size_t size = objArrayOopDesc::object_size(length);\n-  ArrayKlass* ak = array_klass(n, CHECK_NULL);\n-  objArrayOop o = (objArrayOop)Universe::heap()->array_allocate(ak, size, length,\n-                                                                \/* do_zero *\/ true, CHECK_NULL);\n-  return o;\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -813,1 +813,0 @@\n-  objArrayOop allocate_objArray(int n, int length, TRAPS);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1290,0 +1290,1 @@\n+#ifndef ZERO\n@@ -1291,0 +1292,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-  if (!Universe::is_bootstrapping() || vmClasses::Object_klass_loaded()) {\n+  if (!Universe::is_bootstrapping() || vmClasses::Object_klass_is_loaded()) {\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,1 +67,3 @@\n-  Klass** element_klass_addr()      { return &_element_klass; }\n+\n+  \/\/ Compiler\/Interpreter offset\n+  static ByteSize element_klass_offset() { return byte_offset_of(ObjArrayKlass, _element_klass); }\n@@ -76,3 +78,0 @@\n-  \/\/ Compiler\/Interpreter offset\n-  static ByteSize element_klass_offset() { return byte_offset_of(ObjArrayKlass, _element_klass); }\n-\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -621,1 +621,1 @@\n-      LogStreamHandle(Warning, training) log;\n+      LogStreamHandle(Info, training) log;\n","filename":"src\/hotspot\/share\/oops\/trainingData.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -155,0 +155,3 @@\n+    static void assert_locked_or_snapshotted() {\n+      assert(safely_locked() || _snapshot, \"use under TrainingDataLocker or after snapshot\");\n+    }\n@@ -341,0 +344,1 @@\n+      TrainingDataLocker::assert_locked_or_snapshotted();\n@@ -346,0 +350,1 @@\n+      TrainingDataLocker::assert_locked_or_snapshotted();\n@@ -351,0 +356,1 @@\n+      TrainingDataLocker::assert_locked_or_snapshotted();\n@@ -355,0 +361,1 @@\n+      TrainingDataLocker::assert_can_add();\n@@ -364,0 +371,1 @@\n+      TrainingDataLocker::assert_can_add();\n@@ -370,0 +378,1 @@\n+      TrainingDataLocker::assert_can_add();\n@@ -375,0 +384,1 @@\n+      TrainingDataLocker::assert_can_add();\n@@ -381,0 +391,1 @@\n+      TrainingDataLocker::assert_locked();\n@@ -594,0 +605,1 @@\n+        TrainingDataLocker l;\n@@ -602,2 +614,5 @@\n-      bool append_if_missing(const ReturnType& result, const Args&... args) {\n-        return _data.append_if_missing(Record(result, ArgumentsType(args...)));\n+      void append_if_missing(const ReturnType& result, const Args&... args) {\n+        TrainingDataLocker l;\n+        if (l.can_add()) {\n+          _data.append_if_missing(Record(result, ArgumentsType(args...)));\n+        }\n","filename":"src\/hotspot\/share\/oops\/trainingData.hpp","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -563,0 +563,3 @@\n+  if (C->failing()) {\n+    return;\n+  }\n@@ -640,0 +643,3 @@\n+    if (C->failing()) {\n+      return;\n+    }\n@@ -770,1 +776,1 @@\n-      _lrg_map.map(n->_idx, rm.is_NotEmpty() ? lr_counter++ : 0);\n+      _lrg_map.map(n->_idx, !rm.is_Empty() ? lr_counter++ : 0);\n@@ -791,1 +797,1 @@\n-      _lrg_map.map(n->_idx, rm.is_NotEmpty() ? n->_idx : 0);\n+      _lrg_map.map(n->_idx, !rm.is_Empty() ? n->_idx : 0);\n@@ -1401,3 +1407,2 @@\n-static bool is_legal_reg(LRG &lrg, OptoReg::Name reg, int chunk) {\n-  if (reg >= chunk && reg < (chunk + RegMask::CHUNK_SIZE) &&\n-      lrg.mask().Member(OptoReg::add(reg,-chunk))) {\n+static bool is_legal_reg(LRG& lrg, OptoReg::Name reg) {\n+  if (lrg.mask().can_represent(reg) && lrg.mask().Member(reg)) {\n@@ -1426,1 +1431,1 @@\n-static OptoReg::Name find_first_set(LRG &lrg, RegMask mask, int chunk) {\n+static OptoReg::Name find_first_set(LRG& lrg, RegMask& mask) {\n@@ -1432,1 +1437,3 @@\n-    if (chunk == 0 && OptoReg::is_reg(assigned)) {\n+    if (OptoReg::is_reg(assigned)) {\n+      assert(!lrg.mask().is_offset(),\n+             \"offset register masks can only contain stack slots\");\n@@ -1448,1 +1455,2 @@\n-      while (OptoReg::is_valid(assigned) && RegMask::can_represent(assigned)) {\n+      while (OptoReg::is_valid(assigned)) {\n+        assert(mask.can_represent(assigned), \"sanity\");\n@@ -1472,1 +1480,1 @@\n-OptoReg::Name PhaseChaitin::bias_color( LRG &lrg, int chunk ) {\n+OptoReg::Name PhaseChaitin::bias_color(LRG& lrg) {\n@@ -1486,1 +1494,1 @@\n-      if (is_legal_reg(lrg, reg, chunk))\n+      if (is_legal_reg(lrg, reg)) {\n@@ -1488,0 +1496,1 @@\n+      }\n@@ -1497,1 +1506,1 @@\n-      if (is_legal_reg(lrg, reg, chunk))\n+      if (is_legal_reg(lrg, reg)) {\n@@ -1499,1 +1508,2 @@\n-    } else if( chunk == 0 ) {\n+      }\n+    } else if (!lrg.mask().is_offset()) {\n@@ -1501,1 +1511,2 @@\n-      RegMask tempmask = lrg.mask();\n+      ResourceMark rm(C->regmask_arena());\n+      RegMask tempmask(lrg.mask(), C->regmask_arena());\n@@ -1504,1 +1515,1 @@\n-      OptoReg::Name reg = find_first_set(lrg, tempmask, chunk);\n+      OptoReg::Name reg = find_first_set(lrg, tempmask);\n@@ -1513,1 +1524,3 @@\n-    return OptoReg::add(find_first_set(lrg, lrg.mask(), chunk), chunk);\n+    ResourceMark rm(C->regmask_arena());\n+    RegMask tempmask(lrg.mask(), C->regmask_arena());\n+    return find_first_set(lrg, tempmask);\n@@ -1526,1 +1539,1 @@\n-    if( OptoReg::is_reg(reg2))\n+    if (OptoReg::is_reg(reg2)) {\n@@ -1528,0 +1541,1 @@\n+    }\n@@ -1529,1 +1543,1 @@\n-  return OptoReg::add( reg, chunk );\n+  return reg;\n@@ -1533,3 +1547,3 @@\n-OptoReg::Name PhaseChaitin::choose_color( LRG &lrg, int chunk ) {\n-  assert( C->in_preserve_stack_slots() == 0 || chunk != 0 || lrg._is_bound || lrg.mask().is_bound1() || !lrg.mask().Member(OptoReg::Name(_matcher._old_SP-1)), \"must not allocate stack0 (inside preserve area)\");\n-  assert(C->out_preserve_stack_slots() == 0 || chunk != 0 || lrg._is_bound || lrg.mask().is_bound1() || !lrg.mask().Member(OptoReg::Name(_matcher._old_SP+0)), \"must not allocate stack0 (inside preserve area)\");\n+OptoReg::Name PhaseChaitin::choose_color(LRG& lrg) {\n+  assert(C->in_preserve_stack_slots() == 0 || lrg.mask().is_offset() || lrg._is_bound || lrg.mask().is_bound1() || !lrg.mask().Member(OptoReg::Name(_matcher._old_SP - 1)), \"must not allocate stack0 (inside preserve area)\");\n+  assert(C->out_preserve_stack_slots() == 0 || lrg.mask().is_offset() || lrg._is_bound || lrg.mask().is_bound1() || !lrg.mask().Member(OptoReg::Name(_matcher._old_SP + 0)), \"must not allocate stack0 (inside preserve area)\");\n@@ -1540,1 +1554,1 @@\n-    return bias_color(lrg, chunk);\n+    return bias_color(lrg);\n@@ -1548,1 +1562,1 @@\n-  assert( !chunk, \"always color in 1st chunk\" );\n+  assert(!lrg.mask().is_offset(), \"always color in 1st chunk\");\n@@ -1588,1 +1602,0 @@\n-    int chunk = 0;              \/\/ Current chunk is first chunk\n@@ -1593,1 +1606,4 @@\n-    DEBUG_ONLY(RegMask orig_mask = lrg->mask();)\n+#ifndef PRODUCT\n+    ResourceMark rm(C->regmask_arena());\n+    RegMask orig_mask(lrg->mask(), C->regmask_arena());\n+#endif\n@@ -1599,6 +1615,0 @@\n-        \/\/ Note that neighbor might be a spill_reg.  In this case, exclusion\n-        \/\/ of its color will be a no-op, since the spill_reg chunk is in outer\n-        \/\/ space.  Also, if neighbor is in a different chunk, this exclusion\n-        \/\/ will be a no-op.  (Later on, if lrg runs out of possible colors in\n-        \/\/ its chunk, a new chunk of color may be tried, in which case\n-        \/\/ examination of neighbors is started again, at retry_next_chunk.)\n@@ -1607,2 +1617,7 @@\n-        \/\/ Only subtract masks in the same chunk\n-        if (nreg >= chunk && nreg < chunk + RegMask::CHUNK_SIZE) {\n+        \/\/ The neighbor might be a spill_reg. In this case, exclusion of its\n+        \/\/ color will be a no-op, since the spill_reg is in outer space. In\n+        \/\/ this case, do not exclude the corresponding mask. Later on, if lrg\n+        \/\/ runs out of possible colors in its chunk, a new chunk of color may\n+        \/\/ be tried, in which case examination of neighbors is started again,\n+        \/\/ at retry_next_chunk.\n+        if (nreg < LRG::SPILL_REG) {\n@@ -1611,1 +1626,2 @@\n-          RegMask rm = lrg->mask();\n+          ResourceMark rm(C->regmask_arena());\n+          RegMask trace_mask(lrg->mask(), C->regmask_arena());\n@@ -1613,1 +1629,1 @@\n-          lrg->SUBTRACT(nlrg.mask());\n+          lrg->SUBTRACT_inner(nlrg.mask());\n@@ -1618,1 +1634,1 @@\n-            rm.dump();\n+            trace_mask.dump();\n@@ -1622,2 +1638,2 @@\n-            rm.SUBTRACT(lrg->mask());\n-            rm.dump();\n+            trace_mask.SUBTRACT(lrg->mask());\n+            trace_mask.dump();\n@@ -1640,1 +1656,1 @@\n-    OptoReg::Name reg = choose_color( *lrg, chunk );\n+    OptoReg::Name reg = choose_color(*lrg);\n@@ -1643,3 +1659,5 @@\n-    \/\/ If we fail to color and the infinite flag is set, trigger\n-    \/\/ a chunk-rollover event\n-    if (!OptoReg::is_valid(OptoReg::add(reg, -chunk)) && is_infinite_stack) {\n+    \/\/ If we fail to color and the infinite flag is set, we must trigger\n+    \/\/ a chunk-rollover event and continue searching for a color in the next set\n+    \/\/ of slots (which are all necessarily stack slots, as registers are only in\n+    \/\/ the initial chunk)\n+    if (!OptoReg::is_valid(reg) && is_infinite_stack) {\n@@ -1647,2 +1665,10 @@\n-      chunk += RegMask::CHUNK_SIZE;\n-      lrg->Set_All();\n+      bool success = lrg->rollover();\n+      if (!success) {\n+        \/\/ We should never get here in practice. Bail out in product,\n+        \/\/ assert in debug.\n+        assert(false, \"the next available stack slots should be within the \"\n+                      \"OptoRegPair range\");\n+        C->record_method_not_compilable(\n+            \"chunk-rollover outside of OptoRegPair range\");\n+        return -1;\n+      }\n@@ -1656,1 +1682,2 @@\n-      RegMask avail_rm = lrg->mask();\n+      ResourceMark rm(C->regmask_arena());\n+      RegMask avail_rm(lrg->mask(), C->regmask_arena());\n@@ -1662,4 +1689,3 @@\n-      if( reg >= _max_reg )     \/\/ Compute max register limit\n-        _max_reg = OptoReg::add(reg,1);\n-      \/\/ Fold reg back into normal space\n-      reg = OptoReg::add(reg,-chunk);\n+      if (reg >= _max_reg) { \/\/ Compute max register limit\n+        _max_reg = OptoReg::add(reg, 1);\n+      }\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":74,"deletions":48,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -132,0 +132,1 @@\n+  void init_mask(Arena* arena) { new (&_mask) RegMask(arena); }\n@@ -134,0 +135,1 @@\n+  void SUBTRACT_inner(const RegMask& rm) { _mask.SUBTRACT_inner(rm); DEBUG_ONLY(_msize_valid = 0;) }\n@@ -135,1 +137,2 @@\n-  void Set_All() { _mask.Set_All(); DEBUG_ONLY(_msize_valid=1); _mask_size = RegMask::CHUNK_SIZE; }\n+  void Set_All() { _mask.Set_All(); DEBUG_ONLY(_msize_valid = 1); _mask_size = _mask.rm_size_in_bits(); }\n+  bool rollover() { DEBUG_ONLY(_msize_valid = 1); _mask_size = _mask.rm_size_in_bits(); return _mask.rollover(); }\n@@ -700,1 +703,1 @@\n-  OptoReg::Name choose_color( LRG &lrg, int chunk );\n+  OptoReg::Name choose_color(LRG& lrg);\n@@ -702,1 +705,1 @@\n-  OptoReg::Name bias_color( LRG &lrg, int chunk );\n+  OptoReg::Name bias_color(LRG& lrg);\n","filename":"src\/hotspot\/share\/opto\/chaitin.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -696,2 +696,3 @@\n-  RegMask rm = lrgs(lr1).mask();\n-  rm.AND(lrgs(lr2).mask());\n+  ResourceMark rm(C->regmask_arena());\n+  RegMask mask(lrgs(lr1).mask(), C->regmask_arena());\n+  mask.AND(lrgs(lr2).mask());\n@@ -699,1 +700,1 @@\n-  uint rm_size = rm.Size();\n+  uint rm_size = mask.Size();\n@@ -701,1 +702,1 @@\n-  if (UseFPUForSpilling && rm.is_infinite_stack()) {\n+  if (UseFPUForSpilling && mask.is_infinite_stack() ) {\n@@ -710,1 +711,1 @@\n-  if (rm.is_infinite_stack()) {\n+  if (mask.is_infinite_stack()) {\n@@ -735,1 +736,1 @@\n-  uint reg_degree = _ulr.lrg_union( lr1, lr2, rm_size, _phc._ifg, rm );\n+  uint reg_degree = _ulr.lrg_union( lr1, lr2, rm_size, _phc._ifg, mask );\n@@ -748,1 +749,1 @@\n-    reg_degree = compute_separating_interferences(dst_copy, src_copy, b, bindex, rm, rm_size, reg_degree, lr1, lr2 );\n+    reg_degree = compute_separating_interferences(dst_copy, src_copy, b, bindex, mask, rm_size, reg_degree, lr1, lr2 );\n@@ -795,1 +796,1 @@\n-  lrgs(lr1).set_mask(rm);\n+  lrgs(lr1).set_mask(mask);\n","filename":"src\/hotspot\/share\/opto\/coalesce.cpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -696,0 +696,1 @@\n+      _FIRST_STACK_mask(comp_arena()),\n@@ -697,0 +698,1 @@\n+      _regmask_arena(mtCompiler, Arena::Tag::tag_regmask),\n@@ -957,0 +959,1 @@\n+      _FIRST_STACK_mask(comp_arena()),\n@@ -958,0 +961,1 @@\n+      _regmask_arena(mtCompiler, Arena::Tag::tag_regmask),\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -529,0 +529,6 @@\n+  \/\/ Holds dynamically allocated extensions of short-lived register masks. Such\n+  \/\/ extensions are potentially quite large and need tight resource marks which\n+  \/\/ may conflict with other allocations in the default resource area.\n+  \/\/ Therefore, we use a dedicated resource area for register masks.\n+  ResourceArea          _regmask_arena;\n+\n@@ -1116,0 +1122,1 @@\n+  ResourceArea*     regmask_arena()             { return &_regmask_arena; }\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1452,1 +1452,1 @@\n-  if (mach && mach->out_RegMask().is_bound1() && mach->out_RegMask().is_NotEmpty())\n+  if (mach != nullptr && mach->out_RegMask().is_bound1() && !mach->out_RegMask().is_Empty())\n@@ -1485,1 +1485,1 @@\n-    if (mach && LCA == root_block)\n+    if (mach != nullptr && LCA == root_block)\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+    _lrgs[i].init_mask(_arena);\n@@ -655,1 +656,2 @@\n-  RegMask mask_tmp = lrg.mask();\n+  ResourceMark rm(C->regmask_arena());\n+  RegMask mask_tmp(lrg.mask(), C->regmask_arena());\n@@ -712,1 +714,4 @@\n-  const RegMask& rm = lrg.mask();\n+  const RegMask& mask = lrg.mask();\n+  ResourceMark rm(C->regmask_arena());\n+  RegMask old(C->regmask_arena());\n+  RegMask r2mask(C->regmask_arena());\n@@ -727,1 +732,1 @@\n-    RegMask old = interfering_lrg.mask();\n+    old = interfering_lrg.mask();\n@@ -730,2 +735,2 @@\n-    \/\/ Remove the bits from LRG 'rm' from LRG 'l' so 'l' no\n-    \/\/ longer interferes with 'rm'.  If 'l' requires aligned\n+    \/\/ Remove the bits from LRG 'mask' from LRG 'l' so 'l' no\n+    \/\/ longer interferes with 'mask'.  If 'l' requires aligned\n@@ -736,1 +741,1 @@\n-      RegMask r2mask = rm;\n+      r2mask = mask;\n@@ -744,1 +749,1 @@\n-      interfering_lrg.SUBTRACT(rm);\n+      interfering_lrg.SUBTRACT(mask);\n@@ -748,1 +753,1 @@\n-      OptoReg::Name r_reg = rm.find_first_elem();\n+      OptoReg::Name r_reg = mask.find_first_elem();\n@@ -931,1 +936,1 @@\n-        if (lrg.is_bound() && !n->rematerialize() && lrg.mask().is_NotEmpty()) {\n+        if (lrg.is_bound() && !n->rematerialize() && !lrg.mask().is_Empty()) {\n","filename":"src\/hotspot\/share\/opto\/ifg.cpp","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -872,1 +872,2 @@\n-  RegMask regs;\n+  ResourceMark rm(C->regmask_arena());\n+  RegMask regs(C->regmask_arena());\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"opto\/regmask.hpp\"\n@@ -41,2 +42,8 @@\n-BoxLockNode::BoxLockNode( int slot ) : Node( Compile::current()->root() ),\n-                                       _slot(slot), _kind(BoxLockNode::Regular) {\n+BoxLockNode::BoxLockNode(int slot)\n+    : Node(Compile::current()->root()),\n+      _slot(slot),\n+      \/\/ In debug mode, signal that the register mask is constant.\n+      _inmask(OptoReg::stack2reg(_slot),\n+              Compile::current()->comp_arena()\n+              DEBUG_ONLY(COMMA \/*read_only*\/ true)),\n+      _kind(BoxLockNode::Regular) {\n@@ -45,3 +52,3 @@\n-  OptoReg::Name reg = OptoReg::stack2reg(_slot);\n-  if (!RegMask::can_represent(reg, Compile::current()->sync_stack_slots())) {\n-    Compile::current()->record_method_not_compilable(\"must be able to represent all monitor slots in reg mask\");\n+  if (_slot > BoxLockNode_SLOT_LIMIT) {\n+    Compile::current()->record_method_not_compilable(\n+        \"reached BoxLockNode slot limit\");\n@@ -50,1 +57,0 @@\n-  _inmask.Insert(reg);\n","filename":"src\/hotspot\/share\/opto\/locknode.cpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,2 @@\n-  const int     _slot; \/\/ stack slot\n-  RegMask     _inmask; \/\/ OptoReg corresponding to stack slot\n+  const int _slot;       \/\/ stack slot\n+  const RegMask _inmask; \/\/ OptoReg corresponding to stack slot\n","filename":"src\/hotspot\/share\/opto\/locknode.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -528,1 +528,1 @@\n-    if (rm.is_NotEmpty() && rm.is_bound(ideal_reg())) {\n+    if (!rm.is_Empty() && rm.is_bound(ideal_reg())) {\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -757,1 +757,4 @@\n-  MachProjNode( Node *multi, uint con, const RegMask &out, uint ideal_reg ) : ProjNode(multi,con), _rout(out), _ideal_reg(ideal_reg) {\n+  MachProjNode(Node* multi, uint con, const RegMask& out, uint ideal_reg)\n+      : ProjNode(multi, con),\n+        _rout(out, Compile::current()->comp_arena()),\n+        _ideal_reg(ideal_reg) {\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -83,1 +83,2 @@\n-  _register_save_type(register_save_type) {\n+  _register_save_type(register_save_type),\n+  _return_addr_mask(C->comp_arena()) {\n@@ -143,6 +144,0 @@\n-    if (!RegMask::can_represent_arg(warped)) {\n-      \/\/ the compiler cannot represent this method's calling sequence\n-      \/\/ Bailout. We do not have space to represent all arguments.\n-      C->record_method_not_compilable(\"unsupported incoming calling sequence\");\n-      return OptoReg::Bad;\n-    }\n@@ -201,1 +196,3 @@\n-  _return_addr_mask = return_addr();\n+  assert(_return_addr_mask.is_Empty(),\n+         \"return address mask must be empty initially\");\n+  _return_addr_mask.Insert(return_addr());\n@@ -238,0 +235,1 @@\n+    new (_calling_convention_mask + i) RegMask(C->comp_arena());\n@@ -294,3 +292,0 @@\n-    if (C->failing()) {\n-      return;\n-    }\n@@ -301,3 +296,0 @@\n-    if (C->failing()) {\n-      return;\n-    }\n@@ -324,8 +316,0 @@\n-  if (!RegMask::can_represent_arg(OptoReg::add(_out_arg_limit,-1))) {\n-    \/\/ the compiler cannot represent this method's calling sequence\n-    \/\/ Bailout. We do not have space to represent all arguments.\n-    C->record_method_not_compilable(\"must be able to represent all call arguments in reg mask\");\n-  }\n-\n-  if (C->failing())  return;  \/\/ bailed out on incoming arg failure\n-\n@@ -454,0 +438,3 @@\n+  for (unsigned int i = 0; i < size; ++i) {\n+    new (rms + i) RegMask(Compile::current()->comp_arena());\n+  }\n@@ -493,1 +480,1 @@\n-    new (rms + i) RegMask();\n+    new (rms + i) RegMask(C->comp_arena());\n@@ -542,2 +529,0 @@\n-  OptoReg::Name i;\n-\n@@ -549,1 +534,1 @@\n-  for (i = init_in; i < _in_arg_limit; i = OptoReg::add(i,1)) {\n+  for (OptoReg::Name i = init_in; i < _in_arg_limit; i = OptoReg::add(i, 1)) {\n@@ -553,8 +538,1 @@\n-  guarantee(RegMask::can_represent_arg(OptoReg::add(_out_arg_limit,-1)),\n-            \"must be able to represent all call arguments in reg mask\");\n-  OptoReg::Name init = _out_arg_limit;\n-  for (i = init; RegMask::can_represent(i); i = OptoReg::add(i,1)) {\n-    C->FIRST_STACK_mask().Insert(i);\n-  }\n-  \/\/ Finally, set the \"infinite stack\" bit.\n-  C->FIRST_STACK_mask().set_infinite_stack();\n+  C->FIRST_STACK_mask().Set_All_From(_out_arg_limit);\n@@ -563,1 +541,1 @@\n-  RegMask aligned_stack_mask = C->FIRST_STACK_mask();\n+  RegMask aligned_stack_mask(C->FIRST_STACK_mask(), C->comp_arena());\n@@ -567,1 +545,1 @@\n-  RegMask scalable_stack_mask = aligned_stack_mask;\n+  RegMask scalable_stack_mask(aligned_stack_mask, C->comp_arena());\n@@ -987,1 +965,1 @@\n-  c_frame_ptr_mask = c_frame_pointer();\n+  c_frame_ptr_mask = RegMask(c_frame_pointer());\n@@ -995,1 +973,0 @@\n-  OptoReg::Name init = OptoReg::stack2reg(0);\n@@ -997,5 +974,1 @@\n-  OptoReg::Name i;\n-  for (i = init; RegMask::can_represent(i); i = OptoReg::add(i,1))\n-    STACK_ONLY_mask.Insert(i);\n-  \/\/ Also set the \"infinite stack\" bit.\n-  STACK_ONLY_mask.set_infinite_stack();\n+  STACK_ONLY_mask.Set_All_From(OptoReg::stack2reg(0));\n@@ -1003,1 +976,2 @@\n-  for (i = OptoReg::Name(0); i < OptoReg::Name(_last_Mach_Reg); i = OptoReg::add(i, 1)) {\n+  for (OptoReg::Name i = OptoReg::Name(0); i < OptoReg::Name(_last_Mach_Reg);\n+       i = OptoReg::add(i, 1)) {\n@@ -1280,6 +1254,2 @@\n-    if( warped >= out_arg_limit_per_call )\n-      out_arg_limit_per_call = OptoReg::add(warped,1);\n-    if (!RegMask::can_represent_arg(warped)) {\n-      \/\/ Bailout. For example not enough space on stack for all arguments. Happens for methods with too many arguments.\n-      C->record_method_not_compilable(\"unsupported calling sequence\");\n-      return OptoReg::Bad;\n+    if (warped >= out_arg_limit_per_call) {\n+      out_arg_limit_per_call = OptoReg::add(warped, 1);\n@@ -1369,1 +1339,3 @@\n-  for (uint i = 0; i < cnt; i++) ::new (&(msfpt->_in_rms[i])) RegMask();\n+  for (uint i = 0; i < cnt; i++) {\n+    ::new (msfpt->_in_rms + i) RegMask(C->comp_arena());\n+  }\n@@ -1452,3 +1424,0 @@\n-      if (C->failing()) {\n-        return nullptr;\n-      }\n@@ -1459,3 +1428,0 @@\n-      if (C->failing()) {\n-        return nullptr;\n-      }\n@@ -1481,6 +1447,2 @@\n-    if (!RegMask::can_represent_arg(OptoReg::Name(out_arg_limit_per_call-1))) {\n-      \/\/ Bailout. We do not have space to represent all arguments.\n-      C->record_method_not_compilable(\"unsupported outgoing calling sequence\");\n-    } else {\n-      for (int i = begin_out_arg_area; i < out_arg_limit_per_call; i++)\n-        proj->_rout.Insert(OptoReg::Name(i));\n+    for (int i = begin_out_arg_area; i < out_arg_limit_per_call; i++) {\n+      proj->_rout.Insert(OptoReg::Name(i));\n@@ -1488,1 +1450,1 @@\n-    if (proj->_rout.is_NotEmpty()) {\n+    if (!proj->_rout.is_Empty()) {\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":26,"deletions":64,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -552,0 +552,8 @@\n+  if (this->is_MachProj()) {\n+    \/\/ MachProjNodes contain register masks that may contain pointers to\n+    \/\/ externally allocated memory. Make sure to use a proper constructor\n+    \/\/ instead of just shallowly copying.\n+    MachProjNode* mach = n->as_MachProj();\n+    MachProjNode* mthis = this->as_MachProj();\n+    new (&mach->_rout) RegMask(mthis->_rout);\n+  }\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -186,2 +187,4 @@\n-  short _second;\n-  short _first;\n+  typedef short Name;\n+  Name _second;\n+  Name _first;\n+\n@@ -189,5 +192,25 @@\n-  void set_bad (                   ) { _second = OptoReg::Bad; _first = OptoReg::Bad; }\n-  void set1    ( OptoReg::Name n  ) { _second = OptoReg::Bad; _first = n; }\n-  void set2    ( OptoReg::Name n  ) { _second = n + 1;       _first = n; }\n-  void set_pair( OptoReg::Name second, OptoReg::Name first    ) { _second= second;    _first= first; }\n-  void set_ptr ( OptoReg::Name ptr ) {\n+  static constexpr bool can_fit(OptoReg::Name n) {\n+    return n <= std::numeric_limits<OptoRegPair::Name>::max();\n+  }\n+  void set_bad() {\n+    _second = OptoReg::Bad;\n+    _first = OptoReg::Bad;\n+  }\n+  void set1(OptoReg::Name n) {\n+    assert(can_fit(n), \"overflow\");\n+    _second = OptoReg::Bad;\n+    _first = n;\n+  }\n+  void set2(OptoReg::Name n) {\n+    assert(can_fit(n + 1), \"overflow\");\n+    assert(can_fit(n), \"overflow\");\n+    _second = n + 1;\n+    _first = n;\n+  }\n+  void set_pair(OptoReg::Name second, OptoReg::Name first) {\n+    assert(can_fit(second), \"overflow\");\n+    assert(can_fit(first), \"overflow\");\n+    _second = second;\n+    _first = first;\n+  }\n+  void set_ptr(OptoReg::Name ptr) {\n@@ -195,1 +218,2 @@\n-    _second = ptr+1;\n+    assert(can_fit(ptr + 1), \"overflow\");\n+    _second = ptr + 1;\n@@ -199,0 +223,1 @@\n+    assert(can_fit(ptr), \"overflow\");\n@@ -204,3 +229,6 @@\n-  OptoRegPair(OptoReg::Name second, OptoReg::Name first) {  _second = second; _first = first; }\n-  OptoRegPair(OptoReg::Name f) { _second = OptoReg::Bad; _first = f; }\n-  OptoRegPair() { _second = OptoReg::Bad; _first = OptoReg::Bad; }\n+  OptoRegPair(OptoReg::Name second, OptoReg::Name first) {\n+    assert(can_fit(second), \"overflow\");\n+    assert(can_fit(first), \"overflow\");\n+    _second = second;\n+    _first = first;\n+  }\n","filename":"src\/hotspot\/share\/opto\/optoreg.hpp","additions":39,"deletions":11,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -176,2 +176,1 @@\n-  bool can_use = (RegMask::can_represent(def_reg) ? (use_mask.Member(def_reg) != 0)\n-                                                  : (use_mask.is_infinite_stack() != 0));\n+  bool can_use = use_mask.Member(def_reg);\n@@ -668,1 +667,1 @@\n-          if( !value[ureg] ) {\n+          if( value[ureg] == nullptr ) {\n@@ -682,3 +681,4 @@\n-              if (!value[ureg_lo] &&\n-                  (!RegMask::can_represent(ureg_lo) ||\n-                   lrgs(useidx).mask().Member(ureg_lo))) { \/\/ Nearly always adjacent\n+              bool is_adjacent = lrgs(useidx).mask().Member(ureg_lo);\n+              assert(is_adjacent || OptoReg::is_reg(ureg_lo),\n+                     \"only registers can be non-adjacent\");\n+              if (value[ureg_lo] == nullptr && is_adjacent) { \/\/ Nearly always adjacent\n@@ -765,2 +765,3 @@\n-        if( RegMask::can_represent(nreg_lo) &&     \/\/ Either a spill slot, or\n-            !lrgs(lidx).mask().Member(nreg_lo) ) { \/\/ Nearly always adjacent\n+        bool is_adjacent = lrgs(lidx).mask().Member(nreg_lo);\n+        assert(is_adjacent || OptoReg::is_reg(nreg_lo), \"only registers can be non-adjacent\");\n+        if (!is_adjacent) { \/\/ Nearly always adjacent\n","filename":"src\/hotspot\/share\/opto\/postaloc.cpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -479,1 +479,1 @@\n-    if (n->out_RegMask().is_NotEmpty()) {\n+    if (!n->out_RegMask().is_Empty()) {\n@@ -1129,1 +1129,2 @@\n-                  RegMask tmp_rm(umask);\n+                  ResourceMark rm(C->regmask_arena());\n+                  RegMask tmp_rm(umask, C->regmask_arena());\n","filename":"src\/hotspot\/share\/opto\/reg_split.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"utilities\/population_count.hpp\"\n@@ -55,1 +54,1 @@\n-  FORALL_BODY\n+    FORALL_BODY\n@@ -57,2 +56,1 @@\n-  0\n-);\n+    true);\n@@ -122,1 +120,1 @@\n-    uintptr_t bits = _rm_word[i];\n+    uintptr_t bits = rm_word(i);\n@@ -125,1 +123,1 @@\n-    _rm_word[i] = bits;\n+    rm_word(i) = bits;\n@@ -138,1 +136,1 @@\n-    uintptr_t bits = _rm_word[i];\n+    uintptr_t bits = rm_word(i);\n@@ -159,1 +157,1 @@\n-    uintptr_t v = _rm_word[i];\n+    uintptr_t v = rm_word(i);\n@@ -168,1 +166,1 @@\n-        if (_rm_word[i] != 0) {\n+        if (rm_word(i) != 0) {\n@@ -188,2 +186,2 @@\n-    if (_rm_word[i] != 0) {               \/\/ Found some bits\n-      unsigned int bit_index = find_lowest_bit(_rm_word[i]);\n+    if (rm_word(i) != 0) {               \/\/ Found some bits\n+      unsigned int bit_index = find_lowest_bit(rm_word(i));\n@@ -192,1 +190,1 @@\n-        if ((bit | (bit << 1U)) != _rm_word[i]) {\n+        if ((bit | (bit << 1U)) != rm_word(i)) {\n@@ -196,1 +194,1 @@\n-        assert(is_power_of_2(_rm_word[i]), \"invariant\");\n+        assert(is_power_of_2(rm_word(i)), \"invariant\");\n@@ -198,1 +196,1 @@\n-        if (i > _hwm || _rm_word[i] != 1) {\n+        if (i > _hwm || rm_word(i) != 1) {\n@@ -205,1 +203,1 @@\n-        if (_rm_word[i] != 0) {\n+        if (rm_word(i) != 0) {\n@@ -251,1 +249,1 @@\n-    if (_rm_word[i]) {                \/\/ Found some bits\n+    if (rm_word(i) != 0) {                \/\/ Found some bits\n@@ -253,1 +251,2 @@\n-      return OptoReg::Name((i << LogBitsPerWord) + find_lowest_bit(_rm_word[i]) + (size - 1));\n+      return OptoReg::Name(offset_bits() + (i << LogBitsPerWord) +\n+                           find_lowest_bit(rm_word(i)) + (size - 1));\n@@ -267,1 +266,1 @@\n-    uintptr_t bits = _rm_word[i];\n+    uintptr_t bits = rm_word(i);\n@@ -282,1 +281,1 @@\n-    _rm_word[i] = sets;\n+    rm_word(i) = sets;\n@@ -295,1 +294,1 @@\n-    uintptr_t bits = _rm_word[i];\n+    uintptr_t bits = rm_word(i);\n@@ -311,1 +310,1 @@\n-    _rm_word[i] = sets;\n+    rm_word(i) = sets;\n@@ -324,2 +323,2 @@\n-    uintptr_t bits = _rm_word[i];\n-    while (bits) {              \/\/ Check bits for pairing\n+    uintptr_t bits = rm_word(i);\n+    while (bits != 0) {              \/\/ Check bits for pairing\n@@ -353,2 +352,2 @@\n-    if (_rm_word[i] != 0) {       \/\/ Found some bits\n-      unsigned bit_index = find_lowest_bit(_rm_word[i]);\n+    if (rm_word(i) != 0) {       \/\/ Found some bits\n+      unsigned bit_index = find_lowest_bit(rm_word(i));\n@@ -359,1 +358,1 @@\n-        if (set != _rm_word[i]) {\n+        if (set != rm_word(i)) {\n@@ -364,1 +363,1 @@\n-        if ((all & ~(bit - 1)) != _rm_word[i]) {\n+        if ((all & ~(bit - 1)) != rm_word(i)) {\n@@ -370,1 +369,1 @@\n-        if (i > _hwm || _rm_word[i] != set) {\n+        if (i > _hwm || rm_word(i) != set) {\n@@ -377,1 +376,1 @@\n-        if (_rm_word[i] != 0) {\n+        if (rm_word(i) != 0) {\n@@ -402,6 +401,15 @@\n-\/\/ Compute size of register mask in bits\n-uint RegMask::Size() const {\n-  uint sum = 0;\n-  assert(valid_watermarks(), \"sanity\");\n-  for (unsigned i = _lwm; i <= _hwm; i++) {\n-    sum += population_count(_rm_word[i]);\n+#ifndef PRODUCT\n+bool RegMask::dump_end_run(outputStream* st, OptoReg::Name start,\n+                           OptoReg::Name last) const {\n+  bool last_is_end = last == (int)offset_bits() + (int)rm_size_in_bits() - 1;\n+  if (is_infinite_stack() && last_is_end) {\n+    st->print(\"-...\");\n+    return true;\n+  }\n+  if (start == last) { \/\/ 1-register run; no special printing\n+  } else if (start + 1 == last) {\n+    st->print(\",\"); \/\/ 2-register run; print as \"rX,rY\"\n+    OptoReg::dump(last, st);\n+  } else { \/\/ Multi-register run; print as \"rX-rZ\"\n+    st->print(\"-\");\n+    OptoReg::dump(last, st);\n@@ -409,1 +417,1 @@\n-  return sum;\n+  return false;\n@@ -412,1 +420,0 @@\n-#ifndef PRODUCT\n@@ -417,0 +424,1 @@\n+  bool printed_infinite_stack = false;\n@@ -433,8 +441,2 @@\n-        if (start == last) {    \/\/ 1-register run; no special printing\n-        } else if (start+1 == last) {\n-          st->print(\",\");       \/\/ 2-register run; print as \"rX,rY\"\n-          OptoReg::dump(last, st);\n-        } else {                \/\/ Multi-register run; print as \"rX-rZ\"\n-          st->print(\"-\");\n-          OptoReg::dump(last, st);\n-        }\n+        printed_infinite_stack = dump_end_run(st, start, last);\n+        assert(!printed_infinite_stack, \"\");\n@@ -446,8 +448,6 @@\n-\n-    if (start == last) {        \/\/ 1-register run; no special printing\n-    } else if (start+1 == last) {\n-      st->print(\",\");           \/\/ 2-register run; print as \"rX,rY\"\n-      OptoReg::dump(last, st);\n-    } else {                    \/\/ Multi-register run; print as \"rX-rZ\"\n-      st->print(\"-\");\n-      OptoReg::dump(last, st);\n+    printed_infinite_stack = dump_end_run(st, start, last);\n+    \/\/ Print infinite_stack if not already done.\n+    if (is_infinite_stack() && !printed_infinite_stack) {\n+      st->print(\",\");\n+      OptoReg::dump(offset_bits() + rm_size_in_bits(), st);\n+      st->print(\"-...\");\n@@ -455,2 +455,5 @@\n-    if (is_infinite_stack()) {\n-      st->print(\"...\");\n+  } else {\n+    \/\/ Mask is infinite_stack only.\n+    if (is_infinite_stack() && !printed_infinite_stack) {\n+      OptoReg::dump(offset_bits() + rm_size_in_bits(), st);\n+      st->print(\"-...\");\n@@ -461,0 +464,11 @@\n+\n+void RegMask::dump_hex(outputStream* st) const {\n+  st->print(\"...%x|\", is_infinite_stack() ? 0xf : 0x0);\n+  for (int i = rm_word_max_index(); i >= 0; i--) {\n+    st->print(LP64_ONLY(\"%0*lx\") NOT_LP64(\"%0*x\"),\n+              (int)sizeof(uintptr_t) * CHAR_BIT \/ 4, rm_word(i));\n+    if (i != 0) {\n+      st->print(\"|\");\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/opto\/regmask.cpp","additions":69,"deletions":55,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"memory\/arena.hpp\"\n@@ -34,0 +35,21 @@\n+\/\/------------------------------RegMask----------------------------------------\n+\/\/ The register mask data structure (RegMask) provides a representation\n+\/\/ of sets of OptoReg::Name (i.e., machine registers and stack slots). The data\n+\/\/ structure tracks register availability and allocations during code\n+\/\/ generation, in particular during register allocation. Internally, RegMask\n+\/\/ uses a compact bitset representation. Further documentation, including an\n+\/\/ illustrative example, is available in source code comments throughout this\n+\/\/ file.\n+\n+\/\/ The ADLC defines 3 macros, RM_SIZE_IN_INTS, RM_SIZE_IN_INTS_MIN, and FORALL_BODY.\n+\/\/ RM_SIZE_IN_INTS is the base size of a register mask in 32-bit words.\n+\/\/ RM_SIZE_IN_INTS_MIN is the theoretical minimum size of a register mask in 32-bit\n+\/\/ words.\n+\/\/ FORALL_BODY replicates a BODY macro once per word in the register mask.\n+\/\/ The usage is somewhat clumsy and limited to the regmask.[h,c]pp files.\n+\/\/ However, it means the ADLC can redefine the unroll macro and all loops\n+\/\/ over register masks will be unrolled by the correct amount.\n+\/\/\n+\/\/ The ADL file describes how to print the machine-specific registers, as well\n+\/\/ as any notion of register classes.\n+\n@@ -36,0 +58,8 @@\n+\/\/ To avoid unbounded RegMask growth and to be able to statically compute a\n+\/\/ register mask size upper bound (see RM_SIZE_IN_INTS_MAX below), we need to\n+\/\/ set some form of limit on the number of stack slots used by BoxLockNodes. The\n+\/\/ limit below is rather arbitrary but should be quite generous and cover all\n+\/\/ practical cases. We reach this limit by, e.g., deeply nesting synchronized\n+\/\/ statements in Java.\n+const int BoxLockNode_SLOT_LIMIT = 200;\n+\n@@ -46,12 +76,0 @@\n-\/\/------------------------------RegMask----------------------------------------\n-\/\/ The ADL file describes how to print the machine-specific registers, as well\n-\/\/ as any notion of register classes.  We provide a register mask, which is\n-\/\/ just a collection of Register numbers.\n-\n-\/\/ The ADLC defines 2 macros, RM_SIZE_IN_INTS and FORALL_BODY.\n-\/\/ RM_SIZE_IN_INTS is the size of a register mask in 32-bit words.\n-\/\/ FORALL_BODY replicates a BODY macro once per word in the register mask.\n-\/\/ The usage is somewhat clumsy and limited to the regmask.[h,c]pp files.\n-\/\/ However, it means the ADLC can redefine the unroll macro and all loops\n-\/\/ over register masks will be unrolled by the correct amount.\n-\n@@ -66,2 +84,6 @@\n-  static const unsigned int RM_SIZE_IN_WORDS =\n-      LP64_ONLY(RM_SIZE_IN_INTS >> 1) NOT_LP64(RM_SIZE_IN_INTS);\n+\n+  \/\/ RM_SIZE_IN_INTS, but in number of machine words\n+  static const unsigned int RM_SIZE_IN_WORDS = LP64_ONLY(RM_SIZE_IN_INTS >> 1) NOT_LP64(RM_SIZE_IN_INTS);\n+\n+  \/\/ The last index (in machine words) of the (static) array of register mask\n+  \/\/ bits\n@@ -70,0 +92,22 @@\n+  \/\/ Compute a best-effort (statically known) upper bound for register mask\n+  \/\/ size in 32-bit words. When extending\/growing register masks, we should\n+  \/\/ never grow past this size.\n+  static const unsigned int RM_SIZE_IN_INTS_MAX =\n+      (((RM_SIZE_IN_INTS_MIN << 5) +        \/\/ Slots for machine registers\n+        (max_method_parameter_length * 2) + \/\/ Slots for incoming arguments (from caller)\n+        (max_method_parameter_length * 2) + \/\/ Slots for outgoing arguments (to callee)\n+        BoxLockNode_SLOT_LIMIT +            \/\/ Slots for locks\n+        64                                  \/\/ Padding, reserved words, etc.\n+        ) + 31) >> 5; \/\/ Number of bits -> number of 32-bit words\n+\n+  \/\/ RM_SIZE_IN_INTS_MAX, but in number of machine words\n+  static const unsigned int RM_SIZE_IN_WORDS_MAX =\n+      LP64_ONLY(((RM_SIZE_IN_INTS_MAX + 1) & ~1) >> 1) NOT_LP64(RM_SIZE_IN_INTS_MAX);\n+\n+  \/\/ Sanity check\n+  STATIC_ASSERT(RM_SIZE_IN_INTS <= RM_SIZE_IN_INTS_MAX);\n+\n+  \/\/ Ensure that register masks cannot grow beyond the point at which\n+  \/\/ OptoRegPair can no longer index the whole mask\n+  STATIC_ASSERT(OptoRegPair::can_fit((RM_SIZE_IN_INTS_MAX << 5) - 1));\n+\n@@ -71,5 +115,8 @@\n-    \/\/ Array of Register Mask bits.  This array is large enough to cover\n-    \/\/ all the machine registers and all parameters that need to be passed\n-    \/\/ on the stack (stack registers) up to some interesting limit.  Methods\n-    \/\/ that need more parameters will NOT be compiled.  On Intel, the limit\n-    \/\/ is something like 90+ parameters.\n+    \/\/ Array of Register Mask bits. The array should be\n+    \/\/ large enough to cover all the machine registers, as well as a certain\n+    \/\/ number of parameters that need to be passed on the stack (stack\n+    \/\/ registers). The number of parameters that can fit in the mask should be\n+    \/\/ dimensioned to cover most common cases. We handle the uncommon cases by\n+    \/\/ extending register masks dynamically (see below).\n+\n+    \/\/ Viewed as an array of 32-bit words\n@@ -77,0 +124,2 @@\n+\n+    \/\/ Viewed as an array of machine words\n@@ -80,4 +129,59 @@\n-  \/\/ The low and high water marks represents the lowest and highest word\n-  \/\/ that might contain set register mask bits, respectively. We guarantee\n-  \/\/ that there are no bits in words outside this range, but any word at\n-  \/\/ and between the two marks can still be 0.\n+  \/\/ In rare situations (e.g., \"more than 90+ parameters on Intel\"), we need to\n+  \/\/ extend the register mask with dynamically allocated memory. We keep the\n+  \/\/ base statically allocated _rm_word, and arena allocate the extended mask\n+  \/\/ (_rm_word_ext) separately. Another, perhaps more elegant, option would be to\n+  \/\/ have two subclasses of RegMask, where one is statically allocated and one\n+  \/\/ is (entirely) dynamically allocated. Given that register mask extension is\n+  \/\/ rare, we decided to use the current approach (_rm_word and _rm_word_ext) to\n+  \/\/ keep the common case fast. Most of the time, we will then not need to\n+  \/\/ dynamically allocate anything.\n+  \/\/\n+  \/\/ We could use a GrowableArray here, but there are currently some\n+  \/\/ GrowableArray limitations that have a negative performance impact for our\n+  \/\/ use case:\n+  \/\/\n+  \/\/ - There is no efficient copy\/clone operation.\n+  \/\/ - GrowableArray construction currently default-initializes everything\n+  \/\/   within the array's initial capacity, which is unnecessary in our case.\n+  \/\/\n+  \/\/ After addressing these limitations, we should consider using a\n+  \/\/ GrowableArray here.\n+  uintptr_t* _rm_word_ext = nullptr;\n+\n+  \/\/ Where to extend the register mask\n+  Arena* _arena;\n+\n+#ifdef ASSERT\n+  \/\/ Register masks may get shallowly copied without the use of constructors,\n+  \/\/ for example as part of `Node::clone`. This is problematic when dealing with\n+  \/\/ the externally allocated memory for _rm_word_ext. Therefore, we need some\n+  \/\/ sanity checks to ensure we have addressed all such cases. The below\n+  \/\/ variables enable such checks.\n+  \/\/\n+  \/\/ The original address of the _rm_word_ext variable, set when using\n+  \/\/ constructors. If we get copied\/cloned, &_rm_word_ext will no longer equal\n+  \/\/ _original_ext_address.\n+  uintptr_t** _original_ext_address = &_rm_word_ext;\n+  \/\/\n+  \/\/ If the original version, of which we may be a clone, is read-only. In such\n+  \/\/ cases, we can allow read-only sharing.\n+  bool _read_only = false;\n+#endif\n+\n+  \/\/ Current *total* register mask size in machine words (both static and\n+  \/\/ dynamic parts)\n+  unsigned int _rm_size_in_words;\n+\n+  \/\/ If _infinite_stack = true, we consider all registers beyond what the register\n+  \/\/ mask can currently represent to be included. If _infinite_stack = false, we\n+  \/\/ consider the registers not included.\n+  bool _infinite_stack = false;\n+\n+  \/\/ The low and high watermarks represent the lowest and highest word that\n+  \/\/ might contain set register mask bits, respectively. We guarantee that\n+  \/\/ there are no bits in words outside this range, but any word at and between\n+  \/\/ the two marks can still be 0. We only use the watermarks to improve\n+  \/\/ performance, and do not guarantee that the watermarks are optimal. If _hwm\n+  \/\/ < _lwm, the register mask is necessarily empty. Indeed, when we construct\n+  \/\/ empty register masks, we set _hwm = 0 and _lwm = max. The watermarks do not\n+  \/\/ concern _infinite_stack-registers.\n@@ -87,2 +191,197 @@\n- public:\n-  enum { CHUNK_SIZE = RM_SIZE_IN_WORDS * BitsPerWord };\n+  \/\/ The following diagram illustrates the internal representation of a RegMask\n+  \/\/ (for a made-up platform with 10 registers and 4-bit words) that has been\n+  \/\/ extended with two additional words to represent more stack locations:\n+  \/\/\n+  \/\/                         _lwm=1   RM_SIZE_IN_WORDS=3 _hwm=3      _rm_size_in_words=5\n+  \/\/                            |                  |      |                 |\n+  \/\/            r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 s0 s1   s2 s3 s4 s5 s6 s7 s8 s9 s10 s11 ...\n+  \/\/ Content:  [0  0  0  0 |0  1  1  0 |0  0  1  0 ] [1  1  0  1 |0  0  0  0] is  is  is\n+  \/\/   Index: [0]         [1]         [2]           [0]         [1]\n+  \/\/\n+  \/\/          \\____________________________________\/ \\______________________\/\n+  \/\/                                 |                           |\n+  \/\/                             _rm_word                     _rm_word_ext\n+  \/\/          \\_____________________________________________________________\/\n+  \/\/                                          |\n+  \/\/                                  _rm_size_in_words=5\n+  \/\/\n+  \/\/ In this example, registers {r5, r6} and stack locations {s0, s2, s3, s5}\n+  \/\/ are included in the register mask. Depending on the value of\n+  \/\/ _infinite_stack (denoted with is), {s10, s11, ...} are all included (is=1)\n+  \/\/ or excluded (is=0). Note that all registers\/stack locations under _lwm\n+  \/\/ and over _hwm are excluded. The exception is {s10, s11, ...}, where the\n+  \/\/ value is decided solely by _infinite_stack, regardless of the value of\n+  \/\/ _hwm.\n+\n+  \/\/ We support offsetting\/shifting register masks to make explicit stack\n+  \/\/ slots that originally are implicitly represented by _infinite_stack=true.\n+  \/\/ The main use is in PhaseChaitin::Select, when selecting stack slots for\n+  \/\/ spilled values. Spilled values *must* get a stack slot, and therefore have\n+  \/\/ _infinite_stack=true. If we run out of stack slots in an\n+  \/\/ _infinite_mask=true register mask, we roll over the register mask to make\n+  \/\/ the next set of stack slots available for selection.\n+  \/\/\n+  \/\/ The _offset variable indicates how many words we offset with.\n+  \/\/ We consider all registers before the offset to not be included in the\n+  \/\/ register mask.\n+  unsigned int _offset;\n+  \/\/\n+  \/\/ The only operation that may update the _offset attribute is\n+  \/\/ RegMask::rollover(). This operation requires the register mask to be\n+  \/\/ clean\/empty (all zeroes), except for _infinite_stack, which must be true,\n+  \/\/ and has the effect of increasing _offset by _rm_size_in_words and setting\n+  \/\/ all bits (now necessarily representing stack locations) to 1. Here is how\n+  \/\/ the above register mask looks like after clearing, setting _infinite_stack\n+  \/\/ to true, and successfully rolling over:\n+  \/\/\n+  \/\/              _lwm=0                             RM_SIZE_IN_WORDS=3              _hwm=4  _rm_size_in_words=5\n+  \/\/                 |                                        |                        |      |\n+  \/\/            s10 s11 s12 s13 s14 s15 s16 s17 s18 s19 s20 s21  s22 s23 s24 s25 s26 s27 s28 s29 s30 s31 ...\n+  \/\/ Content:  [1   1   1   1  |1   1   1   1  |1   1   1   1 ] [1   1   1   1  |1   1   1   1]  1   1   1\n+  \/\/   Index: [0]             [1]             [2]              [0]             [1]\n+  \/\/\n+  \/\/          \\_______________________________________________\/ \\_____________________________\/\n+  \/\/                                    |                                     |\n+  \/\/                                _rm_word                             _rm_word_ext\n+  \/\/          \\_______________________________________________________________________________\/\n+  \/\/                                                  |\n+  \/\/                                  _rm_size_in_words=_offset=5\n+\n+  \/\/ Access word i in the register mask.\n+  const uintptr_t& rm_word(unsigned int i) const {\n+    assert(_read_only || _original_ext_address == &_rm_word_ext, \"clone sanity check\");\n+    assert(i < _rm_size_in_words, \"sanity\");\n+    if (i < RM_SIZE_IN_WORDS) {\n+      return _rm_word[i];\n+    } else {\n+      assert(_rm_word_ext != nullptr, \"sanity\");\n+      return _rm_word_ext[i - RM_SIZE_IN_WORDS];\n+    }\n+  }\n+\n+  \/\/ Non-const version of the above.\n+  uintptr_t& rm_word(unsigned int i) {\n+    assert(_original_ext_address == &_rm_word_ext, \"clone sanity check\");\n+    return const_cast<uintptr_t&>(const_cast<const RegMask*>(this)->rm_word(i));\n+  }\n+\n+  \/\/ The current maximum word index\n+  unsigned int rm_word_max_index() const {\n+    return _rm_size_in_words - 1U;\n+  }\n+\n+  \/\/ Grow the register mask to ensure it can fit at least min_size words.\n+  void grow(unsigned int min_size, bool initialize_by_infinite_stack = true) {\n+    if (min_size > _rm_size_in_words) {\n+      assert(min_size <= RM_SIZE_IN_WORDS_MAX, \"unexpected register mask growth\");\n+      assert(_arena != nullptr, \"register mask not growable\");\n+      min_size = MIN2(RM_SIZE_IN_WORDS_MAX, round_up_power_of_2(min_size));\n+      unsigned int old_size = _rm_size_in_words;\n+      unsigned int old_ext_size = old_size - RM_SIZE_IN_WORDS;\n+      unsigned int new_ext_size = min_size - RM_SIZE_IN_WORDS;\n+      _rm_size_in_words = min_size;\n+      if (_rm_word_ext == nullptr) {\n+        assert(old_ext_size == 0, \"sanity\");\n+        _rm_word_ext = NEW_ARENA_ARRAY(_arena, uintptr_t, new_ext_size);\n+      } else {\n+        assert(_original_ext_address == &_rm_word_ext, \"clone sanity check\");\n+        _rm_word_ext = REALLOC_ARENA_ARRAY(_arena, uintptr_t, _rm_word_ext,\n+                                           old_ext_size, new_ext_size);\n+      }\n+      if (initialize_by_infinite_stack) {\n+        int fill = 0;\n+        if (is_infinite_stack()) {\n+          fill = 0xFF;\n+          _hwm = rm_word_max_index();\n+        }\n+        set_range(old_size, fill, _rm_size_in_words - old_size);\n+      }\n+    }\n+  }\n+\n+  \/\/ Make us a copy of src\n+  void copy(const RegMask& src) {\n+    assert(_offset == src._offset, \"offset mismatch\");\n+    _hwm = src._hwm;\n+    _lwm = src._lwm;\n+\n+    \/\/ Copy base mask\n+    memcpy(_rm_word, src._rm_word, sizeof(uintptr_t) * RM_SIZE_IN_WORDS);\n+    _infinite_stack = src._infinite_stack;\n+\n+    \/\/ Copy extension\n+    if (src._rm_word_ext != nullptr) {\n+      assert(src._rm_size_in_words > RM_SIZE_IN_WORDS, \"sanity\");\n+      assert(_original_ext_address == &_rm_word_ext, \"clone sanity check\");\n+      grow(src._rm_size_in_words, false);\n+      memcpy(_rm_word_ext, src._rm_word_ext,\n+             sizeof(uintptr_t) * (src._rm_size_in_words - RM_SIZE_IN_WORDS));\n+    }\n+\n+    \/\/ If the source is smaller than us, we need to set the gap according to\n+    \/\/ the sources infinite_stack flag.\n+    if (src._rm_size_in_words < _rm_size_in_words) {\n+      int value = 0;\n+      if (src.is_infinite_stack()) {\n+        value = 0xFF;\n+        _hwm = rm_word_max_index();\n+      }\n+      set_range(src._rm_size_in_words, value, _rm_size_in_words - src._rm_size_in_words);\n+    }\n+\n+    assert(valid_watermarks(), \"post-condition\");\n+  }\n+\n+  \/\/ Make the watermarks as tight as possible.\n+  void trim_watermarks() {\n+    if (_hwm < _lwm) {\n+      return;\n+    }\n+    while ((_hwm > _lwm) && rm_word(_hwm) == 0) {\n+      _hwm--;\n+    }\n+    while ((_lwm < _hwm) && rm_word(_lwm) == 0) {\n+      _lwm++;\n+    }\n+    if ((_lwm == _hwm) && rm_word(_lwm) == 0) {\n+      _lwm = rm_word_max_index();\n+      _hwm = 0;\n+    }\n+  }\n+\n+  \/\/ Set a span of words in the register mask to a given value.\n+  void set_range(unsigned int start, int value, unsigned int length) {\n+    if (start < RM_SIZE_IN_WORDS) {\n+      memset(_rm_word + start, value,\n+             sizeof(uintptr_t) * MIN2((int)length, (int)RM_SIZE_IN_WORDS - (int)start));\n+    }\n+    if (start + length > RM_SIZE_IN_WORDS) {\n+      assert(_rm_word_ext != nullptr, \"sanity\");\n+      assert(_original_ext_address == &_rm_word_ext, \"clone sanity check\");\n+      memset(_rm_word_ext + MAX2((int)start - (int)RM_SIZE_IN_WORDS, 0), value,\n+             sizeof(uintptr_t) *\n+                 MIN2((int)length, (int)length - ((int)RM_SIZE_IN_WORDS - (int)start)));\n+    }\n+  }\n+\n+public:\n+  unsigned int rm_size_in_words() const {\n+    return _rm_size_in_words;\n+  }\n+  unsigned int rm_size_in_bits() const {\n+    return _rm_size_in_words * BitsPerWord;\n+  }\n+\n+  bool is_offset() const {\n+    return _offset > 0;\n+  }\n+  unsigned int offset_bits() const {\n+    return _offset * BitsPerWord;\n+  };\n+\n+  bool is_infinite_stack() const {\n+    return _infinite_stack;\n+  }\n+  void set_infinite_stack(bool value) {\n+    _infinite_stack = value;\n+  }\n@@ -113,1 +412,1 @@\n-  \/\/ in directly.  Calls to this look something like RM(1,2,3,4);\n+  \/\/ in directly.  Calls to this look something like RM(0xc0, 0x0, 0x0, false);\n@@ -116,1 +415,1 @@\n-    FORALL_BODY\n+      FORALL_BODY\n@@ -118,1 +417,2 @@\n-    int dummy = 0) {\n+      bool infinite_stack)\n+      : _arena(nullptr), _rm_size_in_words(RM_SIZE_IN_WORDS), _infinite_stack(infinite_stack), _offset(0) {\n@@ -138,7 +438,4 @@\n-  \/\/ Handy copying constructor\n-  RegMask(RegMask *rm) {\n-    _hwm = rm->_hwm;\n-    _lwm = rm->_lwm;\n-    for (unsigned i = 0; i < RM_SIZE_IN_WORDS; i++) {\n-      _rm_word[i] = rm->_rm_word[i];\n-    }\n+  \/\/ Construct an empty mask\n+  explicit RegMask(Arena* arena DEBUG_ONLY(COMMA bool read_only = false))\n+      : _rm_word(), _arena(arena) DEBUG_ONLY(COMMA _read_only(read_only)),\n+        _rm_size_in_words(RM_SIZE_IN_WORDS), _infinite_stack(false), _lwm(RM_WORD_MAX_INDEX), _hwm(0), _offset(0) {\n@@ -147,3 +444,1 @@\n-\n-  \/\/ Construct an empty mask\n-  RegMask() : _rm_word(), _lwm(RM_WORD_MAX_INDEX), _hwm(0) {\n+  RegMask() : RegMask(nullptr) {\n@@ -154,1 +449,3 @@\n-  RegMask(OptoReg::Name reg) : RegMask() {\n+  RegMask(OptoReg::Name reg,\n+          Arena* arena DEBUG_ONLY(COMMA bool read_only = false))\n+      : RegMask(arena DEBUG_ONLY(COMMA read_only)) {\n@@ -157,0 +454,1 @@\n+  explicit RegMask(OptoReg::Name reg) : RegMask(reg, nullptr) {}\n@@ -158,3 +456,3 @@\n-  \/\/ Check for register being in mask\n-  bool Member(OptoReg::Name reg) const {\n-    assert(reg < CHUNK_SIZE, \"\");\n+  \/\/ ----------------------------------------\n+  \/\/ Deep copying constructors and assignment\n+  \/\/ ----------------------------------------\n@@ -162,2 +460,3 @@\n-    unsigned r = (unsigned)reg;\n-    return _rm_word[r >> LogBitsPerWord] & (uintptr_t(1) << (r & WORD_BIT_MASK));\n+  RegMask(const RegMask& rm, Arena* arena)\n+      : _arena(arena), _rm_size_in_words(RM_SIZE_IN_WORDS), _offset(rm._offset) {\n+    copy(rm);\n@@ -166,5 +465,5 @@\n-  \/\/ The last bit in the register mask indicates that the mask should repeat\n-  \/\/ indefinitely with ONE bits.  Returns TRUE if mask is infinite or\n-  \/\/ unbounded in size.  Returns FALSE if mask is finite size.\n-  bool is_infinite_stack() const {\n-    return (_rm_word[RM_WORD_MAX_INDEX] & (uintptr_t(1) << WORD_BIT_MASK)) != 0;\n+  RegMask(const RegMask& rm) : RegMask(rm, nullptr) {}\n+\n+  RegMask& operator=(const RegMask& rm) {\n+    copy(rm);\n+    return *this;\n@@ -173,2 +472,14 @@\n-  void set_infinite_stack() {\n-    _rm_word[RM_WORD_MAX_INDEX] |= (uintptr_t(1) << WORD_BIT_MASK);\n+  \/\/ ----------------\n+  \/\/ End deep copying\n+  \/\/ ----------------\n+\n+  bool Member(OptoReg::Name reg) const {\n+    reg = reg - offset_bits();\n+    if (reg < 0) {\n+      return false;\n+    }\n+    if (reg >= (int)rm_size_in_bits()) {\n+      return is_infinite_stack();\n+    }\n+    unsigned int r = (unsigned int)reg;\n+    return rm_word(r >> LogBitsPerWord) & (uintptr_t(1) << (r & WORD_BIT_MASK));\n@@ -177,2 +488,2 @@\n-  \/\/ Test for being a not-empty mask.\n-  bool is_NotEmpty() const {\n+  \/\/ Empty mask check. Ignores registers included through the infinite_stack flag.\n+  bool is_Empty() const {\n@@ -180,1 +491,0 @@\n-    uintptr_t tmp = 0;\n@@ -182,1 +492,3 @@\n-      tmp |= _rm_word[i];\n+      if (rm_word(i) != 0) {\n+        return false;\n+      }\n@@ -184,1 +496,1 @@\n-    return tmp;\n+    return true;\n@@ -191,3 +503,4 @@\n-      uintptr_t bits = _rm_word[i];\n-      if (bits) {\n-        return OptoReg::Name((i << LogBitsPerWord) + find_lowest_bit(bits));\n+      uintptr_t bits = rm_word(i);\n+      if (bits != 0) {\n+        return OptoReg::Name(offset_bits() + (i << LogBitsPerWord) +\n+                             find_lowest_bit(bits));\n@@ -199,1 +512,2 @@\n-  \/\/ Get highest-numbered register from mask, or BAD if mask is empty.\n+  \/\/ Get highest-numbered register from mask, or BAD if mask is empty. Ignores\n+  \/\/ registers included through the infinite_stack flag.\n@@ -205,3 +519,4 @@\n-      uintptr_t bits = _rm_word[--i];\n-      if (bits) {\n-        return OptoReg::Name((i << LogBitsPerWord) + find_highest_bit(bits));\n+      uintptr_t bits = rm_word(--i);\n+      if (bits != 0) {\n+        return OptoReg::Name(offset_bits() + (i << LogBitsPerWord) +\n+                             find_highest_bit(bits));\n@@ -220,2 +535,2 @@\n-    assert(_hwm < RM_SIZE_IN_WORDS, \"_hwm out of range: %d\", _hwm);\n-    assert(_lwm < RM_SIZE_IN_WORDS, \"_lwm out of range: %d\", _lwm);\n+    assert(_hwm < _rm_size_in_words, \"_hwm out of range: %d\", _hwm);\n+    assert(_lwm < _rm_size_in_words, \"_lwm out of range: %d\", _lwm);\n@@ -223,1 +538,12 @@\n-      assert(_rm_word[i] == 0, \"_lwm too high: %d regs at: %d\", _lwm, i);\n+      assert(rm_word(i) == 0, \"_lwm too high: %d regs at: %d\", _lwm, i);\n+    }\n+    for (unsigned i = _hwm + 1; i < _rm_size_in_words; i++) {\n+      assert(rm_word(i) == 0, \"_hwm too low: %d regs at: %d\", _hwm, i);\n+    }\n+    return true;\n+  }\n+\n+  bool is_infinite_stack_only() const {\n+    assert(valid_watermarks(), \"sanity\");\n+    if (!is_infinite_stack()) {\n+      return false;\n@@ -225,2 +551,5 @@\n-    for (unsigned i = _hwm + 1; i < RM_SIZE_IN_WORDS; i++) {\n-      assert(_rm_word[i] == 0, \"_hwm too low: %d regs at: %d\", _hwm, i);\n+    uintptr_t tmp = 0;\n+    for (unsigned int i = _lwm; i <= _hwm; i++) {\n+      if (rm_word(i) != 0) {\n+        return false;\n+      }\n@@ -267,1 +596,1 @@\n-  \/\/ Fast overlap test.  Non-zero if any registers in common.\n+  \/\/ Overlap test. Non-zero if any registers in common, including infinite_stack.\n@@ -269,0 +598,1 @@\n+    assert(_offset == rm._offset, \"offset mismatch\");\n@@ -270,0 +600,3 @@\n+\n+    \/\/ Very common overlap case: _rm_word overlap. Check first to reduce\n+    \/\/ execution time.\n@@ -272,1 +605,0 @@\n-    uintptr_t result = 0;\n@@ -274,1 +606,28 @@\n-      result |= _rm_word[i] & rm._rm_word[i];\n+      if ((rm_word(i) & rm.rm_word(i)) != 0) {\n+        return true;\n+      }\n+    }\n+\n+    \/\/ Very rare overlap cases below.\n+\n+    \/\/ We are both infinite_stack\n+    if (is_infinite_stack() && rm.is_infinite_stack()) {\n+      return true;\n+    }\n+\n+    \/\/ We are infinite_stack and rm _hwm is bigger than us\n+    if (is_infinite_stack() && rm._hwm >= _rm_size_in_words) {\n+      for (unsigned i = MAX2(rm._lwm, _rm_size_in_words); i <= rm._hwm; i++) {\n+        if (rm.rm_word(i) != 0) {\n+          return true;\n+        }\n+      }\n+    }\n+\n+    \/\/ rm is infinite_stack and our _hwm is bigger than rm\n+    if (rm.is_infinite_stack() && _hwm >= rm._rm_size_in_words) {\n+      for (unsigned i = MAX2(_lwm, rm._rm_size_in_words); i <= _hwm; i++) {\n+        if (rm_word(i) != 0) {\n+          return true;\n+        }\n+      }\n@@ -276,1 +635,3 @@\n-    return result;\n+\n+    \/\/ No overlap (also very common)\n+    return false;\n@@ -283,1 +644,1 @@\n-  \/\/ Clear a register mask\n+  \/\/ Clear a register mask. Does not clear any offset.\n@@ -285,1 +646,1 @@\n-    _lwm = RM_WORD_MAX_INDEX;\n+    _lwm = rm_word_max_index();\n@@ -287,1 +648,2 @@\n-    memset(_rm_word, 0, sizeof(uintptr_t) * RM_SIZE_IN_WORDS);\n+    set_range(0, 0, _rm_size_in_words);\n+    set_infinite_stack(false);\n@@ -293,0 +655,6 @@\n+    assert(_offset == 0, \"offset non-zero\");\n+    Set_All_From_Offset();\n+  }\n+\n+  \/\/ Fill a register mask with 1's from the current offset.\n+  void Set_All_From_Offset() {\n@@ -294,2 +662,3 @@\n-    _hwm = RM_WORD_MAX_INDEX;\n-    memset(_rm_word, 0xFF, sizeof(uintptr_t) * RM_SIZE_IN_WORDS);\n+    _hwm = rm_word_max_index();\n+    set_range(0, 0xFF, _rm_size_in_words);\n+    set_infinite_stack(true);\n@@ -299,0 +668,23 @@\n+  \/\/ Fill a register mask with 1's starting from the given register.\n+  void Set_All_From(OptoReg::Name reg) {\n+    reg = reg - offset_bits();\n+    assert(reg != OptoReg::Bad, \"sanity\");\n+    assert(reg != OptoReg::Special, \"sanity\");\n+    assert(reg >= 0, \"register outside mask\");\n+    assert(valid_watermarks(), \"pre-condition\");\n+    unsigned int r = (unsigned int)reg;\n+    unsigned int index = r >> LogBitsPerWord;\n+    unsigned int min_size = index + 1;\n+    grow(min_size);\n+    rm_word(index) |= (uintptr_t(-1) << (r & WORD_BIT_MASK));\n+    if (index < rm_word_max_index()) {\n+      set_range(index + 1, 0xFF, rm_word_max_index() - index);\n+    }\n+    if (index < _lwm) {\n+      _lwm = index;\n+    }\n+    _hwm = rm_word_max_index();\n+    set_infinite_stack(true);\n+    assert(valid_watermarks(), \"post-condition\");\n+  }\n+\n@@ -301,0 +693,1 @@\n+    reg = reg - offset_bits();\n@@ -303,1 +696,1 @@\n-    assert(reg < CHUNK_SIZE, \"sanity\");\n+    assert(reg >= 0, \"register outside mask\");\n@@ -305,2 +698,4 @@\n-    unsigned r = (unsigned)reg;\n-    unsigned index = r >> LogBitsPerWord;\n+    unsigned int r = (unsigned int)reg;\n+    unsigned int index = r >> LogBitsPerWord;\n+    unsigned int min_size = index + 1;\n+    grow(min_size);\n@@ -309,1 +704,1 @@\n-    _rm_word[index] |= (uintptr_t(1) << (r & WORD_BIT_MASK));\n+    rm_word(index) |= (uintptr_t(1) << (r & WORD_BIT_MASK));\n@@ -315,3 +710,5 @@\n-    assert(reg < CHUNK_SIZE, \"\");\n-    unsigned r = (unsigned)reg;\n-    _rm_word[r >> LogBitsPerWord] &= ~(uintptr_t(1) << (r & WORD_BIT_MASK));\n+    reg = reg - offset_bits();\n+    assert(reg >= 0, \"register outside mask\");\n+    assert(reg < (int)rm_size_in_bits(), \"register outside mask\");\n+    unsigned int r = (unsigned int)reg;\n+    rm_word(r >> LogBitsPerWord) &= ~(uintptr_t(1) << (r & WORD_BIT_MASK));\n@@ -322,0 +719,1 @@\n+    assert(_offset == rm._offset, \"offset mismatch\");\n@@ -323,0 +721,1 @@\n+    grow(rm._rm_size_in_words);\n@@ -326,2 +725,3 @@\n-    for (unsigned i = _lwm; i <= _hwm; i++) {\n-      _rm_word[i] |= rm._rm_word[i];\n+    \/\/ Compute OR with all words from rm\n+    for (unsigned int i = _lwm; i <= _hwm && i < rm._rm_size_in_words; i++) {\n+      rm_word(i) |= rm.rm_word(i);\n@@ -329,0 +729,7 @@\n+    \/\/ If rm is smaller than us and has the infinite_stack flag set, we need to set\n+    \/\/ all bits in the gap to 1.\n+    if (rm.is_infinite_stack() && rm._rm_size_in_words < _rm_size_in_words) {\n+      set_range(rm._rm_size_in_words, 0xFF, _rm_size_in_words - rm._rm_size_in_words);\n+      _hwm = rm_word_max_index();\n+    }\n+    set_infinite_stack(is_infinite_stack() || rm.is_infinite_stack());\n@@ -334,0 +741,1 @@\n+    assert(_offset == rm._offset, \"offset mismatch\");\n@@ -335,4 +743,22 @@\n-    \/\/ Do not evaluate words outside the current watermark range, as they are\n-    \/\/ already zero and an &= would not change that\n-    for (unsigned i = _lwm; i <= _hwm; i++) {\n-      _rm_word[i] &= rm._rm_word[i];\n+    grow(rm._rm_size_in_words);\n+    \/\/ Compute AND with all words from rm. Do not evaluate words outside the\n+    \/\/ current watermark range, as they are already zero and an &= would not\n+    \/\/ change that\n+    for (unsigned int i = _lwm; i <= _hwm && i < rm._rm_size_in_words; i++) {\n+      rm_word(i) &= rm.rm_word(i);\n+    }\n+    \/\/ If rm is smaller than our high watermark and has the infinite_stack flag not\n+    \/\/ set, we need to set all bits in the gap to 0.\n+    if (!rm.is_infinite_stack() && _hwm > rm.rm_word_max_index()) {\n+      set_range(rm._rm_size_in_words, 0, _hwm - rm.rm_word_max_index());\n+      _hwm = rm.rm_word_max_index();\n+    }\n+    \/\/ Narrow the watermarks if rm spans a narrower range. Update after to\n+    \/\/ ensure non-overlapping words are zeroed out. If rm has the infinite_stack\n+    \/\/ flag set and is smaller than our high watermark, take care not to\n+    \/\/ incorrectly lower the high watermark according to rm.\n+    if (_lwm < rm._lwm) {\n+      _lwm = rm._lwm;\n+    }\n+    if (_hwm > rm._hwm && !(rm.is_infinite_stack() && _hwm > rm.rm_word_max_index())) {\n+      _hwm = rm._hwm;\n@@ -340,4 +766,2 @@\n-    \/\/ Narrow the watermarks if &rm spans a narrower range.\n-    \/\/ Update after to ensure non-overlapping words are zeroed out.\n-    if (_lwm < rm._lwm) _lwm = rm._lwm;\n-    if (_hwm > rm._hwm) _hwm = rm._hwm;\n+    set_infinite_stack(is_infinite_stack() && rm.is_infinite_stack());\n+    assert(valid_watermarks(), \"sanity\");\n@@ -346,1 +770,1 @@\n-  \/\/ Subtract 'rm' from 'this'\n+  \/\/ Subtract 'rm' from 'this'.\n@@ -348,0 +772,1 @@\n+    assert(_offset == rm._offset, \"offset mismatch\");\n@@ -349,4 +774,35 @@\n-    unsigned hwm = MIN2(_hwm, rm._hwm);\n-    unsigned lwm = MAX2(_lwm, rm._lwm);\n-    for (unsigned i = lwm; i <= hwm; i++) {\n-      _rm_word[i] &= ~rm._rm_word[i];\n+    grow(rm._rm_size_in_words);\n+    unsigned int hwm = MIN2(_hwm, rm._hwm);\n+    unsigned int lwm = MAX2(_lwm, rm._lwm);\n+    for (unsigned int i = lwm; i <= hwm; i++) {\n+      rm_word(i) &= ~rm.rm_word(i);\n+    }\n+    \/\/ If rm is smaller than our high watermark and has the infinite_stack flag set,\n+    \/\/ we need to set all bits in the gap to 0.\n+    if (rm.is_infinite_stack() && _hwm > rm.rm_word_max_index()) {\n+      set_range(rm.rm_size_in_words(), 0, _hwm - rm.rm_word_max_index());\n+      _hwm = rm.rm_word_max_index();\n+    }\n+    set_infinite_stack(is_infinite_stack() && !rm.is_infinite_stack());\n+    trim_watermarks();\n+    assert(valid_watermarks(), \"sanity\");\n+  }\n+\n+  \/\/ Subtract 'rm' from 'this', but ignore everything in 'rm' that does not\n+  \/\/ overlap with us and do not modify our infinite_stack flag. Supports masks of\n+  \/\/ differing offsets. Does not support 'rm' with the infinite_stack flag set.\n+  void SUBTRACT_inner(const RegMask& rm) {\n+    assert(valid_watermarks() && rm.valid_watermarks(), \"sanity\");\n+    assert(!rm.is_infinite_stack(), \"not supported\");\n+    \/\/ Various translations due to differing offsets\n+    int rm_index_diff = _offset - rm._offset;\n+    int rm_hwm_tr = (int)rm._hwm - rm_index_diff;\n+    int rm_lwm_tr = (int)rm._lwm - rm_index_diff;\n+    int rm_rm_max_tr = (int)rm.rm_word_max_index() - rm_index_diff;\n+    int rm_rm_size_tr = (int)rm._rm_size_in_words - rm_index_diff;\n+    int hwm = MIN2((int)_hwm, rm_hwm_tr);\n+    int lwm = MAX2((int)_lwm, rm_lwm_tr);\n+    for (int i = lwm; i <= hwm; i++) {\n+      assert(i + rm_index_diff < (int)rm._rm_size_in_words, \"sanity\");\n+      assert(i + rm_index_diff >= 0, \"sanity\");\n+      rm_word(i) &= ~rm.rm_word(i + rm_index_diff);\n@@ -354,0 +810,16 @@\n+    trim_watermarks();\n+    assert(valid_watermarks(), \"sanity\");\n+  }\n+\n+  \/\/ Roll over the register mask. The main use is to expose a new set of stack\n+  \/\/ slots for the register allocator. Return if the rollover succeeded or not.\n+  bool rollover() {\n+    assert(is_infinite_stack(), \"rolling over non-empty mask\");\n+    if (!OptoRegPair::can_fit((_rm_size_in_words + _offset + _rm_size_in_words) * BitsPerWord - 1)) {\n+      \/\/ Ensure that register masks cannot roll over beyond the point at which\n+      \/\/ OptoRegPair can no longer index the whole mask.\n+      return false;\n+    }\n+    _offset += _rm_size_in_words;\n+    Set_All_From_Offset();\n+    return true;\n@@ -357,1 +829,8 @@\n-  uint Size() const;\n+  uint Size() const {\n+    uint sum = 0;\n+    assert(valid_watermarks(), \"sanity\");\n+    for (unsigned i = _lwm; i <= _hwm; i++) {\n+      sum += population_count(rm_word(i));\n+    }\n+    return sum;\n+  }\n@@ -360,0 +839,54 @@\n+private:\n+  bool dump_end_run(outputStream* st, OptoReg::Name start,\n+                    OptoReg::Name last) const;\n+\n+public:\n+\n+  \/\/ ----------------------------------------------------------------------\n+  \/\/ The methods below are only for testing purposes (see test_regmask.cpp)\n+  \/\/ ----------------------------------------------------------------------\n+\n+  unsigned int static gtest_basic_rm_size_in_words() {\n+    return RM_SIZE_IN_WORDS;\n+  }\n+\n+  unsigned int static gtest_rm_size_in_bits_max() {\n+    return RM_SIZE_IN_WORDS_MAX * BitsPerWord;\n+  }\n+\n+  bool gtest_equals(const RegMask& rm) const {\n+    assert(_offset == rm._offset, \"offset mismatch\");\n+    if (_infinite_stack != rm._infinite_stack) {\n+      return false;\n+    }\n+    \/\/ Shared segment\n+    for (unsigned int i = 0; i < MIN2(_rm_size_in_words, rm._rm_size_in_words); i++) {\n+      if (rm_word(i) != rm.rm_word(i)) {\n+        return false;\n+      }\n+    }\n+    \/\/ If there is a size difference, check the protruding segment against\n+    \/\/ infinite_stack.\n+    const unsigned int start = MIN2(_rm_size_in_words, rm._rm_size_in_words);\n+    const uintptr_t value = _infinite_stack ? uintptr_t(-1) : 0;\n+    for (unsigned int i = start; i < _rm_size_in_words; i++) {\n+      if (rm_word(i) != value) {\n+        return false;\n+      }\n+    }\n+    for (unsigned int i = start; i < rm._rm_size_in_words; i++) {\n+      if (rm.rm_word(i) != value) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  void gtest_set_offset(unsigned int offset) {\n+    _offset = offset;\n+  }\n+\n+  \/\/ ----------------------\n+  \/\/ End of testing methods\n+  \/\/ ----------------------\n+\n@@ -362,0 +895,1 @@\n+  void dump_hex(outputStream* st = tty) const; \/\/ Print a mask (raw hex)\n@@ -367,9 +901,3 @@\n-  static bool can_represent(OptoReg::Name reg, unsigned int size = 1) {\n-    \/\/ NOTE: MAX2(1U,size) in computation reflects the usage of the last\n-    \/\/       bit of the regmask as an infinite stack flag.\n-    return (int)reg < (int)(CHUNK_SIZE - MAX2(1U,size));\n-  }\n-  static bool can_represent_arg(OptoReg::Name reg) {\n-    \/\/ NOTE: SlotsPerVecZ in computation reflects the need\n-    \/\/       to keep mask aligned for largest value (VecZ).\n-    return can_represent(reg, SlotsPerVecZ);\n+  bool can_represent(OptoReg::Name reg, unsigned int size = 1) const {\n+    reg = reg - offset_bits();\n+    return reg >= 0 && reg <= (int)(rm_size_in_bits() - size);\n@@ -422,1 +950,1 @@\n-      _current_bits = _rm._rm_word[_next_index++];\n+      _current_bits = _rm.rm_word(_next_index++);\n@@ -430,1 +958,3 @@\n-        _reg = OptoReg::Name(((_next_index - 1) << LogBitsPerWord) + next_bit);\n+        _reg = OptoReg::Name(_rm.offset_bits() +\n+                             ((_next_index - 1) << LogBitsPerWord) +\n+                             next_bit);\n@@ -441,1 +971,1 @@\n-\/\/ Do not use this constant directly in client code!\n+\/\/ Do not use these constants directly in client code!\n@@ -443,0 +973,1 @@\n+#undef RM_SIZE_IN_INTS_MIN\n","filename":"src\/hotspot\/share\/opto\/regmask.hpp","additions":643,"deletions":112,"binary":false,"changes":755,"status":"modified"},{"patch":"@@ -442,2 +442,2 @@\n-  long mask = (-1ULL >> (64 - vlen));\n-  long bit  = type->get_con() & mask;\n+  jlong mask = (-1ULL >> (64 - vlen));\n+  jlong bit = type->get_con() & mask;\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-#include \"gc\/z\/zBarrier.inline.hpp\"\n","filename":"src\/hotspot\/share\/precompiled\/precompiled.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1693,0 +1693,17 @@\n+bool JvmtiExport::has_frame_pops(JavaThread* thread) {\n+  if (!can_post_frame_pop()) {\n+    return false;\n+  }\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n+  if (state == nullptr) {\n+    return false;\n+  }\n+  JvmtiEnvThreadStateIterator it(state);\n+  for (JvmtiEnvThreadState* ets = it.first(); ets != nullptr; ets = it.next(ets)) {\n+    if (ets->has_frame_pops()) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -376,0 +376,1 @@\n+  static bool has_frame_pops(JavaThread* thread) NOT_JVMTI_RETURN_(false);\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -123,0 +123,1 @@\n+#include \"gc\/z\/zHeap.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-    dest->set_bad_metadata_deopt();\n+    dest->set_bad_monitor_deopt();\n","filename":"src\/hotspot\/share\/runtime\/basicLock.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-  volatile uintptr_t _metadata;\n+  ObjectMonitor* volatile _monitor;\n@@ -42,3 +42,3 @@\n-  uintptr_t get_metadata() const { return AtomicAccess::load(&_metadata); }\n-  void set_metadata(uintptr_t value) { AtomicAccess::store(&_metadata, value); }\n-  static int metadata_offset_in_bytes() { return (int)offset_of(BasicLock, _metadata); }\n+  ObjectMonitor* get_monitor() const { return AtomicAccess::load(&_monitor); }\n+  void set_monitor(ObjectMonitor* mon) { AtomicAccess::store(&_monitor, mon); }\n+  static int monitor_offset_in_bytes() { return (int)offset_of(BasicLock, _monitor); }\n@@ -47,1 +47,1 @@\n-  BasicLock() : _metadata(0) {}\n+  BasicLock() : _monitor(nullptr) {}\n@@ -49,3 +49,1 @@\n-  void set_bad_metadata_deopt() { set_metadata(badDispHeaderDeopt); }\n-\n-  static int displaced_header_offset_in_bytes() { return metadata_offset_in_bytes(); }\n+  void set_bad_monitor_deopt() { set_monitor(reinterpret_cast<ObjectMonitor*>(badDispHeaderDeopt)); }\n@@ -56,1 +54,1 @@\n-  static int object_monitor_cache_offset_in_bytes() { return metadata_offset_in_bytes(); }\n+  static int object_monitor_cache_offset_in_bytes() { return monitor_offset_in_bytes(); }\n","filename":"src\/hotspot\/share\/runtime\/basicLock.hpp","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-  return reinterpret_cast<ObjectMonitor*>(get_metadata());\n+  return reinterpret_cast<ObjectMonitor*>(get_monitor());\n@@ -39,1 +39,1 @@\n-  \/\/ that the metadata either is nullptr or ObjectMonitor*.\n+  \/\/ that the monitor either is nullptr or a valid ObjectMonitor*.\n@@ -46,1 +46,1 @@\n-  set_metadata(0);\n+  set_monitor(nullptr);\n@@ -51,1 +51,1 @@\n-  set_metadata(reinterpret_cast<uintptr_t>(mon));\n+  set_monitor(mon);\n","filename":"src\/hotspot\/share\/runtime\/basicLock.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1622,4 +1622,3 @@\n-  if (thread->is_interp_only_mode()) {\n-    JvmtiThreadState *state = thread->jvmti_thread_state();\n-    if (state != nullptr)\n-      state->invalidate_cur_stack_depth();\n+  JvmtiThreadState *state = thread->jvmti_thread_state();\n+  if (state != nullptr) {\n+    state->invalidate_cur_stack_depth();\n@@ -1630,1 +1629,1 @@\n-  if (JvmtiExport::can_post_frame_pop()) {\n+  if (JvmtiExport::has_frame_pops(thread)) {\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1659,1 +1659,1 @@\n-                mon_info->lock()->set_bad_metadata_deopt();\n+                mon_info->lock()->set_bad_monitor_deopt();\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -358,1 +358,1 @@\n-#if defined(X86) && !defined(AMD64)\n+#if (defined(X86) && !defined(AMD64)) || defined(S390)\n@@ -360,2 +360,0 @@\n-#elif defined(S390)\n-  minimum_alignment = 2;\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsCompiler.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -453,1 +453,1 @@\n-    AOTMetaspace::preload_and_dump(thread);\n+    AOTMetaspace::dump_static_archive(thread);\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -538,1 +538,0 @@\n-  static bool   numa_has_group_homing();\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2529,2 +2529,1 @@\n-static void post_adapter_creation(const AdapterBlob* new_adapter,\n-                                  const AdapterHandlerEntry* entry) {\n+static void post_adapter_creation(const AdapterHandlerEntry* entry) {\n@@ -2532,0 +2531,1 @@\n+    AdapterBlob* adapter_blob = entry->adapter_blob();\n@@ -2536,1 +2536,1 @@\n-                 new_adapter->name(),\n+                 adapter_blob->name(),\n@@ -2539,1 +2539,1 @@\n-      Forte::register_stub(blob_id, new_adapter->content_begin(), new_adapter->content_end());\n+      Forte::register_stub(blob_id, adapter_blob->content_begin(), adapter_blob->content_end());\n@@ -2543,1 +2543,1 @@\n-      JvmtiExport::post_dynamic_code_generated(blob_id, new_adapter->content_begin(), new_adapter->content_end());\n+      JvmtiExport::post_dynamic_code_generated(blob_id, adapter_blob->content_begin(), adapter_blob->content_end());\n@@ -2565,5 +2565,0 @@\n-  AdapterBlob* no_arg_blob = nullptr;\n-  AdapterBlob* int_arg_blob = nullptr;\n-  AdapterBlob* obj_arg_blob = nullptr;\n-  AdapterBlob* obj_int_arg_blob = nullptr;\n-  AdapterBlob* obj_obj_arg_blob = nullptr;\n@@ -2573,1 +2568,1 @@\n-    _no_arg_handler = create_adapter(no_arg_blob, 0, nullptr);\n+    _no_arg_handler = create_adapter(0, nullptr);\n@@ -2576,1 +2571,1 @@\n-    _obj_arg_handler = create_adapter(obj_arg_blob, 1, obj_args);\n+    _obj_arg_handler = create_adapter(1, obj_args);\n@@ -2579,1 +2574,1 @@\n-    _int_arg_handler = create_adapter(int_arg_blob, 1, int_args);\n+    _int_arg_handler = create_adapter(1, int_args);\n@@ -2582,1 +2577,1 @@\n-    _obj_int_arg_handler = create_adapter(obj_int_arg_blob, 2, obj_int_args);\n+    _obj_int_arg_handler = create_adapter(2, obj_int_args);\n@@ -2585,1 +2580,1 @@\n-    _obj_obj_arg_handler = create_adapter(obj_obj_arg_blob, 2, obj_obj_args);\n+    _obj_obj_arg_handler = create_adapter(2, obj_obj_args);\n@@ -2599,5 +2594,5 @@\n-  post_adapter_creation(no_arg_blob, _no_arg_handler);\n-  post_adapter_creation(obj_arg_blob, _obj_arg_handler);\n-  post_adapter_creation(int_arg_blob, _int_arg_handler);\n-  post_adapter_creation(obj_int_arg_blob, _obj_int_arg_handler);\n-  post_adapter_creation(obj_obj_arg_blob, _obj_obj_arg_handler);\n+  post_adapter_creation(_no_arg_handler);\n+  post_adapter_creation(_obj_arg_handler);\n+  post_adapter_creation(_int_arg_handler);\n+  post_adapter_creation(_obj_int_arg_handler);\n+  post_adapter_creation(_obj_obj_arg_handler);\n@@ -2698,3 +2693,2 @@\n-  AdapterBlob* comparison_blob = nullptr;\n-  AdapterHandlerEntry* comparison_entry = create_adapter(comparison_blob, total_args_passed, sig_bt, true);\n-  assert(comparison_blob == nullptr, \"no blob should be created when creating an adapter for comparison\");\n+  AdapterHandlerEntry* comparison_entry = create_adapter(total_args_passed, sig_bt, true);\n+  assert(comparison_entry->adapter_blob() == nullptr, \"no blob should be created when creating an adapter for comparison\");\n@@ -2722,1 +2716,1 @@\n-  AdapterBlob* adapter_blob = nullptr;\n+  bool new_entry = false;\n@@ -2738,0 +2732,1 @@\n+#ifndef ZERO\n@@ -2739,0 +2734,1 @@\n+#endif\n@@ -2745,1 +2741,4 @@\n-      entry = create_adapter(adapter_blob, total_args_passed, sig_bt);\n+      entry = create_adapter(total_args_passed, sig_bt);\n+      if (entry != nullptr) {\n+        new_entry = true;\n+      }\n@@ -2750,2 +2749,2 @@\n-  if (adapter_blob != nullptr) {\n-    post_adapter_creation(adapter_blob, entry);\n+  if (new_entry) {\n+    post_adapter_creation(entry);\n@@ -2756,1 +2755,1 @@\n-AdapterBlob* AdapterHandlerLibrary::lookup_aot_cache(AdapterHandlerEntry* handler) {\n+void AdapterHandlerLibrary::lookup_aot_cache(AdapterHandlerEntry* handler) {\n@@ -2760,1 +2759,0 @@\n-  int offsets[AdapterBlob::ENTRY_COUNT];\n@@ -2762,1 +2760,0 @@\n-  AdapterBlob* adapter_blob = nullptr;\n@@ -2765,10 +2762,1 @@\n-    adapter_blob = blob->as_adapter_blob();\n-    adapter_blob->get_offsets(offsets);\n-    address i2c_entry = adapter_blob->content_begin();\n-    assert(offsets[0] == 0, \"sanity check\");\n-    handler->set_entry_points(\n-      i2c_entry,\n-      (offsets[1] != -1) ? (i2c_entry + offsets[1]) : nullptr,\n-      (offsets[2] != -1) ? (i2c_entry + offsets[2]) : nullptr,\n-      (offsets[3] != -1) ? (i2c_entry + offsets[3]) : nullptr\n-    );\n+    handler->set_adapter_blob(blob->as_adapter_blob());\n@@ -2776,1 +2764,0 @@\n-  return adapter_blob;\n@@ -2780,1 +2767,1 @@\n-void AdapterHandlerLibrary::print_adapter_handler_info(outputStream* st, AdapterHandlerEntry* handler, AdapterBlob* adapter_blob) {\n+void AdapterHandlerLibrary::print_adapter_handler_info(outputStream* st, AdapterHandlerEntry* handler) {\n@@ -2786,0 +2773,1 @@\n+  AdapterBlob* adapter_blob = handler->adapter_blob();\n@@ -2795,1 +2783,1 @@\n-    address first_pc = handler->base_address();\n+    address first_pc = adapter_blob->content_begin();\n@@ -2804,2 +2792,13 @@\n-bool AdapterHandlerLibrary::generate_adapter_code(AdapterBlob*& adapter_blob,\n-                                                  AdapterHandlerEntry* handler,\n+void AdapterHandlerLibrary::address_to_offset(address entry_address[AdapterBlob::ENTRY_COUNT],\n+                                              int entry_offset[AdapterBlob::ENTRY_COUNT]) {\n+  entry_offset[AdapterBlob::I2C] = 0;\n+  entry_offset[AdapterBlob::C2I] = entry_address[AdapterBlob::C2I] - entry_address[AdapterBlob::I2C];\n+  entry_offset[AdapterBlob::C2I_Unverified] = entry_address[AdapterBlob::C2I_Unverified] - entry_address[AdapterBlob::I2C];\n+  if (entry_address[AdapterBlob::C2I_No_Clinit_Check] == nullptr) {\n+    entry_offset[AdapterBlob::C2I_No_Clinit_Check] = -1;\n+  } else {\n+    entry_offset[AdapterBlob::C2I_No_Clinit_Check] = entry_address[AdapterBlob::C2I_No_Clinit_Check] - entry_address[AdapterBlob::I2C];\n+  }\n+}\n+\n+bool AdapterHandlerLibrary::generate_adapter_code(AdapterHandlerEntry* handler,\n@@ -2813,0 +2812,1 @@\n+#ifndef ZERO\n@@ -2824,0 +2824,1 @@\n+  address entry_address[AdapterBlob::ENTRY_COUNT];\n@@ -2829,2 +2830,1 @@\n-                                         handler);\n-#ifdef ZERO\n+                                         entry_address);\n@@ -2833,2 +2833,2 @@\n-  adapter_blob = nullptr;\n-#else\n+  int entry_offset[AdapterBlob::ENTRY_COUNT];\n+  address_to_offset(entry_address, entry_offset);\n@@ -2843,13 +2843,1 @@\n-\n-  int entry_offset[AdapterBlob::ENTRY_COUNT];\n-  assert(AdapterBlob::ENTRY_COUNT == 4, \"sanity\");\n-  address i2c_entry = handler->get_i2c_entry();\n-  entry_offset[0] = 0; \/\/ i2c_entry offset\n-  entry_offset[1] = (handler->get_c2i_entry() != nullptr) ?\n-                    (handler->get_c2i_entry() - i2c_entry) : -1;\n-  entry_offset[2] = (handler->get_c2i_unverified_entry() != nullptr) ?\n-                    (handler->get_c2i_unverified_entry() - i2c_entry) : -1;\n-  entry_offset[3] = (handler->get_c2i_no_clinit_check_entry() != nullptr) ?\n-                    (handler->get_c2i_no_clinit_check_entry() - i2c_entry) : -1;\n-\n-  adapter_blob = AdapterBlob::create(&buffer, entry_offset);\n+  AdapterBlob* adapter_blob = AdapterBlob::create(&buffer, entry_offset);\n@@ -2862,0 +2850,1 @@\n+  handler->set_adapter_blob(adapter_blob);\n@@ -2869,1 +2858,0 @@\n-  handler->relocate(adapter_blob->content_begin());\n@@ -2875,1 +2863,1 @@\n-    print_adapter_handler_info(tty, handler, adapter_blob);\n+    print_adapter_handler_info(tty, handler);\n@@ -2882,2 +2870,1 @@\n-AdapterHandlerEntry* AdapterHandlerLibrary::create_adapter(AdapterBlob*& adapter_blob,\n-                                                           int total_args_passed,\n+AdapterHandlerEntry* AdapterHandlerLibrary::create_adapter(int total_args_passed,\n@@ -2888,1 +2875,1 @@\n-  if (!generate_adapter_code(adapter_blob, handler, total_args_passed, sig_bt, is_transient)) {\n+  if (!generate_adapter_code(handler, total_args_passed, sig_bt, is_transient)) {\n@@ -2905,1 +2892,2 @@\n-  set_entry_points(nullptr, nullptr, nullptr, nullptr, false);\n+   _adapter_blob = nullptr;\n+   _linked = false;\n@@ -2955,1 +2943,1 @@\n-AdapterBlob* AdapterHandlerLibrary::link_aot_adapter_handler(AdapterHandlerEntry* handler) {\n+void AdapterHandlerLibrary::link_aot_adapter_handler(AdapterHandlerEntry* handler) {\n@@ -2958,1 +2946,1 @@\n-    return nullptr;\n+    return;\n@@ -2961,1 +2949,1 @@\n-  AdapterBlob* blob = lookup_aot_cache(handler);\n+  lookup_aot_cache(handler);\n@@ -2964,2 +2952,2 @@\n-  if ((blob != nullptr) && (PrintAdapterHandlers || PrintStubCode)) {\n-    print_adapter_handler_info(tty, handler, blob);\n+  if (PrintAdapterHandlers || PrintStubCode) {\n+    print_adapter_handler_info(tty, handler);\n@@ -2968,1 +2956,0 @@\n-  return blob;\n@@ -2974,1 +2961,0 @@\n-  AdapterBlob* adapter_blob = nullptr;\n@@ -2982,2 +2968,3 @@\n-    adapter_blob = AdapterHandlerLibrary::link_aot_adapter_handler(this);\n-    if (adapter_blob == nullptr) {\n+    AdapterHandlerLibrary::link_aot_adapter_handler(this);\n+    \/\/ If link_aot_adapter_handler() succeeds, _adapter_blob will be non-null\n+    if (_adapter_blob == nullptr) {\n@@ -2993,1 +2980,1 @@\n-    if (!AdapterHandlerLibrary::generate_adapter_code(adapter_blob, this, nargs, bt, \/* is_transient *\/ false)) {\n+    if (!AdapterHandlerLibrary::generate_adapter_code(this, nargs, bt, \/* is_transient *\/ false)) {\n@@ -3000,3 +2987,2 @@\n-  \/\/ Outside of the lock\n-  if (adapter_blob != nullptr) {\n-    post_adapter_creation(adapter_blob, this);\n+  if (_adapter_blob != nullptr) {\n+    post_adapter_creation(this);\n@@ -3048,24 +3034,0 @@\n-address AdapterHandlerEntry::base_address() {\n-  address base = _i2c_entry;\n-  if (base == nullptr)  base = _c2i_entry;\n-  assert(base <= _c2i_entry || _c2i_entry == nullptr, \"\");\n-  assert(base <= _c2i_unverified_entry || _c2i_unverified_entry == nullptr, \"\");\n-  assert(base <= _c2i_no_clinit_check_entry || _c2i_no_clinit_check_entry == nullptr, \"\");\n-  return base;\n-}\n-\n-void AdapterHandlerEntry::relocate(address new_base) {\n-  address old_base = base_address();\n-  assert(old_base != nullptr, \"\");\n-  ptrdiff_t delta = new_base - old_base;\n-  if (_i2c_entry != nullptr)\n-    _i2c_entry += delta;\n-  if (_c2i_entry != nullptr)\n-    _c2i_entry += delta;\n-  if (_c2i_unverified_entry != nullptr)\n-    _c2i_unverified_entry += delta;\n-  if (_c2i_no_clinit_check_entry != nullptr)\n-    _c2i_no_clinit_check_entry += delta;\n-  assert(base_address() == new_base, \"\");\n-}\n-\n@@ -3446,1 +3408,1 @@\n-  if (get_i2c_entry() != nullptr) {\n+  if (adapter_blob() != nullptr) {\n@@ -3448,2 +3410,0 @@\n-  }\n-  if (get_c2i_entry() != nullptr) {\n@@ -3451,2 +3411,0 @@\n-  }\n-  if (get_c2i_unverified_entry() != nullptr) {\n@@ -3454,3 +3412,3 @@\n-  }\n-  if (get_c2i_no_clinit_check_entry() != nullptr) {\n-    st->print(\" c2iNCI: \" INTPTR_FORMAT, p2i(get_c2i_no_clinit_check_entry()));\n+    if (get_c2i_no_clinit_check_entry() != nullptr) {\n+      st->print(\" c2iNCI: \" INTPTR_FORMAT, p2i(get_c2i_no_clinit_check_entry()));\n+    }\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":71,"deletions":113,"binary":false,"changes":184,"status":"modified"},{"patch":"@@ -479,5 +479,5 @@\n-                               int total_args_passed,\n-                               int max_arg,\n-                               const BasicType *sig_bt,\n-                               const VMRegPair *regs,\n-                               AdapterHandlerEntry* handler);\n+                                      int total_args_passed,\n+                                      int max_arg,\n+                                      const BasicType *sig_bt,\n+                                      const VMRegPair *regs,\n+                                      address entry_address[AdapterBlob::ENTRY_COUNT]);\n@@ -688,5 +688,2 @@\n-  address _i2c_entry;\n-  address _c2i_entry;\n-  address _c2i_unverified_entry;\n-  address _c2i_no_clinit_check_entry;\n-  bool    _linked;\n+  AdapterBlob* _adapter_blob;\n+  bool _linked;\n@@ -705,4 +702,1 @@\n-    _i2c_entry(nullptr),\n-    _c2i_entry(nullptr),\n-    _c2i_unverified_entry(nullptr),\n-    _c2i_no_clinit_check_entry(nullptr),\n+    _adapter_blob(nullptr),\n@@ -737,6 +731,3 @@\n-  void set_entry_points(address i2c_entry, address c2i_entry, address c2i_unverified_entry, address c2i_no_clinit_check_entry, bool linked = true) {\n-    _i2c_entry = i2c_entry;\n-    _c2i_entry = c2i_entry;\n-    _c2i_unverified_entry = c2i_unverified_entry;\n-    _c2i_no_clinit_check_entry = c2i_no_clinit_check_entry;\n-    _linked = linked;\n+  void set_adapter_blob(AdapterBlob* blob) {\n+    _adapter_blob = blob;\n+    _linked = true;\n@@ -745,4 +736,26 @@\n-  address get_i2c_entry()                  const { return _i2c_entry; }\n-  address get_c2i_entry()                  const { return _c2i_entry; }\n-  address get_c2i_unverified_entry()       const { return _c2i_unverified_entry; }\n-  address get_c2i_no_clinit_check_entry()  const { return _c2i_no_clinit_check_entry; }\n+  address get_i2c_entry() const {\n+#ifndef ZERO\n+    assert(_adapter_blob != nullptr, \"must be\");\n+    return _adapter_blob->i2c_entry();\n+#else\n+    return nullptr;\n+#endif \/\/ ZERO\n+  }\n+\n+  address get_c2i_entry() const {\n+#ifndef ZERO\n+    assert(_adapter_blob != nullptr, \"must be\");\n+    return _adapter_blob->c2i_entry();\n+#else\n+    return nullptr;\n+#endif \/\/ ZERO\n+  }\n+\n+  address get_c2i_unverified_entry() const {\n+#ifndef ZERO\n+    assert(_adapter_blob != nullptr, \"must be\");\n+    return _adapter_blob->c2i_unverified_entry();\n+#else\n+    return nullptr;\n+#endif \/\/ ZERO\n+  }\n@@ -750,3 +763,7 @@\n-  static const char* entry_name(int i) {\n-    assert(i >=0 && i < ENTRIES_COUNT, \"entry id out of range\");\n-    return _entry_names[i];\n+  address get_c2i_no_clinit_check_entry()  const {\n+#ifndef ZERO\n+    assert(_adapter_blob != nullptr, \"must be\");\n+    return _adapter_blob->c2i_no_clinit_check_entry();\n+#else\n+    return nullptr;\n+#endif \/\/ ZERO\n@@ -755,0 +772,1 @@\n+  AdapterBlob* adapter_blob() const { return _adapter_blob; }\n@@ -756,2 +774,0 @@\n-  address base_address();\n-  void relocate(address new_base);\n@@ -798,3 +814,2 @@\n-  static AdapterBlob* lookup_aot_cache(AdapterHandlerEntry* handler);\n-  static AdapterHandlerEntry* create_adapter(AdapterBlob*& new_adapter,\n-                                             int total_args_passed,\n+  static void lookup_aot_cache(AdapterHandlerEntry* handler);\n+  static AdapterHandlerEntry* create_adapter(int total_args_passed,\n@@ -805,1 +820,1 @@\n-  static void print_adapter_handler_info(outputStream* st, AdapterHandlerEntry* handler, AdapterBlob* adapter_blob);\n+  static void print_adapter_handler_info(outputStream* st, AdapterHandlerEntry* handler);\n@@ -813,2 +828,1 @@\n-  static bool generate_adapter_code(AdapterBlob*& adapter_blob,\n-                                    AdapterHandlerEntry* handler,\n+  static bool generate_adapter_code(AdapterHandlerEntry* handler,\n@@ -832,1 +846,1 @@\n-  static AdapterBlob* link_aot_adapter_handler(AdapterHandlerEntry* handler) NOT_CDS_RETURN_(nullptr);\n+  static void link_aot_adapter_handler(AdapterHandlerEntry* handler) NOT_CDS_RETURN;\n@@ -836,0 +850,1 @@\n+  static void address_to_offset(address entry_address[AdapterBlob::ENTRY_COUNT], int entry_offset[AdapterBlob::ENTRY_COUNT]);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":51,"deletions":36,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -33,3 +33,0 @@\n-#if INCLUDE_ZGC\n-#include \"gc\/z\/zBarrier.inline.hpp\"\n-#endif\n","filename":"src\/hotspot\/share\/runtime\/stackValue.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-    LightweightSynchronizer::enter(obj, lock, current);\n+  LightweightSynchronizer::enter(obj, lock, current);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-  set_lgrp_id(-1);\n+  _lgrp_id = -1;\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -540,2 +540,2 @@\n-  int     lgrp_id() const        { return _lgrp_id; }\n-  void    set_lgrp_id(int value) { _lgrp_id = value; }\n+  int     lgrp_id() const  { return _lgrp_id; }\n+  void    update_lgrp_id() { _lgrp_id = os::numa_get_group_id(); }\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -780,1 +780,1 @@\n-    AOTLinkedClassBulkLoader::finish_loading_javabase_classes(CHECK_JNI_ERR);\n+    AOTLinkedClassBulkLoader::link_or_init_javabase_classes(THREAD);\n@@ -799,1 +799,1 @@\n-    AOTLinkedClassBulkLoader::load_non_javabase_classes(THREAD);\n+    AOTLinkedClassBulkLoader::link_or_init_non_javabase_classes(THREAD);\n@@ -897,1 +897,1 @@\n-    AOTMetaspace::preload_and_dump(CHECK_JNI_ERR);\n+    AOTMetaspace::dump_static_archive(CHECK_JNI_ERR);\n@@ -900,1 +900,1 @@\n-    AOTMetaspace::preload_and_dump(CHECK_JNI_ERR);\n+    AOTMetaspace::dump_static_archive(CHECK_JNI_ERR);\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -685,1 +685,0 @@\n-  volatile_nonstatic_field(BasicLock,          _metadata,                                     uintptr_t)                             \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/osThread.hpp\"\n","filename":"src\/hotspot\/share\/services\/cpuTimeUsage.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1164,0 +1164,2 @@\n+    \/\/ thread that owns park blocker object when park blocker is AbstractOwnableSynchronizer\n+    OopHandle _owner;\n@@ -1165,2 +1167,2 @@\n-    Blocker(Type type, OopHandle obj): _type(type), _obj(obj) {}\n-    Blocker(): _type(NOTHING), _obj(nullptr) {}\n+    Blocker(Type type, OopHandle obj): _type(type), _obj(obj), _owner() {}\n+    Blocker(): _type(NOTHING), _obj(), _owner() {}\n@@ -1201,0 +1203,1 @@\n+    _blocker._owner.release(oop_storage());\n@@ -1303,0 +1306,7 @@\n+      if (park_blocker->is_a(vmClasses::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass())) {\n+        \/\/ could be stale (unlikely in practice), but it's good enough to see deadlocks\n+        oop ownerObj = java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(park_blocker);\n+        if (ownerObj != nullptr) {\n+          _blocker._owner = OopHandle(oop_storage(), ownerObj);\n+        }\n+      }\n@@ -1384,0 +1394,1 @@\n+  static int _parkBlockerOwner_offset;\n@@ -1393,0 +1404,1 @@\n+    JavaClasses::compute_offset(_parkBlockerOwner_offset, klass, \"parkBlockerOwner\", vmSymbols::thread_signature(), false);\n@@ -1423,1 +1435,1 @@\n-  static void set_blocker(oop snapshot, int type_ordinal, oop lock) {\n+  static void set_blocker(oop snapshot, int type_ordinal, oop lock, oop owner) {\n@@ -1426,0 +1438,1 @@\n+    snapshot->obj_field_put(_parkBlockerOwner_offset, owner);\n@@ -1437,0 +1450,1 @@\n+int jdk_internal_vm_ThreadSnapshot::_parkBlockerOwner_offset;\n@@ -1562,1 +1576,2 @@\n-    jdk_internal_vm_ThreadSnapshot::set_blocker(snapshot(), cl._blocker._type, cl._blocker._obj.resolve());\n+    jdk_internal_vm_ThreadSnapshot::set_blocker(snapshot(),\n+        cl._blocker._type, cl._blocker._obj.resolve(), cl._blocker._owner.resolve());\n","filename":"src\/hotspot\/share\/services\/threadService.cpp","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -539,0 +539,1 @@\n+const int max_method_parameter_length = 255; \/\/ JVM spec, 22nd ed. section 4.3.3 (p.83)\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"runtime\/os.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/stringUtils.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/utilities\/stringUtils.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import java.lang.runtime.ExactConversionsSupport;\n+\n@@ -367,1 +369,1 @@\n-        int utflen = utfLen(str, countNonZeroAscii);\n+        long utflenLong = utfLen(str, countNonZeroAscii);\n@@ -369,2 +371,2 @@\n-        if (utflen > 65535 || \/* overflow *\/ utflen < strlen)\n-            throw new UTFDataFormatException(tooLongMsg(str, utflen));\n+        if (!ExactConversionsSupport.isLongToCharExact(utflenLong))\n+            throw new UTFDataFormatException(tooLongMsg(str, utflenLong));\n@@ -372,0 +374,1 @@\n+        int utflen = (int)utflenLong;\n@@ -394,1 +397,1 @@\n-    private static String tooLongMsg(String s, int bits32) {\n+    private static String tooLongMsg(String s, long utflen) {\n@@ -398,2 +401,0 @@\n-        \/\/ handle int overflow with max 3x expansion\n-        long actualLength = (long)slen + Integer.toUnsignedLong(bits32 - slen);\n@@ -401,1 +402,1 @@\n-            + actualLength + \" bytes\";\n+            + utflen + \" bytes\";\n","filename":"src\/java.base\/share\/classes\/java\/io\/DataOutputStream.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.lang.runtime.ExactConversionsSupport;\n+\n@@ -1902,2 +1904,2 @@\n-            int utflen = utfLen(str, countNonZeroAscii);\n-            if (utflen <= 0xFFFF) {\n+            long utflen = utfLen(str, countNonZeroAscii);\n+            if (ExactConversionsSupport.isLongToCharExact(utflen)) {\n@@ -1907,1 +1909,1 @@\n-                writeShort(utflen);\n+                writeShort((short)utflen);\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectOutputStream.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+import jdk.internal.misc.CDS;\n@@ -68,0 +69,2 @@\n+import jdk.internal.vm.annotation.AOTRuntimeSetup;\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -224,0 +227,1 @@\n+@AOTSafeClassInitializer\n@@ -228,0 +232,5 @@\n+        runtimeSetup();\n+    }\n+\n+    @AOTRuntimeSetup\n+    private static void runtimeSetup() {\n@@ -1861,2 +1870,2 @@\n-                assert VM.isBooted() && scl != null;\n-                return scl;\n+                assert VM.isBooted() && Holder.scl != null;\n+                return Holder.scl;\n@@ -1887,1 +1896,1 @@\n-        if (scl != null) {\n+        if (Holder.scl != null) {\n@@ -1898,1 +1907,1 @@\n-                scl = (ClassLoader) ctor.newInstance(builtinLoader);\n+                Holder.scl = (ClassLoader) ctor.newInstance(builtinLoader);\n@@ -1913,1 +1922,1 @@\n-            scl = builtinLoader;\n+            Holder.scl = builtinLoader;\n@@ -1915,1 +1924,1 @@\n-        return scl;\n+        return Holder.scl;\n@@ -1928,3 +1937,7 @@\n-    \/\/ The system class loader\n-    \/\/ @GuardedBy(\"ClassLoader.class\")\n-    private static volatile ClassLoader scl;\n+    \/\/ Holder has the field(s) that need to be initialized during JVM bootstrap even if\n+    \/\/ the outer is aot-initialized.\n+    private static class Holder {\n+        \/\/ The system class loader\n+        \/\/ @GuardedBy(\"ClassLoader.class\")\n+        private static volatile ClassLoader scl;\n+    }\n@@ -2605,1 +2618,15 @@\n-        reinitObjectField(\"packages\", new ConcurrentHashMap<>());\n+\n+        if (CDS.isDumpingAOTLinkedClasses()) {\n+            if (System.getProperty(\"cds.debug.archived.packages\") != null) {\n+                for (Map.Entry<String, NamedPackage> entry : packages.entrySet()) {\n+                    String key = entry.getKey();\n+                    NamedPackage value = entry.getValue();\n+                    System.out.println(\"Archiving \" +\n+                                       (value instanceof Package ? \"Package\" : \"NamedPackage\") +\n+                                       \" \\\"\" + key + \"\\\" for \" + this);\n+                }\n+            }\n+        } else {\n+            reinitObjectField(\"packages\", new ConcurrentHashMap<>());\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassLoader.java","additions":37,"deletions":10,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -3713,1 +3713,1 @@\n-        byte[] value = StringConcatHelper.newArray(len);\n+        byte[] value = StringConcatHelper.newArray((int) len);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -144,256 +144,0 @@\n-    \/**\n-     * Return the coder for the character.\n-     * @param value character\n-     * @return      coder\n-     *\/\n-    static long coder(char value) {\n-        return StringLatin1.canEncode(value) ? LATIN1 : UTF16;\n-    }\n-\n-    \/**\n-     * Check for overflow, throw exception on overflow.\n-     *\n-     * @param lengthCoder String length with coder packed into higher bits\n-     *                    the upper word.\n-     * @return            the given parameter value, if valid\n-     *\/\n-    private static long checkOverflow(long lengthCoder) {\n-        if ((int)lengthCoder >= 0) {\n-            return lengthCoder;\n-        }\n-        throw new OutOfMemoryError(\"Overflow: String length out of range\");\n-    }\n-\n-    \/**\n-     * Mix value length and coder into current length and coder.\n-     * @param lengthCoder String length with coder packed into higher bits\n-     *                    the upper word.\n-     * @param value       value to mix in\n-     * @return            new length and coder\n-     *\/\n-    static long mix(long lengthCoder, boolean value) {\n-        return checkOverflow(lengthCoder + (value ? 4 : 5));\n-    }\n-\n-    \/**\n-     * Mix value length and coder into current length and coder.\n-     * @param lengthCoder String length with coder packed into higher bits\n-     *                    the upper word.\n-     * @param value       value to mix in\n-     * @return            new length and coder\n-     *\/\n-    static long mix(long lengthCoder, char value) {\n-        return checkOverflow(lengthCoder + 1) | coder(value);\n-    }\n-\n-    \/**\n-     * Mix value length and coder into current length and coder.\n-     * @param lengthCoder String length with coder packed into higher bits\n-     *                    the upper word.\n-     * @param value       value to mix in\n-     * @return            new length and coder\n-     *\/\n-    static long mix(long lengthCoder, int value) {\n-        return checkOverflow(lengthCoder + DecimalDigits.stringSize(value));\n-    }\n-\n-    \/**\n-     * Mix value length and coder into current length and coder.\n-     * @param lengthCoder String length with coder packed into higher bits\n-     *                    the upper word.\n-     * @param value       value to mix in\n-     * @return            new length and coder\n-     *\/\n-    static long mix(long lengthCoder, long value) {\n-        return checkOverflow(lengthCoder + DecimalDigits.stringSize(value));\n-    }\n-\n-    \/**\n-     * Mix value length and coder into current length and coder.\n-     * @param lengthCoder String length with coder packed into higher bits\n-     *                    the upper word.\n-     * @param value       value to mix in\n-     * @return            new length and coder\n-     *\/\n-    static long mix(long lengthCoder, String value) {\n-        lengthCoder += value.length();\n-        if (!value.isLatin1()) {\n-            lengthCoder |= UTF16;\n-        }\n-        return checkOverflow(lengthCoder);\n-    }\n-\n-    \/**\n-     * Prepends constant and the stringly representation of value into buffer,\n-     * given the coder and final index. Index is measured in chars, not in bytes!\n-     *\n-     * @param indexCoder final char index in the buffer, along with coder packed\n-     *                   into higher bits.\n-     * @param buf        buffer to append to\n-     * @param value      boolean value to encode\n-     * @param prefix     a constant to prepend before value\n-     * @return           updated index (coder value retained)\n-     *\/\n-    static long prepend(long indexCoder, byte[] buf, boolean value, String prefix) {\n-        int index = (int)indexCoder;\n-        if (indexCoder < UTF16) {\n-            if (value) {\n-                index -= 4;\n-                buf[index] = 't';\n-                buf[index + 1] = 'r';\n-                buf[index + 2] = 'u';\n-                buf[index + 3] = 'e';\n-            } else {\n-                index -= 5;\n-                buf[index] = 'f';\n-                buf[index + 1] = 'a';\n-                buf[index + 2] = 'l';\n-                buf[index + 3] = 's';\n-                buf[index + 4] = 'e';\n-            }\n-            index -= prefix.length();\n-            prefix.getBytes(buf, index, String.LATIN1);\n-            return index;\n-        } else {\n-            if (value) {\n-                index -= 4;\n-                StringUTF16.putChar(buf, index, 't');\n-                StringUTF16.putChar(buf, index + 1, 'r');\n-                StringUTF16.putChar(buf, index + 2, 'u');\n-                StringUTF16.putChar(buf, index + 3, 'e');\n-            } else {\n-                index -= 5;\n-                StringUTF16.putChar(buf, index, 'f');\n-                StringUTF16.putChar(buf, index + 1, 'a');\n-                StringUTF16.putChar(buf, index + 2, 'l');\n-                StringUTF16.putChar(buf, index + 3, 's');\n-                StringUTF16.putChar(buf, index + 4, 'e');\n-            }\n-            index -= prefix.length();\n-            prefix.getBytes(buf, index, String.UTF16);\n-            return index | UTF16;\n-        }\n-    }\n-\n-    \/**\n-     * Prepends constant and the stringly representation of value into buffer,\n-     * given the coder and final index. Index is measured in chars, not in bytes!\n-     *\n-     * @param indexCoder final char index in the buffer, along with coder packed\n-     *                   into higher bits.\n-     * @param buf        buffer to append to\n-     * @param value      char value to encode\n-     * @param prefix     a constant to prepend before value\n-     * @return           updated index (coder value retained)\n-     *\/\n-    static long prepend(long indexCoder, byte[] buf, char value, String prefix) {\n-        int index = (int)indexCoder;\n-        if (indexCoder < UTF16) {\n-            buf[--index] = (byte) (value & 0xFF);\n-            index -= prefix.length();\n-            prefix.getBytes(buf, index, String.LATIN1);\n-            return index;\n-        } else {\n-            StringUTF16.putChar(buf, --index, value);\n-            index -= prefix.length();\n-            prefix.getBytes(buf, index, String.UTF16);\n-            return index | UTF16;\n-        }\n-    }\n-\n-    \/**\n-     * Prepends constant and the stringly representation of value into buffer,\n-     * given the coder and final index. Index is measured in chars, not in bytes!\n-     *\n-     * @param indexCoder final char index in the buffer, along with coder packed\n-     *                   into higher bits.\n-     * @param buf        buffer to append to\n-     * @param value      int value to encode\n-     * @param prefix     a constant to prepend before value\n-     * @return           updated index (coder value retained)\n-     *\/\n-    static long prepend(long indexCoder, byte[] buf, int value, String prefix) {\n-        int index = (int)indexCoder;\n-        if (indexCoder < UTF16) {\n-            index = DecimalDigits.uncheckedGetCharsLatin1(value, index, buf);\n-            index -= prefix.length();\n-            prefix.getBytes(buf, index, String.LATIN1);\n-            return index;\n-        } else {\n-            index = DecimalDigits.uncheckedGetCharsUTF16(value, index, buf);\n-            index -= prefix.length();\n-            prefix.getBytes(buf, index, String.UTF16);\n-            return index | UTF16;\n-        }\n-    }\n-\n-    \/**\n-     * Prepends constant and the stringly representation of value into buffer,\n-     * given the coder and final index. Index is measured in chars, not in bytes!\n-     *\n-     * @param indexCoder final char index in the buffer, along with coder packed\n-     *                   into higher bits.\n-     * @param buf        buffer to append to\n-     * @param value      long value to encode\n-     * @param prefix     a constant to prepend before value\n-     * @return           updated index (coder value retained)\n-     *\/\n-    static long prepend(long indexCoder, byte[] buf, long value, String prefix) {\n-        int index = (int)indexCoder;\n-        if (indexCoder < UTF16) {\n-            index = DecimalDigits.uncheckedGetCharsLatin1(value, index, buf);\n-            index -= prefix.length();\n-            prefix.getBytes(buf, index, String.LATIN1);\n-            return index;\n-        } else {\n-            index = DecimalDigits.uncheckedGetCharsUTF16(value, index, buf);\n-            index -= prefix.length();\n-            prefix.getBytes(buf, index, String.UTF16);\n-            return index | UTF16;\n-        }\n-    }\n-\n-    \/**\n-     * Prepends constant and the stringly representation of value into buffer,\n-     * given the coder and final index. Index is measured in chars, not in bytes!\n-     *\n-     * @param indexCoder final char index in the buffer, along with coder packed\n-     *                   into higher bits.\n-     * @param buf        buffer to append to\n-     * @param value      boolean value to encode\n-     * @param prefix     a constant to prepend before value\n-     * @return           updated index (coder value retained)\n-     *\/\n-    static long prepend(long indexCoder, byte[] buf, String value, String prefix) {\n-        int index = ((int)indexCoder) - value.length();\n-        if (indexCoder < UTF16) {\n-            value.getBytes(buf, index, String.LATIN1);\n-            index -= prefix.length();\n-            prefix.getBytes(buf, index, String.LATIN1);\n-            return index;\n-        } else {\n-            value.getBytes(buf, index, String.UTF16);\n-            index -= prefix.length();\n-            prefix.getBytes(buf, index, String.UTF16);\n-            return index | UTF16;\n-        }\n-    }\n-\n-    \/**\n-     * Instantiates the String with given buffer and coder\n-     * @param buf           buffer to use\n-     * @param indexCoder    remaining index (should be zero) and coder\n-     * @return String       resulting string\n-     *\/\n-    static String newString(byte[] buf, long indexCoder) {\n-        \/\/ Use the private, non-copying constructor (unsafe!)\n-        if (indexCoder == LATIN1) {\n-            return new String(buf, String.LATIN1);\n-        } else if (indexCoder == UTF16) {\n-            return new String(buf, String.UTF16);\n-        } else {\n-            throw new InternalError(\"Storage is not completely initialized, \" +\n-                    (int)indexCoder + \" bytes left\");\n-        }\n-    }\n-\n@@ -469,4 +213,0 @@\n-    private static final long LATIN1 = (long)String.LATIN1 << 32;\n-\n-    private static final long UTF16 = (long)String.UTF16 << 32;\n-\n@@ -533,35 +273,0 @@\n-    \/**\n-     * Allocates an uninitialized byte array based on the length and coder\n-     * information, then prepends the given suffix string at the end of the\n-     * byte array before returning it. The calling code must adjust the\n-     * indexCoder so that it's taken the coder of the suffix into account, but\n-     * subtracted the length of the suffix.\n-     *\n-     * @param suffix\n-     * @param indexCoder\n-     * @return the newly allocated byte array\n-     *\/\n-    @ForceInline\n-    static byte[] newArrayWithSuffix(String suffix, long indexCoder) {\n-        byte[] buf = newArray(indexCoder + suffix.length());\n-        if (indexCoder < UTF16) {\n-            suffix.getBytes(buf, (int)indexCoder, String.LATIN1);\n-        } else {\n-            suffix.getBytes(buf, (int)indexCoder, String.UTF16);\n-        }\n-        return buf;\n-    }\n-\n-    \/**\n-     * Allocates an uninitialized byte array based on the length and coder information\n-     * in indexCoder\n-     * @param indexCoder\n-     * @return the newly allocated byte array\n-     *\/\n-    @ForceInline\n-    static byte[] newArray(long indexCoder) {\n-        byte coder = (byte)(indexCoder >> 32);\n-        int index = ((int)indexCoder) << coder;\n-        return newArray(index);\n-    }\n-\n@@ -581,8 +286,0 @@\n-    \/**\n-     * Provides the initial coder for the String.\n-     * @return initial coder, adjusted into the upper half\n-     *\/\n-    static long initialCoder() {\n-        return String.COMPACT_STRINGS ? LATIN1 : UTF16;\n-    }\n-\n@@ -606,1 +303,2 @@\n-     * @param indexCoder\n+     * @param index     final char index in the buffer\n+     * @param coder     coder of the buffer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringConcatHelper.java","additions":2,"deletions":304,"binary":false,"changes":306,"status":"modified"},{"patch":"@@ -2188,12 +2188,0 @@\n-            public long stringConcatInitialCoder() {\n-                return StringConcatHelper.initialCoder();\n-            }\n-\n-            public long stringConcatMix(long lengthCoder, String constant) {\n-                return StringConcatHelper.mix(lengthCoder, constant);\n-            }\n-\n-            public long stringConcatMix(long lengthCoder, char value) {\n-                return StringConcatHelper.mix(lengthCoder, value);\n-            }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1530,30 +1530,0 @@\n-    \/**\n-     * Throws {@code UnsupportedOperationException}.\n-     *\n-     * @throws  UnsupportedOperationException always\n-     *\n-     * @deprecated This method was originally specified to \"stop\" a victim\n-     *       thread by causing the victim thread to throw a {@link ThreadDeath}.\n-     *       It was inherently unsafe. Stopping a thread caused it to unlock\n-     *       all of the monitors that it had locked (as a natural consequence\n-     *       of the {@code ThreadDeath} exception propagating up the stack). If\n-     *       any of the objects previously protected by these monitors were in\n-     *       an inconsistent state, the damaged objects became visible to\n-     *       other threads, potentially resulting in arbitrary behavior.\n-     *       Usages of {@code stop} should be replaced by code that simply\n-     *       modifies some variable to indicate that the target thread should\n-     *       stop running.  The target thread should check this variable\n-     *       regularly, and return from its run method in an orderly fashion\n-     *       if the variable indicates that it is to stop running.  If the\n-     *       target thread waits for long periods (on a condition variable,\n-     *       for example), the {@code interrupt} method should be used to\n-     *       interrupt the wait.\n-     *       For more information, see\n-     *       <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/threadPrimitiveDeprecation.html\">Why\n-     *       is Thread.stop deprecated and the ability to stop a thread removed?<\/a>.\n-     *\/\n-    @Deprecated(since=\"1.2\", forRemoval=true)\n-    public final void stop() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * by a victim thread when \"stopped\" with {@link Thread#stop()}.\n+ * by a victim thread when \"stopped\" with the {@link Thread} API.\n@@ -32,6 +32,4 @@\n- * @deprecated {@link Thread#stop()} was originally specified to \"stop\" a victim\n- *      thread by causing the victim thread to throw a {@code ThreadDeath}. It\n- *      was inherently unsafe and deprecated in an early JDK release. The ability\n- *      to \"stop\" a thread with {@code Thread.stop} has been removed and the\n- *      {@code Thread.stop} method changed to throw an exception. Consequently,\n- *      {@code ThreadDeath} is also deprecated, for removal.\n+ * @deprecated {@code Thread} originally specified a \"{@code stop}\" method to stop a\n+ *      victim thread by causing the victim thread to throw a {@code ThreadDeath}. It\n+ *      was inherently unsafe and deprecated in an early JDK release. The {@code stop}\n+ *      method has since been removed and {@code ThreadDeath} is deprecated, for removal.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ThreadDeath.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -116,0 +116,1 @@\n+     * @throws IllegalArgumentException if any of {@code arguments} is void\n@@ -122,1 +123,1 @@\n-                                                      List.of(arguments));\n+                                                      SignaturesImpl.validateArgumentList(arguments));\n@@ -134,0 +135,1 @@\n+     * @throws IllegalArgumentException if any of {@code arguments} is void\n@@ -143,1 +145,1 @@\n-                List.of(arguments));\n+                SignaturesImpl.validateArgumentList(arguments));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/MethodSignature.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -46,0 +46,5 @@\n+ * <p>\n+ * Names in signatures are <dfn id=\"identifier\">identifiers<\/dfn>, which must\n+ * not be empty and must not contain any of the ASCII characters {@code\n+ * . ; [ \/ < > :}.  Top-level class and interface names are denoted by\n+ * slash-separated identifiers.\n@@ -76,0 +81,2 @@\n+     * @throws IllegalArgumentException if the field descriptor cannot be\n+     *         {@linkplain ##identifier denoted}\n@@ -142,0 +149,25 @@\n+     * <p>\n+     * These are examples of class type signatures:\n+     * <ul>\n+     * <li>{@code Lcom\/example\/Outer;} for {@code Outer}\n+     * <br>Has class name {@code com\/example\/Outer} and no outer type or type\n+     *     argument.\n+     * <li>{@code Lcom\/example\/Outer$Nested<TA;>;} for {@code Outer.Nested<A>}\n+     * <br>Has class name {@code com\/example\/Outer$Nested} representing a nested\n+     *     class, no outer type, and a single type argument of type variable\n+     *     {@code A}.\n+     * <li>{@code Lcom\/example\/GenericOuter<TA;>.Inner;} for {@code\n+     *     GenericOuter<A>.Inner}\n+     * <br>Has class name {@code Inner}, a simple class name, outer type\n+     *     {@code Lcom\/example\/GenericOuter<TA;>;} for {@code GenericOuter<A>},\n+     *     and no type argument.\n+     * <\/ul>\n+     * <p>\n+     * If the {@linkplain #outerType() outer type} exists, the {@linkplain\n+     * #className() class name} is the simple name of the nested type.\n+     * Otherwise, it is a {@linkplain ClassEntry##internalname binary name in\n+     * internal form} (separated by {@code \/}).\n+     * <p>\n+     * If a nested type does not have any enclosing parameterization, it may\n+     * be represented without an outer type and as an internal binary name,\n+     * in which nesting is represented by {@code $} instead of {@code .}.\n@@ -155,1 +187,2 @@\n-         * absent if it is not a parameterized type.\n+         * absent if this is a member class without any parameterized enclosing\n+         * type.\n@@ -164,1 +197,2 @@\n-         * outer type}\n+         * outer type}  Note this may indicate a nested class name with {@code $}\n+         * separators if there is no parameterized enclosing type.\n@@ -191,1 +225,2 @@\n-         *         represent a class or interface\n+         *         represent a class or interface, or if it cannot be\n+         *         {@linkplain Signature##identifier denoted}\n@@ -194,1 +229,1 @@\n-            return of(null, className, typeArgs);\n+            return of(null, Util.toInternalName(className), typeArgs);\n@@ -204,1 +239,7 @@\n-         *         represent a class or interface\n+         *         represent a class or interface, or if it cannot be\n+         *         {@linkplain Signature##identifier denoted}\n+         * @deprecated\n+         * The resulting signature does not denote the class represented by\n+         * {@code className} when {@code outerType} is not null.  Use {@link\n+         * #of(ClassTypeSig, String, TypeArg...) of(ClassTypeSig, String, TypeArg...)}\n+         * instead.\n@@ -206,0 +247,1 @@\n+        @Deprecated(since = \"26\", forRemoval = true)\n@@ -214,1 +256,2 @@\n-         * @param className the name of the class or interface\n+         * @param className the name of the class or interface, may use\n+         *                  {@code \/} to separate\n@@ -216,0 +259,2 @@\n+         * @throws IllegalArgumentException if {@code className} cannot be\n+         *         {@linkplain Signature##identifier denoted}\n@@ -225,1 +270,2 @@\n-         * @param className the name of this class or interface\n+         * @param className the name of this class or interface, may use\n+         *                  {@code \/} to separate if outer type is absent\n@@ -227,0 +273,2 @@\n+         * @throws IllegalArgumentException if {@code className} cannot be\n+         *         {@linkplain Signature##identifier denoted}\n@@ -229,2 +277,6 @@\n-            requireNonNull(className);\n-            return new SignaturesImpl.ClassTypeSigImpl(Optional.ofNullable(outerType), className.replace(\".\", \"\/\"), List.of(typeArgs));\n+            if (outerType != null) {\n+                SignaturesImpl.validateIdentifier(className);\n+            } else {\n+                SignaturesImpl.validatePackageSpecifierPlusIdentifier(className);\n+            }\n+            return new SignaturesImpl.ClassTypeSigImpl(Optional.ofNullable(outerType), className, List.of(typeArgs));\n@@ -386,0 +438,2 @@\n+         * @throws IllegalArgumentException if the name cannot be {@linkplain\n+         *         Signature##identifier denoted}\n@@ -388,1 +442,1 @@\n-            return new SignaturesImpl.TypeVarSigImpl(requireNonNull(identifier));\n+            return new SignaturesImpl.TypeVarSigImpl(SignaturesImpl.validateIdentifier(identifier));\n@@ -411,0 +465,1 @@\n+         * @throws IllegalArgumentException if the component type is void\n@@ -413,1 +468,1 @@\n-            return of(1, requireNonNull(componentSignature));\n+            return of(1, SignaturesImpl.validateNonVoid(componentSignature));\n@@ -421,1 +476,2 @@\n-         *         resulting array type exceeds 255 dimensions\n+         *         resulting array type exceeds 255 dimensions or the component\n+         *         type is void\n@@ -424,1 +480,1 @@\n-            requireNonNull(componentSignature);\n+            SignaturesImpl.validateNonVoid(componentSignature);\n@@ -472,0 +528,2 @@\n+         * @throws IllegalArgumentException if the name cannot be {@linkplain\n+         *         Signature##identifier denoted}\n@@ -475,1 +533,1 @@\n-                    requireNonNull(identifier),\n+                    SignaturesImpl.validateIdentifier(identifier),\n@@ -486,0 +544,2 @@\n+         * @throws IllegalArgumentException if the name cannot be {@linkplain\n+         *         Signature##identifier denoted}\n@@ -489,1 +549,1 @@\n-                    requireNonNull(identifier),\n+                    SignaturesImpl.validateIdentifier(identifier),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Signature.java","additions":75,"deletions":15,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -1,161 +0,0 @@\n-<!doctype html>\n-<!--\n- Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n- DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\n- This code is free software; you can redistribute it and\/or modify it\n- under the terms of the GNU General Public License version 2 only, as\n- published by the Free Software Foundation.  Oracle designates this\n- particular file as subject to the \"Classpath\" exception as provided\n- by Oracle in the LICENSE file that accompanied this code.\n-\n- This code is distributed in the hope that it will be useful, but WITHOUT\n- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- version 2 for more details (a copy is included in the LICENSE file that\n- accompanied this code).\n-\n- You should have received a copy of the GNU General Public License version\n- 2 along with this work; if not, write to the Free Software Foundation,\n- Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n- Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- or visit www.oracle.com if you need additional information or have any\n- questions.\n--->\n-<html lang=\"en\">\n-<head>\n-  <title>Java Thread Primitive Deprecation<\/title>\n-<\/head>\n-<body>\n-<h1>Java Thread Primitive Deprecation<\/h1>\n-<hr>\n-<h2>Why is <code>Thread.stop<\/code> deprecated and the ability to\n-stop a thread removed?<\/h2>\n-<p>Because it was inherently unsafe. Stopping a thread caused it to\n-unlock all the monitors that it had locked. (The monitors were\n-unlocked as the <code>ThreadDeath<\/code> exception propagated up\n-the stack.) If any of the objects previously protected by these\n-monitors were in an inconsistent state, other threads may have viewed\n-these objects in an inconsistent state. Such objects are said to be\n-<i>damaged<\/i>. When threads operate on damaged objects, arbitrary\n-behavior can result. This behavior may be subtle and difficult to\n-detect, or it may be pronounced. Unlike other unchecked exceptions,\n-<code>ThreadDeath<\/code> killed threads silently; thus, the user had\n-no warning that their program may be corrupted. The corruption could\n-manifest itself at any time after the actual damage occurs, even\n-hours or days in the future.<\/p>\n-<hr>\n-<h2>Couldn't I have just caught <code>ThreadDeath<\/code> and fixed\n-the damaged object?<\/h2>\n-<p>In theory, perhaps, but it would <em>vastly<\/em> complicate the\n-task of writing correct multithreaded code. The task would be\n-nearly insurmountable for two reasons:<\/p>\n-<ol>\n-<li>A thread could throw a <code>ThreadDeath<\/code> exception\n-<i>almost anywhere<\/i>. All synchronized methods and blocks would\n-have to be studied in great detail, with this in mind.<\/li>\n-<li>A thread could throw a second <code>ThreadDeath<\/code> exception\n-while cleaning up from the first (in the <code>catch<\/code> or\n-<code>finally<\/code> clause). Cleanup would have to be repeated till\n-it succeeded. The code to ensure this would be quite complex.<\/li>\n-<\/ol>\n-In sum, it just isn't practical.\n-<hr>\n-<h2>What should I use instead of <code>Thread.stop<\/code>?<\/h2>\n-<p>Most uses of <code>stop<\/code> should be replaced by code that\n-simply modifies some variable to indicate that the target thread\n-should stop running. The target thread should check this variable\n-regularly, and return from its run method in an orderly fashion if\n-the variable indicates that it is to stop running. To ensure prompt\n-communication of the stop-request, the variable must be\n-<code>volatile<\/code> (or access to the variable must be\n-synchronized).<\/p>\n-<p>For example, suppose your application contains the following\n-<code>start<\/code>, <code>stop<\/code> and <code>run<\/code>\n-methods:<\/p>\n-<pre>\n-    private Thread blinker;\n-\n-    public void start() {\n-        blinker = new Thread(this);\n-        blinker.start();\n-    }\n-\n-    public void stop() {\n-        blinker.stop();  \/\/ UNSAFE!\n-    }\n-\n-    public void run() {\n-        while (true) {\n-            try {\n-                Thread.sleep(interval);\n-            } catch (InterruptedException e){\n-            }\n-            blink();\n-        }\n-    }\n-<\/pre>\n-You can avoid the use of <code>Thread.stop<\/code> by replacing the\n-application's <code>stop<\/code> and <code>run<\/code> methods with:\n-<pre>\n-    private volatile Thread blinker;\n-\n-    public void stop() {\n-        blinker = null;\n-    }\n-\n-    public void run() {\n-        Thread thisThread = Thread.currentThread();\n-        while (blinker == thisThread) {\n-            try {\n-                Thread.sleep(interval);\n-            } catch (InterruptedException e){\n-            }\n-            blink();\n-        }\n-    }\n-<\/pre>\n-<hr>\n-<h2>How do I stop a thread that waits for long periods (e.g., for\n-input)?<\/h2>\n-<p>That's what the <code>Thread.interrupt<\/code> method is for. The\n-same \"state based\" signaling mechanism shown above can be used, but\n-the state change (<code>blinker = null<\/code>, in the previous\n-example) can be followed by a call to\n-<code>Thread.interrupt<\/code>, to interrupt the wait:<\/p>\n-<pre>\n-    public void stop() {\n-        Thread moribund = waiter;\n-        waiter = null;\n-        moribund.interrupt();\n-    }\n-<\/pre>\n-For this technique to work, it's critical that any method that\n-catches an interrupt exception and is not prepared to deal with it\n-immediately reasserts the exception. We say <em>reasserts<\/em>\n-rather than <em>rethrows<\/em>, because it is not always possible to\n-rethrow the exception. If the method that catches the\n-<code>InterruptedException<\/code> is not declared to throw this\n-(checked) exception, then it should \"reinterrupt itself\" with the\n-following incantation:\n-<pre>\n-    Thread.currentThread().interrupt();\n-<\/pre>\n-This ensures that the Thread will reraise the\n-<code>InterruptedException<\/code> as soon as it is able.\n-<hr>\n-<h2>What if a thread doesn't respond to\n-<code>Thread.interrupt<\/code>?<\/h2>\n-<p>In some cases, you can use application specific tricks. For\n-example, if a thread is waiting on a known socket, you can close\n-the socket to cause the thread to return immediately.\n-Unfortunately, there really isn't any technique that works in\n-general. <em>It should be noted that in all situations where a\n-waiting thread doesn't respond to <code>Thread.interrupt<\/code>, it\n-wouldn't respond to <code>Thread.stop<\/code> either.<\/em> Such\n-cases include deliberate denial-of-service attacks, and I\/O\n-operations for which thread.stop and thread.interrupt do not work\n-properly.<\/p>\n-<\/body>\n-<\/html>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/doc-files\/threadPrimitiveDeprecation.html","additions":0,"deletions":161,"binary":false,"changes":161,"status":"deleted"},{"patch":"@@ -40,1 +40,0 @@\n-import sun.invoke.util.Wrapper;\n@@ -122,1 +121,0 @@\n-    private static final int HIGH_ARITY_THRESHOLD;\n@@ -127,3 +125,0 @@\n-        String highArity = VM.getSavedProperty(\"java.lang.invoke.StringConcat.highArityThreshold\");\n-        HIGH_ARITY_THRESHOLD = highArity != null ? Integer.parseInt(highArity) : 0;\n-\n@@ -394,3 +389,0 @@\n-            if (mh == null && concatType.parameterCount() <= HIGH_ARITY_THRESHOLD) {\n-                mh = generateMHInlineCopy(concatType, constantStrings);\n-            }\n@@ -521,379 +513,0 @@\n-    \/**\n-     * <p>This strategy replicates what StringBuilders are doing: it builds the\n-     * byte[] array on its own and passes that byte[] array to String\n-     * constructor. This strategy requires access to some private APIs in JDK,\n-     * most notably, the private String constructor that accepts byte[] arrays\n-     * without copying.\n-     *\/\n-    private static MethodHandle generateMHInlineCopy(MethodType mt, String[] constants) {\n-        int paramCount = mt.parameterCount();\n-        String suffix = constants[paramCount];\n-\n-\n-        \/\/ else... fall-through to slow-path\n-\n-        \/\/ Create filters and obtain filtered parameter types. Filters would be used in the beginning\n-        \/\/ to convert the incoming arguments into the arguments we can process (e.g. Objects -> Strings).\n-        \/\/ The filtered argument type list is used all over in the combinators below.\n-\n-        Class<?>[] ptypes = mt.erase().parameterArray();\n-        MethodHandle[] objFilters = null;\n-        MethodHandle[] floatFilters = null;\n-        MethodHandle[] doubleFilters = null;\n-        for (int i = 0; i < ptypes.length; i++) {\n-            Class<?> cl = ptypes[i];\n-            \/\/ Use int as the logical type for subword integral types\n-            \/\/ (byte and short). char and boolean require special\n-            \/\/ handling so don't change the logical type of those\n-            ptypes[i] = promoteToIntType(ptypes[i]);\n-            \/\/ Object, float and double will be eagerly transformed\n-            \/\/ into a (non-null) String as a first step after invocation.\n-            \/\/ Set up to use String as the logical type for such arguments\n-            \/\/ internally.\n-            if (cl == Object.class) {\n-                if (objFilters == null) {\n-                    objFilters = new MethodHandle[ptypes.length];\n-                }\n-                objFilters[i] = objectStringifier();\n-                ptypes[i] = String.class;\n-            } else if (cl == float.class) {\n-                if (floatFilters == null) {\n-                    floatFilters = new MethodHandle[ptypes.length];\n-                }\n-                floatFilters[i] = floatStringifier();\n-                ptypes[i] = String.class;\n-            } else if (cl == double.class) {\n-                if (doubleFilters == null) {\n-                    doubleFilters = new MethodHandle[ptypes.length];\n-                }\n-                doubleFilters[i] = doubleStringifier();\n-                ptypes[i] = String.class;\n-            }\n-        }\n-\n-        \/\/ Start building the combinator tree. The tree \"starts\" with (<parameters>)String, and \"finishes\"\n-        \/\/ with the (byte[], long)String shape to invoke newString in StringConcatHelper. The combinators are\n-        \/\/ assembled bottom-up, which makes the code arguably hard to read.\n-\n-        \/\/ Drop all remaining parameter types, leave only helper arguments:\n-        MethodHandle mh = MethodHandles.dropArgumentsTrusted(newString(), 2, ptypes);\n-\n-        \/\/ Calculate the initialLengthCoder value by looking at all constant values and summing up\n-        \/\/ their lengths and adjusting the encoded coder bit if needed\n-        long initialLengthCoder = INITIAL_CODER;\n-\n-        for (String constant : constants) {\n-            if (constant != null) {\n-                initialLengthCoder = JLA.stringConcatMix(initialLengthCoder, constant);\n-            }\n-        }\n-\n-        \/\/ Mix in prependers. This happens when (byte[], long) = (storage, indexCoder) is already\n-        \/\/ known from the combinators below. We are assembling the string backwards, so the index coded\n-        \/\/ into indexCoder is the *ending* index.\n-        mh = filterInPrependers(mh, constants, ptypes);\n-\n-        \/\/ Fold in byte[] instantiation at argument 0\n-        MethodHandle newArrayCombinator;\n-        if (suffix == null || suffix.isEmpty()) {\n-            suffix = \"\";\n-        }\n-        \/\/ newArray variant that deals with prepending any trailing constant\n-        \/\/\n-        \/\/ initialLengthCoder is adjusted to have the correct coder\n-        \/\/ and length: The newArrayWithSuffix method expects only the coder of the\n-        \/\/ suffix to be encoded into indexCoder\n-        initialLengthCoder -= suffix.length();\n-        newArrayCombinator = newArrayWithSuffix(suffix);\n-\n-        mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, newArrayCombinator,\n-                1 \/\/ index\n-        );\n-\n-        \/\/ Start combining length and coder mixers.\n-        \/\/\n-        \/\/ Length is easy: constant lengths can be computed on the spot, and all non-constant\n-        \/\/ shapes have been either converted to Strings, or explicit methods for getting the\n-        \/\/ string length out of primitives are provided.\n-        \/\/\n-        \/\/ Coders are more interesting. Only Object, String and char arguments (and constants)\n-        \/\/ can have non-Latin1 encoding. It is easier to blindly convert constants to String,\n-        \/\/ and deduce the coder from there. Arguments would be either converted to Strings\n-        \/\/ during the initial filtering, or handled by specializations in MIXERS.\n-        \/\/\n-        \/\/ The method handle shape before all mixers are combined in is:\n-        \/\/   (long, <args>)String = (\"indexCoder\", <args>)\n-        \/\/\n-        \/\/ We will bind the initialLengthCoder value to the last mixer (the one that will be\n-        \/\/ executed first), then fold that in. This leaves the shape after all mixers are\n-        \/\/ combined in as:\n-        \/\/   (<args>)String = (<args>)\n-\n-        mh = filterAndFoldInMixers(mh, initialLengthCoder, ptypes);\n-\n-        \/\/ The method handle shape here is (<args>).\n-\n-        \/\/ Apply filters, converting the arguments:\n-        if (objFilters != null) {\n-            mh = MethodHandles.filterArguments(mh, 0, objFilters);\n-        }\n-        if (floatFilters != null) {\n-            mh = MethodHandles.filterArguments(mh, 0, floatFilters);\n-        }\n-        if (doubleFilters != null) {\n-            mh = MethodHandles.filterArguments(mh, 0, doubleFilters);\n-        }\n-\n-        return mh;\n-    }\n-\n-    \/\/ We need one prepender per argument, but also need to fold in constants. We do so by greedily\n-    \/\/ creating prependers that fold in surrounding constants into the argument prepender. This reduces\n-    \/\/ the number of unique MH combinator tree shapes we'll create in an application.\n-    \/\/ Additionally we do this in chunks to reduce the number of combinators bound to the root tree,\n-    \/\/ which simplifies the shape and makes construction of similar trees use less unique LF classes\n-    private static MethodHandle filterInPrependers(MethodHandle mh, String[] constants, Class<?>[] ptypes) {\n-        int pos;\n-        int[] argPositions = null;\n-        MethodHandle prepend;\n-        for (pos = 0; pos < ptypes.length - 3; pos += 4) {\n-            prepend = prepender(pos, constants, ptypes, 4);\n-            argPositions = filterPrependArgPositions(argPositions, pos, 4);\n-            mh = MethodHandles.filterArgumentsWithCombiner(mh, 1, prepend, argPositions);\n-        }\n-        if (pos < ptypes.length) {\n-            int count = ptypes.length - pos;\n-            prepend = prepender(pos, constants, ptypes, count);\n-            argPositions = filterPrependArgPositions(argPositions, pos, count);\n-            mh = MethodHandles.filterArgumentsWithCombiner(mh, 1, prepend, argPositions);\n-        }\n-        return mh;\n-    }\n-\n-    static int[] filterPrependArgPositions(int[] argPositions, int pos, int count) {\n-        if (argPositions == null || argPositions.length != count + 2) {\n-            argPositions = new int[count + 2];\n-            argPositions[0] = 1; \/\/ indexCoder\n-            argPositions[1] = 0; \/\/ storage\n-        }\n-        int limit = count + 2;\n-        for (int i = 2; i < limit; i++) {\n-            argPositions[i] = i + pos;\n-        }\n-        return argPositions;\n-    }\n-\n-\n-    \/\/ We need one mixer per argument.\n-    private static MethodHandle filterAndFoldInMixers(MethodHandle mh, long initialLengthCoder, Class<?>[] ptypes) {\n-        int pos;\n-        int[] argPositions = null;\n-        for (pos = 0; pos < ptypes.length - 4; pos += 4) {\n-            \/\/ Compute new \"index\" in-place pairwise using old value plus the appropriate arguments.\n-            MethodHandle mix = mixer(ptypes[pos], ptypes[pos + 1], ptypes[pos + 2], ptypes[pos + 3]);\n-            argPositions = filterMixerArgPositions(argPositions, pos, 4);\n-            mh = MethodHandles.filterArgumentsWithCombiner(mh, 0,\n-                    mix, argPositions);\n-        }\n-\n-        if (pos < ptypes.length) {\n-            \/\/ Mix in the last 1 to 4 parameters, insert the initialLengthCoder into the final mixer and\n-            \/\/ fold the result into the main combinator\n-            mh = foldInLastMixers(mh, initialLengthCoder, pos, ptypes, ptypes.length - pos);\n-        } else if (ptypes.length == 0) {\n-            \/\/ No mixer (constants only concat), insert initialLengthCoder directly\n-            mh = MethodHandles.insertArguments(mh, 0, initialLengthCoder);\n-        }\n-        return mh;\n-    }\n-\n-    static int[] filterMixerArgPositions(int[] argPositions, int pos, int count) {\n-        if (argPositions == null || argPositions.length != count + 2) {\n-            argPositions = new int[count + 1];\n-            argPositions[0] = 0; \/\/ indexCoder\n-        }\n-        int limit = count + 1;\n-        for (int i = 1; i < limit; i++) {\n-            argPositions[i] = i + pos;\n-        }\n-        return argPositions;\n-    }\n-\n-    private static MethodHandle foldInLastMixers(MethodHandle mh, long initialLengthCoder, int pos, Class<?>[] ptypes, int count) {\n-        MethodHandle mix = switch (count) {\n-            case 1 -> mixer(ptypes[pos]);\n-            case 2 -> mixer(ptypes[pos], ptypes[pos + 1]);\n-            case 3 -> mixer(ptypes[pos], ptypes[pos + 1], ptypes[pos + 2]);\n-            case 4 -> mixer(ptypes[pos], ptypes[pos + 1], ptypes[pos + 2], ptypes[pos + 3]);\n-            default -> throw new IllegalArgumentException(\"Unexpected count: \" + count);\n-        };\n-        mix = MethodHandles.insertArguments(mix,0, initialLengthCoder);\n-        \/\/ apply selected arguments on the 1-4 arg mixer and fold in the result\n-        return switch (count) {\n-            case 1 -> MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,\n-                    1 + pos);\n-            case 2 -> MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,\n-                    1 + pos, 2 + pos);\n-            case 3 -> MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,\n-                    1 + pos, 2 + pos, 3 + pos);\n-            case 4 -> MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,\n-                    1 + pos, 2 + pos, 3 + pos, 4 + pos);\n-            default -> throw new IllegalArgumentException();\n-        };\n-    }\n-\n-    \/\/ Simple prependers, single argument. May be used directly or as a\n-    \/\/ building block for complex prepender combinators.\n-    private static MethodHandle prepender(String prefix, Class<?> cl) {\n-        if (prefix == null || prefix.isEmpty()) {\n-            return noPrefixPrepender(cl);\n-        } else {\n-            return MethodHandles.insertArguments(\n-                    prepender(cl), 3, prefix);\n-        }\n-    }\n-\n-    private static MethodHandle prepender(Class<?> cl) {\n-        int idx = classIndex(cl);\n-        MethodHandle prepend = PREPENDERS[idx];\n-        if (prepend == null) {\n-            PREPENDERS[idx] = prepend = JLA.stringConcatHelper(\"prepend\",\n-                    methodType(long.class, long.class, byte[].class,\n-                            Wrapper.asPrimitiveType(cl), String.class)).rebind();\n-        }\n-        return prepend;\n-    }\n-\n-    private static MethodHandle noPrefixPrepender(Class<?> cl) {\n-        int idx = classIndex(cl);\n-        MethodHandle prepend = NO_PREFIX_PREPENDERS[idx];\n-        if (prepend == null) {\n-            NO_PREFIX_PREPENDERS[idx] = prepend = MethodHandles.insertArguments(prepender(cl), 3, \"\");\n-        }\n-        return prepend;\n-    }\n-\n-    private static final int INT_IDX = 0,\n-            CHAR_IDX = 1,\n-            LONG_IDX = 2,\n-            BOOLEAN_IDX = 3,\n-            STRING_IDX = 4,\n-            TYPE_COUNT = 5;\n-    private static int classIndex(Class<?> cl) {\n-        if (cl == String.class)                          return STRING_IDX;\n-        if (cl == int.class)                             return INT_IDX;\n-        if (cl == boolean.class)                         return BOOLEAN_IDX;\n-        if (cl == char.class)                            return CHAR_IDX;\n-        if (cl == long.class)                            return LONG_IDX;\n-        throw new IllegalArgumentException(\"Unexpected class: \" + cl);\n-    }\n-\n-    \/\/ Constant argument lists used by the prepender MH builders\n-    private static final int[] PREPEND_FILTER_FIRST_ARGS  = new int[] { 0, 1, 2 };\n-    private static final int[] PREPEND_FILTER_SECOND_ARGS = new int[] { 0, 1, 3 };\n-    private static final int[] PREPEND_FILTER_THIRD_ARGS  = new int[] { 0, 1, 4 };\n-    private static final int[] PREPEND_FILTER_FIRST_PAIR_ARGS  = new int[] { 0, 1, 2, 3 };\n-    private static final int[] PREPEND_FILTER_SECOND_PAIR_ARGS = new int[] { 0, 1, 4, 5 };\n-\n-    \/\/ Base MH for complex prepender combinators.\n-    private static @Stable MethodHandle PREPEND_BASE;\n-    private static MethodHandle prependBase() {\n-        MethodHandle base = PREPEND_BASE;\n-        if (base == null) {\n-            base = PREPEND_BASE = MethodHandles.dropArguments(\n-                    MethodHandles.identity(long.class), 1, byte[].class);\n-        }\n-        return base;\n-    }\n-\n-    private static final @Stable MethodHandle[][] DOUBLE_PREPENDERS = new MethodHandle[TYPE_COUNT][TYPE_COUNT];\n-\n-    private static MethodHandle prepender(String prefix, Class<?> cl, String prefix2, Class<?> cl2) {\n-        int idx1 = classIndex(cl);\n-        int idx2 = classIndex(cl2);\n-        MethodHandle prepend = DOUBLE_PREPENDERS[idx1][idx2];\n-        if (prepend == null) {\n-            prepend = DOUBLE_PREPENDERS[idx1][idx2] =\n-                    MethodHandles.dropArguments(prependBase(), 2, cl, cl2);\n-        }\n-        prepend = MethodHandles.filterArgumentsWithCombiner(prepend, 0, prepender(prefix, cl),\n-                PREPEND_FILTER_FIRST_ARGS);\n-        return MethodHandles.filterArgumentsWithCombiner(prepend, 0, prepender(prefix2, cl2),\n-                PREPEND_FILTER_SECOND_ARGS);\n-    }\n-\n-    private static MethodHandle prepender(int pos, String[] constants, Class<?>[] ptypes, int count) {\n-        \/\/ build the simple cases directly\n-        if (count == 1) {\n-            return prepender(constants[pos], ptypes[pos]);\n-        }\n-        if (count == 2) {\n-            return prepender(constants[pos], ptypes[pos], constants[pos + 1], ptypes[pos + 1]);\n-        }\n-        \/\/ build a tree from an unbound prepender, allowing us to bind the constants in a batch as a final step\n-        MethodHandle prepend = prependBase();\n-        if (count == 3) {\n-            prepend = MethodHandles.dropArguments(prepend, 2,\n-                    ptypes[pos], ptypes[pos + 1], ptypes[pos + 2]);\n-            prepend = MethodHandles.filterArgumentsWithCombiner(prepend, 0,\n-                    prepender(constants[pos], ptypes[pos], constants[pos + 1], ptypes[pos + 1]),\n-                    PREPEND_FILTER_FIRST_PAIR_ARGS);\n-            return MethodHandles.filterArgumentsWithCombiner(prepend, 0,\n-                    prepender(constants[pos + 2], ptypes[pos + 2]),\n-                    PREPEND_FILTER_THIRD_ARGS);\n-        } else if (count == 4) {\n-            prepend = MethodHandles.dropArguments(prepend, 2,\n-                    ptypes[pos], ptypes[pos + 1], ptypes[pos + 2], ptypes[pos + 3]);\n-            prepend = MethodHandles.filterArgumentsWithCombiner(prepend, 0,\n-                    prepender(constants[pos], ptypes[pos], constants[pos + 1], ptypes[pos + 1]),\n-                    PREPEND_FILTER_FIRST_PAIR_ARGS);\n-            return MethodHandles.filterArgumentsWithCombiner(prepend, 0,\n-                    prepender(constants[pos + 2], ptypes[pos + 2], constants[pos + 3], ptypes[pos + 3]),\n-                    PREPEND_FILTER_SECOND_PAIR_ARGS);\n-        } else {\n-            throw new IllegalArgumentException(\"Unexpected count: \" + count);\n-        }\n-    }\n-\n-    \/\/ Constant argument lists used by the mixer MH builders\n-    private static final int[] MIX_FILTER_SECOND_ARGS = new int[] { 0, 2 };\n-    private static final int[] MIX_FILTER_THIRD_ARGS  = new int[] { 0, 3 };\n-    private static final int[] MIX_FILTER_SECOND_PAIR_ARGS = new int[] { 0, 3, 4 };\n-    private static MethodHandle mixer(Class<?> cl) {\n-        int index = classIndex(cl);\n-        MethodHandle mix = MIXERS[index];\n-        if (mix == null) {\n-            MIXERS[index] = mix = JLA.stringConcatHelper(\"mix\",\n-                    methodType(long.class, long.class, Wrapper.asPrimitiveType(cl))).rebind();\n-        }\n-        return mix;\n-    }\n-\n-    private static final @Stable MethodHandle[][] DOUBLE_MIXERS = new MethodHandle[TYPE_COUNT][TYPE_COUNT];\n-    private static MethodHandle mixer(Class<?> cl, Class<?> cl2) {\n-        int idx1 = classIndex(cl);\n-        int idx2 = classIndex(cl2);\n-        MethodHandle mix = DOUBLE_MIXERS[idx1][idx2];\n-        if (mix == null) {\n-            mix = mixer(cl);\n-            mix = MethodHandles.dropArguments(mix, 2, cl2);\n-            DOUBLE_MIXERS[idx1][idx2] = mix = MethodHandles.filterArgumentsWithCombiner(mix, 0,\n-                    mixer(cl2), MIX_FILTER_SECOND_ARGS);\n-        }\n-        return mix;\n-    }\n-\n-    private static MethodHandle mixer(Class<?> cl, Class<?> cl2, Class<?> cl3) {\n-        MethodHandle mix = mixer(cl, cl2);\n-        mix = MethodHandles.dropArguments(mix, 3, cl3);\n-        return MethodHandles.filterArgumentsWithCombiner(mix, 0,\n-                mixer(cl3), MIX_FILTER_THIRD_ARGS);\n-    }\n-\n-    private static MethodHandle mixer(Class<?> cl, Class<?> cl2, Class<?> cl3, Class<?> cl4) {\n-        MethodHandle mix = mixer(cl, cl2);\n-        mix = MethodHandles.dropArguments(mix, 3, cl3, cl4);\n-        return MethodHandles.filterArgumentsWithCombiner(mix, 0,\n-                mixer(cl3, cl4), MIX_FILTER_SECOND_PAIR_ARGS);\n-    }\n-\n@@ -911,22 +524,0 @@\n-    private @Stable static MethodHandle NEW_STRING;\n-    private static MethodHandle newString() {\n-        MethodHandle mh = NEW_STRING;\n-        if (mh == null) {\n-            MethodHandle newString = JLA.stringConcatHelper(\"newString\",\n-                    methodType(String.class, byte[].class, long.class));\n-            NEW_STRING = mh = newString.rebind();\n-        }\n-        return mh;\n-    }\n-\n-    private @Stable static MethodHandle NEW_ARRAY_SUFFIX;\n-    private static MethodHandle newArrayWithSuffix(String suffix) {\n-        MethodHandle mh = NEW_ARRAY_SUFFIX;\n-        if (mh == null) {\n-            MethodHandle newArrayWithSuffix = JLA.stringConcatHelper(\"newArrayWithSuffix\",\n-                    methodType(byte[].class, String.class, long.class));\n-            NEW_ARRAY_SUFFIX = mh = newArrayWithSuffix.rebind();\n-        }\n-        return MethodHandles.insertArguments(mh, 0, suffix);\n-    }\n-\n@@ -938,9 +529,0 @@\n-    private @Stable static MethodHandle OBJECT_STRINGIFIER;\n-    private static MethodHandle objectStringifier() {\n-        MethodHandle mh = OBJECT_STRINGIFIER;\n-        if (mh == null) {\n-            OBJECT_STRINGIFIER = mh = JLA.stringConcatHelper(\"stringOf\",\n-                    methodType(String.class, Object.class));\n-        }\n-        return mh;\n-    }\n@@ -1030,32 +612,0 @@\n-    private static final @Stable MethodHandle[] NO_PREFIX_PREPENDERS = new MethodHandle[TYPE_COUNT];\n-    private static final @Stable MethodHandle[] PREPENDERS      = new MethodHandle[TYPE_COUNT];\n-    private static final @Stable MethodHandle[] MIXERS          = new MethodHandle[TYPE_COUNT];\n-    private static final long INITIAL_CODER = JLA.stringConcatInitialCoder();\n-\n-    \/**\n-     * Promote integral types to int.\n-     *\/\n-    private static Class<?> promoteToIntType(Class<?> t) {\n-        \/\/ use int for subword integral types; still need special mixers\n-        \/\/ and prependers for char, boolean\n-        return t == byte.class || t == short.class ? int.class : t;\n-    }\n-\n-    \/**\n-     * Returns a stringifier for references and floats\/doubles only.\n-     * Always returns null for other primitives.\n-     *\n-     * @param t class to stringify\n-     * @return stringifier; null, if not available\n-     *\/\n-    private static MethodHandle stringifierFor(Class<?> t) {\n-        if (t == Object.class) {\n-            return objectStringifier();\n-        } else if (t == float.class) {\n-            return floatStringifier();\n-        } else if (t == double.class) {\n-            return doubleStringifier();\n-        }\n-        return null;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":0,"deletions":450,"binary":false,"changes":450,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+import jdk.internal.vm.annotation.AOTRuntimeSetup;\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -94,0 +96,1 @@\n+@AOTSafeClassInitializer\n@@ -2668,0 +2671,5 @@\n+        runtimeSetup();\n+    }\n+\n+    @AOTRuntimeSetup\n+    private static void runtimeSetup() {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/module\/ModuleDescriptor.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4183,0 +4183,4 @@\n+        if (fitsIntoLong()) {\n+            return Long.toString(longValue(), radix);\n+        }\n+\n@@ -5124,1 +5128,1 @@\n-        if (mag.length <= 2 && bitLength() < Long.SIZE)\n+        if (fitsIntoLong())\n@@ -5130,0 +5134,4 @@\n+    private boolean fitsIntoLong() {\n+        return mag.length <= 2 && bitLength() < Long.SIZE;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+import jdk.internal.vm.annotation.AOTRuntimeSetup;\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -519,0 +521,1 @@\n+@AOTSafeClassInitializer\n@@ -3729,0 +3732,1 @@\n+\n@@ -3730,0 +3734,5 @@\n+        runtimeSetup();\n+    }\n+\n+    @AOTRuntimeSetup\n+    private static void runtimeSetup() {\n","filename":"src\/java.base\/share\/classes\/java\/net\/URI.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+import jdk.internal.vm.annotation.AOTRuntimeSetup;\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -217,0 +219,1 @@\n+@AOTSafeClassInitializer\n@@ -1761,0 +1764,5 @@\n+        runtimeSetup();\n+    }\n+\n+    @AOTRuntimeSetup\n+    private static void runtimeSetup() {\n","filename":"src\/java.base\/share\/classes\/java\/net\/URL.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.internal.misc.CDS;\n@@ -246,1 +247,15 @@\n-        pdcache.clear();\n+        if (CDS.isDumpingAOTLinkedClasses()) {\n+            for (CodeSourceKey key : pdcache.keySet()) {\n+                if (key.cs.getCodeSigners() != null) {\n+                    \/\/ We don't archive any signed classes, so we don't need to cache their ProtectionDomains.\n+                    pdcache.remove(key);\n+                }\n+            }\n+            if (System.getProperty(\"cds.debug.archived.protection.domains\") != null) {\n+                for (CodeSourceKey key : pdcache.keySet()) {\n+                    System.out.println(\"Archiving ProtectionDomain \" + key.cs + \" for \" + this);\n+                }\n+            }\n+        } else {\n+            pdcache.clear();\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/security\/SecureClassLoader.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -253,1 +253,2 @@\n-     * compact number patterns.\n+     * compact number patterns. This field is a read-only\n+     * constant once initialized.\n@@ -259,1 +260,2 @@\n-     * compact number patterns.\n+     * compact number patterns. This field is a read-only\n+     * constant once initialized.\n@@ -265,1 +267,2 @@\n-     * compact number patterns.\n+     * compact number patterns. This field is a read-only\n+     * constant once initialized.\n@@ -271,1 +274,2 @@\n-     * compact number patterns.\n+     * compact number patterns. This field is a read-only\n+     * constant once initialized.\n@@ -278,1 +282,2 @@\n-     * beyond long boundary)\n+     * beyond long boundary). This field is a read-only constant\n+     * once initialized.\n@@ -284,1 +289,1 @@\n-     * for each count.\n+     * for each count. This field is a read-only constant once initialized.\n@@ -377,1 +382,1 @@\n-     * its rule.\n+     * its rule. This field is a read-only constant once initialized.\n@@ -1518,1 +1523,1 @@\n-    private final transient DigitList digitList = new DigitList();\n+    private transient DigitList digitList = new DigitList();\n@@ -2509,0 +2514,3 @@\n+\n+        \/\/ Cloning reference fields. Other fields (e.g., \"positivePrefixPatterns\")\n+        \/\/ are not cloned since they are read-only constants after initialization.\n@@ -2511,0 +2519,3 @@\n+        other.decimalFormat = (DecimalFormat) decimalFormat.clone();\n+        other.defaultDecimalFormat = (DecimalFormat) defaultDecimalFormat.clone();\n+        other.digitList = (DigitList) digitList.clone();\n","filename":"src\/java.base\/share\/classes\/java\/text\/CompactNumberFormat.java","additions":19,"deletions":8,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -111,1 +112,0 @@\n-    private byte[] data;\n@@ -323,0 +323,2 @@\n+        assert Double.isFinite(source);\n+\n@@ -327,1 +329,0 @@\n-        assert !fdConverter.isExceptional();\n@@ -329,3 +330,5 @@\n-        byte[] chars = getDataChars(26);\n-        int len = fdConverter.getChars(chars);\n-        set(isNegative, chars, len,\n+        count = fdConverter.getDigits(digits);\n+\n+        int exp = fdConverter.getDecimalExponent() - count;\n+\n+        set(isNegative, exp,\n@@ -343,1 +346,1 @@\n-    private void set(boolean isNegative, byte[] source, int len,\n+    private void set(boolean isNegative, int exp,\n@@ -349,31 +352,4 @@\n-        decimalAt = -1;\n-        count = 0;\n-        int exponent = 0;\n-        \/\/ Number of zeros between decimal point and first non-zero digit after\n-        \/\/ decimal point, for numbers < 1.\n-        int leadingZerosAfterDecimal = 0;\n-        boolean nonZeroDigitSeen = false;\n-\n-        for (int i = 0; i < len; ) {\n-            byte c = source[i++];\n-            if (c == '.') {\n-                decimalAt = count;\n-            } else if (c == 'e' || c == 'E') {\n-                exponent = parseInt(source, i, len);\n-                break;\n-            } else {\n-                if (!nonZeroDigitSeen) {\n-                    nonZeroDigitSeen = (c != '0');\n-                    if (!nonZeroDigitSeen && decimalAt != -1)\n-                        ++leadingZerosAfterDecimal;\n-                }\n-                if (nonZeroDigitSeen) {\n-                    digits[count++] = c;\n-                }\n-            }\n-        }\n-        if (decimalAt == -1) {\n-            decimalAt = count;\n-        }\n-        if (nonZeroDigitSeen) {\n-            decimalAt += exponent - leadingZerosAfterDecimal;\n+        if (!nonZeroAfterIndex(0)) {\n+            count = 0;\n+            decimalAt = 0;\n+            return;\n@@ -381,0 +357,1 @@\n+        decimalAt = count + exp;\n@@ -672,3 +649,1 @@\n-        String s = source.toString();\n-        extendDigits(s.length());\n-\n+        String s = source.unscaledValue().toString();\n@@ -676,3 +651,5 @@\n-        byte[] chars = getDataChars(len);\n-        s.getBytes(0, len, chars, 0);\n-        set(isNegative, chars, len,\n+\n+        extendDigits(len);\n+        s.getBytes(0, len, digits, 0);\n+        count = len;\n+        set(isNegative, -source.scale(),\n@@ -748,8 +725,1 @@\n-            byte[] newDigits = new byte[digits.length];\n-            System.arraycopy(digits, 0, newDigits, 0, digits.length);\n-            other.digits = newDigits;\n-\n-            \/\/ Data does not need to be copied because it does\n-            \/\/ not carry significant information. It will be recreated on demand.\n-            \/\/ Setting it to null is needed to avoid sharing across clones.\n-            other.data = null;\n+            other.digits = digits.clone();\n@@ -763,22 +733,0 @@\n-    private static int parseInt(byte[] str, int offset, int strLen) {\n-        byte c;\n-        boolean positive = true;\n-        if ((c = str[offset]) == '-') {\n-            positive = false;\n-            offset++;\n-        } else if (c == '+') {\n-            offset++;\n-        }\n-\n-        int value = 0;\n-        while (offset < strLen) {\n-            c = str[offset++];\n-            if (c >= '0' && c <= '9') {\n-                value = value * 10 + (c - '0');\n-            } else {\n-                break;\n-            }\n-        }\n-        return positive ? value : -value;\n-    }\n-\n@@ -786,0 +734,1 @@\n+    @Stable\n@@ -801,7 +750,0 @@\n-\n-    private byte[] getDataChars(int length) {\n-        if (data == null || data.length < length) {\n-            data = new byte[length];\n-        }\n-        return data;\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/text\/DigitList.java","additions":22,"deletions":80,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -534,1 +534,7 @@\n-     * @param asExecutionException true if wrap as ExecutionException\n+     * @param asExecutionException true if wrap the result as an\n+     * ExecutionException. This applies only to actual exceptions, not\n+     * implicit CancellationExceptions issued when not THROWN or\n+     * available, which are not wrapped because by default they are\n+     * issued separately from ExecutionExceptions by callers. Which\n+     * may require further handling when this is not true (currently\n+     * only in InvokeAnyTask).\n@@ -541,6 +547,3 @@\n-        else if ((s & THROWN) == 0 || (a = aux) == null || (ex = a.ex) == null) {\n-            ex = new CancellationException();\n-            if (!asExecutionException || !(this instanceof InterruptibleTask))\n-                return ex;         \/\/ else wrap below\n-        }\n-        else if (a.thread != Thread.currentThread()) {\n+        if ((s & THROWN) == 0 || (a = aux) == null || (ex = a.ex) == null)\n+            return new CancellationException();\n+        if (a.thread != Thread.currentThread()) {\n@@ -1817,0 +1820,2 @@\n+            } catch (CancellationException ce) {\n+                throw new ExecutionException(ce);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinTask.java","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -518,3 +518,3 @@\n-     *         is {@code null}, empty, in an invalid format,\n-     *         or if no provider supports a {@code CipherSpi}\n-     *         implementation for the specified algorithm\n+     *         is {@code null}, empty or in an invalid format;\n+     *         or if a {@code CipherSpi} implementation is not found or\n+     *         is found but does not support the mode\n@@ -522,2 +522,2 @@\n-     * @throws NoSuchPaddingException if {@code transformation}\n-     *         contains a padding scheme that is not available\n+     * @throws NoSuchPaddingException if a {@code CipherSpi} implementation\n+     *         is found but does not support the padding scheme\n@@ -576,0 +576,3 @@\n+        if (failure instanceof NoSuchPaddingException nspe) {\n+            throw nspe;\n+        }\n@@ -577,1 +580,2 @@\n-            (\"Cannot find any provider supporting \" + transformation, failure);\n+                (\"Cannot find any provider supporting \" + transformation,\n+                failure);\n@@ -585,2 +589,2 @@\n-     * {@code CipherSpi} implementation from the specified provider\n-     * is returned.  The specified provider must be registered\n+     * {@code CipherSpi} implementation from the specified {@code provider}\n+     * is returned.  The specified {@code provider} must be registered\n@@ -628,4 +632,4 @@\n-     *         is {@code null}, empty, in an invalid format,\n-     *         or if a {@code CipherSpi} implementation for the\n-     *         specified algorithm is not available from the specified\n-     *         provider\n+     *         is {@code null}, empty or in an invalid format;\n+     *         or if a {@code CipherSpi} implementation from the specified\n+     *         {@code provider} is not found or is found but does not support\n+     *         the mode\n@@ -633,2 +637,3 @@\n-     * @throws NoSuchPaddingException if {@code transformation}\n-     *         contains a padding scheme that is not available\n+     * @throws NoSuchPaddingException if a {@code CipherSpi} implementation\n+     *         from the specified {@code provider} is found but does not\n+     *         support the padding scheme\n@@ -636,1 +641,1 @@\n-     * @throws NoSuchProviderException if the specified provider is not\n+     * @throws NoSuchProviderException if the specified {@code provider} is not\n@@ -709,7 +714,8 @@\n-     *         is {@code null}, empty, in an invalid format,\n-     *         or if a {@code CipherSpi} implementation for the\n-     *         specified algorithm is not available from the specified\n-     *         {@code provider} object\n-     *\n-     * @throws NoSuchPaddingException if {@code transformation}\n-     *         contains a padding scheme that is not available\n+     *         is {@code null}, empty or in an invalid format;\n+     *         or if a {@code CipherSpi} implementation from the specified\n+     *         {@code provider} is not found or is found but does not support\n+     *         the mode\n+     *\n+     * @throws NoSuchPaddingException if a {@code CipherSpi} implementation\n+     *         from the specified {@code provider} is found but does not\n+     *         support the padding scheme\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/Cipher.java","additions":28,"deletions":22,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -455,15 +455,0 @@\n-    \/**\n-     * Get the string concat initial coder\n-     *\/\n-    long stringConcatInitialCoder();\n-\n-    \/**\n-     * Update lengthCoder for constant\n-     *\/\n-    long stringConcatMix(long lengthCoder, String constant);\n-\n-    \/**\n-     * Mix value length and coder into current length and coder.\n-     *\/\n-    long stringConcatMix(long lengthCoder, char value);\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.runtime.ExactConversionsSupport;\n@@ -278,2 +279,5 @@\n-        int utflen = utfLen(str, countNonZeroAscii);\n-        Util.checkU2(utflen, \"utf8 length\");\n+        long utflenLong = utfLen(str, countNonZeroAscii);\n+        if (!ExactConversionsSupport.isLongToCharExact(utflenLong)) {\n+            throw new IllegalArgumentException(\"utf8 length out of range of u2: \" + utflenLong);\n+        }\n+        int utflen = (int)utflenLong;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufWriterImpl.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -312,1 +312,1 @@\n-                        map(cts.classDesc()),\n+                        Util.toInternalName(map(cts.classDesc())),\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassRemapperImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,1 @@\n-                paramTypes.add(typeSig());\n+                paramTypes.add(validateNonVoid(typeSig()));\n@@ -116,2 +116,16 @@\n-                if (sig.charAt(sigp) != ':')\n-                    classBound = referenceTypeSig();\n+                if (sig.charAt(sigp) != ':') {\n+                    int p = nextIdentifierEnd(sig, sigp);\n+                    \/\/ For non-identifier chars:\n+                    \/\/ . \/ < indicates class type (inner, package, type arg)\n+                    \/\/ [ indicates array type\n+                    \/\/ ; indicates class\/type var type\n+                    \/\/ > and : are illegal, such as in <P:R:>\n+                    if (p < sig.length()) {\n+                        char limit = sig.charAt(p);\n+                        if (limit != '>' && limit != ':') {\n+                            classBound = referenceTypeSig();\n+                        }\n+                    }\n+                    \/\/ If classBound is absent here, we start tokenizing\n+                    \/\/ next type parameter, which can trigger failures\n+                }\n@@ -229,1 +243,0 @@\n-        l:\n@@ -231,5 +244,2 @@\n-            switch (sig.charAt(sigp)) {\n-                case '.', ';', '[', '\/', '<', '>', ':' -> {\n-                    break l;\n-                }\n-            }\n+            if (isNonIdentifierChar(sig.charAt(sigp)))\n+                break;\n@@ -244,0 +254,71 @@\n+    \/\/ Non-identifier chars in ascii 0 to 63, note [ is larger\n+    private static final long SMALL_NON_IDENTIFIER_CHARS_SET = (1L << '.')\n+            | (1L << ';')\n+            | (1L << '\/')\n+            | (1L << '<')\n+            | (1L << '>')\n+            | (1L << ':');\n+\n+    private static boolean isNonIdentifierChar(char c) {\n+        return c < Long.SIZE ? (SMALL_NON_IDENTIFIER_CHARS_SET & (1L << c)) != 0 : c == '[';\n+    }\n+\n+    \/\/\/ {@return exclusive end of the next identifier}\n+    public static int nextIdentifierEnd(String st, int start) {\n+        int end = st.length();\n+        for (int i = start; i < end; i++) {\n+            if (isNonIdentifierChar(st.charAt(i))) {\n+                return i;\n+            }\n+        }\n+        return end;\n+    }\n+\n+    \/\/\/ Validates this string as a simple identifier.\n+    public static String validateIdentifier(String st) {\n+        var len = st.length(); \/\/ implicit null check\n+        if (len == 0 || nextIdentifierEnd(st, 0) != len) {\n+            throw new IllegalArgumentException(\"Not a valid identifier: \" + st);\n+        }\n+        return st;\n+    }\n+\n+    \/\/\/ Validates this string as slash-separated one or more identifiers.\n+    public static String validatePackageSpecifierPlusIdentifier(String st) {\n+        int nextIdentifierStart = 0;\n+        int len = st.length();\n+        while (nextIdentifierStart < len) {\n+            int end = nextIdentifierEnd(st, nextIdentifierStart);\n+            if (end == len)\n+                return st;\n+            if (end == nextIdentifierStart || st.charAt(end) != '\/')\n+                throw new IllegalArgumentException(\"Not a class name: \" + st);\n+            nextIdentifierStart = end + 1;\n+        }\n+        \/\/ Couldn't get an identifier initially or after a separator.\n+        throw new IllegalArgumentException(\"Not a class name: \" + st);\n+    }\n+\n+    \/\/\/ Validates the signature to be non-void (a valid field type).\n+    public static Signature validateNonVoid(Signature incoming) {\n+        Objects.requireNonNull(incoming);\n+        if (incoming instanceof Signature.BaseTypeSig baseType && baseType.baseType() == 'V')\n+            throw new IllegalArgumentException(\"void\");\n+        return incoming;\n+    }\n+\n+    \/\/\/ Returns the validated immutable argument list or fails with IAE.\n+    public static List<Signature> validateArgumentList(Signature[] signatures) {\n+        return validateArgumentList(List.of(signatures));\n+    }\n+\n+    \/\/\/ Returns the validated immutable argument list or fails with IAE.\n+    public static List<Signature> validateArgumentList(List<Signature> signatures) {\n+        var res = List.copyOf(signatures); \/\/ deep null checks\n+        for (var sig : signatures) {\n+            if (sig instanceof Signature.BaseTypeSig baseType && baseType.baseType() == 'V')\n+                throw new IllegalArgumentException(\"void\");\n+        }\n+        return res;\n+    }\n+\n@@ -319,1 +400,1 @@\n-        if (typeParameters != null && !typeParameters.isEmpty()) {\n+        if (!typeParameters.isEmpty()) {\n@@ -325,1 +406,1 @@\n-                if (tp.interfaceBounds() != null) for (var is : tp.interfaceBounds())\n+                for (var is : tp.interfaceBounds())\n@@ -340,1 +421,1 @@\n-            if (superinterfaceSignatures != null) for (var in : superinterfaceSignatures)\n+            for (var in : superinterfaceSignatures)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SignaturesImpl.java","additions":94,"deletions":13,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -78,3 +78,7 @@\n-    \/\/ native libraries loaded by the boot class loader\n-    private static final NativeLibraries NATIVE_LIBS\n-        = NativeLibraries.newInstance(null);\n+    \/\/ Holder has the field(s) that need to be initialized during JVM bootstrap even if\n+    \/\/ the outer is aot-initialized.\n+    private static class Holder {\n+        \/\/ native libraries loaded by the boot class loader\n+        private static final NativeLibraries NATIVE_LIBS\n+            = NativeLibraries.newInstance(null);\n+    }\n@@ -107,1 +111,1 @@\n-        return NATIVE_LIBS;\n+        return Holder.NATIVE_LIBS;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/BootLoader.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -156,1 +156,1 @@\n-            if (loadedLibraryNames.contains(name)) {\n+            if (Holder.loadedLibraryNames.contains(name)) {\n@@ -206,1 +206,1 @@\n-            loadedLibraryNames.add(name);\n+            Holder.loadedLibraryNames.add(name);\n@@ -246,0 +246,5 @@\n+    \/\/ Called at the end of AOTCache assembly phase.\n+    public void clear() {\n+        libraries.clear();\n+    }\n+\n@@ -371,1 +376,1 @@\n-                if (!loadedLibraryNames.remove(name)) {\n+                if (!Holder.loadedLibraryNames.remove(name)) {\n@@ -398,2 +403,5 @@\n-    \/\/ All native libraries we've loaded.\n-    private static final Set<String> loadedLibraryNames =\n+    \/\/ Holder has the fields that need to be initialized during JVM bootstrap even if\n+    \/\/ the outer is aot-initialized.\n+    static class Holder {\n+        \/\/ All native libraries we've loaded.\n+        private static final Set<String> loadedLibraryNames =\n@@ -401,0 +409,1 @@\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/NativeLibraries.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-        int getDigits(char[] digits);\n+        int getDigits(byte[] digits);\n@@ -176,1 +176,1 @@\n-        public int getDigits(char[] digits) {\n+        public int getDigits(byte[] digits) {\n@@ -258,1 +258,1 @@\n-        public int getDigits(char[] digits) {\n+        public int getDigits(byte[] digits) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/FloatingDecimal.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -35,0 +36,1 @@\n+@AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/MathUtils.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,5 +50,7 @@\n-    private static final int IS_DUMPING_ARCHIVE              = 1 << 0;\n-    private static final int IS_DUMPING_METHOD_HANDLES       = 1 << 1;\n-    private static final int IS_DUMPING_STATIC_ARCHIVE       = 1 << 2;\n-    private static final int IS_LOGGING_LAMBDA_FORM_INVOKERS = 1 << 3;\n-    private static final int IS_USING_ARCHIVE                = 1 << 4;\n+    private static final int IS_DUMPING_AOT_LINKED_CLASSES   = 1 << 0;\n+    private static final int IS_DUMPING_ARCHIVE              = 1 << 1;\n+    private static final int IS_DUMPING_METHOD_HANDLES       = 1 << 2;\n+    private static final int IS_DUMPING_STATIC_ARCHIVE       = 1 << 3;\n+    private static final int IS_LOGGING_LAMBDA_FORM_INVOKERS = 1 << 4;\n+    private static final int IS_USING_ARCHIVE                = 1 << 5;\n+\n@@ -85,0 +87,4 @@\n+    public static boolean isDumpingAOTLinkedClasses() {\n+        return (configStatus & IS_DUMPING_AOT_LINKED_CLASSES) != 0;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/CDS.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,3 +67,3 @@\n-    public static int utfLen(String str, int countNonZeroAscii) {\n-        int utflen = str.length();\n-        for (int i = utflen - 1; i >= countNonZeroAscii; i--) {\n+    public static long utfLen(String str, int countNonZeroAscii) {\n+        long utflen = str.length();\n+        for (int i = (int)utflen - 1; i >= countNonZeroAscii; i--) {\n@@ -71,1 +72,1 @@\n-                utflen += (c >= 0x800) ? 2 : 1;\n+                utflen += (c >= 0x800) ? 2L : 1L;\n@@ -93,2 +94,1 @@\n-        \/\/ The check strLen > CONSTANT_POOL_UTF8_MAX_BYTES above ensures that utfLen can't overflow here.\n-        int utfLen = utfLen(str, 0);\n+        long utfLen = utfLen(str, 0);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ModifiedUtf.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -208,1 +208,4 @@\n-                    writer.println(\"    - parking to wait for \" + decorateObject(parkBlocker));\n+                    String suffix = (snapshot.parkBlockerOwner() instanceof Thread owner)\n+                            ? \", owner #\"  + owner.threadId()\n+                            : \"\";\n+                    writer.println(\"    - parking to wait for \" + decorateObject(parkBlocker) + suffix);\n@@ -338,0 +341,3 @@\n+            if (snapshot.parkBlockerOwner() instanceof Thread owner) {\n+                jsonWriter.writeProperty(\"owner\", owner.threadId());\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ThreadDumper.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -47,0 +47,2 @@\n+    \/\/ the owner of the blockerObject when the object is park blocker and is AbstractOwnableSynchronizer\n+    private Thread parkBlockerOwner;\n@@ -73,1 +75,3 @@\n-            snapshot.blocker = new ThreadBlocker(snapshot.blockerTypeOrdinal, snapshot.blockerObject);\n+            snapshot.blocker = new ThreadBlocker(snapshot.blockerTypeOrdinal,\n+                                                 snapshot.blockerObject,\n+                                                 snapshot.parkBlockerOwner);\n@@ -75,0 +79,1 @@\n+            snapshot.parkBlockerOwner = null;\n@@ -107,0 +112,7 @@\n+    \/**\n+     * Returns the owner of the parkBlocker if the parkBlocker is an AbstractOwnableSynchronizer.\n+     *\/\n+    Thread parkBlockerOwner() {\n+        return (blocker != null && blocker.type == BlockerLockType.PARK_BLOCKER) ? blocker.owner : null;\n+    }\n+\n@@ -214,1 +226,1 @@\n-    private record ThreadBlocker(BlockerLockType type, Object obj) {\n+    private record ThreadBlocker(BlockerLockType type, Object obj, Thread owner) {\n@@ -217,2 +229,2 @@\n-        ThreadBlocker(int typeOrdinal, Object obj) {\n-            this(lockTypeValues[typeOrdinal], obj);\n+        ThreadBlocker(int typeOrdinal, Object obj, Thread owner) {\n+            this(lockTypeValues[typeOrdinal], obj, owner);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ThreadSnapshot.java","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -33,19 +33,28 @@\n-\/\/\/ Indicates that the static initializer of this class or interface\n-\/\/\/ (its `<clinit>` method) is allowed to be _AOT-initialized_,\n-\/\/\/ because its author considers it safe to execute during the AOT\n-\/\/\/ assembly phase.\n-\/\/\/\n-\/\/\/ This annotation directs the VM to expect that normal execution of Java code\n-\/\/\/ during the assembly phase could trigger initialization of this class,\n-\/\/\/ and if that happens, to store the resulting static field values in the\n-\/\/\/ AOT cache.  (These fields happen to be allocated in the `Class` mirror.)\n-\/\/\/\n-\/\/\/ During the production run, the static initializer (`<clinit>`) of\n-\/\/\/ this class or interface will not be executed, if it was already\n-\/\/\/ executed during the assembling of the AOT being used to start the\n-\/\/\/ production run.  In that case the resulting static field states\n-\/\/\/ (within the `Class` mirror) were already stored in the AOT cache.\n-\/\/\/\n-\/\/\/ Currently, this annotation is used mainly for supporting AOT\n-\/\/\/ linking of APIs, including bootstrap methods, in the\n-\/\/\/ `java.lang.invoke` package.\n+\/\/\/ Indicates that the annotated class or interface is allowed to be _AOT-initialized_,\n+\/\/\/ because its author considers it safe to execute the static initializer of\n+\/\/\/ the class or interface during the AOT assembly phase.\n+\/\/\/\n+\/\/\/ For a class or interface _X_ annotated with `@AOTSafeClassInitializer`, it will\n+\/\/\/ be initialized in the AOT assembly phase under two circumstances:\n+\/\/\/\n+\/\/\/ 1. If _X_ was initialized during the AOT training run, the JVM will proactively\n+\/\/\/    initialize _X_ in the assembly phase.\n+\/\/\/ 2. If _X_ was not initialized during the AOT training run, the initialization of\n+\/\/\/    _X_ can still be triggered by normal execution of Java code in the assembly\n+\/\/\/    phase. At present this is usually the result of performing AOT optimizations for\n+\/\/\/    the `java.lang.invoke` package but it may include other cases as well.\n+\/\/\/\n+\/\/\/ If _X_ is initialized during the AOT assembly phase, the VM will store\n+\/\/\/ the values of the static fields of _X_ in the AOT cache. Consequently,\n+\/\/\/ during the production run that uses this AOT cache, the static initializer\n+\/\/\/ (`<clinit>`) of _X_ will not be executed. _X_ will appear to be in the\n+\/\/\/ \"initialized\" state and all the cached values of the static field of _X_\n+\/\/\/ will be available immediately upon the start of the prodcution run.\n+\/\/\/\n+\/\/\/ Currently, this annotation is used mainly for two purposes:\n+\/\/\/\n+\/\/\/ - To AOT-initialize complex static fields whose values are always the same\n+\/\/\/   across JVM lifetimes. One example is the tables of constant values\n+\/\/\/   in the `jdk.internal.math.MathUtils` class.\n+\/\/\/ - To support AOT linking of APIs, including bootstrap methods, in the\n+\/\/\/   `java.lang.invoke` package.\n@@ -65,0 +74,2 @@\n+\/\/\/ 5. In addition, any class\/interface annotated with `@AOTSafeClassInitializer`\n+\/\/\/    that was initialized during the training run is proactively initialized.\n@@ -115,3 +126,1 @@\n-\/\/\/ test.  As noted above, all supertypes of _X_ must also have the\n-\/\/\/ `@AOTSafeClassInitializer` annotation, and must also be safe for AOT\n-\/\/\/ initialization.\n+\/\/\/ test.\n@@ -124,6 +133,5 @@\n-\/\/\/ In the assembly phase, `classFileParser.cpp` performs checks on the annotated\n-\/\/\/ classes, to ensure all supertypes of this class that must be initialized when\n-\/\/\/ this class is initialized have the `@AOTSafeClassInitializer` annotation.\n-\/\/\/ Otherwise, a [ClassFormatError] will be thrown. (This assembly phase restriction\n-\/\/\/ allows module patching and instrumentation to work on annotated classes when\n-\/\/\/ AOT is not enabled)\n+\/\/\/ Before adding this annotation to a class _X_, the author must determine\n+\/\/\/ that it's safe to execute the static initializer of _X_ during the AOT\n+\/\/\/ assembly phase. In addition, all supertypes of _X_ must also have this\n+\/\/\/ annotation. If a supertype of _X_ is found to be missing this annotation,\n+\/\/\/ the AOT assembly phase will fail.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/AOTSafeClassInitializer.java","additions":36,"deletions":28,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -184,0 +184,10 @@\n+            \/\/ From RFC 8446 \"Implementations\n+            \/\/ MUST NOT send Handshake and Alert records that have a zero-length\n+            \/\/ TLSInnerPlaintext.content; if such a message is received, the\n+            \/\/ receiving implementation MUST terminate the connection with an\n+            \/\/ \"unexpected_message\" alert.\"\n+            if (m.remaining() == 0) {\n+                throw context.fatal(Alert.UNEXPECTED_MESSAGE,\n+                        \"Alert fragments must not be zero length.\");\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/Alert.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -39,0 +39,5 @@\n+ * <p>\n+ * Note: Per RFC 8446, if no \"signature_algorithms_cert\" extension is\n+ *       present, then the \"signature_algorithms\" extension also applies to\n+ *       signatures appearing in certificates.\n+ *       See {@code SignatureAlgorithmsExtension} for details.\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertSignAlgsExtension.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -804,2 +804,5 @@\n-                \/\/ Need no status update.\n-                bufferedFragments.add(hsf);\n+                \/\/ Make sure it's not a retransmitted message\n+                if (hsf.recordEpoch > handshakeEpoch) {\n+                    bufferedFragments.add(hsf);\n+                    flightIsReady = holes.isEmpty();\n+                }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/DTLSInputRecord.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1926,1 +1926,1 @@\n-                for (; i > 0 && pt.get(i) == 0; i--);\n+                for (; i >= pos && pt.get(i) == 0; i--);\n@@ -1928,1 +1928,1 @@\n-                if (i < (pos + 1)) {\n+                if (i < pos) {\n@@ -2444,4 +2444,3 @@\n-                for (; i > 0 && pt.get(i) == 0; i--) {\n-                    \/\/ blank\n-                }\n-                if (i < (pos + 1)) {\n+                for (; i >= pos && pt.get(i) == 0; i--);\n+\n+                if (i < pos) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLCipher.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -281,0 +281,2 @@\n+                \/\/ use getOutputSize to avoid a ShortBufferException\n+                \/\/ from providers that require oversized buffers. See JDK-8368514.\n@@ -282,1 +284,1 @@\n-                        data.remaining() - GCM_TAG_LEN \/ 8);\n+                        c.getOutputSize(data.remaining()));\n@@ -294,1 +296,1 @@\n-                    SSLLogger.fine(\"Decryption failed.\" + e.getMessage());\n+                    SSLLogger.fine(\"Decryption failed.\" + e);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SessionTicketExtension.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.ArrayList;\n@@ -194,11 +195,1 @@\n-            int vectorLen = SignatureScheme.sizeInRecord() *\n-                    chc.localSupportedSignAlgs.size();\n-            byte[] extData = new byte[vectorLen + 2];\n-            ByteBuffer m = ByteBuffer.wrap(extData);\n-            Record.putInt16(m, vectorLen);\n-            for (SignatureScheme ss : chc.localSupportedSignAlgs) {\n-                Record.putInt16(m, ss.id);\n-            }\n-\n-            \/\/ Update the context.\n-            chc.handshakeExtensions.put(\n+            return produceNetworkLoad(chc,\n@@ -206,3 +197,1 @@\n-                    new SignatureSchemesSpec(chc.localSupportedSignAlgs));\n-\n-            return extData;\n+                    SSLExtension.CH_SIGNATURE_ALGORITHMS_CERT);\n@@ -394,13 +383,3 @@\n-            \/\/ localSupportedSignAlgs has been already updated when we\n-            \/\/ set the negotiated protocol.\n-            int vectorLen = SignatureScheme.sizeInRecord()\n-                    * shc.localSupportedSignAlgs.size();\n-            byte[] extData = new byte[vectorLen + 2];\n-            ByteBuffer m = ByteBuffer.wrap(extData);\n-            Record.putInt16(m, vectorLen);\n-            for (SignatureScheme ss : shc.localSupportedSignAlgs) {\n-                Record.putInt16(m, ss.id);\n-            }\n-\n-            \/\/ Update the context.\n-            shc.handshakeExtensions.put(\n+            \/\/ localSupportedSignAlgs and localSupportedCertSignAlgs have been\n+            \/\/ already updated when we set the negotiated protocol.\n+            return produceNetworkLoad(shc,\n@@ -408,3 +387,1 @@\n-                    new SignatureSchemesSpec(shc.localSupportedSignAlgs));\n-\n-            return extData;\n+                    SSLExtension.CR_SIGNATURE_ALGORITHMS_CERT);\n@@ -549,0 +526,41 @@\n+\n+    \/**\n+     * Produce network load and update context.\n+     *\n+     * @param hc HandshakeContext\n+     * @param signatureAlgorithmsExt \"signature_algorithms\" extension\n+     * @param signatureAlgorithmsCertExt \"signature_algorithms_cert\"\n+     *         extension\n+     * @return network load as byte array\n+     *\/\n+    private static byte[] produceNetworkLoad(\n+            HandshakeContext hc, SSLExtension signatureAlgorithmsExt,\n+            SSLExtension signatureAlgorithmsCertExt) throws IOException {\n+\n+        List<SignatureScheme> sigAlgs;\n+\n+        \/\/ If we don't produce \"signature_algorithms_cert\" extension, then\n+        \/\/ the \"signature_algorithms\" extension should contain signatures\n+        \/\/ supported for both: handshake signatures and certificate signatures.\n+        if (hc.sslConfig.isAvailable(signatureAlgorithmsCertExt)) {\n+            sigAlgs = hc.localSupportedSignAlgs;\n+        } else {\n+            sigAlgs = new ArrayList<>(hc.localSupportedSignAlgs);\n+            sigAlgs.retainAll(hc.localSupportedCertSignAlgs);\n+        }\n+\n+        int vectorLen = SignatureScheme.sizeInRecord() * sigAlgs.size();\n+        byte[] extData = new byte[vectorLen + 2];\n+        ByteBuffer m = ByteBuffer.wrap(extData);\n+        Record.putInt16(m, vectorLen);\n+\n+        for (SignatureScheme ss : sigAlgs) {\n+            Record.putInt16(m, ss.id);\n+        }\n+\n+        \/\/ Update the context.\n+        hc.handshakeExtensions.put(\n+                signatureAlgorithmsExt, new SignatureSchemesSpec(sigAlgs));\n+\n+        return extData;\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SignatureAlgorithmsExtension.java","additions":48,"deletions":30,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-dataVersion=179\n+dataVersion=180\n@@ -150,1 +150,1 @@\n-BG=BGN\n+BG=BGN;2025-12-31-22-00-00;EUR\n@@ -196,1 +196,1 @@\n-CW=ANG;2025-04-01-04-00-00;XCG\n+CW=XCG\n@@ -513,1 +513,1 @@\n-SX=ANG;2025-04-01-04-00-00;XCG\n+SX=XCG\n","filename":"src\/java.base\/share\/data\/currency\/CurrencyData.properties","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -70,0 +70,4 @@\n+#if !defined(_AIX)\n+  \/* The \/proc file system on AIX does not contain open system files\n+   * like \/dev\/random. Therefore we use a different approach and do\n+   * not need isAsciiDigit() or FD_DIR *\/\n@@ -76,7 +80,5 @@\n-#if defined(_AIX)\n-  \/* AIX does not understand '\/proc\/self' - it requires the real process ID *\/\n-  #define FD_DIR aix_fd_dir\n-#elif defined(_ALLBSD_SOURCE)\n-  #define FD_DIR \"\/dev\/fd\"\n-#else\n-  #define FD_DIR \"\/proc\/self\/fd\"\n+  #if defined(_ALLBSD_SOURCE)\n+    #define FD_DIR \"\/dev\/fd\"\n+  #else\n+    #define FD_DIR \"\/proc\/self\/fd\"\n+  #endif\n@@ -88,0 +90,13 @@\n+#if defined(_AIX)\n+    \/* On AIX, we cannot rely on proc file system iteration to find all open files. Since\n+     * iteration over all possible file descriptors, and subsequently closing them, can\n+     * take a very long time, we use a bulk close via `ioctl` that is available on AIX.\n+     * Since we hard-close, we need to make sure to keep the fail pipe file descriptor\n+     * alive until the exec call. Therefore we mark the fail pipe fd with close on exec\n+     * like the other OSes do, but then proceed to hard-close file descriptors beyond that.\n+     *\/\n+    if (fcntl(FAIL_FILENO + 1, F_CLOSEM, 0) == -1 ||\n+        (markCloseOnExec(FAIL_FILENO) == -1 && errno != EBADF)) {\n+        return -1;\n+    }\n+#else\n@@ -96,6 +111,0 @@\n-#if defined(_AIX)\n-    \/* AIX does not understand '\/proc\/self' - it requires the real process ID *\/\n-    char aix_fd_dir[32];     \/* the pid has at most 19 digits *\/\n-    snprintf(aix_fd_dir, 32, \"\/proc\/%d\/fd\", getpid());\n-#endif\n-\n@@ -117,0 +126,1 @@\n+#endif\n@@ -409,0 +419,4 @@\n+    \/* For AIX: The code in markDescriptorsCloseOnExec() relies on the current\n+     * semantic of this function. When this point here is reached only the\n+     * FDs 0,1,2 and 3 are further used until the exec() or the exit(-1). *\/\n+\n","filename":"src\/java.base\/unix\/native\/libjava\/childproc.c","additions":27,"deletions":13,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,0 +78,12 @@\n+\n+    @Override\n+    public void drawString(String str, int x, int y) {\n+        str = RasterPrinterJob.removeControlChars(str);\n+        super.drawString(str, x, y);\n+    }\n+\n+    @Override\n+    public void drawString(String str, float x, float y) {\n+        str = RasterPrinterJob.removeControlChars(str);\n+        super.drawString(str, x, y);\n+    }\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CPrinterGraphics.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -82,1 +82,6 @@\n-        return new ProxyPrintGraphics(printJobDelegate.getGraphics(), this);\n+        Graphics g = printJobDelegate.getGraphics();\n+        if (g == null) { \/\/ PrintJob.end() has been called.\n+            return null;\n+        } else {\n+            return new ProxyPrintGraphics(g, this);\n+        }\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/PrintJob2D.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2473,5 +2473,8 @@\n-    \/* On-screen drawString renders most control chars as the missing glyph\n-     * and have the non-zero advance of that glyph.\n-     * Exceptions are \\t, \\n and \\r which are considered zero-width.\n-     * This is a utility method used by subclasses to remove them so we\n-     * don't have to worry about platform or font specific handling of them.\n+    \/**\n+     * Removes ignorable whitespace from the specified text, so that there\n+     * is no need for platform-specific or font-specific custom whitespace\n+     * handling, and so that these characters are not treated like control\n+     * characters which are printed as the missing glyph.\n+     *\n+     * @param s the text to process\n+     * @return the input text, with ignorable whitespace (if any) removed\n@@ -2479,1 +2482,1 @@\n-    protected String removeControlChars(String s) {\n+    public static String removeControlChars(String s) {\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/RasterPrinterJob.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,0 +76,1 @@\n+import sun.print.RasterPrinterJob;\n@@ -850,1 +851,1 @@\n-             str = wPrinterJob.removeControlChars(str);\n+             str = RasterPrinterJob.removeControlChars(str);\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WPathGraphics.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1205,8 +1205,0 @@\n-    \/**\n-     * Remove control characters.\n-     *\/\n-    @Override\n-    protected String removeControlChars(String str) {\n-        return super.removeControlChars(str);\n-    }\n-\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WPrinterJob.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -164,18 +164,1 @@\n-            values = LintCategory.newEmptySet();\n-\n-            Source source = Source.instance(context);\n-            if (source.compareTo(Source.JDK9) >= 0) {\n-                values.add(LintCategory.DEP_ANN);\n-            }\n-            if (Source.Feature.REDUNDANT_STRICTFP.allowedInSource(source)) {\n-                values.add(LintCategory.STRICTFP);\n-            }\n-            values.add(LintCategory.REQUIRES_TRANSITIVE_AUTOMATIC);\n-            values.add(LintCategory.OPENS);\n-            values.add(LintCategory.MODULE);\n-            values.add(LintCategory.REMOVAL);\n-            if (!options.isSet(Option.PREVIEW)) {\n-                values.add(LintCategory.PREVIEW);\n-            }\n-            values.add(LintCategory.IDENTITY);\n-            values.add(LintCategory.INCUBATING);\n+            values = getDefaults();\n@@ -196,0 +179,17 @@\n+    \/\/ Obtain the set of on-by-default categories. Note that for a few categories,\n+    \/\/ whether the category is on-by-default depends on other compiler options.\n+    private EnumSet<LintCategory> getDefaults() {\n+        EnumSet<LintCategory> defaults = LintCategory.newEmptySet();\n+        Source source = Source.instance(context);\n+        Stream.of(LintCategory.values())\n+          .filter(lc ->\n+            switch (lc) {\n+                case DEP_ANN  -> source.compareTo(Source.JDK9) >= 0;\n+                case STRICTFP -> Source.Feature.REDUNDANT_STRICTFP.allowedInSource(source);\n+                case PREVIEW  -> !options.isSet(Option.PREVIEW);\n+                default       -> lc.enabledByDefault;\n+            })\n+          .forEach(defaults::add);\n+        return defaults;\n+    }\n+\n@@ -224,1 +224,1 @@\n-        CLASSFILE(\"classfile\", false),\n+        CLASSFILE(\"classfile\", false, false),\n@@ -241,1 +241,1 @@\n-        DEP_ANN(\"dep-ann\"),\n+        DEP_ANN(\"dep-ann\", true, true),\n@@ -271,1 +271,1 @@\n-        IDENTITY(\"identity\", true, \"synchronization\"),\n+        IDENTITY(\"identity\", true, true, \"synchronization\"),\n@@ -279,1 +279,1 @@\n-        INCUBATING(\"incubating\", false),\n+        INCUBATING(\"incubating\", false, true),\n@@ -294,1 +294,1 @@\n-        MODULE(\"module\"),\n+        MODULE(\"module\", true, true),\n@@ -299,1 +299,1 @@\n-        OPENS(\"opens\"),\n+        OPENS(\"opens\", true, true),\n@@ -307,1 +307,1 @@\n-        OPTIONS(\"options\", false),\n+        OPTIONS(\"options\", false, false),\n@@ -315,1 +315,1 @@\n-        OUTPUT_FILE_CLASH(\"output-file-clash\", false),\n+        OUTPUT_FILE_CLASH(\"output-file-clash\", false, false),\n@@ -333,1 +333,1 @@\n-        PATH(\"path\", false),\n+        PATH(\"path\", false, false),\n@@ -337,0 +337,3 @@\n+         *\n+         * <p>\n+         * This category is not supported by {@code @SuppressWarnings}.\n@@ -338,1 +341,1 @@\n-        PROCESSING(\"processing\"),\n+        PROCESSING(\"processing\", false, false),\n@@ -348,1 +351,1 @@\n-        REMOVAL(\"removal\"),\n+        REMOVAL(\"removal\", true, true),\n@@ -358,1 +361,1 @@\n-        REQUIRES_TRANSITIVE_AUTOMATIC(\"requires-transitive-automatic\"),\n+        REQUIRES_TRANSITIVE_AUTOMATIC(\"requires-transitive-automatic\", true, true),\n@@ -373,1 +376,1 @@\n-        STRICTFP(\"strictfp\"),\n+        STRICTFP(\"strictfp\", true, true),\n@@ -403,1 +406,1 @@\n-        PREVIEW(\"preview\"),\n+        PREVIEW(\"preview\", true, true),\n@@ -411,1 +414,1 @@\n-            this(option, true);\n+            this(option, true, false);\n@@ -414,1 +417,1 @@\n-        LintCategory(String option, boolean annotationSuppression, String... aliases) {\n+        LintCategory(String option, boolean annotationSuppression, boolean enabledByDefault, String... aliases) {\n@@ -417,0 +420,1 @@\n+            this.enabledByDefault = enabledByDefault;\n@@ -453,0 +457,6 @@\n+\n+        \/**\n+         * Is this category included in the default set of enabled lint categories?\n+         * Note that for some categories, command line options can alter this at runtime.\n+         *\/\n+        public final boolean enabledByDefault;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":44,"deletions":34,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.util.List;\n@@ -46,0 +47,1 @@\n+import java.util.TreeMap;\n@@ -487,1 +489,2 @@\n-        private final String LINT_KEY_FORMAT = SMALL_INDENT + SMALL_INDENT + \"%-\" +\n+        private final String HELP_INDENT = SMALL_INDENT + SMALL_INDENT;\n+        private final String LINT_KEY_FORMAT = HELP_INDENT + \"%-\" +\n@@ -492,0 +495,2 @@\n+\n+            \/\/ Print header\n@@ -493,0 +498,2 @@\n+\n+            \/\/ Print \"all\" option\n@@ -497,4 +504,14 @@\n-            LintCategory.options().forEach(ident -> log.printRawLines(WriterKind.STDOUT,\n-                              String.format(LINT_KEY_FORMAT,\n-                                            ident,\n-                                            log.localize(PrefixKind.JAVAC, \"opt.Xlint.desc.\" + ident))));\n+\n+            \/\/ Alphabetize all the category names and their aliases together, and then list them with their descriptions\n+            TreeMap<String, String> keyMap = new TreeMap<>();\n+            Stream.of(LintCategory.values()).forEach(lc ->\n+              lc.optionList.stream()\n+                .forEach(key -> keyMap.put(key,\n+                  String.format(LINT_KEY_FORMAT,\n+                                key,\n+                                key.equals(lc.option) ?\n+                                  log.localize(PrefixKind.JAVAC, \"opt.Xlint.desc.\" + key) :\n+                                  log.localize(PrefixKind.JAVAC, \"opt.Xlint.alias.of\", lc.option, key)))));\n+            keyMap.values().forEach(desc -> log.printRawLines(WriterKind.STDOUT, desc));\n+\n+            \/\/ Print \"none\" option\n@@ -505,0 +522,15 @@\n+\n+            \/\/ Show which lint categories are enabled by default\n+            log.printRawLines(WriterKind.STDOUT, log.localize(PrefixKind.JAVAC, \"opt.help.lint.enabled.by.default\"));\n+            String defaults = Stream.of(LintCategory.values())\n+              .filter(lc -> lc.enabledByDefault)\n+              .map(lc -> lc.option)\n+              .sorted()\n+              .collect(Collectors.joining(\", \"));\n+            log.printRawLines(WriterKind.STDOUT,\n+                              String.format(\"%s%s.\", HELP_INDENT, defaults));\n+\n+            \/\/ Add trailing blurb about aliases\n+            List<String> aliasExample = LintCategory.IDENTITY.optionList;\n+            log.printRawLines(WriterKind.STDOUT,\n+                              log.localize(PrefixKind.JAVAC, \"opt.help.lint.footer\", aliasExample.get(0), aliasExample.get(1)));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/Option.java","additions":37,"deletions":5,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -171,1 +171,2 @@\n-    Enable recommended warning categories\n+    Enable recommended lint warning categories. In this release, all\\n\\\n+    available lint warning categories are recommended.\n@@ -173,1 +174,1 @@\n-    Enable all warning categories\n+    Enable all lint warning categories\n@@ -175,1 +176,1 @@\n-    Disable all warning categories\n+    Disable all lint warning categories\n@@ -180,3 +181,4 @@\n-    Warning categories to enable or disable, separated by comma.\\n\\\n-    Precede a key by ''-'' to disable the specified warning.\\n\\\n-    Use --help-lint to see the supported keys.\n+    Lint warning categories to enable or disable, separated by comma.\\n\\\n+    Precede a key by ''-'' to disable the specified category. Use\\n\\\n+    ''--help-lint'' to show supported keys and which categories are\\n\\\n+    enabled by default.\n@@ -294,7 +296,0 @@\n-# L10N: do not localize: identity synchronization\n-javac.opt.Xlint.desc.synchronization=\\\n-    Warn about synchronization attempts on instances of value-based classes.\\n\\\n-\\                         This key is a deprecated alias for ''identity'', which has the same uses and\\n\\\n-\\                         effects. Users are encouraged to use the ''identity'' category for all future\\n\\\n-\\                         and existing uses of ''synchronization''.\n-\n@@ -304,0 +299,4 @@\n+javac.opt.Xlint.alias.of=\\\n+    Deprecated alias for ''{0}'' with an identical effect. Users are encouraged to use\\n\\\n+\\                         ''{0}'' instead of ''{1}'' for all current and future uses.\n+\n@@ -337,0 +336,5 @@\n+javac.opt.help.lint.enabled.by.default=\\\n+    The following lint warning categories are enabled by default:\n+javac.opt.help.lint.footer=\\\n+    Categories and their aliases can be used interchangeably; for example, the flag\\n\\\n+    ''-Xlint:{0},{1}'' would be redundant.\n@@ -349,0 +353,1 @@\n+# L10N: do not localize: ''preview''\n@@ -350,1 +355,1 @@\n-    Enable preview language features.\\n\\\n+    Enable preview language features. Also disables the ''preview'' lint category.\\n\\\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac.properties","additions":19,"deletions":14,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -144,1 +144,2 @@\n- * strings that can be used with {@code @SuppressWarnings}.\n+ * strings that are recognized by <em>javac<\/em> in {@code @SuppressWarnings}\n+ * annotations. Unrecognized strings are ignored.\n@@ -155,1 +156,0 @@\n- * <tr><th scope=\"row\">{@code classfile}            <td>issues related to classfile contents\n@@ -168,1 +168,0 @@\n- * <tr><th scope=\"row\">{@code incubating}           <td>use of incubating modules\n@@ -176,1 +175,0 @@\n- * <tr><th scope=\"row\">{@code path}                 <td>invalid path elements on the command line\n@@ -180,1 +178,0 @@\n- * <tr><th scope=\"row\">{@code restricted}           <td>use of restricted methods\n@@ -183,0 +180,1 @@\n+ * <tr><th scope=\"row\">{@code restricted}           <td>use of restricted methods\n@@ -190,5 +188,3 @@\n- * <tr><th scope=\"row\">{@code synchronization}      <td>synchronization attempts on instances of value-based classes;\n- *                                                      this key is a deprecated alias for {@code identity}, which has\n- *                                                      the same uses and effects. Users are encouraged to use the\n- *                                                      {@code identity} category for all future and existing uses of\n- *                                                      {@code synchronization}\n+ * <tr><th scope=\"row\">{@code synchronization}      <td>deprecated alias for {@code identity} with an identical effect.\n+ *                                                      Users are encouraged to use {@code identity} instead of\n+ *                                                      {@code synchronization} for all current and future uses.\n@@ -210,0 +206,19 @@\n+ * All of the non-{@code docllint:} strings listed above may also be used with the {@code -Xlint} command line flag.\n+ * The {@code -Xlint} flag also supports these strings not supported by {@code @SuppressWarnings}:\n+ *\n+ * <table class=\"striped\">\n+ *     <caption>Strings supported by {@code -Xlint} but not {@code SuppressWarnings}<\/caption>\n+ * <thead>\n+ * <tr><th>String<th>Warnings Related To ...\n+ * <\/thead>\n+ * <tbody>\n+ * <tr><th scope=\"row\">{@code classfile}            <td>issues related to classfile contents\n+ * <tr><th scope=\"row\">{@code incubating}           <td>use of incubating modules\n+ * <tr><th scope=\"row\">{@code options}              <td>issues relating to use of command line options\n+ * <tr><th scope=\"row\">{@code output-file-clash}    <td>output files being overwritten due to filename clashes\n+ * <tr><th scope=\"row\">{@code path}                 <td>invalid path elements on the command line\n+ * <tr><th scope=\"row\">{@code processing}           <td>issues regarding annotation processing\n+ * <tr><th scope=\"row\">{@code restricted}           <td>use of restricted methods\n+ * <\/tbody>\n+ * <\/table>\n+ *\n","filename":"src\/jdk.compiler\/share\/classes\/module-info.java","additions":25,"deletions":10,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -211,2 +211,2 @@\n-:   Enables preview language features. Used in conjunction with either\n-    [`-source`](#option-source) or [`--release`](#option-release).\n+:   Enables preview language features. Also disables the `preview` lint category.\n+    Used in conjunction with either [`-source`](#option-source) or [`--release`](#option-release).\n@@ -560,2 +560,2 @@\n-:   Enables all recommended warnings. In this release, enabling all available\n-    warnings is recommended.\n+:   Enables recommended lint warning categories. In this release, all available\n+    lint warning categories are recommended.\n@@ -564,1 +564,1 @@\n-:   Enables and\/or disables warning categories using the one or more of the keys described\n+:   Enables and\/or disables lint warning categories using the one or more of the keys described\n@@ -651,4 +651,3 @@\n-    -   `synchronization`: Warns about synchronization attempts on instances\n-        of value-based classes. This key is a deprecated alias for `identity`,\n-        which has the same uses and effects. Users are encouraged to use the\n-        `identity` category for all future and existing uses of `synchronization`.\n+    -   `synchronization`: Deprecated alias for `identity` with an identical\n+        effect. Users are encouraged to use `identity` instead of `synchronization`\n+        for all current and future uses.\n@@ -670,3 +669,7 @@\n-    With the exception of `all` and `none`, the keys can be used with\n-    the `@SuppressWarnings` annotation to suppress warnings in a part\n-    of the source code being compiled.\n+    The keys listed above may be used in `@SuppressWarnings` annotations to suppress\n+    warnings within the annotated declaration, with the exception of: `all`, `none`,\n+    `classfile`, `incubating`, `options`, `output-file-clash`, `processing`, and `path`.\n+\n+    By default, the following lint warning categories are enabled: `dep-ann`, `identity`,\n+    `incubating`, `module`, `opens`, `preview`, `removal`, `requires-transitive-automatic`,\n+    and `strictfp`.\n","filename":"src\/jdk.compiler\/share\/man\/javac.md","additions":15,"deletions":12,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -170,3 +171,18 @@\n-        P11Key p11BaseKey = convertKey(baseKey, (isExtract ? \"IKM\" : \"PRK\") +\n-                \" could not be converted to a token key for HKDF derivation.\");\n-\n+        long baseKeyID;\n+        P11Key p11BaseKey = null;\n+        try {\n+            p11BaseKey = convertKey(baseKey, (isExtract ? \"IKM\" : \"PRK\") +\n+                    \" could not be converted to a token key for HKDF derivation.\");\n+            baseKeyID = p11BaseKey.getKeyID();\n+        } catch (ProviderException pe) {\n+            if (p11BaseKey != null) {\n+                throw pe;\n+            }\n+            \/\/ special handling for FIPS mode when key cannot be imported\n+            if (isExtract) {\n+                baseKeyID = convertKeyToData(baseKey, pe);\n+            } else {\n+                throw pe;\n+            }\n+        }\n+        Session session = null;\n@@ -176,19 +192,0 @@\n-        if (salt instanceof SecretKeySpec) {\n-            saltType = CKF_HKDF_SALT_DATA;\n-            saltBytes = salt.getEncoded();\n-        } else if (salt != EMPTY_KEY) {\n-            \/\/ consolidateKeyMaterial returns a salt from the token.\n-            saltType = CKF_HKDF_SALT_KEY;\n-            p11SaltKey = (P11Key.P11SecretKey) salt;\n-            assert p11SaltKey.token == token : \"salt must be from the same \" +\n-                    \"token as service.\";\n-        }\n-\n-        long derivedKeyClass = isData ? CKO_DATA : CKO_SECRET_KEY;\n-        CK_ATTRIBUTE[] attrs = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_CLASS, derivedKeyClass),\n-                new CK_ATTRIBUTE(CKA_KEY_TYPE, ki.keyType),\n-                new CK_ATTRIBUTE(CKA_VALUE_LEN, outLen)\n-        };\n-        Session session = null;\n-        long baseKeyID = p11BaseKey.getKeyID();\n@@ -196,0 +193,17 @@\n+            if (salt instanceof SecretKeySpec) {\n+                saltType = CKF_HKDF_SALT_DATA;\n+                saltBytes = salt.getEncoded();\n+            } else if (salt != EMPTY_KEY) {\n+                \/\/ consolidateKeyMaterial returns a salt from the token.\n+                saltType = CKF_HKDF_SALT_KEY;\n+                p11SaltKey = (P11Key.P11SecretKey) salt;\n+                assert p11SaltKey.token == token : \"salt must be from the same \" +\n+                        \"token as service.\";\n+            }\n+\n+            long derivedKeyClass = isData ? CKO_DATA : CKO_SECRET_KEY;\n+            CK_ATTRIBUTE[] attrs = new CK_ATTRIBUTE[] {\n+                    new CK_ATTRIBUTE(CKA_CLASS, derivedKeyClass),\n+                    new CK_ATTRIBUTE(CKA_KEY_TYPE, ki.keyType),\n+                    new CK_ATTRIBUTE(CKA_VALUE_LEN, outLen)\n+            };\n@@ -233,1 +247,5 @@\n-            p11BaseKey.releaseKeyID();\n+            if (p11BaseKey != null) {\n+                p11BaseKey.releaseKeyID();\n+            } else {\n+                destroyDataObject(baseKeyID);\n+            }\n@@ -238,0 +256,39 @@\n+    private void destroyDataObject(long baseKeyID) {\n+        try {\n+            Session session = token.getObjSession();\n+            try {\n+                token.p11.C_DestroyObject(session.id(), baseKeyID);\n+            } finally {\n+                token.releaseSession(session);\n+            }\n+        } catch (PKCS11Exception e) {\n+            throw new ProviderException(\"Failed to destroy IKM data object.\", e);\n+        }\n+    }\n+\n+    private long convertKeyToData(SecretKey key, ProviderException pe) {\n+        if (!\"RAW\".equalsIgnoreCase(key.getFormat())) {\n+            throw pe;\n+        }\n+        byte[] keyBytes = key.getEncoded();\n+        if (keyBytes == null) {\n+            throw pe;\n+        }\n+        CK_ATTRIBUTE[] inputAttributes = new CK_ATTRIBUTE[]{\n+                new CK_ATTRIBUTE(CKA_CLASS, CKO_DATA),\n+                new CK_ATTRIBUTE(CKA_VALUE, keyBytes),\n+        };\n+        try {\n+            Session session = token.getObjSession();\n+            try {\n+                return token.p11.C_CreateObject(session.id(), inputAttributes);\n+            } finally {\n+                token.releaseSession(session);\n+            }\n+        } catch (PKCS11Exception e) {\n+            throw new ProviderException(\"Failed to create IKM data object.\", e);\n+        } finally {\n+            Arrays.fill(keyBytes, (byte)0);\n+        }\n+    }\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11HKDF.java","additions":80,"deletions":23,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -369,1 +369,5 @@\n-            if (length > 0) {\n+            \/*\n+             * seed could be NULL here when SecureRandom.generateSeed() is\n+             * called with a length of zero.\n+             *\/\n+            if ((length > 0) || (seed == NULL)) {\n","filename":"src\/jdk.crypto.mscapi\/windows\/native\/libsunmscapi\/security.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -154,6 +154,0 @@\n-  public BasicLock locker() {\n-    if (Assert.ASSERTS_ENABLED) {\n-      Assert.that(hasLocker(), \"check\");\n-    }\n-    return new BasicLock(valueAsAddress());\n-  }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Mark.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-          initialize(VM.getVM().getTypeDataBase());\n@@ -44,7 +43,0 @@\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type  = db.lookupType(\"BasicLock\");\n-    displacedHeaderField = type.getCIntegerField(\"_metadata\");\n-  }\n-\n-  private static CIntegerField displacedHeaderField;\n-\n@@ -54,4 +46,0 @@\n-\n-  public Mark displacedHeader() {\n-    return new Mark(addr.addOffsetTo(displacedHeaderField.getOffset()));\n-  }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/BasicLock.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1,164 +0,0 @@\n-\/*\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.tools.*;\n-import sun.jvm.hotspot.utilities.*;\n-\n-\/**\n-   We don't run any of the \"standard\" SA command line tools for sanity\n-   check. This is because the standard tools print addresses in hex\n-   which could change legally. Also, textual comparison of output may\n-   not match because of other reasons as well. This tool checks\n-   validity of threads and frames logically. This class has reference\n-   frame names from \"known\" threads. The debuggee is assumed to run\n-   \"LibprocTest.java\".\n-*\/\n-\n-public class LibprocClient extends Tool {\n-\n-   public void run() {\n-      \/\/ try to get VM version and check\n-      String version = VM.getVM().getVMRelease();\n-      Assert.that(version.startsWith(\"1.5\"), \"1.5 expected\");\n-\n-      \/\/ try getting threads\n-      Threads threads = VM.getVM().getThreads();\n-      boolean mainTested = false;\n-\n-      \/\/ check frames of each thread\n-      for (JavaThread cur = threads.first(); cur != null; cur = cur.next()) {\n-         if (cur.isJavaThread()) {\n-             String name = cur.getThreadName();\n-             \/\/ testing of basic frame walking for all threads\n-             for (JavaVFrame vf = getLastJavaVFrame(cur); vf != null; vf = vf.javaSender()) {\n-                checkFrame(vf);\n-             }\n-\n-             \/\/ special testing for \"known\" threads. For now, only \"main\" thread.\n-             if (name.equals(\"main\")) {\n-                checkMainThread(cur);\n-                mainTested = true;\n-             }\n-         }\n-      }\n-      Assert.that(mainTested, \"main thread missing\");\n-   }\n-\n-   public static void main(String[] args) {\n-      try {\n-         LibprocClient lc = new LibprocClient();\n-         lc.start(args);\n-         lc.getAgent().detach();\n-         System.out.println(\"\\nPASSED\\n\");\n-      } catch (Exception exp) {\n-         System.out.println(\"\\nFAILED\\n\");\n-         exp.printStackTrace();\n-      }\n-   }\n-\n-   \/\/ -- Internals only below this point\n-   private static JavaVFrame getLastJavaVFrame(JavaThread cur) {\n-      RegisterMap regMap = cur.newRegisterMap(true);\n-      Frame f = cur.getCurrentFrameGuess();\n-      if (f == null) {\n-         System.err.println(\" (Unable to get a top most frame)\");\n-         return null;\n-      }\n-      VFrame vf = VFrame.newVFrame(f, regMap, cur, true, true);\n-      if (vf == null) {\n-         System.err.println(\" (Unable to create vframe for topmost frame guess)\");\n-         return null;\n-      }\n-      if (vf.isJavaFrame()) {\n-         return (JavaVFrame) vf;\n-      }\n-      return (JavaVFrame) vf.javaSender();\n-   }\n-\n-   private void checkMethodSignature(Symbol sig) {\n-      SignatureIterator itr = new SignatureIterator(sig) {\n-                                  public void doBool  () {}\n-                                  public void doChar  () {}\n-                                  public void doFloat () {}\n-                                  public void doDouble() {}\n-                                  public void doByte  () {}\n-                                  public void doShort () {}\n-                                  public void doInt   () {}\n-                                  public void doLong  () {}\n-                                  public void doVoid  () {}\n-                                  public void doObject(int begin, int end) {}\n-                                  public void doArray (int begin, int end) {}\n-                              };\n-      \/\/ this will throw RuntimeException for any invalid item in signature.\n-      itr.iterate();\n-   }\n-\n-   private void checkBCI(Method m, int bci) {\n-      if (! m.isNative()) {\n-         byte[] buf = m.getByteCode();\n-         Assert.that(bci >= 0 && bci < buf.length, \"invalid bci, not in code range\");\n-         if (m.hasLineNumberTable()) {\n-           int lineNum = m.getLineNumberFromBCI(bci);\n-           Assert.that(lineNum >= 0, \"expecting non-negative line number\");\n-         }\n-      }\n-   }\n-\n-   private void checkMethodHolder(Method method) {\n-      Klass klass = method.getMethodHolder();\n-      Assert.that(klass != null, \"expecting non-null instance klass\");\n-   }\n-\n-   private void checkFrame(JavaVFrame vf) {\n-      Method method = vf.getMethod();\n-      Assert.that(method != null, \"expecting a non-null method here\");\n-      Assert.that(method.getName() != null, \"expecting non-null method name\");\n-      checkMethodHolder(method);\n-      checkMethodSignature(method.getSignature());\n-      checkBCI(method, vf.getBCI());\n-   }\n-\n-   \/\/ from the test case LibprocTest.java - in the main thread we\n-   \/\/ should see frames as below\n-   private static String[] mainThreadMethods = new String[] {\n-                             \"java.lang.Object.wait(long)\",\n-                             \"java.lang.Object.wait()\",\n-                             \"LibprocTest.main(java.lang.String[])\"\n-                          };\n-\n-   private void checkMainThread(JavaThread thread) {\n-      checkFrames(thread, mainThreadMethods);\n-   }\n-\n-   private void checkFrames(JavaThread thread, String[] expectedMethodNames) {\n-      int i = 0;\n-      for (JavaVFrame vf = getLastJavaVFrame(thread); vf != null; vf = vf.javaSender(), i++) {\n-         Method m = vf.getMethod();\n-         Assert.that(m.externalNameAndSignature().equals(expectedMethodNames[i]),\n-                     \"expected frame missing\");\n-      }\n-   }\n-}\n","filename":"src\/jdk.hotspot.agent\/test\/libproc\/LibprocClient.java","additions":0,"deletions":164,"binary":false,"changes":164,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/**\n-  This is test case run by debuggee for running LibprocClient.java.\n-*\/\n-\n-public class LibprocTest {\n-   public static void main(String[] args) throws Exception {\n-      String myStr = \"\";\n-      System.out.println(\"main start\");\n-      synchronized(myStr) {\n-         try {\n-            myStr.wait();\n-         } catch (InterruptedException ee) {\n-         }\n-      }\n-      System.out.println(\"main end\");\n-   }\n-}\n","filename":"src\/jdk.hotspot.agent\/test\/libproc\/LibprocTest.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,30 +0,0 @@\n-#\n-# Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-#\n-\n-all:\n-\tjavac LibprocTest.java\n-\tjavac -classpath ..\/..\/build\/classes LibprocClient.java\n-\n-clean:\n-\trm -rf *.class\n","filename":"src\/jdk.hotspot.agent\/test\/libproc\/Makefile","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -1,42 +0,0 @@\n-#\n-# Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#   \n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#   \n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#  \n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#   \n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#  \n-#\n-\n-After making any changes to libproc.so, the shell scripts described\n-below can be run to verify that it does not break Java Serviceability\n-Agent.\n-\n-Setup:\n-\n-You need to have jdk 1.5 installed to run this test. Set environment\n-variable SA_JAVA to point to the java executable of jdk\n-1.5. Otherwise, the script picks-up 'java' from PATH.\n-\n-Running the tests:\n-\n-run libproctest.sh (32-bit debuggee) and libproctest64.sh (64-bit\n-debuggee)\n-\n-Interpreting result:\n-\n-\"PASSED\" or \"FAILED\" is printed in standard output.\n","filename":"src\/jdk.hotspot.agent\/test\/libproc\/README","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -1,66 +0,0 @@\n-#!\/bin\/ksh\n-\n-#\n-# Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#  \n-#\n-\n-# This script is used to run consistency check of Serviceabilty Agent\n-# after making any libproc.so changes. Prints \"PASSED\" or \"FAILED\" in\n-# standard output.\n-\n-usage() {\n-    echo \"usage: $0\"\n-    echo \"   set SA_JAVA to be java executable from JDK 1.5\"\n-    exit 1 \n-}\n-\n-STARTDIR=`dirname $0`\n-\n-if [ \"$1\" == \"-help\" ]; then\n-    usage\n-fi\n-\n-if [ \"x$SA_JAVA\" = \"x\" ]; then\n-   SA_JAVA=java\n-fi\n-\n-# create java process with test case\n-tmp=\/tmp\/libproctest\n-rm -f $tmp\n-$SA_JAVA -classpath $STARTDIR LibprocTest > $tmp &\n-pid=$!\n-while [ ! -s $tmp ] ; do\n-  # Kludge alert!\n-  sleep 2\n-done\n-\n-# dump core\n-gcore $pid\n-kill -9 $pid\n-\n-\n-# run libproc client\n-$SA_JAVA -showversion -cp $STARTDIR\/..\/..\/build\/classes::$STARTDIR\/..\/sa.jar:$STARTDIR LibprocClient x core.$pid\n-\n-# delete core\n-rm -f core.$pid\n","filename":"src\/jdk.hotspot.agent\/test\/libproc\/libproctest.sh","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"},{"patch":"@@ -1,65 +0,0 @@\n-#!\/bin\/ksh\n-\n-#\n-# Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#  \n-#\n-\n-# This script is used to run consistency check of Serviceabilty Agent\n-# after making any libproc.so changes. Prints \"PASSED\" or \"FAILED\" in\n-# standard output.\n-\n-usage() {\n-    echo \"usage: $0\"\n-    echo \"   set SA_JAVA to be the java executable from JDK 1.5\"\n-    exit 1   \n-}\n-\n-if [ \"$1\" == \"-help\" ]; then\n-    usage\n-fi\n-\n-if [ \"x$SA_JAVA\" = \"x\" ]; then\n-   SA_JAVA=java\n-fi\n-\n-STARTDIR=`dirname $0`\n-\n-# create java process with test case\n-tmp=\/tmp\/libproctest\n-rm -f $tmp\n-$SA_JAVA -d64 -classpath $STARTDIR LibprocTest > $tmp &\n-pid=$!\n-while [ ! -s $tmp ] ; do\n-  # Kludge alert!\n-  sleep 2\n-done\n-\n-# dump core\n-gcore $pid\n-kill -9 $pid\n-\n-# run libproc client\n-$SA_JAVA -d64 -showversion -cp $STARTDIR\/..\/..\/build\/classes::$STARTDIR\/..\/sa.jar:$STARTDIR LibprocClient x core.$pid\n-\n-# delete core\n-rm -f core.$pid\n","filename":"src\/jdk.hotspot.agent\/test\/libproc\/libproctest64.sh","additions":0,"deletions":65,"binary":false,"changes":65,"status":"deleted"},{"patch":"@@ -52,1 +52,1 @@\n-    public static boolean enabled() {\n+    public static boolean shouldCommit(long duration) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/MethodTraceEvent.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.jfr.internal.query.Function.FunctionFactory;\n@@ -140,0 +141,2 @@\n+    public FunctionFactory functionFactory;\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/Field.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,4 @@\n+    interface FunctionFactory {\n+        Function newFunction();\n+    }\n+\n@@ -42,1 +46,1 @@\n-    public static Function create(Field field) {\n+    public static FunctionFactory createFactory(Field field) {\n@@ -46,1 +50,1 @@\n-            return new FirstNonNull();\n+            return () -> new FirstNonNull();\n@@ -49,1 +53,1 @@\n-            return new Container(new ArrayList<>());\n+            return () -> new Container(new ArrayList<>());\n@@ -53,1 +57,1 @@\n-            return new Container(new LinkedHashSet<>());\n+            return () -> new Container(new LinkedHashSet<>());\n@@ -58,1 +62,1 @@\n-                return new TimeDifference();\n+                return () -> new TimeDifference();\n@@ -60,1 +64,1 @@\n-                return new Difference();\n+                return () -> new Difference();\n@@ -66,1 +70,1 @@\n-                return new TimespanFunction(new StandardDeviation());\n+                return () -> new TimespanFunction(new StandardDeviation());\n@@ -68,1 +72,1 @@\n-                return new StandardDeviation();\n+                return () -> new StandardDeviation();\n@@ -74,1 +78,1 @@\n-                return new TimespanFunction(new Median());\n+                return () -> new TimespanFunction(new Median());\n@@ -76,1 +80,1 @@\n-                return new Median();\n+                return () -> new Median();\n@@ -86,1 +90,0 @@\n-\n@@ -95,1 +98,1 @@\n-            return new Maximum();\n+            return () -> new Maximum();\n@@ -98,1 +101,1 @@\n-            return new Minimum();\n+            return () -> new Minimum();\n@@ -102,1 +105,1 @@\n-                return new SumDuration();\n+                return () -> new SumDuration();\n@@ -105,1 +108,1 @@\n-                return new SumDouble();\n+                return () -> new SumDouble();\n@@ -108,1 +111,1 @@\n-                return new SumLong();\n+                return () -> new SumLong();\n@@ -113,1 +116,1 @@\n-            return new First();\n+            return () -> new First();\n@@ -116,1 +119,1 @@\n-            return new LastBatch(field);\n+            return () -> new LastBatch(field);\n@@ -119,1 +122,1 @@\n-            return new Last();\n+            return () -> new Last();\n@@ -123,1 +126,1 @@\n-                return new AverageDuration();\n+                return () -> new AverageDuration();\n@@ -125,1 +128,1 @@\n-                return new Average();\n+                return () -> new Average();\n@@ -129,1 +132,1 @@\n-            return new Count();\n+            return () -> new Count();\n@@ -132,1 +135,1 @@\n-            return new Unique();\n+            return () -> new Unique();\n@@ -134,1 +137,1 @@\n-        return new Null();\n+        return () -> new Null();\n@@ -510,2 +513,1 @@\n-    private static Function createPercentile(Field field, double percentile) {\n-        Percentile p = new Percentile(percentile);\n+    private static FunctionFactory createPercentile(Field field, double percentile) {\n@@ -513,1 +515,1 @@\n-            return new TimespanFunction(p);\n+            return () -> new TimespanFunction(new Percentile(percentile));\n@@ -515,1 +517,1 @@\n-            return p;\n+            return () -> new Percentile(percentile);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/Function.java","additions":31,"deletions":29,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -125,0 +125,3 @@\n+        for (Field field : fields) {\n+            field.functionFactory = Function.createFactory(field);\n+        }\n@@ -171,1 +174,1 @@\n-            functions[i] = Function.create(fields.get(i));\n+            functions[i] = fields.get(i).functionFactory.newFunction();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/Histogram.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -293,1 +293,1 @@\n-table = \"COLUMN 'Start', 'GC ID', 'Type', 'Heap Before GC', 'Heap After GC', 'Longest Pause'\n+table = \"COLUMN 'Start', 'GC ID', 'GC Name', 'Heap Before GC', 'Heap After GC', 'Longest Pause'\n@@ -295,1 +295,1 @@\n-         SELECT G.startTime, gcId, [Y|O].eventType.label,\n+         SELECT G.startTime, gcId, G.name,\n@@ -300,3 +300,1 @@\n-                GCHeapSummary AS A,\n-                OldGarbageCollection AS O,\n-                YoungGarbageCollection AS Y\n+                GCHeapSummary AS A\n@@ -304,1 +302,1 @@\n-         GROUP BY gcId ORDER BY G.startTime\"\n+         GROUP BY gcId ORDER BY gcId\"\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/view.ini","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-        if (MethodTraceEvent.enabled() && JVM.getEventWriter() != null) {\n+        if (MethodTraceEvent.shouldCommit(duration) && JVM.getEventWriter() != null) {\n@@ -69,1 +69,1 @@\n-        if (MethodTraceEvent.enabled() && JVM.getEventWriter() != null) {\n+        if (MethodTraceEvent.shouldCommit(duration) && JVM.getEventWriter() != null) {\n@@ -80,1 +80,1 @@\n-        if (MethodTraceEvent.enabled()) {\n+        if (MethodTraceEvent.shouldCommit(duration)) {\n@@ -99,1 +99,1 @@\n-        if (MethodTraceEvent.enabled()) {\n+        if (MethodTraceEvent.shouldCommit(duration)) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/tracing\/MethodTracer.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.io.UncheckedIOException;\n@@ -70,1 +71,1 @@\n-    private DesktopIntegration(BuildEnv env, LinuxPackage pkg, LinuxLauncher launcher) throws IOException {\n+    private DesktopIntegration(BuildEnv env, LinuxPackage pkg, LinuxLauncher launcher) {\n@@ -91,4 +92,8 @@\n-            final Path nullPath = null;\n-            if (curIconResource.get().saveToFile(nullPath) != OverridableResource.Source.DefaultResource) {\n-                \/\/ This launcher has custom icon configured.\n-                withDesktopFile = true;\n+            try {\n+                if (curIconResource.get().saveToFile((Path)null) != OverridableResource.Source.DefaultResource) {\n+                    \/\/ This launcher has custom icon configured.\n+                    withDesktopFile = true;\n+                }\n+            } catch (IOException ex) {\n+                \/\/ Should never happen as `saveToFile((Path)null)` should not perform any actual I\/O operations.\n+                throw new UncheckedIOException(ex);\n@@ -138,1 +143,1 @@\n-            }).map(toFunction(l -> {\n+            }).map(l -> {\n@@ -140,1 +145,1 @@\n-            })).toList();\n+            }).toList();\n@@ -144,1 +149,1 @@\n-    static ShellCustomAction create(BuildEnv env, Package pkg) throws IOException {\n+    static ShellCustomAction create(BuildEnv env, Package pkg) {\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/DesktopIntegration.java","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -28,7 +28,0 @@\n-import jdk.jpackage.internal.model.LinuxPackage;\n-import jdk.jpackage.internal.model.PackagerException;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.model.LinuxDebPackage;\n-import java.io.IOException;\n-import java.nio.file.FileVisitResult;\n-import java.nio.file.Files;\n@@ -36,9 +29,0 @@\n-import java.nio.file.SimpleFileVisitor;\n-import java.nio.file.attribute.BasicFileAttributes;\n-\n-import java.nio.file.attribute.PosixFilePermission;\n-import java.nio.file.attribute.PosixFilePermissions;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n@@ -46,10 +30,4 @@\n-import java.util.Set;\n-import java.util.function.Function;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-import jdk.internal.util.OperatingSystem;\n-import jdk.jpackage.internal.model.AppImageLayout;\n-import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n-import static jdk.jpackage.internal.model.StandardPackageType.LINUX_DEB;\n+import jdk.jpackage.internal.model.LinuxDebPackage;\n+import jdk.jpackage.internal.model.PackagerException;\n+import jdk.jpackage.internal.model.StandardPackageType;\n+import jdk.jpackage.internal.util.Result;\n@@ -59,4 +37,0 @@\n-    private static final String TOOL_DPKG_DEB = \"dpkg-deb\";\n-    private static final String TOOL_DPKG = \"dpkg\";\n-    private static final String TOOL_FAKEROOT = \"fakeroot\";\n-\n@@ -67,317 +41,0 @@\n-    @Override\n-    protected void doValidate(BuildEnv env, LinuxPackage pkg) throws ConfigException {\n-\n-        \/\/ Show warning if license file is missing\n-        if (pkg.licenseFile().isEmpty()) {\n-            Log.verbose(I18N.getString(\"message.debs-like-licenses\"));\n-        }\n-    }\n-\n-    @Override\n-    protected List<ToolValidator> getToolValidators() {\n-        return Stream.of(TOOL_DPKG_DEB, TOOL_DPKG, TOOL_FAKEROOT).map(\n-                ToolValidator::new).toList();\n-    }\n-\n-    @Override\n-    protected void createConfigFiles(Map<String, String> replacementData,\n-            BuildEnv env, LinuxPackage pkg) throws IOException {\n-        prepareProjectConfig(replacementData, env, pkg);\n-        adjustPermissionsRecursive(env.appImageDir());\n-    }\n-\n-    @Override\n-    protected Path buildPackageBundle(BuildEnv env, LinuxPackage pkg,\n-            Path outputParentDir) throws PackagerException, IOException {\n-        return buildDeb(env, pkg, outputParentDir);\n-    }\n-\n-    private static final Pattern PACKAGE_NAME_REGEX = Pattern.compile(\"^(^\\\\S+):\");\n-\n-    @Override\n-    protected void initLibProvidersLookup(LibProvidersLookup libProvidersLookup) {\n-\n-        libProvidersLookup.setPackageLookup(file -> {\n-            Path realPath = file.toRealPath();\n-\n-            try {\n-                \/\/ Try the real path first as it works better on newer Ubuntu versions\n-                return findProvidingPackages(realPath);\n-            } catch (IOException ex) {\n-                \/\/ Try the default path if differ\n-                if (!realPath.toString().equals(file.toString())) {\n-                    return findProvidingPackages(file);\n-                } else {\n-                    throw ex;\n-                }\n-            }\n-        });\n-    }\n-\n-    private static Stream<String> findProvidingPackages(Path file) throws IOException {\n-        \/\/\n-        \/\/ `dpkg -S` command does glob pattern lookup. If not the absolute path\n-        \/\/ to the file is specified it might return mltiple package names.\n-        \/\/ Even for full paths multiple package names can be returned as\n-        \/\/ it is OK for multiple packages to provide the same file. `\/opt`\n-        \/\/ directory is such an example. So we have to deal with multiple\n-        \/\/ packages per file situation.\n-        \/\/\n-        \/\/ E.g.: `dpkg -S libc.so.6` command reports three packages:\n-        \/\/ libc6-x32: \/libx32\/libc.so.6\n-        \/\/ libc6:amd64: \/lib\/x86_64-linux-gnu\/libc.so.6\n-        \/\/ libc6-i386: \/lib32\/libc.so.6\n-        \/\/ `:amd64` is architecture suffix and can (should) be dropped.\n-        \/\/ Still need to decide what package to choose from three.\n-        \/\/ libc6-x32 and libc6-i386 both depend on libc6:\n-        \/\/ $ dpkg -s libc6-x32\n-        \/\/ Package: libc6-x32\n-        \/\/ Status: install ok installed\n-        \/\/ Priority: optional\n-        \/\/ Section: libs\n-        \/\/ Installed-Size: 10840\n-        \/\/ Maintainer: Ubuntu Developers <ubuntu-devel-discuss@lists.ubuntu.com>\n-        \/\/ Architecture: amd64\n-        \/\/ Source: glibc\n-        \/\/ Version: 2.23-0ubuntu10\n-        \/\/ Depends: libc6 (= 2.23-0ubuntu10)\n-        \/\/\n-        \/\/ We can dive into tracking dependencies, but this would be overly\n-        \/\/ complicated.\n-        \/\/\n-        \/\/ For simplicity lets consider the following rules:\n-        \/\/ 1. If there is one item in `dpkg -S` output, accept it.\n-        \/\/ 2. If there are multiple items in `dpkg -S` output and there is at\n-        \/\/  least one item with the default arch suffix (DEB_ARCH),\n-        \/\/  accept only these items.\n-        \/\/ 3. If there are multiple items in `dpkg -S` output and there are\n-        \/\/  no with the default arch suffix (DEB_ARCH), accept all items.\n-        \/\/ So lets use this heuristics: don't accept packages for whom\n-        \/\/  `dpkg -p` command fails.\n-        \/\/ 4. Arch suffix should be stripped from accepted package names.\n-        \/\/\n-\n-        Set<String> archPackages = new HashSet<>();\n-        Set<String> otherPackages = new HashSet<>();\n-\n-        var debArch = LinuxPackageArch.getValue(LINUX_DEB);\n-\n-        Executor.of(TOOL_DPKG, \"-S\", file.toString())\n-                .saveOutput(true).executeExpectSuccess()\n-                .getOutput().forEach(line -> {\n-                    Matcher matcher = PACKAGE_NAME_REGEX.matcher(line);\n-                    if (matcher.find()) {\n-                        String name = matcher.group(1);\n-                        if (name.endsWith(\":\" + debArch)) {\n-                            \/\/ Strip arch suffix\n-                            name = name.substring(0,\n-                                    name.length() - (debArch.length() + 1));\n-                            archPackages.add(name);\n-                        } else {\n-                            otherPackages.add(name);\n-                        }\n-                    }\n-                });\n-\n-        if (!archPackages.isEmpty()) {\n-            return archPackages.stream();\n-        }\n-        return otherPackages.stream();\n-    }\n-\n-    @Override\n-    protected List<ConfigException> verifyOutputBundle(BuildEnv env, LinuxPackage pkg,\n-            Path packageBundle) {\n-        List<ConfigException> errors = new ArrayList<>();\n-\n-        String controlFileName = \"control\";\n-\n-        List<PackageProperty> properties = List.of(\n-                new PackageProperty(\"Package\", pkg.packageName(),\n-                        \"APPLICATION_PACKAGE\", controlFileName),\n-                new PackageProperty(\"Version\", ((LinuxDebPackage)pkg).versionWithRelease(),\n-                        \"APPLICATION_VERSION_WITH_RELEASE\",\n-                        controlFileName),\n-                new PackageProperty(\"Architecture\", pkg.arch(), \"APPLICATION_ARCH\", controlFileName));\n-\n-        List<String> cmdline = new ArrayList<>(List.of(TOOL_DPKG_DEB, \"-f\",\n-                packageBundle.toString()));\n-        properties.forEach(property -> cmdline.add(property.name));\n-        try {\n-            Map<String, String> actualValues = Executor.of(cmdline.toArray(String[]::new))\n-                    .saveOutput(true)\n-                    .executeExpectSuccess()\n-                    .getOutput().stream()\n-                            .map(line -> line.split(\":\\\\s+\", 2))\n-                            .collect(Collectors.toMap(\n-                                    components -> components[0],\n-                                    components -> components[1]));\n-            properties.forEach(property -> errors.add(property.verifyValue(\n-                    actualValues.get(property.name))));\n-        } catch (IOException ex) {\n-            \/\/ Ignore error as it is not critical. Just report it.\n-            Log.verbose(ex);\n-        }\n-\n-        return errors;\n-    }\n-\n-    \/*\n-     * set permissions with a string like \"rwxr-xr-x\"\n-     *\n-     * This cannot be directly backport to 22u which is built with 1.6\n-     *\/\n-    private void setPermissions(Path file, String permissions) {\n-        Set<PosixFilePermission> filePermissions =\n-                PosixFilePermissions.fromString(permissions);\n-        try {\n-            if (Files.exists(file)) {\n-                Files.setPosixFilePermissions(file, filePermissions);\n-            }\n-        } catch (IOException ex) {\n-            Log.error(ex.getMessage());\n-            Log.verbose(ex);\n-        }\n-\n-    }\n-\n-    public static boolean isDebian() {\n-        \/\/ we are just going to run \"dpkg -s coreutils\" and assume Debian\n-        \/\/ or deritive if no error is returned.\n-        try {\n-            Executor.of(TOOL_DPKG, \"-s\", \"coreutils\").executeExpectSuccess();\n-            return true;\n-        } catch (IOException e) {\n-            \/\/ just fall thru\n-        }\n-        return false;\n-    }\n-\n-    private void adjustPermissionsRecursive(Path dir) throws IOException {\n-        Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {\n-            @Override\n-            public FileVisitResult visitFile(Path file,\n-                    BasicFileAttributes attrs)\n-                    throws IOException {\n-                if (file.endsWith(\".so\") || !Files.isExecutable(file)) {\n-                    setPermissions(file, \"rw-r--r--\");\n-                } else if (Files.isExecutable(file)) {\n-                    setPermissions(file, \"rwxr-xr-x\");\n-                }\n-                return FileVisitResult.CONTINUE;\n-            }\n-\n-            @Override\n-            public FileVisitResult postVisitDirectory(Path dir, IOException e)\n-                    throws IOException {\n-                if (e == null) {\n-                    setPermissions(dir, \"rwxr-xr-x\");\n-                    return FileVisitResult.CONTINUE;\n-                } else {\n-                    \/\/ directory iteration failed\n-                    throw e;\n-                }\n-            }\n-        });\n-    }\n-\n-    private class DebianFile {\n-\n-        DebianFile(Path dstFilePath, String comment) {\n-            this.dstFilePath = dstFilePath;\n-            this.comment = comment;\n-        }\n-\n-        DebianFile setExecutable() {\n-            permissions = \"rwxr-xr-x\";\n-            return this;\n-        }\n-\n-        void create(Map<String, String> data, Function<String, OverridableResource> resourceFactory)\n-                throws IOException {\n-            resourceFactory.apply(\"template.\" + dstFilePath.getFileName().toString())\n-                    .setCategory(I18N.getString(comment))\n-                    .setSubstitutionData(data)\n-                    .saveToFile(dstFilePath);\n-            if (permissions != null) {\n-                setPermissions(dstFilePath, permissions);\n-            }\n-        }\n-\n-        private final Path dstFilePath;\n-        private final String comment;\n-        private String permissions;\n-    }\n-\n-    private void prepareProjectConfig(Map<String, String> data, BuildEnv env, LinuxPackage pkg) throws IOException {\n-\n-        Path configDir = env.appImageDir().resolve(\"DEBIAN\");\n-        List<DebianFile> debianFiles = new ArrayList<>();\n-        debianFiles.add(new DebianFile(\n-                configDir.resolve(\"control\"),\n-                \"resource.deb-control-file\"));\n-        debianFiles.add(new DebianFile(\n-                configDir.resolve(\"preinst\"),\n-                \"resource.deb-preinstall-script\").setExecutable());\n-        debianFiles.add(new DebianFile(\n-                configDir.resolve(\"prerm\"),\n-                \"resource.deb-prerm-script\").setExecutable());\n-        debianFiles.add(new DebianFile(\n-                configDir.resolve(\"postinst\"),\n-                \"resource.deb-postinstall-script\").setExecutable());\n-        debianFiles.add(new DebianFile(\n-                configDir.resolve(\"postrm\"),\n-                \"resource.deb-postrm-script\").setExecutable());\n-\n-        ((LinuxDebPackage)pkg).relativeCopyrightFilePath().ifPresent(copyrightFile -> {\n-            debianFiles.add(new DebianFile(env.appImageDir().resolve(copyrightFile),\n-                    \"resource.copyright-file\"));\n-        });\n-\n-        for (DebianFile debianFile : debianFiles) {\n-            debianFile.create(data, env::createResource);\n-        }\n-    }\n-\n-    @Override\n-    protected Map<String, String> createReplacementData(BuildEnv env, LinuxPackage pkg) throws IOException {\n-        Map<String, String> data = new HashMap<>();\n-\n-        String licenseText = pkg.licenseFile().map(toFunction(Files::readString)).orElse(\"Unknown\");\n-\n-        data.put(\"APPLICATION_MAINTAINER\", ((LinuxDebPackage) pkg).maintainer());\n-        data.put(\"APPLICATION_SECTION\", pkg.category().orElseThrow());\n-        data.put(\"APPLICATION_COPYRIGHT\", pkg.app().copyright());\n-        data.put(\"APPLICATION_LICENSE_TEXT\", licenseText);\n-        data.put(\"APPLICATION_ARCH\", pkg.arch());\n-        data.put(\"APPLICATION_INSTALLED_SIZE\", Long.toString(\n-                AppImageLayout.toPathGroup(env.appImageLayout()).sizeInBytes() >> 10));\n-        data.put(\"APPLICATION_HOMEPAGE\", pkg.aboutURL().map(\n-                value -> \"Homepage: \" + value).orElse(\"\"));\n-        data.put(\"APPLICATION_VERSION_WITH_RELEASE\", ((LinuxDebPackage) pkg).versionWithRelease());\n-\n-        return data;\n-    }\n-\n-    private Path buildDeb(BuildEnv env, LinuxPackage pkg, Path outdir) throws IOException {\n-        Path outFile = outdir.resolve(pkg.packageFileNameWithSuffix());\n-        Log.verbose(I18N.format(\"message.outputting-to-location\", outFile.toAbsolutePath()));\n-\n-        List<String> cmdline = new ArrayList<>();\n-        cmdline.addAll(List.of(TOOL_FAKEROOT, TOOL_DPKG_DEB));\n-        if (Log.isVerbose()) {\n-            cmdline.add(\"--verbose\");\n-        }\n-        cmdline.addAll(List.of(\"-b\", env.appImageDir().toString(),\n-                outFile.toAbsolutePath().toString()));\n-\n-        \/\/ run dpkg\n-        RetryExecutor.retryOnKnownErrorMessage(\n-                \"semop(1): encountered an error: Invalid argument\").execute(\n-                        cmdline.toArray(String[]::new));\n-\n-        Log.verbose(I18N.format(\"message.output-to-location\", outFile.toAbsolutePath()));\n-\n-        return outFile;\n-    }\n-\n@@ -395,2 +52,13 @@\n-    public boolean supported(boolean runtimeInstaller) {\n-        return OperatingSystem.isLinux() && (new ToolValidator(TOOL_DPKG_DEB).validate() == null);\n+    public Path execute(Map<String, ? super Object> params, Path outputParentDir) throws PackagerException {\n+\n+        return Packager.<LinuxDebPackage>build().outputDir(outputParentDir)\n+                .pkg(LinuxFromParams.DEB_PACKAGE.fetchFrom(params))\n+                .env(BuildEnvFromParams.BUILD_ENV.fetchFrom(params))\n+                .pipelineBuilderMutatorFactory((env, pkg, outputDir) -> {\n+                    return new LinuxDebPackager(env, pkg, outputDir, sysEnv.orElseThrow());\n+                }).execute(LinuxPackagingPipeline.build());\n+    }\n+\n+    @Override\n+    protected Result<LinuxDebSystemEnvironment> sysEnv() {\n+        return sysEnv;\n@@ -401,1 +69,4 @@\n-        return isDebian();\n+        return sysEnv.value()\n+                .map(LinuxSystemEnvironment::nativePackageType)\n+                .map(StandardPackageType.LINUX_DEB::equals)\n+                .orElse(false);\n@@ -403,0 +74,2 @@\n+\n+    private final Result<LinuxDebSystemEnvironment> sysEnv = LinuxDebSystemEnvironment.create(SYS_ENV);\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxDebBundler.java","additions":23,"deletions":350,"binary":false,"changes":373,"status":"modified"},{"patch":"@@ -0,0 +1,344 @@\n+\/*\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.model.StandardPackageType.LINUX_DEB;\n+import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermission;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.PackagingPipeline.PackageTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.PrimaryTaskID;\n+import jdk.jpackage.internal.model.AppImageLayout;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.LinuxDebPackage;\n+\n+final class LinuxDebPackager extends LinuxPackager<LinuxDebPackage> {\n+\n+    LinuxDebPackager(BuildEnv env, LinuxDebPackage pkg, Path outputDir, LinuxDebSystemEnvironment sysEnv) {\n+        super(env, pkg, outputDir, sysEnv);\n+        this.sysEnv = Objects.requireNonNull(sysEnv);\n+    }\n+\n+    @Override\n+    protected void createConfigFiles(Map<String, String> replacementData) throws IOException {\n+        prepareProjectConfig(replacementData);\n+        adjustPermissionsRecursive();\n+    }\n+\n+    @Override\n+    protected void initLibProvidersLookup(LibProvidersLookup libProvidersLookup) {\n+\n+        libProvidersLookup.setPackageLookup(file -> {\n+            Path realPath = file.toRealPath();\n+\n+            try {\n+                \/\/ Try the real path first as it works better on newer Ubuntu versions\n+                return findProvidingPackages(realPath, sysEnv.dpkg());\n+            } catch (IOException ex) {\n+                \/\/ Try the default path if differ\n+                if (!realPath.equals(file)) {\n+                    return findProvidingPackages(file, sysEnv.dpkg());\n+                } else {\n+                    throw ex;\n+                }\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected List<? extends Exception> findErrorsInOutputPackage() throws IOException {\n+        List<ConfigException> errors = new ArrayList<>();\n+\n+        var controlFileName = \"control\";\n+\n+        List<PackageProperty> properties = List.of(\n+                new PackageProperty(\"Package\", pkg.packageName(),\n+                        \"APPLICATION_PACKAGE\", controlFileName),\n+                new PackageProperty(\"Version\", pkg.versionWithRelease(),\n+                        \"APPLICATION_VERSION_WITH_RELEASE\",\n+                        controlFileName),\n+                new PackageProperty(\"Architecture\", pkg.arch(), \"APPLICATION_ARCH\", controlFileName));\n+\n+        List<String> cmdline = new ArrayList<>(List.of(\n+                sysEnv.dpkgdeb().toString(), \"-f\", outputPackageFile().toString()));\n+\n+        properties.forEach(property -> cmdline.add(property.name));\n+\n+        Map<String, String> actualValues = Executor.of(cmdline.toArray(String[]::new))\n+                .saveOutput(true)\n+                .executeExpectSuccess()\n+                .getOutput().stream()\n+                        .map(line -> line.split(\":\\\\s+\", 2))\n+                        .collect(Collectors.toMap(\n+                                components -> components[0],\n+                                components -> components[1]));\n+\n+        for (var property : properties) {\n+            Optional.ofNullable(property.verifyValue(actualValues.get(property.name))).ifPresent(errors::add);\n+        }\n+\n+        return errors;\n+    }\n+\n+    @Override\n+    protected Map<String, String> createReplacementData() throws IOException {\n+        Map<String, String> data = new HashMap<>();\n+\n+        String licenseText = pkg.licenseFile().map(toFunction(Files::readString)).orElse(\"Unknown\");\n+\n+        data.put(\"APPLICATION_MAINTAINER\", pkg.maintainer());\n+        data.put(\"APPLICATION_SECTION\", pkg.category().orElseThrow());\n+        data.put(\"APPLICATION_COPYRIGHT\", pkg.app().copyright());\n+        data.put(\"APPLICATION_LICENSE_TEXT\", licenseText);\n+        data.put(\"APPLICATION_ARCH\", pkg.arch());\n+        data.put(\"APPLICATION_INSTALLED_SIZE\", Long.toString(\n+                AppImageLayout.toPathGroup(env.appImageLayout()).sizeInBytes() >> 10));\n+        data.put(\"APPLICATION_HOMEPAGE\", pkg.aboutURL().map(\n+                value -> \"Homepage: \" + value).orElse(\"\"));\n+        data.put(\"APPLICATION_VERSION_WITH_RELEASE\", pkg.versionWithRelease());\n+\n+        return data;\n+    }\n+\n+    @Override\n+    protected void buildPackage() throws IOException {\n+\n+        Path debFile = outputPackageFile();\n+\n+        Log.verbose(I18N.format(\"message.outputting-to-location\", debFile.toAbsolutePath()));\n+\n+        List<String> cmdline = new ArrayList<>();\n+        Stream.of(sysEnv.fakeroot(), sysEnv.dpkgdeb()).map(Path::toString).forEach(cmdline::add);\n+        if (Log.isVerbose()) {\n+            cmdline.add(\"--verbose\");\n+        }\n+        cmdline.addAll(List.of(\"-b\", env.appImageDir().toString(), debFile.toAbsolutePath().toString()));\n+\n+        \/\/ run dpkg\n+        RetryExecutor.retryOnKnownErrorMessage(\n+                \"semop(1): encountered an error: Invalid argument\").execute(\n+                        cmdline.toArray(String[]::new));\n+\n+        Log.verbose(I18N.format(\"message.output-to-location\", debFile.toAbsolutePath()));\n+    }\n+\n+    @Override\n+    public void accept(PackagingPipeline.Builder pipelineBuilder) {\n+        super.accept(pipelineBuilder);\n+\n+        \/\/ Build deb config files after app image contents are ready because\n+        \/\/ it calculates the size of the image and saves the value in one of the config files.\n+        pipelineBuilder.configuredTasks().filter(task -> {\n+            return PackageTaskID.CREATE_CONFIG_FILES.equals(task.task());\n+        }).findFirst().orElseThrow()\n+                .addDependencies(PrimaryTaskID.BUILD_APPLICATION_IMAGE, PrimaryTaskID.COPY_APP_IMAGE)\n+                .add();\n+    }\n+\n+    private void adjustPermissionsRecursive() throws IOException {\n+        Files.walkFileTree(env.appImageDir(), new SimpleFileVisitor<Path>() {\n+            @Override\n+            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                if (file.endsWith(\".so\") || !Files.isExecutable(file)) {\n+                    Files.setPosixFilePermissions(file, SO_PERMISSIONS);\n+                } else if (Files.isExecutable(file)) {\n+                    Files.setPosixFilePermissions(file, EXECUTABLE_PERMISSIONS);\n+                }\n+                return FileVisitResult.CONTINUE;\n+            }\n+\n+            @Override\n+            public FileVisitResult postVisitDirectory(Path dir, IOException e) throws IOException {\n+                if (e == null) {\n+                    Files.setPosixFilePermissions(dir, FOLDER_PERMISSIONS);\n+                    return FileVisitResult.CONTINUE;\n+                } else {\n+                    \/\/ directory iteration failed\n+                    throw e;\n+                }\n+            }\n+        });\n+    }\n+\n+    private void prepareProjectConfig(Map<String, String> data) throws IOException {\n+\n+        Path configDir = env.appImageDir().resolve(\"DEBIAN\");\n+        List<DebianFile> debianFiles = new ArrayList<>();\n+        debianFiles.add(new DebianFile(\n+                configDir.resolve(\"control\"),\n+                \"resource.deb-control-file\"));\n+        debianFiles.add(new DebianFile(\n+                configDir.resolve(\"preinst\"),\n+                \"resource.deb-preinstall-script\").setExecutable());\n+        debianFiles.add(new DebianFile(\n+                configDir.resolve(\"prerm\"),\n+                \"resource.deb-prerm-script\").setExecutable());\n+        debianFiles.add(new DebianFile(\n+                configDir.resolve(\"postinst\"),\n+                \"resource.deb-postinstall-script\").setExecutable());\n+        debianFiles.add(new DebianFile(\n+                configDir.resolve(\"postrm\"),\n+                \"resource.deb-postrm-script\").setExecutable());\n+\n+        pkg.relativeCopyrightFilePath().ifPresent(copyrightFile -> {\n+            debianFiles.add(new DebianFile(env.appImageDir().resolve(copyrightFile),\n+                    \"resource.copyright-file\"));\n+        });\n+\n+        for (DebianFile debianFile : debianFiles) {\n+            debianFile.create(data, env::createResource);\n+        }\n+    }\n+\n+    private static Stream<String> findProvidingPackages(Path file, Path dpkg) throws IOException {\n+        \/\/\n+        \/\/ `dpkg -S` command does glob pattern lookup. If not the absolute path\n+        \/\/ to the file is specified it might return mltiple package names.\n+        \/\/ Even for full paths multiple package names can be returned as\n+        \/\/ it is OK for multiple packages to provide the same file. `\/opt`\n+        \/\/ directory is such an example. So we have to deal with multiple\n+        \/\/ packages per file situation.\n+        \/\/\n+        \/\/ E.g.: `dpkg -S libc.so.6` command reports three packages:\n+        \/\/ libc6-x32: \/libx32\/libc.so.6\n+        \/\/ libc6:amd64: \/lib\/x86_64-linux-gnu\/libc.so.6\n+        \/\/ libc6-i386: \/lib32\/libc.so.6\n+        \/\/ `:amd64` is architecture suffix and can (should) be dropped.\n+        \/\/ Still need to decide what package to choose from three.\n+        \/\/ libc6-x32 and libc6-i386 both depend on libc6:\n+        \/\/ $ dpkg -s libc6-x32\n+        \/\/ Package: libc6-x32\n+        \/\/ Status: install ok installed\n+        \/\/ Priority: optional\n+        \/\/ Section: libs\n+        \/\/ Installed-Size: 10840\n+        \/\/ Maintainer: Ubuntu Developers <ubuntu-devel-discuss@lists.ubuntu.com>\n+        \/\/ Architecture: amd64\n+        \/\/ Source: glibc\n+        \/\/ Version: 2.23-0ubuntu10\n+        \/\/ Depends: libc6 (= 2.23-0ubuntu10)\n+        \/\/\n+        \/\/ We can dive into tracking dependencies, but this would be overly\n+        \/\/ complicated.\n+        \/\/\n+        \/\/ For simplicity lets consider the following rules:\n+        \/\/ 1. If there is one item in `dpkg -S` output, accept it.\n+        \/\/ 2. If there are multiple items in `dpkg -S` output and there is at\n+        \/\/  least one item with the default arch suffix (DEB_ARCH),\n+        \/\/  accept only these items.\n+        \/\/ 3. If there are multiple items in `dpkg -S` output and there are\n+        \/\/  no with the default arch suffix (DEB_ARCH), accept all items.\n+        \/\/ So lets use this heuristics: don't accept packages for whom\n+        \/\/  `dpkg -p` command fails.\n+        \/\/ 4. Arch suffix should be stripped from accepted package names.\n+        \/\/\n+\n+        Set<String> archPackages = new HashSet<>();\n+        Set<String> otherPackages = new HashSet<>();\n+\n+        var debArch = LinuxPackageArch.getValue(LINUX_DEB);\n+\n+        Executor.of(dpkg.toString(), \"-S\", file.toString())\n+                .saveOutput(true).executeExpectSuccess()\n+                .getOutput().forEach(line -> {\n+                    Matcher matcher = PACKAGE_NAME_REGEX.matcher(line);\n+                    if (matcher.find()) {\n+                        String name = matcher.group(1);\n+                        if (name.endsWith(\":\" + debArch)) {\n+                            \/\/ Strip arch suffix\n+                            name = name.substring(0,\n+                                    name.length() - (debArch.length() + 1));\n+                            archPackages.add(name);\n+                        } else {\n+                            otherPackages.add(name);\n+                        }\n+                    }\n+                });\n+\n+        if (!archPackages.isEmpty()) {\n+            return archPackages.stream();\n+        }\n+        return otherPackages.stream();\n+    }\n+\n+\n+    private static final class DebianFile {\n+\n+        DebianFile(Path dstFilePath, String comment) {\n+            this.dstFilePath = Objects.requireNonNull(dstFilePath);\n+            this.comment = Objects.requireNonNull(comment);\n+        }\n+\n+        DebianFile setExecutable() {\n+            permissions = EXECUTABLE_PERMISSIONS;\n+            return this;\n+        }\n+\n+        void create(Map<String, String> data, Function<String, OverridableResource> resourceFactory)\n+                throws IOException {\n+            resourceFactory.apply(\"template.\" + dstFilePath.getFileName().toString())\n+                    .setCategory(I18N.getString(comment))\n+                    .setSubstitutionData(data)\n+                    .saveToFile(dstFilePath);\n+            if (permissions != null) {\n+                Files.setPosixFilePermissions(dstFilePath, permissions);\n+            }\n+        }\n+\n+        private final Path dstFilePath;\n+        private final String comment;\n+        private Set<PosixFilePermission> permissions;\n+    }\n+\n+\n+    private final LinuxDebSystemEnvironment sysEnv;\n+\n+    private static final Pattern PACKAGE_NAME_REGEX = Pattern.compile(\"^(^\\\\S+):\");\n+\n+    private static final Set<PosixFilePermission> EXECUTABLE_PERMISSIONS = PosixFilePermissions.fromString(\"rwxr-xr-x\");\n+    private static final Set<PosixFilePermission> FOLDER_PERMISSIONS = PosixFilePermissions.fromString(\"rwxr-xr-x\");\n+    private static final Set<PosixFilePermission> SO_PERMISSIONS = PosixFilePermissions.fromString(\"rw-r--r--\");\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxDebPackager.java","additions":344,"deletions":0,"binary":false,"changes":344,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.LinuxSystemEnvironment.mixin;\n+\n+import jdk.jpackage.internal.util.Result;\n+\n+public interface LinuxDebSystemEnvironment extends LinuxSystemEnvironment, LinuxDebSystemEnvironmentMixin {\n+\n+    static Result<LinuxDebSystemEnvironment> create(Result<LinuxSystemEnvironment> base) {\n+        return mixin(LinuxDebSystemEnvironment.class, base, LinuxDebSystemEnvironmentMixin::create);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxDebSystemEnvironment.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.util.Result;\n+\n+public interface LinuxDebSystemEnvironmentMixin {\n+    Path dpkg();\n+    Path dpkgdeb();\n+    Path fakeroot();\n+\n+    record Stub(Path dpkg, Path dpkgdeb, Path fakeroot) implements LinuxDebSystemEnvironmentMixin {\n+    }\n+\n+    static Result<LinuxDebSystemEnvironmentMixin> create() {\n+        final var errors = Stream.of(Internal.TOOL_DPKG_DEB, Internal.TOOL_DPKG, Internal.TOOL_FAKEROOT)\n+                .map(ToolValidator::new)\n+                .map(ToolValidator::validate)\n+                .filter(Objects::nonNull)\n+                .toList();\n+        if (errors.isEmpty()) {\n+            return Result.ofValue(new Stub(Internal.TOOL_DPKG, Internal.TOOL_DPKG_DEB, Internal.TOOL_FAKEROOT));\n+        } else {\n+            return Result.ofErrors(errors);\n+        }\n+    }\n+\n+    static final class Internal {\n+\n+        private static final Path TOOL_DPKG_DEB = Path.of(\"dpkg-deb\");\n+        private static final Path TOOL_DPKG = Path.of(\"dpkg\");\n+        private static final Path TOOL_FAKEROOT = Path.of(\"fakeroot\");\n+    }\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxDebSystemEnvironmentMixin.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -42,0 +42,1 @@\n+import jdk.jpackage.internal.model.LinuxDebPackage;\n@@ -44,1 +45,1 @@\n-import jdk.jpackage.internal.model.LinuxPackage;\n+import jdk.jpackage.internal.model.LinuxRpmPackage;\n@@ -79,1 +80,1 @@\n-    private static LinuxPackage createLinuxRpmPackage(\n+    private static LinuxRpmPackage createLinuxRpmPackage(\n@@ -91,1 +92,1 @@\n-    private static LinuxPackage createLinuxDebPackage(\n+    private static LinuxDebPackage createLinuxDebPackage(\n@@ -100,1 +101,8 @@\n-        return pkgBuilder.create();\n+        final var pkg = pkgBuilder.create();\n+\n+        \/\/ Show warning if license file is missing\n+        if (pkg.licenseFile().isEmpty()) {\n+            Log.verbose(I18N.getString(\"message.debs-like-licenses\"));\n+        }\n+\n+        return pkg;\n@@ -106,1 +114,1 @@\n-    static final BundlerParamInfo<LinuxPackage> RPM_PACKAGE = createPackageBundlerParam(\n+    static final BundlerParamInfo<LinuxRpmPackage> RPM_PACKAGE = createPackageBundlerParam(\n@@ -109,1 +117,1 @@\n-    static final BundlerParamInfo<LinuxPackage> DEB_PACKAGE = createPackageBundlerParam(\n+    static final BundlerParamInfo<LinuxDebPackage> DEB_PACKAGE = createPackageBundlerParam(\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxFromParams.java","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-    private LinuxLaunchersAsServices(BuildEnv env, Package pkg) throws IOException {\n+    private LinuxLaunchersAsServices(BuildEnv env, Package pkg) {\n@@ -61,1 +61,1 @@\n-    static ShellCustomAction create(BuildEnv env, Package pkg) throws IOException {\n+    static ShellCustomAction create(BuildEnv env, Package pkg) {\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxLaunchersAsServices.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,6 +27,0 @@\n-import java.io.IOException;\n-import java.nio.file.Path;\n-import java.text.MessageFormat;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.List;\n@@ -35,6 +29,0 @@\n-import java.util.function.Predicate;\n-import java.util.stream.Stream;\n-import jdk.jpackage.internal.PackagingPipeline.PackageBuildEnv;\n-import jdk.jpackage.internal.PackagingPipeline.PackageTaskID;\n-import jdk.jpackage.internal.PackagingPipeline.PrimaryTaskID;\n-import jdk.jpackage.internal.model.AppImageLayout;\n@@ -42,1 +30,0 @@\n-import jdk.jpackage.internal.model.LinuxDebPackage;\n@@ -44,2 +31,1 @@\n-import jdk.jpackage.internal.model.Package;\n-import jdk.jpackage.internal.model.PackagerException;\n+import jdk.jpackage.internal.util.Result;\n@@ -50,4 +36,1 @@\n-        this.pkgParam = pkgParam;\n-        customActions = List.of(new CustomActionInstance(\n-                DesktopIntegration::create), new CustomActionInstance(\n-                LinuxLaunchersAsServices::create));\n+        this.pkgParam = Objects.requireNonNull(pkgParam);\n@@ -61,8 +44,8 @@\n-        LinuxPackage pkg = pkgParam.fetchFrom(params);\n-        var env = BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n-\n-        for (var validator: getToolValidators()) {\n-            ConfigException ex = validator.validate();\n-            if (ex != null) {\n-                throw ex;\n-            }\n+        pkgParam.fetchFrom(params);\n+        BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n+\n+        LinuxSystemEnvironment sysEnv;\n+        try {\n+            sysEnv = sysEnv().orElseThrow();\n+        } catch (RuntimeException ex) {\n+            throw ConfigException.rethrowConfigException(ex);\n@@ -72,3 +55,2 @@\n-            withFindNeededPackages = false;\n-            Log.verbose(MessageFormat.format(I18N.getString(\n-                    \"message.not-default-bundler-no-dependencies-lookup\"),\n+            Log.verbose(I18N.format(\n+                    \"message.not-default-bundler-no-dependencies-lookup\",\n@@ -76,12 +58,6 @@\n-        } else {\n-            withFindNeededPackages = LibProvidersLookup.supported();\n-            if (!withFindNeededPackages) {\n-                final String advice;\n-                if (\"deb\".equals(getID())) {\n-                    advice = \"message.deb-ldd-not-available.advice\";\n-                } else {\n-                    advice = \"message.rpm-ldd-not-available.advice\";\n-                }\n-                \/\/ Let user know package dependencies will not be generated.\n-                Log.error(String.format(\"%s\\n%s\", I18N.getString(\n-                        \"message.ldd-not-available\"), I18N.getString(advice)));\n+        } else if (!sysEnv.soLookupAvailable()) {\n+            final String advice;\n+            if (\"deb\".equals(getID())) {\n+                advice = \"message.deb-ldd-not-available.advice\";\n+            } else {\n+                advice = \"message.rpm-ldd-not-available.advice\";\n@@ -89,0 +65,3 @@\n+            \/\/ Let user know package dependencies will not be generated.\n+            Log.error(String.format(\"%s\\n%s\", I18N.getString(\n+                    \"message.ldd-not-available\"), I18N.getString(advice)));\n@@ -91,3 +70,0 @@\n-        \/\/ Packaging specific validation\n-        doValidate(env, pkg);\n-\n@@ -103,103 +79,2 @@\n-    public final Path execute(Map<String, ? super Object> params,\n-            Path outputParentDir) throws PackagerException {\n-        IOUtils.writableOutputDir(outputParentDir);\n-\n-        \/\/ Order is important!\n-        final LinuxPackage pkg = pkgParam.fetchFrom(params);\n-        final var env = BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n-\n-        final var pipelineBuilder = LinuxPackagingPipeline.build()\n-                .excludeDirFromCopying(outputParentDir)\n-                .task(PackageTaskID.CREATE_PACKAGE_FILE)\n-                        .packageAction(this::buildPackage)\n-                        .add();\n-\n-        final var createConfigFilesTaskBuilder = pipelineBuilder\n-                .task(PackageTaskID.CREATE_CONFIG_FILES)\n-                .packageAction(this::buildConfigFiles);\n-\n-        if (pkg instanceof LinuxDebPackage) {\n-            \/\/ Build deb config files after app image contents are ready because\n-            \/\/ it calculates the size of the image and saves the value in one of the config files.\n-            createConfigFilesTaskBuilder.addDependencies(PrimaryTaskID.BUILD_APPLICATION_IMAGE, PrimaryTaskID.COPY_APP_IMAGE);\n-        }\n-\n-        createConfigFilesTaskBuilder.add();\n-\n-        pipelineBuilder.create().execute(env, pkg, outputParentDir);\n-\n-        return outputParentDir.resolve(pkg.packageFileNameWithSuffix()).toAbsolutePath();\n-    }\n-\n-    private void buildConfigFiles(PackageBuildEnv<LinuxPackage, AppImageLayout> env) throws PackagerException, IOException {\n-        for (var ca : customActions) {\n-            ca.init(env.env(), env.pkg());\n-        }\n-\n-        Map<String, String> data = createDefaultReplacementData(env.env(), env.pkg());\n-\n-        for (var ca : customActions) {\n-            ShellCustomAction.mergeReplacementData(data, ca.instance.create());\n-        }\n-\n-        data.putAll(createReplacementData(env.env(), env.pkg()));\n-\n-        createConfigFiles(Collections.unmodifiableMap(data), env.env(), env.pkg());\n-    }\n-\n-    private void buildPackage(PackageBuildEnv<LinuxPackage, AppImageLayout> env) throws PackagerException, IOException {\n-        Path packageBundle = buildPackageBundle(env.env(), env.pkg(), env.outputDir());\n-\n-        verifyOutputBundle(env.env(), env.pkg(), packageBundle).stream()\n-                .filter(Objects::nonNull)\n-                .forEachOrdered(ex -> {\n-            Log.verbose(ex.getLocalizedMessage());\n-            Log.verbose(ex.getAdvice());\n-        });\n-    }\n-\n-    private List<String> getListOfNeededPackages(BuildEnv env) throws IOException {\n-\n-        final List<String> caPackages = customActions.stream()\n-                .map(ca -> ca.instance)\n-                .map(ShellCustomAction::requiredPackages)\n-                .flatMap(List::stream).toList();\n-\n-        final List<String> neededLibPackages;\n-        if (withFindNeededPackages) {\n-            LibProvidersLookup lookup = new LibProvidersLookup();\n-            initLibProvidersLookup(lookup);\n-\n-            neededLibPackages = lookup.execute(env.appImageDir());\n-        } else {\n-            neededLibPackages = Collections.emptyList();\n-            Log.info(I18N.getString(\"warning.foreign-app-image\"));\n-        }\n-\n-        \/\/ Merge all package lists together.\n-        \/\/ Filter out empty names, sort and remove duplicates.\n-        List<String> result = Stream.of(caPackages, neededLibPackages).flatMap(\n-                List::stream).filter(Predicate.not(String::isEmpty)).sorted().distinct().toList();\n-\n-        Log.verbose(String.format(\"Required packages: %s\", result));\n-\n-        return result;\n-    }\n-\n-    private Map<String, String> createDefaultReplacementData(BuildEnv env, LinuxPackage pkg) throws IOException {\n-        Map<String, String> data = new HashMap<>();\n-\n-        data.put(\"APPLICATION_PACKAGE\", pkg.packageName());\n-        data.put(\"APPLICATION_VENDOR\", pkg.app().vendor());\n-        data.put(\"APPLICATION_VERSION\", pkg.version());\n-        data.put(\"APPLICATION_DESCRIPTION\", pkg.description());\n-\n-        String defaultDeps = String.join(\", \", getListOfNeededPackages(env));\n-        String customDeps = pkg.additionalDependencies().orElse(\"\");\n-        if (!customDeps.isEmpty() && !defaultDeps.isEmpty()) {\n-            customDeps = \", \" + customDeps;\n-        }\n-        data.put(\"PACKAGE_DEFAULT_DEPENDENCIES\", defaultDeps);\n-        data.put(\"PACKAGE_CUSTOM_DEPENDENCIES\", customDeps);\n-\n-        return data;\n+    public boolean supported(boolean runtimeInstaller) {\n+        return sysEnv().hasValue();\n@@ -208,20 +83,1 @@\n-    protected abstract List<ConfigException> verifyOutputBundle(\n-            BuildEnv env, LinuxPackage pkg, Path packageBundle);\n-\n-    protected abstract void initLibProvidersLookup(LibProvidersLookup libProvidersLookup);\n-\n-    protected abstract List<ToolValidator> getToolValidators();\n-\n-    protected abstract void doValidate(BuildEnv env, LinuxPackage pkg)\n-            throws ConfigException;\n-\n-    protected abstract Map<String, String> createReplacementData(\n-            BuildEnv env, LinuxPackage pkg) throws IOException;\n-\n-    protected abstract void createConfigFiles(\n-            Map<String, String> replacementData,\n-            BuildEnv env, LinuxPackage pkg) throws IOException;\n-\n-    protected abstract Path buildPackageBundle(\n-            BuildEnv env, LinuxPackage pkg, Path outputParentDir) throws\n-            PackagerException, IOException;\n+    protected abstract Result<? extends LinuxSystemEnvironment> sysEnv();\n@@ -230,2 +86,0 @@\n-    private boolean withFindNeededPackages;\n-    private final List<CustomActionInstance> customActions;\n@@ -233,14 +87,1 @@\n-    private static final class CustomActionInstance {\n-\n-        CustomActionInstance(ShellCustomActionFactory factory) {\n-            this.factory = factory;\n-        }\n-\n-        void init(BuildEnv env, Package pkg) throws IOException {\n-            instance = factory.create(env, pkg);\n-            Objects.requireNonNull(instance);\n-        }\n-\n-        private final ShellCustomActionFactory factory;\n-        ShellCustomAction instance;\n-    }\n+    static final Result<LinuxSystemEnvironment> SYS_ENV = LinuxSystemEnvironment.create();\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxPackageBundler.java","additions":25,"deletions":184,"binary":false,"changes":209,"status":"modified"},{"patch":"@@ -0,0 +1,184 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.PackagingPipeline.PackageTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.PrimaryTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.TaskID;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.LinuxPackage;\n+import jdk.jpackage.internal.model.PackagerException;\n+\n+abstract class LinuxPackager<T extends LinuxPackage> implements Consumer<PackagingPipeline.Builder> {\n+\n+    LinuxPackager(BuildEnv env, T pkg, Path outputDir, LinuxSystemEnvironment sysEnv) {\n+        this.env = Objects.requireNonNull(env);\n+        this.pkg = Objects.requireNonNull(pkg);\n+        this.outputDir = Objects.requireNonNull(outputDir);\n+        this.withRequiredPackagesLookup = sysEnv.soLookupAvailable() && sysEnv.nativePackageType().equals(pkg.type());\n+\n+        customActions = List.of(\n+                DesktopIntegration.create(env, pkg),\n+                LinuxLaunchersAsServices.create(env, pkg));\n+    }\n+\n+    enum LinuxPackageTaskID implements TaskID {\n+        INIT_REQUIRED_PACKAGES,\n+        VERIFY_PACKAGE\n+    }\n+\n+    @Override\n+    public void accept(PackagingPipeline.Builder pipelineBuilder) {\n+        pipelineBuilder.excludeDirFromCopying(outputDir)\n+                .task(PackageTaskID.CREATE_CONFIG_FILES)\n+                        .action(this::buildConfigFiles)\n+                        .add()\n+                .task(LinuxPackageTaskID.INIT_REQUIRED_PACKAGES)\n+                        .addDependencies(PrimaryTaskID.BUILD_APPLICATION_IMAGE, PrimaryTaskID.COPY_APP_IMAGE)\n+                        .addDependent(PackageTaskID.CREATE_CONFIG_FILES)\n+                        .action(this::initRequiredPackages)\n+                        .add()\n+                .task(LinuxPackageTaskID.VERIFY_PACKAGE)\n+                        .addDependencies(PackageTaskID.CREATE_PACKAGE_FILE)\n+                        .addDependent(PrimaryTaskID.PACKAGE)\n+                        .action(this::verifyOutputPackage)\n+                        .add()\n+                .task(PackageTaskID.CREATE_PACKAGE_FILE)\n+                        .action(this::buildPackage)\n+                        .add();\n+    }\n+\n+    protected final Path outputPackageFile() {\n+        return outputDir.resolve(pkg.packageFileNameWithSuffix());\n+    }\n+\n+    protected abstract void buildPackage() throws IOException;\n+\n+    protected abstract List<? extends Exception> findErrorsInOutputPackage() throws IOException;\n+\n+    protected abstract void createConfigFiles(Map<String, String> replacementData) throws IOException;\n+\n+    protected abstract Map<String, String> createReplacementData() throws IOException;\n+\n+    protected abstract void initLibProvidersLookup(LibProvidersLookup libProvidersLookup);\n+\n+    private void buildConfigFiles() throws PackagerException, IOException {\n+\n+        final var data = createDefaultReplacementData();\n+\n+        for (var ca : customActions) {\n+            ShellCustomAction.mergeReplacementData(data, ca.create());\n+        }\n+\n+        data.putAll(createReplacementData());\n+\n+        createConfigFiles(Collections.unmodifiableMap(data));\n+    }\n+\n+    private Map<String, String> createDefaultReplacementData() {\n+        Map<String, String> data = new HashMap<>();\n+\n+        data.put(\"APPLICATION_PACKAGE\", pkg.packageName());\n+        data.put(\"APPLICATION_VENDOR\", pkg.app().vendor());\n+        data.put(\"APPLICATION_VERSION\", pkg.version());\n+        data.put(\"APPLICATION_DESCRIPTION\", pkg.description());\n+\n+        String defaultDeps = String.join(\", \", requiredPackages);\n+        String customDeps = pkg.additionalDependencies().orElse(\"\");\n+        if (!customDeps.isEmpty() && !defaultDeps.isEmpty()) {\n+            customDeps = \", \" + customDeps;\n+        }\n+        data.put(\"PACKAGE_DEFAULT_DEPENDENCIES\", defaultDeps);\n+        data.put(\"PACKAGE_CUSTOM_DEPENDENCIES\", customDeps);\n+\n+        return data;\n+    }\n+\n+    private void initRequiredPackages() throws IOException {\n+\n+        final List<String> caPackages = customActions.stream()\n+                .map(ShellCustomAction::requiredPackages)\n+                .flatMap(List::stream).toList();\n+\n+        final List<String> neededLibPackages;\n+        if (withRequiredPackagesLookup) {\n+            neededLibPackages = findRequiredPackages();\n+        } else {\n+            neededLibPackages = Collections.emptyList();\n+            Log.info(I18N.getString(\"warning.foreign-app-image\"));\n+        }\n+\n+        \/\/ Merge all package lists together.\n+        \/\/ Filter out empty names, sort and remove duplicates.\n+        Stream.of(caPackages, neededLibPackages)\n+                .flatMap(List::stream)\n+                .filter(Predicate.not(String::isEmpty))\n+                .sorted().distinct().forEach(requiredPackages::add);\n+\n+        Log.verbose(String.format(\"Required packages: %s\", requiredPackages));\n+    }\n+\n+    private List<String> findRequiredPackages() throws IOException {\n+        var lookup = new LibProvidersLookup();\n+        initLibProvidersLookup(lookup);\n+        return lookup.execute(env.appImageDir());\n+    }\n+\n+    private void verifyOutputPackage() {\n+        final List<? extends Exception> errors;\n+        try {\n+            errors = findErrorsInOutputPackage();\n+        } catch (Exception ex) {\n+            \/\/ Ignore error as it is not critical. Just report it.\n+            Log.verbose(ex);\n+            return;\n+        }\n+\n+        for (var ex : errors) {\n+            Log.verbose(ex.getLocalizedMessage());\n+            if (ex instanceof ConfigException cfgEx) {\n+                Log.verbose(cfgEx.getAdvice());\n+            }\n+        }\n+    }\n+\n+    protected final BuildEnv env;\n+    protected final T pkg;\n+    protected final Path outputDir;\n+    private final boolean withRequiredPackagesLookup;\n+    private final List<String> requiredPackages = new ArrayList<>();\n+    private final List<ShellCustomAction> customActions;\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxPackager.java","additions":184,"deletions":0,"binary":false,"changes":184,"status":"added"},{"patch":"@@ -28,1 +28,0 @@\n-import java.io.IOException;\n@@ -30,4 +29,0 @@\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.List;\n@@ -35,7 +30,0 @@\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-import java.util.stream.Collectors;\n-import jdk.internal.util.OperatingSystem;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.model.DottedVersion;\n-import jdk.jpackage.internal.model.LinuxPackage;\n@@ -43,1 +31,0 @@\n-import jdk.jpackage.internal.model.Package;\n@@ -45,0 +32,2 @@\n+import jdk.jpackage.internal.model.StandardPackageType;\n+import jdk.jpackage.internal.util.Result;\n@@ -47,11 +36,0 @@\n-\/**\n- * There are two command line options to configure license information for RPM\n- * packaging: --linux-rpm-license-type and --license-file. Value of\n- * --linux-rpm-license-type command line option configures \"License:\" section\n- * of RPM spec. Value of --license-file command line option specifies a license\n- * file to be added to the package. License file is a sort of documentation file\n- * but it will be installed even if user selects an option to install the\n- * package without documentation. --linux-rpm-license-type is the primary option\n- * to set license information. --license-file makes little sense in case of RPM\n- * packaging.\n- *\/\n@@ -60,7 +38,0 @@\n-    private static final String DEFAULT_SPEC_TEMPLATE = \"template.spec\";\n-\n-    public static final String TOOL_RPM = \"rpm\";\n-    public static final String TOOL_RPMBUILD = \"rpmbuild\";\n-    public static final DottedVersion TOOL_RPMBUILD_MIN_VERSION = DottedVersion.lazy(\n-            \"4.10\");\n-\n@@ -71,140 +42,0 @@\n-    @Override\n-    protected void doValidate(BuildEnv env, LinuxPackage pkg) throws ConfigException {\n-    }\n-\n-    private static ToolValidator createRpmbuildToolValidator() {\n-        Pattern pattern = Pattern.compile(\" (\\\\d+\\\\.\\\\d+)\");\n-        return new ToolValidator(TOOL_RPMBUILD).setMinimalVersion(\n-                TOOL_RPMBUILD_MIN_VERSION).setVersionParser(lines -> {\n-                    String versionString = lines.limit(1).collect(\n-                            Collectors.toList()).get(0);\n-                    Matcher matcher = pattern.matcher(versionString);\n-                    if (matcher.find()) {\n-                        return matcher.group(1);\n-                    }\n-                    return null;\n-                });\n-    }\n-\n-    @Override\n-    protected List<ToolValidator> getToolValidators() {\n-        return List.of(createRpmbuildToolValidator());\n-    }\n-\n-    protected void createConfigFiles(Map<String, String> replacementData,\n-            BuildEnv env, LinuxPackage pkg) throws IOException {\n-        Path specFile = specFile(env, pkg);\n-\n-        \/\/ prepare spec file\n-        env.createResource(DEFAULT_SPEC_TEMPLATE)\n-                .setCategory(I18N.getString(\"resource.rpm-spec-file\"))\n-                .setSubstitutionData(replacementData)\n-                .saveToFile(specFile);\n-    }\n-\n-    @Override\n-    protected Path buildPackageBundle(BuildEnv env, LinuxPackage pkg,\n-            Path outputParentDir) throws PackagerException, IOException {\n-        return buildRPM(env, pkg, outputParentDir);\n-    }\n-\n-    private static Path installPrefix(LinuxPackage pkg) {\n-        Path path = pkg.relativeInstallDir();\n-        if (!pkg.isInstallDirInUsrTree()) {\n-            path = path.getParent();\n-        }\n-        return Path.of(\"\/\").resolve(path);\n-    }\n-\n-    @Override\n-    protected Map<String, String> createReplacementData(BuildEnv env, LinuxPackage pkg) throws IOException {\n-        Map<String, String> data = new HashMap<>();\n-\n-        data.put(\"APPLICATION_RELEASE\", pkg.release().orElseThrow());\n-        data.put(\"APPLICATION_PREFIX\", installPrefix(pkg).toString());\n-        data.put(\"APPLICATION_DIRECTORY\", Path.of(\"\/\").resolve(pkg.relativeInstallDir()).toString());\n-        data.put(\"APPLICATION_SUMMARY\", pkg.app().name());\n-        data.put(\"APPLICATION_LICENSE_TYPE\", ((LinuxRpmPackage)pkg).licenseType());\n-\n-        String licenseFile = pkg.licenseFile().map(v -> {\n-            return v.toAbsolutePath().normalize().toString();\n-        }).orElse(null);\n-        data.put(\"APPLICATION_LICENSE_FILE\", licenseFile);\n-        data.put(\"APPLICATION_GROUP\", pkg.category().orElse(\"\"));\n-\n-        data.put(\"APPLICATION_URL\", pkg.aboutURL().orElse(\"\"));\n-\n-        return data;\n-    }\n-\n-    @Override\n-    protected void initLibProvidersLookup(LibProvidersLookup libProvidersLookup) {\n-        libProvidersLookup.setPackageLookup(file -> {\n-            return Executor.of(TOOL_RPM,\n-                \"-q\", \"--queryformat\", \"%{name}\\\\n\",\n-                \"-q\", \"--whatprovides\", file.toString())\n-                .saveOutput(true).executeExpectSuccess().getOutput().stream();\n-        });\n-    }\n-\n-    @Override\n-    protected List<ConfigException> verifyOutputBundle(BuildEnv env, LinuxPackage pkg,\n-            Path packageBundle) {\n-        List<ConfigException> errors = new ArrayList<>();\n-\n-        String specFileName = specFile(env, pkg).getFileName().toString();\n-\n-        try {\n-            List<PackageProperty> properties = List.of(\n-                    new PackageProperty(\"Name\", pkg.packageName(),\n-                            \"APPLICATION_PACKAGE\", specFileName),\n-                    new PackageProperty(\"Version\", pkg.version(),\n-                            \"APPLICATION_VERSION\", specFileName),\n-                    new PackageProperty(\"Release\", pkg.release().orElseThrow(),\n-                            \"APPLICATION_RELEASE\", specFileName),\n-                    new PackageProperty(\"Arch\", pkg.arch(), null, specFileName));\n-\n-            List<String> actualValues = Executor.of(TOOL_RPM, \"-qp\", \"--queryformat\",\n-                    properties.stream().map(entry -> String.format(\"%%{%s}\",\n-                    entry.name)).collect(Collectors.joining(\"\\\\n\")),\n-                    packageBundle.toString()).saveOutput(true).executeExpectSuccess().getOutput();\n-\n-            Iterator<String> actualValuesIt = actualValues.iterator();\n-            properties.forEach(property -> errors.add(property.verifyValue(\n-                    actualValuesIt.next())));\n-        } catch (IOException ex) {\n-            \/\/ Ignore error as it is not critical. Just report it.\n-            Log.verbose(ex);\n-        }\n-\n-        return errors;\n-    }\n-\n-    private Path specFile(BuildEnv env, Package pkg) {\n-        return env.buildRoot().resolve(Path.of(\"SPECS\", pkg.packageName() + \".spec\"));\n-    }\n-\n-    private Path buildRPM(BuildEnv env, Package pkg, Path outdir) throws IOException {\n-\n-        Path rpmFile = outdir.toAbsolutePath().resolve(pkg.packageFileNameWithSuffix());\n-\n-        Log.verbose(I18N.format(\"message.outputting-bundle-location\", rpmFile.getParent()));\n-\n-        \/\/run rpmbuild\n-        Executor.of(TOOL_RPMBUILD,\n-                \"-bb\", specFile(env, pkg).toAbsolutePath().toString(),\n-                \"--define\", String.format(\"%%_sourcedir %s\",\n-                        env.appImageDir().toAbsolutePath()),\n-                \/\/ save result to output dir\n-                \"--define\", String.format(\"%%_rpmdir %s\", rpmFile.getParent()),\n-                \/\/ do not use other system directories to build as current user\n-                \"--define\", String.format(\"%%_topdir %s\",\n-                        env.buildRoot().toAbsolutePath()),\n-                \"--define\", String.format(\"%%_rpmfilename %s\", rpmFile.getFileName())\n-        ).executeExpectSuccess();\n-\n-        Log.verbose(I18N.format(\"message.output-bundle-location\", rpmFile.getParent()));\n-\n-        return rpmFile;\n-    }\n-\n@@ -222,2 +53,13 @@\n-    public boolean supported(boolean runtimeInstaller) {\n-        return OperatingSystem.isLinux() && (createRpmbuildToolValidator().validate() == null);\n+    public Path execute(Map<String, ? super Object> params, Path outputParentDir) throws PackagerException {\n+\n+        return Packager.<LinuxRpmPackage>build().outputDir(outputParentDir)\n+                .pkg(LinuxFromParams.RPM_PACKAGE.fetchFrom(params))\n+                .env(BuildEnvFromParams.BUILD_ENV.fetchFrom(params))\n+                .pipelineBuilderMutatorFactory((env, pkg, outputDir) -> {\n+                    return new LinuxRpmPackager(env, pkg, outputDir, sysEnv.orElseThrow());\n+                }).execute(LinuxPackagingPipeline.build());\n+    }\n+\n+    @Override\n+    protected Result<LinuxRpmSystemEnvironment> sysEnv() {\n+        return sysEnv;\n@@ -228,1 +70,4 @@\n-        return !LinuxDebBundler.isDebian();\n+        return sysEnv.value()\n+                .map(LinuxSystemEnvironment::nativePackageType)\n+                .map(StandardPackageType.LINUX_RPM::equals)\n+                .orElse(false);\n@@ -230,0 +75,2 @@\n+\n+    private final Result<LinuxRpmSystemEnvironment> sysEnv = LinuxRpmSystemEnvironment.create(SYS_ENV);\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxRpmBundler.java","additions":21,"deletions":174,"binary":false,"changes":195,"status":"modified"},{"patch":"@@ -0,0 +1,167 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import static java.util.stream.Collectors.joining;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.LinuxRpmPackage;\n+\n+\n+\/**\n+ * There are two command line options to configure license information for RPM\n+ * packaging: --linux-rpm-license-type and --license-file. Value of\n+ * --linux-rpm-license-type command line option configures \"License:\" section\n+ * of RPM spec. Value of --license-file command line option specifies a license\n+ * file to be added to the package. License file is a sort of documentation file\n+ * but it will be installed even if user selects an option to install the\n+ * package without documentation. --linux-rpm-license-type is the primary option\n+ * to set license information. --license-file makes little sense in case of RPM\n+ * packaging.\n+ *\/\n+final class LinuxRpmPackager extends LinuxPackager<LinuxRpmPackage> {\n+\n+    LinuxRpmPackager(BuildEnv env, LinuxRpmPackage pkg, Path outputDir, LinuxRpmSystemEnvironment sysEnv) {\n+        super(env, pkg, outputDir, sysEnv);\n+        this.sysEnv = Objects.requireNonNull(sysEnv);\n+    }\n+\n+    @Override\n+    protected void createConfigFiles(Map<String, String> replacementData) throws IOException {\n+        Path specFile = specFile();\n+\n+        \/\/ prepare spec file\n+        env.createResource(\"template.spec\")\n+                .setCategory(I18N.getString(\"resource.rpm-spec-file\"))\n+                .setSubstitutionData(replacementData)\n+                .saveToFile(specFile);\n+    }\n+\n+    @Override\n+    protected Map<String, String> createReplacementData() {\n+        Map<String, String> data = new HashMap<>();\n+\n+        data.put(\"APPLICATION_RELEASE\", pkg.release().orElseThrow());\n+        data.put(\"APPLICATION_PREFIX\", installPrefix().toString());\n+        data.put(\"APPLICATION_DIRECTORY\", Path.of(\"\/\").resolve(pkg.relativeInstallDir()).toString());\n+        data.put(\"APPLICATION_SUMMARY\", pkg.app().name());\n+        data.put(\"APPLICATION_LICENSE_TYPE\", pkg.licenseType());\n+\n+        String licenseFile = pkg.licenseFile().map(v -> {\n+            return v.toAbsolutePath().normalize().toString();\n+        }).orElse(null);\n+        data.put(\"APPLICATION_LICENSE_FILE\", licenseFile);\n+        data.put(\"APPLICATION_GROUP\", pkg.category().orElse(\"\"));\n+\n+        data.put(\"APPLICATION_URL\", pkg.aboutURL().orElse(\"\"));\n+\n+        return data;\n+    }\n+\n+    @Override\n+    protected void initLibProvidersLookup(LibProvidersLookup libProvidersLookup) {\n+        libProvidersLookup.setPackageLookup(file -> {\n+            return Executor.of(sysEnv.rpm().toString(),\n+                \"-q\", \"--queryformat\", \"%{name}\\\\n\",\n+                \"-q\", \"--whatprovides\", file.toString()\n+            ).saveOutput(true).executeExpectSuccess().getOutput().stream();\n+        });\n+    }\n+\n+    @Override\n+    protected List<? extends Exception> findErrorsInOutputPackage() throws IOException {\n+        List<ConfigException> errors = new ArrayList<>();\n+\n+        var specFileName = specFile().getFileName().toString();\n+\n+        var properties = List.of(\n+                new PackageProperty(\"Name\", pkg.packageName(),\n+                        \"APPLICATION_PACKAGE\", specFileName),\n+                new PackageProperty(\"Version\", pkg.version(),\n+                        \"APPLICATION_VERSION\", specFileName),\n+                new PackageProperty(\"Release\", pkg.release().orElseThrow(),\n+                        \"APPLICATION_RELEASE\", specFileName),\n+                new PackageProperty(\"Arch\", pkg.arch(), null, specFileName));\n+\n+        var actualValues = Executor.of(\n+                sysEnv.rpm().toString(),\n+                \"-qp\",\n+                \"--queryformat\", properties.stream().map(e -> String.format(\"%%{%s}\", e.name)).collect(joining(\"\\\\n\")),\n+                outputPackageFile().toString()\n+        ).saveOutput(true).executeExpectSuccess().getOutput();\n+\n+        for (int i = 0; i != properties.size(); i++) {\n+            Optional.ofNullable(properties.get(i).verifyValue(actualValues.get(i))).ifPresent(errors::add);\n+        }\n+\n+        return errors;\n+    }\n+\n+    @Override\n+    protected void buildPackage() throws IOException {\n+\n+        Path rpmFile = outputPackageFile();\n+\n+        Log.verbose(I18N.format(\"message.outputting-bundle-location\", rpmFile.getParent()));\n+\n+        \/\/run rpmbuild\n+        Executor.of(sysEnv.rpmbuild().toString(),\n+                \"-bb\", specFile().toAbsolutePath().toString(),\n+                \"--define\", String.format(\"%%_sourcedir %s\",\n+                        env.appImageDir().toAbsolutePath()),\n+                \/\/ save result to output dir\n+                \"--define\", String.format(\"%%_rpmdir %s\", rpmFile.getParent()),\n+                \/\/ do not use other system directories to build as current user\n+                \"--define\", String.format(\"%%_topdir %s\",\n+                        env.buildRoot().toAbsolutePath()),\n+                \"--define\", String.format(\"%%_rpmfilename %s\", rpmFile.getFileName())\n+        ).executeExpectSuccess();\n+\n+        Log.verbose(I18N.format(\"message.output-bundle-location\", rpmFile.getParent()));\n+    }\n+\n+    private Path installPrefix() {\n+        Path path = pkg.relativeInstallDir();\n+        if (!pkg.isInstallDirInUsrTree()) {\n+            path = path.getParent();\n+        }\n+        return Path.of(\"\/\").resolve(path);\n+    }\n+\n+    private Path specFile() {\n+        return env.buildRoot().resolve(Path.of(\"SPECS\", pkg.packageName() + \".spec\"));\n+    }\n+\n+    private final LinuxRpmSystemEnvironment sysEnv;\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxRpmPackager.java","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.LinuxSystemEnvironment.mixin;\n+\n+import jdk.jpackage.internal.util.Result;\n+\n+public interface LinuxRpmSystemEnvironment extends LinuxSystemEnvironment, LinuxRpmSystemEnvironmentMixin {\n+\n+    static Result<LinuxRpmSystemEnvironment> create(Result<LinuxSystemEnvironment> base) {\n+        return mixin(LinuxRpmSystemEnvironment.class, base, LinuxRpmSystemEnvironmentMixin::create);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxRpmSystemEnvironment.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.model.DottedVersion;\n+import jdk.jpackage.internal.util.Result;\n+\n+public interface LinuxRpmSystemEnvironmentMixin {\n+    Path rpm();\n+    Path rpmbuild();\n+\n+    record Stub(Path rpm, Path rpmbuild) implements LinuxRpmSystemEnvironmentMixin {\n+    }\n+\n+    static Result<LinuxRpmSystemEnvironmentMixin> create() {\n+\n+        final var errors = Stream.of(\n+                Internal.createRpmbuildToolValidator(),\n+                new ToolValidator(Internal.TOOL_RPM)\n+        ).map(ToolValidator::validate).filter(Objects::nonNull).toList();\n+\n+        if (errors.isEmpty()) {\n+            return Result.ofValue(new Stub(Internal.TOOL_RPM, Internal.TOOL_RPMBUILD));\n+        } else {\n+            return Result.ofErrors(errors);\n+        }\n+    }\n+\n+    static final class Internal {\n+        private static ToolValidator createRpmbuildToolValidator() {\n+            Pattern pattern = Pattern.compile(\" (\\\\d+\\\\.\\\\d+)\");\n+            return new ToolValidator(TOOL_RPMBUILD).setMinimalVersion(\n+                    TOOL_RPMBUILD_MIN_VERSION).setVersionParser(lines -> {\n+                        String versionString = lines.limit(1).findFirst().orElseThrow();\n+                        Matcher matcher = pattern.matcher(versionString);\n+                        if (matcher.find()) {\n+                            return matcher.group(1);\n+                        }\n+                        return null;\n+                    });\n+        }\n+\n+        private static final Path TOOL_RPM = Path.of(\"rpm\");\n+        private static final Path TOOL_RPMBUILD = Path.of(\"rpmbuild\");\n+        private static final DottedVersion TOOL_RPMBUILD_MIN_VERSION = DottedVersion.lazy(\"4.10\");\n+    }\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxRpmSystemEnvironmentMixin.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+import jdk.jpackage.internal.model.PackageType;\n+import jdk.jpackage.internal.model.StandardPackageType;\n+import jdk.jpackage.internal.util.CompositeProxy;\n+import jdk.jpackage.internal.util.Result;\n+\n+public interface LinuxSystemEnvironment extends SystemEnvironment {\n+    boolean soLookupAvailable();\n+    PackageType nativePackageType();\n+\n+    static Result<LinuxSystemEnvironment> create() {\n+        return detectNativePackageType().map(LinuxSystemEnvironment::create).orElseGet(() -> {\n+            return Result.ofError(new RuntimeException(\"Unknown native package type\"));\n+        });\n+    }\n+\n+    static Optional<PackageType> detectNativePackageType() {\n+        if (Internal.isDebian()) {\n+            return Optional.of(StandardPackageType.LINUX_DEB);\n+        } else if (Internal.isRpm()) {\n+            return Optional.of(StandardPackageType.LINUX_RPM);\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    static Result<LinuxSystemEnvironment> create(PackageType nativePackageType) {\n+        return Result.ofValue(new Stub(LibProvidersLookup.supported(),\n+                Objects.requireNonNull(nativePackageType)));\n+    }\n+\n+    static <T, U extends LinuxSystemEnvironment> U createWithMixin(Class<U> type, LinuxSystemEnvironment base, T mixin) {\n+        return CompositeProxy.create(type, base, mixin);\n+    }\n+\n+    static <T, U extends LinuxSystemEnvironment> Result<U> mixin(Class<U> type,\n+            Result<LinuxSystemEnvironment> base, Supplier<Result<T>> mixinResultSupplier) {\n+        final var mixin = mixinResultSupplier.get();\n+\n+        final List<Exception> errors = new ArrayList<>();\n+        errors.addAll(base.errors());\n+        errors.addAll(mixin.errors());\n+\n+        if (errors.isEmpty()) {\n+            return Result.ofValue(createWithMixin(type, base.orElseThrow(), mixin.orElseThrow()));\n+        } else {\n+            return Result.ofErrors(errors);\n+        }\n+    }\n+\n+    record Stub(boolean soLookupAvailable, PackageType nativePackageType) implements LinuxSystemEnvironment {\n+    }\n+\n+    static final class Internal {\n+\n+        private static boolean isDebian() {\n+            \/\/ we are just going to run \"dpkg -s coreutils\" and assume Debian\n+            \/\/ or derivative if no error is returned.\n+            try {\n+                Executor.of(\"dpkg\", \"-s\", \"coreutils\").executeExpectSuccess();\n+                return true;\n+            } catch (IOException e) {\n+                \/\/ just fall thru\n+                return false;\n+            }\n+        }\n+\n+        private static boolean isRpm() {\n+            \/\/ we are just going to run \"rpm -q rpm\" and assume RPM\n+            \/\/ or derivative if no error is returned.\n+            try {\n+                Executor.of(\"rpm\", \"-q\", \"rpm\").executeExpectSuccess();\n+                return true;\n+            } catch (IOException e) {\n+                \/\/ just fall thru\n+                return false;\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxSystemEnvironment.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -240,1 +240,1 @@\n-            final var codesignDir = Codesign.build(signingCfgWithoutEntitlements::toCodesignArgs).force(true).create().asConsumer();\n+            final var codesignDir = Codesign.build(signingCfg::toCodesignArgs).force(true).create().asConsumer();\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/AppImageSigner.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.nio.file.Files;\n@@ -32,0 +31,1 @@\n+import java.util.Optional;\n@@ -33,0 +33,1 @@\n+import jdk.jpackage.internal.model.MacDmgPackage;\n@@ -34,0 +35,1 @@\n+import jdk.jpackage.internal.util.Result;\n@@ -73,2 +75,1 @@\n-        final var pkg = MacFromParams.DMG_PACKAGE.fetchFrom(params);\n-        var env = MacBuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n+        var pkg = MacFromParams.DMG_PACKAGE.fetchFrom(params);\n@@ -76,1 +77,1 @@\n-        final var packager = MacDmgPackager.build().outputDir(outputParentDir).pkg(pkg).env(env);\n+        Log.verbose(I18N.format(\"message.building-dmg\", pkg.app().name()));\n@@ -78,3 +79,6 @@\n-        MacDmgPackager.findSetFileUtility().ifPresent(packager::setFileUtility);\n-\n-        return packager.execute();\n+        return Packager.<MacDmgPackage>build().outputDir(outputParentDir)\n+                .pkg(pkg)\n+                .env(MacBuildEnvFromParams.BUILD_ENV.fetchFrom(params))\n+                .pipelineBuilderMutatorFactory((env, _, outputDir) -> {\n+                    return new MacDmgPackager(env, pkg, outputDir, sysEnv.orElseThrow());\n+                }).execute(MacPackagingPipeline.build(Optional.of(pkg)));\n@@ -85,17 +89,1 @@\n-        return isSupported();\n-    }\n-\n-    public static final String[] required =\n-            {\"\/usr\/bin\/hdiutil\", \"\/usr\/bin\/osascript\"};\n-    public static boolean isSupported() {\n-        try {\n-            for (String s : required) {\n-                Path f = Path.of(s);\n-                if (!Files.exists(f) || !Files.isExecutable(f)) {\n-                    return false;\n-                }\n-            }\n-            return true;\n-        } catch (Exception e) {\n-            return false;\n-        }\n+        return sysEnv.hasValue();\n@@ -108,0 +96,2 @@\n+\n+    private final Result<MacDmgSystemEnvironment> sysEnv = MacDmgSystemEnvironment.create();\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacDmgBundler.java","additions":14,"deletions":24,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -39,2 +39,1 @@\n-import java.util.Optional;\n-import java.util.stream.Stream;\n+import java.util.function.Consumer;\n@@ -42,1 +41,0 @@\n-import jdk.jpackage.internal.PackagingPipeline.StartupParameters;\n@@ -45,1 +43,0 @@\n-import jdk.jpackage.internal.model.PackagerException;\n@@ -49,1 +46,2 @@\n-record MacDmgPackager(MacDmgPackage pkg, BuildEnv env, Path hdiutil, Path outputDir, Optional<Path> setFileUtility) {\n+record MacDmgPackager(BuildEnv env, MacDmgPackage pkg, Path outputDir,\n+        MacDmgSystemEnvironment sysEnv) implements Consumer<PackagingPipeline.Builder> {\n@@ -52,1 +50,0 @@\n-        Objects.requireNonNull(pkg);\n@@ -54,1 +51,1 @@\n-        Objects.requireNonNull(hdiutil);\n+        Objects.requireNonNull(pkg);\n@@ -56,5 +53,1 @@\n-        Objects.requireNonNull(setFileUtility);\n-    }\n-\n-    static Builder build() {\n-        return new Builder();\n+        Objects.requireNonNull(sysEnv);\n@@ -63,76 +56,2 @@\n-    static final class Builder extends PackagerBuilder<MacDmgPackage, Builder> {\n-\n-        Builder hdiutil(Path v) {\n-            hdiutil = v;\n-            return this;\n-        }\n-\n-        Builder setFileUtility(Path v) {\n-            setFileUtility = v;\n-            return this;\n-        }\n-\n-        Path execute() throws PackagerException {\n-            Log.verbose(MessageFormat.format(I18N.getString(\"message.building-dmg\"),\n-                    pkg.app().name()));\n-\n-            IOUtils.writableOutputDir(outputDir);\n-\n-            return execute(MacPackagingPipeline.build(Optional.of(pkg)));\n-        }\n-\n-        @Override\n-        protected void configurePackagingPipeline(PackagingPipeline.Builder pipelineBuilder,\n-                StartupParameters startupParameters) {\n-            final var packager = new MacDmgPackager(pkg, startupParameters.packagingEnv(),\n-                    validatedHdiutil(), outputDir, Optional.ofNullable(setFileUtility));\n-            packager.applyToPipeline(pipelineBuilder);\n-        }\n-\n-        private Path validatedHdiutil() {\n-            return Optional.ofNullable(hdiutil).orElse(HDIUTIL);\n-        }\n-\n-        private Path hdiutil;\n-        private Path setFileUtility;\n-    }\n-\n-    \/\/ Location of SetFile utility may be different depending on MacOS version\n-    \/\/ We look for several known places and if none of them work will\n-    \/\/ try to find it\n-    static Optional<Path> findSetFileUtility() {\n-        String typicalPaths[] = {\"\/Developer\/Tools\/SetFile\",\n-                \"\/usr\/bin\/SetFile\", \"\/Developer\/usr\/bin\/SetFile\"};\n-\n-        final var setFilePath = Stream.of(typicalPaths).map(Path::of).filter(Files::isExecutable).findFirst();\n-        if (setFilePath.isPresent()) {\n-            \/\/ Validate SetFile, if Xcode is not installed it will run, but exit with error\n-            \/\/ code\n-            try {\n-                if (Executor.of(setFilePath.orElseThrow().toString(), \"-h\").setQuiet(true).execute() == 0) {\n-                    return setFilePath;\n-                }\n-            } catch (Exception ignored) {\n-                \/\/ No need for generic find attempt. We found it, but it does not work.\n-                \/\/ Probably due to missing xcode.\n-                return Optional.empty();\n-            }\n-        }\n-\n-        \/\/ generic find attempt\n-        try {\n-            final var executor = Executor.of(\"\/usr\/bin\/xcrun\", \"-find\", \"SetFile\");\n-            final var code = executor.setQuiet(true).saveOutput(true).execute();\n-            if (code == 0 && executor.getOutput().isEmpty()) {\n-                final var firstLine = executor.getOutput().getFirst();\n-                Path f = Path.of(firstLine);\n-                if (Files.exists(f) && Files.isExecutable(f)) {\n-                    return Optional.of(f.toAbsolutePath());\n-                }\n-            }\n-        } catch (IOException ignored) {}\n-\n-        return Optional.empty();\n-    }\n-\n-    private void applyToPipeline(PackagingPipeline.Builder pipelineBuilder) {\n+    @Override\n+    public void accept(PackagingPipeline.Builder pipelineBuilder) {\n@@ -321,1 +240,1 @@\n-                hdiutil.toString(),\n+                sysEnv.hdiutil().toString(),\n@@ -344,1 +263,1 @@\n-                hdiutil.toString(),\n+                sysEnv.hdiutil().toString(),\n@@ -360,1 +279,1 @@\n-                hdiutil.toString(),\n+                sysEnv.hdiutil().toString(),\n@@ -385,1 +304,1 @@\n-                pb = new ProcessBuilder(\"\/usr\/bin\/osascript\",\n+                pb = new ProcessBuilder(sysEnv.osascript().toString(),\n@@ -400,1 +319,1 @@\n-            if (setFileUtility.isPresent()) {\n+            if (sysEnv.setFileUtility().isPresent()) {\n@@ -409,1 +328,1 @@\n-                            setFileUtility.orElseThrow().toString(),\n+                            sysEnv.setFileUtility().orElseThrow().toString(),\n@@ -416,1 +335,1 @@\n-                            setFileUtility.orElseThrow().toString(),\n+                            sysEnv.setFileUtility().orElseThrow().toString(),\n@@ -431,1 +350,1 @@\n-                    hdiutil.toString(),\n+                    sysEnv.hdiutil().toString(),\n@@ -454,1 +373,1 @@\n-                                hdiutil.toString(),\n+                                sysEnv.hdiutil().toString(),\n@@ -467,1 +386,1 @@\n-                hdiutil.toString(),\n+                sysEnv.hdiutil().toString(),\n@@ -484,1 +403,1 @@\n-                        hdiutil.toString(),\n+                        sysEnv.hdiutil().toString(),\n@@ -499,1 +418,1 @@\n-                    hdiutil.toString(),\n+                    sysEnv.hdiutil().toString(),\n@@ -530,2 +449,0 @@\n-\n-    private static final Path HDIUTIL = Path.of(\"\/usr\/bin\/hdiutil\");\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacDmgPackager.java","additions":19,"deletions":102,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.util.Result;\n+\n+record MacDmgSystemEnvironment(Path hdiutil, Path osascript, Optional<Path> setFileUtility) implements SystemEnvironment {\n+\n+    MacDmgSystemEnvironment {\n+    }\n+\n+    static Result<MacDmgSystemEnvironment> create() {\n+        final var errors = Stream.of(HDIUTIL, OSASCRIPT)\n+                .map(ToolValidator::new)\n+                .map(ToolValidator::checkExistsOnly)\n+                .map(ToolValidator::validate)\n+                .filter(Objects::nonNull)\n+                .toList();\n+        if (errors.isEmpty()) {\n+            return Result.ofValue(new MacDmgSystemEnvironment(HDIUTIL, OSASCRIPT, findSetFileUtility()));\n+        } else {\n+            return Result.ofErrors(errors);\n+        }\n+    }\n+\n+    \/\/ Location of SetFile utility may be different depending on MacOS version\n+    \/\/ We look for several known places and if none of them work will\n+    \/\/ try to find it\n+    private static Optional<Path> findSetFileUtility() {\n+        String typicalPaths[] = {\"\/Developer\/Tools\/SetFile\",\n+                \"\/usr\/bin\/SetFile\", \"\/Developer\/usr\/bin\/SetFile\"};\n+\n+        final var setFilePath = Stream.of(typicalPaths).map(Path::of).filter(Files::isExecutable).findFirst();\n+        if (setFilePath.isPresent()) {\n+            \/\/ Validate SetFile, if Xcode is not installed it will run, but exit with error\n+            \/\/ code\n+            try {\n+                if (Executor.of(setFilePath.orElseThrow().toString(), \"-h\").setQuiet(true).execute() == 0) {\n+                    return setFilePath;\n+                }\n+            } catch (Exception ignored) {\n+                \/\/ No need for generic find attempt. We found it, but it does not work.\n+                \/\/ Probably due to missing xcode.\n+                return Optional.empty();\n+            }\n+        }\n+\n+        \/\/ generic find attempt\n+        try {\n+            final var executor = Executor.of(\"\/usr\/bin\/xcrun\", \"-find\", \"SetFile\");\n+            final var code = executor.setQuiet(true).saveOutput(true).execute();\n+            if (code == 0 && !executor.getOutput().isEmpty()) {\n+                final var firstLine = executor.getOutput().getFirst();\n+                Path f = Path.of(firstLine);\n+                if (new ToolValidator(f).checkExistsOnly().validate() == null) {\n+                    return Optional.of(f.toAbsolutePath());\n+                }\n+            }\n+        } catch (IOException ignored) {}\n+\n+        return Optional.empty();\n+    }\n+\n+    private static final Path HDIUTIL = Path.of(\"\/usr\/bin\/hdiutil\");\n+    private static final Path OSASCRIPT = Path.of(\"\/usr\/bin\/osascript\");\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacDmgSystemEnvironment.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Optional;\n@@ -32,0 +33,1 @@\n+import jdk.jpackage.internal.model.MacPkgPackage;\n@@ -52,1 +54,1 @@\n-            final var pkgPkg = MacFromParams.PKG_PACKAGE.fetchFrom(params);\n+            final var pkg = MacFromParams.PKG_PACKAGE.fetchFrom(params);\n@@ -75,2 +77,1 @@\n-        final var pkg = MacFromParams.PKG_PACKAGE.fetchFrom(params);\n-        var env = MacBuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n+        var pkg = MacFromParams.PKG_PACKAGE.fetchFrom(params);\n@@ -78,1 +79,1 @@\n-        final var packager = MacPkgPackager.build().outputDir(outputParentDir).pkg(pkg).env(env);\n+        Log.verbose(I18N.format(\"message.building-pkg\", pkg.app().name()));\n@@ -80,1 +81,6 @@\n-        return packager.execute();\n+        return Packager.<MacPkgPackage>build().outputDir(outputParentDir)\n+                .pkg(pkg)\n+                .env(MacBuildEnvFromParams.BUILD_ENV.fetchFrom(params))\n+                .pipelineBuilderMutatorFactory((env, _, outputDir) -> {\n+                    return new MacPkgPackager(env, pkg, outputDir);\n+                }).execute(MacPackagingPipeline.build(Optional.of(pkg)));\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPkgBundler.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import java.util.function.Consumer;\n@@ -55,1 +56,0 @@\n-import jdk.jpackage.internal.PackagingPipeline.StartupParameters;\n@@ -58,1 +58,0 @@\n-import jdk.jpackage.internal.model.PackagerException;\n@@ -63,1 +62,13 @@\n-record MacPkgPackager(MacPkgPackage pkg, BuildEnv env, Optional<Services> services, Path outputDir) {\n+record MacPkgPackager(BuildEnv env, MacPkgPackage pkg, Optional<Services> services,\n+        Path outputDir) implements Consumer<PackagingPipeline.Builder> {\n+\n+    MacPkgPackager {\n+        Objects.requireNonNull(env);\n+        Objects.requireNonNull(pkg);\n+        Objects.requireNonNull(services);\n+        Objects.requireNonNull(outputDir);\n+    }\n+\n+    MacPkgPackager(BuildEnv env, MacPkgPackage pkg, Path outputDir) {\n+        this(env, pkg, createServices(env, pkg), outputDir);\n+    }\n@@ -72,31 +83,0 @@\n-    static Builder build() {\n-        return new Builder();\n-    }\n-\n-    static final class Builder extends PackagerBuilder<MacPkgPackage, Builder> {\n-\n-        Path execute() throws PackagerException {\n-            Log.verbose(MessageFormat.format(I18N.getString(\"message.building-pkg\"),\n-                    pkg.app().name()));\n-\n-            IOUtils.writableOutputDir(outputDir);\n-\n-            return execute(MacPackagingPipeline.build(Optional.of(pkg)));\n-        }\n-\n-        @Override\n-        protected void configurePackagingPipeline(PackagingPipeline.Builder pipelineBuilder,\n-                StartupParameters startupParameters) {\n-            final var packager = new MacPkgPackager(pkg, startupParameters.packagingEnv(), createServices(), outputDir);\n-            packager.applyToPipeline(pipelineBuilder);\n-        }\n-\n-        private Optional<Services> createServices() {\n-            if (pkg.app().isService()) {\n-                return Optional.of(Services.create(pkg, env));\n-            } else {\n-                return Optional.empty();\n-            }\n-        }\n-    }\n-\n@@ -233,1 +213,2 @@\n-    private void applyToPipeline(PackagingPipeline.Builder pipelineBuilder) {\n+    @Override\n+    public void accept(PackagingPipeline.Builder pipelineBuilder) {\n@@ -562,0 +543,8 @@\n+    private static Optional<Services> createServices(BuildEnv env, MacPkgPackage pkg) {\n+        if (pkg.app().isService()) {\n+            return Optional.of(Services.create(pkg, env));\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPkgPackager.java","additions":24,"deletions":35,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import jdk.jpackage.internal.model.Package;\n+import jdk.jpackage.internal.model.PackagerException;\n+\n+final class Packager<T extends Package> {\n+\n+    static <T extends Package> Packager<T> build() {\n+        return new Packager<>();\n+    }\n+\n+    Packager<T> pkg(T v) {\n+        pkg = v;\n+        return this;\n+    }\n+\n+    Packager<T> env(BuildEnv v) {\n+        env = v;\n+        return this;\n+    }\n+\n+    Packager<T> outputDir(Path v) {\n+        outputDir = v;\n+        return this;\n+    }\n+\n+    Packager<T> pipelineBuilderMutatorFactory(PipelineBuilderMutatorFactory<T> v) {\n+        pipelineBuilderMutatorFactory = v;\n+        return this;\n+    }\n+\n+    T pkg() {\n+        return Objects.requireNonNull(pkg);\n+    }\n+\n+    Path outputDir() {\n+        return Objects.requireNonNull(outputDir);\n+    }\n+\n+    BuildEnv env() {\n+        return Objects.requireNonNull(env);\n+    }\n+\n+    Path execute(PackagingPipeline.Builder pipelineBuilder) throws PackagerException {\n+        Objects.requireNonNull(pkg);\n+        Objects.requireNonNull(env);\n+        Objects.requireNonNull(outputDir);\n+\n+        IOUtils.writableOutputDir(outputDir);\n+\n+        final var startupParameters = pipelineBuilder.createStartupParameters(env, pkg, outputDir);\n+\n+        pipelineBuilderMutatorFactory().ifPresent(factory -> {\n+            factory.create(startupParameters.packagingEnv(), pkg, outputDir).accept(pipelineBuilder);\n+        });\n+\n+        pipelineBuilder.create().execute(startupParameters);\n+\n+        return outputDir.resolve(pkg.packageFileNameWithSuffix());\n+    }\n+\n+\n+    @FunctionalInterface\n+    interface PipelineBuilderMutatorFactory<T extends Package> {\n+        Consumer<PackagingPipeline.Builder> create(BuildEnv env, T pkg, Path outputDir);\n+    }\n+\n+\n+    private Optional<PipelineBuilderMutatorFactory<T>> pipelineBuilderMutatorFactory() {\n+        return Optional.ofNullable(pipelineBuilderMutatorFactory);\n+    }\n+\n+    private T pkg;\n+    private BuildEnv env;\n+    private Path outputDir;\n+    private PipelineBuilderMutatorFactory<T> pipelineBuilderMutatorFactory;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Packager.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -1,75 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal;\n-\n-import java.nio.file.Path;\n-import java.util.Objects;\n-import jdk.jpackage.internal.PackagingPipeline.StartupParameters;\n-import jdk.jpackage.internal.model.Package;\n-import jdk.jpackage.internal.model.PackagerException;\n-\n-abstract class PackagerBuilder<T extends Package, U extends PackagerBuilder<T, U>> {\n-\n-    U pkg(T v) {\n-        pkg = v;\n-        return thiz();\n-    }\n-\n-    U env(BuildEnv v) {\n-        env = v;\n-        return thiz();\n-    }\n-\n-    U outputDir(Path v) {\n-        outputDir = v;\n-        return thiz();\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private U thiz() {\n-        return (U)this;\n-    }\n-\n-    protected abstract void configurePackagingPipeline(PackagingPipeline.Builder pipelineBuilder,\n-            StartupParameters startupParameters);\n-\n-    Path execute(PackagingPipeline.Builder pipelineBuilder) throws PackagerException {\n-        Objects.requireNonNull(pkg);\n-        Objects.requireNonNull(env);\n-        Objects.requireNonNull(outputDir);\n-\n-        final var startupParameters = pipelineBuilder.createStartupParameters(env, pkg, outputDir);\n-\n-        configurePackagingPipeline(pipelineBuilder, startupParameters);\n-\n-        pipelineBuilder.create().execute(startupParameters);\n-\n-        return outputDir.resolve(pkg.packageFileNameWithSuffix());\n-    }\n-\n-    protected T pkg;\n-    protected BuildEnv env;\n-    protected Path outputDir;\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/PackagerBuilder.java","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+public interface SystemEnvironment {\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/SystemEnvironment.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -27,3 +27,0 @@\n-import jdk.internal.util.OperatingSystem;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.model.DottedVersion;\n@@ -31,0 +28,1 @@\n+import java.nio.file.Files;\n@@ -32,1 +30,0 @@\n-import java.text.MessageFormat;\n@@ -35,1 +32,1 @@\n-import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.Objects;\n@@ -39,0 +36,3 @@\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.DottedVersion;\n@@ -41,1 +41,1 @@\n-public final class ToolValidator {\n+final class ToolValidator {\n@@ -48,3 +48,1 @@\n-        this.toolPath = toolPath;\n-        args = new ArrayList<>();\n-\n+        this.toolPath = Objects.requireNonNull(toolPath);\n@@ -54,3 +52,0 @@\n-\n-        setToolNotFoundErrorHandler(null);\n-        setToolOldVersionErrorHandler(null);\n@@ -70,1 +65,11 @@\n-        return setMinimalVersion(t -> DottedVersion.compareComponents(v, DottedVersion.lazy(t)));\n+        return setMinimalVersion(new Comparable<String>() {\n+            @Override\n+            public int compareTo(String o) {\n+                return DottedVersion.compareComponents(v, DottedVersion.lazy(o));\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return v.toString();\n+            }\n+        });\n@@ -78,2 +83,1 @@\n-    ToolValidator setToolNotFoundErrorHandler(\n-            BiFunction<String, IOException, ConfigException> v) {\n+    ToolValidator setToolNotFoundErrorHandler(Function<Path, ConfigException> v) {\n@@ -84,1 +88,1 @@\n-    ToolValidator setToolOldVersionErrorHandler(BiFunction<String, String, ConfigException> v) {\n+    ToolValidator setToolOldVersionErrorHandler(BiFunction<Path, String, ConfigException> v) {\n@@ -89,0 +93,9 @@\n+    ToolValidator checkExistsOnly(boolean v) {\n+        checkExistsOnly = v;\n+        return this;\n+    }\n+\n+    ToolValidator checkExistsOnly() {\n+        return checkExistsOnly(true);\n+    }\n+\n@@ -90,0 +103,15 @@\n+        if (checkExistsOnly) {\n+            if (Files.isExecutable(toolPath) && !Files.isDirectory(toolPath)) {\n+                return null;\n+            } else if (Files.exists(toolPath)) {\n+                return new ConfigException(\n+                        I18N.format(\"error.tool-not-executable\", toolPath), (String)null);\n+            } else if (toolNotFoundErrorHandler != null) {\n+                return toolNotFoundErrorHandler.apply(toolPath);\n+            } else {\n+                return new ConfigException(\n+                        I18N.format(\"error.tool-not-found\", toolPath),\n+                        I18N.format(\"error.tool-not-found.advice\", toolPath));\n+            }\n+        }\n+\n@@ -92,1 +120,3 @@\n-        cmdline.addAll(args);\n+        if (args != null) {\n+            cmdline.addAll(args);\n+        }\n@@ -94,8 +124,5 @@\n-        String name = IOUtils.getFileName(toolPath).toString();\n-        try {\n-            ProcessBuilder pb = new ProcessBuilder(cmdline);\n-            AtomicBoolean canUseTool = new AtomicBoolean();\n-            if (minimalVersion == null) {\n-                \/\/ No version check.\n-                canUseTool.setPlain(true);\n-            }\n+        boolean canUseTool[] = new boolean[1];\n+        if (minimalVersion == null) {\n+            \/\/ No version check.\n+            canUseTool[0] = true;\n+        }\n@@ -103,2 +130,4 @@\n-            String[] version = new String[1];\n-            Executor.of(pb).setQuiet(true).setOutputConsumer(lines -> {\n+        String[] version = new String[1];\n+\n+        try {\n+            Executor.of(cmdline.toArray(String[]::new)).setQuiet(true).setOutputConsumer(lines -> {\n@@ -107,2 +136,2 @@\n-                    if (minimalVersion.compareTo(version[0]) < 0) {\n-                        canUseTool.setPlain(true);\n+                    if (version[0] != null && minimalVersion.compareTo(version[0]) <= 0) {\n+                        canUseTool[0] = true;\n@@ -112,11 +141,0 @@\n-\n-            if (!canUseTool.getPlain()) {\n-                if (toolOldVersionErrorHandler != null) {\n-                    return toolOldVersionErrorHandler.apply(name, version[0]);\n-                }\n-                return new ConfigException(MessageFormat.format(I18N.getString(\n-                        \"error.tool-old-version\"), name, minimalVersion),\n-                        MessageFormat.format(I18N.getString(\n-                                \"error.tool-old-version.advice\"), name,\n-                                minimalVersion));\n-            }\n@@ -124,7 +142,1 @@\n-            if (toolNotFoundErrorHandler != null) {\n-                return toolNotFoundErrorHandler.apply(name, e);\n-            }\n-            return new ConfigException(MessageFormat.format(I18N.getString(\n-                    \"error.tool-not-found\"), name, e.getMessage()),\n-                    MessageFormat.format(I18N.getString(\n-                            \"error.tool-not-found.advice\"), name), e);\n+            return new ConfigException(I18N.format(\"error.tool-error\", toolPath, e.getMessage()), null, e);\n@@ -133,2 +145,10 @@\n-        \/\/ All good. Tool can be used.\n-        return null;\n+        if (canUseTool[0]) {\n+            \/\/ All good. Tool can be used.\n+            return null;\n+        } else if (toolOldVersionErrorHandler != null) {\n+            return toolOldVersionErrorHandler.apply(toolPath, version[0]);\n+        } else {\n+            return new ConfigException(\n+                    I18N.format(\"error.tool-old-version\", toolPath, minimalVersion),\n+                    I18N.format(\"error.tool-old-version.advice\", toolPath, minimalVersion));\n+        }\n@@ -141,2 +161,3 @@\n-    private BiFunction<String, IOException, ConfigException> toolNotFoundErrorHandler;\n-    private BiFunction<String, String, ConfigException> toolOldVersionErrorHandler;\n+    private Function<Path, ConfigException> toolNotFoundErrorHandler;\n+    private BiFunction<Path, String, ConfigException> toolOldVersionErrorHandler;\n+    private boolean checkExistsOnly;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ToolValidator.java","additions":72,"deletions":51,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -69,4 +69,7 @@\n-error.tool-not-found=Can not find {0}. Reason: {1}\n-error.tool-not-found.advice=Please install {0}\n-error.tool-old-version=Can not find {0} {1} or newer\n-error.tool-old-version.advice=Please install {0} {1} or newer\n+error.tool-error=Can not validate \"{0}\". Reason: {1}\n+error.tool-not-executable=\"{0}\" is not executable\n+error.tool-not-found=Can not find \"{0}\"\n+error.tool-not-found.advice=Please install \"{0}\"\n+error.tool-old-version=Can not find \"{0}\" {1} or newer\n+error.tool-old-version.advice=Please install \"{0}\" {1} or newer\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/MainResources.properties","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n+\n@@ -29,0 +31,1 @@\n+import java.util.HashMap;\n@@ -30,0 +33,1 @@\n+import java.util.Map;\n@@ -33,0 +37,1 @@\n+import java.util.stream.Stream;\n@@ -34,0 +39,1 @@\n+import javax.xml.xpath.XPath;\n@@ -36,1 +42,1 @@\n-import jdk.jpackage.internal.util.function.ThrowingSupplier;\n+import org.w3c.dom.Element;\n@@ -40,0 +46,3 @@\n+\/**\n+ * Property list (plist) file reader.\n+ *\/\n@@ -42,0 +51,111 @@\n+    public record Raw(String value, Type type) {\n+\n+        public enum Type {\n+            STRING,\n+            BOOLEAN,\n+            REAL,\n+            INTEGER,\n+            DATE,\n+            DATA;\n+\n+            private static Optional<Type> fromElementName(String name) {\n+                switch (name) {\n+                    case \"string\" -> {\n+                        return Optional.of(STRING);\n+                    }\n+                    case \"true\" -> {\n+                        return Optional.of(BOOLEAN);\n+                    }\n+                    case \"false\" -> {\n+                        return Optional.of(BOOLEAN);\n+                    }\n+                    case \"real\" -> {\n+                        return Optional.of(REAL);\n+                    }\n+                    case \"integer\" -> {\n+                        return Optional.of(INTEGER);\n+                    }\n+                    case \"date\" -> {\n+                        return Optional.of(DATE);\n+                    }\n+                    case \"data\" -> {\n+                        return Optional.of(DATA);\n+                    }\n+                    default -> {\n+                        return Optional.empty();\n+                    }\n+                }\n+            }\n+        }\n+\n+        public Raw {\n+            Objects.requireNonNull(value);\n+            Objects.requireNonNull(type);\n+        }\n+\n+        private static Optional<Raw> tryCreate(Element e) {\n+            return Type.fromElementName(e.getNodeName()).map(type -> {\n+                if (type == Type.BOOLEAN) {\n+                    if (\"true\".equals(e.getNodeName())) {\n+                        return new Raw(Boolean.TRUE.toString(), type);\n+                    } else {\n+                        return new Raw(Boolean.FALSE.toString(), type);\n+                    }\n+                } else {\n+                    return new Raw(e.getTextContent(), type);\n+                }\n+            });\n+        }\n+    }\n+\n+    \/**\n+     * Returns the contents of the the underlying \"dict\" element as a Map.\n+     * <p>\n+     * The keys in the returned map are names of the properties.\n+     * <p>\n+     * Values of nested \"dict\" properties are stored as {@code Map<String, Object>}\n+     * or {@code PListReader} objects depending on the value of the\n+     * {@code fetchDictionaries} parameter.\n+     * <p>\n+     * Values of \"array\" properties are stored as {@code List<Object>} objects.\n+     * <p>\n+     * Values of other properties are stored as {@code Raw} objects.\n+     *\n+     * @param fetchDictionaries controls the type of objects of nested \"dict\"\n+     *                          elements. If the value is {@code true},\n+     *                          {@code Map<String, Object>} type is used, and\n+     *                          {@code PListReader} type otherwise.\n+     * @return the contents of the the underlying \"dict\" element as a Map\n+     *\/\n+    public Map<String, Object> toMap(boolean fetchDictionaries) {\n+        Map<String, Object> reply = new HashMap<>();\n+        var nodes = root.getChildNodes();\n+        for (int i = 0; i != nodes.getLength(); i++) {\n+            if (nodes.item(i) instanceof Element e) {\n+                tryCreateValue(e, fetchDictionaries).ifPresent(value -> {\n+                    final var query = \"preceding-sibling::*[1]\";\n+                    Optional.ofNullable(toSupplier(() -> {\n+                        return (Node) XPathSingleton.INSTANCE.evaluate(query, e, XPathConstants.NODE);\n+                    }).get()).ifPresent(n -> {\n+                        if (\"key\".equals(n.getNodeName())) {\n+                            var keyName = n.getTextContent();\n+                            reply.putIfAbsent(keyName, value);\n+                        }\n+                    });\n+                });\n+            }\n+        }\n+\n+        return reply;\n+    }\n+\n+    \/**\n+     * Returns the value of the given string property in the underlying \"dict\"\n+     * element.\n+     *\n+     * @param keyName the name of a string property whose value to query\n+     * @return the value of the string property with the specified name in the\n+     *         underlying \"dict\" element\n+     * @throws NoSuchElementException if there is no string property with the given\n+     *                                name in the underlying \"dict\" element\n+     *\/\n@@ -54,0 +174,32 @@\n+    \/**\n+     * Returns the value of the given \"dict\" property in the underlying \"dict\"\n+     * element.\n+     *\n+     * @param keyName the name of a \"dict\" property whose value to query\n+     * @return the value of the \"dict\" property with the specified name in the\n+     *         underlying \"dict\" element\n+     * @throws NoSuchElementException if there is no \"dict\" property with the given\n+     *                                name in the underlying \"dict\" element\n+     *\/\n+    public PListReader queryDictValue(String keyName) {\n+        final var node = getNode(keyName);\n+        switch (node.getNodeName()) {\n+            case \"dict\" -> {\n+                return new PListReader(node);\n+            }\n+            default -> {\n+                throw new NoSuchElementException();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Returns the value of the given boolean property in the underlying \"dict\"\n+     * element.\n+     *\n+     * @param keyName the name of a boolean property whose value to query\n+     * @return the value of the boolean property with the specified name in the\n+     *         underlying \"dict\" element\n+     * @throws NoSuchElementException if there is no string property with the given\n+     *                                name in the underlying \"dict\" element\n+     *\/\n@@ -69,1 +221,48 @@\n-    public List<String> queryArrayValue(String keyName) {\n+    \/**\n+     * Returns the value of the given array property in the underlying \"dict\"\n+     * element as a list of strings.\n+     * <p>\n+     * Processes the result of calling {@link #queryArrayValue(String)} on the\n+     * specified property name by filtering {@link Raw} instances of type\n+     * {@link Raw.Type#STRING}.\n+     *\n+     * @param keyName the name of an array property whose value to query\n+     * @return the value of the array property with the specified name in the\n+     *         underlying \"dict\" element\n+     * @throws NoSuchElementException if there is no array property with the given\n+     *                                name in the underlying \"dict\" element\n+     *\/\n+    public List<String> queryStringArrayValue(String keyName) {\n+        return queryArrayValue(keyName, false).map(v -> {\n+            if (v instanceof Raw r) {\n+                if (r.type() == Raw.Type.STRING) {\n+                    return r.value();\n+                }\n+            }\n+            return (String)null;\n+        }).filter(Objects::nonNull).toList();\n+    }\n+\n+    \/**\n+     * Returns the value of the given array property in the underlying \"dict\"\n+     * element as a stream of {@link Object}-s.\n+     * <p>\n+     * Values of \"dict\" array items are stored as {@code Map<String, Object>} or\n+     * {@code PListReader} objects depending on the value of the\n+     * {@code fetchDictionaries} parameter.\n+     * <p>\n+     * Values of \"array\" array items are stored as {@code List<Object>} objects.\n+     * <p>\n+     * Values of other types are stored as {@code Raw} objects.\n+     *\n+     * @param keyName           the name of an array property whose value to query\n+     * @param fetchDictionaries controls the type of objects of \"dict\" elements. If\n+     *                          the value is {@code true},\n+     *                          {@code Map<String, Object>} type is used, and\n+     *                          {@code PListReader} type otherwise.\n+     * @return the value of the array property with the specified name in the\n+     *         underlying \"dict\" element\n+     * @throws NoSuchElementException if there is no array key with the given name\n+     *                                in the underlying \"dict\" element\n+     *\/\n+    public Stream<Object> queryArrayValue(String keyName, boolean fetchDictionaries) {\n@@ -73,3 +272,1 @@\n-                return XmlUtils.toStream(node.getChildNodes()).filter(n -> {\n-                    return n.getNodeName().equals(\"string\");\n-                }).map(Node::getTextContent).toList();\n+                return readArray(node, fetchDictionaries);\n@@ -83,2 +280,21 @@\n-    public PListReader(Node doc) {\n-        this.root = Objects.requireNonNull(doc);\n+    \/**\n+     * Creates plist reader from the given node.\n+     * <p>\n+     * If the specified node is an element with the name \"dict\", the reader is bound\n+     * to the specified node; otherwise, it is bound to the {@code \/plist\/dict}\n+     * element in the document.\n+     *\n+     * @param node the node\n+     * @throws NoSuchElementException if the specified node is not an element with\n+     *                                name \"dict\" and there is no\n+     *                                {@code \/plist\/dict} node in the document\n+     *\/\n+    public PListReader(Node node) {\n+        Objects.requireNonNull(node);\n+        if (node.getNodeName().equals(\"dict\")) {\n+            this.root = node;\n+        } else {\n+            this.root = Optional.ofNullable(toSupplier(() -> {\n+                return (Node) XPathSingleton.INSTANCE.evaluate(\"\/plist[1]\/dict[1]\", node, XPathConstants.NODE);\n+            }).get()).orElseThrow(NoSuchElementException::new);\n+        }\n@@ -91,0 +307,29 @@\n+    private Optional<?> tryCreateValue(Element e, boolean fetchDictionaries) {\n+        switch (e.getNodeName()) {\n+            case \"dict\" -> {\n+                var plistReader = new PListReader(e);\n+                if (fetchDictionaries) {\n+                    return Optional.of(plistReader.toMap(fetchDictionaries));\n+                } else {\n+                    return Optional.of(plistReader);\n+                }\n+            }\n+            case \"array\" -> {\n+                return Optional.of(readArray(e, fetchDictionaries).toList());\n+            }\n+            default -> {\n+                return Raw.tryCreate(e);\n+            }\n+        }\n+    }\n+\n+    private Stream<Object> readArray(Node node, boolean fetchDictionaries) {\n+        return XmlUtils.toStream(node.getChildNodes()).map(n -> {\n+            if (n instanceof Element e) {\n+                return tryCreateValue(e, fetchDictionaries);\n+            } else {\n+                return Optional.<Raw>empty();\n+            }\n+        }).filter(Optional::isPresent).map(Optional::get);\n+    }\n+\n@@ -92,4 +337,4 @@\n-        final var xPath = XPathFactory.newInstance().newXPath();\n-        final var query = String.format(\"\/\/*[preceding-sibling::key = \\\"%s\\\"][1]\", keyName);\n-        return Optional.ofNullable(ThrowingSupplier.toSupplier(() -> {\n-            return (Node) xPath.evaluate(query, root, XPathConstants.NODE);\n+        Objects.requireNonNull(keyName);\n+        final var query = String.format(\"*[preceding-sibling::key = \\\"%s\\\"][1]\", keyName);\n+        return Optional.ofNullable(toSupplier(() -> {\n+            return (Node) XPathSingleton.INSTANCE.evaluate(query, root, XPathConstants.NODE);\n@@ -99,0 +344,6 @@\n+\n+    private static final class XPathSingleton {\n+        private static final XPath INSTANCE = XPathFactory.newInstance().newXPath();\n+    }\n+\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/PListReader.java","additions":262,"deletions":11,"binary":false,"changes":273,"status":"modified"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.util;\n+\n+import static jdk.jpackage.internal.util.function.ExceptionBox.rethrowUnchecked;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.StreamSupport;\n+\n+\n+public record Result<T>(Optional<T> value, Collection<? extends Exception> errors) {\n+    public Result {\n+        if (value.isEmpty() == errors.isEmpty()) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        if (value.isEmpty() && errors.isEmpty()) {\n+            throw new IllegalArgumentException(\"Error collection must be non-empty\");\n+        }\n+\n+    }\n+\n+    public T orElseThrow() {\n+        firstError().ifPresent(ex -> {\n+            rethrowUnchecked(ex);\n+        });\n+        return value.orElseThrow();\n+    }\n+\n+    public boolean hasValue() {\n+        return value.isPresent();\n+    }\n+\n+    public boolean hasErrors() {\n+        return !errors.isEmpty();\n+    }\n+\n+    public <U> Result<U> map(Function<T, U> conv) {\n+        return new Result<>(value.map(conv), errors);\n+    }\n+\n+    public <U> Result<U> flatMap(Function<T, Result<U>> conv) {\n+        return value.map(conv).orElseGet(() -> {\n+            return new Result<>(Optional.empty(), errors);\n+        });\n+    }\n+\n+    public Result<T> mapErrors(UnaryOperator<Collection<? extends Exception>> errorsMapper) {\n+        return new Result<>(value, errorsMapper.apply(errors));\n+    }\n+\n+    public <U> Result<U> mapErrors() {\n+        return new Result<>(Optional.empty(), errors);\n+    }\n+\n+    public Result<T> peekErrors(Consumer<Collection<? extends Exception>> consumer) {\n+        if (hasErrors()) {\n+            consumer.accept(errors);\n+        }\n+        return this;\n+    }\n+\n+    public Result<T> peekValue(Consumer<T> consumer) {\n+        value.ifPresent(consumer);\n+        return this;\n+    }\n+\n+    public Optional<? extends Exception> firstError() {\n+        return errors.stream().findFirst();\n+    }\n+\n+    public static <T> Result<T> create(Supplier<T> supplier) {\n+        try {\n+            return ofValue(supplier.get());\n+        } catch (Exception ex) {\n+            return ofError(ex);\n+        }\n+    }\n+\n+    public static <T> Result<T> ofValue(T value) {\n+        return new Result<>(Optional.of(value), List.of());\n+    }\n+\n+    public static <T> Result<T> ofErrors(Collection<? extends Exception> errors) {\n+        return new Result<>(Optional.empty(), List.copyOf(errors));\n+    }\n+\n+    public static <T> Result<T> ofError(Exception error) {\n+        return ofErrors(List.of(error));\n+    }\n+\n+    public static boolean allHaveValues(Iterable<? extends Result<?>> results) {\n+        return StreamSupport.stream(results.spliterator(), false).allMatch(Result::hasValue);\n+    }\n+\n+    public static boolean allHaveValues(Result<?>... results) {\n+        return allHaveValues(List.of(results));\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/Result.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -27,5 +27,0 @@\n-import static jdk.jpackage.internal.StandardBundlerParam.ICON;\n-import static jdk.jpackage.internal.util.function.ThrowingRunnable.toRunnable;\n-\n-import java.io.IOException;\n-import java.nio.file.Files;\n@@ -33,1 +28,0 @@\n-import java.nio.file.StandardCopyOption;\n@@ -37,1 +31,1 @@\n-import jdk.jpackage.internal.model.WinExePackage;\n+import jdk.jpackage.internal.model.WinMsiPackage;\n@@ -82,1 +76,1 @@\n-        var pkg = WinFromParams.MSI_PACKAGE.fetchFrom(params);\n+        var pkg = WinFromParams.EXE_PACKAGE.fetchFrom(params);\n@@ -85,22 +79,11 @@\n-        IOUtils.writableOutputDir(outdir);\n-\n-        Path msiDir = env.buildRoot().resolve(\"msi\");\n-        toRunnable(() -> Files.createDirectories(msiDir)).run();\n-\n-        \/\/ Write msi to temporary directory.\n-        Path msi = msiBundler.execute(params, msiDir);\n-\n-        try {\n-            new ScriptRunner()\n-            .setDirectory(msi.getParent())\n-            .setResourceCategoryId(\"resource.post-msi-script\")\n-            .setScriptNameSuffix(\"post-msi\")\n-            .setEnvironmentVariable(\"JpMsiFile\", msi.toAbsolutePath().toString())\n-            .run(env, pkg.packageName());\n-\n-            var exePkg = new WinExePackageBuilder(pkg).icon(ICON.fetchFrom(params)).create();\n-            return buildEXE(env, exePkg, msi, outdir);\n-        } catch (IOException|ConfigException ex) {\n-            Log.verbose(ex);\n-            throw new PackagerException(ex);\n-        }\n+        var msiOutputDir = env.buildRoot().resolve(\"msi\");\n+\n+        return Packager.<WinMsiPackage>build().outputDir(msiOutputDir)\n+                .pkg(pkg.msiPackage())\n+                .env(env)\n+                .pipelineBuilderMutatorFactory((packagingEnv, msiPackage, _) -> {\n+                    var msiPackager = new WinMsiPackager(packagingEnv, msiPackage,\n+                            msiOutputDir, msiBundler.sysEnv.orElseThrow());\n+                    var exePackager = new WinExePackager(packagingEnv, pkg, outdir, msiOutputDir);\n+                    return msiPackager.andThen(exePackager);\n+                }).execute(WinPackagingPipeline.build());\n@@ -109,28 +92,1 @@\n-    private Path buildEXE(BuildEnv env, WinExePackage pkg, Path msi,\n-            Path outdir) throws IOException {\n-\n-        Log.verbose(I18N.format(\"message.outputting-to-location\", outdir.toAbsolutePath()));\n-\n-        \/\/ Copy template msi wrapper next to msi file\n-        final Path exePath = msi.getParent().resolve(pkg.packageFileNameWithSuffix());\n-\n-        env.createResource(\"msiwrapper.exe\")\n-                .setCategory(I18N.getString(\"resource.installer-exe\"))\n-                .setPublicName(\"installer.exe\")\n-                .saveToFile(exePath);\n-\n-        new ExecutableRebrander(pkg, env::createResource, resourceLock -> {\n-            \/\/ Embed msi in msi wrapper exe.\n-            embedMSI(resourceLock, msi.toAbsolutePath().toString());\n-        }).execute(env, exePath, pkg.icon());\n-\n-        Path dstExePath = outdir.resolve(exePath.getFileName());\n-\n-        Files.copy(exePath, dstExePath, StandardCopyOption.REPLACE_EXISTING);\n-\n-        dstExePath.toFile().setExecutable(true);\n-\n-        Log.verbose(I18N.format(\"message.output-location\", outdir.toAbsolutePath()));\n-\n-        return dstExePath;\n-    }\n+    static native int embedMSI(long resourceLock, String msiPath);\n@@ -139,2 +95,0 @@\n-\n-    private static native int embedMSI(long resourceLock, String msiPath);\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinExeBundler.java","additions":14,"deletions":60,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import jdk.jpackage.internal.PackagingPipeline.PackageTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.PrimaryTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.TaskID;\n+import jdk.jpackage.internal.model.WinExePackage;\n+\n+final record WinExePackager(BuildEnv env, WinExePackage pkg, Path outputDir, Path msiOutputDir) implements Consumer<PackagingPipeline.Builder> {\n+\n+    WinExePackager {\n+        Objects.requireNonNull(env);\n+        Objects.requireNonNull(pkg);\n+        Objects.requireNonNull(outputDir);\n+        Objects.requireNonNull(msiOutputDir);\n+    }\n+\n+    enum ExePackageTaskID implements TaskID {\n+        RUN_POST_MSI_USER_SCRIPT,\n+        WRAP_MSI_IN_EXE\n+    }\n+\n+    @Override\n+    public void accept(PackagingPipeline.Builder pipelineBuilder) {\n+        pipelineBuilder.excludeDirFromCopying(outputDir)\n+                .task(ExePackageTaskID.RUN_POST_MSI_USER_SCRIPT)\n+                        .action(this::runPostMsiScript)\n+                        .addDependency(PackageTaskID.CREATE_PACKAGE_FILE)\n+                        .add()\n+                .task(ExePackageTaskID.WRAP_MSI_IN_EXE)\n+                        .action(this::wrapMsiInExe)\n+                        .addDependency(ExePackageTaskID.RUN_POST_MSI_USER_SCRIPT)\n+                        .addDependent(PrimaryTaskID.PACKAGE)\n+                        .add();\n+    }\n+\n+    private Path msi() {\n+        return msiOutputDir.resolve(pkg.msiPackage().packageFileNameWithSuffix());\n+    }\n+\n+    private void runPostMsiScript() throws IOException {\n+        new ScriptRunner()\n+        .setDirectory(msiOutputDir)\n+        .setResourceCategoryId(\"resource.post-msi-script\")\n+        .setScriptNameSuffix(\"post-msi\")\n+        .setEnvironmentVariable(\"JpMsiFile\", msi().toAbsolutePath().toString())\n+        .run(env, pkg.msiPackage().packageName());\n+    }\n+\n+    private void wrapMsiInExe() throws IOException {\n+\n+        Log.verbose(I18N.format(\"message.outputting-to-location\", outputDir.toAbsolutePath()));\n+\n+        final var msi = msi();\n+\n+        \/\/ Copy template msi wrapper next to msi file\n+        final Path exePath = msi.getParent().resolve(pkg.packageFileNameWithSuffix());\n+\n+        env.createResource(\"msiwrapper.exe\")\n+                .setCategory(I18N.getString(\"resource.installer-exe\"))\n+                .setPublicName(\"installer.exe\")\n+                .saveToFile(exePath);\n+\n+        new ExecutableRebrander(pkg, env::createResource, resourceLock -> {\n+            \/\/ Embed msi in msi wrapper exe.\n+            WinExeBundler.embedMSI(resourceLock, msi.toAbsolutePath().toString());\n+        }).execute(env, exePath, pkg.icon());\n+\n+        Path dstExePath = outputDir.resolve(exePath.getFileName());\n+\n+        Files.createDirectories(dstExePath.getParent());\n+        Files.copy(exePath, dstExePath, StandardCopyOption.REPLACE_EXISTING);\n+\n+        dstExePath.toFile().setExecutable(true);\n+\n+        Log.verbose(I18N.format(\"message.output-location\", outputDir.toAbsolutePath()));\n+    }\n+}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinExePackager.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -34,0 +34,1 @@\n+import static jdk.jpackage.internal.StandardBundlerParam.ICON;\n@@ -44,0 +45,1 @@\n+import jdk.jpackage.internal.model.WinExePackage;\n@@ -102,0 +104,11 @@\n+    private static WinExePackage createWinExePackage(Map<String, ? super Object> params) throws ConfigException, IOException {\n+\n+        final var msiPkg = MSI_PACKAGE.fetchFrom(params);\n+\n+        final var pkgBuilder = new WinExePackageBuilder(msiPkg);\n+\n+        ICON.copyInto(params, pkgBuilder::icon);\n+\n+        return pkgBuilder.create();\n+    }\n+\n@@ -108,0 +121,3 @@\n+    static final BundlerParamInfo<WinExePackage> EXE_PACKAGE = createPackageBundlerParam(\n+            WinFromParams::createWinExePackage);\n+\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinFromParams.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -30,7 +30,0 @@\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.UncheckedIOException;\n-import java.io.Writer;\n-import java.nio.charset.Charset;\n-import java.nio.file.FileSystems;\n-import java.nio.file.Files;\n@@ -38,6 +31,0 @@\n-import java.nio.file.PathMatcher;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n@@ -45,13 +32,0 @@\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n-import javax.xml.parsers.ParserConfigurationException;\n-import javax.xml.xpath.XPath;\n-import javax.xml.xpath.XPathConstants;\n-import javax.xml.xpath.XPathExpressionException;\n-import javax.xml.xpath.XPathFactory;\n-import jdk.jpackage.internal.PackagingPipeline.PackageBuildEnv;\n-import jdk.jpackage.internal.model.AppImageLayout;\n-import jdk.jpackage.internal.model.ApplicationLayout;\n@@ -59,1 +33,0 @@\n-import jdk.jpackage.internal.model.Package;\n@@ -61,1 +34,0 @@\n-import jdk.jpackage.internal.model.RuntimeLayout;\n@@ -63,3 +35,1 @@\n-import org.w3c.dom.Document;\n-import org.w3c.dom.NodeList;\n-import org.xml.sax.SAXException;\n+import jdk.jpackage.internal.util.Result;\n@@ -67,61 +37,0 @@\n-\/**\n- * WinMsiBundler\n- *\n- * Produces .msi installer from application image. Uses WiX Toolkit to build\n- * .msi installer.\n- * <p>\n- * {@link #execute} method creates a number of source files with the description\n- * of installer to be processed by WiX tools. Generated source files are stored\n- * in \"config\" subdirectory next to \"app\" subdirectory in the root work\n- * directory. The following WiX source files are generated:\n- * <ul>\n- * <li>main.wxs. Main source file with the installer description\n- * <li>bundle.wxf. Source file with application and Java run-time directory tree\n- * description.\n- * <li>ui.wxf. Source file with UI description of the installer.\n- * <\/ul>\n- *\n- * <p>\n- * main.wxs file is a copy of main.wxs resource from\n- * jdk.jpackage.internal.resources package. It is parametrized with the\n- * following WiX variables:\n- * <ul>\n- * <li>JpAppName. Name of the application. Set to the value of --name command\n- * line option\n- * <li>JpAppVersion. Version of the application. Set to the value of\n- * --app-version command line option\n- * <li>JpAppVendor. Vendor of the application. Set to the value of --vendor\n- * command line option\n- * <li>JpAppDescription. Description of the application. Set to the value of\n- * --description command line option\n- * <li>JpProductCode. Set to product code UUID of the application. Random value\n- * generated by jpackage every time {@link #execute} method is called\n- * <li>JpProductUpgradeCode. Set to upgrade code UUID of the application. Random\n- * value generated by jpackage every time {@link #execute} method is called if\n- * --win-upgrade-uuid command line option is not specified. Otherwise this\n- * variable is set to the value of --win-upgrade-uuid command line option\n- * <li>JpAllowUpgrades. Set to \"yes\", but all that matters is it is defined.\n- * <li>JpAllowDowngrades. Defined for application installers, and undefined for\n- * Java runtime installers.\n- * <li>JpConfigDir. Absolute path to the directory with generated WiX source\n- * files.\n- * <li>JpIsSystemWide. Set to \"yes\" if --win-per-user-install command line\n- * option was not specified. Undefined otherwise\n- * <li>JpAppSizeKb. Set to estimated size of the application in kilobytes\n- * <li>JpHelpURL. Set to value of --win-help-url command line option if it\n- * was specified. Undefined otherwise\n- * <li>JpAboutURL. Set to value of --about-url command line option if it\n- * was specified. Undefined otherwise\n- * <li>JpUpdateURL. Set to value of --win-update-url command line option if it\n- * was specified. Undefined otherwise\n- * <\/ul>\n- *\n- * <p>\n- * ui.wxf file is generated based on --license-file, --win-shortcut-prompt,\n- * --win-dir-chooser command line options. It is parametrized with the following\n- * WiX variables:\n- * <ul>\n- * <li>JpLicenseRtf. Set to the value of --license-file command line option.\n- * Undefined if --license-file command line option was not specified\n- * <\/ul>\n- *\/\n@@ -131,8 +40,0 @@\n-        wixFragments = Stream.of(\n-                Map.entry(\"bundle.wxf\", new WixAppImageFragmentBuilder()),\n-                Map.entry(\"ui.wxf\", new WixUiFragmentBuilder()),\n-                Map.entry(\"os-condition.wxf\", OSVersionCondition.createWixFragmentBuilder())\n-        ).<WixFragmentBuilder>map(e -> {\n-            e.getValue().setOutputFileName(e.getKey());\n-            return e.getValue();\n-        }).toList();\n@@ -159,2 +60,5 @@\n-            if (wixToolset == null) {\n-                wixToolset = WixTool.createToolset();\n+            try {\n+                sysEnv.orElseThrow();\n+                return true;\n+            } catch (RuntimeException ex) {\n+                ConfigException.rethrowConfigException(ex);\n@@ -162,1 +66,0 @@\n-            return true;\n@@ -187,3 +90,1 @@\n-            if (wixToolset == null) {\n-                wixToolset = WixTool.createToolset();\n-            }\n+            final var wixToolset = sysEnv.orElseThrow().wixToolset();\n@@ -197,6 +98,0 @@\n-            wixFragments.forEach(wixFragment -> wixFragment.setWixVersion(wixToolset.getVersion(),\n-                    wixToolset.getType()));\n-\n-            wixFragments.stream().map(WixFragmentBuilder::getLoggableWixFeatures).flatMap(\n-                    List::stream).distinct().toList().forEach(Log::verbose);\n-\n@@ -209,31 +104,0 @@\n-    private void prepareProto(Package pkg, BuildEnv env, AppImageLayout appImageLayout) throws\n-            PackagerException, IOException {\n-\n-        \/\/ Configure installer icon\n-        if (appImageLayout instanceof RuntimeLayout runtimeLayout) {\n-            \/\/ Use icon from java launcher.\n-            \/\/ Assume java.exe exists in Java Runtime being packed.\n-            \/\/ Ignore custom icon if any as we don't want to copy anything in\n-            \/\/ Java Runtime image.\n-            installerIcon = runtimeLayout.runtimeDirectory().resolve(Path.of(\"bin\", \"java.exe\"));\n-        } else if (appImageLayout instanceof ApplicationLayout appLayout) {\n-            installerIcon = appLayout.launchersDirectory().resolve(\n-                    pkg.app().mainLauncher().orElseThrow().executableNameWithSuffix());\n-        }\n-        installerIcon = installerIcon.toAbsolutePath();\n-\n-        pkg.licenseFile().ifPresent(licenseFile -> {\n-            \/\/ need to copy license file to the working directory\n-            \/\/ and convert to rtf if needed\n-            Path destFile = env.configDir().resolve(licenseFile.getFileName());\n-\n-            try {\n-                IOUtils.copyFile(licenseFile, destFile);\n-            } catch (IOException ex) {\n-                throw new UncheckedIOException(ex);\n-            }\n-            destFile.toFile().setWritable(true);\n-            ensureByMutationFileIsRTF(destFile);\n-        });\n-    }\n-\n@@ -244,310 +108,6 @@\n-        IOUtils.writableOutputDir(outputParentDir);\n-\n-        \/\/ Order is important!\n-        var pkg = WinFromParams.MSI_PACKAGE.fetchFrom(params);\n-        var env = BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n-\n-        WinPackagingPipeline.build()\n-                .excludeDirFromCopying(outputParentDir)\n-                .task(PackagingPipeline.PackageTaskID.CREATE_CONFIG_FILES)\n-                        .packageAction(this::prepareConfigFiles)\n-                        .add()\n-                .task(PackagingPipeline.PackageTaskID.CREATE_PACKAGE_FILE)\n-                        .packageAction(this::buildPackage)\n-                        .add()\n-                .create().execute(env, pkg, outputParentDir);\n-\n-        return outputParentDir.resolve(pkg.packageFileNameWithSuffix()).toAbsolutePath();\n-    }\n-\n-    private void prepareConfigFiles(PackageBuildEnv<WinMsiPackage, AppImageLayout> env) throws PackagerException, IOException {\n-        prepareProto(env.pkg(), env.env(), env.resolvedLayout());\n-        for (var wixFragment : wixFragments) {\n-            wixFragment.initFromParams(env.env(), env.pkg());\n-            wixFragment.addFilesToConfigRoot();\n-        }\n-\n-        final var msiOut = env.outputDir().resolve(env.pkg().packageFileNameWithSuffix());\n-\n-        Log.verbose(I18N.format(\"message.preparing-msi-config\", msiOut.toAbsolutePath()));\n-\n-        final var wixVars = createWixVars(env);\n-\n-        final var wixObjDir = env.env().buildRoot().resolve(\"wixobj\");\n-\n-        final var configDir = env.env().configDir();\n-\n-        final var wixPipelineBuilder = WixPipeline.build()\n-                .setWixObjDir(wixObjDir)\n-                .setWorkDir(env.env().appImageDir())\n-                .addSource(configDir.resolve(\"main.wxs\"), wixVars);\n-\n-        for (var wixFragment : wixFragments) {\n-            wixFragment.configureWixPipeline(wixPipelineBuilder);\n-        }\n-\n-        switch (wixToolset.getType()) {\n-            case Wix3 -> {\n-                wixPipelineBuilder.addLightOptions(\"-sice:ICE27\");\n-\n-                if (!env.pkg().isSystemWideInstall()) {\n-                    wixPipelineBuilder.addLightOptions(\"-sice:ICE91\");\n-                }\n-            }\n-            case Wix4 -> {\n-            }\n-            default -> {\n-                throw new IllegalArgumentException();\n-            }\n-        }\n-\n-        var primaryWxlFiles = Stream.of(\"de\", \"en\", \"ja\", \"zh_CN\").map(loc -> {\n-            return configDir.resolve(\"MsiInstallerStrings_\" + loc + \".wxl\");\n-        }).toList();\n-\n-        var wixResources = new WixSourceConverter.ResourceGroup(wixToolset.getType());\n-\n-        \/\/ Copy standard l10n files.\n-        for (var path : primaryWxlFiles) {\n-            var name = path.getFileName().toString();\n-            wixResources.addResource(env.env().createResource(name).setPublicName(name).setCategory(\n-                    I18N.getString(\"resource.wxl-file\")), path);\n-        }\n-\n-        wixResources.addResource(env.env().createResource(\"main.wxs\").setPublicName(\"main.wxs\").\n-                setCategory(I18N.getString(\"resource.main-wix-file\")), configDir.resolve(\"main.wxs\"));\n-\n-        wixResources.addResource(env.env().createResource(\"overrides.wxi\").setPublicName(\n-                \"overrides.wxi\").setCategory(I18N.getString(\"resource.overrides-wix-file\")),\n-                configDir.resolve(\"overrides.wxi\"));\n-\n-        \/\/ Filter out custom l10n files that were already used to\n-        \/\/ override primary l10n files. Ignore case filename comparison,\n-        \/\/ both lists are expected to be short.\n-        List<Path> customWxlFiles = env.env().resourceDir()\n-                .map(WinMsiBundler::getWxlFilesFromDir)\n-                .orElseGet(Collections::emptyList)\n-                .stream()\n-                .filter(custom -> primaryWxlFiles.stream().noneMatch(primary ->\n-                        primary.getFileName().toString().equalsIgnoreCase(\n-                                custom.getFileName().toString())))\n-                .peek(custom -> Log.verbose(I18N.format(\n-                        \"message.using-custom-resource\", String.format(\"[%s]\",\n-                                I18N.getString(\"resource.wxl-file\")),\n-                        custom.getFileName()))).toList();\n-\n-        \/\/ Copy custom l10n files.\n-        for (var path : customWxlFiles) {\n-            var name = path.getFileName().toString();\n-            wixResources.addResource(env.env().createResource(name).setPublicName(name).\n-                    setSourceOrder(OverridableResource.Source.ResourceDir).setCategory(I18N.\n-                    getString(\"resource.wxl-file\")), configDir.resolve(name));\n-        }\n-\n-        \/\/ Save all WiX resources into config dir.\n-        wixResources.saveResources();\n-\n-        \/\/ All l10n files are supplied to WiX with \"-loc\", but only\n-        \/\/ Cultures from custom files and a single primary Culture are\n-        \/\/ included into \"-cultures\" list\n-        for (var wxl : primaryWxlFiles) {\n-            wixPipelineBuilder.addLightOptions(\"-loc\", wxl.toString());\n-        }\n-\n-        List<String> cultures = new ArrayList<>();\n-        for (var wxl : customWxlFiles) {\n-            wxl = configDir.resolve(wxl.getFileName());\n-            wixPipelineBuilder.addLightOptions(\"-loc\", wxl.toString());\n-            cultures.add(getCultureFromWxlFile(wxl));\n-        }\n-\n-        \/\/ Append a primary culture bases on runtime locale.\n-        final Path primaryWxlFile = configDir.resolve(\n-                I18N.getString(\"resource.wxl-file-name\"));\n-        cultures.add(getCultureFromWxlFile(primaryWxlFile));\n-\n-        \/\/ Build ordered list of unique cultures.\n-        Set<String> uniqueCultures = new LinkedHashSet<>();\n-        uniqueCultures.addAll(cultures);\n-        switch (wixToolset.getType()) {\n-            case Wix3 -> {\n-                wixPipelineBuilder.addLightOptions(uniqueCultures.stream().collect(Collectors.joining(\";\",\n-                        \"-cultures:\", \"\")));\n-            }\n-            case Wix4 -> {\n-                uniqueCultures.forEach(culture -> {\n-                    wixPipelineBuilder.addLightOptions(\"-culture\", culture);\n-                });\n-            }\n-            default -> {\n-                throw new IllegalArgumentException();\n-            }\n-        }\n-\n-        Files.createDirectories(wixObjDir);\n-        wixPipeline = wixPipelineBuilder.create(wixToolset);\n-    }\n-\n-    private void buildPackage(PackageBuildEnv<WinMsiPackage, AppImageLayout> env) throws PackagerException, IOException {\n-        final var msiOut = env.outputDir().resolve(env.pkg().packageFileNameWithSuffix());\n-        Log.verbose(I18N.format(\"message.generating-msi\", msiOut.toAbsolutePath()));\n-        wixPipeline.buildMsi(msiOut.toAbsolutePath());\n-    }\n-\n-    private Map<String, String> createWixVars(PackageBuildEnv<WinMsiPackage, AppImageLayout> env) throws IOException {\n-        Map<String, String> data = new HashMap<>();\n-\n-        final var pkg = env.pkg();\n-\n-        data.put(\"JpProductCode\", pkg.productCode().toString());\n-        data.put(\"JpProductUpgradeCode\", pkg.upgradeCode().toString());\n-\n-        Log.verbose(I18N.format(\"message.product-code\", pkg.productCode()));\n-        Log.verbose(I18N.format(\"message.upgrade-code\", pkg.upgradeCode()));\n-\n-        data.put(\"JpAllowUpgrades\", \"yes\");\n-        if (!pkg.isRuntimeInstaller()) {\n-            data.put(\"JpAllowDowngrades\", \"yes\");\n-        }\n-\n-        data.put(\"JpAppName\", pkg.packageName());\n-        data.put(\"JpAppDescription\", pkg.description());\n-        data.put(\"JpAppVendor\", pkg.app().vendor());\n-        data.put(\"JpAppVersion\", pkg.version());\n-        if (Files.exists(installerIcon)) {\n-            data.put(\"JpIcon\", installerIcon.toString());\n-        }\n-\n-        pkg.helpURL().ifPresent(value -> {\n-            data.put(\"JpHelpURL\", value);\n-        });\n-\n-        pkg.updateURL().ifPresent(value -> {\n-            data.put(\"JpUpdateURL\", value);\n-        });\n-\n-        pkg.aboutURL().ifPresent(value -> {\n-            data.put(\"JpAboutURL\", value);\n-        });\n-\n-        data.put(\"JpAppSizeKb\", Long.toString(AppImageLayout.toPathGroup(\n-                env.resolvedLayout()).sizeInBytes() >> 10));\n-\n-        data.put(\"JpConfigDir\", env.env().configDir().toAbsolutePath().toString());\n-\n-        if (pkg.isSystemWideInstall()) {\n-            data.put(\"JpIsSystemWide\", \"yes\");\n-        }\n-\n-        return data;\n-    }\n-\n-    private static List<Path> getWxlFilesFromDir(Path dir) {\n-        final String glob = \"glob:**\/*.wxl\";\n-        final PathMatcher pathMatcher = FileSystems.getDefault().getPathMatcher(\n-                glob);\n-\n-        try (var walk = Files.walk(dir, 1)) {\n-            return walk\n-                    .filter(Files::isReadable)\n-                    .filter(pathMatcher::matches)\n-                    .sorted((a, b) -> a.getFileName().toString().compareToIgnoreCase(b.getFileName().toString()))\n-                    .toList();\n-        } catch (IOException ex) {\n-            throw new UncheckedIOException(ex);\n-        }\n-    }\n-\n-    private static String getCultureFromWxlFile(Path wxlPath) {\n-        try {\n-            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n-            factory.setNamespaceAware(false);\n-            DocumentBuilder builder = factory.newDocumentBuilder();\n-\n-            Document doc = builder.parse(wxlPath.toFile());\n-\n-            XPath xPath = XPathFactory.newInstance().newXPath();\n-            NodeList nodes = (NodeList) xPath.evaluate(\n-                    \"\/\/WixLocalization\/@Culture\", doc, XPathConstants.NODESET);\n-            if (nodes.getLength() != 1) {\n-                throw new IOException(I18N.format(\n-                        \"error.extract-culture-from-wix-l10n-file\",\n-                        wxlPath.toAbsolutePath().normalize()));\n-            }\n-\n-            return nodes.item(0).getNodeValue();\n-        } catch (XPathExpressionException | ParserConfigurationException\n-                | SAXException ex) {\n-            throw new UncheckedIOException(new IOException(\n-                    I18N.format(\"error.read-wix-l10n-file\", wxlPath.toAbsolutePath().normalize()), ex));\n-        } catch (IOException ex) {\n-            throw new UncheckedIOException(ex);\n-        }\n-    }\n-\n-    private static void ensureByMutationFileIsRTF(Path f) {\n-        try {\n-            boolean existingLicenseIsRTF = false;\n-\n-            try (InputStream fin = Files.newInputStream(f)) {\n-                byte[] firstBits = new byte[7];\n-\n-                if (fin.read(firstBits) == firstBits.length) {\n-                    String header = new String(firstBits);\n-                    existingLicenseIsRTF = \"{\\\\rtf1\\\\\".equals(header);\n-                }\n-            }\n-\n-            if (!existingLicenseIsRTF) {\n-                List<String> oldLicense = Files.readAllLines(f);\n-                try (Writer w = Files.newBufferedWriter(\n-                        f, Charset.forName(\"Windows-1252\"))) {\n-                    w.write(\"{\\\\rtf1\\\\ansi\\\\ansicpg1252\\\\deff0\\\\deflang1033\"\n-                            + \"{\\\\fonttbl{\\\\f0\\\\fnil\\\\fcharset0 Arial;}}\\n\"\n-                            + \"\\\\viewkind4\\\\uc1\\\\pard\\\\sa200\\\\sl276\"\n-                            + \"\\\\slmult1\\\\lang9\\\\fs20 \");\n-                    oldLicense.forEach(l -> {\n-                        try {\n-                            for (char c : l.toCharArray()) {\n-                                \/\/ 0x00 <= ch < 0x20 Escaped (\\'hh)\n-                                \/\/ 0x20 <= ch < 0x80 Raw(non - escaped) char\n-                                \/\/ 0x80 <= ch <= 0xFF Escaped(\\ 'hh)\n-                                \/\/ 0x5C, 0x7B, 0x7D (special RTF characters\n-                                \/\/ \\,{,})Escaped(\\'hh)\n-                                \/\/ ch > 0xff Escaped (\\\\ud###?)\n-                                if (c < 0x10) {\n-                                    w.write(\"\\\\'0\");\n-                                    w.write(Integer.toHexString(c));\n-                                } else if (c > 0xff) {\n-                                    w.write(\"\\\\ud\");\n-                                    w.write(Integer.toString(c));\n-                                    \/\/ \\\\uc1 is in the header and in effect\n-                                    \/\/ so we trail with a replacement char if\n-                                    \/\/ the font lacks that character - '?'\n-                                    w.write(\"?\");\n-                                } else if ((c < 0x20) || (c >= 0x80) ||\n-                                        (c == 0x5C) || (c == 0x7B) ||\n-                                        (c == 0x7D)) {\n-                                    w.write(\"\\\\'\");\n-                                    w.write(Integer.toHexString(c));\n-                                } else {\n-                                    w.write(c);\n-                                }\n-                            }\n-                            \/\/ blank lines are interpreted as paragraph breaks\n-                            if (l.length() < 1) {\n-                                w.write(\"\\\\par\");\n-                            } else {\n-                                w.write(\" \");\n-                            }\n-                            w.write(\"\\r\\n\");\n-                        } catch (IOException e) {\n-                            Log.verbose(e);\n-                        }\n-                    });\n-                    w.write(\"}\\r\\n\");\n-                }\n-            }\n-        } catch (IOException e) {\n-            Log.verbose(e);\n-        }\n+        return Packager.<WinMsiPackage>build().outputDir(outputParentDir)\n+                .pkg(WinFromParams.MSI_PACKAGE.fetchFrom(params))\n+                .env(BuildEnvFromParams.BUILD_ENV.fetchFrom(params))\n+                .pipelineBuilderMutatorFactory((env, pkg, outputDir) -> {\n+                    return new WinMsiPackager(env, pkg, outputDir, sysEnv.orElseThrow());\n+                }).execute(WinPackagingPipeline.build());\n@@ -556,4 +116,1 @@\n-    private Path installerIcon;\n-    private WixToolset wixToolset;\n-    private WixPipeline wixPipeline;\n-    private final List<WixFragmentBuilder> wixFragments;\n+    final Result<WinSystemEnvironment> sysEnv = WinSystemEnvironment.create();\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinMsiBundler.java","additions":14,"deletions":457,"binary":false,"changes":471,"status":"modified"},{"patch":"@@ -0,0 +1,486 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UncheckedIOException;\n+import java.io.Writer;\n+import java.nio.charset.Charset;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.xpath.XPath;\n+import javax.xml.xpath.XPathConstants;\n+import javax.xml.xpath.XPathExpressionException;\n+import javax.xml.xpath.XPathFactory;\n+import jdk.jpackage.internal.model.AppImageLayout;\n+import jdk.jpackage.internal.model.PackagerException;\n+import jdk.jpackage.internal.model.RuntimeLayout;\n+import jdk.jpackage.internal.model.WinMsiPackage;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.NodeList;\n+import org.xml.sax.SAXException;\n+\n+\/**\n+ * WinMsiPackager\n+ *\n+ * Produces .msi installer from application image. Uses WiX Toolkit to build\n+ * .msi installer.\n+ * <p>\n+ * Creates a number of source files with the description\n+ * of installer to be processed by WiX tools. Generated source files are stored\n+ * in \"config\" subdirectory next to \"app\" subdirectory in the root work\n+ * directory. The following WiX source files are generated:\n+ * <ul>\n+ * <li>main.wxs. Main source file with the installer description\n+ * <li>bundle.wxf. Source file with application and Java run-time directory tree\n+ * description.\n+ * <li>ui.wxf. Source file with UI description of the installer.\n+ * <\/ul>\n+ *\n+ * <p>\n+ * main.wxs file is a copy of main.wxs resource from\n+ * jdk.jpackage.internal.resources package. It is parametrized with the\n+ * following WiX variables:\n+ * <ul>\n+ * <li>JpAppName. Name of the application. Set to the value of --name command\n+ * line option\n+ * <li>JpAppVersion. Version of the application. Set to the value of\n+ * --app-version command line option\n+ * <li>JpAppVendor. Vendor of the application. Set to the value of --vendor\n+ * command line option\n+ * <li>JpAppDescription. Description of the application. Set to the value of\n+ * --description command line option\n+ * <li>JpProductCode. Set to product code UUID of the application. Random value\n+ * generated by jpackage every time {@link #execute} method is called\n+ * <li>JpProductUpgradeCode. Set to upgrade code UUID of the application. Random\n+ * value generated by jpackage every time {@link #execute} method is called if\n+ * --win-upgrade-uuid command line option is not specified. Otherwise this\n+ * variable is set to the value of --win-upgrade-uuid command line option\n+ * <li>JpAllowUpgrades. Set to \"yes\", but all that matters is it is defined.\n+ * <li>JpAllowDowngrades. Defined for application installers, and undefined for\n+ * Java runtime installers.\n+ * <li>JpConfigDir. Absolute path to the directory with generated WiX source\n+ * files.\n+ * <li>JpIsSystemWide. Set to \"yes\" if --win-per-user-install command line\n+ * option was not specified. Undefined otherwise\n+ * <li>JpAppSizeKb. Set to estimated size of the application in kilobytes\n+ * <li>JpHelpURL. Set to value of --win-help-url command line option if it\n+ * was specified. Undefined otherwise\n+ * <li>JpAboutURL. Set to value of --about-url command line option if it\n+ * was specified. Undefined otherwise\n+ * <li>JpUpdateURL. Set to value of --win-update-url command line option if it\n+ * was specified. Undefined otherwise\n+ * <\/ul>\n+ *\n+ * <p>\n+ * ui.wxf file is generated based on --license-file, --win-shortcut-prompt,\n+ * --win-dir-chooser command line options. It is parametrized with the following\n+ * WiX variables:\n+ * <ul>\n+ * <li>JpLicenseRtf. Set to the value of --license-file command line option.\n+ * Undefined if --license-file command line option was not specified\n+ * <\/ul>\n+ *\/\n+final class WinMsiPackager implements Consumer<PackagingPipeline.Builder> {\n+\n+    WinMsiPackager(BuildEnv env, WinMsiPackage pkg, Path outputDir, WixToolset wixToolset) {\n+        this.pkg = Objects.requireNonNull(pkg);\n+        this.env = Objects.requireNonNull(env);\n+        this.outputDir = Objects.requireNonNull(outputDir);\n+        this.wixToolset = Objects.requireNonNull(wixToolset);\n+\n+        wixFragments = Stream.of(\n+                Map.entry(\"bundle.wxf\", new WixAppImageFragmentBuilder()),\n+                Map.entry(\"ui.wxf\", new WixUiFragmentBuilder()),\n+                Map.entry(\"os-condition.wxf\", OSVersionCondition.createWixFragmentBuilder())\n+        ).<WixFragmentBuilder>map(e -> {\n+            e.getValue().setOutputFileName(e.getKey());\n+            return e.getValue();\n+        }).toList();\n+\n+        \/\/ Configure installer icon\n+        if (env.appImageLayout() instanceof RuntimeLayout runtimeLayout) {\n+            \/\/ Use icon from java launcher.\n+            \/\/ Assume java.exe exists in Java Runtime being packed.\n+            \/\/ Ignore custom icon if any as we don't want to copy anything in\n+            \/\/ Java Runtime image.\n+            installerIcon = runtimeLayout.runtimeDirectory().resolve(Path.of(\"bin\", \"java.exe\")).toAbsolutePath();\n+        } else {\n+            installerIcon = env.asApplicationLayout().orElseThrow().launchersDirectory().resolve(\n+                    pkg.app().mainLauncher().orElseThrow().executableNameWithSuffix()).toAbsolutePath();\n+        }\n+\n+        wixFragments.forEach(wixFragment -> wixFragment.setWixVersion(wixToolset.getVersion(),\n+                wixToolset.getType()));\n+\n+        wixFragments.stream().map(WixFragmentBuilder::getLoggableWixFeatures).flatMap(\n+                List::stream).distinct().toList().forEach(Log::verbose);\n+    }\n+\n+    WinMsiPackager(BuildEnv env, WinMsiPackage pkg, Path outputDir, WinSystemEnvironment sysEnv) {\n+        this(env, pkg, outputDir, sysEnv.wixToolset());\n+    }\n+\n+    @Override\n+    public void accept(PackagingPipeline.Builder pipelineBuilder) {\n+        pipelineBuilder.excludeDirFromCopying(outputDir)\n+                .task(PackagingPipeline.PackageTaskID.CREATE_CONFIG_FILES)\n+                        .action(this::prepareConfigFiles)\n+                        .add()\n+                .task(PackagingPipeline.PackageTaskID.CREATE_PACKAGE_FILE)\n+                        .action(this::buildPackage)\n+                        .add();\n+    }\n+\n+    private void prepareConfigFiles() throws PackagerException, IOException {\n+\n+        pkg.licenseFile().ifPresent(licenseFile -> {\n+            \/\/ need to copy license file to the working directory\n+            \/\/ and convert to rtf if needed\n+            Path destFile = env.configDir().resolve(licenseFile.getFileName());\n+\n+            try {\n+                IOUtils.copyFile(licenseFile, destFile);\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+            destFile.toFile().setWritable(true);\n+            ensureByMutationFileIsRTF(destFile);\n+        });\n+\n+        for (var wixFragment : wixFragments) {\n+            wixFragment.initFromParams(env, pkg);\n+            wixFragment.addFilesToConfigRoot();\n+        }\n+\n+        final var msiOut = outputDir.resolve(pkg.packageFileNameWithSuffix());\n+\n+        Log.verbose(I18N.format(\"message.preparing-msi-config\", msiOut.toAbsolutePath()));\n+\n+        final var wixVars = createWixVars();\n+\n+        final var wixObjDir = env.buildRoot().resolve(\"wixobj\");\n+\n+        final var configDir = env.configDir();\n+\n+        final var wixPipelineBuilder = WixPipeline.build()\n+                .setWixObjDir(wixObjDir)\n+                .setWorkDir(env.appImageDir())\n+                .addSource(configDir.resolve(\"main.wxs\"), wixVars);\n+\n+        for (var wixFragment : wixFragments) {\n+            wixFragment.configureWixPipeline(wixPipelineBuilder);\n+        }\n+\n+        switch (wixToolset.getType()) {\n+            case Wix3 -> {\n+                wixPipelineBuilder.addLightOptions(\"-sice:ICE27\");\n+\n+                if (!pkg.isSystemWideInstall()) {\n+                    wixPipelineBuilder.addLightOptions(\"-sice:ICE91\");\n+                }\n+            }\n+            case Wix4 -> {\n+            }\n+            default -> {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        var primaryWxlFiles = Stream.of(\"de\", \"en\", \"ja\", \"zh_CN\").map(loc -> {\n+            return configDir.resolve(\"MsiInstallerStrings_\" + loc + \".wxl\");\n+        }).toList();\n+\n+        var wixResources = new WixSourceConverter.ResourceGroup(wixToolset.getType());\n+\n+        \/\/ Copy standard l10n files.\n+        for (var path : primaryWxlFiles) {\n+            var name = path.getFileName().toString();\n+            wixResources.addResource(env.createResource(name).setPublicName(name).setCategory(\n+                    I18N.getString(\"resource.wxl-file\")), path);\n+        }\n+\n+        wixResources.addResource(env.createResource(\"main.wxs\").setPublicName(\"main.wxs\").\n+                setCategory(I18N.getString(\"resource.main-wix-file\")), configDir.resolve(\"main.wxs\"));\n+\n+        wixResources.addResource(env.createResource(\"overrides.wxi\").setPublicName(\n+                \"overrides.wxi\").setCategory(I18N.getString(\"resource.overrides-wix-file\")),\n+                configDir.resolve(\"overrides.wxi\"));\n+\n+        \/\/ Filter out custom l10n files that were already used to\n+        \/\/ override primary l10n files. Ignore case filename comparison,\n+        \/\/ both lists are expected to be short.\n+        List<Path> customWxlFiles = env.resourceDir()\n+                .map(WinMsiPackager::getWxlFilesFromDir)\n+                .orElseGet(Collections::emptyList)\n+                .stream()\n+                .filter(custom -> primaryWxlFiles.stream().noneMatch(primary ->\n+                        primary.getFileName().toString().equalsIgnoreCase(\n+                                custom.getFileName().toString())))\n+                .peek(custom -> Log.verbose(I18N.format(\n+                        \"message.using-custom-resource\", String.format(\"[%s]\",\n+                                I18N.getString(\"resource.wxl-file\")),\n+                        custom.getFileName()))).toList();\n+\n+        \/\/ Copy custom l10n files.\n+        for (var path : customWxlFiles) {\n+            var name = path.getFileName().toString();\n+            wixResources.addResource(env.createResource(name).setPublicName(name).\n+                    setSourceOrder(OverridableResource.Source.ResourceDir).setCategory(I18N.\n+                    getString(\"resource.wxl-file\")), configDir.resolve(name));\n+        }\n+\n+        \/\/ Save all WiX resources into config dir.\n+        wixResources.saveResources();\n+\n+        \/\/ All l10n files are supplied to WiX with \"-loc\", but only\n+        \/\/ Cultures from custom files and a single primary Culture are\n+        \/\/ included into \"-cultures\" list\n+        for (var wxl : primaryWxlFiles) {\n+            wixPipelineBuilder.addLightOptions(\"-loc\", wxl.toString());\n+        }\n+\n+        List<String> cultures = new ArrayList<>();\n+        for (var wxl : customWxlFiles) {\n+            wxl = configDir.resolve(wxl.getFileName());\n+            wixPipelineBuilder.addLightOptions(\"-loc\", wxl.toString());\n+            cultures.add(getCultureFromWxlFile(wxl));\n+        }\n+\n+        \/\/ Append a primary culture bases on runtime locale.\n+        final Path primaryWxlFile = configDir.resolve(\n+                I18N.getString(\"resource.wxl-file-name\"));\n+        cultures.add(getCultureFromWxlFile(primaryWxlFile));\n+\n+        \/\/ Build ordered list of unique cultures.\n+        Set<String> uniqueCultures = new LinkedHashSet<>();\n+        uniqueCultures.addAll(cultures);\n+        switch (wixToolset.getType()) {\n+            case Wix3 -> {\n+                wixPipelineBuilder.addLightOptions(uniqueCultures.stream().collect(Collectors.joining(\";\",\n+                        \"-cultures:\", \"\")));\n+            }\n+            case Wix4 -> {\n+                uniqueCultures.forEach(culture -> {\n+                    wixPipelineBuilder.addLightOptions(\"-culture\", culture);\n+                });\n+            }\n+            default -> {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        Files.createDirectories(wixObjDir);\n+        wixPipeline = wixPipelineBuilder.create(wixToolset);\n+    }\n+\n+    private void buildPackage() throws PackagerException, IOException {\n+        final var msiOut = outputDir.resolve(pkg.packageFileNameWithSuffix());\n+        Log.verbose(I18N.format(\"message.generating-msi\", msiOut.toAbsolutePath()));\n+        wixPipeline.buildMsi(msiOut.toAbsolutePath());\n+    }\n+\n+    private Map<String, String> createWixVars() throws IOException {\n+        Map<String, String> data = new HashMap<>();\n+\n+        data.put(\"JpProductCode\", pkg.productCode().toString());\n+        data.put(\"JpProductUpgradeCode\", pkg.upgradeCode().toString());\n+\n+        Log.verbose(I18N.format(\"message.product-code\", pkg.productCode()));\n+        Log.verbose(I18N.format(\"message.upgrade-code\", pkg.upgradeCode()));\n+\n+        data.put(\"JpAllowUpgrades\", \"yes\");\n+        if (!pkg.isRuntimeInstaller()) {\n+            data.put(\"JpAllowDowngrades\", \"yes\");\n+        }\n+\n+        data.put(\"JpAppName\", pkg.packageName());\n+        data.put(\"JpAppDescription\", pkg.description());\n+        data.put(\"JpAppVendor\", pkg.app().vendor());\n+        data.put(\"JpAppVersion\", pkg.version());\n+        if (Files.exists(installerIcon)) {\n+            data.put(\"JpIcon\", installerIcon.toString());\n+        }\n+\n+        pkg.helpURL().ifPresent(value -> {\n+            data.put(\"JpHelpURL\", value);\n+        });\n+\n+        pkg.updateURL().ifPresent(value -> {\n+            data.put(\"JpUpdateURL\", value);\n+        });\n+\n+        pkg.aboutURL().ifPresent(value -> {\n+            data.put(\"JpAboutURL\", value);\n+        });\n+\n+        data.put(\"JpAppSizeKb\", Long.toString(AppImageLayout.toPathGroup(\n+                env.appImageLayout()).sizeInBytes() >> 10));\n+\n+        data.put(\"JpConfigDir\", env.configDir().toAbsolutePath().toString());\n+\n+        if (pkg.isSystemWideInstall()) {\n+            data.put(\"JpIsSystemWide\", \"yes\");\n+        }\n+\n+        return data;\n+    }\n+\n+    private static List<Path> getWxlFilesFromDir(Path dir) {\n+        final String glob = \"glob:**\/*.wxl\";\n+        final PathMatcher pathMatcher = FileSystems.getDefault().getPathMatcher(\n+                glob);\n+\n+        try (var walk = Files.walk(dir, 1)) {\n+            return walk\n+                    .filter(Files::isReadable)\n+                    .filter(pathMatcher::matches)\n+                    .sorted((a, b) -> a.getFileName().toString().compareToIgnoreCase(b.getFileName().toString()))\n+                    .toList();\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n+    }\n+\n+    private static String getCultureFromWxlFile(Path wxlPath) {\n+        try {\n+            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n+            factory.setNamespaceAware(false);\n+            DocumentBuilder builder = factory.newDocumentBuilder();\n+\n+            Document doc = builder.parse(wxlPath.toFile());\n+\n+            XPath xPath = XPathFactory.newInstance().newXPath();\n+            NodeList nodes = (NodeList) xPath.evaluate(\n+                    \"\/\/WixLocalization\/@Culture\", doc, XPathConstants.NODESET);\n+            if (nodes.getLength() != 1) {\n+                throw new RuntimeException(I18N.format(\n+                        \"error.extract-culture-from-wix-l10n-file\",\n+                        wxlPath.toAbsolutePath().normalize()));\n+            }\n+\n+            return nodes.item(0).getNodeValue();\n+        } catch (XPathExpressionException | ParserConfigurationException | SAXException ex) {\n+            throw new RuntimeException(I18N.format(\n+                    \"error.read-wix-l10n-file\", wxlPath.toAbsolutePath().normalize()), ex);\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n+    }\n+\n+    private static void ensureByMutationFileIsRTF(Path f) {\n+        try {\n+            boolean existingLicenseIsRTF = false;\n+\n+            try (InputStream fin = Files.newInputStream(f)) {\n+                byte[] firstBits = new byte[7];\n+\n+                if (fin.read(firstBits) == firstBits.length) {\n+                    String header = new String(firstBits);\n+                    existingLicenseIsRTF = \"{\\\\rtf1\\\\\".equals(header);\n+                }\n+            }\n+\n+            if (!existingLicenseIsRTF) {\n+                List<String> oldLicense = Files.readAllLines(f);\n+                try (Writer w = Files.newBufferedWriter(\n+                        f, Charset.forName(\"Windows-1252\"))) {\n+                    w.write(\"{\\\\rtf1\\\\ansi\\\\ansicpg1252\\\\deff0\\\\deflang1033\"\n+                            + \"{\\\\fonttbl{\\\\f0\\\\fnil\\\\fcharset0 Arial;}}\\n\"\n+                            + \"\\\\viewkind4\\\\uc1\\\\pard\\\\sa200\\\\sl276\"\n+                            + \"\\\\slmult1\\\\lang9\\\\fs20 \");\n+                    oldLicense.forEach(l -> {\n+                        try {\n+                            for (char c : l.toCharArray()) {\n+                                \/\/ 0x00 <= ch < 0x20 Escaped (\\'hh)\n+                                \/\/ 0x20 <= ch < 0x80 Raw(non - escaped) char\n+                                \/\/ 0x80 <= ch <= 0xFF Escaped(\\ 'hh)\n+                                \/\/ 0x5C, 0x7B, 0x7D (special RTF characters\n+                                \/\/ \\,{,})Escaped(\\'hh)\n+                                \/\/ ch > 0xff Escaped (\\\\ud###?)\n+                                if (c < 0x10) {\n+                                    w.write(\"\\\\'0\");\n+                                    w.write(Integer.toHexString(c));\n+                                } else if (c > 0xff) {\n+                                    w.write(\"\\\\ud\");\n+                                    w.write(Integer.toString(c));\n+                                    \/\/ \\\\uc1 is in the header and in effect\n+                                    \/\/ so we trail with a replacement char if\n+                                    \/\/ the font lacks that character - '?'\n+                                    w.write(\"?\");\n+                                } else if ((c < 0x20) || (c >= 0x80) ||\n+                                        (c == 0x5C) || (c == 0x7B) ||\n+                                        (c == 0x7D)) {\n+                                    w.write(\"\\\\'\");\n+                                    w.write(Integer.toHexString(c));\n+                                } else {\n+                                    w.write(c);\n+                                }\n+                            }\n+                            \/\/ blank lines are interpreted as paragraph breaks\n+                            if (l.length() < 1) {\n+                                w.write(\"\\\\par\");\n+                            } else {\n+                                w.write(\" \");\n+                            }\n+                            w.write(\"\\r\\n\");\n+                        } catch (IOException e) {\n+                            Log.verbose(e);\n+                        }\n+                    });\n+                    w.write(\"}\\r\\n\");\n+                }\n+            }\n+        } catch (IOException e) {\n+            Log.verbose(e);\n+        }\n+    }\n+\n+    private final WinMsiPackage pkg;\n+    private final BuildEnv env;\n+    private final Path outputDir;\n+    private final WixToolset wixToolset;\n+    private final List<WixFragmentBuilder> wixFragments;\n+    private final Path installerIcon;\n+    private WixPipeline wixPipeline;\n+}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinMsiPackager.java","additions":486,"deletions":0,"binary":false,"changes":486,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n+\n+import java.util.Objects;\n+import jdk.jpackage.internal.util.Result;\n+\n+record WinSystemEnvironment(WixToolset wixToolset) implements SystemEnvironment {\n+\n+    WinSystemEnvironment {\n+        Objects.requireNonNull(wixToolset);\n+    }\n+\n+    static Result<WinSystemEnvironment> create() {\n+        return Result.create(toSupplier(WixTool::createToolset)).map(WinSystemEnvironment::new);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinSystemEnvironment.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -186,7 +186,6 @@\n-            final var validator = new ToolValidator(toolPath).setMinimalVersion(tool.minimalVersion).\n-                    setToolNotFoundErrorHandler((name, ex) -> {\n-                        return new ConfigException(\"\", \"\");\n-                    }).setToolOldVersionErrorHandler((name, version) -> {\n-                tooOld[0] = true;\n-                return null;\n-            });\n+            final var validator = new ToolValidator(toolPath)\n+                    .setMinimalVersion(tool.minimalVersion)\n+                    .setToolOldVersionErrorHandler((name, version) -> {\n+                        tooOld[0] = true;\n+                        return null;\n+                    });\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixTool.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2306,1 +2306,2 @@\n-            if (Files.exists(path)) {\n+            if (Files.exists(path) &&\n+                !isJRTMarkerFile(path)) { \/\/don't directly index lib\/modules\n@@ -2337,0 +2338,4 @@\n+    private static boolean isJRTMarkerFile(Path path) {\n+        return path.equals(Paths.get(System.getProperty(\"java.home\"), \"lib\", \"modules\"));\n+    }\n+\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/SourceCodeAnalysisImpl.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.io.ByteArrayInputStream;\n@@ -37,0 +38,1 @@\n+import java.lang.classfile.ClassHierarchyResolver;\n@@ -88,3 +90,1 @@\n-        super.load(Stream.of(cbcs)\n-                .map(cbc -> new ClassBytecodes(cbc.name(), instrument(cbc.bytecodes())))\n-                .toArray(ClassBytecodes[]::new));\n+        super.load(instrument(cbcs));\n@@ -98,2 +98,20 @@\n-    private static byte[] instrument(byte[] classFile) {\n-        var cc = ClassFile.of();\n+    private static ClassBytecodes[] instrument(ClassBytecodes[] cbcs) {\n+        var cc = ClassFile.of(ClassFile.ClassHierarchyResolverOption.of(\n+                ClassHierarchyResolver.defaultResolver().orElse(\n+                        ClassHierarchyResolver.ofResourceParsing(cd -> {\n+                            String cName = cd.descriptorString();\n+                            cName = cName.substring(1, cName.length() - 1).replace('\/', '.');\n+                            for (ClassBytecodes cbc : cbcs) {\n+                                if (cName.equals(cbc.name())) {\n+                                    return new ByteArrayInputStream(cbc.bytecodes());\n+                                }\n+                            }\n+                            return null;\n+                        }))));\n+\n+        return Stream.of(cbcs)\n+                .map(cbc -> new ClassBytecodes(cbc.name(), instrument(cc, cbc.bytecodes())))\n+                .toArray(ClassBytecodes[]::new);\n+    }\n+\n+    private static byte[] instrument(ClassFile cc, byte[] classFile) {\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/LocalExecutionControl.java","additions":23,"deletions":5,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -81,0 +81,4 @@\n+                          \"owner\": {\n+                            \"type\": \"string\",\n+                            \"description\": \"The thread identifier of the owner when the parkBlocker is an AbstractOwnableSynchronizer.\"\n+                          }\n@@ -118,1 +122,1 @@\n-                                    null\n+                                    \"null\"\n@@ -120,1 +124,1 @@\n-                                  \"description\": \"The object for which the monitor is owned by the thread, null if eliminated\"\n+                                  \"description\": \"The object for which the monitor is owned by the thread, null if eliminated.\"\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/doc-files\/threadDump.schema.json","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"gc\/shenandoah\/shenandoahCollectorPolicy.hpp\"\n+#include \"unittest.hpp\"\n+\n+TEST(ShenandoahCollectorPolicyTest, track_degen_cycles_sanity) {\n+  ShenandoahCollectorPolicy policy;\n+  EXPECT_EQ(policy.consecutive_degenerated_gc_count(), 0UL);\n+  EXPECT_EQ(policy.generational_should_upgrade_degenerated_gc(), false);\n+}\n+\n+TEST(ShenandoahCollectorPolicyTest, track_degen_cycles_no_upgrade) {\n+  ShenandoahCollectorPolicy policy;\n+  policy.record_degenerated(true, true, true);\n+  policy.record_degenerated(true, true, true);\n+  EXPECT_EQ(policy.consecutive_degenerated_gc_count(), 2UL);\n+  EXPECT_EQ(policy.generational_should_upgrade_degenerated_gc(), false);\n+}\n+\n+TEST(ShenandoahCollectorPolicyTest, track_degen_cycles_upgrade) {\n+  ShenandoahCollectorPolicy policy;\n+  policy.record_degenerated(true, true, false);\n+  policy.record_degenerated(true, true, false);\n+  EXPECT_EQ(policy.consecutive_degenerated_gc_count(), 2UL);\n+  EXPECT_EQ(policy.generational_should_upgrade_degenerated_gc(), true);\n+}\n+\n+TEST(ShenandoahCollectorPolicyTest, track_degen_cycles_reset_progress) {\n+  ShenandoahCollectorPolicy policy;\n+  policy.record_degenerated(true, true, false);\n+  policy.record_degenerated(true, true, true);\n+  EXPECT_EQ(policy.consecutive_degenerated_gc_count(), 2UL);\n+  EXPECT_EQ(policy.generational_should_upgrade_degenerated_gc(), false);\n+}\n+\n+TEST(ShenandoahCollectorPolicyTest, track_degen_cycles_full_reset) {\n+  ShenandoahCollectorPolicy policy;\n+  policy.record_degenerated(true, true, false);\n+  policy.record_success_full();\n+  EXPECT_EQ(policy.consecutive_degenerated_gc_count(), 0UL);\n+  EXPECT_EQ(policy.generational_should_upgrade_degenerated_gc(), false);\n+}\n+\n+TEST(ShenandoahCollectorPolicyTest, track_degen_cycles_reset) {\n+  ShenandoahCollectorPolicy policy;\n+  policy.record_degenerated(true, true, false);\n+  policy.record_success_concurrent(true, true);\n+  EXPECT_EQ(policy.consecutive_degenerated_gc_count(), 0UL);\n+  EXPECT_EQ(policy.generational_should_upgrade_degenerated_gc(), false);\n+}\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahCollectorPolicy.cpp","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"opto\/chaitin.hpp\"\n@@ -29,1 +30,3 @@\n-\/\/ Sanity tests for RegMask and RegMaskIterator\n+\/\/ Sanity tests for RegMask and RegMaskIterator. The file tests operations on\n+\/\/ combinations of different RegMask versions (\"basic\", i.e. only statically\n+\/\/ allocated and \"extended\", i.e. extended with dynamically allocated memory).\n@@ -35,1 +38,1 @@\n-    ASSERT_TRUE(rm.is_NotEmpty());\n+    ASSERT_TRUE(!rm.is_Empty());\n@@ -37,1 +40,1 @@\n-    ASSERT_TRUE(!rm.is_NotEmpty());\n+    ASSERT_TRUE(rm.is_Empty());\n@@ -82,1 +85,1 @@\n-  \/\/ Check that Set_All doesn't add bits outside of CHUNK_SIZE\n+  \/\/ Check that Set_All doesn't add bits outside of rm.rm_size_bits()\n@@ -85,3 +88,3 @@\n-  ASSERT_TRUE(rm.Size() == RegMask::CHUNK_SIZE);\n-  ASSERT_TRUE(rm.is_NotEmpty());\n-  \/\/ Set_All sets the infinite bit\n+  ASSERT_TRUE(rm.Size() == rm.rm_size_in_bits());\n+  ASSERT_TRUE(!rm.is_Empty());\n+  \/\/ Set_All sets infinite_stack\n@@ -89,1 +92,1 @@\n-  contains_expected_num_of_registers(rm, RegMask::CHUNK_SIZE);\n+  contains_expected_num_of_registers(rm, rm.rm_size_in_bits());\n@@ -135,1 +138,1 @@\n-  for (int i = 17; i < RegMask::CHUNK_SIZE; i++) {\n+  for (int i = 17; i < (int)rm1.rm_size_in_bits(); i++) {\n@@ -138,0 +141,1 @@\n+  rm1.set_infinite_stack(true);\n@@ -140,1 +144,13 @@\n-  contains_expected_num_of_registers(rm1, RegMask::CHUNK_SIZE - 17);\n+  contains_expected_num_of_registers(rm1, rm1.rm_size_in_bits() - 17);\n+  contains_expected_num_of_registers(rm2, 17);\n+}\n+\n+TEST_VM(RegMask, SUBTRACT_inner) {\n+  RegMask rm1;\n+  RegMask rm2;\n+  rm2.Set_All();\n+  for (int i = 17; i < (int)rm1.rm_size_in_bits(); i++) {\n+    rm1.Insert(i);\n+  }\n+  rm2.SUBTRACT_inner(rm1);\n+  contains_expected_num_of_registers(rm1, rm1.rm_size_in_bits() - 17);\n@@ -147,1 +163,1 @@\n-  for (int i = 0; i < RegMask::CHUNK_SIZE - 1; i++) {\n+  for (int i = 0; i < (int)rm.rm_size_in_bits() - 1; i++) {\n@@ -154,2 +170,2 @@\n-  \/\/ The infinite bit does not count as a bound register\n-  rm.set_infinite_stack();\n+  \/\/ infinite_stack does not count as a bound register\n+  rm.set_infinite_stack(true);\n@@ -162,1 +178,1 @@\n-  for (int i = 0; i < RegMask::CHUNK_SIZE - 2; i++) {\n+  for (int i = 0; i < (int)rm.rm_size_in_bits() - 2; i++) {\n@@ -173,2 +189,3 @@\n-  rm.Insert(RegMask::CHUNK_SIZE - 2);\n-  rm.Insert(RegMask::CHUNK_SIZE - 1);\n+  rm.Insert(rm.rm_size_in_bits() - 2);\n+  rm.Insert(rm.rm_size_in_bits() - 1);\n+  rm.set_infinite_stack(true);\n@@ -182,1 +199,1 @@\n-    for (int i = 0; i < RegMask::CHUNK_SIZE - size; i++) {\n+    for (int i = 0; i < (int)rm.rm_size_in_bits() - size; i++) {\n@@ -190,3 +207,3 @@\n-    \/\/ A set with the infinite bit does not count as a bound set\n-    for (int j = RegMask::CHUNK_SIZE - size; j < RegMask::CHUNK_SIZE; j++) {\n-        rm.Insert(j);\n+    \/\/ A set with infinite_stack does not count as a bound set\n+    for (int j = rm.rm_size_in_bits() - size; j < (int)rm.rm_size_in_bits(); j++) {\n+      rm.Insert(j);\n@@ -194,0 +211,1 @@\n+    rm.set_infinite_stack(true);\n@@ -198,0 +216,1041 @@\n+\n+TEST_VM(RegMask, external_member) {\n+  RegMask rm;\n+  rm.set_infinite_stack(false);\n+  ASSERT_FALSE(rm.Member(OptoReg::Name(rm.rm_size_in_bits())));\n+  rm.set_infinite_stack(true);\n+  ASSERT_TRUE(rm.Member(OptoReg::Name(rm.rm_size_in_bits())));\n+}\n+\n+TEST_VM(RegMask, find_element) {\n+  RegMask rm;\n+  rm.Insert(OptoReg::Name(44));\n+  rm.Insert(OptoReg::Name(30));\n+  rm.Insert(OptoReg::Name(54));\n+  ASSERT_EQ(rm.find_first_elem(), OptoReg::Name(30));\n+  ASSERT_EQ(rm.find_last_elem(), OptoReg::Name(54));\n+  rm.set_infinite_stack(true);\n+  ASSERT_EQ(rm.find_last_elem(), OptoReg::Name(54));\n+  rm.Clear();\n+  ASSERT_EQ(rm.find_first_elem(), OptoReg::Bad);\n+  ASSERT_EQ(rm.find_last_elem(), OptoReg::Bad);\n+}\n+\n+TEST_VM(RegMask, find_first_set) {\n+  RegMask rm;\n+  LRG lrg;\n+  lrg._is_scalable = 0;\n+  lrg._is_vector = 0;\n+  ASSERT_EQ(rm.find_first_set(lrg, 2), OptoReg::Bad);\n+  rm.Insert(OptoReg::Name(24));\n+  rm.Insert(OptoReg::Name(25));\n+  rm.Insert(OptoReg::Name(26));\n+  rm.Insert(OptoReg::Name(27));\n+  rm.Insert(OptoReg::Name(16));\n+  rm.Insert(OptoReg::Name(17));\n+  rm.Insert(OptoReg::Name(18));\n+  rm.Insert(OptoReg::Name(19));\n+  ASSERT_EQ(rm.find_first_set(lrg, 4), OptoReg::Name(19));\n+}\n+\n+TEST_VM(RegMask, alignment) {\n+  RegMask rm;\n+  rm.Insert(OptoReg::Name(30));\n+  rm.Insert(OptoReg::Name(31));\n+  ASSERT_TRUE(rm.is_aligned_sets(2));\n+  rm.Insert(OptoReg::Name(32));\n+  rm.Insert(OptoReg::Name(37));\n+  rm.Insert(OptoReg::Name(62));\n+  rm.Insert(OptoReg::Name(71));\n+  rm.Insert(OptoReg::Name(74));\n+  rm.Insert(OptoReg::Name(75));\n+  ASSERT_FALSE(rm.is_aligned_pairs());\n+  rm.clear_to_pairs();\n+  ASSERT_TRUE(rm.is_aligned_sets(2));\n+  ASSERT_TRUE(rm.is_aligned_pairs());\n+  contains_expected_num_of_registers(rm, 4);\n+  ASSERT_TRUE(rm.Member(OptoReg::Name(30)));\n+  ASSERT_TRUE(rm.Member(OptoReg::Name(31)));\n+  ASSERT_TRUE(rm.Member(OptoReg::Name(74)));\n+  ASSERT_TRUE(rm.Member(OptoReg::Name(75)));\n+  ASSERT_FALSE(rm.is_misaligned_pair());\n+  rm.Remove(OptoReg::Name(30));\n+  rm.Remove(OptoReg::Name(74));\n+  ASSERT_TRUE(rm.is_misaligned_pair());\n+}\n+\n+TEST_VM(RegMask, clear_to_sets) {\n+  RegMask rm;\n+  rm.Insert(OptoReg::Name(3));\n+  rm.Insert(OptoReg::Name(20));\n+  rm.Insert(OptoReg::Name(21));\n+  rm.Insert(OptoReg::Name(22));\n+  rm.Insert(OptoReg::Name(23));\n+  rm.Insert(OptoReg::Name(25));\n+  rm.Insert(OptoReg::Name(26));\n+  rm.Insert(OptoReg::Name(27));\n+  rm.Insert(OptoReg::Name(40));\n+  rm.Insert(OptoReg::Name(42));\n+  rm.Insert(OptoReg::Name(43));\n+  rm.Insert(OptoReg::Name(44));\n+  rm.Insert(OptoReg::Name(45));\n+  rm.clear_to_sets(2);\n+  ASSERT_TRUE(rm.is_aligned_sets(2));\n+  contains_expected_num_of_registers(rm, 10);\n+  rm.clear_to_sets(4);\n+  ASSERT_TRUE(rm.is_aligned_sets(4));\n+  contains_expected_num_of_registers(rm, 4);\n+  rm.clear_to_sets(8);\n+  ASSERT_TRUE(rm.is_aligned_sets(8));\n+  contains_expected_num_of_registers(rm, 0);\n+}\n+\n+TEST_VM(RegMask, smear_to_sets) {\n+  RegMask rm;\n+  rm.Insert(OptoReg::Name(3));\n+  rm.smear_to_sets(2);\n+  ASSERT_TRUE(rm.is_aligned_sets(2));\n+  contains_expected_num_of_registers(rm, 2);\n+  rm.smear_to_sets(4);\n+  ASSERT_TRUE(rm.is_aligned_sets(4));\n+  contains_expected_num_of_registers(rm, 4);\n+  rm.smear_to_sets(8);\n+  ASSERT_TRUE(rm.is_aligned_sets(8));\n+  contains_expected_num_of_registers(rm, 8);\n+  rm.smear_to_sets(16);\n+  ASSERT_TRUE(rm.is_aligned_sets(16));\n+  contains_expected_num_of_registers(rm, 16);\n+}\n+\n+TEST_VM(RegMask, overlap) {\n+  RegMask rm1;\n+  RegMask rm2;\n+  ASSERT_FALSE(rm1.overlap(rm2));\n+  ASSERT_FALSE(rm2.overlap(rm1));\n+  rm1.Insert(OptoReg::Name(23));\n+  rm1.Insert(OptoReg::Name(2));\n+  rm1.Insert(OptoReg::Name(12));\n+  rm2.Insert(OptoReg::Name(1));\n+  rm2.Insert(OptoReg::Name(4));\n+  ASSERT_FALSE(rm1.overlap(rm2));\n+  ASSERT_FALSE(rm2.overlap(rm1));\n+  rm1.Insert(OptoReg::Name(4));\n+  ASSERT_TRUE(rm1.overlap(rm2));\n+  ASSERT_TRUE(rm2.overlap(rm1));\n+}\n+\n+TEST_VM(RegMask, valid_reg) {\n+  RegMask rm;\n+  ASSERT_FALSE(rm.is_valid_reg(OptoReg::Name(42), 1));\n+  rm.Insert(OptoReg::Name(3));\n+  rm.Insert(OptoReg::Name(5));\n+  rm.Insert(OptoReg::Name(6));\n+  rm.Insert(OptoReg::Name(7));\n+  ASSERT_FALSE(rm.is_valid_reg(OptoReg::Name(7), 4));\n+  ASSERT_TRUE(rm.is_valid_reg(OptoReg::Name(7), 2));\n+}\n+\n+TEST_VM(RegMask, rollover_and_insert_remove) {\n+  RegMask rm;\n+  OptoReg::Name reg1(rm.rm_size_in_bits() + 42);\n+  OptoReg::Name reg2(rm.rm_size_in_bits() * 2 + 42);\n+  rm.set_infinite_stack(true);\n+  ASSERT_TRUE(rm.Member(reg1));\n+  rm.rollover();\n+  rm.Clear();\n+  rm.Insert(reg1);\n+  ASSERT_TRUE(rm.Member(reg1));\n+  rm.Remove(reg1);\n+  ASSERT_FALSE(rm.Member(reg1));\n+  rm.set_infinite_stack(true);\n+  rm.rollover();\n+  rm.Clear();\n+  rm.Insert(reg2);\n+  ASSERT_FALSE(rm.Member(reg1));\n+  ASSERT_TRUE(rm.Member(reg2));\n+}\n+\n+TEST_VM(RegMask, rollover_and_find) {\n+  RegMask rm;\n+  OptoReg::Name reg1(rm.rm_size_in_bits() + 42);\n+  OptoReg::Name reg2(rm.rm_size_in_bits() + 7);\n+  rm.set_infinite_stack(true);\n+  rm.rollover();\n+  rm.Clear();\n+  ASSERT_EQ(rm.find_first_elem(), OptoReg::Bad);\n+  ASSERT_EQ(rm.find_last_elem(), OptoReg::Bad);\n+  rm.Insert(reg1);\n+  rm.Insert(reg2);\n+  ASSERT_EQ(rm.find_first_elem(), reg2);\n+  ASSERT_EQ(rm.find_last_elem(), reg1);\n+}\n+\n+TEST_VM(RegMask, rollover_and_find_first_set) {\n+  LRG lrg;\n+  lrg._is_scalable = 0;\n+  lrg._is_vector = 0;\n+  RegMask rm;\n+  OptoReg::Name reg1(rm.rm_size_in_bits() + 24);\n+  OptoReg::Name reg2(rm.rm_size_in_bits() + 25);\n+  OptoReg::Name reg3(rm.rm_size_in_bits() + 26);\n+  OptoReg::Name reg4(rm.rm_size_in_bits() + 27);\n+  OptoReg::Name reg5(rm.rm_size_in_bits() + 16);\n+  OptoReg::Name reg6(rm.rm_size_in_bits() + 17);\n+  OptoReg::Name reg7(rm.rm_size_in_bits() + 18);\n+  OptoReg::Name reg8(rm.rm_size_in_bits() + 19);\n+  rm.set_infinite_stack(true);\n+  rm.rollover();\n+  rm.Clear();\n+  ASSERT_EQ(rm.find_first_set(lrg, 2), OptoReg::Bad);\n+  rm.Insert(reg1);\n+  rm.Insert(reg2);\n+  rm.Insert(reg3);\n+  rm.Insert(reg4);\n+  rm.Insert(reg5);\n+  rm.Insert(reg6);\n+  rm.Insert(reg7);\n+  rm.Insert(reg8);\n+  ASSERT_EQ(rm.find_first_set(lrg, 4), reg8);\n+}\n+\n+TEST_VM(RegMask, rollover_and_Set_All_From) {\n+  RegMask rm;\n+  OptoReg::Name reg1(rm.rm_size_in_bits() + 42);\n+  rm.set_infinite_stack(true);\n+  rm.rollover();\n+  rm.Clear();\n+  rm.Set_All_From(reg1);\n+  contains_expected_num_of_registers(rm, rm.rm_size_in_bits() - 42);\n+}\n+\n+TEST_VM(RegMask, rollover_and_Set_All_From_Offset) {\n+  RegMask rm;\n+  rm.set_infinite_stack(true);\n+  rm.rollover();\n+  rm.Clear();\n+  rm.Set_All_From_Offset();\n+  contains_expected_num_of_registers(rm, rm.rm_size_in_bits());\n+}\n+\n+TEST_VM(RegMask, rollover_and_iterate) {\n+  RegMask rm;\n+  OptoReg::Name reg1(rm.rm_size_in_bits() + 2);\n+  OptoReg::Name reg2(rm.rm_size_in_bits() + 6);\n+  OptoReg::Name reg3(rm.rm_size_in_bits() + 17);\n+  OptoReg::Name reg4(rm.rm_size_in_bits() + 43);\n+  rm.set_infinite_stack(true);\n+  rm.rollover();\n+  rm.Clear();\n+  rm.Insert(reg1);\n+  rm.Insert(reg2);\n+  rm.Insert(reg3);\n+  rm.Insert(reg4);\n+  RegMaskIterator rmi(rm);\n+  ASSERT_EQ(rmi.next(), reg1);\n+  ASSERT_EQ(rmi.next(), reg2);\n+  ASSERT_EQ(rmi.next(), reg3);\n+  ASSERT_EQ(rmi.next(), reg4);\n+  ASSERT_FALSE(rmi.has_next());\n+}\n+\n+TEST_VM(RegMask, rollover_and_SUBTRACT_inner_disjoint) {\n+  RegMask rm1;\n+  RegMask rm2;\n+  OptoReg::Name reg1(rm1.rm_size_in_bits() + 42);\n+  rm1.set_infinite_stack(true);\n+  rm1.rollover();\n+  rm1.Clear();\n+  rm1.SUBTRACT_inner(rm2);\n+  contains_expected_num_of_registers(rm1, 0);\n+  rm2.SUBTRACT_inner(rm1);\n+  contains_expected_num_of_registers(rm2, 0);\n+  rm1.Insert(reg1);\n+  rm2.Insert(42);\n+  rm1.SUBTRACT_inner(rm2);\n+  contains_expected_num_of_registers(rm1, 1);\n+  rm2.SUBTRACT_inner(rm1);\n+  contains_expected_num_of_registers(rm2, 1);\n+}\n+\n+TEST_VM(RegMask, rollover_and_SUBTRACT_inner_overlap) {\n+  RegMask rm1;\n+  RegMask rm2;\n+  OptoReg::Name reg1(rm1.rm_size_in_bits() + 42);\n+  rm1.set_infinite_stack(true);\n+  rm1.rollover();\n+  rm1.Clear();\n+  rm2.set_infinite_stack(true);\n+  rm2.rollover();\n+  rm2.Clear();\n+  rm1.SUBTRACT_inner(rm2);\n+  contains_expected_num_of_registers(rm1, 0);\n+  rm2.SUBTRACT_inner(rm1);\n+  contains_expected_num_of_registers(rm2, 0);\n+  rm1.Insert(reg1);\n+  rm2.Insert(reg1);\n+  rm1.SUBTRACT_inner(rm2);\n+  contains_expected_num_of_registers(rm1, 0);\n+  rm1.Insert(reg1);\n+  rm2.SUBTRACT_inner(rm1);\n+  contains_expected_num_of_registers(rm2, 0);\n+}\n+\n+#ifdef ASSERT\n+\n+TEST_VM_ASSERT_MSG(RegMask, unexpected_clone, \".*clone sanity check\") {\n+  RegMask rm1;\n+  RegMask rm2;\n+  \/\/ Copy contents of rm1 to rm2 inappropriately (no copy constructor)\n+  memcpy((void*)&rm2, (void*)&rm1, sizeof(RegMask));\n+  rm2.Member(0); \/\/ Safeguard in RegMask must catch this.\n+}\n+\n+TEST_VM_ASSERT_MSG(RegMask, unexpected_growth, \".*unexpected register mask growth\") {\n+  RegMask rm;\n+  \/\/ Add clearly out of range OptoReg::Name\n+  rm.Insert(std::numeric_limits<OptoReg::Name>::max());\n+}\n+\n+TEST_VM_ASSERT_MSG(RegMask, not_growable, \".*register mask not growable\") {\n+  RegMask rm;\n+  \/\/ Add a bit just outside the mask, without having specified an arena for\n+  \/\/ extension.\n+  rm.Insert(rm.rm_size_in_bits());\n+}\n+\n+TEST_VM_ASSERT_MSG(RegMask, offset_mismatch, \".*offset mismatch\") {\n+  RegMask rm1;\n+  RegMask rm2;\n+  rm1.set_infinite_stack(true);\n+  rm1.rollover();\n+  \/\/ Cannot copy with different offsets\n+  rm2 = rm1;\n+}\n+\n+#endif\n+\n+#ifndef PRODUCT\n+\n+Arena* arena() {\n+  return Thread::current()->resource_area();\n+}\n+\n+static void is_basic(const RegMask& rm) {\n+  ASSERT_EQ(rm.rm_size_in_words(), RegMask::gtest_basic_rm_size_in_words());\n+}\n+\n+static void is_extended(const RegMask& rm) {\n+  ASSERT_TRUE(rm.rm_size_in_words() > RegMask::gtest_basic_rm_size_in_words());\n+}\n+\n+static int first_extended() {\n+  return RegMask::gtest_basic_rm_size_in_words() * BitsPerWord;\n+}\n+\n+static void extend(RegMask& rm, unsigned int n = 4) {\n+  \/\/ Extend the given RegMask with at least n dynamically-allocated words.\n+  rm.Insert(OptoReg::Name(first_extended() + (BitsPerWord * n) - 1));\n+  rm.Clear();\n+  ASSERT_TRUE(rm.rm_size_in_words() >= RegMask::gtest_basic_rm_size_in_words() + n);\n+}\n+\n+TEST_VM(RegMask, static_by_default) {\n+  \/\/ Check that a freshly created RegMask does not allocate dynamic memory.\n+  RegMask rm;\n+  is_basic(rm);\n+}\n+\n+TEST_VM(RegMask, iteration_extended) {\n+  RegMask rm(arena());\n+  rm.Insert(30);\n+  rm.Insert(31);\n+  rm.Insert(33);\n+  rm.Insert(62);\n+  rm.Insert(first_extended());\n+  rm.Insert(first_extended() + 42);\n+  rm.Insert(first_extended() + 55);\n+  rm.Insert(first_extended() + 456);\n+\n+  RegMaskIterator rmi(rm);\n+  ASSERT_TRUE(rmi.next() == OptoReg::Name(30));\n+  ASSERT_TRUE(rmi.next() == OptoReg::Name(31));\n+  ASSERT_TRUE(rmi.next() == OptoReg::Name(33));\n+  ASSERT_TRUE(rmi.next() == OptoReg::Name(62));\n+  ASSERT_TRUE(rmi.next() == OptoReg::Name(first_extended()));\n+  ASSERT_TRUE(rmi.next() == OptoReg::Name(first_extended() + 42));\n+  ASSERT_TRUE(rmi.next() == OptoReg::Name(first_extended() + 55));\n+  ASSERT_TRUE(rmi.next() == OptoReg::Name(first_extended() + 456));\n+  ASSERT_FALSE(rmi.has_next());\n+}\n+\n+TEST_VM(RegMask, Set_ALL_extended) {\n+  \/\/ Check that Set_All doesn't add bits outside of rm.rm_size_bits() on\n+  \/\/ extended RegMasks.\n+  RegMask rm(arena());\n+  extend(rm);\n+  rm.Set_All();\n+  ASSERT_EQ(rm.Size(), rm.rm_size_in_bits());\n+  ASSERT_TRUE(!rm.is_Empty());\n+  \/\/ Set_All sets infinite_stack bit\n+  ASSERT_TRUE(rm.is_infinite_stack());\n+  contains_expected_num_of_registers(rm, rm.rm_size_in_bits());\n+}\n+\n+TEST_VM(RegMask, Set_ALL_From_extended) {\n+  RegMask rm(arena());\n+  extend(rm);\n+  rm.Set_All_From(OptoReg::Name(42));\n+  contains_expected_num_of_registers(rm, rm.rm_size_in_bits() - 42);\n+}\n+\n+TEST_VM(RegMask, Set_ALL_From_extended_grow) {\n+  RegMask rm(arena());\n+  rm.Set_All_From(first_extended() + OptoReg::Name(42));\n+  is_extended(rm);\n+  contains_expected_num_of_registers(rm, rm.rm_size_in_bits() - first_extended() - 42);\n+}\n+\n+TEST_VM(RegMask, Clear_extended) {\n+  \/\/ Check that Clear doesn't leave any stray bits on extended RegMasks.\n+  RegMask rm(arena());\n+  rm.Insert(first_extended());\n+  is_extended(rm);\n+  rm.Set_All();\n+  rm.Clear();\n+  contains_expected_num_of_registers(rm, 0);\n+}\n+\n+TEST_VM(RegMask, AND_extended_basic) {\n+  RegMask rm1(arena());\n+  rm1.Insert(OptoReg::Name(first_extended()));\n+  is_extended(rm1);\n+  contains_expected_num_of_registers(rm1, 1);\n+  ASSERT_TRUE(rm1.Member(OptoReg::Name(first_extended())));\n+\n+  rm1.AND(rm1);\n+  contains_expected_num_of_registers(rm1, 1);\n+\n+  RegMask rm2;\n+  is_basic(rm2);\n+  rm1.AND(rm2);\n+  contains_expected_num_of_registers(rm1, 0);\n+  contains_expected_num_of_registers(rm2, 0);\n+}\n+\n+TEST_VM(RegMask, AND_extended_extended) {\n+  RegMask rm1(arena());\n+  rm1.Insert(OptoReg::Name(first_extended()));\n+  is_extended(rm1);\n+  contains_expected_num_of_registers(rm1, 1);\n+  ASSERT_TRUE(rm1.Member(OptoReg::Name(first_extended())));\n+\n+  rm1.AND(rm1);\n+  contains_expected_num_of_registers(rm1, 1);\n+\n+  RegMask rm2(arena());\n+  extend(rm2);\n+  rm1.AND(rm2);\n+  contains_expected_num_of_registers(rm1, 0);\n+  contains_expected_num_of_registers(rm2, 0);\n+}\n+\n+TEST_VM(RegMask, OR_extended_basic) {\n+  RegMask rm1(arena());\n+  rm1.Insert(OptoReg::Name(first_extended()));\n+  is_extended(rm1);\n+  contains_expected_num_of_registers(rm1, 1);\n+  ASSERT_TRUE(rm1.Member(OptoReg::Name(first_extended())));\n+\n+  rm1.OR(rm1);\n+  contains_expected_num_of_registers(rm1, 1);\n+\n+  RegMask rm2;\n+  is_basic(rm2);\n+  rm1.OR(rm2);\n+  contains_expected_num_of_registers(rm1, 1);\n+  contains_expected_num_of_registers(rm2, 0);\n+}\n+\n+TEST_VM(RegMask, OR_extended_extended) {\n+  RegMask rm1(arena());\n+  rm1.Insert(OptoReg::Name(first_extended()));\n+  is_extended(rm1);\n+  contains_expected_num_of_registers(rm1, 1);\n+  ASSERT_TRUE(rm1.Member(OptoReg::Name(first_extended())));\n+\n+  rm1.OR(rm1);\n+  contains_expected_num_of_registers(rm1, 1);\n+\n+  RegMask rm2(arena());\n+  extend(rm2);\n+  rm1.OR(rm2);\n+  contains_expected_num_of_registers(rm1, 1);\n+  contains_expected_num_of_registers(rm2, 0);\n+}\n+\n+TEST_VM(RegMask, SUBTRACT_extended) {\n+  RegMask rm1(arena());\n+  extend(rm1);\n+  RegMask rm2(arena());\n+  extend(rm2);\n+\n+  rm2.Set_All();\n+  ASSERT_TRUE(rm2.is_infinite_stack());\n+  for (int i = first_extended() + 17; i < (int)rm1.rm_size_in_bits(); i++) {\n+    rm1.Insert(i);\n+  }\n+  rm1.set_infinite_stack(true);\n+  ASSERT_TRUE(rm1.is_infinite_stack());\n+  rm2.SUBTRACT(rm1);\n+  contains_expected_num_of_registers(rm1, rm1.rm_size_in_bits() - first_extended() - 17);\n+  contains_expected_num_of_registers(rm2, first_extended() + 17);\n+}\n+\n+TEST_VM(RegMask, external_member_extended) {\n+  RegMask rm(arena());\n+  extend(rm);\n+  rm.set_infinite_stack(false);\n+  ASSERT_FALSE(rm.Member(OptoReg::Name(rm.rm_size_in_bits())));\n+  rm.set_infinite_stack(true);\n+  ASSERT_TRUE(rm.Member(OptoReg::Name(rm.rm_size_in_bits())));\n+}\n+\n+TEST_VM(RegMask, overlap_extended) {\n+  RegMask rm1(arena());\n+  extend(rm1);\n+  RegMask rm2(arena());\n+  extend(rm2);\n+  ASSERT_FALSE(rm1.overlap(rm2));\n+  ASSERT_FALSE(rm2.overlap(rm1));\n+  rm1.Insert(OptoReg::Name(23));\n+  rm1.Insert(OptoReg::Name(2));\n+  rm1.Insert(OptoReg::Name(first_extended() + 12));\n+  rm2.Insert(OptoReg::Name(1));\n+  rm2.Insert(OptoReg::Name(first_extended() + 4));\n+  ASSERT_FALSE(rm1.overlap(rm2));\n+  ASSERT_FALSE(rm2.overlap(rm1));\n+  rm1.Insert(OptoReg::Name(first_extended() + 4));\n+  ASSERT_TRUE(rm1.overlap(rm2));\n+  ASSERT_TRUE(rm2.overlap(rm1));\n+}\n+\n+TEST_VM(RegMask, up_extended) {\n+  RegMask rm(arena());\n+  extend(rm);\n+  ASSERT_TRUE(rm.is_UP());\n+  rm.Insert(OptoReg::Name(1));\n+  ASSERT_TRUE(rm.is_UP());\n+  rm.Insert(OptoReg::Name(first_extended()));\n+  ASSERT_FALSE(rm.is_UP());\n+  rm.Clear();\n+  rm.set_infinite_stack(true);\n+  ASSERT_FALSE(rm.is_UP());\n+}\n+\n+TEST_VM(RegMask, SUBTRACT_inner_basic_extended) {\n+  RegMask rm1;\n+  RegMask rm2(arena());\n+  rm1.Insert(OptoReg::Name(1));\n+  rm1.Insert(OptoReg::Name(42));\n+  is_basic(rm1);\n+  rm2.Insert(OptoReg::Name(1));\n+  rm2.Insert(OptoReg::Name(first_extended() + 20));\n+  is_extended(rm2);\n+  rm1.SUBTRACT_inner(rm2);\n+  is_basic(rm1);\n+  contains_expected_num_of_registers(rm1, 1);\n+  ASSERT_TRUE(rm1.Member(OptoReg::Name(42)));\n+}\n+\n+TEST_VM(RegMask, SUBTRACT_inner_extended_basic) {\n+  RegMask rm1(arena());\n+  RegMask rm2;\n+  rm1.Insert(OptoReg::Name(1));\n+  rm1.Insert(OptoReg::Name(42));\n+  rm1.Insert(OptoReg::Name(first_extended() + 20));\n+  is_extended(rm1);\n+  rm2.Insert(OptoReg::Name(1));\n+  is_basic(rm2);\n+  rm1.SUBTRACT_inner(rm2);\n+  contains_expected_num_of_registers(rm1, 2);\n+  ASSERT_TRUE(rm1.Member(OptoReg::Name(42)));\n+  ASSERT_TRUE(rm1.Member(OptoReg::Name(first_extended() + 20)));\n+}\n+\n+TEST_VM(RegMask, rollover_extended) {\n+  RegMask rm(arena());\n+  extend(rm);\n+  is_extended(rm);\n+  OptoReg::Name reg1(rm.rm_size_in_bits() + 42);\n+  rm.set_infinite_stack(true);\n+  rm.rollover();\n+  rm.Insert(reg1);\n+  ASSERT_TRUE(rm.Member(reg1));\n+}\n+\n+TEST_VM(RegMask, rollover_and_SUBTRACT_inner_disjoint_extended) {\n+  RegMask rm1(arena());\n+  RegMask rm2;\n+  extend(rm1);\n+  OptoReg::Name reg1(rm1.rm_size_in_bits() + 42);\n+  rm1.set_infinite_stack(true);\n+  rm1.rollover();\n+  rm1.Clear();\n+  rm1.SUBTRACT_inner(rm2);\n+  contains_expected_num_of_registers(rm1, 0);\n+  rm2.SUBTRACT_inner(rm1);\n+  contains_expected_num_of_registers(rm2, 0);\n+  rm1.Insert(reg1);\n+  rm2.Insert(42);\n+  rm1.SUBTRACT_inner(rm2);\n+  contains_expected_num_of_registers(rm1, 1);\n+  rm2.SUBTRACT_inner(rm1);\n+  contains_expected_num_of_registers(rm2, 1);\n+}\n+\n+TEST_VM(RegMask, rollover_and_SUBTRACT_inner_overlap_extended) {\n+  RegMask rm1(arena());\n+  RegMask rm2;\n+  OptoReg::Name reg1(rm1.rm_size_in_bits() + 42);\n+  extend(rm1);\n+  rm2.set_infinite_stack(true);\n+  rm2.rollover();\n+  rm2.Clear();\n+  rm1.SUBTRACT_inner(rm2);\n+  contains_expected_num_of_registers(rm1, 0);\n+  rm2.SUBTRACT_inner(rm1);\n+  contains_expected_num_of_registers(rm2, 0);\n+  rm1.Insert(reg1);\n+  rm2.Insert(reg1);\n+  rm1.SUBTRACT_inner(rm2);\n+  contains_expected_num_of_registers(rm1, 0);\n+  rm1.Insert(reg1);\n+  rm2.SUBTRACT_inner(rm1);\n+  contains_expected_num_of_registers(rm2, 0);\n+}\n+\n+const uint iterations = 50000;\n+\n+static uint r;\n+static uint next_random() {\n+  r = os::next_random(r);\n+  return r;\n+}\n+static void init_random() {\n+  if (StressSeed == 0) {\n+    r = static_cast<uint>(Ticks::now().nanoseconds());\n+    tty->print_cr(\"seed: %u\", r);\n+  } else {\n+    r = StressSeed;\n+  }\n+}\n+\n+static void print(const char* name, const RegMask& mask) {\n+  tty->print(\"%s: \", name);\n+  mask.print();\n+  tty->print_cr(\", size: %u, offset: %u, infinite_stack: %u\", mask.rm_size_in_bits(),\n+                mask.offset_bits(), mask.is_infinite_stack());\n+}\n+\n+static void assert_equivalent(const RegMask& mask,\n+                              const ResourceBitMap& mask_ref,\n+                              bool infinite_stack_ref) {\n+  ASSERT_EQ(mask_ref.count_one_bits(), mask.Size());\n+  RegMaskIterator it(mask);\n+  OptoReg::Name reg = OptoReg::Bad;\n+  while (it.has_next()) {\n+    reg = it.next();\n+    ASSERT_TRUE(OptoReg::is_valid(reg));\n+    ASSERT_TRUE(mask_ref.at(reg));\n+  }\n+  ASSERT_EQ(infinite_stack_ref, mask.is_infinite_stack());\n+}\n+\n+static void populate_auxiliary_sets(RegMask& mask_aux,\n+                                    ResourceBitMap& mask_aux_ref,\n+                                    uint reg_capacity, uint offset,\n+                                    bool random_offset) {\n+  mask_aux.Clear();\n+  mask_aux_ref.clear();\n+  if (random_offset) {\n+    uint offset_in_words = offset \/ BitsPerWord;\n+    uint capacity_in_words = reg_capacity \/ BitsPerWord;\n+    uint new_offset_in_words;\n+    uint offset_target = next_random() % 3;\n+    switch (offset_target) {\n+    case 0: \/\/ before\n+      if (offset_in_words == 0) {\n+        new_offset_in_words = 0;\n+      } else {\n+        new_offset_in_words = next_random() % offset_in_words;\n+      }\n+      break;\n+    case 1: \/\/ within\n+      new_offset_in_words =\n+          (next_random() % capacity_in_words) + offset_in_words;\n+      break;\n+    case 2: \/\/ after\n+      new_offset_in_words = offset_in_words + capacity_in_words +\n+                            (next_random() % (capacity_in_words));\n+      break;\n+    default:\n+      FAIL();\n+    }\n+    offset = new_offset_in_words * BitsPerWord;\n+    if (offset + RegMask::gtest_rm_size_in_bits_max() > mask_aux_ref.size()) {\n+      \/\/ Ensure that there is space in the reference mask.\n+      offset = 0;\n+    }\n+  }\n+  mask_aux.gtest_set_offset(offset \/ BitsPerWord);\n+  assert_equivalent(mask_aux, mask_aux_ref, false);\n+  uint max_size;\n+  uint size_target = next_random() % 3;\n+  switch (size_target) {\n+  case 0: \/\/ smaller\n+    max_size = reg_capacity \/ 2;\n+    break;\n+  case 1: \/\/ equal\n+    max_size = reg_capacity;\n+    break;\n+  case 2: \/\/ larger (if possible)\n+    max_size = RegMask::gtest_rm_size_in_bits_max();\n+    break;\n+  default:\n+    FAIL();\n+  }\n+  uint regs;\n+  uint regs_target = next_random() % 3;\n+  switch (regs_target) {\n+  case 0: \/\/ sparse\n+    regs = next_random() % 8;\n+    break;\n+  case 1: \/\/ medium\n+    regs = next_random() % (max_size \/ 8);\n+    break;\n+  case 2: \/\/ dense\n+    regs = next_random() % max_size;\n+    break;\n+  default:\n+    FAIL();\n+  }\n+  for (uint i = 0; i < regs; i++) {\n+    uint reg = (next_random() % max_size) + offset;\n+    mask_aux.Insert(reg);\n+    mask_aux_ref.set_bit(reg);\n+  }\n+  mask_aux.set_infinite_stack(next_random() % 2);\n+  assert_equivalent(mask_aux, mask_aux_ref, mask_aux.is_infinite_stack());\n+\n+  if (Verbose) {\n+    print(\"mask_aux\", mask_aux);\n+  }\n+}\n+\n+static void stack_extend_ref_masks(ResourceBitMap& mask1, bool infinite_stack1,\n+                                   uint size_bits1, uint offset1,\n+                                   ResourceBitMap& mask2, bool infinite_stack2,\n+                                   uint size_bits2, uint offset2) {\n+  uint size_bits_after = MAX2(size_bits1, size_bits2);\n+  if (infinite_stack1) {\n+    mask1.set_range(size_bits1 + offset1, size_bits_after + offset1);\n+  }\n+  if (infinite_stack2) {\n+    mask2.set_range(size_bits2 + offset2, size_bits_after + offset2);\n+  }\n+}\n+\n+TEST_VM(RegMask, random) {\n+  ResourceMark rm;\n+  RegMask mask(arena());\n+  ResourceBitMap mask_ref(std::numeric_limits<short>::max() + 1);\n+  bool infinite_stack_ref = false;\n+  uint offset_ref = 0;\n+  init_random();\n+\n+  for (uint i = 0; i < iterations; i++) {\n+    if (Verbose) {\n+      print(\"mask    \", mask);\n+      tty->print(\"%u. \", i);\n+    }\n+    uint action = next_random() % 13;\n+    uint reg;\n+    uint size_bits_before = mask.rm_size_in_bits();\n+    \/\/ This copy is used for stack-extension in overlap.\n+    ResourceBitMap mask_ref_copy(std::numeric_limits<short>::max() + 1);\n+    mask_ref_copy.clear();\n+    mask_ref.iterate([&](BitMap::idx_t index) {\n+      mask_ref_copy.set_bit(index);\n+      return true;\n+    });\n+    ResourceBitMap mask_aux_ref(std::numeric_limits<short>::max() + 1);\n+    RegMask mask_aux(arena());\n+    switch (action) {\n+    case 0:\n+      reg = (next_random() % RegMask::gtest_rm_size_in_bits_max()) + offset_ref;\n+      if (Verbose) {\n+        tty->print_cr(\"action: Insert\");\n+        tty->print(\"value   : \");\n+        OptoReg::dump(reg);\n+        tty->cr();\n+      }\n+      mask.Insert(reg);\n+      mask_ref.set_bit(reg);\n+      if (mask.is_infinite_stack() && reg >= size_bits_before) {\n+        \/\/ Stack-extend reference bitset.\n+        mask_ref.set_range(size_bits_before + offset_ref,\n+                           mask.rm_size_in_bits() + offset_ref);\n+      }\n+      break;\n+    case 1:\n+      reg = (next_random() % size_bits_before) + offset_ref;\n+      if (Verbose) {\n+        tty->print_cr(\"action: Remove\");\n+        tty->print(\"value   : \");\n+        OptoReg::dump(reg);\n+        tty->cr();\n+      }\n+      mask.Remove(reg);\n+      mask_ref.clear_bit(reg);\n+      break;\n+    case 2:\n+      if (Verbose) {\n+        tty->print_cr(\"action: Clear\");\n+      }\n+      mask.Clear();\n+      mask_ref.clear();\n+      infinite_stack_ref = false;\n+      break;\n+    case 3:\n+      if (offset_ref > 0) {\n+        \/\/ Set_All expects a zero-offset.\n+        break;\n+      }\n+      if (Verbose) {\n+        tty->print_cr(\"action: Set_All\");\n+      }\n+      mask.Set_All();\n+      mask_ref.set_range(0, size_bits_before);\n+      infinite_stack_ref = true;\n+      break;\n+    case 4:\n+      if (Verbose) {\n+        tty->print_cr(\"action: AND\");\n+      }\n+      populate_auxiliary_sets(mask_aux, mask_aux_ref, mask.rm_size_in_bits(),\n+                              offset_ref, \/*random_offset*\/ false);\n+      mask.AND(mask_aux);\n+      stack_extend_ref_masks(mask_ref, infinite_stack_ref, size_bits_before,\n+                             offset_ref, mask_aux_ref, mask_aux.is_infinite_stack(),\n+                             mask_aux.rm_size_in_bits(), mask_aux.offset_bits());\n+      mask_ref.set_intersection(mask_aux_ref);\n+      infinite_stack_ref = infinite_stack_ref && mask_aux.is_infinite_stack();\n+      break;\n+    case 5:\n+      if (Verbose) {\n+        tty->print_cr(\"action: OR\");\n+      }\n+      populate_auxiliary_sets(mask_aux, mask_aux_ref, mask.rm_size_in_bits(),\n+                              offset_ref, \/*random_offset*\/ false);\n+      mask.OR(mask_aux);\n+      stack_extend_ref_masks(mask_ref, infinite_stack_ref, size_bits_before,\n+                             offset_ref, mask_aux_ref, mask_aux.is_infinite_stack(),\n+                             mask_aux.rm_size_in_bits(), mask_aux.offset_bits());\n+      mask_ref.set_union(mask_aux_ref);\n+      infinite_stack_ref = infinite_stack_ref || mask_aux.is_infinite_stack();\n+      break;\n+    case 6:\n+      if (Verbose) {\n+        tty->print_cr(\"action: SUBTRACT\");\n+      }\n+      populate_auxiliary_sets(mask_aux, mask_aux_ref, mask.rm_size_in_bits(),\n+                              offset_ref, \/*random_offset*\/ false);\n+      mask.SUBTRACT(mask_aux);\n+      stack_extend_ref_masks(mask_ref, infinite_stack_ref, size_bits_before,\n+                             offset_ref, mask_aux_ref, mask_aux.is_infinite_stack(),\n+                             mask_aux.rm_size_in_bits(), mask_aux.offset_bits());\n+      mask_ref.set_difference(mask_aux_ref);\n+      if (mask_aux.is_infinite_stack()) {\n+        infinite_stack_ref = false;\n+      }\n+      break;\n+    case 7:\n+      if (Verbose) {\n+        tty->print_cr(\"action: SUBTRACT_inner\");\n+      }\n+      populate_auxiliary_sets(mask_aux, mask_aux_ref, mask.rm_size_in_bits(),\n+                              offset_ref, \/*random_offset*\/ true);\n+      \/\/ SUBTRACT_inner expects an argument register mask with infinite_stack =\n+      \/\/ false.\n+      mask_aux.set_infinite_stack(false);\n+      mask.SUBTRACT_inner(mask_aux);\n+      \/\/ SUBTRACT_inner does not have \"stack-extension semantics\".\n+      mask_ref.set_difference(mask_aux_ref);\n+      break;\n+    case 8:\n+      if (Verbose) {\n+        tty->print_cr(\"action: overlap\");\n+      }\n+      populate_auxiliary_sets(mask_aux, mask_aux_ref, mask.rm_size_in_bits(),\n+                              offset_ref, \/*random_offset*\/ false);\n+      \/\/ Stack-extend a copy of mask_ref to avoid mutating the original.\n+      stack_extend_ref_masks(mask_ref_copy, infinite_stack_ref, size_bits_before,\n+                             offset_ref, mask_aux_ref, mask_aux.is_infinite_stack(),\n+                             mask_aux.rm_size_in_bits(), mask_aux.offset_bits());\n+      ASSERT_EQ(mask_ref_copy.intersects(mask_aux_ref) ||\n+                    (infinite_stack_ref && mask_aux.is_infinite_stack()),\n+                mask.overlap(mask_aux));\n+      break;\n+    case 9:\n+      if (Verbose) {\n+        tty->print_cr(\"action: rollover\");\n+      }\n+      \/\/ rollover expects the mask to be cleared and with infinite_stack = true\n+      mask.Clear();\n+      mask.set_infinite_stack(true);\n+      mask_ref.clear();\n+      infinite_stack_ref = true;\n+      if (mask.rollover()) {\n+        offset_ref += size_bits_before;\n+        mask_ref.set_range(offset_ref, offset_ref + size_bits_before);\n+      }\n+      break;\n+    case 10:\n+      if (Verbose) {\n+        tty->print_cr(\"action: reset\");\n+      }\n+      mask.gtest_set_offset(0);\n+      mask.Clear();\n+      mask_ref.clear();\n+      infinite_stack_ref = false;\n+      offset_ref = 0;\n+      break;\n+    case 11:\n+      if (Verbose) {\n+        tty->print_cr(\"action: Set_All_From_Offset\");\n+      }\n+      mask.Set_All_From_Offset();\n+      mask_ref.set_range(offset_ref, offset_ref + size_bits_before);\n+      infinite_stack_ref = true;\n+      break;\n+    case 12:\n+      reg = (next_random() % size_bits_before) + offset_ref;\n+      if (Verbose) {\n+        tty->print_cr(\"action: Set_All_From\");\n+        tty->print(\"value   : \");\n+        OptoReg::dump(reg);\n+        tty->cr();\n+      }\n+      mask.Set_All_From(reg);\n+      mask_ref.set_range(reg, offset_ref + size_bits_before);\n+      infinite_stack_ref = true;\n+      break;\n+    default:\n+      FAIL() << \"Unimplemented action\";\n+    }\n+    ASSERT_NO_FATAL_FAILURE(assert_equivalent(mask, mask_ref, infinite_stack_ref));\n+  }\n+}\n+\n+\/\/ Randomly sets register mask contents. Does not change register mask size.\n+static void randomize(RegMask& rm) {\n+  rm.Clear();\n+  \/\/ Uniform distribution over number of registers.\n+  uint regs = next_random() % (rm.rm_size_in_bits() + 1);\n+  for (uint i = 0; i < regs; i++) {\n+    uint reg = (next_random() % rm.rm_size_in_bits()) + rm.offset_bits();\n+    rm.Insert(reg);\n+  }\n+  rm.set_infinite_stack(next_random() % 2);\n+}\n+\n+static uint grow_randomly(RegMask& rm, uint min_growth = 1,\n+                          uint max_growth = 3) {\n+  \/\/ Grow between min_growth and max_growth times.\n+  uint grow = min_growth + (max_growth > 0 ? next_random() % max_growth : 0);\n+  for (uint i = 0; i < grow; ++i) {\n+    uint reg = rm.rm_size_in_bits();\n+    if (reg >= RegMask::gtest_rm_size_in_bits_max()) {\n+      \/\/ Cannot grow more\n+      break;\n+    }\n+    \/\/ Force grow\n+    rm.Insert(reg);\n+    if (!rm.is_infinite_stack()) {\n+      \/\/ Restore\n+      rm.Remove(reg);\n+    }\n+  }\n+  \/\/ Return how many times we grew\n+  return grow;\n+}\n+\n+TEST_VM(RegMask, random_copy) {\n+  init_random();\n+\n+  auto print_failure = [&](const RegMask& src, const RegMask& dst) {\n+    tty->print_cr(\"Failure, src and dst not equal\");\n+    tty->print(\"src: \");\n+    src.dump_hex();\n+    tty->cr();\n+    tty->print(\"dst: \");\n+    dst.dump_hex();\n+    tty->cr();\n+  };\n+\n+  \/\/ Test copying a larger register mask\n+  for (uint i = 0; i < iterations; i++) {\n+    ResourceMark rm;\n+\n+    \/\/ Create source RegMask\n+    RegMask src(arena());\n+\n+    \/\/ Grow source randomly\n+    grow_randomly(src);\n+\n+    \/\/ Randomly initialize source\n+    randomize(src);\n+\n+    \/\/ Copy construct source to destination\n+    RegMask dst(src, arena());\n+\n+    \/\/ Check equality\n+    bool passed = src.gtest_equals(dst);\n+    if (Verbose && !passed) {\n+      print_failure(src, dst);\n+    }\n+    ASSERT_TRUE(passed);\n+  }\n+\n+  \/\/ Test copying a smaller register mask\n+  for (uint i = 0; i < iterations; i++) {\n+    ResourceMark rm;\n+\n+    \/\/ Create destination RegMask\n+    RegMask dst(arena());\n+\n+    \/\/ Grow destination arbitrarily (1-3 times)\n+    uint growth = grow_randomly(dst, 1, 3);\n+\n+    \/\/ Create source RegMask\n+    RegMask src(arena());\n+\n+    \/\/ Grow source arbitrarily, but not as much as destination\n+    grow_randomly(src, 0, growth - 1);\n+\n+    \/\/ Randomly initialize source\n+    randomize(src);\n+\n+    \/\/ Copy source to destination\n+    dst = src;\n+\n+    \/\/ Check equality\n+    bool passed = src.gtest_equals(dst);\n+    if (Verbose && !passed) {\n+      print_failure(src, dst);\n+    }\n+    ASSERT_TRUE(passed);\n+  }\n+}\n+\n+#endif \/\/ !PRODUCT\n","filename":"test\/hotspot\/gtest\/opto\/test_regmask.cpp","additions":1079,"deletions":20,"binary":false,"changes":1099,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include <sys\/prctl.h>\n@@ -471,0 +472,23 @@\n+static void test_set_thread_name(const char* name, const char* expected) {\n+  os::set_native_thread_name(name);\n+  char buf[16];\n+  int rc = prctl(PR_GET_NAME, buf);\n+  ASSERT_EQ(0, rc);\n+  ASSERT_STREQ(buf, expected);\n+}\n+\n+TEST_VM(os_linux, set_thread_name) {\n+  char buf[16];\n+  \/\/ retrieve current name\n+  int rc = prctl(PR_GET_NAME, buf);\n+  ASSERT_EQ(0, rc);\n+\n+  test_set_thread_name(\"shortname\", \"shortname\");\n+  test_set_thread_name(\"012345678901234\",  \"012345678901234\");\n+  test_set_thread_name(\"0123456789012345\", \"0123456..012345\");\n+  test_set_thread_name(\"MyAllocationWorkerThread22\", \"MyAlloc..read22\");\n+\n+  \/\/ restore current name\n+  test_set_thread_name(buf, buf);\n+}\n+\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_linux.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"runtime\/os.hpp\"\n+#include \"runtime\/os.inline.hpp\"\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_windows.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,0 +5,4 @@\n+# The following tests use very small -Xmx and will not be able to\n+# use the AOT cache generated by \"make test JTREG=AOT_JDK=onestep ...\"\n+gc\/arguments\/TestG1HeapSizeFlags.java                 0000000 generic-all\n+gc\/arguments\/TestParallelHeapSizeFlags.java           0000000 generic-all\n@@ -6,0 +10,1 @@\n+\n@@ -20,0 +25,4 @@\n+\n+# These tests fail often with AotJdk due to JDK-8323727\n+compiler\/arguments\/TestStressReflectiveCode.java 8323727 generic-all\n+compiler\/arraycopy\/TestCloneWithStressReflectiveCode.java 8323727 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-AotJdk.txt","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-serviceability\/jvmti\/GetThreadListStackTraces\/OneGetThreadListStackTraces.java 8308027 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-Virtual.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -415,0 +415,1 @@\n+ -runtime\/cds\/appcds\/aotAnnotations \\\n@@ -515,0 +516,1 @@\n+ -runtime\/cds\/appcds\/aotAnnotations \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,323 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8325467\n+ * @requires vm.opt.DeoptimizeALot == null | vm.opt.DeoptimizeALot == false\n+ * @summary Ensure C2 can compile methods with the maximum number of parameters\n+ *          (according to the JVM spec).\n+ * @run main\/othervm -XX:CompileCommand=compileonly,compiler.arguments.TestMaxMethodArguments::test\n+ *                   -Xcomp\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+AbortVMOnCompilationFailure\n+ *                   compiler.arguments.TestMaxMethodArguments\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8325467\n+ * @summary Same test as above but do not enforce that compilation succeeds\n+ *          (first run) or that the test method is compiled at all (second\n+ *          run).\n+ * @run main\/othervm -XX:CompileCommand=compileonly,compiler.arguments.TestMaxMethodArguments::test\n+ *                   -Xcomp compiler.arguments.TestMaxMethodArguments\n+ * @run main compiler.arguments.TestMaxMethodArguments\n+ *\/\n+\n+package compiler.arguments;\n+\n+public class TestMaxMethodArguments {\n+\n+    static class TestException extends Exception {}\n+\n+    public static void main(String[] args) {\n+        try {\n+            test(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255);\n+        } catch (TestException e) {\n+            \/\/ Fine\n+        }\n+    }\n+\n+    public static int test(int x1, int x2, int x3, int x4, int x5, int x6, int x7, int x8, int x9, int x10, int x11, int x12, int x13, int x14, int x15, int x16, int x17, int x18, int x19, int x20, int x21, int x22, int x23, int x24, int x25, int x26, int x27, int x28, int x29, int x30, int x31, int x32, int x33, int x34, int x35, int x36, int x37, int x38, int x39, int x40, int x41, int x42, int x43, int x44, int x45, int x46, int x47, int x48, int x49, int x50, int x51, int x52, int x53, int x54, int x55, int x56, int x57, int x58, int x59, int x60, int x61, int x62, int x63, int x64, int x65, int x66, int x67, int x68, int x69, int x70, int x71, int x72, int x73, int x74, int x75, int x76, int x77, int x78, int x79, int x80, int x81, int x82, int x83, int x84, int x85, int x86, int x87, int x88, int x89, int x90, int x91, int x92, int x93, int x94, int x95, int x96, int x97, int x98, int x99, int x100, int x101, int x102, int x103, int x104, int x105, int x106, int x107, int x108, int x109, int x110, int x111, int x112, int x113, int x114, int x115, int x116, int x117, int x118, int x119, int x120, int x121, int x122, int x123, int x124, int x125, int x126, int x127, int x128, int x129, int x130, int x131, int x132, int x133, int x134, int x135, int x136, int x137, int x138, int x139, int x140, int x141, int x142, int x143, int x144, int x145, int x146, int x147, int x148, int x149, int x150, int x151, int x152, int x153, int x154, int x155, int x156, int x157, int x158, int x159, int x160, int x161, int x162, int x163, int x164, int x165, int x166, int x167, int x168, int x169, int x170, int x171, int x172, int x173, int x174, int x175, int x176, int x177, int x178, int x179, int x180, int x181, int x182, int x183, int x184, int x185, int x186, int x187, int x188, int x189, int x190, int x191, int x192, int x193, int x194, int x195, int x196, int x197, int x198, int x199, int x200, int x201, int x202, int x203, int x204, int x205, int x206, int x207, int x208, int x209, int x210, int x211, int x212, int x213, int x214, int x215, int x216, int x217, int x218, int x219, int x220, int x221, int x222, int x223, int x224, int x225, int x226, int x227, int x228, int x229, int x230, int x231, int x232, int x233, int x234, int x235, int x236, int x237, int x238, int x239, int x240, int x241, int x242, int x243, int x244, int x245, int x246, int x247, int x248, int x249, int x250, int x251, int x252, int x253, int x254, int x255) throws TestException {\n+        \/\/ Exceptions after every definition of a temporary force the\n+        \/\/ evaluation order.\n+        int t1 = x1 % 101; if(t1 == 0) { throw new TestException(); }\n+        int t2 = x2 % 102; if(t2 == 0) { throw new TestException(); }\n+        int t3 = x3 % 103; if(t3 == 0) { throw new TestException(); }\n+        int t4 = x4 % 104; if(t4 == 0) { throw new TestException(); }\n+        int t5 = x5 % 105; if(t5 == 0) { throw new TestException(); }\n+        int t6 = x6 % 106; if(t6 == 0) { throw new TestException(); }\n+        int t7 = x7 % 107; if(t7 == 0) { throw new TestException(); }\n+        int t8 = x8 % 108; if(t8 == 0) { throw new TestException(); }\n+        int t9 = x9 % 109; if(t9 == 0) { throw new TestException(); }\n+        int t10 = x10 % 110; if(t10 == 0) { throw new TestException(); }\n+        int t11 = x11 % 111; if(t11 == 0) { throw new TestException(); }\n+        int t12 = x12 % 112; if(t12 == 0) { throw new TestException(); }\n+        int t13 = x13 % 113; if(t13 == 0) { throw new TestException(); }\n+        int t14 = x14 % 114; if(t14 == 0) { throw new TestException(); }\n+        int t15 = x15 % 115; if(t15 == 0) { throw new TestException(); }\n+        int t16 = x16 % 116; if(t16 == 0) { throw new TestException(); }\n+        int t17 = x17 % 117; if(t17 == 0) { throw new TestException(); }\n+        int t18 = x18 % 118; if(t18 == 0) { throw new TestException(); }\n+        int t19 = x19 % 119; if(t19 == 0) { throw new TestException(); }\n+        int t20 = x20 % 120; if(t20 == 0) { throw new TestException(); }\n+        int t21 = x21 % 121; if(t21 == 0) { throw new TestException(); }\n+        int t22 = x22 % 122; if(t22 == 0) { throw new TestException(); }\n+        int t23 = x23 % 123; if(t23 == 0) { throw new TestException(); }\n+        int t24 = x24 % 124; if(t24 == 0) { throw new TestException(); }\n+        int t25 = x25 % 125; if(t25 == 0) { throw new TestException(); }\n+        int t26 = x26 % 126; if(t26 == 0) { throw new TestException(); }\n+        int t27 = x27 % 127; if(t27 == 0) { throw new TestException(); }\n+        int t28 = x28 % 128; if(t28 == 0) { throw new TestException(); }\n+        int t29 = x29 % 129; if(t29 == 0) { throw new TestException(); }\n+        int t30 = x30 % 130; if(t30 == 0) { throw new TestException(); }\n+        int t31 = x31 % 131; if(t31 == 0) { throw new TestException(); }\n+        int t32 = x32 % 132; if(t32 == 0) { throw new TestException(); }\n+        int t33 = x33 % 133; if(t33 == 0) { throw new TestException(); }\n+        int t34 = x34 % 134; if(t34 == 0) { throw new TestException(); }\n+        int t35 = x35 % 135; if(t35 == 0) { throw new TestException(); }\n+        int t36 = x36 % 136; if(t36 == 0) { throw new TestException(); }\n+        int t37 = x37 % 137; if(t37 == 0) { throw new TestException(); }\n+        int t38 = x38 % 138; if(t38 == 0) { throw new TestException(); }\n+        int t39 = x39 % 139; if(t39 == 0) { throw new TestException(); }\n+        int t40 = x40 % 140; if(t40 == 0) { throw new TestException(); }\n+        int t41 = x41 % 141; if(t41 == 0) { throw new TestException(); }\n+        int t42 = x42 % 142; if(t42 == 0) { throw new TestException(); }\n+        int t43 = x43 % 143; if(t43 == 0) { throw new TestException(); }\n+        int t44 = x44 % 144; if(t44 == 0) { throw new TestException(); }\n+        int t45 = x45 % 145; if(t45 == 0) { throw new TestException(); }\n+        int t46 = x46 % 146; if(t46 == 0) { throw new TestException(); }\n+        int t47 = x47 % 147; if(t47 == 0) { throw new TestException(); }\n+        int t48 = x48 % 148; if(t48 == 0) { throw new TestException(); }\n+        int t49 = x49 % 149; if(t49 == 0) { throw new TestException(); }\n+        int t50 = x50 % 150; if(t50 == 0) { throw new TestException(); }\n+        int t51 = x51 % 151; if(t51 == 0) { throw new TestException(); }\n+        int t52 = x52 % 152; if(t52 == 0) { throw new TestException(); }\n+        int t53 = x53 % 153; if(t53 == 0) { throw new TestException(); }\n+        int t54 = x54 % 154; if(t54 == 0) { throw new TestException(); }\n+        int t55 = x55 % 155; if(t55 == 0) { throw new TestException(); }\n+        int t56 = x56 % 156; if(t56 == 0) { throw new TestException(); }\n+        int t57 = x57 % 157; if(t57 == 0) { throw new TestException(); }\n+        int t58 = x58 % 158; if(t58 == 0) { throw new TestException(); }\n+        int t59 = x59 % 159; if(t59 == 0) { throw new TestException(); }\n+        int t60 = x60 % 160; if(t60 == 0) { throw new TestException(); }\n+        int t61 = x61 % 161; if(t61 == 0) { throw new TestException(); }\n+        int t62 = x62 % 162; if(t62 == 0) { throw new TestException(); }\n+        int t63 = x63 % 163; if(t63 == 0) { throw new TestException(); }\n+        int t64 = x64 % 164; if(t64 == 0) { throw new TestException(); }\n+        int t65 = x65 % 165; if(t65 == 0) { throw new TestException(); }\n+        int t66 = x66 % 166; if(t66 == 0) { throw new TestException(); }\n+        int t67 = x67 % 167; if(t67 == 0) { throw new TestException(); }\n+        int t68 = x68 % 168; if(t68 == 0) { throw new TestException(); }\n+        int t69 = x69 % 169; if(t69 == 0) { throw new TestException(); }\n+        int t70 = x70 % 170; if(t70 == 0) { throw new TestException(); }\n+        int t71 = x71 % 171; if(t71 == 0) { throw new TestException(); }\n+        int t72 = x72 % 172; if(t72 == 0) { throw new TestException(); }\n+        int t73 = x73 % 173; if(t73 == 0) { throw new TestException(); }\n+        int t74 = x74 % 174; if(t74 == 0) { throw new TestException(); }\n+        int t75 = x75 % 175; if(t75 == 0) { throw new TestException(); }\n+        int t76 = x76 % 176; if(t76 == 0) { throw new TestException(); }\n+        int t77 = x77 % 177; if(t77 == 0) { throw new TestException(); }\n+        int t78 = x78 % 178; if(t78 == 0) { throw new TestException(); }\n+        int t79 = x79 % 179; if(t79 == 0) { throw new TestException(); }\n+        int t80 = x80 % 180; if(t80 == 0) { throw new TestException(); }\n+        int t81 = x81 % 181; if(t81 == 0) { throw new TestException(); }\n+        int t82 = x82 % 182; if(t82 == 0) { throw new TestException(); }\n+        int t83 = x83 % 183; if(t83 == 0) { throw new TestException(); }\n+        int t84 = x84 % 184; if(t84 == 0) { throw new TestException(); }\n+        int t85 = x85 % 185; if(t85 == 0) { throw new TestException(); }\n+        int t86 = x86 % 186; if(t86 == 0) { throw new TestException(); }\n+        int t87 = x87 % 187; if(t87 == 0) { throw new TestException(); }\n+        int t88 = x88 % 188; if(t88 == 0) { throw new TestException(); }\n+        int t89 = x89 % 189; if(t89 == 0) { throw new TestException(); }\n+        int t90 = x90 % 190; if(t90 == 0) { throw new TestException(); }\n+        int t91 = x91 % 191; if(t91 == 0) { throw new TestException(); }\n+        int t92 = x92 % 192; if(t92 == 0) { throw new TestException(); }\n+        int t93 = x93 % 193; if(t93 == 0) { throw new TestException(); }\n+        int t94 = x94 % 194; if(t94 == 0) { throw new TestException(); }\n+        int t95 = x95 % 195; if(t95 == 0) { throw new TestException(); }\n+        int t96 = x96 % 196; if(t96 == 0) { throw new TestException(); }\n+        int t97 = x97 % 197; if(t97 == 0) { throw new TestException(); }\n+        int t98 = x98 % 198; if(t98 == 0) { throw new TestException(); }\n+        int t99 = x99 % 199; if(t99 == 0) { throw new TestException(); }\n+        int t100 = x100 % 200; if(t100 == 0) { throw new TestException(); }\n+        int t101 = x101 % 201; if(t101 == 0) { throw new TestException(); }\n+        int t102 = x102 % 202; if(t102 == 0) { throw new TestException(); }\n+        int t103 = x103 % 203; if(t103 == 0) { throw new TestException(); }\n+        int t104 = x104 % 204; if(t104 == 0) { throw new TestException(); }\n+        int t105 = x105 % 205; if(t105 == 0) { throw new TestException(); }\n+        int t106 = x106 % 206; if(t106 == 0) { throw new TestException(); }\n+        int t107 = x107 % 207; if(t107 == 0) { throw new TestException(); }\n+        int t108 = x108 % 208; if(t108 == 0) { throw new TestException(); }\n+        int t109 = x109 % 209; if(t109 == 0) { throw new TestException(); }\n+        int t110 = x110 % 210; if(t110 == 0) { throw new TestException(); }\n+        int t111 = x111 % 211; if(t111 == 0) { throw new TestException(); }\n+        int t112 = x112 % 212; if(t112 == 0) { throw new TestException(); }\n+        int t113 = x113 % 213; if(t113 == 0) { throw new TestException(); }\n+        int t114 = x114 % 214; if(t114 == 0) { throw new TestException(); }\n+        int t115 = x115 % 215; if(t115 == 0) { throw new TestException(); }\n+        int t116 = x116 % 216; if(t116 == 0) { throw new TestException(); }\n+        int t117 = x117 % 217; if(t117 == 0) { throw new TestException(); }\n+        int t118 = x118 % 218; if(t118 == 0) { throw new TestException(); }\n+        int t119 = x119 % 219; if(t119 == 0) { throw new TestException(); }\n+        int t120 = x120 % 220; if(t120 == 0) { throw new TestException(); }\n+        int t121 = x121 % 221; if(t121 == 0) { throw new TestException(); }\n+        int t122 = x122 % 222; if(t122 == 0) { throw new TestException(); }\n+        int t123 = x123 % 223; if(t123 == 0) { throw new TestException(); }\n+        int t124 = x124 % 224; if(t124 == 0) { throw new TestException(); }\n+        int t125 = x125 % 225; if(t125 == 0) { throw new TestException(); }\n+        int t126 = x126 % 226; if(t126 == 0) { throw new TestException(); }\n+        int t127 = x127 % 227; if(t127 == 0) { throw new TestException(); }\n+        int t128 = x128 % 228; if(t128 == 0) { throw new TestException(); }\n+        int t129 = x129 % 229; if(t129 == 0) { throw new TestException(); }\n+        int t130 = x130 % 230; if(t130 == 0) { throw new TestException(); }\n+        int t131 = x131 % 231; if(t131 == 0) { throw new TestException(); }\n+        int t132 = x132 % 232; if(t132 == 0) { throw new TestException(); }\n+        int t133 = x133 % 233; if(t133 == 0) { throw new TestException(); }\n+        int t134 = x134 % 234; if(t134 == 0) { throw new TestException(); }\n+        int t135 = x135 % 235; if(t135 == 0) { throw new TestException(); }\n+        int t136 = x136 % 236; if(t136 == 0) { throw new TestException(); }\n+        int t137 = x137 % 237; if(t137 == 0) { throw new TestException(); }\n+        int t138 = x138 % 238; if(t138 == 0) { throw new TestException(); }\n+        int t139 = x139 % 239; if(t139 == 0) { throw new TestException(); }\n+        int t140 = x140 % 240; if(t140 == 0) { throw new TestException(); }\n+        int t141 = x141 % 241; if(t141 == 0) { throw new TestException(); }\n+        int t142 = x142 % 242; if(t142 == 0) { throw new TestException(); }\n+        int t143 = x143 % 243; if(t143 == 0) { throw new TestException(); }\n+        int t144 = x144 % 244; if(t144 == 0) { throw new TestException(); }\n+        int t145 = x145 % 245; if(t145 == 0) { throw new TestException(); }\n+        int t146 = x146 % 246; if(t146 == 0) { throw new TestException(); }\n+        int t147 = x147 % 247; if(t147 == 0) { throw new TestException(); }\n+        int t148 = x148 % 248; if(t148 == 0) { throw new TestException(); }\n+        int t149 = x149 % 249; if(t149 == 0) { throw new TestException(); }\n+        int t150 = x150 % 250; if(t150 == 0) { throw new TestException(); }\n+        int t151 = x151 % 251; if(t151 == 0) { throw new TestException(); }\n+        int t152 = x152 % 252; if(t152 == 0) { throw new TestException(); }\n+        int t153 = x153 % 253; if(t153 == 0) { throw new TestException(); }\n+        int t154 = x154 % 254; if(t154 == 0) { throw new TestException(); }\n+        int t155 = x155 % 255; if(t155 == 0) { throw new TestException(); }\n+        int t156 = x156 % 256; if(t156 == 0) { throw new TestException(); }\n+        int t157 = x157 % 257; if(t157 == 0) { throw new TestException(); }\n+        int t158 = x158 % 258; if(t158 == 0) { throw new TestException(); }\n+        int t159 = x159 % 259; if(t159 == 0) { throw new TestException(); }\n+        int t160 = x160 % 260; if(t160 == 0) { throw new TestException(); }\n+        int t161 = x161 % 261; if(t161 == 0) { throw new TestException(); }\n+        int t162 = x162 % 262; if(t162 == 0) { throw new TestException(); }\n+        int t163 = x163 % 263; if(t163 == 0) { throw new TestException(); }\n+        int t164 = x164 % 264; if(t164 == 0) { throw new TestException(); }\n+        int t165 = x165 % 265; if(t165 == 0) { throw new TestException(); }\n+        int t166 = x166 % 266; if(t166 == 0) { throw new TestException(); }\n+        int t167 = x167 % 267; if(t167 == 0) { throw new TestException(); }\n+        int t168 = x168 % 268; if(t168 == 0) { throw new TestException(); }\n+        int t169 = x169 % 269; if(t169 == 0) { throw new TestException(); }\n+        int t170 = x170 % 270; if(t170 == 0) { throw new TestException(); }\n+        int t171 = x171 % 271; if(t171 == 0) { throw new TestException(); }\n+        int t172 = x172 % 272; if(t172 == 0) { throw new TestException(); }\n+        int t173 = x173 % 273; if(t173 == 0) { throw new TestException(); }\n+        int t174 = x174 % 274; if(t174 == 0) { throw new TestException(); }\n+        int t175 = x175 % 275; if(t175 == 0) { throw new TestException(); }\n+        int t176 = x176 % 276; if(t176 == 0) { throw new TestException(); }\n+        int t177 = x177 % 277; if(t177 == 0) { throw new TestException(); }\n+        int t178 = x178 % 278; if(t178 == 0) { throw new TestException(); }\n+        int t179 = x179 % 279; if(t179 == 0) { throw new TestException(); }\n+        int t180 = x180 % 280; if(t180 == 0) { throw new TestException(); }\n+        int t181 = x181 % 281; if(t181 == 0) { throw new TestException(); }\n+        int t182 = x182 % 282; if(t182 == 0) { throw new TestException(); }\n+        int t183 = x183 % 283; if(t183 == 0) { throw new TestException(); }\n+        int t184 = x184 % 284; if(t184 == 0) { throw new TestException(); }\n+        int t185 = x185 % 285; if(t185 == 0) { throw new TestException(); }\n+        int t186 = x186 % 286; if(t186 == 0) { throw new TestException(); }\n+        int t187 = x187 % 287; if(t187 == 0) { throw new TestException(); }\n+        int t188 = x188 % 288; if(t188 == 0) { throw new TestException(); }\n+        int t189 = x189 % 289; if(t189 == 0) { throw new TestException(); }\n+        int t190 = x190 % 290; if(t190 == 0) { throw new TestException(); }\n+        int t191 = x191 % 291; if(t191 == 0) { throw new TestException(); }\n+        int t192 = x192 % 292; if(t192 == 0) { throw new TestException(); }\n+        int t193 = x193 % 293; if(t193 == 0) { throw new TestException(); }\n+        int t194 = x194 % 294; if(t194 == 0) { throw new TestException(); }\n+        int t195 = x195 % 295; if(t195 == 0) { throw new TestException(); }\n+        int t196 = x196 % 296; if(t196 == 0) { throw new TestException(); }\n+        int t197 = x197 % 297; if(t197 == 0) { throw new TestException(); }\n+        int t198 = x198 % 298; if(t198 == 0) { throw new TestException(); }\n+        int t199 = x199 % 299; if(t199 == 0) { throw new TestException(); }\n+        int t200 = x200 % 300; if(t200 == 0) { throw new TestException(); }\n+        int t201 = x201 % 301; if(t201 == 0) { throw new TestException(); }\n+        int t202 = x202 % 302; if(t202 == 0) { throw new TestException(); }\n+        int t203 = x203 % 303; if(t203 == 0) { throw new TestException(); }\n+        int t204 = x204 % 304; if(t204 == 0) { throw new TestException(); }\n+        int t205 = x205 % 305; if(t205 == 0) { throw new TestException(); }\n+        int t206 = x206 % 306; if(t206 == 0) { throw new TestException(); }\n+        int t207 = x207 % 307; if(t207 == 0) { throw new TestException(); }\n+        int t208 = x208 % 308; if(t208 == 0) { throw new TestException(); }\n+        int t209 = x209 % 309; if(t209 == 0) { throw new TestException(); }\n+        int t210 = x210 % 310; if(t210 == 0) { throw new TestException(); }\n+        int t211 = x211 % 311; if(t211 == 0) { throw new TestException(); }\n+        int t212 = x212 % 312; if(t212 == 0) { throw new TestException(); }\n+        int t213 = x213 % 313; if(t213 == 0) { throw new TestException(); }\n+        int t214 = x214 % 314; if(t214 == 0) { throw new TestException(); }\n+        int t215 = x215 % 315; if(t215 == 0) { throw new TestException(); }\n+        int t216 = x216 % 316; if(t216 == 0) { throw new TestException(); }\n+        int t217 = x217 % 317; if(t217 == 0) { throw new TestException(); }\n+        int t218 = x218 % 318; if(t218 == 0) { throw new TestException(); }\n+        int t219 = x219 % 319; if(t219 == 0) { throw new TestException(); }\n+        int t220 = x220 % 320; if(t220 == 0) { throw new TestException(); }\n+        int t221 = x221 % 321; if(t221 == 0) { throw new TestException(); }\n+        int t222 = x222 % 322; if(t222 == 0) { throw new TestException(); }\n+        int t223 = x223 % 323; if(t223 == 0) { throw new TestException(); }\n+        int t224 = x224 % 324; if(t224 == 0) { throw new TestException(); }\n+        int t225 = x225 % 325; if(t225 == 0) { throw new TestException(); }\n+        int t226 = x226 % 326; if(t226 == 0) { throw new TestException(); }\n+        int t227 = x227 % 327; if(t227 == 0) { throw new TestException(); }\n+        int t228 = x228 % 328; if(t228 == 0) { throw new TestException(); }\n+        int t229 = x229 % 329; if(t229 == 0) { throw new TestException(); }\n+        int t230 = x230 % 330; if(t230 == 0) { throw new TestException(); }\n+        int t231 = x231 % 331; if(t231 == 0) { throw new TestException(); }\n+        int t232 = x232 % 332; if(t232 == 0) { throw new TestException(); }\n+        int t233 = x233 % 333; if(t233 == 0) { throw new TestException(); }\n+        int t234 = x234 % 334; if(t234 == 0) { throw new TestException(); }\n+        int t235 = x235 % 335; if(t235 == 0) { throw new TestException(); }\n+        int t236 = x236 % 336; if(t236 == 0) { throw new TestException(); }\n+        int t237 = x237 % 337; if(t237 == 0) { throw new TestException(); }\n+        int t238 = x238 % 338; if(t238 == 0) { throw new TestException(); }\n+        int t239 = x239 % 339; if(t239 == 0) { throw new TestException(); }\n+        int t240 = x240 % 340; if(t240 == 0) { throw new TestException(); }\n+        int t241 = x241 % 341; if(t241 == 0) { throw new TestException(); }\n+        int t242 = x242 % 342; if(t242 == 0) { throw new TestException(); }\n+        int t243 = x243 % 343; if(t243 == 0) { throw new TestException(); }\n+        int t244 = x244 % 344; if(t244 == 0) { throw new TestException(); }\n+        int t245 = x245 % 345; if(t245 == 0) { throw new TestException(); }\n+        int t246 = x246 % 346; if(t246 == 0) { throw new TestException(); }\n+        int t247 = x247 % 347; if(t247 == 0) { throw new TestException(); }\n+        int t248 = x248 % 348; if(t248 == 0) { throw new TestException(); }\n+        int t249 = x249 % 349; if(t249 == 0) { throw new TestException(); }\n+        int t250 = x250 % 350; if(t250 == 0) { throw new TestException(); }\n+        int t251 = x251 % 351; if(t251 == 0) { throw new TestException(); }\n+        int t252 = x252 % 352; if(t252 == 0) { throw new TestException(); }\n+        int t253 = x253 % 353; if(t253 == 0) { throw new TestException(); }\n+        int t254 = x254 % 354; if(t254 == 0) { throw new TestException(); }\n+        int t255 = x255 % 355; if(t255 == 0) { throw new TestException(); }\n+        \/\/ All temporaries are live here, stressing the register allocator.\n+        return t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 + t10 + t11 + t12 + t13 + t14 + t15 + t16 + t17 + t18 + t19 + t20 + t21 + t22 + t23 + t24 + t25 + t26 + t27 + t28 + t29 + t30 + t31 + t32 + t33 + t34 + t35 + t36 + t37 + t38 + t39 + t40 + t41 + t42 + t43 + t44 + t45 + t46 + t47 + t48 + t49 + t50 + t51 + t52 + t53 + t54 + t55 + t56 + t57 + t58 + t59 + t60 + t61 + t62 + t63 + t64 + t65 + t66 + t67 + t68 + t69 + t70 + t71 + t72 + t73 + t74 + t75 + t76 + t77 + t78 + t79 + t80 + t81 + t82 + t83 + t84 + t85 + t86 + t87 + t88 + t89 + t90 + t91 + t92 + t93 + t94 + t95 + t96 + t97 + t98 + t99 + t100 + t101 + t102 + t103 + t104 + t105 + t106 + t107 + t108 + t109 + t110 + t111 + t112 + t113 + t114 + t115 + t116 + t117 + t118 + t119 + t120 + t121 + t122 + t123 + t124 + t125 + t126 + t127 + t128 + t129 + t130 + t131 + t132 + t133 + t134 + t135 + t136 + t137 + t138 + t139 + t140 + t141 + t142 + t143 + t144 + t145 + t146 + t147 + t148 + t149 + t150 + t151 + t152 + t153 + t154 + t155 + t156 + t157 + t158 + t159 + t160 + t161 + t162 + t163 + t164 + t165 + t166 + t167 + t168 + t169 + t170 + t171 + t172 + t173 + t174 + t175 + t176 + t177 + t178 + t179 + t180 + t181 + t182 + t183 + t184 + t185 + t186 + t187 + t188 + t189 + t190 + t191 + t192 + t193 + t194 + t195 + t196 + t197 + t198 + t199 + t200 + t201 + t202 + t203 + t204 + t205 + t206 + t207 + t208 + t209 + t210 + t211 + t212 + t213 + t214 + t215 + t216 + t217 + t218 + t219 + t220 + t221 + t222 + t223 + t224 + t225 + t226 + t227 + t228 + t229 + t230 + t231 + t232 + t233 + t234 + t235 + t236 + t237 + t238 + t239 + t240 + t241 + t242 + t243 + t244 + t245 + t246 + t247 + t248 + t249 + t250 + t251 + t252 + t253 + t254 + t255;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arguments\/TestMaxMethodArguments.java","additions":323,"deletions":0,"binary":false,"changes":323,"status":"added"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8325467\n+ * @summary Ensure that C2 can compile methods up to the maximum\n+ *          number of parameters (according to the JVM spec).\n+ * @library \/test\/lib \/\n+ * @requires vm.compMode != \"Xcomp\"\n+ * @run driver\/timeout=1000 compiler.arguments.TestMethodArguments\n+ *\/\n+\n+package compiler.arguments;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import compiler.lib.compile_framework.CompileFramework;\n+import compiler.lib.template_framework.Template;\n+import compiler.lib.template_framework.library.CodeGenerationDataNameType;\n+import compiler.lib.template_framework.library.PrimitiveType;\n+\n+public class TestMethodArguments {\n+\n+    static final int MIN = 0;\n+    static final int MAX = 255;\n+    static final int INPUT_SIZE = 100;\n+\n+    public static Template.ZeroArgs generateTest(PrimitiveType type, int numberOfArguments) {\n+        String arguments = IntStream.range(0, numberOfArguments)\n+                .mapToObj(i -> \"input[\" + i + \"]\")\n+                .collect(Collectors.joining(\", \"));\n+        String parameters = IntStream.range(0, numberOfArguments)\n+                .mapToObj(i -> type.name() + \" x\" + i)\n+                .collect(Collectors.joining(\", \"));\n+        String sum = numberOfArguments == 0 ? \"0\"\n+                : IntStream.range(0, numberOfArguments)\n+                        .mapToObj(i -> \"x\" + i)\n+                        .collect(Collectors.joining(\" + \"));\n+        return Template.make(() -> Template.body(\n+                Template.let(\"type\", type.name()),\n+                Template.let(\"boxedType\", type.boxedTypeName()),\n+                Template.let(\"arguments\", arguments),\n+                Template.let(\"parameters\", parameters),\n+                Template.let(\"sum\", sum),\n+                Template.let(\"inputSize\", INPUT_SIZE),\n+                Template.let(\"numberOfArguments\", numberOfArguments),\n+                \"\"\"\n+                static #boxedType[][] $inputs = generateInput(generator#boxedType, new #boxedType[#inputSize][#numberOfArguments]);\n+                static int $nextInput = 0;\n+                static #type[] $golden = $init();\n+\n+                public static #type[] $init() {\n+                    #type[] golden = new #type[$inputs.length];\n+                    for (int i = 0; i < golden.length; ++i) {\n+                        #boxedType[] input = $inputs[i];\n+                        golden[i] = $test(#arguments);\n+                    }\n+                    return golden;\n+                }\n+\n+                @Setup\n+                public static Object[] $setup() {\n+                    #boxedType[] input = $inputs[$nextInput];\n+                    return new Object[]{#arguments};\n+                }\n+\n+                @Test\n+                @Arguments(setup = \"$setup\")\n+                public static #type $test(#parameters) {\n+                    return #sum;\n+                }\n+\n+                @Check(test = \"$test\")\n+                public static void $check(#type res) {\n+                    if (res != $golden[$nextInput]) {\n+                        throw new RuntimeException(\"wrong result \" + res + \"!=\" + $golden[$nextInput]);\n+                    }\n+                    $nextInput = ($nextInput + 1) % $inputs.length;\n+                }\n+                \"\"\"));\n+    }\n+\n+    public static String generate(CompileFramework comp) {\n+        List<Object> tests = new LinkedList<>();\n+        for (int i = MIN; i <= MAX; ++i) {\n+            tests.add(generateTest(CodeGenerationDataNameType.ints(), i).asToken());\n+            tests.add(generateTest(CodeGenerationDataNameType.floats(), i).asToken());\n+            \/\/ Longs and doubles take up double as much space in the parameter list as other\n+            \/\/ primitive types (e.g., int). We therefore have to divide by two to fill up\n+            \/\/ the same amount of space as for ints and floats.\n+            tests.add(generateTest(CodeGenerationDataNameType.longs(), i \/ 2).asToken());\n+            tests.add(generateTest(CodeGenerationDataNameType.doubles(), i \/ 2).asToken());\n+        }\n+        return Template.make(() -> Template.body(\n+                Template.let(\"classpath\", comp.getEscapedClassPathOfCompiledClasses()),\n+                \"\"\"\n+                import java.util.Arrays;\n+                import java.util.stream.*;\n+                import compiler.lib.generators.*;\n+                import compiler.lib.ir_framework.*;\n+                import compiler.lib.template_framework.library.*;\n+\n+                public class InnerTest {\n+\n+                    static RestrictableGenerator<Integer> generatorInteger = Generators.G.uniformInts();\n+                    static RestrictableGenerator<Long> generatorLong = Generators.G.uniformLongs();\n+                    static RestrictableGenerator<Float> generatorFloat = Generators.G.uniformFloats();\n+                    static RestrictableGenerator<Double> generatorDouble = Generators.G.uniformDoubles();\n+\n+                    public static void main() {\n+                        TestFramework framework = new TestFramework(InnerTest.class);\n+                        framework.addFlags(\"-classpath\", \"#classpath\");\n+                        framework.start();\n+                    }\n+\n+                    public static <T> T[][] generateInput(Generator<T> t, T[][] array) {\n+                        for (int i = 0; i < array.length; i++) {\n+                            for (int j = 0; j < array[i].length; j++) {\n+                                array[i][j] = t.next();\n+                            }\n+                        }\n+                        return array;\n+                    }\n+                \"\"\",\n+                tests,\n+                \"\"\"\n+                }\n+                \"\"\")).render();\n+    }\n+\n+    public static void main(String[] args) {\n+        CompileFramework comp = new CompileFramework();\n+        comp.addJavaSourceCode(\"InnerTest\", generate(comp));\n+        comp.compile();\n+        comp.invoke(\"InnerTest\", \"main\", new Object[] {});\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arguments\/TestMethodArguments.java","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -0,0 +1,207 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @bug 8364305\n+* @summary Test scalar float\/double to integral cast\n+* @requires vm.compiler2.enabled\n+* @library \/test\/lib \/\n+* @run main\/othervm\/native compiler.floatingpoint.ScalarFPtoIntCastTest\n+*\/\n+\n+package compiler.floatingpoint;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.generators.Generator;\n+import static compiler.lib.generators.Generators.G;\n+import compiler.lib.verify.Verify;\n+\n+public class ScalarFPtoIntCastTest {\n+    private static final int COUNT = 16;\n+\n+    private float[] float_arr;\n+    private double[] double_arr;\n+    private long[] long_float_arr;\n+    private long[] long_double_arr;\n+    private int[] int_float_arr;\n+    private int[] int_double_arr;\n+    private short[] short_float_arr;\n+    private short[] short_double_arr;\n+    private byte[] byte_float_arr;\n+    private byte[] byte_double_arr;\n+\n+    private static final Generator<Float> genF = G.floats();\n+    private static final Generator<Double> genD = G.doubles();\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.start();\n+    }\n+\n+    public ScalarFPtoIntCastTest() {\n+        long_float_arr = new long[COUNT];\n+        long_double_arr = new long[COUNT];\n+        int_float_arr = new int[COUNT];\n+        int_double_arr = new int[COUNT];\n+        short_float_arr = new short[COUNT];\n+        short_double_arr = new short[COUNT];\n+        byte_float_arr = new byte[COUNT];\n+        byte_double_arr = new byte[COUNT];\n+        float_arr = new float[COUNT];\n+        double_arr = new double[COUNT];\n+\n+        G.fill(genF, float_arr);\n+        G.fill(genD, double_arr);\n+        for (int i = 0; i < COUNT; i++) {\n+            long_float_arr[i] = (long) float_arr[i];\n+            long_double_arr[i] = (long) double_arr[i];\n+            int_float_arr[i] = (int) float_arr[i];\n+            int_double_arr[i] = (int) double_arr[i];\n+            short_float_arr[i] = (short) float_arr[i];\n+            short_double_arr[i] = (short) double_arr[i];\n+            byte_float_arr[i] = (byte) float_arr[i];\n+            byte_double_arr[i] = (byte) double_arr[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV_F2I, \"> 0\"})\n+    @IR(counts = {IRNode.X86_SCONV_F2I, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_SCONV_F2I_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n+    public void float2int() {\n+        for (int i = 0; i < COUNT; i++) {\n+            float float_val = float_arr[i];\n+            int computed = (int) float_val;\n+            int expected = int_float_arr[i];\n+            Verify.checkEQ(computed, expected);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV_F2L, \"> 0\"})\n+    @IR(counts = {IRNode.X86_SCONV_F2L, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_SCONV_F2L_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n+    public void float2long() {\n+        for (int i = 0; i < COUNT; i++) {\n+            float float_val = float_arr[i];\n+            long computed = (long) float_val;\n+            long expected = long_float_arr[i];\n+            Verify.checkEQ(computed, expected);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV_F2I, \"> 0\"})\n+    @IR(counts = {IRNode.X86_SCONV_F2I, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_SCONV_F2I_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n+    public void float2short() {\n+        for (int i = 0; i < COUNT; i++) {\n+            float float_val = float_arr[i];\n+            short computed = (short) float_val;\n+            short expected = short_float_arr[i];\n+            Verify.checkEQ(computed, expected);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV_F2I, \"> 0\"})\n+    @IR(counts = {IRNode.X86_SCONV_F2I, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_SCONV_F2I_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n+    public void float2byte() {\n+        for (int i = 0; i < COUNT; i++) {\n+            float float_val = float_arr[i];\n+            byte computed = (byte) float_val;\n+            byte expected = byte_float_arr[i];\n+            Verify.checkEQ(computed, expected);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV_D2I, \"> 0\"})\n+    @IR(counts = {IRNode.X86_SCONV_D2I, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_SCONV_D2I_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n+    public void double2int() {\n+        for (int i = 0; i < COUNT; i++) {\n+            double double_val = double_arr[i];\n+            int computed = (int) double_val;\n+            int expected = int_double_arr[i];\n+            Verify.checkEQ(computed, expected);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV_D2L, \"> 0\"})\n+    @IR(counts = {IRNode.X86_SCONV_D2L, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_SCONV_D2L_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n+    public void double2long() {\n+        for (int i = 0; i < COUNT; i++) {\n+            double double_val = double_arr[i];\n+            long computed = (long) double_val;\n+            long expected = long_double_arr[i];\n+            Verify.checkEQ(computed, expected);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV_D2I, \"> 0\"})\n+    @IR(counts = {IRNode.X86_SCONV_D2I, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_SCONV_D2I_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n+    public void double2short() {\n+        for (int i = 0; i < COUNT; i++) {\n+            double double_val = double_arr[i];\n+            short computed = (short) double_val;\n+            short expected = short_double_arr[i];\n+            Verify.checkEQ(computed, expected);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CONV_D2I, \"> 0\"})\n+    @IR(counts = {IRNode.X86_SCONV_D2I, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_SCONV_D2I_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n+    public void double2byte() {\n+        for (int i = 0; i < COUNT; i++) {\n+            double double_val = double_arr[i];\n+            byte computed = (byte) double_val;\n+            byte expected = byte_double_arr[i];\n+            Verify.checkEQ(computed, expected);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/floatingpoint\/ScalarFPtoIntCastTest.java","additions":207,"deletions":0,"binary":false,"changes":207,"status":"added"},{"patch":"@@ -613,0 +613,10 @@\n+    public static final String CONV_D2I = PREFIX + \"CONV_D2I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CONV_D2I, \"ConvD2I\");\n+    }\n+\n+    public static final String CONV_D2L = PREFIX + \"CONV_D2L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CONV_D2L, \"ConvD2L\");\n+    }\n+\n@@ -618,0 +628,10 @@\n+    public static final String CONV_F2I = PREFIX + \"CONV_F2I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CONV_F2I, \"ConvF2I\");\n+    }\n+\n+    public static final String CONV_F2L = PREFIX + \"CONV_F2L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CONV_F2L, \"ConvF2L\");\n+    }\n+\n@@ -2678,0 +2698,60 @@\n+    public static final String X86_SCONV_D2I = PREFIX + \"X86_SCONV_D2I\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_SCONV_D2I, \"convD2I_reg_reg\");\n+    }\n+\n+    public static final String X86_SCONV_D2L = PREFIX + \"X86_SCONV_D2L\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_SCONV_D2L, \"convD2L_reg_reg\");\n+    }\n+\n+    public static final String X86_SCONV_F2I = PREFIX + \"X86_SCONV_F2I\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_SCONV_F2I, \"convF2I_reg_reg\");\n+    }\n+\n+    public static final String X86_SCONV_F2L = PREFIX + \"X86_SCONV_F2L\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_SCONV_F2L, \"convF2L_reg_reg\");\n+    }\n+\n+    public static final String X86_SCONV_D2I_AVX10 = PREFIX + \"X86_SCONV2_D2I_AVX10\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_SCONV_D2I_AVX10, \"convD2I_(reg_reg|reg_mem)_avx10\");\n+    }\n+\n+    public static final String X86_SCONV_D2L_AVX10 = PREFIX + \"X86_SCONV_D2L_AVX10\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_SCONV_D2L_AVX10, \"convD2L_(reg_reg|reg_mem)_avx10\");\n+    }\n+\n+    public static final String X86_SCONV_F2I_AVX10 = PREFIX + \"X86_SCONV_F2I_AVX10\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_SCONV_F2I_AVX10, \"convF2I_(reg_reg|reg_mem)_avx10\");\n+    }\n+\n+    public static final String X86_SCONV_F2L_AVX10 = PREFIX + \"X86_SCONV_F2L_AVX10\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_SCONV_F2L_AVX10, \"convF2L_(reg_reg|reg_mem)_avx10\");\n+    }\n+\n+    public static final String X86_VCAST_F2X = PREFIX + \"X86_VCAST_F2X\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_VCAST_F2X, \"castFtoX_reg_(av|eve)x\");\n+    }\n+\n+    public static final String X86_VCAST_D2X = PREFIX + \"X86_VCAST_D2X\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_VCAST_D2X, \"castDtoX_reg_(av|eve)x\");\n+    }\n+\n+    public static final String X86_VCAST_F2X_AVX10 = PREFIX + \"X86_VCAST_F2X_AVX10\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_VCAST_F2X_AVX10, \"castFtoX_(reg|mem)_avx10\");\n+    }\n+\n+    public static final String X86_VCAST_D2X_AVX10 = PREFIX + \"X86_VCAST_D2X_AVX10\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_VCAST_D2X_AVX10, \"castDtoX_(reg|mem)_avx10\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -109,0 +109,1 @@\n+        \"avx10_2\",\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,4 +26,8 @@\n- * @bug 8322996\n- * @summary Ensure no assert error in C2 with deeply nested synchronize\n- *          statements.\n- * @run main\/othervm -XX:CompileCommand=compileonly,compiler.locks.TestNestedSynchronize::test\n+ * @bug 8322996 8324839 8325467\n+ * @summary Ensure C2 can compile deeply nested synchronize statements.\n+ *          Exercises C2 register masks, in particular. We incrementally\n+ *          increase the level of nesting (up to 100) to trigger potential edge\n+ *          cases.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run main\/othervm -XX:CompileCommand=compileonly,Test::test*\n@@ -31,0 +35,2 @@\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+AbortVMOnCompilationFailure\n@@ -32,0 +38,1 @@\n+ * @run main compiler.locks.TestNestedSynchronize\n@@ -36,0 +43,3 @@\n+import compiler.lib.compile_framework.*;\n+import java.util.LinkedList;\n+\n@@ -37,0 +47,4 @@\n+    static int min = 1;\n+    static int max = 100;\n+    static String test_class_name = \"Test\";\n+    static String test_method_name = \"test\";\n@@ -38,2 +52,57 @@\n-    public static void main(String[] args) {\n-        test();\n+    \/\/ The below method generates a program of the form:\n+    \/\/\n+    \/\/ public class Test {\n+    \/\/     public static void test1() {\n+    \/\/         synchronized (Test.class) {\n+    \/\/         }\n+    \/\/     }\n+    \/\/\n+    \/\/     public static void test2() {\n+    \/\/         synchronized (Test.class) {\n+    \/\/         synchronized (Test.class) {\n+    \/\/         }\n+    \/\/         }\n+    \/\/     }\n+    \/\/\n+    \/\/     public static void test3() {\n+    \/\/         synchronized (Test.class) {\n+    \/\/         synchronized (Test.class) {\n+    \/\/         synchronized (Test.class) {\n+    \/\/         }\n+    \/\/         }\n+    \/\/         }\n+    \/\/     }\n+    \/\/\n+    \/\/     ...\n+    \/\/\n+    \/\/     public static void test100() {\n+    \/\/         synchronized (Test.class) {\n+    \/\/         synchronized (Test.class) {\n+    \/\/         synchronized (Test.class) {\n+    \/\/         ...\n+    \/\/         }\n+    \/\/         }\n+    \/\/         }\n+    \/\/     }\n+    \/\/ }\n+    \/\/\n+    \/\/ The above is a massive program. Therefore, we do not directly inline the\n+    \/\/ program in TestNestedSynchronize and instead compile and run it via the\n+    \/\/ CompileFramework.\n+    public static String generate_test() {\n+        LinkedList<String> acc = new LinkedList<String>();\n+        for (int i = min; i <= max; i++) {\n+            LinkedList<String> method = new LinkedList<String>();\n+            for (int j = 0; j < i; j++) {\n+                method.addFirst(String.format(\n+                    \"        synchronized (%s.class) {\", test_class_name));\n+                method.addLast(\"        }\");\n+            }\n+            method.addFirst(String.format(\n+                \"    public static void %s%d() {\", test_method_name, i));\n+            method.addLast(\"    }\");\n+            acc.addAll(method);\n+        }\n+        acc.addFirst(String.format(\"public class %s {\", test_class_name));\n+        acc.addLast(\"}\");\n+        return String.join(\"\\n\", acc);\n@@ -42,194 +111,6 @@\n-    public static void test() {\n-\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n+    public static void main(String[] args) {\n+        CompileFramework comp = new CompileFramework();\n+        comp.addJavaSourceCode(test_class_name, generate_test());\n+        comp.compile();\n+        for (int i = min; i <= max; i++) {\n+            comp.invoke(test_class_name, test_method_name + i, new Object[] {});\n","filename":"test\/hotspot\/jtreg\/compiler\/locks\/TestNestedSynchronize.java","additions":82,"deletions":201,"binary":false,"changes":283,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-    @IR(counts = { IRNode.EXPAND_VB, \"= 1\" }, applyIfCPUFeature = { \"asimd\", \"true\" })\n+    @IR(counts = { IRNode.EXPAND_VB, \"= 1\" }, applyIfCPUFeatureOr = { \"asimd\", \"true\", \"rvv\", \"true\" })\n@@ -108,1 +108,1 @@\n-    @IR(counts = { IRNode.EXPAND_VS, \"= 1\" }, applyIfCPUFeature = { \"asimd\", \"true\" })\n+    @IR(counts = { IRNode.EXPAND_VS, \"= 1\" }, applyIfCPUFeatureOr = { \"asimd\", \"true\", \"rvv\", \"true\" })\n@@ -125,1 +125,1 @@\n-    @IR(counts = { IRNode.EXPAND_VI, \"= 1\" }, applyIfCPUFeature = { \"asimd\", \"true\" })\n+    @IR(counts = { IRNode.EXPAND_VI, \"= 1\" }, applyIfCPUFeatureOr = { \"asimd\", \"true\", \"rvv\", \"true\" })\n@@ -142,1 +142,1 @@\n-    @IR(counts = { IRNode.EXPAND_VL, \"= 1\" }, applyIfCPUFeature = { \"asimd\", \"true\" })\n+    @IR(counts = { IRNode.EXPAND_VL, \"= 1\" }, applyIfCPUFeatureOr = { \"asimd\", \"true\", \"rvv\", \"true\" })\n@@ -159,1 +159,1 @@\n-    @IR(counts = { IRNode.EXPAND_VF, \"= 1\" }, applyIfCPUFeature = { \"asimd\", \"true\" })\n+    @IR(counts = { IRNode.EXPAND_VF, \"= 1\" }, applyIfCPUFeatureOr = { \"asimd\", \"true\", \"rvv\", \"true\" })\n@@ -176,1 +176,1 @@\n-    @IR(counts = { IRNode.EXPAND_VD, \"= 1\" }, applyIfCPUFeature = { \"asimd\", \"true\" })\n+    @IR(counts = { IRNode.EXPAND_VD, \"= 1\" }, applyIfCPUFeatureOr = { \"asimd\", \"true\", \"rvv\", \"true\" })\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorExpandTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,2 @@\n-* @bug 8287835\n-* @summary Test float\/double to integral cast\n+* @bug 8287835 8364305\n+* @summary Test vector float\/double to integral cast\n@@ -90,1 +90,5 @@\n-        applyIfCPUFeature = {\"avx512f\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512f\", \"true\", \"avx10_2\", \"true\"})\n+    @IR(counts = {IRNode.X86_VCAST_F2X, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"avx512f\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_VCAST_F2X_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -99,1 +103,1 @@\n-            int expected = (int)float_arr[i];\n+            int expected = (int) float_arr[i];\n@@ -108,1 +112,5 @@\n-        applyIfCPUFeature = {\"avx512dq\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512dq\", \"true\", \"avx10_2\", \"true\"})\n+    @IR(counts = {IRNode.X86_VCAST_F2X, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"avx512dq\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_VCAST_F2X_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -117,1 +125,1 @@\n-            long expected = (long)float_arr[i];\n+            long expected = (long) float_arr[i];\n@@ -126,1 +134,5 @@\n-        applyIfCPUFeature = {\"avx512f\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512f\", \"true\", \"avx10_2\", \"true\"})\n+    @IR(counts = {IRNode.X86_VCAST_F2X, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"avx512f\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_VCAST_F2X_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -135,1 +147,1 @@\n-            short expected = (short)float_arr[i];\n+            short expected = (short) float_arr[i];\n@@ -144,1 +156,5 @@\n-        applyIfCPUFeature = {\"avx512f\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512f\", \"true\", \"avx10_2\", \"true\"})\n+    @IR(counts = {IRNode.X86_VCAST_F2X, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"avx512f\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_VCAST_F2X_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -153,1 +169,1 @@\n-            byte expected = (byte)float_arr[i];\n+            byte expected = (byte) float_arr[i];\n@@ -162,1 +178,5 @@\n-        applyIfCPUFeature = {\"avx512f\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512f\", \"true\", \"avx10_2\", \"true\"})\n+    @IR(counts = {IRNode.X86_VCAST_D2X, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"avx512f\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_VCAST_D2X_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -171,1 +191,1 @@\n-            int expected = (int)double_arr[i];\n+            int expected = (int) double_arr[i];\n@@ -180,1 +200,5 @@\n-        applyIfCPUFeature = {\"avx512dq\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512dq\", \"true\", \"avx10_2\", \"true\"})\n+    @IR(counts = {IRNode.X86_VCAST_D2X, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"avx512dq\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_VCAST_D2X_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -189,1 +213,1 @@\n-            long expected = (long)double_arr[i];\n+            long expected = (long) double_arr[i];\n@@ -198,1 +222,5 @@\n-        applyIfCPUFeature = {\"avx512f\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512f\", \"true\", \"avx10_2\", \"true\"})\n+    @IR(counts = {IRNode.X86_VCAST_D2X, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"avx512f\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_VCAST_D2X_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -207,1 +235,1 @@\n-            short expected = (short)double_arr[i];\n+            short expected = (short) double_arr[i];\n@@ -216,1 +244,5 @@\n-        applyIfCPUFeature = {\"avx512f\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512f\", \"true\", \"avx10_2\", \"true\"})\n+    @IR(counts = {IRNode.X86_VCAST_D2X, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"avx512f\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_VCAST_D2X_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -225,1 +257,1 @@\n-            byte expected = (byte)double_arr[i];\n+            byte expected = (byte) double_arr[i];\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorFPtoIntCastTest.java","additions":51,"deletions":19,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+ * @requires (os.arch != \"riscv64\" | (os.arch == \"riscv64\" & vm.cpu.features ~= \".*rvv.*\"))\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskCompareNotTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-* @bug 8356760\n+* @bug 8356760 8367391\n@@ -176,1 +176,1 @@\n-                   IRNode.VECTOR_LONG_TO_MASK, \"> 0\" },\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 2\" },\n@@ -182,1 +182,1 @@\n-                   IRNode.VECTOR_LONG_TO_MASK, \"> 0\" },\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 2\" },\n@@ -185,2 +185,3 @@\n-        \/\/ Test the case where some but not all bits are set.\n-        testMaskFromLong(B_SPECIES, (-1L >>> (64 - B_SPECIES.length()))-1);\n+        \/\/ Test cases where some but not all bits are set.\n+        testMaskFromLong(B_SPECIES, (-1L >>> (64 - B_SPECIES.length())) - 1);\n+        testMaskFromLong(B_SPECIES, (-1L >>> (64 - B_SPECIES.length())) >>> 1);\n@@ -191,1 +192,1 @@\n-                   IRNode.VECTOR_LONG_TO_MASK, \"> 0\" },\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 2\" },\n@@ -197,1 +198,1 @@\n-                   IRNode.VECTOR_LONG_TO_MASK, \"> 0\" },\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 2\" },\n@@ -200,2 +201,3 @@\n-        \/\/ Test the case where some but not all bits are set.\n-        testMaskFromLong(S_SPECIES, (-1L >>> (64 - S_SPECIES.length()))-1);\n+        \/\/ Test cases where some but not all bits are set.\n+        testMaskFromLong(S_SPECIES, (-1L >>> (64 - S_SPECIES.length())) - 1);\n+        testMaskFromLong(S_SPECIES, (-1L >>> (64 - S_SPECIES.length())) >>> 1);\n@@ -206,1 +208,1 @@\n-                   IRNode.VECTOR_LONG_TO_MASK, \"> 0\" },\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 2\" },\n@@ -212,1 +214,1 @@\n-                   IRNode.VECTOR_LONG_TO_MASK, \"> 0\" },\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 2\" },\n@@ -215,2 +217,3 @@\n-        \/\/ Test the case where some but not all bits are set.\n-        testMaskFromLong(I_SPECIES, (-1L >>> (64 - I_SPECIES.length()))-1);\n+        \/\/ Test cases where some but not all bits are set.\n+        testMaskFromLong(I_SPECIES, (-1L >>> (64 - I_SPECIES.length())) - 1);\n+        testMaskFromLong(I_SPECIES, (-1L >>> (64 - I_SPECIES.length())) >>> 1);\n@@ -221,1 +224,1 @@\n-                   IRNode.VECTOR_LONG_TO_MASK, \"> 0\" },\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 2\" },\n@@ -227,1 +230,1 @@\n-                   IRNode.VECTOR_LONG_TO_MASK, \"> 0\" },\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 2\" },\n@@ -230,2 +233,3 @@\n-        \/\/ Test the case where some but not all bits are set.\n-        testMaskFromLong(L_SPECIES, (-1L >>> (64 - L_SPECIES.length()))-1);\n+        \/\/ Test cases where some but not all bits are set.\n+        testMaskFromLong(L_SPECIES, (-1L >>> (64 - L_SPECIES.length())) - 1);\n+        testMaskFromLong(L_SPECIES, (-1L >>> (64 - L_SPECIES.length())) >>> 1);\n@@ -236,1 +240,1 @@\n-                   IRNode.VECTOR_LONG_TO_MASK, \"> 0\" },\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 2\" },\n@@ -242,1 +246,1 @@\n-                   IRNode.VECTOR_LONG_TO_MASK, \"> 0\" },\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 2\" },\n@@ -245,2 +249,3 @@\n-        \/\/ Test the case where some but not all bits are set.\n-        testMaskFromLong(F_SPECIES, (-1L >>> (64 - F_SPECIES.length()))-1);\n+        \/\/ Test cases where some but not all bits are set.\n+        testMaskFromLong(F_SPECIES, (-1L >>> (64 - F_SPECIES.length())) - 1);\n+        testMaskFromLong(F_SPECIES, (-1L >>> (64 - F_SPECIES.length())) >>> 1);\n@@ -251,1 +256,1 @@\n-                   IRNode.VECTOR_LONG_TO_MASK, \"> 0\" },\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 2\" },\n@@ -257,1 +262,1 @@\n-                   IRNode.VECTOR_LONG_TO_MASK, \"> 0\" },\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 2\" },\n@@ -260,2 +265,3 @@\n-        \/\/ Test the case where some but not all bits are set.\n-        testMaskFromLong(D_SPECIES, (-1L >>> (64 - D_SPECIES.length()))-1);\n+        \/\/ Test cases where some but not all bits are set.\n+        testMaskFromLong(D_SPECIES, (-1L >>> (64 - D_SPECIES.length())) - 1);\n+        testMaskFromLong(D_SPECIES, (-1L >>> (64 - D_SPECIES.length())) >>> 1);\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskFromLongTest.java","additions":31,"deletions":25,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -297,2 +297,6 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"},\n-        counts = {IRNode.VECTOR_CAST_F2I, IRNode.VECTOR_SIZE + \"min(max_float, max_int)\", \">0\"})\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\", \"avx10_2\", \"true\", \"rvv\", \"true\"},\n+        counts = {IRNode.VECTOR_CAST_F2I, IRNode.VECTOR_SIZE + \"min(max_float, max_int)\", \"> 0\"})\n+    @IR(counts = {IRNode.X86_VCAST_F2X, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_VCAST_F2X_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -308,2 +312,6 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx512dq\", \"true\", \"rvv\", \"true\"},\n-        counts = {IRNode.VECTOR_CAST_F2L, IRNode.VECTOR_SIZE + \"min(max_float, max_long)\", \">0\"})\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx512dq\", \"true\", \"avx10_2\", \"true\", \"rvv\", \"true\"},\n+        counts = {IRNode.VECTOR_CAST_F2L, IRNode.VECTOR_SIZE + \"min(max_float, max_long)\", \"> 0\"})\n+    @IR(counts = {IRNode.X86_VCAST_F2X, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"avx512dq\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_VCAST_F2X_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -319,2 +327,6 @@\n-    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx\", \"true\", \"rvv\", \"true\"},\n-        counts = {IRNode.VECTOR_CAST_D2I, IRNode.VECTOR_SIZE + \"min(max_double, max_int)\", \">0\"})\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx\", \"true\", \"avx10_2\", \"true\", \"rvv\", \"true\"},\n+        counts = {IRNode.VECTOR_CAST_D2I, IRNode.VECTOR_SIZE + \"min(max_double, max_int)\", \"> 0\"})\n+    @IR(counts = {IRNode.X86_VCAST_D2X, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_VCAST_D2X_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -330,2 +342,6 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx512dq\", \"true\", \"rvv\", \"true\"},\n-        counts = {IRNode.VECTOR_CAST_D2L, IRNode.VECTOR_SIZE + \"min(max_double, max_long)\", \">0\"})\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx512dq\", \"true\", \"avx10_2\", \"true\", \"rvv\", \"true\"},\n+        counts = {IRNode.VECTOR_CAST_D2L, IRNode.VECTOR_SIZE + \"min(max_double, max_long)\", \"> 0\"})\n+    @IR(counts = {IRNode.X86_VCAST_D2X, \"> 0\"},\n+        applyIfCPUFeatureAnd = {\"avx512dq\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_VCAST_D2X_AVX10, \"> 0\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -342,1 +358,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\", \"avx10_2\", \"true\", \"rvv\", \"true\"},\n@@ -344,1 +360,7 @@\n-        counts = {IRNode.VECTOR_CAST_F2S, IRNode.VECTOR_SIZE + \"min(max_float, max_short)\", \">0\"})\n+        counts = {IRNode.VECTOR_CAST_F2S, IRNode.VECTOR_SIZE + \"min(max_float, max_short)\", \"> 0\"})\n+    @IR(counts = {IRNode.X86_VCAST_F2X, \"> 0\"},\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_VCAST_F2X_AVX10, \"> 0\"},\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -361,1 +383,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\", \"avx10_2\", \"true\", \"rvv\", \"true\"},\n@@ -363,1 +385,7 @@\n-        counts = {IRNode.VECTOR_CAST_F2S, IRNode.VECTOR_SIZE + \"min(max_float, max_char)\", \">0\"})\n+        counts = {IRNode.VECTOR_CAST_F2S, IRNode.VECTOR_SIZE + \"min(max_float, max_char)\", \"> 0\"})\n+    @IR(counts = {IRNode.X86_VCAST_F2X, \"> 0\"},\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_VCAST_F2X_AVX10, \"> 0\"},\n+        applyIfOr = {\"AlignVector\", \"false\", \"UseCompactObjectHeaders\", \"false\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -382,2 +410,5 @@\n-        counts = {IRNode.VECTOR_CAST_D2S, IRNode.VECTOR_SIZE + \"min(max_double, max_short)\", \">0\"})\n-    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx\", \"true\"},\n+        counts = {IRNode.VECTOR_CAST_D2S, IRNode.VECTOR_SIZE + \"min(max_double, max_short)\", \"> 0\"})\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx\", \"true\", \"avx10_2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=16\"},\n+        counts = {IRNode.VECTOR_CAST_D2S, IRNode.VECTOR_SIZE + \"min(max_double, max_short)\", \"> 0\"})\n+    @IR(counts = {IRNode.X86_VCAST_D2X, \"> 0\"},\n@@ -385,1 +416,4 @@\n-        counts = {IRNode.VECTOR_CAST_D2S, IRNode.VECTOR_SIZE + \"min(max_double, max_short)\", \">0\"})\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_VCAST_D2X_AVX10, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">=16\"},\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n@@ -396,3 +430,9 @@\n-        applyIf = {\"MaxVectorSize\", \">=32\"},\n-        counts = {IRNode.VECTOR_CAST_D2S, IRNode.VECTOR_SIZE + \"min(max_double, max_char)\", \">0\"})\n-    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">= 32\"},\n+        counts = {IRNode.VECTOR_CAST_D2S, IRNode.VECTOR_SIZE + \"min(max_double, max_char)\", \"> 0\"})\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx\", \"true\", \"avx10_2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">= 16\"},\n+        counts = {IRNode.VECTOR_CAST_D2S, IRNode.VECTOR_SIZE + \"min(max_double, max_char)\", \"> 0\"})\n+    @IR(counts = {IRNode.X86_VCAST_D2X, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">=16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx10_2\", \"false\"})\n+    @IR(counts = {IRNode.X86_VCAST_D2X_AVX10, \"> 0\"},\n@@ -400,1 +440,1 @@\n-        counts = {IRNode.VECTOR_CAST_D2S, IRNode.VECTOR_SIZE + \"min(max_double, max_char)\", \">0\"})\n+        applyIfCPUFeature = {\"avx10_2\", \"true\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayTypeConvertTest.java","additions":59,"deletions":19,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/z\/TestZNMT.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,2 +53,2 @@\n-        String loadFromJar = \".class,load. Hello source: file:.*signed_hello.jar\";\n-        String lambdaLoadFromHello = \".class.load. Hello[$][$]Lambda.*\/0x.*source.*Hello\";\n+        String loadFromJar = \".class,load\\s*. Hello source: file:.*signed_hello.jar\";\n+        String lambdaLoadFromHello = \".class.load\\s*. Hello[$][$]Lambda.*\/0x.*source.*Hello\";\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/SignedJar.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\/*\n+ * @test\n+ * @summary Tests the effect of jdk.internal.vm.annotation.AOTXXX annotations\n+ *          in the core Java library.\n+ * @bug 8317269\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @library \/test\/jdk\/lib\/testlibrary \/test\/lib\n+ * @build AOTAnnotationsTest\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar AOTAnnotationsTestApp\n+ * @run driver AOTAnnotationsTest\n+ *\/\n+\n+import jdk.test.lib.cds.CDSAppTester;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class AOTAnnotationsTest {\n+    static final String appJar = ClassFileInstaller.getJarPath(\"app.jar\");\n+    static final String mainClass = AOTAnnotationsTestApp.class.getName();\n+\n+    public static void main(String[] args) throws Exception {\n+        Tester tester = new Tester();\n+        tester.run(new String[] {\"AOT\", \"--two-step-training\"} );\n+    }\n+\n+    static class Tester extends CDSAppTester {\n+        public Tester() {\n+            super(mainClass);\n+        }\n+\n+        @Override\n+        public String classpath(RunMode runMode) {\n+            return appJar;\n+        }\n+\n+        @Override\n+        public String[] vmArgs(RunMode runMode) {\n+            return new String[] {\n+                \"-Xlog:aot+class=debug\",\n+                \"-Xlog:aot+init\",\n+            };\n+        }\n+\n+        @Override\n+        public String[] appCommandLine(RunMode runMode) {\n+            return new String[] { mainClass};\n+        }\n+\n+        @Override\n+        public void checkExecution(OutputAnalyzer out, RunMode runMode) {\n+            if (runMode == RunMode.ASSEMBLY) {\n+                out.shouldMatch(\"jdk.internal.math.MathUtils .*inited\");\n+            }\n+        }\n+    }\n+}\n+\n+class AOTAnnotationsTestApp {\n+    public static void main(String args[]) {\n+        double d = 12.34567;\n+\n+        \/\/ Double.toString() uses jdk.internal.math.MathUtils.\n+        \/\/ Because MathUtils has @AOTSafeClassInitializer and was initialized during\n+        \/\/ the training run, it will be cached in aot-inited state.\n+        System.out.println(Double.toString(d));\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotAnnotations\/AOTAnnotationsTest.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary classes defined with JNI DefineClass should be excluded from the AOT config file and AOT cache.\n+ * @bug 8368182\n+ * @requires vm.cds\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @library \/test\/lib\n+ * @build JNIDefineClass\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar\n+ *                 JNIDefineClassApp ExcludedDummy ExcludedDummy2\n+ * @run main\/native JNIDefineClass\n+ *\/\n+\n+import java.io.InputStream;\n+import jdk.test.lib.cds.CDSAppTester;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class JNIDefineClass {\n+    static final String appJar = ClassFileInstaller.getJarPath(\"app.jar\");\n+    static final String mainClass = \"JNIDefineClassApp\";\n+\n+    public static void main(String[] args) throws Exception {\n+        Tester tester = new Tester();\n+        tester.run(new String[] {\"AOT\", \"--two-step-training\"} );\n+    }\n+\n+    static class Tester extends CDSAppTester {\n+        public Tester() {\n+            super(mainClass);\n+        }\n+\n+        @Override\n+        public String classpath(RunMode runMode) {\n+            return appJar;\n+        }\n+\n+        @Override\n+        public String[] vmArgs(RunMode runMode) {\n+            return new String[] {\n+                \"--enable-native-access=ALL-UNNAMED\",\n+                \"-Xlog:aot,aot+class=debug\",\n+                \"-Djava.library.path=\" + System.getProperty(\"java.library.path\"),\n+            };\n+        }\n+\n+        @Override\n+        public String[] appCommandLine(RunMode runMode) {\n+            return new String[] {mainClass};\n+        }\n+\n+        @Override\n+        public void checkExecution(OutputAnalyzer out, RunMode runMode) {\n+            if (runMode.isApplicationExecuted()) {\n+                out.shouldContain(\"@@loader = null\");\n+                out.shouldContain(\"@@name = ExcludedDummy\");\n+\n+                out.shouldMatch(\"@@loader2 = .*AppClassLoader\");\n+                out.shouldContain(\"@@name2 = ExcludedDummy2\");\n+            }\n+            if (runMode == RunMode.TRAINING) {\n+                out.shouldContain(\"Skipping ExcludedDummy: Unsupported location\");\n+            }\n+\n+            \/\/ Must not have a log like this\n+            \/\/\/ [0.378s][debug  ][aot,class] klasses[   65] = 0x0000000800160490 boot  ExcludedDummy\n+            \/\/\/ [0.378s][debug  ][aot,class] klasses[   66] = 0x0000000800160490 app   ExcludedDummy2\n+            out.shouldNotContain(\"aot,class.* klasses.*ExcludedDummy\");\n+            out.shouldNotContain(\"aot,class.* klasses.*ExcludedDummy2\");\n+        }\n+    }\n+}\n+\n+class JNIDefineClassApp {\n+\n+    static native Class<?> nativeDefineClass(String name, ClassLoader ldr, byte[] class_bytes);\n+\n+    static {\n+        System.loadLibrary(\"JNIDefineClassApp\");\n+    }\n+\n+    public static void main(java.lang.String[] unused) throws Exception {\n+        ClassLoader appLoader = JNIDefineClassApp.class.getClassLoader();\n+\n+        try (InputStream in = appLoader.getResourceAsStream(\"ExcludedDummy.class\")) {\n+            byte[] b = in.readAllBytes();\n+            System.out.println(b.length);\n+            Class<?> c = nativeDefineClass(\"ExcludedDummy\", null, b);\n+            System.out.println(\"@@loader = \" + c.getClassLoader());\n+            System.out.println(\"@@name = \" + c.getName());\n+        }\n+\n+        try (InputStream in = appLoader.getResourceAsStream(\"ExcludedDummy2.class\")) {\n+            byte[] b = in.readAllBytes();\n+            System.out.println(b.length);\n+            Class<?> c = nativeDefineClass(\"ExcludedDummy2\", appLoader, b);\n+            System.out.println(\"@@loader2 = \" + c.getClassLoader());\n+            System.out.println(\"@@name2 = \" + c.getName());\n+        }\n+\n+        System.out.println(\"TEST PASSED\");\n+    }\n+}\n+\n+\/\/ This class is loaded into the bootstrap loader using JNI DefineClass() with a null code source,\n+\/\/ so it should be excluded from the AOT configuration (and hence excluded from AOT cache)\n+class ExcludedDummy {\n+\n+}\n+\n+\/\/ This class is loaded into the app loader using JNI DefineClass() with a null code source,\n+\/\/ so it should be excluded from the AOT configuration (and hence excluded from AOT cache)\n+class ExcludedDummy2 {\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCache\/JNIDefineClass.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -41,0 +41,1 @@\n+ * @requires vm.cds.supports.aot.class.linking\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCache\/JavaAgent.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+                \"-Xlog:aot\",\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCache\/OldClassSupport.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-            .addVmArgs(\"-Xlog:aot+class=debug\")\n+            .addVmArgs(\"-Xlog:aot,aot+class=debug\")\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCache\/VerifierFailOver.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+\n+JNIEXPORT jclass JNICALL\n+Java_JNIDefineClassApp_nativeDefineClass(JNIEnv* env, jclass clazz \/*unused*\/,\n+                                         jstring className, jobject classLoader, jbyteArray bytecode) {\n+    const char* classNameChar = (*env)->GetStringUTFChars(env, className, NULL);\n+    jbyte* arrayContent = (*env)->GetByteArrayElements(env, bytecode, NULL);\n+    jsize bytecodeLength = (*env)->GetArrayLength(env, bytecode);\n+    jclass returnValue = (*env)->DefineClass(env, classNameChar, classLoader, arrayContent, bytecodeLength);\n+    (*env)->ReleaseByteArrayElements(env, bytecode, arrayContent, JNI_ABORT);\n+    (*env)->ReleaseStringUTFChars(env, className, classNameChar);\n+    return returnValue;\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCache\/libJNIDefineClassApp.c","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -121,1 +121,1 @@\n-                \"-Xlog:cds,aot+load,cds+class=debug,aot+class=debug\",\n+                \"-Xlog:cds,aot,aot+load,cds+class=debug,aot+class=debug\",\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/BulkLoaderTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+ *             InterfaceWithEnum EnumWithClinit\n@@ -104,0 +105,5 @@\n+\n+            \/\/ For MethodHandleTestApp.testLambdaWithEnums()\n+            if (runMode == RunMode.ASSEMBLY) {\n+                out.shouldNotContain(\"EnumWithClinit.<clinit>\");\n+            }\n@@ -209,0 +215,2 @@\n+        testLambdaWithEnums();\n+\n@@ -278,0 +286,23 @@\n+\n+\n+    static boolean InterfaceWithEnum_inited = false;\n+\n+    \/\/ Enum types used in lambdas shouldn't be initialized during the assembly phase.\n+    static void testLambdaWithEnums() {\n+        if (InterfaceWithEnum_inited) {\n+            throw new RuntimeException(\"InterfaceWithEnum should not be inited\");\n+        }\n+\n+        InterfaceWithEnum iwe = (x) -> {\n+            System.out.println(\"Hello from testLambdaWithEnums\");\n+        };\n+\n+        System.out.println(iwe);\n+        if (InterfaceWithEnum_inited) {\n+            throw new RuntimeException(\"InterfaceWithEnum should not be inited\");\n+        }\n+        iwe.func(EnumWithClinit.Dummy);\n+        if (!InterfaceWithEnum_inited) {\n+            throw new RuntimeException(\"InterfaceWithEnum should be inited\");\n+        }\n+    }\n@@ -335,0 +366,12 @@\n+interface InterfaceWithEnum {\n+    void func(EnumWithClinit e);\n+}\n+\n+enum EnumWithClinit {\n+    Dummy;\n+    static {\n+        MethodHandleTestApp.InterfaceWithEnum_inited = true;\n+        System.out.println(\"EnumWithClinit.<clinit>\");\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/MethodHandleTest.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+ * @requires test.thread.factory == null\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetThreadListStackTraces\/OneGetThreadListStackTraces.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/AllocateWithoutOomTest\/AllocateWithoutOomTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,0 +121,7 @@\n+void JNICALL\n+cbVMDeath(jvmtiEnv* jvmti, JNIEnv* jni) {\n+    if (!NSK_JVMTI_VERIFY(jvmti->DestroyRawMonitor(syncLock))) {\n+        nsk_jvmti_setFailStatus();\n+    }\n+}\n+\n@@ -141,0 +148,1 @@\n+    eventCallbacks.VMDeath = &cbVMDeath;\n@@ -259,3 +267,0 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->DestroyRawMonitor(syncLock))) {\n-        nsk_jvmti_setFailStatus();\n-    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/events\/EM04\/em04t001\/em04t001.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/compact\/Compact_InternedStrings_Strings\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/compact\/Compact_NonbranchyTree\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/compact\/Compact_NonbranchyTree_ArrayOf\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/compact\/Compact_NonbranchyTree_TwoFields\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/compact\/Compact_Strings\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/compact\/Compact_Strings_InternedStrings\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/compact\/Compact_Strings_TwoFields\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/compact\/Humongous_NonbranchyTree\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/gc\/compact\/Humongous_Strings\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -258,1 +258,0 @@\n-sun\/java2d\/X11SurfaceData\/SharedMemoryPixmapsTest\/SharedMemoryPixmapsTest.sh 7184899,8221451 linux-all,macosx-aarch64\n@@ -273,0 +272,1 @@\n+java\/awt\/Dialog\/ModalExcludedTest.java 7125054 macosx-all\n@@ -532,1 +532,0 @@\n-java\/lang\/ProcessBuilder\/Basic.java#id0                         8368192 macosx-all\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8153029\n+ * @bug 8153029 8360463\n@@ -41,0 +41,1 @@\n+import javax.crypto.NoSuchPaddingException;\n@@ -69,4 +70,2 @@\n-        checkTransformation(\"ChaCha20\", true);\n-        checkTransformation(\"ChaCha20\/None\/NoPadding\", true);\n-        checkTransformation(\"ChaCha20-Poly1305\", true);\n-        checkTransformation(\"ChaCha20-Poly1305\/None\/NoPadding\", true);\n+        Class NSAE = NoSuchAlgorithmException.class;\n+        Class NSPE = NoSuchPaddingException.class;\n@@ -74,4 +73,8 @@\n-        checkTransformation(\"ChaCha20\/ECB\/NoPadding\", false);\n-        checkTransformation(\"ChaCha20\/None\/PKCS5Padding\", false);\n-        checkTransformation(\"ChaCha20-Poly1305\/ECB\/NoPadding\", false);\n-        checkTransformation(\"ChaCha20-Poly1305\/None\/PKCS5Padding\", false);\n+        checkTransformation(\"ChaCha20\", null);\n+        checkTransformation(\"ChaCha20\/None\/NoPadding\", null);\n+        checkTransformation(\"ChaCha20-Poly1305\", null);\n+        checkTransformation(\"ChaCha20-Poly1305\/None\/NoPadding\", null);\n+        checkTransformation(\"ChaCha20\/ECB\/NoPadding\", NSAE);\n+        checkTransformation(\"ChaCha20\/None\/PKCS5Padding\", NSPE);\n+        checkTransformation(\"ChaCha20-Poly1305\/ECB\/NoPadding\", NSAE);\n+        checkTransformation(\"ChaCha20-Poly1305\/None\/PKCS5Padding\", NSPE);\n@@ -80,2 +83,2 @@\n-    private static void checkTransformation(String transformation,\n-            boolean expected) throws Exception {\n+    private static void checkTransformation(String transformation, Class exCls)\n+            throws Exception {\n@@ -83,4 +86,5 @@\n-            Cipher.getInstance(transformation);\n-            if (!expected) {\n-                throw new RuntimeException(\n-                        \"Unexpected transformation: \" + transformation);\n+            Cipher.getInstance(transformation,\n+                    System.getProperty(\"test.provider.name\", \"SunJCE\"));\n+            if (exCls != null) {\n+                throw new RuntimeException(\"Expected Exception not thrown: \" +\n+                        exCls);\n@@ -88,1 +92,1 @@\n-                System.out.println(\"Expected transformation: \" + transformation);\n+                System.out.println(transformation + \": pass\");\n@@ -90,3 +94,3 @@\n-        } catch (NoSuchAlgorithmException e) {\n-            if (!expected) {\n-                System.out.println(\"Unexpected transformation: \" + transformation);\n+        } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {\n+            if (e.getClass() != exCls) {\n+                throw new RuntimeException(\"Unexpected Exception\", e);\n@@ -94,1 +98,2 @@\n-                throw new RuntimeException(\"Unexpected fail: \" + transformation, e);\n+                System.out.println(transformation + \": got expected \" +\n+                        exCls.getName());\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/ChaCha20\/unittest\/ChaCha20CipherUnitTest.java","additions":26,"deletions":21,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8284161 8287008 8309406 8356870\n+ * @bug 8284161 8287008 8309406 8356870 8365057\n@@ -428,1 +428,3 @@\n-            assertTrue(contains(lines, \"- parking to wait for <java.util.concurrent.locks.ReentrantLock\"));\n+            String line = find(lines, \"- parking to wait for <java.util.concurrent.locks.ReentrantLock\");\n+            assertNotNull(line, \"parking to wait line not found\");\n+            assertTrue(line.endsWith(\" owner #\" + Thread.currentThread().threadId()));\n@@ -443,0 +445,6 @@\n+\n+            \/\/ the owner of the parkBlocker should be the current thread\n+            long ownerTid = ti.parkBlockerOwner().orElse(-1L);\n+            assertNotEquals(-1L, ownerTid, \"parkBlockerOwner not found\");\n+            assertEquals(Thread.currentThread().threadId(), ownerTid);\n+\n@@ -687,0 +695,10 @@\n+    \/**\n+     * Finds the line of a plain text thread dump containing the given text.\n+     *\/\n+    private String find(List<String> lines, String text) {\n+        return lines.stream().map(String::trim)\n+                .filter(l -> l.contains(text))\n+                .findAny()\n+                .orElse(null);\n+    }\n+\n","filename":"test\/jdk\/com\/sun\/management\/HotSpotDiagnosticMXBean\/DumpThreads.java","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n- * @run driver HeadlessMalfunctionTest\n+ * @run driver\/timeout=240 HeadlessMalfunctionTest\n","filename":"test\/jdk\/java\/awt\/Headless\/HeadlessMalfunctionTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @key headful\n@@ -28,3 +29,2 @@\n- * @library \/java\/awt\/regtesthelpers\n- * @build PassFailJFrame\n- * @run main\/manual MouseDraggedOriginatedByScrollBarTest\n+ * @requires os.family == \"linux\"\n+ * @run main MouseDraggedOriginatedByScrollBarTest\n@@ -33,0 +33,1 @@\n+import java.awt.EventQueue;\n@@ -36,1 +37,3 @@\n-import java.awt.event.MouseMotionAdapter;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.event.InputEvent;\n@@ -39,0 +42,1 @@\n+import java.awt.event.MouseMotionAdapter;\n@@ -41,5 +45,5 @@\n-\n-    private static final String INSTRUCTIONS = \"\"\"\n-            1) Click and drag the scrollbar of the list.\n-            2) Keep dragging till the mouse pointer goes out the scrollbar.\n-            3) The test failed if you see messages about events. The test passed if you don't.\"\"\";\n+    private static Frame frame;\n+    private static volatile Point loc;\n+    private static List list;\n+    private static final int XOFFSET = 10;\n+    private static final int YOFFSET = 20;\n@@ -48,9 +52,10 @@\n-        PassFailJFrame.builder()\n-                .title(\"MouseDraggedOriginatedByScrollBarTest Instructions\")\n-                .instructions(INSTRUCTIONS)\n-                .rows((int) INSTRUCTIONS.lines().count() + 2)\n-                .columns(35)\n-                .testUI(MouseDraggedOriginatedByScrollBarTest::createTestUI)\n-                .logArea()\n-                .build()\n-                .awaitAndCheck();\n+        try {\n+            EventQueue.invokeAndWait(() -> createUI());\n+            test();\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n@@ -59,3 +64,3 @@\n-    private static Frame createTestUI() {\n-        Frame frame = new Frame();\n-        List list = new List(4, false);\n+    private static void createUI() {\n+        frame = new Frame();\n+        list = new List(4, false);\n@@ -80,1 +85,2 @@\n-                    PassFailJFrame.log(me.toString());\n+                    System.out.println(me);\n+                    throw new RuntimeException(\"Mouse dragged event detected.\");\n@@ -87,1 +93,2 @@\n-                    PassFailJFrame.log(me.toString());\n+                    System.out.println(me);\n+                    throw new RuntimeException(\"Mouse pressed event detected.\");\n@@ -91,1 +98,2 @@\n-                    PassFailJFrame.log(me.toString());\n+                    System.out.println(me);\n+                    throw new RuntimeException(\"Mouse released event detected.\");\n@@ -95,1 +103,2 @@\n-                    PassFailJFrame.log(me.toString());\n+                    System.out.println(me);\n+                    throw new RuntimeException(\"Mouse clicked event detected.\");\n@@ -101,1 +110,22 @@\n-        return frame;\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    private static void test() throws Exception {\n+        Robot robot = new Robot();\n+        robot.waitForIdle();\n+        robot.delay(1000);\n+        robot.setAutoWaitForIdle(true);\n+\n+        EventQueue.invokeAndWait(() -> {\n+            Point p = list.getLocationOnScreen();\n+            p.translate(list.getWidth() - XOFFSET, YOFFSET);\n+            loc = p;\n+        });\n+        robot.mouseMove(loc.x, loc.y);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        for (int i = 0; i < 30; i++) {\n+            robot.mouseMove(loc.x, loc.y + i);\n+        }\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.delay(100);\n","filename":"test\/jdk\/java\/awt\/List\/MouseDraggedOriginatedByScrollBarTest.java","additions":57,"deletions":27,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 50510568367702\n+  @key headful printer\n+  @summary  PrintJob.getGraphics() should return null after PrintJob.end() is called.\n+  @run main GetGraphicsTest\n+*\/\n+\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.JobAttributes;\n+import java.awt.PageAttributes;\n+import java.awt.PrintJob;\n+import java.awt.Toolkit;\n+\n+public class GetGraphicsTest {\n+\n+    public static void main(String[] args) {\n+\n+        JobAttributes ja = new JobAttributes();\n+        ja.setDialog(JobAttributes.DialogType.NONE);\n+        PageAttributes pa = new PageAttributes();\n+        pa.setOrigin( PageAttributes.OriginType.PRINTABLE);\n+\n+        Toolkit tk = Toolkit.getDefaultToolkit();\n+        PrintJob pjob = tk.getPrintJob(new Frame(),\"Printing Test\", ja,pa);\n+        if (pjob != null) {\n+            pjob.end();\n+            Graphics pg = pjob.getGraphics();\n+            if (pg == null) {\n+                System.out.println(\"Graphics is null, TEST PASSES\");\n+            }\n+            else {\n+               throw new RuntimeException(\"Graphics is NOT null, TEST FAILED\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/PrintJob\/GetGraphicsTest.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -31,1 +31,1 @@\n- *      8352533\n+ *      8352533 8368192\n@@ -780,7 +780,5 @@\n-    private static String matchAndExtract(String str, String regex) {\n-        Matcher matcher = Pattern.compile(regex).matcher(str);\n-        if (matcher.find()) {\n-            return matcher.group();\n-        } else {\n-            return \"\";\n-        }\n+    \/\/ Return the string with the matching regex removed\n+    private static String matchAndRemove(String str, String regex) {\n+        return Pattern.compile(regex)\n+                .matcher(str)\n+                .replaceAll(\"\");\n@@ -790,4 +788,3 @@\n-     * Mac OS X (may) add the variable __CF_USER_TEXT_ENCODING to an empty\n-     * environment. The environment variable JAVA_MAIN_CLASS_<pid> may also\n-     * be set in Mac OS X.\n-     * Remove them both from the list of env variables\n+     * Mac OS X (may) add the variables: __CF_USER_TEXT_ENCODING, JAVA_MAIN_CLASS_<pid>,\n+     * and TMPDIR.\n+     * Remove them from the list of env variables\n@@ -797,2 +794,2 @@\n-        String cleanedVars = vars.replace(\"__CF_USER_TEXT_ENCODING=\"\n-                                            +cfUserTextEncoding+\",\",\"\");\n+        String cleanedVars = matchAndRemove(vars,\n+                \"__CF_USER_TEXT_ENCODING=\" + cfUserTextEncoding + \",\");\n@@ -800,4 +797,6 @@\n-        String javaMainClassStr\n-                = matchAndExtract(cleanedVars,\n-                                    \"JAVA_MAIN_CLASS_\\\\d+=Basic.JavaChild,\");\n-        return cleanedVars.replace(javaMainClassStr,\"\");\n+        cleanedVars = matchAndRemove(cleanedVars,\n+                \"JAVA_MAIN_CLASS_\\\\d+=Basic.JavaChild,\");\n+        \/\/ Check and remove TMPDIR\n+        cleanedVars = matchAndRemove(cleanedVars,\n+                \"TMPDIR=[^,]*,\");\n+        return cleanedVars;\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/Basic.java","additions":17,"deletions":18,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+maxOutputSize=6000000\n","filename":"test\/jdk\/java\/lang\/ProcessHandle\/TEST.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -1,112 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug 8289610 8249627 8205132 8320532\n- * @summary Test that Thread stops throws UOE\n- * @run junit ThreadStopTest\n- *\/\n-\n-import java.time.Duration;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.locks.LockSupport;\n-import org.junit.jupiter.api.Test;\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-class ThreadStopTest {\n-\n-    \/**\n-     * Test current thread calling Thread.stop on itself.\n-     *\/\n-    @Test\n-    void testCurrentThread() {\n-        var thread = Thread.currentThread();\n-        assertThrows(UnsupportedOperationException.class, thread::stop);\n-    }\n-\n-    \/**\n-     * Test Thread.stop on an unstarted thread.\n-     *\/\n-    @Test\n-    void testUnstartedThread() {\n-        Thread thread = new Thread(() -> { });\n-        assertThrows(UnsupportedOperationException.class, thread::stop);\n-        assertTrue(thread.getState() == Thread.State.NEW);\n-    }\n-\n-    \/**\n-     * Test Thread.stop on a thread spinning in a loop.\n-     *\/\n-    @Test\n-    void testRunnableThread() throws Exception {\n-        AtomicBoolean done = new AtomicBoolean();\n-        Thread thread = new Thread(() -> {\n-            while (!done.get()) {\n-                Thread.onSpinWait();\n-            }\n-        });\n-        thread.start();\n-        try {\n-            assertThrows(UnsupportedOperationException.class, thread::stop);\n-\n-            \/\/ thread should not terminate\n-            boolean terminated = thread.join(Duration.ofMillis(500));\n-            assertFalse(terminated);\n-        } finally {\n-            done.set(true);\n-            thread.join();\n-        }\n-    }\n-\n-    \/**\n-     * Test Thread.stop on a thread that is parked.\n-     *\/\n-    @Test\n-    void testWaitingThread() throws Exception {\n-        Thread thread = new Thread(LockSupport::park);\n-        thread.start();\n-        try {\n-            \/\/ wait for thread to park\n-            while ((thread.getState() != Thread.State.WAITING)) {\n-                Thread.sleep(10);\n-            }\n-            assertThrows(UnsupportedOperationException.class, thread::stop);\n-            assertTrue(thread.getState() == Thread.State.WAITING);\n-        } finally {\n-            LockSupport.unpark(thread);\n-            thread.join();\n-        }\n-    }\n-\n-    \/**\n-     * Test Thread.stop on a terminated thread.\n-     *\/\n-    @Test\n-    void testTerminatedThread() throws Exception {\n-        Thread thread = new Thread(() -> { });\n-        thread.start();\n-        thread.join();\n-        assertThrows(UnsupportedOperationException.class, thread::stop);\n-        assertTrue(thread.getState() == Thread.State.TERMINATED);\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/Thread\/ThreadStopTest.java","additions":0,"deletions":112,"binary":false,"changes":112,"status":"deleted"},{"patch":"@@ -255,29 +255,0 @@\n-    \/**\n-     * Test Thread::stop from current thread.\n-     *\/\n-    @Test\n-    void testStop1() throws Exception {\n-        VThreadRunner.run(() -> {\n-            Thread t = Thread.currentThread();\n-            assertThrows(UnsupportedOperationException.class, t::stop);\n-        });\n-    }\n-\n-    \/**\n-     * Test Thread::stop from another thread.\n-     *\/\n-    @Test\n-    void testStop2() throws Exception {\n-        var thread = Thread.ofVirtual().start(() -> {\n-            try {\n-                Thread.sleep(20*1000);\n-            } catch (InterruptedException e) { }\n-        });\n-        try {\n-            assertThrows(UnsupportedOperationException.class, thread::stop);\n-        } finally {\n-            thread.interrupt();\n-            thread.join();\n-        }\n-    }\n-\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ThreadAPI.java","additions":0,"deletions":29,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-import java.io.FileNotFoundException;\n@@ -63,1 +62,0 @@\n-import static org.testng.Assert.fail;\n@@ -159,20 +157,0 @@\n-    @Test\n-    public void testFileNotFound() throws Exception {\n-        out.printf(\"\\n\\n--- testFileNotFound(): starting\\n\");\n-        try (FileSystem fs = newZipFs()) {\n-            Path fileInZip = fs.getPath(\"non-existent.txt\");\n-            BodyPublishers.ofFile(fileInZip);\n-            fail();\n-        } catch (FileNotFoundException e) {\n-            out.println(\"Caught expected: \" + e);\n-        }\n-        var path = Path.of(\"fileNotFound.txt\");\n-        try {\n-            Files.deleteIfExists(path);\n-            BodyPublishers.ofFile(path);\n-            fail();\n-        } catch (FileNotFoundException e) {\n-            out.println(\"Caught expected: \" + e);\n-        }\n-    }\n-\n","filename":"test\/jdk\/java\/net\/httpclient\/FilePublisherTest.java","additions":0,"deletions":22,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import java.util.concurrent.Flow.Publisher;\n@@ -58,2 +57,0 @@\n-import static org.testng.Assert.assertThrows;\n-import static org.testng.Assert.assertTrue;\n@@ -126,14 +123,0 @@\n-    @Test\n-    public void testAPIExceptions() {\n-        assertThrows(NPE, () -> fromPublisher(null));\n-        assertThrows(NPE, () -> fromPublisher(null, 1));\n-        assertThrows(IAE, () -> fromPublisher(new BBPublisher(), 0));\n-        assertThrows(IAE, () -> fromPublisher(new BBPublisher(), -1));\n-        assertThrows(IAE, () -> fromPublisher(new BBPublisher(), Long.MIN_VALUE));\n-\n-        Publisher publisher = fromPublisher(new BBPublisher());\n-        assertThrows(NPE, () -> publisher.subscribe(null));\n-    }\n-\n-    \/\/  Flow.Publisher<ByteBuffer>\n-\n","filename":"test\/jdk\/java\/net\/httpclient\/FlowAdapterPublisherTest.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n- * @bug 8364733\n+ * @bug 8226303 8364733\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpRequestBodyPublishers\/OfByteArraysTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n- * @bug 8364733\n+ * @bug 8226303 8235459 8358688 8364733\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpRequestBodyPublishers\/OfFileTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -136,1 +136,1 @@\n-        HttpRequest request = reqBuilder\n+        HttpRequest request = reqBuilder.copy()\n","filename":"test\/jdk\/java\/net\/httpclient\/RedirectTimeoutTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,113 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.test.lib.util.FileUtils;\n-import org.testng.annotations.Test;\n-\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.net.http.HttpRequest.BodyPublisher;\n-import java.net.http.HttpRequest.BodyPublishers;\n-import java.nio.ByteBuffer;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.Flow;\n-\n-import static org.testng.Assert.assertEquals;\n-\n-\/*\n- * @test\n- * @summary Verifies that some of the standard BodyPublishers relay exception\n- *          rather than throw it\n- * @bug 8226303 8358688\n- * @library \/test\/lib\n- * @run testng\/othervm RelayingPublishers\n- *\/\n-public class RelayingPublishers {\n-\n-    @Test\n-    public void ofFile0() throws IOException {\n-        Path directory = Files.createDirectory(Path.of(\"d\"));\n-        \/\/ Even though the path exists, the publisher should not be able\n-        \/\/ to read from it, as that path denotes a directory, not a file\n-        BodyPublisher pub = BodyPublishers.ofFile(directory);\n-        CompletableSubscriber<ByteBuffer> s = new CompletableSubscriber<>();\n-        pub.subscribe(s);\n-        s.future().join();\n-        \/\/ Interestingly enough, it's FileNotFoundException if a file\n-        \/\/ is a directory\n-        assertEquals(s.future().join().getClass(), FileNotFoundException.class);\n-    }\n-\n-    @Test\n-    public void ofFile1() throws IOException {\n-        Path file = Files.createFile(Path.of(\"f\"));\n-        BodyPublisher pub = BodyPublishers.ofFile(file);\n-        FileUtils.deleteFileWithRetry(file);\n-        CompletableSubscriber<ByteBuffer> s = new CompletableSubscriber<>();\n-        pub.subscribe(s);\n-        assertEquals(s.future().join().getClass(), FileNotFoundException.class);\n-    }\n-\n-    @Test\n-    public void ofByteArrays() {\n-        List<byte[]> bytes = new ArrayList<>();\n-        bytes.add(null);\n-        BodyPublisher pub = BodyPublishers.ofByteArrays(bytes);\n-        CompletableSubscriber<ByteBuffer> s = new CompletableSubscriber<>();\n-        pub.subscribe(s);\n-        assertEquals(s.future().join().getClass(), NullPointerException.class);\n-    }\n-\n-    static class CompletableSubscriber<T> implements Flow.Subscriber<T> {\n-\n-        final CompletableFuture<Throwable> f = new CompletableFuture<>();\n-\n-        @Override\n-        public void onSubscribe(Flow.Subscription subscription) {\n-            subscription.request(1);\n-        }\n-\n-        @Override\n-        public void onNext(T item) {\n-            f.completeExceptionally(new RuntimeException(\"Unexpected onNext\"));\n-        }\n-\n-        @Override\n-        public void onError(Throwable throwable) {\n-            f.complete(throwable);\n-        }\n-\n-        @Override\n-        public void onComplete() {\n-            f.completeExceptionally(new RuntimeException(\"Unexpected onNext\"));\n-        }\n-\n-        CompletableFuture<Throwable> future() {\n-            return f.copy();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/RelayingPublishers.java","additions":0,"deletions":113,"binary":false,"changes":113,"status":"deleted"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.OpenOption;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Flow;\n+import java.net.http.HttpResponse.BodyHandler;\n+import java.net.http.HttpResponse.ResponseInfo;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.net.http.HttpResponse.BodySubscriber;\n+import java.net.http.HttpResponse.BodySubscribers;\n+import java.util.function.Function;\n+\n+import org.testng.annotations.Test;\n+\n+import static java.nio.file.StandardOpenOption.CREATE;\n+import static java.nio.file.StandardOpenOption.DELETE_ON_CLOSE;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.nio.file.StandardOpenOption.READ;\n+import static org.testng.Assert.assertThrows;\n+\n+\/*\n+ * @test\n+ * @summary Basic tests for API specified exceptions from Handler,\n+ *          and Subscriber convenience static factory methods.\n+ * @run testng SubscriberAPIExceptions\n+ *\/\n+\n+public class SubscriberAPIExceptions {\n+\n+    static final Class<NullPointerException> NPE = NullPointerException.class;\n+    static final Class<IllegalArgumentException> IAE = IllegalArgumentException.class;\n+    static final Class<IndexOutOfBoundsException> IOB = IndexOutOfBoundsException.class;\n+\n+    @Test\n+    public void handlerAPIExceptions() throws Exception {\n+        Path path = Paths.get(\".\").resolve(\"tt\");\n+        Path file = Files.createFile(Paths.get(\".\").resolve(\"aFile\"));\n+        Path doesNotExist = Paths.get(\".\").resolve(\"doneNotExist\");\n+        if (Files.exists(doesNotExist))\n+            throw new AssertionError(\"Unexpected \" + doesNotExist);\n+\n+        assertThrows(NPE, () -> BodyHandlers.ofByteArrayConsumer(null));\n+        assertThrows(NPE, () -> BodyHandlers.ofFile(null));\n+        assertThrows(NPE, () -> BodyHandlers.ofFile(null, CREATE, WRITE));\n+        assertThrows(NPE, () -> BodyHandlers.ofFile(path, (OpenOption[])null));\n+        assertThrows(NPE, () -> BodyHandlers.ofFile(path, new OpenOption[] {null}));\n+        assertThrows(NPE, () -> BodyHandlers.ofFile(path, new OpenOption[] {CREATE, null}));\n+        assertThrows(NPE, () -> BodyHandlers.ofFile(path, new OpenOption[] {null, CREATE}));\n+        assertThrows(NPE, () -> BodyHandlers.ofFile(null, (OpenOption[])null));\n+        assertThrows(NPE, () -> BodyHandlers.ofFileDownload(null, CREATE, WRITE));\n+        assertThrows(NPE, () -> BodyHandlers.ofFileDownload(path, (OpenOption[])null));\n+        assertThrows(NPE, () -> BodyHandlers.ofFileDownload(path, new OpenOption[] {null}));\n+        assertThrows(NPE, () -> BodyHandlers.ofFileDownload(path, new OpenOption[] {CREATE, null}));\n+        assertThrows(NPE, () -> BodyHandlers.ofFileDownload(path, new OpenOption[] {null, CREATE}));\n+        assertThrows(NPE, () -> BodyHandlers.ofFileDownload(null, (OpenOption[])null));\n+        assertThrows(IAE, () -> BodyHandlers.ofFileDownload(file, CREATE, WRITE));\n+        assertThrows(IAE, () -> BodyHandlers.ofFileDownload(doesNotExist, CREATE, WRITE));\n+        assertThrows(NPE, () -> BodyHandlers.ofString(null));\n+        assertThrows(NPE, () -> BodyHandlers.buffering(null, 1));\n+        assertThrows(IAE, () -> BodyHandlers.buffering(new NoOpHandler(), 0));\n+        assertThrows(IAE, () -> BodyHandlers.buffering(new NoOpHandler(), -1));\n+        assertThrows(IAE, () -> BodyHandlers.buffering(new NoOpHandler(), Integer.MIN_VALUE));\n+\n+        \/\/ implementation specific exceptions\n+        assertThrows(IAE, () -> BodyHandlers.ofFile(path, READ));\n+        assertThrows(IAE, () -> BodyHandlers.ofFile(path, DELETE_ON_CLOSE));\n+        assertThrows(IAE, () -> BodyHandlers.ofFile(path, READ, DELETE_ON_CLOSE));\n+        assertThrows(IAE, () -> BodyHandlers.ofFileDownload(path, DELETE_ON_CLOSE));\n+    }\n+\n+    @Test\n+    public void subscriberAPIExceptions() {\n+        Path path = Paths.get(\".\").resolve(\"tt\");\n+        assertThrows(NPE, () -> BodySubscribers.ofByteArrayConsumer(null));\n+        assertThrows(NPE, () -> BodySubscribers.ofFile(null));\n+        assertThrows(NPE, () -> BodySubscribers.ofFile(null, CREATE, WRITE));\n+        assertThrows(NPE, () -> BodySubscribers.ofFile(path, (OpenOption[])null));\n+        assertThrows(NPE, () -> BodySubscribers.ofFile(path, new OpenOption[] {null}));\n+        assertThrows(NPE, () -> BodySubscribers.ofFile(path, new OpenOption[] {CREATE, null}));\n+        assertThrows(NPE, () -> BodySubscribers.ofFile(path, new OpenOption[] {null, CREATE}));\n+        assertThrows(NPE, () -> BodySubscribers.ofFile(null, (OpenOption[])null));\n+        assertThrows(NPE, () -> BodySubscribers.ofString(null));\n+        assertThrows(NPE, () -> BodySubscribers.buffering(null, 1));\n+        assertThrows(IAE, () -> BodySubscribers.buffering(new NoOpSubscriber(), 0));\n+        assertThrows(IAE, () -> BodySubscribers.buffering(new NoOpSubscriber(), -1));\n+        assertThrows(IAE, () -> BodySubscribers.buffering(new NoOpSubscriber(), Integer.MIN_VALUE));\n+        assertThrows(NPE, () -> BodySubscribers.mapping(null, Function.identity()));\n+        assertThrows(NPE, () -> BodySubscribers.mapping(BodySubscribers.ofByteArray(), null));\n+        assertThrows(NPE, () -> BodySubscribers.mapping(null, null));\n+\n+        \/\/ implementation specific exceptions\n+        assertThrows(IAE, () -> BodySubscribers.ofFile(path, READ));\n+        assertThrows(IAE, () -> BodySubscribers.ofFile(path, DELETE_ON_CLOSE));\n+        assertThrows(IAE, () -> BodySubscribers.ofFile(path, READ, DELETE_ON_CLOSE));\n+    }\n+\n+    static class NoOpHandler implements BodyHandler<Void> {\n+        @Override public BodySubscriber<Void> apply(ResponseInfo rinfo) { return null; }\n+    }\n+\n+    static class NoOpSubscriber implements BodySubscriber<Void> {\n+        @Override public void onSubscribe(Flow.Subscription subscription) { }\n+        @Override public void onNext(List<ByteBuffer> item) { }\n+        @Override public void onError(Throwable throwable) { }\n+        @Override public void onComplete() { }\n+        @Override public CompletableFuture<Void> getBody() { return null; }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/SubscriberAPIExceptions.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -1,173 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.FileNotFoundException;\n-import java.nio.ByteBuffer;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.nio.file.OpenOption;\n-import java.util.List;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.Flow;\n-import java.net.http.HttpHeaders;\n-import java.net.http.HttpRequest.BodyPublishers;\n-import java.net.http.HttpResponse.BodyHandler;\n-import java.net.http.HttpResponse.ResponseInfo;\n-import java.net.http.HttpResponse.BodyHandlers;\n-import java.net.http.HttpResponse.BodySubscriber;\n-import java.net.http.HttpResponse.BodySubscribers;\n-import java.util.function.Function;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static java.nio.charset.StandardCharsets.UTF_8;\n-import static java.nio.file.StandardOpenOption.CREATE;\n-import static java.nio.file.StandardOpenOption.DELETE_ON_CLOSE;\n-import static java.nio.file.StandardOpenOption.WRITE;\n-import static java.nio.file.StandardOpenOption.READ;\n-import static org.testng.Assert.assertThrows;\n-\n-\/*\n- * @test\n- * @summary Basic tests for API specified exceptions from Publisher, Handler,\n- *          and Subscriber convenience static factory methods.\n- * @run testng SubscriberPublisherAPIExceptions\n- *\/\n-\n-public class SubscriberPublisherAPIExceptions {\n-\n-    static final Class<NullPointerException> NPE = NullPointerException.class;\n-    static final Class<IllegalArgumentException> IAE = IllegalArgumentException.class;\n-    static final Class<IndexOutOfBoundsException> IOB = IndexOutOfBoundsException.class;\n-\n-    @Test\n-    public void publisherAPIExceptions() {\n-        assertThrows(NPE, () -> BodyPublishers.ofByteArray(null));\n-        assertThrows(NPE, () -> BodyPublishers.ofByteArray(null, 0, 1));\n-        assertThrows(IOB, () -> BodyPublishers.ofByteArray(new byte[100],    0, 101));\n-        assertThrows(IOB, () -> BodyPublishers.ofByteArray(new byte[100],    1, 100));\n-        assertThrows(IOB, () -> BodyPublishers.ofByteArray(new byte[100],   -1,  10));\n-        assertThrows(IOB, () -> BodyPublishers.ofByteArray(new byte[100],   99,   2));\n-        assertThrows(IOB, () -> BodyPublishers.ofByteArray(new byte[1],   -100,   1));\n-        assertThrows(NPE, () -> BodyPublishers.ofByteArray(null));\n-        assertThrows(NPE, () -> BodyPublishers.ofFile(null));\n-        assertThrows(NPE, () -> BodyPublishers.ofInputStream(null));\n-        assertThrows(NPE, () -> BodyPublishers.ofString(null));\n-        assertThrows(NPE, () -> BodyPublishers.ofString(\"A\", null));\n-        assertThrows(NPE, () -> BodyPublishers.ofString(null, UTF_8));\n-        assertThrows(NPE, () -> BodyPublishers.ofString(null, null));\n-    }\n-\n-    @DataProvider(name = \"nonExistentFiles\")\n-    public Object[][] nonExistentFiles() {\n-        List<Path> paths = List.of(Paths.get(\"doesNotExist\"),\n-                                   Paths.get(\"tsixEtoNseod\"),\n-                                   Paths.get(\"doesNotExist2\"));\n-        paths.forEach(p -> {\n-            if (Files.exists(p))\n-                throw new AssertionError(\"Unexpected \" + p);\n-        });\n-\n-        return paths.stream().map(p -> new Object[] { p }).toArray(Object[][]::new);\n-    }\n-\n-    @Test(dataProvider = \"nonExistentFiles\", expectedExceptions = FileNotFoundException.class)\n-    public void fromFileCheck(Path path) throws Exception {\n-        BodyPublishers.ofFile(path);\n-    }\n-\n-    @Test\n-    public void handlerAPIExceptions() throws Exception {\n-        Path path = Paths.get(\".\").resolve(\"tt\");\n-        Path file = Files.createFile(Paths.get(\".\").resolve(\"aFile\"));\n-        Path doesNotExist = Paths.get(\".\").resolve(\"doneNotExist\");\n-        if (Files.exists(doesNotExist))\n-            throw new AssertionError(\"Unexpected \" + doesNotExist);\n-\n-        assertThrows(NPE, () -> BodyHandlers.ofByteArrayConsumer(null));\n-        assertThrows(NPE, () -> BodyHandlers.ofFile(null));\n-        assertThrows(NPE, () -> BodyHandlers.ofFile(null, CREATE, WRITE));\n-        assertThrows(NPE, () -> BodyHandlers.ofFile(path, (OpenOption[])null));\n-        assertThrows(NPE, () -> BodyHandlers.ofFile(path, new OpenOption[] {null}));\n-        assertThrows(NPE, () -> BodyHandlers.ofFile(path, new OpenOption[] {CREATE, null}));\n-        assertThrows(NPE, () -> BodyHandlers.ofFile(path, new OpenOption[] {null, CREATE}));\n-        assertThrows(NPE, () -> BodyHandlers.ofFile(null, (OpenOption[])null));\n-        assertThrows(NPE, () -> BodyHandlers.ofFileDownload(null, CREATE, WRITE));\n-        assertThrows(NPE, () -> BodyHandlers.ofFileDownload(path, (OpenOption[])null));\n-        assertThrows(NPE, () -> BodyHandlers.ofFileDownload(path, new OpenOption[] {null}));\n-        assertThrows(NPE, () -> BodyHandlers.ofFileDownload(path, new OpenOption[] {CREATE, null}));\n-        assertThrows(NPE, () -> BodyHandlers.ofFileDownload(path, new OpenOption[] {null, CREATE}));\n-        assertThrows(NPE, () -> BodyHandlers.ofFileDownload(null, (OpenOption[])null));\n-        assertThrows(IAE, () -> BodyHandlers.ofFileDownload(file, CREATE, WRITE));\n-        assertThrows(IAE, () -> BodyHandlers.ofFileDownload(doesNotExist, CREATE, WRITE));\n-        assertThrows(NPE, () -> BodyHandlers.ofString(null));\n-        assertThrows(NPE, () -> BodyHandlers.buffering(null, 1));\n-        assertThrows(IAE, () -> BodyHandlers.buffering(new NoOpHandler(), 0));\n-        assertThrows(IAE, () -> BodyHandlers.buffering(new NoOpHandler(), -1));\n-        assertThrows(IAE, () -> BodyHandlers.buffering(new NoOpHandler(), Integer.MIN_VALUE));\n-\n-        \/\/ implementation specific exceptions\n-        assertThrows(IAE, () -> BodyHandlers.ofFile(path, READ));\n-        assertThrows(IAE, () -> BodyHandlers.ofFile(path, DELETE_ON_CLOSE));\n-        assertThrows(IAE, () -> BodyHandlers.ofFile(path, READ, DELETE_ON_CLOSE));\n-        assertThrows(IAE, () -> BodyHandlers.ofFileDownload(path, DELETE_ON_CLOSE));\n-    }\n-\n-    @Test\n-    public void subscriberAPIExceptions() {\n-        Path path = Paths.get(\".\").resolve(\"tt\");\n-        assertThrows(NPE, () -> BodySubscribers.ofByteArrayConsumer(null));\n-        assertThrows(NPE, () -> BodySubscribers.ofFile(null));\n-        assertThrows(NPE, () -> BodySubscribers.ofFile(null, CREATE, WRITE));\n-        assertThrows(NPE, () -> BodySubscribers.ofFile(path, (OpenOption[])null));\n-        assertThrows(NPE, () -> BodySubscribers.ofFile(path, new OpenOption[] {null}));\n-        assertThrows(NPE, () -> BodySubscribers.ofFile(path, new OpenOption[] {CREATE, null}));\n-        assertThrows(NPE, () -> BodySubscribers.ofFile(path, new OpenOption[] {null, CREATE}));\n-        assertThrows(NPE, () -> BodySubscribers.ofFile(null, (OpenOption[])null));\n-        assertThrows(NPE, () -> BodySubscribers.ofString(null));\n-        assertThrows(NPE, () -> BodySubscribers.buffering(null, 1));\n-        assertThrows(IAE, () -> BodySubscribers.buffering(new NoOpSubscriber(), 0));\n-        assertThrows(IAE, () -> BodySubscribers.buffering(new NoOpSubscriber(), -1));\n-        assertThrows(IAE, () -> BodySubscribers.buffering(new NoOpSubscriber(), Integer.MIN_VALUE));\n-        assertThrows(NPE, () -> BodySubscribers.mapping(null, Function.identity()));\n-        assertThrows(NPE, () -> BodySubscribers.mapping(BodySubscribers.ofByteArray(), null));\n-        assertThrows(NPE, () -> BodySubscribers.mapping(null, null));\n-\n-        \/\/ implementation specific exceptions\n-        assertThrows(IAE, () -> BodySubscribers.ofFile(path, READ));\n-        assertThrows(IAE, () -> BodySubscribers.ofFile(path, DELETE_ON_CLOSE));\n-        assertThrows(IAE, () -> BodySubscribers.ofFile(path, READ, DELETE_ON_CLOSE));\n-    }\n-\n-    static class NoOpHandler implements BodyHandler<Void> {\n-        @Override public BodySubscriber<Void> apply(ResponseInfo rinfo) { return null; }\n-    }\n-\n-    static class NoOpSubscriber implements BodySubscriber<Void> {\n-        @Override public void onSubscribe(Flow.Subscription subscription) { }\n-        @Override public void onNext(List<ByteBuffer> item) { }\n-        @Override public void onError(Throwable throwable) { }\n-        @Override public void onComplete() { }\n-        @Override public CompletableFuture<Void> getBody() { return null; }\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/SubscriberPublisherAPIExceptions.java","additions":0,"deletions":173,"binary":false,"changes":173,"status":"deleted"},{"patch":"@@ -32,1 +32,1 @@\n- * @run testng\/othervm -Djdk.internal.httpclient.debug=true BadHeadersTest\n+ * @run junit\/othervm -Djdk.internal.httpclient.debug=true BadHeadersTest\n@@ -41,4 +41,4 @@\n-import org.testng.annotations.AfterTest;\n-import org.testng.annotations.BeforeTest;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -64,0 +64,1 @@\n+\n@@ -72,2 +73,3 @@\n-import static org.testng.Assert.assertTrue;\n-import static org.testng.Assert.fail;\n+import static org.junit.jupiter.api.Assertions.assertInstanceOf;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n@@ -88,5 +90,5 @@\n-    SSLContext sslContext;\n-    Http2TestServer http2TestServer;   \/\/ HTTP\/2 ( h2c )\n-    Http2TestServer https2TestServer;  \/\/ HTTP\/2 ( h2  )\n-    String http2URI;\n-    String https2URI;\n+    private static SSLContext sslContext;\n+    private static Http2TestServer http2TestServer;   \/\/ HTTP\/2 ( h2c )\n+    private static Http2TestServer https2TestServer;  \/\/ HTTP\/2 ( h2  )\n+    private static String http2URI;\n+    private static String https2URI;\n@@ -130,2 +132,1 @@\n-    @DataProvider(name = \"variants\")\n-    public Object[][] variants() {\n+    static Object[][] variants() {\n@@ -145,2 +146,2 @@\n-\n-    @Test(dataProvider = \"variants\")\n+    @ParameterizedTest\n+    @MethodSource(\"variants\")\n@@ -175,1 +176,2 @@\n-    @Test(dataProvider = \"variants\")\n+    @ParameterizedTest\n+    @MethodSource(\"variants\")\n@@ -214,2 +216,1 @@\n-            assertTrue(throwable instanceof ProtocolException,\n-                    \"Expected ProtocolException, got \" + throwable);\n+            assertInstanceOf(ProtocolException.class, throwable, \"Expected ProtocolException, got \" + throwable);\n@@ -242,2 +243,2 @@\n-    @BeforeTest\n-    public void setup() throws Exception {\n+    @BeforeAll\n+    static void setup() throws Exception {\n@@ -267,2 +268,2 @@\n-    @AfterTest\n-    public void teardown() throws Exception {\n+    @AfterAll\n+    static void teardown() throws Exception {\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/BadHeadersTest.java","additions":24,"deletions":23,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run testng\/othervm\n+ * @run junit\/othervm\n@@ -36,3 +36,3 @@\n-import org.testng.annotations.AfterTest;\n-import org.testng.annotations.BeforeTest;\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n@@ -62,1 +62,1 @@\n-import static org.testng.Assert.*;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -76,2 +76,2 @@\n-    HttpServerAdapters.HttpTestServer server;\n-    URI uri;\n+    static HttpServerAdapters.HttpTestServer server;\n+    static URI uri;\n@@ -79,2 +79,2 @@\n-    @BeforeTest\n-    public void setup() throws Exception {\n+    @BeforeAll\n+    static void setup() throws Exception {\n@@ -90,2 +90,2 @@\n-    @AfterTest\n-    public void teardown() {\n+    @AfterAll\n+    static void teardown() {\n@@ -99,1 +99,1 @@\n-    public void test() throws Exception {\n+    void test() {\n@@ -126,2 +126,1 @@\n-            assertTrue(throwable instanceof ProtocolException,\n-                    \"Expected ProtocolException, got \" + throwable);\n+            assertInstanceOf(ProtocolException.class, throwable, \"Expected ProtocolException, got \" + throwable);\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/BadPushPromiseTest.java","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * @run testng\/othervm -Djdk.httpclient.HttpClient.log=ssl,requests,responses,errors BasicTest\n+ * @run junit\/othervm -Djdk.httpclient.HttpClient.log=ssl,requests,responses,errors BasicTest\n@@ -56,1 +56,1 @@\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -63,1 +63,0 @@\n-@Test\n@@ -130,1 +129,1 @@\n-    public static void test() throws Exception {\n+    void test() throws Exception {\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/BasicTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run testng\/othervm  -Djdk.internal.httpclient.debug=true\n+ * @run junit\/othervm   -Djdk.internal.httpclient.debug=true\n@@ -46,1 +46,0 @@\n-import java.net.http.HttpResponse.BodyHandler;\n@@ -48,3 +47,0 @@\n-import java.net.http.HttpResponse.BodySubscriber;\n-import java.net.http.HttpResponse.ResponseInfo;\n-import java.nio.ByteBuffer;\n@@ -52,1 +48,0 @@\n-import java.util.ArrayList;\n@@ -54,2 +49,0 @@\n-import java.util.List;\n-import java.util.Map.Entry;\n@@ -57,1 +50,0 @@\n-import java.util.concurrent.CompletionStage;\n@@ -60,1 +52,0 @@\n-import java.util.concurrent.Flow.Subscription;\n@@ -62,1 +53,0 @@\n-import java.util.function.BiFunction;\n@@ -75,4 +65,0 @@\n-import jdk.internal.net.http.frame.ContinuationFrame;\n-import jdk.internal.net.http.frame.HeaderFrame;\n-import jdk.internal.net.http.frame.HeadersFrame;\n-import jdk.internal.net.http.frame.Http2Frame;\n@@ -82,4 +68,4 @@\n-import org.testng.annotations.AfterTest;\n-import org.testng.annotations.BeforeTest;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -87,6 +73,1 @@\n-import static java.util.List.of;\n-import static java.util.Map.entry;\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertNotEquals;\n-import static org.testng.Assert.assertTrue;\n-import static org.testng.Assert.fail;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -96,6 +77,6 @@\n-    SSLContext sslContext;\n-    HttpTestServer http2TestServer;   \/\/ HTTP\/2 ( h2c )\n-    HttpTestServer https2TestServer;  \/\/ HTTP\/2 ( h2  )\n-    String http2URI;\n-    String https2URI;\n-    final AtomicInteger reqid = new AtomicInteger();\n+    private static SSLContext sslContext;\n+    private static HttpTestServer http2TestServer;   \/\/ HTTP\/2 ( h2c )\n+    private static HttpTestServer https2TestServer;  \/\/ HTTP\/2 ( h2  )\n+    private static String http2URI;\n+    private static String https2URI;\n+    private final AtomicInteger reqid = new AtomicInteger();\n@@ -103,3 +84,1 @@\n-\n-    @DataProvider(name = \"variants\")\n-    public Object[][] variants() {\n+    static Object[][] variants() {\n@@ -112,1 +91,2 @@\n-    @Test(dataProvider = \"variants\")\n+    @ParameterizedTest\n+    @MethodSource(\"variants\")\n@@ -151,1 +131,1 @@\n-                            assertEquals(ckey, label, \"Unexpected key for \" + query);\n+                            assertEquals(label, ckey, \"Unexpected key for \" + query);\n@@ -177,1 +157,1 @@\n-                            assertEquals(ckey, label, \"Unexpected key for \" + query);\n+                            assertEquals(label, ckey, \"Unexpected key for \" + query);\n@@ -230,1 +210,1 @@\n-                assertNotEquals(ckey, label);\n+                assertNotEquals(label, ckey);\n@@ -261,2 +241,2 @@\n-    @BeforeTest\n-    public void setup() throws Exception {\n+    @BeforeAll\n+    static void setup() throws Exception {\n@@ -267,4 +247,4 @@\n-        var http2TestServer = new Http2TestServer(\"localhost\", false, 0);\n-        http2TestServer.addHandler(new Http2TestHandler(), \"\/http2\/\");\n-        this.http2TestServer = HttpTestServer.of(http2TestServer);\n-        http2URI = \"http:\/\/\" + this.http2TestServer.serverAuthority() + \"\/http2\/x\";\n+        var http2TestServerLocal = new Http2TestServer(\"localhost\", false, 0);\n+        http2TestServerLocal.addHandler(new Http2TestHandler(), \"\/http2\/\");\n+        http2TestServer = HttpTestServer.of(http2TestServerLocal);\n+        http2URI = \"http:\/\/\" + http2TestServer.serverAuthority() + \"\/http2\/x\";\n@@ -272,4 +252,4 @@\n-        var https2TestServer = new Http2TestServer(\"localhost\", true, sslContext);\n-        https2TestServer.addHandler(new Http2TestHandler(), \"\/https2\/\");\n-        this.https2TestServer = HttpTestServer.of(https2TestServer);\n-        https2URI = \"https:\/\/\" + this.https2TestServer.serverAuthority() + \"\/https2\/x\";\n+        var https2TestServerLocal = new Http2TestServer(\"localhost\", true, sslContext);\n+        https2TestServerLocal.addHandler(new Http2TestHandler(), \"\/https2\/\");\n+        https2TestServer = HttpTestServer.of(https2TestServerLocal);\n+        https2URI = \"https:\/\/\" + https2TestServer.serverAuthority() + \"\/https2\/x\";\n@@ -279,2 +259,2 @@\n-        http2TestServer.setExchangeSupplier(FCHttp2TestExchange::new);\n-        https2TestServer.setExchangeSupplier(FCHttp2TestExchange::new);\n+        http2TestServerLocal.setExchangeSupplier(FCHttp2TestExchange::new);\n+        https2TestServerLocal.setExchangeSupplier(FCHttp2TestExchange::new);\n@@ -282,2 +262,2 @@\n-        this.http2TestServer.start();\n-        this.https2TestServer.start();\n+        http2TestServer.start();\n+        https2TestServer.start();\n@@ -286,2 +266,2 @@\n-    @AfterTest\n-    public void teardown() throws Exception {\n+    @AfterAll\n+    static void teardown() throws Exception {\n@@ -367,1 +347,0 @@\n-\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/ConnectionFlowControlTest.java","additions":35,"deletions":56,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run testng\/othervm ContinuationFrameTest\n+ * @run junit\/othervm ContinuationFrameTest\n@@ -63,4 +63,4 @@\n-import org.testng.annotations.AfterTest;\n-import org.testng.annotations.BeforeTest;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -69,2 +69,1 @@\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -74,8 +73,8 @@\n-    SSLContext sslContext;\n-    Http2TestServer http2TestServer;   \/\/ HTTP\/2 ( h2c )\n-    Http2TestServer https2TestServer;  \/\/ HTTP\/2 ( h2  )\n-    String http2URI;\n-    String https2URI;\n-    String noBodyhttp2URI;\n-    String noBodyhttps2URI;\n-    final ReferenceTracker TRACKER = ReferenceTracker.INSTANCE;\n+    private static SSLContext sslContext;\n+    private static Http2TestServer http2TestServer;   \/\/ HTTP\/2 ( h2c )\n+    private static Http2TestServer https2TestServer;  \/\/ HTTP\/2 ( h2  )\n+    private static String http2URI;\n+    private static String https2URI;\n+    private static String noBodyhttp2URI;\n+    private static String noBodyhttps2URI;\n+    private final static ReferenceTracker TRACKER = ReferenceTracker.INSTANCE;\n@@ -136,2 +135,1 @@\n-    @DataProvider(name = \"variants\")\n-    public Object[][] variants() {\n+    static Object[][] variants() {\n@@ -158,1 +156,1 @@\n-    HttpClient sharedClient;\n+    static HttpClient sharedClient;\n@@ -174,1 +172,2 @@\n-    @Test(dataProvider = \"variants\")\n+    @ParameterizedTest\n+    @MethodSource(\"variants\")\n@@ -200,3 +199,2 @@\n-                assertTrue(resp.statusCode() == 204,\n-                    \"Expected 204, got:\" + resp.statusCode());\n-                assertEquals(resp.version(), HTTP_2);\n+                assertEquals(204, resp.statusCode(), \"Expected 204, got:\" + resp.statusCode());\n+                assertEquals(HTTP_2, resp.version());\n@@ -207,4 +205,3 @@\n-            assertTrue(resp.statusCode() == 200,\n-                       \"Expected 200, got:\" + resp.statusCode());\n-            assertEquals(resp.body(), \"Hello there!\");\n-            assertEquals(resp.version(), HTTP_2);\n+            assertEquals(200, resp.statusCode(), \"Expected 200, got:\" + resp.statusCode());\n+            assertEquals(\"Hello there!\", resp.body());\n+            assertEquals(HTTP_2, resp.version());\n@@ -214,2 +211,2 @@\n-    @BeforeTest\n-    public void setup() throws Exception {\n+    @BeforeAll\n+    static void setup() throws Exception {\n@@ -243,2 +240,2 @@\n-    @AfterTest\n-    public void teardown() throws Exception {\n+    @AfterAll\n+    static void teardown() throws Exception {\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/ContinuationFrameTest.java","additions":28,"deletions":31,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import jdk.test.lib.Utils;\n@@ -805,1 +806,1 @@\n-                    .get(10, TimeUnit.SECONDS);\n+                    .get(Utils.adjustTimeout(10), TimeUnit.SECONDS);\n@@ -946,1 +947,1 @@\n-                    .get(10, TimeUnit.SECONDS);\n+                    .get(Utils.adjustTimeout(10), TimeUnit.SECONDS);\n@@ -969,1 +970,1 @@\n-                    .get(10, TimeUnit.SECONDS);\n+                    .get(Utils.adjustTimeout(20), TimeUnit.SECONDS);\n@@ -975,1 +976,1 @@\n-            TerminationCause terminationCause = errorCF.get(10, TimeUnit.SECONDS);\n+            TerminationCause terminationCause = errorCF.get(Utils.adjustTimeout(10), TimeUnit.SECONDS);\n@@ -992,1 +993,1 @@\n-                    .get(10, TimeUnit.SECONDS);\n+                    .get(Utils.adjustTimeout(10), TimeUnit.SECONDS);\n@@ -998,1 +999,1 @@\n-            TerminationCause terminationCause = errorCF.get(10, TimeUnit.SECONDS);\n+            TerminationCause terminationCause = errorCF.get(Utils.adjustTimeout(10), TimeUnit.SECONDS);\n@@ -1022,1 +1023,1 @@\n-            ).get(10, TimeUnit.SECONDS);\n+            ).get(Utils.adjustTimeout(10), TimeUnit.SECONDS);\n@@ -1028,1 +1029,1 @@\n-            TerminationCause terminationCause = errorCF.get(10, TimeUnit.SECONDS);\n+            TerminationCause terminationCause = errorCF.get(Utils.adjustTimeout(10), TimeUnit.SECONDS);\n","filename":"test\/jdk\/java\/net\/httpclient\/http3\/H3ErrorHandlingTest.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.test.lib.Utils;\n@@ -371,1 +372,1 @@\n-                    .get(10, TimeUnit.SECONDS);\n+                    .get(Utils.adjustTimeout(10), TimeUnit.SECONDS);\n","filename":"test\/jdk\/java\/net\/httpclient\/http3\/H3MalformedResponseTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,2 +39,2 @@\n-    private UDPThread udpThread;\n-    private ServerSocketThread serverSocketThread;\n+    private final UDPThread udpThread;\n+    private final ServerSocketThread serverSocketThread;\n@@ -42,1 +42,1 @@\n-    StressNativeSignal() {\n+    StressNativeSignal() throws IOException {\n@@ -44,3 +44,1 @@\n-        if (serverSocketThread != null) {\n-            serverSocketThread.start();\n-        }\n+        serverSocketThread.start();\n@@ -49,3 +47,1 @@\n-        if (udpThread != null) {\n-            udpThread.start();\n-        }\n+        udpThread.start();\n@@ -54,9 +50,2 @@\n-    private UDPThread initUDPThread() {\n-        UDPThread aUDPThread = null;\n-        try {\n-            aUDPThread = new UDPThread();\n-        } catch (Exception z) {\n-            System.err.println(\"failed to create and start a UDPThread\");\n-            z.printStackTrace();\n-        }\n-        return aUDPThread;\n+    private UDPThread initUDPThread() throws IOException {\n+        return new UDPThread();\n@@ -65,10 +54,2 @@\n-    private ServerSocketThread initServerSocketThread() {\n-        ServerSocketThread aServerSocketThread = null;\n-        try {\n-            aServerSocketThread = new ServerSocketThread();\n-\n-        } catch (Exception z) {\n-            System.err.println(\"failed to create and start a ServerSocketThread\");\n-            z.printStackTrace();\n-        }\n-        return aServerSocketThread;\n+    private ServerSocketThread initServerSocketThread() throws IOException {\n+        return new ServerSocketThread();\n@@ -83,2 +64,2 @@\n-    public void shutdown() {\n-        if ((udpThread != null) && udpThread.isAlive()) {\n+    public void shutdown() throws InterruptedException, IOException {\n+        if (udpThread != null && udpThread.isAlive()) {\n@@ -86,5 +67,2 @@\n-            try {\n-                udpThread.join();\n-            } catch (Exception z) {\n-                z.printStackTrace(System.err);\n-            }\n+            udpThread.join();\n+\n@@ -95,1 +73,1 @@\n-        if ((serverSocketThread != null) && (serverSocketThread.isAlive())) {\n+        if (serverSocketThread != null && serverSocketThread.isAlive()) {\n@@ -97,5 +75,1 @@\n-            try {\n-                serverSocketThread.join();\n-            } catch (Exception z) {\n-                z.printStackTrace(System.err);\n-            }\n+            serverSocketThread.join();\n@@ -107,2 +81,2 @@\n-    public void waitForTestThreadsToStart() {\n-        if ((udpThread != null) && udpThread.isAlive()) {\n+    public void waitForTestThreadsToStart() throws InterruptedException {\n+        if (udpThread != null && udpThread.isAlive()) {\n@@ -111,1 +85,1 @@\n-        if ((serverSocketThread != null) && (serverSocketThread.isAlive())) {\n+        if (serverSocketThread != null && serverSocketThread.isAlive()) {\n@@ -118,1 +92,1 @@\n-        private ServerSocket socket;\n+        private final ServerSocket socket;\n@@ -121,2 +95,2 @@\n-        public ServerSocketThread () throws Exception {\n-            socket = new ServerSocket(1122);\n+        public ServerSocketThread() throws IOException {\n+            socket = new ServerSocket(0);\n@@ -132,1 +106,1 @@\n-            } catch (Exception z) {\n+            } catch (IOException z) {\n@@ -144,1 +118,1 @@\n-            } catch (Exception z) {\n+            } catch (IOException z) {\n@@ -153,1 +127,1 @@\n-            } catch (Exception z) {\n+            } catch (InterruptedException z) {\n@@ -161,1 +135,1 @@\n-        private DatagramChannel channel;\n+        private final DatagramChannel channel;\n@@ -165,2 +139,1 @@\n-        public UDPThread () throws Exception {\n-\n+        public UDPThread() throws IOException {\n@@ -169,1 +142,1 @@\n-            channel.bind(new InetSocketAddress(19870));\n+            channel.bind(new InetSocketAddress(0));\n@@ -194,1 +167,1 @@\n-            } catch (Exception z) {\n+            } catch (IOException z) {\n@@ -204,1 +177,1 @@\n-            } catch (Exception z) {\n+            } catch (InterruptedException z) {\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/StressNativeSignal.java","additions":30,"deletions":57,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @build IsSameFile jdk.test.lib.util.FileUtils\n@@ -45,2 +44,0 @@\n-import jdk.test.lib.util.FileUtils;\n-\n@@ -67,1 +64,0 @@\n-    private List<Path> allFiles;\n@@ -73,1 +69,2 @@\n-        home = Files.createTempDirectory(\"TestIsSameFile\");\n+        Path cwd = Path.of(System.getProperty(\"user.dir\"));\n+        home = Files.createTempDirectory(cwd, IsSameFile.class.getSimpleName());\n@@ -75,5 +72,4 @@\n-        allFiles = new ArrayList();\n-        allFiles.add(a = home.resolve(\"a\"));\n-        allFiles.add(aa = home.resolve(\"a\"));\n-        allFiles.add(b = home.resolve(\"b\"));\n-        allFiles.add(c = home.resolve(\"c\"));\n+        a = home.resolve(\"a\");\n+        aa = home.resolve(\"a\");\n+        b = home.resolve(\"b\");\n+        c = home.resolve(\"c\");\n@@ -89,1 +85,1 @@\n-        for (Path p : allFiles)\n+        for (Path p : Files.list(home).toList())\n@@ -152,1 +148,2 @@\n-    private Stream<Arguments> obj2ZipSource() throws IOException {\n+    @Test\n+    public void obj2Zip() throws IOException {\n@@ -156,11 +153,3 @@\n-        FileSystem zipfs = FileSystems.newFileSystem(b);\n-        List<Arguments> list = new ArrayList<Arguments>();\n-        list.add(Arguments.of(false, a, zipfs.getPath(b.toString())));\n-        return list.stream();\n-    }\n-\n-    @ParameterizedTest\n-    @MethodSource(\"obj2ZipSource\")\n-    public void obj2Zip(boolean expect, Path x, Path y)\n-        throws IOException {\n-        test(expect, x, y);\n+        try (FileSystem zipfs = FileSystems.newFileSystem(b)) {\n+            test(false, a, zipfs.getPath(b.toString()));\n+        }\n@@ -260,1 +249,0 @@\n-        allFiles.add(target);\n@@ -262,1 +250,1 @@\n-        Path L2 = Path.of(\"link2\");\n+        Path L2 = home.resolve(\"link2\");\n@@ -264,1 +252,0 @@\n-        allFiles.add(L2);\n@@ -266,1 +253,1 @@\n-        Path L1 = Path.of(\"link1\");\n+        Path L1 = home.resolve(\"link1\");\n@@ -268,1 +255,0 @@\n-        allFiles.add(L1);\n@@ -270,1 +256,1 @@\n-        Path L4 = Path.of(\"link4\");\n+        Path L4 = home.resolve(\"link4\");\n@@ -272,1 +258,0 @@\n-        allFiles.add(L4);\n@@ -274,1 +259,1 @@\n-        Path L3 = Path.of(\"link3\");\n+        Path L3 = home.resolve(\"link3\");\n@@ -276,1 +261,0 @@\n-        allFiles.add(L3);\n@@ -299,1 +283,0 @@\n-        allFiles.add(target);\n@@ -301,1 +284,1 @@\n-        Path L2 = Path.of(\"link2\");\n+        Path L2 = home.resolve(\"link2\");\n@@ -303,1 +286,0 @@\n-        allFiles.add(L2);\n@@ -305,1 +287,1 @@\n-        Path L1 = Path.of(\"link1\");\n+        Path L1 = home.resolve(\"link1\");\n@@ -307,1 +289,0 @@\n-        allFiles.add(L1);\n@@ -311,1 +292,0 @@\n-        allFiles.add(cible);\n@@ -313,1 +293,1 @@\n-        Path L4 = Path.of(\"link4\");\n+        Path L4 = home.resolve(\"link4\");\n@@ -315,1 +295,0 @@\n-        allFiles.add(L4);\n@@ -317,1 +296,1 @@\n-        Path L3 = Path.of(\"link3\");\n+        Path L3 = home.resolve(\"link3\");\n@@ -319,1 +298,0 @@\n-        allFiles.add(L3);\n@@ -341,1 +319,1 @@\n-        Path doesNotExist = Path.of(\"doesNotExist\");\n+        Path doesNotExist = home.resolve(\"doesNotExist\");\n@@ -343,1 +321,1 @@\n-        Path L2 = Path.of(\"link2\");\n+        Path L2 = home.resolve(\"link2\");\n@@ -345,1 +323,0 @@\n-        allFiles.add(L2);\n@@ -347,1 +324,1 @@\n-        Path L1 = Path.of(\"link1\");\n+        Path L1 = home.resolve(\"link1\");\n@@ -349,1 +326,0 @@\n-        allFiles.add(L1);\n@@ -351,1 +327,1 @@\n-        Path L4 = Path.of(\"link4\");\n+        Path L4 = home.resolve(\"link4\");\n@@ -353,1 +329,0 @@\n-        allFiles.add(L4);\n@@ -355,1 +330,1 @@\n-        Path L3 = Path.of(\"link3\");\n+        Path L3 = home.resolve(\"link3\");\n@@ -357,1 +332,0 @@\n-        allFiles.add(L3);\n@@ -381,1 +355,0 @@\n-        allFiles.add(target);\n@@ -383,2 +356,1 @@\n-        links[3] = Files.createSymbolicLink(Path.of(\"link4\"), target);\n-        allFiles.add(links[3]);\n+        links[3] = Files.createSymbolicLink(home.resolve(\"link4\"), target);\n@@ -386,2 +358,1 @@\n-            links[i-1] = Files.createSymbolicLink(Path.of(\"link\"+i), links[i]);\n-            allFiles.add(links[i-1]);\n+            links[i-1] = Files.createSymbolicLink(home.resolve(\"link\"+i), links[i]);\n@@ -417,1 +388,0 @@\n-        allFiles.add(target);\n@@ -419,2 +389,1 @@\n-        links[3] = Files.createSymbolicLink(Path.of(\"link4\"), target);\n-        allFiles.add(links[3]);\n+        links[3] = Files.createSymbolicLink(home.resolve(\"link4\"), target);\n@@ -422,1 +391,0 @@\n-        allFiles.remove(target);\n@@ -424,2 +392,1 @@\n-            links[i-1] = Files.createSymbolicLink(Path.of(\"link\"+i), links[i]);\n-            allFiles.add(links[i-1]);\n+            links[i-1] = Files.createSymbolicLink(home.resolve(\"link\"+i), links[i]);\n@@ -457,3 +424,3 @@\n-        allFiles.add(Files.createSymbolicLink(link1, link2));\n-        allFiles.add(Files.createSymbolicLink(link2, link3));\n-        allFiles.add(Files.createSymbolicLink(link3, link1));\n+        Files.createSymbolicLink(link1, link2);\n+        Files.createSymbolicLink(link2, link3);\n+        Files.createSymbolicLink(link3, link1);\n","filename":"test\/jdk\/java\/nio\/file\/Files\/IsSameFile.java","additions":32,"deletions":65,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.security.SecureRandom;\n+import java.util.Arrays;\n+\n+\/*\n+ * @test\n+ * @bug 8364657\n+ * @summary verify the behavior of SecureRandom instance returned by\n+ *          SecureRandom.getInstanceStrong()\n+ * @run main TestStrong\n+ *\/\n+public class TestStrong {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        final SecureRandom random = SecureRandom.getInstanceStrong();\n+        System.out.println(\"going to generate random seed using \" + random);\n+        final byte[] seed = random.generateSeed(0);\n+        System.out.println(\"random seed generated\");\n+        System.out.println(\"seed: \" + Arrays.toString(seed));\n+    }\n+}\n","filename":"test\/jdk\/java\/security\/SecureRandom\/TestStrong.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng\/othervm RuleBasedCollatorTest\n+ * @run junit\/othervm RuleBasedCollatorTest\n@@ -32,0 +32,6 @@\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n@@ -34,1 +40,0 @@\n-import java.text.RuleBasedCollator;\n@@ -37,0 +42,1 @@\n+import java.text.RuleBasedCollator;\n@@ -40,5 +46,6 @@\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import org.testng.SkipException;\n-import static org.testng.Assert.*;\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assumptions.assumeFalse;\n@@ -46,0 +53,1 @@\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n@@ -48,2 +56,2 @@\n-    static RuleBasedCollator USC;\n-    static String US_RULES;\n+    private static RuleBasedCollator USC;\n+    private static String US_RULES;\n@@ -51,2 +59,2 @@\n-    @BeforeClass\n-    public void setup() {\n+    @BeforeAll\n+    void setup() {\n@@ -54,3 +62,1 @@\n-        if (!(c instanceof RuleBasedCollator)) {\n-            throw new SkipException(\"skip tests.\");\n-        }\n+        assumeFalse(!(c instanceof RuleBasedCollator), \"skip tests.\");\n@@ -62,1 +68,0 @@\n-    @DataProvider(name = \"rulesData\")\n@@ -94,2 +99,3 @@\n-    @Test(dataProvider = \"rulesData\")\n-    public void testRules(String rules, String[] testData, String[] expected)\n+    @ParameterizedTest\n+    @MethodSource(\"rulesData\")\n+    void testRules(String rules, String[] testData, String[] expected)\n@@ -98,1 +104,1 @@\n-        assertEquals(testData, expected);\n+        assertArrayEquals(expected, testData);\n@@ -102,1 +108,0 @@\n-    @DataProvider(name = \"FrenchSecondarySort\")\n@@ -114,2 +119,3 @@\n-    @Test(dataProvider = \"FrenchSecondarySort\")\n-    public void testFrenchSecondarySort(String sData, String tData,\n+    @ParameterizedTest\n+    @MethodSource(\"FrenchSecondarySort\")\n+    void testFrenchSecondarySort(String sData, String tData,\n@@ -124,1 +130,0 @@\n-    @DataProvider(name = \"ThaiLaoVowelConsonantSwapping\")\n@@ -132,2 +137,3 @@\n-    @Test(dataProvider = \"ThaiLaoVowelConsonantSwapping\")\n-    public void testThaiLaoVowelConsonantSwapping(String sData, String tData,\n+    @ParameterizedTest\n+    @MethodSource(\"ThaiLaoVowelConsonantSwapping\")\n+    void testThaiLaoVowelConsonantSwapping(String sData, String tData,\n@@ -143,1 +149,1 @@\n-    public void testIgnorableCharacter() throws ParseException {\n+    void testIgnorableCharacter() throws ParseException {\n@@ -149,1 +155,1 @@\n-        assertEquals(primary, 0);\n+        assertEquals(0, primary);\n@@ -152,1 +158,0 @@\n-    @DataProvider(name = \"Normalization\")\n@@ -165,2 +170,3 @@\n-    @Test(dataProvider = \"Normalization\")\n-    public void testNormalization(String sData, String tData, int decomp,\n+    @ParameterizedTest\n+    @MethodSource(\"Normalization\")\n+    void testNormalization(String sData, String tData, int decomp,\n@@ -170,1 +176,1 @@\n-        assertEquals(rc.compare(sData, tData), result);\n+        assertEquals(result, rc.compare(sData, tData));\n@@ -174,1 +180,1 @@\n-    public void testEquality() throws ParseException {\n+    void testEquality() throws ParseException {\n@@ -189,2 +195,2 @@\n-        assertEquals(array1, array2);\n-        assertEquals(array1, expected);\n+        assertArrayEquals(array2, array1);\n+        assertArrayEquals(expected, array1);\n@@ -194,1 +200,1 @@\n-    public void testBasicParsingOrder() throws ParseException {\n+    void testBasicParsingOrder() throws ParseException {\n@@ -206,1 +212,1 @@\n-        assertEquals(k1.compareTo(k2) == 0, false);\n+        assertNotEquals(0, k1.compareTo(k2));\n@@ -209,1 +215,1 @@\n-        assertEquals(k2.compareTo(k3) == 0, true);\n+        assertEquals(0, k2.compareTo(k3));\n@@ -212,1 +218,0 @@\n-    @DataProvider(name = \"ParseData\")\n@@ -223,4 +228,4 @@\n-    @Test(dataProvider = \"ParseData\",\n-            expectedExceptions = ParseException.class)\n-    public void testParseException(String rule) throws ParseException{\n-        new RuleBasedCollator(rule);\n+    @ParameterizedTest\n+    @MethodSource(\"ParseData\")\n+    void testParseException(String rule) {\n+        assertThrows(ParseException.class, () -> new RuleBasedCollator(rule));\n@@ -229,3 +234,3 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testNullParseException() throws ParseException{\n-        new RuleBasedCollator(null);\n+    @Test\n+    void testNullParseException() {\n+        assertThrows(NullPointerException.class, () -> new RuleBasedCollator(null));\n","filename":"test\/jdk\/java\/text\/Collator\/RuleBasedCollatorTest.java","additions":50,"deletions":45,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,2 @@\n-import static org.testng.Assert.assertEquals;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -34,1 +35,1 @@\n-        assertEquals(result, expected, \"Incorrect formatting of the number '\"\n+        assertEquals(expected, result, \"Incorrect formatting of the number '\"\n@@ -49,1 +50,1 @@\n-            assertEquals(number.getClass(), returnType,\n+            assertEquals(returnType, number.getClass(),\n@@ -53,1 +54,1 @@\n-        assertEquals(number, expected, \"Incorrect parsing of the string '\"\n+        assertEquals(expected, number, \"Incorrect parsing of the string '\"\n","filename":"test\/jdk\/java\/text\/Format\/CompactNumberFormat\/CompactFormatAndParseHelper.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,0 +23,1 @@\n+\n@@ -27,1 +28,1 @@\n- * @run testng\/othervm TestCNFRounding\n+ * @run junit\/othervm TestCNFRounding\n@@ -30,0 +31,5 @@\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n@@ -34,3 +40,0 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n@@ -38,0 +41,4 @@\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n@@ -49,1 +56,0 @@\n-    @DataProvider(name = \"roundingData\")\n@@ -73,1 +79,0 @@\n-    @DataProvider(name = \"roundingFract\")\n@@ -97,1 +102,0 @@\n-    @DataProvider(name = \"rounding2Fract\")\n@@ -121,5 +125,7 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testNullMode() {\n-        NumberFormat fmt = NumberFormat\n-                .getCompactNumberInstance(Locale.US, NumberFormat.Style.SHORT);\n-        fmt.setRoundingMode(null);\n+    @Test\n+    void testNullMode() {\n+        assertThrows(NullPointerException.class, () -> {\n+            NumberFormat fmt = NumberFormat\n+                    .getCompactNumberInstance(Locale.US, NumberFormat.Style.SHORT);\n+            fmt.setRoundingMode(null);\n+        });\n@@ -129,1 +135,1 @@\n-    public void testDefaultRoundingMode() {\n+    void testDefaultRoundingMode() {\n@@ -132,1 +138,1 @@\n-        assertEquals(fmt.getRoundingMode(), RoundingMode.HALF_EVEN,\n+        assertEquals(RoundingMode.HALF_EVEN, fmt.getRoundingMode(),\n@@ -136,2 +142,3 @@\n-    @Test(dataProvider = \"roundingData\")\n-    public void testRounding(Object number, String[] expected) {\n+    @ParameterizedTest\n+    @MethodSource(\"roundingData\")\n+    void testRounding(Object number, String[] expected) {\n@@ -143,2 +150,3 @@\n-    @Test(dataProvider = \"roundingFract\")\n-    public void testRoundingFract(Object number, String[] expected) {\n+    @ParameterizedTest\n+    @MethodSource(\"roundingFract\")\n+    void testRoundingFract(Object number, String[] expected) {\n@@ -150,2 +158,3 @@\n-    @Test(dataProvider = \"rounding2Fract\")\n-    public void testRounding2Fract(Object number, String[] expected) {\n+    @ParameterizedTest\n+    @MethodSource(\"rounding2Fract\")\n+    void testRounding2Fract(Object number, String[] expected) {\n@@ -164,1 +173,1 @@\n-        assertEquals(fmt.getRoundingMode(), rounding,\n+        assertEquals(rounding, fmt.getRoundingMode(),\n@@ -169,1 +178,1 @@\n-        assertEquals(result, expected, \"Incorrect formatting of number \"\n+        assertEquals(expected, result, \"Incorrect formatting of number \"\n","filename":"test\/jdk\/java\/text\/Format\/CompactNumberFormat\/TestCNFRounding.java","additions":32,"deletions":23,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8368328\n+ * @summary Tests if CompactNumberFormat.clone() creates an independent object\n+ * @run junit\/othervm --add-opens java.base\/java.text=ALL-UNNAMED TestClone\n+ *\/\n+\n+import java.lang.invoke.MethodHandles;\n+import java.text.CompactNumberFormat;\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.text.NumberFormat;\n+import java.util.Locale;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotSame;\n+\n+public class TestClone {\n+    \/\/ Concurrently parse numbers using cloned instances as originally\n+    \/\/ reported in the bug. This test could produce false negative results,\n+    \/\/ depending on the testing environment\n+    @Test\n+    void randomAccessTest() {\n+        var original =\n+            NumberFormat.getCompactNumberInstance(Locale.US, NumberFormat.Style.SHORT);\n+        var threads = IntStream.range(0, 10)\n+            .mapToObj(num -> new Thread(() -> {\n+                var clone = (NumberFormat) original.clone();\n+                for (int i = 0; i < 1000; i++) {\n+                    assertDoesNotThrow(() ->\n+                        assertEquals(num, clone.parse(String.valueOf(num)).intValue()));\n+                }\n+            })).toList();\n+        threads.forEach(Thread::start);\n+        threads.forEach(t -> {\n+            try {\n+                t.join();\n+            } catch (InterruptedException ie) {\n+                throw new RuntimeException(ie);\n+            }\n+        });\n+    }\n+\n+    private static Stream<Arguments> referenceFields() throws ClassNotFoundException {\n+        return Stream.of(\n+            Arguments.of(\"compactPatterns\", String[].class),\n+            Arguments.of(\"symbols\", DecimalFormatSymbols.class),\n+            Arguments.of(\"decimalFormat\", DecimalFormat.class),\n+            Arguments.of(\"defaultDecimalFormat\", DecimalFormat.class),\n+            Arguments.of(\"digitList\", Class.forName(\"java.text.DigitList\"))\n+        );\n+    }\n+    \/\/ Explicitly checks if the cloned object has its own references for\n+    \/\/ \"compactPatterns\", \"symbols\", \"decimalFormat\", \"defaultDecimalFormat\",\n+    \/\/ and \"digitList\"\n+    @ParameterizedTest\n+    @MethodSource(\"referenceFields\")\n+    void whiteBoxTest(String fieldName, Class<?> type) throws Throwable {\n+        var original = NumberFormat.getCompactNumberInstance(Locale.US, NumberFormat.Style.SHORT);\n+        var clone = original.clone();\n+        var lookup = MethodHandles.privateLookupIn(CompactNumberFormat.class, MethodHandles.lookup());\n+\n+        assertNotSame(lookup.findGetter(CompactNumberFormat.class, fieldName, type).invoke(original),\n+            lookup.findGetter(CompactNumberFormat.class, fieldName, type).invoke(clone));\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/CompactNumberFormat\/TestClone.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -28,1 +28,1 @@\n- * @run testng\/othervm TestCompactNumber\n+ * @run junit\/othervm TestCompactNumber\n@@ -30,0 +30,6 @@\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n@@ -39,3 +45,0 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n@@ -43,0 +46,4 @@\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n@@ -109,1 +116,0 @@\n-    @DataProvider(name = \"format\")\n@@ -381,1 +387,0 @@\n-    @DataProvider(name = \"parse\")\n@@ -494,1 +499,0 @@\n-    @DataProvider(name = \"exceptionParse\")\n@@ -511,1 +515,0 @@\n-    @DataProvider(name = \"invalidParse\")\n@@ -545,1 +548,0 @@\n-    @DataProvider(name = \"fieldPosition\")\n@@ -591,1 +593,0 @@\n-    @DataProvider(name = \"varParsePosition\")\n@@ -619,1 +620,1 @@\n-    public void testInstanceCreation() {\n+    void testInstanceCreation() {\n@@ -626,3 +627,5 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testFormatWithNullParam() {\n-        FORMAT_EN_US_SHORT.format(null);\n+    @Test\n+    void testFormatWithNullParam() {\n+        assertThrows(IllegalArgumentException.class, () -> {\n+            FORMAT_EN_US_SHORT.format(null);\n+        });\n@@ -631,2 +634,3 @@\n-    @Test(dataProvider = \"format\")\n-    public void testFormat(NumberFormat cnf, Object number,\n+    @ParameterizedTest\n+    @MethodSource(\"compactFormatData\")\n+    void testFormat(NumberFormat cnf, Object number,\n@@ -637,2 +641,3 @@\n-    @Test(dataProvider = \"parse\")\n-    public void testParse(NumberFormat cnf, String parseString,\n+    @ParameterizedTest\n+    @MethodSource(\"compactParseData\")\n+    void testParse(NumberFormat cnf, String parseString,\n@@ -643,2 +648,3 @@\n-    @Test(dataProvider = \"parse\")\n-    public void testParsePosition(NumberFormat cnf, String parseString,\n+    @ParameterizedTest\n+    @MethodSource(\"compactParseData\")\n+    void testParsePosition(NumberFormat cnf, String parseString,\n@@ -648,2 +654,2 @@\n-        assertEquals(pos.getIndex(), parseString.length());\n-        assertEquals(pos.getErrorIndex(), -1);\n+        assertEquals(parseString.length(), pos.getIndex());\n+        assertEquals(-1, pos.getErrorIndex());\n@@ -652,2 +658,3 @@\n-    @Test(dataProvider = \"varParsePosition\")\n-    public void testVarParsePosition(NumberFormat cnf, String parseString,\n+    @ParameterizedTest\n+    @MethodSource(\"varParsePosition\")\n+    void testVarParsePosition(NumberFormat cnf, String parseString,\n@@ -658,2 +665,2 @@\n-        assertEquals(pos.getIndex(), indexPosition);\n-        assertEquals(pos.getErrorIndex(), errPosition);\n+        assertEquals(indexPosition, pos.getIndex());\n+        assertEquals(errPosition, pos.getErrorIndex());\n@@ -662,4 +669,5 @@\n-    @Test(dataProvider = \"exceptionParse\", expectedExceptions = ParseException.class)\n-    public void throwsParseException(NumberFormat cnf, String parseString,\n-            Number expected) throws ParseException {\n-        CompactFormatAndParseHelper.testParse(cnf, parseString, expected, null, null);\n+    @ParameterizedTest\n+    @MethodSource(\"exceptionParseData\")\n+    void throwsParseException(NumberFormat cnf, String parseString,\n+            Number expected) {\n+        assertThrows(ParseException.class, () -> CompactFormatAndParseHelper.testParse(cnf, parseString, expected, null, null));\n@@ -668,2 +676,3 @@\n-    @Test(dataProvider = \"invalidParse\")\n-    public void testInvalidParse(NumberFormat cnf, String parseString,\n+    @ParameterizedTest\n+    @MethodSource(\"invalidParseData\")\n+    void testInvalidParse(NumberFormat cnf, String parseString,\n@@ -674,2 +683,3 @@\n-    @Test(dataProvider = \"fieldPosition\")\n-    public void testFormatWithFieldPosition(NumberFormat nf,\n+    @ParameterizedTest\n+    @MethodSource(\"formatFieldPositionData\")\n+    void testFormatWithFieldPosition(NumberFormat nf,\n@@ -681,1 +691,1 @@\n-        assertEquals(result.toString(), expected, \"Incorrect formatting of the number '\"\n+        assertEquals(expected, result.toString(), \"Incorrect formatting of the number '\"\n@@ -683,1 +693,1 @@\n-        assertEquals(pos.getBeginIndex(), posStartExpected, \"Incorrect start position\"\n+        assertEquals(posStartExpected, pos.getBeginIndex(), \"Incorrect start position\"\n@@ -685,1 +695,1 @@\n-        assertEquals(pos.getEndIndex(), posEndExpected, \"Incorrect end position\"\n+        assertEquals(posEndExpected, pos.getEndIndex(), \"Incorrect end position\"\n","filename":"test\/jdk\/java\/text\/Format\/CompactNumberFormat\/TestCompactNumber.java","additions":47,"deletions":37,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng\/othervm TestCompactPatternsValidity\n+ * @run junit\/othervm TestCompactPatternsValidity\n@@ -31,0 +31,4 @@\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n@@ -38,2 +42,0 @@\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n@@ -41,0 +43,3 @@\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n@@ -77,1 +82,0 @@\n-    @DataProvider(name = \"invalidPatterns\")\n@@ -93,1 +97,0 @@\n-    @DataProvider(name = \"validPatternsFormat\")\n@@ -119,1 +122,0 @@\n-    @DataProvider(name = \"validPatternsParse\")\n@@ -139,1 +141,0 @@\n-    @DataProvider(name = \"validPatternsFormatWithPluralRules\")\n@@ -147,1 +148,0 @@\n-    @DataProvider(name = \"validPatternsParseWithPluralRules\")\n@@ -155,5 +155,7 @@\n-    @Test(dataProvider = \"invalidPatterns\",\n-            expectedExceptions = IllegalArgumentException.class)\n-    public void testInvalidCompactPatterns(String[] compactPatterns) {\n-        new CompactNumberFormat(\"#,##0.0#\", DecimalFormatSymbols\n-                .getInstance(Locale.US), compactPatterns);\n+    @ParameterizedTest\n+    @MethodSource(\"invalidCompactPatterns\")\n+    void testInvalidCompactPatterns(String[] compactPatterns) {\n+        assertThrows(IllegalArgumentException.class, () -> {\n+            new CompactNumberFormat(\"#,##0.0#\", DecimalFormatSymbols\n+                    .getInstance(Locale.US), compactPatterns);\n+        });\n@@ -162,2 +164,3 @@\n-    @Test(dataProvider = \"validPatternsFormat\")\n-    public void testValidPatternsFormat(String[] compactPatterns,\n+    @ParameterizedTest\n+    @MethodSource(\"validPatternsFormat\")\n+    void testValidPatternsFormat(String[] compactPatterns,\n@@ -173,2 +176,3 @@\n-    @Test(dataProvider = \"validPatternsParse\")\n-    public void testValidPatternsParse(String[] compactPatterns,\n+    @ParameterizedTest\n+    @MethodSource(\"validPatternsParse\")\n+    void testValidPatternsParse(String[] compactPatterns,\n@@ -184,2 +188,3 @@\n-    @Test(dataProvider = \"validPatternsFormatWithPluralRules\")\n-    public void testValidPatternsFormatWithPluralRules(String[] compactPatterns, String pluralRules,\n+    @ParameterizedTest\n+    @MethodSource(\"validPatternsFormatWithPluralRules\")\n+    void testValidPatternsFormatWithPluralRules(String[] compactPatterns, String pluralRules,\n@@ -195,2 +200,3 @@\n-    @Test(dataProvider = \"validPatternsParseWithPluralRules\")\n-    public void testValidPatternsParsewithPluralRules(String[] compactPatterns, String pluralRules,\n+    @ParameterizedTest\n+    @MethodSource(\"validPatternsParseWithPluralRules\")\n+    void testValidPatternsParsewithPluralRules(String[] compactPatterns, String pluralRules,\n","filename":"test\/jdk\/java\/text\/Format\/CompactNumberFormat\/TestCompactPatternsValidity.java","additions":28,"deletions":22,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,0 +23,1 @@\n+\n@@ -28,2 +29,1 @@\n- * @run testng\/othervm TestEquality\n- *\n+ * @run junit\/othervm TestEquality\n@@ -32,0 +32,2 @@\n+import org.junit.jupiter.api.Test;\n+\n@@ -36,1 +38,0 @@\n-import org.testng.annotations.Test;\n@@ -41,1 +42,1 @@\n-    public void testEquality() {\n+    void testEquality() {\n@@ -163,1 +164,1 @@\n-    public void testHashCode() {\n+    void testHashCode() {\n@@ -178,1 +179,1 @@\n-    public void testEqualsAndHashCode() {\n+    void testEqualsAndHashCode() {\n","filename":"test\/jdk\/java\/text\/Format\/CompactNumberFormat\/TestEquality.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,0 +23,1 @@\n+\n@@ -29,1 +30,1 @@\n- * @run testng\/othervm TestFormatToCharacterIterator\n+ * @run junit\/othervm TestFormatToCharacterIterator\n@@ -31,0 +32,5 @@\n+\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n@@ -39,3 +45,0 @@\n-import static org.testng.Assert.assertEquals;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n@@ -43,0 +46,3 @@\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n@@ -57,1 +63,0 @@\n-    @DataProvider(name = \"fieldPositions\")\n@@ -152,2 +157,3 @@\n-    @Test(dataProvider = \"fieldPositions\")\n-    public void testFormatToCharacterIterator(NumberFormat fmt, Object number,\n+    @ParameterizedTest\n+    @MethodSource(\"compactFieldPositionData\")\n+    void testFormatToCharacterIterator(NumberFormat fmt, Object number,\n@@ -156,1 +162,1 @@\n-        assertEquals(getText(iterator), expected, \"Incorrect formatting of the number '\"\n+        assertEquals(expected, getText(iterator), \"Incorrect formatting of the number '\"\n@@ -161,1 +167,1 @@\n-        assertEquals(iterator.getBeginIndex(), 0, \"Incorrect start index: \"\n+        assertEquals(0, iterator.getBeginIndex(), \"Incorrect start index: \"\n@@ -163,1 +169,1 @@\n-        assertEquals(iterator.getEndIndex(), expected.length(), \"Incorrect end index: \"\n+        assertEquals(expected.length(), iterator.getEndIndex(), \"Incorrect end index: \"\n@@ -167,1 +173,1 @@\n-        assertEquals(iterator.getAllAttributeKeys(), Set.of(expectedFields),\n+        assertEquals(Set.of(expectedFields), iterator.getAllAttributeKeys(),\n@@ -176,1 +182,1 @@\n-            assertEquals(start, positions[currentPosition],\n+            assertEquals(positions[currentPosition], start,\n@@ -179,1 +185,1 @@\n-            assertEquals(end, positions[currentPosition + 1],\n+            assertEquals(positions[currentPosition + 1], end,\n","filename":"test\/jdk\/java\/text\/Format\/CompactNumberFormat\/TestFormatToCharacterIterator.java","additions":20,"deletions":14,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,0 +23,1 @@\n+\n@@ -30,1 +31,1 @@\n- * @run testng\/othervm TestMutatingInstance\n+ * @run junit\/othervm TestMutatingInstance\n@@ -32,0 +33,6 @@\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n@@ -39,3 +46,0 @@\n-import org.testng.annotations.BeforeTest;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n@@ -43,0 +47,1 @@\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n@@ -64,2 +69,2 @@\n-    @BeforeTest\n-    public void mutateInstances() {\n+    @BeforeAll\n+    void mutateInstances() {\n@@ -78,1 +83,0 @@\n-    @DataProvider(name = \"format\")\n@@ -98,1 +102,0 @@\n-    @DataProvider(name = \"parse\")\n@@ -109,2 +112,3 @@\n-    @Test(dataProvider = \"format\")\n-    public void formatCompactNumber(NumberFormat nf,\n+    @ParameterizedTest\n+    @MethodSource(\"compactFormatData\")\n+    void formatCompactNumber(NumberFormat nf,\n@@ -115,2 +119,3 @@\n-    @Test(dataProvider = \"parse\")\n-    public void parseCompactNumber(NumberFormat nf,\n+    @ParameterizedTest\n+    @MethodSource(\"compactParseData\")\n+    void parseCompactNumber(NumberFormat nf,\n","filename":"test\/jdk\/java\/text\/Format\/CompactNumberFormat\/TestMutatingInstance.java","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,0 +23,1 @@\n+\n@@ -28,1 +29,1 @@\n- * @run testng\/othervm TestParseBigDecimal\n+ * @run junit\/othervm TestParseBigDecimal\n@@ -31,3 +32,4 @@\n-import org.testng.annotations.BeforeTest;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -41,0 +43,1 @@\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n@@ -67,2 +70,2 @@\n-    @BeforeTest\n-    public void mutateInstances() {\n+    @BeforeAll\n+    void mutateInstances() {\n@@ -79,1 +82,0 @@\n-    @DataProvider(name = \"parse\")\n@@ -168,2 +170,3 @@\n-    @Test(dataProvider = \"parse\")\n-    public void testParse(NumberFormat cnf, String parseString,\n+    @ParameterizedTest\n+    @MethodSource(\"compactParseData\")\n+    void testParse(NumberFormat cnf, String parseString,\n","filename":"test\/jdk\/java\/text\/Format\/CompactNumberFormat\/TestParseBigDecimal.java","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,0 +23,1 @@\n+\n@@ -27,1 +28,1 @@\n- * @run testng\/othervm TestPlurals\n+ * @run junit\/othervm TestPlurals\n@@ -30,0 +31,5 @@\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n@@ -34,3 +40,2 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n@@ -38,0 +43,1 @@\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n@@ -48,1 +54,0 @@\n-    @DataProvider\n@@ -81,1 +86,0 @@\n-    @DataProvider\n@@ -95,4 +99,6 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testNullPluralRules() {\n-        String[] pattern = {\"\"};\n-        new CompactNumberFormat(\"#\", DFS, PATTERN, null);\n+    @Test\n+    void testNullPluralRules() {\n+        assertThrows(NullPointerException.class, () -> {\n+            String[] pattern = {\"\"};\n+            new CompactNumberFormat(\"#\", DFS, PATTERN, null);\n+        });\n@@ -101,2 +107,3 @@\n-    @Test(dataProvider = \"pluralRules\")\n-    public void testPluralRules(String rules, Number n, String expected) {\n+    @ParameterizedTest\n+    @MethodSource(\"pluralRules\")\n+    void testPluralRules(String rules, Number n, String expected) {\n@@ -104,1 +111,1 @@\n-        assertEquals(cnp.format(n), expected);\n+        assertEquals(expected, cnp.format(n));\n@@ -107,3 +114,5 @@\n-    @Test(dataProvider = \"invalidRules\", expectedExceptions = IllegalArgumentException.class)\n-    public void testInvalidRules(String rules) {\n-        new CompactNumberFormat(\"#\", DFS, PATTERN, rules);\n+    @ParameterizedTest\n+    @MethodSource(\"invalidRules\")\n+    void testInvalidRules(String rules) {\n+        assertThrows(IllegalArgumentException.class,\n+                () -> new CompactNumberFormat(\"#\", DFS, PATTERN, rules));\n@@ -112,5 +121,7 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testLimitExceedingRules() {\n-        String andCond = \" and n = 1\";\n-        String invalid = \"one: n = 1\" + andCond.repeat(2_048 \/ andCond.length());\n-        new CompactNumberFormat(\"#\", DFS, PATTERN, invalid);\n+    @Test\n+    void testLimitExceedingRules() {\n+        assertThrows(IllegalArgumentException.class, () -> {\n+            String andCond = \" and n = 1\";\n+            String invalid = \"one: n = 1\" + andCond.repeat(2_048 \/ andCond.length());\n+            new CompactNumberFormat(\"#\", DFS, PATTERN, invalid);\n+        });\n","filename":"test\/jdk\/java\/text\/Format\/CompactNumberFormat\/TestPlurals.java","additions":33,"deletions":22,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,0 +23,1 @@\n+\n@@ -28,1 +29,1 @@\n- * @run testng\/othervm TestSpecialValues\n+ * @run junit\/othervm TestSpecialValues\n@@ -30,0 +31,5 @@\n+\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n@@ -33,2 +39,0 @@\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n@@ -36,0 +40,1 @@\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n@@ -41,1 +46,0 @@\n-    @DataProvider(name = \"formatSpecialValues\")\n@@ -56,1 +60,0 @@\n-    @DataProvider(name = \"parseSpecialValues\")\n@@ -68,2 +71,3 @@\n-    @Test(dataProvider = \"formatSpecialValues\")\n-    public void testFormatSpecialValues(Object number, String expected) {\n+    @ParameterizedTest\n+    @MethodSource(\"formatSpecialValues\")\n+    void testFormatSpecialValues(Object number, String expected) {\n@@ -73,2 +77,3 @@\n-    @Test(dataProvider = \"parseSpecialValues\")\n-    public void testParseSpecialValues(String parseString, Number expected)\n+    @ParameterizedTest\n+    @MethodSource(\"parseSpecialValues\")\n+    void testParseSpecialValues(String parseString, Number expected)\n","filename":"test\/jdk\/java\/text\/Format\/CompactNumberFormat\/TestSpecialValues.java","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,0 +23,1 @@\n+\n@@ -29,1 +30,1 @@\n- * @run testng\/othervm TestUExtensionOverride\n+ * @run junit\/othervm TestUExtensionOverride\n@@ -31,0 +32,5 @@\n+\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n@@ -34,2 +40,0 @@\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n@@ -37,0 +41,1 @@\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n@@ -39,1 +44,0 @@\n-    @DataProvider(name = \"compactFormatData\")\n@@ -64,1 +68,0 @@\n-    @DataProvider(name = \"compactParseData\")\n@@ -90,2 +93,3 @@\n-    @Test(dataProvider = \"compactFormatData\")\n-    public void testFormat(Locale locale, double num,\n+    @ParameterizedTest\n+    @MethodSource(\"compactFormatData\")\n+    void testFormat(Locale locale, double num,\n@@ -98,2 +102,3 @@\n-    @Test(dataProvider = \"compactParseData\")\n-    public void testParse(Locale locale, String parseString,\n+    @ParameterizedTest\n+    @MethodSource(\"compactParseData\")\n+    void testParse(Locale locale, String parseString,\n","filename":"test\/jdk\/java\/text\/Format\/CompactNumberFormat\/TestUExtensionOverride.java","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run testng\/othervm TestDeserializeCNF\n+ * @run junit\/othervm TestDeserializeCNF\n@@ -34,2 +34,3 @@\n-import org.testng.annotations.BeforeTest;\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n@@ -44,1 +45,0 @@\n-import static org.testng.Assert.*;\n@@ -46,0 +46,3 @@\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n@@ -63,2 +66,2 @@\n-    @BeforeTest\n-    public void mutateInstances() {\n+    @BeforeAll\n+    void mutateInstances() {\n@@ -74,1 +77,1 @@\n-    public void testDeserialization() throws IOException, ClassNotFoundException {\n+    void testDeserialization() throws IOException, ClassNotFoundException {\n@@ -81,1 +84,1 @@\n-            assertEquals(obj1, COMPACT_FORMAT1, \"Deserialized instance is not\"\n+            assertEquals(COMPACT_FORMAT1, obj1, \"Deserialized instance is not\"\n@@ -85,1 +88,1 @@\n-            assertEquals(obj2, COMPACT_FORMAT2, \"Deserialized instance is not\"\n+            assertEquals(COMPACT_FORMAT2, obj2, \"Deserialized instance is not\"\n","filename":"test\/jdk\/java\/text\/Format\/CompactNumberFormat\/serialization\/TestDeserializeCNF.java","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,0 +23,1 @@\n+\n@@ -28,1 +29,1 @@\n- * @run testng\/othervm TestSerialization\n+ * @run junit\/othervm TestSerialization\n@@ -31,2 +32,3 @@\n-import org.testng.annotations.BeforeTest;\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n@@ -43,1 +45,0 @@\n-import static org.testng.Assert.*;\n@@ -45,0 +46,3 @@\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n@@ -60,2 +64,2 @@\n-    @BeforeTest\n-    public void mutateInstances() {\n+    @BeforeAll\n+    void mutateInstances() {\n@@ -84,1 +88,1 @@\n-    public void testSerialization() throws IOException, ClassNotFoundException {\n+    void testSerialization() throws IOException, ClassNotFoundException {\n@@ -107,1 +111,1 @@\n-                assertEquals(fmt, obj, \"Serialized and deserialized\"\n+                assertEquals(obj, fmt, \"Serialized and deserialized\"\n@@ -113,1 +117,1 @@\n-                assertEquals(actual, expected, \"Serialized and deserialized\"\n+                assertEquals(expected, actual, \"Serialized and deserialized\"\n","filename":"test\/jdk\/java\/text\/Format\/CompactNumberFormat\/serialization\/TestSerialization.java","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,0 +23,1 @@\n+\n@@ -29,1 +30,1 @@\n- * @run testng\/othervm Bug8193444\n+ * @run junit\/othervm Bug8193444\n@@ -31,2 +32,4 @@\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n+\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -39,1 +42,1 @@\n-import static org.testng.Assert.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -41,0 +44,1 @@\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n@@ -45,1 +49,0 @@\n-    @DataProvider(name = \"dateFormat\")\n@@ -56,2 +59,3 @@\n-    @Test(dataProvider = \"dateFormat\")\n-    public void testDateFormatAndParse(int length)\n+    @ParameterizedTest\n+    @MethodSource(\"dateFormatData\")\n+    void testDateFormatAndParse(int length)\n@@ -69,1 +73,1 @@\n-        assertEquals(result, pattern, \"Failed to format the date using\"\n+        assertEquals(pattern, result, \"Failed to format the date using\"\n","filename":"test\/jdk\/java\/text\/Format\/DateFormat\/Bug8193444.java","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n@@ -28,1 +28,0 @@\n- * @run testng\/othervm CaseInsensitiveParseTest\n@@ -30,0 +29,1 @@\n+ * @run junit\/othervm CaseInsensitiveParseTest\n@@ -32,0 +32,4 @@\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n@@ -40,3 +44,1 @@\n-import static org.testng.Assert.assertEquals;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -44,0 +46,1 @@\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n@@ -49,2 +52,1 @@\n-    @DataProvider\n-    private Object[][] locales() {\n+    Object[][] locales() {\n@@ -57,2 +59,3 @@\n-    @Test(dataProvider = \"locales\")\n-    public void testUpperCase(Locale loc) throws ParseException {\n+    @ParameterizedTest\n+    @MethodSource(\"locales\")\n+    void testUpperCase(Locale loc) throws ParseException {\n@@ -61,1 +64,1 @@\n-        assertEquals(sdf.parse(formatted.toUpperCase(Locale.ROOT)), EPOCH,\n+        assertEquals(EPOCH, sdf.parse(formatted.toUpperCase(Locale.ROOT)),\n@@ -65,2 +68,3 @@\n-    @Test(dataProvider = \"locales\")\n-    public void testLowerCase(Locale loc) throws ParseException {\n+    @ParameterizedTest\n+    @MethodSource(\"locales\")\n+    void testLowerCase(Locale loc) throws ParseException {\n@@ -69,1 +73,1 @@\n-        assertEquals(sdf.parse(formatted.toLowerCase(Locale.ROOT)), EPOCH,\n+        assertEquals(EPOCH, sdf.parse(formatted.toLowerCase(Locale.ROOT)),\n","filename":"test\/jdk\/java\/text\/Format\/DateFormat\/CaseInsensitiveParseTest.java","additions":18,"deletions":14,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n@@ -28,1 +28,0 @@\n- * @run testng LocaleDateFormats\n@@ -30,0 +29,1 @@\n+ * @run junit LocaleDateFormats\n@@ -32,0 +32,4 @@\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n@@ -35,3 +39,0 @@\n-import static org.testng.Assert.assertEquals;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n@@ -39,0 +40,3 @@\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n@@ -41,2 +45,3 @@\n-    @Test(dataProvider = \"dateFormats\")\n-    public void testDateFormat(Locale loc, int style, int year, int month, int date, String expectedString) {\n+    @ParameterizedTest\n+    @MethodSource(\"dateFormats\")\n+    void testDateFormat(Locale loc, int style, int year, int month, int date, String expectedString) {\n@@ -48,1 +53,1 @@\n-        assertEquals(df.format(cal.getTime()), expectedString);\n+        assertEquals(expectedString, df.format(cal.getTime()));\n@@ -51,1 +56,0 @@\n-    @DataProvider(name = \"dateFormats\" )\n","filename":"test\/jdk\/java\/text\/Format\/DateFormat\/LocaleDateFormats.java","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n@@ -28,1 +28,1 @@\n- * @run testng\/othervm SimpleDateFormatPatternTest\n+ * @run junit\/othervm SimpleDateFormatPatternTest\n@@ -30,1 +30,5 @@\n-import java.lang.IllegalArgumentException;\n+\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n@@ -36,2 +40,1 @@\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n@@ -39,0 +42,1 @@\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n@@ -139,1 +143,0 @@\n-    @DataProvider(name = \"dfAllLocalesObj\")\n@@ -144,1 +147,0 @@\n-    @DataProvider(name = \"invalidPatternObj\")\n@@ -149,1 +151,0 @@\n-    @DataProvider(name = \"validPatternObj\")\n@@ -155,3 +156,3 @@\n-    @Test(dataProvider = \"invalidPatternObj\",\n-            expectedExceptions = IllegalArgumentException.class)\n-    public void testIllegalArgumentException1(String pattern, Locale loc)\n+    @ParameterizedTest\n+    @MethodSource(\"invalidPatternObj\")\n+    void testIllegalArgumentException1(String pattern, Locale loc)\n@@ -159,2 +160,4 @@\n-        Locale.setDefault(loc);\n-        new SimpleDateFormat(pattern);\n+        assertThrows(IllegalArgumentException.class, () -> {\n+            Locale.setDefault(loc);\n+            new SimpleDateFormat(pattern);\n+        });\n@@ -163,3 +166,3 @@\n-    @Test(dataProvider = \"invalidPatternObj\",\n-            expectedExceptions = IllegalArgumentException.class)\n-    public void testIllegalArgumentException2(String pattern, Locale loc)\n+    @ParameterizedTest\n+    @MethodSource(\"invalidPatternObj\")\n+    void testIllegalArgumentException2(String pattern, Locale loc)\n@@ -167,2 +170,4 @@\n-        Locale.setDefault(loc);\n-        new SimpleDateFormat(pattern, new DateFormatSymbols());\n+        assertThrows(IllegalArgumentException.class, () -> {\n+            Locale.setDefault(loc);\n+            new SimpleDateFormat(pattern, new DateFormatSymbols());\n+        });\n@@ -171,3 +176,3 @@\n-    @Test(dataProvider = \"invalidPatternObj\",\n-            expectedExceptions = IllegalArgumentException.class)\n-    public void testIllegalArgumentException3 (String pattern, Locale loc)\n+    @ParameterizedTest\n+    @MethodSource(\"invalidPatternObj\")\n+    void testIllegalArgumentException3 (String pattern, Locale loc)\n@@ -175,2 +180,4 @@\n-        Locale.setDefault(loc);\n-        new SimpleDateFormat(pattern, Locale.getDefault());\n+        assertThrows(IllegalArgumentException.class, () -> {\n+            Locale.setDefault(loc);\n+            new SimpleDateFormat(pattern, Locale.getDefault());\n+        });\n@@ -179,3 +186,3 @@\n-    @Test(dataProvider = \"invalidPatternObj\",\n-            expectedExceptions = IllegalArgumentException.class)\n-    public void testIllegalArgumentException4(String pattern, Locale loc)\n+    @ParameterizedTest\n+    @MethodSource(\"invalidPatternObj\")\n+    void testIllegalArgumentException4(String pattern, Locale loc)\n@@ -183,2 +190,4 @@\n-        Locale.setDefault(loc);\n-        new SimpleDateFormat().applyPattern(pattern);\n+        assertThrows(IllegalArgumentException.class, () -> {\n+            Locale.setDefault(loc);\n+            new SimpleDateFormat().applyPattern(pattern);\n+        });\n@@ -188,3 +197,3 @@\n-    @Test(dataProvider = \"dfAllLocalesObj\",\n-            expectedExceptions = NullPointerException.class)\n-    public void testNullPointerException1(Locale loc)\n+    @ParameterizedTest\n+    @MethodSource(\"dfAllLocalesObj\")\n+    void testNullPointerException1(Locale loc)\n@@ -192,2 +201,4 @@\n-        Locale.setDefault(loc);\n-        new SimpleDateFormat(null);\n+        assertThrows(NullPointerException.class, () -> {\n+            Locale.setDefault(loc);\n+            new SimpleDateFormat(null);\n+        });\n@@ -196,3 +207,3 @@\n-    @Test(dataProvider = \"dfAllLocalesObj\",\n-            expectedExceptions = NullPointerException.class)\n-    public void testNullPointerException2(Locale loc)\n+    @ParameterizedTest\n+    @MethodSource(\"dfAllLocalesObj\")\n+    void testNullPointerException2(Locale loc)\n@@ -200,2 +211,4 @@\n-        Locale.setDefault(loc);\n-        new SimpleDateFormat(null, new DateFormatSymbols());\n+        assertThrows(NullPointerException.class, () -> {\n+            Locale.setDefault(loc);\n+            new SimpleDateFormat(null, new DateFormatSymbols());\n+        });\n@@ -204,3 +217,3 @@\n-    @Test(dataProvider = \"dfAllLocalesObj\",\n-            expectedExceptions = NullPointerException.class)\n-    public void testNullPointerException3(Locale loc)\n+    @ParameterizedTest\n+    @MethodSource(\"dfAllLocalesObj\")\n+    void testNullPointerException3(Locale loc)\n@@ -208,2 +221,4 @@\n-        Locale.setDefault(loc);\n-        new SimpleDateFormat(null, Locale.getDefault());\n+        assertThrows(NullPointerException.class, () -> {\n+            Locale.setDefault(loc);\n+            new SimpleDateFormat(null, Locale.getDefault());\n+        });\n@@ -212,3 +227,3 @@\n-    @Test(dataProvider = \"dfAllLocalesObj\",\n-            expectedExceptions = NullPointerException.class)\n-    public void testNullPointerException4(Locale loc)\n+    @ParameterizedTest\n+    @MethodSource(\"dfAllLocalesObj\")\n+    void testNullPointerException4(Locale loc)\n@@ -216,2 +231,4 @@\n-        Locale.setDefault(loc);\n-        new SimpleDateFormat().applyPattern(null);\n+        assertThrows(NullPointerException.class, () -> {\n+            Locale.setDefault(loc);\n+            new SimpleDateFormat().applyPattern(null);\n+        });\n@@ -220,1 +237,1 @@\n-    @Test(dataProvider = \"validPatternObj\")\n+    @ParameterizedTest\n@@ -222,1 +239,2 @@\n-    public void testValidPattern(String pattern, Locale loc) {\n+    @MethodSource(\"validPatternObj\")\n+    void testValidPattern(String pattern, Locale loc) {\n","filename":"test\/jdk\/java\/text\/Format\/DateFormat\/SimpleDateFormatPatternTest.java","additions":69,"deletions":51,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8354522 8358880\n+ * @bug 8354522 8358880 8367324\n@@ -92,6 +92,0 @@\n-\n-                Object data = valFromDigitList(original, \"data\");\n-                if (data != null) {\n-                    assertNotSame(data, valFromDigitList(dfClone, \"data\"));\n-                }\n-\n","filename":"test\/jdk\/java\/text\/Format\/DecimalFormat\/CloneTest.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng\/othervm SetGroupingSizeTest\n+ * @run junit\/othervm SetGroupingSizeTest\n@@ -32,0 +32,3 @@\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n@@ -34,3 +37,2 @@\n-import static org.testng.Assert.assertEquals;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n@@ -38,1 +40,0 @@\n-@Test\n@@ -41,2 +42,1 @@\n-    @DataProvider\n-    public static Object[][] validGroupingSizes() {\n+    static Object[][] validGroupingSizes() {\n@@ -49,2 +49,1 @@\n-    @DataProvider\n-    public static Object[][] invalidGroupingSizes() {\n+    static Object[][] invalidGroupingSizes() {\n@@ -61,2 +60,3 @@\n-    @Test(dataProvider = \"validGroupingSizes\")\n-    public void test_validGroupingSize(int newVal) {\n+    @ParameterizedTest\n+    @MethodSource(\"validGroupingSizes\")\n+    void test_validGroupingSize(int newVal) {\n@@ -65,1 +65,1 @@\n-        assertEquals(df.getGroupingSize(), newVal);\n+        assertEquals(newVal, df.getGroupingSize());\n@@ -68,5 +68,7 @@\n-    @Test(dataProvider = \"invalidGroupingSizes\",\n-        expectedExceptions = IllegalArgumentException.class)\n-    public void test_invalidGroupingSize(int newVal) {\n-        DecimalFormat df = new DecimalFormat();\n-        df.setGroupingSize(newVal);\n+    @ParameterizedTest\n+    @MethodSource(\"invalidGroupingSizes\")\n+    void test_invalidGroupingSize(int newVal) {\n+        assertThrows(IllegalArgumentException.class, () -> {\n+            DecimalFormat df = new DecimalFormat();\n+            df.setGroupingSize(newVal);\n+        });\n","filename":"test\/jdk\/java\/text\/Format\/DecimalFormat\/SetGroupingSizeTest.java","additions":20,"deletions":18,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n@@ -32,1 +32,1 @@\n- * @run testng\/othervm DFSMinusPerCentMill\n+ * @run junit\/othervm DFSMinusPerCentMill\n@@ -35,3 +35,13 @@\n-import java.io.*;\n-import java.util.*;\n-import java.text.*;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.text.NumberFormat;\n+import java.util.Locale;\n@@ -39,3 +49,1 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -43,0 +51,1 @@\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n@@ -52,1 +61,0 @@\n-    @DataProvider\n@@ -72,1 +80,0 @@\n-    @DataProvider\n@@ -81,2 +88,3 @@\n-    @Test(dataProvider=\"formatData\")\n-    public void testFormatData(Locale l, Type style, String expected) {\n+    @ParameterizedTest\n+    @MethodSource(\"formatData\")\n+    void testFormatData(Locale l, Type style, String expected) {\n@@ -105,1 +113,1 @@\n-        assertEquals(nf.format(SRC_NUM), expected);\n+        assertEquals(expected, nf.format(SRC_NUM));\n@@ -108,2 +116,3 @@\n-    @Test(dataProvider=\"charSymbols\")\n-    public void testCharSymbols(Locale l, char percent, char permill, char minus) {\n+    @ParameterizedTest\n+    @MethodSource(\"charSymbols\")\n+    void testCharSymbols(Locale l, char percent, char permill, char minus) {\n@@ -111,3 +120,3 @@\n-        assertEquals(dfs.getPercent(), percent);\n-        assertEquals(dfs.getPerMill(), permill);\n-        assertEquals(dfs.getMinusSign(), minus);\n+        assertEquals(percent, dfs.getPercent());\n+        assertEquals(permill, dfs.getPerMill());\n+        assertEquals(minus, dfs.getMinusSign());\n@@ -117,1 +126,1 @@\n-    public void testSerialization() throws Exception {\n+    void testSerialization() throws Exception {\n@@ -125,1 +134,1 @@\n-        assertEquals(dfs, dfsSerialized);\n+        assertEquals(dfsSerialized, dfs);\n@@ -137,1 +146,1 @@\n-        assertEquals(dfs, dfsSerialized);\n+        assertEquals(dfsSerialized, dfs);\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/DFSMinusPerCentMill.java","additions":31,"deletions":22,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng\/othervm SquareEraCharacterTest\n+ * @run junit\/othervm SquareEraCharacterTest\n@@ -31,1 +31,3 @@\n-import static org.testng.Assert.assertEquals;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -35,2 +37,1 @@\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -38,1 +39,1 @@\n-@Test\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n@@ -41,1 +42,0 @@\n-    @DataProvider\n@@ -54,6 +54,4 @@\n-    @Test(dataProvider=\"squareEras\")\n-    public void test_normalize(char squareChar, String expected) {\n-\n-        assertEquals(\n-            Normalizer.normalize(Character.toString(squareChar), Normalizer.Form.NFKD),\n-            expected,\n+    @ParameterizedTest\n+    @MethodSource(\"squareEras\")\n+    void test_normalize(char squareChar, String expected) {\n+        assertEquals(expected, Normalizer.normalize(Character.toString(squareChar), Normalizer.Form.NFKD),\n","filename":"test\/jdk\/java\/text\/Normalizer\/SquareEraCharacterTest.java","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -3,2 +3,2 @@\n-# Amendments up until ISO 4217 AMENDMENT NUMBER 179\n-#   (As of 02 May 2025)\n+# Amendments up until ISO 4217 AMENDMENT NUMBER 180\n+#   (As of 22 September 2025)\n@@ -9,1 +9,1 @@\n-DATAVERSION=179\n+DATAVERSION=180\n@@ -47,1 +47,1 @@\n-BG\tBGN\t975\t2\n+BG\tBGN\t975\t2\t2025-12-31-22-00-00\tEUR\t978\t2\n@@ -72,1 +72,1 @@\n-CW\tANG\t532\t2\t2025-04-01-04-00-00\tXCG\t532\t2\n+CW\tXCG\t532\t2\n@@ -236,1 +236,1 @@\n-SX\tANG\t532\t2\t2025-04-01-04-00-00\tXCG\t532\t2\n+SX\tXCG\t532\t2\n","filename":"test\/jdk\/java\/util\/Currency\/ISO4217-list-one.txt","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- *      8354343 8354344 8356096\n+ *      8354343 8354344 8356096 8368308\n@@ -119,1 +119,1 @@\n-            \"ADP-AFA-ATS-AYM-AZM-BEF-BGL-BOV-BYB-BYR-CHE-CHW-CLF-COU-CUC-CYP-\"\n+            \"ADP-AFA-ATS-AYM-AZM-BEF-BGL-BGN-BOV-BYB-BYR-CHE-CHW-CLF-COU-CUC-CYP-\"\n","filename":"test\/jdk\/java\/util\/Currency\/ValidateISO4217.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng\/othervm LocaleMatchingTest\n+ * @run junit\/othervm LocaleMatchingTest\n@@ -31,0 +31,4 @@\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n@@ -43,4 +47,4 @@\n-import static org.testng.Assert.*;\n-\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n@@ -50,2 +54,1 @@\n-    @DataProvider(name = \"LRConstructorData\")\n-    Object[][] LRConstructorData() {\n+    static Object[][] LRConstructorData() {\n@@ -65,2 +68,1 @@\n-    @DataProvider(name = \"LRConstructorNPEData\")\n-    Object[][] LRConstructorNPEData() {\n+    static Object[][] LRConstructorNPEData() {\n@@ -74,2 +76,1 @@\n-    @DataProvider(name = \"LRConstructorIAEData\")\n-    Object[][] LRConstructorIAEData() {\n+    static Object[][] LRConstructorIAEData() {\n@@ -96,2 +97,1 @@\n-    @DataProvider(name = \"LRParseData\")\n-    Object[][] LRParseData() {\n+    static Object[][] LRParseData() {\n@@ -142,2 +142,1 @@\n-    @DataProvider(name = \"LRParseIAEData\")\n-    Object[][] LRParseIAEData() {\n+    static Object[][] LRParseIAEData() {\n@@ -151,2 +150,1 @@\n-    @DataProvider(name = \"LRMapEquivalentsData\")\n-    Object[][] LRMapEquivalentsData() {\n+    static Object[][] LRMapEquivalentsData() {\n@@ -184,2 +182,1 @@\n-    @DataProvider(name = \"LFilterData\")\n-    Object[][] LFilterData() {\n+    static Object[][] LFilterData() {\n@@ -206,2 +203,1 @@\n-    @DataProvider(name = \"LFilterNPEData\")\n-    Object[][] LFilterNPEData() {\n+    static Object[][] LFilterNPEData() {\n@@ -215,2 +211,1 @@\n-    @DataProvider(name = \"LFilterTagsData\")\n-    Object[][] LFilterTagsData() {\n+    static Object[][] LFilterTagsData() {\n@@ -277,2 +272,1 @@\n-    @DataProvider(name = \"LLookupData\")\n-    Object[][] LLookupData() {\n+    static Object[][] LLookupData() {\n@@ -287,2 +281,1 @@\n-    @DataProvider(name = \"LLookupTagData\")\n-    Object[][] LLookupTagData() {\n+    static Object[][] LLookupTagData() {\n@@ -301,2 +294,2 @@\n-    public void testLRConstants() {\n-        assertEquals(MIN_WEIGHT, 0.0, \"    MIN_WEIGHT should be 0.0 but got \"\n+    void testLRConstants() {\n+        assertEquals(0.0, MIN_WEIGHT, \"    MIN_WEIGHT should be 0.0 but got \"\n@@ -304,1 +297,1 @@\n-        assertEquals(MAX_WEIGHT, 1.0, \"    MAX_WEIGHT should be 1.0 but got \"\n+        assertEquals(1.0, MAX_WEIGHT, \"    MAX_WEIGHT should be 1.0 but got \"\n@@ -308,2 +301,3 @@\n-    @Test(dataProvider = \"LRConstructorData\")\n-    public void testLRConstructors(String range, double weight) {\n+    @MethodSource(\"LRConstructorData\")\n+    @ParameterizedTest\n+    void testLRConstructors(String range, double weight) {\n@@ -316,1 +310,1 @@\n-        assertEquals(lr.getRange(), range.toLowerCase(Locale.ROOT),\n+        assertEquals(range.toLowerCase(Locale.ROOT), lr.getRange(),\n@@ -319,1 +313,1 @@\n-        assertEquals(lr.getWeight(), weight,\n+        assertEquals(weight, lr.getWeight(),\n@@ -324,2 +318,3 @@\n-    @Test(dataProvider = \"LRConstructorNPEData\", expectedExceptions = NullPointerException.class)\n-    public void testLRConstructorNPE(String range, double weight) {\n+    @MethodSource(\"LRConstructorNPEData\")\n+    @ParameterizedTest\n+    void testLRConstructorNPE(String range, double weight) {\n@@ -327,1 +322,1 @@\n-            new LanguageRange(range);\n+            assertThrows(NullPointerException.class, () -> new LanguageRange(range));\n@@ -329,1 +324,1 @@\n-            new LanguageRange(range, weight);\n+            assertThrows(NullPointerException.class, () -> new LanguageRange(range, weight));\n@@ -333,2 +328,3 @@\n-    @Test(dataProvider = \"LRConstructorIAEData\", expectedExceptions = IllegalArgumentException.class)\n-    public void testLRConstructorIAE(String range, double weight) {\n+    @MethodSource(\"LRConstructorIAEData\")\n+    @ParameterizedTest\n+    void testLRConstructorIAE(String range, double weight) {\n@@ -336,1 +332,1 @@\n-            new LanguageRange(range);\n+            assertThrows(IllegalArgumentException.class, () -> new LanguageRange(range));\n@@ -338,1 +334,1 @@\n-            new LanguageRange(range, weight);\n+            assertThrows(IllegalArgumentException.class, () -> new LanguageRange(range, weight));\n@@ -343,1 +339,1 @@\n-    public void testLREquals() {\n+    void testLREquals() {\n@@ -349,3 +345,3 @@\n-        assertEquals(lr1, lr2, \"    LR(ja, 1.0).equals(LR(ja)) should return true.\");\n-        assertNotEquals(lr1, lr3, \"    LR(ja, 1.0).equals(LR(ja, 0.1)) should return false.\");\n-        assertNotEquals(lr1, lr4, \"    LR(ja, 1.0).equals(LR(en, 1.0)) should return false.\");\n+        assertEquals(lr2, lr1, \"    LR(ja, 1.0).equals(LR(ja)) should return true.\");\n+        assertNotEquals(lr3, lr1, \"    LR(ja, 1.0).equals(LR(ja, 0.1)) should return false.\");\n+        assertNotEquals(lr4, lr1, \"    LR(ja, 1.0).equals(LR(en, 1.0)) should return false.\");\n@@ -353,1 +349,1 @@\n-        assertNotEquals(lr1, \"\", \"    LR(ja, 1.0).equals(\\\"\\\") should return false.\");\n+        assertNotEquals(\"\", lr1, \"    LR(ja, 1.0).equals(\\\"\\\") should return false.\");\n@@ -356,3 +352,4 @@\n-    @Test(dataProvider = \"LRParseData\")\n-    public void testLRParse(String ranges, List<LanguageRange> expected) {\n-        assertEquals(LanguageRange.parse(ranges), expected,\n+    @MethodSource(\"LRParseData\")\n+    @ParameterizedTest\n+    void testLRParse(String ranges, List<LanguageRange> expected) {\n+        assertEquals(expected, LanguageRange.parse(ranges),\n@@ -362,3 +359,3 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testLRParseNPE() {\n-        LanguageRange.parse(null);\n+    @Test\n+    void testLRParseNPE() {\n+        assertThrows(NullPointerException.class, () -> LanguageRange.parse(null));\n@@ -367,3 +364,4 @@\n-    @Test(dataProvider = \"LRParseIAEData\", expectedExceptions = IllegalArgumentException.class)\n-    public void testLRParseIAE(String ranges) {\n-        LanguageRange.parse(ranges);\n+    @MethodSource(\"LRParseIAEData\")\n+    @ParameterizedTest\n+    void testLRParseIAE(String ranges) {\n+        assertThrows(IllegalArgumentException.class, () -> LanguageRange.parse(ranges));\n@@ -372,2 +370,3 @@\n-    @Test(dataProvider = \"LRMapEquivalentsData\")\n-    public void testLRMapEquivalents(List<Locale.LanguageRange> priorityList,\n+    @MethodSource(\"LRMapEquivalentsData\")\n+    @ParameterizedTest\n+    void testLRMapEquivalents(List<Locale.LanguageRange> priorityList,\n@@ -375,1 +374,1 @@\n-        assertEquals(LanguageRange.mapEquivalents(priorityList, map), expected,\n+        assertEquals(expected, LanguageRange.mapEquivalents(priorityList, map),\n@@ -379,3 +378,4 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testLRMapEquivalentsNPE() {\n-        LanguageRange.mapEquivalents(null, Map.of(\"ja\", List.of(\"ja\", \"ja-Hira\")));\n+    @Test\n+    void testLRMapEquivalentsNPE() {\n+        assertThrows(NullPointerException.class,\n+                () -> LanguageRange.mapEquivalents(null, Map.of(\"ja\", List.of(\"ja\", \"ja-Hira\"))));\n@@ -384,2 +384,3 @@\n-    @Test(dataProvider = \"LFilterData\")\n-    public void testLFilter(String ranges, String tags, FilteringMode mode, String expectedLocales) {\n+    @MethodSource(\"LFilterData\")\n+    @ParameterizedTest\n+    void testLFilter(String ranges, String tags, FilteringMode mode, String expectedLocales) {\n@@ -390,1 +391,1 @@\n-        assertEquals(actualLocales, expectedLocales, showErrorMessage(\"    L.Filter(\" + mode + \")\",\n+        assertEquals(expectedLocales, actualLocales, showErrorMessage(\"    L.Filter(\" + mode + \")\",\n@@ -394,5 +395,13 @@\n-    @Test(dataProvider = \"LFilterNPEData\", expectedExceptions = NullPointerException.class)\n-    public void testLFilterNPE(String ranges, String tags, FilteringMode mode) {\n-        List<LanguageRange> priorityList = LanguageRange.parse(ranges);\n-        List<Locale> tagList = generateLocales(tags);\n-        showLocales(Locale.filter(priorityList, tagList, mode));\n+    @MethodSource(\"LFilterNPEData\")\n+    @ParameterizedTest\n+    void testLFilterNPE(String ranges, String tags, FilteringMode mode) {\n+        if (ranges == null) {\n+            \/\/ Ranges are null\n+            assertThrows(NullPointerException.class, () -> LanguageRange.parse(ranges));\n+        } else {\n+            \/\/ Tags are null\n+            List<LanguageRange> priorityList = LanguageRange.parse(ranges);\n+            List<Locale> tagList = generateLocales(tags);\n+            assertThrows(NullPointerException.class,\n+                    () -> showLocales(Locale.filter(priorityList, tagList, mode)));\n+        }\n@@ -401,2 +410,2 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testLFilterIAE() {\n+    @Test\n+    void testLFilterIAE() {\n@@ -407,1 +416,2 @@\n-        showLocales(Locale.filter(priorityList, tagList, REJECT_EXTENDED_RANGES));\n+        assertThrows(IllegalArgumentException.class,\n+                () -> showLocales(Locale.filter(priorityList, tagList, REJECT_EXTENDED_RANGES)));\n@@ -410,2 +420,3 @@\n-    @Test(dataProvider = \"LFilterTagsData\")\n-    public void testLFilterTags(String ranges, String tags, FilteringMode mode, String expectedTags) {\n+    @MethodSource(\"LFilterTagsData\")\n+    @ParameterizedTest\n+    void testLFilterTags(String ranges, String tags, FilteringMode mode, String expectedTags) {\n@@ -420,1 +431,1 @@\n-        assertEquals(actualTags, expectedTags,\n+        assertEquals(expectedTags, actualTags,\n@@ -425,2 +436,2 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testLFilterTagsIAE() {\n+    @Test\n+    void testLFilterTagsIAE() {\n@@ -431,1 +442,2 @@\n-        showLanguageTags(Locale.filterTags(priorityList, generateLanguageTags(tags), REJECT_EXTENDED_RANGES));\n+        assertThrows(IllegalArgumentException.class,\n+                () -> showLanguageTags(Locale.filterTags(priorityList, generateLanguageTags(tags), REJECT_EXTENDED_RANGES)));\n@@ -434,2 +446,3 @@\n-    @Test(dataProvider = \"LLookupData\")\n-    public void testLLookup(String ranges, String tags, String expectedLocale) {\n+    @MethodSource(\"LLookupData\")\n+    @ParameterizedTest\n+    void testLLookup(String ranges, String tags, String expectedLocale) {\n@@ -440,1 +453,1 @@\n-        assertEquals(actualLocale, expectedLocale, showErrorMessage(\"    L.Lookup()\",\n+        assertEquals(expectedLocale, actualLocale, showErrorMessage(\"    L.Lookup()\",\n@@ -444,2 +457,3 @@\n-    @Test(dataProvider = \"LLookupTagData\")\n-    public void testLLookupTag(String ranges, String tags, String expectedTag) {\n+    @MethodSource(\"LLookupTagData\")\n+    @ParameterizedTest\n+    void testLLookupTag(String ranges, String tags, String expectedTag) {\n@@ -449,1 +463,1 @@\n-        assertEquals(actualTag, expectedTag, showErrorMessage(\"    L.LookupTag()\",\n+        assertEquals(expectedTag, actualTag, showErrorMessage(\"    L.LookupTag()\",\n","filename":"test\/jdk\/java\/util\/Locale\/LocaleMatchingTest.java","additions":100,"deletions":86,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -23,1 +23,2 @@\n-\/**\n+\n+\/*\n@@ -28,1 +29,1 @@\n- * @run testng RequiredAvailableLocalesTest\n+ * @run junit RequiredAvailableLocalesTest\n@@ -33,1 +34,6 @@\n-import java.text.*;\n+import java.text.BreakIterator;\n+import java.text.Collator;\n+import java.text.DateFormat;\n+import java.text.DateFormatSymbols;\n+import java.text.DecimalFormatSymbols;\n+import java.text.NumberFormat;\n@@ -35,1 +41,7 @@\n-import java.util.*;\n+import java.util.Arrays;\n+import java.util.Calendar;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -37,3 +49,1 @@\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -41,1 +51,0 @@\n-@Test\n@@ -48,2 +57,1 @@\n-    @DataProvider\n-    public Object[][] availableLocalesClasses() {\n+    static Object[][] availableLocalesClasses() {\n@@ -63,2 +71,3 @@\n-    @Test (dataProvider = \"availableLocalesClasses\")\n-    public void checkRequiredLocales(Class<?> c, MethodType mt) throws Throwable {\n+    @MethodSource(\"availableLocalesClasses\")\n+    @ParameterizedTest\n+    void checkRequiredLocales(Class<?> c, MethodType mt) throws Throwable {\n","filename":"test\/jdk\/java\/util\/Locale\/RequiredAvailableLocalesTest.java","additions":21,"deletions":12,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,1 +23,2 @@\n-\/**\n+\n+\/*\n@@ -30,1 +31,1 @@\n- * @run testng TestOf\n+ * @run junit TestOf\n@@ -32,2 +33,4 @@\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertThrows;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -37,2 +40,2 @@\n-import org.testng.annotations.Test;\n-import org.testng.annotations.DataProvider;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n@@ -41,1 +44,0 @@\n-@Test\n@@ -44,2 +46,1 @@\n-    @DataProvider\n-    public Object[][] data_1Arg() {\n+    static Object[][] data_1Arg() {\n@@ -58,2 +59,1 @@\n-    @DataProvider\n-    public Object[][] data_2Args() {\n+    static Object[][] data_2Args() {\n@@ -72,2 +72,1 @@\n-    @DataProvider\n-    public Object[][] data_3Args() {\n+    static Object[][] data_3Args() {\n@@ -90,3 +89,4 @@\n-    @Test (dataProvider = \"data_1Arg\")\n-    public void test_1Arg(Locale expected, String lang) {\n-        assertEquals(Locale.of(lang), expected);\n+    @MethodSource(\"data_1Arg\")\n+    @ParameterizedTest\n+    void test_1Arg(Locale expected, String lang) {\n+        assertEquals(expected, Locale.of(lang));\n@@ -95,3 +95,4 @@\n-    @Test (dataProvider = \"data_2Args\")\n-    public void test_2Args(Locale expected, String lang, String ctry) {\n-        assertEquals(Locale.of(lang, ctry), expected);\n+    @MethodSource(\"data_2Args\")\n+    @ParameterizedTest\n+    void test_2Args(Locale expected, String lang, String ctry) {\n+        assertEquals(expected, Locale.of(lang, ctry));\n@@ -100,3 +101,4 @@\n-    @Test (dataProvider = \"data_3Args\")\n-    public void test_3Args(Locale expected, String lang, String ctry, String vrnt) {\n-        assertEquals(Locale.of(lang, ctry, vrnt), expected);\n+    @MethodSource(\"data_3Args\")\n+    @ParameterizedTest\n+    void test_3Args(Locale expected, String lang, String ctry, String vrnt) {\n+        assertEquals(expected, Locale.of(lang, ctry, vrnt));\n@@ -106,1 +108,1 @@\n-    public void test_NPE() {\n+    void test_NPE() {\n","filename":"test\/jdk\/java\/util\/Locale\/TestOf.java","additions":26,"deletions":24,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run testng\/othervm CalendarTests\n+ * @run junit\/othervm CalendarTests\n@@ -34,2 +34,0 @@\n-import static org.testng.Assert.assertEquals;\n-\n@@ -41,4 +39,6 @@\n-import org.testng.annotations.AfterTest;\n-import org.testng.annotations.BeforeTest;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -49,1 +49,0 @@\n-@Test\n@@ -67,2 +66,2 @@\n-    @BeforeTest\n-    public void beforeTest() {\n+    @BeforeAll\n+    static void beforeTest() {\n@@ -73,2 +72,2 @@\n-    @AfterTest\n-    public void afterTest() {\n+    @AfterAll\n+    static void afterTest() {\n@@ -78,2 +77,1 @@\n-    @DataProvider(name=\"tz\")\n-    Object[][] tz() {\n+    static Object[][] tz() {\n@@ -90,2 +88,1 @@\n-    @DataProvider(name=\"firstDayOfWeek\")\n-    Object[][] firstDayOfWeek () {\n+    static Object[][] firstDayOfWeek () {\n@@ -117,2 +114,1 @@\n-    @DataProvider(name=\"minDaysInFirstWeek\")\n-    Object[][] minDaysInFrstWeek () {\n+    static Object[][] minDaysInFirstWeek () {\n@@ -129,2 +125,3 @@\n-    @Test(dataProvider=\"tz\")\n-    public void test_tz(Locale locale, TimeZone zoneExpected) {\n+    @MethodSource(\"tz\")\n+    @ParameterizedTest\n+    void test_tz(Locale locale, TimeZone zoneExpected) {\n@@ -132,1 +129,1 @@\n-        assertEquals(df.getTimeZone(), zoneExpected);\n+        assertEquals(zoneExpected, df.getTimeZone());\n@@ -135,1 +132,1 @@\n-        assertEquals(c.getTimeZone(), zoneExpected);\n+        assertEquals(zoneExpected, c.getTimeZone());\n@@ -138,1 +135,1 @@\n-        assertEquals(c.getTimeZone(), zoneExpected);\n+        assertEquals(zoneExpected, c.getTimeZone());\n@@ -141,2 +138,3 @@\n-    @Test(dataProvider=\"firstDayOfWeek\")\n-    public void test_firstDayOfWeek(Locale locale, int dowExpected) {\n+    @MethodSource(\"firstDayOfWeek\")\n+    @ParameterizedTest\n+    void test_firstDayOfWeek(Locale locale, int dowExpected) {\n@@ -144,1 +142,1 @@\n-        assertEquals(c.getFirstDayOfWeek(), dowExpected);\n+        assertEquals(dowExpected, c.getFirstDayOfWeek());\n@@ -147,1 +145,1 @@\n-        assertEquals(c.getFirstDayOfWeek(), dowExpected);\n+        assertEquals(dowExpected, c.getFirstDayOfWeek());\n@@ -150,2 +148,3 @@\n-    @Test(dataProvider=\"minDaysInFirstWeek\")\n-    public void test_minDaysInFirstWeek(Locale locale, int minDaysExpected) {\n+    @MethodSource(\"minDaysInFirstWeek\")\n+    @ParameterizedTest\n+    void test_minDaysInFirstWeek(Locale locale, int minDaysExpected) {\n@@ -153,1 +152,1 @@\n-        assertEquals(c.getMinimalDaysInFirstWeek(), minDaysExpected);\n+        assertEquals(minDaysExpected, c.getMinimalDaysInFirstWeek());\n@@ -156,1 +155,1 @@\n-        assertEquals(c.getMinimalDaysInFirstWeek(), minDaysExpected);\n+        assertEquals(minDaysExpected, c.getMinimalDaysInFirstWeek());\n","filename":"test\/jdk\/java\/util\/Locale\/bcp47u\/CalendarTests.java","additions":31,"deletions":32,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run testng CurrencyFormatTests\n+ * @run junit CurrencyFormatTests\n@@ -33,1 +33,2 @@\n-import static org.testng.Assert.assertEquals;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -38,2 +39,1 @@\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -45,1 +45,0 @@\n-@Test\n@@ -48,2 +47,1 @@\n-    @DataProvider(name=\"getInstanceData\")\n-    Object[][] getInstanceData() {\n+    static Object[][] getInstanceData() {\n@@ -100,3 +98,4 @@\n-    @Test(dataProvider=\"getInstanceData\")\n-    public void test_getInstance(Locale locale, int amount, String expected) {\n-        assertEquals(NumberFormat.getCurrencyInstance(locale).format(amount), expected);\n+    @MethodSource(\"getInstanceData\")\n+    @ParameterizedTest\n+    void test_getInstance(Locale locale, int amount, String expected) {\n+        assertEquals(expected, NumberFormat.getCurrencyInstance(locale).format(amount));\n","filename":"test\/jdk\/java\/util\/Locale\/bcp47u\/CurrencyFormatTests.java","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run testng\/othervm CurrencyTests\n+ * @run junit\/othervm CurrencyTests\n@@ -34,1 +34,2 @@\n-import static org.testng.Assert.assertEquals;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -39,2 +40,1 @@\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -45,1 +45,0 @@\n-@Test\n@@ -51,2 +50,1 @@\n-    @DataProvider(name=\"getInstanceData\")\n-    Object[][] getInstanceData() {\n+    static Object[][] getInstanceData() {\n@@ -79,2 +77,1 @@\n-    @DataProvider(name=\"getSymbolData\")\n-    Object[][] getSymbolData() {\n+    static Object[][] getSymbolData() {\n@@ -97,3 +94,4 @@\n-    @Test(dataProvider=\"getInstanceData\")\n-    public void test_getInstance(Locale locale, Currency currencyExpected) {\n-        assertEquals(Currency.getInstance(locale), currencyExpected);\n+    @MethodSource(\"getInstanceData\")\n+    @ParameterizedTest\n+    void test_getInstance(Locale locale, Currency currencyExpected) {\n+        assertEquals(currencyExpected, Currency.getInstance(locale));\n@@ -102,3 +100,4 @@\n-    @Test(dataProvider=\"getSymbolData\")\n-    public void test_getSymbol(Currency c, Locale locale, String expected) {\n-        assertEquals(c.getSymbol(locale), expected);\n+    @MethodSource(\"getSymbolData\")\n+    @ParameterizedTest\n+    void test_getSymbol(Currency c, Locale locale, String expected) {\n+        assertEquals(expected, c.getSymbol(locale));\n","filename":"test\/jdk\/java\/util\/Locale\/bcp47u\/CurrencyTests.java","additions":15,"deletions":16,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run testng DisplayNameTests\n+ * @run junit DisplayNameTests\n@@ -33,1 +33,2 @@\n-import static org.testng.Assert.assertEquals;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -37,2 +38,1 @@\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -44,1 +44,0 @@\n-@Test\n@@ -78,2 +77,1 @@\n-    @DataProvider(name=\"locales\")\n-    Object[][] tz() {\n+    static Object[][] locales() {\n@@ -104,2 +102,3 @@\n-    @Test(dataProvider=\"locales\")\n-    public void test_locales(Locale inLocale, Locale testLocale, String expected) {\n+    @MethodSource(\"locales\")\n+    @ParameterizedTest\n+    void test_locales(Locale inLocale, Locale testLocale, String expected) {\n@@ -107,1 +106,1 @@\n-        assertEquals(result, expected);\n+        assertEquals(expected, result);\n","filename":"test\/jdk\/java\/util\/Locale\/bcp47u\/DisplayNameTests.java","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run testng FormatTests\n+ * @run junit FormatTests\n@@ -34,1 +34,4 @@\n-import static org.testng.Assert.assertEquals;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -43,4 +46,1 @@\n-import org.testng.annotations.AfterTest;\n-import org.testng.annotations.BeforeTest;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -51,1 +51,0 @@\n-@Test\n@@ -83,2 +82,2 @@\n-    @BeforeTest\n-    public void beforeTest() {\n+    @BeforeAll\n+    static void beforeTest() {\n@@ -89,2 +88,2 @@\n-    @AfterTest\n-    public void afterTest() {\n+    @AfterAll\n+    static void afterTest() {\n@@ -94,2 +93,1 @@\n-    @DataProvider(name=\"dateFormatData\")\n-    Object[][] dateFormatData() {\n+    static Object[][] dateFormatData() {\n@@ -119,2 +117,1 @@\n-    @DataProvider(name=\"numberFormatData\")\n-    Object[][] numberFormatData() {\n+    static Object[][] numberFormatData() {\n@@ -139,2 +136,3 @@\n-    @Test(dataProvider=\"dateFormatData\")\n-    public void test_DateFormat(Locale locale, String calClass, TimeZone tz,\n+    @MethodSource(\"dateFormatData\")\n+    @ParameterizedTest\n+    void test_DateFormat(Locale locale, String calClass, TimeZone tz,\n@@ -146,1 +144,1 @@\n-            assertEquals(df.getCalendar().getClass(), expected);\n+            assertEquals(expected, df.getCalendar().getClass());\n@@ -152,1 +150,1 @@\n-            assertEquals(df.getTimeZone(), tz);\n+            assertEquals(tz, df.getTimeZone());\n@@ -155,2 +153,2 @@\n-        assertEquals(formatted, formatExpected);\n-        assertEquals(df.parse(formatted), testDate);\n+        assertEquals(formatExpected, formatted);\n+        assertEquals(testDate, df.parse(formatted));\n@@ -159,2 +157,3 @@\n-    @Test(dataProvider=\"numberFormatData\")\n-    public void test_NumberFormat(Locale locale, double num,\n+    @MethodSource(\"numberFormatData\")\n+    @ParameterizedTest\n+    void test_NumberFormat(Locale locale, double num,\n@@ -165,2 +164,2 @@\n-        assertEquals(nf.format(num), formatExpected);\n-        assertEquals(nf.parse(formatted), num);\n+        assertEquals(formatExpected, nf.format(num));\n+        assertEquals(num, nf.parse(formatted));\n","filename":"test\/jdk\/java\/util\/Locale\/bcp47u\/FormatTests.java","additions":24,"deletions":25,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run testng SymbolsTests\n+ * @run junit SymbolsTests\n@@ -34,1 +34,2 @@\n-import static org.testng.Assert.assertEquals;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -40,2 +41,1 @@\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -46,1 +46,0 @@\n-@Test\n@@ -53,2 +52,1 @@\n-    @DataProvider(name=\"dateFormatSymbolsData\")\n-    Object[][] dateFormatSymbolsData() {\n+    static Object[][] dateFormatSymbolsData() {\n@@ -64,2 +62,1 @@\n-    @DataProvider(name=\"decimalFormatSymbolsData\")\n-    Object[][] decimalFormatSymbolsData() {\n+    static Object[][] decimalFormatSymbolsData() {\n@@ -77,2 +74,3 @@\n-    @Test(dataProvider=\"dateFormatSymbolsData\")\n-    public void test_DateFormatSymbols(Locale locale, String amExpected, String pmExpected) {\n+    @MethodSource(\"dateFormatSymbolsData\")\n+    @ParameterizedTest\n+    void test_DateFormatSymbols(Locale locale, String amExpected, String pmExpected) {\n@@ -81,2 +79,2 @@\n-        assertEquals(ampm[0], amExpected);\n-        assertEquals(ampm[1], pmExpected);\n+        assertEquals(amExpected, ampm[0]);\n+        assertEquals(pmExpected, ampm[1]);\n@@ -85,2 +83,3 @@\n-    @Test(dataProvider=\"decimalFormatSymbolsData\")\n-    public void test_DecimalFormatSymbols(Locale locale, char decimal, char grouping) {\n+    @MethodSource(\"decimalFormatSymbolsData\")\n+    @ParameterizedTest\n+    void test_DecimalFormatSymbols(Locale locale, char decimal, char grouping) {\n@@ -88,2 +87,2 @@\n-        assertEquals(dfs.getDecimalSeparator(), decimal);\n-        assertEquals(dfs.getGroupingSeparator(), grouping);\n+        assertEquals(decimal, dfs.getDecimalSeparator());\n+        assertEquals(grouping, dfs.getGroupingSeparator());\n","filename":"test\/jdk\/java\/util\/Locale\/bcp47u\/SymbolsTests.java","additions":16,"deletions":17,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run testng\/othervm SystemPropertyTests\n+ * @run junit\/othervm SystemPropertyTests\n@@ -34,4 +34,2 @@\n-import static jdk.test.lib.process.ProcessTools.executeTestJava;\n-import static org.testng.Assert.assertTrue;\n-\n-import java.util.Locale;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -39,2 +37,2 @@\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n+import static jdk.test.lib.process.ProcessTools.executeTestJava;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -46,1 +44,0 @@\n-@Test\n@@ -53,2 +50,1 @@\n-    @DataProvider(name=\"data\")\n-    Object[][] data() {\n+    static Object[][] data() {\n@@ -89,2 +85,3 @@\n-    @Test(dataProvider=\"data\")\n-    public void runTest(String extprop, String defLoc,\n+    @MethodSource(\"data\")\n+    @ParameterizedTest\n+    void runTest(String extprop, String defLoc,\n@@ -98,1 +95,1 @@\n-        assertTrue(exitValue == 0);\n+        assertEquals(0, exitValue);\n","filename":"test\/jdk\/java\/util\/Locale\/bcp47u\/SystemPropertyTests.java","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -34,3 +34,0 @@\n-import static java.util.concurrent.TimeUnit.MILLISECONDS;\n-import static java.util.concurrent.TimeUnit.NANOSECONDS;\n-\n@@ -44,0 +41,1 @@\n+import java.util.concurrent.CancellationException;\n@@ -54,0 +52,3 @@\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n@@ -56,0 +57,1 @@\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -61,0 +63,2 @@\n+import static java.util.concurrent.TimeUnit.*;\n+\n@@ -485,0 +489,51 @@\n+    public void testCancellationExceptionInGet() throws Exception {\n+        final ExecutorService e = new ForkJoinPool(1);\n+        try (var cleaner = cleaner(e)) {\n+            assertCancellationExceptionFrom(\n+                e::submit,\n+                f -> () -> f.get(1000, TimeUnit.SECONDS)\n+            );\n+            assertCancellationExceptionFrom(\n+                e::submit,\n+                f -> f::get\n+            );\n+            assertCancellationExceptionFrom(\n+                c -> e.submit(() -> { try { c.call(); } catch (Exception ex) { throw new RuntimeException(ex); } }),\n+                f -> () -> f.get(1000, TimeUnit.SECONDS)\n+            );\n+            assertCancellationExceptionFrom(\n+                c -> e.submit(() -> { try { c.call(); } catch (Exception ex) { throw new RuntimeException(ex); } }),\n+                f -> f::get\n+            );\n+        }\n+    }\n+\n+    private void assertCancellationExceptionFrom(\n+            Function<Callable<Void>, Future<?>> createTask,\n+            Function<Future<?>, Callable<?>> getResult) throws Exception {\n+        final var t = new AtomicReference<Thread>();\n+        final var c = new CountDownLatch(1); \/\/ Only used to induce WAITING state (never counted down)\n+        final var task = createTask.apply(() -> {\n+            try {\n+                t.set(Thread.currentThread());\n+                c.await();\n+            } catch (InterruptedException ie) {\n+                Thread.currentThread().interrupt();;\n+            }\n+            return null;\n+        });\n+        Thread taskThread;\n+        while((taskThread = t.get()) == null || taskThread.getState() != Thread.State.WAITING) {\n+            if (Thread.interrupted())\n+                throw new InterruptedException();\n+            Thread.onSpinWait();\n+        }\n+        task.cancel(true);\n+        try {\n+            getResult.apply(task).call();\n+        } catch (CancellationException ce) {\n+            return; \/\/ Success\n+        }\n+        shouldThrow();\n+    }\n+\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/ForkJoinPoolTest.java","additions":58,"deletions":3,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ SunJSSE does not support dynamic system properties, no way to re-use\n+\/\/ system properties in samevm\/agentvm mode.\n+\n+\/*\n+ * @test\n+ * @bug 8367133\n+ * @summary Verify that handshake succeeds when Finished message is fragmented\n+ * @modules java.base\/sun.security.util\n+ * @library \/test\/lib\n+ * @build DTLSOverDatagram\n+ * @run main\/othervm FragmentedFinished\n+ *\/\n+\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.SSLParameters;\n+import java.net.DatagramPacket;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class FragmentedFinished extends DTLSOverDatagram {\n+    private SSLEngine serverSSLEngine;\n+    public static void main(String[] args) throws Exception {\n+        FragmentedFinished testCase = new FragmentedFinished();\n+        testCase.runTest(testCase);\n+    }\n+\n+    @Override\n+    SSLEngine createSSLEngine(boolean isClient) throws Exception {\n+        SSLEngine sslEngine = super.createSSLEngine(isClient);\n+        if (!isClient) {\n+            serverSSLEngine = sslEngine;\n+        }\n+        return sslEngine;\n+    }\n+\n+    @Override\n+    DatagramPacket createHandshakePacket(byte[] ba, SocketAddress socketAddr) {\n+        if (ba.length < 30) { \/\/ detect ChangeCipherSpec\n+            \/\/ Reduce the maximumPacketSize to force fragmentation\n+            \/\/ of the Finished message\n+            SSLParameters params = serverSSLEngine.getSSLParameters();\n+            params.setMaximumPacketSize(53);\n+            serverSSLEngine.setSSLParameters(params);\n+        }\n+\n+        return super.createHandshakePacket(ba, socketAddr);\n+    }\n+}\n","filename":"test\/jdk\/javax\/net\/ssl\/DTLS\/FragmentedFinished.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @bug 8321540 8319463 8357955\n+ * @bug 8321540 8319463 8357955 8368050 8368331\n@@ -51,0 +51,3 @@\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n@@ -66,1 +69,1 @@\n-                                ClassDesc.of(\"LinkedHashIterator\")),\n+                                \"LinkedHashIterator\"),\n@@ -120,0 +123,75 @@\n+\n+        assertEqualsDeep(\n+                MethodSignature.of(\n+                        List.of(TypeParam.of(\"A\", ClassTypeSig.of(\"one\/Two\")), \/\/ \/\n+                                TypeParam.of(\"B\", ClassTypeSig.of(ClassTypeSig.of(\"Outer\"), \"Inner\")), \/\/ .\n+                                TypeParam.of(\"C\", ArrayTypeSig.of(BaseTypeSig.of('I'))), \/\/ [\n+                                TypeParam.of(\"D\", ClassTypeSig.of(\"Generic\", TypeArg.unbounded())), \/\/ <\n+                                TypeParam.of(\"E\", TypeVarSig.of(\"A\")), \/\/ ;\n+                                TypeParam.of(\"F\", (ClassTypeSig) null), \/\/ :\n+                                TypeParam.of(\"G\", (ClassTypeSig) null)), \/\/ >\n+                        List.of(),\n+                        BaseTypeSig.of('V')),\n+                MethodSignature.parseFrom(\"<A:Lone\/Two;B:LOuter.Inner;C:[ID:LGeneric<*>;E:TA;F:G:>()V\")\n+        );\n+    }\n+\n+    @Test\n+    void testGenericCreationChecks() {\n+        var weirdNameClass = ClassDesc.of(\"<Unsupported>\");\n+        var voidSig = BaseTypeSig.of('V');\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> Signature.of(weirdNameClass));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> BaseTypeSig.of(CD_Object));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> BaseTypeSig.of(CD_int.arrayType()));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> ClassTypeSig.of(CD_int));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> ClassTypeSig.of(CD_Object.arrayType()));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> ClassTypeSig.of(weirdNameClass));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> ArrayTypeSig.of(voidSig));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> ArrayTypeSig.of(255, voidSig));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> MethodSignature.of(voidSig, voidSig));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> MethodSignature.of(List.of(), List.of(), voidSig, voidSig));\n+    }\n+\n+    static Stream<String> goodIdentifiers() {\n+        return Stream.of(\"T\", \"Hello\", \"Mock\", \"(Weird)\", \" Huh? \");\n+    }\n+\n+    static Stream<String> badIdentifiers() {\n+        return Stream.of(\"\", \";\", \".\", \"\/\", \"<\", \">\", \"[\", \":\",\n+                \"<Unsupported>\", \"has.chars\", \"\/Outer\", \"test\/\", \"test\/\/Outer\");\n+    }\n+\n+    static Stream<String> slashedIdentifiers() {\n+        return Stream.of(\"test\/Outer\", \"java\/lang\/Integer\");\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource({\"badIdentifiers\", \"slashedIdentifiers\"})\n+    void testBadSimpleIdentifier(String st) {\n+        ClassTypeSig outer = ClassTypeSig.of(\"test\/Outer\");\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> ClassTypeSig.of(outer, st));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> TypeVarSig.of(st));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> TypeParam.of(st, (RefTypeSig) null));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> TypeParam.of(st, Optional.empty()));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"goodIdentifiers\")\n+    void testGoodSimpleIdentifier(String st) {\n+        ClassTypeSig outer = ClassTypeSig.of(\"test\/Outer\");\n+        ClassTypeSig.of(outer, st);\n+        TypeVarSig.of(st);\n+        TypeParam.of(st, (RefTypeSig) null);\n+        TypeParam.of(st, Optional.empty());\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"badIdentifiers\")\n+    void testBadSlashedIdentifier(String st) {\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> ClassTypeSig.of(st));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource({\"goodIdentifiers\", \"slashedIdentifiers\"})\n+    void testGoodSlashedIdentifier(String st) {\n+        ClassTypeSig.of(st);\n@@ -234,0 +312,1 @@\n+        [V\n@@ -300,0 +379,1 @@\n+        (V)V\n","filename":"test\/jdk\/jdk\/classfile\/SignaturesTest.java","additions":83,"deletions":3,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8366421\n+ * @summary Test for ModifiedUtf.utfLen() return type change from int to long to avoid overflow\n+ * @modules java.base\/jdk.internal.classfile.impl:+open\n+ *          java.base\/jdk.internal.util\n+ * @run main\/othervm -Xmx4g ModifiedUtfTest\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.OutputStream;\n+import java.io.UTFDataFormatException;\n+\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n+import java.lang.classfile.ClassFile;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+\n+import jdk.internal.classfile.impl.BufWriterImpl;\n+import jdk.internal.classfile.impl.ClassFileImpl;\n+import jdk.internal.util.ModifiedUtf;\n+\n+public class ModifiedUtfTest {\n+\n+    static class HeaderCapturedException extends RuntimeException {\n+    }\n+    \/**\n+     * Keep only a fixed-length output and stop writing further data\n+     * by throwing an exception when the limit is exceeded.\n+     * For testing purposes only.\n+     *\/\n+    static class HeaderCaptureOutputStream extends OutputStream {\n+        private byte[] head;\n+        private int count;\n+\n+        public HeaderCaptureOutputStream(int headSize) {\n+            this.head = new byte[headSize];\n+        }\n+\n+        @Override\n+        public void write(int b) {\n+            if (count >= head.length) {\n+                \/\/ Only reserve a fixed-length header and throw an exception to stop writing.\n+                throw new HeaderCapturedException();\n+            }\n+            head[count++] = (byte) b;\n+        }\n+        public byte[] get(){\n+            return head;\n+        }\n+    }\n+\n+    private static final String THREE_BYTE = \"\\u2600\";   \/\/ 3-byte UTF-8\n+\n+    public static void main(String[] args) throws Exception{\n+        int count = Integer.MAX_VALUE \/ 3 + 1;\n+        long expected = 3L * count;\n+        String largeString = THREE_BYTE.repeat(count);\n+\n+        long total = ModifiedUtf.utfLen(largeString, 0);\n+        if (total != expected) {\n+            throw new RuntimeException(\"Expected total=\" + expected + \" but got \" + total);\n+        }\n+\n+        \/**\n+         * Verifies that the following three methods that call ModifiedUtf.utfLen()\n+         * correctly handle overflow:\n+         * - DataOutputStream.writeUTF(String)\n+         * - BufWriterImpl.writeUtfEntry(String)\n+         * - ObjectOutputStream.writeUTF(String)\n+         *\/\n+        try (ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n+             DataOutputStream dataOut = new DataOutputStream(byteOut)) {\n+            dataOut.writeUTF(largeString);\n+            throw new RuntimeException(\"Expected UTFDataFormatException was not thrown.\");\n+        } catch (UTFDataFormatException e) {\n+        }\n+\n+        BufWriterImpl bufWriter = new BufWriterImpl(ConstantPoolBuilder.of(), (ClassFileImpl) ClassFile.of());\n+        Method writeUtfEntry = bufWriter.getClass().getDeclaredMethod(\"writeUtfEntry\", String.class);\n+        writeUtfEntry.setAccessible(true);\n+        try {\n+            writeUtfEntry.invoke(bufWriter, largeString);\n+            throw new RuntimeException(\"Expected IllegalArgumentException was not thrown.\");\n+        } catch (InvocationTargetException e) {\n+            Throwable cause = e.getCause();\n+            if (!(cause instanceof IllegalArgumentException)) {\n+                throw new RuntimeException(\"Expected IllegalArgumentException was not thrown.\");\n+            }\n+        }\n+\n+        \/**\n+         * In the writeUTF function, utfLen is used to calculate the length of the string to be written\n+         * and store it in the stream header. This test uses the HeaderCaptureOutputStream inner class\n+         * to capture the header bytes and compare them with the expected length,\n+         * verifying that utfLen returns the correct value.\n+         *\/\n+        int lengthFieldSize = 8;\n+        \/\/ Offset to UTF length field: 2 bytes STREAM_MAGIC + 2 bytes STREAM_VERSION + 5 bytes block data header\n+        int lengthFieldOffset = 9;\n+        int headerSize = 20; \/\/ greater than lengthFieldSize + lengthFieldOffset\n+        HeaderCaptureOutputStream headerOut = new HeaderCaptureOutputStream(headerSize);\n+        try (ObjectOutputStream objOut = new ObjectOutputStream(headerOut)) {\n+            objOut.writeUTF(largeString);\n+        } catch (HeaderCapturedException  e) {\n+        }\n+        byte[] header = headerOut.get();\n+        ByteBuffer bf = ByteBuffer.wrap(header, lengthFieldOffset, lengthFieldSize);\n+        bf.order(ByteOrder.BIG_ENDIAN);\n+        long lenInHeader = bf.getLong();\n+        if ( lenInHeader != expected ) {\n+            throw new RuntimeException(\"Header length mismatch: expected=\" + expected + \", found=\" + lenInHeader);\n+        }\n+\n+        System.out.println(\"PASSED\");\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/internal\/util\/ModifiedUtfTest.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-            RecordedEvent event = events.getFirst();\n+            RecordedEvent event = events.getLast();\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/detailed\/TestGCHeapMemoryUsageEvent.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+import java.time.Duration;\n+import java.util.List;\n@@ -32,0 +34,1 @@\n+import jdk.jfr.Recording;\n@@ -33,0 +36,1 @@\n+import jdk.test.lib.jfr.Events;\n@@ -55,0 +59,25 @@\n+        testWithoutThreshold();\n+        testWithThreshold();\n+    }\n+\n+    private static void testWithThreshold() throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(EVENT_NAME)\n+             .with(\"filter\", CLASS_NAME + \"::printHello\")\n+             .withThreshold(Duration.ofHours(1));\n+            r.start();\n+            printHello();\n+            r.stop();\n+            List<RecordedEvent> events = Events.fromRecording(r);\n+            if (!events.isEmpty()) {\n+                System.out.println(events);\n+                throw new Exception(\"Unexpected MethodTrace event\");\n+            }\n+        }\n+    }\n+\n+    public static void printHello() {\n+        System.out.println(\"Hello!\");\n+    }\n+\n+    private static void testWithoutThreshold() throws Exception {\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/TestMethodTrace.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-        output.shouldContain(\"Old Garbage Collection\");\n+        output.shouldContain(\"G1\");\n","filename":"test\/jdk\/jdk\/jfr\/jcmd\/TestJcmdView.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-        output.shouldContain(\"Old Garbage Collection\");\n+        output.shouldContain(\"G1\");\n","filename":"test\/jdk\/jdk\/jfr\/tool\/TestView.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,0 @@\n-import java.awt.AWTException;\n@@ -28,0 +27,1 @@\n+import java.awt.EventQueue;\n@@ -45,2 +45,0 @@\n- *\n- * @author Dmitri.Trembovetski\n@@ -50,5 +48,6 @@\n-    static final int IMAGE_SIZE = 100;\n-    static boolean show = false;\n-    final Frame testFrame;\n-    \/** Creates a new instance of SharedMemoryPixmapsTest *\/\n-    public SharedMemoryPixmapsTest() {\n+    static final int IMAGE_SIZE = 200;\n+    static volatile boolean show = false;\n+    static volatile Frame testFrame;\n+    static volatile TestComponent testComponent;\n+\n+    static void createUI() {\n@@ -56,1 +55,2 @@\n-        testFrame.add(new TestComponent());\n+        testComponent = new TestComponent();\n+        testFrame.add(testComponent);\n@@ -65,1 +65,1 @@\n-    public static void main(String[] args) {\n+    public static void main(String[] args) throws Exception {\n@@ -73,1 +73,33 @@\n-        new SharedMemoryPixmapsTest();\n+        EventQueue.invokeAndWait(SharedMemoryPixmapsTest::createUI);\n+        if (testRendering()) {\n+            System.err.println(\"Test Passed\");\n+        } else {\n+            System.err.println(\"Test Failed\");\n+        }\n+        if (!show && testFrame != null) {\n+            EventQueue.invokeAndWait(testFrame::dispose);\n+        }\n+    }\n+\n+    static boolean testRendering() throws Exception {\n+        Robot r = new Robot();\n+        r.waitForIdle();\n+        r.delay(2000);\n+        Point p = testComponent.getLocationOnScreen();\n+        BufferedImage b =\n+            r.createScreenCapture(new Rectangle(p, testComponent.getPreferredSize()));\n+        for (int y = 20; y < b.getHeight() - 40; y++) {\n+            for (int x = 20; x < b.getWidth() - 40; x++) {\n+                if (b.getRGB(x, y) != Color.red.getRGB()) {\n+                    System.err.println(\"Incorrect pixel at \"\n+                        + x + \"x\" + y + \" : \" +\n+                        Integer.toHexString(b.getRGB(x, y)));\n+                    if (show) {\n+                        return false;\n+                    }\n+                    System.err.println(\"Test Failed\");\n+                    System.exit(1);\n+                }\n+            }\n+        }\n+        return true;\n@@ -76,1 +108,1 @@\n-    private class TestComponent extends Component {\n+    static class TestComponent extends Component {\n@@ -78,1 +110,0 @@\n-        boolean tested = false;\n@@ -107,0 +138,1 @@\n+                vi = null;\n@@ -110,45 +142,0 @@\n-\n-            Toolkit.getDefaultToolkit().sync();\n-            if (!tested) {\n-                if (testRendering()) {\n-                    System.err.println(\"Test Passed\");\n-                } else {\n-                    System.err.println(\"Test Failed\");\n-                }\n-                tested = true;\n-            }\n-            if (!show) {\n-                testFrame.setVisible(false);\n-                testFrame.dispose();\n-            }\n-        }\n-\n-        private boolean testRendering() throws RuntimeException {\n-            try {\n-                Thread.sleep(2000);\n-            } catch (InterruptedException ex) {}\n-            Robot r = null;\n-            try {\n-                r = new Robot();\n-            } catch (AWTException ex) {\n-                ex.printStackTrace();\n-                throw new RuntimeException(\"Can't create Robot\");\n-            }\n-            Point p = getLocationOnScreen();\n-            BufferedImage b =\n-                r.createScreenCapture(new Rectangle(p, getPreferredSize()));\n-            for (int y = 0; y < b.getHeight(); y++) {\n-                for (int x = 0; x < b.getWidth(); x++) {\n-                    if (b.getRGB(x, y) != Color.red.getRGB()) {\n-                        System.err.println(\"Incorrect pixel\" + \" at \"\n-                            + x + \"x\" + y + \" : \" +\n-                            Integer.toHexString(b.getRGB(x, y)));\n-                        if (show) {\n-                            return false;\n-                        }\n-                        System.err.println(\"Test Failed\");\n-                        System.exit(1);\n-                    }\n-                }\n-            }\n-            return true;\n@@ -162,1 +149,0 @@\n-\n","filename":"test\/jdk\/sun\/java2d\/X11SurfaceData\/SharedMemoryPixmapsTest\/SharedMemoryPixmapsTest.java","additions":46,"deletions":60,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-# Copyright (c) 2005, 2008, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-# @author Dmitri.Trembovetski\n","filename":"test\/jdk\/sun\/java2d\/X11SurfaceData\/SharedMemoryPixmapsTest\/SharedMemoryPixmapsTest.sh","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1550,14 +1550,14 @@\n-        thread1 = new Thread() {\n-            public void run() {\n-                udpConsumerReady = true;\n-                while (true) {\n-                    try {\n-                        byte[] inbuf = new byte[8192];\n-                        DatagramPacket p = new DatagramPacket(inbuf, inbuf.length);\n-                        udp.receive(p);\n-                        System.out.println(\"-----------------------------------------------\");\n-                        System.out.println(\">>>>> UDP packet received\");\n-                        q.put(new Job(processMessage(Arrays.copyOf(inbuf, p.getLength())), udp, p));\n-                    } catch (Exception e) {\n-                        e.printStackTrace();\n-                    }\n+        thread1 = new Thread(() -> {\n+            udpConsumerReady = true;\n+            while (true) {\n+                try {\n+                    byte[] inbuf = new byte[8192];\n+                    DatagramPacket p = new DatagramPacket(inbuf, inbuf.length);\n+                    udp.receive(p);\n+                    System.out.println(\"-----------------------------------------------\");\n+                    System.out.println(\">>>>> UDP packet received\");\n+                    q.put(new Job(processMessage(Arrays.copyOf(inbuf, p.getLength())), udp, p));\n+                } catch (InterruptedException e){\n+                    break; \/\/ Thread was stopped, so stopping the loop\n+                } catch (Exception e) {\n+                    e.printStackTrace();\n@@ -1566,1 +1566,1 @@\n-        };\n+        });\n@@ -1571,19 +1571,12 @@\n-        thread2 = new Thread() {\n-            public void run() {\n-                tcpConsumerReady = true;\n-                while (true) {\n-                    try {\n-                        Socket socket = tcp.accept();\n-                        System.out.println(\"-----------------------------------------------\");\n-                        System.out.println(\">>>>> TCP connection established\");\n-                        DataInputStream in = new DataInputStream(socket.getInputStream());\n-                        DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n-                        int len = in.readInt();\n-                        if (len > 65535) {\n-                            throw new Exception(\"Huge request not supported\");\n-                        }\n-                        byte[] token = new byte[len];\n-                        in.readFully(token);\n-                        q.put(new Job(processMessage(token), socket, out));\n-                    } catch (Exception e) {\n-                        e.printStackTrace();\n+        thread2 = new Thread(() -> {\n+            tcpConsumerReady = true;\n+            while (true) {\n+                try {\n+                    Socket socket = tcp.accept();\n+                    System.out.println(\"-----------------------------------------------\");\n+                    System.out.println(\">>>>> TCP connection established\");\n+                    DataInputStream in = new DataInputStream(socket.getInputStream());\n+                    DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n+                    int len = in.readInt();\n+                    if (len > 65535) {\n+                        throw new Exception(\"Huge request not supported\");\n@@ -1591,0 +1584,7 @@\n+                    byte[] token = new byte[len];\n+                    in.readFully(token);\n+                    q.put(new Job(processMessage(token), socket, out));\n+                } catch (InterruptedException e){\n+                    break; \/\/ Thread was stopped, so stopping the loop\n+                } catch (Exception e) {\n+                    e.printStackTrace();\n@@ -1593,1 +1593,1 @@\n-        };\n+        });\n@@ -1598,8 +1598,8 @@\n-        thread3 = new Thread() {\n-            public void run() {\n-                dispatcherReady = true;\n-                while (true) {\n-                    try {\n-                        q.take().send();\n-                    } catch (Exception e) {\n-                    }\n+        thread3 = new Thread(() -> {\n+            dispatcherReady = true;\n+            while (true) {\n+                try {\n+                    q.take().send();\n+                } catch (InterruptedException e){\n+                    break; \/\/ Thread was stopped, so stopping the loop\n+                } catch (Exception e) {\n@@ -1608,1 +1608,1 @@\n-        };\n+        });\n@@ -1649,3 +1649,3 @@\n-                thread1.stop();\n-                thread2.stop();\n-                thread3.stop();\n+                thread1.interrupt();\n+                thread2.interrupt();\n+                thread3.interrupt();\n","filename":"test\/jdk\/sun\/security\/krb5\/auto\/KDC.java","additions":48,"deletions":48,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -782,1 +782,6 @@\n-        Path p = ArtifactResolver.fetchOne(clazz);\n+        Path p;\n+        try {\n+            p = ArtifactResolver.fetchOne(clazz);\n+        } catch (IOException exc) {\n+            throw new SkippedException(\"Could not find NSS\", exc);\n+        }\n","filename":"test\/jdk\/sun\/security\/pkcs11\/PKCS11Test.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,496 @@\n+\/*\n+ * Copyright (c) 2019, Red Hat, Inc.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8029661 8325164 8368073 8368514\n+ * @summary Test TLS 1.2 and TLS 1.3\n+ * @modules java.base\/sun.security.internal.spec\n+ *          java.base\/sun.security.util\n+ *          java.base\/com.sun.crypto.provider\n+ * @library \/test\/lib ..\/..\n+ * @run main\/othervm\/timeout=120 -Djdk.tls.client.protocols=TLSv1.2\n+ *      -Djdk.tls.useExtendedMasterSecret=false\n+ *      -Djdk.tls.client.enableSessionTicketExtension=false FipsModeTLS\n+ * @comment SunPKCS11 does not support (TLS1.2) SunTlsExtendedMasterSecret yet.\n+ *   Stateless resumption doesn't currently work with NSS-FIPS, see JDK-8368669\n+ * @run main\/othervm\/timeout=120 -Djdk.tls.client.protocols=TLSv1.3 FipsModeTLS\n+ *\/\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+\n+import java.security.PrivateKey;\n+import java.security.PublicKey;\n+import java.security.KeyStore;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Provider;\n+import java.security.SecureRandom;\n+import java.security.Security;\n+\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.KDF;\n+import javax.crypto.KeyGenerator;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.SSLEngineResult;\n+import javax.net.ssl.SSLEngineResult.HandshakeStatus;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLSession;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+import jdk.test.lib.security.SecurityUtils;\n+import sun.security.internal.spec.TlsMasterSecretParameterSpec;\n+import sun.security.internal.spec.TlsPrfParameterSpec;\n+import sun.security.internal.spec.TlsRsaPremasterSecretParameterSpec;\n+\n+public final class FipsModeTLS extends SecmodTest {\n+\n+    private static final boolean enableDebug = true;\n+\n+    private static Provider sunPKCS11NSSProvider;\n+    private static Provider sunJCEProvider;\n+    private static KeyStore ks;\n+    private static KeyStore ts;\n+    private static char[] passphrase = \"JAHshj131@@\".toCharArray();\n+    private static PrivateKey privateKey;\n+    private static PublicKey publicKey;\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            initialize();\n+        } catch (Exception e) {\n+            System.out.println(\"Test skipped: failure during\" +\n+                    \" initialization\");\n+            if (enableDebug) {\n+                System.out.println(e);\n+            }\n+            return;\n+        }\n+\n+        if (shouldRun()) {\n+            \/\/ Test against JCE\n+            testTlsAuthenticationCodeGeneration();\n+\n+            \/\/ Self-integrity test (complete TLS communication)\n+            testTLSSunPKCS11Communication.initSslContext();\n+            testTLSSunPKCS11Communication.run();\n+\n+            System.out.println(\"Test PASS - OK\");\n+        } else {\n+            System.out.println(\"Test skipped: TLS 1.2 mechanisms\" +\n+                    \" not supported by current SunPKCS11 back-end\");\n+        }\n+    }\n+\n+    private static boolean shouldRun() {\n+        if (sunPKCS11NSSProvider == null) {\n+            return false;\n+        }\n+        try {\n+            String proto = System.getProperty(\"jdk.tls.client.protocols\");\n+            if (\"TLSv1.3\".equals(proto)) {\n+                KDF.getInstance(\"HKDF-SHA256\", sunPKCS11NSSProvider);\n+            } else {\n+                KeyGenerator.getInstance(\"SunTls12MasterSecret\",\n+                        sunPKCS11NSSProvider);\n+                KeyGenerator.getInstance(\n+                        \"SunTls12RsaPremasterSecret\", sunPKCS11NSSProvider);\n+                KeyGenerator.getInstance(\"SunTls12Prf\", sunPKCS11NSSProvider);\n+            }\n+        } catch (NoSuchAlgorithmException e) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private static void testTlsAuthenticationCodeGeneration()\n+            throws Exception {\n+        \/\/ Generate RSA Pre-Master Secret in SunPKCS11 provider\n+        SecretKey rsaPreMasterSecret = null;\n+        @SuppressWarnings(\"deprecation\")\n+        TlsRsaPremasterSecretParameterSpec rsaPreMasterSecretSpec =\n+                new TlsRsaPremasterSecretParameterSpec(0x0303, 0x0303);\n+        {\n+            KeyGenerator rsaPreMasterSecretKG = KeyGenerator.getInstance(\n+                    \"SunTls12RsaPremasterSecret\", sunPKCS11NSSProvider);\n+            rsaPreMasterSecretKG.init(rsaPreMasterSecretSpec, null);\n+            rsaPreMasterSecret = rsaPreMasterSecretKG.generateKey();\n+        }\n+\n+        \/\/ Get RSA Pre-Master Secret in plain (from SunPKCS11 provider)\n+        byte[] rsaPlainPreMasterSecret = null;\n+        {\n+            Cipher rsaPreMasterSecretWrapperCipher =\n+                    Cipher.getInstance(\"RSA\/ECB\/PKCS1Padding\",\n+                            sunPKCS11NSSProvider);\n+            rsaPreMasterSecretWrapperCipher.init(Cipher.WRAP_MODE, publicKey,\n+                    new SecureRandom());\n+            byte[] rsaEncryptedPreMasterSecret =\n+                    rsaPreMasterSecretWrapperCipher.wrap(rsaPreMasterSecret);\n+            Cipher rsaPreMasterSecretUnwrapperCipher =\n+                    Cipher.getInstance(\"RSA\/ECB\/PKCS1Padding\", sunJCEProvider);\n+            rsaPreMasterSecretUnwrapperCipher.init(Cipher.UNWRAP_MODE,\n+                    privateKey, rsaPreMasterSecretSpec);\n+            rsaPlainPreMasterSecret = rsaPreMasterSecretUnwrapperCipher.unwrap(\n+                    rsaEncryptedPreMasterSecret, \"TlsRsaPremasterSecret\",\n+                    Cipher.SECRET_KEY).getEncoded();\n+\n+            if (enableDebug) {\n+                System.out.println(\"rsaPlainPreMasterSecret:\");\n+                for (byte b : rsaPlainPreMasterSecret) {\n+                    System.out.printf(\"%02X, \", b);\n+                }\n+                System.out.println(\"\");\n+            }\n+        }\n+\n+        \/\/ Generate Master Secret\n+        SecretKey sunPKCS11MasterSecret = null;\n+        SecretKey jceMasterSecret = null;\n+        {\n+            KeyGenerator sunPKCS11MasterSecretGenerator =\n+                    KeyGenerator.getInstance(\"SunTls12MasterSecret\",\n+                            sunPKCS11NSSProvider);\n+            KeyGenerator jceMasterSecretGenerator = KeyGenerator.getInstance(\n+                    \"SunTls12MasterSecret\", sunJCEProvider);\n+            @SuppressWarnings(\"deprecation\")\n+            TlsMasterSecretParameterSpec sunPKCS11MasterSecretSpec =\n+                    new TlsMasterSecretParameterSpec(rsaPreMasterSecret, 3, 3,\n+                            new byte[32], new byte[32], \"SHA-256\", 32, 64);\n+            @SuppressWarnings(\"deprecation\")\n+            TlsMasterSecretParameterSpec jceMasterSecretSpec =\n+                    new TlsMasterSecretParameterSpec(\n+                            new SecretKeySpec(rsaPlainPreMasterSecret,\n+                                    \"Generic\"), 3, 3, new byte[32],\n+                            new byte[32], \"SHA-256\", 32, 64);\n+            sunPKCS11MasterSecretGenerator.init(sunPKCS11MasterSecretSpec,\n+                    null);\n+            jceMasterSecretGenerator.init(jceMasterSecretSpec, null);\n+            sunPKCS11MasterSecret =\n+                    sunPKCS11MasterSecretGenerator.generateKey();\n+            jceMasterSecret = jceMasterSecretGenerator.generateKey();\n+            if (enableDebug) {\n+                System.out.println(\"Master Secret (SunJCE):\");\n+                if (jceMasterSecret != null) {\n+                    for (byte b : jceMasterSecret.getEncoded()) {\n+                        System.out.printf(\"%02X, \", b);\n+                    }\n+                    System.out.println(\"\");\n+                }\n+            }\n+        }\n+\n+        \/\/ Generate authentication codes\n+        byte[] sunPKCS11AuthenticationCode = null;\n+        byte[] jceAuthenticationCode = null;\n+        {\n+            \/\/ Generate SunPKCS11 authentication code\n+            {\n+                @SuppressWarnings(\"deprecation\")\n+                TlsPrfParameterSpec sunPKCS11AuthenticationCodeSpec =\n+                        new TlsPrfParameterSpec(sunPKCS11MasterSecret,\n+                                \"client finished\", \"a\".getBytes(), 12,\n+                                \"SHA-256\", 32, 64);\n+                KeyGenerator sunPKCS11AuthCodeGenerator =\n+                        KeyGenerator.getInstance(\"SunTls12Prf\",\n+                                sunPKCS11NSSProvider);\n+                sunPKCS11AuthCodeGenerator.init(\n+                        sunPKCS11AuthenticationCodeSpec);\n+                sunPKCS11AuthenticationCode =\n+                        sunPKCS11AuthCodeGenerator.generateKey().getEncoded();\n+            }\n+\n+            \/\/ Generate SunJCE authentication code\n+            {\n+                @SuppressWarnings(\"deprecation\")\n+                TlsPrfParameterSpec jceAuthenticationCodeSpec =\n+                        new TlsPrfParameterSpec(jceMasterSecret,\n+                                \"client finished\", \"a\".getBytes(), 12,\n+                                \"SHA-256\", 32, 64);\n+                KeyGenerator jceAuthCodeGenerator =\n+                        KeyGenerator.getInstance(\"SunTls12Prf\",\n+                                sunJCEProvider);\n+                jceAuthCodeGenerator.init(jceAuthenticationCodeSpec);\n+                jceAuthenticationCode =\n+                        jceAuthCodeGenerator.generateKey().getEncoded();\n+            }\n+\n+            if (enableDebug) {\n+                System.out.println(\"SunPKCS11 Authentication Code: \");\n+                for (byte b : sunPKCS11AuthenticationCode) {\n+                    System.out.printf(\"%02X, \", b);\n+                }\n+                System.out.println(\"\");\n+                System.out.println(\"SunJCE Authentication Code: \");\n+                for (byte b : jceAuthenticationCode) {\n+                    System.out.printf(\"%02X, \", b);\n+                }\n+                System.out.println(\"\");\n+            }\n+        }\n+\n+        if (sunPKCS11AuthenticationCode == null ||\n+                jceAuthenticationCode == null ||\n+                sunPKCS11AuthenticationCode.length == 0 ||\n+                jceAuthenticationCode.length == 0 ||\n+                !Arrays.equals(sunPKCS11AuthenticationCode,\n+                        jceAuthenticationCode)) {\n+            throw new Exception(\"Authentication codes from JCE\" +\n+                        \" and SunPKCS11 differ.\");\n+        }\n+    }\n+\n+    private static class testTLSSunPKCS11Communication {\n+        public static void run() throws Exception {\n+            SSLEngine[][] enginesToTest = getSSLEnginesToTest();\n+            boolean firstSession = true;\n+            for (SSLEngine[] engineToTest : enginesToTest) {\n+\n+                SSLEngine clientSSLEngine = engineToTest[0];\n+                SSLEngine serverSSLEngine = engineToTest[1];\n+                \/\/ The first connection needs to do a full handshake.\n+                \/\/ Verify that subsequent handshakes use resumption.\n+                clientSSLEngine.setEnableSessionCreation(firstSession);\n+                firstSession = false;\n+                \/\/ SSLEngine code based on RedhandshakeFinished.java\n+\n+                boolean dataDone = false;\n+\n+                ByteBuffer clientOut = null;\n+                ByteBuffer clientIn = null;\n+                ByteBuffer serverOut = null;\n+                ByteBuffer serverIn = null;\n+                ByteBuffer cTOs;\n+                ByteBuffer sTOc;\n+\n+                SSLSession session = clientSSLEngine.getSession();\n+                int appBufferMax = session.getApplicationBufferSize();\n+                int netBufferMax = session.getPacketBufferSize();\n+\n+                clientIn = ByteBuffer.allocate(appBufferMax + 50);\n+                serverIn = ByteBuffer.allocate(appBufferMax + 50);\n+\n+                cTOs = ByteBuffer.allocateDirect(netBufferMax);\n+                sTOc = ByteBuffer.allocateDirect(netBufferMax);\n+\n+                clientOut = ByteBuffer.wrap(\n+                        \"Hi Server, I'm Client\".getBytes());\n+                serverOut = ByteBuffer.wrap(\n+                        \"Hello Client, I'm Server\".getBytes());\n+\n+                SSLEngineResult clientResult;\n+                SSLEngineResult serverResult;\n+\n+                while (!dataDone) {\n+                    clientResult = clientSSLEngine.wrap(clientOut, cTOs);\n+                    runDelegatedTasks(clientResult, clientSSLEngine);\n+                    serverResult = serverSSLEngine.wrap(serverOut, sTOc);\n+                    runDelegatedTasks(serverResult, serverSSLEngine);\n+                    cTOs.flip();\n+                    sTOc.flip();\n+\n+                    if (enableDebug) {\n+                        System.out.println(\"Client -> Network\");\n+                        printTlsNetworkPacket(\"\", cTOs);\n+                        System.out.println(\"\");\n+                        System.out.println(\"Server -> Network\");\n+                        printTlsNetworkPacket(\"\", sTOc);\n+                        System.out.println(\"\");\n+                    }\n+\n+                    clientResult = clientSSLEngine.unwrap(sTOc, clientIn);\n+                    runDelegatedTasks(clientResult, clientSSLEngine);\n+                    serverResult = serverSSLEngine.unwrap(cTOs, serverIn);\n+                    runDelegatedTasks(serverResult, serverSSLEngine);\n+\n+                    cTOs.compact();\n+                    sTOc.compact();\n+\n+                    if (!dataDone &&\n+                            (clientOut.limit() == serverIn.position()) &&\n+                            (serverOut.limit() == clientIn.position())) {\n+                        checkTransfer(serverOut, clientIn);\n+                        checkTransfer(clientOut, serverIn);\n+                        dataDone = true;\n+                    }\n+                }\n+            }\n+        }\n+\n+        static void printTlsNetworkPacket(String prefix, ByteBuffer bb) {\n+            ByteBuffer slice = bb.slice();\n+            byte[] buffer = new byte[slice.remaining()];\n+            slice.get(buffer);\n+            for (int i = 0; i < buffer.length; i++) {\n+                System.out.printf(\"%02X, \", (byte)(buffer[i] & (byte)0xFF));\n+                if (i % 8 == 0 && i % 16 != 0) {\n+                    System.out.print(\" \");\n+                }\n+                if (i % 16 == 0) {\n+                    System.out.println(\"\");\n+                }\n+            }\n+            System.out.flush();\n+        }\n+\n+        private static void checkTransfer(ByteBuffer a, ByteBuffer b)\n+                throws Exception {\n+            a.flip();\n+            b.flip();\n+            if (!a.equals(b)) {\n+                throw new Exception(\"Data didn't transfer cleanly\");\n+            }\n+            a.position(a.limit());\n+            b.position(b.limit());\n+            a.limit(a.capacity());\n+            b.limit(b.capacity());\n+        }\n+\n+        private static void runDelegatedTasks(SSLEngineResult result,\n+                SSLEngine engine) throws Exception {\n+\n+            if (result.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n+                Runnable runnable;\n+                while ((runnable = engine.getDelegatedTask()) != null) {\n+                    runnable.run();\n+                }\n+                HandshakeStatus hsStatus = engine.getHandshakeStatus();\n+                if (hsStatus == HandshakeStatus.NEED_TASK) {\n+                    throw new Exception(\n+                        \"handshake shouldn't need additional tasks\");\n+                }\n+            }\n+        }\n+\n+        private static SSLEngine[][] getSSLEnginesToTest() throws Exception {\n+            SSLEngine[][] enginesToTest = new SSLEngine[2][2];\n+            for (int i = 0; i < enginesToTest.length; i++) {\n+                enginesToTest[i][0] = createSSLEngine(true);\n+                enginesToTest[i][1] = createSSLEngine(false);\n+            }\n+            return enginesToTest;\n+        }\n+\n+        static private SSLEngine createSSLEngine(boolean client)\n+                throws Exception {\n+            SSLEngine ssle;\n+            ssle = sslCtx.createSSLEngine(\"localhost\", 443);\n+            ssle.setUseClientMode(client);\n+            SSLParameters sslParameters = ssle.getSSLParameters();\n+            \/\/ verify that FFDHE named groups are available\n+            String[] namedGroups = sslParameters.getNamedGroups();\n+            boolean ffdheAvailable = Arrays.stream(namedGroups)\n+                    .anyMatch(ng -> ng.startsWith(\"ffdhe\"));\n+            if (!ffdheAvailable) {\n+                throw new RuntimeException(\"No FFDHE named groups available\");\n+            }\n+            \/\/ verify that ECDHE named groups are available\n+            boolean ecdheAvailable = Arrays.stream(namedGroups)\n+                    .anyMatch(ng -> ng.startsWith(\"secp\"));\n+            if (!ecdheAvailable) {\n+                throw new RuntimeException(\"No ECDHE named groups available\");\n+            }\n+            \/\/ remove XDH named groups - not available in PKCS11\n+            namedGroups = Arrays.stream(namedGroups).filter(s-> !s.startsWith(\"x\")).toArray(String[]::new);\n+            sslParameters.setNamedGroups(namedGroups);\n+            ssle.setSSLParameters(sslParameters);\n+\n+            return ssle;\n+        }\n+\n+        private static SSLContext sslCtx;\n+        private static void initSslContext() throws Exception {\n+            KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"PKIX\", \"SunJSSE\");\n+            kmf.init(ks, passphrase);\n+\n+            TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"PKIX\", \"SunJSSE\");\n+            tmf.init(ts);\n+\n+            sslCtx = SSLContext.getInstance(\"TLS\", \"SunJSSE\");\n+            sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n+        }\n+    }\n+\n+    private static void initialize() throws Exception {\n+        \/\/\n+        \/\/ For a successful FIPS-mode TLS connection, the following\n+        \/\/ cryptographic providers will be installed:\n+        \/\/\n+        \/\/  1. SunPKCS11 (with an NSS FIPS mode backend)\n+        \/\/  2. SUN (to handle X.509 certificates)\n+        \/\/  3. SunJSSE (for a TLS engine)\n+\n+        if (initSecmod() == false) {\n+            return;\n+        }\n+        String configName = BASE + SEP + \"nss.cfg\";\n+        sunPKCS11NSSProvider = getSunPKCS11(configName);\n+        System.out.println(\"SunPKCS11 provider: \" + sunPKCS11NSSProvider);\n+\n+        List<Provider> installedProviders = new LinkedList<>();\n+        for (Provider p : Security.getProviders()){\n+            installedProviders.add(p);\n+            Security.removeProvider(p.getName());\n+        }\n+        Security.addProvider(sunPKCS11NSSProvider);\n+        for (Provider p : installedProviders){\n+            String providerName = p.getName();\n+            if (providerName.equals(\"SunJSSE\") || providerName.equals(\"SUN\")) {\n+                Security.addProvider(p);\n+            } else if (providerName.equals(\"SunJCE\")) {\n+                sunJCEProvider = p;\n+            }\n+        }\n+\n+        ks = KeyStore.getInstance(\"PKCS11\", sunPKCS11NSSProvider);\n+        ks.load(null, \"test12\".toCharArray());\n+        ts = ks;\n+\n+        KeyStore ksPlain = readTestKeyStore();\n+        privateKey = (PrivateKey)ksPlain.getKey(\"rh_rsa_sha256\",\n+                passphrase);\n+        publicKey = (PublicKey)ksPlain.getCertificate(\n+                \"rh_rsa_sha256\").getPublicKey();\n+    }\n+\n+    private static KeyStore readTestKeyStore() throws Exception {\n+        File file = new File(System.getProperty(\"test.src\", \".\"), \"keystore\");\n+        InputStream in = new FileInputStream(file);\n+        KeyStore ks = KeyStore.getInstance(\"JKS\");\n+        ks.load(in, \"passphrase\".toCharArray());\n+        in.close();\n+        return ks;\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/tls\/fips\/FipsModeTLS.java","additions":496,"deletions":0,"binary":false,"changes":496,"status":"added"},{"patch":"","filename":"test\/jdk\/sun\/security\/pkcs11\/tls\/fips\/cert8.db","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/pkcs11\/tls\/tls12\/cert8.db","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/pkcs11\/tls\/fips\/cert9.db","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/pkcs11\/tls\/tls12\/cert9.db","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/pkcs11\/tls\/fips\/key3.db","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/pkcs11\/tls\/tls12\/key3.db","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/pkcs11\/tls\/fips\/key4.db","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/pkcs11\/tls\/tls12\/key4.db","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/pkcs11\/tls\/fips\/keystore","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/pkcs11\/tls\/tls12\/keystore","status":"renamed"},{"patch":"@@ -0,0 +1,27 @@\n+\n+name = NSSKeyStore\n+\n+nssSecmodDirectory = ${pkcs11test.nss.db}\n+\n+nssLibraryDirectory = ${pkcs11test.nss.libdir}\n+\n+nssModule = fips\n+\n+# NSS-FIPS needs sensitive=true for key extraction.\n+# TLS 1.3 needs CKA_SIGN to sign the Finished message.\n+\n+attributes(*,CKO_SECRET_KEY,CKK_GENERIC_SECRET) = {\n+  CKA_SIGN = true\n+  CKA_SENSITIVE=true\n+}\n+\n+# NSS needs CKA_NETSCAPE_DB for DSA and DH private keys\n+# just put an arbitrary value in there to make it happy\n+\n+attributes(*,CKO_PRIVATE_KEY,CKK_DSA) = {\n+  CKA_NETSCAPE_DB = 0h00\n+}\n+\n+attributes(*,CKO_PRIVATE_KEY,CKK_DH) = {\n+  CKA_NETSCAPE_DB = 0h00\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/tls\/fips\/nss.cfg","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"","filename":"test\/jdk\/sun\/security\/pkcs11\/tls\/fips\/pkcs11.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/pkcs11\/tls\/tls12\/pkcs11.txt","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/pkcs11\/tls\/fips\/secmod.db","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/pkcs11\/tls\/tls12\/secmod.db","status":"renamed"},{"patch":"@@ -1,488 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Red Hat, Inc.\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8029661 8325164\n- * @summary Test TLS 1.2\n- * @modules java.base\/sun.security.internal.spec\n- *          java.base\/sun.security.util\n- *          java.base\/com.sun.crypto.provider\n- * @library \/test\/lib ..\/..\n- * @run main\/othervm\/timeout=120 -Djdk.tls.useExtendedMasterSecret=false FipsModeTLS12\n- *\/\n-\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.InputStream;\n-import java.nio.ByteBuffer;\n-\n-import java.security.PrivateKey;\n-import java.security.PublicKey;\n-import java.security.KeyStore;\n-import java.security.NoSuchAlgorithmException;\n-import java.security.Provider;\n-import java.security.SecureRandom;\n-import java.security.Security;\n-\n-import java.util.Arrays;\n-import java.util.LinkedList;\n-import java.util.List;\n-\n-import javax.crypto.Cipher;\n-import javax.crypto.KeyGenerator;\n-import javax.crypto.SecretKey;\n-import javax.crypto.spec.SecretKeySpec;\n-\n-import javax.net.ssl.KeyManagerFactory;\n-import javax.net.ssl.SSLContext;\n-import javax.net.ssl.SSLEngine;\n-import javax.net.ssl.SSLEngineResult;\n-import javax.net.ssl.SSLEngineResult.HandshakeStatus;\n-import javax.net.ssl.SSLParameters;\n-import javax.net.ssl.SSLSession;\n-import javax.net.ssl.TrustManagerFactory;\n-\n-import jdk.test.lib.security.SecurityUtils;\n-import sun.security.internal.spec.TlsMasterSecretParameterSpec;\n-import sun.security.internal.spec.TlsPrfParameterSpec;\n-import sun.security.internal.spec.TlsRsaPremasterSecretParameterSpec;\n-\n-public final class FipsModeTLS12 extends SecmodTest {\n-\n-    private static final boolean enableDebug = true;\n-\n-    private static Provider sunPKCS11NSSProvider;\n-    private static Provider sunJCEProvider;\n-    private static KeyStore ks;\n-    private static KeyStore ts;\n-    private static char[] passphrase = \"JAHshj131@@\".toCharArray();\n-    private static PrivateKey privateKey;\n-    private static PublicKey publicKey;\n-\n-    public static void main(String[] args) throws Exception {\n-        \/\/ Re-enable TLS_RSA_* since test depends on it.\n-        SecurityUtils.removeFromDisabledTlsAlgs(\"TLS_RSA_*\");\n-\n-        try {\n-            initialize();\n-        } catch (Exception e) {\n-            System.out.println(\"Test skipped: failure during\" +\n-                    \" initialization\");\n-            if (enableDebug) {\n-                System.out.println(e);\n-            }\n-            return;\n-        }\n-\n-        if (shouldRun()) {\n-            \/\/ Test against JCE\n-            testTlsAuthenticationCodeGeneration();\n-\n-            \/\/ Self-integrity test (complete TLS 1.2 communication)\n-            new testTLS12SunPKCS11Communication().run();\n-\n-            System.out.println(\"Test PASS - OK\");\n-        } else {\n-            System.out.println(\"Test skipped: TLS 1.2 mechanisms\" +\n-                    \" not supported by current SunPKCS11 back-end\");\n-        }\n-    }\n-\n-    private static boolean shouldRun() {\n-        if (sunPKCS11NSSProvider == null) {\n-            return false;\n-        }\n-        try {\n-            KeyGenerator.getInstance(\"SunTls12MasterSecret\",\n-                    sunPKCS11NSSProvider);\n-            KeyGenerator.getInstance(\n-                    \"SunTls12RsaPremasterSecret\", sunPKCS11NSSProvider);\n-            KeyGenerator.getInstance(\"SunTls12Prf\", sunPKCS11NSSProvider);\n-        } catch (NoSuchAlgorithmException e) {\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    private static void testTlsAuthenticationCodeGeneration()\n-            throws Exception {\n-        \/\/ Generate RSA Pre-Master Secret in SunPKCS11 provider\n-        SecretKey rsaPreMasterSecret = null;\n-        @SuppressWarnings(\"deprecation\")\n-        TlsRsaPremasterSecretParameterSpec rsaPreMasterSecretSpec =\n-                new TlsRsaPremasterSecretParameterSpec(0x0303, 0x0303);\n-        {\n-            KeyGenerator rsaPreMasterSecretKG = KeyGenerator.getInstance(\n-                    \"SunTls12RsaPremasterSecret\", sunPKCS11NSSProvider);\n-            rsaPreMasterSecretKG.init(rsaPreMasterSecretSpec, null);\n-            rsaPreMasterSecret = rsaPreMasterSecretKG.generateKey();\n-        }\n-\n-        \/\/ Get RSA Pre-Master Secret in plain (from SunPKCS11 provider)\n-        byte[] rsaPlainPreMasterSecret = null;\n-        {\n-            Cipher rsaPreMasterSecretWrapperCipher =\n-                    Cipher.getInstance(\"RSA\/ECB\/PKCS1Padding\",\n-                            sunPKCS11NSSProvider);\n-            rsaPreMasterSecretWrapperCipher.init(Cipher.WRAP_MODE, publicKey,\n-                    new SecureRandom());\n-            byte[] rsaEncryptedPreMasterSecret =\n-                    rsaPreMasterSecretWrapperCipher.wrap(rsaPreMasterSecret);\n-            Cipher rsaPreMasterSecretUnwrapperCipher =\n-                    Cipher.getInstance(\"RSA\/ECB\/PKCS1Padding\", sunJCEProvider);\n-            rsaPreMasterSecretUnwrapperCipher.init(Cipher.UNWRAP_MODE,\n-                    privateKey, rsaPreMasterSecretSpec);\n-            rsaPlainPreMasterSecret = rsaPreMasterSecretUnwrapperCipher.unwrap(\n-                    rsaEncryptedPreMasterSecret, \"TlsRsaPremasterSecret\",\n-                    Cipher.SECRET_KEY).getEncoded();\n-\n-            if (enableDebug) {\n-                System.out.println(\"rsaPlainPreMasterSecret:\");\n-                for (byte b : rsaPlainPreMasterSecret) {\n-                    System.out.printf(\"%02X, \", b);\n-                }\n-                System.out.println(\"\");\n-            }\n-        }\n-\n-        \/\/ Generate Master Secret\n-        SecretKey sunPKCS11MasterSecret = null;\n-        SecretKey jceMasterSecret = null;\n-        {\n-            KeyGenerator sunPKCS11MasterSecretGenerator =\n-                    KeyGenerator.getInstance(\"SunTls12MasterSecret\",\n-                            sunPKCS11NSSProvider);\n-            KeyGenerator jceMasterSecretGenerator = KeyGenerator.getInstance(\n-                    \"SunTls12MasterSecret\", sunJCEProvider);\n-            @SuppressWarnings(\"deprecation\")\n-            TlsMasterSecretParameterSpec sunPKCS11MasterSecretSpec =\n-                    new TlsMasterSecretParameterSpec(rsaPreMasterSecret, 3, 3,\n-                            new byte[32], new byte[32], \"SHA-256\", 32, 64);\n-            @SuppressWarnings(\"deprecation\")\n-            TlsMasterSecretParameterSpec jceMasterSecretSpec =\n-                    new TlsMasterSecretParameterSpec(\n-                            new SecretKeySpec(rsaPlainPreMasterSecret,\n-                                    \"Generic\"), 3, 3, new byte[32],\n-                            new byte[32], \"SHA-256\", 32, 64);\n-            sunPKCS11MasterSecretGenerator.init(sunPKCS11MasterSecretSpec,\n-                    null);\n-            jceMasterSecretGenerator.init(jceMasterSecretSpec, null);\n-            sunPKCS11MasterSecret =\n-                    sunPKCS11MasterSecretGenerator.generateKey();\n-            jceMasterSecret = jceMasterSecretGenerator.generateKey();\n-            if (enableDebug) {\n-                System.out.println(\"Master Secret (SunJCE):\");\n-                if (jceMasterSecret != null) {\n-                    for (byte b : jceMasterSecret.getEncoded()) {\n-                        System.out.printf(\"%02X, \", b);\n-                    }\n-                    System.out.println(\"\");\n-                }\n-            }\n-        }\n-\n-        \/\/ Generate authentication codes\n-        byte[] sunPKCS11AuthenticationCode = null;\n-        byte[] jceAuthenticationCode = null;\n-        {\n-            \/\/ Generate SunPKCS11 authentication code\n-            {\n-                @SuppressWarnings(\"deprecation\")\n-                TlsPrfParameterSpec sunPKCS11AuthenticationCodeSpec =\n-                        new TlsPrfParameterSpec(sunPKCS11MasterSecret,\n-                                \"client finished\", \"a\".getBytes(), 12,\n-                                \"SHA-256\", 32, 64);\n-                KeyGenerator sunPKCS11AuthCodeGenerator =\n-                        KeyGenerator.getInstance(\"SunTls12Prf\",\n-                                sunPKCS11NSSProvider);\n-                sunPKCS11AuthCodeGenerator.init(\n-                        sunPKCS11AuthenticationCodeSpec);\n-                sunPKCS11AuthenticationCode =\n-                        sunPKCS11AuthCodeGenerator.generateKey().getEncoded();\n-            }\n-\n-            \/\/ Generate SunJCE authentication code\n-            {\n-                @SuppressWarnings(\"deprecation\")\n-                TlsPrfParameterSpec jceAuthenticationCodeSpec =\n-                        new TlsPrfParameterSpec(jceMasterSecret,\n-                                \"client finished\", \"a\".getBytes(), 12,\n-                                \"SHA-256\", 32, 64);\n-                KeyGenerator jceAuthCodeGenerator =\n-                        KeyGenerator.getInstance(\"SunTls12Prf\",\n-                                sunJCEProvider);\n-                jceAuthCodeGenerator.init(jceAuthenticationCodeSpec);\n-                jceAuthenticationCode =\n-                        jceAuthCodeGenerator.generateKey().getEncoded();\n-            }\n-\n-            if (enableDebug) {\n-                System.out.println(\"SunPKCS11 Authentication Code: \");\n-                for (byte b : sunPKCS11AuthenticationCode) {\n-                    System.out.printf(\"%02X, \", b);\n-                }\n-                System.out.println(\"\");\n-                System.out.println(\"SunJCE Authentication Code: \");\n-                for (byte b : jceAuthenticationCode) {\n-                    System.out.printf(\"%02X, \", b);\n-                }\n-                System.out.println(\"\");\n-            }\n-        }\n-\n-        if (sunPKCS11AuthenticationCode == null ||\n-                jceAuthenticationCode == null ||\n-                sunPKCS11AuthenticationCode.length == 0 ||\n-                jceAuthenticationCode.length == 0 ||\n-                !Arrays.equals(sunPKCS11AuthenticationCode,\n-                        jceAuthenticationCode)) {\n-            throw new Exception(\"Authentication codes from JCE\" +\n-                        \" and SunPKCS11 differ.\");\n-        }\n-    }\n-\n-    private static class testTLS12SunPKCS11Communication {\n-        public static void run() throws Exception {\n-            SSLEngine[][] enginesToTest = getSSLEnginesToTest();\n-\n-            for (SSLEngine[] engineToTest : enginesToTest) {\n-\n-                SSLEngine clientSSLEngine = engineToTest[0];\n-                SSLEngine serverSSLEngine = engineToTest[1];\n-\n-                \/\/ SSLEngine code based on RedhandshakeFinished.java\n-\n-                boolean dataDone = false;\n-\n-                ByteBuffer clientOut = null;\n-                ByteBuffer clientIn = null;\n-                ByteBuffer serverOut = null;\n-                ByteBuffer serverIn = null;\n-                ByteBuffer cTOs;\n-                ByteBuffer sTOc;\n-\n-                SSLSession session = clientSSLEngine.getSession();\n-                int appBufferMax = session.getApplicationBufferSize();\n-                int netBufferMax = session.getPacketBufferSize();\n-\n-                clientIn = ByteBuffer.allocate(appBufferMax + 50);\n-                serverIn = ByteBuffer.allocate(appBufferMax + 50);\n-\n-                cTOs = ByteBuffer.allocateDirect(netBufferMax);\n-                sTOc = ByteBuffer.allocateDirect(netBufferMax);\n-\n-                clientOut = ByteBuffer.wrap(\n-                        \"Hi Server, I'm Client\".getBytes());\n-                serverOut = ByteBuffer.wrap(\n-                        \"Hello Client, I'm Server\".getBytes());\n-\n-                SSLEngineResult clientResult;\n-                SSLEngineResult serverResult;\n-\n-                while (!dataDone) {\n-                    clientResult = clientSSLEngine.wrap(clientOut, cTOs);\n-                    runDelegatedTasks(clientResult, clientSSLEngine);\n-                    serverResult = serverSSLEngine.wrap(serverOut, sTOc);\n-                    runDelegatedTasks(serverResult, serverSSLEngine);\n-                    cTOs.flip();\n-                    sTOc.flip();\n-\n-                    if (enableDebug) {\n-                        System.out.println(\"Client -> Network\");\n-                        printTlsNetworkPacket(\"\", cTOs);\n-                        System.out.println(\"\");\n-                        System.out.println(\"Server -> Network\");\n-                        printTlsNetworkPacket(\"\", sTOc);\n-                        System.out.println(\"\");\n-                    }\n-\n-                    clientResult = clientSSLEngine.unwrap(sTOc, clientIn);\n-                    runDelegatedTasks(clientResult, clientSSLEngine);\n-                    serverResult = serverSSLEngine.unwrap(cTOs, serverIn);\n-                    runDelegatedTasks(serverResult, serverSSLEngine);\n-\n-                    cTOs.compact();\n-                    sTOc.compact();\n-\n-                    if (!dataDone &&\n-                            (clientOut.limit() == serverIn.position()) &&\n-                            (serverOut.limit() == clientIn.position())) {\n-                        checkTransfer(serverOut, clientIn);\n-                        checkTransfer(clientOut, serverIn);\n-                        dataDone = true;\n-                    }\n-                }\n-            }\n-        }\n-\n-        static void printTlsNetworkPacket(String prefix, ByteBuffer bb) {\n-            ByteBuffer slice = bb.slice();\n-            byte[] buffer = new byte[slice.remaining()];\n-            slice.get(buffer);\n-            for (int i = 0; i < buffer.length; i++) {\n-                System.out.printf(\"%02X, \", (byte)(buffer[i] & (byte)0xFF));\n-                if (i % 8 == 0 && i % 16 != 0) {\n-                    System.out.print(\" \");\n-                }\n-                if (i % 16 == 0) {\n-                    System.out.println(\"\");\n-                }\n-            }\n-            System.out.flush();\n-        }\n-\n-        private static void checkTransfer(ByteBuffer a, ByteBuffer b)\n-                throws Exception {\n-            a.flip();\n-            b.flip();\n-            if (!a.equals(b)) {\n-                throw new Exception(\"Data didn't transfer cleanly\");\n-            }\n-            a.position(a.limit());\n-            b.position(b.limit());\n-            a.limit(a.capacity());\n-            b.limit(b.capacity());\n-        }\n-\n-        private static void runDelegatedTasks(SSLEngineResult result,\n-                SSLEngine engine) throws Exception {\n-\n-            if (result.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n-                Runnable runnable;\n-                while ((runnable = engine.getDelegatedTask()) != null) {\n-                    runnable.run();\n-                }\n-                HandshakeStatus hsStatus = engine.getHandshakeStatus();\n-                if (hsStatus == HandshakeStatus.NEED_TASK) {\n-                    throw new Exception(\n-                        \"handshake shouldn't need additional tasks\");\n-                }\n-            }\n-        }\n-\n-        private static SSLEngine[][] getSSLEnginesToTest() throws Exception {\n-            SSLEngine[][] enginesToTest = new SSLEngine[2][2];\n-            \/\/ TLS_RSA_WITH_AES_128_GCM_SHA256 ciphersuite is available but\n-            \/\/ must not be chosen for the TLS connection if not supported.\n-            \/\/ See JDK-8222937.\n-            String[][] preferredSuites = new String[][]{ new String[] {\n-                    \"TLS_RSA_WITH_AES_128_GCM_SHA256\",\n-                    \"TLS_RSA_WITH_AES_128_CBC_SHA256\"\n-            },  new String[] {\n-                    \"TLS_RSA_WITH_AES_128_GCM_SHA256\",\n-                    \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA256\"\n-            }};\n-            for (int i = 0; i < enginesToTest.length; i++) {\n-                enginesToTest[i][0] = createSSLEngine(true);\n-                enginesToTest[i][1] = createSSLEngine(false);\n-                \/\/ All CipherSuites enabled for the client.\n-                enginesToTest[i][1].setEnabledCipherSuites(preferredSuites[i]);\n-            }\n-            return enginesToTest;\n-        }\n-\n-        static private SSLEngine createSSLEngine(boolean client)\n-                throws Exception {\n-            SSLEngine ssle;\n-            KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"PKIX\", \"SunJSSE\");\n-            kmf.init(ks, passphrase);\n-\n-            TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"PKIX\", \"SunJSSE\");\n-            tmf.init(ts);\n-\n-            SSLContext sslCtx = SSLContext.getInstance(\"TLSv1.2\", \"SunJSSE\");\n-            sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n-            ssle = sslCtx.createSSLEngine(\"localhost\", 443);\n-            ssle.setUseClientMode(client);\n-            SSLParameters sslParameters = ssle.getSSLParameters();\n-            \/\/ verify that FFDHE named groups are available\n-            boolean ffdheAvailable = Arrays.stream(sslParameters.getNamedGroups())\n-                    .anyMatch(ng -> ng.startsWith(\"ffdhe\"));\n-            if (!ffdheAvailable) {\n-                throw new RuntimeException(\"No FFDHE named groups available\");\n-            }\n-            \/\/ verify that ECDHE named groups are available\n-            boolean ecdheAvailable = Arrays.stream(sslParameters.getNamedGroups())\n-                    .anyMatch(ng -> ng.startsWith(\"secp\"));\n-            if (!ecdheAvailable) {\n-                throw new RuntimeException(\"No ECDHE named groups available\");\n-            }\n-            ssle.setSSLParameters(sslParameters);\n-\n-            return ssle;\n-        }\n-    }\n-\n-    private static void initialize() throws Exception {\n-        \/\/\n-        \/\/ For a successful FIPS-mode TLS connection, the following\n-        \/\/ cryptographic providers will be installed:\n-        \/\/\n-        \/\/  1. SunPKCS11 (with an NSS FIPS mode backend)\n-        \/\/  2. SUN (to handle X.509 certificates)\n-        \/\/  3. SunJSSE (for a TLS engine)\n-\n-        if (initSecmod() == false) {\n-            return;\n-        }\n-        String configName = BASE + SEP + \"nss.cfg\";\n-        sunPKCS11NSSProvider = getSunPKCS11(configName);\n-        System.out.println(\"SunPKCS11 provider: \" + sunPKCS11NSSProvider);\n-\n-        List<Provider> installedProviders = new LinkedList<>();\n-        for (Provider p : Security.getProviders()){\n-            installedProviders.add(p);\n-            Security.removeProvider(p.getName());\n-        }\n-        Security.addProvider(sunPKCS11NSSProvider);\n-        for (Provider p : installedProviders){\n-            String providerName = p.getName();\n-            if (providerName.equals(\"SunJSSE\") || providerName.equals(\"SUN\")) {\n-                Security.addProvider(p);\n-            } else if (providerName.equals(\"SunJCE\")) {\n-                sunJCEProvider = p;\n-            }\n-        }\n-\n-        ks = KeyStore.getInstance(\"PKCS11\", sunPKCS11NSSProvider);\n-        ks.load(null, \"test12\".toCharArray());\n-        ts = ks;\n-\n-        KeyStore ksPlain = readTestKeyStore();\n-        privateKey = (PrivateKey)ksPlain.getKey(\"rh_rsa_sha256\",\n-                passphrase);\n-        publicKey = (PublicKey)ksPlain.getCertificate(\n-                \"rh_rsa_sha256\").getPublicKey();\n-    }\n-\n-    private static KeyStore readTestKeyStore() throws Exception {\n-        File file = new File(System.getProperty(\"test.src\", \".\"), \"keystore\");\n-        InputStream in = new FileInputStream(file);\n-        KeyStore ks = KeyStore.getInstance(\"JKS\");\n-        ks.load(in, \"passphrase\".toCharArray());\n-        in.close();\n-        return ks;\n-    }\n-}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/tls\/tls12\/FipsModeTLS12.java","additions":0,"deletions":488,"binary":false,"changes":488,"status":"deleted"},{"patch":"@@ -1,19 +0,0 @@\n-\n-name = NSSKeyStore\n-\n-nssSecmodDirectory = ${pkcs11test.nss.db}\n-\n-nssLibraryDirectory = ${pkcs11test.nss.libdir}\n-\n-nssModule = fips\n-\n-# NSS needs CKA_NETSCAPE_DB for DSA and DH private keys\n-# just put an arbitrary value in there to make it happy\n-\n-attributes(*,CKO_PRIVATE_KEY,CKK_DSA) = {\n-  CKA_NETSCAPE_DB = 0h00\n-}\n-\n-attributes(*,CKO_PRIVATE_KEY,CKK_DH) = {\n-  CKA_NETSCAPE_DB = 0h00\n-}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/tls\/tls12\/nss.cfg","additions":0,"deletions":19,"binary":false,"changes":19,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,1 +106,1 @@\n-        } catch (SSLHandshakeException exc) {\n+        } catch (SSLProtocolException exc) {\n@@ -136,1 +136,1 @@\n-        } catch (SSLHandshakeException exc) {\n+        } catch (SSLProtocolException exc) {\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLEngineImpl\/SSLEngineEmptyFragments.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -354,1 +354,1 @@\n-                tests::testEmptyAlertNotHandshaking, SSLHandshakeException.class);\n+                tests::testEmptyAlertNotHandshaking, SSLProtocolException.class);\n@@ -356,1 +356,1 @@\n-                tests::testEmptyAlertDuringHandshake, SSLHandshakeException.class);\n+                tests::testEmptyAlertDuringHandshake, SSLProtocolException.class);\n@@ -364,1 +364,1 @@\n-                tests::testEmptyAlertNotHandshaking, SSLHandshakeException.class);\n+                tests::testEmptyAlertNotHandshaking, SSLProtocolException.class);\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSocketImpl\/SSLSocketEmptyFragments.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8365820\n+ * @summary Apply certificate scope constraints to algorithms in\n+ *          \"signature_algorithms\" extension when\n+ *          \"signature_algorithms_cert\" extension is not being sent.\n+ *          This test covers the client side for TLSv1.2.\n+ * @library \/javax\/net\/ssl\/templates\n+ *          \/test\/lib\n+ * @run main\/othervm DisableCertSignAlgsExtForClientTLS12\n+ *\/\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertFalse;\n+\n+import java.security.Security;\n+import java.util.List;\n+\n+\/\/ Test disabled signature_algorithms_cert extension on the client side\n+\/\/ for TLSv1.2.\n+public class DisableCertSignAlgsExtForClientTLS12 extends\n+        DisableSignatureSchemePerScopeTLS12 {\n+\n+    protected DisableCertSignAlgsExtForClientTLS12()\n+            throws Exception {\n+        super();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Security.setProperty(\n+                \"jdk.tls.disabledAlgorithms\", DISABLED_CONSTRAINTS);\n+        \/\/ Disable signature_algorithms_cert extension for the client.\n+        System.setProperty(\"jdk.tls.client.disableExtensions\",\n+                \"signature_algorithms_cert\");\n+        new DisableCertSignAlgsExtForClientTLS12().run();\n+    }\n+\n+    @Override\n+    protected void checkClientHello() throws Exception {\n+        \/\/ --- Check signature_algorithms extension ---\n+\n+        \/\/ Get signature_algorithms extension signature schemes.\n+        List<String> sigAlgsSS = getSigSchemesCliHello(\n+                extractHandshakeMsg(cTOs, TLS_HS_CLI_HELLO),\n+                SIG_ALGS_EXT);\n+\n+        \/\/ signature_algorithms extension MUST NOT contain disabled\n+        \/\/ handshake signature scheme.\n+        assertFalse(sigAlgsSS.contains(HANDSHAKE_DISABLED_SIG),\n+                \"Signature Scheme \" + HANDSHAKE_DISABLED_SIG\n+                        + \" present in ClientHello's signature_algorithms extension\");\n+\n+        \/\/ signature_algorithms extension MUST NOT contain disabled\n+        \/\/ certificate signature scheme.\n+        assertFalse(sigAlgsSS.contains(CERTIFICATE_DISABLED_SIG),\n+                \"Signature Scheme \" + CERTIFICATE_DISABLED_SIG\n+                        + \" present in ClientHello's signature_algorithms extension\");\n+\n+        \/\/ signature_algorithms_cert extension MUST NOT be present.\n+        assertEquals(getSigSchemesCliHello(extractHandshakeMsg(\n+                        cTOs, TLS_HS_CLI_HELLO), SIG_ALGS_CERT_EXT).size(), 0,\n+                \"signature_algorithms_cert extension present in ClientHello\");\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/DisableCertSignAlgsExtForClientTLS12.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8365820\n+ * @summary Apply certificate scope constraints to algorithms in\n+ *          \"signature_algorithms\" extension when\n+ *          \"signature_algorithms_cert\" extension is not being sent.\n+ *          This test covers the client side for TLSv1.3.\n+ * @library \/javax\/net\/ssl\/templates\n+ *          \/test\/lib\n+ * @run main\/othervm DisableCertSignAlgsExtForClientTLS13\n+ *\/\n+\n+import static jdk.test.lib.Asserts.assertFalse;\n+\n+import java.security.Security;\n+import java.util.List;\n+\n+\/\/ Test disabled signature_algorithms_cert extension on the client side\n+\/\/ for TLSv1.3.\n+public class DisableCertSignAlgsExtForClientTLS13 extends\n+        DisableCertSignAlgsExtForClientTLS12 {\n+\n+    protected DisableCertSignAlgsExtForClientTLS13()\n+            throws Exception {\n+        super();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Security.setProperty(\n+                \"jdk.tls.disabledAlgorithms\", DISABLED_CONSTRAINTS);\n+        \/\/ Disable signature_algorithms_cert extension for the client.\n+        System.setProperty(\"jdk.tls.client.disableExtensions\",\n+                \"signature_algorithms_cert\");\n+        new DisableCertSignAlgsExtForClientTLS13().run();\n+    }\n+\n+    @Override\n+    protected String getProtocol() {\n+        return \"TLSv1.3\";\n+    }\n+\n+    @Override\n+    protected void checkClientHello() throws Exception {\n+        super.checkClientHello();\n+\n+        \/\/ Get signature_algorithms extension signature schemes.\n+        List<String> sigAlgsSS = getSigSchemesCliHello(\n+                extractHandshakeMsg(cTOs, TLS_HS_CLI_HELLO),\n+                SIG_ALGS_EXT);\n+\n+        \/\/ These signature schemes MOST NOT be present in signature_algorithms\n+        \/\/ extension.\n+        TLS13_CERT_ONLY.forEach(ss ->\n+                assertFalse(sigAlgsSS.contains(ss), \"Signature Scheme \" + ss\n+                        + \" present in ClientHello's\"\n+                        + \" signature_algorithms extension\"));\n+    }\n+\n+    \/\/ TLSv1.3 sends CertificateRequest signature schemes in\n+    \/\/ signature_algorithms and signature_algorithms_cert extensions. Same as\n+    \/\/ ClientHello, but they are encrypted. So we skip CertificateRequest\n+    \/\/ signature schemes verification for TLSv1.3.\n+    @Override\n+    protected void checkCertificateRequest() {\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/DisableCertSignAlgsExtForClientTLS13.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,281 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static jdk.test.lib.Asserts.assertTrue;\n+import static jdk.test.lib.Utils.runAndCheckException;\n+\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.net.SocketException;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.KeyStore;\n+import java.security.PrivateKey;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Date;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLHandshakeException;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLServerSocket;\n+import javax.net.ssl.TrustManagerFactory;\n+import jdk.test.lib.security.CertificateBuilder;\n+import sun.security.x509.AuthorityKeyIdentifierExtension;\n+import sun.security.x509.GeneralName;\n+import sun.security.x509.GeneralNames;\n+import sun.security.x509.KeyIdentifier;\n+import sun.security.x509.SerialNumber;\n+import sun.security.x509.X500Name;\n+\n+\/*\n+ * @test\n+ * @bug 8365820\n+ * @summary Apply certificate scope constraints to algorithms in\n+ *          \"signature_algorithms\" extension when\n+ *          \"signature_algorithms_cert\" extension is not being sent.\n+ *          This test covers the server side for TLSv1.3.\n+ * @modules java.base\/sun.security.x509\n+ *          java.base\/sun.security.util\n+ * @library \/javax\/net\/ssl\/templates\n+ *          \/test\/lib\n+ * @run main\/othervm DisableCertSignAlgsExtForServerTLS13 true\n+ * @run main\/othervm DisableCertSignAlgsExtForServerTLS13 false\n+ *\/\n+\n+\/*\n+ * Test disabled signature_algorithms_cert extension on the server side.\n+ *\n+ * CertificateRequest's extensions are encrypted in TLSv1.3. So we can't verify\n+ * the content of the CertificateRequest's signature_algorithms extension\n+ * directly like we do it for extensions in ClientHello message.\n+ * Instead, we run a TLS handshake and check that certificate scope\n+ * constraints are being applied to algorithms in \"signature_algorithms\"\n+ * extension when \"signature_algorithms_cert\" extension is not being sent.\n+ *\n+ * Note that for TLSv1.2 disabling \"signature_algorithms_cert\" extension\n+ * doesn't change anything for the signatures schemes list contained in\n+ * CertificateRequest message. The TLSv1.2 CertificateRequest message\n+ * doesn't contain extensions and includes the signatures schemes list\n+ * directly (which is also an intersection of signature schemes allowed\n+ * for handshake signatures and for the certificate signatures).\n+ * This functionality is being tested by \"DisableSignatureSchemePerScopeTLS12\".\n+ *\/\n+\n+public class DisableCertSignAlgsExtForServerTLS13 extends SSLSocketTemplate {\n+\n+    private static final String KEY_ALGORITHM = \"RSA\";\n+    private static final String SERVER_CERT_SIG_ALG = \"RSASSA-PSS\";\n+    \/\/ SHA256withRSA signature algorithm is not allowed for handshake\n+    \/\/ signatures in TLSv1.3, but it's allowed for certificate\n+    \/\/ signatures. This is regardless of jdk.tls.disabledAlgorithms\n+    \/\/ configuration. We use this difference to construct our test.\n+    private static final String CLIENT_CERT_SIG_ALG = \"SHA256withRSA\";\n+    private static final String TRUSTED_CERT_SIG_ALG = \"RSASSA-PSS\";\n+\n+    private final String protocol;\n+    private X509Certificate trustedCert;\n+    private X509Certificate serverCert;\n+    private X509Certificate clientCert;\n+    private KeyPair serverKeys;\n+    private KeyPair clientKeys;\n+\n+    protected DisableCertSignAlgsExtForServerTLS13(\n+            String protocol) throws Exception {\n+        super();\n+        this.protocol = protocol;\n+        setupCertificates();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 1) {\n+            throw new RuntimeException(\"Wrong number of arguments\");\n+        }\n+\n+        boolean disabled = Boolean.parseBoolean(args[0]);\n+\n+        \/\/ Disable signature_algorithms_cert extension on the server side.\n+        if (disabled) {\n+            System.setProperty(\"jdk.tls.server.disableExtensions\",\n+                    \"signature_algorithms_cert\");\n+        }\n+\n+        \/\/ Should always run fine on TLSv1.2 because SHA256withRSA signature\n+        \/\/ algorithm is allowed for both handshake and certificates signatures\n+        \/\/ in TLSv1.2.\n+        new DisableCertSignAlgsExtForServerTLS13(\"TLSv1.2\").run();\n+\n+        var tls13Test = new DisableCertSignAlgsExtForServerTLS13(\"TLSv1.3\");\n+\n+        if (disabled) {\n+            \/\/ Fails with \"signature_algorithms_cert\" extension disabled\n+            \/\/ because in such case we use an intersection of signature\n+            \/\/ schemes allowed for handshake signatures and for the certificate\n+            \/\/ signatures for \"signature_algorithms\" extension.\n+            runAndCheckException(\n+                    tls13Test::run,\n+                    localEx -> {\n+                        Throwable remoteEx = localEx.getSuppressed()[0];\n+\n+                        for (Throwable ex :\n+                                new Throwable[]{localEx, remoteEx}) {\n+                            assertTrue((ex instanceof SSLHandshakeException\n+                                    && ex.getMessage()\n+                                    .contains(\"(certificate_required)\")\n+                                    \/\/ Sometimes we can get SocketException\n+                                    \/\/ instead, depends on network setup.\n+                                    || ex instanceof SocketException));\n+                        }\n+                    });\n+        } else {\n+            \/\/ Runs fine with \"signature_algorithms_cert\" extension present.\n+            tls13Test.run();\n+        }\n+    }\n+\n+    @Override\n+    protected void configureServerSocket(SSLServerSocket sslServerSocket) {\n+        \/\/ Require a conforming certificate for the client.\n+        SSLParameters sslParameters = sslServerSocket.getSSLParameters();\n+        sslParameters.setNeedClientAuth(true);\n+        sslServerSocket.setSSLParameters(sslParameters);\n+    }\n+\n+    @Override\n+    public SSLContext createServerSSLContext() throws Exception {\n+        return getSSLContext(\n+                trustedCert, serverCert, serverKeys.getPrivate(), protocol);\n+    }\n+\n+    @Override\n+    public SSLContext createClientSSLContext() throws Exception {\n+        return getSSLContext(\n+                trustedCert, clientCert, clientKeys.getPrivate(), protocol);\n+    }\n+\n+    private static SSLContext getSSLContext(\n+            X509Certificate trustedCertificate, X509Certificate keyCertificate,\n+            PrivateKey privateKey, String protocol)\n+            throws Exception {\n+\n+        \/\/ create a key store\n+        KeyStore ks = KeyStore.getInstance(\"PKCS12\");\n+        ks.load(null, null);\n+\n+        \/\/ import the trusted cert\n+        ks.setCertificateEntry(\"TLS Signer\", trustedCertificate);\n+\n+        \/\/ generate certificate chain\n+        Certificate[] chain = new Certificate[2];\n+        chain[0] = keyCertificate;\n+        chain[1] = trustedCertificate;\n+\n+        \/\/ import the key entry.\n+        final char[] passphrase = \"passphrase\".toCharArray();\n+        ks.setKeyEntry(\"Whatever\", privateKey, passphrase, chain);\n+\n+        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"PKIX\");\n+        tmf.init(ks);\n+\n+        \/\/ create SSL context\n+        SSLContext ctx = SSLContext.getInstance(protocol);\n+\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n+        kmf.init(ks, passphrase);\n+\n+        ctx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n+\n+        return ctx;\n+    }\n+\n+    \/\/ Certificate-building helper methods.\n+\n+    private void setupCertificates() throws Exception {\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\n+                KEY_ALGORITHM);\n+        KeyPair caKeys = kpg.generateKeyPair();\n+        this.serverKeys = kpg.generateKeyPair();\n+        this.clientKeys = kpg.generateKeyPair();\n+\n+        this.trustedCert = createTrustedCert(caKeys);\n+\n+        this.serverCert = customCertificateBuilder(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                serverKeys.getPublic(), caKeys.getPublic())\n+                .addBasicConstraintsExt(false, false, -1)\n+                .build(trustedCert, caKeys.getPrivate(), SERVER_CERT_SIG_ALG);\n+\n+        this.clientCert = customCertificateBuilder(\n+                \"CN=localhost, OU=SSL-Client, O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                clientKeys.getPublic(), caKeys.getPublic())\n+                .addBasicConstraintsExt(false, false, -1)\n+                .build(trustedCert, caKeys.getPrivate(), CLIENT_CERT_SIG_ALG);\n+    }\n+\n+    private static X509Certificate createTrustedCert(KeyPair caKeys)\n+            throws Exception {\n+        SecureRandom random = new SecureRandom();\n+\n+        KeyIdentifier kid = new KeyIdentifier(caKeys.getPublic());\n+        GeneralNames gns = new GeneralNames();\n+        GeneralName name = new GeneralName(new X500Name(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\"));\n+        gns.add(name);\n+        BigInteger serialNumber = BigInteger.valueOf(\n+                random.nextLong(1000000) + 1);\n+        return customCertificateBuilder(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                caKeys.getPublic(), caKeys.getPublic())\n+                .setSerialNumber(serialNumber)\n+                .addExtension(new AuthorityKeyIdentifierExtension(kid, gns,\n+                        new SerialNumber(serialNumber)))\n+                .addBasicConstraintsExt(true, true, -1)\n+                .build(null, caKeys.getPrivate(), TRUSTED_CERT_SIG_ALG);\n+    }\n+\n+    private static CertificateBuilder customCertificateBuilder(\n+            String subjectName, PublicKey publicKey, PublicKey caKey)\n+            throws CertificateException, IOException {\n+        SecureRandom random = new SecureRandom();\n+\n+        CertificateBuilder builder = new CertificateBuilder()\n+                .setSubjectName(subjectName)\n+                .setPublicKey(publicKey)\n+                .setNotBefore(\n+                        Date.from(Instant.now().minus(1, ChronoUnit.HOURS)))\n+                .setNotAfter(Date.from(Instant.now().plus(1, ChronoUnit.HOURS)))\n+                .setSerialNumber(\n+                        BigInteger.valueOf(random.nextLong(1000000) + 1))\n+                .addSubjectKeyIdExt(publicKey)\n+                .addAuthorityKeyIdExt(caKey);\n+        builder.addKeyUsageExt(\n+                new boolean[]{true, true, true, true, true, true});\n+\n+        return builder;\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/DisableCertSignAlgsExtForServerTLS13.java","additions":281,"deletions":0,"binary":false,"changes":281,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8349583\n+ * @bug 8349583 8365820\n@@ -56,0 +56,11 @@\n+    \/\/ Signature schemes not supported in TLSv1.3 for the handshake\n+    \/\/ regardless of jdk.tls.disabledAlgorithms configuration.\n+    \/\/ In TLSv1.2 these are supported for both: handshake and certificate.\n+    protected static final List<String> TLS13_CERT_ONLY = List.of(\n+            \"ecdsa_sha1\",\n+            \"rsa_pkcs1_sha1\",\n+            \"rsa_pkcs1_sha256\",\n+            \"rsa_pkcs1_sha384\",\n+            \"rsa_pkcs1_sha512\"\n+    );\n+\n@@ -123,1 +134,1 @@\n-                + \" signature_algorithms extension\");\n+                + \" signature_algorithms_cert extension\");\n@@ -129,1 +140,1 @@\n-                + \" present in ClientHello's signature_algorithms extension\");\n+                + \" present in ClientHello's signature_algorithms_cert extension\");\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/DisableSignatureSchemePerScopeTLS12.java","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8349583\n+ * @bug 8349583 8365820\n@@ -44,9 +44,0 @@\n-    \/\/ Signature schemes not supported in TLSv1.3 only for the handshake.\n-    \/\/ This is regardless of jdk.tls.disabledAlgorithms configuration.\n-    List<String> NOT_SUPPORTED_FOR_HANDSHAKE = List.of(\n-            \"rsa_pkcs1_sha1\",\n-            \"rsa_pkcs1_sha256\",\n-            \"rsa_pkcs1_sha384\",\n-            \"rsa_pkcs1_sha512\"\n-    );\n-\n@@ -77,5 +68,6 @@\n-        \/\/ Should not be present in signature_algorithms extension.\n-        NOT_SUPPORTED_FOR_HANDSHAKE.forEach(ss ->\n-                assertFalse(sigAlgsSS.contains(ss),\n-                        \"Signature Scheme \" + ss\n-                        + \" present in ClientHello's signature_algorithms extension\"));\n+        \/\/ These signature schemes MOST NOT be present in signature_algorithms\n+        \/\/ extension.\n+        TLS13_CERT_ONLY.forEach(ss ->\n+                assertFalse(sigAlgsSS.contains(ss), \"Signature Scheme \" + ss\n+                        + \" present in ClientHello's\"\n+                        + \" signature_algorithms extension\"));\n@@ -88,4 +80,4 @@\n-        \/\/ Should be present in signature_algorithms_cert extension.\n-        NOT_SUPPORTED_FOR_HANDSHAKE.forEach(ss ->\n-                assertTrue(sigAlgsCertSS.contains(ss),\n-                        \"Signature Scheme \" + ss\n+        \/\/ These signature schemes MUST be present in\n+        \/\/ signature_algorithms_cert extension.\n+        TLS13_CERT_ONLY.forEach(ss ->\n+                assertTrue(sigAlgsCertSS.contains(ss), \"Signature Scheme \" + ss\n@@ -93,1 +85,1 @@\n-                        + \" signature_algorithms extension\"));\n+                        + \" signature_algorithms_cert extension\"));\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/DisableSignatureSchemePerScopeTLS13.java","additions":12,"deletions":20,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+    jdk.jpackage\/jdk.jpackage.internal.resources \\\n","filename":"test\/jdk\/tools\/jpackage\/TEST.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1088,1 +1088,3 @@\n-                new LauncherVerifier(cmd).verify(cmd, LauncherVerifier.Action.VERIFY_INSTALLED);\n+                new LauncherVerifier(cmd).verify(cmd,\n+                        LauncherVerifier.Action.VERIFY_INSTALLED,\n+                        LauncherVerifier.Action.VERIFY_MAC_ENTITLEMENTS);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -314,1 +314,1 @@\n-        var args = servicePlist.queryArrayValue(\"ProgramArguments\");\n+        var args = servicePlist.queryStringArrayValue(\"ProgramArguments\");\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherAsServiceVerifier.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,3 @@\n+import javax.xml.parsers.ParserConfigurationException;\n+import jdk.jpackage.internal.resources.ResourceLocator;\n+import jdk.jpackage.internal.util.PListReader;\n@@ -41,0 +44,1 @@\n+import jdk.jpackage.internal.util.function.ThrowingSupplier;\n@@ -43,0 +47,1 @@\n+import org.xml.sax.SAXException;\n@@ -85,0 +90,5 @@\n+        VERIFY_MAC_ENTITLEMENTS((verifier, cmd) -> {\n+            if (TKit.isOSX() && MacHelper.appImageSigned(cmd)) {\n+                verifier.verifyMacEntitlements(cmd);\n+            }\n+        }),\n@@ -99,1 +109,1 @@\n-                VERIFY_ICON, VERIFY_DESCRIPTION, VERIFY_INSTALLED, VERIFY_APP_IMAGE_FILE\n+                VERIFY_ICON, VERIFY_DESCRIPTION, VERIFY_INSTALLED, VERIFY_APP_IMAGE_FILE, VERIFY_MAC_ENTITLEMENTS\n@@ -326,0 +336,18 @@\n+    private void verifyMacEntitlements(JPackageCommand cmd) throws ParserConfigurationException, SAXException, IOException {\n+        Path launcherPath = cmd.appLauncherPath(name);\n+        var entitlements = MacSignVerify.findEntitlements(launcherPath);\n+\n+        TKit.assertTrue(entitlements.isPresent(), String.format(\"Check [%s] launcher is signed with entitlements\", name));\n+\n+        Map<String, Object> expected;\n+        if (cmd.hasArgument(\"--mac-entitlements\")) {\n+            expected = new PListReader(Files.readAllBytes(Path.of(cmd.getArgumentValue(\"--mac-entitlements\")))).toMap(true);\n+        } else if (cmd.hasArgument(\"--mac-app-store\")) {\n+            expected = DefaultEntitlements.APP_STORE;\n+        } else {\n+            expected = DefaultEntitlements.STANDARD;\n+        }\n+\n+        TKit.assertEquals(expected, entitlements.orElseThrow().toMap(true), String.format(\"Check [%s] launcher is signed with expected entitlements\", name));\n+    }\n+\n@@ -365,0 +393,14 @@\n+\n+    private static final class DefaultEntitlements {\n+        private static Map<String, Object> loadFromResources(String resourceName) {\n+            return ThrowingSupplier.toSupplier(() -> {\n+                var bytes = ResourceLocator.class.getResourceAsStream(\"entitlements.plist\").readAllBytes();\n+                return new PListReader(bytes).toMap(true);\n+            }).get();\n+        }\n+\n+        static final Map<String, Object> STANDARD = loadFromResources(\"entitlements.plist\");\n+        static final Map<String, Object> APP_STORE = loadFromResources(\"sandbox.plist\");\n+    }\n+\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherVerifier.java","additions":43,"deletions":1,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -77,1 +77,2 @@\n-            var plist = readPList(attachExecutor.getOutput());\n+            \/\/ The first \"dict\" item of \"system-entities\" array property contains \"mount-point\" string property.\n+            var plist = readPList(attachExecutor.getOutput()).queryArrayValue(\"system-entities\", false).findFirst().map(PListReader.class::cast).orElseThrow();\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacHelper.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -59,0 +59,11 @@\n+    public static Optional<PListReader> findEntitlements(Path path) {\n+        final var exec = Executor.of(\"\/usr\/bin\/codesign\", \"-d\", \"--entitlements\", \"-\", \"--xml\", path.toString()).saveOutput().dumpOutput();\n+        final var result = exec.execute();\n+        var xml = result.stdout().getOutput();\n+        if (xml.isEmpty()) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(MacHelper.readPList(xml));\n+        }\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacSignVerify.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -26,4 +26,1 @@\n-import jdk.jpackage.internal.model.DottedVersion;\n-import jdk.jpackage.internal.model.ConfigException;\n-import java.nio.file.Path;\n-import jdk.internal.util.OperatingSystem;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -33,0 +30,10 @@\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.DottedVersion;\n@@ -34,0 +41,4 @@\n+import org.junit.jupiter.api.io.TempDir;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n@@ -38,3 +49,4 @@\n-    @Test\n-    public void testAvailable() {\n-        assertNull(new ToolValidator(TOOL_JAVA).validate());\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void testAvailable(boolean checkExistsOnly) {\n+        assertNull(new ToolValidator(TOOL_JAVA).checkExistsOnly(checkExistsOnly).validate());\n@@ -44,2 +56,98 @@\n-    public void testNotAvailable() {\n-        assertValidationFailure(new ToolValidator(TOOL_UNKNOWN).validate(), true);\n+    public void testAvailable_setCommandLine() {\n+        \/\/ java doesn't recognize \"--foo\" command line option, but the validation will\n+        \/\/ still pass as there is no minimal version specified and the validator ignores\n+        \/\/ the exit code\n+        assertNull(new ToolValidator(TOOL_JAVA).setCommandLine(\"--foo\").validate());\n+    }\n+\n+    enum TestAvailableMode {\n+        NO_VERSION(null),\n+        TOO_OLD(\"0.9\"),\n+        EQUALS(\"1.0\"),\n+        NEWER(\"1.1\");\n+\n+        TestAvailableMode(String parsedVersion) {\n+            this.parsedVersion = parsedVersion;\n+        }\n+\n+        final String parsedVersion;\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(TestAvailableMode.class)\n+    public void testAvailable(TestAvailableMode mode) {\n+        var minVer = TestAvailableMode.EQUALS.parsedVersion;\n+        var err = new ToolValidator(TOOL_JAVA).setVersionParser(lines -> {\n+            return mode.parsedVersion;\n+        }).setMinimalVersion(DottedVersion.greedy(minVer)).validate();\n+\n+        if (Set.of(TestAvailableMode.NO_VERSION, TestAvailableMode.TOO_OLD).contains(mode)) {\n+            var expectedMessage = I18N.format(\"error.tool-old-version\", TOOL_JAVA, minVer);\n+            var expectedAdvice = I18N.format(\"error.tool-old-version.advice\", TOOL_JAVA, minVer);\n+\n+            assertEquals(expectedMessage, err.getMessage());\n+            assertEquals(expectedAdvice, err.getAdvice());\n+        } else {\n+            assertNull(err);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(TestAvailableMode.class)\n+    public void testAvailable_setToolOldVersionErrorHandler(TestAvailableMode mode) {\n+        var handler = new ToolOldVersionErrorHandler();\n+        var minVer = TestAvailableMode.EQUALS.parsedVersion;\n+        var err = new ToolValidator(TOOL_JAVA).setVersionParser(lines -> {\n+            return mode.parsedVersion;\n+        }).setMinimalVersion(DottedVersion.greedy(minVer)).setToolOldVersionErrorHandler(handler).validate();\n+\n+        if (Set.of(TestAvailableMode.NO_VERSION, TestAvailableMode.TOO_OLD).contains(mode)) {\n+            assertSame(ToolOldVersionErrorHandler.ERR, err);\n+            handler.verifyCalled(Path.of(TOOL_JAVA), mode.parsedVersion);\n+        } else {\n+            assertNull(err);\n+            handler.verifyNotCalled();\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void testNotAvailable(boolean checkExistsOnly, @TempDir Path dir) {\n+        var err = new ToolValidator(dir.resolve(\"foo\")).checkExistsOnly(checkExistsOnly).validate();\n+        if (checkExistsOnly) {\n+            assertValidationFailure(err, false);\n+        } else {\n+            assertValidationFailureNoAdvice(err, !checkExistsOnly);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void testToolIsDirectory(boolean checkExistsOnly, @TempDir Path dir) {\n+        var err = new ToolValidator(dir).checkExistsOnly(checkExistsOnly).validate();\n+        assertValidationFailureNoAdvice(err, !checkExistsOnly);\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void testNotAvailable_setToolNotFoundErrorHandler(boolean checkExistsOnly, @TempDir Path dir) {\n+        var handler = new ToolNotFoundErrorHandler();\n+        var err = new ToolValidator(dir.resolve(\"foo\")).checkExistsOnly(checkExistsOnly)\n+                .setToolNotFoundErrorHandler(handler)\n+                .validate();\n+        if (checkExistsOnly) {\n+            handler.verifyCalled(dir.resolve(\"foo\"));\n+            assertSame(ToolNotFoundErrorHandler.ERR, err);\n+        } else {\n+            handler.verifyNotCalled();\n+            assertValidationFailureNoAdvice(err, !checkExistsOnly);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void testToolIsDirectory_setToolNotFoundErrorHandler(boolean checkExistsOnly, @TempDir Path dir) {\n+        var handler = new ToolNotFoundErrorHandler();\n+        var err = new ToolValidator(dir).checkExistsOnly(checkExistsOnly).validate();\n+        handler.verifyNotCalled();\n+        assertValidationFailureNoAdvice(err, !checkExistsOnly);\n@@ -52,1 +160,1 @@\n-            throw new RuntimeException();\n+            throw new AssertionError();\n@@ -84,0 +192,61 @@\n+    private static void assertValidationFailureNoAdvice(ConfigException v, boolean withCause) {\n+        assertNotNull(v);\n+        assertNotEquals(\"\", v.getMessage().strip());\n+        assertNull(v.getAdvice());\n+        if (withCause) {\n+            assertNotNull(v.getCause());\n+        } else {\n+            assertNull(v.getCause());\n+        }\n+    }\n+\n+\n+    private static final class ToolNotFoundErrorHandler implements Function<Path, ConfigException> {\n+\n+        @Override\n+        public ConfigException apply(Path tool) {\n+            assertNotNull(tool);\n+            this.tool = tool;\n+            return ERR;\n+        }\n+\n+        void verifyCalled(Path expectedTool) {\n+            assertEquals(Objects.requireNonNull(expectedTool), tool);\n+        }\n+\n+        void verifyNotCalled() {\n+            assertNull(tool);\n+        }\n+\n+        private Path tool;\n+\n+        static final ConfigException ERR = new ConfigException(\"no tool\", \"install the tool\");\n+    }\n+\n+\n+    private static final class ToolOldVersionErrorHandler implements BiFunction<Path, String, ConfigException> {\n+\n+        @Override\n+        public ConfigException apply(Path tool, String parsedVersion) {\n+            assertNotNull(tool);\n+            this.tool = tool;\n+            this.parsedVersion = parsedVersion;\n+            return ERR;\n+        }\n+\n+        void verifyCalled(Path expectedTool, String expectedParsedVersion) {\n+            assertEquals(Objects.requireNonNull(expectedTool), tool);\n+            assertEquals(expectedParsedVersion, parsedVersion);\n+        }\n+\n+        void verifyNotCalled() {\n+            assertNull(tool);\n+        }\n+\n+        private Path tool;\n+        private String parsedVersion;\n+\n+        static final ConfigException ERR = new ConfigException(\"tool too old\", \"install the newer version\");\n+    }\n+\n+\n@@ -85,2 +254,0 @@\n-    private static final String TOOL_UNKNOWN = Path.of(System.getProperty(\n-            \"java.home\"), \"bin\").toString();\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/ToolValidatorTest.java","additions":179,"deletions":12,"binary":false,"changes":191,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.Map;\n@@ -39,0 +40,1 @@\n+import java.util.stream.Stream;\n@@ -40,0 +42,1 @@\n+import jdk.jpackage.internal.util.PListReader.Raw;\n@@ -43,0 +46,1 @@\n+import org.junit.jupiter.params.provider.EnumSource.Mode;\n@@ -54,1 +58,17 @@\n-        STRING_ARRAY(PListReader::queryArrayValue);\n+        DICT((plistReader, keyName) -> {\n+            return plistReader.queryDictValue(keyName).toMap(true);\n+        }),\n+        STRING_ARRAY(PListReader::queryStringArrayValue),\n+        RAW_ARRAY((plistReader, keyName) -> {\n+            return plistReader.queryArrayValue(keyName, false).toList();\n+        }),\n+        RAW_ARRAY_RECURSIVE((plistReader, keyName) -> {\n+            return plistReader.queryArrayValue(keyName, true).toList();\n+        }),\n+        TO_MAP((plistReader, _) -> {\n+            return plistReader.toMap(false);\n+        }),\n+        TO_MAP_RECURSIVE((plistReader, _) -> {\n+            return plistReader.toMap(true);\n+        }),\n+        ;\n@@ -68,1 +88,1 @@\n-    public record QueryValueTestSpec(QueryType queryType, String keyName, Optional<Object> expectedValue,\n+    public record TestSpec(QueryType queryType, Optional<String> keyName, Optional<Object> expectedValue,\n@@ -71,1 +91,1 @@\n-        public QueryValueTestSpec {\n+        public TestSpec {\n@@ -80,0 +100,8 @@\n+            if (keyName.isEmpty()) {\n+                switch (queryType) {\n+                    case TO_MAP, TO_MAP_RECURSIVE -> {}\n+                    default -> {\n+                        throw new IllegalArgumentException();\n+                    }\n+                }\n+            }\n@@ -94,1 +122,1 @@\n-            Builder expectedValue(Object v) {\n+            Builder expect(Object v) {\n@@ -102,0 +130,2 @@\n+                } else if (v instanceof Map<?, ?>) {\n+                    queryType(QueryType.DICT);\n@@ -106,1 +136,1 @@\n-            Builder expectedException(Class<? extends RuntimeException> v) {\n+            Builder expectException(Class<? extends RuntimeException> v) {\n@@ -116,2 +146,5 @@\n-            QueryValueTestSpec create() {\n-                return new QueryValueTestSpec(queryType, keyName, Optional.ofNullable(expectedValue),\n+            TestSpec create() {\n+                return new TestSpec(\n+                        queryType,\n+                        Optional.ofNullable(keyName),\n+                        Optional.ofNullable(expectedValue),\n@@ -140,1 +173,1 @@\n-                final var actualValue = queryType.queryValue(plistReader, keyName);\n+                final var actualValue = queryType.queryValue(plistReader, keyName.orElse(null));\n@@ -145,1 +178,1 @@\n-                assertThrows(v, () -> queryType.queryValue(plistReader, keyName));\n+                assertThrows(v, () -> queryType.queryValue(plistReader, keyName.orElse(null)));\n@@ -153,1 +186,3 @@\n-            sb.append(\"; key=\").append(keyName);\n+            if (keyName != null) {\n+                sb.append(\"; key=\").append(keyName);\n+            }\n@@ -169,1 +204,1 @@\n-    @EnumSource(QueryType.class)\n+    @EnumSource(mode = Mode.MATCH_NONE, names = {\"TO_MAP.*\"})\n@@ -175,1 +210,1 @@\n-    @EnumSource(QueryType.class)\n+    @EnumSource(mode = Mode.MATCH_NONE, names = {\"TO_MAP.*\"})\n@@ -185,1 +220,3 @@\n-                \"<array><string>b<\/string><\/array>\");\n+                \"<array><string>b<\/string><\/array>\",\n+                \"<key>dict-key<\/key>\",\n+                \"<dict><key>nested-dict-key<\/key><integer>345<\/integer><\/dict>\");\n@@ -187,1 +224,1 @@\n-        List<QueryValueTestSpec> testSpecs = new ArrayList<>();\n+        List<TestSpec> testSpecs = new ArrayList<>();\n@@ -194,0 +231,1 @@\n+                testSpecs.add(builder.keyName(\"dict-key\").create());\n@@ -198,0 +236,1 @@\n+                testSpecs.add(builder.keyName(\"dict-key\").create());\n@@ -199,1 +238,1 @@\n-            case STRING_ARRAY -> {\n+            case STRING_ARRAY, RAW_ARRAY, RAW_ARRAY_RECURSIVE -> {\n@@ -203,0 +242,10 @@\n+                testSpecs.add(builder.keyName(\"dict-key\").create());\n+            }\n+            case DICT -> {\n+                testSpecs.add(builder.keyName(\"string-key\").create());\n+                testSpecs.add(builder.keyName(\"boolean-true-key\").create());\n+                testSpecs.add(builder.keyName(\"boolean-false-key\").create());\n+                testSpecs.add(builder.keyName(\"array-key\").create());\n+            }\n+            case TO_MAP, TO_MAP_RECURSIVE -> {\n+                throw new UnsupportedOperationException();\n@@ -206,1 +255,10 @@\n-        testSpecs.forEach(QueryValueTestSpec::test);\n+        testSpecs.forEach(TestSpec::test);\n+\n+        builder.keyName(null).expect(Map.of(\n+                \"string-key\", new Raw(\"a\", Raw.Type.STRING),\n+                \"boolean-true-key\", new Raw(Boolean.TRUE.toString(), Raw.Type.BOOLEAN),\n+                \"boolean-false-key\", new Raw(Boolean.FALSE.toString(), Raw.Type.BOOLEAN),\n+                \"array-key\", List.of(new Raw(\"b\", Raw.Type.STRING)),\n+                \"dict-key\", Map.of(\"nested-dict-key\", new Raw(\"345\", Raw.Type.INTEGER))\n+        )).queryType(QueryType.TO_MAP_RECURSIVE).create().test();\n+\n@@ -211,1 +269,1 @@\n-    public void testQueryValue(QueryValueTestSpec testSpec) {\n+    public void test(TestSpec testSpec) {\n@@ -222,14 +280,54 @@\n-    private static List<QueryValueTestSpec> testQueryValue() {\n-        return List.of(\n-                testSpec().expectedValue(\"A\").xml(\"<key>foo<\/key><string>A<\/string>\").create(),\n-                testSpec().expectedValue(\"\").xml(\"<key>foo<\/key><string\/>\").create(),\n-                testSpec().xml(\"<key>foo<\/key><String\/>\").create(),\n-                testSpec().expectedValue(Boolean.TRUE).xml(\"<key>foo<\/key><true\/>\").create(),\n-                testSpec().expectedValue(Boolean.FALSE).xml(\"<key>foo<\/key><false\/>\").create(),\n-                testSpec(QueryType.BOOLEAN).xml(\"<key>foo<\/key><True\/>\").create(),\n-                testSpec(QueryType.BOOLEAN).xml(\"<key>foo<\/key><False\/>\").create(),\n-                testSpec().expectedValue(List.of(\"foo\", \"bar\")).xml(\"<key>foo<\/key><array><string>foo<\/string><string>bar<\/string><\/array>\").create(),\n-                testSpec().expectedValue(List.of()).xml(\"<key>foo<\/key><array\/>\").create(),\n-                testSpec(QueryType.STRING_ARRAY).xml(\"<key>foo<\/key><Array\/>\").create(),\n-                testSpec().expectedValue(\"A\").xml(\"<key>foo<\/key><string>A<\/string><string>B<\/string>\").create(),\n-                testSpec().expectedValue(\"A\").xml(\"<key>foo<\/key><string>A<\/string><key>foo<\/key><string>B<\/string>\").create()\n+    @Test\n+    public void test_toMap() {\n+\n+        var builder = testSpec();\n+\n+        builder.xml(\n+                \"<key>AppName<\/key>\",\n+                \"<string>Hello<\/string>\",\n+                \"<!-- Application version -->\",\n+                \"<key>AppVersion<\/key>\",\n+                \"<real>1.0<\/real>\",\n+                \"<key>Release<\/key>\",\n+                \"<true\/>\",\n+                \"<key>Debug<\/key>\",\n+                \"<false\/>\",\n+                \"<key>ReleaseDate<\/key>\",\n+                \"<date>2025-09-24T09:23:00Z<\/date>\",\n+                \"<key>UserData<\/key>\",\n+                \"<!-- User data -->\",\n+                \"<dict>\",\n+                \"  <key>Foo<\/key>\",\n+                \"  <array>\",\n+                \"    <string>Str<\/string>\",\n+                \"    <array>\",\n+                \"      <string>Another Str<\/string>\",\n+                \"      <true\/>\",\n+                \"      <false\/>\",\n+                \"    <\/array>\",\n+                \"  <\/array>\",\n+                \"<\/dict>\",\n+                \"<key>Checksum<\/key>\",\n+                \"<data>7841ff0076cdde93bdca02cfd332748c40620ce4<\/data>\",\n+                \"<key>Plugins<\/key>\",\n+                \"<array>\",\n+                \"  <dict>\",\n+                \"    <key>PluginName<\/key>\",\n+                \"    <string>Foo<\/string>\",\n+                \"    <key>Priority<\/key>\",\n+                \"    <integer>13<\/integer>\",\n+                \"    <key>History<\/key>\",\n+                \"    <array>\",\n+                \"      <string>New File<\/string>\",\n+                \"      <string>Another New File<\/string>\",\n+                \"    <\/array>\",\n+                \"  <\/dict>\",\n+                \"  <dict>\",\n+                \"    <key>PluginName<\/key>\",\n+                \"    <string>Bar<\/string>\",\n+                \"    <key>Priority<\/key>\",\n+                \"    <real>23<\/real>\",\n+                \"    <key>History<\/key>\",\n+                \"    <array\/>\",\n+                \"  <\/dict>\",\n+                \"<\/array>\"\n@@ -237,0 +335,122 @@\n+\n+        var expected = Map.of(\n+                \"AppName\", new Raw(\"Hello\", Raw.Type.STRING),\n+                \"AppVersion\", new Raw(\"1.0\", Raw.Type.REAL),\n+                \"Release\", new Raw(Boolean.TRUE.toString(), Raw.Type.BOOLEAN),\n+                \"Debug\", new Raw(Boolean.FALSE.toString(), Raw.Type.BOOLEAN),\n+                \"ReleaseDate\", new Raw(\"2025-09-24T09:23:00Z\", Raw.Type.DATE),\n+                \"Checksum\", new Raw(\"7841ff0076cdde93bdca02cfd332748c40620ce4\", Raw.Type.DATA),\n+                \"UserData\", Map.of(\n+                        \"Foo\", List.of(\n+                                new Raw(\"Str\", Raw.Type.STRING),\n+                                List.of(\n+                                        new Raw(\"Another Str\", Raw.Type.STRING),\n+                                        new Raw(Boolean.TRUE.toString(), Raw.Type.BOOLEAN),\n+                                        new Raw(Boolean.FALSE.toString(), Raw.Type.BOOLEAN)\n+                                )\n+                        )\n+                ),\n+                \"Plugins\", List.of(\n+                        Map.of(\n+                                \"PluginName\", new Raw(\"Foo\", Raw.Type.STRING),\n+                                \"Priority\", new Raw(\"13\", Raw.Type.INTEGER),\n+                                \"History\", List.of(\n+                                        new Raw(\"New File\", Raw.Type.STRING),\n+                                        new Raw(\"Another New File\", Raw.Type.STRING)\n+                                )\n+                        ),\n+                        Map.of(\n+                                \"PluginName\", new Raw(\"Bar\", Raw.Type.STRING),\n+                                \"Priority\", new Raw(\"23\", Raw.Type.REAL),\n+                                \"History\", List.of()\n+                        )\n+                )\n+        );\n+\n+        builder.expect(expected).queryType(QueryType.TO_MAP_RECURSIVE).create().test();\n+    }\n+\n+    private static List<TestSpec> test() {\n+\n+        List<TestSpec> data = new ArrayList<>();\n+\n+        Stream.of(\n+                testSpec().expect(\"A\").xml(\"<key>foo<\/key><string>A<\/string>\"),\n+                testSpec().expect(\"A\").xml(\"<a><string>B<\/string><\/a><key>foo<\/key><string>A<\/string>\"),\n+                testSpec().expect(\"\").xml(\"<key>foo<\/key> some text <string\/>\"),\n+                testSpec().xml(\"<key>foo<\/key><String\/>\"),\n+                testSpec().xml(\"<key>foo<\/key>\"),\n+                testSpec().xml(\"<key>foo<\/key><foo\/><string>A<\/string>\"),\n+                testSpec().expect(Boolean.TRUE).xml(\"<key>foo<\/key><true\/>\"),\n+                testSpec().expect(Boolean.FALSE).xml(\"<key>foo<\/key><false\/>\"),\n+                testSpec(QueryType.BOOLEAN).xml(\"<key>foo<\/key><True\/>\"),\n+                testSpec(QueryType.BOOLEAN).xml(\"<key>foo<\/key><False\/>\"),\n+                testSpec().expect(List.of(\"foo\", \"bar\")).xml(\"<key>foo<\/key><array><string>foo<\/string><random\/><dict\/><string>bar<\/string><true\/><\/array>\"),\n+                testSpec().expect(List.of()).xml(\"<key>foo<\/key><array\/>\"),\n+                testSpec(QueryType.STRING_ARRAY).xml(\"<key>foo<\/key><Array\/>\"),\n+                testSpec().expect(\"A\").xml(\"<key>foo<\/key><string>A<\/string><string>B<\/string>\"),\n+                testSpec().expect(\"A\").xml(\"<key>foo<\/key><string>A<\/string><key>foo<\/key><string>B<\/string>\"),\n+\n+                testSpec().expect(Map.of()).xml(\"<key>foo<\/key><dict\/>\"),\n+\n+                \/\/\n+                \/\/ Test that if there are multiple keys with the same name, all but the first are ignored.\n+                \/\/\n+                testSpec().expect(\"A\").xml(\"<key>foo<\/key><string>A<\/string><key>foo<\/key><string>B<\/string><key>foo<\/key><string>C<\/string>\"),\n+                testSpec().expect(\"A\").xml(\"<key>foo<\/key><string>A<\/string><key>foo<\/key><String>B<\/String>\"),\n+                testSpec(QueryType.STRING).xml(\"<key>foo<\/key><String>B<\/String><key>foo<\/key><string>A<\/string>\"),\n+                testSpec().expect(Boolean.TRUE).xml(\"<key>foo<\/key><true\/><key>foo<\/key><false\/>\"),\n+                testSpec().expect(Boolean.TRUE).xml(\"<key>foo<\/key><true\/><key>foo<\/key><False\/>\"),\n+                testSpec(QueryType.BOOLEAN).xml(\"<key>foo<\/key><False\/><key>foo<\/key><true\/>\"),\n+\n+                \/\/\n+                \/\/ Test that it doesn't look up keys in nested \"dict\" or \"array\" elements.\n+                \/\/\n+                testSpec().xml(\"<key>foo<\/key><dict><key>foo<\/key><string>A<\/string><\/dict>\"),\n+                testSpec().expect(\"B\").xml(\"<key>bar<\/key><dict><key>foo<\/key><string>A<\/string><\/dict><key>foo<\/key><string>B<\/string>\"),\n+                testSpec().xml(\"<key>foo<\/key><array><dict><key>foo<\/key><string>A<\/string><\/dict><\/array>\"),\n+                testSpec().expect(\"B\").xml(\"<key>bar<\/key><array><dict><key>foo<\/key><string>A<\/string><\/dict><\/array><key>foo<\/key><string>B<\/string>\"),\n+\n+                \/\/\n+                \/\/ Test empty arrays.\n+                \/\/\n+                testSpec().expect(List.of()).queryType(QueryType.RAW_ARRAY_RECURSIVE).xml(\"<key>foo<\/key><array\/>\"),\n+                testSpec().expect(List.of()).queryType(QueryType.RAW_ARRAY).xml(\"<key>foo<\/key><array\/>\")\n+\n+        ).map(TestSpec.Builder::create).forEach(data::add);\n+\n+        \/\/\n+        \/\/ Test toMap() method.\n+        \/\/\n+        Stream.of(\n+                testSpec().expect(Map.of()).xml(),\n+                testSpec().expect(Map.of()).xml(\"<key>foo<\/key><key>bar<\/key>\"),\n+                testSpec().expect(Map.of()).xml(\"<string>A<\/string><key>bar<\/key>\"),\n+                testSpec().expect(Map.of()).xml(\"<string>A<\/string>\"),\n+                testSpec().expect(Map.of()).xml(\"<key>foo<\/key><a\/><string>A<\/string>\"),\n+                testSpec().expect(Map.of(\"foo\", new Raw(\"A\", Raw.Type.STRING))).xml(\"<key>foo<\/key><string>A<\/string><string>B<\/string>\"),\n+                testSpec().expect(Map.of(\"foo\", new Raw(\"A\", Raw.Type.STRING))).xml(\"<key>foo<\/key><string>A<\/string> hello <key>foo<\/key> bye <string>B<\/string>\"),\n+                testSpec().expect(Map.of(\"foo\", new Raw(\"A\", Raw.Type.STRING), \"Foo\", new Raw(\"B\", Raw.Type.STRING))).xml(\"<key>foo<\/key><string>A<\/string><key>Foo<\/key><string>B<\/string>\")\n+        ).map(builder -> {\n+            return builder.queryType(QueryType.TO_MAP_RECURSIVE);\n+        }).map(TestSpec.Builder::create).forEach(data::add);\n+\n+        var arrayTestSpec = testSpec().expect(List.of(\n+                new Raw(\"Hello\", Raw.Type.STRING),\n+                Map.of(\"foo\", new Raw(\"Bye\", Raw.Type.STRING)),\n+                new Raw(\"integer\", Raw.Type.INTEGER),\n+                Map.of(),\n+                new Raw(Boolean.TRUE.toString(), Raw.Type.BOOLEAN)\n+        )).queryType(QueryType.RAW_ARRAY_RECURSIVE);\n+\n+        Stream.of(\n+                \"<string>Hello<\/string><random\/><dict><key>foo<\/key><string>Bye<\/string><\/dict><integer>integer<\/integer><dict\/><true\/>\",\n+                \"<string>Hello<\/string><dict><data>Bingo<\/data><key>foo<\/key><string>Bye<\/string><\/dict><integer>integer<\/integer><dict\/><true\/>\",\n+                \"<a><string>B<\/string><\/a><string>Hello<\/string><random\/><dict><key>foo<\/key><string>Bye<\/string><string>Byeee<\/string><\/dict><integer>integer<\/integer><dict\/><true\/>\",\n+                \"<string>Hello<\/string><random\/><dict><key>bar<\/key><key>foo<\/key><string>Bye<\/string><\/dict><integer>integer<\/integer><dict\/><true\/>\",\n+                \"<string>Hello<\/string><random\/><dict><key>foo<\/key><string>Bye<\/string><key>foo<\/key><string>ByeBye<\/string><\/dict><integer>integer<\/integer><dict\/><true\/>\"\n+        ).map(xml -> {\n+            return \"<key>foo<\/key><array>\" + xml + \"<\/array>\";\n+        }).map(arrayTestSpec::xml).map(TestSpec.Builder::create).forEach(data::add);\n+\n+        return data;\n@@ -239,2 +459,2 @@\n-    private static QueryValueTestSpec.Builder testSpec() {\n-        return new QueryValueTestSpec.Builder();\n+    private static TestSpec.Builder testSpec() {\n+        return new TestSpec.Builder();\n@@ -243,1 +463,1 @@\n-    private static QueryValueTestSpec.Builder testSpec(QueryType queryType) {\n+    private static TestSpec.Builder testSpec(QueryType queryType) {\n@@ -251,0 +471,1 @@\n+        content.add(\"<dict>\");\n@@ -252,0 +473,1 @@\n+        content.add(\"<\/dict>\");\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/util\/PListReaderTest.java","additions":256,"deletions":34,"binary":false,"changes":290,"status":"modified"},{"patch":"@@ -24,0 +24,2 @@\n+import static java.util.Map.entry;\n+\n@@ -27,4 +29,0 @@\n-import static java.util.Map.entry;\n-import jdk.jpackage.test.JPackageCommand;\n-import jdk.jpackage.test.TKit;\n-import jdk.jpackage.test.MacHelper;\n@@ -33,0 +31,3 @@\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.MacHelper;\n+import jdk.jpackage.test.TKit;\n@@ -83,3 +84,3 @@\n-    private static void checkBoolValue(PListReader plist, String key, Boolean value) {\n-        Boolean result = plist.queryBoolValue(key);\n-        TKit.assertEquals(value.toString(), result.toString(), String.format(\n+    private static void checkBoolValue(PListReader plist, String key, boolean value) {\n+        boolean result = plist.queryBoolValue(key);\n+        TKit.assertEquals(value, result, String.format(\n@@ -91,1 +92,1 @@\n-        List<String> result = plist.queryArrayValue(key);\n+        List<String> result = plist.queryStringArrayValue(key);\n@@ -97,1 +98,6 @@\n-        var plist = MacHelper.readPListFromAppImage(appImage);\n+        final var rootPlist = MacHelper.readPListFromAppImage(appImage);\n+\n+        TKit.traceFileContents(appImage.resolve(\"Contents\/Info.plist\"), \"Info.plist\");\n+\n+        var plist = rootPlist.queryArrayValue(\"CFBundleDocumentTypes\", false).findFirst().map(PListReader.class::cast).orElseThrow();\n+\n@@ -106,2 +112,7 @@\n-        checkArrayValue(plist, \"NSExportableTypes\", List.of(\"public.png\",\n-                                                            \"public.jpg\"));\n+        plist = rootPlist.queryArrayValue(\"UTExportedTypeDeclarations\", false).findFirst().map(PListReader.class::cast).orElseThrow();\n+\n+        checkArrayValue(plist, \"UTTypeConformsTo\", List.of(\"public.image\", \"public.data\"));\n+\n+        plist = plist.queryDictValue(\"UTTypeTagSpecification\");\n+\n+        checkArrayValue(plist, \"NSExportableTypes\", List.of(\"public.png\", \"public.jpg\"));\n@@ -109,2 +120,0 @@\n-        checkArrayValue(plist, \"UTTypeConformsTo\", List.of(\"public.image\",\n-                                                           \"public.data\"));\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/MacFileAssociationsTest.java","additions":22,"deletions":13,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -55,2 +55,0 @@\n-jdk\/jshell\/ToolSimpleTest.java                                                  8366582    generic-all\n-jdk\/jshell\/ToolLocalSimpleTest.java                                             8366582    generic-all\n","filename":"test\/langtools\/ProblemList.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8366926\n+ * @summary Verify the instrumenation class hierarchy resolution works properly in local execution mode\n+ * @library \/tools\/lib\n+ * @modules\n+ *      jdk.compiler\/com.sun.tools.javac.api\n+ *      jdk.compiler\/com.sun.tools.javac.main\n+ * @build KullaTesting\n+ * @run junit\/othervm LocalExecutionInstrumentationCHRTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n+public class LocalExecutionInstrumentationCHRTest extends ReplToolTesting {\n+\n+    @Test\n+    public void verifyMyClassFoundOnClassPath() {\n+        test(new String[] { \"--execution\", \"local\" },\n+            a -> assertCommand(a, \"public interface TestInterface {}\", \"|  created interface TestInterface\"),\n+            a -> assertCommand(a,\n+                      \"public class TestClass {\"\n+                        + \"public TestInterface foo(boolean b) {\"\n+                            + \"TestInterface test; \"\n+                            + \"if (b) {\"\n+                                + \"test = new TestInterfaceImpl1();\"\n+                            + \"} else {\"\n+                                + \"test = new TestInterfaceImpl2();\"\n+                            + \"}\"\n+                            + \"return test;\"\n+                        + \"}\"\n+                        + \"private class TestInterfaceImpl1 implements TestInterface {}\"\n+                        + \"private class TestInterfaceImpl2 implements TestInterface {}\"\n+                    + \"}\", \"|  created class TestClass\"),\n+            a -> assertCommand(a, \"new TestClass().foo(true).getClass();\", \"$3 ==> class TestClass$TestInterfaceImpl1\"),\n+            a -> assertCommand(a, \"new TestClass().foo(false).getClass();\", \"$4 ==> class TestClass$TestInterfaceImpl2\")\n+        );\n+    }\n+}\n","filename":"test\/langtools\/jdk\/jshell\/LocalExecutionInstrumentationCHRTest.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -41,1 +41,0 @@\n-import java.nio.ByteBuffer;\n@@ -53,2 +52,0 @@\n-import java.security.MessageDigest;\n-import java.security.NoSuchAlgorithmException;\n@@ -74,0 +71,1 @@\n+import java.util.zip.CRC32C;\n@@ -173,10 +171,5 @@\n-               \/\/ promotable build -> use 1st 8 bytes of md5($version)\n-               try {\n-                   var md = MessageDigest.getInstance(\"MD5\");\n-                   var bytes = v.toString()\n-                                .getBytes(StandardCharsets.UTF_8);\n-                   bytes = md.digest(bytes);\n-                   SEED = ByteBuffer.wrap(bytes).getLong();\n-               } catch (NoSuchAlgorithmException e) {\n-                   throw new Error(e);\n-               }\n+               \/\/ promotable build -> generate a seed based on the version string\n+               var bytes = v.toString().getBytes(StandardCharsets.UTF_8);\n+               var crc = new CRC32C();\n+               crc.update(bytes);\n+               SEED = crc.getValue();\n","filename":"test\/lib\/jdk\/test\/lib\/Utils.java","additions":6,"deletions":13,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -26,2 +26,1 @@\n-import jtreg.SkippedException;\n-\n+import java.io.IOException;\n@@ -93,1 +92,1 @@\n-     * @throws SkippedException thrown if the artifact cannot be found\n+     * @throws IOException thrown if the artifact cannot be found\n@@ -95,1 +94,1 @@\n-    public static Path fetchOne(Class<?> klass) {\n+    public static Path fetchOne(Class<?> klass) throws IOException {\n@@ -101,1 +100,1 @@\n-            throw new SkippedException(\"Cannot find the artifact \" + artifact.name(), e);\n+            throw new IOException(\"Cannot find the artifact \" + artifact.name(), e);\n","filename":"test\/lib\/jdk\/test\/lib\/artifacts\/ArtifactResolver.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.io.IOException;\n@@ -52,0 +53,1 @@\n+     *         or if OpenSSL is not available on the target platform\n@@ -56,0 +58,1 @@\n+            System.out.println(\"Using OpenSSL from system property.\");\n@@ -58,0 +61,1 @@\n+\n@@ -60,0 +64,1 @@\n+            System.out.println(\"Using OpenSSL from system.\");\n@@ -62,0 +67,1 @@\n+\n@@ -64,1 +70,1 @@\n-                path = fetchOpenssl(LINUX_X64.class);\n+                return fetchOpenssl(LINUX_X64.class);\n@@ -66,1 +72,1 @@\n-                path = fetchOpenssl(MACOSX_X64.class);\n+                return fetchOpenssl(MACOSX_X64.class);\n@@ -68,1 +74,1 @@\n-                path = fetchOpenssl(WINDOWS_X64.class);\n+                return fetchOpenssl(WINDOWS_X64.class);\n@@ -72,1 +78,1 @@\n-                path = fetchOpenssl(LINUX_AARCH64.class);\n+                return fetchOpenssl(LINUX_AARCH64.class);\n@@ -75,1 +81,1 @@\n-                path = fetchOpenssl(MACOSX_AARCH64.class);\n+                return fetchOpenssl(MACOSX_AARCH64.class);\n@@ -79,9 +85,2 @@\n-        if (!verifyOpensslVersion(path, OPENSSL_BUNDLE_VERSION)) {\n-            String exMsg = \"Can't find the version: \"\n-                    + OpensslArtifactFetcher.getTestOpensslBundleVersion()\n-                    + \" of openssl binary on this machine, please install\"\n-                    + \" and set openssl path with property 'test.openssl.path'\";\n-            throw new SkippedException(exMsg);\n-        } else {\n-            return path;\n-        }\n+        throw new SkippedException(String.format(\"No OpenSSL %s found for %s\/%s\",\n+                OPENSSL_BUNDLE_VERSION, Platform.getOsName(), Platform.getOsArch()));\n@@ -123,3 +122,7 @@\n-        return ArtifactResolver.fetchOne(clazz)\n-                .resolve(\"openssl\", \"bin\", \"openssl\")\n-                .toString();\n+        try {\n+            return ArtifactResolver.fetchOne(clazz)\n+                    .resolve(\"openssl\", \"bin\", \"openssl\")\n+                    .toString();\n+        } catch (IOException exc) {\n+            throw new SkippedException(\"Could not find openssl\", exc);\n+        }\n","filename":"test\/lib\/jdk\/test\/lib\/security\/OpensslArtifactFetcher.java","additions":20,"deletions":17,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -299,0 +299,10 @@\n+        \/**\n+         * Returns the owner of the parkBlocker if the parkBlocker is an AbstractOwnableSynchronizer.\n+         *\/\n+        public OptionalLong parkBlockerOwner() {\n+            String owner = getStringProperty(\"parkBlocker\", \"owner\");\n+            return (owner != null)\n+                    ? OptionalLong.of(Long.parseLong(owner))\n+                    : OptionalLong.empty();\n+        }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/threaddump\/ThreadDump.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+import java.math.BigDecimal;\n@@ -28,0 +29,1 @@\n+import java.util.stream.DoubleStream;\n@@ -32,0 +34,1 @@\n+import org.openjdk.jmh.annotations.Level;\n@@ -53,0 +56,1 @@\n+    public static final int VALUES_SIZE = 13;\n@@ -54,0 +58,2 @@\n+    public BigDecimal[] bdLargeValues;\n+    public BigDecimal[] bdSmallValues;\n@@ -55,1 +61,1 @@\n-    @Setup\n+    @Setup(Level.Invocation)\n@@ -60,0 +66,8 @@\n+\n+        bdLargeValues = DoubleStream.of(values)\n+                .mapToObj(BigDecimal::new)\n+                .toArray(BigDecimal[]::new);\n+\n+        bdSmallValues = DoubleStream.of(values)\n+                .mapToObj(BigDecimal::valueOf)\n+                .toArray(BigDecimal[]::new);\n@@ -65,1 +79,1 @@\n-    @OperationsPerInvocation(13)\n+    @OperationsPerInvocation(VALUES_SIZE)\n@@ -72,0 +86,16 @@\n+    @Benchmark\n+    @OperationsPerInvocation(VALUES_SIZE)\n+    public void testSmallBigDecDefNumberFormatter(final Blackhole blackhole) {\n+        for (BigDecimal value : bdSmallValues) {\n+            blackhole.consume(this.dnf.format(value));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(VALUES_SIZE)\n+    public void testLargeBigDecDefNumberFormatter(final Blackhole blackhole) {\n+        for (BigDecimal value : bdLargeValues) {\n+            blackhole.consume(this.dnf.format(value));\n+        }\n+    }\n+\n@@ -91,0 +121,4 @@\n+\n+        public String format(final BigDecimal bd) {\n+            return this.n.format(bd);\n+        }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/text\/DefFormatterBench.java","additions":37,"deletions":3,"binary":false,"changes":40,"status":"modified"}]}