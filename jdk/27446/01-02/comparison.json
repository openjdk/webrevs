{"files":[{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/globals_extension.hpp\"\n@@ -35,2 +36,0 @@\n-\n-static const char* g_asan_report = nullptr;\n@@ -38,1 +37,2 @@\n-static callback_setter_t callback_setter = nullptr;\n+static callback_setter_t g_callback_setter = nullptr;\n+static const char* g_report = nullptr;\n@@ -41,7 +41,8 @@\n-  \/\/ Keep things very short and simple here;\n-  \/\/ Do use as little as possible of any hotspot infrastructure.\n-  \/\/ We will print out the report text on stderr; then, we will\n-  \/\/ end the JVM with a fatal error, resulting in hs-err file\n-  \/\/ and core dump. VMError will also print the error report\n-  \/\/ to the hs-err file.\n-  g_asan_report = report_text;\n+  \/\/ Please keep things very short and simple here and use as little\n+  \/\/ as possible of any hotspot infrastructure. However shaky the JVM,\n+  \/\/ we should always at least get the ASAN report on stderr.\n+\n+  \/\/ Note: this is threadsafe since ASAN synchronizes error reports\n+  g_report = report_text;\n+\n+  \/\/ First, print off the bare error to stderr\n@@ -50,2 +51,0 @@\n-  fatal(\"ASAN error caught\");\n-}\n@@ -53,2 +52,2 @@\n-const char* Asan::report() {\n-  return g_asan_report;\n+  \/\/ Then, let normal JVM error handling run its due course.\n+  fatal(\"ASAN Error\");\n@@ -58,6 +57,57 @@\n-  callback_setter = (callback_setter_t) dlsym(RTLD_DEFAULT, \"__asan_set_error_report_callback\");\n-  if (callback_setter) {\n-    callback_setter(asan_error_callback);\n-    log_info(asan)(\"JVM callback for ASAN errors successfully installed\");\n-  } else {\n-    log_info(asan)(\"*** Failed to install JVM callback for ASAN. ASAN errors will not generate hs-err files. ***\");\n+\n+  g_callback_setter = (callback_setter_t) dlsym(RTLD_DEFAULT, \"__asan_set_error_report_callback\");\n+  if (g_callback_setter == nullptr) {\n+    log_warning(asan)(\"*** Failed to install JVM callback for ASAN. ASAN errors will not generate hs-err files. ***\");\n+    return;\n+  }\n+\n+  g_callback_setter(asan_error_callback);\n+  log_info(asan)(\"JVM callback for ASAN errors successfully installed\");\n+\n+  \/\/ Controlling core dump behavior:\n+  \/\/\n+  \/\/ In hotspot, CreateCoredumpOnCrash decides whether to create a core dump (on Posix, whether to\n+  \/\/ end the process with abort(3) or exit(3)).\n+  \/\/\n+  \/\/ Core generation in the default ASAN reporter is controlled by two options:\n+  \/\/ - \"abort_on_error=0\" (default) - end with exit(3), \"abort_on_error=1\" end with abort(3)\n+  \/\/ - \"disable_coredump=1\" (default) disables cores by imposing a near-zero core soft limit.\n+  \/\/ By default both options are set to prevent cores. That default makes sense since ASAN cores\n+  \/\/ can get very large (due to the shadow map) and very numerous (ASAN is typically ran for\n+  \/\/ large-scale integration tests, not targeted micro-tests).\n+  \/\/\n+  \/\/ In hotspot ASAN builds, we replace the default ASAN reporter. The soft limit imposed by\n+  \/\/ \"disable_coredump=1\" is still in effect. But \"abort_on_error\" is not honored. Since we'd\n+  \/\/ like to exhibit exactly the same behavior as the standard ASAN error reporter, we honor\n+  \/\/ \"abort_on_error=1\" by ending the JVM with exit(3) (we just switch off CreateCoredumpOnCrash).\n+  \/\/\n+  \/\/ Thus:\n+  \/\/     abort_on_error      disable_coredump       core file?\n+  \/\/         0                   0                  No  (enforced by ergo-setting CreateCoredumpOnCrash=0)\n+  \/\/ (*)     0                   1                  No  (enforced by ASAN-imposed soft limit)\n+  \/\/         1                   0                  Yes, unless -XX:-CreateCoredumpOnCrash set on command line\n+  \/\/         1                   1                  No  (enforced by ASAN-imposed soft limit)\n+  \/\/ (*) is the default if no ASAN options are specified.\n+\n+  const char* const asan_options = getenv(\"ASAN_OPTIONS\");\n+  const bool abort_on_error = (asan_options != nullptr) && ::strstr(asan_options, \"abort_on_error=1\");\n+  if (!abort_on_error) {\n+    if (CreateCoredumpOnCrash && FLAG_IS_CMDLINE(CreateCoredumpOnCrash)) {\n+      log_warning(asan)(\"CreateCoredumpOnCrash overruled by%s abort_on_error, core generation will be disabled.\",\n+                        asan_options != nullptr ? \"\" : \" default setting for\");\n+      log_warning(asan)(\"Use 'ASAN_OPTIONS=abort_on_error=1:disable_coredump=0:unmap_shadow_on_exit=1' to enable core generation.\");\n+    }\n+    FLAG_SET_ERGO(CreateCoredumpOnCrash, false);\n+  }\n+}\n+\n+bool Asan::had_error() {\n+  return g_report != nullptr;\n+}\n+\n+void Asan::report(outputStream* st) {\n+  if (had_error()) {\n+    \/\/ Use raw print here to avoid truncation.\n+    st->print_raw(g_report);\n+    st->cr();\n+    st->cr();\n","filename":"src\/hotspot\/share\/sanitizers\/address.cpp","additions":70,"deletions":20,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -79,0 +79,2 @@\n+class outputStream;\n+\n@@ -82,2 +84,2 @@\n-  \/\/ Returns the ASAN report text; nullptr if no ASAN error happened.\n-  static const char* report();\n+  static bool had_error();\n+  static void report(outputStream* st);\n","filename":"src\/hotspot\/share\/sanitizers\/address.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -915,1 +915,1 @@\n-  STEP_IF(\"printing ASAN error information\", _verbose && Asan::report() != nullptr)\n+  STEP_IF(\"printing ASAN error information\", _verbose && Asan::had_error())\n@@ -919,3 +919,1 @@\n-    \/\/ Note: Use print_raw, not print or print_cr, to avoid truncation\n-    \/\/ (report can be longer than 2K)\n-    st->print_raw(Asan::report());\n+    Asan::report(st);\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import java.util.Arrays;\n@@ -44,1 +43,0 @@\n-import jdk.test.lib.Platform;\n@@ -52,2 +50,5 @@\n-                \"-Xmx100M\",\n-                \"-XX:-CreateCoredumpOnCrash\",\n+                \"-Xmx64M\", \"-XX:CompressedClassSpaceSize=64M\",\n+                \/\/ Default ASAN options should prevent core file generation, which should overrule +CreateCoredumpOnCrash.\n+                \/\/ We test below.\n+                \"-XX:+CreateCoredumpOnCrash\",\n+                \"-Xlog:asan\",\n@@ -65,0 +66,1 @@\n+        output.shouldContain(\"CreateCoredumpOnCrash overruled\");\n@@ -66,3 +68,4 @@\n-        output.shouldContain(\"# A fatal error has been detected by the Java Runtime Environment\");\n-        output.shouldMatch(\".*AddressSanitizer.*double-free.*\");\n-        output.shouldContain(\"#  fatal error: ASAN error\");\n+        output.shouldMatch(\"AddressSanitizer.*double-free\");\n+        output.shouldMatch(\"# +A fatal error has been detected by the Java Runtime Environment\");\n+        output.shouldMatch(\"# +fatal error: ASAN\");\n+        output.shouldNotContain(\"Aborted (core dumped)\");\n@@ -77,1 +80,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/AsanReportTest.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"}]}