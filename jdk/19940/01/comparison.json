{"files":[{"patch":"@@ -452,0 +452,4 @@\n+  AssertionPredicateType assertion_predicate_type() const {\n+    return _assertion_predicate_type;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1845,1 +1845,1 @@\n-    case AssertionPredicateType::Init_value:\n+    case AssertionPredicateType::InitValue:\n@@ -1848,1 +1848,1 @@\n-    case AssertionPredicateType::Last_value:\n+    case AssertionPredicateType::LastValue:\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1327,1 +1327,1 @@\n-                                                     false NOT_PRODUCT(COMMA AssertionPredicateType::Init_value));\n+                                                     false NOT_PRODUCT(COMMA AssertionPredicateType::InitValue));\n@@ -1353,1 +1353,1 @@\n-                                         false NOT_PRODUCT(COMMA AssertionPredicateType::Last_value));\n+                                         false NOT_PRODUCT(COMMA AssertionPredicateType::LastValue));\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1376,1 +1376,0 @@\n-        assert(assertion_predicate_has_loop_opaque_node(iff), \"must find OpaqueLoop* nodes\");\n@@ -1380,7 +1379,3 @@\n-        prev_proj = clone_assertion_predicate_and_initialize(iff, opaque_init, nullptr, predicate_proj, uncommon_proj,\n-                                                             current_proj, outer_loop, prev_proj);\n-        assert(assertion_predicate_has_loop_opaque_node(prev_proj->in(0)->as_If()), \"\");\n-\n-        prev_proj = clone_assertion_predicate_and_initialize(iff, init, stride, predicate_proj, uncommon_proj,\n-                                                             current_proj, outer_loop, prev_proj);\n-        assert(!assertion_predicate_has_loop_opaque_node(prev_proj->in(0)->as_If()), \"\");\n+        prev_proj = clone_template_assertion_predicate(iff, opaque_init, predicate_proj, uncommon_proj,\n+                                                       current_proj, outer_loop, prev_proj);\n+        prev_proj = create_initialized_assertion_predicate(iff, init, stride, prev_proj);\n@@ -1480,5 +1475,19 @@\n-\/\/ Clone an Assertion Predicate for the main loop. new_init and new_stride are set as new inputs. Since the predicates\n-\/\/ cannot fail at runtime, Halt nodes are inserted instead of uncommon traps.\n-Node* PhaseIdealLoop::clone_assertion_predicate_and_initialize(Node* iff, Node* new_init, Node* new_stride, Node* predicate,\n-                                                               Node* uncommon_proj, Node* control, IdealLoopTree* outer_loop,\n-                                                               Node* input_proj) {\n+\/\/ Create an Initialized Assertion Predicate from the template_assertion_predicate\n+IfTrueNode* PhaseIdealLoop::create_initialized_assertion_predicate(IfNode* template_assertion_predicate, Node* new_init,\n+                                                                   Node* new_stride, Node* control) {\n+  assert(assertion_predicate_has_loop_opaque_node(template_assertion_predicate),\n+         \"must find OpaqueLoop* nodes for Template Assertion Predicate\");\n+  InitializedAssertionPredicate initialized_assertion_predicate(template_assertion_predicate, new_init, new_stride, this);\n+  IfTrueNode* success_proj = initialized_assertion_predicate.create(control);\n+  assert(!assertion_predicate_has_loop_opaque_node(success_proj->in(0)->as_If()),\n+         \"Initialized Assertion Predicates do not have OpaqueLoop* nodes in the bool expression anymore\");\n+  return success_proj;\n+}\n+\n+\/\/ Clone the Template Assertion Predicate and set a new OpaqueLoopInitNode to create a new Template Assertion Predicate.\n+\/\/ This is done when creating a new Template Assertion Predicate for the main loop which requires a new init node.\n+\/\/ We keep the Opaque4 node since it's still a template. Since the templates are eventually removed after loop opts,\n+\/\/ these are never executed. We therefore insert a Halt node instead of an uncommon trap.\n+Node* PhaseIdealLoop::clone_template_assertion_predicate(IfNode* iff, Node* new_init, Node* predicate, Node* uncommon_proj,\n+                                                         Node* control, IdealLoopTree* outer_loop, Node* input_proj) {\n+  assert(assertion_predicate_has_loop_opaque_node(iff), \"must find OpaqueLoop* nodes for Template Assertion Predicate\");\n@@ -1486,15 +1495,2 @@\n-  Node* new_opaque_node;\n-  if (new_stride == nullptr) {\n-    \/\/ Clone the Template Assertion Predicate and set a new OpaqueLoopInitNode to create a new Template Assertion Predicate.\n-    \/\/ This is done when creating a new Template Assertion Predicate for the main loop which requires a new init node.\n-    \/\/ We keep the Opaque4 node since it's still a template.\n-    assert(new_init->is_OpaqueLoopInit(), \"only for creating new Template Assertion Predicates\");\n-    new_opaque_node = template_assertion_predicate_expression.clone_and_replace_init(new_init, control, this);\n-  } else {\n-    \/\/ Create an Initialized Assertion Predicate from the Template Assertion Predicate.\n-    new_opaque_node = template_assertion_predicate_expression.clone_and_replace_init_and_stride(new_init, new_stride,\n-                                                                                                 control, this);\n-    \/\/ Since this is an Initialized Assertion Predicate, we use the dedicated opaque node.\n-    new_opaque_node = new OpaqueInitializedAssertionPredicateNode(new_opaque_node->in(1)->as_Bool(), C);\n-    register_new_node(new_opaque_node, control);\n-  }\n+  assert(new_init->is_OpaqueLoopInit(), \"only for creating new Template Assertion Predicates\");\n+  Opaque4Node* new_opaque_node = template_assertion_predicate_expression.clone_and_replace_init(new_init, control, this);\n@@ -1509,2 +1505,1 @@\n-  \/\/ It's impossible for the predicate to fail at runtime. Use a Halt node.\n-  Node* halt = new HaltNode(other_proj, frame, \"duplicated predicate failed which is impossible\");\n+  Node* halt = new HaltNode(other_proj, frame, \"Template Assertion Predicates are always removed before code generation\");\n@@ -1518,0 +1513,2 @@\n+  assert(assertion_predicate_has_loop_opaque_node(proj->in(0)->as_If()),\n+         \"Template Assertion Predicates must have OpaqueLoop* nodes in the bool expression\");\n@@ -1970,3 +1967,1 @@\n-        prev_proj = clone_assertion_predicate_and_initialize(iff, init, max_value, entry, proj, ctrl, outer_loop,\n-                                                             prev_proj);\n-        assert(!assertion_predicate_has_loop_opaque_node(prev_proj->in(0)->as_If()), \"unexpected\");\n+        prev_proj = create_initialized_assertion_predicate(iff, init, max_value, prev_proj);\n@@ -2011,4 +2006,1 @@\n-      assert(assertion_predicate_has_loop_opaque_node(iff), \"must find OpaqueLoop* nodes\");\n-      prev_proj = clone_assertion_predicate_and_initialize(iff, init, stride, ctrl, proj, post_loop_entry,\n-                                                           post_loop, prev_proj);\n-      assert(!assertion_predicate_has_loop_opaque_node(prev_proj->in(0)->as_If()), \"must not find OpaqueLoop* nodes\");\n+      prev_proj = create_initialized_assertion_predicate(iff, init, stride, prev_proj);\n@@ -2033,3 +2025,1 @@\n-  Node* control = outer_loop_head->in(LoopNode::EntryControl);\n-  Node* input_proj = control;\n-\n+  Node* input_proj = outer_loop_head->in(LoopNode::EntryControl);\n@@ -2049,3 +2039,1 @@\n-      assert(assertion_predicate_has_loop_opaque_node(iff), \"must find OpaqueLoop* nodes\");\n-      input_proj = clone_assertion_predicate_and_initialize(iff, init, stride, next_regular_predicate_proj, uncommon_proj, control,\n-                                                            outer_loop, input_proj);\n+      input_proj = create_initialized_assertion_predicate(iff, init, stride, input_proj);\n@@ -2997,1 +2985,1 @@\n-              NOT_PRODUCT(COMMA AssertionPredicateType::Init_value));\n+              NOT_PRODUCT(COMMA AssertionPredicateType::InitValue));\n@@ -3011,1 +2999,1 @@\n-              NOT_PRODUCT(COMMA AssertionPredicateType::Last_value));\n+              NOT_PRODUCT(COMMA AssertionPredicateType::LastValue));\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":33,"deletions":45,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -950,3 +950,4 @@\n-  Node* clone_assertion_predicate_and_initialize(Node* iff, Node* new_init, Node* new_stride, Node* predicate,\n-                                                 Node* uncommon_proj, Node* control, IdealLoopTree* outer_loop,\n-                                                 Node* input_proj);\n+  Node* clone_template_assertion_predicate(IfNode* iff, Node* new_init, Node* predicate, Node* uncommon_proj, Node* control,\n+                                           IdealLoopTree* outer_loop, Node* input_proj);\n+  IfTrueNode* create_initialized_assertion_predicate(IfNode* template_assertion_predicate, Node* new_init,\n+                                                     Node* new_stride, Node* control);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"opto\/rootnode.hpp\"\n@@ -384,0 +385,80 @@\n+InitializedAssertionPredicate::InitializedAssertionPredicate(IfNode* template_assertion_predicate, Node* new_init,\n+                                                             Node* new_stride, PhaseIdealLoop* phase)\n+    : _template_assertion_predicate(template_assertion_predicate),\n+      _new_init(new_init),\n+      _new_stride(new_stride),\n+      _phase(phase) {}\n+\n+\/\/ Create an Initialized Assertion Predicate at the provided control from the _template_assertion_predicate.\n+\/\/ We clone the Template Assertion Predicate Expression and replace:\n+\/\/ - Opaque4 with OpaqueInitializedAssertionPredicate\n+\/\/ - OpaqueLoop*Nodes with _new_init and _new_stride, respectively.\n+\/\/\n+\/\/          init                 stride\n+\/\/            |                    |\n+\/\/   OpaqueLoopInitNode  OpaqueLoopStrideNode                      _new_init    _new_stride\n+\/\/                  \\     \/                                               \\     \/\n+\/\/                    ...                                                   ...\n+\/\/                     |                                                     |\n+\/\/                    Bool                                                new Bool\n+\/\/                     |                                                     |\n+\/\/                  Opaque4                ======>              control   OpaqueInitializedAssertionPredicate\n+\/\/                     |                                              \\  \/\n+\/\/                    If                                             new If\n+\/\/                  \/    \\                                           \/    \\\n+\/\/            success     fail path                         new success   new Halt\n+\/\/              proj    (Halt or UCT)                           proj\n+\/\/\n+IfTrueNode* InitializedAssertionPredicate::create(Node* control) {\n+  IdealLoopTree* loop = _phase->get_loop(control);\n+  OpaqueInitializedAssertionPredicateNode* assertion_expression = create_assertion_expression(control);\n+  IfNode* if_node = create_if_node(control, assertion_expression, loop);\n+  create_fail_path(if_node, loop);\n+  return create_success_path(if_node, loop);\n+}\n+\n+\/\/ Create a new Assertion Expression to be used as bool input for the Initialized Assertion Predicate IfNode.\n+OpaqueInitializedAssertionPredicateNode* InitializedAssertionPredicate::create_assertion_expression(Node* control) {\n+  Opaque4Node* template_opaque = _template_assertion_predicate->in(1)->as_Opaque4();\n+  TemplateAssertionPredicateExpression assertion_expression(template_opaque);\n+  Opaque4Node* tmp_opaque =\n+      assertion_expression.clone_and_replace_init_and_stride(_new_init, _new_stride, control, _phase);\n+  OpaqueInitializedAssertionPredicateNode* assertion_predicate_expression\n+      = new OpaqueInitializedAssertionPredicateNode(tmp_opaque->in(1)->as_Bool(), _phase->C);\n+  _phase->register_new_node(assertion_predicate_expression, control);\n+  return assertion_predicate_expression;\n+}\n+\n+IfNode* InitializedAssertionPredicate::create_if_node(Node* control,\n+                                                      OpaqueInitializedAssertionPredicateNode* assertion_expression,\n+                                                      IdealLoopTree* loop) {\n+  const int if_opcode = _template_assertion_predicate->Opcode();\n+  const AssertionPredicateType assertion_predicate_type = _template_assertion_predicate->assertion_predicate_type();\n+  IfNode* if_node = if_opcode == Op_If ?\n+      new IfNode(control, assertion_expression, PROB_MAX, COUNT_UNKNOWN NOT_PRODUCT(COMMA assertion_predicate_type)) :\n+      new RangeCheckNode(control, assertion_expression, PROB_MAX, COUNT_UNKNOWN NOT_PRODUCT(COMMA assertion_predicate_type));\n+  _phase->register_control(if_node, loop, control);\n+  return if_node;\n+}\n+\n+IfTrueNode* InitializedAssertionPredicate::create_success_path(IfNode* if_node, IdealLoopTree* loop) {\n+  IfTrueNode* success_proj = new IfTrueNode(if_node);\n+  _phase->register_control(success_proj, loop, if_node);\n+  return success_proj;\n+}\n+\n+void InitializedAssertionPredicate::create_fail_path(IfNode* if_node, IdealLoopTree* loop) {\n+  IfFalseNode* fail_proj = new IfFalseNode(if_node);\n+  _phase->register_control(fail_proj, loop, if_node);\n+  create_halt_node(fail_proj, loop);\n+}\n+\n+void InitializedAssertionPredicate::create_halt_node(IfFalseNode* fail_proj, IdealLoopTree* loop) {\n+  StartNode* start_node = _phase->C->start();\n+  Node* frame = new ParmNode(start_node, TypeFunc::FramePtr);\n+  _phase->register_new_node(frame, start_node);\n+  Node* halt = new HaltNode(fail_proj, frame, \"Initialized Assertion Predicate cannot fail\");\n+  _phase->igvn().add_input_to(_phase->C->root(), halt);\n+  _phase->register_control(halt, loop, fail_proj);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":81,"deletions":0,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+class IdealLoopTree;\n+\n@@ -201,2 +203,2 @@\n-  Init_value,\n-  Last_value\n+  InitValue,\n+  LastValue\n@@ -321,1 +323,1 @@\n-\/\/ Class to represent a node being part of a Template Assertion Predicate Expression.\n+\/\/ Class to represent a node being part of a Template Assertion Predicate Expression. Note that this is not an IR node.\n@@ -395,0 +397,23 @@\n+\/\/ This class creates a new Initialized Assertion Predicate.\n+class InitializedAssertionPredicate : public StackObj {\n+  IfNode* const _template_assertion_predicate;\n+  Node* const _new_init;\n+  Node* const _new_stride;\n+  PhaseIdealLoop* const _phase;\n+\n+ public:\n+  InitializedAssertionPredicate(IfNode* template_assertion_predicate, Node* new_init, Node* new_stride,\n+                                PhaseIdealLoop* phase);\n+  NONCOPYABLE(InitializedAssertionPredicate);\n+\n+  IfTrueNode* create(Node* control);\n+\n+ private:\n+  OpaqueInitializedAssertionPredicateNode* create_assertion_expression(Node* control);\n+  IfNode* create_if_node(Node* control, OpaqueInitializedAssertionPredicateNode* assertion_expression, IdealLoopTree* loop);\n+  void create_fail_path(IfNode* if_node, IdealLoopTree* loop);\n+  void create_halt_node(IfFalseNode* fail_proj, IdealLoopTree* loop);\n+  IfTrueNode* create_success_path(IfNode* if_node, IdealLoopTree* loop);\n+};\n+\n+\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":28,"deletions":3,"binary":false,"changes":31,"status":"modified"}]}