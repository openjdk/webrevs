{"files":[{"patch":"@@ -452,0 +452,4 @@\n+  AssertionPredicateType assertion_predicate_type() const {\n+    return _assertion_predicate_type;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1846,1 +1846,1 @@\n-    case AssertionPredicateType::Init_value:\n+    case AssertionPredicateType::InitValue:\n@@ -1849,1 +1849,1 @@\n-    case AssertionPredicateType::Last_value:\n+    case AssertionPredicateType::LastValue:\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -377,4 +377,4 @@\n-  TemplateAssertionPredicateExpression template_assertion_predicate_expression(\n-      template_assertion_predicate->in(1)->as_Opaque4());\n-  Opaque4Node* cloned_opaque4_node = template_assertion_predicate_expression.clone(parse_predicate_proj->in(0)->in(0), this);\n-  IfProjNode* if_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, reason, template_assertion_predicate->Opcode(), false);\n+  TemplateAssertionExpression template_assertion_expression(template_assertion_predicate->in(1)->as_Opaque4());\n+  Opaque4Node* cloned_opaque4_node = template_assertion_expression.clone(parse_predicate_proj->in(0)->in(0), this);\n+  IfProjNode* if_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, reason,\n+                                                    template_assertion_predicate->Opcode(), false);\n@@ -1327,1 +1327,1 @@\n-                                                     false NOT_PRODUCT(COMMA AssertionPredicateType::Init_value));\n+                                                     false NOT_PRODUCT(COMMA AssertionPredicateType::InitValue));\n@@ -1353,1 +1353,1 @@\n-                                         false NOT_PRODUCT(COMMA AssertionPredicateType::Last_value));\n+                                         false NOT_PRODUCT(COMMA AssertionPredicateType::LastValue));\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1376,1 +1376,0 @@\n-        assert(assertion_predicate_has_loop_opaque_node(iff), \"must find OpaqueLoop* nodes\");\n@@ -1380,7 +1379,3 @@\n-        prev_proj = clone_assertion_predicate_and_initialize(iff, opaque_init, nullptr, predicate_proj, uncommon_proj,\n-                                                             current_proj, outer_loop, prev_proj);\n-        assert(assertion_predicate_has_loop_opaque_node(prev_proj->in(0)->as_If()), \"\");\n-\n-        prev_proj = clone_assertion_predicate_and_initialize(iff, init, stride, predicate_proj, uncommon_proj,\n-                                                             current_proj, outer_loop, prev_proj);\n-        assert(!assertion_predicate_has_loop_opaque_node(prev_proj->in(0)->as_If()), \"\");\n+        prev_proj = clone_template_assertion_predicate(iff, opaque_init, predicate_proj, uncommon_proj,\n+                                                       current_proj, outer_loop, prev_proj);\n+        prev_proj = create_initialized_assertion_predicate(iff, init, stride, prev_proj);\n@@ -1463,1 +1458,1 @@\n-    if (TemplateAssertionPredicateExpressionNode::is_maybe_in_expression(n)) {\n+    if (TemplateAssertionExpressionNode::is_maybe_in_expression(n)) {\n@@ -1480,21 +1475,22 @@\n-\/\/ Clone an Assertion Predicate for the main loop. new_init and new_stride are set as new inputs. Since the predicates\n-\/\/ cannot fail at runtime, Halt nodes are inserted instead of uncommon traps.\n-Node* PhaseIdealLoop::clone_assertion_predicate_and_initialize(Node* iff, Node* new_init, Node* new_stride, Node* predicate,\n-                                                               Node* uncommon_proj, Node* control, IdealLoopTree* outer_loop,\n-                                                               Node* input_proj) {\n-  TemplateAssertionPredicateExpression template_assertion_predicate_expression(iff->in(1)->as_Opaque4());\n-  Node* new_opaque_node;\n-  if (new_stride == nullptr) {\n-    \/\/ Clone the Template Assertion Predicate and set a new OpaqueLoopInitNode to create a new Template Assertion Predicate.\n-    \/\/ This is done when creating a new Template Assertion Predicate for the main loop which requires a new init node.\n-    \/\/ We keep the Opaque4 node since it's still a template.\n-    assert(new_init->is_OpaqueLoopInit(), \"only for creating new Template Assertion Predicates\");\n-    new_opaque_node = template_assertion_predicate_expression.clone_and_replace_init(new_init, control, this);\n-  } else {\n-    \/\/ Create an Initialized Assertion Predicate from the Template Assertion Predicate.\n-    new_opaque_node = template_assertion_predicate_expression.clone_and_replace_init_and_stride(new_init, new_stride,\n-                                                                                                 control, this);\n-    \/\/ Since this is an Initialized Assertion Predicate, we use the dedicated opaque node.\n-    new_opaque_node = new OpaqueInitializedAssertionPredicateNode(new_opaque_node->in(1)->as_Bool(), C);\n-    register_new_node(new_opaque_node, control);\n-  }\n+\/\/ Create an Initialized Assertion Predicate from the template_assertion_predicate\n+IfTrueNode* PhaseIdealLoop::create_initialized_assertion_predicate(IfNode* template_assertion_predicate, Node* new_init,\n+                                                                   Node* new_stride, Node* control) {\n+  assert(assertion_predicate_has_loop_opaque_node(template_assertion_predicate),\n+         \"must find OpaqueLoop* nodes for Template Assertion Predicate\");\n+  InitializedAssertionPredicate initialized_assertion_predicate(template_assertion_predicate, new_init, new_stride, this);\n+  IfTrueNode* success_proj = initialized_assertion_predicate.create(control);\n+  assert(!assertion_predicate_has_loop_opaque_node(success_proj->in(0)->as_If()),\n+         \"Initialized Assertion Predicates do not have OpaqueLoop* nodes in the bool expression anymore\");\n+  return success_proj;\n+}\n+\n+\/\/ Clone the Template Assertion Predicate and set a new OpaqueLoopInitNode to create a new Template Assertion Predicate.\n+\/\/ This is done when creating a new Template Assertion Predicate for the main loop which requires a new init node.\n+\/\/ We keep the Opaque4 node since it's still a template. Since the templates are eventually removed after loop opts,\n+\/\/ these are never executed. We therefore insert a Halt node instead of an uncommon trap.\n+Node* PhaseIdealLoop::clone_template_assertion_predicate(IfNode* iff, Node* new_init, Node* predicate, Node* uncommon_proj,\n+                                                         Node* control, IdealLoopTree* outer_loop, Node* input_proj) {\n+  assert(assertion_predicate_has_loop_opaque_node(iff), \"must find OpaqueLoop* nodes for Template Assertion Predicate\");\n+  TemplateAssertionExpression template_assertion_expression(iff->in(1)->as_Opaque4());\n+  assert(new_init->is_OpaqueLoopInit(), \"only for creating new Template Assertion Predicates\");\n+  Opaque4Node* new_opaque_node = template_assertion_expression.clone_and_replace_init(new_init, control, this);\n@@ -1509,2 +1505,1 @@\n-  \/\/ It's impossible for the predicate to fail at runtime. Use a Halt node.\n-  Node* halt = new HaltNode(other_proj, frame, \"duplicated predicate failed which is impossible\");\n+  Node* halt = new HaltNode(other_proj, frame, \"Template Assertion Predicates are always removed before code generation\");\n@@ -1518,0 +1513,2 @@\n+  assert(assertion_predicate_has_loop_opaque_node(proj->in(0)->as_If()),\n+         \"Template Assertion Predicates must have OpaqueLoop* nodes in the bool expression\");\n@@ -1970,3 +1967,1 @@\n-        prev_proj = clone_assertion_predicate_and_initialize(iff, init, max_value, entry, proj, ctrl, outer_loop,\n-                                                             prev_proj);\n-        assert(!assertion_predicate_has_loop_opaque_node(prev_proj->in(0)->as_If()), \"unexpected\");\n+        prev_proj = create_initialized_assertion_predicate(iff, init, max_value, prev_proj);\n@@ -2011,4 +2006,1 @@\n-      assert(assertion_predicate_has_loop_opaque_node(iff), \"must find OpaqueLoop* nodes\");\n-      prev_proj = clone_assertion_predicate_and_initialize(iff, init, stride, ctrl, proj, post_loop_entry,\n-                                                           post_loop, prev_proj);\n-      assert(!assertion_predicate_has_loop_opaque_node(prev_proj->in(0)->as_If()), \"must not find OpaqueLoop* nodes\");\n+      prev_proj = create_initialized_assertion_predicate(iff, init, stride, prev_proj);\n@@ -2033,3 +2025,1 @@\n-  Node* control = outer_loop_head->in(LoopNode::EntryControl);\n-  Node* input_proj = control;\n-\n+  Node* input_proj = outer_loop_head->in(LoopNode::EntryControl);\n@@ -2049,3 +2039,1 @@\n-      assert(assertion_predicate_has_loop_opaque_node(iff), \"must find OpaqueLoop* nodes\");\n-      input_proj = clone_assertion_predicate_and_initialize(iff, init, stride, next_regular_predicate_proj, uncommon_proj, control,\n-                                                            outer_loop, input_proj);\n+      input_proj = create_initialized_assertion_predicate(iff, init, stride, input_proj);\n@@ -2997,1 +2985,1 @@\n-              NOT_PRODUCT(COMMA AssertionPredicateType::Init_value));\n+              NOT_PRODUCT(COMMA AssertionPredicateType::InitValue));\n@@ -3011,1 +2999,1 @@\n-              NOT_PRODUCT(COMMA AssertionPredicateType::Last_value));\n+              NOT_PRODUCT(COMMA AssertionPredicateType::LastValue));\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":35,"deletions":47,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -950,3 +950,4 @@\n-  Node* clone_assertion_predicate_and_initialize(Node* iff, Node* new_init, Node* new_stride, Node* predicate,\n-                                                 Node* uncommon_proj, Node* control, IdealLoopTree* outer_loop,\n-                                                 Node* input_proj);\n+  Node* clone_template_assertion_predicate(IfNode* iff, Node* new_init, Node* predicate, Node* uncommon_proj, Node* control,\n+                                           IdealLoopTree* outer_loop, Node* input_proj);\n+  IfTrueNode* create_initialized_assertion_predicate(IfNode* template_assertion_predicate, Node* new_init,\n+                                                     Node* new_stride, Node* control);\n@@ -1772,1 +1773,1 @@\n-  void clone_template_assertion_predicate_expression_down(Node* node);\n+  void clone_template_assertion_expression_down(Node* node);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"opto\/rootnode.hpp\"\n@@ -242,5 +243,5 @@\n-\/\/ Creates an identical clone of this Template Assertion Predicate Expression (i.e.cloning all nodes from the Opaque4Node\n-\/\/ to and including the OpaqueLoop* nodes). The cloned nodes are rewired to reflect the same graph structure as found for\n-\/\/ this Template Assertion Predicate Expression. The cloned nodes get 'new_ctrl' as ctrl. There is no other update done\n-\/\/ for the cloned nodes. Return the newly cloned Opaque4Node.\n-Opaque4Node* TemplateAssertionPredicateExpression::clone(Node* new_ctrl, PhaseIdealLoop* phase) {\n+\/\/ Creates an identical clone of this Template Assertion Expression (i.e.cloning all nodes from the Opaque4Node to and\n+\/\/ including the OpaqueLoop* nodes). The cloned nodes are rewired to reflect the same graph structure as found for this\n+\/\/ Template Assertion Expression. The cloned nodes get 'new_ctrl' as ctrl. There is no other update done for the cloned\n+\/\/ nodes. Return the newly cloned Opaque4Node.\n+Opaque4Node* TemplateAssertionExpression::clone(Node* new_ctrl, PhaseIdealLoop* phase) {\n@@ -252,2 +253,2 @@\n-Opaque4Node* TemplateAssertionPredicateExpression::clone_and_replace_init(Node* new_init, Node* new_ctrl,\n-                                                                          PhaseIdealLoop* phase) {\n+Opaque4Node* TemplateAssertionExpression::clone_and_replace_init(Node* new_init, Node* new_ctrl,\n+                                                                 PhaseIdealLoop* phase) {\n@@ -260,3 +261,3 @@\n-Opaque4Node* TemplateAssertionPredicateExpression::clone_and_replace_init_and_stride(Node* new_init, Node* new_stride,\n-                                                                                     Node* new_ctrl,\n-                                                                                     PhaseIdealLoop* phase) {\n+Opaque4Node* TemplateAssertionExpression::clone_and_replace_init_and_stride(Node* new_init, Node* new_stride,\n+                                                                            Node* new_ctrl,\n+                                                                            PhaseIdealLoop* phase) {\n@@ -310,2 +311,1 @@\n-  \/\/       Given that the typical Template Assertion Predicate Expression only consists of a few nodes, we aim for\n-  \/\/       simplicity here.\n+  \/\/       Given that the typical Template Assertion Expression only consists of a few nodes, we aim for simplicity here.\n@@ -345,3 +345,3 @@\n-\/\/ Clones this Template Assertion Predicate Expression and applies the given strategy to transform the OpaqueLoop* nodes.\n-Opaque4Node* TemplateAssertionPredicateExpression::clone(const TransformStrategyForOpaqueLoopNodes& transform_strategy,\n-                                                         Node* new_ctrl, PhaseIdealLoop* phase) {\n+\/\/ Clones this Template Assertion Expression and applies the given strategy to transform the OpaqueLoop* nodes.\n+Opaque4Node* TemplateAssertionExpression::clone(const TransformStrategyForOpaqueLoopNodes& transform_strategy,\n+                                                Node* new_ctrl, PhaseIdealLoop* phase) {\n@@ -352,1 +352,1 @@\n-  DataNodesOnPathsToTargets data_nodes_on_path_to_targets(TemplateAssertionPredicateExpressionNode::is_maybe_in_expression,\n+  DataNodesOnPathsToTargets data_nodes_on_path_to_targets(TemplateAssertionExpressionNode::is_maybe_in_expression,\n@@ -362,2 +362,2 @@\n-\/\/ Check if this node belongs a Template Assertion Predicate Expression (including OpaqueLoop* nodes).\n-bool TemplateAssertionPredicateExpressionNode::is_in_expression(Node* node) {\n+\/\/ Check if this node belongs a Template Assertion Expression (including OpaqueLoop* nodes).\n+bool TemplateAssertionExpressionNode::is_in_expression(Node* node) {\n@@ -380,1 +380,1 @@\n-bool TemplateAssertionPredicateExpressionNode::is_template_assertion_predicate(Node* node) {\n+bool TemplateAssertionExpressionNode::is_template_assertion_predicate(Node* node) {\n@@ -384,0 +384,80 @@\n+InitializedAssertionPredicate::InitializedAssertionPredicate(IfNode* template_assertion_predicate, Node* new_init,\n+                                                             Node* new_stride, PhaseIdealLoop* phase)\n+    : _template_assertion_predicate(template_assertion_predicate),\n+      _new_init(new_init),\n+      _new_stride(new_stride),\n+      _phase(phase) {}\n+\n+\/\/ Create an Initialized Assertion Predicate at the provided control from the _template_assertion_predicate.\n+\/\/ We clone the Template Assertion Expression and replace:\n+\/\/ - Opaque4 with OpaqueInitializedAssertionPredicate\n+\/\/ - OpaqueLoop*Nodes with _new_init and _new_stride, respectively.\n+\/\/\n+\/\/             \/         init                 stride\n+\/\/             |           |                    |\n+\/\/             |  OpaqueLoopInitNode  OpaqueLoopStrideNode                      \/       _new_init    _new_stride\n+\/\/  Template   |                 \\     \/                                        |              \\     \/\n+\/\/  Assertion  |                   ...                               Assertion  |                ...\n+\/\/  Expression |                    |                                Expression |                 |\n+\/\/             |                   Bool                                         |              new Bool\n+\/\/             |                    |                                           |                 |\n+\/\/             \\                 Opaque4           ======>          control     \\  OpaqueInitializedAssertionPredicate\n+\/\/                                  |                                      \\      \/\n+\/\/                                 If                                       new If\n+\/\/                               \/    \\                                     \/    \\\n+\/\/                         success     fail path                   new success   new Halt\n+\/\/                           proj    (Halt or UCT)                     proj\n+\/\/\n+IfTrueNode* InitializedAssertionPredicate::create(Node* control) {\n+  IdealLoopTree* loop = _phase->get_loop(control);\n+  OpaqueInitializedAssertionPredicateNode* assertion_expression = create_assertion_expression(control);\n+  IfNode* if_node = create_if_node(control, assertion_expression, loop);\n+  create_fail_path(if_node, loop);\n+  return create_success_path(if_node, loop);\n+}\n+\n+\/\/ Create a new Assertion Expression to be used as bool input for the Initialized Assertion Predicate IfNode.\n+OpaqueInitializedAssertionPredicateNode* InitializedAssertionPredicate::create_assertion_expression(Node* control) {\n+  Opaque4Node* template_opaque = _template_assertion_predicate->in(1)->as_Opaque4();\n+  TemplateAssertionExpression template_assertion_expression(template_opaque);\n+  Opaque4Node* tmp_opaque = template_assertion_expression.clone_and_replace_init_and_stride(_new_init, _new_stride,\n+                                                                                            control, _phase);\n+  OpaqueInitializedAssertionPredicateNode* assertion_expression =\n+      new OpaqueInitializedAssertionPredicateNode(tmp_opaque->in(1)->as_Bool(), _phase->C);\n+  _phase->register_new_node(assertion_expression, control);\n+  return assertion_expression;\n+}\n+\n+IfNode* InitializedAssertionPredicate::create_if_node(Node* control,\n+                                                      OpaqueInitializedAssertionPredicateNode* assertion_expression,\n+                                                      IdealLoopTree* loop) {\n+  const int if_opcode = _template_assertion_predicate->Opcode();\n+  NOT_PRODUCT(const AssertionPredicateType assertion_predicate_type = _template_assertion_predicate->assertion_predicate_type();)\n+  IfNode* if_node = if_opcode == Op_If ?\n+      new IfNode(control, assertion_expression, PROB_MAX, COUNT_UNKNOWN NOT_PRODUCT(COMMA assertion_predicate_type)) :\n+      new RangeCheckNode(control, assertion_expression, PROB_MAX, COUNT_UNKNOWN NOT_PRODUCT(COMMA assertion_predicate_type));\n+  _phase->register_control(if_node, loop, control);\n+  return if_node;\n+}\n+\n+IfTrueNode* InitializedAssertionPredicate::create_success_path(IfNode* if_node, IdealLoopTree* loop) {\n+  IfTrueNode* success_proj = new IfTrueNode(if_node);\n+  _phase->register_control(success_proj, loop, if_node);\n+  return success_proj;\n+}\n+\n+void InitializedAssertionPredicate::create_fail_path(IfNode* if_node, IdealLoopTree* loop) {\n+  IfFalseNode* fail_proj = new IfFalseNode(if_node);\n+  _phase->register_control(fail_proj, loop, if_node);\n+  create_halt_node(fail_proj, loop);\n+}\n+\n+void InitializedAssertionPredicate::create_halt_node(IfFalseNode* fail_proj, IdealLoopTree* loop) {\n+  StartNode* start_node = _phase->C->start();\n+  Node* frame = new ParmNode(start_node, TypeFunc::FramePtr);\n+  _phase->register_new_node(frame, start_node);\n+  Node* halt = new HaltNode(fail_proj, frame, \"Initialized Assertion Predicate cannot fail\");\n+  _phase->igvn().add_input_to(_phase->C->root(), halt);\n+  _phase->register_control(halt, loop, fail_proj);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":99,"deletions":19,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+class IdealLoopTree;\n+\n@@ -201,2 +203,2 @@\n-  Init_value,\n-  Last_value\n+  InitValue,\n+  LastValue\n@@ -297,1 +299,1 @@\n-\/\/ Interface to transform OpaqueLoopInit and OpaqueLoopStride nodes of a Template Assertion Predicate Expression.\n+\/\/ Interface to transform OpaqueLoopInit and OpaqueLoopStride nodes of a Template Assertion Expression.\n@@ -304,1 +306,1 @@\n-\/\/ A Template Assertion Predicate Expression represents the Opaque4Node for the initial value or the last value of a\n+\/\/ A Template Assertion Predicate represents the Opaque4Node for the initial value or the last value of a\n@@ -306,1 +308,1 @@\n-class TemplateAssertionPredicateExpression : public StackObj {\n+class TemplateAssertionExpression : public StackObj {\n@@ -310,1 +312,1 @@\n-  explicit TemplateAssertionPredicateExpression(Opaque4Node* opaque4_node) : _opaque4_node(opaque4_node) {}\n+  explicit TemplateAssertionExpression(Opaque4Node* opaque4_node) : _opaque4_node(opaque4_node) {}\n@@ -321,1 +323,1 @@\n-\/\/ Class to represent a node being part of a Template Assertion Predicate Expression.\n+\/\/ Class to represent a node being part of a Template Assertion Expression. Note that this is not an IR node.\n@@ -327,1 +329,1 @@\n-class TemplateAssertionPredicateExpressionNode : public StackObj {\n+class TemplateAssertionExpressionNode : public StackObj {\n@@ -331,1 +333,1 @@\n-  explicit TemplateAssertionPredicateExpressionNode(Node* node) : _node(node) {\n+  explicit TemplateAssertionExpressionNode(Node* node) : _node(node) {\n@@ -334,1 +336,1 @@\n-  NONCOPYABLE(TemplateAssertionPredicateExpressionNode);\n+  NONCOPYABLE(TemplateAssertionExpressionNode);\n@@ -340,1 +342,1 @@\n-  \/\/ Check whether the provided node is part of a Template Assertion Predicate Expression or not.\n+  \/\/ Check whether the provided node is part of a Template Assertion Expression or not.\n@@ -343,1 +345,1 @@\n-  \/\/ Check if the opcode of node could be found in a Template Assertion Predicate Expression.\n+  \/\/ Check if the opcode of node could be found in a Template Assertion Expression.\n@@ -380,1 +382,1 @@\n-        assert(!next->is_CFG(), \"no CFG expected in Template Assertion Predicate Expression\");\n+        assert(!next->is_CFG(), \"no CFG expected in Template Assertion Expression\");\n@@ -385,5 +387,5 @@\n-    \/\/ Each node inside a Template Assertion Predicate Expression is in between a Template Assertion Predicate and\n-    \/\/ its OpaqueLoop* nodes (or an OpaqueLoop* node itself). The OpaqueLoop* nodes do not common up. Therefore, each\n-    \/\/ Template Assertion Predicate Expression node belongs to a single expression - except for OpaqueLoopInitNodes.\n-    \/\/ An OpaqueLoopInitNode is shared between the init and last value Template Assertion Predicate at creation.\n-    \/\/ Later, when cloning the expressions, they are no longer shared.\n+    \/\/ Each node inside a Template Assertion Expression is in between a Template Assertion Predicate and its OpaqueLoop*\n+    \/\/ nodes (or an OpaqueLoop* node itself). The OpaqueLoop* nodes do not common up. Therefore, each Template Assertion\n+    \/\/ Expression node belongs to a single expression - except for OpaqueLoopInitNodes. An OpaqueLoopInitNode is shared\n+    \/\/ between the init and last value Template Assertion Predicate at creation. Later, when cloning the expressions,\n+    \/\/ they are no longer shared.\n@@ -395,0 +397,23 @@\n+\/\/ This class creates a new Initialized Assertion Predicate.\n+class InitializedAssertionPredicate : public StackObj {\n+  IfNode* const _template_assertion_predicate;\n+  Node* const _new_init;\n+  Node* const _new_stride;\n+  PhaseIdealLoop* const _phase;\n+\n+ public:\n+  InitializedAssertionPredicate(IfNode* template_assertion_predicate, Node* new_init, Node* new_stride,\n+                                PhaseIdealLoop* phase);\n+  NONCOPYABLE(InitializedAssertionPredicate);\n+\n+  IfTrueNode* create(Node* control);\n+\n+ private:\n+  OpaqueInitializedAssertionPredicateNode* create_assertion_expression(Node* control);\n+  IfNode* create_if_node(Node* control, OpaqueInitializedAssertionPredicateNode* assertion_expression, IdealLoopTree* loop);\n+  void create_fail_path(IfNode* if_node, IdealLoopTree* loop);\n+  void create_halt_node(IfFalseNode* fail_proj, IdealLoopTree* loop);\n+  IfTrueNode* create_success_path(IfNode* if_node, IdealLoopTree* loop);\n+};\n+\n+\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":43,"deletions":18,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-  clone_template_assertion_predicate_expression_down(n);\n+  clone_template_assertion_expression_down(n);\n@@ -412,7 +412,7 @@\n-\/\/ 'n' could be a node belonging to a Template Assertion Predicate Expression (i.e. any node between a Template\n-\/\/ Assertion Predicate and its OpaqueLoop* nodes (included)). We cannot simply split this node up since this would\n-\/\/ create a phi node inside the Template Assertion Predicate Expression - making it unrecognizable as such. Therefore,\n-\/\/ we completely clone the entire Template Assertion Predicate Expression \"down\". This ensures that we have an\n-\/\/ untouched copy that is still recognized by the Template Assertion Predicate matching code.\n-void PhaseIdealLoop::clone_template_assertion_predicate_expression_down(Node* node) {\n-  if (!TemplateAssertionPredicateExpressionNode::is_in_expression(node)) {\n+\/\/ 'n' could be a node belonging to a Template Assertion Expression (i.e. any node between a Template Assertion Predicate\n+\/\/ and its OpaqueLoop* nodes (included)). We cannot simply split this node up since this would  create a phi node inside\n+\/\/ the Template Assertion Expression - making it unrecognizable as such. Therefore, we completely clone the entire\n+\/\/ Template Assertion Expression \"down\". This ensures that we have an untouched copy that is still recognized by the\n+\/\/ Template Assertion Predicate matching code.\n+void PhaseIdealLoop::clone_template_assertion_expression_down(Node* node) {\n+  if (!TemplateAssertionExpressionNode::is_in_expression(node)) {\n@@ -422,1 +422,1 @@\n-  TemplateAssertionPredicateExpressionNode template_assertion_predicate_expression_node(node);\n+  TemplateAssertionExpressionNode template_assertion_expression_node(node);\n@@ -425,1 +425,1 @@\n-    TemplateAssertionPredicateExpression template_assertion_predicate_expression(opaque4_node);\n+    TemplateAssertionExpression template_assertion_expression(opaque4_node);\n@@ -427,1 +427,1 @@\n-    Opaque4Node* cloned_opaque4_node = template_assertion_predicate_expression.clone(new_ctrl, this);\n+    Opaque4Node* cloned_opaque4_node = template_assertion_expression.clone(new_ctrl, this);\n@@ -430,1 +430,1 @@\n-  template_assertion_predicate_expression_node.for_each_template_assertion_predicate(clone_expression);\n+  template_assertion_expression_node.for_each_template_assertion_predicate(clone_expression);\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"}]}