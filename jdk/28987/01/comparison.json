{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -199,2 +200,2 @@\n-      static volatile uint32_t counter=0;\n-      if (AtomicAccess::add(&counter, 1u) % 10 == 0) {\n+      static Atomic<uint32_t> counter{0};\n+      if (counter.add_then_fetch(1u) % 10 == 0) {\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetNMethod.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-#include \"runtime\/atomicAccess.hpp\"\n+#include \"runtime\/atomic.hpp\"\n@@ -51,1 +51,1 @@\n-  AtomicAccess::release_store(&_has_terminated, true);\n+  _has_terminated.release_store(true);\n@@ -60,1 +60,1 @@\n-  AtomicAccess::release_store_fence(&_should_terminate, true);\n+  _should_terminate.release_store_fence(true);\n@@ -66,1 +66,1 @@\n-  while (!_has_terminated) {\n+  while (!_has_terminated.load_relaxed()) {\n@@ -72,1 +72,1 @@\n-  return AtomicAccess::load_acquire(&_should_terminate);\n+  return _should_terminate.load_acquire();\n@@ -76,1 +76,1 @@\n-  return AtomicAccess::load_acquire(&_has_terminated);\n+  return _has_terminated.load_acquire();\n","filename":"src\/hotspot\/share\/gc\/shared\/concurrentGCThread.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -34,2 +35,2 @@\n-  volatile bool _should_terminate;\n-  volatile bool _has_terminated;\n+  Atomic<bool> _should_terminate;\n+  Atomic<bool> _has_terminated;\n","filename":"src\/hotspot\/share\/gc\/shared\/concurrentGCThread.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-#include \"runtime\/atomicAccess.hpp\"\n+#include \"runtime\/atomic.hpp\"\n@@ -63,1 +63,1 @@\n-volatile bool GCLocker::_is_gc_request_pending;\n+Atomic<bool> GCLocker::_is_gc_request_pending{false};\n@@ -65,1 +65,1 @@\n-DEBUG_ONLY(uint64_t GCLocker::_verify_in_cr_count;)\n+DEBUG_ONLY(Atomic<uint64_t> GCLocker::_verify_in_cr_count{0};)\n@@ -70,3 +70,0 @@\n-  _is_gc_request_pending = false;\n-\n-  DEBUG_ONLY(_verify_in_cr_count = 0;)\n@@ -87,1 +84,1 @@\n-  assert(AtomicAccess::load(&_is_gc_request_pending) == false, \"precondition\");\n+  assert(_is_gc_request_pending.load_relaxed() == false, \"precondition\");\n@@ -91,1 +88,1 @@\n-  AtomicAccess::store(&_is_gc_request_pending, true);\n+  _is_gc_request_pending.store_relaxed(true);\n@@ -115,1 +112,1 @@\n-  assert(AtomicAccess::load(&_verify_in_cr_count) == 0, \"inv\");\n+  assert(_verify_in_cr_count.load_relaxed() == 0, \"inv\");\n@@ -120,1 +117,1 @@\n-  assert(AtomicAccess::load(&_is_gc_request_pending) == true, \"precondition\");\n+  assert(_is_gc_request_pending.load_relaxed() == true, \"precondition\");\n@@ -122,1 +119,1 @@\n-  AtomicAccess::store(&_is_gc_request_pending, false);\n+  _is_gc_request_pending.store_relaxed(false);\n@@ -142,1 +139,1 @@\n-    if (!AtomicAccess::load(&_is_gc_request_pending)) {\n+    if (!_is_gc_request_pending.load_relaxed()) {\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLocker.cpp","additions":10,"deletions":13,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -46,1 +47,1 @@\n-  static volatile bool _is_gc_request_pending;\n+  static Atomic<bool> _is_gc_request_pending;\n@@ -50,1 +51,1 @@\n-  static uint64_t _verify_in_cr_count;\n+  static Atomic<uint64_t> _verify_in_cr_count;\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLocker.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-    if (AtomicAccess::load(&_is_gc_request_pending)) {\n+    if (_is_gc_request_pending.load_relaxed()) {\n@@ -47,1 +47,1 @@\n-    DEBUG_ONLY(AtomicAccess::add(&_verify_in_cr_count, (uint64_t)1);)\n+    DEBUG_ONLY(_verify_in_cr_count.add_then_fetch(1u);)\n@@ -58,1 +58,1 @@\n-    AtomicAccess::add(&_verify_in_cr_count, (uint64_t)-1);\n+    _verify_in_cr_count.sub_then_fetch(1u);\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLocker.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"runtime\/atomicAccess.hpp\"\n+#include \"runtime\/atomic.hpp\"\n@@ -55,1 +55,1 @@\n-    char* cur_start = AtomicAccess::load(&_cur_addr);\n+    char* cur_start = _cur_addr.load_relaxed();\n@@ -59,1 +59,1 @@\n-    } else if (cur_start == AtomicAccess::cmpxchg(&_cur_addr, cur_start, cur_end)) {\n+    } else if (cur_start == _cur_addr.compare_exchange(cur_start, cur_end)) {\n","filename":"src\/hotspot\/share\/gc\/shared\/pretouchTask.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+#include \"runtime\/atomic.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -31,1 +33,1 @@\n-  char* volatile _cur_addr;\n+  Atomic<char*> _cur_addr;\n","filename":"src\/hotspot\/share\/gc\/shared\/pretouchTask.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-volatile bool SuspendibleThreadSet::_suspend_all       = false;\n+Atomic<bool>  SuspendibleThreadSet::_suspend_all{false};\n@@ -99,1 +99,1 @@\n-    AtomicAccess::store(&_suspend_all, true);\n+    _suspend_all.store_relaxed(true);\n@@ -130,1 +130,1 @@\n-  AtomicAccess::store(&_suspend_all, false);\n+  _suspend_all.store_relaxed(false);\n","filename":"src\/hotspot\/share\/gc\/shared\/suspendibleThreadSet.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"runtime\/atomicAccess.hpp\"\n+#include \"runtime\/atomic.hpp\"\n@@ -46,1 +46,1 @@\n-  static volatile bool _suspend_all;\n+  static Atomic<bool>  _suspend_all;\n@@ -62,1 +62,1 @@\n-  static bool should_yield() { return AtomicAccess::load(&_suspend_all); }\n+  static bool should_yield() { return _suspend_all.load_relaxed(); }\n","filename":"src\/hotspot\/share\/gc\/shared\/suspendibleThreadSet.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-  _not_finished = num_workers;\n+  _not_finished.store_relaxed(num_workers);\n@@ -54,1 +54,4 @@\n-  assert(_not_finished == 0, \"%d not finished workers?\", _not_finished);\n+#ifdef ASSERT\n+  uint not_finished = _not_finished.load_relaxed();\n+  assert(not_finished == 0, \"%u not finished workers?\", not_finished);\n+#endif \/\/ ASSERT\n@@ -56,1 +59,1 @@\n-  _started = 0;\n+  _started.store_relaxed(0);\n@@ -64,1 +67,1 @@\n-  const uint worker_id = AtomicAccess::fetch_then_add(&_started, 1u);\n+  const uint worker_id = _started.fetch_then_add(1u);\n@@ -73,1 +76,1 @@\n-  const uint not_finished = AtomicAccess::sub(&_not_finished, 1u);\n+  const uint not_finished = _not_finished.sub_then_fetch(1u);\n","filename":"src\/hotspot\/share\/gc\/shared\/workerThread.cpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -61,2 +62,2 @@\n-  volatile uint _started;\n-  volatile uint _not_finished;\n+  Atomic<uint> _started;\n+  Atomic<uint> _not_finished;\n","filename":"src\/hotspot\/share\/gc\/shared\/workerThread.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"}]}