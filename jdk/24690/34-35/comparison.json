{"files":[{"patch":"@@ -1249,0 +1249,10 @@\n+    \/**\n+     * Constructs a BigInteger with magnitude specified by the long,\n+     * which may not be zero, and the signum specified by the int.\n+     *\/\n+    private BigInteger(long mag, int signum) {\n+        assert mag != 0 && signum != 0;\n+        this.signum = signum;\n+        this.mag = toMagArray(mag);\n+    }\n+\n@@ -1259,0 +1269,2 @@\n+        mag = toMagArray(val);\n+    }\n@@ -1260,9 +1272,5 @@\n-        int highWord = (int)(val >>> 32);\n-        if (highWord == 0) {\n-            mag = new int[1];\n-            mag[0] = (int)val;\n-        } else {\n-            mag = new int[2];\n-            mag[0] = highWord;\n-            mag[1] = (int)val;\n-        }\n+    private static int[] toMagArray(long mag) {\n+        int highWord = (int) (mag >>> 32);\n+        return highWord == 0\n+                ? new int[] { (int) mag }\n+                : new int[] { highWord, (int) mag };\n@@ -2641,3 +2649,3 @@\n-        \/\/ See if the result will safely fit into a long. (Largest 2^63-1)\n-        if (base.mag.length == 1 && scaleFactor <= 62) {\n-            \/\/ Small number algorithm.  Everything fits into a long.\n+        \/\/ See if the result will safely fit into an unsigned long. (Largest 2^64-1)\n+        if (base.mag.length == 1 && scaleFactor <= Long.SIZE) {\n+            \/\/ Small number algorithm.  Everything fits into an unsigned long.\n@@ -2648,9 +2656,5 @@\n-            if (powersOfTwo > 0) {\n-                if (bitsToShift + scaleFactor <= 62) { \/\/ Fits in long?\n-                    return valueOf((result << bitsToShift) * newSign);\n-                } else {\n-                    return valueOf(result*newSign).shiftLeft(bitsToShift);\n-                }\n-            } else {\n-                return valueOf(result*newSign);\n-            }\n+            return powersOfTwo == 0\n+                    ? new BigInteger(result, newSign)\n+                    : (bitsToShift + scaleFactor <= Long.SIZE  \/\/ Fits in long?\n+                            ? new BigInteger(result << bitsToShift, newSign)\n+                            : new BigInteger(result, newSign).shiftLeft(bitsToShift));\n@@ -2717,1 +2721,1 @@\n-            blockLen = maxExpLen < nLen ? maxExpLen : nLen;\n+            blockLen = Math.min(maxExpLen, nLen);\n@@ -2801,1 +2805,1 @@\n-            blockLen = maxExpLen < nLen ? maxExpLen : nLen;\n+            blockLen = Math.min(maxExpLen, nLen);\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":27,"deletions":23,"binary":false,"changes":50,"status":"modified"}]}