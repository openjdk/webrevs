{"files":[{"patch":"@@ -2592,3 +2592,5 @@\n-        if (signum == 0) {\n-            return (exponent == 0 ? ONE : this);\n-        }\n+        if (exponent == 0 || this.equals(ONE))\n+            return ONE;\n+\n+        if (signum == 0)\n+            return ZERO;\n@@ -2596,1 +2598,1 @@\n-        BigInteger partToSquare = this.abs();\n+        BigInteger base = this.abs();\n@@ -2602,1 +2604,1 @@\n-        int powersOfTwo = partToSquare.getLowestSetBit();\n+        int powersOfTwo = base.getLowestSetBit();\n@@ -2613,2 +2615,2 @@\n-            partToSquare = partToSquare.shiftRight(powersOfTwo);\n-            remainingBits = partToSquare.bitLength();\n+            base = base.shiftRight(powersOfTwo);\n+            remainingBits = base.bitLength();\n@@ -2623,1 +2625,1 @@\n-            remainingBits = partToSquare.bitLength();\n+            remainingBits = base.bitLength();\n@@ -2640,1 +2642,1 @@\n-        if (partToSquare.mag.length == 1 && scaleFactor <= 62) {\n+        if (base.mag.length == 1 && scaleFactor <= 62) {\n@@ -2643,15 +2645,1 @@\n-            long result = 1;\n-            long baseToPow2 = partToSquare.mag[0] & LONG_MASK;\n-\n-            int workingExponent = exponent;\n-\n-            \/\/ Perform exponentiation using repeated squaring trick\n-            while (workingExponent != 0) {\n-                if ((workingExponent & 1) == 1) {\n-                    result = result * baseToPow2;\n-                }\n-\n-                if ((workingExponent >>>= 1) != 0) {\n-                    baseToPow2 = baseToPow2 * baseToPow2;\n-                }\n-            }\n+            long result = unsignedLongPow(base.mag[0] & LONG_MASK, exponent);\n@@ -2675,1 +2663,1 @@\n-            \/\/ the algorithm above, but calls multiply() and square()\n+            \/\/ the algorithm above, but calls multiply()\n@@ -2677,1 +2665,5 @@\n-            BigInteger answer = ONE;\n+            BigInteger answer;\n+            if (base.mag.length == 1) {\n+                answer = unsignedIntPow(base.mag[0], exponent);\n+            } else {\n+                answer = ONE;\n@@ -2679,6 +2671,7 @@\n-            int workingExponent = exponent;\n-            \/\/ Perform exponentiation using repeated squaring trick\n-            while (workingExponent != 0) {\n-                if ((workingExponent & 1) == 1) {\n-                    answer = answer.multiply(partToSquare);\n-                }\n+                final int expZeros = Integer.numberOfLeadingZeros(exponent);\n+                int workingExp = exponent << expZeros;\n+                \/\/ Perform exponentiation using repeated squaring trick\n+                for (int expLen = Integer.SIZE - expZeros; expLen > 0; expLen--) {\n+                    answer = answer.multiply(answer);\n+                    if (workingExp < 0) \/\/ leading bit is set\n+                        answer = answer.multiply(base);\n@@ -2686,2 +2679,1 @@\n-                if ((workingExponent >>>= 1) != 0) {\n-                    partToSquare = partToSquare.square();\n+                    workingExp <<= 1;\n@@ -2690,0 +2682,1 @@\n+\n@@ -2704,0 +2697,163 @@\n+    \/**\n+     * Computes {@code x^n} using repeated squaring trick.\n+     * Assumes {@code x != 0}.\n+     *\/\n+    private static BigInteger unsignedIntPow(int x, int n) {\n+        if (x == 1)\n+            return ONE;\n+        \/\/ Double.PRECISION \/ bitLength(x) is the largest integer e\n+        \/\/ such that x^e fits into a double. If e <= 2, we won't use fp arithmetic.\n+        \/\/ This allows to use fp arithmetic in computePower(), where possible.\n+        final int maxExp = Math.max(2, Double.PRECISION \/ bitLengthForInt(x));\n+        final int maxExpLen = bitLengthForInt(maxExp);\n+        final BigInteger[] powerCache = new BigInteger[1 << maxExpLen];\n+\n+        final int nZeros = Integer.numberOfLeadingZeros(n);\n+        n <<= nZeros;\n+\n+        BigInteger pow = ONE;\n+        int blockLen;\n+        for (int nLen = Integer.SIZE - nZeros; nLen > 0; nLen -= blockLen) {\n+            blockLen = maxExpLen < nLen ? maxExpLen : nLen;\n+            \/\/ compute pow^(2^blockLen)\n+            if (!pow.equals(ONE)) {\n+                for (int i = 0; i < blockLen; i++)\n+                    pow = pow.multiply(pow);\n+            }\n+\n+            \/\/ add exp to power's exponent\n+            int exp = n >>> -blockLen;\n+            if (exp > 0)\n+                pow = pow.multiply(computePower(powerCache, x & LONG_MASK, exp, maxExp));\n+\n+            n <<= blockLen; \/\/ shift to next block of bits\n+        }\n+\n+        return pow;\n+    }\n+\n+    \/**\n+     * Returns {@code x^exp}. This method is used by {@code unsignedIntPow(int, int)}.\n+     * Assumes {@code maxExp == max(2, Double.PRECISION \/ bitLength(x))}.\n+     *\/\n+    private static BigInteger computePower(BigInteger[] powerCache, long x, int exp, int maxExp) {\n+        BigInteger xToExp = powerCache[exp];\n+        if (xToExp == null) {\n+            if (exp <= maxExp) {\n+                \/\/ don't use fp arithmetic if exp <= 2\n+                long pow = exp == 1 ? x :\n+                          (exp == 2 ? x*x : (long) Math.pow(x, exp));\n+\n+                xToExp = new BigInteger(1, new int[] { (int) (pow >>> 32), (int) pow });\n+                powerCache[exp] = xToExp;\n+            } else {\n+                \/\/ adjust exp to fit x^expAdj into a double\n+                final int expAdj = exp >>> 1;\n+\n+                xToExp = powerCache[expAdj << 1];\n+                if (xToExp == null) { \/\/ compute x^(expAdj << 1)\n+                    xToExp = powerCache[expAdj];\n+                    if (xToExp == null) { \/\/ compute x^expAdj\n+                        \/\/ don't use fp arithmetic if expAdj <= 2\n+                        long xToExpAdj = expAdj == 1 ? x :\n+                                        (expAdj == 2 ? x*x : (long) Math.pow(x, expAdj));\n+\n+                        xToExp = new BigInteger(1, new int[] { (int) (xToExpAdj >>> 32), (int) xToExpAdj });\n+                        powerCache[expAdj] = xToExp;\n+                    }\n+                    xToExp = xToExp.multiply(xToExp);\n+                    powerCache[expAdj << 1] = xToExp;\n+                }\n+\n+                \/\/ append exp's rightmost bit to expAdj\n+                if ((exp & 1) == 1) {\n+                    xToExp = xToExp.multiply(x);\n+                    powerCache[exp] = xToExp;\n+                }\n+            }\n+        }\n+        return xToExp;\n+    }\n+\n+    \/**\n+     * Computes {@code x^n} using repeated squaring trick.\n+     * Assumes {@code x != 0 && x^n < 2^Long.SIZE}.\n+     *\/\n+    static long unsignedLongPow(long x, int n) {\n+        if (x == 1L)\n+            return 1L;\n+\n+        if (x == 2L)\n+            return 1L << n;\n+        \/\/ Double.PRECISION \/ bitLength(x) is the largest integer e\n+        \/\/ such that x^e fits into a double. If e <= 3, we won't use fp arithmetic.\n+        \/\/ This allows to use fp arithmetic in computePower(), where possible.\n+        final int maxExp = Math.max(3, Double.PRECISION \/ bitLengthForLong(x));\n+        final int maxExpLen = bitLengthForInt(maxExp);\n+        final long[] powerCache = new long[1 << maxExpLen];\n+\n+        final int nZeros = Integer.numberOfLeadingZeros(n);\n+        n <<= nZeros;\n+\n+        long pow = 1L;\n+        int blockLen;\n+        for (int nLen = Integer.SIZE - nZeros; nLen > 0; nLen -= blockLen) {\n+            blockLen = maxExpLen < nLen ? maxExpLen : nLen;\n+            \/\/ compute pow^(2^blockLen)\n+            if (pow != 1L) {\n+                for (int i = 0; i < blockLen; i++)\n+                    pow *= pow;\n+            }\n+\n+            \/\/ add exp to power's exponent\n+            int exp = n >>> -blockLen;\n+            if (exp > 0)\n+                pow *= computePower(powerCache, x, exp, maxExp);\n+\n+            n <<= blockLen; \/\/ shift to next block of bits\n+        }\n+\n+        return pow;\n+    }\n+\n+    \/**\n+     * Returns {@code x^exp}. This method is used by {@code unsignedLongPow(long, int)}.\n+     * Assumes {@code maxExp == max(3, Double.PRECISION \/ bitLength(x))}.\n+     *\/\n+    private static long computePower(long[] powerCache, long x, int exp, int maxExp) {\n+        long xToExp = powerCache[exp];\n+        if (xToExp == 0) {\n+            if (exp <= maxExp) {\n+                \/\/ don't use fp arithmetic if exp <= 3\n+                xToExp = exp == 1 ? x :\n+                        (exp == 2 ? x*x :\n+                        (exp == 3 ? x*x*x : (long) Math.pow(x, exp)));\n+                powerCache[exp] = xToExp;\n+            } else {\n+                \/\/ adjust exp to fit x^expAdj into a double\n+                final int expAdj = exp >>> 1;\n+\n+                xToExp = powerCache[expAdj << 1];\n+                if (xToExp == 0) { \/\/ compute x^(expAdj << 1)\n+                    xToExp = powerCache[expAdj];\n+                    if (xToExp == 0) {  \/\/ compute x^expAdj\n+                        \/\/ don't use fp arithmetic if expAdj <= 3\n+                        xToExp = expAdj == 1 ? x :\n+                                (expAdj == 2 ? x*x :\n+                                (expAdj == 3 ? x*x*x : (long) Math.pow(x, expAdj)));\n+                        powerCache[expAdj] = xToExp;\n+                    }\n+                    xToExp *= xToExp;\n+                    powerCache[expAdj << 1] = xToExp;\n+                }\n+\n+                \/\/ append exp's rightmost bit to expAdj\n+                if ((exp & 1) == 1) {\n+                    xToExp *= x;\n+                    powerCache[exp] = xToExp;\n+                }\n+            }\n+        }\n+        return xToExp;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":190,"deletions":34,"binary":false,"changes":224,"status":"modified"}]}