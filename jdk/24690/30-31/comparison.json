{"files":[{"patch":"@@ -2897,1 +2897,13 @@\n-        return n == 1 ? this : (n == 2 ? sqrt() : nthRootAndRemainder(n, false)[0]);\n+        if (n == 1)\n+            return this;\n+\n+        if (n == 2)\n+            return sqrt();\n+\n+        if (n <= 0)\n+            throw new ArithmeticException(\"Non-positive root degree\");\n+\n+        if ((n & 1) == 0 && this.signum < 0)\n+            throw new ArithmeticException(\"Negative radicand with even root degree\");\n+\n+        return new MutableBigInteger(this.mag).nthRoot(n).toBigInteger(signum);\n@@ -2921,10 +2933,2 @@\n-        return n == 1 ? new BigInteger[] { this, ZERO }\n-                      : (n == 2 ? sqrtAndRemainder() : nthRootAndRemainder(n, true));\n-    }\n-\n-    \/**\n-     * Assume {@code n != 1 && n != 2}\n-     *\/\n-    private BigInteger[] nthRootAndRemainder(int n, boolean needRemainder) {\n-        if (n <= 0)\n-            throw new ArithmeticException(\"Non-positive root degree\");\n+        if (n == 1)\n+            return new BigInteger[] { this, ZERO };\n@@ -2932,2 +2936,2 @@\n-        if ((n & 1) == 0 && this.signum < 0)\n-            throw new ArithmeticException(\"Negative radicand with even root degree\");\n+        if (n == 2)\n+            return sqrtAndRemainder();\n@@ -2935,5 +2939,3 @@\n-        MutableBigInteger[] rootRem = new MutableBigInteger(this.mag).nthRootRem(n);\n-        return new BigInteger[] {\n-                rootRem[0].toBigInteger(signum),\n-                needRemainder ? rootRem[1].toBigInteger(signum) : null\n-        };\n+        BigInteger root = nthRoot(n), rem = this.subtract(root.pow(n));\n+        assert rem.signum == 0 || rem.signum == this.signum;\n+        return new BigInteger[] { root, rem };\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":20,"deletions":18,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -1917,2 +1917,2 @@\n-     * Calculate the integer {@code n}th root {@code floor(nthRoot(this, n))} and the remainder,\n-     * where {@code nthRoot(., n)} denotes the mathematical {@code n}th root. The contents of\n+     * Calculate the integer {@code n}th root {@code floor(nthRoot(this, n))} where\n+     * {@code nthRoot(., n)} denotes the mathematical {@code n}th root. The contents of\n@@ -1922,5 +1922,3 @@\n-     * @implNote The implementation is based on the material in Henry S. Warren,\n-     * Jr., <i>Hacker's Delight (2nd ed.)<\/i> (Addison Wesley, 2013), 279-282.\n-     * <a href=\"https:\/\/github.com\/user-attachments\/files\/19785045\/nth_root_newton_proof_integers.pdf\">\n-     * Here<\/a> is a proof for the convergence of the recurrence used by the\n-     * algorithm.\n+     * @implNote The implementation is based on the material in Richard P. Brent\n+     * and Paul Zimmermann, <a href=\"https:\/\/maths-people.anu.edu.au\/~brent\/pd\/mca-cup-0.5.9.pdf\">\n+     * Modern Computer Arithmetic<\/a>, 27-28.\n@@ -1928,1 +1926,1 @@\n-     * @return the integer {@code n}th of {@code this} and the remainder\n+     * @return the integer {@code n}th of {@code this}\n@@ -1930,1 +1928,1 @@\n-    MutableBigInteger[] nthRootRem(int n) {\n+    MutableBigInteger nthRoot(int n) {\n@@ -1933,1 +1931,1 @@\n-            return new MutableBigInteger[] { this, new MutableBigInteger() };\n+            return this;\n@@ -1940,1 +1938,1 @@\n-            return new MutableBigInteger[] { new MutableBigInteger(1), rem };\n+            return new MutableBigInteger(1);\n@@ -1944,0 +1942,1 @@\n+        long shift = 0L;\n@@ -1952,1 +1951,1 @@\n-            if (BigInteger.bitLengthForLong(rLong) * n <= Long.SIZE) {\n+            if (BigInteger.bitLengthForLong(rLong) * (n - 1) <= Long.SIZE) {\n@@ -1954,0 +1953,1 @@\n+                long r1 = rLong;\n@@ -1955,0 +1955,1 @@\n+                    rLong = r1;\n@@ -1956,14 +1957,5 @@\n-                    long rToN = rToN1 * rLong;\n-                    if (Long.compareUnsigned(rToN, x) <= 0)\n-                        return new MutableBigInteger[] {\n-                                new MutableBigInteger(rLong), new MutableBigInteger(x - rToN)\n-                        };\n-\n-                    \/\/ compute rLong - ceil((rToN - x) \/ (n * rToN1))\n-                    long dividend = rToN - x, divisor = n * rToN1;\n-                    if (Long.remainderUnsigned(dividend, divisor) != 0)\n-                        rLong--;\n-\n-                    rLong -= Long.divideUnsigned(dividend, divisor);\n-                } while (true);\n-            } else { \/\/ r^n could overflow long range, use MutableBigInteger loop instead\n+                    r1 = ((n - 1) * rLong + x \/ rToN1) \/ n;\n+                } while (r1 < rLong); \/\/ Terminate when non-decreasing.\n+\n+                return new MutableBigInteger(rLong);\n+            } else { \/\/ r^(n - 1) could overflow long range, use MutableBigInteger loop instead\n@@ -1975,11 +1967,16 @@\n-            long shift = Math.max(0, bitLength - Double.MAX_EXPONENT); \/\/ use long to avoid overflow later\n-            int shiftExcess = (int) (shift % n);\n-\n-            \/\/ Shift the value into finite double range\n-            double rad = this.toBigInteger().shiftRight((int) shift).doubleValue();\n-            \/\/ Complete the shift to a multiple of n,\n-            \/\/ avoiding to lose more bits than necessary.\n-            if (shiftExcess != 0) {\n-                int shiftLack = n - shiftExcess;\n-                shift += shiftLack; \/\/ shift is long, no overflow\n-                rad \/= Double.valueOf(\"0x1p\" + shiftLack);\n+            double rad;\n+            if (bitLength > Double.MAX_EXPONENT) {\n+                shift = bitLength - Double.MAX_EXPONENT;\n+                int shiftExcess = (int) (shift % n);\n+\n+                \/\/ Shift the value into finite double range\n+                rad = this.toBigInteger().shiftRight((int) shift).doubleValue();\n+                \/\/ Complete the shift to a multiple of n,\n+                \/\/ avoiding to lose more bits than necessary.\n+                if (shiftExcess != 0) {\n+                    int shiftLack = n - shiftExcess;\n+                    shift += shiftLack; \/\/ shift is long, no overflow\n+                    rad \/= Double.valueOf(\"0x1p\" + shiftLack);\n+                }\n+            } else {\n+                rad = this.toBigInteger().doubleValue();\n@@ -1992,0 +1989,1 @@\n+        }\n@@ -1993,2 +1991,22 @@\n-            \/\/ Shift the approximate root back into the original range.\n-            r.safeLeftShift((int) (shift \/ n));\n+        \/\/ Refine the estimate, avoiding to compute non-significant bits\n+        final int trailingZeros = this.getLowestSetBit();\n+        int rootShift = (int) (shift \/ n);\n+        for (int rootBits = (int) r.bitLength(); rootShift >= rootBits\n+                && rootBits > 0; rootBits <<= 1) { \/\/ avoid overflow\n+            r.leftShift(rootBits);\n+            rootShift -= rootBits;\n+\n+            \/\/ Remove useless bits from the radicand\n+            MutableBigInteger x = new MutableBigInteger(this);\n+            int removedBits = rootShift * n;\n+            x.rightShift(removedBits);\n+            if (removedBits > trailingZeros)\n+                x.add(ONE); \/\/ round up to ensure r1 is an upper bound of the root\n+\n+            MutableBigInteger rToN1 = new MutableBigInteger(r.toBigInteger().pow(n - 1).mag);\n+            MutableBigInteger dividend = new MutableBigInteger();\n+            r.mul(n - 1, dividend);\n+            MutableBigInteger xDivRToN1 = new MutableBigInteger();\n+            x.divide(rToN1, xDivRToN1, false);\n+            dividend.add(xDivRToN1);\n+            dividend.divideOneWord(n, r);\n@@ -1998,0 +2016,2 @@\n+        r.safeLeftShift(rootShift);\n+        MutableBigInteger r1 = r;\n@@ -1999,17 +2019,11 @@\n-            BigInteger rBig = r.toBigInteger();\n-            BigInteger rToN1 = rBig.pow(n - 1);\n-            MutableBigInteger rem = new MutableBigInteger(rToN1.multiply(rBig).mag);\n-            if (rem.subtract(this) <= 0)\n-                return new MutableBigInteger[] { r, rem };\n-\n-            \/\/ compute r - ceil((r^n - this) \/ (n * r^(n-1)))\n-            MutableBigInteger q1 = new MutableBigInteger();\n-            MutableBigInteger delta = new MutableBigInteger();\n-            \/\/ Don't use conditional-or, in order to do both divisions\n-            \/\/ and make delta == (r^n - this) \/ (n * r^(n-1))\n-            if ((rem.divideOneWord(n, q1) != 0)\n-                    | (!q1.divide(new MutableBigInteger(rToN1.mag), delta).isZero()))\n-                r.subtract(ONE);\n-\n-            r.subtract(delta);\n-        } while (true);\n+            r = r1;\n+            MutableBigInteger rToN1 = new MutableBigInteger(r.toBigInteger().pow(n - 1).mag);\n+            MutableBigInteger dividend = new MutableBigInteger();\n+            r.mul(n - 1, dividend);\n+            MutableBigInteger xDivRToN1 = new MutableBigInteger();\n+            this.divide(rToN1, xDivRToN1);\n+            dividend.add(xDivRToN1);\n+            dividend.divideOneWord(n, r1);\n+        } while (r1.compare(r) < 0); \/\/ Terminate when non-decreasing.\n+\n+        return r;\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":70,"deletions":56,"binary":false,"changes":126,"status":"modified"}]}