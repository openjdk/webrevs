{"files":[{"patch":"@@ -1249,0 +1249,10 @@\n+    \/**\n+     * Constructs a BigInteger with magnitude specified by the long,\n+     * which may not be zero, and the signum specified by the int.\n+     *\/\n+    private BigInteger(long mag, int signum) {\n+        assert mag != 0 && signum != 0;\n+        this.signum = signum;\n+        this.mag = toMagArray(mag);\n+    }\n+\n@@ -1259,0 +1269,2 @@\n+        mag = toMagArray(val);\n+    }\n@@ -1260,9 +1272,5 @@\n-        int highWord = (int)(val >>> 32);\n-        if (highWord == 0) {\n-            mag = new int[1];\n-            mag[0] = (int)val;\n-        } else {\n-            mag = new int[2];\n-            mag[0] = highWord;\n-            mag[1] = (int)val;\n-        }\n+    private static int[] toMagArray(long mag) {\n+        int highWord = (int) (mag >>> 32);\n+        return highWord == 0\n+                ? new int[] { (int) mag }\n+                : new int[] { highWord, (int) mag };\n@@ -2592,3 +2600,5 @@\n-        if (signum == 0) {\n-            return (exponent == 0 ? ONE : this);\n-        }\n+        if (exponent == 0 || this.equals(ONE))\n+            return ONE;\n+\n+        if (signum == 0)\n+            return ZERO;\n@@ -2596,1 +2606,1 @@\n-        BigInteger partToSquare = this.abs();\n+        BigInteger base = this.abs();\n@@ -2602,1 +2612,1 @@\n-        int powersOfTwo = partToSquare.getLowestSetBit();\n+        int powersOfTwo = base.getLowestSetBit();\n@@ -2613,2 +2623,2 @@\n-            partToSquare = partToSquare.shiftRight(powersOfTwo);\n-            remainingBits = partToSquare.bitLength();\n+            base = base.shiftRight(powersOfTwo);\n+            remainingBits = base.bitLength();\n@@ -2623,1 +2633,1 @@\n-            remainingBits = partToSquare.bitLength();\n+            remainingBits = base.bitLength();\n@@ -2639,3 +2649,3 @@\n-        \/\/ See if the result will safely fit into a long. (Largest 2^63-1)\n-        if (partToSquare.mag.length == 1 && scaleFactor <= 62) {\n-            \/\/ Small number algorithm.  Everything fits into a long.\n+        \/\/ See if the result will safely fit into an unsigned long. (Largest 2^64-1)\n+        if (base.mag.length == 1 && scaleFactor <= Long.SIZE) {\n+            \/\/ Small number algorithm.  Everything fits into an unsigned long.\n@@ -2643,15 +2653,1 @@\n-            long result = 1;\n-            long baseToPow2 = partToSquare.mag[0] & LONG_MASK;\n-\n-            int workingExponent = exponent;\n-\n-            \/\/ Perform exponentiation using repeated squaring trick\n-            while (workingExponent != 0) {\n-                if ((workingExponent & 1) == 1) {\n-                    result = result * baseToPow2;\n-                }\n-\n-                if ((workingExponent >>>= 1) != 0) {\n-                    baseToPow2 = baseToPow2 * baseToPow2;\n-                }\n-            }\n+            long result = unsignedLongPow(base.mag[0] & LONG_MASK, exponent);\n@@ -2660,9 +2656,5 @@\n-            if (powersOfTwo > 0) {\n-                if (bitsToShift + scaleFactor <= 62) { \/\/ Fits in long?\n-                    return valueOf((result << bitsToShift) * newSign);\n-                } else {\n-                    return valueOf(result*newSign).shiftLeft(bitsToShift);\n-                }\n-            } else {\n-                return valueOf(result*newSign);\n-            }\n+            return powersOfTwo == 0\n+                    ? new BigInteger(result, newSign)\n+                    : (bitsToShift + scaleFactor <= Long.SIZE  \/\/ Fits in long?\n+                            ? new BigInteger(result << bitsToShift, newSign)\n+                            : new BigInteger(result, newSign).shiftLeft(bitsToShift));\n@@ -2675,1 +2667,1 @@\n-            \/\/ the algorithm above, but calls multiply() and square()\n+            \/\/ the algorithm above, but calls multiply()\n@@ -2679,1 +2671,2 @@\n-            int workingExponent = exponent;\n+            final int expZeros = Integer.numberOfLeadingZeros(exponent);\n+            int workingExp = exponent << expZeros;\n@@ -2681,4 +2674,4 @@\n-            while (workingExponent != 0) {\n-                if ((workingExponent & 1) == 1) {\n-                    answer = answer.multiply(partToSquare);\n-                }\n+            for (int expLen = Integer.SIZE - expZeros; expLen > 0; expLen--) {\n+                answer = answer.multiply(answer);\n+                if (workingExp < 0) \/\/ leading bit is set\n+                    answer = answer.multiply(base);\n@@ -2686,3 +2679,1 @@\n-                if ((workingExponent >>>= 1) != 0) {\n-                    partToSquare = partToSquare.square();\n-                }\n+                workingExp <<= 1;\n@@ -2690,0 +2681,1 @@\n+\n@@ -2704,0 +2696,79 @@\n+    \/**\n+     * Computes {@code x^n} using repeated squaring trick.\n+     * Assumes {@code x != 0 && x^n < 2^Long.SIZE}.\n+     *\/\n+    static long unsignedLongPow(long x, int n) {\n+        if (x == 1L)\n+            return 1L;\n+\n+        if (x == 2L)\n+            return 1L << n;\n+        \/\/ Double.PRECISION \/ bitLength(x) is the largest integer e\n+        \/\/ such that x^e fits into a double. If e <= 3, we won't use fp arithmetic.\n+        \/\/ This allows to use fp arithmetic in computePower(), where possible.\n+        final int maxExp = Math.max(3, Double.PRECISION \/ bitLengthForLong(x));\n+        final int maxExpLen = bitLengthForInt(maxExp);\n+        final long[] powerCache = new long[1 << maxExpLen];\n+        powerCache[1] = x;\n+        powerCache[2] = x * x;\n+        powerCache[3] = x * x * x;\n+\n+        final int nZeros = Integer.numberOfLeadingZeros(n);\n+        n <<= nZeros;\n+\n+        long pow = 1L;\n+        int blockLen;\n+        for (int nLen = Integer.SIZE - nZeros; nLen > 0; nLen -= blockLen) {\n+            blockLen = Math.min(maxExpLen, nLen);\n+            \/\/ compute pow^(2^blockLen)\n+            if (pow != 1L) {\n+                for (int i = 0; i < blockLen; i++)\n+                    pow *= pow;\n+            }\n+\n+            \/\/ add exp to power's exponent\n+            int exp = n >>> -blockLen;\n+            if (exp > 0)\n+                pow *= computePower(powerCache, x, exp, maxExp);\n+\n+            n <<= blockLen; \/\/ shift to next block of bits\n+        }\n+\n+        return pow;\n+    }\n+\n+    \/**\n+     * Returns {@code x^exp}. This method is used by {@code unsignedLongPow(long, int)}.\n+     * Assumes {@code maxExp == max(3, Double.PRECISION \/ bitLength(x))}.\n+     *\/\n+    private static long computePower(long[] powerCache, long x, int exp, int maxExp) {\n+        long xToExp = powerCache[exp];\n+        if (xToExp == 0) {\n+            if (exp <= maxExp) {\n+                xToExp = (long) Math.pow(x, exp); \/\/ don't use fp arithmetic if exp <= 3\n+                powerCache[exp] = xToExp;\n+            } else {\n+                \/\/ adjust exp to fit x^expAdj into a double\n+                final int expAdj = exp >>> 1;\n+\n+                xToExp = powerCache[expAdj << 1];\n+                if (xToExp == 0) { \/\/ compute x^(expAdj << 1)\n+                    xToExp = powerCache[expAdj];\n+                    if (xToExp == 0) {  \/\/ compute x^expAdj\n+                        xToExp = (long) Math.pow(x, expAdj); \/\/ don't use fp arithmetic if expAdj <= 3\n+                        powerCache[expAdj] = xToExp;\n+                    }\n+                    xToExp *= xToExp;\n+                    powerCache[expAdj << 1] = xToExp;\n+                }\n+\n+                \/\/ append exp's rightmost bit to expAdj\n+                if ((exp & 1) == 1) {\n+                    xToExp *= x;\n+                    powerCache[exp] = xToExp;\n+                }\n+            }\n+        }\n+        return xToExp;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":124,"deletions":53,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.math;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.RunnerException;\n+import org.openjdk.jmh.runner.options.Options;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+import org.openjdk.jmh.profile.GCProfiler;\n+\n+import java.math.BigInteger;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 3)\n+public class BigIntegerPow {\n+\n+    private BigInteger[] xsArray, sArray, mArray, lArray, xlArray;\n+    private int xsExp, sExp, mExp, lExp, xlExp;\n+    private static final int TESTSIZE = 2;\n+\n+    \/*\n+     * You can run this test via the command line:\n+     *    $ mvn clean install\n+     *    $ java -jar target\/benchmarks.jar BigIntegerPow -prof gc\n+     *\/\n+    public static void main(String[] args) throws RunnerException {\n+        Options opt = new OptionsBuilder()\n+                .include(BigIntegerPow.class.getSimpleName())\n+                .addProfiler(GCProfiler.class)\n+                .build();\n+\n+        new Runner(opt).run();\n+    }\n+\n+    @Setup\n+    public void setup() {\n+        Random r = new Random(1123);\n+\n+        xsExp = (1 << 25) - 1;\n+        xsArray = new BigInteger[TESTSIZE]; \/*\n+         * Each array entry is atmost 64 bits\n+         * in size\n+         *\/\n+        sExp = (1 << 23) - 1;\n+        sArray = new BigInteger[TESTSIZE]; \/*\n+         * Each array entry is atmost 256 bits\n+         * in size\n+         *\/\n+        mExp = (1 << 21) - 1;\n+        mArray = new BigInteger[TESTSIZE]; \/*\n+         * Each array entry is atmost 1024 bits\n+         * in size\n+         *\/\n+        lExp = (1 << 19) - 1;\n+        lArray = new BigInteger[TESTSIZE]; \/*\n+         * Each array entry is atmost 4096 bits\n+         * in size\n+         *\/\n+        xlExp = (1 << 17) - 1;\n+        xlArray = new BigInteger[TESTSIZE]; \/*\n+         * Each array entry is atmost 16384 bits\n+         * in size\n+         *\/\n+\n+        for (int i = 0; i < TESTSIZE; i++) {\n+            xsArray[i] = new BigInteger(64, r);\n+            sArray[i] = new BigInteger(256, r);\n+            mArray[i] = new BigInteger(1024, r);\n+            lArray[i] = new BigInteger(4096, r);\n+            xlArray[i] = new BigInteger(16384, r);\n+        }\n+    }\n+\n+    \/** Test BigInteger.pow() with numbers long at most 64 bits  *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testPowXS(Blackhole bh) {\n+        for (BigInteger s : xsArray) {\n+            bh.consume(s.pow(xsExp));\n+        }\n+    }\n+\n+    \/** Test BigInteger.pow() with numbers long at most 256 bits *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testPowS(Blackhole bh) {\n+        for (BigInteger s : sArray) {\n+            bh.consume(s.pow(sExp));\n+        }\n+    }\n+\n+    \/** Test BigInteger.pow() with numbers long at most 1024 bits *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testPowM(Blackhole bh) {\n+        for (BigInteger s : mArray) {\n+            bh.consume(s.pow(mExp));\n+        }\n+    }\n+\n+    \/** Test BigInteger.pow() with numbers long at most 4096 bits *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testPowL(Blackhole bh) {\n+        for (BigInteger s : lArray) {\n+            bh.consume(s.pow(lExp));\n+        }\n+    }\n+\n+    \/** Test BigInteger.pow() with numbers long at most 16384 bits *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testPowXL(Blackhole bh) {\n+        for (BigInteger s : xlArray) {\n+            bh.consume(s.pow(xlExp));\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/BigIntegerPow.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"}]}