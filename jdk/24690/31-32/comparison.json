{"files":[{"patch":"@@ -2870,74 +2870,0 @@\n-    \/**\n-     * Returns the integer {@code n}th root of this BigInteger. The integer\n-     * {@code n}th root of the corresponding mathematical integer {@code x} has the\n-     * same sign of {@code x}, and its magnitude is the largest integer {@code r}\n-     * such that {@code r**n <= abs(x)}. It is equal to the value of\n-     * {@code (x.signum() * floor(abs(nthRoot(x, n))))}, where {@code nthRoot(x, n)}\n-     * denotes the real {@code n}th root of {@code x} treated as a real. If {@code n}\n-     * is even and this BigInteger is negative, an {@code ArithmeticException} will be\n-     * thrown.\n-     *\n-     * <p>Note that the magnitude of the integer {@code n}th root will be less than\n-     * the magnitude of the real {@code n}th root if the latter is not representable\n-     * as an integral value.\n-     *\n-     * @param n the root degree\n-     * @return the integer {@code n}th root of {@code this}\n-     * @throws ArithmeticException if {@code n == 0} (Zeroth roots are not\n-     *                             defined.)\n-     * @throws ArithmeticException if {@code n} is negative. (This would cause the\n-     *                             operation to yield a non-integer value.)\n-     * @throws ArithmeticException if {@code n} is even and {@code this} is\n-     *                             negative. (This would cause the operation to\n-     *                             yield non-real roots.)\n-     * @see #sqrt()\n-     * @since 25\n-     *\/\n-    public BigInteger nthRoot(int n) {\n-        if (n == 1)\n-            return this;\n-\n-        if (n == 2)\n-            return sqrt();\n-\n-        if (n <= 0)\n-            throw new ArithmeticException(\"Non-positive root degree\");\n-\n-        if ((n & 1) == 0 && this.signum < 0)\n-            throw new ArithmeticException(\"Negative radicand with even root degree\");\n-\n-        return new MutableBigInteger(this.mag).nthRoot(n).toBigInteger(signum);\n-    }\n-\n-    \/**\n-     * Returns an array of two BigIntegers containing the integer {@code n}th root\n-     * {@code r} of {@code this} and its remainder {@code this - r^n},\n-     * respectively.\n-     *\n-     * @param n the root degree\n-     * @return an array of two BigIntegers with the integer {@code n}th root at\n-     *         offset 0 and the remainder at offset 1\n-     * @throws ArithmeticException if {@code n == 0} (Zeroth roots are not\n-     *                             defined.)\n-     * @throws ArithmeticException if {@code n} is negative. (This would cause the\n-     *                             operation to yield a non-integer value.)\n-     * @throws ArithmeticException if {@code n} is even and {@code this} is\n-     *                             negative. (This would cause the operation to\n-     *                             yield non-real roots.)\n-     * @see #sqrt()\n-     * @see #sqrtAndRemainder()\n-     * @see #nthRoot(int)\n-     * @since 25\n-     *\/\n-    public BigInteger[] nthRootAndRemainder(int n) {\n-        if (n == 1)\n-            return new BigInteger[] { this, ZERO };\n-\n-        if (n == 2)\n-            return sqrtAndRemainder();\n-\n-        BigInteger root = nthRoot(n), rem = this.subtract(root.pow(n));\n-        assert rem.signum == 0 || rem.signum == this.signum;\n-        return new BigInteger[] { root, rem };\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":0,"deletions":74,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -1916,116 +1916,0 @@\n-    \/**\n-     * Calculate the integer {@code n}th root {@code floor(nthRoot(this, n))} where\n-     * {@code nthRoot(., n)} denotes the mathematical {@code n}th root. The contents of\n-     * {@code this} are <b>not<\/b> changed. The value of {@code this} is assumed\n-     * to be non-negative and the root degree {@code n >= 3}.\n-     *\n-     * @implNote The implementation is based on the material in Richard P. Brent\n-     * and Paul Zimmermann, <a href=\"https:\/\/maths-people.anu.edu.au\/~brent\/pd\/mca-cup-0.5.9.pdf\">\n-     * Modern Computer Arithmetic<\/a>, 27-28.\n-     *\n-     * @return the integer {@code n}th of {@code this}\n-     *\/\n-    MutableBigInteger nthRoot(int n) {\n-        \/\/ Special cases.\n-        if (this.isZero() || this.isOne())\n-            return this;\n-\n-        final int bitLength = (int) this.bitLength();\n-        \/\/ if this < 2^n, result is unity\n-        if (bitLength <= n) {\n-            MutableBigInteger rem = new MutableBigInteger(this);\n-            rem.subtract(ONE);\n-            return new MutableBigInteger(1);\n-        }\n-\n-        MutableBigInteger r;\n-        long shift = 0L;\n-        if (bitLength <= Long.SIZE) {\n-            \/\/ Initial estimate is the root of the unsigned long value.\n-            final long x = this.toLong();\n-            \/\/ Use fp arithmetic to get an upper bound of the root\n-            final double rad = Math.nextUp(x >= 0 ? x : x + 0x1p64);\n-            final double approx = n == 3 ? Math.cbrt(rad) : Math.pow(rad, Math.nextUp(1.0 \/ n));\n-            long rLong = (long) Math.ceil(Math.nextUp(approx));\n-\n-            if (BigInteger.bitLengthForLong(rLong) * (n - 1) <= Long.SIZE) {\n-                \/\/ Refine the estimate.\n-                long r1 = rLong;\n-                do {\n-                    rLong = r1;\n-                    long rToN1 = BigInteger.unsignedLongPow(rLong, n - 1);\n-                    r1 = ((n - 1) * rLong + x \/ rToN1) \/ n;\n-                } while (r1 < rLong); \/\/ Terminate when non-decreasing.\n-\n-                return new MutableBigInteger(rLong);\n-            } else { \/\/ r^(n - 1) could overflow long range, use MutableBigInteger loop instead\n-                r = new MutableBigInteger(rLong);\n-            }\n-        } else {\n-            \/\/ Set up the initial estimate of the iteration.\n-            \/\/ Determine a right shift that is a multiple of n into finite double range.\n-            double rad;\n-            if (bitLength > Double.MAX_EXPONENT) {\n-                shift = bitLength - Double.MAX_EXPONENT;\n-                int shiftExcess = (int) (shift % n);\n-\n-                \/\/ Shift the value into finite double range\n-                rad = this.toBigInteger().shiftRight((int) shift).doubleValue();\n-                \/\/ Complete the shift to a multiple of n,\n-                \/\/ avoiding to lose more bits than necessary.\n-                if (shiftExcess != 0) {\n-                    int shiftLack = n - shiftExcess;\n-                    shift += shiftLack; \/\/ shift is long, no overflow\n-                    rad \/= Double.valueOf(\"0x1p\" + shiftLack);\n-                }\n-            } else {\n-                rad = this.toBigInteger().doubleValue();\n-            }\n-\n-            \/\/ Use the root of the shifted value as an estimate.\n-            rad = Math.nextUp(rad);\n-            final double approx = n == 3 ? Math.cbrt(rad) : Math.pow(rad, Math.nextUp(1.0 \/ n));\n-            r = valueOf(Math.ceil(Math.nextUp(approx)));\n-        }\n-\n-        \/\/ Refine the estimate, avoiding to compute non-significant bits\n-        final int trailingZeros = this.getLowestSetBit();\n-        int rootShift = (int) (shift \/ n);\n-        for (int rootBits = (int) r.bitLength(); rootShift >= rootBits\n-                && rootBits > 0; rootBits <<= 1) { \/\/ avoid overflow\n-            r.leftShift(rootBits);\n-            rootShift -= rootBits;\n-\n-            \/\/ Remove useless bits from the radicand\n-            MutableBigInteger x = new MutableBigInteger(this);\n-            int removedBits = rootShift * n;\n-            x.rightShift(removedBits);\n-            if (removedBits > trailingZeros)\n-                x.add(ONE); \/\/ round up to ensure r1 is an upper bound of the root\n-\n-            MutableBigInteger rToN1 = new MutableBigInteger(r.toBigInteger().pow(n - 1).mag);\n-            MutableBigInteger dividend = new MutableBigInteger();\n-            r.mul(n - 1, dividend);\n-            MutableBigInteger xDivRToN1 = new MutableBigInteger();\n-            x.divide(rToN1, xDivRToN1, false);\n-            dividend.add(xDivRToN1);\n-            dividend.divideOneWord(n, r);\n-        }\n-\n-        \/\/ Refine the estimate.\n-        r.safeLeftShift(rootShift);\n-        MutableBigInteger r1 = r;\n-        do {\n-            r = r1;\n-            MutableBigInteger rToN1 = new MutableBigInteger(r.toBigInteger().pow(n - 1).mag);\n-            MutableBigInteger dividend = new MutableBigInteger();\n-            r.mul(n - 1, dividend);\n-            MutableBigInteger xDivRToN1 = new MutableBigInteger();\n-            this.divide(rToN1, xDivRToN1);\n-            dividend.add(xDivRToN1);\n-            dividend.divideOneWord(n, r1);\n-        } while (r1.compare(r) < 0); \/\/ Terminate when non-decreasing.\n-\n-        return r;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":0,"deletions":116,"binary":false,"changes":116,"status":"modified"}]}