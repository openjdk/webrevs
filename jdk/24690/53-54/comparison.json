{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -2629,1 +2629,1 @@\n-        final long scaleFactor = (long)remainingBits * exponent;\n+        final long scaleFactor = (long) remainingBits * exponent;\n@@ -2642,4 +2642,1 @@\n-        } else {\n-            if ((bitLength() - 1L) * exponent >= Integer.MAX_VALUE) {\n-                reportOverflow();\n-            }\n+        }\n@@ -2647,17 +2644,8 @@\n-            \/\/ Large number algorithm.  This is basically identical to\n-            \/\/ the algorithm above, but calls multiply()\n-            \/\/ which may use more efficient algorithms for large numbers.\n-            BigInteger answer = ONE;\n-\n-            final int expZeros = Integer.numberOfLeadingZeros(exponent);\n-            int workingExp = exponent << expZeros;\n-            \/\/ Perform exponentiation using repeated squaring trick\n-            \/\/ The loop relies on this invariant:\n-            \/\/ base^exponent == answer^(2^expLen) * base^(workingExp >>> (32-expLen))\n-            for (int expLen = Integer.SIZE - expZeros; expLen > 0; expLen--) {\n-                answer = answer.multiply(answer);\n-                if (workingExp < 0) \/\/ leading bit is set\n-                    answer = answer.multiply(base);\n-\n-                workingExp <<= 1;\n-            }\n+        if ((bitLength() - 1L) * exponent >= Integer.MAX_VALUE) {\n+            reportOverflow();\n+        }\n+\n+        \/\/ Large number algorithm.  This is basically identical to\n+        \/\/ the algorithm above, but calls multiply()\n+        \/\/ which may use more efficient algorithms for large numbers.\n+        BigInteger answer = ONE;\n@@ -2665,4 +2653,11 @@\n-            \/\/ Multiply back the (exponentiated) powers of two (quickly,\n-            \/\/ by shifting left)\n-            answer = answer.shiftLeft(bitsToShift);\n-            return negative ? answer.negate() : answer;\n+        final int expZeros = Integer.numberOfLeadingZeros(exponent);\n+        int workingExp = exponent << expZeros;\n+        \/\/ Perform exponentiation using repeated squaring trick\n+        \/\/ The loop relies on this invariant:\n+        \/\/ base^exponent == answer^(2^expLen) * base^(workingExp >>> (32-expLen))\n+        for (int expLen = Integer.SIZE - expZeros; expLen > 0; expLen--) {\n+            answer = answer.multiply(answer);\n+            if (workingExp < 0) \/\/ leading bit is set\n+                answer = answer.multiply(base);\n+\n+            workingExp <<= 1;\n@@ -2670,0 +2665,5 @@\n+\n+        \/\/ Multiply back the (exponentiated) powers of two (quickly,\n+        \/\/ by shifting left)\n+        answer = answer.shiftLeft(bitsToShift);\n+        return negative ? answer.negate() : answer;\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":27,"deletions":27,"binary":false,"changes":54,"status":"modified"}]}