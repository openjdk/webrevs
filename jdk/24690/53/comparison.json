{"files":[{"patch":"@@ -1249,0 +1249,10 @@\n+    \/**\n+     * Constructs a BigInteger with magnitude specified by the long,\n+     * which may not be zero, and the signum specified by the int.\n+     *\/\n+    private BigInteger(long mag, int signum) {\n+        assert mag != 0 && signum != 0;\n+        this.signum = signum;\n+        this.mag = toMagArray(mag);\n+    }\n+\n@@ -1259,0 +1269,2 @@\n+        mag = toMagArray(val);\n+    }\n@@ -1260,9 +1272,5 @@\n-        int highWord = (int)(val >>> 32);\n-        if (highWord == 0) {\n-            mag = new int[1];\n-            mag[0] = (int)val;\n-        } else {\n-            mag = new int[2];\n-            mag[0] = highWord;\n-            mag[1] = (int)val;\n-        }\n+    private static int[] toMagArray(long mag) {\n+        int highWord = (int) (mag >>> 32);\n+        return highWord == 0\n+                ? new int[] { (int) mag }\n+                : new int[] { highWord, (int) mag };\n@@ -2592,3 +2600,2 @@\n-        if (signum == 0) {\n-            return (exponent == 0 ? ONE : this);\n-        }\n+        if (exponent == 0 || this.equals(ONE))\n+            return ONE;\n@@ -2596,1 +2603,5 @@\n-        BigInteger partToSquare = this.abs();\n+        if (signum == 0 || exponent == 1)\n+            return this;\n+\n+        BigInteger base = this.abs();\n+        final boolean negative = signum < 0 && (exponent & 1) == 1;\n@@ -2602,3 +2613,4 @@\n-        int powersOfTwo = partToSquare.getLowestSetBit();\n-        long bitsToShiftLong = (long)powersOfTwo * exponent;\n-        if (bitsToShiftLong > Integer.MAX_VALUE) {\n+        final int powersOfTwo = base.getLowestSetBit();\n+        final long bitsToShiftLong = (long) powersOfTwo * exponent;\n+        final int bitsToShift = (int) bitsToShiftLong;\n+        if (bitsToShift != bitsToShiftLong) {\n@@ -2607,1 +2619,0 @@\n-        int bitsToShift = (int)bitsToShiftLong;\n@@ -2609,23 +2620,5 @@\n-        int remainingBits;\n-\n-        \/\/ Factor the powers of two out quickly by shifting right, if needed.\n-        if (powersOfTwo > 0) {\n-            partToSquare = partToSquare.shiftRight(powersOfTwo);\n-            remainingBits = partToSquare.bitLength();\n-            if (remainingBits == 1) {  \/\/ Nothing left but +\/- 1?\n-                if (signum < 0 && (exponent&1) == 1) {\n-                    return NEGATIVE_ONE.shiftLeft(bitsToShift);\n-                } else {\n-                    return ONE.shiftLeft(bitsToShift);\n-                }\n-            }\n-        } else {\n-            remainingBits = partToSquare.bitLength();\n-            if (remainingBits == 1) { \/\/ Nothing left but +\/- 1?\n-                if (signum < 0  && (exponent&1) == 1) {\n-                    return NEGATIVE_ONE;\n-                } else {\n-                    return ONE;\n-                }\n-            }\n-        }\n+        \/\/ Factor the powers of two out quickly by shifting right.\n+        base = base.shiftRight(powersOfTwo);\n+        final int remainingBits = base.bitLength();\n+        if (remainingBits == 1) \/\/ Nothing left but +\/- 1?\n+            return (negative ? NEGATIVE_ONE : ONE).shiftLeft(bitsToShift);\n@@ -2636,1 +2629,1 @@\n-        long scaleFactor = (long)remainingBits * exponent;\n+        final long scaleFactor = (long)remainingBits * exponent;\n@@ -2639,19 +2632,5 @@\n-        \/\/ See if the result will safely fit into a long. (Largest 2^63-1)\n-        if (partToSquare.mag.length == 1 && scaleFactor <= 62) {\n-            \/\/ Small number algorithm.  Everything fits into a long.\n-            int newSign = (signum <0  && (exponent&1) == 1 ? -1 : 1);\n-            long result = 1;\n-            long baseToPow2 = partToSquare.mag[0] & LONG_MASK;\n-\n-            int workingExponent = exponent;\n-\n-            \/\/ Perform exponentiation using repeated squaring trick\n-            while (workingExponent != 0) {\n-                if ((workingExponent & 1) == 1) {\n-                    result = result * baseToPow2;\n-                }\n-\n-                if ((workingExponent >>>= 1) != 0) {\n-                    baseToPow2 = baseToPow2 * baseToPow2;\n-                }\n-            }\n+        \/\/ See if the result will safely fit into an unsigned long. (Largest 2^64-1)\n+        if (scaleFactor <= Long.SIZE) {\n+            \/\/ Small number algorithm.  Everything fits into an unsigned long.\n+            final int newSign = negative ? -1 : 1;\n+            final long result = unsignedLongPow(base.mag[0] & LONG_MASK, exponent);\n@@ -2660,9 +2639,3 @@\n-            if (powersOfTwo > 0) {\n-                if (bitsToShift + scaleFactor <= 62) { \/\/ Fits in long?\n-                    return valueOf((result << bitsToShift) * newSign);\n-                } else {\n-                    return valueOf(result*newSign).shiftLeft(bitsToShift);\n-                }\n-            } else {\n-                return valueOf(result*newSign);\n-            }\n+            return bitsToShift + scaleFactor <= Long.SIZE  \/\/ Fits in long?\n+                    ? new BigInteger(result << bitsToShift, newSign)\n+                    : new BigInteger(result, newSign).shiftLeft(bitsToShift);\n@@ -2670,1 +2643,1 @@\n-            if ((long)bitLength() * exponent \/ Integer.SIZE > MAX_MAG_LENGTH) {\n+            if ((bitLength() - 1L) * exponent >= Integer.MAX_VALUE) {\n@@ -2675,1 +2648,1 @@\n-            \/\/ the algorithm above, but calls multiply() and square()\n+            \/\/ the algorithm above, but calls multiply()\n@@ -2679,1 +2652,2 @@\n-            int workingExponent = exponent;\n+            final int expZeros = Integer.numberOfLeadingZeros(exponent);\n+            int workingExp = exponent << expZeros;\n@@ -2681,8 +2655,8 @@\n-            while (workingExponent != 0) {\n-                if ((workingExponent & 1) == 1) {\n-                    answer = answer.multiply(partToSquare);\n-                }\n-\n-                if ((workingExponent >>>= 1) != 0) {\n-                    partToSquare = partToSquare.square();\n-                }\n+            \/\/ The loop relies on this invariant:\n+            \/\/ base^exponent == answer^(2^expLen) * base^(workingExp >>> (32-expLen))\n+            for (int expLen = Integer.SIZE - expZeros; expLen > 0; expLen--) {\n+                answer = answer.multiply(answer);\n+                if (workingExp < 0) \/\/ leading bit is set\n+                    answer = answer.multiply(base);\n+\n+                workingExp <<= 1;\n@@ -2690,0 +2664,1 @@\n+\n@@ -2692,3 +2667,4 @@\n-            if (powersOfTwo > 0) {\n-                answer = answer.shiftLeft(bitsToShift);\n-            }\n+            answer = answer.shiftLeft(bitsToShift);\n+            return negative ? answer.negate() : answer;\n+        }\n+    }\n@@ -2696,5 +2672,21 @@\n-            if (signum < 0 && (exponent&1) == 1) {\n-                return answer.negate();\n-            } else {\n-                return answer;\n-            }\n+    \/**\n+     * Computes {@code x^n} using repeated squaring trick.\n+     * Assumes {@code x != 0 && x^n < 2^Long.SIZE}.\n+     *\/\n+    static long unsignedLongPow(long x, int n) {\n+        if (x == 1L || n == 0)\n+            return 1L;\n+\n+        if (x == 2L)\n+            return 1L << n;\n+\n+        \/*\n+         * The method assumption means that n <= 40 here.\n+         * Thus, the loop body executes at most 5 times.\n+         *\/\n+        long pow = 1L;\n+        for (; n != 1; n >>>= 1) {\n+            if ((n & 1) != 0)\n+                pow *= x;\n+\n+            x *= x;\n@@ -2702,0 +2694,1 @@\n+        return pow * x;\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":81,"deletions":88,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -0,0 +1,189 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.math;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.RunnerException;\n+import org.openjdk.jmh.runner.options.Options;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+import org.openjdk.jmh.profile.GCProfiler;\n+\n+import java.math.BigInteger;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 1, time = 1)\n+@Measurement(iterations = 1, time = 1)\n+@Fork(value = 3)\n+public class BigIntegerPow {\n+\n+    private static final int TESTSIZE = 1;\n+\n+    private int xsExp = (1 << 20) - 1;\n+    \/* Each array entry is atmost 64 bits in size *\/\n+    private BigInteger[] xsArray = new BigInteger[TESTSIZE];\n+\n+    private int sExp = (1 << 18) - 1;\n+    \/* Each array entry is atmost 256 bits in size *\/\n+    private BigInteger[] sArray = new BigInteger[TESTSIZE];\n+\n+    private int mExp = (1 << 16) - 1;\n+    \/* Each array entry is atmost 1024 bits in size *\/\n+    private BigInteger[] mArray = new BigInteger[TESTSIZE];\n+\n+    private int lExp = (1 << 14) - 1;\n+    \/* Each array entry is atmost 4096 bits in size *\/\n+    private BigInteger[] lArray = new BigInteger[TESTSIZE];\n+\n+    private int xlExp = (1 << 12) - 1;\n+    \/* Each array entry is atmost 16384 bits in size *\/\n+    private BigInteger[] xlArray = new BigInteger[TESTSIZE];\n+\n+    private int[] randomExps;\n+\n+    \/*\n+     * You can run this test via the command line:\n+     *    $ make test TEST=\"micro:java.math.BigIntegerPow\" MICRO=\"OPTIONS=-prof gc\"\n+     *\/\n+\n+    @Setup\n+    public void setup() {\n+        Random r = new Random(1123);\n+\n+        randomExps = new int[TESTSIZE];\n+        for (int i = 0; i < TESTSIZE; i++) {\n+            xsArray[i] = new BigInteger(64, r);\n+            sArray[i] = new BigInteger(256, r);\n+            mArray[i] = new BigInteger(1024, r);\n+            lArray[i] = new BigInteger(4096, r);\n+            xlArray[i] = new BigInteger(16384, r);\n+            randomExps[i] = r.nextInt(1 << 12);\n+        }\n+    }\n+\n+    \/** Test BigInteger.pow() with numbers long at most 64 bits  *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testPowXS(Blackhole bh) {\n+        for (BigInteger xs : xsArray) {\n+            bh.consume(xs.pow(xsExp));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testPowXSRandomExps(Blackhole bh) {\n+        int i = 0;\n+        for (BigInteger xs : xsArray) {\n+            bh.consume(xs.pow(randomExps[i++]));\n+        }\n+    }\n+\n+    \/** Test BigInteger.pow() with numbers long at most 256 bits *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testPowS(Blackhole bh) {\n+        for (BigInteger s : sArray) {\n+            bh.consume(s.pow(sExp));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testPowSRandomExps(Blackhole bh) {\n+        int i = 0;\n+        for (BigInteger s : sArray) {\n+            bh.consume(s.pow(randomExps[i++]));\n+        }\n+    }\n+\n+    \/** Test BigInteger.pow() with numbers long at most 1024 bits *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testPowM(Blackhole bh) {\n+        for (BigInteger m : mArray) {\n+            bh.consume(m.pow(mExp));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testPowMRandomExps(Blackhole bh) {\n+        int i = 0;\n+        for (BigInteger m : mArray) {\n+            bh.consume(m.pow(randomExps[i++]));\n+        }\n+    }\n+\n+    \/** Test BigInteger.pow() with numbers long at most 4096 bits *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testPowL(Blackhole bh) {\n+        for (BigInteger l : lArray) {\n+            bh.consume(l.pow(lExp));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testPowLRandomExps(Blackhole bh) {\n+        int i = 0;\n+        for (BigInteger l : lArray) {\n+            bh.consume(l.pow(randomExps[i++]));\n+        }\n+    }\n+\n+    \/** Test BigInteger.pow() with numbers long at most 16384 bits *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testPowXL(Blackhole bh) {\n+        for (BigInteger xl : xlArray) {\n+            bh.consume(xl.pow(xlExp));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testPowXLRandomExps(Blackhole bh) {\n+        int i = 0;\n+        for (BigInteger xl : xlArray) {\n+            bh.consume(xl.pow(randomExps[i++]));\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/BigIntegerPow.java","additions":189,"deletions":0,"binary":false,"changes":189,"status":"added"}]}