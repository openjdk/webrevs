{"files":[{"patch":"@@ -2596,1 +2596,1 @@\n-        BigInteger partToSquare = this.abs();\n+        BigInteger base = this.abs();\n@@ -2602,2 +2602,2 @@\n-        int powersOfTwo = partToSquare.getLowestSetBit();\n-        long bitsToShiftLong = (long)powersOfTwo * exponent;\n+        int powersOfTwo = base.getLowestSetBit();\n+        long bitsToShiftLong = (long) powersOfTwo * exponent;\n@@ -2613,2 +2613,2 @@\n-            partToSquare = partToSquare.shiftRight(powersOfTwo);\n-            remainingBits = partToSquare.bitLength();\n+            base = base.shiftRight(powersOfTwo);\n+            remainingBits = base.bitLength();\n@@ -2616,1 +2616,1 @@\n-                if (signum < 0 && (exponent&1) == 1) {\n+                if (signum < 0 && (exponent & 1) == 1) {\n@@ -2623,1 +2623,1 @@\n-            remainingBits = partToSquare.bitLength();\n+            remainingBits = base.bitLength();\n@@ -2625,1 +2625,1 @@\n-                if (signum < 0  && (exponent&1) == 1) {\n+                if (signum < 0 && (exponent & 1) == 1) {\n@@ -2636,1 +2636,1 @@\n-        long scaleFactor = (long)remainingBits * exponent;\n+        long scaleFactor = (long) remainingBits * exponent;\n@@ -2640,1 +2640,1 @@\n-        if (partToSquare.mag.length == 1 && scaleFactor <= 62) {\n+        if (base.mag.length == 1 && scaleFactor <= 62) {\n@@ -2642,16 +2642,2 @@\n-            int newSign = (signum <0  && (exponent&1) == 1 ? -1 : 1);\n-            long result = 1;\n-            long baseToPow2 = partToSquare.mag[0] & LONG_MASK;\n-\n-            int workingExponent = exponent;\n-\n-            \/\/ Perform exponentiation using repeated squaring trick\n-            while (workingExponent != 0) {\n-                if ((workingExponent & 1) == 1) {\n-                    result = result * baseToPow2;\n-                }\n-\n-                if ((workingExponent >>>= 1) != 0) {\n-                    baseToPow2 = baseToPow2 * baseToPow2;\n-                }\n-            }\n+            int newSign = (signum < 0  && (exponent & 1) == 1 ? -1 : 1);\n+            long result = unsignedLongPow(base.mag[0] & LONG_MASK, exponent);\n@@ -2664,1 +2650,1 @@\n-                    return valueOf(result*newSign).shiftLeft(bitsToShift);\n+                    return valueOf(result * newSign).shiftLeft(bitsToShift);\n@@ -2667,1 +2653,1 @@\n-                return valueOf(result*newSign);\n+                return valueOf(result * newSign);\n@@ -2670,1 +2656,1 @@\n-            if ((long)bitLength() * exponent \/ Integer.SIZE > MAX_MAG_LENGTH) {\n+            if ((long) bitLength() * exponent \/ Integer.SIZE > MAX_MAG_LENGTH) {\n@@ -2675,1 +2661,1 @@\n-            \/\/ the algorithm above, but calls multiply() and square()\n+            \/\/ the algorithm above, but calls multiply()\n@@ -2679,1 +2665,3 @@\n-            int workingExponent = exponent;\n+            final int expZeros = Integer.numberOfLeadingZeros(exponent);\n+            int expLen = Integer.SIZE - expZeros;\n+            int workingExp = exponent << expZeros;\n@@ -2681,4 +2669,4 @@\n-            while (workingExponent != 0) {\n-                if ((workingExponent & 1) == 1) {\n-                    answer = answer.multiply(partToSquare);\n-                }\n+            for (; expLen > 0; expLen--) {\n+                answer = answer.multiply(answer);\n+                if (workingExp < 0) \/\/ leading bit is set\n+                    answer = answer.multiply(base);\n@@ -2686,3 +2674,1 @@\n-                if ((workingExponent >>>= 1) != 0) {\n-                    partToSquare = partToSquare.square();\n-                }\n+                workingExp <<= 1;\n@@ -2690,0 +2676,1 @@\n+\n@@ -2696,1 +2683,1 @@\n-            if (signum < 0 && (exponent&1) == 1) {\n+            if (signum < 0 && (exponent & 1) == 1) {\n@@ -2704,0 +2691,50 @@\n+    \/**\n+     * Computes {@code x^n} using repeated squaring trick.\n+     * Assumes {@code x != 0 && x^n < 2^Long.SIZE}.\n+     *\/\n+    static long unsignedLongPow(long x, int n) {\n+        \/\/ Double.PRECISION \/ bitLength(x) is the largest integer e\n+        \/\/ such that x^e fits into a double. If e <= 3, we won't use fp arithmetic.\n+        \/\/ This allows to use fp arithmetic where possible.\n+        final int maxExp = Math.max(3, Double.PRECISION \/ bitLengthForLong(x));\n+        final int maxExpLen = bitLengthForInt(maxExp);\n+\n+        final int leadingZeros = Integer.numberOfLeadingZeros(n);\n+        int nLen = Integer.SIZE - leadingZeros;\n+        n <<= leadingZeros;\n+\n+        long pow = 1L;\n+        int blockLen;\n+        for (; nLen > 0; nLen -= blockLen) {\n+            blockLen = maxExpLen < nLen ? maxExpLen : nLen;\n+            \/\/ compute pow^(2^blockLen)\n+            if (pow != 1L) {\n+                for (int i = 0; i < blockLen; i++)\n+                    pow *= pow;\n+            }\n+\n+            \/\/ add exp to power's exponent\n+            int exp = n >>> -blockLen;\n+            if (exp > 0) {\n+                \/\/ adjust exp to fit x^expAdj into a double\n+                int expAdj = exp <= maxExp ? exp : exp >>> 1;\n+\n+                \/\/ don't use fp arithmetic if expAdj <= 3\n+                long xToExp = expAdj == 1 ? x :\n+                             (expAdj == 2 ? x*x :\n+                             (expAdj == 3 ? x*x*x : (long) Math.pow(x, expAdj)));\n+\n+                \/\/ append exp's rightmost bit to expAdj\n+                if (expAdj != exp) {\n+                    xToExp *= xToExp;\n+                    if ((exp & 1) == 1)\n+                        xToExp *= x;\n+                }\n+                pow *= xToExp;\n+            }\n+            n <<= blockLen; \/\/ shift to next block of bits\n+        }\n+\n+        return pow;\n+    }\n+\n@@ -2753,0 +2790,74 @@\n+    \/**\n+     * Returns the integer {@code n}th root of this BigInteger. The integer\n+     * {@code n}th root of the corresponding mathematical integer {@code x} has the\n+     * same sign of {@code x}, and its magnitude is the largest integer {@code r}\n+     * such that {@code r**n <= abs(x)}. It is equal to the value of\n+     * {@code (x.signum() * floor(abs(nthRoot(x, n))))}, where {@code nthRoot(x, n)}\n+     * denotes the real {@code n}th root of {@code x} treated as a real. If {@code n}\n+     * is even and this BigInteger is negative, an {@code ArithmeticException} will be\n+     * thrown.\n+     *\n+     * <p>Note that the magnitude of the integer {@code n}th root will be less than\n+     * the magnitude of the real {@code n}th root if the latter is not representable\n+     * as an integral value.\n+     *\n+     * @param n the root degree\n+     * @return the integer {@code n}th root of {@code this}\n+     * @throws ArithmeticException if {@code n == 0} (Zeroth roots are not\n+     *                             defined.)\n+     * @throws ArithmeticException if {@code n} is negative. (This would cause the\n+     *                             operation to yield a non-integer value.)\n+     * @throws ArithmeticException if {@code n} is even and {@code this} is\n+     *                             negative. (This would cause the operation to\n+     *                             yield non-real roots.)\n+     * @see #sqrt()\n+     * @since 25\n+     *\/\n+    public BigInteger nthRoot(int n) {\n+        if (n == 1)\n+            return this;\n+\n+        if (n == 2)\n+            return sqrt();\n+\n+        if (n <= 0)\n+            throw new ArithmeticException(\"Non-positive root degree\");\n+\n+        if ((n & 1) == 0 && this.signum < 0)\n+            throw new ArithmeticException(\"Negative radicand with even root degree\");\n+\n+        return new MutableBigInteger(this.mag).nthRoot(n).toBigInteger(signum);\n+    }\n+\n+    \/**\n+     * Returns an array of two BigIntegers containing the integer {@code n}th root\n+     * {@code r} of {@code this} and its remainder {@code this - r^n},\n+     * respectively.\n+     *\n+     * @param n the root degree\n+     * @return an array of two BigIntegers with the integer {@code n}th root at\n+     *         offset 0 and the remainder at offset 1\n+     * @throws ArithmeticException if {@code n == 0} (Zeroth roots are not\n+     *                             defined.)\n+     * @throws ArithmeticException if {@code n} is negative. (This would cause the\n+     *                             operation to yield a non-integer value.)\n+     * @throws ArithmeticException if {@code n} is even and {@code this} is\n+     *                             negative. (This would cause the operation to\n+     *                             yield non-real roots.)\n+     * @see #sqrt()\n+     * @see #sqrtAndRemainder()\n+     * @see #nthRoot(int)\n+     * @since 25\n+     *\/\n+    public BigInteger[] nthRootAndRemainder(int n) {\n+        if (n == 1)\n+            return new BigInteger[] { this, ZERO };\n+\n+        if (n == 2)\n+            return sqrtAndRemainder();\n+\n+        BigInteger root = nthRoot(n), rem = this.subtract(root.pow(n));\n+        assert rem.signum == 0 || rem.signum == this.signum;\n+        return new BigInteger[] { root, rem };\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":150,"deletions":39,"binary":false,"changes":189,"status":"modified"},{"patch":"@@ -1895,0 +1895,96 @@\n+    \/**\n+     * Calculate the integer {@code n}th root {@code floor(nthRoot(this, n))} where\n+     * {@code nthRoot(., n)} denotes the mathematical {@code n}th root. The contents of\n+     * {@code this} are <b>not<\/b> changed. The value of {@code this} is assumed\n+     * to be non-negative and the root degree {@code n >= 3}.\n+     *\n+     * @implNote The implementation is based on the material in Henry S. Warren,\n+     * Jr., <i>Hacker's Delight (2nd ed.)<\/i> (Addison Wesley, 2013), 279-282.\n+     *\n+     * @return the integer {@code n}th of {@code this}\n+     *\/\n+    MutableBigInteger nthRoot(int n) {\n+        \/\/ Special cases.\n+        if (this.isZero() || this.isOne())\n+            return this;\n+\n+        final int bitLength = (int) this.bitLength();\n+        \/\/ if this < 2^n, result is unity\n+        if (bitLength <= n)\n+            return new MutableBigInteger(1);\n+\n+        MutableBigInteger r;\n+        if (bitLength <= Long.SIZE) {\n+            \/\/ Initial estimate is the root of the unsigned long value.\n+            final long x = this.toLong();\n+            \/\/ Use fp arithmetic to get an upper bound of the root\n+            final double base = Math.nextUp(x >= 0 ? x : x + 0x1p64);\n+            final double exp = Math.nextUp(1.0 \/ n);\n+            long rLong = (long) Math.ceil(Math.nextUp(Math.pow(base, exp)));\n+\n+            if (BigInteger.bitLengthForLong(rLong) * n <= Long.SIZE) {\n+                \/\/ Refine the estimate.\n+                do {\n+                    long rToN1 = BigInteger.unsignedLongPow(rLong, n - 1);\n+                    long rToN = rToN1 * rLong;\n+                    if (Long.compareUnsigned(rToN, x) <= 0)\n+                        return new MutableBigInteger(rLong);\n+\n+                    \/\/ compute rLong - ceil((rToN - x) \/ (n * rToN1))\n+                    long dividend = rToN - x, divisor = n * rToN1;\n+                    if (Long.remainderUnsigned(dividend, divisor) != 0)\n+                        rLong--;\n+\n+                    rLong -= Long.divideUnsigned(dividend, divisor);\n+                } while (true);\n+            } else { \/\/ r^n could overflow long range, use MutableBigInteger loop instead\n+                r = new MutableBigInteger(rLong);\n+            }\n+        } else {\n+            \/\/ Set up the initial estimate of the iteration.\n+            \/\/ Determine a right shift that is a multiple of n into finite double range.\n+            long shift = Math.max(0, bitLength - Double.MAX_EXPONENT); \/\/ use long to avoid overflow later\n+            int shiftExcess = (int) (shift % n);\n+\n+            \/\/ Shift the value into finite double range\n+            r = new MutableBigInteger(this);\n+            r.rightShift((int) shift);\n+            double base = r.toBigInteger().doubleValue();\n+            \/\/ Complete the shift to a multiple of n,\n+            \/\/ avoiding to lose more bits than necessary.\n+            if (shiftExcess != 0) {\n+                int shiftLack = n - shiftExcess;\n+                shift += shiftLack; \/\/ shift is long, no overflow\n+                base \/= Double.valueOf(\"0x1p\" + shiftLack);\n+            }\n+\n+            \/\/ Use the root of the shifted value as an estimate.\n+            base = Math.nextUp(base);\n+            final double exp = Math.nextUp(1.0 \/ n);\n+            final double rDouble = Math.ceil(Math.nextUp(Math.pow(base, exp)));\n+            r = new MutableBigInteger(new BigDecimal(rDouble).toBigInteger().mag);\n+\n+            \/\/ Shift the approximate root back into the original range.\n+            r.leftShift((int) (shift \/ n));\n+        }\n+\n+        \/\/ Refine the estimate.\n+        do {\n+            BigInteger rBig = r.toBigInteger();\n+            BigInteger rToN1 = rBig.pow(n - 1);\n+            MutableBigInteger rToN = new MutableBigInteger(rToN1.multiply(rBig).mag);\n+            if (rToN.compare(this) <= 0)\n+                return r;\n+\n+            \/\/ compute r - ceil((rToN - this) \/ (n * rToN1))\n+            MutableBigInteger q1 = new MutableBigInteger();\n+            MutableBigInteger delta = new MutableBigInteger();\n+            rToN.subtract(this);\n+            \/\/ Don't use conditional-or to ensure to do both divisions\n+            if(rToN.divideOneWord(n, q1) != 0 | !q1.divide(new MutableBigInteger(rToN1.mag), delta).isZero())\n+                r.subtract(ONE);\n+\n+            r.subtract(delta);\n+        } while (true);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"modified"}]}