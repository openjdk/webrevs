{"files":[{"patch":"@@ -2706,1 +2706,1 @@\n-        \/\/ This allows to use fp arithmetic where possible.\n+        \/\/ This allows to use fp arithmetic in computePower(), where possible.\n@@ -2726,26 +2726,3 @@\n-            if (exp > 0) {\n-                BigInteger xToExp = powerCache[exp];\n-                if (xToExp == null) {\n-                    \/\/ adjust exp to fit x^expAdj into a double\n-                    int expAdj = exp <= maxExp ? exp : exp >>> 1;\n-\n-                    long xLong = x & LONG_MASK;\n-                    \/\/ don't use fp arithmetic if expAdj <= 2\n-                    long xToExpAdj = expAdj == 1 ? xLong :\n-                                    (expAdj == 2 ? xLong*xLong : (long) Math.pow(xLong, expAdj));\n-\n-                    xToExp = new BigInteger(1, new int[] { (int) (xToExpAdj >>> 32), (int) xToExpAdj });\n-                    powerCache[expAdj] = xToExp;\n-                    \/\/ append exp's rightmost bit to expAdj\n-                    if (expAdj != exp) {\n-                        xToExp = xToExp.multiply(xToExp);\n-                        powerCache[expAdj << 1] = xToExp;\n-\n-                        if ((exp & 1) == 1) {\n-                            xToExp = xToExp.multiply(xLong);\n-                            powerCache[exp] = xToExp;\n-                        }\n-                    }\n-                }\n-                pow = pow.multiply(xToExp);\n-            }\n+            if (exp > 0)\n+                pow = pow.multiply(computePower(powerCache, x & LONG_MASK, exp, maxExp));\n+\n@@ -2758,0 +2735,43 @@\n+    \/**\n+     * Returns {@code x^exp}. This method is used by {@code unsignedIntPow(int, int)}.\n+     * Assumes {@code maxExp == max(2, Double.PRECISION \/ bitLength(x))}.\n+     *\/\n+    private static BigInteger computePower(BigInteger[] powerCache, long x, int exp, int maxExp) {\n+        BigInteger xToExp = powerCache[exp];\n+        if (xToExp == null) {\n+            if (exp <= maxExp) {\n+                \/\/ don't use fp arithmetic if exp <= 2\n+                long pow = exp == 1 ? x :\n+                          (exp == 2 ? x*x : (long) Math.pow(x, exp));\n+\n+                xToExp = new BigInteger(1, new int[] { (int) (pow >>> 32), (int) pow });\n+                powerCache[exp] = xToExp;\n+            } else {\n+                \/\/ adjust exp to fit x^expAdj into a double\n+                final int expAdj = exp >>> 1;\n+\n+                xToExp = powerCache[expAdj << 1];\n+                if (xToExp == null) { \/\/ compute x^(expAdj << 1)\n+                    xToExp = powerCache[expAdj];\n+                    if (xToExp == null) { \/\/ compute x^expAdj\n+                        \/\/ don't use fp arithmetic if expAdj <= 2\n+                        long xToExpAdj = expAdj == 1 ? x :\n+                                        (expAdj == 2 ? x*x : (long) Math.pow(x, expAdj));\n+\n+                        xToExp = new BigInteger(1, new int[] { (int) (xToExpAdj >>> 32), (int) xToExpAdj });\n+                        powerCache[expAdj] = xToExp;\n+                    }\n+                    xToExp = xToExp.multiply(xToExp);\n+                    powerCache[expAdj << 1] = xToExp;\n+                }\n+\n+                \/\/ append exp's rightmost bit to expAdj\n+                if ((exp & 1) == 1) {\n+                    xToExp = xToExp.multiply(x);\n+                    powerCache[exp] = xToExp;\n+                }\n+            }\n+        }\n+        return xToExp;\n+    }\n+\n@@ -2770,1 +2790,1 @@\n-        \/\/ This allows to use fp arithmetic where possible.\n+        \/\/ This allows to use fp arithmetic in computePower(), where possible.\n@@ -2790,25 +2810,3 @@\n-            if (exp > 0) {\n-                long xToExp = powerCache[exp];\n-                if (xToExp == 0) {\n-                    \/\/ adjust exp to fit x^expAdj into a double\n-                    int expAdj = exp <= maxExp ? exp : exp >>> 1;\n-\n-                    \/\/ don't use fp arithmetic if expAdj <= 3\n-                    xToExp = expAdj == 1 ? x :\n-                            (expAdj == 2 ? x*x :\n-                            (expAdj == 3 ? x*x*x : (long) Math.pow(x, expAdj)));\n-                    powerCache[expAdj] = xToExp;\n-\n-                    \/\/ append exp's rightmost bit to expAdj\n-                    if (expAdj != exp) {\n-                        xToExp *= xToExp;\n-                        powerCache[expAdj << 1] = xToExp;\n-\n-                        if ((exp & 1) == 1) {\n-                            xToExp *= x;\n-                            powerCache[exp] = xToExp;\n-                        }\n-                    }\n-                }\n-                pow *= xToExp;\n-            }\n+            if (exp > 0)\n+                pow *= computePower(powerCache, x, exp, maxExp);\n+\n@@ -2821,0 +2819,41 @@\n+    \/**\n+     * Returns {@code x^exp}. This method is used by {@code unsignedLongPow(long, int)}.\n+     * Assumes {@code maxExp == max(3, Double.PRECISION \/ bitLength(x))}.\n+     *\/\n+    private static long computePower(long[] powerCache, long x, int exp, int maxExp) {\n+        long xToExp = powerCache[exp];\n+        if (xToExp == 0) {\n+            if (exp <= maxExp) {\n+                \/\/ don't use fp arithmetic if exp <= 3\n+                xToExp = exp == 1 ? x :\n+                        (exp == 2 ? x*x :\n+                        (exp == 3 ? x*x*x : (long) Math.pow(x, exp)));\n+                powerCache[exp] = xToExp;\n+            } else {\n+                \/\/ adjust exp to fit x^expAdj into a double\n+                final int expAdj = exp >>> 1;\n+\n+                xToExp = powerCache[expAdj << 1];\n+                if (xToExp == 0) { \/\/ compute x^(expAdj << 1)\n+                    xToExp = powerCache[expAdj];\n+                    if (xToExp == 0) {  \/\/ compute x^expAdj\n+                        \/\/ don't use fp arithmetic if expAdj <= 3\n+                        xToExp = expAdj == 1 ? x :\n+                                (expAdj == 2 ? x*x :\n+                                (expAdj == 3 ? x*x*x : (long) Math.pow(x, expAdj)));\n+                        powerCache[expAdj] = xToExp;\n+                    }\n+                    xToExp *= xToExp;\n+                    powerCache[expAdj << 1] = xToExp;\n+                }\n+\n+                \/\/ append exp's rightmost bit to expAdj\n+                if ((exp & 1) == 1) {\n+                    xToExp *= x;\n+                    powerCache[exp] = xToExp;\n+                }\n+            }\n+        }\n+        return xToExp;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":92,"deletions":53,"binary":false,"changes":145,"status":"modified"}]}