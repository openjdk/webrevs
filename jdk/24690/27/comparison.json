{"files":[{"patch":"@@ -2596,1 +2596,1 @@\n-        BigInteger partToSquare = this.abs();\n+        BigInteger base = this.abs();\n@@ -2602,1 +2602,1 @@\n-        int powersOfTwo = partToSquare.getLowestSetBit();\n+        int powersOfTwo = base.getLowestSetBit();\n@@ -2613,2 +2613,2 @@\n-            partToSquare = partToSquare.shiftRight(powersOfTwo);\n-            remainingBits = partToSquare.bitLength();\n+            base = base.shiftRight(powersOfTwo);\n+            remainingBits = base.bitLength();\n@@ -2623,1 +2623,1 @@\n-            remainingBits = partToSquare.bitLength();\n+            remainingBits = base.bitLength();\n@@ -2640,1 +2640,1 @@\n-        if (partToSquare.mag.length == 1 && scaleFactor <= 62) {\n+        if (base.mag.length == 1 && scaleFactor <= 62) {\n@@ -2643,15 +2643,1 @@\n-            long result = 1;\n-            long baseToPow2 = partToSquare.mag[0] & LONG_MASK;\n-\n-            int workingExponent = exponent;\n-\n-            \/\/ Perform exponentiation using repeated squaring trick\n-            while (workingExponent != 0) {\n-                if ((workingExponent & 1) == 1) {\n-                    result = result * baseToPow2;\n-                }\n-\n-                if ((workingExponent >>>= 1) != 0) {\n-                    baseToPow2 = baseToPow2 * baseToPow2;\n-                }\n-            }\n+            long result = unsignedLongPow(base.mag[0] & LONG_MASK, exponent);\n@@ -2675,1 +2661,1 @@\n-            \/\/ the algorithm above, but calls multiply() and square()\n+            \/\/ the algorithm above, but calls multiply()\n@@ -2677,1 +2663,5 @@\n-            BigInteger answer = ONE;\n+            BigInteger answer;\n+            if (base.mag.length == 1) {\n+                answer = unsignedIntPow(base.mag[0], exponent);\n+            } else {\n+                answer = ONE;\n@@ -2679,6 +2669,7 @@\n-            int workingExponent = exponent;\n-            \/\/ Perform exponentiation using repeated squaring trick\n-            while (workingExponent != 0) {\n-                if ((workingExponent & 1) == 1) {\n-                    answer = answer.multiply(partToSquare);\n-                }\n+                final int expZeros = Integer.numberOfLeadingZeros(exponent);\n+                int workingExp = exponent << expZeros;\n+                \/\/ Perform exponentiation using repeated squaring trick\n+                for (int expLen = Integer.SIZE - expZeros; expLen > 0; expLen--) {\n+                    answer = answer.multiply(answer);\n+                    if (workingExp < 0) \/\/ leading bit is set\n+                        answer = answer.multiply(base);\n@@ -2686,2 +2677,1 @@\n-                if ((workingExponent >>>= 1) != 0) {\n-                    partToSquare = partToSquare.square();\n+                    workingExp <<= 1;\n@@ -2690,0 +2680,1 @@\n+\n@@ -2704,0 +2695,99 @@\n+    \/**\n+     * Computes {@code x^n} using repeated squaring trick.\n+     * Assumes {@code x != 0}.\n+     *\/\n+    static BigInteger unsignedIntPow(int x, int n) {\n+        \/\/ Double.PRECISION \/ bitLength(x) is the largest integer e\n+        \/\/ such that x^e fits into a double. If e <= 2, we won't use fp arithmetic.\n+        \/\/ This allows to use fp arithmetic where possible.\n+        final int maxExp = Math.max(2, Double.PRECISION \/ bitLengthForInt(x));\n+        final int maxExpLen = bitLengthForInt(maxExp);\n+\n+        final int nZeros = Integer.numberOfLeadingZeros(n);\n+        n <<= nZeros;\n+\n+        BigInteger pow = ONE;\n+        int blockLen;\n+        for (int nLen = Integer.SIZE - nZeros; nLen > 0; nLen -= blockLen) {\n+            blockLen = maxExpLen < nLen ? maxExpLen : nLen;\n+            \/\/ compute pow^(2^blockLen)\n+            if (!pow.equals(ONE)) {\n+                for (int i = 0; i < blockLen; i++)\n+                    pow = pow.multiply(pow);\n+            }\n+\n+            \/\/ add exp to power's exponent\n+            int exp = n >>> -blockLen;\n+            if (exp > 0) {\n+                \/\/ adjust exp to fit x^expAdj into a double\n+                int expAdj = exp <= maxExp ? exp : exp >>> 1;\n+\n+                long xLong = x & LONG_MASK;\n+                \/\/ don't use fp arithmetic if expAdj <= 2\n+                long xToExpAdj = expAdj == 1 ? xLong :\n+                                (expAdj == 2 ? xLong*xLong : (long) Math.pow(xLong, expAdj));\n+\n+                \/\/ append exp's rightmost bit to expAdj\n+                BigInteger xToExp = new BigInteger(1, new int[] { (int) (xToExpAdj >>> 32), (int) xToExpAdj });\n+                if (expAdj != exp) {\n+                    xToExp = xToExp.multiply(xToExp);\n+                    if ((exp & 1) == 1)\n+                        xToExp = xToExp.multiply(xLong);\n+                }\n+                pow = pow.multiply(xToExp);\n+            }\n+            n <<= blockLen; \/\/ shift to next block of bits\n+        }\n+\n+        return pow;\n+    }\n+\n+    \/**\n+     * Computes {@code x^n} using repeated squaring trick.\n+     * Assumes {@code x != 0 && x^n < 2^Long.SIZE}.\n+     *\/\n+    static long unsignedLongPow(long x, int n) {\n+        \/\/ Double.PRECISION \/ bitLength(x) is the largest integer e\n+        \/\/ such that x^e fits into a double. If e <= 3, we won't use fp arithmetic.\n+        \/\/ This allows to use fp arithmetic where possible.\n+        final int maxExp = Math.max(3, Double.PRECISION \/ bitLengthForLong(x));\n+        final int maxExpLen = bitLengthForInt(maxExp);\n+\n+        final int nZeros = Integer.numberOfLeadingZeros(n);\n+        n <<= nZeros;\n+\n+        long pow = 1L;\n+        int blockLen;\n+        for (int nLen = Integer.SIZE - nZeros; nLen > 0; nLen -= blockLen) {\n+            blockLen = maxExpLen < nLen ? maxExpLen : nLen;\n+            \/\/ compute pow^(2^blockLen)\n+            if (pow != 1L) {\n+                for (int i = 0; i < blockLen; i++)\n+                    pow *= pow;\n+            }\n+\n+            \/\/ add exp to power's exponent\n+            int exp = n >>> -blockLen;\n+            if (exp > 0) {\n+                \/\/ adjust exp to fit x^expAdj into a double\n+                int expAdj = exp <= maxExp ? exp : exp >>> 1;\n+\n+                \/\/ don't use fp arithmetic if expAdj <= 3\n+                long xToExp = expAdj == 1 ? x :\n+                             (expAdj == 2 ? x*x :\n+                             (expAdj == 3 ? x*x*x : (long) Math.pow(x, expAdj)));\n+\n+                \/\/ append exp's rightmost bit to expAdj\n+                if (expAdj != exp) {\n+                    xToExp *= xToExp;\n+                    if ((exp & 1) == 1)\n+                        xToExp *= x;\n+                }\n+                pow *= xToExp;\n+            }\n+            n <<= blockLen; \/\/ shift to next block of bits\n+        }\n+\n+        return pow;\n+    }\n+\n@@ -2753,0 +2843,72 @@\n+    \/**\n+     * Returns the integer {@code n}th root of this BigInteger. The integer\n+     * {@code n}th root of the corresponding mathematical integer {@code x} has the\n+     * same sign of {@code x}, and its magnitude is the largest integer {@code r}\n+     * such that {@code r**n <= abs(x)}. It is equal to the value of\n+     * {@code (x.signum() * floor(abs(nthRoot(x, n))))}, where {@code nthRoot(x, n)}\n+     * denotes the real {@code n}th root of {@code x} treated as a real. If {@code n}\n+     * is even and this BigInteger is negative, an {@code ArithmeticException} will be\n+     * thrown.\n+     *\n+     * <p>Note that the magnitude of the integer {@code n}th root will be less than\n+     * the magnitude of the real {@code n}th root if the latter is not representable\n+     * as an integral value.\n+     *\n+     * @param n the root degree\n+     * @return the integer {@code n}th root of {@code this}\n+     * @throws ArithmeticException if {@code n == 0} (Zeroth roots are not\n+     *                             defined.)\n+     * @throws ArithmeticException if {@code n} is negative. (This would cause the\n+     *                             operation to yield a non-integer value.)\n+     * @throws ArithmeticException if {@code n} is even and {@code this} is\n+     *                             negative. (This would cause the operation to\n+     *                             yield non-real roots.)\n+     * @see #sqrt()\n+     * @since 25\n+     *\/\n+    public BigInteger nthRoot(int n) {\n+        return n == 1 ? this : (n == 2 ? sqrt() : nthRootAndRemainder(n, false)[0]);\n+    }\n+\n+    \/**\n+     * Returns an array of two BigIntegers containing the integer {@code n}th root\n+     * {@code r} of {@code this} and its remainder {@code this - r^n},\n+     * respectively.\n+     *\n+     * @param n the root degree\n+     * @return an array of two BigIntegers with the integer {@code n}th root at\n+     *         offset 0 and the remainder at offset 1\n+     * @throws ArithmeticException if {@code n == 0} (Zeroth roots are not\n+     *                             defined.)\n+     * @throws ArithmeticException if {@code n} is negative. (This would cause the\n+     *                             operation to yield a non-integer value.)\n+     * @throws ArithmeticException if {@code n} is even and {@code this} is\n+     *                             negative. (This would cause the operation to\n+     *                             yield non-real roots.)\n+     * @see #sqrt()\n+     * @see #sqrtAndRemainder()\n+     * @see #nthRoot(int)\n+     * @since 25\n+     *\/\n+    public BigInteger[] nthRootAndRemainder(int n) {\n+        return n == 1 ? new BigInteger[] { this, ZERO }\n+                      : (n == 2 ? sqrtAndRemainder() : nthRootAndRemainder(n, true));\n+    }\n+\n+    \/**\n+     * Assume {@code n != 1 && n != 2}\n+     *\/\n+    private BigInteger[] nthRootAndRemainder(int n, boolean needRemainder) {\n+        if (n <= 0)\n+            throw new ArithmeticException(\"Non-positive root degree\");\n+\n+        if ((n & 1) == 0 && this.signum < 0)\n+            throw new ArithmeticException(\"Negative radicand with even root degree\");\n+\n+        MutableBigInteger[] rootRem = new MutableBigInteger(this.mag).nthRootRem(n);\n+        return new BigInteger[] {\n+                rootRem[0].toBigInteger(signum),\n+                needRemainder ? rootRem[1].toBigInteger(signum) : null\n+        };\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":193,"deletions":31,"binary":false,"changes":224,"status":"modified"},{"patch":"@@ -161,0 +161,21 @@\n+    \/**\n+     * Returns a MutableBigInteger with a magnitude specified by\n+     * the absolute value of the double val. Any fractional part is discarded.\n+     *\n+     * Assume val is in the finite double range.\n+     *\/\n+    static MutableBigInteger valueOf(double val) {\n+        val = Math.abs(val);\n+        if (val < 0x1p63)\n+            return new MutableBigInteger((long) val);\n+        \/\/ Translate the double into exponent and significand, according\n+        \/\/ to the formulae in JLS, Section 20.10.22.\n+        long valBits = Double.doubleToRawLongBits(val);\n+        int exponent = (int) ((valBits >> 52) & 0x7ffL) - 1075;\n+        long significand = (valBits & ((1L << 52) - 1)) | (1L << 52);\n+        \/\/ At this point, val == significand * 2^exponent, with exponent > 0\n+        MutableBigInteger result = new MutableBigInteger(significand);\n+        result.leftShift(exponent);\n+        return result;\n+    }\n+\n@@ -1895,0 +1916,102 @@\n+    \/**\n+     * Calculate the integer {@code n}th root {@code floor(nthRoot(this, n))} and the remainder,\n+     * where {@code nthRoot(., n)} denotes the mathematical {@code n}th root. The contents of\n+     * {@code this} are <b>not<\/b> changed. The value of {@code this} is assumed\n+     * to be non-negative and the root degree {@code n >= 3}.\n+     *\n+     * @implNote The implementation is based on the material in Henry S. Warren,\n+     * Jr., <i>Hacker's Delight (2nd ed.)<\/i> (Addison Wesley, 2013), 279-282.\n+     * <a href=\"https:\/\/github.com\/user-attachments\/files\/19785045\/nth_root_newton_proof_integers.pdf\">\n+     * Here<\/a> is a proof for the convergence of the recurrence used by the\n+     * algorithm.\n+     *\n+     * @return the integer {@code n}th of {@code this} and the remainder\n+     *\/\n+    MutableBigInteger[] nthRootRem(int n) {\n+        \/\/ Special cases.\n+        if (this.isZero() || this.isOne())\n+            return new MutableBigInteger[] { this, new MutableBigInteger() };\n+\n+        final int bitLength = (int) this.bitLength();\n+        \/\/ if this < 2^n, result is unity\n+        if (bitLength <= n) {\n+            MutableBigInteger rem = new MutableBigInteger(this);\n+            rem.subtract(ONE);\n+            return new MutableBigInteger[] { new MutableBigInteger(1), rem };\n+        }\n+\n+        MutableBigInteger r;\n+        if (bitLength <= Long.SIZE) {\n+            \/\/ Initial estimate is the root of the unsigned long value.\n+            final long x = this.toLong();\n+            \/\/ Use fp arithmetic to get an upper bound of the root\n+            final double rad = Math.nextUp(x >= 0 ? x : x + 0x1p64);\n+            final double approx = n == 3 ? Math.cbrt(rad) : Math.pow(rad, Math.nextUp(1.0 \/ n));\n+            long rLong = (long) Math.ceil(Math.nextUp(approx));\n+\n+            if (BigInteger.bitLengthForLong(rLong) * n <= Long.SIZE) {\n+                \/\/ Refine the estimate.\n+                do {\n+                    long rToN1 = BigInteger.unsignedLongPow(rLong, n - 1);\n+                    long rToN = rToN1 * rLong;\n+                    if (Long.compareUnsigned(rToN, x) <= 0)\n+                        return new MutableBigInteger[] {\n+                                new MutableBigInteger(rLong), new MutableBigInteger(x - rToN)\n+                        };\n+\n+                    \/\/ compute rLong - ceil((rToN - x) \/ (n * rToN1))\n+                    long dividend = rToN - x, divisor = n * rToN1;\n+                    if (Long.remainderUnsigned(dividend, divisor) != 0)\n+                        rLong--;\n+\n+                    rLong -= Long.divideUnsigned(dividend, divisor);\n+                } while (true);\n+            } else { \/\/ r^n could overflow long range, use MutableBigInteger loop instead\n+                r = new MutableBigInteger(rLong);\n+            }\n+        } else {\n+            \/\/ Set up the initial estimate of the iteration.\n+            \/\/ Determine a right shift that is a multiple of n into finite double range.\n+            long shift = Math.max(0, bitLength - Double.MAX_EXPONENT); \/\/ use long to avoid overflow later\n+            int shiftExcess = (int) (shift % n);\n+\n+            \/\/ Shift the value into finite double range\n+            double rad = this.toBigInteger().shiftRight((int) shift).doubleValue();\n+            \/\/ Complete the shift to a multiple of n,\n+            \/\/ avoiding to lose more bits than necessary.\n+            if (shiftExcess != 0) {\n+                int shiftLack = n - shiftExcess;\n+                shift += shiftLack; \/\/ shift is long, no overflow\n+                rad \/= Double.valueOf(\"0x1p\" + shiftLack);\n+            }\n+\n+            \/\/ Use the root of the shifted value as an estimate.\n+            rad = Math.nextUp(rad);\n+            final double approx = n == 3 ? Math.cbrt(rad) : Math.pow(rad, Math.nextUp(1.0 \/ n));\n+            r = valueOf(Math.ceil(Math.nextUp(approx)));\n+\n+            \/\/ Shift the approximate root back into the original range.\n+            r.safeLeftShift((int) (shift \/ n));\n+        }\n+\n+        \/\/ Refine the estimate.\n+        do {\n+            BigInteger rBig = r.toBigInteger();\n+            BigInteger rToN1 = rBig.pow(n - 1);\n+            MutableBigInteger rem = new MutableBigInteger(rToN1.multiply(rBig).mag);\n+            if (rem.subtract(this) <= 0)\n+                return new MutableBigInteger[] { r, rem };\n+\n+            \/\/ compute r - ceil((r^n - this) \/ (n * r^(n-1)))\n+            MutableBigInteger q1 = new MutableBigInteger();\n+            MutableBigInteger delta = new MutableBigInteger();\n+            \/\/ Don't use conditional-or, in order to do both divisions\n+            \/\/ and make delta == (r^n - this) \/ (n * r^(n-1))\n+            if ((rem.divideOneWord(n, q1) != 0)\n+                    | (!q1.divide(new MutableBigInteger(rToN1.mag), delta).isZero()))\n+                r.subtract(ONE);\n+\n+            r.subtract(delta);\n+        } while (true);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"modified"}]}