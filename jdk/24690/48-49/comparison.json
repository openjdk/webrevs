{"files":[{"patch":"@@ -2607,0 +2607,1 @@\n+        final boolean negative = signum < 0 && (exponent & 1) == 1;\n@@ -2619,23 +2620,5 @@\n-        int remainingBits;\n-\n-        \/\/ Factor the powers of two out quickly by shifting right, if needed.\n-        if (powersOfTwo > 0) {\n-            base = base.shiftRight(powersOfTwo);\n-            remainingBits = base.bitLength();\n-            if (remainingBits == 1) {  \/\/ Nothing left but +\/- 1?\n-                if (signum < 0 && (exponent&1) == 1) {\n-                    return NEGATIVE_ONE.shiftLeft(bitsToShift);\n-                } else {\n-                    return ONE.shiftLeft(bitsToShift);\n-                }\n-            }\n-        } else {\n-            remainingBits = base.bitLength();\n-            if (remainingBits == 1) { \/\/ Nothing left but +\/- 1?\n-                if (signum < 0  && (exponent&1) == 1) {\n-                    return NEGATIVE_ONE;\n-                } else {\n-                    return ONE;\n-                }\n-            }\n-        }\n+        \/\/ Factor the powers of two out quickly by shifting right.\n+        base = base.shiftRight(powersOfTwo);\n+        int remainingBits = base.bitLength();\n+        if (remainingBits == 1) \/\/ Nothing left but +\/- 1?\n+            return (negative ? NEGATIVE_ONE : ONE).shiftLeft(bitsToShift);\n@@ -2652,2 +2635,2 @@\n-            int newSign = (signum < 0 && (exponent & 1) == 1 ? -1 : 1);\n-            long result = unsignedLongPow(base.mag[0] & LONG_MASK, exponent);\n+            final int newSign = negative ? -1 : 1;\n+            final long result = unsignedLongPow(base.mag[0] & LONG_MASK, exponent);\n@@ -2656,5 +2639,3 @@\n-            return powersOfTwo == 0\n-                    ? new BigInteger(result, newSign)\n-                    : (bitsToShift + scaleFactor <= Long.SIZE  \/\/ Fits in long?\n-                            ? new BigInteger(result << bitsToShift, newSign)\n-                            : new BigInteger(result, newSign).shiftLeft(bitsToShift));\n+            return bitsToShift + scaleFactor <= Long.SIZE  \/\/ Fits in long?\n+                    ? new BigInteger(result << bitsToShift, newSign)\n+                    : new BigInteger(result, newSign).shiftLeft(bitsToShift);\n@@ -2662,1 +2643,1 @@\n-            if ((((bitLength() - 1L) * exponent) >>> 5) + 1L > MAX_MAG_LENGTH) {\n+            if (((bitLength() - 1L) * exponent) >= (long) MAX_MAG_LENGTH << 5) {\n@@ -2684,9 +2665,2 @@\n-            if (powersOfTwo > 0) {\n-                answer = answer.shiftLeft(bitsToShift);\n-            }\n-\n-            if (signum < 0 && (exponent&1) == 1) {\n-                return answer.negate();\n-            } else {\n-                return answer;\n-            }\n+            answer = answer.shiftLeft(bitsToShift);\n+            return negative ? answer.negate() : answer;\n@@ -2701,1 +2675,1 @@\n-        if (x == 1L)\n+        if (x == 1L || n == 0)\n@@ -2712,1 +2686,1 @@\n-        for (; n != 0; n >>>= 1) {\n+        for (; n != 1; n >>>= 1) {\n@@ -2718,1 +2692,1 @@\n-        return pow;\n+        return pow * x;\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":17,"deletions":43,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+    private int[] randomExps;\n@@ -62,2 +63,1 @@\n-     *    $ mvn clean install\n-     *    $ java -jar target\/benchmarks.jar BigIntegerPow -prof gc\n+     *    $ make test TEST=\"micro:java.math.BigIntegerPow\" MICRO=\"OPTIONS=-prof gc\"\n@@ -65,8 +65,0 @@\n-    public static void main(String[] args) throws RunnerException {\n-        Options opt = new OptionsBuilder()\n-                .include(BigIntegerPow.class.getSimpleName())\n-                .addProfiler(GCProfiler.class)\n-                .build();\n-\n-        new Runner(opt).run();\n-    }\n@@ -104,0 +96,1 @@\n+        randomExps = new int[TESTSIZE];\n@@ -110,0 +103,1 @@\n+            randomExps[i] = r.nextInt(1 << 12);\n@@ -117,2 +111,11 @@\n-        for (BigInteger s : xsArray) {\n-            bh.consume(s.pow(xsExp));\n+        for (BigInteger xs : xsArray) {\n+            bh.consume(xs.pow(xsExp));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testPowXSRandomExps(Blackhole bh) {\n+        int i = 0;\n+        for (BigInteger xs : xsArray) {\n+            bh.consume(xs.pow(randomExps[i++]));\n@@ -131,0 +134,9 @@\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testPowSRandomExps(Blackhole bh) {\n+        int i = 0;\n+        for (BigInteger s : sArray) {\n+            bh.consume(s.pow(randomExps[i++]));\n+        }\n+    }\n+\n@@ -135,2 +147,11 @@\n-        for (BigInteger s : mArray) {\n-            bh.consume(s.pow(mExp));\n+        for (BigInteger m : mArray) {\n+            bh.consume(m.pow(mExp));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testPowMRandomExps(Blackhole bh) {\n+        int i = 0;\n+        for (BigInteger m : mArray) {\n+            bh.consume(m.pow(randomExps[i++]));\n@@ -144,2 +165,11 @@\n-        for (BigInteger s : lArray) {\n-            bh.consume(s.pow(lExp));\n+        for (BigInteger l : lArray) {\n+            bh.consume(l.pow(lExp));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testPowLRandomExps(Blackhole bh) {\n+        int i = 0;\n+        for (BigInteger l : lArray) {\n+            bh.consume(l.pow(randomExps[i++]));\n@@ -153,2 +183,11 @@\n-        for (BigInteger s : xlArray) {\n-            bh.consume(s.pow(xlExp));\n+        for (BigInteger xl : xlArray) {\n+            bh.consume(xl.pow(xlExp));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testPowXLRandomExps(Blackhole bh) {\n+        int i = 0;\n+        for (BigInteger xl : xlArray) {\n+            bh.consume(xl.pow(randomExps[i++]));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/BigIntegerPow.java","additions":57,"deletions":18,"binary":false,"changes":75,"status":"modified"}]}