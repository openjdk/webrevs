{"files":[{"patch":"@@ -2663,1 +2663,5 @@\n-            BigInteger answer = ONE;\n+            BigInteger answer;\n+            if (base.mag.length == 1) {\n+                answer = unsignedIntPow(base.mag[0], exponent);\n+            } else {\n+                answer = ONE;\n@@ -2665,7 +2669,7 @@\n-            final int expZeros = Integer.numberOfLeadingZeros(exponent);\n-            int workingExp = exponent << expZeros;\n-            \/\/ Perform exponentiation using repeated squaring trick\n-            for (int expLen = Integer.SIZE - expZeros; expLen > 0; expLen--) {\n-                answer = answer.multiply(answer);\n-                if (workingExp < 0) \/\/ leading bit is set\n-                    answer = answer.multiply(base);\n+                final int expZeros = Integer.numberOfLeadingZeros(exponent);\n+                int workingExp = exponent << expZeros;\n+                \/\/ Perform exponentiation using repeated squaring trick\n+                for (int expLen = Integer.SIZE - expZeros; expLen > 0; expLen--) {\n+                    answer = answer.multiply(answer);\n+                    if (workingExp < 0) \/\/ leading bit is set\n+                        answer = answer.multiply(base);\n@@ -2673,1 +2677,2 @@\n-                workingExp <<= 1;\n+                    workingExp <<= 1;\n+                }\n@@ -2690,0 +2695,50 @@\n+    \/**\n+     * Computes {@code x^n} using repeated squaring trick.\n+     * Assumes {@code x != 0}.\n+     *\/\n+    static BigInteger unsignedIntPow(int x, int n) {\n+        \/\/ Double.PRECISION \/ bitLength(x) is the largest integer e\n+        \/\/ such that x^e fits into a double. If e <= 2, we won't use fp arithmetic.\n+        \/\/ This allows to use fp arithmetic where possible.\n+        final int maxExp = Math.max(2, Double.PRECISION \/ bitLengthForInt(x));\n+        final int maxExpLen = bitLengthForInt(maxExp);\n+\n+        final int nZeros = Integer.numberOfLeadingZeros(n);\n+        n <<= nZeros;\n+\n+        BigInteger pow = ONE;\n+        int blockLen;\n+        for (int nLen = Integer.SIZE - nZeros; nLen > 0; nLen -= blockLen) {\n+            blockLen = maxExpLen < nLen ? maxExpLen : nLen;\n+            \/\/ compute pow^(2^blockLen)\n+            if (!pow.equals(ONE)) {\n+                for (int i = 0; i < blockLen; i++)\n+                    pow = pow.multiply(pow);\n+            }\n+\n+            \/\/ add exp to power's exponent\n+            int exp = n >>> -blockLen;\n+            if (exp > 0) {\n+                \/\/ adjust exp to fit x^expAdj into a double\n+                int expAdj = exp <= maxExp ? exp : exp >>> 1;\n+\n+                long xLong = x & LONG_MASK;\n+                \/\/ don't use fp arithmetic if expAdj <= 2\n+                long xToExpAdj = expAdj == 1 ? xLong :\n+                                (expAdj == 2 ? xLong*xLong : (long) Math.pow(xLong, expAdj));\n+\n+                \/\/ append exp's rightmost bit to expAdj\n+                BigInteger xToExp = new BigInteger(1, new int[] { (int) (xToExpAdj >>> 32), (int) xToExpAdj });\n+                if (expAdj != exp) {\n+                    xToExp = xToExp.multiply(xToExp);\n+                    if ((exp & 1) == 1)\n+                        xToExp = xToExp.multiply(xLong);\n+                }\n+                pow = pow.multiply(xToExp);\n+            }\n+            n <<= blockLen; \/\/ shift to next block of bits\n+        }\n+\n+        return pow;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":64,"deletions":9,"binary":false,"changes":73,"status":"modified"}]}