{"files":[{"patch":"@@ -161,0 +161,23 @@\n+    \/**\n+     * Returns a MutableBigInteger with a magnitude specified by\n+     * the double val. Any fractional part is discarded.\n+     *\n+     * Assume {@code 1.0 <= val < Double.POSITIVE_INFINITY}\n+     *\/\n+    static MutableBigInteger valueOf(double val) {\n+        \/\/ Translate the double into exponent and significand, according\n+        \/\/ to the formulae in JLS, Section 20.10.22.\n+        long valBits = Double.doubleToLongBits(val);\n+        int exponent = (int) ((valBits >> 52) & 0x7ffL) - 1075;\n+        long significand = (valBits & ((1L << 52) - 1)) | (1L << 52);\n+        \/\/ At this point, val == significand * 2^exponent.\n+        MutableBigInteger result;\n+        if (exponent > 0) {\n+            result = new MutableBigInteger(significand);\n+            result.leftShift(exponent);\n+        } else {\n+            result = new MutableBigInteger(significand >> -exponent);\n+        }\n+        return result;\n+    }\n+\n@@ -1950,3 +1973,1 @@\n-            r = new MutableBigInteger(this);\n-            r.rightShift((int) shift);\n-            double base = r.toBigInteger().doubleValue();\n+            double base = this.toBigInteger().shiftRight((int) shift).doubleValue();\n@@ -1964,2 +1985,1 @@\n-            final double rDouble = Math.ceil(Math.nextUp(Math.pow(base, exp)));\n-            r.copyValue(new BigDecimal(rDouble).toBigInteger().mag);\n+            r = valueOf(Math.ceil(Math.nextUp(Math.pow(base, exp))));\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":25,"deletions":5,"binary":false,"changes":30,"status":"modified"}]}