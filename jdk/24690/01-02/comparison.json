{"files":[{"patch":"@@ -1945,3 +1945,3 @@\n-            \/\/ Determine an even valued right shift into unsigned long range.\n-            int shift = bitLength - Long.SIZE;\n-            shift += shift & 1;\n+            \/\/ Determine a right shift that is a multiple of n into finite double range.\n+            int shift = Math.max(0, bitLength - Double.MAX_EXPONENT);\n+            int shiftExcess = shift % n;\n@@ -1949,1 +1949,1 @@\n-            \/\/ Shift the value into unsigned long range.\n+            \/\/ Shift the value into finite double range\n@@ -1952,0 +1952,8 @@\n+            double base = r.toBigInteger().doubleValue();\n+            \/\/ Complete the shift to a multiple of n,\n+            \/\/ avoiding to lose more bits than necessary.\n+            if (shiftExcess != 0) { \n+                int shiftLack = n - shiftExcess;\n+                shift += shiftLack;\n+                base \/= Double.valueOf(\"0x1p\" + shiftLack);\n+            }\n@@ -1954,1 +1962,1 @@\n-            final double base = Math.nextUp(r.toLong() + 0x1p64);\n+            base = Math.nextUp(base);\n@@ -1956,1 +1964,2 @@\n-            r = new MutableBigInteger((long) Math.ceil(Math.nextUp(Math.pow(base, exp))));\n+            final double rDouble = Math.ceil(Math.nextUp(Math.pow(base, exp)));\n+            r = new MutableBigInteger(new BigDecimal(rDouble).toBigInteger().mag);\n@@ -1959,1 +1968,1 @@\n-            r.leftShift(shift >> 1);\n+            r.leftShift(shift \/ n);\n@@ -1970,1 +1979,1 @@\n-            \/\/ compute ceil((rToN - this) \/ (n * rToN1))\n+            \/\/ compute r - ceil((rToN - this) \/ (n * rToN1))\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"}]}