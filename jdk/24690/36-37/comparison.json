{"files":[{"patch":"@@ -2669,5 +2669,1 @@\n-            BigInteger answer;\n-            if (base.mag.length == 1) {\n-                answer = unsignedIntPow(base.mag[0], exponent);\n-            } else {\n-                answer = ONE;\n+            BigInteger answer = ONE;\n@@ -2675,7 +2671,7 @@\n-                final int expZeros = Integer.numberOfLeadingZeros(exponent);\n-                int workingExp = exponent << expZeros;\n-                \/\/ Perform exponentiation using repeated squaring trick\n-                for (int expLen = Integer.SIZE - expZeros; expLen > 0; expLen--) {\n-                    answer = answer.multiply(answer);\n-                    if (workingExp < 0) \/\/ leading bit is set\n-                        answer = answer.multiply(base);\n+            final int expZeros = Integer.numberOfLeadingZeros(exponent);\n+            int workingExp = exponent << expZeros;\n+            \/\/ Perform exponentiation using repeated squaring trick\n+            for (int expLen = Integer.SIZE - expZeros; expLen > 0; expLen--) {\n+                answer = answer.multiply(answer);\n+                if (workingExp < 0) \/\/ leading bit is set\n+                    answer = answer.multiply(base);\n@@ -2683,2 +2679,1 @@\n-                    workingExp <<= 1;\n-                }\n+                workingExp <<= 1;\n@@ -2701,81 +2696,0 @@\n-    \/**\n-     * Computes {@code x^n} using repeated squaring trick.\n-     * Assumes {@code x != 0}.\n-     *\/\n-    private static BigInteger unsignedIntPow(int x, int n) {\n-        if (x == 1)\n-            return ONE;\n-        \/\/ Double.PRECISION \/ bitLength(x) is the largest integer e\n-        \/\/ such that x^e fits into a double. If e <= 2, we won't use fp arithmetic.\n-        \/\/ This allows to use fp arithmetic in computePower(), where possible.\n-        final int maxExp = Math.max(2, Double.PRECISION \/ bitLengthForInt(x));\n-        final int maxExpLen = bitLengthForInt(maxExp);\n-        final BigInteger[] powerCache = new BigInteger[1 << maxExpLen];\n-\n-        final int nZeros = Integer.numberOfLeadingZeros(n);\n-        n <<= nZeros;\n-\n-        BigInteger pow = ONE;\n-        int blockLen;\n-        for (int nLen = Integer.SIZE - nZeros; nLen > 0; nLen -= blockLen) {\n-            blockLen = Math.min(maxExpLen, nLen);\n-            \/\/ compute pow^(2^blockLen)\n-            if (!pow.equals(ONE)) {\n-                for (int i = 0; i < blockLen; i++)\n-                    pow = pow.multiply(pow);\n-            }\n-\n-            \/\/ add exp to power's exponent\n-            int exp = n >>> -blockLen;\n-            if (exp > 0)\n-                pow = pow.multiply(computePower(powerCache, x & LONG_MASK, exp, maxExp));\n-\n-            n <<= blockLen; \/\/ shift to next block of bits\n-        }\n-\n-        return pow;\n-    }\n-\n-    \/**\n-     * Returns {@code x^exp}. This method is used by {@code unsignedIntPow(int, int)}.\n-     * Assumes {@code maxExp == max(2, Double.PRECISION \/ bitLength(x))}.\n-     *\/\n-    private static BigInteger computePower(BigInteger[] powerCache, long x, int exp, int maxExp) {\n-        BigInteger xToExp = powerCache[exp];\n-        if (xToExp == null) {\n-            if (exp <= maxExp) {\n-                \/\/ don't use fp arithmetic if exp <= 2\n-                long pow = exp == 1 ? x :\n-                          (exp == 2 ? x*x : (long) Math.pow(x, exp));\n-\n-                xToExp = new BigInteger(1, new int[] { (int) (pow >>> 32), (int) pow });\n-                powerCache[exp] = xToExp;\n-            } else {\n-                \/\/ adjust exp to fit x^expAdj into a double\n-                final int expAdj = exp >>> 1;\n-\n-                xToExp = powerCache[expAdj << 1];\n-                if (xToExp == null) { \/\/ compute x^(expAdj << 1)\n-                    xToExp = powerCache[expAdj];\n-                    if (xToExp == null) { \/\/ compute x^expAdj\n-                        \/\/ don't use fp arithmetic if expAdj <= 2\n-                        long xToExpAdj = expAdj == 1 ? x :\n-                                        (expAdj == 2 ? x*x : (long) Math.pow(x, expAdj));\n-\n-                        xToExp = new BigInteger(xToExpAdj, 1);\n-                        powerCache[expAdj] = xToExp;\n-                    }\n-                    xToExp = xToExp.multiply(xToExp);\n-                    powerCache[expAdj << 1] = xToExp;\n-                }\n-\n-                \/\/ append exp's rightmost bit to expAdj\n-                if ((exp & 1) == 1) {\n-                    xToExp = xToExp.multiply(x);\n-                    powerCache[exp] = xToExp;\n-                }\n-            }\n-        }\n-        return xToExp;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":9,"deletions":95,"binary":false,"changes":104,"status":"modified"}]}