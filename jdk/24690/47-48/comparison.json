{"files":[{"patch":"@@ -2706,12 +2706,0 @@\n-        \/\/ Double.PRECISION \/ bitLength(x) is the largest integer e\n-        \/\/ such that x^e fits into a double. If e <= 3, we won't use fp arithmetic.\n-        \/\/ This allows to use fp arithmetic in computePower(), where possible.\n-        final int maxExp = Math.max(3, Double.PRECISION \/ bitLengthForLong(x));\n-        final int maxExpLen = bitLengthForInt(maxExp);\n-        final long[] powerCache = new long[1 << maxExpLen];\n-        powerCache[1] = x;\n-        powerCache[2] = x * x;\n-        powerCache[3] = x * x * x;\n-\n-        final int nZeros = Integer.numberOfLeadingZeros(n);\n-        n <<= nZeros;\n@@ -2719,0 +2707,4 @@\n+        \/*\n+         * The method assumption means that n <= 40 here.\n+         * Thus, the loop body executes at most 5 times.\n+         *\/\n@@ -2720,13 +2712,3 @@\n-        int blockLen;\n-        for (int nLen = Integer.SIZE - nZeros; nLen > 0; nLen -= blockLen) {\n-            blockLen = Math.min(maxExpLen, nLen);\n-            \/\/ compute pow^(2^blockLen)\n-            if (pow != 1L) {\n-                for (int i = 0; i < blockLen; i++)\n-                    pow *= pow;\n-            }\n-\n-            \/\/ add exp to power's exponent\n-            int exp = n >>> -blockLen;\n-            if (exp > 0)\n-                pow *= computePower(powerCache, x, exp, maxExp);\n+        for (; n != 0; n >>>= 1) {\n+            if ((n & 1) != 0)\n+                pow *= x;\n@@ -2734,1 +2716,1 @@\n-            n <<= blockLen; \/\/ shift to next block of bits\n+            x *= x;\n@@ -2736,1 +2718,0 @@\n-\n@@ -2740,35 +2721,0 @@\n-    \/**\n-     * Returns {@code x^exp}. This method is used by {@code unsignedLongPow(long, int)}.\n-     * Assumes {@code maxExp == max(3, Double.PRECISION \/ bitLength(x))}.\n-     *\/\n-    private static long computePower(long[] powerCache, long x, int exp, int maxExp) {\n-        long xToExp = powerCache[exp];\n-        if (xToExp == 0) {\n-            if (exp <= maxExp) {\n-                xToExp = (long) Math.pow(x, exp); \/\/ don't use fp arithmetic if exp <= 3\n-                powerCache[exp] = xToExp;\n-            } else {\n-                \/\/ adjust exp to fit x^expAdj into a double\n-                final int expAdj = exp >>> 1;\n-\n-                xToExp = powerCache[expAdj << 1];\n-                if (xToExp == 0) { \/\/ compute x^(expAdj << 1)\n-                    xToExp = powerCache[expAdj];\n-                    if (xToExp == 0) {  \/\/ compute x^expAdj\n-                        xToExp = (long) Math.pow(x, expAdj); \/\/ don't use fp arithmetic if expAdj <= 3\n-                        powerCache[expAdj] = xToExp;\n-                    }\n-                    xToExp *= xToExp;\n-                    powerCache[expAdj << 1] = xToExp;\n-                }\n-\n-                \/\/ append exp's rightmost bit to expAdj\n-                if ((exp & 1) == 1) {\n-                    xToExp *= x;\n-                    powerCache[exp] = xToExp;\n-                }\n-            }\n-        }\n-        return xToExp;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":8,"deletions":62,"binary":false,"changes":70,"status":"modified"}]}