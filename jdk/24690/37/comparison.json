{"files":[{"patch":"@@ -1249,0 +1249,10 @@\n+    \/**\n+     * Constructs a BigInteger with magnitude specified by the long,\n+     * which may not be zero, and the signum specified by the int.\n+     *\/\n+    private BigInteger(long mag, int signum) {\n+        assert mag != 0 && signum != 0;\n+        this.signum = signum;\n+        this.mag = toMagArray(mag);\n+    }\n+\n@@ -1259,0 +1269,2 @@\n+        mag = toMagArray(val);\n+    }\n@@ -1260,9 +1272,5 @@\n-        int highWord = (int)(val >>> 32);\n-        if (highWord == 0) {\n-            mag = new int[1];\n-            mag[0] = (int)val;\n-        } else {\n-            mag = new int[2];\n-            mag[0] = highWord;\n-            mag[1] = (int)val;\n-        }\n+    private static int[] toMagArray(long mag) {\n+        int highWord = (int) (mag >>> 32);\n+        return highWord == 0\n+                ? new int[] { (int) mag }\n+                : new int[] { highWord, (int) mag };\n@@ -2592,3 +2600,5 @@\n-        if (signum == 0) {\n-            return (exponent == 0 ? ONE : this);\n-        }\n+        if (exponent == 0 || this.equals(ONE))\n+            return ONE;\n+\n+        if (signum == 0)\n+            return ZERO;\n@@ -2596,1 +2606,1 @@\n-        BigInteger partToSquare = this.abs();\n+        BigInteger base = this.abs();\n@@ -2602,1 +2612,1 @@\n-        int powersOfTwo = partToSquare.getLowestSetBit();\n+        int powersOfTwo = base.getLowestSetBit();\n@@ -2613,2 +2623,2 @@\n-            partToSquare = partToSquare.shiftRight(powersOfTwo);\n-            remainingBits = partToSquare.bitLength();\n+            base = base.shiftRight(powersOfTwo);\n+            remainingBits = base.bitLength();\n@@ -2623,1 +2633,1 @@\n-            remainingBits = partToSquare.bitLength();\n+            remainingBits = base.bitLength();\n@@ -2639,3 +2649,3 @@\n-        \/\/ See if the result will safely fit into a long. (Largest 2^63-1)\n-        if (partToSquare.mag.length == 1 && scaleFactor <= 62) {\n-            \/\/ Small number algorithm.  Everything fits into a long.\n+        \/\/ See if the result will safely fit into an unsigned long. (Largest 2^64-1)\n+        if (base.mag.length == 1 && scaleFactor <= Long.SIZE) {\n+            \/\/ Small number algorithm.  Everything fits into an unsigned long.\n@@ -2643,15 +2653,1 @@\n-            long result = 1;\n-            long baseToPow2 = partToSquare.mag[0] & LONG_MASK;\n-\n-            int workingExponent = exponent;\n-\n-            \/\/ Perform exponentiation using repeated squaring trick\n-            while (workingExponent != 0) {\n-                if ((workingExponent & 1) == 1) {\n-                    result = result * baseToPow2;\n-                }\n-\n-                if ((workingExponent >>>= 1) != 0) {\n-                    baseToPow2 = baseToPow2 * baseToPow2;\n-                }\n-            }\n+            long result = unsignedLongPow(base.mag[0] & LONG_MASK, exponent);\n@@ -2660,9 +2656,5 @@\n-            if (powersOfTwo > 0) {\n-                if (bitsToShift + scaleFactor <= 62) { \/\/ Fits in long?\n-                    return valueOf((result << bitsToShift) * newSign);\n-                } else {\n-                    return valueOf(result*newSign).shiftLeft(bitsToShift);\n-                }\n-            } else {\n-                return valueOf(result*newSign);\n-            }\n+            return powersOfTwo == 0\n+                    ? new BigInteger(result, newSign)\n+                    : (bitsToShift + scaleFactor <= Long.SIZE  \/\/ Fits in long?\n+                            ? new BigInteger(result << bitsToShift, newSign)\n+                            : new BigInteger(result, newSign).shiftLeft(bitsToShift));\n@@ -2675,1 +2667,1 @@\n-            \/\/ the algorithm above, but calls multiply() and square()\n+            \/\/ the algorithm above, but calls multiply()\n@@ -2679,1 +2671,2 @@\n-            int workingExponent = exponent;\n+            final int expZeros = Integer.numberOfLeadingZeros(exponent);\n+            int workingExp = exponent << expZeros;\n@@ -2681,4 +2674,4 @@\n-            while (workingExponent != 0) {\n-                if ((workingExponent & 1) == 1) {\n-                    answer = answer.multiply(partToSquare);\n-                }\n+            for (int expLen = Integer.SIZE - expZeros; expLen > 0; expLen--) {\n+                answer = answer.multiply(answer);\n+                if (workingExp < 0) \/\/ leading bit is set\n+                    answer = answer.multiply(base);\n@@ -2686,3 +2679,1 @@\n-                if ((workingExponent >>>= 1) != 0) {\n-                    partToSquare = partToSquare.square();\n-                }\n+                workingExp <<= 1;\n@@ -2690,0 +2681,1 @@\n+\n@@ -2704,0 +2696,82 @@\n+    \/**\n+     * Computes {@code x^n} using repeated squaring trick.\n+     * Assumes {@code x != 0 && x^n < 2^Long.SIZE}.\n+     *\/\n+    static long unsignedLongPow(long x, int n) {\n+        if (x == 1L)\n+            return 1L;\n+\n+        if (x == 2L)\n+            return 1L << n;\n+        \/\/ Double.PRECISION \/ bitLength(x) is the largest integer e\n+        \/\/ such that x^e fits into a double. If e <= 3, we won't use fp arithmetic.\n+        \/\/ This allows to use fp arithmetic in computePower(), where possible.\n+        final int maxExp = Math.max(3, Double.PRECISION \/ bitLengthForLong(x));\n+        final int maxExpLen = bitLengthForInt(maxExp);\n+        final long[] powerCache = new long[1 << maxExpLen];\n+\n+        final int nZeros = Integer.numberOfLeadingZeros(n);\n+        n <<= nZeros;\n+\n+        long pow = 1L;\n+        int blockLen;\n+        for (int nLen = Integer.SIZE - nZeros; nLen > 0; nLen -= blockLen) {\n+            blockLen = Math.min(maxExpLen, nLen);\n+            \/\/ compute pow^(2^blockLen)\n+            if (pow != 1L) {\n+                for (int i = 0; i < blockLen; i++)\n+                    pow *= pow;\n+            }\n+\n+            \/\/ add exp to power's exponent\n+            int exp = n >>> -blockLen;\n+            if (exp > 0)\n+                pow *= computePower(powerCache, x, exp, maxExp);\n+\n+            n <<= blockLen; \/\/ shift to next block of bits\n+        }\n+\n+        return pow;\n+    }\n+\n+    \/**\n+     * Returns {@code x^exp}. This method is used by {@code unsignedLongPow(long, int)}.\n+     * Assumes {@code maxExp == max(3, Double.PRECISION \/ bitLength(x))}.\n+     *\/\n+    private static long computePower(long[] powerCache, long x, int exp, int maxExp) {\n+        long xToExp = powerCache[exp];\n+        if (xToExp == 0) {\n+            if (exp <= maxExp) {\n+                \/\/ don't use fp arithmetic if exp <= 3\n+                xToExp = exp == 1 ? x :\n+                        (exp == 2 ? x*x :\n+                        (exp == 3 ? x*x*x : (long) Math.pow(x, exp)));\n+                powerCache[exp] = xToExp;\n+            } else {\n+                \/\/ adjust exp to fit x^expAdj into a double\n+                final int expAdj = exp >>> 1;\n+\n+                xToExp = powerCache[expAdj << 1];\n+                if (xToExp == 0) { \/\/ compute x^(expAdj << 1)\n+                    xToExp = powerCache[expAdj];\n+                    if (xToExp == 0) {  \/\/ compute x^expAdj\n+                        \/\/ don't use fp arithmetic if expAdj <= 3\n+                        xToExp = expAdj == 1 ? x :\n+                                (expAdj == 2 ? x*x :\n+                                (expAdj == 3 ? x*x*x : (long) Math.pow(x, expAdj)));\n+                        powerCache[expAdj] = xToExp;\n+                    }\n+                    xToExp *= xToExp;\n+                    powerCache[expAdj << 1] = xToExp;\n+                }\n+\n+                \/\/ append exp's rightmost bit to expAdj\n+                if ((exp & 1) == 1) {\n+                    xToExp *= x;\n+                    powerCache[exp] = xToExp;\n+                }\n+            }\n+        }\n+        return xToExp;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":127,"deletions":53,"binary":false,"changes":180,"status":"modified"}]}