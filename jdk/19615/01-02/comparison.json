{"files":[{"patch":"@@ -51,1 +51,0 @@\n-import static java.lang.classfile.TypeKind.ReferenceType;\n@@ -55,3 +54,0 @@\n-import java.lang.constant.DirectMethodHandleDesc;\n-import java.lang.constant.DynamicConstantDesc;\n-\n@@ -73,0 +69,2 @@\n+            CD_ClassNotFoundException = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/ClassNotFoundException;\"),\n+            CD_NoClassDefFoundError = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/NoClassDefFoundError;\"),\n@@ -88,0 +86,1 @@\n+            MTD_Class_String_boolean_ClassLoader = MethodTypeDescImpl.ofValidated(CD_Class, CD_String, CD_boolean, CD_ClassLoader),\n@@ -89,2 +88,0 @@\n-            MTD_Class_array = MethodTypeDescImpl.ofValidated(CD_Class_array),\n-            MTD_MethodType_String_ClassLoader = MethodTypeDescImpl.ofValidated(CD_MethodType, CD_String, CD_ClassLoader),\n@@ -98,2 +95,1 @@\n-            NAME_LOOKUP_ACCESSOR = \"proxyClassLookup\",\n-            NAME_CLASS_LOADER = \"LOADER\";\n+            NAME_LOOKUP_ACCESSOR = \"proxyClassLookup\";\n@@ -119,3 +115,3 @@\n-    private static final ProxyMethod HASH_CODE_METHOD;\n-    private static final ProxyMethod EQUALS_METHOD;\n-    private static final ProxyMethod TO_STRING_METHOD;\n+    private static final Method OBJECT_HASH_CODE_METHOD;\n+    private static final Method OBJECT_EQUALS_METHOD;\n+    private static final Method OBJECT_TO_STRING_METHOD;\n@@ -125,3 +121,3 @@\n-            HASH_CODE_METHOD = new ProxyMethod(Object.class.getMethod(\"hashCode\"));\n-            EQUALS_METHOD = new ProxyMethod(Object.class.getMethod(\"equals\", Object.class));\n-            TO_STRING_METHOD = new ProxyMethod(Object.class.getMethod(\"toString\"));\n+            OBJECT_HASH_CODE_METHOD = Object.class.getMethod(\"hashCode\");\n+            OBJECT_EQUALS_METHOD = Object.class.getMethod(\"equals\", Object.class);\n+            OBJECT_TO_STRING_METHOD = Object.class.getMethod(\"toString\");\n@@ -134,1 +130,1 @@\n-    private final List<StackMapFrameInfo.VerificationTypeInfo> throwableStack;\n+    private final List<StackMapFrameInfo.VerificationTypeInfo> classLoaderLocal, throwableStack;\n@@ -136,5 +132,4 @@\n-    private final ClassEntry object, proxy, ute;\n-    private final FieldRefEntry handlerField, classLoaderField;\n-    private final InterfaceMethodRefEntry invoke;\n-    private final MethodRefEntry uteInit;\n-    private final DirectMethodHandleDesc bsm;\n+    private final ClassEntry objectCe, proxyCe, uteCe, classCe;\n+    private final FieldRefEntry handlerField;\n+    private final InterfaceMethodRefEntry invocationHandlerInvoke;\n+    private final MethodRefEntry uteInit, classGetMethod, classForName, throwableGetMessage;\n@@ -146,1 +141,1 @@\n-    private final ClassEntry classEntry;\n+    private final ClassEntry thisClass;\n@@ -165,0 +160,6 @@\n+    \/**\n+     * Ordinal of next ProxyMethod object added to proxyMethods.\n+     * Indexes are reserved for hashcode(0), equals(1), toString(2).\n+     *\/\n+    private int proxyMethodCount = 3;\n+\n@@ -175,1 +176,1 @@\n-        this.classEntry = cp.classEntry(ConstantUtils.binaryNameToDesc(className));\n+        this.thisClass = cp.classEntry(ConstantUtils.binaryNameToDesc(className));\n@@ -178,1 +179,3 @@\n-        this.throwableStack = List.of(StackMapFrameInfo.ObjectVerificationTypeInfo.of(cp.classEntry(CD_Throwable)));\n+        var throwable = cp.classEntry(CD_Throwable);\n+        this.classLoaderLocal = List.of(StackMapFrameInfo.ObjectVerificationTypeInfo.of(cp.classEntry(CD_ClassLoader)));\n+        this.throwableStack = List.of(StackMapFrameInfo.ObjectVerificationTypeInfo.of(throwable));\n@@ -180,8 +183,10 @@\n-        this.object = cp.classEntry(CD_Object);\n-        this.proxy = cp.classEntry(CD_Proxy);\n-        this.handlerField = cp.fieldRefEntry(proxy, cp.nameAndTypeEntry(NAME_HANDLER_FIELD, CD_InvocationHandler));\n-        this.classLoaderField = cp.fieldRefEntry(classEntry.asSymbol(), NAME_CLASS_LOADER, CD_ClassLoader);\n-        this.invoke = cp.interfaceMethodRefEntry(CD_InvocationHandler, \"invoke\", MTD_Object_Object_Method_ObjectArray);\n-        this.ute = cp.classEntry(CD_UndeclaredThrowableException);\n-        this.uteInit = cp.methodRefEntry(ute, cp.nameAndTypeEntry(INIT_NAME, MTD_void_Throwable));\n-        this.bsm = ofConstantBootstrap(classEntry.asSymbol(), \"$getMethod\", CD_Method, CD_Class, CD_String);\n+        this.objectCe = cp.classEntry(CD_Object);\n+        this.proxyCe = cp.classEntry(CD_Proxy);\n+        this.classCe = cp.classEntry(CD_Class);\n+        this.handlerField = cp.fieldRefEntry(proxyCe, cp.nameAndTypeEntry(NAME_HANDLER_FIELD, CD_InvocationHandler));\n+        this.invocationHandlerInvoke = cp.interfaceMethodRefEntry(CD_InvocationHandler, \"invoke\", MTD_Object_Object_Method_ObjectArray);\n+        this.uteCe = cp.classEntry(CD_UndeclaredThrowableException);\n+        this.uteInit = cp.methodRefEntry(uteCe, cp.nameAndTypeEntry(INIT_NAME, MTD_void_Throwable));\n+        this.classGetMethod = cp.methodRefEntry(classCe, cp.nameAndTypeEntry(\"getMethod\", MTD_Method_String_Class_array));\n+        this.classForName = cp.methodRefEntry(classCe, cp.nameAndTypeEntry(\"forName\", MTD_Class_String_boolean_ClassLoader));\n+        this.throwableGetMessage = cp.methodRefEntry(throwable, cp.nameAndTypeEntry(\"getMessage\", MTD_String));\n@@ -446,3 +451,3 @@\n-        addProxyMethod(HASH_CODE_METHOD);\n-        addProxyMethod(EQUALS_METHOD);\n-        addProxyMethod(TO_STRING_METHOD);\n+        addProxyMethod(new ProxyMethod(OBJECT_HASH_CODE_METHOD, \"m0\"));\n+        addProxyMethod(new ProxyMethod(OBJECT_EQUALS_METHOD, \"m1\"));\n+        addProxyMethod(new ProxyMethod(OBJECT_TO_STRING_METHOD, \"m2\"));\n@@ -469,2 +474,2 @@\n-        return CF_CONTEXT.build(classEntry, cp, clb -> {\n-            clb.withSuperclass(proxy);\n+        return CF_CONTEXT.build(thisClass, cp, clb -> {\n+            clb.withSuperclass(proxyCe);\n@@ -477,0 +482,3 @@\n+                    \/\/ add static field for the Method object\n+                    clb.withField(pm.fieldName, CD_Method, ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n+\n@@ -478,1 +486,1 @@\n-                    pm.generateMethod(this, clb);\n+                    pm.generateMethod(clb);\n@@ -482,2 +490,1 @@\n-            generateClassInitializer(clb);\n-            generateBootstrapMethod(clb);\n+            generateStaticInitializer(clb);\n@@ -526,1 +533,1 @@\n-                exceptionTypes, fromClass));\n+                exceptionTypes, fromClass, \"m\" + proxyMethodCount++));\n@@ -548,1 +555,1 @@\n-               .invokespecial(cp.methodRefEntry(proxy, cp.nameAndTypeEntry(INIT_NAME, MTD_void_InvocationHandler)))\n+               .invokespecial(CD_Proxy, INIT_NAME, MTD_void_InvocationHandler)\n@@ -556,2 +563,1 @@\n-    private void generateClassInitializer(ClassBuilder clb) {\n-        clb.withField(classLoaderField.name(), classLoaderField.type(), ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n+    private void generateStaticInitializer(ClassBuilder clb) {\n@@ -559,2 +565,5 @@\n-            cob.ldc(classEntry)\n-               .invokevirtual(CD_Class, \"getClassLoader\", MTD_ClassLoader)\n+            \/\/ Put ClassLoader at local variable index 0, used by\n+            \/\/ Class.forName(String, boolean, ClassLoader) calls\n+            cob.ldc(thisClass)\n+               .invokevirtual(cp.methodRefEntry(classCe,\n+                       cp.nameAndTypeEntry(\"getClassLoader\", MTD_ClassLoader)))\n@@ -562,35 +571,20 @@\n-            var endIf = cob.newLabel();\n-            cob.aload(0)\n-               .if_nonnull(endIf)\n-               .invokestatic(CD_ClassLoader, \"getPlatformClassLoader\", MTD_ClassLoader)\n-               .astore(0)\n-               .labelBinding(endIf)\n-               .aload(0)\n-               .putstatic(classLoaderField)\n-               .return_()\n-               .with(StackMapTableAttribute.of(List.of(\n-                    StackMapFrameInfo.of(endIf,\n-                            List.of(StackMapFrameInfo.ObjectVerificationTypeInfo.of(CD_ClassLoader)),\n-                            List.of()))));\n-        });\n-\n-    }\n-\n-    \/**\n-     * Generate CONDY bootstrap method for the proxy class to retrieve {@link Method} instances.\n-     *\/\n-    private void generateBootstrapMethod(ClassBuilder clb) {\n-        clb.withMethodBody(bsm.methodName(), bsm.invocationType(), ClassFile.ACC_PRIVATE | ClassFile.ACC_STATIC, cob -> {\n-            cob.aload(3) \/\/interface Class\n-               .aload(1) \/\/interface method name String\n-               .aload(4) \/\/interface method type String\n-               .getstatic(classLoaderField)\n-               .invokestatic(CD_MethodType, \"fromMethodDescriptorString\",\n-                       MTD_MethodType_String_ClassLoader) \/\/interface method type\n-               .invokevirtual(CD_MethodType, \"parameterArray\", MTD_Class_array)\n-               .invokevirtual(CD_Class, \"getMethod\", MTD_Method_String_Class_array)\n-               .areturn();\n-            Label failLabel = cob.newBoundLabel();\n-            ClassEntry nsme = cp.classEntry(CD_NoSuchMethodError);\n-            cob.exceptionCatch(cob.startLabel(), failLabel, failLabel, CD_NoSuchMethodException)\n-               .new_(nsme)\n+            var ts = cob.newBoundLabel();\n+            for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\n+                for (ProxyMethod pm : sigmethods) {\n+                    pm.codeFieldInitialization(cob);\n+                }\n+            }\n+            cob.return_();\n+            var c1 = cob.newBoundLabel();\n+            var nsmError = cp.classEntry(CD_NoSuchMethodError);\n+            cob.exceptionCatch(ts, c1, c1, CD_NoSuchMethodException)\n+               .new_(nsmError)\n+               .dup_x1()\n+               .swap()\n+               .invokevirtual(throwableGetMessage)\n+               .invokespecial(cp.methodRefEntry(nsmError, exInit))\n+               .athrow();\n+            var c2 = cob.newBoundLabel();\n+            var ncdfError = cp.classEntry(CD_NoClassDefFoundError);\n+            cob.exceptionCatch(ts, c1, c2, CD_ClassNotFoundException)\n+               .new_(ncdfError)\n@@ -599,5 +593,7 @@\n-               .invokevirtual(cp.methodRefEntry(CD_Throwable, \"getMessage\", MTD_String))\n-               .invokespecial(cp.methodRefEntry(nsme, exInit))\n-               .athrow()\n-               .with(StackMapTableAttribute.of(List.of(\n-                       StackMapFrameInfo.of(failLabel, List.of(), throwableStack))));\n+               .invokevirtual(throwableGetMessage)\n+               .invokespecial(cp.methodRefEntry(ncdfError, exInit))\n+               .athrow();\n+            cob.with(StackMapTableAttribute.of(List.of(\n+                       StackMapFrameInfo.of(c1, classLoaderLocal, throwableStack),\n+                       StackMapFrameInfo.of(c2, classLoaderLocal, throwableStack))));\n+\n@@ -623,1 +619,1 @@\n-                               .ldc(proxy)\n+                               .ldc(proxyCe)\n@@ -649,1 +645,1 @@\n-    private static class ProxyMethod {\n+    private class ProxyMethod {\n@@ -652,0 +648,1 @@\n+        private final String fieldName;\n@@ -657,0 +654,1 @@\n+        private FieldRefEntry methodFieldCache;\n@@ -660,1 +658,1 @@\n-                            Class<?> fromClass) {\n+                            Class<?> fromClass, String fieldName) {\n@@ -667,0 +665,1 @@\n+            this.fieldName = fieldName;\n@@ -674,1 +673,1 @@\n-        private ProxyMethod(Method method) {\n+        private ProxyMethod(Method method, String fieldName) {\n@@ -677,1 +676,10 @@\n-                 method.getSharedExceptionTypes(), method.getDeclaringClass());\n+                 method.getSharedExceptionTypes(), method.getDeclaringClass(),\n+                 fieldName);\n+        }\n+\n+        private FieldRefEntry methodField() {\n+            var cache = methodFieldCache;\n+            if (cache != null)\n+                return cache;\n+            return methodFieldCache = cp.fieldRefEntry(thisClass,\n+                    cp.nameAndTypeEntry(fieldName, CD_Method));\n@@ -683,2 +691,1 @@\n-        private void generateMethod(ProxyGenerator pg, ClassBuilder clb) {\n-            var cp = pg.cp;\n+        private void generateMethod(ClassBuilder clb) {\n@@ -692,10 +699,4 @@\n-                        cob.aload(0)\n-                           .getfield(pg.handlerField)\n-                           .aload(0)\n-                           .ldc(DynamicConstantDesc.ofNamed(pg.bsm,\n-                                method.getName(),\n-                                CD_Method,\n-                                referenceClassDesc(fromClass),\n-                                \/\/ some types in the method may be package private\n-                                \/\/ so Class or MethodType constants will fail\n-                                desc.descriptorString()));\n+                        cob.aload(cob.receiverSlot())\n+                           .getfield(handlerField)\n+                           .aload(cob.receiverSlot())\n+                           .getstatic(methodField());\n@@ -705,1 +706,1 @@\n-                               .anewarray(pg.object);\n+                               .anewarray(objectCe);\n@@ -716,1 +717,1 @@\n-                        cob.invokeinterface(pg.invoke);\n+                        cob.invokeinterface(invocationHandlerInvoke);\n@@ -732,1 +733,1 @@\n-                               .new_(pg.ute)\n+                               .new_(uteCe)\n@@ -735,1 +736,1 @@\n-                               .invokespecial(pg.uteInit)\n+                               .invokespecial(uteInit)\n@@ -738,2 +739,2 @@\n-                                       StackMapFrameInfo.of(c1, List.of(), pg.throwableStack),\n-                                       StackMapFrameInfo.of(c2, List.of(), pg.throwableStack))));\n+                                     StackMapFrameInfo.of(c1, List.of(), throwableStack),\n+                                     StackMapFrameInfo.of(c2, List.of(), throwableStack))));\n@@ -754,1 +755,1 @@\n-                cob.invokestatic(prim.wrapperMethodRef(cob.constantPool()));\n+                cob.invokestatic(prim.wrapperMethodRef(cp));\n@@ -770,1 +771,1 @@\n-                   .invokevirtual(prim.unwrapMethodRef(cob.constantPool()))\n+                   .invokevirtual(prim.unwrapMethodRef(cp))\n@@ -778,0 +779,51 @@\n+        \/**\n+         * Generate code for initializing the static field that stores\n+         * the Method object for this proxy method. A class loader is\n+         * anticipated at local variable index 0.\n+         * The generated code must be run in an AccessController.doPrivileged\n+         * block if a SecurityManager is present, as otherwise the code\n+         * cannot pass {@code null} ClassLoader to forName.\n+         *\/\n+        private void codeFieldInitialization(CodeBuilder cob) {\n+            var cp = cob.constantPool();\n+            codeClassForName(cob, fromClass);\n+\n+            cob.ldc(method.getName())\n+               .loadConstant(parameterTypes.length)\n+               .anewarray(classCe);\n+\n+            \/\/ Construct an array with the parameter types mapping primitives to Wrapper types\n+            for (int i = 0; i < parameterTypes.length; i++) {\n+                cob.dup()\n+                   .loadConstant(i);\n+                if (parameterTypes[i].isPrimitive()) {\n+                    PrimitiveTypeInfo prim = PrimitiveTypeInfo.get(parameterTypes[i]);\n+                    cob.getstatic(prim.typeFieldRef(cp));\n+                } else {\n+                    codeClassForName(cob, parameterTypes[i]);\n+                }\n+                cob.aastore();\n+            }\n+            \/\/ lookup the method\n+            cob.invokevirtual(classGetMethod)\n+               .putstatic(methodField());\n+        }\n+\n+        \/*\n+         * =============== Code Generation Utility Methods ===============\n+         *\/\n+\n+        \/**\n+         * Generate code to invoke the Class.forName with the name of the given\n+         * class to get its Class object at runtime.  The code is written to\n+         * the supplied stream.  Note that the code generated by this method\n+         * may cause the checked ClassNotFoundException to be thrown. A class\n+         * loader is anticipated at local variable index 0.\n+         *\/\n+        private void codeClassForName(CodeBuilder cob, Class<?> cl) {\n+            cob.ldc(cl.getName())\n+               .iconst_0() \/\/ false\n+               .aload(0)\/\/ classLoader\n+               .invokestatic(classForName);\n+        }\n+\n@@ -844,0 +896,4 @@\n+\n+        public FieldRefEntry typeFieldRef(ConstantPoolBuilder cp) {\n+            return cp.fieldRefEntry(wrapperClass, \"TYPE\", CD_Class);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":166,"deletions":110,"binary":false,"changes":276,"status":"modified"}]}