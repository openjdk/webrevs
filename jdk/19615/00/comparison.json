{"files":[{"patch":"@@ -50,1 +50,0 @@\n-import java.lang.constant.ConstantDescs;\n@@ -70,0 +69,1 @@\n+            CD_ClassLoader = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/ClassLoader;\"),\n@@ -86,0 +86,1 @@\n+            MTD_ClassLoader = MethodTypeDescImpl.ofValidated(CD_ClassLoader),\n@@ -87,1 +88,2 @@\n-            MTD_Method_String_Class_array = MethodTypeDescImpl.ofValidated(CD_Method, ConstantDescs.CD_String, CD_Class_array),\n+            MTD_MethodType_String_ClassLoader = MethodTypeDescImpl.ofValidated(CD_MethodType, CD_String, CD_ClassLoader),\n+            MTD_Method_String_Class_array = MethodTypeDescImpl.ofValidated(CD_Method, CD_String, CD_Class_array),\n@@ -179,1 +181,1 @@\n-        this.bsm = ConstantDescs.ofConstantBootstrap(classEntry.asSymbol(), \"$getMethod\", CD_Method, CD_Class, CD_String, CD_MethodType);\n+        this.bsm = ofConstantBootstrap(classEntry.asSymbol(), \"$getMethod\", CD_Method, CD_Class, CD_String);\n@@ -549,2 +551,6 @@\n-               .aload(4) \/\/interface method name String\n-               .aload(5) \/\/interface MethodType\n+               .aload(1) \/\/interface method name String\n+               .aload(4) \/\/interface method type String\n+               .ldc(classEntry)\n+               .invokevirtual(CD_Class, \"getClassLoader\", MTD_ClassLoader)\n+               .invokestatic(CD_MethodType, \"fromMethodDescriptorString\",\n+                       MTD_MethodType_String_ClassLoader) \/\/interface method type\n@@ -552,1 +558,1 @@\n-               .invokevirtual(ConstantDescs.CD_Class, \"getMethod\", MTD_Method_String_Class_array)\n+               .invokevirtual(CD_Class, \"getMethod\", MTD_Method_String_Class_array)\n@@ -656,2 +662,1 @@\n-                           .ldc(DynamicConstantDesc.of(pg.bsm,\n-                                referenceClassDesc(fromClass),\n+                           .ldc(DynamicConstantDesc.ofNamed(pg.bsm,\n@@ -659,1 +664,5 @@\n-                                desc));\n+                                CD_Method,\n+                                referenceClassDesc(fromClass),\n+                                \/\/ some types in the method may be package private\n+                                \/\/ so Class or MethodType constants will fail\n+                                desc.descriptorString()));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":18,"deletions":9,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333854\n+ * @summary Test invoking a method in a proxy interface with package-private\n+ *          classes or interfaces in its method type\n+ * @run junit NonPublicMethodTypeTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.reflect.Proxy;\n+\n+import static org.junit.jupiter.api.Assertions.assertNotSame;\n+\n+public final class NonPublicMethodTypeTest {\n+    interface NonPublicWorker {\n+        void work();\n+    }\n+\n+    public interface PublicWorkable {\n+        void accept(NonPublicWorker worker);\n+    }\n+\n+    @Test\n+    public void test() {\n+        PublicWorkable proxy = (PublicWorkable) Proxy.newProxyInstance(\n+               NonPublicMethodTypeTest.class.getClassLoader(),\n+               new Class[] {PublicWorkable.class},\n+               (_, _, _) -> null);\n+        assertNotSame(NonPublicWorker.class.getPackage(),\n+                proxy.getClass().getPackage(),\n+                \"Proxy class should not be able to access method parameter \" +\n+                        \"NonPublic type's package\");\n+        proxy.accept(() -> {}); \/\/ Call should not fail\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/NonPublicMethodTypeTest.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"}]}