{"files":[{"patch":"@@ -50,1 +50,2 @@\n-import java.lang.constant.ConstantDescs;\n+\n+import static java.lang.classfile.TypeKind.ReferenceType;\n@@ -70,0 +71,1 @@\n+            CD_ClassLoader = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/ClassLoader;\"),\n@@ -86,0 +88,1 @@\n+            MTD_ClassLoader = MethodTypeDescImpl.ofValidated(CD_ClassLoader),\n@@ -87,1 +90,2 @@\n-            MTD_Method_String_Class_array = MethodTypeDescImpl.ofValidated(CD_Method, ConstantDescs.CD_String, CD_Class_array),\n+            MTD_MethodType_String_ClassLoader = MethodTypeDescImpl.ofValidated(CD_MethodType, CD_String, CD_ClassLoader),\n+            MTD_Method_String_Class_array = MethodTypeDescImpl.ofValidated(CD_Method, CD_String, CD_Class_array),\n@@ -93,1 +97,4 @@\n-    private static final String NAME_LOOKUP_ACCESSOR = \"proxyClassLookup\";\n+    private static final String\n+            NAME_LOOKUP_ACCESSOR = \"proxyClassLookup\",\n+            NAME_CLASS_LOADER = \"LOADER\";\n+\n@@ -130,1 +137,1 @@\n-    private final FieldRefEntry handlerField;\n+    private final FieldRefEntry handlerField, classLoaderField;\n@@ -176,0 +183,1 @@\n+        this.classLoaderField = cp.fieldRefEntry(classEntry.asSymbol(), NAME_CLASS_LOADER, CD_ClassLoader);\n@@ -179,1 +187,1 @@\n-        this.bsm = ConstantDescs.ofConstantBootstrap(classEntry.asSymbol(), \"$getMethod\", CD_Method, CD_Class, CD_String, CD_MethodType);\n+        this.bsm = ofConstantBootstrap(classEntry.asSymbol(), \"$getMethod\", CD_Method, CD_Class, CD_String);\n@@ -474,0 +482,1 @@\n+            generateClassInitializer(clb);\n@@ -543,0 +552,27 @@\n+    \/**\n+     * Generate the class initializer, called in AccessController.doPrivileged\n+     * to obtain the class loader.\n+     *\/\n+    private void generateClassInitializer(ClassBuilder clb) {\n+        clb.withField(classLoaderField.name(), classLoaderField.type(), ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n+        clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ACC_STATIC, cob -> {\n+            cob.ldc(classEntry)\n+               .invokevirtual(CD_Class, \"getClassLoader\", MTD_ClassLoader)\n+               .astore(0);\n+            var endIf = cob.newLabel();\n+            cob.aload(0)\n+               .if_nonnull(endIf)\n+               .invokestatic(CD_ClassLoader, \"getPlatformClassLoader\", MTD_ClassLoader)\n+               .astore(0)\n+               .labelBinding(endIf)\n+               .aload(0)\n+               .putstatic(classLoaderField)\n+               .return_()\n+               .with(StackMapTableAttribute.of(List.of(\n+                    StackMapFrameInfo.of(endIf,\n+                            List.of(StackMapFrameInfo.ObjectVerificationTypeInfo.of(CD_ClassLoader)),\n+                            List.of()))));\n+        });\n+\n+    }\n+\n@@ -549,2 +585,5 @@\n-               .aload(4) \/\/interface method name String\n-               .aload(5) \/\/interface MethodType\n+               .aload(1) \/\/interface method name String\n+               .aload(4) \/\/interface method type String\n+               .getstatic(classLoaderField)\n+               .invokestatic(CD_MethodType, \"fromMethodDescriptorString\",\n+                       MTD_MethodType_String_ClassLoader) \/\/interface method type\n@@ -552,1 +591,1 @@\n-               .invokevirtual(ConstantDescs.CD_Class, \"getMethod\", MTD_Method_String_Class_array)\n+               .invokevirtual(CD_Class, \"getMethod\", MTD_Method_String_Class_array)\n@@ -656,2 +695,1 @@\n-                           .ldc(DynamicConstantDesc.of(pg.bsm,\n-                                referenceClassDesc(fromClass),\n+                           .ldc(DynamicConstantDesc.ofNamed(pg.bsm,\n@@ -659,1 +697,5 @@\n-                                desc));\n+                                CD_Method,\n+                                referenceClassDesc(fromClass),\n+                                \/\/ some types in the method may be package private\n+                                \/\/ so Class or MethodType constants will fail\n+                                desc.descriptorString()));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":53,"deletions":11,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333854\n+ * @summary Test invoking a method in a proxy interface with package-private\n+ *          classes or interfaces in its method type\n+ * @run junit NonPublicMethodTypeTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.reflect.Proxy;\n+\n+import static org.junit.jupiter.api.Assertions.assertNotSame;\n+\n+public final class NonPublicMethodTypeTest {\n+    interface NonPublicWorker {\n+        void work();\n+    }\n+\n+    public interface PublicWorkable {\n+        void accept(NonPublicWorker worker);\n+    }\n+\n+    @Test\n+    public void test() {\n+        PublicWorkable proxy = (PublicWorkable) Proxy.newProxyInstance(\n+               NonPublicMethodTypeTest.class.getClassLoader(),\n+               new Class[] {PublicWorkable.class},\n+               (_, _, _) -> null);\n+        assertNotSame(NonPublicWorker.class.getPackage(),\n+                proxy.getClass().getPackage(),\n+                \"Proxy class should not be able to access method parameter \" +\n+                        \"NonPublic type's package\");\n+        proxy.accept(() -> {}); \/\/ Call should not fail\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/NonPublicMethodTypeTest.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"}]}