{"files":[{"patch":"@@ -50,1 +50,1 @@\n-import java.lang.constant.ConstantDescs;\n+\n@@ -54,3 +54,0 @@\n-import java.lang.constant.DirectMethodHandleDesc;\n-import java.lang.constant.DynamicConstantDesc;\n-\n@@ -70,0 +67,1 @@\n+            CD_ClassLoader = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/ClassLoader;\"),\n@@ -71,0 +69,2 @@\n+            CD_ClassNotFoundException = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/ClassNotFoundException;\"),\n+            CD_NoClassDefFoundError = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/NoClassDefFoundError;\"),\n@@ -86,2 +86,3 @@\n-            MTD_Class_array = MethodTypeDescImpl.ofValidated(CD_Class_array),\n-            MTD_Method_String_Class_array = MethodTypeDescImpl.ofValidated(CD_Method, ConstantDescs.CD_String, CD_Class_array),\n+            MTD_Class_String_boolean_ClassLoader = MethodTypeDescImpl.ofValidated(CD_Class, CD_String, CD_boolean, CD_ClassLoader),\n+            MTD_ClassLoader = MethodTypeDescImpl.ofValidated(CD_ClassLoader),\n+            MTD_Method_String_Class_array = MethodTypeDescImpl.ofValidated(CD_Method, CD_String, CD_Class_array),\n@@ -112,3 +113,3 @@\n-    private static final ProxyMethod HASH_CODE_METHOD;\n-    private static final ProxyMethod EQUALS_METHOD;\n-    private static final ProxyMethod TO_STRING_METHOD;\n+    private static final Method OBJECT_HASH_CODE_METHOD;\n+    private static final Method OBJECT_EQUALS_METHOD;\n+    private static final Method OBJECT_TO_STRING_METHOD;\n@@ -118,3 +119,3 @@\n-            HASH_CODE_METHOD = new ProxyMethod(Object.class.getMethod(\"hashCode\"));\n-            EQUALS_METHOD = new ProxyMethod(Object.class.getMethod(\"equals\", Object.class));\n-            TO_STRING_METHOD = new ProxyMethod(Object.class.getMethod(\"toString\"));\n+            OBJECT_HASH_CODE_METHOD = Object.class.getMethod(\"hashCode\");\n+            OBJECT_EQUALS_METHOD = Object.class.getMethod(\"equals\", Object.class);\n+            OBJECT_TO_STRING_METHOD = Object.class.getMethod(\"toString\");\n@@ -127,1 +128,1 @@\n-    private final List<StackMapFrameInfo.VerificationTypeInfo> throwableStack;\n+    private final List<StackMapFrameInfo.VerificationTypeInfo> classLoaderLocal, throwableStack;\n@@ -129,1 +130,1 @@\n-    private final ClassEntry object, proxy, ute;\n+    private final ClassEntry objectCE, proxyCE, uteCE, classCE;\n@@ -131,3 +132,2 @@\n-    private final InterfaceMethodRefEntry invoke;\n-    private final MethodRefEntry uteInit;\n-    private final DirectMethodHandleDesc bsm;\n+    private final InterfaceMethodRefEntry invocationHandlerInvoke;\n+    private final MethodRefEntry uteInit, classGetMethod, classForName, throwableGetMessage;\n@@ -137,1 +137,1 @@\n-     * Name of proxy class\n+     * ClassEntry for this proxy class\n@@ -139,1 +139,1 @@\n-    private final ClassEntry classEntry;\n+    private final ClassEntry thisClassCE;\n@@ -158,0 +158,6 @@\n+    \/**\n+     * Ordinal of next ProxyMethod object added to proxyMethods.\n+     * Indexes are reserved for hashcode(0), equals(1), toString(2).\n+     *\/\n+    private int proxyMethodCount = 3;\n+\n@@ -168,1 +174,1 @@\n-        this.classEntry = cp.classEntry(ConstantUtils.binaryNameToDesc(className));\n+        this.thisClassCE = cp.classEntry(ConstantUtils.binaryNameToDesc(className));\n@@ -171,1 +177,3 @@\n-        this.throwableStack = List.of(StackMapFrameInfo.ObjectVerificationTypeInfo.of(cp.classEntry(CD_Throwable)));\n+        var throwable = cp.classEntry(CD_Throwable);\n+        this.classLoaderLocal = List.of(StackMapFrameInfo.ObjectVerificationTypeInfo.of(cp.classEntry(CD_ClassLoader)));\n+        this.throwableStack = List.of(StackMapFrameInfo.ObjectVerificationTypeInfo.of(throwable));\n@@ -173,7 +181,10 @@\n-        this.object = cp.classEntry(CD_Object);\n-        this.proxy = cp.classEntry(CD_Proxy);\n-        this.handlerField = cp.fieldRefEntry(proxy, cp.nameAndTypeEntry(NAME_HANDLER_FIELD, CD_InvocationHandler));\n-        this.invoke = cp.interfaceMethodRefEntry(CD_InvocationHandler, \"invoke\", MTD_Object_Object_Method_ObjectArray);\n-        this.ute = cp.classEntry(CD_UndeclaredThrowableException);\n-        this.uteInit = cp.methodRefEntry(ute, cp.nameAndTypeEntry(INIT_NAME, MTD_void_Throwable));\n-        this.bsm = ConstantDescs.ofConstantBootstrap(classEntry.asSymbol(), \"$getMethod\", CD_Method, CD_Class, CD_String, CD_MethodType);\n+        this.objectCE = cp.classEntry(CD_Object);\n+        this.proxyCE = cp.classEntry(CD_Proxy);\n+        this.classCE = cp.classEntry(CD_Class);\n+        this.handlerField = cp.fieldRefEntry(proxyCE, cp.nameAndTypeEntry(NAME_HANDLER_FIELD, CD_InvocationHandler));\n+        this.invocationHandlerInvoke = cp.interfaceMethodRefEntry(CD_InvocationHandler, \"invoke\", MTD_Object_Object_Method_ObjectArray);\n+        this.uteCE = cp.classEntry(CD_UndeclaredThrowableException);\n+        this.uteInit = cp.methodRefEntry(uteCE, cp.nameAndTypeEntry(INIT_NAME, MTD_void_Throwable));\n+        this.classGetMethod = cp.methodRefEntry(classCE, cp.nameAndTypeEntry(\"getMethod\", MTD_Method_String_Class_array));\n+        this.classForName = cp.methodRefEntry(classCE, cp.nameAndTypeEntry(\"forName\", MTD_Class_String_boolean_ClassLoader));\n+        this.throwableGetMessage = cp.methodRefEntry(throwable, cp.nameAndTypeEntry(\"getMessage\", MTD_String));\n@@ -438,3 +449,3 @@\n-        addProxyMethod(HASH_CODE_METHOD);\n-        addProxyMethod(EQUALS_METHOD);\n-        addProxyMethod(TO_STRING_METHOD);\n+        addProxyMethod(new ProxyMethod(OBJECT_HASH_CODE_METHOD, \"m0\"));\n+        addProxyMethod(new ProxyMethod(OBJECT_EQUALS_METHOD, \"m1\"));\n+        addProxyMethod(new ProxyMethod(OBJECT_TO_STRING_METHOD, \"m2\"));\n@@ -461,2 +472,2 @@\n-        return CF_CONTEXT.build(classEntry, cp, clb -> {\n-            clb.withSuperclass(proxy);\n+        return CF_CONTEXT.build(thisClassCE, cp, clb -> {\n+            clb.withSuperclass(proxyCE);\n@@ -469,0 +480,3 @@\n+                    \/\/ add static field for the Method object\n+                    clb.withField(pm.methodFieldName, CD_Method, ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n+\n@@ -470,1 +484,1 @@\n-                    pm.generateMethod(this, clb);\n+                    pm.generateMethod(clb);\n@@ -474,1 +488,1 @@\n-            generateBootstrapMethod(clb);\n+            generateStaticInitializer(clb);\n@@ -517,1 +531,1 @@\n-                exceptionTypes, fromClass));\n+                exceptionTypes, fromClass, \"m\" + proxyMethodCount++));\n@@ -539,1 +553,2 @@\n-               .invokespecial(cp.methodRefEntry(proxy, cp.nameAndTypeEntry(INIT_NAME, MTD_void_InvocationHandler)))\n+               .invokespecial(cp.methodRefEntry(proxyCE,\n+                   cp.nameAndTypeEntry(INIT_NAME, MTD_void_InvocationHandler)))\n@@ -544,1 +559,6 @@\n-     * Generate CONDY bootstrap method for the proxy class to retrieve {@link Method} instances.\n+     * Generate the class initializer.\n+     * Discussion: Currently, for Proxy to work with SecurityManager,\n+     * we rely on the parameter classes of the methods to be computed\n+     * from Proxy instead of via user code paths like bootstrap method\n+     * lazy evaluation. That might change if we can pass in the live\n+     * Method objects directly..\n@@ -546,12 +566,28 @@\n-    private void generateBootstrapMethod(ClassBuilder clb) {\n-        clb.withMethodBody(bsm.methodName(), bsm.invocationType(), ClassFile.ACC_PRIVATE | ClassFile.ACC_STATIC, cob -> {\n-            cob.aload(3) \/\/interface Class\n-               .aload(4) \/\/interface method name String\n-               .aload(5) \/\/interface MethodType\n-               .invokevirtual(CD_MethodType, \"parameterArray\", MTD_Class_array)\n-               .invokevirtual(ConstantDescs.CD_Class, \"getMethod\", MTD_Method_String_Class_array)\n-               .areturn();\n-            Label failLabel = cob.newBoundLabel();\n-            ClassEntry nsme = cp.classEntry(CD_NoSuchMethodError);\n-            cob.exceptionCatch(cob.startLabel(), failLabel, failLabel, CD_NoSuchMethodException)\n-               .new_(nsme)\n+    private void generateStaticInitializer(ClassBuilder clb) {\n+        clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ACC_STATIC, cob -> {\n+            \/\/ Put ClassLoader at local variable index 0, used by\n+            \/\/ Class.forName(String, boolean, ClassLoader) calls\n+            cob.ldc(thisClassCE)\n+               .invokevirtual(cp.methodRefEntry(classCE,\n+                       cp.nameAndTypeEntry(\"getClassLoader\", MTD_ClassLoader)))\n+               .astore(0);\n+            var ts = cob.newBoundLabel();\n+            for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\n+                for (ProxyMethod pm : sigmethods) {\n+                    pm.codeFieldInitialization(cob);\n+                }\n+            }\n+            cob.return_();\n+            var c1 = cob.newBoundLabel();\n+            var nsmError = cp.classEntry(CD_NoSuchMethodError);\n+            cob.exceptionCatch(ts, c1, c1, CD_NoSuchMethodException)\n+               .new_(nsmError)\n+               .dup_x1()\n+               .swap()\n+               .invokevirtual(throwableGetMessage)\n+               .invokespecial(cp.methodRefEntry(nsmError, exInit))\n+               .athrow();\n+            var c2 = cob.newBoundLabel();\n+            var ncdfError = cp.classEntry(CD_NoClassDefFoundError);\n+            cob.exceptionCatch(ts, c1, c2, CD_ClassNotFoundException)\n+               .new_(ncdfError)\n@@ -560,5 +596,7 @@\n-               .invokevirtual(cp.methodRefEntry(CD_Throwable, \"getMessage\", MTD_String))\n-               .invokespecial(cp.methodRefEntry(nsme, exInit))\n-               .athrow()\n-               .with(StackMapTableAttribute.of(List.of(\n-                       StackMapFrameInfo.of(failLabel, List.of(), throwableStack))));\n+               .invokevirtual(throwableGetMessage)\n+               .invokespecial(cp.methodRefEntry(ncdfError, exInit))\n+               .athrow();\n+            cob.with(StackMapTableAttribute.of(List.of(\n+                       StackMapFrameInfo.of(c1, classLoaderLocal, throwableStack),\n+                       StackMapFrameInfo.of(c2, classLoaderLocal, throwableStack))));\n+\n@@ -584,1 +622,1 @@\n-                               .ldc(proxy)\n+                               .ldc(proxyCE)\n@@ -610,1 +648,1 @@\n-    private static class ProxyMethod {\n+    private class ProxyMethod {\n@@ -617,0 +655,1 @@\n+        private final String methodFieldName;\n@@ -618,0 +657,1 @@\n+        private final FieldRefEntry methodField;\n@@ -621,1 +661,1 @@\n-                            Class<?> fromClass) {\n+                            Class<?> fromClass, String methodFieldName) {\n@@ -628,0 +668,3 @@\n+            this.methodFieldName = methodFieldName;\n+            this.methodField = cp.fieldRefEntry(thisClassCE,\n+                cp.nameAndTypeEntry(methodFieldName, CD_Method));\n@@ -635,1 +678,1 @@\n-        private ProxyMethod(Method method) {\n+        private ProxyMethod(Method method, String methodFieldName) {\n@@ -638,1 +681,1 @@\n-                 method.getSharedExceptionTypes(), method.getDeclaringClass());\n+                 method.getSharedExceptionTypes(), method.getDeclaringClass(), methodFieldName);\n@@ -644,2 +687,1 @@\n-        private void generateMethod(ProxyGenerator pg, ClassBuilder clb) {\n-            var cp = pg.cp;\n+        private void generateMethod(ClassBuilder clb) {\n@@ -653,7 +695,4 @@\n-                        cob.aload(0)\n-                           .getfield(pg.handlerField)\n-                           .aload(0)\n-                           .ldc(DynamicConstantDesc.of(pg.bsm,\n-                                referenceClassDesc(fromClass),\n-                                method.getName(),\n-                                desc));\n+                        cob.aload(cob.receiverSlot())\n+                           .getfield(handlerField)\n+                           .aload(cob.receiverSlot())\n+                           .getstatic(methodField);\n@@ -663,1 +702,1 @@\n-                               .anewarray(pg.object);\n+                               .anewarray(objectCE);\n@@ -674,1 +713,1 @@\n-                        cob.invokeinterface(pg.invoke);\n+                        cob.invokeinterface(invocationHandlerInvoke);\n@@ -690,1 +729,1 @@\n-                               .new_(pg.ute)\n+                               .new_(uteCE)\n@@ -693,1 +732,1 @@\n-                               .invokespecial(pg.uteInit)\n+                               .invokespecial(uteInit)\n@@ -696,2 +735,2 @@\n-                                       StackMapFrameInfo.of(c1, List.of(), pg.throwableStack),\n-                                       StackMapFrameInfo.of(c2, List.of(), pg.throwableStack))));\n+                                    StackMapFrameInfo.of(c1, List.of(), throwableStack),\n+                                    StackMapFrameInfo.of(c2, List.of(), throwableStack))));\n@@ -712,1 +751,1 @@\n-                cob.invokestatic(prim.wrapperMethodRef(cob.constantPool()));\n+                cob.invokestatic(prim.wrapperMethodRef(cp));\n@@ -728,1 +767,1 @@\n-                   .invokevirtual(prim.unwrapMethodRef(cob.constantPool()))\n+                   .invokevirtual(prim.unwrapMethodRef(cp))\n@@ -736,0 +775,51 @@\n+        \/**\n+         * Generate code for initializing the static field that stores\n+         * the Method object for this proxy method. A class loader is\n+         * anticipated at local variable index 0.\n+         * The generated code must be run in an AccessController.doPrivileged\n+         * block if a SecurityManager is present, as otherwise the code\n+         * cannot pass {@code null} ClassLoader to forName.\n+         *\/\n+        private void codeFieldInitialization(CodeBuilder cob) {\n+            var cp = cob.constantPool();\n+            codeClassForName(cob, fromClass);\n+\n+            cob.ldc(method.getName())\n+               .loadConstant(parameterTypes.length)\n+               .anewarray(classCE);\n+\n+            \/\/ Construct an array with the parameter types mapping primitives to Wrapper types\n+            for (int i = 0; i < parameterTypes.length; i++) {\n+                cob.dup()\n+                   .loadConstant(i);\n+                if (parameterTypes[i].isPrimitive()) {\n+                    PrimitiveTypeInfo prim = PrimitiveTypeInfo.get(parameterTypes[i]);\n+                    cob.getstatic(prim.typeFieldRef(cp));\n+                } else {\n+                    codeClassForName(cob, parameterTypes[i]);\n+                }\n+                cob.aastore();\n+            }\n+            \/\/ lookup the method\n+            cob.invokevirtual(classGetMethod)\n+               .putstatic(methodField);\n+        }\n+\n+        \/*\n+         * =============== Code Generation Utility Methods ===============\n+         *\/\n+\n+        \/**\n+         * Generate code to invoke the Class.forName with the name of the given\n+         * class to get its Class object at runtime.  The code is written to\n+         * the supplied stream.  Note that the code generated by this method\n+         * may cause the checked ClassNotFoundException to be thrown. A class\n+         * loader is anticipated at local variable index 0.\n+         *\/\n+        private void codeClassForName(CodeBuilder cob, Class<?> cl) {\n+            cob.ldc(cl.getName())\n+               .iconst_0() \/\/ false\n+               .aload(0)\/\/ classLoader\n+               .invokestatic(classForName);\n+        }\n+\n@@ -802,0 +892,4 @@\n+\n+        public FieldRefEntry typeFieldRef(ConstantPoolBuilder cp) {\n+            return cp.fieldRefEntry(wrapperClass, \"TYPE\", CD_Class);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":171,"deletions":77,"binary":false,"changes":248,"status":"modified"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333854\n+ * @summary Test invoking a method in a proxy interface with package-private\n+ *          classes or interfaces in its method type\n+ * @run junit NonPublicMethodTypeTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.reflect.Proxy;\n+\n+import static org.junit.jupiter.api.Assertions.assertNotSame;\n+\n+public final class NonPublicMethodTypeTest {\n+    interface NonPublicWorker {\n+        void work();\n+    }\n+\n+    public interface PublicWorkable {\n+        void accept(NonPublicWorker worker);\n+    }\n+\n+    @Test\n+    public void test() {\n+        PublicWorkable proxy = (PublicWorkable) Proxy.newProxyInstance(\n+               NonPublicMethodTypeTest.class.getClassLoader(),\n+               new Class[] {PublicWorkable.class},\n+               (_, _, _) -> null);\n+        assertNotSame(NonPublicWorker.class.getPackage(),\n+                proxy.getClass().getPackage(),\n+                \"Proxy class should not be able to access method parameter \" +\n+                        \"NonPublic type's package\");\n+        proxy.accept(() -> {}); \/\/ Call should not fail\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/NonPublicMethodTypeTest.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"}]}