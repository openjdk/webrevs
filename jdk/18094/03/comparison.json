{"files":[{"patch":"@@ -3286,1 +3286,5 @@\n-     * Does the real work of generating a pattern.  *\/\n+     * Implementation of producing a pattern. This method returns a positive and\n+     * negative (if needed), pattern string in the form of : Prefix (optional)\n+     * Number Suffix (optional). A NegativePattern is only produced if the\n+     * prefix or suffix patterns differs.\n+     *\/\n@@ -3288,0 +3292,12 @@\n+        \/\/ Determine symbol values; use DFS if localized\n+        char zeroSymbol = localized ? symbols.getZeroDigit() : PATTERN_ZERO_DIGIT;\n+        char digitSymbol = localized ? symbols.getDigit() : PATTERN_DIGIT;\n+        char groupingSymbol = localized ?\n+                (isCurrencyFormat ? symbols.getMonetaryGroupingSeparator() : symbols.getGroupingSeparator()) :\n+                PATTERN_GROUPING_SEPARATOR;\n+        char decimalSymbol = localized ?\n+                (isCurrencyFormat ? symbols.getMonetaryDecimalSeparator() : symbols.getDecimalSeparator()) :\n+                PATTERN_DECIMAL_SEPARATOR;\n+        String exponentSymbol = localized ? symbols.getExponentSeparator() : PATTERN_EXPONENT;\n+        char patternSeparator = localized ? symbols.getPatternSeparator() : PATTERN_SEPARATOR;\n+\n@@ -3289,0 +3305,1 @@\n+        \/\/ j == 1 denotes PositivePattern, j == 0 denotes NegativePattern\n@@ -3290,1 +3307,2 @@\n-            if (j == 1)\n+            if (j == 1) {\n+                \/\/ Append positive and negative (if needed) prefix pattern\n@@ -3292,6 +3310,7 @@\n-            else appendAffix(result, negPrefixPattern, negativePrefix, localized);\n-            int i;\n-            int digitCount = useExponentialNotation\n-                        ? getMaximumIntegerDigits()\n-                        : Math.max(groupingSize, getMinimumIntegerDigits())+1;\n-            for (i = digitCount; i > 0; --i) {\n+            } else {\n+                appendAffix(result, negPrefixPattern, negativePrefix, localized);\n+            }\n+            \/\/ Append integer digits\n+            int digitCount = useExponentialNotation ? getMaximumIntegerDigits() :\n+                    Math.max(groupingSize, getMinimumIntegerDigits()) + 1;\n+            for (int i = digitCount; i > 0; --i) {\n@@ -3299,20 +3318,2 @@\n-                    i % groupingSize == 0) {\n-                    result.append(localized ?\n-                        (isCurrencyFormat ? symbols.getMonetaryGroupingSeparator() : symbols.getGroupingSeparator()) :\n-                        PATTERN_GROUPING_SEPARATOR);\n-                }\n-                result.append(i <= getMinimumIntegerDigits()\n-                    ? (localized ? symbols.getZeroDigit() : PATTERN_ZERO_DIGIT)\n-                    : (localized ? symbols.getDigit() : PATTERN_DIGIT));\n-            }\n-            if (getMaximumFractionDigits() > 0 || decimalSeparatorAlwaysShown)\n-                result.append(localized ?\n-                    (isCurrencyFormat ? symbols.getMonetaryDecimalSeparator() : symbols.getDecimalSeparator()) :\n-                    PATTERN_DECIMAL_SEPARATOR);\n-            for (i = 0; i < getMaximumFractionDigits(); ++i) {\n-                if (i < getMinimumFractionDigits()) {\n-                    result.append(localized ? symbols.getZeroDigit() :\n-                                  PATTERN_ZERO_DIGIT);\n-                } else {\n-                    result.append(localized ? symbols.getDigit() :\n-                                  PATTERN_DIGIT);\n+                        i % groupingSize == 0) {\n+                    result.append(groupingSymbol);\n@@ -3320,0 +3321,13 @@\n+                result.append(i <= getMinimumIntegerDigits() ? zeroSymbol : digitSymbol);\n+            }\n+            \/\/ Append decimal symbol\n+            if (getMaximumFractionDigits() > 0 || decimalSeparatorAlwaysShown) {\n+                result.append(decimalSymbol);\n+            }\n+            \/\/ Append fraction digits\n+            result.repeat(zeroSymbol, getMinimumFractionDigits());\n+            result.repeat(digitSymbol, getMaximumFractionDigits() - getMinimumFractionDigits());\n+            \/\/ Append exponent symbol and digits\n+            if (useExponentialNotation) {\n+                result.append(exponentSymbol);\n+                result.repeat(zeroSymbol, minExponentDigits);\n@@ -3321,8 +3335,0 @@\n-        if (useExponentialNotation)\n-        {\n-            result.append(localized ? symbols.getExponentSeparator() :\n-                  PATTERN_EXPONENT);\n-        for (i=0; i<minExponentDigits; ++i)\n-                    result.append(localized ? symbols.getZeroDigit() :\n-                                  PATTERN_ZERO_DIGIT);\n-        }\n@@ -3330,0 +3336,1 @@\n+                \/\/ Append positive suffix pattern\n@@ -3331,9 +3338,3 @@\n-                if ((negSuffixPattern == posSuffixPattern && \/\/ n == p == null\n-                     negativeSuffix.equals(positiveSuffix))\n-                    || (negSuffixPattern != null &&\n-                        negSuffixPattern.equals(posSuffixPattern))) {\n-                    if ((negPrefixPattern != null && posPrefixPattern != null &&\n-                         negPrefixPattern.equals(\"'-\" + posPrefixPattern)) ||\n-                        (negPrefixPattern == posPrefixPattern && \/\/ n == p == null\n-                         negativePrefix.equals(symbols.getMinusSignText() + positivePrefix)))\n-                        break;\n+                if (posEqualsNegPattern()) {\n+                    \/\/ Negative pattern not needed if suffix\/prefix are equivalent\n+                    break;\n@@ -3341,3 +3342,4 @@\n-                result.append(localized ? symbols.getPatternSeparator() :\n-                              PATTERN_SEPARATOR);\n-            } else appendAffix(result, negSuffixPattern, negativeSuffix, localized);\n+                result.append(patternSeparator);\n+            } else {\n+                appendAffix(result, negSuffixPattern, negativeSuffix, localized);\n+            }\n@@ -3348,0 +3350,18 @@\n+    \/**\n+     * This method returns true if the positive and negative prefix\/suffix\n+     * values are equivalent. This is used to determine if an explicit NegativePattern\n+     * is required.\n+     *\/\n+    private boolean posEqualsNegPattern() {\n+        \/\/ Check suffix\n+        return ((negSuffixPattern == posSuffixPattern && \/\/ n == p == null\n+                negativeSuffix.equals(positiveSuffix))\n+                || (negSuffixPattern != null &&\n+                negSuffixPattern.equals(posSuffixPattern)))\n+                && \/\/ Check prefix\n+                ((negPrefixPattern != null && posPrefixPattern != null &&\n+                negPrefixPattern.equals(\"'-\" + posPrefixPattern)) ||\n+                (negPrefixPattern == posPrefixPattern && \/\/ n == p == null\n+                negativePrefix.equals(symbols.getMinusSignText() + positivePrefix)));\n+    }\n+\n@@ -3715,1 +3735,3 @@\n-            setMaximumFractionDigits(MAXIMUM_FRACTION_DIGITS);\n+            \/\/ As maxFracDigits are fully displayed unlike maxIntDigits\n+            \/\/ Prevent OOME by setting to a much more reasonable value.\n+            setMaximumFractionDigits(DOUBLE_FRACTION_DIGITS);\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormat.java","additions":71,"deletions":49,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,4 +26,3 @@\n- * @bug 8282929\n- * @summary Verifies that toLocalizedPattern() method correctly returns\n- *          monetary symbols in a currency formatter\n- * @run testng ToLocalizedPatternTest\n+ * @bug 8282929 8326908\n+ * @summary Verify DecimalFormat::toLocalizedPattern correctness.\n+ * @run junit ToLocalizedPatternTest\n@@ -32,2 +31,3 @@\n-import static org.testng.Assert.assertEquals;\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -39,1 +39,0 @@\n-@Test\n@@ -44,1 +43,4 @@\n-    public void testToLocalizedPattern() {\n+    \/\/ Verifies that the toLocalizedPattern() method correctly returns\n+    \/\/ monetary symbols for a currency formatter.\n+    @Test\n+    public void monetarySymbolsTest() {\n@@ -61,0 +63,13 @@\n+\n+    \/\/ Verify some common symbols are enforced with the DFS\n+    @Test\n+    public void useDFSWhenLocalizedTest() {\n+        DecimalFormatSymbols dfs = new DecimalFormatSymbols();\n+        dfs.setGroupingSeparator('a');\n+        dfs.setDecimalSeparator('b');\n+        dfs.setDigit('c');\n+        dfs.setZeroDigit('d');\n+        \/\/ Create a DecimalFormat that utilizes the above symbols\n+        DecimalFormat dFmt = new DecimalFormat(\"###,##0.###\", dfs);\n+        assertEquals(\"caccdbccc\", dFmt.toLocalizedPattern());\n+    }\n","filename":"test\/jdk\/java\/text\/Format\/DecimalFormat\/ToLocalizedPatternTest.java","additions":24,"deletions":9,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8326908\n+ * @summary Verify DecimalFormat::toPattern correctness.\n+ * @run junit ToPatternTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.text.DecimalFormat;\n+import java.util.stream.Stream;\n+\n+public class ToPatternTest {\n+\n+    \/\/ DecimalFormat constant\n+    private static final int DOUBLE_FRACTION_DIGITS = 340;\n+\n+    \/\/ Ensure that toPattern() provides the correct amount of minimum\n+    \/\/ and maximum digits for integer\/fraction.\n+    @ParameterizedTest\n+    @MethodSource(\"minMaxDigits\")\n+    public void basicTest(int maxInt, int minInt, int maxFrac, int minFrac) {\n+        DecimalFormat dFmt = new DecimalFormat();\n+\n+        dFmt.setMaximumIntegerDigits(maxInt);\n+        dFmt.setMinimumIntegerDigits(minInt);\n+        dFmt.setMaximumFractionDigits(maxFrac);\n+        dFmt.setMinimumFractionDigits(minFrac);\n+\n+        \/\/ Non-localized separator always uses '.'\n+        String[] patterns = dFmt.toPattern().split(\"\\\\.\");\n+        assertEquals(2, patterns.length,\n+                dFmt.toPattern() + \" should be split into an integer\/fraction portion\");\n+        String integerPattern = patterns[0];\n+        String fractionPattern = patterns[1];\n+\n+        \/\/ Count # and 0 explicitly (since there are grouping symbols)\n+        assertEquals(integerPattern.chars().filter(ch -> ch == '0').count() +\n+                integerPattern.chars().filter(ch -> ch == '#').count(),\n+                Math.max(dFmt.getGroupingSize(), dFmt.getMinimumIntegerDigits()) + 1);\n+        assertEquals(integerPattern.chars().filter(ch -> ch == '0').count(), dFmt.getMinimumIntegerDigits());\n+        assertEquals(fractionPattern.length(), dFmt.getMaximumFractionDigits());\n+        assertEquals(fractionPattern.chars().filter(ch -> ch == '0').count(), dFmt.getMinimumFractionDigits());\n+    }\n+\n+    \/\/ General and edge cases for the min and max Integer\/Fraction digits\n+    private static Stream<Arguments> minMaxDigits() {\n+        return Stream.of(\n+                Arguments.of(10, 5, 10, 5),\n+                Arguments.of(0, 0, 1, 1),\n+                Arguments.of(1, 1, 1, 1),\n+                Arguments.of(5, 5, 5, 5),\n+                Arguments.of(5, 10, 5, 10),\n+                Arguments.of(333, 27, 409, 3)\n+        );\n+    }\n+\n+    \/\/ Ensure that a NegativePattern is explicitly produced when required.\n+    @Test\n+    public void negativeSubPatternTest() {\n+        DecimalFormat dFmt = new DecimalFormat();\n+        dFmt.setPositivePrefix(\"foo\");\n+        dFmt.setPositiveSuffix(\"bar\");\n+        dFmt.setNegativePrefix(\"baz\");\n+        dFmt.setNegativeSuffix(\"qux\");\n+\n+        String[] patterns = dFmt.toPattern().split(\";\");\n+        assertEquals(2, patterns.length,\n+                \"There should be a positivePattern and negativePattern\");\n+        String positivePattern = patterns[0];\n+        String negativePattern = patterns[1];\n+\n+        assertTrue(positivePattern.startsWith(dFmt.getPositivePrefix()));\n+        assertTrue(positivePattern.endsWith(dFmt.getPositiveSuffix()));\n+        assertTrue(negativePattern.startsWith(dFmt.getNegativePrefix()));\n+        assertTrue(negativePattern.endsWith(dFmt.getNegativeSuffix()));\n+    }\n+\n+    \/\/ 8326908: Verify that an empty pattern DecimalFormat does not throw an\n+    \/\/ OutOfMemoryError when toPattern() is invoked. Behavioral change of\n+    \/\/ MAXIMUM_INTEGER_DIGITS replaced with DOUBLE_FRACTION_DIGITS for empty\n+    \/\/ pattern initialization.\n+    @Test\n+    public void emptyStringPatternTest() {\n+        DecimalFormat empty = new DecimalFormat(\"\");\n+        \/\/ Verify new maximum fraction digits value\n+        assertEquals(DOUBLE_FRACTION_DIGITS, empty.getMaximumFractionDigits());\n+        \/\/ Verify no OOME for empty pattern\n+        assertDoesNotThrow(empty::toPattern);\n+        \/\/ Check toString for coverage, as it invokes toPattern\n+        assertDoesNotThrow(empty::toString);\n+    }\n+\n+    \/\/ Verify that only the last grouping interval is used for the grouping size.\n+    @Test\n+    public void groupingSizeTest() {\n+        assertEquals(22,\n+                new DecimalFormat( \"###,####,\"+\"#\".repeat(22)).getGroupingSize());\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/DecimalFormat\/ToPatternTest.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"}]}