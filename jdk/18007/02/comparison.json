{"files":[{"patch":"@@ -308,2 +308,1 @@\n- * occurs at an n-byte aligned physical address (except for {@code long[]} and\n- * {@code double[]}, where alignment is platform-dependent, as explained below). The\n+ * occurs at an n-byte aligned physical address. The\n@@ -328,17 +327,8 @@\n- *     (e.g. 1000) on 64-bit platforms, so that successive long elements occur at\n- *     8-byte aligned addresses (e.g., 1000, 1008, 1016, 1024, etc.) On 64-bit platforms,\n- *     a heap segment backed by a {@code long[]} array can be accessed at offsets\n- *     0, 8, 16, 24, etc under an 8-byte alignment constraint. In addition, the segment\n- *     can be accessed at offsets 0, 4, 8, 12, etc under a 4-byte alignment constraint,\n- *     because the target addresses (1000, 1004, 1008, 1012) are 4-byte aligned. And,\n- *     the segment can be accessed at offsets 0, 2, 4, 6, etc under a 2-byte alignment\n- *     constraint, because the target addresses (e.g. 1000, 1002, 1004, 1006) are\n- *     2-byte aligned.<\/li>\n- * <li>The starting physical address of a {@code long[]} array will be 4-byte aligned\n- *     (e.g. 1004) on 32-bit platforms, so that successive long elements occur at 4-byte\n- *     aligned addresses (e.g., 1004, 1008, 1012, 1016, etc.) On 32-bit platforms, a heap\n- *     segment backed by a {@code long[]} array can be accessed at offsets\n- *     0, 4, 8, 12, etc under a 4-byte alignment constraint, because the target addresses\n- *     (1004, 1008, 1012, 1016) are 4-byte aligned. And, the segment can be accessed at\n- *     offsets 0, 2, 4, 6, etc under a 2-byte alignment constraint, because the target\n- *     addresses (e.g. 1000, 1002, 1004, 1006) are 2-byte aligned.<\/li>\n+ *     (e.g. 1000), so that successive long elements occur at 8-byte aligned addresses\n+ *     (e.g., 1000, 1008, 1016, 1024, etc.) A heap segment backed by a {@code long[]}\n+ *     array can be accessed at offsets 0, 8, 16, 24, etc under an 8-byte alignment\n+ *     constraint. In addition, the segment can be accessed at offsets 0, 4, 8, 12,\n+ *     etc under a 4-byte alignment constraint, because the target addresses (1000, 1004,\n+ *     1008, 1012) are 4-byte aligned. And, the segment can be accessed at offsets 0, 2,\n+ *     4, 6, etc under a 2-byte alignment constraint, because the target addresses (e.g.\n+ *     1000, 1002, 1004, 1006) are 2-byte aligned.<\/li>\n@@ -347,1 +337,1 @@\n- * In other words, heap segments feature a (platform-dependent) <em>maximum<\/em>\n+ * In other words, heap segments feature a <em>maximum<\/em>\n@@ -392,4 +382,1 @@\n- * set to {@code ValueLayout.JAVA_LONG.byteAlignment()} which is a platform-dependent\n- * value (set to {@code ValueLayout.ADDRESS.byteSize()}). That is, {@code long[]}) is\n- * guaranteed to provide at least 8-byte alignment in 64-bit platforms, but only 4-byte\n- * alignment in 32-bit platforms:\n+ * set to {@code ValueLayout.JAVA_LONG.byteAlignment()}, which is 8 bytes:\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":11,"deletions":24,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -50,3 +50,0 @@\n- *          Moreover, the alignment constraint of {@link ValueLayout#JAVA_LONG} and\n- *          {@link ValueLayout#JAVA_DOUBLE} is set to 8 bytes on 64-bit platforms,\n- *          but only to 4 bytes on 32-bit platforms.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -52,3 +52,0 @@\n-    \/\/ While for most arrays, the maximum alignment is constant (the size, in bytes, of the array elements),\n-    \/\/ note that the alignment of a long[]\/double[] depends on the platform: it's 4-byte on x86, but 8 bytes on x64\n-    \/\/ (as specified by the JAVA_LONG layout constant).\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -310,2 +310,2 @@\n-                    Map.entry(\"long long\", JAVA_LONG),\n-                    Map.entry(\"double\", JAVA_DOUBLE),\n+                    Map.entry(\"long long\", JAVA_LONG.withByteAlignment(LibFallback.longLongAlign())),\n+                    Map.entry(\"double\", JAVA_DOUBLE.withByteAlignment(LibFallback.doubleAlign())),\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FallbackLinker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -76,0 +76,2 @@\n+    static int longLongAlign() { return NativeConstants.ALIGNOF_LONG_LONG; }\n+    static int doubleAlign() { return NativeConstants.ALIGNOF_DOUBLE; }\n@@ -245,0 +247,3 @@\n+    private static native int alignof_long_long();\n+    private static native int alignof_double();\n+\n@@ -266,0 +271,2 @@\n+        static final int ALIGNOF_LONG_LONG = alignof_long_long();\n+        static final int ALIGNOF_DOUBLE = alignof_double();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/LibFallback.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -281,1 +281,1 @@\n-            return new OfLongImpl(order, ADDRESS_SIZE_BYTES, Optional.empty());\n+            return new OfLongImpl(order, Long.BYTES, Optional.empty());\n@@ -297,1 +297,1 @@\n-            return new OfDoubleImpl(order, ADDRESS_SIZE_BYTES, Optional.empty());\n+            return new OfDoubleImpl(order, Double.BYTES, Optional.empty());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/ValueLayouts.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include <stdalign.h>\n@@ -278,0 +279,10 @@\n+\n+JNIEXPORT jint JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_alignof_1long_1long(JNIEnv* env, jclass cls) {\n+  return alignof(long long);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_alignof_1double(JNIEnv* env, jclass cls) {\n+  return alignof(double);\n+}\n","filename":"src\/java.base\/share\/native\/libfallbackLinker\/fallbackLinker.c","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -164,1 +164,1 @@\n-        assertEquals(struct.byteAlignment(), ADDRESS.byteSize());\n+        assertEquals(struct.byteAlignment(), 8);\n@@ -195,1 +195,1 @@\n-        assertEquals(struct.byteAlignment(), ADDRESS.byteSize());\n+        assertEquals(struct.byteAlignment(), 8);\n@@ -480,1 +480,1 @@\n-        for (MemoryLayout l : basicLayoutsNoLongDouble) {\n+        for (MemoryLayout l : basicLayouts) {\n@@ -484,1 +484,1 @@\n-        for (MemoryLayout l : basicLayoutsNoLongDouble) {\n+        for (MemoryLayout l : basicLayouts) {\n@@ -488,2 +488,2 @@\n-        for (MemoryLayout l1 : basicLayoutsNoLongDouble) {\n-            for (MemoryLayout l2 : basicLayoutsNoLongDouble) {\n+        for (MemoryLayout l1 : basicLayouts) {\n+            for (MemoryLayout l2 : basicLayouts) {\n@@ -496,2 +496,2 @@\n-        for (MemoryLayout l1 : basicLayoutsNoLongDouble) {\n-            for (MemoryLayout l2 : basicLayoutsNoLongDouble) {\n+        for (MemoryLayout l1 : basicLayouts) {\n+            for (MemoryLayout l2 : basicLayouts) {\n@@ -546,4 +546,0 @@\n-\n-    static MemoryLayout[] basicLayoutsNoLongDouble = Stream.of(basicLayouts)\n-            .filter(l -> l.carrier() != long.class && l.carrier() != double.class)\n-            .toArray(MemoryLayout[]::new);\n","filename":"test\/jdk\/java\/foreign\/TestLayouts.java","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-        testAligned(JAVA_LONG, long.class, Long.BYTES, ADDRESS.byteSize());\n+        testAligned(JAVA_LONG, long.class, Long.BYTES, Long.BYTES);\n@@ -93,1 +93,1 @@\n-        testAligned(JAVA_DOUBLE, double.class, Double.BYTES, ADDRESS.byteSize());\n+        testAligned(JAVA_DOUBLE, double.class, Double.BYTES, Double.BYTES);\n","filename":"test\/jdk\/java\/foreign\/TestValueLayouts.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-        if (depth < 100) {\n+        if (depth < 50) {\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestReentrantUpcalls.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}