{"files":[{"patch":"@@ -217,0 +217,2 @@\n+  assert(r->is_old() || r->is_humongous(), \"precondition\");\n+\n@@ -222,6 +224,1 @@\n-  G1RemSetTrackingPolicy* tracker = _g1h->policy()->remset_tracker();\n-  if (tracker->needs_scan_for_rebuild(r)) {\n-    _top_at_rebuild_starts[region] = r->top();\n-  } else {\n-    \/\/ Leave TARS at null.\n-  }\n+  _top_at_rebuild_starts[region] = r->top();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.inline.hpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -33,8 +33,0 @@\n-bool G1RemSetTrackingPolicy::needs_scan_for_rebuild(G1HeapRegion* r) const {\n-  \/\/ All non-free and non-young regions need to be scanned for references;\n-  \/\/ At every gc we gather references to other regions in young.\n-  \/\/ Free regions trivially do not need scanning because they do not contain live\n-  \/\/ objects.\n-  return !(r->is_young() || r->is_free());\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetTrackingPolicy.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -37,3 +37,0 @@\n-  \/\/ Do we need to scan the given region to get all outgoing references for remembered\n-  \/\/ set rebuild?\n-  bool needs_scan_for_rebuild(G1HeapRegion* r) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetTrackingPolicy.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"}]}