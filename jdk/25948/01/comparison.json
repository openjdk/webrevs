{"files":[{"patch":"@@ -131,1 +131,0 @@\n-serviceability\/jvmti\/ModuleAwareAgents\/ThreadStart\/MAAThreadStart.java 8225354 windows-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,11 +33,0 @@\n-    static {\n-        try {\n-            System.loadLibrary(\"MAAThreadStart\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load MAAThreadStart library\");\n-            System.err.println(\"java.library.path: \"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/ModuleAwareAgents\/ThreadStart\/MAAThreadStart.java","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,177 +0,0 @@\n-\/*\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-#ifndef JNI_ENV_ARG\n-\n-#ifdef __cplusplus\n-#define JNI_ENV_ARG(x, y) y\n-#define JNI_ENV_PTR(x) x\n-#else\n-#define JNI_ENV_ARG(x,y) x, y\n-#define JNI_ENV_PTR(x) (*x)\n-#endif\n-\n-#endif\n-\n-#define TranslateError(err) \"JVMTI error\"\n-\n-#define PASSED 0\n-#define FAILED 2\n-\n-static const char *EXC_CNAME = \"java\/lang\/Exception\";\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-\n-static int thread_start_events_vm_start = 0;\n-\n-static jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved);\n-\n-JNIEXPORT\n-jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-\n-JNIEXPORT\n-jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-\n-JNIEXPORT\n-jint JNICALL JNI_OnLoad(JavaVM *jvm, void *reserved) {\n-    return JNI_VERSION_9;\n-}\n-\n-static\n-jint throw_exc(JNIEnv *env, char *msg) {\n-    jclass exc_class = JNI_ENV_PTR(env)->FindClass(JNI_ENV_ARG(env, EXC_CNAME));\n-\n-    if (exc_class == NULL) {\n-        printf(\"throw_exc: Error in FindClass(env, %s)\\n\", EXC_CNAME);\n-        return -1;\n-    }\n-    return JNI_ENV_PTR(env)->ThrowNew(JNI_ENV_ARG(env, exc_class), msg);\n-}\n-\n-\n-void JNICALL Callback_ThreadStart(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thread) {\n-    jvmtiError err;\n-    jvmtiPhase phase;\n-\n-    err = (*jvmti)->GetPhase(jvmti_env,&phase);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"ThreadStart event: GetPhase error: %s (%d)\\n\", TranslateError(err), err);\n-        result = FAILED;\n-        return;\n-    }\n-\n-    if (phase == JVMTI_PHASE_START) {\n-        thread_start_events_vm_start++;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>>    ThreadStart event: phase(%d)\\n\", phase);\n-    }\n-}\n-\n-static\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jint res, size;\n-    jvmtiCapabilities caps;\n-    jvmtiEventCallbacks callbacks;\n-    jvmtiError err;\n-\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = JNI_ENV_PTR(jvm)->GetEnv(JNI_ENV_ARG(jvm, (void **) &jvmti),\n-        JVMTI_VERSION_9);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"    Error: wrong result of a valid call to GetEnv!\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    printf(\"Enabling following capability: can_generate_early_vmstart\\n\");\n-    memset(&caps, 0, sizeof(caps));\n-    caps.can_generate_early_vmstart = 1;\n-\n-    err = (*jvmti)->AddCapabilities(jvmti, &caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"    Error in AddCapabilites: %s (%d)\\n\", TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    size = (jint)sizeof(callbacks);\n-\n-    memset(&callbacks, 0, sizeof(callbacks));\n-    callbacks.ThreadStart = Callback_ThreadStart;\n-\n-    err = (*jvmti)->SetEventCallbacks(jvmti, &callbacks, size);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"    Error in SetEventCallbacks: %s (%d)\\n\", TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = (*jvmti)->SetEventNotificationMode(jvmti, JVMTI_ENABLE, JVMTI_EVENT_THREAD_START, NULL);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"    Error in SetEventNotificationMode: %s (%d)\\n\", TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_MAAThreadStart_check(JNIEnv *env, jclass cls) {\n-    jobject loader = NULL;\n-\n-    if (jvmti == NULL) {\n-        throw_exc(env, \"JVMTI client was not properly loaded!\\n\");\n-        return FAILED;\n-    }\n-\n-    \/*\n-     * Expecting that ThreadStart events are sent during VM Start phase when\n-     * can_generate_early_vmstart capability is enabled.\n-     *\/\n-    if (thread_start_events_vm_start == 0) {\n-        throw_exc(env, \"Didn't get ThreadStart events in VM early start phase!\\n\");\n-        return FAILED;\n-    }\n-\n-    return result;\n-}\n-\n-#ifdef __cplusplus\n-}\n-#endif\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/ModuleAwareAgents\/ThreadStart\/libMAAThreadStart.c","additions":0,"deletions":177,"binary":false,"changes":177,"status":"deleted"},{"patch":"@@ -0,0 +1,143 @@\n+\/*\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.hpp\"\n+\n+extern \"C\" {\n+\n+#define PASSED 0\n+#define FAILED 2\n+\n+static jvmtiEnv *jvmti = NULL;\n+static int thread_start_events_vm_start = 0;\n+static jrawMonitorID agent_lock = nullptr;\n+\n+static jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved);\n+\n+JNIEXPORT\n+jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT\n+jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT\n+jint JNICALL JNI_OnLoad(JavaVM *jvm, void *reserved) {\n+  return JNI_VERSION_9;\n+}\n+\n+void JNICALL ThreadStart(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread) {\n+  jvmtiError err;\n+  jvmtiPhase phase;\n+\n+  RawMonitorLocker agent_locker(jvmti, jni, agent_lock);\n+\n+  err = jvmti->GetPhase(&phase);\n+  check_jvmti_status(jni, err, \"GetPhase\");\n+\n+  if (phase == JVMTI_PHASE_START) {\n+    thread_start_events_vm_start++;\n+    LOG(\">>>    ThreadStart event: phase: %s\\n\", TranslatePhase(phase));\n+  }\n+  agent_locker.notify(); \/\/ notify VM_INIT thread\n+}\n+\n+\n+void JNICALL VMInit(jvmtiEnv *jvmti, JNIEnv *jni, jthread thr) {\n+  RawMonitorLocker agent_locker(jvmti, jni, agent_lock);\n+\n+  LOG(\">>>    VMInit event\\n\");\n+  if (thread_start_events_vm_start == 0) {\n+    \/\/ wait for at least one thread to start in early VM_START phase\n+    LOG(\">>>    VMInit event: waiting for any ThreadStart event\\n\");\n+    agent_locker.wait(200);\n+  }\n+}\n+\n+static\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jint res, size;\n+  jvmtiCapabilities caps;\n+  jvmtiEventCallbacks callbacks;\n+  jvmtiError err;\n+\n+  res = jvm->GetEnv((void **)(&jvmti), JVMTI_VERSION_9);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    LOG(\"    Error: wrong result of a valid call to GetEnv!\\n\");\n+      return JNI_ERR;\n+  }\n+\n+  LOG(\"Enabling following capability: can_generate_early_vmstart\\n\");\n+  memset(&caps, 0, sizeof(caps));\n+  caps.can_generate_early_vmstart = 1;\n+\n+  err = jvmti->AddCapabilities(&caps);\n+  check_jvmti_error(jvmti->AddCapabilities(&caps), \"AddCapabilities\");\n+\n+  size = (jint)sizeof(callbacks);\n+  memset(&callbacks, 0, sizeof(callbacks));\n+  callbacks.VMInit = VMInit;\n+  callbacks.ThreadStart = ThreadStart;\n+\n+  err = jvmti->SetEventCallbacks(&callbacks, size);\n+  check_jvmti_error(jvmti->AddCapabilities(&caps), \"SetEventCallbacks\");\n+\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL);\n+  check_jvmti_error(jvmti->AddCapabilities(&caps), \"SetEventNotificationMode for VM_INIT\");\n+\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_START, NULL);\n+  check_jvmti_error(jvmti->AddCapabilities(&caps), \"SetEventNotificationMode for THREAD_START\");\n+\n+  agent_lock = create_raw_monitor(jvmti, \"agent_lock\");\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_MAAThreadStart_check(JNIEnv *jni, jclass cls) {\n+  jobject loader = NULL;\n+\n+  RawMonitorLocker agent_locker(jvmti, jni, agent_lock);\n+\n+  if (jvmti == NULL) {\n+    fatal(jni, \"JVMTI client was not properly loaded!\\n\");\n+    return FAILED;\n+  }\n+\n+  \/*\n+   * Expecting that ThreadStart events are sent during VM Start phase when\n+   * can_generate_early_vmstart capability is enabled.\n+   *\/\n+  if (thread_start_events_vm_start == 0) {\n+    fatal(jni, \"Didn't get ThreadStart events in VM early start phase!\\n\");\n+      return FAILED;\n+  }\n+  return PASSED;\n+}\n+\n+} \/\/ extern \"C\"\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/ModuleAwareAgents\/ThreadStart\/libMAAThreadStart.cpp","additions":143,"deletions":0,"binary":false,"changes":143,"status":"added"}]}