{"files":[{"patch":"@@ -131,1 +131,0 @@\n-serviceability\/jvmti\/ModuleAwareAgents\/ThreadStart\/MAAThreadStart.java 8225354 windows-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @summary Verify ThreadStart JVMTI event with can_generate_early_vmstart capability\n- * @requires vm.jvmti\n- * @run main\/othervm\/native -agentlib:MAAThreadStart MAAThreadStart\n- *\/\n-\n-public class MAAThreadStart {\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"MAAThreadStart\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load MAAThreadStart library\");\n-            System.err.println(\"java.library.path: \"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native static int check();\n-\n-    public static void main(String args[]) {\n-        int status = check();\n-        if (status != 0) {\n-            throw new RuntimeException(\"Non-zero status returned from the agent: \" + status);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/ModuleAwareAgents\/ThreadStart\/MAAThreadStart.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -1,177 +0,0 @@\n-\/*\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-#ifndef JNI_ENV_ARG\n-\n-#ifdef __cplusplus\n-#define JNI_ENV_ARG(x, y) y\n-#define JNI_ENV_PTR(x) x\n-#else\n-#define JNI_ENV_ARG(x,y) x, y\n-#define JNI_ENV_PTR(x) (*x)\n-#endif\n-\n-#endif\n-\n-#define TranslateError(err) \"JVMTI error\"\n-\n-#define PASSED 0\n-#define FAILED 2\n-\n-static const char *EXC_CNAME = \"java\/lang\/Exception\";\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-\n-static int thread_start_events_vm_start = 0;\n-\n-static jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved);\n-\n-JNIEXPORT\n-jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-\n-JNIEXPORT\n-jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-\n-JNIEXPORT\n-jint JNICALL JNI_OnLoad(JavaVM *jvm, void *reserved) {\n-    return JNI_VERSION_9;\n-}\n-\n-static\n-jint throw_exc(JNIEnv *env, char *msg) {\n-    jclass exc_class = JNI_ENV_PTR(env)->FindClass(JNI_ENV_ARG(env, EXC_CNAME));\n-\n-    if (exc_class == NULL) {\n-        printf(\"throw_exc: Error in FindClass(env, %s)\\n\", EXC_CNAME);\n-        return -1;\n-    }\n-    return JNI_ENV_PTR(env)->ThrowNew(JNI_ENV_ARG(env, exc_class), msg);\n-}\n-\n-\n-void JNICALL Callback_ThreadStart(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thread) {\n-    jvmtiError err;\n-    jvmtiPhase phase;\n-\n-    err = (*jvmti)->GetPhase(jvmti_env,&phase);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"ThreadStart event: GetPhase error: %s (%d)\\n\", TranslateError(err), err);\n-        result = FAILED;\n-        return;\n-    }\n-\n-    if (phase == JVMTI_PHASE_START) {\n-        thread_start_events_vm_start++;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>>    ThreadStart event: phase(%d)\\n\", phase);\n-    }\n-}\n-\n-static\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jint res, size;\n-    jvmtiCapabilities caps;\n-    jvmtiEventCallbacks callbacks;\n-    jvmtiError err;\n-\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = JNI_ENV_PTR(jvm)->GetEnv(JNI_ENV_ARG(jvm, (void **) &jvmti),\n-        JVMTI_VERSION_9);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"    Error: wrong result of a valid call to GetEnv!\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    printf(\"Enabling following capability: can_generate_early_vmstart\\n\");\n-    memset(&caps, 0, sizeof(caps));\n-    caps.can_generate_early_vmstart = 1;\n-\n-    err = (*jvmti)->AddCapabilities(jvmti, &caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"    Error in AddCapabilites: %s (%d)\\n\", TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    size = (jint)sizeof(callbacks);\n-\n-    memset(&callbacks, 0, sizeof(callbacks));\n-    callbacks.ThreadStart = Callback_ThreadStart;\n-\n-    err = (*jvmti)->SetEventCallbacks(jvmti, &callbacks, size);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"    Error in SetEventCallbacks: %s (%d)\\n\", TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = (*jvmti)->SetEventNotificationMode(jvmti, JVMTI_ENABLE, JVMTI_EVENT_THREAD_START, NULL);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"    Error in SetEventNotificationMode: %s (%d)\\n\", TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_MAAThreadStart_check(JNIEnv *env, jclass cls) {\n-    jobject loader = NULL;\n-\n-    if (jvmti == NULL) {\n-        throw_exc(env, \"JVMTI client was not properly loaded!\\n\");\n-        return FAILED;\n-    }\n-\n-    \/*\n-     * Expecting that ThreadStart events are sent during VM Start phase when\n-     * can_generate_early_vmstart capability is enabled.\n-     *\/\n-    if (thread_start_events_vm_start == 0) {\n-        throw_exc(env, \"Didn't get ThreadStart events in VM early start phase!\\n\");\n-        return FAILED;\n-    }\n-\n-    return result;\n-}\n-\n-#ifdef __cplusplus\n-}\n-#endif\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/ModuleAwareAgents\/ThreadStart\/libMAAThreadStart.c","additions":0,"deletions":177,"binary":false,"changes":177,"status":"deleted"}]}