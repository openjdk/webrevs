{"files":[{"patch":"@@ -284,9 +284,0 @@\n-\/\/ Return true if any of the following is true:\n-\/\/ . the allocation won't fit into the current young gen heap\n-\/\/ . heap memory is tight\n-bool SerialHeap::should_try_older_generation_allocation(size_t word_size) const {\n-  size_t young_capacity = _young_gen->capacity_before_gc();\n-  return    (word_size > heap_word_size(young_capacity))\n-         || _is_heap_almost_full;\n-}\n-\n@@ -311,6 +302,3 @@\n-  \/\/ Loop until the allocation is satisfied, or unsatisfied after GC.\n-  for (uint try_count = 1; \/* return or throw *\/; try_count += 1) {\n-    \/\/ First allocation attempt is lock-free.\n-    DefNewGeneration *young = _young_gen;\n-    if (young->should_allocate(size, is_tlab)) {\n-      result = young->par_allocate(size);\n+  for (uint try_count = 1; \/* break *\/; try_count++) {\n+    if (_young_gen->should_allocate(size, is_tlab)) {\n+      result = _young_gen->par_allocate(size);\n@@ -318,2 +306,11 @@\n-        assert(is_in_reserved(result), \"result not in heap\");\n-        return result;\n+        break;\n+      }\n+    }\n+    \/\/ Try old-gen allocation for non-TLAB.\n+    if (!is_tlab) {\n+      \/\/ If it's too large for young-gen or heap is too full.\n+      if (size > heap_word_size(_young_gen->capacity_before_gc()) || _is_heap_almost_full) {\n+        result = _old_gen->par_allocate(size);\n+        if (result != nullptr) {\n+          break;\n+        }\n@@ -325,12 +322,0 @@\n-      log_trace(gc, alloc)(\"SerialHeap::mem_allocate_work: attempting locked slow path allocation\");\n-      \/\/ Note that only large objects get a shot at being\n-      \/\/ allocated in later generations.\n-      bool first_only = !should_try_older_generation_allocation(size);\n-\n-      result = attempt_allocation(size, is_tlab, first_only);\n-      if (result != nullptr) {\n-        assert(is_in_reserved(result), \"result not in heap\");\n-        return result;\n-      }\n-\n-      \/\/ Read the gc count while the heap lock is held.\n@@ -344,4 +329,1 @@\n-\n-      assert(result == nullptr || is_in_reserved(result),\n-             \"result not in heap\");\n-      return result;\n+      break;\n@@ -357,0 +339,3 @@\n+\n+  assert(result == nullptr || is_in_reserved(result), \"postcondition\");\n+  return result;\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":18,"deletions":33,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -232,4 +232,0 @@\n-  \/\/ Return true if an allocation should be attempted in the older generation\n-  \/\/ if it fails in the younger generation.  Return false, otherwise.\n-  bool should_try_older_generation_allocation(size_t word_size) const;\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -129,0 +129,2 @@\n+  \/\/ Multi-threaded version.\n+  inline HeapWord* par_allocate(size_t word_size);\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,0 +60,8 @@\n+HeapWord* TenuredGeneration::par_allocate(size_t word_size) {\n+  HeapWord* res = _the_space->par_allocate(word_size);\n+  if (res != nullptr) {\n+    _bts->update_for_block(res, res + word_size);\n+  }\n+  return res;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.inline.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"}]}