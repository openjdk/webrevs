{"files":[{"patch":"@@ -814,1 +814,1 @@\n-            if (getColorSpaceType(p) == ColorSpace.TYPE_GRAY\n+            if (getColorSpaceType(data) == ColorSpace.TYPE_GRAY\n@@ -819,1 +819,1 @@\n-            if (getColorSpaceType(p) == ColorSpace.TYPE_RGB\n+            if (getColorSpaceType(data) == ColorSpace.TYPE_RGB\n@@ -1031,7 +1031,2 @@\n-        return getColorSpaceType(cmmProfile());\n-    }\n-\n-    private static int getColorSpaceType(Profile p) {\n-        byte[] theHeader = getData(p, icSigHead);\n-        int theColorSpaceSig = intFromBigEndian(theHeader, icHdrColorSpace);\n-        return iccCStoJCS(theColorSpaceSig);\n+        byte[] theHeader = getData(cmmProfile(), icSigHead);\n+        return getColorSpaceType(theHeader);\n@@ -1060,2 +1055,1 @@\n-        int thePCSSig = intFromBigEndian(theHeader, icHdrPcs);\n-        return iccCStoJCS(thePCSSig);\n+        return getPCSType(theHeader);\n@@ -1192,1 +1186,1 @@\n-    private static boolean checkRenderingIntent(byte[] header) {\n+    private static void checkRenderingIntent(byte[] header) {\n@@ -1194,5 +1188,4 @@\n-\n-        \/* According to ICC spec, only the least-significant 16 bits shall be\n-         * used to encode the rendering intent. The most significant 16 bits\n-         * shall be set to zero. Thus, we are ignoring two most significant\n-         * bytes here. Please refer ICC Spec Document for more details.\n+        \/*\n+         * ICC spec: only the least-significant 16 bits encode the rendering\n+         * intent. The most significant 16 bits must be zero and can be ignored.\n+         * https:\/\/www.color.org\/specification\/ICC.1-2022-05.pdf, section 7.2.15\n@@ -1200,9 +1193,6 @@\n-        int renderingIntent = ((header[index+2] & 0xff) <<  8) |\n-                              (header[index+3] & 0xff);\n-\n-        switch (renderingIntent) {\n-            case icPerceptual, icMediaRelativeColorimetric,\n-                    icSaturation, icAbsoluteColorimetric -> {\n-                return true;\n-            }\n-            default -> throw new IllegalArgumentException(\"Unknown Rendering Intent\");\n+        \/\/ Extract 16-bit unsigned rendering intent (0â€“65535)\n+        int intent = (header[index + 2] & 0xff) << 8 | header[index + 3] & 0xff;\n+        \/\/ Only check upper bound since intent can't be negative\n+        if (intent > icICCAbsoluteColorimetric) {\n+            throw new IllegalArgumentException(\n+                    \"Unknown Rendering Intent: %d\".formatted(intent));\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ICC_Profile.java","additions":16,"deletions":26,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -687,7 +687,4 @@\n-\n-        \/* According to ICC spec, only the least-significant 16 bits shall be\n-         * used to encode the rendering intent. The most significant 16 bits\n-         * shall be set to zero. Thus, we are ignoring two most significant\n-         * bytes here.\n-         *\n-         *  See https:\/\/www.color.org\/ICC1v42_2006-05.pdf, section 7.2.15.\n+        \/*\n+         * ICC spec: only the least-significant 16 bits encode the rendering\n+         * intent. The most significant 16 bits must be zero and can be ignored.\n+         * https:\/\/www.color.org\/specification\/ICC.1-2022-05.pdf, section 7.2.15\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/image\/ColorConvertOp.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.color.ColorSpace;\n+import java.awt.color.ICC_Profile;\n+\n+import static java.awt.color.ICC_Profile.icAbsoluteColorimetric;\n+import static java.awt.color.ICC_Profile.icICCAbsoluteColorimetric;\n+import static java.awt.color.ICC_Profile.icMediaRelativeColorimetric;\n+import static java.awt.color.ICC_Profile.icPerceptual;\n+import static java.awt.color.ICC_Profile.icRelativeColorimetric;\n+import static java.awt.color.ICC_Profile.icSaturation;\n+\n+\/**\n+ * @test\n+ * @bug 8358057\n+ * @summary Stress test for ICC_Profile rendering intent parsing and validation\n+ *\/\n+public final class RenderingIntentStressTest {\n+\n+    public static void main(String[] args) {\n+        ICC_Profile builtin = ICC_Profile.getInstance(ColorSpace.CS_sRGB);\n+        ICC_Profile profile = ICC_Profile.getInstance(builtin.getData());\n+        \/\/ some random combinations that should be ignored\n+        int[] upperBytes = {0x0000, 0xFFFF, 0xA5A5, 0x8000, 0x0001, 0x8080,\n+                            0x0101, 0xAA55, 0x550A, 0xFF00};\n+        for (int up : upperBytes) {\n+            for (int low = 0; low <= 0xFFFF; low++) {\n+                test(profile, up, low);\n+            }\n+        }\n+    }\n+\n+    private static int getRenderingIntent(byte[] header) {\n+        \/\/ replicate the logic we have in jdk\n+        int index = ICC_Profile.icHdrRenderingIntent;\n+        return (header[index + 2] & 0xff) << 8 | header[index + 3] & 0xff;\n+    }\n+\n+    private static void test(ICC_Profile profile, int up, int low) {\n+        byte[] header = profile.getData(ICC_Profile.icSigHead);\n+        \/\/ These bytes should be ignored\n+        header[ICC_Profile.icHdrRenderingIntent + 0] = (byte) (up >> 8 & 0xFF);\n+        header[ICC_Profile.icHdrRenderingIntent + 1] = (byte) (up & 0xFF);\n+        \/\/ This is the actual intent\n+        header[ICC_Profile.icHdrRenderingIntent + 2] = (byte) (low >> 8 & 0xFF);\n+        header[ICC_Profile.icHdrRenderingIntent + 3] = (byte) (low & 0xFF);\n+\n+        boolean isValid = isValidIntent(low);\n+        try {\n+            profile.setData(ICC_Profile.icSigHead, header);\n+            if (!isValid) {\n+                throw new RuntimeException(\"IAE is expected\");\n+            }\n+        } catch (IllegalArgumentException e) {\n+            if (isValid) {\n+                throw e;\n+            }\n+            return;\n+        }\n+        \/\/ verify that the intent is correctly stored in the profile by the CMM\n+        byte[] data = profile.getData(ICC_Profile.icSigHead);\n+        int actualIntent = getRenderingIntent(data);\n+        if (actualIntent != low) {\n+            System.out.println(\"Expected: \" + low);\n+            System.out.println(\"Actual: \" + actualIntent);\n+            throw new RuntimeException(\"Unexpected intent\");\n+        }\n+    }\n+\n+    private static boolean isValidIntent(int intent) {\n+        return intent == icPerceptual || intent == icRelativeColorimetric\n+                || intent == icMediaRelativeColorimetric\n+                || intent == icSaturation || intent == icAbsoluteColorimetric\n+                || intent == icICCAbsoluteColorimetric;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/RenderingIntentStressTest.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8337703\n+ * @bug 8337703 8347377 8358057\n@@ -147,3 +147,1 @@\n-        \/\/valid rendering intent values are 0-3\n-        int invalidRenderIntent = 5;\n-        testInvalidHeaderData(invalidRenderIntent, RENDER_INTENT_START_INDEX, 4);\n+        testInvalidIntent();\n@@ -190,0 +188,15 @@\n+    private static void testInvalidIntent() {\n+        \/\/valid rendering intent values are 0-3\n+        int invalidRenderIntent = 5;\n+        try {\n+            setTag(invalidRenderIntent, RENDER_INTENT_START_INDEX, 4);\n+            throw new RuntimeException(\"Test Failed ! Expected IAE NOT thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            String message = iae.getMessage();\n+            System.out.println(\"Expected IAE thrown: \" + message);\n+            if (!message.contains(\": \" + invalidRenderIntent)) {\n+                throw new RuntimeException(\"Test Failed ! Unexpected text\");\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/ValidateICCHeaderData\/ValidateICCHeaderData.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"}]}