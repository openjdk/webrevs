{"files":[{"patch":"@@ -144,1 +144,0 @@\n-java\/awt\/Frame\/ShapeNotSetSometimes\/ShapeNotSetSometimes.java 8144030 macosx-all,linux-all\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,3 +34,10 @@\n-import java.awt.*;\n-import java.awt.event.InputEvent;\n-import java.awt.geom.*;\n+import java.awt.Color;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.geom.Area;\n+import java.awt.geom.Ellipse2D;\n+import java.awt.geom.Rectangle2D;\n@@ -43,3 +50,7 @@\n-    private static final Color BACKGROUND_COLOR = Color.BLUE;\n-    private Shape shape;\n-    private int[][] pointsToCheck;\n+    private static final Color BACKGROUND_COLOR = Color.GREEN;\n+    private static final Color SHAPE_COLOR = Color.WHITE;\n+    private Point[] pointsOutsideToCheck;\n+    private Point[] shadedPointsToCheck;\n+    private Point innerPoint;\n+\n+    private final Rectangle bounds = new Rectangle(220, 400, 300, 300);\n@@ -57,2 +68,1 @@\n-        backgroundFrame.setSize(300, 300);\n-        backgroundFrame.setLocation(20, 400);\n+        backgroundFrame.setBounds(bounds);\n@@ -61,20 +71,20 @@\n-        shape = null;\n-        String shape_name = null;\n-        Area a;\n-        GeneralPath gp;\n-        shape_name = \"Rounded-corners\";\n-        a = new Area();\n-        a.add(new Area(new Rectangle2D.Float(50, 0, 100, 150)));\n-        a.add(new Area(new Rectangle2D.Float(0, 50, 200, 50)));\n-        a.add(new Area(new Ellipse2D.Float(0, 0, 100, 100)));\n-        a.add(new Area(new Ellipse2D.Float(0, 50, 100, 100)));\n-        a.add(new Area(new Ellipse2D.Float(100, 0, 100, 100)));\n-        a.add(new Area(new Ellipse2D.Float(100, 50, 100, 100)));\n-        shape = a;\n-        pointsToCheck = new int[][] {\n-            \/\/ inside shape\n-            {106, 86}, {96, 38}, {76, 107}, {180, 25}, {24, 105},\n-            {196, 77}, {165, 50}, {14, 113}, {89, 132}, {167, 117},\n-            \/\/ outside shape\n-            {165, 196}, {191, 163}, {146, 185}, {61, 170}, {148, 171},\n-            {82, 172}, {186, 11}, {199, 141}, {13, 173}, {187, 3}\n+        Area area = new Area();\n+        area.add(new Area(new Rectangle2D.Float(100, 50, 100, 150)));\n+        area.add(new Area(new Rectangle2D.Float(50, 100, 200, 50)));\n+        area.add(new Area(new Ellipse2D.Float(50, 50, 100, 100)));\n+        area.add(new Area(new Ellipse2D.Float(50, 100, 100, 100)));\n+        area.add(new Area(new Ellipse2D.Float(150, 50, 100, 100)));\n+        area.add(new Area(new Ellipse2D.Float(150, 100, 100, 100)));\n+\n+\n+        innerPoint = new Point(150, 130);\n+        pointsOutsideToCheck = new Point[] {\n+                new Point(150, 20),\n+                new Point(280, 120),\n+                new Point(150, 250),\n+                new Point(20, 120)\n+        };\n+\n+        shadedPointsToCheck = new Point[] {\n+                new Point(62, 62),\n+                new Point(240, 185)\n@@ -85,3 +95,2 @@\n-        window.setSize(200, 200);\n-        window.setLocation(70, 450);\n-        window.setShape(shape);\n+        window.setBounds(bounds);\n+        window.setShape(area);\n@@ -89,2 +98,0 @@\n-\n-        System.out.println(\"Checking \" + window.getClass().getSuperclass().getName() + \" with \" + shape_name + \" shape (\" + window.getShape() + \")...\");\n@@ -93,1 +100,1 @@\n-    class BackgroundFrame extends Frame {\n+    static class BackgroundFrame extends Frame {\n@@ -110,2 +117,2 @@\n-            g.setColor(Color.WHITE);\n-            g.fillRect(0, 0, 200, 200);\n+            g.setColor(SHAPE_COLOR);\n+            g.fillRect(0, 0, bounds.width, bounds.height);\n@@ -127,1 +134,2 @@\n-        Point wls = backgroundFrame.getLocationOnScreen();\n+        EventQueue.invokeAndWait(backgroundFrame::toFront);\n+        robot.waitForIdle();\n@@ -129,5 +137,2 @@\n-        robot.mouseMove(wls.x + 5, wls.y + 5);\n-        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n-        robot.delay(10);\n-        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n-        robot.delay(500);\n+        EventQueue.invokeAndWait(window::toFront);\n+        robot.waitForIdle();\n@@ -135,1 +140,1 @@\n-        EventQueue.invokeAndWait(window::requestFocus);\n+        robot.delay(500);\n@@ -137,1 +142,0 @@\n-        robot.waitForIdle();\n@@ -139,4 +143,1 @@\n-            Thread.sleep(300);\n-        } catch (InterruptedException e) {\n-            \/\/ ignore this one\n-        }\n+            colorCheck(innerPoint.x, innerPoint.y, SHAPE_COLOR, true);\n@@ -144,17 +145,2 @@\n-        \/\/ check transparency\n-        final int COUNT_TARGET = 10;\n-\n-        \/\/ checking outside points only\n-        for(int i = COUNT_TARGET; i < COUNT_TARGET * 2; i++) {\n-            int x = pointsToCheck[i][0];\n-            int y = pointsToCheck[i][1];\n-            boolean inside = i < COUNT_TARGET;\n-            Color c = robot.getPixelColor(window.getX() + x, window.getY() + y);\n-            System.out.println(\"checking \" + x + \", \" + y + \", color = \" + c);\n-            if (inside && BACKGROUND_COLOR.equals(c) || !inside && !BACKGROUND_COLOR.equals(c)) {\n-                System.out.println(\"window.getX() = \" + window.getX() + \", window.getY() = \" + window.getY());\n-                System.err.println(\"Checking for transparency failed: point: \" +\n-                        (window.getX() + x) + \", \" + (window.getY() + y) +\n-                        \", color = \" + c + (inside ? \" is of un\" : \" is not of \") +\n-                        \"expected background color \" + BACKGROUND_COLOR);\n-                throw new RuntimeException(\"Test failed. The shape has not been applied.\");\n+            for (Point point : pointsOutsideToCheck) {\n+                colorCheck(point.x, point.y, BACKGROUND_COLOR, true);\n@@ -162,1 +148,0 @@\n-        }\n@@ -164,2 +149,5 @@\n-        EventQueue.invokeAndWait(new Runnable() {\n-            public void run() {\n+            for (Point point : shadedPointsToCheck) {\n+                colorCheck(point.x, point.y, SHAPE_COLOR, false);\n+            }\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n@@ -168,2 +156,31 @@\n-            }\n-        });\n+            });\n+        }\n+    }\n+\n+    private void colorCheck(int x, int y, Color expectedColor, boolean mustBeExpectedColor) {\n+\n+        int screenX = window.getX() + x;\n+        int screenY = window.getY() + y;\n+\n+        Color actualColor = robot.getPixelColor(screenX, screenY);\n+\n+        System.out.printf(\n+                \"Checking %3d, %3d, %35s should %sbe %35s\\n\",\n+                x, y,\n+                actualColor,\n+                (mustBeExpectedColor) ? \"\" : \"not \",\n+                expectedColor\n+        );\n+\n+        if (mustBeExpectedColor != expectedColor.equals(actualColor)) {\n+            System.out.printf(\"window.getX() = %3d, window.getY() = %3d\\n\", window.getX(), window.getY());\n+\n+            System.err.printf(\n+                    \"Checking for transparency failed: point: %3d, %3d\\n\\tactual    %s\\n\\texpected %s%s\\n\",\n+                    screenX,\n+                    screenY,\n+                    actualColor,\n+                    mustBeExpectedColor ? \"\" : \"not \",\n+                    expectedColor);\n+            throw new RuntimeException(\"Test failed. The shape has not been applied.\");\n+        }\n","filename":"test\/jdk\/java\/awt\/Frame\/ShapeNotSetSometimes\/ShapeNotSetSometimes.java","additions":88,"deletions":71,"binary":false,"changes":159,"status":"modified"}]}