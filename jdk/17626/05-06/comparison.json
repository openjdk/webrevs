{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -319,1 +319,2 @@\n-  \/\/ The monitor is private to locking_thread which must be suspended. So this code may only contend with deflation.\n+  \/\/ The monitor is private to or already owned by locking_thread which must be suspended.\n+  \/\/ So this code may only contend with deflation.\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -508,3 +508,1 @@\n-\/\/ The interpreter and compiler assembly code tries to lock using the fast path\n-\/\/ of this algorithm. Make sure to update that code if the following function is\n-\/\/ changed. The implementation is extremely sensitive to race condition. Be careful.\n+\n@@ -550,0 +548,3 @@\n+\/\/ The interpreter and compiler assembly code tries to lock using the fast path\n+\/\/ of this algorithm. Make sure to update that code if the following function is\n+\/\/ changed. The implementation is extremely sensitive to race condition. Be careful.\n@@ -1339,3 +1340,3 @@\n-ObjectMonitor* ObjectSynchronizer::inflate_impl(JavaThread* thread, oop object, const InflateCause cause) {\n-  \/\/ The JavaThread* thread parameter is only used by LM_LIGHTWEIGHT and requires\n-  \/\/ that the thread == Thread::current() or is suspended throughout the call by\n+ObjectMonitor* ObjectSynchronizer::inflate_impl(JavaThread* inflating_thread, oop object, const InflateCause cause) {\n+  \/\/ The JavaThread* inflating_thread parameter is only used by LM_LIGHTWEIGHT and requires\n+  \/\/ that the inflating_thread == Thread::current() or is suspended throughout the call by\n@@ -1347,1 +1348,1 @@\n-  \/\/ ObjectSynchronizer::enter_for from any thread, or ObjectSynchronizer::exit\n+  \/\/ ObjectSynchronizer::enter_for from any thread, or ObjectSynchronizer::exit.\n@@ -1356,3 +1357,4 @@\n-    \/\/                   is anonymous and the thread owns the object lock,\n-    \/\/                   then we make the thread the ObjectMonitor owner\n-    \/\/                   and remove the lock from the thread's lock stack.\n+    \/\/                   is anonymous and the inflating_thread owns the\n+    \/\/                   object lock, then we make the inflating_thread\n+    \/\/                   the ObjectMonitor owner and remove the lock from\n+    \/\/                   the inflating_thread's lock stack.\n@@ -1371,3 +1373,3 @@\n-          thread != nullptr && thread->lock_stack().contains(object)) {\n-        inf->set_owner_from_anonymous(thread);\n-        thread->lock_stack().remove(object);\n+          inflating_thread != nullptr && inflating_thread->lock_stack().contains(object)) {\n+        inf->set_owner_from_anonymous(inflating_thread);\n+        inflating_thread->lock_stack().remove(object);\n@@ -1393,1 +1395,1 @@\n-    \/\/ Could be fast-locked either by the thread or by some other thread.\n+    \/\/ Could be fast-locked either by the inflating_thread or by some other thread.\n@@ -1397,2 +1399,2 @@\n-    \/\/ this thread owns the monitor, then we set the ObjectMonitor's\n-    \/\/ owner to this thread. Otherwise, we set the ObjectMonitor's owner\n+    \/\/ the inflating_thread owns the monitor, then we set the ObjectMonitor's\n+    \/\/ owner to the inflating_thread. Otherwise, we set the ObjectMonitor's owner\n@@ -1406,1 +1408,1 @@\n-      bool own = thread != nullptr && thread->lock_stack().contains(object);\n+      bool own = inflating_thread != nullptr && inflating_thread->lock_stack().contains(object);\n@@ -1409,1 +1411,1 @@\n-        monitor->set_owner_from(nullptr, thread);\n+        monitor->set_owner_from(nullptr, inflating_thread);\n@@ -1419,1 +1421,1 @@\n-          thread->lock_stack().remove(object);\n+          inflating_thread->lock_stack().remove(object);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":22,"deletions":20,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,2 +104,2 @@\n-  \/\/ Shared implementation for enter and enter_for. Preforms all but\n-  \/\/ inflated monitor enter\n+  \/\/ Shared implementation for enter and enter_for. Performs all but\n+  \/\/ inflated monitor enter.\n@@ -124,1 +124,1 @@\n-  \/\/ Used inflate a monitor as if it was done from the thread JavaThread.\n+  \/\/ Used to inflate a monitor as if it was done from the thread JavaThread.\n@@ -128,1 +128,1 @@\n-  \/\/ Shared implementation between the different LockingMode\n+  \/\/ Shared implementation between the different LockingMode.\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -147,2 +147,4 @@\n- *                 -XX:LockingMode=0\n- *                 -Xlog:monitorinflation=trace\n+ *                 -XX:LockingMode=2\n+ *                 -Xlog:monitorinflation=trace:file=monitorinflation.log\n+ *\n+ * @comment Re-lock may race with deflation.\n@@ -157,2 +159,2 @@\n- *                 -XX:LockingMode=2\n- *                 -Xlog:monitorinflation=trace\n+ *                 -XX:LockingMode=0\n+ *                 -XX:GuaranteedAsyncDeflationInterval=1000\n@@ -293,0 +295,1 @@\n+        new EARelockingNestedInflated_03Target()                                            .run();\n@@ -416,0 +419,1 @@\n+        new EARelockingNestedInflated_03()                                            .run(this);\n@@ -1968,0 +1972,68 @@\n+\/**\n+ * Like {@link EARelockingNestedInflated_02} with the difference that the\n+ * inflation of the lock happens because of contention.\n+ *\/\n+class EARelockingNestedInflated_03 extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        @SuppressWarnings(\"unused\")\n+        ObjectReference o = getLocalRef(bpe.thread().frame(2), XYVAL_NAME, \"l1\");\n+    }\n+}\n+\n+class EARelockingNestedInflated_03Target extends EATestCaseBaseTarget {\n+\n+    public XYVal lockInflatedByContention;\n+    public volatile boolean doLockNow;\n+\n+    @Override\n+    public void setUp() {\n+        super.setUp();\n+        testMethodDepth = 2;\n+        lockInflatedByContention = new XYVal(1, 1);\n+        Thread contendingThread = DebuggeeWrapper.newThread(() -> {\n+            while(!doLockNow) {\n+                try {\n+                    Thread.sleep(10);\n+                } catch (InterruptedException e) { \/* ignored *\/ }\n+            }\n+            doLockNow = false; \/\/ reset for main thread\n+            synchronized(lockInflatedByContention) { \/\/ will block and trigger inflation\n+                msg(Thread.currentThread().getName() + \": acquired lockInflatedByContention\");\n+            }\n+            }, testCaseName + \": Lock Contender (test thread)\");\n+        contendingThread.setDaemon(true);\n+        contendingThread.start();\n+    }\n+\n+    public void dontinline_testMethod() {\n+        @SuppressWarnings(\"unused\")\n+        XYVal xy = new XYVal(1, 1);            \/\/ scalar replaced\n+        XYVal l1 = lockInflatedByContention;   \/\/ read by debugger\n+        synchronized (l1) {\n+            testMethod_inlined(l1);\n+        }\n+    }\n+\n+    public void testMethod_inlined(XYVal l2) {\n+        synchronized (l2) {                 \/\/ eliminated nested locking\n+            dontinline_setDoLockNow();\n+            dontinline_brkpt();\n+        }\n+    }\n+\n+    public void dontinline_setDoLockNow() {\n+        doLockNow = warmupDone;\n+        \/\/ wait for other thread to reset doLockNow\n+        while(doLockNow) {\n+            try {\n+                Thread.sleep(10);\n+            } catch (InterruptedException e) { \/* ignored *\/ }\n+        }\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n","filename":"test\/jdk\/com\/sun\/jdi\/EATests.java","additions":76,"deletions":4,"binary":false,"changes":80,"status":"modified"}]}