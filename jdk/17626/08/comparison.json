{"files":[{"patch":"@@ -1649,1 +1649,1 @@\n-          ObjectSynchronizer::enter(obj, nullptr, deoptee_thread);\n+          ObjectSynchronizer::enter_for(obj, nullptr, deoptee_thread);\n@@ -1651,1 +1651,1 @@\n-          ObjectMonitor* mon = ObjectSynchronizer::inflate(deoptee_thread, obj(), ObjectSynchronizer::inflate_cause_vm_internal);\n+          ObjectMonitor* mon = ObjectSynchronizer::inflate_for(deoptee_thread, obj(), ObjectSynchronizer::inflate_cause_vm_internal);\n@@ -1655,1 +1655,1 @@\n-          ObjectSynchronizer::enter(obj, lock, deoptee_thread);\n+          ObjectSynchronizer::enter_for(obj, lock, deoptee_thread);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -56,0 +57,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -315,0 +317,62 @@\n+bool ObjectMonitor::enter_for(JavaThread* locking_thread) {\n+  \/\/ Used by ObjectSynchronizer::enter_for to enter for another thread.\n+  \/\/ The monitor is private to or already owned by locking_thread which must be suspended.\n+  \/\/ So this code may only contend with deflation.\n+  assert(locking_thread == Thread::current() || locking_thread->is_obj_deopt_suspend(), \"must be\");\n+\n+  \/\/ Block out deflation as soon as possible.\n+  add_to_contentions(1);\n+\n+  bool success = false;\n+  if (!is_being_async_deflated()) {\n+    void* prev_owner = try_set_owner_from(nullptr, locking_thread);\n+\n+    if (prev_owner == nullptr) {\n+      assert(_recursions == 0, \"invariant\");\n+      success = true;\n+    } else if (prev_owner == locking_thread) {\n+      _recursions++;\n+      success = true;\n+    } else if (prev_owner == DEFLATER_MARKER) {\n+      \/\/ Racing with deflation.\n+      prev_owner = try_set_owner_from(DEFLATER_MARKER, locking_thread);\n+      if (prev_owner == DEFLATER_MARKER) {\n+        \/\/ Cancelled deflation. Increment contentions as part of the deflation protocol.\n+        add_to_contentions(1);\n+        success = true;\n+      } else if (prev_owner == nullptr) {\n+        \/\/ At this point we cannot race with deflation as we have both incremented\n+        \/\/ contentions, seen contention > 0 and seen a DEFLATER_MARKER.\n+        \/\/ success will only be false if this races with something other than\n+        \/\/ deflation.\n+        prev_owner = try_set_owner_from(nullptr, locking_thread);\n+        success = prev_owner == nullptr;\n+      }\n+    } else if (LockingMode == LM_LEGACY && locking_thread->is_lock_owned((address)prev_owner)) {\n+      assert(_recursions == 0, \"must be\");\n+      _recursions = 1;\n+      set_owner_from_BasicLock(prev_owner, locking_thread);\n+      success = true;\n+    }\n+    assert(success, \"Failed to enter_for: locking_thread=\" INTPTR_FORMAT\n+           \", this=\" INTPTR_FORMAT \"{owner=\" INTPTR_FORMAT \"}, observed owner: \" INTPTR_FORMAT,\n+           p2i(locking_thread), p2i(this), p2i(owner_raw()), p2i(prev_owner));\n+  } else {\n+    \/\/ Async deflation is in progress and our contentions increment\n+    \/\/ above lost the race to async deflation. Undo the work and\n+    \/\/ force the caller to retry.\n+    const oop l_object = object();\n+    if (l_object != nullptr) {\n+      \/\/ Attempt to restore the header\/dmw to the object's header so that\n+      \/\/ we only retry once if the deflater thread happens to be slow.\n+      install_displaced_markword_in_object(l_object);\n+    }\n+  }\n+\n+  add_to_contentions(-1);\n+\n+  assert(!success || owner_raw() == locking_thread, \"must be\");\n+\n+  return success;\n+}\n+\n@@ -316,0 +380,1 @@\n+  assert(current == JavaThread::current(), \"must be\");\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":66,"deletions":1,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -332,0 +332,1 @@\n+  bool      enter_for(JavaThread* locking_thread);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -63,0 +64,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -447,2 +449,3 @@\n-void ObjectSynchronizer::handle_sync_on_value_based_class(Handle obj, JavaThread* current) {\n-  frame last_frame = current->last_frame();\n+void ObjectSynchronizer::handle_sync_on_value_based_class(Handle obj, JavaThread* locking_thread) {\n+  assert(locking_thread == Thread::current() || locking_thread->is_obj_deopt_suspend(), \"must be\");\n+  frame last_frame = locking_thread->last_frame();\n@@ -461,1 +464,1 @@\n-    ResourceMark rm(current);\n+    ResourceMark rm;\n@@ -463,1 +466,1 @@\n-    current->print_active_stack_on(&ss);\n+    locking_thread->print_active_stack_on(&ss);\n@@ -472,1 +475,1 @@\n-    ResourceMark rm(current);\n+    ResourceMark rm;\n@@ -476,1 +479,1 @@\n-    if (current->has_last_Java_frame()) {\n+    if (locking_thread->has_last_Java_frame()) {\n@@ -478,1 +481,1 @@\n-      current->print_active_stack_on(&info_stream);\n+      locking_thread->print_active_stack_on(&info_stream);\n@@ -505,0 +508,39 @@\n+\n+void ObjectSynchronizer::enter_for(Handle obj, BasicLock* lock, JavaThread* locking_thread) {\n+  \/\/ When called with locking_thread != Thread::current() some mechanism must synchronize\n+  \/\/ the locking_thread with respect to the current thread. Currently only used when\n+  \/\/ deoptimizing and re-locking locks. See Deoptimization::relock_objects\n+  assert(locking_thread == Thread::current() || locking_thread->is_obj_deopt_suspend(), \"must be\");\n+  if (!enter_fast_impl(obj, lock, locking_thread)) {\n+    \/\/ Inflated ObjectMonitor::enter_for is required\n+\n+    \/\/ An async deflation can race after the inflate_for() call and before\n+    \/\/ enter() can make the ObjectMonitor busy. enter_for() returns false if\n+    \/\/ we have lost the race to async deflation and we simply try again.\n+    while (true) {\n+      ObjectMonitor* monitor = inflate_for(locking_thread, obj(), inflate_cause_monitor_enter);\n+      if (monitor->enter_for(locking_thread)) {\n+        return;\n+      }\n+      assert(monitor->is_being_async_deflated(), \"must be\");\n+    }\n+  }\n+}\n+\n+void ObjectSynchronizer::enter(Handle obj, BasicLock* lock, JavaThread* current) {\n+  assert(current == Thread::current(), \"must be\");\n+  if (!enter_fast_impl(obj, lock, current)) {\n+    \/\/ Inflated ObjectMonitor::enter is required\n+\n+    \/\/ An async deflation can race after the inflate() call and before\n+    \/\/ enter() can make the ObjectMonitor busy. enter() returns false if\n+    \/\/ we have lost the race to async deflation and we simply try again.\n+    while (true) {\n+      ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_monitor_enter);\n+      if (monitor->enter(current)) {\n+        return;\n+      }\n+    }\n+  }\n+}\n+\n@@ -508,0 +550,1 @@\n+bool ObjectSynchronizer::enter_fast_impl(Handle obj, BasicLock* lock, JavaThread* locking_thread) {\n@@ -509,1 +552,0 @@\n-void ObjectSynchronizer::enter(Handle obj, BasicLock* lock, JavaThread* current) {\n@@ -511,1 +553,1 @@\n-    handle_sync_on_value_based_class(obj, current);\n+    handle_sync_on_value_based_class(obj, locking_thread);\n@@ -514,1 +556,1 @@\n-  current->inc_held_monitor_count();\n+  locking_thread->inc_held_monitor_count();\n@@ -519,1 +561,1 @@\n-      LockStack& lock_stack = current->lock_stack();\n+      LockStack& lock_stack = locking_thread->lock_stack();\n@@ -531,1 +573,1 @@\n-            return;\n+            return true;\n@@ -544,1 +586,1 @@\n-          return;\n+          return true;\n@@ -548,1 +590,1 @@\n-                 current->is_lock_owned((address) mark.locker())) {\n+                 locking_thread->is_lock_owned((address) mark.locker())) {\n@@ -552,1 +594,1 @@\n-        return;\n+        return true;\n@@ -565,9 +607,1 @@\n-  \/\/ An async deflation can race after the inflate() call and before\n-  \/\/ enter() can make the ObjectMonitor busy. enter() returns false if\n-  \/\/ we have lost the race to async deflation and we simply try again.\n-  while (true) {\n-    ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_monitor_enter);\n-    if (monitor->enter(current)) {\n-      return;\n-    }\n-  }\n+  return false;\n@@ -1292,5 +1326,11 @@\n-\/\/ Can be called from non JavaThreads (e.g., VMThread) for FastHashCode\n-\/\/ calculations as part of JVM\/TI tagging.\n-static bool is_lock_owned(Thread* thread, oop obj) {\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"only call this with new lightweight locking enabled\");\n-  return thread->is_Java_thread() ? JavaThread::cast(thread)->lock_stack().contains(obj) : false;\n+ObjectMonitor* ObjectSynchronizer::inflate(Thread* current, oop obj, const InflateCause cause) {\n+  assert(current == Thread::current(), \"must be\");\n+  if (LockingMode == LM_LIGHTWEIGHT && current->is_Java_thread()) {\n+    return inflate_impl(JavaThread::cast(current), obj, cause);\n+  }\n+  return inflate_impl(nullptr, obj, cause);\n+}\n+\n+ObjectMonitor* ObjectSynchronizer::inflate_for(JavaThread* thread, oop obj, const InflateCause cause) {\n+  assert(thread == Thread::current() || thread->is_obj_deopt_suspend(), \"must be\");\n+  return inflate_impl(thread, obj, cause);\n@@ -1299,2 +1339,9 @@\n-ObjectMonitor* ObjectSynchronizer::inflate(Thread* current, oop object,\n-                                           const InflateCause cause) {\n+ObjectMonitor* ObjectSynchronizer::inflate_impl(JavaThread* inflating_thread, oop object, const InflateCause cause) {\n+  \/\/ The JavaThread* inflating_thread parameter is only used by LM_LIGHTWEIGHT and requires\n+  \/\/ that the inflating_thread == Thread::current() or is suspended throughout the call by\n+  \/\/ some other mechanism.\n+  \/\/ Even with LM_LIGHTWEIGHT the thread might be nullptr when called from a non\n+  \/\/ JavaThread. (As may still be the case from FastHashCode). However it is only\n+  \/\/ important for the correctness of the LM_LIGHTWEIGHT algorithm that the thread\n+  \/\/ is set when called from ObjectSynchronizer::enter from the owning thread,\n+  \/\/ ObjectSynchronizer::enter_for from any thread, or ObjectSynchronizer::exit.\n@@ -1309,4 +1356,4 @@\n-    \/\/                   is anonymous and the current thread owns the\n-    \/\/                   object lock, then we make the current thread the\n-    \/\/                   ObjectMonitor owner and remove the lock from the\n-    \/\/                   current thread's lock stack.\n+    \/\/                   is anonymous and the inflating_thread owns the\n+    \/\/                   object lock, then we make the inflating_thread\n+    \/\/                   the ObjectMonitor owner and remove the lock from\n+    \/\/                   the inflating_thread's lock stack.\n@@ -1324,3 +1371,4 @@\n-      if (LockingMode == LM_LIGHTWEIGHT && inf->is_owner_anonymous() && is_lock_owned(current, object)) {\n-        inf->set_owner_from_anonymous(current);\n-        JavaThread::cast(current)->lock_stack().remove(object);\n+      if (LockingMode == LM_LIGHTWEIGHT && inf->is_owner_anonymous() &&\n+          inflating_thread != nullptr && inflating_thread->lock_stack().contains(object)) {\n+        inf->set_owner_from_anonymous(inflating_thread);\n+        inflating_thread->lock_stack().remove(object);\n@@ -1346,1 +1394,1 @@\n-    \/\/ Could be fast-locked either by current or by some other thread.\n+    \/\/ Could be fast-locked either by the inflating_thread or by some other thread.\n@@ -1350,2 +1398,2 @@\n-    \/\/ this thread owns the monitor, then we set the ObjectMonitor's\n-    \/\/ owner to this thread. Otherwise, we set the ObjectMonitor's owner\n+    \/\/ the inflating_thread owns the monitor, then we set the ObjectMonitor's\n+    \/\/ owner to the inflating_thread. Otherwise, we set the ObjectMonitor's owner\n@@ -1359,1 +1407,1 @@\n-      bool own = is_lock_owned(current, object);\n+      bool own = inflating_thread != nullptr && inflating_thread->lock_stack().contains(object);\n@@ -1362,1 +1410,1 @@\n-        monitor->set_owner_from(nullptr, current);\n+        monitor->set_owner_from(nullptr, inflating_thread);\n@@ -1372,1 +1420,1 @@\n-          JavaThread::cast(current)->lock_stack().remove(object);\n+          inflating_thread->lock_stack().remove(object);\n@@ -1382,1 +1430,1 @@\n-          ResourceMark rm(current);\n+          ResourceMark rm;\n@@ -1481,1 +1529,1 @@\n-        ResourceMark rm(current);\n+        ResourceMark rm;\n@@ -1525,1 +1573,1 @@\n-      ResourceMark rm(current);\n+      ResourceMark rm;\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":96,"deletions":48,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,0 +97,10 @@\n+  \/\/ Used to enter a monitor for another thread. This requires that the\n+  \/\/ locking_thread is suspended, and that entering on a potential\n+  \/\/ inflated monitor may only contend with deflation. That is the obj being\n+  \/\/ locked on is either already locked by the locking_thread or cannot\n+  \/\/ escape the locking_thread.\n+  static void enter_for(Handle obj, BasicLock* lock, JavaThread* locking_thread);\n+private:\n+  \/\/ Shared implementation for enter and enter_for. Performs all but\n+  \/\/ inflated monitor enter.\n+  static bool enter_fast_impl(Handle obj, BasicLock* lock, JavaThread* locking_thread);\n@@ -98,0 +108,1 @@\n+public:\n@@ -113,0 +124,8 @@\n+  \/\/ Used to inflate a monitor as if it was done from the thread JavaThread.\n+  static ObjectMonitor* inflate_for(JavaThread* thread, oop obj, const InflateCause cause);\n+\n+private:\n+  \/\/ Shared implementation between the different LockingMode.\n+  static ObjectMonitor* inflate_impl(JavaThread* thread, oop obj, const InflateCause cause);\n+\n+public:\n@@ -190,1 +209,1 @@\n-  static void handle_sync_on_value_based_class(Handle obj, JavaThread* current);\n+  static void handle_sync_on_value_based_class(Handle obj, JavaThread* locking_thread);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":21,"deletions":2,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -123,0 +123,38 @@\n+ * @bug 8324881\n+ * @comment Regression test for using the wrong thread when logging during re-locking from deoptimization.\n+ *\n+ * @comment DiagnoseSyncOnValueBasedClasses=2 will cause logging when locking on \\@ValueBased objects.\n+ * @run driver EATests\n+ *                 -XX:+UnlockDiagnosticVMOptions\n+ *                 -Xms256m -Xmx256m\n+ *                 -Xbootclasspath\/a:.\n+ *                 -XX:CompileCommand=dontinline,*::dontinline_*\n+ *                 -XX:+WhiteBoxAPI\n+ *                 -Xbatch\n+ *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n+ *                 -XX:LockingMode=1\n+ *                 -XX:DiagnoseSyncOnValueBasedClasses=2\n+ *\n+ * @comment Re-lock may inflate monitors when re-locking, which cause monitorinflation trace logging.\n+ * @run driver EATests\n+ *                 -XX:+UnlockDiagnosticVMOptions\n+ *                 -Xms256m -Xmx256m\n+ *                 -Xbootclasspath\/a:.\n+ *                 -XX:CompileCommand=dontinline,*::dontinline_*\n+ *                 -XX:+WhiteBoxAPI\n+ *                 -Xbatch\n+ *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n+ *                 -XX:LockingMode=2\n+ *                 -Xlog:monitorinflation=trace:file=monitorinflation.log\n+ *\n+ * @comment Re-lock may race with deflation.\n+ * @run driver EATests\n+ *                 -XX:+UnlockDiagnosticVMOptions\n+ *                 -Xms256m -Xmx256m\n+ *                 -Xbootclasspath\/a:.\n+ *                 -XX:CompileCommand=dontinline,*::dontinline_*\n+ *                 -XX:+WhiteBoxAPI\n+ *                 -Xbatch\n+ *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n+ *                 -XX:LockingMode=0\n+ *                 -XX:GuaranteedAsyncDeflationInterval=1000\n@@ -124,0 +162,1 @@\n+\n@@ -256,0 +295,1 @@\n+        new EARelockingNestedInflated_03Target()                                            .run();\n@@ -262,0 +302,1 @@\n+        new EARelockingValueBasedTarget()                                                   .run();\n@@ -378,0 +419,1 @@\n+        new EARelockingNestedInflated_03()                                            .run(this);\n@@ -384,0 +426,1 @@\n+        new EARelockingValueBased()                                                   .run(this);\n@@ -1929,0 +1972,88 @@\n+\/**\n+ * Like {@link EARelockingNestedInflated_02} with the difference that the\n+ * inflation of the lock happens because of contention.\n+ *\/\n+class EARelockingNestedInflated_03 extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        @SuppressWarnings(\"unused\")\n+        ObjectReference o = getLocalRef(bpe.thread().frame(2), XYVAL_NAME, \"l1\");\n+    }\n+}\n+\n+class EARelockingNestedInflated_03Target extends EATestCaseBaseTarget {\n+\n+    public XYVal lockInflatedByContention;\n+    public boolean doLockNow;\n+    public EATestCaseBaseTarget testCase;\n+\n+    @Override\n+    public void setUp() {\n+        super.setUp();\n+        testMethodDepth = 2;\n+        lockInflatedByContention = new XYVal(1, 1);\n+        testCase = this;\n+    }\n+\n+    @Override\n+    public void warmupDone() {\n+        super.warmupDone();\n+        \/\/ Use new lock. lockInflatedByContention might have been inflated because of recursion.\n+        lockInflatedByContention = new XYVal(1, 1);\n+        \/\/ Start thread that tries to enter lockInflatedByContention while the main thread owns it -> inflation\n+        DebuggeeWrapper.newThread(() -> {\n+            while (true) {\n+                synchronized (testCase) {\n+                    try {\n+                        if (doLockNow) {\n+                            doLockNow = false; \/\/ reset for main thread\n+                            testCase.notify();\n+                            break;\n+                        }\n+                        testCase.wait();\n+                    } catch (InterruptedException e) { \/* ignored *\/ }\n+                }\n+            }\n+            synchronized(lockInflatedByContention) { \/\/ will block and trigger inflation\n+                msg(Thread.currentThread().getName() + \": acquired lockInflatedByContention\");\n+            }\n+            }, testCaseName + \": Lock Contender (test thread)\").start();\n+    }\n+\n+    public void dontinline_testMethod() {\n+        @SuppressWarnings(\"unused\")\n+        XYVal xy = new XYVal(1, 1);            \/\/ scalar replaced\n+        XYVal l1 = lockInflatedByContention;   \/\/ read by debugger\n+        synchronized (l1) {\n+            testMethod_inlined(l1);\n+        }\n+    }\n+\n+    public void testMethod_inlined(XYVal l2) {\n+        synchronized (l2) {                 \/\/ eliminated nested locking\n+            dontinline_notifyOtherThread();\n+            dontinline_brkpt();\n+        }\n+    }\n+\n+    public void dontinline_notifyOtherThread() {\n+        if (!warmupDone) {\n+            return;\n+        }\n+        synchronized (testCase) {\n+            doLockNow = true;\n+            testCase.notify();\n+            \/\/ wait for other thread to reset doLockNow again\n+            while (doLockNow) {\n+                try {\n+                    testCase.wait();\n+                } catch (InterruptedException e) { \/* ignored *\/ }\n+            }\n+        }\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n@@ -2144,0 +2275,26 @@\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/**\n+ * Test relocking eliminated @ValueBased object.\n+ *\/\n+class EARelockingValueBased extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        @SuppressWarnings(\"unused\")\n+        ObjectReference o = getLocalRef(bpe.thread().frame(1), Integer.class.getName(), \"l1\");\n+    }\n+}\n+\n+class EARelockingValueBasedTarget extends EATestCaseBaseTarget {\n+\n+    public void dontinline_testMethod() {\n+        Integer l1 = new Integer(255);\n+        synchronized (l1) {\n+            dontinline_brkpt();\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/com\/sun\/jdi\/EATests.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"modified"}]}