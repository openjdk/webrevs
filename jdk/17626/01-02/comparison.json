{"files":[{"patch":"@@ -1648,1 +1648,1 @@\n-          ObjectSynchronizer::enter(obj, nullptr, deoptee_thread, thread);\n+          ObjectSynchronizer::enter(obj, nullptr, deoptee_thread);\n@@ -1650,1 +1650,1 @@\n-          ObjectMonitor* mon = ObjectSynchronizer::inflate(deoptee_thread, thread, obj(), ObjectSynchronizer::inflate_cause_vm_internal);\n+          ObjectMonitor* mon = ObjectSynchronizer::inflate_for(deoptee_thread, obj(), ObjectSynchronizer::inflate_cause_vm_internal);\n@@ -1654,1 +1654,1 @@\n-          ObjectSynchronizer::enter(obj, lock, deoptee_thread, thread);\n+          ObjectSynchronizer::enter(obj, lock, deoptee_thread);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -56,3 +56,0 @@\n-  \/\/ Get the owning thread of this lock-stack.\n-  inline JavaThread* get_thread() const;\n-\n@@ -74,0 +71,3 @@\n+  \/\/ Get the owning thread of this lock-stack.\n+  inline JavaThread* get_thread() const;\n+\n","filename":"src\/hotspot\/share\/runtime\/lockStack.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -449,7 +449,1 @@\n-void ObjectSynchronizer::handle_sync_on_value_based_class(Handle obj, JavaThread* current) {\n-  assert(current == JavaThread::current(), \"must be\");\n-  handle_sync_on_value_based_class(obj, current, current);\n-}\n-\n-void ObjectSynchronizer::handle_sync_on_value_based_class(Handle obj, JavaThread* locking_thread, JavaThread* current) {\n-  assert(current == JavaThread::current(), \"must be\");\n+void ObjectSynchronizer::handle_sync_on_value_based_class(Handle obj, JavaThread* locking_thread) {\n@@ -469,1 +463,1 @@\n-    ResourceMark rm(current);\n+    ResourceMark rm;\n@@ -480,1 +474,1 @@\n-    ResourceMark rm(current);\n+    ResourceMark rm;\n@@ -516,11 +510,5 @@\n-void ObjectSynchronizer::enter(Handle obj, BasicLock* lock, JavaThread* current) {\n-  assert(current == JavaThread::current(), \"must lock on the current thread\");\n-  enter(obj, lock, current, current);\n-}\n-\n-void ObjectSynchronizer::enter(Handle obj, BasicLock* lock, JavaThread* locking_thread, JavaThread* current) {\n-  assert(current == JavaThread::current(), \"must be\");\n-  \/\/ When called with locking_thread != current some mechanism must synchronize the locking_thread\n-  \/\/ with respect to the current thread. Currently only used when deoptimizing and re-locking locks.\n-  \/\/ See Deoptimization::relock_objects\n-  assert(locking_thread == current || locking_thread->is_obj_deopt_suspend(), \"must be\");\n+void ObjectSynchronizer::enter(Handle obj, BasicLock* lock, JavaThread* locking_thread) {\n+  \/\/ When called with locking_thread != Thread::current() some mechanism must synchronize\n+  \/\/ the locking_thread with respect to the current thread. Currently only used when\n+  \/\/ deoptimizing and re-locking locks. See Deoptimization::relock_objects\n+  assert(locking_thread == Thread::current() || locking_thread->is_obj_deopt_suspend(), \"must be\");\n@@ -529,1 +517,1 @@\n-    handle_sync_on_value_based_class(obj, locking_thread, current);\n+    handle_sync_on_value_based_class(obj, locking_thread);\n@@ -586,0 +574,1 @@\n+  LockStack* const lock_stack = LockingMode == LM_LIGHTWEIGHT ? &locking_thread->lock_stack() : nullptr;\n@@ -587,1 +576,1 @@\n-    ObjectMonitor* monitor = inflate(locking_thread, current, obj(), inflate_cause_monitor_enter);\n+    ObjectMonitor* monitor = inflate_impl(lock_stack, obj(), inflate_cause_monitor_enter);\n@@ -1310,10 +1299,2 @@\n-\/\/ Can be called from non JavaThreads (e.g., VMThread) for FastHashCode\n-\/\/ calculations as part of JVM\/TI tagging.\n-static bool is_lock_owned(JavaThread* locking_thread, oop obj) {\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"only call this with new lightweight locking enabled\");\n-  return locking_thread != nullptr ? locking_thread->lock_stack().contains(obj) : false;\n-}\n-\n-ObjectMonitor* ObjectSynchronizer::inflate(Thread* current, oop object,\n-                                           const InflateCause cause) {\n-  JavaThread* locking_thread = nullptr;\n+ObjectMonitor* ObjectSynchronizer::inflate(Thread* current, oop obj, const InflateCause cause) {\n+  assert(current == Thread::current(), \"must be\");\n@@ -1321,1 +1302,1 @@\n-    locking_thread = JavaThread::cast(current);\n+    return inflate_for(JavaThread::cast(current), obj, cause);\n@@ -1323,1 +1304,1 @@\n-  return inflate(locking_thread, current, object, cause);\n+  return inflate_impl(nullptr, obj, cause);\n@@ -1326,10 +1307,9 @@\n-ObjectMonitor* ObjectSynchronizer::inflate(JavaThread* locking_thread, Thread* current, oop object,\n-                                           const InflateCause cause) {\n-  assert(current == Thread::current(), \"must be\");\n-  \/\/ locking_thread != nullptr implies that the thread is safe to look into including\n-  \/\/ reading and modifying it's lock stack. This is always valid if current == locking_thread\n-  \/\/ When called with locking_thread != nullptr and locking_thread != current some mechanism\n-  \/\/ must synchronize the locking_thread with respect to the current thread. Currently only\n-  \/\/ used when deoptimizing and re-locking locks. See Deoptimization::relock_objects\n-  assert(locking_thread == nullptr || locking_thread == current ||\n-         locking_thread->is_obj_deopt_suspend(), \"must be\");\n+ObjectMonitor* ObjectSynchronizer::inflate_for(JavaThread* thread, oop obj, const InflateCause cause) {\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"only used by LM_LIGHTWEIGHT\");\n+  assert(thread == Thread::current() || thread->is_obj_deopt_suspend(), \"must be\");\n+  return inflate_impl(&thread->lock_stack(), obj, cause);\n+}\n+\n+ObjectMonitor* ObjectSynchronizer::inflate_impl(LockStack* lock_stack, oop object, const InflateCause cause) {\n+  assert(lock_stack == nullptr || LockingMode == LM_LIGHTWEIGHT, \"only LM_LIGHTWEIGHT uses a lock_stack\");\n+\n@@ -1344,2 +1324,2 @@\n-    \/\/                   is anonymous and the locking_thread owns the\n-    \/\/                   object lock, then we make the locking_thread the\n+    \/\/                   is anonymous and the lock_stack contains the\n+    \/\/                   object, then we make the lock_stacks owner the\n@@ -1347,1 +1327,1 @@\n-    \/\/                   locking_thread's lock stack.\n+    \/\/                   lock stack.\n@@ -1359,3 +1339,4 @@\n-      if (LockingMode == LM_LIGHTWEIGHT && inf->is_owner_anonymous() && is_lock_owned(locking_thread, object)) {\n-        inf->set_owner_from_anonymous(locking_thread);\n-        locking_thread->lock_stack().remove(object);\n+      if (LockingMode == LM_LIGHTWEIGHT && inf->is_owner_anonymous() &&\n+          lock_stack != nullptr && lock_stack->contains(object)) {\n+        inf->set_owner_from_anonymous(lock_stack->get_thread());\n+        lock_stack->remove(object);\n@@ -1381,1 +1362,1 @@\n-    \/\/ Could be fast-locked either by locking_thread or by some other thread.\n+    \/\/ Could be fast-locked either by lock_stack's thread or by some other thread.\n@@ -1394,1 +1375,1 @@\n-      bool own = is_lock_owned(locking_thread, object);\n+      bool own = lock_stack != nullptr && lock_stack->contains(object);\n@@ -1397,1 +1378,1 @@\n-        monitor->set_owner_from(nullptr, locking_thread);\n+        monitor->set_owner_from(nullptr, lock_stack->get_thread());\n@@ -1407,1 +1388,1 @@\n-          locking_thread->lock_stack().remove(object);\n+          lock_stack->remove(object);\n@@ -1417,1 +1398,1 @@\n-          ResourceMark rm(current);\n+          ResourceMark rm;\n@@ -1516,1 +1497,1 @@\n-        ResourceMark rm(current);\n+        ResourceMark rm;\n@@ -1560,1 +1541,1 @@\n-      ResourceMark rm(current);\n+      ResourceMark rm;\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":38,"deletions":57,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/lockStack.hpp\"\n@@ -95,2 +96,1 @@\n-  static void enter(Handle obj, BasicLock* lock, JavaThread* locking_thread, JavaThread* current);\n-  static void enter(Handle obj, BasicLock* lock, JavaThread* current);\n+  static void enter(Handle obj, BasicLock* lock, JavaThread* locking_thread);\n@@ -114,1 +114,8 @@\n-  static ObjectMonitor* inflate(JavaThread* locking_thread, Thread* current, oop obj, const InflateCause cause);\n+  \/\/ Used for LM_LIGHTWEIGHT to inflate a monitor as if it was done from the thread JavaThread.\n+  static ObjectMonitor* inflate_for(JavaThread* thread, oop obj, const InflateCause cause);\n+\n+private:\n+  \/\/ Shared implementation between the different LockingMode\n+  static ObjectMonitor* inflate_impl(LockStack* lock_stack, oop obj, const InflateCause cause);\n+\n+public:\n@@ -192,2 +199,1 @@\n-  static void handle_sync_on_value_based_class(Handle obj, JavaThread* locking_thread, JavaThread* current);\n-  static void handle_sync_on_value_based_class(Handle obj, JavaThread* current);\n+  static void handle_sync_on_value_based_class(Handle obj, JavaThread* locking_thread);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"}]}