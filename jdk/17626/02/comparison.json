{"files":[{"patch":"@@ -1650,1 +1650,1 @@\n-          ObjectMonitor* mon = ObjectSynchronizer::inflate(deoptee_thread, obj(), ObjectSynchronizer::inflate_cause_vm_internal);\n+          ObjectMonitor* mon = ObjectSynchronizer::inflate_for(deoptee_thread, obj(), ObjectSynchronizer::inflate_cause_vm_internal);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,3 +56,0 @@\n-  \/\/ Get the owning thread of this lock-stack.\n-  inline JavaThread* get_thread() const;\n-\n@@ -74,0 +71,3 @@\n+  \/\/ Get the owning thread of this lock-stack.\n+  inline JavaThread* get_thread() const;\n+\n","filename":"src\/hotspot\/share\/runtime\/lockStack.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -63,0 +64,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -447,2 +449,2 @@\n-void ObjectSynchronizer::handle_sync_on_value_based_class(Handle obj, JavaThread* current) {\n-  frame last_frame = current->last_frame();\n+void ObjectSynchronizer::handle_sync_on_value_based_class(Handle obj, JavaThread* locking_thread) {\n+  frame last_frame = locking_thread->last_frame();\n@@ -461,1 +463,1 @@\n-    ResourceMark rm(current);\n+    ResourceMark rm;\n@@ -463,1 +465,1 @@\n-    current->print_active_stack_on(&ss);\n+    locking_thread->print_active_stack_on(&ss);\n@@ -472,1 +474,1 @@\n-    ResourceMark rm(current);\n+    ResourceMark rm;\n@@ -476,1 +478,1 @@\n-    if (current->has_last_Java_frame()) {\n+    if (locking_thread->has_last_Java_frame()) {\n@@ -478,1 +480,1 @@\n-      current->print_active_stack_on(&info_stream);\n+      locking_thread->print_active_stack_on(&info_stream);\n@@ -508,0 +510,5 @@\n+void ObjectSynchronizer::enter(Handle obj, BasicLock* lock, JavaThread* locking_thread) {\n+  \/\/ When called with locking_thread != Thread::current() some mechanism must synchronize\n+  \/\/ the locking_thread with respect to the current thread. Currently only used when\n+  \/\/ deoptimizing and re-locking locks. See Deoptimization::relock_objects\n+  assert(locking_thread == Thread::current() || locking_thread->is_obj_deopt_suspend(), \"must be\");\n@@ -509,1 +516,0 @@\n-void ObjectSynchronizer::enter(Handle obj, BasicLock* lock, JavaThread* current) {\n@@ -511,1 +517,1 @@\n-    handle_sync_on_value_based_class(obj, current);\n+    handle_sync_on_value_based_class(obj, locking_thread);\n@@ -514,1 +520,1 @@\n-  current->inc_held_monitor_count();\n+  locking_thread->inc_held_monitor_count();\n@@ -519,1 +525,1 @@\n-      LockStack& lock_stack = current->lock_stack();\n+      LockStack& lock_stack = locking_thread->lock_stack();\n@@ -548,1 +554,1 @@\n-                 current->is_lock_owned((address) mark.locker())) {\n+                 locking_thread->is_lock_owned((address) mark.locker())) {\n@@ -568,0 +574,1 @@\n+  LockStack* const lock_stack = LockingMode == LM_LIGHTWEIGHT ? &locking_thread->lock_stack() : nullptr;\n@@ -569,2 +576,2 @@\n-    ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_monitor_enter);\n-    if (monitor->enter(current)) {\n+    ObjectMonitor* monitor = inflate_impl(lock_stack, obj(), inflate_cause_monitor_enter);\n+    if (monitor->enter(locking_thread)) {\n@@ -1292,5 +1299,12 @@\n-\/\/ Can be called from non JavaThreads (e.g., VMThread) for FastHashCode\n-\/\/ calculations as part of JVM\/TI tagging.\n-static bool is_lock_owned(Thread* thread, oop obj) {\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"only call this with new lightweight locking enabled\");\n-  return thread->is_Java_thread() ? JavaThread::cast(thread)->lock_stack().contains(obj) : false;\n+ObjectMonitor* ObjectSynchronizer::inflate(Thread* current, oop obj, const InflateCause cause) {\n+  assert(current == Thread::current(), \"must be\");\n+  if (LockingMode == LM_LIGHTWEIGHT && current->is_Java_thread()) {\n+    return inflate_for(JavaThread::cast(current), obj, cause);\n+  }\n+  return inflate_impl(nullptr, obj, cause);\n+}\n+\n+ObjectMonitor* ObjectSynchronizer::inflate_for(JavaThread* thread, oop obj, const InflateCause cause) {\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"only used by LM_LIGHTWEIGHT\");\n+  assert(thread == Thread::current() || thread->is_obj_deopt_suspend(), \"must be\");\n+  return inflate_impl(&thread->lock_stack(), obj, cause);\n@@ -1299,2 +1313,3 @@\n-ObjectMonitor* ObjectSynchronizer::inflate(Thread* current, oop object,\n-                                           const InflateCause cause) {\n+ObjectMonitor* ObjectSynchronizer::inflate_impl(LockStack* lock_stack, oop object, const InflateCause cause) {\n+  assert(lock_stack == nullptr || LockingMode == LM_LIGHTWEIGHT, \"only LM_LIGHTWEIGHT uses a lock_stack\");\n+\n@@ -1309,2 +1324,2 @@\n-    \/\/                   is anonymous and the current thread owns the\n-    \/\/                   object lock, then we make the current thread the\n+    \/\/                   is anonymous and the lock_stack contains the\n+    \/\/                   object, then we make the lock_stacks owner the\n@@ -1312,1 +1327,1 @@\n-    \/\/                   current thread's lock stack.\n+    \/\/                   lock stack.\n@@ -1324,3 +1339,4 @@\n-      if (LockingMode == LM_LIGHTWEIGHT && inf->is_owner_anonymous() && is_lock_owned(current, object)) {\n-        inf->set_owner_from_anonymous(current);\n-        JavaThread::cast(current)->lock_stack().remove(object);\n+      if (LockingMode == LM_LIGHTWEIGHT && inf->is_owner_anonymous() &&\n+          lock_stack != nullptr && lock_stack->contains(object)) {\n+        inf->set_owner_from_anonymous(lock_stack->get_thread());\n+        lock_stack->remove(object);\n@@ -1346,1 +1362,1 @@\n-    \/\/ Could be fast-locked either by current or by some other thread.\n+    \/\/ Could be fast-locked either by lock_stack's thread or by some other thread.\n@@ -1359,1 +1375,1 @@\n-      bool own = is_lock_owned(current, object);\n+      bool own = lock_stack != nullptr && lock_stack->contains(object);\n@@ -1362,1 +1378,1 @@\n-        monitor->set_owner_from(nullptr, current);\n+        monitor->set_owner_from(nullptr, lock_stack->get_thread());\n@@ -1372,1 +1388,1 @@\n-          JavaThread::cast(current)->lock_stack().remove(object);\n+          lock_stack->remove(object);\n@@ -1382,1 +1398,1 @@\n-          ResourceMark rm(current);\n+          ResourceMark rm;\n@@ -1481,1 +1497,1 @@\n-        ResourceMark rm(current);\n+        ResourceMark rm;\n@@ -1525,1 +1541,1 @@\n-      ResourceMark rm(current);\n+      ResourceMark rm;\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":50,"deletions":34,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/lockStack.hpp\"\n@@ -95,1 +96,1 @@\n-  static void enter(Handle obj, BasicLock* lock, JavaThread* current);\n+  static void enter(Handle obj, BasicLock* lock, JavaThread* locking_thread);\n@@ -113,0 +114,8 @@\n+  \/\/ Used for LM_LIGHTWEIGHT to inflate a monitor as if it was done from the thread JavaThread.\n+  static ObjectMonitor* inflate_for(JavaThread* thread, oop obj, const InflateCause cause);\n+\n+private:\n+  \/\/ Shared implementation between the different LockingMode\n+  static ObjectMonitor* inflate_impl(LockStack* lock_stack, oop obj, const InflateCause cause);\n+\n+public:\n@@ -190,1 +199,1 @@\n-  static void handle_sync_on_value_based_class(Handle obj, JavaThread* current);\n+  static void handle_sync_on_value_based_class(Handle obj, JavaThread* locking_thread);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -123,0 +123,36 @@\n+ * @bug 8324881\n+ * @comment Regression test for using the wrong thread when logging during re-locking from deoptimization.\n+ *\n+ * @comment DiagnoseSyncOnValueBasedClasses=2 will cause logging when locking on \\@ValueBased objects.\n+ * @run driver EATests\n+ *                 -XX:+UnlockDiagnosticVMOptions\n+ *                 -Xms256m -Xmx256m\n+ *                 -Xbootclasspath\/a:.\n+ *                 -XX:CompileCommand=dontinline,*::dontinline_*\n+ *                 -XX:+WhiteBoxAPI\n+ *                 -Xbatch\n+ *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n+ *                 -XX:LockingMode=1\n+ *                 -XX:DiagnoseSyncOnValueBasedClasses=2\n+ *\n+ * @comment Re-lock may inflate monitors when re-locking, which cause monitorinflation trace logging.\n+ * @run driver EATests\n+ *                 -XX:+UnlockDiagnosticVMOptions\n+ *                 -Xms256m -Xmx256m\n+ *                 -Xbootclasspath\/a:.\n+ *                 -XX:CompileCommand=dontinline,*::dontinline_*\n+ *                 -XX:+WhiteBoxAPI\n+ *                 -Xbatch\n+ *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n+ *                 -XX:LockingMode=0\n+ *                 -Xlog:monitorinflation=trace\n+ * @run driver EATests\n+ *                 -XX:+UnlockDiagnosticVMOptions\n+ *                 -Xms256m -Xmx256m\n+ *                 -Xbootclasspath\/a:.\n+ *                 -XX:CompileCommand=dontinline,*::dontinline_*\n+ *                 -XX:+WhiteBoxAPI\n+ *                 -Xbatch\n+ *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n+ *                 -XX:LockingMode=2\n+ *                 -Xlog:monitorinflation=trace\n@@ -124,0 +160,1 @@\n+\n@@ -262,0 +299,1 @@\n+        new EARelockingValueBasedTarget()                                                   .run();\n@@ -384,0 +422,1 @@\n+        new EARelockingValueBased()                                                   .run(this);\n@@ -2144,0 +2183,26 @@\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/**\n+ * Test relocking eliminated @ValueBased object.\n+ *\/\n+class EARelockingValueBased extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        @SuppressWarnings(\"unused\")\n+        ObjectReference o = getLocalRef(bpe.thread().frame(1), Integer.class.getName(), \"l1\");\n+    }\n+}\n+\n+class EARelockingValueBasedTarget extends EATestCaseBaseTarget {\n+\n+    public void dontinline_testMethod() {\n+        Integer l1 = new Integer(255);\n+        synchronized (l1) {\n+            dontinline_brkpt();\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/com\/sun\/jdi\/EATests.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"modified"}]}