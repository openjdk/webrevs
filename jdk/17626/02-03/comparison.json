{"files":[{"patch":"@@ -1649,1 +1649,1 @@\n-          ObjectSynchronizer::enter(obj, nullptr, deoptee_thread);\n+          ObjectSynchronizer::enter_for(obj, nullptr, deoptee_thread);\n@@ -1655,1 +1655,1 @@\n-          ObjectSynchronizer::enter(obj, lock, deoptee_thread);\n+          ObjectSynchronizer::enter_for(obj, lock, deoptee_thread);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,0 +56,3 @@\n+  \/\/ Get the owning thread of this lock-stack.\n+  inline JavaThread* get_thread() const;\n+\n@@ -71,3 +74,0 @@\n-  \/\/ Get the owning thread of this lock-stack.\n-  inline JavaThread* get_thread() const;\n-\n","filename":"src\/hotspot\/share\/runtime\/lockStack.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -315,0 +315,52 @@\n+bool ObjectMonitor::enter_for(JavaThread* locking_thread) {\n+  \/\/ Used by ObjectSynchronizer::enter_for to enter for another thread\n+  \/\/ this code may only contend with deflation.\n+  assert(locking_thread == Thread::current() || locking_thread->is_obj_deopt_suspend(), \"must be\");\n+\n+  \/\/ Block out deflation as soon as possible.\n+  add_to_contentions(1);\n+\n+  bool success = false;\n+  if (!is_being_async_deflated()) {\n+    void* prev_owner = try_set_owner_from(nullptr, locking_thread);\n+\n+    if (prev_owner == nullptr) {\n+      assert(_recursions == 0, \"invariant\");\n+      success = true;\n+    } else if (prev_owner == locking_thread) {\n+      _recursions++;\n+      success = true;\n+    } else if (prev_owner == DEFLATER_MARKER) {\n+      \/\/ Racing with deflation.\n+      prev_owner = try_set_owner_from(DEFLATER_MARKER, locking_thread);\n+      if (prev_owner == DEFLATER_MARKER) {\n+        \/\/ Cancelled deflation. Increment contentions as part of the deflation protocol.\n+        add_to_contentions(1);\n+        success = true;\n+      } else if (prev_owner == nullptr) {\n+        \/\/ At this point we cannot race with deflation as we have both incremented\n+        \/\/ contentions, seen contention > 0 and seen a DEFLATER_MARKER.\n+        \/\/ success will only be false if this races with something other than\n+        \/\/ deflation.\n+        success = try_set_owner_from(nullptr, locking_thread) == nullptr;\n+      }\n+    }\n+  } else {\n+    \/\/ Async deflation is in progress and our contentions increment\n+    \/\/ above lost the race to async deflation. Undo the work and\n+    \/\/ force the caller to retry.\n+    const oop l_object = object();\n+    if (l_object != nullptr) {\n+      \/\/ Attempt to restore the header\/dmw to the object's header so that\n+      \/\/ we only retry once if the deflater thread happens to be slow.\n+      install_displaced_markword_in_object(l_object);\n+    }\n+  }\n+\n+  add_to_contentions(-1);\n+\n+  assert(!success || owner_raw() == locking_thread, \"must be\");\n+\n+  return success;\n+}\n+\n@@ -316,0 +368,1 @@\n+  assert(current == JavaThread::current(), \"must be\");\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":53,"deletions":0,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -332,0 +332,1 @@\n+  bool      enter_for(JavaThread* locking_thread);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -450,0 +450,1 @@\n+  assert(locking_thread == Thread::current() || locking_thread->is_obj_deopt_suspend(), \"must be\");\n@@ -510,1 +511,1 @@\n-void ObjectSynchronizer::enter(Handle obj, BasicLock* lock, JavaThread* locking_thread) {\n+void ObjectSynchronizer::enter_for(Handle obj, BasicLock* lock, JavaThread* locking_thread) {\n@@ -515,0 +516,35 @@\n+  if (!enter_fast_impl(obj, lock, locking_thread)) {\n+    \/\/ Inflated ObjectMonitor::enter_for is required\n+\n+    \/\/ An async deflation can race after the inflate_for() call and before\n+    \/\/ enter() can make the ObjectMonitor busy. enter_for() returns false if\n+    \/\/ we have lost the race to async deflation and we simply try again.\n+    while (true) {\n+      ObjectMonitor* monitor = inflate_for(locking_thread, obj(), inflate_cause_monitor_enter);\n+      if (monitor->enter_for(locking_thread)) {\n+        return;\n+      }\n+      assert(monitor->is_being_async_deflated(), \"must be\");\n+    }\n+  }\n+\n+}\n+\n+void ObjectSynchronizer::enter(Handle obj, BasicLock* lock, JavaThread* current) {\n+  assert(current == Thread::current(), \"must be\");\n+  if (!enter_fast_impl(obj, lock, current)) {\n+    \/\/ Inflated ObjectMonitor::enter is required\n+\n+    \/\/ An async deflation can race after the inflate() call and before\n+    \/\/ enter() can make the ObjectMonitor busy. enter() returns false if\n+    \/\/ we have lost the race to async deflation and we simply try again.\n+    while (true) {\n+      ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_monitor_enter);\n+      if (monitor->enter(current)) {\n+        return;\n+      }\n+    }\n+  }\n+}\n+\n+bool ObjectSynchronizer::enter_fast_impl(Handle obj, BasicLock* lock, JavaThread* locking_thread) {\n@@ -537,1 +573,1 @@\n-            return;\n+            return true;\n@@ -550,1 +586,1 @@\n-          return;\n+          return true;\n@@ -558,1 +594,1 @@\n-        return;\n+        return true;\n@@ -571,10 +607,1 @@\n-  \/\/ An async deflation can race after the inflate() call and before\n-  \/\/ enter() can make the ObjectMonitor busy. enter() returns false if\n-  \/\/ we have lost the race to async deflation and we simply try again.\n-  LockStack* const lock_stack = LockingMode == LM_LIGHTWEIGHT ? &locking_thread->lock_stack() : nullptr;\n-  while (true) {\n-    ObjectMonitor* monitor = inflate_impl(lock_stack, obj(), inflate_cause_monitor_enter);\n-    if (monitor->enter(locking_thread)) {\n-      return;\n-    }\n-  }\n+  return false;\n@@ -1302,1 +1329,1 @@\n-    return inflate_for(JavaThread::cast(current), obj, cause);\n+    return inflate_impl(JavaThread::cast(current), obj, cause);\n@@ -1308,1 +1335,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"only used by LM_LIGHTWEIGHT\");\n@@ -1310,1 +1336,1 @@\n-  return inflate_impl(&thread->lock_stack(), obj, cause);\n+  return inflate_impl(thread, obj, cause);\n@@ -1313,3 +1339,9 @@\n-ObjectMonitor* ObjectSynchronizer::inflate_impl(LockStack* lock_stack, oop object, const InflateCause cause) {\n-  assert(lock_stack == nullptr || LockingMode == LM_LIGHTWEIGHT, \"only LM_LIGHTWEIGHT uses a lock_stack\");\n-\n+ObjectMonitor* ObjectSynchronizer::inflate_impl(JavaThread* thread, oop object, const InflateCause cause) {\n+  \/\/ The JavaThread* thread parameter is only used by LM_LIGHTWEIGHT and requires\n+  \/\/ that the thread == Thread::current() or is suspended throughout the call by\n+  \/\/ some other mechanism.\n+  \/\/ Even with LM_LIGHTWEIGHT the thread might be nullptr when called from a non\n+  \/\/ JavaThread. (As may still be the case from FastHashCode). However it is only\n+  \/\/ important for the correctness of the LM_LIGHTWEIGHT algorithm that the thread\n+  \/\/ is set when called from ObjectSynchronizer::enter from the owning thread,\n+  \/\/ ObjectSynchronizer::enter_for from any thread, or ObjectSynchronizer::exit\n@@ -1324,4 +1356,3 @@\n-    \/\/                   is anonymous and the lock_stack contains the\n-    \/\/                   object, then we make the lock_stacks owner the\n-    \/\/                   ObjectMonitor owner and remove the lock from the\n-    \/\/                   lock stack.\n+    \/\/                   is anonymous and the thread owns the object lock,\n+    \/\/                   then we make the thread the ObjectMonitor owner\n+    \/\/                   and remove the lock from the thread's lock stack.\n@@ -1340,3 +1371,3 @@\n-          lock_stack != nullptr && lock_stack->contains(object)) {\n-        inf->set_owner_from_anonymous(lock_stack->get_thread());\n-        lock_stack->remove(object);\n+          thread != nullptr && thread->lock_stack().contains(object)) {\n+        inf->set_owner_from_anonymous(thread);\n+        thread->lock_stack().remove(object);\n@@ -1362,1 +1393,1 @@\n-    \/\/ Could be fast-locked either by lock_stack's thread or by some other thread.\n+    \/\/ Could be fast-locked either by the thread or by some other thread.\n@@ -1375,1 +1406,1 @@\n-      bool own = lock_stack != nullptr && lock_stack->contains(object);\n+      bool own = thread != nullptr && thread->lock_stack().contains(object);\n@@ -1378,1 +1409,1 @@\n-        monitor->set_owner_from(nullptr, lock_stack->get_thread());\n+        monitor->set_owner_from(nullptr, thread);\n@@ -1388,1 +1419,1 @@\n-          lock_stack->remove(object);\n+          thread->lock_stack().remove(object);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":62,"deletions":31,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"runtime\/lockStack.hpp\"\n@@ -96,1 +95,1 @@\n-  static void enter(Handle obj, BasicLock* lock, JavaThread* locking_thread);\n+  static void enter(Handle obj, BasicLock* lock, JavaThread* current);\n@@ -98,0 +97,10 @@\n+  \/\/ Used to enter a monitor for another thread. This requires that the\n+  \/\/ that the locking_thread is suspended, and that entering on a potential\n+  \/\/ inflated monitor may only contend with deflation. That is the obj being\n+  \/\/ locked on is either already locked by the locking_thread or cannot\n+  \/\/ escape the locking_thread.\n+  static void enter_for(Handle obj, BasicLock* lock, JavaThread* locking_thread);\n+private:\n+  \/\/ Shared implementation for enter and enter_for. Preforms all but\n+  \/\/ inflated monitor enter\n+  static bool enter_fast_impl(Handle obj, BasicLock* lock, JavaThread* locking_thread);\n@@ -99,0 +108,1 @@\n+public:\n@@ -114,1 +124,1 @@\n-  \/\/ Used for LM_LIGHTWEIGHT to inflate a monitor as if it was done from the thread JavaThread.\n+  \/\/ Used inflate a monitor as if it was done from the thread JavaThread.\n@@ -119,1 +129,1 @@\n-  static ObjectMonitor* inflate_impl(LockStack* lock_stack, oop obj, const InflateCause cause);\n+  static ObjectMonitor* inflate_impl(JavaThread* thread, oop obj, const InflateCause cause);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"}]}