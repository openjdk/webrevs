{"files":[{"patch":"@@ -1989,1 +1989,2 @@\n-    public volatile boolean doLockNow;\n+    public boolean doLockNow;\n+    public EATestCaseBaseTarget testCase;\n@@ -1996,5 +1997,21 @@\n-        Thread contendingThread = DebuggeeWrapper.newThread(() -> {\n-            while(!doLockNow) {\n-                try {\n-                    Thread.sleep(10);\n-                } catch (InterruptedException e) { \/* ignored *\/ }\n+        testCase = this;\n+    }\n+\n+    @Override\n+    public void warmupDone() {\n+        super.warmupDone();\n+        \/\/ Use new lock. lockInflatedByContention might have been inflated because of recursion.\n+        lockInflatedByContention = new XYVal(1, 1);\n+        \/\/ Start thread that tries to enter lockInflatedByContention while the main thread owns it -> inflation\n+        DebuggeeWrapper.newThread(() -> {\n+            while(true) {\n+                synchronized(testCase) {\n+                    try {\n+                        if (doLockNow) {\n+                            doLockNow = false; \/\/ reset for main thread\n+                            testCase.notify();\n+                            break;\n+                        }\n+                        testCase.wait();\n+                    } catch (InterruptedException e) { \/* ignored *\/ }\n+                }\n@@ -2002,1 +2019,0 @@\n-            doLockNow = false; \/\/ reset for main thread\n@@ -2006,3 +2022,1 @@\n-            }, testCaseName + \": Lock Contender (test thread)\");\n-        contendingThread.setDaemon(true);\n-        contendingThread.start();\n+            }, testCaseName + \": Lock Contender (test thread)\").start();\n@@ -2022,1 +2036,1 @@\n-            dontinline_setDoLockNow();\n+            dontinline_notifyOtherThread();\n@@ -2027,7 +2041,13 @@\n-    public void dontinline_setDoLockNow() {\n-        doLockNow = warmupDone;\n-        \/\/ wait for other thread to reset doLockNow\n-        while(doLockNow) {\n-            try {\n-                Thread.sleep(10);\n-            } catch (InterruptedException e) { \/* ignored *\/ }\n+    public void dontinline_notifyOtherThread() {\n+        if (!warmupDone) {\n+            return;\n+        }\n+        synchronized(testCase) {\n+            doLockNow = true;\n+            testCase.notify();\n+            \/\/ wait for other thread to reset doLockNow again\n+            while(doLockNow) {\n+                try {\n+                    testCase.wait();\n+                } catch (InterruptedException e) { \/* ignored *\/ }\n+            }\n","filename":"test\/jdk\/com\/sun\/jdi\/EATests.java","additions":38,"deletions":18,"binary":false,"changes":56,"status":"modified"}]}