{"files":[{"patch":"@@ -1648,1 +1648,1 @@\n-          ObjectSynchronizer::enter(obj, nullptr, deoptee_thread);\n+          ObjectSynchronizer::enter(obj, nullptr, deoptee_thread, thread);\n@@ -1650,1 +1650,1 @@\n-          ObjectMonitor* mon = ObjectSynchronizer::inflate(deoptee_thread, obj(), ObjectSynchronizer::inflate_cause_vm_internal);\n+          ObjectMonitor* mon = ObjectSynchronizer::inflate(deoptee_thread, thread, obj(), ObjectSynchronizer::inflate_cause_vm_internal);\n@@ -1654,1 +1654,1 @@\n-          ObjectSynchronizer::enter(obj, lock, deoptee_thread);\n+          ObjectSynchronizer::enter(obj, lock, deoptee_thread, thread);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -63,0 +64,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -448,1 +450,7 @@\n-  frame last_frame = current->last_frame();\n+  assert(current == JavaThread::current(), \"must be\");\n+  handle_sync_on_value_based_class(obj, current, current);\n+}\n+\n+void ObjectSynchronizer::handle_sync_on_value_based_class(Handle obj, JavaThread* locking_thread, JavaThread* current) {\n+  assert(current == JavaThread::current(), \"must be\");\n+  frame last_frame = locking_thread->last_frame();\n@@ -463,1 +471,1 @@\n-    current->print_active_stack_on(&ss);\n+    locking_thread->print_active_stack_on(&ss);\n@@ -476,1 +484,1 @@\n-    if (current->has_last_Java_frame()) {\n+    if (locking_thread->has_last_Java_frame()) {\n@@ -478,1 +486,1 @@\n-      current->print_active_stack_on(&info_stream);\n+      locking_thread->print_active_stack_on(&info_stream);\n@@ -508,1 +516,0 @@\n-\n@@ -510,0 +517,11 @@\n+  assert(current == JavaThread::current(), \"must lock on the current thread\");\n+  enter(obj, lock, current, current);\n+}\n+\n+void ObjectSynchronizer::enter(Handle obj, BasicLock* lock, JavaThread* locking_thread, JavaThread* current) {\n+  assert(current == JavaThread::current(), \"must be\");\n+  \/\/ When called with locking_thread != current some mechanism must synchronize the locking_thread\n+  \/\/ with respect to the current thread. Currently only used when deoptimizing and re-locking locks.\n+  \/\/ See Deoptimization::relock_objects\n+  assert(locking_thread == current || locking_thread->is_obj_deopt_suspend(), \"must be\");\n+\n@@ -511,1 +529,1 @@\n-    handle_sync_on_value_based_class(obj, current);\n+    handle_sync_on_value_based_class(obj, locking_thread, current);\n@@ -514,1 +532,1 @@\n-  current->inc_held_monitor_count();\n+  locking_thread->inc_held_monitor_count();\n@@ -519,1 +537,1 @@\n-      LockStack& lock_stack = current->lock_stack();\n+      LockStack& lock_stack = locking_thread->lock_stack();\n@@ -548,1 +566,1 @@\n-                 current->is_lock_owned((address) mark.locker())) {\n+                 locking_thread->is_lock_owned((address) mark.locker())) {\n@@ -569,2 +587,2 @@\n-    ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_monitor_enter);\n-    if (monitor->enter(current)) {\n+    ObjectMonitor* monitor = inflate(locking_thread, current, obj(), inflate_cause_monitor_enter);\n+    if (monitor->enter(locking_thread)) {\n@@ -1294,1 +1312,1 @@\n-static bool is_lock_owned(Thread* thread, oop obj) {\n+static bool is_lock_owned(JavaThread* locking_thread, oop obj) {\n@@ -1296,1 +1314,1 @@\n-  return thread->is_Java_thread() ? JavaThread::cast(thread)->lock_stack().contains(obj) : false;\n+  return locking_thread != nullptr ? locking_thread->lock_stack().contains(obj) : false;\n@@ -1301,0 +1319,17 @@\n+  JavaThread* locking_thread = nullptr;\n+  if (LockingMode == LM_LIGHTWEIGHT && current->is_Java_thread()) {\n+    locking_thread = JavaThread::cast(current);\n+  }\n+  return inflate(locking_thread, current, object, cause);\n+}\n+\n+ObjectMonitor* ObjectSynchronizer::inflate(JavaThread* locking_thread, Thread* current, oop object,\n+                                           const InflateCause cause) {\n+  assert(current == Thread::current(), \"must be\");\n+  \/\/ locking_thread != nullptr implies that the thread is safe to look into including\n+  \/\/ reading and modifying it's lock stack. This is always valid if current == locking_thread\n+  \/\/ When called with locking_thread != nullptr and locking_thread != current some mechanism\n+  \/\/ must synchronize the locking_thread with respect to the current thread. Currently only\n+  \/\/ used when deoptimizing and re-locking locks. See Deoptimization::relock_objects\n+  assert(locking_thread == nullptr || locking_thread == current ||\n+         locking_thread->is_obj_deopt_suspend(), \"must be\");\n@@ -1309,2 +1344,2 @@\n-    \/\/                   is anonymous and the current thread owns the\n-    \/\/                   object lock, then we make the current thread the\n+    \/\/                   is anonymous and the locking_thread owns the\n+    \/\/                   object lock, then we make the locking_thread the\n@@ -1312,1 +1347,1 @@\n-    \/\/                   current thread's lock stack.\n+    \/\/                   locking_thread's lock stack.\n@@ -1324,3 +1359,3 @@\n-      if (LockingMode == LM_LIGHTWEIGHT && inf->is_owner_anonymous() && is_lock_owned(current, object)) {\n-        inf->set_owner_from_anonymous(current);\n-        JavaThread::cast(current)->lock_stack().remove(object);\n+      if (LockingMode == LM_LIGHTWEIGHT && inf->is_owner_anonymous() && is_lock_owned(locking_thread, object)) {\n+        inf->set_owner_from_anonymous(locking_thread);\n+        locking_thread->lock_stack().remove(object);\n@@ -1346,1 +1381,1 @@\n-    \/\/ Could be fast-locked either by current or by some other thread.\n+    \/\/ Could be fast-locked either by locking_thread or by some other thread.\n@@ -1359,1 +1394,1 @@\n-      bool own = is_lock_owned(current, object);\n+      bool own = is_lock_owned(locking_thread, object);\n@@ -1362,1 +1397,1 @@\n-        monitor->set_owner_from(nullptr, current);\n+        monitor->set_owner_from(nullptr, locking_thread);\n@@ -1372,1 +1407,1 @@\n-          JavaThread::cast(current)->lock_stack().remove(object);\n+          locking_thread->lock_stack().remove(object);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":58,"deletions":23,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -95,0 +95,1 @@\n+  static void enter(Handle obj, BasicLock* lock, JavaThread* locking_thread, JavaThread* current);\n@@ -113,0 +114,1 @@\n+  static ObjectMonitor* inflate(JavaThread* locking_thread, Thread* current, oop obj, const InflateCause cause);\n@@ -190,0 +192,1 @@\n+  static void handle_sync_on_value_based_class(Handle obj, JavaThread* locking_thread, JavaThread* current);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -123,0 +123,36 @@\n+ * @bug 8324881\n+ * @comment Regression test for using the wrong thread when logging during re-locking from deoptimization.\n+ *\n+ * @comment DiagnoseSyncOnValueBasedClasses=2 will cause logging when locking on \\@ValueBased objects.\n+ * @run driver EATests\n+ *                 -XX:+UnlockDiagnosticVMOptions\n+ *                 -Xms256m -Xmx256m\n+ *                 -Xbootclasspath\/a:.\n+ *                 -XX:CompileCommand=dontinline,*::dontinline_*\n+ *                 -XX:+WhiteBoxAPI\n+ *                 -Xbatch\n+ *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n+ *                 -XX:LockingMode=1\n+ *                 -XX:DiagnoseSyncOnValueBasedClasses=2\n+ *\n+ * @comment Re-lock may inflate monitors when re-locking, which cause monitorinflation trace logging.\n+ * @run driver EATests\n+ *                 -XX:+UnlockDiagnosticVMOptions\n+ *                 -Xms256m -Xmx256m\n+ *                 -Xbootclasspath\/a:.\n+ *                 -XX:CompileCommand=dontinline,*::dontinline_*\n+ *                 -XX:+WhiteBoxAPI\n+ *                 -Xbatch\n+ *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n+ *                 -XX:LockingMode=0\n+ *                 -Xlog:monitorinflation=trace\n+ * @run driver EATests\n+ *                 -XX:+UnlockDiagnosticVMOptions\n+ *                 -Xms256m -Xmx256m\n+ *                 -Xbootclasspath\/a:.\n+ *                 -XX:CompileCommand=dontinline,*::dontinline_*\n+ *                 -XX:+WhiteBoxAPI\n+ *                 -Xbatch\n+ *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n+ *                 -XX:LockingMode=2\n+ *                 -Xlog:monitorinflation=trace\n@@ -124,0 +160,1 @@\n+\n@@ -262,0 +299,1 @@\n+        new EARelockingValueBasedTarget()                                                   .run();\n@@ -384,0 +422,1 @@\n+        new EARelockingValueBased()                                                   .run(this);\n@@ -2144,0 +2183,26 @@\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/**\n+ * Test relocking eliminated @ValueBased object.\n+ *\/\n+class EARelockingValueBased extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        @SuppressWarnings(\"unused\")\n+        ObjectReference o = getLocalRef(bpe.thread().frame(1), Integer.class.getName(), \"l1\");\n+    }\n+}\n+\n+class EARelockingValueBasedTarget extends EATestCaseBaseTarget {\n+\n+    public void dontinline_testMethod() {\n+        Integer l1 = new Integer(255);\n+        synchronized (l1) {\n+            dontinline_brkpt();\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/com\/sun\/jdi\/EATests.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"modified"}]}