{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.lang.classfile.constantpool.ConstantPool;\n@@ -32,0 +31,2 @@\n+\n+import jdk.internal.classfile.impl.TransformImpl;\n@@ -74,8 +75,0 @@\n-    \/**\n-     * {@return whether the provided constant pool is compatible with this builder}\n-     * @param source the constant pool to test compatibility with\n-     *\/\n-    default boolean canWriteDirect(ConstantPool source) {\n-        return constantPool().canWriteDirect(source);\n-    }\n-\n@@ -86,0 +79,1 @@\n+     * @return this builder\n@@ -87,1 +81,1 @@\n-    default void transform(CompoundElement<E> model, ClassFileTransform<?, E, B> transform) {\n+    default B transform(CompoundElement<E> model, ClassFileTransform<?, E, B> transform) {\n@@ -90,1 +84,1 @@\n-        var resolved = transform.resolve(builder);\n+        var resolved = TransformImpl.resolve(transform, builder);\n@@ -94,0 +88,1 @@\n+        return builder;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassFileBuilder.java","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import java.util.function.Consumer;\n@@ -127,42 +126,0 @@\n-\n-    \/**\n-     * The result of binding a transform to a builder.  Used primarily within\n-     * the implementation to perform transformation.\n-     *\n-     * @param <E> the element type\n-     *\n-     * @since 22\n-     *\/\n-    @PreviewFeature(feature = PreviewFeature.Feature.CLASSFILE_API)\n-    interface ResolvedTransform<E extends ClassFileElement> {\n-        \/**\n-         * {@return a {@link Consumer} to receive elements}\n-         *\/\n-        Consumer<E> consumer();\n-\n-        \/**\n-         * {@return an action to call at the end of transformation}\n-         *\/\n-        Runnable endHandler();\n-\n-        \/**\n-         * {@return an action to call at the start of transformation}\n-         *\/\n-        Runnable startHandler();\n-    }\n-\n-    \/**\n-     * Bind a transform to a builder.  If the transform is chained, intermediate\n-     * builders are created for each chain link.  If the transform is stateful\n-     * (see, e.g., {@link ClassTransform#ofStateful(Supplier)}), the supplier is\n-     * invoked to get a fresh transform object.\n-     *\n-     * <p>This method is a low-level method that should rarely be used by\n-     * user code; most of the time, user code should prefer\n-     * {@link ClassFileBuilder#transform(CompoundElement, ClassFileTransform)},\n-     * which resolves the transform and executes it on the current builder.\n-     *\n-     * @param builder the builder to bind to\n-     * @return the bound result\n-     *\/\n-    ResolvedTransform<E> resolve(B builder);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassFileTransform.java","additions":1,"deletions":44,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -174,11 +174,0 @@\n-\n-    \/**\n-     * @implSpec The default implementation returns a resolved transform bound\n-     *           to the given class builder.\n-     *\/\n-    @Override\n-    default ResolvedTransform<ClassElement> resolve(ClassBuilder builder) {\n-        return new TransformImpl.ResolvedTransformImpl<>(e -> accept(builder, e),\n-                                                         () -> atEnd(builder),\n-                                                         () -> atStart(builder));\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassTransform.java","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -89,0 +89,2 @@\n+\n+import jdk.internal.classfile.impl.TransformImpl;\n@@ -193,1 +195,1 @@\n-        var resolved = transform.resolve(this);\n+        var resolved = TransformImpl.resolve(transform, this);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/CodeBuilder.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,11 +99,0 @@\n-\n-    \/**\n-     * @implSpec The default implementation returns a resolved transform bound\n-     *           to the given code builder.\n-     *\/\n-    @Override\n-    default ResolvedTransform<CodeElement> resolve(CodeBuilder builder) {\n-        return new TransformImpl.ResolvedTransformImpl<>(e -> accept(builder, e),\n-                                                         () -> atEnd(builder),\n-                                                         () -> atStart(builder));\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/CodeTransform.java","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -114,11 +114,0 @@\n-\n-    \/**\n-     * @implSpec The default implementation returns a resolved transform bound\n-     *           to the given field builder.\n-     *\/\n-    @Override\n-    default ResolvedTransform<FieldElement> resolve(FieldBuilder builder) {\n-        return new TransformImpl.ResolvedTransformImpl<>(e -> accept(builder, e),\n-                                                         () -> atEnd(builder),\n-                                                         () -> atStart(builder));\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/FieldTransform.java","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -114,11 +114,0 @@\n-    \/**\n-     * @implSpec The default implementation returns a resolved transform bound\n-     *           to the given method builder.\n-     *\/\n-    @Override\n-    default ResolvedTransform<MethodElement> resolve(MethodBuilder builder) {\n-        return new TransformImpl.ResolvedTransformImpl<>(e -> accept(builder, e),\n-                                                         () -> atEnd(builder),\n-                                                         () -> atStart(builder));\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/MethodTransform.java","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import java.lang.classfile.constantpool.ConstantPool;\n@@ -46,0 +47,4 @@\n+    public boolean canWriteDirect(ConstantPool source) {\n+        return constantPool().canWriteDirect(source);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractDirectBuilder.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -100,2 +100,1 @@\n-                        fm.fieldTypeSymbol()), fb ->\n-                                fm.forEachElement(asFieldTransform().resolve(fb).consumer()));\n+                        fm.fieldTypeSymbol()), fb -> fb.transform(fm, asFieldTransform()));\n@@ -104,2 +103,1 @@\n-                        mm.methodTypeSymbol()), mm.flags().flagsMask(), mb ->\n-                                mm.forEachElement(asMethodTransform().resolve(mb).consumer()));\n+                        mm.methodTypeSymbol()), mm.flags().flagsMask(), mb -> mb.transform(mm, asMethodTransform()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassRemapperImpl.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import java.lang.classfile.ClassFileBuilder;\n+import java.lang.classfile.ClassFileTransform;\n@@ -35,1 +37,0 @@\n-import java.lang.classfile.ClassFileTransform;\n@@ -49,1 +50,1 @@\n-public class TransformImpl {\n+public final class TransformImpl {\n@@ -61,1 +62,17 @@\n-    interface UnresolvedClassTransform extends ClassTransform {\n+    public static <E extends ClassFileElement, B extends ClassFileBuilder<E, B>>\n+            ResolvedTransform<E> resolve(ClassFileTransform<?, E, B> transform, B builder) {\n+        if (transform instanceof ResolvableTransform) {\n+            @SuppressWarnings(\"unchecked\")\n+            var ut = (ResolvableTransform<E, B>) transform;\n+            return ut.resolve(builder);\n+        }\n+        return new ResolvedTransform<>(e -> transform.accept(builder, e),\n+            () -> transform.atEnd(builder),\n+            () -> transform.atStart(builder));\n+    }\n+\n+    interface ResolvableTransform<E extends ClassFileElement, B extends ClassFileBuilder<E, B>> {\n+        ResolvedTransform<E> resolve(B builder);\n+    }\n+\n+    interface UnresolvedClassTransform extends ClassTransform, ResolvableTransform<ClassElement, ClassBuilder> {\n@@ -78,1 +95,1 @@\n-    public record ResolvedTransformImpl<E extends ClassFileElement>(Consumer<E> consumer,\n+    public record ResolvedTransform<E extends ClassFileElement>(Consumer<E> consumer,\n@@ -80,2 +97,1 @@\n-                                     Runnable startHandler)\n-            implements ClassFileTransform.ResolvedTransform<E> {\n+                                     Runnable startHandler) {\n@@ -83,1 +99,1 @@\n-        public ResolvedTransformImpl(Consumer<E> consumer) {\n+        public ResolvedTransform(Consumer<E> consumer) {\n@@ -92,2 +108,2 @@\n-        public ResolvedTransformImpl<ClassElement> resolve(ClassBuilder builder) {\n-            ResolvedTransform<ClassElement> downstream = next.resolve(builder);\n+        public ResolvedTransform<ClassElement> resolve(ClassBuilder builder) {\n+            ResolvedTransform<ClassElement> downstream = TransformImpl.resolve(next, builder);\n@@ -95,2 +111,2 @@\n-            ResolvedTransform<ClassElement> upstream = t.resolve(chainedBuilder);\n-            return new ResolvedTransformImpl<>(upstream.consumer(),\n+            ResolvedTransform<ClassElement> upstream = TransformImpl.resolve(t, chainedBuilder);\n+            return new ResolvedTransform<>(upstream.consumer(),\n@@ -106,1 +122,1 @@\n-            return supplier.get().resolve(builder);\n+            return TransformImpl.resolve(supplier.get(), builder);\n@@ -115,1 +131,1 @@\n-            return new ResolvedTransformImpl<>(ce -> {\n+            return new ResolvedTransform<>(ce -> {\n@@ -138,1 +154,1 @@\n-            return new ResolvedTransformImpl<>(ce -> {\n+            return new ResolvedTransform<>(ce -> {\n@@ -158,1 +174,1 @@\n-    interface UnresolvedMethodTransform extends MethodTransform {\n+    interface UnresolvedMethodTransform extends MethodTransform, ResolvableTransform<MethodElement, MethodBuilder> {\n@@ -180,1 +196,1 @@\n-            ResolvedTransform<MethodElement> downstream = next.resolve(builder);\n+            ResolvedTransform<MethodElement> downstream = TransformImpl.resolve(next, builder);\n@@ -182,2 +198,2 @@\n-            ResolvedTransform<MethodElement> upstream = t.resolve(chainedBuilder);\n-            return new ResolvedTransformImpl<>(upstream.consumer(),\n+            ResolvedTransform<MethodElement> upstream = TransformImpl.resolve(t, chainedBuilder);\n+            return new ResolvedTransform<>(upstream.consumer(),\n@@ -193,1 +209,1 @@\n-            return supplier.get().resolve(builder);\n+            return TransformImpl.resolve(supplier.get(), builder);\n@@ -201,1 +217,1 @@\n-            return new ResolvedTransformImpl<>(me -> {\n+            return new ResolvedTransform<>(me -> {\n@@ -222,1 +238,1 @@\n-    interface UnresolvedFieldTransform extends FieldTransform {\n+    interface UnresolvedFieldTransform extends FieldTransform, ResolvableTransform<FieldElement, FieldBuilder> {\n@@ -243,1 +259,1 @@\n-            ResolvedTransform<FieldElement> downstream = next.resolve(builder);\n+            ResolvedTransform<FieldElement> downstream = TransformImpl.resolve(next, builder);\n@@ -245,2 +261,2 @@\n-            ResolvedTransform<FieldElement> upstream = t.resolve(chainedBuilder);\n-            return new ResolvedTransformImpl<>(upstream.consumer(),\n+            ResolvedTransform<FieldElement> upstream = TransformImpl.resolve(t, chainedBuilder);\n+            return new ResolvedTransform<>(upstream.consumer(),\n@@ -256,1 +272,1 @@\n-            return supplier.get().resolve(builder);\n+            return TransformImpl.resolve(supplier.get(), builder);\n@@ -262,1 +278,1 @@\n-    interface UnresolvedCodeTransform extends CodeTransform {\n+    interface UnresolvedCodeTransform extends CodeTransform, ResolvableTransform<CodeElement, CodeBuilder> {\n@@ -283,1 +299,1 @@\n-            ResolvedTransform<CodeElement> downstream = next.resolve(builder);\n+            ResolvedTransform<CodeElement> downstream = TransformImpl.resolve(next, builder);\n@@ -285,2 +301,2 @@\n-            ResolvedTransform<CodeElement> upstream = t.resolve(chainedBuilder);\n-            return new ResolvedTransformImpl<>(upstream.consumer(),\n+            ResolvedTransform<CodeElement> upstream = TransformImpl.resolve(t, chainedBuilder);\n+            return new ResolvedTransform<>(upstream.consumer(),\n@@ -296,1 +312,1 @@\n-            return supplier.get().resolve(builder);\n+            return TransformImpl.resolve(supplier.get(), builder);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/TransformImpl.java","additions":47,"deletions":31,"binary":false,"changes":78,"status":"modified"}]}