{"files":[{"patch":"@@ -884,2 +884,1 @@\n-                Matchable testClassMatchable = testClassParser.parse(testVMProcess.getHotspotPidFileName(),\n-                                                                     testVMProcess.getApplicableIRRules());\n+                Matchable testClassMatchable = testClassParser.parse(testVMProcess.testVmData());\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import compiler.lib.ir_framework.driver.network.TestVMData;\n@@ -61,1 +62,0 @@\n-    private String hotspotPidFileName;\n@@ -64,1 +64,1 @@\n-    private String applicableIRRules;\n+    private final TestVMData testVmData;\n@@ -75,1 +75,0 @@\n-        processSocketOutput(socket);\n@@ -77,0 +76,2 @@\n+        String hotspotPidFileName = String.format(\"hotspot_pid%d.log\", oa.pid());\n+        testVmData = socket.testVmData(hotspotPidFileName, allowNotCompilable);\n@@ -83,6 +84,2 @@\n-    public String getApplicableIRRules() {\n-        return applicableIRRules;\n-    }\n-\n-    public String getHotspotPidFileName() {\n-        return hotspotPidFileName;\n+    public TestVMData testVmData() {\n+        return testVmData;\n@@ -175,1 +172,0 @@\n-        hotspotPidFileName = String.format(\"hotspot_pid%d.log\", oa.pid());\n@@ -179,45 +175,0 @@\n-    \/**\n-     * Process the socket output: All prefixed lines are dumped to the standard output while the remaining lines\n-     * represent the Applicable IR Rules used for IR matching later.\n-     *\/\n-    private void processSocketOutput(TestFrameworkSocket socket) {\n-        String output = socket.getOutput();\n-        if (socket.hasStdOut()) {\n-            StringBuilder testListBuilder = new StringBuilder();\n-            StringBuilder messagesBuilder = new StringBuilder();\n-            StringBuilder nonStdOutBuilder = new StringBuilder();\n-            Scanner scanner = new Scanner(output);\n-            while (scanner.hasNextLine()) {\n-                String line = scanner.nextLine();\n-                if (line.startsWith(TestFrameworkSocket.STDOUT_PREFIX)) {\n-                    \/\/ Exclude [STDOUT] from message.\n-                    line = line.substring(TestFrameworkSocket.STDOUT_PREFIX.length());\n-                    if (line.startsWith(TestFrameworkSocket.TESTLIST_TAG)) {\n-                        \/\/ Exclude [TESTLIST] from message for better formatting.\n-                        line = \"> \" + line.substring(TestFrameworkSocket.TESTLIST_TAG.length() + 1);\n-                        testListBuilder.append(line).append(System.lineSeparator());\n-                    } else {\n-                        messagesBuilder.append(line).append(System.lineSeparator());\n-                    }\n-                } else {\n-                    nonStdOutBuilder.append(line).append(System.lineSeparator());\n-                }\n-            }\n-            System.out.println();\n-            if (!testListBuilder.isEmpty()) {\n-                System.out.println(\"Run flag defined test list\");\n-                System.out.println(\"--------------------------\");\n-                System.out.println(testListBuilder);\n-                System.out.println();\n-            }\n-            if (!messagesBuilder.isEmpty()) {\n-                System.out.println(\"Messages from Test VM\");\n-                System.out.println(\"---------------------\");\n-                System.out.println(messagesBuilder);\n-            }\n-            applicableIRRules = nonStdOutBuilder.toString();\n-        } else {\n-            applicableIRRules = output;\n-        }\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/TestVMProcess.java","additions":6,"deletions":55,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import compiler.lib.ir_framework.driver.network.TestVMData;\n@@ -56,1 +57,1 @@\n-    public Matchable parse(String hotspotPidFileName, String applicableIRRules) {\n+    public Matchable parse(TestVMData testVmData) {\n@@ -58,2 +59,2 @@\n-        TestMethods testMethods = applicableIRRulesParser.parse(applicableIRRules);\n-        VMInfo vmInfo = VMInfoParser.parseVMInfo(applicableIRRules);\n+        TestMethods testMethods = applicableIRRulesParser.parse(testVmData.applicableIRRules());\n+        VMInfo vmInfo = VMInfoParser.parseVMInfo(testVmData.applicableIRRules());\n@@ -62,1 +63,1 @@\n-            LoggedMethods loggedMethods = hotSpotPidFileParser.parse(hotspotPidFileName);\n+            LoggedMethods loggedMethods = hotSpotPidFileParser.parse(testVmData.hotspotPidFileName());\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/TestClassParser.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.network;\n+\n+import compiler.lib.ir_framework.driver.irmatching.IRMatcher;\n+import compiler.lib.ir_framework.driver.network.testvm.java.JavaMessages;\n+import compiler.lib.ir_framework.shared.TestFrameworkSocket;\n+import compiler.lib.ir_framework.test.network.MessageTag;\n+\n+import java.util.Scanner;\n+\n+\/**\n+ * This class collects all the parsed data received over the {@link TestFrameworkSocket}. This data is required later\n+ * in the {@link IRMatcher}.\n+ *\/\n+public class TestVMData {\n+    private final boolean allowNotCompilable;\n+    private final String hotspotPidFileName;\n+    private final String applicableIRRules;\n+\n+    public TestVMData(JavaMessages javaMessages, String hotspotPidFileName, boolean allowNotCompilable) {\n+        this.applicableIRRules = processOutput(javaMessages);\n+        this.hotspotPidFileName = hotspotPidFileName;\n+        this.allowNotCompilable = allowNotCompilable;\n+    }\n+\n+    public String hotspotPidFileName() {\n+        return hotspotPidFileName;\n+    }\n+\n+    public boolean allowNotCompilable() {\n+        return allowNotCompilable;\n+    }\n+\n+    public String applicableIRRules() {\n+        return applicableIRRules;\n+    }\n+\n+    \/**\n+     * Process the socket output: All prefixed lines are dumped to the standard output while the remaining lines\n+     * represent the Applicable IR Rules used for IR matching later.\n+     *\/\n+    private String processOutput(JavaMessages javaMessages) {\n+        String output = javaMessages.output();\n+        if (javaMessages.hasStdOut()) {\n+            StringBuilder testListBuilder = new StringBuilder();\n+            StringBuilder messagesBuilder = new StringBuilder();\n+            StringBuilder nonStdOutBuilder = new StringBuilder();\n+            Scanner scanner = new Scanner(output);\n+            while (scanner.hasNextLine()) {\n+                String line = scanner.nextLine();\n+                if (line.startsWith(MessageTag.STDOUT)) {\n+                    \/\/ Exclude [STDOUT] from message.\n+                    line = line.substring(MessageTag.STDOUT.length());\n+                    if (line.startsWith(MessageTag.TEST_LIST)) {\n+                        \/\/ Exclude [TEST_LIST] from message for better formatting.\n+                        line = \"> \" + line.substring(MessageTag.TEST_LIST.length() + 1);\n+                        testListBuilder.append(line).append(System.lineSeparator());\n+                    } else {\n+                        messagesBuilder.append(line).append(System.lineSeparator());\n+                    }\n+                } else {\n+                    nonStdOutBuilder.append(line).append(System.lineSeparator());\n+                }\n+            }\n+            System.out.println();\n+            if (!testListBuilder.isEmpty()) {\n+                System.out.println(\"Run flag defined test list\");\n+                System.out.println(\"--------------------------\");\n+                System.out.println(testListBuilder);\n+                System.out.println();\n+            }\n+            if (!messagesBuilder.isEmpty()) {\n+                System.out.println(\"Messages from Test VM\");\n+                System.out.println(\"---------------------\");\n+                System.out.println(messagesBuilder);\n+            }\n+            return nonStdOutBuilder.toString();\n+        } else {\n+            return output;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/network\/TestVMData.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.network.testvm;\n+\n+import compiler.lib.ir_framework.driver.network.testvm.java.JavaMessages;\n+import compiler.lib.ir_framework.shared.TestFrameworkException;\n+import compiler.lib.ir_framework.shared.TestFrameworkSocket;\n+import compiler.lib.ir_framework.test.network.MessageTag;\n+\n+import java.io.BufferedReader;\n+import java.net.Socket;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.Future;\n+\n+\/**\n+ * Dedicated reader for Test VM messages received by the {@link TestFrameworkSocket}. The reader is used as a task\n+ * wrapped in a {@link Future}. The received messages are returned in a new {@link JavaMessages} wrapper. Once the\n+ * Test VM is terminated, the client connection is closed and the parsed messages can be fetched with\n+ * {@link Future#get()} which calls {@link #call()}.\n+ *\/\n+public class TestVmMessageReader implements Callable<JavaMessages> {\n+    private final Socket socket;\n+    private final BufferedReader reader;\n+    private boolean receivedStdOut;\n+\n+    public TestVmMessageReader(Socket socket, BufferedReader reader) {\n+        this.socket = socket;\n+        this.reader = reader;\n+        this.receivedStdOut = false;\n+    }\n+\n+    @Override\n+    public JavaMessages call() {\n+        try (socket; reader) {\n+            StringBuilder builder = new StringBuilder();\n+            String line;\n+            while ((line = reader.readLine()) != null) {\n+                builder.append(line).append(System.lineSeparator());\n+                if (line.startsWith(MessageTag.STDOUT)) {\n+                    receivedStdOut = true;\n+                }\n+            }\n+            return new JavaMessages(builder.toString(), receivedStdOut);\n+        } catch (Exception e) {\n+            throw new TestFrameworkException(\"Error while reading Test VM socket messages\", e);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/network\/testvm\/TestVmMessageReader.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.network.testvm.java;\n+\n+import compiler.lib.ir_framework.test.network.MessageTag;\n+\n+\/**\n+ * Class to collect all Java messages sent from the Test VM to the Driver VM.\n+ *\/\n+public class JavaMessages {\n+    private final String output;\n+    private final boolean receivedStdOut;\n+\n+    public JavaMessages(String output, boolean receivedStdOut) {\n+        this.output = output;\n+        this.receivedStdOut = receivedStdOut;\n+    }\n+\n+    public String output() {\n+        return output;\n+    }\n+\n+    \/**\n+     * Return whether Test VM sent messages to be put on stdout (starting with {@link MessageTag#STDOUT}).\n+     *\/\n+    public boolean hasStdOut() {\n+        return receivedStdOut;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/network\/testvm\/java\/JavaMessages.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -27,0 +27,3 @@\n+import compiler.lib.ir_framework.driver.network.*;\n+import compiler.lib.ir_framework.driver.network.testvm.TestVmMessageReader;\n+import compiler.lib.ir_framework.driver.network.testvm.java.JavaMessages;\n@@ -31,7 +34,2 @@\n-import java.io.PrintWriter;\n-import java.net.InetAddress;\n-import java.net.InetSocketAddress;\n-import java.net.ServerSocket;\n-import java.net.Socket;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.FutureTask;\n+import java.net.*;\n+import java.util.concurrent.*;\n@@ -40,1 +38,1 @@\n- * Dedicated socket to send data from the flag and Test VM back to the Driver VM.\n+ * Dedicated Driver VM socket to receive data from the Test VM. Could either be received from Java and C2 code.\n@@ -43,7 +41,0 @@\n-    public static final String STDOUT_PREFIX = \"[STDOUT]\";\n-    public static final String TESTLIST_TAG = \"[TESTLIST]\";\n-    public static final String DEFAULT_REGEX_TAG = \"[DEFAULT_REGEX]\";\n-    public static final String PRINT_TIMES_TAG = \"[PRINT_TIMES]\";\n-    public static final String NOT_COMPILABLE_TAG = \"[NOT_COMPILABLE]\";\n-\n-    \/\/ Static fields used for Test VM only.\n@@ -51,5 +42,0 @@\n-    private static final int SERVER_PORT = Integer.getInteger(SERVER_PORT_PROPERTY, -1);\n-\n-    private static final boolean REPRODUCE = Boolean.getBoolean(\"Reproduce\");\n-    private static Socket clientSocket = null;\n-    private static PrintWriter clientWriter = null;\n@@ -57,2 +43,1 @@\n-    private final String serverPortPropertyFlag;\n-    private FutureTask<String> socketTask;\n+    private final int serverSocketPort;\n@@ -60,1 +45,3 @@\n-    private boolean receivedStdOut = false;\n+    private boolean running;\n+    private final ExecutorService executor;\n+    private Future<JavaMessages> javaFuture;\n@@ -69,1 +56,2 @@\n-        int port = serverSocket.getLocalPort();\n+        serverSocketPort = serverSocket.getLocalPort();\n+        executor = Executors.newCachedThreadPool();\n@@ -71,1 +59,1 @@\n-            System.out.println(\"TestFramework server socket uses port \" + port);\n+            System.out.println(\"TestFramework server socket uses port \" + serverSocketPort);\n@@ -73,1 +61,0 @@\n-        serverPortPropertyFlag = \"-D\" + SERVER_PORT_PROPERTY + \"=\" + port;\n@@ -78,1 +65,1 @@\n-        return serverPortPropertyFlag;\n+        return \"-D\" + SERVER_PORT_PROPERTY + \"=\" + serverSocketPort;\n@@ -82,3 +69,2 @@\n-        socketTask = initSocketTask();\n-        Thread socketThread = new Thread(socketTask);\n-        socketThread.start();\n+        running = true;\n+        executor.submit(this::acceptLoop);\n@@ -88,1 +74,1 @@\n-     * Waits for a client (created by flag or Test VM) to connect. Return the messages received from the client.\n+     * Main loop to wait for new client connections and handling them upon connection request.\n@@ -90,15 +76,9 @@\n-    private FutureTask<String> initSocketTask() {\n-        return new FutureTask<>(() -> {\n-            try (Socket clientSocket = serverSocket.accept();\n-                 BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()))\n-            ) {\n-                StringBuilder builder = new StringBuilder();\n-                String next;\n-                while ((next = in.readLine()) != null) {\n-                    builder.append(next).append(System.lineSeparator());\n-                    if (next.startsWith(STDOUT_PREFIX)) {\n-                        receivedStdOut = true;\n-                    }\n-                }\n-                return builder.toString();\n-            } catch (IOException e) {\n+    private void acceptLoop() {\n+        while (running) {\n+            try {\n+                acceptNewClientConnection();\n+            } catch (TestFrameworkException e) {\n+                running = false;\n+                throw e;\n+            } catch (Exception e) {\n+                running = false;\n@@ -107,9 +87,0 @@\n-        });\n-    }\n-\n-    @Override\n-    public void close() {\n-        try {\n-            serverSocket.close();\n-        } catch (IOException e) {\n-            throw new TestFrameworkException(\"Could not close socket\", e);\n@@ -120,1 +91,1 @@\n-     * Only called by Test VM to write to server socket.\n+     * Accept new client connection and then submit a task accordingly to manage incoming message on that connection\/socket.\n@@ -122,2 +93,4 @@\n-    public static void write(String msg, String tag) {\n-        write(msg, tag, false);\n+    private void acceptNewClientConnection() throws IOException {\n+        Socket client = serverSocket.accept();\n+        BufferedReader reader = new BufferedReader(new InputStreamReader(client.getInputStream()));\n+        submitTask(client, reader);\n@@ -127,7 +100,2 @@\n-     * Only called by Test VM to write to server socket.\n-     * <p>\n-     * The Test VM is spawned by the main jtreg VM. The stdout of the Test VM is hidden\n-     * unless the Verbose or ReportStdout flag is used. TestFrameworkSocket is used by the parent jtreg\n-     * VM and the Test VM to communicate. By sending the prints through the TestFrameworkSocket with the\n-     * parameter stdout set to true, the parent VM will print the received messages to its stdout, making it\n-     * visible to the user.\n+     * Submit dedicated tasks which are wrapped into {@link Future} objects. The tasks will read all messages sent\n+     * over that connection.\n@@ -135,7 +103,6 @@\n-    public static void write(String msg, String tag, boolean stdout) {\n-        if (REPRODUCE) {\n-            System.out.println(\"Debugging Test VM: Skip writing due to -DReproduce\");\n-            return;\n-        }\n-        TestFramework.check(SERVER_PORT != -1, \"Server port was not set correctly for flag and\/or Test VM \"\n-                                               + \"or method not called from flag or Test VM\");\n+    private void submitTask(Socket client, BufferedReader reader) {\n+        javaFuture = executor.submit(new TestVmMessageReader(client, reader));\n+    }\n+\n+    @Override\n+    public void close() {\n@@ -143,24 +110,4 @@\n-            \/\/ Keep the client socket open until the Test VM terminates (calls closeClientSocket before exiting main()).\n-            if (clientSocket == null) {\n-                clientSocket = new Socket(InetAddress.getLoopbackAddress(), SERVER_PORT);\n-                clientWriter = new PrintWriter(clientSocket.getOutputStream(), true);\n-            }\n-            if (stdout) {\n-                msg = STDOUT_PREFIX + tag + \" \" + msg;\n-            }\n-            clientWriter.println(msg);\n-        } catch (Exception e) {\n-            \/\/ When the Test VM is directly run, we should ignore all messages that would normally be sent to the\n-            \/\/ Driver VM.\n-            String failMsg = System.lineSeparator() + System.lineSeparator() + \"\"\"\n-                             ###########################################################\n-                              Did you directly run the Test VM (TestVM class)\n-                              to reproduce a bug?\n-                              => Append the flag -DReproduce=true and try again!\n-                             ###########################################################\n-                             \"\"\";\n-            throw new TestRunException(failMsg, e);\n-        }\n-        if (TestFramework.VERBOSE) {\n-            System.out.println(\"Written \" + tag + \" to socket:\");\n-            System.out.println(msg);\n+            running = false;\n+            serverSocket.close();\n+        } catch (IOException e) {\n+            throw new TestFrameworkException(\"Could not close socket\", e);\n@@ -168,0 +115,1 @@\n+        executor.shutdown();\n@@ -170,13 +118,3 @@\n-    \/**\n-     * Closes (and flushes) the printer to the socket and the socket itself. Is called as last thing before exiting\n-     * the main() method of the flag and the Test VM.\n-     *\/\n-    public static void closeClientSocket() {\n-        if (clientSocket != null) {\n-            try {\n-                clientWriter.close();\n-                clientSocket.close();\n-            } catch (IOException e) {\n-                throw new RuntimeException(\"Could not close TestVM socket\", e);\n-            }\n-        }\n+    public TestVMData testVmData(String hotspotPidFileName, boolean allowNotCompilable) {\n+        JavaMessages javaMessages = testVmMessages();\n+        return new TestVMData(javaMessages, hotspotPidFileName, allowNotCompilable);\n@@ -185,4 +123,1 @@\n-    \/**\n-     * Get the socket output of the Flag VM.\n-     *\/\n-    public String getOutput() {\n+    private JavaMessages testVmMessages() {\n@@ -190,1 +125,1 @@\n-            return socketTask.get();\n+            return javaFuture.get();\n@@ -192,2 +127,1 @@\n-            \/\/ Thrown when socket task was not finished, yet (i.e. no client sent data) but socket was already closed.\n-            return \"\";\n+            throw new TestFrameworkException(\"No test VM messages were received\", e);\n@@ -195,1 +129,1 @@\n-            throw new TestFrameworkException(\"Could not read from socket task\", e);\n+            throw new TestFrameworkException(\"Error while fetching Test VM Future\", e);\n@@ -198,7 +132,0 @@\n-\n-    \/**\n-     * Return whether Test VM sent messages to be put on stdout (starting with {@link ::STDOUT_PREFIX}).\n-     *\/\n-    public boolean hasStdOut() {\n-        return receivedStdOut;\n-    }\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/TestFrameworkSocket.java","additions":51,"deletions":124,"binary":false,"changes":175,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import compiler.lib.ir_framework.test.network.TestVmSocket;\n@@ -35,2 +36,0 @@\n-import compiler.lib.ir_framework.shared.TestFrameworkSocket;\n-\n@@ -121,1 +120,1 @@\n-            TestFrameworkSocket.write(\"Method not compilable: \" + testMethod, TestFrameworkSocket.NOT_COMPILABLE_TAG, true);\n+            TestVmSocket.send(\"Method not compilable: \" + testMethod);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/AbstractTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import compiler.lib.ir_framework.test.network.MessageTag;\n+import compiler.lib.ir_framework.test.network.TestVmSocket;\n@@ -172,3 +174,2 @@\n-        TestFrameworkSocket.write(\"Disabling IR matching for rule \" + ruleIndex + \" of \" + ruleMax + \" in \" +\n-                                  method + \": \" + reason + \": \" + String.join(\", \", apply),\n-                                  \"[ApplicableIRRules]\", true);\n+        TestVmSocket.send(\"Disabling IR matching for rule \" + ruleIndex + \" of \" + ruleMax + \" in \" + method + \": \" +\n+                                  reason + \": \" + String.join(\", \", apply));\n@@ -287,1 +288,1 @@\n-            TestFrameworkSocket.write(\"Skip Rule \" + ruleIndex + \": \" + e.getMessage(), TestFrameworkSocket.DEFAULT_REGEX_TAG, true);\n+            TestVmSocket.send(\"Skip Rule \" + ruleIndex + \": \" + e.getMessage());\n@@ -525,1 +526,1 @@\n-        TestFrameworkSocket.write(output.toString(), \"ApplicableIRRules\");\n+        TestVmSocket.sendWithTag(MessageTag.APPLICABLE_IR_RULES, output.toString());\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/ApplicableIRRulesPrinter.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import compiler.lib.ir_framework.test.network.MessageTag;\n+import compiler.lib.ir_framework.test.network.TestVmSocket;\n@@ -41,2 +43,0 @@\n-import static compiler.lib.ir_framework.shared.TestFrameworkSocket.PRINT_TIMES_TAG;\n-\n@@ -162,0 +162,1 @@\n+            TestVmSocket.connect();\n@@ -170,1 +171,1 @@\n-            TestFrameworkSocket.closeClientSocket();\n+            TestVmSocket.close();\n@@ -862,1 +863,1 @@\n-                TestFrameworkSocket.write(\"Run \" + test.toString(), TestFrameworkSocket.TESTLIST_TAG, true);\n+                TestVmSocket.send(MessageTag.TEST_LIST + \"Run \" + test.toString());\n@@ -890,1 +891,1 @@\n-            TestFrameworkSocket.write(\"Test execution times:\", PRINT_TIMES_TAG, true);\n+            TestVmSocket.send(MessageTag.PRINT_TIMES + \" Test execution times:\");\n@@ -892,2 +893,1 @@\n-                TestFrameworkSocket.write(String.format(\"%-25s%15d ns%n\", entry.getValue() + \":\", entry.getKey()),\n-                        PRINT_TIMES_TAG, true);\n+                TestVmSocket.send(MessageTag.PRINT_TIMES + String.format(\"%-25s%15d ns%n\", entry.getValue() + \":\", entry.getKey()));\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/TestVM.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -26,1 +26,2 @@\n-import compiler.lib.ir_framework.shared.TestFrameworkSocket;\n+import compiler.lib.ir_framework.test.network.MessageTag;\n+import compiler.lib.ir_framework.test.network.TestVmSocket;\n@@ -68,1 +69,1 @@\n-        TestFrameworkSocket.write(vmInfo.toString(), \"VMInfo\");\n+        TestVmSocket.sendWithTag(MessageTag.VM_INFO, vmInfo.toString());\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/VMInfoPrinter.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.test.network;\n+\n+public class MessageTag {\n+    public static final String STDOUT = \"[STDOUT]\";\n+    public static final String TEST_LIST = \"[TEST_LIST]\";\n+    public static final String PRINT_TIMES = \"[PRINT_TIMES]\";\n+    public static final String VM_INFO = \"[VM_INFO]\";\n+    public static final String APPLICABLE_IR_RULES = \"[APPLICABLE_IR_RULES]\";\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/network\/MessageTag.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.test.network;\n+\n+import compiler.lib.ir_framework.TestFramework;\n+import compiler.lib.ir_framework.shared.TestRunException;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+\n+public class TestVmSocket {\n+    private static final boolean REPRODUCE = Boolean.getBoolean(\"Reproduce\");\n+    private static final String SERVER_PORT_PROPERTY = \"ir.framework.server.port\";\n+    private static final int SERVER_PORT = Integer.getInteger(SERVER_PORT_PROPERTY, -1);\n+\n+    private static Socket socket = null;\n+    private static PrintWriter writer = null;\n+\n+    \/**\n+     * Send a message to the Driver VM which is unconditionally shown in the Driver VM output.\n+     *\/\n+    public static void send(String message) {\n+        sendWithTag(MessageTag.STDOUT, message);\n+    }\n+\n+    \/**\n+     * Send a message to the Driver VM with a {@link MessageTag}. Not all messages are shown by default in the\n+     * Driver VM output and require setting some property flags first like {@code -DPrintTimes=true}.\n+     *\/\n+    public static void sendWithTag(String tag, String message) {\n+        if (REPRODUCE) {\n+            \/\/ Debugging Test VM: Skip writing due to -DReproduce;\n+            return;\n+        }\n+\n+        TestFramework.check(socket != null, \"must be connected\");\n+        writer.println(tag + \" \" + message);\n+    }\n+\n+    public static void connect() {\n+        if (REPRODUCE) {\n+            \/\/ Debugging Test VM: Skip writing due to -DReproduce;\n+            return;\n+        }\n+\n+        TestFramework.check(SERVER_PORT != -1, \"Server port was not set correctly for flag and\/or test VM \"\n+                + \"or method not called from flag or test VM\");\n+\n+        try {\n+            \/\/ Keep the client socket open until the test VM terminates (calls closeClientSocket before exiting main()).\n+            socket = new Socket(InetAddress.getLoopbackAddress(), SERVER_PORT);\n+            writer = new PrintWriter(socket.getOutputStream(), true);\n+        } catch (Exception e) {\n+            \/\/ When the test VM is directly run, we should ignore all messages that would normally be sent to the\n+            \/\/ driver VM.\n+            String failMsg = System.lineSeparator() + System.lineSeparator() + \"\"\"\n+                             ###########################################################\n+                              Did you directly run the test VM (TestVM class)\n+                              to reproduce a bug?\n+                              => Append the flag -DReproduce=true and try again!\n+                             ###########################################################\n+                             \"\"\";\n+            throw new TestRunException(failMsg, e);\n+        }\n+\n+    }\n+\n+    \/**\n+     * Closes (and flushes) the printer to the socket and the socket itself. Is called as last thing before exiting\n+     * the main() method of the flag and the test VM.\n+     *\/\n+    public static void close() {\n+        if (socket != null) {\n+            writer.close();\n+            try {\n+                socket.close();\n+            } catch (IOException e) {\n+                throw new RuntimeException(\"Could not close TestVM socket\", e);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/network\/TestVmSocket.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -72,2 +72,1 @@\n-        Matchable testClassMatchable = testClassParser.parse(testVMProcess.getHotspotPidFileName(),\n-                                                             testVMProcess.getApplicableIRRules());\n+        Matchable testClassMatchable = testClassParser.parse(testVMProcess.testVmData());\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestPhaseIRMatching.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}