{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import javax.print.attribute.standard.Chromaticity;\n@@ -76,0 +77,2 @@\n+    private boolean monochrome = false;\n+\n@@ -215,0 +218,5 @@\n+\n+        PrintService service = getPrintService();\n+        Chromaticity chromaticity = (Chromaticity)attributes.get(Chromaticity.class);\n+        monochrome = chromaticity == Chromaticity.MONOCHROME && service != null &&\n+                service.isAttributeCategorySupported(Chromaticity.class);\n@@ -791,0 +799,3 @@\n+                if (monochrome) {\n+                    pathGraphics = new GrayscaleProxyGraphics2D(pathGraphics, printerJob);\n+                }\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CPrinterJob.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,211 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.print;\n+\n+\n+import java.awt.Color;\n+import java.awt.GradientPaint;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Image;\n+import java.awt.LinearGradientPaint;\n+import java.awt.Paint;\n+import java.awt.RadialGradientPaint;\n+import java.awt.TexturePaint;\n+import java.awt.color.ColorSpace;\n+import java.awt.geom.AffineTransform;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.BufferedImageOp;\n+import java.awt.image.ImageObserver;\n+import java.awt.image.RenderedImage;\n+import java.awt.print.PrinterJob;\n+\n+\/**\n+ * Proxy class to print with grayscale.\n+ * Convert Colors, Paints and Images to the grayscale.\n+ *\n+ *\/\n+public class GrayscaleProxyGraphics2D extends ProxyGraphics2D {\n+\n+    \/**\n+     * The new ProxyGraphics2D will forward all graphics\n+     * calls to 'graphics'.\n+     *\n+     * @param graphics\n+     * @param printerJob\n+     *\/\n+    public GrayscaleProxyGraphics2D(Graphics2D graphics, PrinterJob printerJob) {\n+        super(graphics, printerJob);\n+    }\n+\n+    @Override\n+    public void setBackground(Color color) {\n+        Color gcolor = getGrayscaleColor(color);\n+        super.setBackground(gcolor);\n+    }\n+\n+    @Override\n+    public void setColor(Color c) {\n+        Color gcolor = getGrayscaleColor(c);\n+        super.setColor(gcolor);\n+    }\n+\n+    @Override\n+    public void setPaint(Paint paint) {\n+        if (paint instanceof Color color) {\n+            super.setPaint(getGrayscaleColor(color));\n+        } else if (paint instanceof TexturePaint texturePaint) {\n+            super.setPaint(new TexturePaint(getGrayscaleImage(texturePaint.getImage()), texturePaint.getAnchorRect()));\n+        } else if (paint instanceof GradientPaint gradientPaint) {\n+            super.setPaint(new GradientPaint(gradientPaint.getPoint1(),\n+                    getGrayscaleColor(gradientPaint.getColor1()),\n+                    gradientPaint.getPoint2(),\n+                    getGrayscaleColor(gradientPaint.getColor2()),\n+                    gradientPaint.isCyclic()));\n+        } else if (paint instanceof LinearGradientPaint linearGradientPaint) {\n+            Color[] colors = new Color[linearGradientPaint.getColors().length];\n+            Color[] oldColors = linearGradientPaint.getColors();\n+            for (int i = 0; i < colors.length; i++) {\n+                colors[i] = getGrayscaleColor(oldColors[i]);\n+            }\n+            super.setPaint(new LinearGradientPaint(linearGradientPaint.getStartPoint(),\n+                    linearGradientPaint.getEndPoint(),\n+                    linearGradientPaint.getFractions(),\n+                    colors,\n+                    linearGradientPaint.getCycleMethod(),\n+                    linearGradientPaint.getColorSpace(),\n+                    linearGradientPaint.getTransform()\n+            ));\n+        } else if (paint instanceof RadialGradientPaint radialGradientPaint) {\n+            Color[] colors = new Color[radialGradientPaint.getColors().length];\n+            Color[] oldColors = radialGradientPaint.getColors();\n+            for (int i = 0; i < colors.length; i++) {\n+                colors[i] = getGrayscaleColor(oldColors[i]);\n+            }\n+            super.setPaint(new RadialGradientPaint(radialGradientPaint.getCenterPoint(),\n+                    radialGradientPaint.getRadius(),\n+                    radialGradientPaint.getFocusPoint(),\n+                    radialGradientPaint.getFractions(),\n+                    colors,\n+                    radialGradientPaint.getCycleMethod(),\n+                    radialGradientPaint.getColorSpace(),\n+                    radialGradientPaint.getTransform()));\n+        } else if (paint == null) {\n+            super.setPaint(paint);\n+        } else {\n+            throw new IllegalArgumentException(\"Unsupported Paint\");\n+        }\n+    }\n+\n+    @Override\n+    public void drawRenderedImage(RenderedImage img, AffineTransform xform) {\n+        BufferedImage grayImage = new BufferedImage(img.getWidth() + img.getTileWidth(),\n+                img.getHeight() + img.getTileHeight(), BufferedImage.TYPE_BYTE_GRAY);\n+        Graphics2D g2 = grayImage.createGraphics();\n+        g2.drawRenderedImage(img, new AffineTransform());\n+        g2.dispose();\n+        super.drawRenderedImage(getGrayscaleImage(grayImage), xform);\n+    }\n+\n+    @Override\n+    public boolean drawImage(Image img, int dx1, int dy1, int dx2, int dy2, int sx1, int sy1, int sx2, int sy2,\n+                             Color bgcolor, ImageObserver observer) {\n+        return super.drawImage(getGrayscaleImage(img), dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, bgcolor, observer);\n+    }\n+\n+    @Override\n+    public boolean drawImage(Image img, int dx1, int dy1, int dx2, int dy2, int sx1, int sy1, int sx2, int sy2,\n+                             ImageObserver observer) {\n+        return super.drawImage(getGrayscaleImage(img), dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, observer);\n+    }\n+\n+    @Override\n+    public boolean drawImage(Image img, int x, int y, int width, int height, Color bgcolor, ImageObserver observer) {\n+        return super.drawImage(getGrayscaleImage(img), x, y, width, height, bgcolor, observer);\n+    }\n+\n+    @Override\n+    public boolean drawImage(Image img, int x, int y, Color bgcolor, ImageObserver observer) {\n+        return super.drawImage(getGrayscaleImage(img), x, y, bgcolor, observer);\n+    }\n+\n+    @Override\n+    public boolean drawImage(Image img, int x, int y, int width, int height, ImageObserver observer) {\n+        return super.drawImage(getGrayscaleImage(img), x, y, width, height, observer);\n+    }\n+\n+    @Override\n+    public boolean drawImage(Image img, int x, int y, ImageObserver observer) {\n+        return super.drawImage(getGrayscaleImage(img), x, y, observer);\n+    }\n+\n+    @Override\n+    public void drawImage(BufferedImage img, BufferedImageOp op, int x, int y) {\n+        super.drawImage(getGrayscaleImage(img), op, x, y);\n+    }\n+\n+    @Override\n+    public boolean drawImage(Image img, AffineTransform xform, ImageObserver obs) {\n+        return super.drawImage(getGrayscaleImage(img), xform, obs);\n+    }\n+\n+    \/**\n+     * Returns grayscale variant of the input Color\n+     * @param color color to transform to grayscale\n+     * @return grayscale color\n+     *\/\n+    private Color getGrayscaleColor(Color color) {\n+        if (color == null) {\n+            return null;\n+        }\n+        float[] gcolor = color.getComponents(ColorSpace.getInstance(ColorSpace.CS_GRAY), null);\n+        return switch (gcolor.length) {\n+            case 1 -> new Color(gcolor[0], gcolor[0], gcolor[0]);\n+            case 2 -> new Color(gcolor[0], gcolor[0], gcolor[0], gcolor[1]);\n+            default -> throw new IllegalArgumentException(\"Unknown grayscale color. \" +\n+                    \"Expected 1 or 2 components, received \" + gcolor.length + \" components.\");\n+        };\n+    }\n+\n+    \/**\n+     * Converts Image to a grayscale\n+     * @param img colored image\n+     * @return grayscale BufferedImage\n+     *\/\n+    private BufferedImage getGrayscaleImage(Image img) {\n+        if (img == null) {\n+            return null;\n+        }\n+        BufferedImage grayImage = new BufferedImage(img.getWidth(null), img.getHeight(null),\n+                BufferedImage.TYPE_BYTE_GRAY);\n+        Graphics grayGraphics = grayImage.getGraphics();\n+        grayGraphics.drawImage(img, 0, 0, null);\n+        grayGraphics.dispose();\n+        return grayImage;\n+    }\n+\n+}\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/GrayscaleProxyGraphics2D.java","additions":211,"deletions":0,"binary":false,"changes":211,"status":"added"},{"patch":"@@ -575,2 +575,9 @@\n-                Chromaticity[]arr = new Chromaticity[1];\n-                arr[0] = Chromaticity.COLOR;\n+                Chromaticity[] arr;\n+                if (PrintServiceLookupProvider.isMac()) {\n+                    arr = new Chromaticity[2];\n+                    arr[0] = Chromaticity.COLOR;\n+                    arr[1] = Chromaticity.MONOCHROME;\n+                } else {\n+                    arr = new Chromaticity[1];\n+                    arr[0] = Chromaticity.COLOR;\n+                }\n@@ -1403,1 +1410,1 @@\n-                return attr == Chromaticity.COLOR;\n+                return PrintServiceLookupProvider.isMac() || attr == Chromaticity.COLOR;\n","filename":"src\/java.desktop\/unix\/classes\/sun\/print\/IPPPrintService.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,272 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import javax.print.PrintService;\n+import javax.print.PrintServiceLookup;\n+import javax.print.attribute.HashPrintRequestAttributeSet;\n+import javax.print.attribute.PrintRequestAttributeSet;\n+import javax.print.attribute.Size2DSyntax;\n+import javax.print.attribute.standard.Chromaticity;\n+import javax.print.attribute.standard.MediaSize;\n+import javax.print.attribute.standard.MediaSizeName;\n+import javax.swing.JButton;\n+import javax.swing.JComboBox;\n+import javax.swing.JFrame;\n+import javax.swing.JLabel;\n+import javax.swing.JList;\n+import javax.swing.JPanel;\n+import javax.swing.ListCellRenderer;\n+import javax.swing.border.EmptyBorder;\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.GridLayout;\n+import java.awt.LinearGradientPaint;\n+import java.awt.MultipleGradientPaint;\n+import java.awt.Paint;\n+import java.awt.RadialGradientPaint;\n+import java.awt.Window;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.image.BufferedImage;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @bug 8315113\n+ * @key printer\n+ * @requires (os.family == \"mac\")\n+ * @summary javax.print: Support monochrome printing\n+ * @run main\/manual MonochromePrintTest\n+ *\/\n+\n+public class MonochromePrintTest {\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+           This test checks availability of the monochrome printing\n+           on color printers.\n+           To be able to run this test it is required to have a color\n+           printer configured in your user environment.\n+           Test's steps:\n+             - Choose a printer.\n+             - Press 'Print' button.\n+           Visual inspection of the printed pages is needed.\n+           A passing test will print two pages with\n+           color and grayscale appearances\n+           \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PrintService[] availablePrintServices = getTestablePrintServices();\n+        if (availablePrintServices.length == 0) {\n+            System.out.println(\"Available print services not found\");\n+            return;\n+        }\n+        PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .testTimeOut(300)\n+                .title(\"Monochrome printing\")\n+                .testUI(createTestWindow(availablePrintServices))\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Window createTestWindow(final PrintService[] availablePrintServices) {\n+        Window frame = new JFrame(\"Choose service to test\");\n+        JPanel pnlMain = new JPanel();\n+        pnlMain.setBorder(new EmptyBorder(5,5,5,5));\n+        pnlMain.setLayout(new GridLayout(3, 1, 5, 5));\n+        JLabel lblServices = new JLabel(\"Available services\");\n+        JComboBox<PrintService> cbServices = new JComboBox<>();\n+        JButton btnPrint = new JButton(\"Print\");\n+        btnPrint.setEnabled(false);\n+        cbServices.setRenderer(new ListCellRenderer<PrintService>() {\n+            @Override\n+            public Component getListCellRendererComponent(JList<? extends PrintService> list, PrintService value,\n+                                                          int index, boolean isSelected, boolean cellHasFocus) {\n+                return new JLabel(value == null ? \"\" : value.getName());\n+            }\n+        });\n+        cbServices.addActionListener(new ActionListener() {\n+            @Override\n+            public void actionPerformed(ActionEvent e) {\n+                btnPrint.setEnabled(cbServices.getSelectedItem() != null);\n+            }\n+        });\n+        for (PrintService ps : availablePrintServices) {\n+            cbServices.addItem(ps);\n+        }\n+        lblServices.setLabelFor(cbServices);\n+        btnPrint.addActionListener(new ActionListener() {\n+            @Override\n+            public void actionPerformed(ActionEvent e) {\n+                PrintService printService = (PrintService) cbServices.getSelectedItem();\n+                if (printService != null) {\n+                    cbServices.setEnabled(false);\n+                    btnPrint.setEnabled(false);\n+                    test(printService);\n+                }\n+            }\n+        });\n+        pnlMain.add(lblServices);\n+        pnlMain.add(cbServices);\n+        pnlMain.add(btnPrint);\n+        frame.add(pnlMain);\n+        frame.pack();\n+        return frame;\n+    }\n+\n+    private static PrintService[] getTestablePrintServices() {\n+        List<PrintService> testablePrintServices = new ArrayList<>();\n+        for (PrintService ps : PrintServiceLookup.lookupPrintServices(null,null)) {\n+            if (ps.isAttributeValueSupported(Chromaticity.MONOCHROME, null, null) &&\n+                    ps.isAttributeValueSupported(Chromaticity.COLOR, null, null)) {\n+                testablePrintServices.add(ps);\n+            }\n+        }\n+        return testablePrintServices.toArray(new PrintService[0]);\n+    }\n+\n+    private static void test(PrintService printService) {\n+        try {\n+            print(printService, Chromaticity.COLOR);\n+            print(printService, Chromaticity.MONOCHROME);\n+        } catch (PrinterException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    private static void print(PrintService printService, Chromaticity chromaticity)\n+            throws PrinterException {\n+        PrintRequestAttributeSet attr = new HashPrintRequestAttributeSet();\n+        attr.add(chromaticity);\n+        PrinterJob job = PrinterJob.getPrinterJob();\n+        job.setPrintService(printService);\n+        job.setJobName(\"Print with \" + chromaticity);\n+        job.setPrintable(new ChromaticityAttributePrintable(chromaticity));\n+        job.print(attr);\n+    }\n+\n+    private static class ChromaticityAttributePrintable implements Printable {\n+\n+        private final Chromaticity chromaticity;\n+\n+        public ChromaticityAttributePrintable(Chromaticity chromaticity) {\n+            this.chromaticity = chromaticity;\n+        }\n+\n+        @Override\n+        public int print(Graphics graphics, PageFormat pageFormat, int pageIndex) {\n+\n+            if (pageIndex != 0) {\n+                return NO_SUCH_PAGE;\n+            }\n+\n+            final int sx = (int) Math.ceil(pageFormat.getImageableX());\n+            final int sy = (int) Math.ceil(pageFormat.getImageableY());\n+\n+            Graphics2D g = (Graphics2D) graphics;\n+\n+            BufferedImage bufferdImage = getBufferedImage((int) Math.ceil(pageFormat.getImageableWidth() \/ 3),\n+                    (int) Math.ceil(pageFormat.getImageableHeight() \/ 7));\n+            g.drawImage(bufferdImage, null, sx, sy);\n+\n+            double defaultMediaSizeWidth = MediaSize.getMediaSizeForName(MediaSizeName.ISO_A4)\n+                    .getX(Size2DSyntax.INCH) * 72;\n+            double scale = pageFormat.getWidth() \/ defaultMediaSizeWidth;\n+\n+            final int squareSideLenngth = (int)(50 * scale);\n+            final int offset = (int)(10 * scale);\n+            int imh = sy + (int) Math.ceil(pageFormat.getImageableHeight() \/ 7) + offset;\n+\n+            g.setColor(Color.ORANGE);\n+            g.drawRect(sx, imh, squareSideLenngth, squareSideLenngth);\n+            imh = imh + squareSideLenngth + offset;\n+\n+            g.setColor(Color.BLUE);\n+            g.fillOval(sx, imh, squareSideLenngth, squareSideLenngth);\n+            imh = imh + squareSideLenngth + offset;\n+\n+            Paint paint = new LinearGradientPaint(0, 0,\n+                    squareSideLenngth>>1, offset>>1, new float[]{0.0f, 0.2f, 1.0f},\n+                    new Color[]{Color.RED, Color.GREEN, Color.CYAN}, MultipleGradientPaint.CycleMethod.REPEAT);\n+            g.setPaint(paint);\n+            g.setStroke(new BasicStroke(squareSideLenngth));\n+            g.fillRect(sx, imh + offset, squareSideLenngth, squareSideLenngth);\n+            imh = imh + squareSideLenngth + offset;\n+\n+            paint = new RadialGradientPaint(offset, offset, offset>>1, new float[]{0.0f, 0.5f, 1.0f},\n+                    new Color[]{Color.RED, Color.GREEN, Color.CYAN}, MultipleGradientPaint.CycleMethod.REPEAT);\n+            g.setPaint(paint);\n+            g.fillRect(sx, imh + offset, squareSideLenngth, squareSideLenngth);\n+            imh = imh + squareSideLenngth + offset;\n+\n+            g.setStroke(new BasicStroke(offset>>1));\n+            g.setColor(Color.PINK);\n+            g.drawString(\"This page should be \" + chromaticity, sx, imh + squareSideLenngth);\n+\n+            return PAGE_EXISTS;\n+        }\n+\n+        private BufferedImage getBufferedImage(int width, int height) {\n+            Color[] colors = new Color[]{\n+                    Color.RED, Color.ORANGE, Color.BLUE,\n+                    Color.CYAN, Color.MAGENTA, Color.GREEN\n+            };\n+            BufferedImage bufferedImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\n+            final int secondSquareOffset = width \/ 3;\n+            final int thirdSquareOffset = secondSquareOffset * 2;\n+            final int squareHeight = height \/ 2;\n+\n+            int offset = 0;\n+            Color color;\n+            for (int y = 0; y < height; y++) {\n+                if (y > squareHeight) {\n+                    offset = 3;\n+                }\n+                for (int x = 0; x < width; x++) {\n+                    if (x >= thirdSquareOffset) {\n+                        color = colors[offset + 2];\n+                    } else if (x >= secondSquareOffset) {\n+                        color = colors[offset + 1];\n+                    } else {\n+                        color = colors[offset];\n+                    }\n+                    bufferedImage.setRGB(x, y, color.getRGB());\n+                }\n+            }\n+            return bufferedImage;\n+        }\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/javax\/print\/attribute\/MonochromePrintTest.java","additions":272,"deletions":0,"binary":false,"changes":272,"status":"added"}]}