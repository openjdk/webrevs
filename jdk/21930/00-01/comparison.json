{"files":[{"patch":"@@ -1,165 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2024, BELLSOFT. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.print;\n-\n-\n-import java.awt.Color;\n-import java.awt.GradientPaint;\n-import java.awt.Graphics;\n-import java.awt.Graphics2D;\n-import java.awt.Image;\n-import java.awt.LinearGradientPaint;\n-import java.awt.Paint;\n-import java.awt.RadialGradientPaint;\n-import java.awt.TexturePaint;\n-import java.awt.color.ColorSpace;\n-import java.awt.image.BufferedImage;\n-import java.awt.image.ColorConvertOp;\n-import java.awt.print.PrinterJob;\n-\n-\/**\n- * Proxy class to print with grayscale.\n- * Override methods:\n- * <ul>\n- *     <li>{@link #setColor(Color)}<\/li>\n- *     <li>{@link #setPaint(Paint)}<\/li>\n- * <\/ul>\n- * and change input Colors and Paints to grayscale.\n- * It uses {@link ColorConvertOp} to convert colors and images to grayscale.\n- *\n- *\/\n-public class GrayscaleProxyGraphics2D extends ProxyGraphics2D {\n-\n-    \/**\n-     * Color converter\n-     *\/\n-    private final ColorConvertOp monochromeConverter =\n-            new ColorConvertOp(ColorSpace.getInstance(ColorSpace.CS_GRAY), null);\n-\n-    \/**\n-     * buffered image is used to convert colors\n-     *\/\n-    private final BufferedImage monochromeImg = new BufferedImage(1, 1, BufferedImage.TYPE_INT_RGB);\n-\n-    \/**\n-     * The new ProxyGraphics2D will forward all graphics\n-     * calls to 'graphics'.\n-     *\n-     * @param graphics\n-     * @param printerJob\n-     *\/\n-    public GrayscaleProxyGraphics2D(Graphics2D graphics, PrinterJob printerJob) {\n-        super(graphics, printerJob);\n-    }\n-\n-    @Override\n-    public void setColor(Color c) {\n-        Color gcolor = getGrayscaleColor(c);\n-        super.setColor(gcolor);\n-    }\n-\n-    @Override\n-    public void setPaint(Paint paint) {\n-        if (paint instanceof Color color) {\n-            super.setPaint(getGrayscaleColor(color));\n-        } else if (paint instanceof TexturePaint texturePaint) {\n-            super.setPaint(new TexturePaint(getGrayscaleImage(texturePaint.getImage()), texturePaint.getAnchorRect()));\n-        } else if (paint instanceof GradientPaint gradientPaint) {\n-            super.setPaint(new GradientPaint(gradientPaint.getPoint1(),\n-                    getGrayscaleColor(gradientPaint.getColor1()),\n-                    gradientPaint.getPoint2(),\n-                    getGrayscaleColor(gradientPaint.getColor2()),\n-                    gradientPaint.isCyclic()));\n-        } else if (paint instanceof LinearGradientPaint linearGradientPaint) {\n-            Color[] colors = new Color[linearGradientPaint.getColors().length];\n-            Color[] oldColors = linearGradientPaint.getColors();\n-            for (int i = 0; i < colors.length; i++) {\n-                colors[i] = getGrayscaleColor(oldColors[i]);\n-            }\n-            super.setPaint(new LinearGradientPaint(linearGradientPaint.getStartPoint(),\n-                    linearGradientPaint.getEndPoint(),\n-                    linearGradientPaint.getFractions(),\n-                    colors,\n-                    linearGradientPaint.getCycleMethod(),\n-                    linearGradientPaint.getColorSpace(),\n-                    linearGradientPaint.getTransform()\n-            ));\n-        } else if (paint instanceof RadialGradientPaint radialGradientPaint) {\n-            Color[] colors = new Color[radialGradientPaint.getColors().length];\n-            Color[] oldColors = radialGradientPaint.getColors();\n-            for (int i = 0; i < colors.length; i++) {\n-                colors[i] = getGrayscaleColor(oldColors[i]);\n-            }\n-            super.setPaint(new RadialGradientPaint(radialGradientPaint.getCenterPoint(),\n-                    radialGradientPaint.getRadius(),\n-                    radialGradientPaint.getFocusPoint(),\n-                    radialGradientPaint.getFractions(),\n-                    colors,\n-                    radialGradientPaint.getCycleMethod(),\n-                    radialGradientPaint.getColorSpace(),\n-                    radialGradientPaint.getTransform()));\n-        } else {\n-            super.setPaint(paint);\n-        }\n-    }\n-\n-    \/**\n-     * Returns grayscale variant of the input Color\n-     * @param color color to transform to grayscale\n-     * @return grayscale color\n-     *\/\n-    private Color getGrayscaleColor(Color color) {\n-        monochromeImg.setRGB(0, 0, color.getRGB());\n-        convertToMonochrome(monochromeImg);\n-        int[] data = monochromeImg.getData().getPixel(0, 0, new int[3]);\n-        Color grayColor = new Color(data[0], data[1], data[2]);\n-        return grayColor;\n-    }\n-\n-    \/**\n-     * Converts Image to a grayscale\n-     * @param img colored image\n-     * @return grayscale BufferedImage\n-     *\/\n-    private BufferedImage getGrayscaleImage(Image img) {\n-        BufferedImage grayImage = new BufferedImage(img.getWidth(null), img.getHeight(null), BufferedImage.TYPE_INT_ARGB);\n-        Graphics grayGraphics = grayImage.getGraphics();\n-        grayGraphics.drawImage(img, 0, 0, null);\n-        grayGraphics.dispose();\n-        convertToMonochrome(grayImage);\n-        return grayImage;\n-    }\n-\n-    \/**\n-     * Convert provided colored BufferdImage to the grayscale image\n-     * @param img image to be converted\n-     *\/\n-    private void convertToMonochrome(BufferedImage img) {\n-        monochromeConverter.filter(img, img);\n-    }\n-\n-}\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/GrayscaleProxyGraphics2D.java","additions":0,"deletions":165,"binary":false,"changes":165,"status":"deleted"},{"patch":"@@ -30,0 +30,1 @@\n+import java.awt.GradientPaint;\n@@ -33,0 +34,3 @@\n+import java.awt.LinearGradientPaint;\n+import java.awt.Paint;\n+import java.awt.RadialGradientPaint;\n@@ -34,0 +38,1 @@\n+import java.awt.TexturePaint;\n@@ -68,0 +73,2 @@\n+    private final BufferedImage colorConverterImg = new BufferedImage(1, 1, BufferedImage.TYPE_INT_RGB);\n+\n@@ -787,0 +794,85 @@\n+    @Override\n+    public void setColor(Color c) {\n+        PSPrinterJob psPrinterJob = (PSPrinterJob) getPrinterJob();\n+        if (psPrinterJob.monochrome) {\n+            super.setColor(getGrayscaleColor(c));\n+        }\n+        super.setColor(c);\n+    }\n+\n+    @Override\n+    public void setPaint(Paint paint) {\n+        PSPrinterJob psPrinterJob = (PSPrinterJob) getPrinterJob();\n+        if (!psPrinterJob.monochrome) {\n+            super.setPaint(paint);\n+            return;\n+        }\n+        if (paint instanceof Color color) {\n+            super.setPaint(getGrayscaleColor(color));\n+        } else if (paint instanceof TexturePaint texturePaint) {\n+            super.setPaint(new TexturePaint(getGrayscaleImage(texturePaint.getImage()), texturePaint.getAnchorRect()));\n+        } else if (paint instanceof GradientPaint gradientPaint) {\n+            super.setPaint(new GradientPaint(gradientPaint.getPoint1(),\n+                    getGrayscaleColor(gradientPaint.getColor1()),\n+                    gradientPaint.getPoint2(),\n+                    getGrayscaleColor(gradientPaint.getColor2()),\n+                    gradientPaint.isCyclic()));\n+        } else if (paint instanceof LinearGradientPaint linearGradientPaint) {\n+            Color[] colors = new Color[linearGradientPaint.getColors().length];\n+            Color[] oldColors = linearGradientPaint.getColors();\n+            for (int i = 0; i < colors.length; i++) {\n+                colors[i] = getGrayscaleColor(oldColors[i]);\n+            }\n+            super.setPaint(new LinearGradientPaint(linearGradientPaint.getStartPoint(),\n+                    linearGradientPaint.getEndPoint(),\n+                    linearGradientPaint.getFractions(),\n+                    colors,\n+                    linearGradientPaint.getCycleMethod(),\n+                    linearGradientPaint.getColorSpace(),\n+                    linearGradientPaint.getTransform()\n+            ));\n+        } else if (paint instanceof RadialGradientPaint radialGradientPaint) {\n+            Color[] colors = new Color[radialGradientPaint.getColors().length];\n+            Color[] oldColors = radialGradientPaint.getColors();\n+            for (int i = 0; i < colors.length; i++) {\n+                colors[i] = getGrayscaleColor(oldColors[i]);\n+            }\n+            super.setPaint(new RadialGradientPaint(radialGradientPaint.getCenterPoint(),\n+                    radialGradientPaint.getRadius(),\n+                    radialGradientPaint.getFocusPoint(),\n+                    radialGradientPaint.getFractions(),\n+                    colors,\n+                    radialGradientPaint.getCycleMethod(),\n+                    radialGradientPaint.getColorSpace(),\n+                    radialGradientPaint.getTransform()));\n+        } else {\n+            super.setPaint(paint);\n+        }\n+    }\n+\n+    \/**\n+     * Converts Image to a grayscale\n+     * @param img colored image\n+     * @return grayscale BufferedImage\n+     *\/\n+    private BufferedImage getGrayscaleImage(Image img) {\n+        BufferedImage grayImage = new BufferedImage(img.getWidth(null), img.getHeight(null), BufferedImage.TYPE_INT_ARGB);\n+        Graphics grayGraphics = grayImage.getGraphics();\n+        grayGraphics.drawImage(img, 0, 0, null);\n+        grayGraphics.dispose();\n+        ((PSPrinterJob)getPrinterJob()).monochromeConverter.filter(grayImage, grayImage);\n+        return grayImage;\n+    }\n+\n+    \/**\n+     * Returns grayscale variant of the input Color\n+     * @param color color to transform to grayscale\n+     * @return grayscale color\n+     *\/\n+    private Color getGrayscaleColor(Color color) {\n+        colorConverterImg.setRGB(0, 0, color.getRGB());\n+        ((PSPrinterJob)getPrinterJob()).monochromeConverter.filter(colorConverterImg, colorConverterImg);\n+        int[] data = colorConverterImg.getData().getPixel(0, 0, new int[3]);\n+        return new Color(data[0], data[1], data[2]);\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/PSPathGraphics.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -1092,3 +1092,1 @@\n-            if (monochrome) {\n-                bufferedGraphics = new GrayscaleProxyGraphics2D(bufferedGraphics, printerJob);\n-            }\n+\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/PSPrinterJob.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"}]}