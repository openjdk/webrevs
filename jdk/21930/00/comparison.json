{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -794,1 +794,12 @@\n-                painter.print(pathGraphics, FlipPageFormat.getOriginal(page), pageIndex);\n+                if (monochrome) {\n+                    BufferedImage bufferedImage = new BufferedImage((int)page.getWidth(), (int)page.getHeight(),\n+                            BufferedImage.TYPE_INT_ARGB);\n+                    Graphics2D g2 = bufferedImage.createGraphics();\n+                    g2.setFont(delegate.getFont());\n+                    painter.print(g2, FlipPageFormat.getOriginal(page), pageIndex);\n+                    g2.dispose();\n+                    monochromeConverter.filter(bufferedImage, bufferedImage);\n+                    pathGraphics.drawImage(bufferedImage, null, 0, 0);\n+                } else {\n+                    painter.print(pathGraphics, FlipPageFormat.getOriginal(page), pageIndex);\n+                }\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CPrinterJob.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,165 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.print;\n+\n+\n+import java.awt.Color;\n+import java.awt.GradientPaint;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Image;\n+import java.awt.LinearGradientPaint;\n+import java.awt.Paint;\n+import java.awt.RadialGradientPaint;\n+import java.awt.TexturePaint;\n+import java.awt.color.ColorSpace;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorConvertOp;\n+import java.awt.print.PrinterJob;\n+\n+\/**\n+ * Proxy class to print with grayscale.\n+ * Override methods:\n+ * <ul>\n+ *     <li>{@link #setColor(Color)}<\/li>\n+ *     <li>{@link #setPaint(Paint)}<\/li>\n+ * <\/ul>\n+ * and change input Colors and Paints to grayscale.\n+ * It uses {@link ColorConvertOp} to convert colors and images to grayscale.\n+ *\n+ *\/\n+public class GrayscaleProxyGraphics2D extends ProxyGraphics2D {\n+\n+    \/**\n+     * Color converter\n+     *\/\n+    private final ColorConvertOp monochromeConverter =\n+            new ColorConvertOp(ColorSpace.getInstance(ColorSpace.CS_GRAY), null);\n+\n+    \/**\n+     * buffered image is used to convert colors\n+     *\/\n+    private final BufferedImage monochromeImg = new BufferedImage(1, 1, BufferedImage.TYPE_INT_RGB);\n+\n+    \/**\n+     * The new ProxyGraphics2D will forward all graphics\n+     * calls to 'graphics'.\n+     *\n+     * @param graphics\n+     * @param printerJob\n+     *\/\n+    public GrayscaleProxyGraphics2D(Graphics2D graphics, PrinterJob printerJob) {\n+        super(graphics, printerJob);\n+    }\n+\n+    @Override\n+    public void setColor(Color c) {\n+        Color gcolor = getGrayscaleColor(c);\n+        super.setColor(gcolor);\n+    }\n+\n+    @Override\n+    public void setPaint(Paint paint) {\n+        if (paint instanceof Color color) {\n+            super.setPaint(getGrayscaleColor(color));\n+        } else if (paint instanceof TexturePaint texturePaint) {\n+            super.setPaint(new TexturePaint(getGrayscaleImage(texturePaint.getImage()), texturePaint.getAnchorRect()));\n+        } else if (paint instanceof GradientPaint gradientPaint) {\n+            super.setPaint(new GradientPaint(gradientPaint.getPoint1(),\n+                    getGrayscaleColor(gradientPaint.getColor1()),\n+                    gradientPaint.getPoint2(),\n+                    getGrayscaleColor(gradientPaint.getColor2()),\n+                    gradientPaint.isCyclic()));\n+        } else if (paint instanceof LinearGradientPaint linearGradientPaint) {\n+            Color[] colors = new Color[linearGradientPaint.getColors().length];\n+            Color[] oldColors = linearGradientPaint.getColors();\n+            for (int i = 0; i < colors.length; i++) {\n+                colors[i] = getGrayscaleColor(oldColors[i]);\n+            }\n+            super.setPaint(new LinearGradientPaint(linearGradientPaint.getStartPoint(),\n+                    linearGradientPaint.getEndPoint(),\n+                    linearGradientPaint.getFractions(),\n+                    colors,\n+                    linearGradientPaint.getCycleMethod(),\n+                    linearGradientPaint.getColorSpace(),\n+                    linearGradientPaint.getTransform()\n+            ));\n+        } else if (paint instanceof RadialGradientPaint radialGradientPaint) {\n+            Color[] colors = new Color[radialGradientPaint.getColors().length];\n+            Color[] oldColors = radialGradientPaint.getColors();\n+            for (int i = 0; i < colors.length; i++) {\n+                colors[i] = getGrayscaleColor(oldColors[i]);\n+            }\n+            super.setPaint(new RadialGradientPaint(radialGradientPaint.getCenterPoint(),\n+                    radialGradientPaint.getRadius(),\n+                    radialGradientPaint.getFocusPoint(),\n+                    radialGradientPaint.getFractions(),\n+                    colors,\n+                    radialGradientPaint.getCycleMethod(),\n+                    radialGradientPaint.getColorSpace(),\n+                    radialGradientPaint.getTransform()));\n+        } else {\n+            super.setPaint(paint);\n+        }\n+    }\n+\n+    \/**\n+     * Returns grayscale variant of the input Color\n+     * @param color color to transform to grayscale\n+     * @return grayscale color\n+     *\/\n+    private Color getGrayscaleColor(Color color) {\n+        monochromeImg.setRGB(0, 0, color.getRGB());\n+        convertToMonochrome(monochromeImg);\n+        int[] data = monochromeImg.getData().getPixel(0, 0, new int[3]);\n+        Color grayColor = new Color(data[0], data[1], data[2]);\n+        return grayColor;\n+    }\n+\n+    \/**\n+     * Converts Image to a grayscale\n+     * @param img colored image\n+     * @return grayscale BufferedImage\n+     *\/\n+    private BufferedImage getGrayscaleImage(Image img) {\n+        BufferedImage grayImage = new BufferedImage(img.getWidth(null), img.getHeight(null), BufferedImage.TYPE_INT_ARGB);\n+        Graphics grayGraphics = grayImage.getGraphics();\n+        grayGraphics.drawImage(img, 0, 0, null);\n+        grayGraphics.dispose();\n+        convertToMonochrome(grayImage);\n+        return grayImage;\n+    }\n+\n+    \/**\n+     * Convert provided colored BufferdImage to the grayscale image\n+     * @param img image to be converted\n+     *\/\n+    private void convertToMonochrome(BufferedImage img) {\n+        monochromeConverter.filter(img, img);\n+    }\n+\n+}\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/GrayscaleProxyGraphics2D.java","additions":165,"deletions":0,"binary":false,"changes":165,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -570,0 +570,3 @@\n+                    if (psPrinterJob.monochrome) {\n+                        psPrinterJob.monochromeConverter.filter(deepImage, deepImage);\n+                    }\n@@ -721,1 +724,3 @@\n-\n+        if (psPrinterJob.monochrome) {\n+            psPrinterJob.monochromeConverter.filter(deepImage, deepImage);\n+        }\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/PSPathGraphics.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1092,1 +1092,3 @@\n-\n+            if (monochrome) {\n+                bufferedGraphics = new GrayscaleProxyGraphics2D(bufferedGraphics, printerJob);\n+            }\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/PSPrinterJob.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.awt.color.ColorSpace;\n+import java.awt.image.ColorConvertOp;\n@@ -72,0 +74,1 @@\n+import javax.print.attribute.standard.Chromaticity;\n@@ -300,0 +303,2 @@\n+    protected boolean monochrome;\n+    protected ColorConvertOp monochromeConverter;\n@@ -1217,0 +1222,5 @@\n+    protected boolean isAttributeCategorySupported(Class<? extends Attribute> category) {\n+        PrintService ps = getPrintService();\n+        return category != null && ps != null && ps.isAttributeCategorySupported(category);\n+    }\n+\n@@ -1457,0 +1467,5 @@\n+        Attribute attr = attributes.get(Chromaticity.class);\n+        monochrome = attr == Chromaticity.MONOCHROME && isAttributeCategorySupported(Chromaticity.class);\n+        if (monochrome && monochromeConverter == null) {\n+            monochromeConverter = new ColorConvertOp(ColorSpace.getInstance(ColorSpace.CS_GRAY), null);\n+        }\n@@ -2446,0 +2461,3 @@\n+                        if (monochrome) {\n+                            monochromeConverter.filter(band, band);\n+                        }\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/RasterPrinterJob.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -582,1 +582,1 @@\n-                Chromaticity[]arr = new Chromaticity[1];\n+                Chromaticity[]arr = new Chromaticity[2];\n@@ -584,0 +584,1 @@\n+                arr[1] = Chromaticity.MONOCHROME;\n","filename":"src\/java.desktop\/unix\/classes\/sun\/print\/IPPPrintService.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,354 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import javax.print.PrintService;\n+import javax.print.attribute.Attribute;\n+import javax.print.attribute.HashPrintRequestAttributeSet;\n+import javax.print.attribute.PrintRequestAttributeSet;\n+import javax.print.attribute.standard.Chromaticity;\n+import javax.print.attribute.standard.MediaSizeName;\n+import javax.swing.JButton;\n+import javax.swing.JDialog;\n+import javax.swing.JPanel;\n+import javax.swing.JTextArea;\n+import javax.swing.SwingUtilities;\n+import java.awt.BasicStroke;\n+import java.awt.BorderLayout;\n+import java.awt.Color;\n+import java.awt.Dialog;\n+import java.awt.FlowLayout;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.LinearGradientPaint;\n+import java.awt.MultipleGradientPaint;\n+import java.awt.Paint;\n+import java.awt.RadialGradientPaint;\n+import java.awt.Window;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.awt.image.BufferedImage;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+import java.util.Arrays;\n+\n+\/*\n+ * @test\n+ * @bug 8315113\n+ * @key printer\n+ * @requires (os.family == \"linux\" | os.family == \"mac\")\n+ * @summary javax.print: Support monochrome printing\n+ *\/\n+\n+public class MonochromePrintTest {\n+\n+    private static final long TIMEOUT = 10 * 60_000;\n+    private static volatile boolean testPassed = true;\n+    private static volatile boolean testSkipped = false;\n+    private static volatile boolean testFinished = false;\n+\n+    private static volatile int testCount;\n+    private static volatile int testTotalCount;\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        final Chromaticity[] supportedChromaticity = getSupportedChromaticity();\n+        if (supportedChromaticity == null || supportedChromaticity.length < 2) {\n+            return;\n+        }\n+\n+        SwingUtilities.invokeLater(() -> {\n+            testTotalCount = supportedChromaticity.length;\n+            for (Chromaticity chromaticity : supportedChromaticity) {\n+                if (testSkipped) {\n+                    break;\n+                }\n+                testPrint(chromaticity, supportedChromaticity);\n+            }\n+            testFinished = true;\n+        });\n+\n+        long time = System.currentTimeMillis() + TIMEOUT;\n+\n+        while (System.currentTimeMillis() < time) {\n+            if (!testPassed || testFinished) {\n+                break;\n+            }\n+            Thread.sleep(500);\n+        }\n+\n+        closeDialogs();\n+\n+        if (testSkipped) {\n+            System.out.printf(\"Test is skipped!%n\");\n+            return;\n+        }\n+\n+        if (!testPassed) {\n+            throw new Exception(\"Test failed!\");\n+        }\n+\n+        if (testCount != testTotalCount) {\n+            throw new Exception(\n+                    \"Timeout: \" + testCount + \" tests passed out from \" + testTotalCount);\n+        }\n+    }\n+\n+    private static void testPrint(Chromaticity chromaticity, Chromaticity[] supportedChromaticity) {\n+\n+        String[] instructions = {\n+                \"Two tests will run and it will test all available color apearances:\",\n+                Arrays.toString(supportedChromaticity) + \"supported by the printer.\",\n+                \"\",\n+                \"The test is \" + (testCount + 1) + \" from \" + testTotalCount + \".\",\n+                \"\",\n+                \"On-screen inspection is not possible for this printing-specific\",\n+                \"test therefore its only output is a page printed to the printer\",\n+                \"\",\n+                \"To be able to run this test it is required to have a default\",\n+                \"printer configured in your user environment.\",\n+                \"\",\n+                \" - Press 'Start Test' button.\",\n+                \"   The print dialog should appear.\",\n+                \" - Select 'Appearance' tab.\",\n+                \" - Select '\" + chromaticity + \"' on the 'Color apearance' panel.\",\n+                \" - Press 'Print' button.\",\n+                \"\",\n+                \"Visual inspection of the printed pages is needed.\",\n+                \"\",\n+                \"A passing test will print the page with color appearance '\" + chromaticity + \"'.\",\n+                \"The text, shapes and image should be \" + chromaticity + \".\",\n+                \"The test fails if the page is not printed with required color apearance.\",\n+        };\n+\n+        String title = String.format(\"Print with %s chromaticity test: %d from %d\", chromaticity, testCount + 1, testTotalCount);\n+        final JDialog dialog = new JDialog(null, title, Dialog.ModalityType.DOCUMENT_MODAL);\n+        JTextArea textArea = new JTextArea(String.join(\"\\n\", instructions));\n+        textArea.setEditable(false);\n+        final JButton testButton = new JButton(\"Start Test\");\n+        final JButton skipButton = new JButton(\"Skip Test\");\n+        final JButton passButton = new JButton(\"PASS\");\n+        skipButton.setEnabled(false);\n+        passButton.setEnabled(false);\n+        passButton.addActionListener((e) -> {\n+            pass();\n+            dialog.dispose();\n+        });\n+        skipButton.addActionListener((e) -> {\n+            skip();\n+            dialog.dispose();\n+        });\n+        final JButton failButton = new JButton(\"FAIL\");\n+        failButton.setEnabled(false);\n+        failButton.addActionListener((e) -> {\n+            fail(chromaticity);\n+            dialog.dispose();\n+        });\n+        testButton.addActionListener((e) -> {\n+            testButton.setEnabled(false);\n+            runPrint(chromaticity);\n+            skipButton.setEnabled(true);\n+            passButton.setEnabled(true);\n+            failButton.setEnabled(true);\n+        });\n+\n+        JPanel mainPanel = new JPanel(new BorderLayout());\n+        mainPanel.add(textArea, BorderLayout.CENTER);\n+        JPanel buttonPanel = new JPanel(new FlowLayout());\n+        buttonPanel.add(testButton);\n+        buttonPanel.add(passButton);\n+        buttonPanel.add(failButton);\n+        mainPanel.add(buttonPanel, BorderLayout.SOUTH);\n+        dialog.add(mainPanel);\n+        dialog.pack();\n+        dialog.setVisible(true);\n+        dialog.addWindowListener(new WindowAdapter() {\n+            @Override\n+            public void windowClosing(WindowEvent e) {\n+                System.out.println(\"Dialog closing\");\n+                fail(chromaticity);\n+            }\n+        });\n+    }\n+\n+    private static void print(Chromaticity chromaticity) throws PrinterException {\n+        PrintRequestAttributeSet attr = new HashPrintRequestAttributeSet();\n+        attr.add(MediaSizeName.ISO_A4);\n+        attr.add(chromaticity);\n+\n+        for (Attribute attribute : attr.toArray()) {\n+            System.out.printf(\"Used print request attribute: %s%n\", attribute);\n+        }\n+\n+        PrinterJob job = PrinterJob.getPrinterJob();\n+        job.setJobName(\"Print with \" + chromaticity);\n+        job.setPrintable(new ChromaticityAttributePrintable(chromaticity));\n+\n+        if (job.printDialog(attr)) {\n+            job.print();\n+        } else {\n+            throw new RuntimeException(\"Test for \" + chromaticity + \" is canceled!\");\n+        }\n+    }\n+\n+    private static void closeDialogs() {\n+        for (Window w : Dialog.getWindows()) {\n+            w.dispose();\n+        }\n+    }\n+\n+    private static void pass() {\n+        testCount++;\n+    }\n+\n+    private static void skip() {\n+        testSkipped = true;\n+    }\n+\n+    private static void fail(Chromaticity chromaticity) {\n+        System.out.printf(\"Failed test: %s\", chromaticity.toString());\n+        testPassed = false;\n+    }\n+\n+    private static Chromaticity[] getSupportedChromaticity() {\n+\n+        PrinterJob printerJob = PrinterJob.getPrinterJob();\n+        PrintService service = printerJob.getPrintService();\n+        if (service == null) {\n+            System.out.printf(\"No print service found.\");\n+            return null;\n+        }\n+\n+        if (!service.isAttributeCategorySupported(Chromaticity.class)) {\n+            System.out.printf(\"Skipping the test as Chromaticity category is not supported for this printer.\");\n+            return null;\n+        }\n+\n+        Object obj = service.getSupportedAttributeValues(Chromaticity.class, null, null);\n+\n+        if (obj instanceof Chromaticity[]) {\n+            return (Chromaticity[]) obj;\n+        }\n+\n+        throw new RuntimeException(\"Chromaticity category is supported but no supported attribute values are returned.\");\n+    }\n+\n+    private static void runPrint(Chromaticity chromaticity) {\n+        try {\n+            print(chromaticity);\n+        } catch (PrinterException e) {\n+            e.printStackTrace();\n+            fail(chromaticity);\n+            closeDialogs();\n+        }\n+    }\n+\n+\n+    private static class ChromaticityAttributePrintable implements Printable {\n+\n+        private final Chromaticity chromaticity;\n+\n+        public ChromaticityAttributePrintable(Chromaticity chromaticity) {\n+            this.chromaticity = chromaticity;\n+        }\n+\n+        @Override\n+        public int print(Graphics graphics, PageFormat pageFormat, int pageIndex) throws PrinterException {\n+\n+            if (pageIndex != 0) {\n+                return NO_SUCH_PAGE;\n+            }\n+\n+            final int sx = (int) Math.ceil(pageFormat.getImageableX());\n+            final int sy = (int) Math.ceil(pageFormat.getImageableY());\n+\n+            Graphics2D g = (Graphics2D) graphics;\n+\n+            BufferedImage bufferdImage = getBufferedImage((int) Math.ceil(pageFormat.getImageableWidth() \/ 3), (int) Math.ceil(pageFormat.getImageableHeight() \/ 7));\n+            g.drawImage(bufferdImage, null, sx, sy);\n+\n+            int imh = sy + (int) Math.ceil(pageFormat.getImageableHeight() \/ 7) + 10;\n+\n+            g.setColor(Color.ORANGE);\n+            g.drawRect(sx, imh, 50, 50);\n+            imh += 60;\n+\n+            g.setColor(Color.BLUE);\n+            g.fillOval(sx, imh, 50, 50);\n+            imh += 60;\n+\n+            Paint paint = new LinearGradientPaint(0, 0, 20, 5, new float[]{0.0f, 0.2f, 1.0f},\n+                    new Color[]{Color.RED, Color.GREEN, Color.CYAN}, MultipleGradientPaint.CycleMethod.REPEAT);\n+            g.setPaint(paint);\n+            g.setStroke(new BasicStroke(50));\n+            g.fillRect(sx, imh + 10, 50, 50);\n+            imh += 60;\n+\n+            paint = new RadialGradientPaint(10, 10, 5, new float[]{0.0f, 0.5f, 1.0f},\n+                    new Color[]{Color.RED, Color.GREEN, Color.CYAN}, MultipleGradientPaint.CycleMethod.REPEAT);\n+            g.setPaint(paint);\n+            g.fillRect(sx, imh + 10, 50, 50);\n+            imh += 60;\n+\n+            g.setStroke(new BasicStroke(5));\n+            g.setColor(Color.PINK);\n+            g.drawString(\"Chromaticity: \" + chromaticity, sx, imh + 30);\n+\n+            return PAGE_EXISTS;\n+        }\n+\n+        private BufferedImage getBufferedImage(int width, int height) {\n+            Color[] colors = new Color[]{\n+                    Color.RED, Color.ORANGE, Color.BLUE,\n+                    Color.CYAN, Color.MAGENTA, Color.GREEN\n+            };\n+            BufferedImage bufferedImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\n+            final int secondSquareOffset = width \/ 3;\n+            final int thirdSquareOffset = secondSquareOffset * 2;\n+            final int squareHeight = height \/ 2;\n+\n+            int offset = 0;\n+            Color color;\n+            for (int y = 0; y < height; y++) {\n+                if (y > squareHeight) {\n+                    offset = 3;\n+                }\n+                for (int x = 0; x < width; x++) {\n+                    if (x >= thirdSquareOffset) {\n+                        color = colors[offset + 2];\n+                    } else if (x >= secondSquareOffset) {\n+                        color = colors[offset + 1];\n+                    } else {\n+                        color = colors[offset];\n+                    }\n+                    bufferedImage.setRGB(x, y, color.getRGB());\n+                }\n+            }\n+            return bufferedImage;\n+        }\n+\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/javax\/print\/attribute\/MonochromePrintTest.java","additions":354,"deletions":0,"binary":false,"changes":354,"status":"added"}]}