{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -187,1 +187,6 @@\n-        TAGLET_PATH;\n+        TAGLET_PATH,\n+\n+        \/**\n+         * Location to search for snippets.\n+         *\/\n+        SNIPPET_PATH;\n","filename":"src\/java.compiler\/share\/classes\/javax\/tools\/DocumentationTool.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * A tree node for an attribute in an HTML element.\n+ * A tree node for an attribute in an HTML element or tag.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/doctree\/AttributeTree.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-         * representing an HTML attribute.\n+         * representing an attribute in an HTML element or tag.\n@@ -207,0 +207,6 @@\n+        \/**\n+         * Used for instances of {@link SnippetTree}\n+         * representing an {@code @snippet} tag.\n+         *\/\n+        SNIPPET(\"snippet\"),\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/doctree\/DocTree.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -290,0 +290,15 @@\n+    \/**\n+     * Visits a {@code SnippetTree} node.\n+     *\n+     * @implSpec Visits the provided {@code SnippetTree} node\n+     * by calling {@code visitOther(node, p)}.\n+     *\n+     * @param node the node being visited\n+     * @param p a parameter value\n+     * @return a result value\n+     * @since 18\n+     *\/\n+    default R visitSnippet(SnippetTree node, P p) {\n+        return visitOther(node, p);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/doctree\/DocTreeVisitor.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.source.doctree;\n+\n+import java.util.List;\n+\n+\/**\n+ * A tree node for an {@code @snippet} inline tag.\n+ *\n+ * <pre>\n+ *    {&#064;snippet :\n+ *     body\n+ *    }\n+ *\n+ *    {&#064;snippet attributes}\n+ *\n+ *    {&#064;snippet attributes :\n+ *     body\n+ *    }\n+ * <\/pre>\n+ *\n+ * @since 18\n+ *\/\n+public interface SnippetTree extends InlineTagTree {\n+\n+    \/**\n+     * Returns the list of the attributes of the {@code @snippet} tag.\n+     *\n+     * @return the list of the attributes\n+     *\/\n+    List<? extends DocTree> getAttributes();\n+\n+    \/**\n+     * Returns the body of the {@code @snippet} tag, or {@code null} if there is no body.\n+     *\n+     * @apiNote\n+     * An instance of {@code SnippetTree} with an empty body differs from an\n+     * instance of {@code SnippetTree} with no body.\n+     * If a tag has no body, then calling this method returns {@code null}.\n+     * If a tag has an empty body, then this method returns a {@code TextTree}\n+     * whose {@link TextTree#getBody()} returns an empty string.\n+     *\n+     * @return the body of the tag, or {@code null} if there is no body\n+     *\/\n+    TextTree getBody();\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/doctree\/SnippetTree.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,0 +61,1 @@\n+import com.sun.source.doctree.SnippetTree;\n@@ -82,1 +83,1 @@\n-     * Creates a new {@code AttributeTree} object, to represent an HTML attribute in an HTML tag.\n+     * Creates a new {@code AttributeTree} object, to represent an attribute in an HTML element or tag.\n@@ -329,0 +330,9 @@\n+    \/**\n+     * Creates a new {@code SnippetTree} object, to represent a {@code {@snippet }} tag.\n+     * @param attributes the attributes of the tag\n+     * @param text the body of the tag, or {@code null} if the tag has no body (not to be confused with an empty body)\n+     * @return a {@code SnippetTree} object\n+     * @since 18\n+     *\/\n+    SnippetTree newSnippetTree(List<? extends DocTree> attributes, TextTree text);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/DocTreeFactory.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -495,0 +495,17 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n+     *\n+     * @param node  {@inheritDoc}\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n+     * @since 18\n+     *\/\n+    @Override\n+    public R visitSnippet(SnippetTree node, P p) {\n+        R r = scan(node.getAttributes(), p);\n+        r = scanAndReduce(node.getBody(), p, r);\n+        return r;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/DocTreeScanner.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -451,0 +451,15 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n+     * @return  the result of {@code defaultAction}\n+     * @since 18\n+     *\/\n+    @Override\n+    public R visitSnippet(SnippetTree node, P p) {\n+        return defaultAction(node, p);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/SimpleDocTreeVisitor.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1065,0 +1065,7 @@\n+    protected boolean isHorizontalWhitespace(char ch) {\n+        \/\/ This parser treats `\\f` as a line break (see `nextChar`).\n+        \/\/ To be consistent with that behaviour, this method does the same.\n+        \/\/ (see JDK-8273809)\n+        return ch == ' ' || ch == '\\t';\n+    }\n+\n@@ -1400,0 +1407,87 @@\n+            \/\/ {@snippet attributes :\n+            \/\/  body}\n+            new TagParser(TagParser.Kind.INLINE, DCTree.Kind.SNIPPET) {\n+                @Override\n+                DCTree parse(int pos) throws ParseException {\n+                    skipWhitespace();\n+                    List<DCTree> attributes = tagAttrs();\n+                    \/\/ expect \"}\" or \":\"\n+                    if (ch == '}') {\n+                        nextChar();\n+                        return m.at(pos).newSnippetTree(attributes, null);\n+                    } else if (ch == ':') {\n+                        newline = false;\n+                        \/\/ consume ':'\n+                        nextChar();\n+                        \/\/ expect optional whitespace followed by mandatory newline\n+                        while (bp < buflen && isHorizontalWhitespace(ch)) {\n+                            nextChar();\n+                        }\n+                        \/\/ check that we are looking at newline\n+                        if (!newline) {\n+                            if (bp >= buf.length - 1) {\n+                                throw new ParseException(\"dc.no.content\");\n+                            }\n+                            throw new ParseException(\"dc.unexpected.content\");\n+                        }\n+                        \/\/ consume newline\n+                        nextChar();\n+                        DCText text = inlineText(WhitespaceRetentionPolicy.RETAIN_ALL);\n+                        nextChar();\n+                        return m.at(pos).newSnippetTree(attributes, text);\n+                    } else if (bp >= buf.length - 1) {\n+                        throw new ParseException(\"dc.no.content\");\n+                    } else {\n+                        throw new ParseException(\"dc.unexpected.content\");\n+                    }\n+                }\n+\n+                \/*\n+                 * Reads a series of inline snippet tag attributes.\n+                 *\n+                 * Attributes are terminated by the first of \":\" (colon) or\n+                 * an unmatched \"}\" (closing curly).\n+                 *\/\n+                private List<DCTree> tagAttrs() {\n+                    ListBuffer<DCTree> attrs = new ListBuffer<>();\n+                    skipWhitespace();\n+                    while (bp < buflen && isIdentifierStart(ch)) {\n+                        int namePos = bp;\n+                        Name name = readAttributeName();\n+                        skipWhitespace();\n+                        List<DCTree> value = null;\n+                        ValueKind vkind = ValueKind.EMPTY;\n+                        if (ch == '=') {\n+                            ListBuffer<DCTree> v = new ListBuffer<>();\n+                            nextChar();\n+                            skipWhitespace();\n+                            if (ch == '\\'' || ch == '\"') {\n+                                newline = false;\n+                                vkind = (ch == '\\'') ? ValueKind.SINGLE : ValueKind.DOUBLE;\n+                                char quote = ch;\n+                                nextChar();\n+                                textStart = bp;\n+                                while (bp < buflen && ch != quote) {\n+                                    nextChar();\n+                                }\n+                                addPendingText(v, bp - 1);\n+                                nextChar();\n+                            } else {\n+                                vkind = ValueKind.UNQUOTED;\n+                                textStart = bp;\n+                                \/\/ Stop on '}' and ':' for them to be re-consumed by non-attribute parts of tag\n+                                while (bp < buflen && (ch != '}' && ch != ':' && !isUnquotedAttrValueTerminator(ch))) {\n+                                    nextChar();\n+                                }\n+                                addPendingText(v, bp - 1);\n+                            }\n+                            skipWhitespace();\n+                            value = v.toList();\n+                        }\n+                        DCAttribute attr = m.at(namePos).newAttributeTree(name, vkind, value);\n+                        attrs.add(attr);\n+                    }\n+                    return attrs.toList();\n+                }\n+            },\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/DocCommentParser.java","additions":95,"deletions":1,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -860,0 +860,30 @@\n+    public static class DCSnippet extends DCInlineTag implements SnippetTree {\n+        public final List<? extends DocTree> attributes;\n+        public final DCText body;\n+\n+        public DCSnippet(List<DCTree> attributes, DCText body) {\n+            this.body = body;\n+            this.attributes = attributes;\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public Kind getKind() {\n+            return Kind.SNIPPET;\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public <R, D> R accept(DocTreeVisitor<R, D> v, D d) {\n+            return v.visitSnippet(this, d);\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public List<? extends DocTree> getAttributes() {\n+            return attributes;\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public TextTree getBody() {\n+            return body;\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/DCTree.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -493,0 +493,21 @@\n+    @Override @DefinedBy(Api.COMPILER_TREE)\n+    public Void visitSnippet(SnippetTree node, Void p) {\n+        try {\n+            print(\"{\");\n+            printTagName(node);\n+            List<? extends DocTree> attrs = node.getAttributes();\n+            if (!attrs.isEmpty()) {\n+                print(\" \");\n+                print(attrs, \" \");\n+            }\n+            if (node.getBody() != null) {\n+                print(\" :\\n\");\n+                print(node.getBody());\n+            }\n+            print(\"}\");\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+        return null;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/DocPretty.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import java.util.EnumSet;\n@@ -79,0 +78,1 @@\n+import com.sun.tools.javac.tree.DCTree.DCSnippet;\n@@ -434,0 +434,7 @@\n+    @Override @DefinedBy(Api.COMPILER_TREE)\n+    public DCSnippet newSnippetTree(List<? extends DocTree> attributes, TextTree text) {\n+        DCSnippet tree = new DCSnippet(cast(attributes), (DCText) text);\n+        tree.pos = pos;\n+        return tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/DocTreeMaker.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1145,0 +1145,127 @@\n+    \/\/ TODO: this method and seeTagToContent share much of the code; consider factoring common pieces out\n+    public Content linkToContent(Element referrer, Element target, String targetSignature, String text) {\n+        CommentHelper ch = utils.getCommentHelper(referrer);\n+\n+        boolean isLinkPlain = false; \/\/ TODO: for now\n+        Content labelContent = plainOrCode(isLinkPlain, Text.of(text));\n+\n+        TypeElement refClass = ch.getReferencedClass(target);\n+        Element refMem =       ch.getReferencedMember(target);\n+        String refMemName =    ch.getReferencedMemberName(targetSignature);\n+\n+        if (refMemName == null && refMem != null) {\n+            refMemName = refMem.toString();\n+        }\n+        if (refClass == null) {\n+            ModuleElement refModule = ch.getReferencedModule(target);\n+            if (refModule != null && utils.isIncluded(refModule)) {\n+                return getModuleLink(refModule, labelContent);\n+            }\n+            \/\/@see is not referencing an included class\n+            PackageElement refPackage = ch.getReferencedPackage(target);\n+            if (refPackage != null && utils.isIncluded(refPackage)) {\n+                \/\/@see is referencing an included package\n+                if (labelContent.isEmpty())\n+                    labelContent = plainOrCode(isLinkPlain,\n+                                               Text.of(refPackage.getQualifiedName()));\n+                return getPackageLink(refPackage, labelContent);\n+            } else {\n+                \/\/ @see is not referencing an included class, module or package. Check for cross links.\n+                String refModuleName =  ch.getReferencedModuleName(targetSignature);\n+                DocLink elementCrossLink = (refPackage != null) ? getCrossPackageLink(refPackage) :\n+                        (configuration.extern.isModule(refModuleName))\n+                                ? getCrossModuleLink(utils.elementUtils.getModuleElement(refModuleName))\n+                                : null;\n+                if (elementCrossLink != null) {\n+                    \/\/ Element cross link found\n+                    return links.createExternalLink(elementCrossLink, labelContent);\n+                } else {\n+                    \/\/ No cross link found so print warning\n+\/\/ TODO:\n+\/\/                    messages.warning(ch.getDocTreePath(see),\n+\/\/                                     \"doclet.see.class_or_package_not_found\",\n+\/\/                                     \"@\" + tagName,\n+\/\/                                     seeText);\n+                    return labelContent;\n+                }\n+            }\n+        } else if (refMemName == null) {\n+            \/\/ Must be a class reference since refClass is not null and refMemName is null.\n+            if (labelContent.isEmpty()) {\n+                if (!refClass.getTypeParameters().isEmpty() && targetSignature.contains(\"<\")) {\n+                    \/\/ If this is a generic type link try to use the TypeMirror representation.\n+\n+\/\/ TODO:\n+\/\/                  TypeMirror refType = ch.getReferencedType(target);\n+                    TypeMirror refType = target.asType();\n+\n+                    if (refType != null) {\n+                        return plainOrCode(isLinkPlain, getLink(\n+                                new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.DEFAULT, refType)));\n+                    }\n+                }\n+                labelContent = plainOrCode(isLinkPlain, Text.of(utils.getSimpleName(refClass)));\n+            }\n+            return getLink(new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.DEFAULT, refClass)\n+                                   .label(labelContent));\n+        } else if (refMem == null) {\n+            \/\/ Must be a member reference since refClass is not null and refMemName is not null.\n+            \/\/ However, refMem is null, so this referenced member does not exist.\n+            return labelContent;\n+        } else {\n+            \/\/ Must be a member reference since refClass is not null and refMemName is not null.\n+            \/\/ refMem is not null, so this @see tag must be referencing a valid member.\n+            TypeElement containing = utils.getEnclosingTypeElement(refMem);\n+\n+            \/\/ Find the enclosing type where the method is actually visible\n+            \/\/ in the inheritance hierarchy.\n+            ExecutableElement overriddenMethod = null;\n+            if (refMem.getKind() == ElementKind.METHOD) {\n+                VisibleMemberTable vmt = configuration.getVisibleMemberTable(containing);\n+                overriddenMethod = vmt.getOverriddenMethod((ExecutableElement)refMem);\n+\n+                if (overriddenMethod != null)\n+                    containing = utils.getEnclosingTypeElement(overriddenMethod);\n+            }\n+            if (targetSignature.trim().startsWith(\"#\") &&\n+                    ! (utils.isPublic(containing) || utils.isLinkable(containing))) {\n+                \/\/ Since the link is relative and the holder is not even being\n+                \/\/ documented, this must be an inherited link.  Redirect it.\n+                \/\/ The current class either overrides the referenced member or\n+                \/\/ inherits it automatically.\n+                if (this instanceof ClassWriterImpl writer) {\n+                    containing = writer.getTypeElement();\n+                } else if (!utils.isPublic(containing)) {\n+\/\/ TODO:\n+\/\/                    messages.warning(\n+\/\/                            ch.getDocTreePath(see), \"doclet.see.class_or_package_not_accessible\",\n+\/\/                            tagName, utils.getFullyQualifiedName(containing));\n+                } else {\n+\/\/ TODO:\n+\/\/                    messages.warning(\n+\/\/                            ch.getDocTreePath(see), \"doclet.see.class_or_package_not_found\",\n+\/\/                            tagName, seeText);\n+                }\n+            }\n+            if (configuration.currentTypeElement != containing) {\n+                refMemName = (utils.isConstructor(refMem))\n+                        ? refMemName\n+                        : utils.getSimpleName(containing) + \".\" + refMemName;\n+            }\n+            if (utils.isExecutableElement(refMem)) {\n+                if (refMemName.indexOf('(') < 0) {\n+                    refMemName += utils.makeSignature((ExecutableElement) refMem, null, true);\n+                }\n+                if (overriddenMethod != null) {\n+                    \/\/ The method to actually link.\n+                    refMem = overriddenMethod;\n+                }\n+            }\n+\n+            return getDocLink(HtmlLinkInfo.Kind.SEE_TAG, containing,\n+                              refMem, (labelContent.isEmpty()\n+                            ? plainOrCode(isLinkPlain, Text.of(text))\n+                            : labelContent), null, false);\n+        }\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.HashSet;\n@@ -50,0 +51,1 @@\n+import com.sun.source.doctree.SnippetTree;\n@@ -52,0 +54,1 @@\n+import com.sun.source.util.DocTreePath;\n@@ -66,0 +69,2 @@\n+import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.Style;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.StyledText;\n@@ -377,0 +382,75 @@\n+    @Override\n+    protected Content snippetTagOutput(Element element, SnippetTree tag, StyledText content) {\n+        HtmlTree result = new HtmlTree(TagName.PRE).setStyle(HtmlStyle.snippet);\n+        result.add(Text.of(utils.normalizeNewlines(\"\\n\")));\n+        content.consumeBy((styles, sequence) -> {\n+            CharSequence text = utils.normalizeNewlines(sequence);\n+            if (styles.isEmpty()) {\n+                result.add(text);\n+            } else {\n+                Element e = null;\n+                String t = null;\n+                boolean linkEncountered = false;\n+                Set<String> classes = new HashSet<>();\n+                for (Style s : styles) {\n+                    if (s instanceof Style.Name n) {\n+                        classes.add(n.name());\n+                    } else if (s instanceof Style.Link l) {\n+                        assert !linkEncountered; \/\/ TODO: do not assert; pick the first link report on subsequent\n+                        linkEncountered = true;\n+                        t = l.target();\n+                        e = getLinkedElement(element, t);\n+                        if (e == null) {\n+                            \/\/ TODO: diagnostic output\n+                        }\n+                    } else if (s instanceof Style.Markup) {\n+                    } else {\n+                        \/\/ TODO: transform this if...else into an exhaustive\n+                        \/\/ switch over the sealed Style hierarchy when \"Pattern\n+                        \/\/ Matching for switch\" has been implemented (JEP 406\n+                        \/\/ and friends)\n+                        throw new AssertionError(styles);\n+                    }\n+                }\n+                Content c;\n+                if (linkEncountered) {\n+                    assert e != null;\n+                    String line = sequence.toString();\n+                    String strippedLine = line.strip();\n+                    int idx = line.indexOf(strippedLine);\n+                    assert idx >= 0; \/\/ because the stripped line is a substring of the line being stripped\n+                    Text whitespace = Text.of(line.substring(0, idx));\n+                    \/\/ If the leading whitespace is not excluded from the link,\n+                    \/\/ browsers might exhibit unwanted behavior. For example, a\n+                    \/\/ browser might display hand-click cursor while user hovers\n+                    \/\/ over that whitespace portion of the line; or use\n+                    \/\/ underline decoration.\n+                    c = new ContentBuilder(whitespace, htmlWriter.linkToContent(element, e, t, strippedLine));\n+                    \/\/ We don't care about trailing whitespace.\n+                } else {\n+                    c = HtmlTree.SPAN(Text.of(sequence));\n+                    classes.forEach(((HtmlTree) c)::addStyle);\n+                }\n+                result.add(c);\n+            }\n+        });\n+        return result;\n+    }\n+\n+    \/*\n+     * Returns the element that is linked from the context of the referrer using\n+     * the provided signature; returns null if such element could not be found.\n+     *\n+     * This method is to be used when it is the target of the link that is\n+     * important, not the container of the link (e.g. was it an @see,\n+     * @link\/@linkplain or @snippet tags, etc.)\n+     *\/\n+    public Element getLinkedElement(Element referer, String signature) {\n+        var factory = utils.docTrees.getDocTreeFactory();\n+        var docCommentTree = utils.getDocCommentTree(referer);\n+        var rootPath = new DocTreePath(utils.getTreePath(referer), docCommentTree);\n+        var reference = factory.newReferenceTree(signature);\n+        var fabricatedPath = new DocTreePath(rootPath, reference);\n+        return utils.docTrees.getElement(fabricatedPath);\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/TagletWriterImpl.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -78,0 +78,5 @@\n+    \/**\n+     * The class of the {@code pre} element presenting a snippet.\n+     *\/\n+    snippet,\n+\n@@ -806,0 +811,1 @@\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/HtmlStyle.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -541,0 +541,6 @@\n+doclet.usage.snippet-path.parameters=\\\n+    <path>\n+\n+doclet.usage.snippet-path.description=\\\n+    The path for external snippets\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/standard.properties","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.io.File;\n@@ -31,0 +32,2 @@\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.Path;\n@@ -32,0 +35,1 @@\n+import java.util.Arrays;\n@@ -53,0 +57,1 @@\n+import javax.tools.DocumentationTool;\n@@ -55,0 +60,1 @@\n+import javax.tools.StandardJavaFileManager;\n@@ -377,0 +383,22 @@\n+\n+        String snippetPath = options.snippetPath();\n+        if (snippetPath != null) {\n+            Messages messages = getMessages();\n+            JavaFileManager fm = getFileManager();\n+            if (fm instanceof StandardJavaFileManager) {\n+                try {\n+                    List<Path> sp = Arrays.stream(snippetPath.split(File.pathSeparator))\n+                            .map(Path::of)\n+                            .toList();\n+                    StandardJavaFileManager sfm = (StandardJavaFileManager) fm;\n+                    sfm.setLocationFromPaths(DocumentationTool.Location.SNIPPET_PATH, sp);\n+                } catch (IOException | InvalidPathException e) {\n+                    throw new SimpleDocletException(messages.getResources().getText(\n+                            \"doclet.error_setting_snippet_path\", snippetPath, e), e);\n+                }\n+            } else {\n+                throw new SimpleDocletException(messages.getResources().getText(\n+                        \"doclet.cannot_use_snippet_path\", snippetPath));\n+            }\n+        }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/BaseConfiguration.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -285,0 +285,6 @@\n+    \/**\n+     * Argument for command-line option {@code --snippet-path}.\n+     * The path for external snippets.\n+     *\/\n+    private String snippetPath = null;\n+\n@@ -557,0 +563,8 @@\n+                new Option(resources, \"--snippet-path\", 1) {\n+                    @Override\n+                    public boolean process(String opt, List<String> args) {\n+                        snippetPath = args.get(0);\n+                        return true;\n+                    }\n+                },\n+\n@@ -965,0 +979,8 @@\n+    \/**\n+     * Argument for command-line option {@code --snippet-path}.\n+     * The path for external snippets.\n+     *\/\n+    public String snippetPath() {\n+        return snippetPath;\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/BaseOptions.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -350,1 +350,51 @@\n-doclet.search.search_tags=Search Tags\n\\ No newline at end of file\n+doclet.search.search_tags=Search Tags\n+\n+doclet.snippet.contents.none=\\\n+ @snippet does not specify contents\n+\n+doclet.snippet.contents.ambiguity.external=\\\n+ @snippet specifies multiple external contents, which is ambiguous\n+\n+doclet.snippet.region.not_found=\\\n+ region not found: \"{0}\"\n+\n+doclet.tag.attribute.value.illegal=\\\n+ illegal value for attribute \"{0}\": \"{1}\"\n+\n+doclet.tag.attribute.repeated=\\\n+ repeated attribute: \"{0}\"\n+\n+doclet.snippet.contents.mismatch=\\\n+ contents mismatch:\\n{0}\n+\n+doclet.snippet.markup=\\\n+ snippet markup: {0}\n+\n+doclet.snippet.markup.attribute.absent=\\\n+  missing attribute \"{0}\"\n+doclet.snippet.markup.attribute.simultaneous.use=\\\n+  attributes \"{0}\" and \"{1}\" used simultaneously\n+doclet.snippet.markup.attribute.unexpected=\\\n+  unexpected attribute\n+doclet.snippet.markup.attribute.value.invalid=\\\n+  invalid attribute value\n+doclet.snippet.markup.attribute.value.unterminated=\\\n+  unterminated attribute value\n+doclet.snippet.markup.regex.invalid=\\\n+  invalid regex\n+doclet.snippet.markup.region.duplicated=\\\n+  duplicated region\n+doclet.snippet.markup.region.none=\\\n+  no region to end\n+doclet.snippet.markup.region.unpaired=\\\n+  unpaired region\n+doclet.snippet.markup.tag.non.existent.lines=\\\n+  tag refers to non-existent lines\n+\n+# 0: path\n+doclet.cannot_use_snippet_path=\\\n+  Cannot use ''--snippet-path'' option with the given file manager: {0}\n+\n+# 0: path; 1: exception\n+doclet.error_setting_snippet_path=\\\n+  Error setting snippet path {0}: {1}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/doclets.properties","additions":51,"deletions":1,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -866,0 +866,21 @@\n+\n+pre.snippet {\n+    background-color: #ebecee;\n+    padding: 10px;\n+    margin: 12px 0;\n+    overflow: auto;\n+    white-space: pre;\n+}\n+\n+pre.snippet .italic {\n+    font-style: italic;\n+}\n+\n+pre.snippet .bold {\n+    font-weight: bold;\n+}\n+\n+pre.snippet .highlighted {\n+    background-color: #f7c590;\n+    border-radius: 10%;\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/stylesheet.css","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,367 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.toolkit.taglets;\n+\n+import java.io.IOException;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.PackageElement;\n+import javax.tools.Diagnostic;\n+import javax.tools.DocumentationTool.Location;\n+import javax.tools.FileObject;\n+import javax.tools.JavaFileManager;\n+\n+import com.sun.source.doctree.AttributeTree;\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.SnippetTree;\n+import com.sun.source.doctree.TextTree;\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.DocletElement;\n+import jdk.javadoc.internal.doclets.toolkit.Resources;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.Action;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.ParseException;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.Parser;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.StyledText;\n+import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n+\n+\/**\n+ * A taglet that represents the {@code @snippet} tag.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+public class SnippetTaglet extends BaseTaglet {\n+\n+    public SnippetTaglet() {\n+        super(DocTree.Kind.SNIPPET, true, EnumSet.allOf(Taglet.Location.class));\n+    }\n+\n+    \/*\n+     * A snippet can specify content by value (inline), by reference (external)\n+     * or both (hybrid).\n+     *\n+     * To specify content by value, a snippet uses its body; the body of\n+     * a snippet is the content.\n+     *\n+     * To specify content by reference, a snippet uses either the \"class\"\n+     * or \"file\" attribute; the value of that attribute refers to the content.\n+     *\n+     * A snippet can specify the \"region\" attribute. That attribute refines\n+     * the location of the content. The value of that attribute must match\n+     * one of the named regions in the snippets content.\n+     *\/\n+    @Override\n+    public Content getInlineTagOutput(Element holder, DocTree tag, TagletWriter writer) {\n+        SnippetTree snippetTag = (SnippetTree) tag;\n+\n+        \/\/ organize snippet attributes in a map, performing basic checks along the way\n+        Map<String, AttributeTree> attributes = new HashMap<>();\n+        for (DocTree d : snippetTag.getAttributes()) {\n+            if (!(d instanceof AttributeTree a)) {\n+                continue; \/\/ this might be an ErroneousTree\n+            }\n+            if (attributes.putIfAbsent(a.getName().toString(), a) == null) {\n+                continue;\n+            }\n+            \/\/ two like-named attributes found; although we report on the most\n+            \/\/ recently encountered of the two, the iteration order might differ\n+            \/\/ from the source order (see JDK-8266826)\n+            error(writer, holder, a, \"doclet.tag.attribute.repeated\",\n+                a.getName().toString());\n+            return badSnippet(writer);\n+        }\n+\n+        final String CLASS = \"class\";\n+        final String FILE = \"file\";\n+\n+        final boolean containsClass = attributes.containsKey(CLASS);\n+        final boolean containsFile = attributes.containsKey(FILE);\n+        final boolean containsBody = snippetTag.getBody() != null;\n+\n+        if (containsClass && containsFile) {\n+            error(writer, holder, attributes.get(CLASS),\n+                \"doclet.snippet.contents.ambiguity.external\");\n+            return badSnippet(writer);\n+        } else if (!containsClass && !containsFile && !containsBody) {\n+            error(writer, holder, tag, \"doclet.snippet.contents.none\");\n+            return badSnippet(writer);\n+        }\n+\n+        String regionName = null;\n+        AttributeTree region = attributes.get(\"region\");\n+        if (region != null) {\n+            regionName = stringOf(region.getValue());\n+            if (regionName.isBlank()) {\n+                error(writer, holder, region, \"doclet.tag.attribute.value.illegal\",\n+                    \"region\", region.getValue());\n+                return badSnippet(writer);\n+            }\n+        }\n+\n+        String inlineContent = null, externalContent = null;\n+\n+        if (containsBody) {\n+            inlineContent = snippetTag.getBody().getBody();\n+        }\n+\n+        FileObject fileObject = null;\n+\n+        if (containsFile || containsClass) {\n+            AttributeTree a;\n+            String v = containsFile\n+                ? stringOf((a = attributes.get(FILE)).getValue())\n+                : stringOf((a = attributes.get(CLASS)).getValue()).replace(\".\", \"\/\") + \".java\";\n+\n+            if (v.isBlank()) {\n+                error(writer, holder, a, \"doclet.tag.attribute.value.illegal\",\n+                    containsFile ? FILE : CLASS, v);\n+            }\n+\n+            \/\/ we didn't create JavaFileManager, so we won't close it; even if an error occurs\n+            var fileManager = writer.configuration().getFileManager();\n+\n+            \/\/ first, look in local snippet-files subdirectory\n+            Utils utils = writer.configuration().utils;\n+            PackageElement pkg = getPackageElement(holder, utils);\n+            JavaFileManager.Location l = utils.getLocationForPackage(pkg);\n+            String relativeName = \"snippet-files\/\" + v;\n+            String packageName = packageName(pkg, utils);\n+            try {\n+                fileObject = fileManager.getFileForInput(l, packageName, relativeName);\n+\n+                \/\/ if not found in local snippet-files directory, look on snippet path\n+                if (fileObject == null && fileManager.hasLocation(Location.SNIPPET_PATH)) {\n+                    fileObject = fileManager.getFileForInput(Location.SNIPPET_PATH, \"\", v);\n+                }\n+            } catch (IOException | IllegalArgumentException e) {\n+                \/\/ JavaFileManager.getFileForInput can throw IllegalArgumentException in certain cases\n+                error(writer, holder, a, \"doclet.exception.read.file\", v, e.getCause());\n+                return badSnippet(writer);\n+            }\n+\n+            if (fileObject == null) {\n+                \/\/ i.e. the file does not exist\n+                error(writer, holder, a, \"doclet.File_not_found\", v);\n+                return badSnippet(writer);\n+            }\n+\n+            try {\n+                externalContent = fileObject.getCharContent(true).toString();\n+            } catch (IOException e) {\n+                error(writer, holder, a, \"doclet.exception.read.file\",\n+                    fileObject.getName(), e.getCause());\n+                return badSnippet(writer);\n+            }\n+        }\n+\n+        \/\/ TODO cache parsed external snippet (WeakHashMap)\n+\n+        StyledText inlineSnippet = null;\n+        StyledText externalSnippet = null;\n+\n+        try {\n+            if (inlineContent != null) {\n+                inlineSnippet = parse(writer.configuration().getDocResources(), inlineContent);\n+            }\n+        } catch (ParseException e) {\n+            var path = writer.configuration().utils.getCommentHelper(holder)\n+                .getDocTreePath(snippetTag.getBody());\n+            \/\/ TODO: there should be a method in Messages; that method should mirror Reporter's; use that method instead accessing Reporter.\n+            String msg = writer.configuration().getDocResources()\n+                .getText(\"doclet.snippet.markup\", e.getMessage());\n+            writer.configuration().getReporter().print(Diagnostic.Kind.ERROR,\n+                path, e.getPosition(), e.getPosition(), e.getPosition(), msg);\n+            return badSnippet(writer);\n+        }\n+\n+        try {\n+            if (externalContent != null) {\n+                externalSnippet = parse(writer.configuration().getDocResources(), externalContent);\n+            }\n+        } catch (ParseException e) {\n+            assert fileObject != null;\n+            writer.configuration().getMessages().error(fileObject, e.getPosition(),\n+                e.getPosition(), e.getPosition(), \"doclet.snippet.markup\", e.getMessage());\n+            return badSnippet(writer);\n+        }\n+\n+        \/\/ the region must be matched at least in one content: it can be matched\n+        \/\/ in both, but never in none\n+        if (regionName != null) {\n+            StyledText r1 = null;\n+            StyledText r2 = null;\n+            if (inlineSnippet != null) {\n+                r1 = inlineSnippet.getBookmarkedText(regionName);\n+                if (r1 != null) {\n+                    inlineSnippet = r1;\n+                }\n+            }\n+            if (externalSnippet != null) {\n+                r2 = externalSnippet.getBookmarkedText(regionName);\n+                if (r2 != null) {\n+                    externalSnippet = r2;\n+                }\n+            }\n+            if (r1 == null && r2 == null) {\n+                error(writer, holder, tag, \"doclet.snippet.region.not_found\", regionName);\n+                return badSnippet(writer);\n+            }\n+        }\n+\n+        if (inlineSnippet != null) {\n+            inlineSnippet = toDisplayForm(inlineSnippet);\n+        }\n+\n+        if (externalSnippet != null) {\n+            externalSnippet = toDisplayForm(externalSnippet);\n+        }\n+\n+        if (inlineSnippet != null && externalSnippet != null) {\n+            String inlineStr = inlineSnippet.asCharSequence().toString();\n+            String externalStr = externalSnippet.asCharSequence().toString();\n+            if (!Objects.equals(inlineStr, externalStr)) {\n+                error(writer, holder, tag, \"doclet.snippet.contents.mismatch\", diff(inlineStr, externalStr));\n+                \/\/ output one above the other\n+                return badSnippet(writer);\n+            }\n+        }\n+\n+        assert inlineSnippet != null || externalSnippet != null;\n+        StyledText text = inlineSnippet != null ? inlineSnippet : externalSnippet;\n+\n+        return writer.snippetTagOutput(holder, snippetTag, text);\n+    }\n+\n+    \/*\n+     * Maybe there's a case for implementing a proper (or at least more helpful)\n+     * diff view, but for now simply outputting both sides of a hybrid snippet\n+     * would do. A user could then use a diff tool of their choice to compare\n+     * those sides.\n+     *\n+     * There's a separate issue of mapping discrepancies back to their\n+     * originating source in the doc comment and the external file. Maybe there\n+     * is a value in it, or maybe there isn't. In any case, accurate mapping\n+     * would not be trivial to code.\n+     *\/\n+    private static String diff(String inline, String external) {\n+        return \"\"\"\n+               ----------------- inline -------------------\n+               %s\n+               ----------------- external -----------------\n+               %s\n+               \"\"\".formatted(inline, external);\n+    }\n+\n+    private StyledText parse(Resources resources, String content) throws ParseException {\n+        Parser.Result result = new Parser(resources).parse(content);\n+        result.actions().forEach(Action::perform);\n+        return result.text();\n+    }\n+\n+    private static String stringOf(List<? extends DocTree> value) {\n+        return value.stream()\n+            \/\/ value consists of TextTree or ErroneousTree nodes;\n+            \/\/ ErroneousTree is a subtype of TextTree\n+            .map(t -> ((TextTree) t).getBody())\n+            .collect(Collectors.joining());\n+    }\n+\n+    private void error(TagletWriter writer, Element holder, DocTree tag, String key, Object... args) {\n+        writer.configuration().getMessages().error(\n+            writer.configuration().utils.getCommentHelper(holder).getDocTreePath(tag), key, args);\n+    }\n+\n+    private Content badSnippet(TagletWriter writer) {\n+        return writer.getOutputInstance().add(\"bad snippet\");\n+    }\n+\n+    private String packageName(PackageElement pkg, Utils utils) {\n+        return utils.getPackageName(pkg);\n+    }\n+\n+    private static PackageElement getPackageElement(Element e, Utils utils) {\n+        if (e instanceof DocletElement de) {\n+            return de.getPackageElement();\n+        } else {\n+            return utils.elementUtils.getPackageOf(e);\n+        }\n+    }\n+\n+    \/*\n+     * Returns a version of styled text that can be rendered into HTML or\n+     * compared to another such version. The latter is used to decide if inline\n+     * and external parts of a hybrid snippet match.\n+     *\n+     * Use this method to obtain a final version of text. After all\n+     * transformations on text have been performed, call this method with that\n+     * text and then use the returned result as described above.\n+     *\/\n+    private static StyledText toDisplayForm(StyledText source) {\n+        var sourceString = source.asCharSequence().toString();\n+        var result = new StyledText();\n+        var originalLines = sourceString.lines().iterator();\n+        var unindentedLines = sourceString.stripIndent().lines().iterator();\n+        \/\/ done; the rest of the method translates the stripIndent\n+        \/\/ transformation performed on a character sequence to the styled\n+        \/\/ text that this sequence originates from, line by line\n+        int pos = 0;\n+        \/\/ overcome a \"quirk\" of String.lines\n+        boolean endsWithLineFeed = !sourceString.isEmpty() && sourceString.charAt(source.length() - 1) == '\\n';\n+        while (originalLines.hasNext() && unindentedLines.hasNext()) { \/\/ [^1]\n+            String originalLine = originalLines.next();\n+            String unindentedLine = unindentedLines.next();\n+            \/\/ the search MUST succeed\n+            int idx = originalLine.indexOf(unindentedLine);\n+            \/\/ assume newlines are always of the \\n form\n+            \/\/ append the found fragment\n+            result.append(source.subText(pos + idx, pos + idx + unindentedLine.length()));\n+            \/\/ append the possibly styled newline, but not if it's the last line\n+            int eol = pos + originalLine.length();\n+            if (originalLines.hasNext() || endsWithLineFeed) {\n+                result.append(source.subText(eol, eol + 1));\n+            }\n+            pos = eol + 1;\n+        }\n+        return result;\n+        \/\/ [^1]: Checking hasNext() on both iterators might look unnecessary.\n+        \/\/ However, there are strings for which those iterators return different\n+        \/\/ number of lines. That is, there exists a string s, such that\n+        \/\/\n+        \/\/     s.lines().count() != s.stripIndent().lines().count()\n+        \/\/\n+        \/\/ The most trivial example of such a string is \" \". In fact, any string\n+        \/\/ with a trailing non-empty blank line would do.\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SnippetTaglet.java","additions":367,"deletions":0,"binary":false,"changes":367,"status":"added"},{"patch":"@@ -658,0 +658,1 @@\n+        addStandardTaglet(new SnippetTaglet());\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/TagletManager.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import com.sun.source.doctree.SnippetTree;\n@@ -47,0 +48,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.StyledText;\n@@ -177,0 +179,10 @@\n+    \/**\n+     * Returns the output for a {@code {@snippet ...}} tag.\n+     *\n+     * @param element    The element that owns the doc comment\n+     * @param snippetTag the snippet tag\n+     *\n+     * @return the output\n+     *\/\n+    protected abstract Content snippetTagOutput(Element element, SnippetTree snippetTag, StyledText text);\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/TagletWriter.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+\n+\/**\n+ * An action described by markup. Such an action is typically an opaque compound\n+ * of primitive operations of {@link StyledText}.\n+ *\n+ * <p><b>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own risk.\n+ * This code and its internal interfaces are subject to change or\n+ * deletion without notice.<\/b>\n+ *\/\n+public interface Action {\n+\n+    \/**\n+     * Performs this action.\n+     *\/\n+    void perform();\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Action.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * An action that applies an additional style to text.\n+ *\n+ * <p><b>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own risk.\n+ * This code and its internal interfaces are subject to change or\n+ * deletion without notice.<\/b>\n+ *\/\n+public final class AddStyle implements Action {\n+\n+    private final Style style;\n+    private final Pattern pattern;\n+    private final StyledText text;\n+\n+    \/**\n+     * Constructs an action that applies an additional style to regex finds in\n+     * text.\n+     *\n+     * @param style the style to add (to already existing styles)\n+     * @param pattern the regex used to search the text\n+     * @param text the text to search\n+     *\/\n+    public AddStyle(Style style, Pattern pattern, StyledText text) {\n+        this.style = style;\n+        this.pattern = pattern;\n+        this.text = text;\n+    }\n+\n+    @Override\n+    public void perform() {\n+        var singleStyle = Set.of(style);\n+        Matcher matcher = pattern.matcher(text.asCharSequence());\n+        while (matcher.find()) {\n+            int start = matcher.start();\n+            int end = matcher.end();\n+            text.subText(start, end).addStyle(singleStyle);\n+        }\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/AddStyle.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+\n+import java.util.Objects;\n+\n+\/*\n+ * 1. The hierarchy of attributes is modelled as\n+ *\n+ *     Attribute\n+ *     |\n+ *     +- Valueless\n+ *     |\n+ *     +- Valued\n+ *\n+ * not as\n+ *\n+ *     Attribute (Valueless)\n+ *     |\n+ *     +- Valued\n+ *\n+ * because in conjunction with query operations of `Attributes`, `Valued` and\n+ * `Valueless` should be more useful if neither is a subtype of the other.\n+ *\n+ * 2. `Attribute` is abstract because its sole purpose is to be a category.\n+ *\n+ * 3. This attribute abstraction is simpler than that of com.sun.source.doctree.AttributeTree.\n+ * There's no need to have recursive structure similar to that of allowed by AttributeTree.\n+ *\/\n+\/**\n+ * A markup attribute.\n+ *\n+ * <p><b>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own risk.\n+ * This code and its internal interfaces are subject to change or\n+ * deletion without notice.<\/b>\n+ *\/\n+\/\/ TODO: uncomment \/* sealed *\/ when minimum boot JDK version >= 17\n+public \/* sealed *\/ abstract class Attribute {\n+\n+    private final String name;\n+\n+    private final int nameStartPosition;\n+\n+    private Attribute(String name, int nameStartPosition) {\n+        this.name = Objects.requireNonNull(name);\n+        this.nameStartPosition = nameStartPosition;\n+    }\n+\n+    String name() {\n+        return name;\n+    }\n+\n+    int nameStartPosition() {\n+        return nameStartPosition;\n+    }\n+\n+    \/*\n+     * `Valued` can be later extended by classes such as DoublyQuoted,\n+     * SinglyQuoted or Unquoted to form a (sealed) hierarchy. In that case,\n+     * `Valued` should become abstract similarly to `Attribute`.\n+     *\/\n+    final static class Valued extends Attribute {\n+\n+        private final String value;\n+\n+        private final int valueStartPosition;\n+\n+        Valued(String name, String value, int namePosition, int valueStartPosition) {\n+            super(name, namePosition);\n+            this.value = Objects.requireNonNull(value);\n+            this.valueStartPosition = valueStartPosition;\n+        }\n+\n+        String value() {\n+            return value;\n+        }\n+\n+        public int valueStartPosition() {\n+            return valueStartPosition;\n+        }\n+    }\n+\n+    final static class Valueless extends Attribute {\n+\n+        Valueless(String name, int nameStartPosition) {\n+            super(name, nameStartPosition);\n+        }\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Attribute.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * Convenient access to attributes.\n+ *\n+ * <p><b>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own risk.\n+ * This code and its internal interfaces are subject to change or\n+ * deletion without notice.<\/b>\n+ *\/\n+public final class Attributes {\n+\n+    private final Map<String, List<Attribute>> attributes;\n+\n+    public Attributes(Collection<? extends Attribute> attributes) {\n+        this.attributes = attributes\n+                .stream()\n+                .collect(Collectors.groupingBy(Attribute::name,\n+                                               Collectors.toList()));\n+    }\n+\n+    \/*\n+     * 1. If there are multiple attributes with the same name and type, it is\n+     * unknown which one of these attributes will be returned.\n+     *\n+     * 2. If there are no attributes with this name and type, an empty optional\n+     * will be returned.\n+     *\n+     * 3. If a non-specific (any\/or\/union\/etc.) result is required, query for\n+     * the Attribute.class type.\n+     *\/\n+    public <T extends Attribute> Optional<T> get(String name, Class<T> type) {\n+        return attributes.getOrDefault(name, List.of())\n+                .stream()\n+                .filter(type::isInstance)\n+                .map(type::cast)\n+                .findAny();\n+    }\n+\n+    public int size() {\n+        return attributes.values().stream().mapToInt(List::size).sum();\n+    }\n+\n+    public boolean isEmpty() {\n+        return attributes.isEmpty();\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Attributes.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+\n+\/**\n+ * An action that associates text with a name.\n+ *\n+ * <p><b>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own risk.\n+ * This code and its internal interfaces are subject to change or\n+ * deletion without notice.<\/b>\n+ *\/\n+public final class Bookmark implements Action {\n+\n+    private final String name;\n+    private final StyledText text;\n+\n+    \/**\n+     * Constructs an action that associates text with a name.\n+     *\n+     * @param name the string (key) to associate text with\n+     * @param text the text\n+     *\/\n+    public Bookmark(String name, StyledText text) {\n+        this.name = name;\n+        this.text = text;\n+    }\n+\n+    @Override\n+    public void perform() {\n+        text.subText(0, text.length()).bookmark(name);\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Bookmark.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,236 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import jdk.javadoc.internal.doclets.toolkit.Resources;\n+\n+\/\/\n+\/\/ markup-comment = { markup-tag } ;\n+\/\/     markup-tag = \"@\" , tag-name , {attribute} [\":\"] ;\n+\/\/\n+\/\/ If optional trailing \":\" is present, the tag refers to the next line\n+\/\/ rather than to this line.\n+\/\/\n+\n+\/**\n+ * A parser of a markup line.\n+ *\n+ * <p><b>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own risk.\n+ * This code and its internal interfaces are subject to change or\n+ * deletion without notice.<\/b>\n+ *\/\n+public final class MarkupParser {\n+\n+    private final static int EOI = 0x1A;\n+    private char[] buf;\n+    private int bp;\n+    private int buflen;\n+    private char ch;\n+\n+    private final Resources resources;\n+\n+    public MarkupParser(Resources resources) {\n+        this.resources = resources;\n+    }\n+\n+    public List<Parser.Tag> parse(String input) throws ParseException {\n+\n+        \/\/ No vertical whitespace\n+        assert input.codePoints().noneMatch(c -> c == '\\n' || c == '\\r');\n+\n+        buf = new char[input.length() + 1];\n+        input.getChars(0, input.length(), buf, 0);\n+        buf[buf.length - 1] = EOI;\n+        buflen = buf.length - 1;\n+        bp = -1;\n+\n+        nextChar();\n+        return parse();\n+    }\n+\n+    protected List<Parser.Tag> parse() throws ParseException {\n+        List<Parser.Tag> tags = new ArrayList<>();\n+        \/\/ TODO: what to do with leading and trailing unrecognized markup?\n+        while (bp < buflen) {\n+            switch (ch) {\n+                case '@' -> tags.add(readTag());\n+                default -> nextChar();\n+            }\n+        }\n+\n+        return tags;\n+    }\n+\n+    protected Parser.Tag readTag() throws ParseException {\n+        nextChar();\n+        final int nameBp = bp;\n+        String name = readIdentifier();\n+        skipWhitespace();\n+\n+        boolean appliesToNextLine = false;\n+        List<Attribute> attributes = List.of();\n+\n+        if (ch == ':') {\n+            appliesToNextLine = true;\n+            nextChar();\n+        } else {\n+            attributes = attrs();\n+            skipWhitespace();\n+            if (ch == ':') {\n+                appliesToNextLine = true;\n+                nextChar();\n+            }\n+        }\n+\n+        Parser.Tag i = new Parser.Tag();\n+        i.nameLineOffset = nameBp;\n+        i.name = name;\n+        i.attributes = attributes;\n+        i.appliesToNextLine = appliesToNextLine;\n+\n+        return i;\n+    }\n+\n+    protected String readIdentifier() {\n+        int start = bp;\n+        nextChar();\n+        while (bp < buflen && (Character.isUnicodeIdentifierPart(ch) || ch == '-')) {\n+            nextChar();\n+        }\n+        return new String(buf, start, bp - start);\n+    }\n+\n+    protected void skipWhitespace() {\n+        while (bp < buflen && Character.isWhitespace(ch)) {\n+            nextChar();\n+        }\n+    }\n+\n+    void nextChar() {\n+        ch = buf[bp < buflen ? ++bp : buflen];\n+    }\n+\n+    \/\/ Parsing machinery is adapted from com.sun.tools.javac.parser.DocCommentParser:\n+\n+    private enum ValueKind {\n+        EMPTY,\n+        UNQUOTED,\n+        SINGLE_QUOTED,\n+        DOUBLE_QUOTED;\n+    }\n+\n+    protected List<Attribute> attrs() throws ParseException {\n+        List<Attribute> attrs = new ArrayList<>();\n+        skipWhitespace();\n+\n+        while (bp < buflen && isIdentifierStart(ch)) {\n+            int nameStartPos = bp;\n+            String name = readAttributeName();\n+            skipWhitespace();\n+            StringBuilder value = new StringBuilder();\n+            var vkind = ValueKind.EMPTY;\n+            int valueStartPos = -1;\n+            if (ch == '=') {\n+                nextChar();\n+                skipWhitespace();\n+                if (ch == '\\'' || ch == '\"') {\n+                    vkind = (ch == '\\'') ? ValueKind.SINGLE_QUOTED : ValueKind.DOUBLE_QUOTED;\n+                    char quote = ch;\n+                    nextChar();\n+                    valueStartPos = bp;\n+                    while (bp < buflen && ch != quote) {\n+                        nextChar();\n+                    }\n+                    if (bp >= buflen) {\n+                        String message = resources.getText(\"doclet.snippet.markup.attribute.value.unterminated\");\n+                        throw new ParseException(() -> message, bp - 1);\n+                    }\n+                    addPendingText(value, valueStartPos, bp - 1);\n+                    nextChar();\n+                } else {\n+                    vkind = ValueKind.UNQUOTED;\n+                    valueStartPos = bp;\n+                    while (bp < buflen && !isUnquotedAttrValueTerminator(ch)) {\n+                        nextChar();\n+                    }\n+                    \/\/ Unlike the case with a quoted value, there's no need to\n+                    \/\/ check for unexpected EOL here; an EOL would simply mean\n+                    \/\/ \"end of unquoted value\".\n+                    addPendingText(value, valueStartPos, bp - 1);\n+                }\n+                skipWhitespace();\n+            }\n+\n+            \/\/ material implication:\n+            \/\/     if vkind != EMPTY then it must be the case that valueStartPos >=0\n+            assert !(vkind != ValueKind.EMPTY && valueStartPos < 0);\n+\n+            var attribute = vkind == ValueKind.EMPTY ?\n+                    new Attribute.Valueless(name, nameStartPos) :\n+                    new Attribute.Valued(name, value.toString(), nameStartPos, valueStartPos);\n+\n+            attrs.add(attribute);\n+        }\n+        return attrs;\n+    }\n+\n+    protected boolean isIdentifierStart(char ch) {\n+        return Character.isUnicodeIdentifierStart(ch);\n+    }\n+\n+    protected String readAttributeName() {\n+        int start = bp;\n+        nextChar();\n+        while (bp < buflen && (Character.isUnicodeIdentifierPart(ch) || ch == '-'))\n+            nextChar();\n+        return new String(buf, start, bp - start);\n+    }\n+\n+    \/\/ Similar to https:\/\/html.spec.whatwg.org\/multipage\/syntax.html#unquoted\n+    protected boolean isUnquotedAttrValueTerminator(char ch) {\n+        switch (ch) {\n+            case ':': \/\/ indicates that the instruction relates to the next line\n+            case ' ': case '\\t':\n+            case '\"': case '\\'': case '`':\n+            case '=': case '<': case '>':\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    protected void addPendingText(StringBuilder b, int textStart, int textEnd) {\n+        if (textStart != -1) {\n+            if (textStart <= textEnd) {\n+                b.append(buf, textStart, (textEnd - textStart) + 1);\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/MarkupParser.java","additions":236,"deletions":0,"binary":false,"changes":236,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+\n+import java.util.function.Supplier;\n+\n+\/**\n+ * An exception thrown by {@link Parser} and {@link MarkupParser}.\n+ *\n+ * This exception is only used to capture a user-facing error message.\n+ * The message supplier is accepted not to control when to obtain a message,\n+ * but to abstract how to obtain it.\n+ *\n+ * <p><b>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own risk.\n+ * This code and its internal interfaces are subject to change or\n+ * deletion without notice.<\/b>\n+ *\/\n+public class ParseException extends Exception {\n+\n+    @java.io.Serial\n+    private static final long serialVersionUID = 1;\n+\n+    private final int index;\n+\n+    public ParseException(Supplier<String> messageSupplier, int position) {\n+        super(messageSupplier.get());\n+        if (position < 0) {\n+            throw new IllegalArgumentException(String.valueOf(position));\n+        }\n+        this.index = position;\n+    }\n+\n+    public int getPosition() {\n+        return index;\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/ParseException.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,531 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import jdk.javadoc.internal.doclets.toolkit.Resources;\n+\n+\/*\n+ * Semantics of a EOL comment; plus\n+ * 1. This parser treats input as plain text. This may result in markup being\n+ * produced from unexpected places; for example, when parsing Java text blocks:\n+ *\n+ *     String text =\n+ *         \"\"\"\n+ *             \/\/ @start x\n+ *         \"\"\";\n+ *\n+ * false positives are possible, but false negatives are not.\n+ * To remediate that, perhaps a no-op trailing \/\/ @start x @end x might be added.\n+ *\n+ * 2. To allow some preexisting constructs, unknown actions in a leading position are skipped;\n+ * for example, \"\/\/ @formatter:on\" marker in IntelliJ IDEA is ignored.\n+ *\n+ * 3. This match's value can be confused for a trailing markup.\n+ *\n+ *     String x; \/\/ comment \/\/ another comment \/\/ @formatter:on \/\/ @highlight match=\"\/\/ @\"\n+ *\n+ * Do we need escapes?\n+ *\n+ * 4. Rules for EOL are very different among formats: compare Java's \/\/ with properties' #\/!\n+ *\n+ * 5. A convenience `end` ends all the things started so far.\n+ *\/\n+\/**\n+ * A parser of snippet content.\n+ *\n+ * <p><b>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own risk.\n+ * This code and its internal interfaces are subject to change or\n+ * deletion without notice.<\/b>\n+ *\/\n+public final class Parser {\n+\n+    \/\/ next-line tag behaves as if it were specified on the next line\n+\n+    private String eolMarker;\n+    private Matcher markedUpLine;\n+\n+    private final Resources resources;\n+    private final MarkupParser markupParser;\n+\n+    \/\/ Incomplete actions waiting for their complementary @end\n+    private final Regions regions = new Regions();\n+    private final Queue<Tag> tags = new LinkedList<>();\n+\n+    public Parser(Resources resources) {\n+        this.resources = resources;\n+        this.markupParser = new MarkupParser(resources);\n+    }\n+\n+    public Result parse(String source) throws ParseException {\n+        return parse(\"\/\/\", source);\n+    }\n+\n+    \/*\n+     * Newline characters in the returned text are of the \\n form.\n+     *\/\n+    public Result parse(String eolMarker, String source) throws ParseException {\n+        Objects.requireNonNull(eolMarker);\n+        Objects.requireNonNull(source);\n+        if (!Objects.equals(eolMarker, this.eolMarker)) {\n+            if (eolMarker.length() < 1) {\n+                throw new IllegalArgumentException();\n+            }\n+            for (int i = 0; i < eolMarker.length(); i++) {\n+                switch (eolMarker.charAt(i)) {\n+                    case '\\f', '\\n', '\\r' -> throw new IllegalArgumentException();\n+                }\n+            }\n+            this.eolMarker = eolMarker;\n+            \/\/ capture the rightmost eolMarker (e.g. \"\/\/\")\n+            \/\/ The below Pattern.compile should never throw PatternSyntaxException\n+            Pattern pattern = Pattern.compile(\"^(.*)(\" + Pattern.quote(eolMarker)\n+                    + \"(\\\\s*@\\\\s*\\\\w+.+?))$\");\n+            this.markedUpLine = pattern.matcher(\"\"); \/\/ reusable matcher\n+        }\n+\n+        tags.clear();\n+        regions.clear();\n+\n+        Queue<Action> actions = new LinkedList<>();\n+\n+        StyledText text = new StyledText();\n+        boolean trailingNewline = source.endsWith(\"\\r\") || source.endsWith(\"\\n\");\n+        int lineStart = 0;\n+        List<Tag> previousLineTags = new ArrayList<>();\n+        List<Tag> thisLineTags = new ArrayList<>();\n+        List<Tag> tempList = new ArrayList<>();\n+\n+        \/\/ while lines could be computed lazily, it would yield more complex code\n+        record OffsetAndLine(int offset, String line) { }\n+        var offsetAndLines = new LinkedList<OffsetAndLine>();\n+        forEachLine(source, (off, line) -> offsetAndLines.add(new OffsetAndLine(off, line)));\n+        Iterator<OffsetAndLine> iterator = offsetAndLines.iterator();\n+\n+        while (iterator.hasNext()) {\n+            \/\/ There are 3 cases:\n+            \/\/   1. The pattern that describes a marked-up line is not matched\n+            \/\/   2. While the pattern is matched, the markup is not recognized\n+            \/\/   3. Both the pattern is matched and the markup is recognized\n+            OffsetAndLine next = iterator.next();\n+            String rawLine = next.line();\n+            boolean addLineTerminator = iterator.hasNext() || trailingNewline;\n+            String line;\n+            markedUpLine.reset(rawLine);\n+            if (!markedUpLine.matches()) { \/\/ (1)\n+                line = rawLine + (addLineTerminator ? \"\\n\" : \"\");\n+            } else {\n+                String maybeMarkup = markedUpLine.group(3);\n+                List<Tag> parsedTags = null;\n+                try {\n+                    parsedTags = markupParser.parse(maybeMarkup);\n+                } catch (ParseException e) {\n+                    \/\/ adjust index\n+                    throw new ParseException(e::getMessage, markedUpLine.start(3) + e.getPosition());\n+                }\n+                for (Tag t : parsedTags) {\n+                    t.lineSourceOffset = next.offset;\n+                    t.markupLineOffset = markedUpLine.start(3);\n+                }\n+                thisLineTags.addAll(parsedTags);\n+                for (var tagIterator = thisLineTags.iterator(); tagIterator.hasNext(); ) {\n+                    Tag t = tagIterator.next();\n+                    if (t.appliesToNextLine) {\n+                        tagIterator.remove();\n+                        t.appliesToNextLine = false; \/\/ clear the flag\n+                        tempList.add(t);\n+                    }\n+                }\n+                if (parsedTags.isEmpty()) { \/\/ (2)\n+                    \/\/ TODO: log this with NOTICE;\n+                    line = rawLine + (addLineTerminator ? \"\\n\" : \"\");\n+                } else { \/\/ (3)\n+                    String payload = markedUpLine.group(1);\n+                    line = payload + (addLineTerminator ? \"\\n\" : \"\");\n+                }\n+            }\n+\n+            thisLineTags.addAll(0, previousLineTags); \/\/ prepend!\n+            previousLineTags.clear();\n+            for (Tag t : thisLineTags) {\n+                t.start = lineStart;\n+                t.end = lineStart + line.length(); \/\/ this includes line terminator, if any\n+                processTag(t);\n+            }\n+            previousLineTags.addAll(tempList);\n+            tempList.clear();\n+\n+            thisLineTags.clear();\n+\n+            append(text, Set.of(), line);\n+            \/\/ TODO: mark up trailing whitespace!\n+            lineStart += line.length();\n+        }\n+\n+        if (!previousLineTags.isEmpty()) {\n+            Tag t = previousLineTags.iterator().next();\n+            String message = resources.getText(\"doclet.snippet.markup.tag.non.existent.lines\");\n+            throw new ParseException(() -> message, t.lineSourceOffset\n+                    + t.markupLineOffset + t.nameLineOffset);\n+        }\n+\n+        for (var t : tags) {\n+\n+            \/\/ Translate a list of attributes into a more convenient form\n+            Attributes attributes = new Attributes(t.attributes());\n+\n+            final var substring = attributes.get(\"substring\", Attribute.Valued.class);\n+            final var regex = attributes.get(\"regex\", Attribute.Valued.class);\n+\n+            if (!t.name().equals(\"start\") && substring.isPresent() && regex.isPresent()) {\n+                throw newParseException(t.lineSourceOffset + t.markupLineOffset\n+                                + substring.get().nameStartPosition(),\n+                        \"doclet.snippet.markup.attribute.simultaneous.use\",\n+                        \"substring\", \"regex\");\n+            }\n+\n+            switch (t.name()) {\n+                case \"link\" -> {\n+                    var target = attributes.get(\"target\", Attribute.Valued.class)\n+                            .orElseThrow(() -> newParseException(t.lineSourceOffset\n+                                    + t.markupLineOffset + t.nameLineOffset,\n+                                    \"doclet.snippet.markup.attribute.absent\", \"target\"));\n+                    \/\/ \"type\" is what HTML calls an enumerated attribute\n+                    var type = attributes.get(\"type\", Attribute.Valued.class);\n+                    String typeValue = type.isPresent() ? type.get().value() : \"link\";\n+                    if (!typeValue.equals(\"link\") && !typeValue.equals(\"linkplain\")) {\n+                        throw newParseException(t.lineSourceOffset + t.markupLineOffset\n+                                + type.get().valueStartPosition(),\n+                                \"doclet.snippet.markup.attribute.value.invalid\", typeValue);\n+                    }\n+                    AddStyle a = new AddStyle(new Style.Link(target.value()),\n+                            \/\/ the default regex is different so as not to include newline\n+                            createRegexPattern(substring, regex, \".+\",\n+                                    t.lineSourceOffset + t.markupLineOffset),\n+                            text.subText(t.start(), t.end()));\n+                    actions.add(a);\n+                }\n+                case \"replace\" -> {\n+                    var replacement = attributes.get(\"replacement\", Attribute.Valued.class)\n+                            .orElseThrow(() -> newParseException(t.lineSourceOffset\n+                                    + t.markupLineOffset + t.nameLineOffset,\n+                                    \"doclet.snippet.markup.attribute.absent\", \"replacement\"));\n+                    Replace a = new Replace(replacement.value(),\n+                            createRegexPattern(substring, regex,\n+                                    t.lineSourceOffset + t.markupLineOffset),\n+                            text.subText(t.start(), t.end()));\n+                    actions.add(a);\n+                }\n+                case \"highlight\" -> {\n+                    var type = attributes.get(\"type\", Attribute.Valued.class);\n+\n+                    String typeValue = type.isPresent() ? type.get().value() : \"bold\";\n+\n+                    AddStyle a = new AddStyle(new Style.Name(typeValue),\n+                            createRegexPattern(substring, regex,\n+                                    t.lineSourceOffset + t.markupLineOffset),\n+                            text.subText(t.start(), t.end()));\n+                    actions.add(a);\n+                }\n+                case \"start\" -> {\n+                    var region = attributes.get(\"region\", Attribute.Valued.class)\n+                            .orElseThrow(() -> newParseException(t.lineSourceOffset\n+                                    + t.markupLineOffset + t.nameLineOffset,\n+                                    \"doclet.snippet.markup.attribute.absent\", \"region\"));\n+                    String regionValue = region.value();\n+                    if (regionValue.isBlank()) {\n+                        throw newParseException(t.lineSourceOffset + t.markupLineOffset\n+                                + region.valueStartPosition(), \"doclet.snippet.markup.attribute.value.invalid\");\n+                    }\n+                    for (Attribute a : t.attributes) {\n+                        if (!a.name().equals(\"region\")) {\n+                            throw newParseException(t.lineSourceOffset +\n+                                            t.markupLineOffset + a.nameStartPosition(),\n+                                    \"doclet.snippet.markup.attribute.unexpected\");\n+                        }\n+                    }\n+                    actions.add(new Bookmark(region.value(), text.subText(t.start(), t.end() - 1)));\n+                }\n+            }\n+        }\n+\n+        \/\/ also report on unpaired with corresponding `end` or unknown tags\n+        if (!regions.isEmpty()) {\n+            Optional<Tag> tag = regions.removeLast(); \/\/ any of these tags would do\n+            Tag t = tag.get();\n+            String message = resources.getText(\"doclet.snippet.markup.region.unpaired\");\n+            throw new ParseException(() -> message, t.lineSourceOffset\n+                    + t.markupLineOffset + t.nameLineOffset);\n+        }\n+\n+        return new Result(text, actions);\n+    }\n+\n+    private ParseException newParseException(int pos, String key, Object... args) {\n+        String message = resources.getText(key, args);\n+        return new ParseException(() -> message, pos);\n+    }\n+\n+    private Pattern createRegexPattern(Optional<Attribute.Valued> substring,\n+                                       Optional<Attribute.Valued> regex,\n+                                       int offset) throws ParseException {\n+        return createRegexPattern(substring, regex, \"(?s).+\", offset);\n+    }\n+\n+    private Pattern createRegexPattern(Optional<Attribute.Valued> substring,\n+                                       Optional<Attribute.Valued> regex,\n+                                       String defaultRegex,\n+                                       int offset) throws ParseException {\n+        Pattern pattern;\n+        if (substring.isPresent()) {\n+            \/\/ this Pattern.compile *cannot* throw an exception\n+            pattern = Pattern.compile(Pattern.quote(substring.get().value()));\n+        } else if (regex.isEmpty()) {\n+            \/\/ this Pattern.compile *should not* throw an exception\n+            pattern = Pattern.compile(defaultRegex);\n+        } else {\n+            final String value = regex.get().value();\n+            try {\n+                pattern = Pattern.compile(value);\n+            } catch (PatternSyntaxException e) {\n+                \/\/ Unlike string literals in Java source, attribute values in\n+                \/\/ snippet markup do not use escape sequences. This is why\n+                \/\/ indices of characters in the regex pattern directly map to\n+                \/\/ their corresponding positions in snippet source. Refine\n+                \/\/ position using e.getIndex() only if that index is relevant to\n+                \/\/ the regex in the attribute value. Index might be irrelevant\n+                \/\/ because it refers to an internal representation of regex,\n+                \/\/ e.getPattern(), which might be a normalized or partial view\n+                \/\/ of the original pattern.\n+                int pos = offset + regex.get().valueStartPosition();\n+                if (e.getIndex() > -1 && value.equals(e.getPattern())) {\n+                    pos += e.getIndex();\n+                }\n+                \/\/ getLocalized cannot be used because it provides a localized\n+                \/\/ version of getMessage(), which in the case of this particular\n+                \/\/ exception is multi-line with the caret. If we used that,\n+                \/\/ it would duplicate the information we're trying to provide.\n+                String message = resources.getText(\"doclet.snippet.markup.regex.invalid\");\n+                throw new ParseException(() -> message, pos);\n+            }\n+        }\n+        return pattern;\n+    }\n+\n+    private void processTag(Tag t) throws ParseException {\n+\n+        Attributes attributes = new Attributes(t.attributes()); \/\/ TODO: avoid creating attributes twice\n+        Optional<Attribute> region = attributes.get(\"region\", Attribute.class);\n+\n+        if (!t.name().equals(\"end\")) {\n+            tags.add(t);\n+            if (region.isPresent()) {\n+                if (region.get() instanceof Attribute.Valued v) {\n+                    String name = v.value();\n+                    if (!regions.addNamed(name, t)) {\n+                        throw newParseException(t.lineSourceOffset + t.markupLineOffset\n+                                + v.valueStartPosition(), \"doclet.snippet.markup.region.duplicated\", name);\n+                    }\n+                } else {\n+                    \/\/ TODO: change to exhaustive switch after \"Pattern Matching for switch\" is implemented\n+                    assert region.get() instanceof Attribute.Valueless;\n+                    regions.addAnonymous(t);\n+                }\n+            }\n+        } else {\n+            if (region.isEmpty() || region.get() instanceof Attribute.Valueless) {\n+                Optional<Tag> tag = regions.removeLast();\n+                if (tag.isEmpty()) {\n+                    throw newParseException(t.lineSourceOffset + t.markupLineOffset\n+                            + t.nameLineOffset, \"doclet.snippet.markup.region.none\");\n+                }\n+                completeTag(tag.get(), t);\n+            } else {\n+                assert region.get() instanceof Attribute.Valued;\n+                String name = ((Attribute.Valued) region.get()).value();\n+                Optional<Tag> tag = regions.removeNamed(name);\n+                if (tag.isEmpty()) {\n+                    throw newParseException(t.lineSourceOffset + t.markupLineOffset\n+                            + region.get().nameStartPosition(), \"doclet.snippet.markup.region.unpaired\", name);\n+                }\n+                completeTag(tag.get(), t);\n+            }\n+        }\n+    }\n+\n+    static final class Tag {\n+\n+        String name;\n+        int lineSourceOffset;\n+        int markupLineOffset;\n+        int nameLineOffset;\n+        int start;\n+        int end;\n+        List<Attribute> attributes;\n+        boolean appliesToNextLine;\n+\n+        String name() {\n+            return name;\n+        }\n+\n+        List<Attribute> attributes() {\n+            return attributes;\n+        }\n+\n+        int start() {\n+            return start;\n+        }\n+\n+        int end() {\n+            return end;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Tag{\" +\n+                    \"name='\" + name + '\\'' +\n+                    \", start=\" + start +\n+                    \", end=\" + end +\n+                    \", attributes=\" + attributes +\n+                    '}';\n+        }\n+    }\n+\n+    private void completeTag(Tag start, Tag end) {\n+        assert !start.name().equals(\"end\") : start;\n+        assert end.name().equals(\"end\") : end;\n+        start.end = end.end();\n+    }\n+\n+    private void append(StyledText text, Set<Style> style, CharSequence s) {\n+        text.subText(text.length(), text.length()).replace(style, s.toString());\n+    }\n+\n+    public record Result(StyledText text, Queue<Action> actions) { }\n+\n+    \/*\n+     * Encapsulates the data structure used to manage regions.\n+     *\n+     * boolean-returning commands return true if succeed and false if fail.\n+     *\/\n+    public static final class Regions {\n+\n+        \/*\n+         * LinkedHashMap does not fit here because of both the need for unique\n+         * keys for anonymous regions and inability to easily access the most\n+         * recently put entry.\n+         *\n+         * Since we expect only a few regions, a list will do.\n+         *\/\n+        private final ArrayList<Map.Entry<Optional<String>, Tag>> tags = new ArrayList<>();\n+\n+        void addAnonymous(Tag i) {\n+            tags.add(Map.entry(Optional.empty(), i));\n+        }\n+\n+        boolean addNamed(String name, Tag i) {\n+            boolean matches = tags.stream()\n+                    .anyMatch(entry -> entry.getKey().isPresent() && entry.getKey().get().equals(name));\n+            if (matches) {\n+                return false; \/\/ won't add a duplicate\n+            }\n+            tags.add(Map.entry(Optional.of(name), i));\n+            return true;\n+        }\n+\n+        Optional<Tag> removeNamed(String name) {\n+            for (var iterator = tags.iterator(); iterator.hasNext(); ) {\n+                var entry = iterator.next();\n+                if (entry.getKey().isPresent() && entry.getKey().get().equals(name)) {\n+                    iterator.remove();\n+                    return Optional.of(entry.getValue());\n+                }\n+            }\n+            return Optional.empty();\n+        }\n+\n+        Optional<Tag> removeLast() {\n+            if (tags.isEmpty()) {\n+                return Optional.empty();\n+            }\n+            Map.Entry<Optional<String>, Tag> e = tags.remove(tags.size() - 1);\n+            return Optional.of(e.getValue());\n+        }\n+\n+        void clear() {\n+            tags.clear();\n+        }\n+\n+        boolean isEmpty() {\n+            return tags.isEmpty();\n+        }\n+    }\n+\n+    \/*\n+     * The reason that the lines are split using a custom method as opposed to\n+     * String.split(String) or String.lines() is that along with the lines\n+     * themselves we also need their offsets in the originating input to supply\n+     * to diagnostic exceptions should they arise.\n+     *\n+     * The reason that \"\\n|(\\r\\n)|\\r\" is used instead of \"\\\\R\" is that the\n+     * latter is UNICODE-aware, which we must be not.\n+     *\/\n+    static void forEachLine(String s, LineConsumer consumer) {\n+        \/\/ the fact that the regex alternation is *ordered* is used here to try\n+        \/\/ to match \\r\\n before \\r\n+        final Pattern NEWLINE = Pattern.compile(\"\\n|(\\r\\n)|\\r\");\n+        Matcher matcher = NEWLINE.matcher(s);\n+        int pos = 0;\n+        while (matcher.find()) {\n+            consumer.accept(pos, s.substring(pos, matcher.start()));\n+            pos = matcher.end();\n+        }\n+        if (pos < s.length())\n+            consumer.accept(pos, s.substring(pos));\n+    }\n+\n+    \/*\n+     * This interface is introduced to encapsulate the matching mechanics so\n+     * that it wouldn't be obtrusive to the client code.\n+     *\/\n+    @FunctionalInterface\n+    interface LineConsumer {\n+        void accept(int offset, String line);\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Parser.java","additions":531,"deletions":0,"binary":false,"changes":531,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+\n+import java.util.ArrayList;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * An action that replaces characters in text.\n+ *\n+ * <p><b>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own risk.\n+ * This code and its internal interfaces are subject to change or\n+ * deletion without notice.<\/b>\n+ *\/\n+public final class Replace implements Action {\n+\n+    private final Pattern pattern;\n+    private final String replacement;\n+    private final StyledText text;\n+\n+    \/**\n+     * Constructs an action that replaces regex finds in text.\n+     *\n+     * @param replacement the replacement string\n+     * @param pattern the regex used to search the text\n+     * @param text the text\n+     *\/\n+    public Replace(String replacement, Pattern pattern, StyledText text) {\n+        this.replacement = replacement;\n+        this.pattern = pattern;\n+        this.text = text;\n+    }\n+\n+    @Override\n+    public void perform() {\n+        record Replacement(int start, int end, String value) { }\n+        \/\/ until JDK-8261619 is resolved, translating replacements requires some\n+        \/\/ amount of waste and careful index manipulation\n+        String textString = text.asCharSequence().toString();\n+        Matcher matcher = pattern.matcher(textString);\n+        var replacements = new ArrayList<Replacement>();\n+        StringBuilder b = new StringBuilder();\n+        int off = 0; \/\/ offset because of the replacements (can be negative)\n+        while (matcher.find()) {\n+            int start = matcher.start();\n+            int end = matcher.end();\n+            \/\/ replacements are computed as they may have special symbols\n+            matcher.appendReplacement(b, replacement);\n+            String s = b.substring(start + off);\n+            off = b.length() - end;\n+            replacements.add(new Replacement(start, end, s));\n+        }\n+        \/\/ there's no need to call matcher.appendTail(b)\n+        for (int i = replacements.size() - 1; i >= 0; i--) {\n+            Replacement r = replacements.get(i);\n+            text.subText(r.start, r.end).replace(Set.of(), r.value);\n+        }\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Replace.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+\n+\/**\n+ * A style of a snippet text character.\n+ *\n+ * <p><b>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own risk.\n+ * This code and its internal interfaces are subject to change or\n+ * deletion without notice.<\/b>\n+ *\/\n+\/\/ TODO: uncomment \/* sealed *\/ when minimum boot JDK version >= 17\n+public \/* sealed *\/ interface Style {\n+\n+    \/**\n+     * A style that describes a link. Characters of this style are typically\n+     * processed by wrapping into an HTML {@code A} element pointing to the\n+     * provided target.\n+     *\/\n+    record Link(String target) implements Style { }\n+\n+    \/**\n+     * A named style. Characters of this style are typically processed by\n+     * wrapping into an HTML {@code SPAN} element with the {@code class}\n+     * attribute which is obtained from the provided name.\n+     *\/\n+    record Name(String name) implements Style { }\n+\n+    \/**\n+     * A marker of belonging to markup. Characters of this style are typically\n+     * processed by omitting from the output.\n+     *\/\n+    record Markup() implements Style { }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Style.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,343 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+\n+\/**\n+ * A mutable sequence of individually styleable characters.\n+ *\n+ * <p><b>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own risk.\n+ * This code and its internal interfaces are subject to change or\n+ * deletion without notice.<\/b>\n+ *\/\n+public class StyledText {\n+\n+    private Map<String, StyledText> bookmarks;\n+    private StringBuilder chars;\n+    private Styles styles;\n+    private List<WeakReference<SubText>> subtexts;\n+\n+    public StyledText() {\n+        init();\n+    }\n+\n+    \/*\n+     * This method should be overridden to be no-op by a subclass that wants to\n+     * inherit the interface but not the implementation, which includes\n+     * unnecessary internal objects. If this is done, then all public methods\n+     * should be overridden too, otherwise they will not work.\n+     *\n+     * An alternative design would be to provide an interface for styled text;\n+     * but I ruled that out as unnecessarily heavyweight.\n+     *\/\n+    protected void init() {\n+        this.bookmarks = new HashMap<>();\n+        this.chars = new StringBuilder();\n+        this.styles = new Styles();\n+        this.subtexts = new ArrayList<>();\n+    }\n+\n+    \/*\n+     * For each character of this text adds the provided objects to a set of\n+     * objects associated with that character.\n+     *\/\n+    public void addStyle(Set<? extends Style> additionalStyles) {\n+        styles.add(0, length(), additionalStyles);\n+    }\n+\n+    public int length() {\n+        return chars.length();\n+    }\n+\n+    \/*\n+     * Replaces all characters of this text with the provided sequence of\n+     * characters, each of which is associated with all the provided objects.\n+     *\/\n+    public void replace(Set<? extends Style> styles, CharSequence plaintext) {\n+        replace(0, length(), styles, plaintext);\n+    }\n+\n+    \/*\n+     * A multi-purpose operation that can be used to replace, insert or delete\n+     * text. The effect on a text is as if [start, end) were deleted and\n+     * then plaintext inserted at start.\n+     *\/\n+    private void replace(int start, int end, Set<? extends Style> styles, CharSequence plaintext) {\n+        chars.replace(start, end, plaintext.toString());\n+        this.styles.delete(start, end);\n+        this.styles.insert(start, plaintext.length(), styles);\n+        \/\/ The number of subtexts is not expected to be big; hence no\n+        \/\/ optimizations are applied\n+        var iterator = subtexts.iterator();\n+        while (iterator.hasNext()) {\n+            WeakReference<SubText> ref = iterator.next();\n+            SubText txt = ref.get();\n+            if (txt == null) {\n+                iterator.remove(); \/\/ a stale ref\n+            } else {\n+                update(start, end, plaintext.length(), txt);\n+            }\n+        }\n+    }\n+\n+    \/*\n+     * Updates the text given the scope of the change to reflect text continuity.\n+     *\/\n+    private void update(int start, int end, int newLength, SubText text) {\n+        assert start <= end;\n+        assert text.start <= text.end;\n+        assert newLength >= 0;\n+        if (text.start == text.end && start == text.start) {\n+            \/\/ insertion into empty text; special-cased for simplicity\n+            text.end += newLength;\n+            return;\n+        }\n+        if (end <= text.start) { \/\/ the change is on the left-hand side of the text\n+            int diff = newLength - (end - start);\n+            text.start += diff;\n+            text.end += diff;\n+        } else if (text.end <= start) { \/\/ the change is on the right-hand side of the text\n+            \/\/ no-op; explicit \"if\" for clarity\n+        } else { \/\/ the change intersects with the text\n+            if (text.start <= start && end <= text.end) { \/\/ the change is within the text\n+                text.end += newLength - (end - start);\n+            } else {\n+                int intersectionLen = min(end, text.end) - max(start, text.start);\n+                int oldLen = text.end - text.start;\n+                if (start <= text.start) {\n+                    text.start = start + newLength;\n+                }\n+                text.end = text.start + oldLen - intersectionLen;\n+            }\n+        }\n+    }\n+\n+    private void addStyle(int start, int end, Set<? extends Style> additionalStyles) {\n+        styles.add(start, end, additionalStyles);\n+    }\n+\n+    public StyledText getBookmarkedText(String bookmark) {\n+        return bookmarks.get(Objects.requireNonNull(bookmark));\n+    }\n+\n+    \/*\n+     * Maps the provided name to this text, using a flat namespace. A flat\n+     * namespace means that this text (t), as well as any subtext derived from\n+     * either t or t's subtext, share the naming map.\n+     *\/\n+    public void bookmark(String name) {\n+        bookmark(name, 0, length());\n+    }\n+\n+    private void bookmark(String name, int start, int end) {\n+        bookmarks.put(Objects.requireNonNull(name), subText(start, end));\n+    }\n+\n+    \/*\n+     * Selects a view of the portion of this text starting from start\n+     * (inclusive) to end (exclusive).\n+     *\n+     * In contrast with java.util.List.subList, returned views provide extra\n+     * consistency: they reflect structural changes happening to the underlying\n+     * text and other views thereof.\n+     *\/\n+    public StyledText subText(int start, int end) {\n+        Objects.checkFromToIndex(start, end, length());\n+        var s = new SubText(start, end);\n+        subtexts.add(new WeakReference<>(s));\n+        return s;\n+    }\n+\n+    \/*\n+     * Returns plaintext version of this text. This method is to be used for\n+     * algorithms that accept String or CharSequence to map the result back to\n+     * this text.\n+     *\n+     * There are no extensible \"mutable string\" interface. java.lang.Appendable\n+     * does not support replacements and insertions. StringBuilder\/StringBuffer\n+     * is not extensible. Even if it were extensible, not many general-purpose\n+     * string algorithms accept it.\n+     *\/\n+    public CharSequence asCharSequence() {\n+        return chars;\n+    }\n+\n+    \/*\n+     * Provides text to the consumer efficiently. The text always calls the\n+     * consumer at least once; even if the text is empty.\n+     *\/\n+    public void consumeBy(StyledText.Consumer consumer) {\n+        consumeBy(consumer, 0, length());\n+    }\n+\n+    private void consumeBy(StyledText.Consumer consumer, int start, int end) {\n+        Objects.checkFromToIndex(start, end, length());\n+        styles.consumeBy(consumer, chars, start, end);\n+    }\n+\n+    public StyledText append(Set<? extends Style> styles, CharSequence sequence) {\n+        subText(length(), length()).replace(styles, sequence);\n+        return this;\n+    }\n+\n+    public StyledText append(StyledText fragment) {\n+        fragment.consumeBy((style, sequence) -> subText(length(), length()).replace(style, sequence));\n+        return this;\n+    }\n+\n+    @FunctionalInterface\n+    public interface Consumer {\n+\n+        void consume(Set<? extends Style> style, CharSequence sequence);\n+    }\n+\n+    \/*\n+     * A structure that stores character styles.\n+     *\/\n+    private static final class Styles {\n+\n+        \/\/ Although this structure optimizes neither memory use nor object\n+        \/\/ allocation, it is simple both to implement and reason about.\n+\n+        \/\/ list is a reference to ArrayList because this class accesses list by\n+        \/\/ index, so this is important that the list is RandomAccess, which\n+        \/\/ ArrayList is\n+        private final ArrayList<Set<Style>> list = new ArrayList<>();\n+\n+        private void delete(int fromIndex, int toIndex) {\n+            list.subList(fromIndex, toIndex).clear();\n+        }\n+\n+        private void insert(int fromIndex, int length, Set<? extends Style> s) {\n+            list.addAll(fromIndex, Collections.nCopies(length, Set.copyOf(s)));\n+        }\n+\n+        private void add(int fromIndex, int toIndex, Set<? extends Style> additional) {\n+            Set<Style> copyOfAdditional = Set.copyOf(additional);\n+            list.subList(fromIndex, toIndex).replaceAll(current -> sum(current, copyOfAdditional));\n+        }\n+\n+        private Set<Style> sum(Set<? extends Style> a, Set<Style> b) {\n+            \/\/ assumption: until there are complex texts, the most common\n+            \/\/ scenario is the one where `a` is empty while `b` is not\n+            if (a.isEmpty()) {\n+                return b;\n+            } else {\n+                Set<Style> c = new HashSet<>(a);\n+                c.addAll(b);\n+                return Set.copyOf(c);\n+            }\n+        }\n+\n+        private void consumeBy(StyledText.Consumer consumer, CharSequence seq, int start, int end) {\n+            if (start == end) {\n+                \/\/ an empty region doesn't have an associated set; special-cased\n+                \/\/ for simplicity to avoid more complicated implementation of\n+                \/\/ this method using a do-while loop\n+                consumer.consume(Set.of(), \"\");\n+            } else {\n+                for (int i = start, j = i + 1; i < end; i = j) {\n+                    var ith = list.get(i);\n+                    while (j < end && ith.equals(list.get(j))) {\n+                        j++;\n+                    }\n+                    consumer.consume(ith, seq.subSequence(i, j));\n+                }\n+            }\n+        }\n+    }\n+\n+    final class SubText extends StyledText {\n+\n+        int start, end;\n+\n+        private SubText(int start, int end) {\n+            this.start = start;\n+            this.end = end;\n+        }\n+\n+        @Override\n+        protected void init() {\n+            \/\/ no-op\n+        }\n+\n+        @Override\n+        public void addStyle(Set<? extends Style> additionalStyles) {\n+            StyledText.this.addStyle(start, end, additionalStyles);\n+        }\n+\n+        @Override\n+        public int length() {\n+            return end - start;\n+        }\n+\n+        @Override\n+        public void replace(Set<? extends Style> styles, CharSequence plaintext) {\n+            \/\/ If the \"replace\" operation affects this text's size, which it\n+            \/\/ can, then that size will be updated along with all other sizes\n+            \/\/ during the bulk \"update\" operation in tracking text instance.\n+            StyledText.this.replace(start, end, styles, plaintext);\n+        }\n+\n+        @Override\n+        public StyledText getBookmarkedText(String bookmark) {\n+            return StyledText.this.getBookmarkedText(bookmark);\n+        }\n+\n+        @Override\n+        public void bookmark(String name) {\n+            StyledText.this.bookmark(name, start, end);\n+        }\n+\n+        @Override\n+        public StyledText subText(int start, int end) {\n+            return StyledText.this.subText(this.start + start, this.start + end);\n+        }\n+\n+        @Override\n+        public CharSequence asCharSequence() {\n+            return StyledText.this.asCharSequence().subSequence(start, end);\n+        }\n+\n+        @Override\n+        public void consumeBy(StyledText.Consumer consumer) {\n+            StyledText.this.consumeBy(consumer, start, end);\n+        }\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/StyledText.java","additions":343,"deletions":0,"binary":false,"changes":343,"status":"added"},{"patch":"@@ -343,1 +343,0 @@\n-        Utils utils = configuration.utils;\n@@ -345,0 +344,5 @@\n+        return getReferencedClass(e);\n+    }\n+\n+    public TypeElement getReferencedClass(Element e) {\n+        Utils utils = configuration.utils;\n@@ -357,1 +361,5 @@\n-        if (s == null || s.contains(\"#\") || s.contains(\"(\")) {\n+        return getReferencedModuleName(s);\n+    }\n+\n+    public String getReferencedModuleName(String signature) {\n+        if (signature == null || signature.contains(\"#\") || signature.contains(\"(\")) {\n@@ -360,2 +368,2 @@\n-        int n = s.indexOf(\"\/\");\n-        return (n == -1) ? s : s.substring(0, n);\n+        int n = signature.indexOf(\"\/\");\n+        return (n == -1) ? signature : signature.substring(0, n);\n@@ -365,1 +373,0 @@\n-        Utils utils = configuration.utils;\n@@ -367,0 +374,5 @@\n+        return getReferencedMember(e);\n+    }\n+\n+    public Element getReferencedMember(Element e) {\n+        Utils utils = configuration.utils;\n@@ -375,1 +387,5 @@\n-        if (s == null) {\n+        return getReferencedMemberName(s);\n+    }\n+\n+    public String getReferencedMemberName(String signature) {\n+        if (signature == null) {\n@@ -378,2 +394,2 @@\n-        int n = s.indexOf(\"#\");\n-        return (n == -1) ? null : s.substring(n + 1);\n+        int n = signature.indexOf(\"#\");\n+        return (n == -1) ? null : signature.substring(n + 1);\n@@ -384,0 +400,4 @@\n+        return getReferencedPackage(e);\n+    }\n+\n+    public PackageElement getReferencedPackage(Element e) {\n@@ -393,0 +413,4 @@\n+        return getReferencedModule(e);\n+    }\n+\n+    public ModuleElement getReferencedModule(Element e) {\n@@ -399,1 +423,0 @@\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/CommentHelper.java","additions":32,"deletions":9,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -632,0 +632,6 @@\n+        \/\/ for now, ensure we're in an HTML StartElementTree;\n+        \/\/ in time, we might check uses of attributes in other tree nodes\n+        if (getParentKind() != DocTree.Kind.START_ELEMENT) {\n+            return null;\n+        }\n+\n@@ -1159,0 +1165,4 @@\n+    private DocTree.Kind getParentKind() {\n+        return getCurrentPath().getParentPath().getLeaf().getKind();\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclint\/Checker.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -143,0 +143,3 @@\n+        \/\/ snippet-related\n+        removeAll(styleSheetNames, \"bold\", \"highlighted\", \"italic\");\n+\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/checkStylesheetClasses\/CheckStylesheetClasses.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,2380 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8201533\n+ * @summary Implementation for snippets\n+ * @library \/tools\/lib ..\/..\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build javadoc.tester.* toolbox.ToolBox toolbox.ModuleBuilder builder.ClassBuilder\n+ * @run main TestSnippetTag\n+ *\/\n+\n+import builder.ClassBuilder;\n+import builder.ClassBuilder.MethodBuilder;\n+import javadoc.tester.JavadocTester;\n+import toolbox.ModuleBuilder;\n+import toolbox.ToolBox;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+import java.util.function.ObjIntConsumer;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+\/\/ FIXME\n+\/\/   0. Add tests for snippets in all types of elements: e.g., fields\n+\/\/      and constructors (i.e. not only methods.)\n+\/\/   1. Add tests for nested structure under \"snippet-files\/\"\n+\/\/   2. Add negative tests for region\n+\/\/   3. Add tests for hybrid snippets\n+\n+\/*\n+ * General notes.\n+ *\n+ * 1. Some of the below tests could benefit from using a combinatorics library\n+ * as they are otherwise very wordy.\n+ *\n+ * 2. One has to be careful when using JavadocTester.checkOutput with duplicating\n+ * strings. If JavadocTester.checkOutput(x) is true, then it will also be true\n+ * if x is passed to that method additionally N times: JavadocTester.checkOutput(x, x, ..., x).\n+ * This is because a single occurrence of x in the output will be matched N times.\n+ *\/\n+public class TestSnippetTag extends JavadocTester {\n+\n+    private final ToolBox tb = new ToolBox();\n+\n+    private TestSnippetTag() { }\n+\n+    public static void main(String... args) throws Exception {\n+        new TestSnippetTag().runTests(m -> new Object[]{Paths.get(m.getName())});\n+    }\n+\n+    \/*\n+     * While the \"id\" and \"lang\" attributes are advertised in JEP 413, they are\n+     * currently unused by the implementation. The goal of this test is to make\n+     * sure that specifying these attributes causes no errors and exhibits no\n+     * unexpected behavior.\n+     *\/\n+    @Test\n+    public void testIdAndLangAttributes(Path base) throws IOException {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        final var snippets = List.of(\n+                \"\"\"\n+                {@snippet id=\"foo\" :\n+                    Hello, Snippet!\n+                }\n+                \"\"\",\n+                \"\"\"\n+                {@snippet id=\"foo\":\n+                    Hello, Snippet!\n+                }\n+                \"\"\",\n+                \"\"\"\n+                {@snippet id='foo' :\n+                    Hello, Snippet!\n+                }\n+                \"\"\",\n+                \"\"\"\n+                {@snippet id='foo':\n+                    Hello, Snippet!\n+                }\n+                \"\"\",\n+                \"\"\"\n+                {@snippet id=foo :\n+                    Hello, Snippet!\n+                }\n+                \"\"\",\n+\/\/ (1) Haven't yet decided on this one. It's a consistency issue. On the one\n+\/\/ hand, `:` is considered a part of a javadoc tag's name (e.g. JDK-4750173);\n+\/\/ on the other hand, snippet markup treats `:` (next-line modifier) as a value\n+\/\/ terminator.\n+\/\/                \"\"\"\n+\/\/                {@snippet id=foo:\n+\/\/                    Hello, Snippet!\n+\/\/                }\n+\/\/                \"\"\",\n+                \"\"\"\n+                {@snippet id=\"\" :\n+                    Hello, Snippet!\n+                }\n+                \"\"\",\n+                \"\"\"\n+                {@snippet id=\"\":\n+                    Hello, Snippet!\n+                }\n+                \"\"\",\n+                \"\"\"\n+                {@snippet id='':\n+                    Hello, Snippet!\n+                }\n+                \"\"\",\n+                \"\"\"\n+                {@snippet id=:\n+                    Hello, Snippet!\n+                }\n+                \"\"\",\n+                \"\"\"\n+                {@snippet lang=\"java\" :\n+                    Hello, Snippet!\n+                }\n+                \"\"\",\n+                \"\"\"\n+                {@snippet lang=\"java\":\n+                    Hello, Snippet!\n+                }\n+                \"\"\",\n+                \"\"\"\n+                {@snippet lang='java' :\n+                    Hello, Snippet!\n+                }\n+                \"\"\",\n+                \"\"\"\n+                {@snippet lang='java':\n+                    Hello, Snippet!\n+                }\n+                \"\"\",\n+                \"\"\"\n+                {@snippet lang=java :\n+                    Hello, Snippet!\n+                }\n+                \"\"\",\n+                \"\"\"\n+                {@snippet lang=\"properties\" :\n+                    Hello, Snippet!\n+                }\n+                \"\"\",\n+                \"\"\"\n+                {@snippet lang=\"text\" :\n+                    Hello, Snippet!\n+                }\n+                \"\"\",\n+                \"\"\"\n+                {@snippet lang=\"\" :\n+                    Hello, Snippet!\n+                }\n+                \"\"\",\n+                \"\"\"\n+                {@snippet lang=\"foo\" id=\"bar\" :\n+                    Hello, Snippet!\n+                }\n+                \"\"\"\n+        );\n+        ClassBuilder classBuilder = new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\");\n+        forEachNumbered(snippets, (s, i) -> {\n+            classBuilder.addMembers(\n+                    MethodBuilder.parse(\"public void case%s() { }\".formatted(i))\n+                            .setComments(s));\n+        });\n+        classBuilder.write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+        for (int j = 0; j < snippets.size(); j++) {\n+            checkOutput(\"pkg\/A.html\", true,\n+                        \"\"\"\n+                        <span class=\"element-name\">case%s<\/span>()<\/div>\n+                        <div class=\"block\">\n+                        <pre class=\"snippet\">\n+                            Hello, Snippet!\n+                        <\/pre>\n+                        <\/div>\n+                        \"\"\".formatted(j));\n+        }\n+    }\n+\n+    \/*\n+     * This is a convenience method to iterate through a list.\n+     * Unlike List.forEach, this method provides the consumer not only with an\n+     * element but also that element's index.\n+     *\n+     * See JDK-8184707.\n+     *\/\n+    private static <T> void forEachNumbered(List<T> list, ObjIntConsumer<? super T> action) {\n+        for (var iterator = list.listIterator(); iterator.hasNext(); ) {\n+            action.accept(iterator.next(), iterator.previousIndex());\n+        }\n+    }\n+\n+    @Test\n+    public void testBadTagSyntax(Path base) throws IOException {\n+        \/\/ TODO consider improving diagnostic output by providing more specific\n+        \/\/  error messages and better positioning the caret (depends on JDK-8273244)\n+\n+        \/\/ Capture is created to expose TestCase only to the testErrors method;\n+        \/\/ The resulting complexity suggests this whole method should be\n+        \/\/ extracted into a separate test file\n+        class Capture {\n+            static final AtomicInteger counter = new AtomicInteger();\n+\n+            record TestCase(String input, String expectedError) { }\n+\n+            void testErrors(List<TestCase> testCases) throws IOException {\n+                List<String> inputs = testCases.stream().map(s -> s.input).toList();\n+                StringBuilder methods = new StringBuilder();\n+                forEachNumbered(inputs, (i, n) -> {\n+                    methods.append(\n+                        \"\"\"\n+\n+                        \/**\n+                        %s*\/\n+                        public void case%s() {}\n+                        \"\"\".formatted(i, n));\n+                });\n+\n+                String classString =\n+                    \"\"\"\n+                    public class A {\n+                    %s\n+                    }\n+                    \"\"\".formatted(methods.toString());\n+\n+                String suffix = String.valueOf(counter.incrementAndGet());\n+\n+                Path src = Files.createDirectories(base.resolve(\"src\" + suffix));\n+                tb.writeJavaFiles(src, classString);\n+\n+                javadoc(\"-d\", base.resolve(\"out\" + suffix).toString(),\n+                    \"-sourcepath\", src.toString(),\n+                    src.resolve(\"A.java\").toString());\n+                checkExit(Exit.ERROR);\n+                checkOrder(Output.OUT, testCases.stream().map(TestCase::expectedError).toArray(String[]::new));\n+                checkNoCrashes();\n+            }\n+        }\n+\n+        new Capture().testErrors(List.of(\n+            \/\/ <editor-fold desc=\"missing newline after colon\">\n+            new Capture.TestCase(\n+                \"\"\"\n+                {@snippet :}\n+                \"\"\",\n+                \"\"\"\n+                error: unexpected content\n+                {@snippet :}\n+                ^\n+                \"\"\"),\n+            new Capture.TestCase(\n+                \"\"\"\n+                {@snippet : }\n+                \"\"\",\n+                \"\"\"\n+                error: unexpected content\n+                {@snippet : }\n+                ^\n+                \"\"\"),\n+            new Capture.TestCase(\n+                \"\"\"\n+                {@snippet :a}\n+                \"\"\",\n+                \"\"\"\n+                error: unexpected content\n+                {@snippet :a}\n+                ^\n+                \"\"\"),\n+            new Capture.TestCase(\n+                \"\"\"\n+                {@snippet\n+                :}\n+                \"\"\",\n+                \"\"\"\n+                error: unexpected content\n+                {@snippet\n+                ^\n+                \"\"\"),\n+            new Capture.TestCase(\n+                \"\"\"\n+                {@snippet\n+                : }\n+                \"\"\",\n+                \"\"\"\n+                error: unexpected content\n+                {@snippet\n+                ^\n+                \"\"\"),\n+            new Capture.TestCase(\n+                \"\"\"\n+                {@snippet\n+                :a}\n+                \"\"\",\n+                \"\"\"\n+                error: unexpected content\n+                {@snippet\n+                ^\n+                \"\"\"),\n+            new Capture.TestCase(\n+                \"\"\"\n+                {@snippet\n+                 :}\n+                \"\"\",\n+                \"\"\"\n+                error: unexpected content\n+                {@snippet\n+                ^\n+                \"\"\"),\n+            new Capture.TestCase(\n+                \"\"\"\n+                {@snippet\n+                 : }\n+                \"\"\",\n+                \"\"\"\n+                error: unexpected content\n+                {@snippet\n+                ^\n+                \"\"\"),\n+            new Capture.TestCase(\n+                \"\"\"\n+                {@snippet\n+                 :a}\n+                \"\"\",\n+                \"\"\"\n+                error: unexpected content\n+                {@snippet\n+                ^\n+                \"\"\"),\n+            \/\/ <\/editor-fold>\n+            \/\/ <editor-fold desc=\"unexpected end of attribute\">\n+            \/\/ In this and some other tests cases below, the tested behavior\n+            \/\/ is expected, although it might seem counterintuitive.\n+            \/\/ It might seem like the closing curly should close the tag,\n+            \/\/ where in fact it belongs to the attribute value.\n+            new Capture.TestCase(\n+                \"\"\"\n+                {@snippet file=\"}\n+                \"\"\",\n+                \"\"\"\n+                error: no content\n+                {@snippet file=\"}\n+                ^\n+                \"\"\"),\n+            new Capture.TestCase(\n+                \"\"\"\n+                {@snippet file=\"\n+                }\n+                \"\"\",\n+                \"\"\"\n+                error: no content\n+                {@snippet file=\"\n+                ^\n+                \"\"\"),\n+            new Capture.TestCase(\n+                \"\"\"\n+                {@snippet file='}\n+                \"\"\",\n+                \"\"\"\n+                error: no content\n+                {@snippet file='}\n+                ^\n+                \"\"\"),\n+            new Capture.TestCase(\n+                \"\"\"\n+                {@snippet file='\n+                }\n+                \"\"\",\n+                \"\"\"\n+                error: no content\n+                {@snippet file='\n+                ^\n+                \"\"\"),\n+            new Capture.TestCase(\n+                \"\"\"\n+                {@snippet file='\n+                    }\n+                \"\"\",\n+                \"\"\"\n+                error: no content\n+                {@snippet file='\n+                ^\n+                \"\"\"),\n+            new Capture.TestCase(\n+                \"\"\"\n+                {@snippet\n+                file='\n+                    }\n+                \"\"\",\n+                \"\"\"\n+                error: no content\n+                {@snippet\n+                ^\n+                \"\"\"),\n+            new Capture.TestCase(\n+                \"\"\"\n+                {@snippet\n+                file='}\n+                \"\"\",\n+                \"\"\"\n+                error: no content\n+                {@snippet\n+                ^\n+                \"\"\"),\n+            \/\/ <\/editor-fold>\n+            \/\/ <editor-fold desc=\"missing attribute value\">\n+            new Capture.TestCase(\n+                \"\"\"\n+                {@snippet file=}\n+                \"\"\",\n+                \"\"\"\n+                error: illegal value for attribute \"file\": \"\"\n+                {@snippet file=}\n+                          ^\n+                \"\"\"),\n+            new Capture.TestCase(\n+                \"\"\"\n+                {@snippet file=:\n+                }\n+                \"\"\",\n+                \"\"\"\n+                error: illegal value for attribute \"file\": \"\"\n+                {@snippet file=:\n+                          ^\n+                \"\"\")\n+            \/\/ <\/editor-fold>\n+        ));\n+\n+        \/\/ The below errors are checked separately because they might appear\n+        \/\/ out of order with respect to the errors checked above.\n+        \/\/ This is because the errors below are modelled as exceptions thrown\n+        \/\/ at parse time, when there are no doc trees yet. And the errors above\n+        \/\/ are modelled as erroneous trees that are processed after the parsing\n+        \/\/ is finished.\n+\n+        new Capture().testErrors(List.of(\n+            \/\/ <editor-fold desc=\"unexpected end of input\">\n+            \/\/ now newline after :\n+            new Capture.TestCase(\n+                \"\"\"\n+                {@snippet file=:}\n+                \"\"\",\n+                \"\"\"\n+                error: unexpected content\n+                {@snippet file=:}\n+                ^\n+                \"\"\"),\n+            new Capture.TestCase(\n+                \"\"\"\n+                {@snippet\n+                \"\"\",\n+                \"\"\"\n+                error: no content\n+                {@snippet\n+                ^\n+                \"\"\"),\n+            new Capture.TestCase(\n+                \"\"\"\n+                {@snippet file\n+                \"\"\",\n+                \"\"\"\n+                error: no content\n+                {@snippet file\n+                ^\n+                \"\"\"),\n+            new Capture.TestCase(\n+                \"\"\"\n+                {@snippet file=\n+                \"\"\",\n+                \"\"\"\n+                error: no content\n+                {@snippet file=\n+                ^\n+                \"\"\"),\n+            new Capture.TestCase(\n+                \"\"\"\n+                {@snippet file=\"\n+                \"\"\",\n+                \"\"\"\n+                error: no content\n+                {@snippet file=\"\n+                ^\n+                \"\"\"),\n+            new Capture.TestCase(\n+                \"\"\"\n+                {@snippet file='\n+                \"\"\",\n+                \"\"\"\n+                error: no content\n+                {@snippet file='\n+                ^\n+                \"\"\"),\n+            new Capture.TestCase(\n+                \"\"\"\n+                {@snippet :\"\"\",\n+                \"\"\"\n+                error: no content\n+                {@snippet :*\/\n+                ^\n+                \"\"\"),\n+            new Capture.TestCase(\n+                \"\"\"\n+                {@snippet :\n+                    Hello, World!\"\"\",\n+                \"\"\"\n+                error: unterminated inline tag\n+                {@snippet :\n+                ^\n+                \"\"\"),\n+            new Capture.TestCase(\n+                \"\"\"\n+                {@snippet file=\"gibberish\" :\\\n+                \"\"\",\n+                \"\"\"\n+                error: no content\n+                {@snippet file=\"gibberish\" :*\/\n+                ^\n+                \"\"\"),\n+            new Capture.TestCase(\n+                \"\"\"\n+                {@snippet file=\"gibberish\" :\n+                \"\"\",\n+                \"\"\"\n+                error: unterminated inline tag\n+                {@snippet file=\"gibberish\" :\n+                ^\n+                \"\"\")\n+            \/\/ <\/editor-fold>\n+        ));\n+    }\n+\n+    \/\/ TODO This is a temporary method; it should be removed after JavadocTester has provided similar functionality (JDK-8273154).\n+    private void checkOrder(Output output, String... strings) {\n+        String outputString = getOutput(output);\n+        int prevIndex = -1;\n+        for (String s : strings) {\n+            s = s.replace(\"\\n\", NL); \/\/ normalize new lines\n+            int currentIndex = outputString.indexOf(s, prevIndex + 1);\n+            checking(\"output: \" + output + \": \" + s + \" at index \" + currentIndex);\n+            if (currentIndex == -1) {\n+                failed(output + \": \" + s + \" not found.\");\n+                continue;\n+            }\n+            if (currentIndex > prevIndex) {\n+                passed(output + \": \" + \" is in the correct order\");\n+            } else {\n+                failed(output + \": \" + \" is in the wrong order.\");\n+            }\n+            prevIndex = currentIndex;\n+        }\n+    }\n+\n+    \/*\n+     * When checking for errors, it is important not to confuse one error with\n+     * another. This method checks that there are no crashes (which are also\n+     * errors) by checking for stack traces. We never expect crashes.\n+     *\/\n+    private void checkNoCrashes() {\n+        checking(\"check crashes\");\n+        Matcher matcher = Pattern.compile(\"\\s*at.*\\\\(.*\\\\.java:\\\\d+\\\\)\")\n+                .matcher(getOutput(Output.STDERR));\n+        if (!matcher.find()) {\n+            passed(\"\");\n+        } else {\n+            failed(\"Looks like a stacktrace: \" + matcher.group());\n+        }\n+    }\n+\n+    \/*\n+     * A colon that is not separated from a tag name by whitespace is considered\n+     * a part of that name. This behavior is historical. For more context see,\n+     * for example, JDK-4750173.\n+     *\/\n+    @Test\n+    public void testUnknownTag(Path base) throws IOException {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        final var unknownTags = List.of(\n+                \"\"\"\n+                {@snippet:}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet:\n+                }\n+                \"\"\"\n+        );\n+        ClassBuilder classBuilder = new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\");\n+        forEachNumbered(unknownTags, (s, i) -> {\n+            classBuilder.addMembers(\n+                    MethodBuilder.parse(\"public void case%s() { }\".formatted(i))\n+                            .setComments(s));\n+        });\n+        classBuilder.write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+        long actual = Pattern.compile(\"error: unknown tag: snippet:\")\n+                .matcher(getOutput(Output.OUT)).results().count();\n+        checking(\"Number of errors\");\n+        int expected = unknownTags.size();\n+        if (actual == expected) {\n+            passed(\"\");\n+        } else {\n+            failed(actual + \" vs \" + expected);\n+        }\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testInline(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+\n+        record TestCase(String input, String expectedOutput) { }\n+\n+        final var testCases = List.of(\n+                \/\/ minimal empty\n+                new TestCase(\"\"\"\n+                             {@snippet :\n+                             }\n+                             \"\"\",\n+                             \"\"\"\n+                             \"\"\"),\n+                \/\/ empty with a newline before `:` as a separator\n+                new TestCase(\"\"\"\n+                             {@snippet\n+                             :\n+                             }\n+                             \"\"\",\n+                             \"\"\"\n+                             \"\"\"),\n+                \/\/ empty with a newline followed by whitespace before `:`\n+                new TestCase(\"\"\"\n+                             {@snippet\n+                                       :\n+                             }\n+                             \"\"\",\n+                             \"\"\"\n+                             \"\"\"),\n+                \/\/ empty with whitespace followed by a newline before `:`\n+                new TestCase(\"\"\"\n+                             {@snippet    \\s\n+                             :\n+                             }\n+                             \"\"\",\n+                             \"\"\"\n+                             \"\"\"),\n+                \/\/ basic\n+                new TestCase(\"\"\"\n+                             {@snippet :\n+                                 Hello, Snippet!\n+                             }\n+                             \"\"\",\n+                             \"\"\"\n+                                 Hello, Snippet!\n+                             \"\"\"),\n+                \/\/ leading whitespace before `:`\n+                new TestCase(\"\"\"\n+                             {@snippet       :\n+                                 Hello, Snippet!\n+                             }\n+                             \"\"\",\n+                             \"\"\"\n+                                 Hello, Snippet!\n+                             \"\"\"),\n+                \/\/ trailing whitespace after `:`\n+                new TestCase(\"\"\"\n+                             {@snippet :      \\s\n+                                 Hello, Snippet!\n+                             }\n+                             \"\"\",\n+                             \"\"\"\n+                                 Hello, Snippet!\n+                             \"\"\"),\n+                \/\/ attributes do not interfere with body\n+                new TestCase(\"\"\"\n+                             {@snippet  attr1=\"val1\"    :\n+                                 Hello, Snippet!\n+                             }\n+                             \"\"\",\n+                             \"\"\"\n+                                 Hello, Snippet!\n+                             \"\"\"),\n+                \/\/ multi-line\n+                new TestCase(\"\"\"\n+                             {@snippet :\n+                                 Hello\n+                                 ,\n+                                  Snippet!\n+                             }\n+                             \"\"\",\n+                             \"\"\"\n+                                 Hello\n+                                 ,\n+                                  Snippet!\n+                             \"\"\"),\n+                \/\/ leading empty line\n+                new TestCase(\"\"\"\n+                             {@snippet :\n+\n+                                 Hello\n+                                 ,\n+                                  Snippet!\n+                             }\n+                             \"\"\",\n+                             \"\"\"\n+\n+                                 Hello\n+                                 ,\n+                                  Snippet!\n+                             \"\"\"),\n+                \/\/ trailing empty line\n+                new TestCase(\"\"\"\n+                             {@snippet :\n+                                 Hello\n+                                 ,\n+                                  Snippet!\n+\n+                             }\n+                             \"\"\",\n+                             \"\"\"\n+                                 Hello\n+                                 ,\n+                                  Snippet!\n+\n+                             \"\"\"),\n+                \/\/ controlling indent with `}`\n+                new TestCase(\"\"\"\n+                             {@snippet :\n+                                 Hello\n+                                 ,\n+                                  Snippet!\n+                                 }\n+                             \"\"\",\n+                             \"\"\"\n+                             Hello\n+                             ,\n+                              Snippet!\n+                             \"\"\"\n+                ),\n+                \/\/ no trailing newline before `}\n+                new TestCase(\"\"\"\n+                             {@snippet :\n+                                 Hello\n+                                 ,\n+                                  Snippet!}\n+                             \"\"\",\n+                             \"\"\"\n+                             Hello\n+                             ,\n+                              Snippet!\"\"\"),\n+                \/\/ trailing space is stripped\n+                new TestCase(\"\"\"\n+                             {@snippet :\n+                                 Hello\n+                                 ,    \\s\n+                                  Snippet!\n+                             }\n+                             \"\"\",\n+                             \"\"\"\n+                                 Hello\n+                                 ,\n+                                  Snippet!\n+                             \"\"\"),\n+                \/\/ escapes of Text Blocks and string literals are not interpreted\n+                new TestCase(\"\"\"\n+                             {@snippet :\n+                                 \\\\b\\\\t\\\\n\\\\f\\\\r\\\\\"\\\\'\\\\\\\n+                                 Hello\\\\\n+                                 ,\\\\s\n+                                  Snippet!\n+                             }\n+                             \"\"\",\n+                             \"\"\"\n+                                 \\\\b\\\\t\\\\n\\\\f\\\\r\\\\\"\\\\'\\\\    Hello\\\\\n+                                 ,\\\\s\n+                                  Snippet!\n+                             \"\"\"),\n+                \/\/ HTML is not interpreted\n+                new TestCase(\"\"\"\n+                             {@snippet :\n+                                 <\/pre>\n+                                     <!-- comment -->\n+                                 <b>&trade;<\/b> &#8230; \" '\n+                             }\n+                             \"\"\",\n+                             \"\"\"\n+                                 &lt;\/pre&gt;\n+                                     &lt;!-- comment --&gt;\n+                                 &lt;b&gt;&amp;trade;&lt;\/b&gt; &amp;#8230; \" '\n+                             \"\"\")\n+        );\n+        ClassBuilder classBuilder = new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\");\n+        forEachNumbered(testCases, (t, id) -> {\n+            classBuilder\n+                    .addMembers(\n+                            MethodBuilder\n+                                    .parse(\"public void case%s() { }\".formatted(id))\n+                                    .setComments(t.input()));\n+        });\n+        classBuilder.write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+        forEachNumbered(testCases, (t, id) -> {\n+            checkOutput(\"pkg\/A.html\", true,\n+                        \"\"\"\n+                        <span class=\"element-name\">case%s<\/span>()<\/div>\n+                        <div class=\"block\">\n+                        <pre class=\"snippet\">\n+                        %s<\/pre>\n+                        <\/div>\"\"\".formatted(id, t.expectedOutput()));\n+        });\n+    }\n+\n+    @Test\n+    public void testExternalFile(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+\n+        record TestCase(String input, Function<String, String> expectedTransformation) {\n+\n+            TestCase(String input) {\n+                this(input, Function.identity());\n+            }\n+        }\n+\n+        final var testCases = List.of(\n+                new TestCase(\"\"\"\n+                             Hello, Snippet!\n+                             \"\"\"),\n+                new TestCase(\"\"\"\n+                                 Hello, Snippet!\n+                             \"\"\"),\n+                new TestCase(\"\"\"\n+                                 Hello\n+                                 ,\n+                                  Snippet!\n+                             \"\"\"),\n+                new TestCase(\"\"\"\n+\n+                                 Hello\n+                                 ,\n+                                  Snippet!\n+                             \"\"\"),\n+                new TestCase(\"\"\"\n+                                 Hello\n+                                 ,\n+                                  Snippet!\n+\n+                             \"\"\"),\n+                new TestCase(\"\"\"\n+                                 Hello\n+                                 ,        \\s\n+                                  Snippet!\n+                             \"\"\",\n+                             String::stripIndent),\n+                new TestCase(\"\"\"\n+                             Hello\n+                             ,\n+                              Snippet!\"\"\"),\n+                new TestCase(\"\"\"\n+                                 \\\\b\\\\t\\\\n\\\\f\\\\r\\\\\"\\\\'\\\\\\\n+                                 Hello\\\\\n+                                 ,\\\\s\n+                                  Snippet!\n+                             \"\"\"),\n+                new TestCase(\"\"\"\n+                                 <\/pre>\n+                                     <!-- comment -->\n+                                 <b>&trade;<\/b> &#8230; \" '\n+                             \"\"\",\n+                             s -> s.replace(\"&\", \"&amp;\").replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\")),\n+                new TestCase(\"\"\"\n+                                 &lt;\/pre&gt;\n+                                     &lt;!-- comment --&gt;\n+                                 &lt;b&gt;&amp;trade;&lt;\/b&gt; &amp;#8230; \" '\n+                             \"\"\",\n+                             s -> s.replaceAll(\"&\", \"&amp;\"))\n+        );\n+        ClassBuilder classBuilder = new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\");\n+        forEachNumbered(testCases, (t, id) -> {\n+            classBuilder\n+                    .addMembers(\n+                            MethodBuilder\n+                                    .parse(\"public void case%s() { }\".formatted(id))\n+                                    .setComments(\"\"\"\n+                                                 {@snippet file=\"%s.txt\"}\n+                                                 \"\"\".formatted(id)));\n+            addSnippetFile(srcDir, \"pkg\", \"%s.txt\".formatted(id), t.input());\n+        });\n+        classBuilder.write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+        forEachNumbered(testCases, (testCase, index) -> {\n+            String expectedOutput = testCase.expectedTransformation().apply(testCase.input());\n+            checkOutput(\"pkg\/A.html\", true,\n+                        \"\"\"\n+                        <span class=\"element-name\">case%s<\/span>()<\/div>\n+                        <div class=\"block\">\n+                        <pre class=\"snippet\">\n+                        %s<\/pre>\n+                        <\/div>\"\"\".formatted(index, expectedOutput));\n+        });\n+    }\n+\n+    \/\/ TODO:\n+    \/\/   Explore the toolbox.ToolBox.writeFile and toolbox.ToolBox.writeJavaFiles methods:\n+    \/\/   see if any of them could be used instead of this one\n+    private void addSnippetFile(Path srcDir, String packageName, String fileName, String content) throws UncheckedIOException {\n+        String[] components = packageName.split(\"\\\\.\");\n+        Path snippetFiles = Path.of(components[0], Arrays.copyOfRange(components, 1, components.length)).resolve(\"snippet-files\");\n+        try {\n+            Path p = Files.createDirectories(srcDir.resolve(snippetFiles));\n+            Files.writeString(p.resolve(fileName), content, StandardOpenOption.CREATE_NEW);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    @Test\n+    public void testInlineSnippetInDocFiles(Path base) throws IOException {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        \/\/ If there is no *.java files, javadoc will not create an output\n+        \/\/ directory; so this class is created solely to trigger output.\n+        new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\")\n+                .addMembers(\n+                        MethodBuilder\n+                                .parse(\"public void m() { }\")\n+                                \/\/ a (convenience) user entry point to the html file (not used by test)\n+                                .setComments(\"<a href=\\\"doc-files\/file.html\\\">A document<\/a>\"))\n+                .write(srcDir);\n+        var content = \"\"\"\n+                              Unlike Java files, HTML files don't mind hosting\n+                              the *\/ sequence in a @snippet tag\n+                      \"\"\";\n+        String html = \"\"\"\n+                      <!DOCTYPE html>\n+                      <html lang=\"en\">\n+                        <head>\n+                          <meta charset=\"utf-8\">\n+                          <title>title<\/title>\n+                        <\/head>\n+                        <body>\n+                          <!-- yet another user entry point to the html file (not used by test): through an index page -->\n+                          {@index this A document}\n+                          {@snippet :\n+                              %s}\n+                        <\/body>\n+                      <\/html>\n+                      \"\"\".formatted(content);\n+        Path p = Files.createDirectories(srcDir.resolve(\"pkg\").resolve(\"doc-files\"));\n+        Files.writeString(p.resolve(\"file.html\"), html, StandardOpenOption.CREATE_NEW);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+        checkOutput(\"pkg\/doc-files\/file.html\", true, content);\n+    }\n+\n+    @Test\n+    public void testExternalSnippetInDocFiles(Path base) throws IOException {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        \/\/ If there is no *.java files, javadoc will not create an output\n+        \/\/ directory; so this class is created solely to trigger output.\n+        new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\")\n+                .addMembers(\n+                        MethodBuilder\n+                                .parse(\"public void m() { }\")\n+                                \/\/ a (convenience) user entry point to the html file (not used by test)\n+                                .setComments(\"<a href=\\\"doc-files\/file.html\\\">A document<\/a>\"))\n+                .write(srcDir);\n+        String html = \"\"\"\n+                      <!DOCTYPE html>\n+                      <html lang=\"en\">\n+                        <head>\n+                          <meta charset=\"utf-8\">\n+                          <title>title<\/title>\n+                        <\/head>\n+                        <body>\n+                          <!-- yet another user entry point to the html file (not used by test): through an index page -->\n+                          {@index this A document}\n+                          {@snippet file=\"file.txt\"}\n+                        <\/body>\n+                      <\/html>\n+                      \"\"\";\n+        Path p = Files.createDirectories(srcDir.resolve(\"pkg\").resolve(\"doc-files\"));\n+        Files.writeString(p.resolve(\"file.html\"), html, StandardOpenOption.CREATE_NEW);\n+        String content = \"\"\"\n+                            Unlike Java files, text files don't mind hosting\n+                            the *\/ sequence in a @snippet tag\n+                         \"\"\";\n+        addSnippetFile(srcDir, \"pkg\", \"file.txt\", content);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+        checkOutput(\"pkg\/doc-files\/file.html\", true, content);\n+    }\n+\n+    @Test\n+    public void testExternalFileNotFound(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        var fileName = \"text.txt\";\n+        new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\")\n+                .addMembers(\n+                        MethodBuilder\n+                                .parse(\"public void test() { }\")\n+                                .setComments(\"\"\"\n+                                             {@snippet file=\"%s\"}\n+                                             \"\"\".formatted(fileName)))\n+                .write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+        checkOutput(Output.OUT, true,\n+                    \"\"\"\n+                    A.java:4: error: File not found: %s\"\"\".formatted(fileName));\n+        checkNoCrashes();\n+    }\n+\n+    @Test \/\/ TODO perhaps this could be unified with testExternalFile\n+    public void testExternalFileModuleSourcePath(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        var fileName = \"snippet.txt\";\n+        String MODULE_NAME = \"mdl1\";\n+        String PACKAGE_NAME = \"pkg1.pkg2\";\n+        Path moduleDir = new ModuleBuilder(tb, MODULE_NAME)\n+                .exports(PACKAGE_NAME)\n+                .write(srcDir);\n+        new ClassBuilder(tb, String.join(\".\", PACKAGE_NAME, \"A\"))\n+                .setModifiers(\"public\", \"class\")\n+                .addMembers(\n+                        MethodBuilder\n+                                .parse(\"public void test() { }\")\n+                                .setComments(\"\"\"\n+                                             {@snippet file=\"%s\"}\n+                                             \"\"\".formatted(fileName)))\n+                .write(moduleDir);\n+        addSnippetFile(moduleDir, PACKAGE_NAME, fileName, \"content\");\n+        javadoc(\"-d\", outDir.toString(),\n+                \"--module-source-path\", srcDir.toString(),\n+                \"--module\", MODULE_NAME);\n+        checkExit(Exit.OK);\n+    }\n+\n+    @Test \/\/ TODO perhaps this could be unified with testExternalFileNotFound\n+    public void testExternalFileNotFoundModuleSourcePath(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        var fileName = \"text.txt\";\n+        var MODULE_NAME = \"mdl1\";\n+        var PACKAGE_NAME = \"pkg1.pkg2\";\n+        Path moduleDir = new ModuleBuilder(tb, MODULE_NAME)\n+                .exports(PACKAGE_NAME)\n+                .write(srcDir);\n+        new ClassBuilder(tb, String.join(\".\", PACKAGE_NAME, \"A\"))\n+                .setModifiers(\"public\", \"class\")\n+                .addMembers(\n+                        MethodBuilder\n+                                .parse(\"public void test() { }\")\n+                                .setComments(\"\"\"\n+                                             {@snippet file=\"%s\"}\n+                                             \"\"\".formatted(fileName)))\n+                .write(moduleDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"--module-source-path\", srcDir.toString(),\n+                \"--module\", MODULE_NAME);\n+        checkExit(Exit.ERROR);\n+        checkOutput(Output.OUT, true,\n+                    \"\"\"\n+                    A.java:4: error: File not found: %s\"\"\".formatted(fileName));\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testNoContents(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        new ClassBuilder(tb, \"pkg.A\")\n+                .setComments(\"\"\"\n+                             {@snippet}\n+                             \"\"\")\n+                .setModifiers(\"public\", \"class\")\n+                .write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+        checkOutput(Output.OUT, true,\n+                    \"\"\"\n+                    A.java:3: error: @snippet does not specify contents\"\"\");\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testConflict20(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        new ClassBuilder(tb, \"pkg.A\")\n+                .setComments(\"\"\"\n+                             {@snippet file=\"\" class=\"\" :\n+                                 Hello, Snippet!\n+                             }\n+                             \"\"\")\n+                .setModifiers(\"public\", \"class\")\n+                .write(srcDir);\n+\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+        \/\/ TODO\n+        \/\/   In this and all similar tests check that there are no other errors, let alone errors related to {@snippet}\n+        \/\/   To achieve that, we might need to change JavadocTester (i.e. add \"consume output\", \"check that the output is empty\", etc.)\n+        checkOutput(Output.OUT, true,\n+                    \"\"\"\n+                    A.java:3: error: @snippet specifies multiple external contents, which is ambiguous\"\"\");\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testConflict30(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        new ClassBuilder(tb, \"pkg.A\")\n+                .setComments(\"\"\"\n+                             {@snippet class=\"\" file=\"\" :\n+                                 Hello, Snippet!\n+                             }\n+                             \"\"\")\n+                .setModifiers(\"public\", \"class\")\n+                .write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+        checkOutputEither(Output.OUT,\n+                          \"\"\"\n+                          A.java:3: error: @snippet specifies multiple external contents, which is ambiguous\"\"\");\n+        checkNoCrashes();\n+    }\n+\n+    \/\/ TODO: perhaps this method could be added to JavadocTester\n+    private void checkOutputEither(Output out, String first, String... other) {\n+        checking(\"checkOutputEither\");\n+        String output = getOutput(out);\n+        Stream<String> strings = Stream.concat(Stream.of(first), Stream.of(other));\n+        Optional<String> any = strings.filter(output::contains).findAny();\n+        if (any.isPresent()) {\n+            passed(\": following text is found:\\n\" + any.get());\n+        } else {\n+            failed(\": nothing found\");\n+        }\n+    }\n+\n+    @Test\n+    public void testConflict60(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        new ClassBuilder(tb, \"pkg.A\")\n+                .setComments(\"\"\"\n+                             {@snippet file=\"\" file=\"\"}\n+                             \"\"\")\n+                .setModifiers(\"public\", \"class\")\n+                .write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+        checkOutput(Output.OUT, true,\n+                    \"\"\"\n+                    A.java:3: error: repeated attribute: \"file\\\"\"\"\");\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testConflict70(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        new ClassBuilder(tb, \"pkg.A\")\n+                .setComments(\"\"\"\n+                             {@snippet class=\"\" class=\"\" }\n+                             \"\"\")\n+                .setModifiers(\"public\", \"class\")\n+                .write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+        checkOutput(Output.OUT, true,\n+                    \"\"\"\n+                    A.java:3: error: repeated attribute: \"class\\\"\"\"\");\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testConflict80(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        new ClassBuilder(tb, \"pkg.A\")\n+                .setComments(\"\"\"\n+                             {@snippet class=\"\" class=\"\" :\n+                                 Hello, Snippet!\n+                             }\n+                             \"\"\")\n+                .setModifiers(\"public\", \"class\")\n+                .write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+        checkOutputEither(Output.OUT,\n+                          \"\"\"\n+                          A.java:3: error: repeated attribute: \"class\\\"\"\"\",\n+                          \"\"\"\n+                          A.java:3: error: @snippet specifies external and inline contents, which is ambiguous\"\"\");\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testConflict90(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        new ClassBuilder(tb, \"pkg.A\")\n+                .setComments(\"\"\"\n+                             {@snippet file=\"\" file=\"\" :\n+                                 Hello, Snippet!\n+                             }\n+                             \"\"\")\n+                .setModifiers(\"public\", \"class\")\n+                .write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+        checkOutputEither(Output.OUT,\n+                          \"\"\"\n+                          A.java:3: error: repeated attribute: \"file\\\"\"\"\",\n+                          \"\"\"\n+                          A.java:3: error: @snippet specifies external and inline contents, which is ambiguous\"\"\");\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testErrorPositionResolution(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        new ClassBuilder(tb, \"pkg.A\")\n+                .setComments(\"\"\"\n+                             {@snippet} {@snippet}\n+                             \"\"\")\n+                .setModifiers(\"public\", \"class\")\n+                .write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+        checkOutput(Output.OUT, true,\n+                    \"\"\"\n+                    A.java:3: error: @snippet does not specify contents\n+                     * {@snippet} {@snippet}\n+                       ^\n+                    \"\"\",\n+                    \"\"\"\n+                    A.java:3: error: @snippet does not specify contents\n+                     * {@snippet} {@snippet}\n+                                  ^\n+                    \"\"\");\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testRegion(Path base) throws Exception {\n+        record TestCase(Snippet snippet, String expectedOutput) { }\n+        final var testCases = List.of(\n+                new TestCase(newSnippetBuilder()\n+                                     .body(\"\"\"\n+                                           \/\/ @start region=here :\n+                                           Hello\n+                                           ,\n+                                            Snippet!\n+                                           \/\/ @end\n+                                           \"\"\")\n+                                     .region(\"here\")\n+                                     .build(),\n+                             \"\"\"\n+                             Hello\n+                             ,\n+                              Snippet!\n+                             \"\"\"\n+                )\n+                ,\n+                new TestCase(newSnippetBuilder()\n+                                     .body(\"\"\"\n+                                               \/\/ @start region=here :\n+                                               Hello\n+                                               ,\n+                                                Snippet!\n+                                           \/\/ @end\n+                                               \"\"\")\n+                                     .region(\"here\")\n+                                     .build(),\n+                             \"\"\"\n+                                 Hello\n+                                 ,\n+                                  Snippet!\n+                             \"\"\")\n+                ,\n+                new TestCase(newSnippetBuilder()\n+                                     .body(\"\"\"\n+                                               \/\/ @start region=here :\n+                                               Hello\n+                                               ,\n+                                                Snippet!\/\/ @end\n+                                           \"\"\")\n+                                     .region(\"here\")\n+                                     .build(),\n+                             \"\"\"\n+                             Hello\n+                             ,\n+                              Snippet!\\\n+                             \"\"\"\n+                )\n+                ,\n+                new TestCase(newSnippetBuilder()\n+                                     .body(\"\"\"\n+                                           \/\/ @start region=there :\n+                                           \/\/ @end\n+\n+                                               \/\/ @start region=here :\n+                                               Hello\n+                                               ,\n+                                                Snippet!\n+                                               \/\/ @end\n+                                                  \"\"\")\n+                                     .region(\"here\")\n+                                     .build(),\n+                             \"\"\"\n+                             Hello\n+                             ,\n+                              Snippet!\n+                             \"\"\"\n+                )\n+                ,\n+\/\/                entry(newSnippetBuilder()\n+\/\/                              .body(\"\"\"\n+\/\/                                    \/\/ @start region=here :\n+\/\/                                        Hello\n+\/\/                                    \/\/ @end\n+\/\/\n+\/\/                                         , Snippet!\n+\/\/                                    \/\/ @end\n+\/\/                                        \"\"\")\n+\/\/                              .region(\"here\")\n+\/\/                              .build()\n+\/\/                        ,\n+\/\/                      \"\"\"\n+\/\/                          Hello\n+\/\/                      \"\"\"\n+\/\/                )\n+\/\/                ,\n+                new TestCase(newSnippetBuilder()\n+                                     .body(\"\"\"\n+                                           \/\/ @start region=here :\n+                                               This is the only line you should see.\n+                                           \/\/ @end\n+                                           \/\/ @start region=hereafter :\n+                                               You should NOT see this.\n+                                           \/\/ @end\n+                                               \"\"\")\n+                                     .region(\"here\")\n+                                     .build(),\n+                             \"\"\"\n+                                 This is the only line you should see.\n+                             \"\"\"\n+                )\n+                ,\n+                new TestCase(newSnippetBuilder()\n+                                     .body(\"\"\"\n+                                           \/\/ @start region=here :\n+                                               You should NOT see this.\n+                                           \/\/ @end\n+                                           \/\/ @start region=hereafter :\n+                                               This is the only line you should see.\n+                                           \/\/ @end\n+                                               \"\"\")\n+                                     .region(\"hereafter\")\n+                                     .build(),\n+                             \"\"\"\n+                                 This is the only line you should see.\n+                             \"\"\"\n+                )\n+                ,\n+                new TestCase(newSnippetBuilder()\n+                                     .body(\"\"\"\n+                                           \/\/ @start region=beforehand :\n+                                               You should NOT see this.\n+                                           \/\/ @end\n+                                           \/\/ @start region=before :\n+                                               This is the only line you should see.\n+                                           \/\/ @end\n+                                               \"\"\")\n+                                     .region(\"before\")\n+                                     .build(),\n+                             \"\"\"\n+                                 This is the only line you should see.\n+                             \"\"\"\n+                )\n+                ,\n+                new TestCase(newSnippetBuilder()\n+                                     .body(\"\"\"\n+                                           \/\/ @start region=beforehand :\n+                                               This is the only line you should see.\n+                                           \/\/ @end\n+                                           \/\/ @start region=before :\n+                                               You should NOT see this.\n+                                           \/\/ @end\n+                                               \"\"\")\n+                                     .region(\"beforehand\")\n+                                     .build(),\n+                             \"\"\"\n+                                 This is the only line you should see.\n+                             \"\"\"\n+                )\n+        );\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        ClassBuilder classBuilder = new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\");\n+        forEachNumbered(testCases, (t, id) -> {\n+            var snippet = t.snippet();\n+            classBuilder\n+                    .addMembers(\n+                            MethodBuilder\n+                                    .parse(\"public void case%s() { }\".formatted(id))\n+                                    .setComments(\"\"\"\n+                                                 {@snippet region=\"%s\" :\n+                                                 %s}\n+                                                 \"\"\".formatted(snippet.regionName(), snippet.body())));\n+        });\n+        classBuilder.write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+        forEachNumbered(testCases, (t, index) -> {\n+            checkOutput(\"pkg\/A.html\", true,\n+                        \"\"\"\n+                        <span class=\"element-name\">case%s<\/span>()<\/div>\n+                        <div class=\"block\">\n+                        <pre class=\"snippet\">\n+                        %s<\/pre>\n+                        <\/div>\"\"\".formatted(index, t.expectedOutput()));\n+        });\n+    }\n+\n+    private static Snippet.Builder newSnippetBuilder() {\n+        return new Snippet.Builder();\n+    }\n+\n+    private record Snippet(String regionName, String body, String fileContent) {\n+\n+        static class Builder {\n+\n+            private String regionName;\n+            private String body;\n+            private String fileContent;\n+\n+            Builder region(String name) {\n+                this.regionName = name;\n+                return this;\n+            }\n+\n+            Builder body(String content) {\n+                this.body = content;\n+                return this;\n+            }\n+\n+            Builder fileContent(String fileContent) {\n+                this.fileContent = fileContent;\n+                return this;\n+            }\n+\n+            Snippet build() {\n+                return new Snippet(regionName, body, fileContent);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testAttributeValueSyntaxUnquotedCurly(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        \/*\n+         * The snippet region attribute's value is empty because the tag is\n+         * terminated by the first }\n+         *\n+         *    v                v\n+         *    {@snippet region=} :\n+         *        \/\/ @start region=\"}\" @end\n+         *    }\n+         *\/\n+        ClassBuilder classBuilder = new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\")\n+                .addMembers(\n+                        MethodBuilder\n+                                .parse(\"public void case0() { }\")\n+                                .setComments(\"\"\"\n+                                             {@snippet region=} :\n+                                                 \/\/ @start region=\"}\" @end\n+                                             }\n+                                             \"\"\"));\n+        classBuilder.write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+        checkOutput(Output.OUT, true,\n+                    \"\"\"\n+                    A.java:4: error: @snippet does not specify contents\"\"\");\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testAttributeValueSyntaxCurly(Path base) throws Exception {\n+        \/*\n+         * The snippet has to be external, otherwise its content would\n+         * interfere with the test: that internal closing curly would\n+         * terminate the @snippet tag:\n+         *\n+         *     v\n+         *     {@snippet region=\"}\" :\n+         *         \/\/ @start region=\"}\" @end\n+         *                           ^\n+         *     }\n+         *\/\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        addSnippetFile(srcDir, \"pkg\", \"file.txt\", \"\"\"\n+                                                  \/\/ @start region=\"}\" @end\n+                                                  \"\"\"\n+        );\n+        ClassBuilder classBuilder = new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\")\n+                .addMembers(\n+                        MethodBuilder\n+                                .parse(\"public void case0() { }\")\n+                                .setComments(\"\"\"\n+                                             {@snippet region=\"}\" file=\"file.txt\"}\n+                                             \"\"\"))\n+                .addMembers(\n+                        MethodBuilder\n+                                .parse(\"public void case1() { }\")\n+                                .setComments(\"\"\"\n+                                             {@snippet region='}' file=\"file.txt\"}\n+                                             \"\"\"));\n+        classBuilder.write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+        checkOutput(\"pkg\/A.html\", true,\n+                    \"\"\"\n+                    <span class=\"element-name\">case0<\/span>()<\/div>\n+                    <div class=\"block\">\n+                    <pre class=\"snippet\">\n+                    <\/pre>\n+                    <\/div>\"\"\");\n+        checkOutput(\"pkg\/A.html\", true,\n+                    \"\"\"\n+                    <span class=\"element-name\">case1<\/span>()<\/div>\n+                    <div class=\"block\">\n+                    <pre class=\"snippet\">\n+                    <\/pre>\n+                    <\/div>\"\"\");\n+    }\n+\n+    @Test\n+    public void testAttributeValueSyntax(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        \/\/ Test most expected use cases for external snippet\n+        final var snippets = List.of(\n+                \"\"\"\n+                {@snippet file=file region=region}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet file=file region= region}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet file=file region=\"region\"}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet file=file region='region'}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet file= file region=region}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet file= file region= region}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet file= file region=\"region\"}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet file= file region='region'}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet file=\"file\" region=region}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet file=\"file\" region= region}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet file=\"file\" region=\"region\"}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet file=\"file\" region='region'}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet file='file' region=region}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet file='file' region= region}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet file='file' region=\"region\"}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet file='file' region='region'}\n+                \"\"\",\n+                \/\/ ---------------------------------------------------------------\n+                \"\"\"\n+                {@snippet region=region file=file}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet region=region file=\"file\"}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet region=\"region\" file=\"file\"}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet file=\"file\"\n+                          region=\"region\"}\n+                \"\"\",\n+                \"\"\"\n+                {@snippet file=\"file\"\n+                          region=region}\n+                \"\"\"\n+        );\n+        addSnippetFile(srcDir, \"pkg\", \"file\", \"\"\"\n+                                              1 \/\/ @start region=bar @end\n+                                              2 \/\/ @start region=region @end\n+                                              3 \/\/ @start region=foo @end\n+                                              \"\"\");\n+        ClassBuilder classBuilder = new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\");\n+        forEachNumbered(snippets, (s, i) -> {\n+            classBuilder.addMembers(\n+                    MethodBuilder.parse(\"public void case%s() { }\".formatted(i)).setComments(s));\n+        });\n+        classBuilder.write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+        for (int j = 0; j < snippets.size(); j++) {\n+            checkOutput(\"pkg\/A.html\", true,\n+                        \"\"\"\n+                        <span class=\"element-name\">case%s<\/span>()<\/div>\n+                        <div class=\"block\">\n+                        <pre class=\"snippet\">\n+                        2<\/pre>\n+                        <\/div>\n+                        \"\"\".formatted(j));\n+        }\n+    }\n+\n+    @Test\n+    public void testComment(Path base) throws Exception {\n+        record TestCase(Snippet snippet, String expectedOutput) { }\n+        final var testCases = List.of(\n+                new TestCase(newSnippetBuilder()\n+                                     .body(\"\"\"\n+                                           \/\/ \/\/ @replace substring=\"\/\/\" replacement=\"Hello\"\n+                                           ,\n+                                            Snippet!\"\"\")\n+                                     .build(),\n+                             \"\"\"\n+                             Hello\n+                             ,\n+                              Snippet!\"\"\"\n+                )\n+                ,\n+                new TestCase(newSnippetBuilder()\n+                                     .body(\"\"\"\n+                                           \/\/             \/\/ @replace substring=\"\/\/\" replacement=\"Hello\"\n+                                           ,\n+                                            Snippet!\"\"\")\n+                                     .build(),\n+                             \"\"\"\n+                             Hello\n+                             ,\n+                              Snippet!\"\"\"\n+                )\n+                ,\n+                new TestCase(newSnippetBuilder()\n+                                     .body(\"\"\"\n+                                           \/\/ \/\/ @replace substring=\"\/\/\" replacement=\" Hello\"\n+                                           ,\n+                                            Snippet!\"\"\")\n+                                     .build(),\n+                             \"\"\"\n+                              Hello\n+                             ,\n+                              Snippet!\"\"\"\n+                )\n+\/\/ Uncomment when parser has improved (this would allow to write meta snippets,\n+\/\/ i.e. snippets showing how to write snippets.\n+\/\/\n+\/\/                ,\n+\/\/                entry(newSnippetBuilder()\n+\/\/                              .body(\"\"\"\n+\/\/                                    \/\/ snippet-comment : \/\/ snippet-comment : my comment\"\"\")\n+\/\/                              .build(),\n+\/\/                      \"\"\"\n+\/\/                      \/\/ snippet-comment : my comment\"\"\"\n+\/\/                )\n+        );\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        ClassBuilder classBuilder = new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\");\n+        forEachNumbered(testCases, (t, id) -> {\n+            classBuilder\n+                    .addMembers(\n+                            MethodBuilder\n+                                    .parse(\"public void case%s() { }\".formatted(id))\n+                                    .setComments(\"\"\"\n+                                                 {@snippet :\n+                                                 %s}\n+                                                 \"\"\".formatted(t.snippet().body())));\n+        });\n+        classBuilder.write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+        forEachNumbered(testCases, (t, index) -> {\n+            checkOutput(\"pkg\/A.html\", true,\n+                        \"\"\"\n+                        <span class=\"element-name\">case%s<\/span>()<\/div>\n+                        <div class=\"block\">\n+                        <pre class=\"snippet\">\n+                        %s<\/pre>\n+                        <\/div>\"\"\".formatted(index, t.expectedOutput()));\n+        });\n+    }\n+\n+    @Test\n+    public void testRedundantFileNotFound(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        var fileName = \"text.txt\";\n+        new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\")\n+                .addMembers(\n+                        MethodBuilder\n+                                .parse(\"public void test() { }\")\n+                                .setComments(\"\"\"\n+                                             {@snippet file=\"%s\":\n+                                                 Hello, Snippet!}\n+                                             \"\"\".formatted(fileName)))\n+                .write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+        checkOutput(Output.OUT, true,\n+                    \"\"\"\n+                    A.java:4: error: File not found: %s\"\"\".formatted(fileName));\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testRedundantRegionNotFound(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        var fileName = \"text.txt\";\n+        var region = \"here\";\n+        var content =\n+                \"\"\"\n+                Hello, Snippet!\"\"\";\n+\n+        new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\")\n+                .addMembers(\n+                        MethodBuilder\n+                                .parse(\"public void test() { }\")\n+                                .setComments(\"\"\"\n+                                             {@snippet region=\"%s\" file=\"%s\":\n+                                             %s}\n+                                             \"\"\".formatted(region, fileName, content)))\n+                .write(srcDir);\n+        addSnippetFile(srcDir, \"pkg\", fileName, content);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+        checkOutput(Output.OUT, true,\n+                    \"\"\"\n+                    A.java:4: error: region not found: \"%s\\\"\"\"\".formatted(region));\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testRedundantMismatch(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        var fileName = \"text.txt\";\n+        var content =\n+                \"\"\"\n+                Hello, Snippet!\"\"\";\n+        new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\")\n+                .addMembers(\n+                        MethodBuilder\n+                                .parse(\"public void test() { }\")\n+                                .setComments(\"\"\"\n+                                             {@snippet file=\"%s\":\n+                                             %s}\n+                                             \"\"\".formatted(fileName, content)))\n+                .write(srcDir);\n+        addSnippetFile(srcDir, \"pkg\", fileName, content + \"...more\");\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+        checkOutput(Output.OUT, true,\n+                    \"\"\"\n+                    A.java:4: error: contents mismatch\"\"\");\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testRedundantRegionRegionMismatch(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        var fileName = \"text.txt\";\n+        var region = \"here\";\n+        var content =\n+                \"\"\"\n+                Hello, Snippet!\"\"\";\n+        new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\")\n+                .addMembers(\n+                        MethodBuilder\n+                                .parse(\"public void test() { }\")\n+                                .setComments(\"\"\"\n+                                             {@snippet region=\"%s\" file=\"%s\":\n+                                             Above the region.\n+                                             \/\/ @start region=\"%s\" :\n+                                             %s ...more\n+                                             \/\/ @end\n+                                             Below the region}\n+                                             \"\"\".formatted(region, fileName, region, content)))\n+                .write(srcDir);\n+        addSnippetFile(srcDir, \"pkg\", fileName,\n+                       \"\"\"\n+                       This line is above the region.\n+                       \/\/ @start region=\"%s\" :\n+                       %s\n+                       \/\/ @end\n+                       This line is below the region.\"\"\".formatted(region, content));\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+        checkOutput(Output.OUT, true,\n+                    \"\"\"\n+                    A.java:4: error: contents mismatch\"\"\");\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testRedundantRegion1Mismatch(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        var fileName = \"text.txt\";\n+        var region = \"here\";\n+        var content =\n+                \"\"\"\n+                Hello, Snippet!\"\"\";\n+        new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\")\n+                .addMembers(\n+                        MethodBuilder\n+                                .parse(\"public void test() { }\")\n+                                .setComments(\"\"\"\n+                                             {@snippet region=\"%s\" file=\"%s\":\n+                                             Above the region.\n+                                             \/\/ @start region=\"%s\" :\n+                                             %s ...more\n+                                             \/\/ @end\n+                                             Below the region}\n+                                             \"\"\".formatted(region, fileName, region, content)))\n+                .write(srcDir);\n+        addSnippetFile(srcDir, \"pkg\", fileName, content);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+        checkOutput(Output.OUT, true,\n+                    \"\"\"\n+                    A.java:4: error: contents mismatch\"\"\");\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testRedundantRegion2Mismatch(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        var fileName = \"text.txt\";\n+        var region = \"here\";\n+        var content =\n+                \"\"\"\n+                Hello, Snippet!\"\"\";\n+        new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\")\n+                .addMembers(\n+                        MethodBuilder\n+                                .parse(\"public void test() { }\")\n+                                .setComments(\"\"\"\n+                                             {@snippet region=\"%s\" file=\"%s\":\n+                                             %s}\n+                                             \"\"\".formatted(region, fileName, content)))\n+                .write(srcDir);\n+        addSnippetFile(srcDir, \"pkg\", fileName,\n+                       \"\"\"\n+                       Above the region.\n+                       \/\/ @start region=\"%s\" :\n+                       %s ...more\n+                       \/\/ @end\n+                       Below the region\n+                       \"\"\".formatted(region, content));\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+        checkOutput(Output.OUT, true,\n+                    \"\"\"\n+                    A.java:4: error: contents mismatch\"\"\");\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testRedundant(Path base) throws Exception {\n+        record TestCase(Snippet snippet, String expectedOutput) { }\n+        final var testCases = List.of(\n+                new TestCase(newSnippetBuilder()\n+                                     .body(\"\"\"\n+                                           Hello\n+                                           ,\n+                                            Snippet!\"\"\")\n+                                     .fileContent(\n+                                             \"\"\"\n+                                             Hello\n+                                             ,\n+                                              Snippet!\"\"\")\n+                                     .build(),\n+                             \"\"\"\n+                             Hello\n+                             ,\n+                              Snippet!\"\"\"\n+                )\n+                ,\n+                new TestCase(newSnippetBuilder()\n+                                     .body(\"\"\"\n+                                             Hello\n+                                             ,\n+                                              Snippet!\n+                                           \"\"\")\n+                                     .region(\"here\")\n+                                     .fileContent(\n+                                             \"\"\"\n+                                             Above the region.\n+                                             \/\/ @start region=here :\n+                                               Hello\n+                                               ,\n+                                                Snippet!\n+                                             \/\/ @end\n+                                             Below the region.\n+                                             \"\"\")\n+                                     .build(),\n+                             \"\"\"\n+                               Hello\n+                               ,\n+                                Snippet!\n+                             \"\"\"\n+                )\n+                ,\n+                new TestCase(newSnippetBuilder()\n+                                     .body(\"\"\"\n+                                           Above the region.\n+                                           \/\/ @start region=here :\n+                                             Hello\n+                                             ,\n+                                              Snippet!\n+                                           \/\/ @end\n+                                           Below the region.\n+                                           \"\"\")\n+                                     .region(\"here\")\n+                                     .fileContent(\n+                                             \"\"\"\n+                                               Hello\n+                                               ,\n+                                                Snippet!\n+                                             \"\"\")\n+                                     .build(),\n+                             \"\"\"\n+                               Hello\n+                               ,\n+                                Snippet!\n+                             \"\"\"\n+                )\n+                ,\n+                new TestCase(newSnippetBuilder()\n+                                     .body(\"\"\"\n+                                           Above the region.\n+                                           \/\/ @start region=here :\n+                                             Hello\n+                                             ,\n+                                              Snippet!\n+                                           \/\/ @end\n+                                           Below the region.\n+                                           \"\"\")\n+                                     .region(\"here\")\n+                                     .fileContent(\n+                                             \"\"\"\n+                                             Above the region.\n+                                             \/\/ @start region=here :\n+                                               Hello\n+                                               ,\n+                                                Snippet!\n+                                             \/\/ @end\n+                                             Below the region.\n+                                             \"\"\")\n+                                     .build(),\n+                             \"\"\"\n+                               Hello\n+                               ,\n+                                Snippet!\n+                             \"\"\"\n+                )\n+        );\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        ClassBuilder classBuilder = new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\");\n+        forEachNumbered(testCases, (t, id) -> {\n+            var snippet = t.snippet();\n+            final String r = snippet.regionName() == null ? \"\" : \"region=\\\"\" + snippet.regionName() + \"\\\"\";\n+            final String f = snippet.fileContent() == null ? \"\" : \"file=\\\"%s.txt\\\"\".formatted(id);\n+            classBuilder\n+                    .addMembers(\n+                            MethodBuilder\n+                                    .parse(\"public void case%s() { }\".formatted(id))\n+                                    .setComments(\"\"\"\n+                                                 {@snippet %s %s:\n+                                                 %s}\n+                                                 \"\"\".formatted(r, f, snippet.body())));\n+            addSnippetFile(srcDir, \"pkg\", \"%s.txt\".formatted(id), snippet.fileContent());\n+        });\n+        classBuilder.write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+        forEachNumbered(testCases, (t, index) -> {\n+            checkOutput(\"pkg\/A.html\", true,\n+                        \"\"\"\n+                        <span class=\"element-name\">case%s<\/span>()<\/div>\n+                        <div class=\"block\">\n+                        <pre class=\"snippet\">\n+                        %s<\/pre>\n+                        <\/div>\"\"\".formatted(index, t.expectedOutput()));\n+        });\n+    }\n+\n+    @Test\n+    public void testInvalidRegexDiagnostics(Path base) throws Exception {\n+\n+        record TestCase(String input, String expectedError) { }\n+\n+        \/\/ WARNING: debugging these test cases by reading .jtr files might prove\n+        \/\/ confusing. This is because of how jtharness, which is used by jtreg,\n+        \/\/ represents special symbols it encounters in standard streams. While\n+        \/\/ CR, LR and TAB are output as they are, \\ is output as \\\\ and the rest\n+        \/\/ of the escape sequences are output using the \\\\uxxxx notation. This\n+        \/\/ might affect relative symbol positioning on adjacent lines. For\n+        \/\/ example, it might be hard to judge the true (i.e. console) position\n+        \/\/ of the caret. Try using -show:System.out jtreg option to remediate\n+        \/\/ that.\n+\n+        final var testCases = List.of(\n+                new TestCase(\"\"\"\n+{@snippet :\n+hello there \/\/   @highlight   regex =\"\\t**\"\n+}\"\"\",\n+                             \"\"\"\n+error: snippet markup: invalid regex\n+hello there \/\/   @highlight   regex =\"\\t**\"\n+                                      \\t ^\n+\"\"\"),\n+                new TestCase(\"\"\"\n+{@snippet :\n+hello there \/\/   @highlight   regex =\"\\\\t**\"\n+}\"\"\",\n+                        \"\"\"\n+error: snippet markup: invalid regex\n+hello there \/\/   @highlight   regex =\"\\\\t**\"\n+                                         ^\n+\"\"\"),\n+                new TestCase(\"\"\"\n+{@snippet :\n+hello there \/\/ @highlight regex=\"\\\\.\\\\*\\\\+\\\\E\"\n+}\"\"\",\n+                             \"\"\"\n+error: snippet markup: invalid regex\n+hello there \/\/ @highlight regex=\"\\\\.\\\\*\\\\+\\\\E\"\n+                                 \\s\\s\\s\\s   ^\n+\"\"\"), \/\/ use \\s to counteract shift introduced by \\\\ so as to visually align ^ right below E\n+                new TestCase(\"\"\"\n+{@snippet :\n+hello there \/\/   @highlight  type=\"italics\" regex =\"  [\"\n+}\"\"\",\n+                        \"\"\"\n+error: snippet markup: invalid regex\n+hello there \/\/   @highlight  type=\"italics\" regex =\"  [\"\n+                                                      ^\n+\"\"\")\n+                );\n+\n+        List<String> inputs = testCases.stream().map(s -> s.input).toList();\n+        StringBuilder methods = new StringBuilder();\n+        forEachNumbered(inputs, (i, n) -> {\n+            methods.append(\n+                    \"\"\"\n+\n+                    \/**\n+                    %s*\/\n+                    public void case%s() {}\n+                    \"\"\".formatted(i, n));\n+        });\n+\n+        String classString =\n+                \"\"\"\n+                public class A {\n+                %s\n+                }\n+                \"\"\".formatted(methods.toString());\n+\n+        Path src = Files.createDirectories(base.resolve(\"src\"));\n+        tb.writeJavaFiles(src, classString);\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                src.resolve(\"A.java\").toString());\n+        checkExit(Exit.ERROR);\n+        checkOrder(Output.OUT, testCases.stream().map(TestCase::expectedError).toArray(String[]::new));\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testErrorMessages(Path base) throws Exception {\n+\n+        record TestCase(String input, String expectedError) { }\n+\n+        final var testCases = List.of(\n+                new TestCase(\"\"\"\n+{@snippet :\n+    hello \/\/ @link\n+}\"\"\",\n+                             \"\"\"\n+error: snippet markup: missing attribute \"target\"\n+    hello \/\/ @link\n+              ^\n+                             \"\"\"),\n+                new TestCase(\"\"\"\n+{@snippet :\n+    hello \/\/ @start\n+}\"\"\",\n+                             \"\"\"\n+error: snippet markup: missing attribute \"region\"\n+    hello \/\/ @start\n+              ^\n+                             \"\"\"),\n+                new TestCase(\"\"\"\n+{@snippet :\n+    hello \/\/ @replace\n+}\"\"\",\n+                             \"\"\"\n+error: snippet markup: missing attribute \"replacement\"\n+    hello \/\/ @replace\n+              ^\n+                             \"\"\"),\n+                \/* ---------------------- *\/\n+                new TestCase(\"\"\"\n+{@snippet :\n+    hello \/\/ @highlight regex=\\\\w+ substring=hello\n+}\"\"\",\n+                        \"\"\"\n+error: snippet markup: attributes \"substring\" and \"regex\" used simultaneously\n+    hello \/\/ @highlight regex=\\\\w+ substring=hello\n+                                  ^\n+                        \"\"\"),\n+                new TestCase(\"\"\"\n+{@snippet :\n+    hello \/\/ @start region=\"x\" name=\"here\"\n+}\"\"\",\n+                        \"\"\"\n+error: snippet markup: unexpected attribute\n+    hello \/\/ @start region=\"x\" name=\"here\"\n+                               ^\n+                        \"\"\"),\n+                new TestCase(\"\"\"\n+{@snippet :\n+    hello \/\/ @start region=\"\"\n+}\"\"\",\n+                        \"\"\"\n+error: snippet markup: invalid attribute value\n+    hello \/\/ @start region=\"\"\n+                            ^\n+                        \"\"\"),\n+                new TestCase(\"\"\"\n+{@snippet :\n+    hello \/\/ @link target=\"Object#equals()\" type=fluffy\n+}\"\"\",\n+                        \"\"\"\n+error: snippet markup: invalid attribute value\n+    hello \/\/ @link target=\"Object#equals()\" type=fluffy\n+                                                 ^\n+                        \"\"\"),\n+                \/* ---------------------- *\/\n+                new TestCase(\"\"\"\n+{@snippet :\n+    hello \/\/ @highlight substring=\"\n+}\"\"\",\n+                             \"\"\"\n+error: snippet markup: unterminated attribute value\n+    hello \/\/ @highlight substring=\"\n+                                  ^\n+                             \"\"\"),\n+                new TestCase(\"\"\"\n+{@snippet :\n+    hello \/\/ @start region=\"this\"\n+    world \/\/ @start region=\"this\"\n+    !     \/\/ @end\n+}\"\"\",\n+                        \"\"\"\n+error: snippet markup: duplicated region\n+    world \/\/ @start region=\"this\"\n+                            ^\n+                        \"\"\"),\n+                new TestCase(\"\"\"\n+{@snippet :\n+    hello \/\/ @end\n+}\"\"\",\n+                        \"\"\"\n+error: snippet markup: no region to end\n+    hello \/\/ @end\n+              ^\n+                        \"\"\"),\n+                new TestCase(\"\"\"\n+{@snippet :\n+    hello \/\/ @start region=this\n+}\"\"\",\n+                        \"\"\"\n+error: snippet markup: unpaired region\n+    hello \/\/ @start region=this\n+              ^\n+                        \"\"\"),\n+                new TestCase(\"\"\"\n+{@snippet :\n+    hello \/\/ @highlight substring=\"hello\" :\n+}\"\"\",\n+                             \"\"\"\n+error: snippet markup: tag refers to non-existent lines\n+    hello \/\/ @highlight substring=\"hello\" :\n+              ^\n+              \"\"\")\n+        );\n+        List<String> inputs = testCases.stream().map(s -> s.input).toList();\n+        StringBuilder methods = new StringBuilder();\n+        forEachNumbered(inputs, (i, n) -> {\n+            methods.append(\n+                    \"\"\"\n+\n+                    \/**\n+                    %s*\/\n+                    public void case%s() {}\n+                    \"\"\".formatted(i, n));\n+        });\n+\n+        String classString =\n+                \"\"\"\n+                public class A {\n+                %s\n+                }\n+                \"\"\".formatted(methods.toString());\n+\n+        Path src = Files.createDirectories(base.resolve(\"src\"));\n+        tb.writeJavaFiles(src, classString);\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                src.resolve(\"A.java\").toString());\n+        checkExit(Exit.ERROR);\n+        \/\/ use the facility from JDK-8273154 when it becomes available\n+        checkOutput(Output.OUT, true, testCases.stream().map(TestCase::expectedError).toArray(String[]::new));\n+        checkNoCrashes();\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSnippetTag\/TestSnippetTag.java","additions":2380,"deletions":0,"binary":false,"changes":2380,"status":"added"},{"patch":"@@ -23,0 +23,1 @@\n+          {@snippet}: ..... overview module package type constructor method field inline ........\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testTaglets\/TestTaglets.out","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-        if (values.length != 3)\n+        if (values.length != 4)\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/api\/basic\/DocumentationToolLocationTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,0 +108,7 @@\n+            case \"SnippetTree\" ->\n+                    test(d, type, \"\"\"\n+                            {@snippet :\n+                                abc\n+                            }\n+                            \"\"\");\n+\n","filename":"test\/langtools\/tools\/doclint\/EmptyHtmlTest.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -590,0 +590,12 @@\n+            @Override\n+            public Void visitSnippet(SnippetTree node, Void p) {\n+                header(node);\n+                indent(+1);\n+                print(\"attributes\", node.getAttributes());\n+                print(\"body\", node.getBody());\n+                indent(-1);\n+                indent();\n+                out.println(\"]\");\n+                return null;\n+            }\n+\n","filename":"test\/langtools\/tools\/javac\/doctree\/DocCommentTester.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8201533\n+ * @summary Implementation for snippets\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.file\n+ *          jdk.compiler\/com.sun.tools.javac.tree\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build DocCommentTester\n+ * @run main DocCommentTester SnippetTest.java\n+ *\/\n+\n+class SnippetTest {\n+    \/**\n+     * {@snippet attr1=\"val1\" :\n+     *     Hello, Snippet!\n+     * }\n+     *\/\n+    void inline() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:1\n+  firstSentence: 1\n+    Snippet[SNIPPET, pos:1\n+      attributes: 1\n+        Attribute[ATTRIBUTE, pos:11\n+          name: attr1\n+          vkind: DOUBLE\n+          value: 1\n+            Text[TEXT, pos:18, val1]\n+        ]\n+      body:\n+        Text[TEXT, pos:26, _____Hello,_Snippet!|_]\n+    ]\n+  body: empty\n+  block tags: empty\n+]\n+*\/\n+}\n","filename":"test\/langtools\/tools\/javac\/doctree\/SnippetTest.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"}]}