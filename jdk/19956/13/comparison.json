{"files":[{"patch":"@@ -4481,1 +4481,1 @@\n-        return new Formatter().format(format, args).toString();\n+        return StringFormat.format(format, args);\n@@ -4543,1 +4543,1 @@\n-        return new Formatter().format(this, args).toString();\n+        return StringFormat.format(this, args);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,353 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang;\n+\n+import java.text.DecimalFormatSymbols;\n+import java.util.Formatter;\n+import java.util.Locale;\n+\n+import jdk.internal.util.HexDigits;\n+\n+\/**\n+ * Utility class for string format fastpath\n+ *\/\n+final class StringFormat {\n+    private static final char DECIMAL_INTEGER           = 'd';\n+    private static final char HEXADECIMAL_INTEGER       = 'x';\n+    private static final char HEXADECIMAL_INTEGER_UPPER = 'X';\n+    private static final char STRING                    = 's';\n+\n+    static String format(String format, Object... args) {\n+        if (args != null && args.length <= 2) {\n+            int off = format.indexOf('%');\n+            if (off == -1) {\n+                return format;\n+            }\n+\n+            int len = format.length();\n+            if (off + 1 != len) {\n+                int off1 = format.indexOf('%', off + 2);\n+                String s = null;\n+                if (args.length == 1) {\n+                    if (off1 == -1) {\n+                        s = format1(format, off, args[0]);\n+                    }\n+                } else if (args.length == 2) {\n+                    if (off1 != -1 && off1 + 1 != len) {\n+                        s = format2(format, off, off1, args[0], args[1]);\n+                    }\n+                }\n+                if (s != null) {\n+                    return s;\n+                }\n+            }\n+        }\n+\n+        return new Formatter().format(format, args).toString();\n+    }\n+\n+    private static String format1(String format, int off, Object arg) {\n+        int len = format.length();\n+        char conv = format.charAt(off + 1);\n+        int width = 0;\n+        if (conv >= '1' && conv <= '9') {\n+            width = conv - '0';\n+            if (off + 2 < len) {\n+                conv = format.charAt(off + 2);\n+            }\n+        }\n+\n+        byte coder = format.coder();\n+        if (conv == STRING) {\n+            if (isLong(arg)) {\n+                conv = DECIMAL_INTEGER;\n+            } else {\n+                String str = String.valueOf(arg);\n+                coder |= str.coder();\n+                arg = str;\n+            }\n+        }\n+\n+        int size = stringSize(conv, arg);\n+        if (size == -1) {\n+            return null;\n+        }\n+        return format1(format, coder, off, conv, arg, width, size);\n+    }\n+\n+    private static String format2(String format, int off0, int off1, Object arg0, Object arg1) {\n+        final int len = format.length();\n+        char conv0 = format.charAt(off0 + 1);\n+        int width0 = 0;\n+        if (conv0 >= '1' && conv0 <= '9') {\n+            width0 = conv0 - '0';\n+            if (off0 + 2 < len) {\n+                conv0 = format.charAt(off0 + 2);\n+            }\n+        }\n+\n+        char conv1 = format.charAt(off1 + 1);\n+        int width1 = 0;\n+        if (conv1 >= '1' && conv1 <= '9') {\n+            width1 = conv1 - '0';\n+            if (off1 + 2 < len) {\n+                conv1 = format.charAt(off1 + 2);\n+            }\n+        }\n+\n+        if (off1 + 2 < len) {\n+            if (format.indexOf('%', off1 + 2) != -1) {\n+                return null;\n+            }\n+        }\n+\n+        String str;\n+        byte coder = format.coder();\n+        if (conv0 == STRING) {\n+            if (isLong(arg0)) {\n+                conv0 = DECIMAL_INTEGER;\n+            } else {\n+                str = String.valueOf(arg0);\n+                coder |= str.coder();\n+                arg0 = str;\n+            }\n+        }\n+\n+        if (conv1 == STRING) {\n+            if (isLong(arg1)) {\n+                conv1 = DECIMAL_INTEGER;\n+            } else {\n+                str = String.valueOf(arg1);\n+                coder |= str.coder();\n+                arg1 = str;\n+            }\n+        }\n+\n+        int size0 = stringSize(conv0, arg0);\n+        if (size0 == -1) {\n+            return null;\n+        }\n+        int size1 = stringSize(conv1, arg1);\n+        if (size1 == -1) {\n+            return null;\n+        }\n+\n+        int specifierSize0 = 2 + (width0 != 0 ? 1 : 0);\n+        int specifierSize1 = 2 + (width1 != 0 ? 1 : 0);\n+\n+        int strlen = len\n+                + Math.max(width0, size0)\n+                + Math.max(width1, size1)\n+                - specifierSize0\n+                - specifierSize1;\n+        return coder == String.LATIN1\n+                ? format2Latin1(format, strlen, off0, conv0, arg0, width0, size0, specifierSize0,\n+                                                off1, conv1, arg1, width1, size1, specifierSize1)\n+                : format2UTF16( format, strlen, off0, conv0, arg0, width0, size0, specifierSize0,\n+                                                off1, conv1, arg1, width1, size1, specifierSize1);\n+    }\n+\n+    private static int stringSize(char conv, Object arg) {\n+        int size = -1;\n+        if (isLong(arg)) {\n+            long longValue = ((Number) arg).longValue();\n+            if (conv == DECIMAL_INTEGER) {\n+                if (defaultLocaleDecimalSupport()) {\n+                    size = Long.stringSize(longValue);\n+                }\n+            } else if (conv == HEXADECIMAL_INTEGER || conv == HEXADECIMAL_INTEGER_UPPER) {\n+                size = HexDigits.stringSize(longValue);\n+            }\n+        } else if (conv == STRING && arg instanceof String) {\n+            size = ((String) arg).length();\n+        }\n+        return size;\n+    }\n+\n+    private static boolean isLong(Object arg) {\n+        return arg instanceof Long\n+            || arg instanceof Integer\n+            || arg instanceof Short\n+            || arg instanceof Byte;\n+    }\n+\n+    private static String format1(String format, byte coder, int off, char conv, Object arg, int width, int size) {\n+        int specifierSize = 2 + (width != 0 ? 1 : 0);\n+        int strlen = format.length() + Math.max(width, size) - specifierSize;\n+        byte[] bytes = new byte[strlen << coder];\n+        if (off > 0) {\n+            format.getBytes(bytes, 0, 0, coder, off);\n+        }\n+\n+        int index = coder == String.LATIN1\n+                ? getCharsLatin1(bytes, off, arg, conv, width, size)\n+                : getCharsUTF16(bytes, off, arg, conv, width, size);\n+\n+        int rest = format.length() - off - specifierSize;\n+        if (rest > 0) {\n+            format.getBytes(bytes, off + specifierSize, index, coder, rest);\n+        }\n+        return new String(bytes, coder);\n+    }\n+\n+    private static String format2Latin1(\n+            String format, int strlen,\n+            int off0, char conv0, Object arg0, int width0, int size0, int specifierSize0,\n+            int off1, char conv1, Object arg1, int width1, int size1, int specifierSize1\n+    ) {\n+        byte[] bytes = new byte[strlen];\n+        if (off0 > 0) {\n+            format.getBytes(bytes, 0, 0, String.LATIN1, off0);\n+        }\n+\n+        int index = getCharsLatin1(bytes, off0, arg0, conv0, width0, size0);\n+\n+        int middle = off1 - off0 - specifierSize0;\n+        if (middle > 0) {\n+            format.getBytes(bytes, off0 + specifierSize0, index, String.LATIN1, middle);\n+            index += middle;\n+        }\n+\n+        index = getCharsLatin1(bytes, index, arg1, conv1, width1, size1);\n+\n+        int rest = format.length() - off1 - specifierSize1;\n+        if (rest > 0) {\n+            format.getBytes(bytes, off1 + specifierSize1, index, String.LATIN1, rest);\n+        }\n+        return new String(bytes, String.LATIN1);\n+    }\n+\n+    private static String format2UTF16(\n+            String format, int strlen,\n+            int off0, char conv0, Object arg0, int width0, int size0, int specifierSize0,\n+            int off1, char conv1, Object arg1, int width1, int size1, int specifierSize1\n+    ) {\n+        byte coder = String.UTF16;\n+        byte[] bytes = new byte[strlen << coder];\n+        if (off0 > 0) {\n+            format.getBytes(bytes, 0, 0, coder, off0);\n+        }\n+\n+        int index = getCharsUTF16(bytes, off0, arg0, conv0, width0, size0);\n+\n+        int middle = off1 - off0 - specifierSize0;\n+        if (middle > 0) {\n+            format.getBytes(bytes, off0 + specifierSize0, index, coder, middle);\n+            index += middle;\n+        }\n+\n+        index = getCharsUTF16(bytes, index, arg1, conv1, width1, size1);\n+\n+        int rest = format.length() - off1 - specifierSize1;\n+        if (rest > 0) {\n+            format.getBytes(bytes, off1 + specifierSize1, index, coder, rest);\n+        }\n+        return new String(bytes, coder);\n+    }\n+\n+    private static int getCharsLatin1(byte[] bytes, int index, Object arg, char conv, int width, int size) {\n+        int pad = width - size;\n+        if (pad > 0) {\n+            for (int i = 0; i < pad; i++) {\n+                bytes[index + i] = ' ';\n+            }\n+            index += pad;\n+        }\n+\n+        if (conv == STRING) {\n+            String str = (String) arg;\n+            str.getBytes(bytes, index, String.LATIN1);\n+            return index + size;\n+        }\n+\n+        long value = ((Number) arg).longValue();\n+        index += size;\n+        if (conv == HEXADECIMAL_INTEGER) {\n+            HexDigits.getCharsLatin1(value, index, bytes);\n+        } else if (conv == HEXADECIMAL_INTEGER_UPPER) {\n+            HexDigits.getCharsLatin1(value, index, bytes, true);\n+        } else {\n+            StringLatin1.getChars(value, index, bytes);\n+        }\n+        return index;\n+    }\n+\n+    private static int getCharsUTF16(byte[] bytes, int index, Object arg, char conv, int width, int size) {\n+        int pad = width - size;\n+        if (pad > 0) {\n+            for (int i = 0; i < pad; i++) {\n+                StringUTF16.putChar(bytes, index + i, ' ');\n+            }\n+            index += pad;\n+        }\n+\n+        if (conv == STRING) {\n+            String str = (String) arg;\n+            str.getBytes(bytes, index, String.UTF16);\n+            return index + size;\n+        }\n+\n+        long value = ((Number) arg).longValue();\n+        index += size;\n+        if (conv == HEXADECIMAL_INTEGER) {\n+            HexDigits.getCharsUTF16(value, index, bytes);\n+        } else if (conv == HEXADECIMAL_INTEGER_UPPER) {\n+            HexDigits.getCharsUTF16(value, index, bytes, true);\n+        } else {\n+            StringUTF16.getChars(value, index, bytes);\n+        }\n+        return index;\n+    }\n+\n+    private static boolean defaultLocaleDecimalSupport() {\n+        return Locale.getDefault(Locale.Category.FORMAT) == DecimalFormat.FAST_PATH_FORMAT_LOCALE;\n+    }\n+\n+    private static class DecimalFormat {\n+        static final Locale FAST_PATH_FORMAT_LOCALE;\n+        static {\n+            Locale locale = Locale.getDefault(Locale.Category.FORMAT);\n+\n+            boolean zero = false;\n+\n+            \/\/Avoid expensive initialization of DecimalFormatSymbols in the following languages\n+            String[] fast_path_languages = {\"en\", \"fr\", \"de\", \"it\", \"ja\", \"ko\", \"zh\"};\n+            for (String lange : fast_path_languages) {\n+                if (lange.equals(locale.getLanguage())) {\n+                    zero = true;\n+                    break;\n+                }\n+            }\n+\n+            if (!zero) {\n+                DecimalFormatSymbols dfs = DecimalFormatSymbols.getInstance(locale);\n+                zero = dfs.getZeroDigit() == '0';\n+            }\n+\n+            FAST_PATH_FORMAT_LOCALE = zero ? locale : null;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringFormat.java","additions":353,"deletions":0,"binary":false,"changes":353,"status":"added"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -142,0 +143,14 @@\n+        return getCharsLatin1(value, index, buffer, false);\n+    }\n+\n+    \/**\n+     * Insert digits for long value in buffer from high index to low index.\n+     *\n+     * @param value      value to convert\n+     * @param index      insert point + 1\n+     * @param buffer     byte buffer to copy into\n+     * @param ucase true uppper case, false lower case\n+     *\n+     * @return the last index used\n+     *\/\n+    public static int getCharsLatin1(long value, int index, byte[] buffer, boolean ucase) {\n@@ -143,1 +158,1 @@\n-            short pair = DIGITS[((int) value) & 0xFF];\n+            short pair = digitPair((int) value, ucase);\n@@ -149,1 +164,1 @@\n-        int digits = DIGITS[(int) (value & 0xFF)];\n+        int digits = digitPair((int) value, ucase);\n@@ -169,0 +184,14 @@\n+        return getCharsUTF16(value, index, buffer, false);\n+    }\n+\n+    \/**\n+     * Insert digits for long value in buffer from high index to low index.\n+     *\n+     * @param value      value to convert\n+     * @param index      insert point + 1\n+     * @param buffer     byte buffer to copy into\n+     * @param ucase true uppper case, false lower case\n+     *\n+     * @return the last index used\n+     *\/\n+    public static int getCharsUTF16(long value, int index, byte[] buffer, boolean ucase) {\n@@ -170,1 +199,1 @@\n-            int pair = (int) DIGITS[((int) value) & 0xFF];\n+            short pair = digitPair((int) value, ucase);\n@@ -176,1 +205,1 @@\n-        int digits = DIGITS[(int) (value & 0xFF)];\n+        short digits = digitPair((int) value, ucase);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/HexDigits.java","additions":33,"deletions":4,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -0,0 +1,369 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary StringFormat fastpath test\n+ *\/\n+\n+import java.util.Formatter;\n+import java.util.Locale;\n+\n+public class StringFormat {\n+    static char[] utf_chars = new char[] {\n+            '\\u3007', '\\u4e00', '\\u4e8c', '\\u4e09', '\\u56db', '\\u4e94', '\\u516d', '\\u4e03', '\\u516b', '\\u4e5d'\n+    };\n+\n+    static String str3(String s, char c, int i) {\n+        int x1 = (i * 3 - 1) % 10, x2 = (i * 3)  % 10, x3 = (i * 3 + 1)  % 10;\n+        return s + (char) (c + x1) + (char) (c + x2) + (char) (c + x3);\n+    }\n+\n+    static String str3_utf16(String s, int i) {\n+        int x1 = (i * 3 - 1) % 10, x2 = (i * 3)  % 10, x3 = (i * 3 + 1)  % 10;\n+        return s + utf_chars[x1] + utf_chars[x2] + utf_chars[x3];\n+    }\n+\n+    public static void main(String[] args) {\n+        int n = 5;\n+        String[] str_args_0 = new String[n];\n+        String[] str_args_1 = new String[n];\n+        String[] str_args_utf16 = new String[n];\n+        long[] int_args = new long[n];\n+\n+        String[] prefix = new String[n];\n+        String[] suffix = new String[n];\n+        String[] middle = new String[n];\n+\n+        str_args_0[0] = \"\";\n+        str_args_1[0] = \"\";\n+        str_args_utf16[0] = \"\";\n+\n+        prefix[0] = \"\";\n+        suffix[0] = \"\";\n+        middle[0] = \"\";\n+        int_args[0] = 1;\n+        for (int i = 1; i < n; i++) {\n+            int x1 = (i * 3 - 1) % 10, x2 = (i * 3)  % 10, x3 = (i * 3 + 1)  % 10;\n+            str_args_0[i] = str3(str_args_0[i - 1], 'M', i);\n+            str_args_1[i] = str3(str_args_1[i - 1], 'm', i);\n+            int_args[i] = int_args[i - 1] * 1000 + x1 * 100 + x2 * 10 + x3;\n+\n+            str_args_utf16[i] = str3_utf16(str_args_utf16[i - 1], i);\n+\n+            prefix[i] = str3(prefix[i - 1], 'a', i);\n+            suffix[i] = str3(suffix[i - 1], 'A', i);\n+            middle[i] = str3(middle[i - 1], 'k', i);\n+        }\n+\n+        String[] formats_1s = new String[n * n * n];\n+        for (int i = 0; i < n; i++) {\n+            for (int j = 0; j < n; j++) {\n+                for (int k = 0; k < n; k++) {\n+                    String specifier = \"%\" + (k == 0 ? \"\" : Integer.toString(k)) + \"s\";\n+                    formats_1s[i * n * n + j * n + k] = prefix[i] + specifier + suffix[j];\n+                }\n+            }\n+        }\n+\n+        for (String format : formats_1s) {\n+            for (String arg : str_args_0) {\n+                format1(format, arg);\n+            }\n+\n+            for (long arg : int_args) {\n+                format1(format, arg);\n+            }\n+        }\n+\n+        String[] formats_1d = new String[n * n * n];\n+        for (int i = 0; i < n; i++) {\n+            for (int j = 0; j < n; j++) {\n+                for (int k = 0; k < n; k++) {\n+                    String specifier = \"%\" + (k == 0 ? \"\" : Integer.toString(k * 3)) + \"s\";\n+                    formats_1d[i * n * n + j * n + k] = prefix[i] + specifier + suffix[j];\n+                }\n+            }\n+        }\n+        for (String format : formats_1d) {\n+            for (int i = 0; i < n; i++) {\n+                format1(format, str_args_0[i]);\n+                format1(format, str_args_utf16[i]);\n+                format1(format, int_args[i]);\n+            }\n+        }\n+\n+        String[] formats_1d_utf16 = new String[n * n * n];\n+        for (int i = 0; i < n; i++) {\n+            for (int j = 0; j < n; j++) {\n+                for (int k = 0; k < n; k++) {\n+                    String specifier = utf_chars[0] + \"%\" + (k == 0 ? \"\" : Integer.toString(k * 3)) + \"s\";\n+                    formats_1d_utf16[i * n * n + j * n + k] = prefix[i] + specifier + suffix[j];\n+                }\n+            }\n+        }\n+        for (String format : formats_1d_utf16) {\n+            for (int i = 0; i < n; i++) {\n+                format1(format, str_args_0[i]);\n+                format1(format, str_args_utf16[i]);\n+                format1(format, int_args[i]);\n+            }\n+        }\n+\n+        String[] formats_2_s_s = new String[n * n * n * n * n];\n+        for (int i0 = 0; i0 < n; i0++) {\n+            for (int i1 = 0; i1 < n; i1++) {\n+                for (int i2 = 0; i2 < n; i2++) {\n+                    for (int i3 = 0; i3 < n; i3++) {\n+                        for (int i4 = 0; i4 < n; i4++) {\n+                            String s0 = \"%\" + (i3 == 0 ? \"\" : Integer.toString(i3 * 3)) + \"s\";\n+                            String s1 = \"%\" + (i4 == 0 ? \"\" : Integer.toString(i4 * 3)) + \"s\";\n+                            int index = i0 * n * n * n * n\n+                                    + i1 * n * n * n\n+                                    + i2 * n * n\n+                                    + i3 * n\n+                                    + i4;\n+                            formats_2_s_s[index] = prefix[i0] + s0 + middle[i1] + s1 + suffix[i2];\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        for (String format : formats_2_s_s) {\n+            for (int i = 0; i < str_args_0.length; i++) {\n+                for (int j = 0; j < str_args_0.length; j++) {\n+                    format2(format, str_args_0[i], str_args_0[j]);\n+                    format2(format, int_args[i], int_args[j]);\n+                }\n+            }\n+        }\n+\n+        String[] formats_2_s_d = new String[n * n * n * n * n];\n+        for (int i0 = 0; i0 < n; i0++) {\n+            for (int i1 = 0; i1 < n; i1++) {\n+                for (int i2 = 0; i2 < n; i2++) {\n+                    for (int i3 = 0; i3 < n; i3++) {\n+                        for (int i4 = 0; i4 < n; i4++) {\n+                            String s0 = \"%\" + (i3 == 0 ? \"\" : Integer.toString(i3 * 3)) + \"s\";\n+                            String s1 = \"%\" + (i4 == 0 ? \"\" : Integer.toString(i4 * 3)) + \"d\";\n+                            int index = i0 * n * n * n * n\n+                                    + i1 * n * n * n\n+                                    + i2 * n * n\n+                                    + i3 * n\n+                                    + i4;\n+                            formats_2_s_d[index] = prefix[i0] + s0 + middle[i1] + s1 + suffix[i2];\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        for (String format : formats_2_s_d) {\n+            for (int i = 0; i < str_args_0.length; i++) {\n+                for (int j = 0; j < str_args_0.length; j++) {\n+                    format2(format, str_args_0[i], int_args[j]);\n+                }\n+            }\n+        }\n+\n+        String[] formats_2_d_s = new String[n * n * n * n * n];\n+        for (int i0 = 0; i0 < n; i0++) {\n+            for (int i1 = 0; i1 < n; i1++) {\n+                for (int i2 = 0; i2 < n; i2++) {\n+                    for (int i3 = 0; i3 < n; i3++) {\n+                        for (int i4 = 0; i4 < n; i4++) {\n+                            String s0 = \"%\" + (i3 == 0 ? \"\" : Integer.toString(i3 * 3)) + \"d\";\n+                            String s1 = \"%\" + (i4 == 0 ? \"\" : Integer.toString(i4 * 3)) + \"s\";\n+                            int index = i0 * n * n * n * n\n+                                    + i1 * n * n * n\n+                                    + i2 * n * n\n+                                    + i3 * n\n+                                    + i4;\n+                            formats_2_d_s[index] = prefix[i0] + s0 + middle[i1] + s1 + suffix[i2];\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        for (String format : formats_2_d_s) {\n+            for (int i = 0; i < str_args_0.length; i++) {\n+                for (int j = 0; j < str_args_0.length; j++) {\n+                    format2(format, int_args[i], str_args_0[j]);\n+                }\n+            }\n+        }\n+\n+        String[] formats_2_d_d = new String[n * n * n * n * n];\n+        for (int i0 = 0; i0 < n; i0++) {\n+            for (int i1 = 0; i1 < n; i1++) {\n+                for (int i2 = 0; i2 < n; i2++) {\n+                    for (int i3 = 0; i3 < n; i3++) {\n+                        for (int i4 = 0; i4 < n; i4++) {\n+                            String s0 = \"%\" + (i3 == 0 ? \"\" : Integer.toString(i3 * 3)) + \"d\";\n+                            String s1 = \"%\" + (i4 == 0 ? \"\" : Integer.toString(i4 * 3)) + \"d\";\n+                            int index = i0 * n * n * n * n\n+                                    + i1 * n * n * n\n+                                    + i2 * n * n\n+                                    + i3 * n\n+                                    + i4;\n+                            formats_2_d_d[index] = prefix[i0] + s0 + middle[i1] + s1 + suffix[i2];\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        for (String format : formats_2_d_d) {\n+            for (int i = 0; i < str_args_0.length; i++) {\n+                for (int j = 0; j < str_args_0.length; j++) {\n+                    format2(format, int_args[i], int_args[j]);\n+                }\n+            }\n+        }\n+\n+        locales(() -> {\n+            for (int i = 0; i < n; i++) {\n+                format2(\"%s%d\", str_args_0[i], int_args[i]);\n+                format2(\"%s%d\", str_args_0[i], int_args[i]);\n+                format2(\"%s%x\", str_args_0[i], int_args[i]);\n+                format2(\"%s%X\", str_args_0[i], int_args[i]);\n+\n+                format2(utf_chars[0] + \"%s%d\", str_args_0[i], int_args[i]);\n+                format2(utf_chars[0] + \"%s%d\", str_args_0[i], int_args[i]);\n+                format2(utf_chars[0] + \"%s%x\", str_args_0[i], int_args[i]);\n+                format2(utf_chars[0] + \"%s%X\", str_args_0[i], int_args[i]);\n+                format2(\"%s %d\" + utf_chars[0], str_args_0[i], int_args[i]);\n+                format2(\"%s %d\" + utf_chars[0], str_args_0[i], int_args[i]);\n+                format2(\"%s %x\" + utf_chars[0], str_args_0[i], int_args[i]);\n+                format2(\"%s %X\" + utf_chars[0], str_args_0[i], int_args[i]);\n+\n+                format2(\"%s%d\", formats_1d_utf16[i], int_args[i]);\n+                format2(\"%s%d\", formats_1d_utf16[i], int_args[i]);\n+                format2(\"%s%x\", formats_1d_utf16[i], int_args[i]);\n+                format2(\"%s%X\", formats_1d_utf16[i], int_args[i]);\n+            }\n+        });\n+\n+        format2(\"%s%\", \"\", 12);\n+        format2(\"%3\", \"\", 12);\n+        format2(\"%s%3\", \"\", 12);\n+        format2(\"%s%33%\", \"\", 12);\n+\n+        format1(\"a%n\");\n+        format1(\"a%nb\");\n+        format1(\"%nb\");\n+        format1(utf_chars[0] + \"%n\");\n+        format1(utf_chars[0] + \"%n\" + utf_chars[0]);\n+        format1(\"%n\" + utf_chars[0]);\n+\n+        format1(utf_chars[0] + \"%s%n\", str_args_0[0]);\n+        format1(utf_chars[0] + \"%s%n\", formats_1d_utf16[0]);\n+        format1(utf_chars[0] + \"%n%s\", str_args_0[0]);\n+        format1(utf_chars[0] + \"%n%s\", formats_1d_utf16[0]);\n+    }\n+\n+    static void locales(Runnable r) {\n+        Locale defaultLocale = Locale.getDefault(Locale.Category.FORMAT);\n+        Locale[] locales = Locale.getAvailableLocales();\n+        for (Locale locale : locales) {\n+            Locale.setDefault(Locale.Category.FORMAT, locale);\n+            r.run();\n+        }\n+        Locale.setDefault(Locale.Category.FORMAT, defaultLocale);\n+    }\n+\n+    private static void format1(String format) {\n+        String juf = new Formatter().format(format).toString();\n+        String strf = format.formatted();\n+        assertEquals(juf, strf);\n+    }\n+\n+    private static void format1(String format, String arg) {\n+        String juf = new Formatter().format(format, arg).toString();\n+        String strf = format.formatted(arg);\n+        assertEquals(juf, strf);\n+    }\n+\n+    private static void format2(String format, Object arg0, Object arg1) {\n+        RuntimeException jue = null;\n+        String juf = null;\n+        try {\n+            juf = new Formatter().format(format, arg0, arg1).toString();\n+        } catch (RuntimeException e) {\n+            jue = e;\n+        }\n+\n+        RuntimeException stre = null;\n+        String strf = null;\n+        try {\n+            strf = format.formatted(arg0, arg1);\n+        } catch (RuntimeException e) {\n+            stre = e;\n+        }\n+\n+        if (jue != null && stre == null) {\n+            throw jue;\n+        }\n+\n+        if (jue == null && stre != null) {\n+            throw stre;\n+        }\n+\n+        if (jue != null && stre != null) {\n+            return;\n+        }\n+\n+        assertEquals(juf, strf);\n+    }\n+\n+    private static void format1(String format, long arg) {\n+        {\n+            byte byteArg = (byte) arg;\n+            String juf = new Formatter().format(format, byteArg).toString();\n+            String strf = format.formatted(byteArg);\n+            assertEquals(juf, strf);\n+        }\n+        {\n+            short shortArg = (short) arg;\n+            String juf = new Formatter().format(format, shortArg).toString();\n+            String strf = format.formatted(shortArg);\n+            assertEquals(juf, strf);\n+        }\n+        {\n+            int intArg = (int) arg;\n+            String juf = new Formatter().format(format, intArg).toString();\n+            String strf = format.formatted(intArg);\n+            assertEquals(juf, strf);\n+        }\n+        {\n+            String juf = new Formatter().format(format, arg).toString();\n+            String strf = format.formatted(arg);\n+            assertEquals(juf, strf);\n+        }\n+    }\n+\n+    private static void assertEquals(Object expected, Object actual) {\n+        if (!expected.equals(actual)) {\n+            throw new RuntimeException(\"Expected \" + expected + \" but got \" + actual);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/String\/StringFormat.java","additions":369,"deletions":0,"binary":false,"changes":369,"status":"added"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -58,0 +59,10 @@\n+    @Benchmark\n+    public String lineFormat() {\n+        return \"0123456789 %n\".formatted();\n+    }\n+\n+    @Benchmark\n+    public String lineFormatUtf16() {\n+        return \"\\u3007\\u4e00\\u4e8c\\u4e09\\u56db\\u4e94\\u516d\\u4e03\\u516b\\u4e5d %n\".formatted();\n+    }\n+\n@@ -60,1 +71,1 @@\n-        return \"%s\".formatted(s);\n+        return \"0123456789 %s\".formatted(s);\n@@ -64,2 +75,12 @@\n-    public String stringIntFormat() {\n-        return \"%s %d\".formatted(s, i);\n+    public String stringFormatUtf16() {\n+        return \"\\u3007\\u4e00\\u4e8c\\u4e09\\u56db\\u4e94\\u516d\\u4e03\\u516b\\u4e5d %s\".formatted(s);\n+    }\n+\n+    @Benchmark\n+    public String stringLineFormat() {\n+        return \"%s 0123456789 %n\".formatted(s);\n+    }\n+\n+    @Benchmark\n+    public String stringLineFormatUtf16() {\n+        return \"%s \\u3007\\u4e00\\u4e8c\\u4e09\\u56db\\u4e94\\u516d\\u4e03\\u516b\\u4e5d %n\".formatted(s);\n@@ -70,1 +91,6 @@\n-        return \"%3s\".formatted(s);\n+        return \"0123456789 %3s\".formatted(s);\n+    }\n+\n+    @Benchmark\n+    public String widthStringFormatUtf16() {\n+        return \"\\u3007\\u4e00\\u4e8c\\u4e09\\u56db\\u4e94\\u516d\\u4e03\\u516b\\u4e5d %3s\".formatted(s);\n@@ -75,1 +101,106 @@\n-        return \"%3s %d\".formatted(s, i);\n+        return \"0123456789 %3s %d\".formatted(s, i);\n+    }\n+\n+    @Benchmark\n+    public String widthStringIntFormatUtf16() {\n+        return \"\\u3007\\u4e00\\u4e8c\\u4e09\\u56db\\u4e94\\u516d\\u4e03\\u516b\\u4e5d %3s %d\".formatted(s, i);\n+    }\n+\n+    @Benchmark\n+    public String intFormat() {\n+        return \"0123456789 %d\".formatted(i);\n+    }\n+\n+    @Benchmark\n+    public String intFormatUtf16() {\n+        return \"\\u3007\\u4e00\\u4e8c\\u4e09\\u56db\\u4e94\\u516d\\u4e03\\u516b\\u4e5d %d\".formatted(i);\n+    }\n+\n+    @Benchmark\n+    public String intIntFormat() {\n+        return \"\\u3007\\u4e00\\u4e8c\\u4e09\\u56db\\u4e94\\u516d\\u4e03\\u516b\\u4e5d %d %d\".formatted(i, i);\n+    }\n+\n+    @Benchmark\n+    public String intIntFormatUtf16() {\n+        return \"\\u3007\\u4e00\\u4e8c\\u4e09\\u56db\\u4e94\\u516d\\u4e03\\u516b\\u4e5d %d %d\".formatted(i, i);\n+    }\n+\n+    @Benchmark\n+    public String intHexFormat() {\n+        return \"0123456789 is %d %x\".formatted(i, i);\n+    }\n+\n+    @Benchmark\n+    public String intHexFormatUtf16() {\n+        return \"\\u3007\\u4e00\\u4e8c\\u4e09\\u56db\\u4e94\\u516d\\u4e03\\u516b\\u4e5d %d : %x\".formatted(i, i);\n+    }\n+\n+    @Benchmark\n+    public String intHexUFormat() {\n+        return \"0123456789 is %d %X\".formatted(i, i);\n+    }\n+\n+    @Benchmark\n+    public String intHexUFormatUtf16() {\n+        return \"\\u3007\\u4e00\\u4e8c\\u4e09\\u56db\\u4e94\\u516d\\u4e03\\u516b\\u4e5d %d : %X\".formatted(i, i);\n+    }\n+\n+    @Benchmark\n+    public String intOctalFormat() {\n+        return \"0123456789 is %d %o\".formatted(i, i);\n+    }\n+\n+    @Benchmark\n+    public String intOctalFormatUtf16() {\n+        return \"\\u3007\\u4e00\\u4e8c\\u4e09\\u56db\\u4e94\\u516d\\u4e03\\u516b\\u4e5d %d : %o\".formatted(i, i);\n+    }\n+\n+    @Benchmark\n+    public String stringIntFormat() {\n+        return \"0123456789 %s : %d\".formatted(s, i);\n+    }\n+\n+    @Benchmark\n+    public String stringIntFormatUtf16() {\n+        return \"\\u3007\\u4e00\\u4e8c\\u4e09\\u56db\\u4e94\\u516d\\u4e03\\u516b\\u4e5d %s : %d\".formatted(s, i);\n+    }\n+\n+    @Benchmark\n+    public String stringIntRFormat() {\n+        return \"0123456789 %s : %d 0123456789\".formatted(s, i);\n+    }\n+\n+    @Benchmark\n+    public String stringIntRFormatUtf16() {\n+        return \"\\u3007\\u4e00\\u4e8c\\u4e09\\u56db\\u4e94\\u516d\\u4e03\\u516b\\u4e5d %s : %d \\u3007\\u4e00\\u4e8c\\u4e09\\u56db\\u4e94\\u516d\\u4e03\\u516b\\u4e5d\".formatted(s, i);\n+    }\n+\n+    @Benchmark\n+    public String stringWidthIntFormat() {\n+        return \"0123456789 %s : %3d\".formatted(s, i);\n+    }\n+\n+    @Benchmark\n+    public String stringWidthIntFormatUtf16() {\n+        return \"\\u3007\\u4e00\\u4e8c\\u4e09\\u56db\\u4e94\\u516d\\u4e03\\u516b\\u4e5d %s : %3d\".formatted(s, i);\n+    }\n+\n+    @Benchmark\n+    public String stringIntHexFormat() {\n+        return \"0123456789 %s : %x\".formatted(s, i);\n+    }\n+\n+    @Benchmark\n+    public String stringIntHexUFormat() {\n+        return \"0123456789 %s : %x\".formatted(s, i);\n+    }\n+\n+    @Benchmark\n+    public String stringIntOctalFormat() {\n+        return \"0123456789 %s : %o\".formatted(s, i);\n+    }\n+\n+    @Benchmark\n+    public String stringIntOctalFormatUtf16() {\n+        return \"\\u3007\\u4e00\\u4e8c\\u4e09\\u56db\\u4e94\\u516d\\u4e03\\u516b\\u4e5d %s : %o\".formatted(s, i);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringFormat.java","additions":137,"deletions":6,"binary":false,"changes":143,"status":"modified"}]}