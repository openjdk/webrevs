{"files":[{"patch":"@@ -4481,1 +4481,1 @@\n-        return new Formatter().format(format, args).toString();\n+        return StringFormat.format(format, args);\n@@ -4543,1 +4543,1 @@\n-        return new Formatter().format(this, args).toString();\n+        return StringFormat.format(this, args);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,344 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang;\n+\n+import jdk.internal.util.HexDigits;\n+import java.text.DecimalFormatSymbols;\n+import java.util.Formatter;\n+import java.util.Locale;\n+\n+\/**\n+ * Utility class for string format fastpath\n+ *\/\n+final class StringFormat {\n+    private static final char DECIMAL_INTEGER           = 'd';\n+    private static final char HEXADECIMAL_INTEGER       = 'x';\n+    private static final char HEXADECIMAL_INTEGER_UPPER = 'X';\n+    private static final char STRING                    = 's';\n+\n+    private static final Locale FAST_PATH_FORMAT_LOCALE;\n+    static {\n+        Locale locale = Locale.getDefault(Locale.Category.FORMAT);\n+\n+        boolean zero = false;\n+\n+        \/\/Avoid expensive initialization of DecimalFormatSymbols in the following languages\n+        String[] fast_path_languages = {\"en\", \"fr\", \"de\", \"it\", \"ja\", \"ko\", \"zh\"};\n+        for (String lange : fast_path_languages) {\n+            if (lange.equals(locale.getLanguage())) {\n+                zero = true;\n+                break;\n+            }\n+        }\n+\n+        if (!zero) {\n+            DecimalFormatSymbols dfs = DecimalFormatSymbols.getInstance(locale);\n+            zero = dfs.getZeroDigit() == '0';\n+        }\n+\n+        FAST_PATH_FORMAT_LOCALE = zero ? locale : null;\n+    }\n+\n+    static String format(String format, Object... args) {\n+        if (args != null) {\n+            int off = format.indexOf('%');\n+            if (off == -1) {\n+                \/\/ no formatting to be done\n+                return format;\n+            }\n+\n+            int len = format.length();\n+            if (off + 1 != len) {\n+                int off1 = format.indexOf('%', off + 2);\n+                String s = null;\n+                if (args.length == 1) {\n+                    if (off1 == -1) {\n+                        s = format1(format, off, args[0]);\n+                    }\n+                } else if (args.length == 2) {\n+                    if (off1 != -1 && off1 + 1 != len) {\n+                        s = format2(format, off, off1, args[0], args[1]);\n+                    }\n+                }\n+                if (s != null) {\n+                    return s;\n+                }\n+            }\n+        }\n+\n+        return new Formatter().format(format, args).toString();\n+    }\n+\n+    private static String format1(String format, int off, Object arg) {\n+        int len = format.length();\n+        char conv = format.charAt(off + 1);\n+        int width = 0;\n+        if (conv >= '1' && conv <= '9') {\n+            width = conv - '0';\n+            if (off + 2 < len) {\n+                conv = format.charAt(off + 2);\n+            }\n+        }\n+\n+        if (conv == STRING) {\n+            if (isLong(arg)) {\n+                conv = DECIMAL_INTEGER;\n+            } else {\n+                arg = String.valueOf(arg);\n+            }\n+        }\n+\n+        int size = stringSize(conv, arg);\n+        if (size == -1) {\n+            return null;\n+        }\n+        return format1(format, off, conv, arg, width, size);\n+    }\n+\n+    private static String format2(String format, int off0, int off1, Object arg0, Object arg1) {\n+        final int len = format.length();\n+        char conv0 = format.charAt(off0 + 1);\n+        int width0 = 0;\n+        if (conv0 >= '1' && conv0 <= '9') {\n+            width0 = conv0 - '0';\n+            if (off0 + 2 < len) {\n+                conv0 = format.charAt(off0 + 2);\n+            }\n+        }\n+\n+        char conv1 = format.charAt(off1 + 1);\n+        int width1 = 0;\n+        if (conv1 >= '1' && conv1 <= '9') {\n+            width1 = conv1 - '0';\n+            if (off1 + 2 < len) {\n+                conv1 = format.charAt(off1 + 2);\n+            }\n+        }\n+\n+        if (off1 + 2 < len) {\n+            if (format.indexOf('%', off1 + 2) != -1) {\n+                return null;\n+            }\n+        }\n+\n+        String str;\n+        byte coder = format.coder();\n+        if (conv0 == STRING) {\n+            if (isLong(arg0)) {\n+                conv0 = DECIMAL_INTEGER;\n+            } else {\n+                str = String.valueOf(arg0);\n+                coder |= str.coder();\n+                arg0 = str;\n+            }\n+        }\n+\n+        if (conv1 == STRING) {\n+            if (isLong(arg1)) {\n+                conv1 = DECIMAL_INTEGER;\n+            } else {\n+                str = String.valueOf(arg1);\n+                coder |= str.coder();\n+                arg1 = String.valueOf(str);\n+            }\n+        }\n+\n+        int size0 = stringSize(conv0, arg0);\n+        if (size0 == -1) {\n+            return null;\n+        }\n+        int size1 = stringSize(conv1, arg1);\n+        if (size1 == -1) {\n+            return null;\n+        }\n+\n+        int specifierSize0 = 2 + (width0 != 0 ? 1 : 0);\n+        int specifierSize1 = 2 + (width1 != 0 ? 1 : 0);\n+\n+        int strlen = len\n+                + Math.max(width0, size0)\n+                + Math.max(width1, size1)\n+                - specifierSize0\n+                - specifierSize1;\n+        return coder == String.LATIN1\n+                ? format2Latin1(format, strlen, off0, conv0, arg0, width0, size0, specifierSize0,\n+                                                off1, conv1, arg1, width1, size1, specifierSize1)\n+                : format2UTF16( format, strlen, off0, conv0, arg0, width0, size0, specifierSize0,\n+                                                off1, conv1, arg1, width1, size1, specifierSize1);\n+    }\n+\n+    private static int stringSize(char conv, Object arg) {\n+        int size = -1;\n+        if (isLong(arg)) {\n+            long longValue = ((Number) arg).longValue();\n+            if (conv == DECIMAL_INTEGER) {\n+                if (FAST_PATH_FORMAT_LOCALE == Locale.getDefault(Locale.Category.FORMAT)) {\n+                    size = Long.stringSize(longValue);\n+                }\n+            } else if (conv == HEXADECIMAL_INTEGER || conv == HEXADECIMAL_INTEGER_UPPER) {\n+                size = HexDigits.stringSize(longValue);\n+            }\n+        } else if (conv == STRING && arg instanceof String) {\n+            size = ((String) arg).length();\n+        }\n+        return size;\n+    }\n+\n+    private static boolean isLong(Object arg) {\n+        return arg instanceof Long\n+            || arg instanceof Integer\n+            || arg instanceof Short\n+            || arg instanceof Byte;\n+    }\n+\n+    private static String format1(String format, int off, char conv, Object arg, int width, int size) {\n+        byte coder = format.coder();\n+        if (arg instanceof String) {\n+            coder |= ((String) arg).coder();\n+        }\n+        int specifierSize = 2 + (width != 0 ? 1 : 0);\n+        int length = format.length() + Math.max(width, size) - specifierSize;\n+        byte[] bytes = new byte[length << coder];\n+        if (off > 0) {\n+            format.getBytes(bytes, 0, 0, coder, off);\n+        }\n+\n+        int index = coder == String.LATIN1\n+                ? getCharsLatin1(bytes, off, arg, conv, width, size)\n+                : getCharsUTF16(bytes, off, arg, conv, width, size);\n+\n+        int rest = format.length() - off - specifierSize;\n+        if (rest > 0) {\n+            format.getBytes(bytes, off + specifierSize, index, coder, rest);\n+        }\n+        return new String(bytes, coder);\n+    }\n+\n+    private static String format2Latin1(\n+            String format, int length,\n+            int off0, char conv0, Object arg0, int width0, int size0, int specifierSize0,\n+            int off1, char conv1, Object arg1, int width1, int size1, int specifierSize1\n+    ) {\n+        byte[] bytes = new byte[length];\n+        if (off0 > 0) {\n+            format.getBytes(bytes, 0, 0, String.LATIN1, off0);\n+        }\n+\n+        int index = getCharsLatin1(bytes, off0, arg0, conv0, width0, size0);\n+\n+        int middle = off1 - off0 - specifierSize0;\n+        if (middle > 0) {\n+            format.getBytes(bytes, off0 + specifierSize0, index, String.LATIN1, middle);\n+            index += middle;\n+        }\n+\n+        index = getCharsLatin1(bytes, index, arg1, conv1, width1, size1);\n+\n+        int rest = format.length() - off1 - specifierSize1;\n+        if (rest > 0) {\n+            format.getBytes(bytes, off1 + specifierSize1, index, String.LATIN1, rest);\n+        }\n+        return new String(bytes, String.LATIN1);\n+    }\n+\n+    private static String format2UTF16(\n+            String format, int length,\n+            int off0, char conv0, Object arg0, int width0, int size0, int specifierSize0,\n+            int off1, char conv1, Object arg1, int width1, int size1, int specifierSize1\n+    ) {\n+        byte coder = String.UTF16;\n+        byte[] bytes = new byte[length << coder];\n+        if (off0 > 0) {\n+            format.getBytes(bytes, 0, 0, coder, off0);\n+        }\n+\n+        int index = getCharsUTF16(bytes, off0, arg0, conv0, width0, size0);\n+\n+        int middle = off1 - off0 - specifierSize0;\n+        if (middle > 0) {\n+            format.getBytes(bytes, off0 + specifierSize0, index, coder, middle);\n+            index += middle;\n+        }\n+\n+        index = getCharsUTF16(bytes, index, arg1, conv1, width1, size1);\n+\n+        int rest = format.length() - off1 - specifierSize1;\n+        if (rest > 0) {\n+            format.getBytes(bytes, off1 + specifierSize1, index, coder, rest);\n+        }\n+        return new String(bytes, coder);\n+    }\n+\n+    private static int getCharsLatin1(byte[] bytes, int index, Object arg, char conv, int width, int size) {\n+        if (size < width) {\n+            for (int i = size; i < width; i++) {\n+                bytes[index++] = ' ';\n+            }\n+        }\n+\n+        if (conv == STRING) {\n+            String str = (String) arg;\n+            str.getBytes(bytes, index, String.LATIN1);\n+            return index + size;\n+        }\n+\n+        long value = ((Number) arg).longValue();\n+        index += size;\n+        if (conv == HEXADECIMAL_INTEGER) {\n+            HexDigits.getCharsLatin1(value, index, bytes);\n+        } else if (conv == HEXADECIMAL_INTEGER_UPPER) {\n+            HexDigits.getCharsLatin1(value, index, bytes, true);\n+        } else {\n+            StringLatin1.getChars(value, index, bytes);\n+        }\n+        return index;\n+    }\n+\n+    private static int getCharsUTF16(byte[] bytes, int index, Object arg, char conv, int width, int size) {\n+        if (size < width) {\n+            for (int i = size; i < width; i++) {\n+                StringUTF16.putChar(bytes, index++, ' ');\n+            }\n+        }\n+\n+        if (conv == STRING) {\n+            String str = (String) arg;\n+            str.getBytes(bytes, index, String.UTF16);\n+            return index + size;\n+        }\n+\n+        long value = ((Number) arg).longValue();\n+        index += size;\n+        if (conv == HEXADECIMAL_INTEGER) {\n+            HexDigits.getCharsUTF16(value, index, bytes);\n+        } else if (conv == HEXADECIMAL_INTEGER_UPPER) {\n+            HexDigits.getCharsUTF16(value, index, bytes, true);\n+        } else {\n+            StringUTF16.getChars(value, index, bytes);\n+        }\n+        return index;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringFormat.java","additions":344,"deletions":0,"binary":false,"changes":344,"status":"added"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -142,0 +143,14 @@\n+        return getCharsLatin1(value, index, buffer, false);\n+    }\n+\n+    \/**\n+     * Insert digits for long value in buffer from high index to low index.\n+     *\n+     * @param value      value to convert\n+     * @param index      insert point + 1\n+     * @param buffer     byte buffer to copy into\n+     * @param ucase true uppper case, false lower case\n+     *\n+     * @return the last index used\n+     *\/\n+    public static int getCharsLatin1(long value, int index, byte[] buffer, boolean ucase) {\n@@ -143,1 +158,1 @@\n-            short pair = DIGITS[((int) value) & 0xFF];\n+            short pair = digitPair((int) value, ucase);\n@@ -149,1 +164,1 @@\n-        int digits = DIGITS[(int) (value & 0xFF)];\n+        int digits = digitPair((int) value, ucase);\n@@ -169,0 +184,14 @@\n+        return getCharsUTF16(value, index, buffer, false);\n+    }\n+\n+    \/**\n+     * Insert digits for long value in buffer from high index to low index.\n+     *\n+     * @param value      value to convert\n+     * @param index      insert point + 1\n+     * @param buffer     byte buffer to copy into\n+     * @param ucase true uppper case, false lower case\n+     *\n+     * @return the last index used\n+     *\/\n+    public static int getCharsUTF16(long value, int index, byte[] buffer, boolean ucase) {\n@@ -170,1 +199,1 @@\n-            int pair = (int) DIGITS[((int) value) & 0xFF];\n+            short pair = digitPair((int) value, ucase);\n@@ -176,1 +205,1 @@\n-        int digits = DIGITS[(int) (value & 0xFF)];\n+        short digits = digitPair((int) value, ucase);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/HexDigits.java","additions":33,"deletions":4,"binary":false,"changes":37,"status":"modified"}]}