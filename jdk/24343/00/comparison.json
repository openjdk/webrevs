{"files":[{"patch":"@@ -27,0 +27,1 @@\n+#include \"nmt\/nMemLimit.hpp\"\n@@ -306,1 +307,1 @@\n-  if (MemTracker::check_exceeds_limit(x, _mem_tag)) {\n+  if (MemTracker::check_exceeds_limit(x, _mem_tag, NMemType::Malloc)) {\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,231 +0,0 @@\n-\/*\n- * Copyright (c) 2023 SAP SE. All rights reserved.\n- * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"nmt\/mallocLimit.hpp\"\n-#include \"nmt\/memTag.hpp\"\n-#include \"nmt\/nmtCommon.hpp\"\n-#include \"runtime\/java.hpp\"\n-#include \"runtime\/globals.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/parseInteger.hpp\"\n-#include \"utilities\/ostream.hpp\"\n-\n-MallocLimitSet MallocLimitHandler::_limits;\n-bool MallocLimitHandler::_have_limit = false;\n-\n-static const char* const MODE_OOM = \"oom\";\n-static const char* const MODE_FATAL = \"fatal\";\n-\n-static const char* mode_to_name(MallocLimitMode m) {\n-  switch (m) {\n-  case MallocLimitMode::trigger_fatal: return MODE_FATAL;\n-  case MallocLimitMode::trigger_oom: return MODE_OOM;\n-  default: ShouldNotReachHere();\n-  };\n-  return nullptr;\n-}\n-\n-class ParserHelper {\n-  \/\/ Start, end of parsed string.\n-  const char* const _s;\n-  const char* const _end;\n-  \/\/ Current parse position.\n-  const char* _p;\n-\n-public:\n-  ParserHelper(const char* s) : _s(s), _end(s + strlen(s)), _p(s) {}\n-\n-  bool eof() const { return _p >= _end; }\n-\n-  \/\/ Check if string at position matches a malloclimit_mode_t.\n-  \/\/ Advance position on match.\n-  bool match_mode_flag(MallocLimitMode* out) {\n-    if (eof()) {\n-      return false;\n-    }\n-    if (strncasecmp(_p, MODE_OOM, strlen(MODE_OOM)) == 0) {\n-      *out = MallocLimitMode::trigger_oom;\n-      _p += 3;\n-      return true;\n-    } else if (strncasecmp(_p, MODE_FATAL, strlen(MODE_FATAL)) == 0) {\n-      *out = MallocLimitMode::trigger_fatal;\n-      _p += 5;\n-      return true;\n-    }\n-    return false;\n-  }\n-\n-  \/\/ Check if string at position matches a category name.\n-  \/\/ Advances position on match.\n-  bool match_category(MemTag* out) {\n-    if (eof()) {\n-      return false;\n-    }\n-    const char* end = strchr(_p, ':');\n-    if (end == nullptr) {\n-      end = _end;\n-    }\n-    stringStream ss;\n-    ss.print(\"%.*s\", (int)(end - _p), _p);\n-    MemTag mem_tag = NMTUtil::string_to_mem_tag(ss.base());\n-    if (mem_tag != mtNone) {\n-      *out = mem_tag;\n-      _p = end;\n-      return true;\n-    }\n-    return false;\n-  }\n-\n-  \/\/ Check if string at position matches a memory size (e.g. \"100\", \"100g\" etc).\n-  \/\/ Advances position on match.\n-  bool match_size(size_t* out) {\n-    if (!eof()) {\n-      char* remainder = nullptr;\n-      if (parse_integer<size_t>(_p, &remainder, out)) {\n-        assert(remainder > _p && remainder <= _end, \"sanity\");\n-        _p = remainder;\n-        return true;\n-      }\n-    }\n-    return false;\n-  }\n-\n-  \/\/ Check if char at pos matches c; return true and advance pos if so.\n-  bool match_char(char c) {\n-    if (!eof() && (*_p) == c) {\n-      _p ++;\n-      return true;\n-    }\n-    return false;\n-  }\n-};\n-\n-MallocLimitSet::MallocLimitSet() {\n-  reset();\n-}\n-\n-void MallocLimitSet::set_global_limit(size_t s, MallocLimitMode flag) {\n-  _glob.sz = s; _glob.mode = flag;\n-}\n-\n-void MallocLimitSet::set_category_limit(MemTag mem_tag, size_t s, MallocLimitMode flag) {\n-  const int i = NMTUtil::tag_to_index(mem_tag);\n-  _cat[i].sz = s; _cat[i].mode = flag;\n-}\n-\n-void MallocLimitSet::reset() {\n-  set_global_limit(0, MallocLimitMode::trigger_fatal);\n-  _glob.sz = 0; _glob.mode = MallocLimitMode::trigger_fatal;\n-  for (int i = 0; i < mt_number_of_tags; i++) {\n-    set_category_limit(NMTUtil::index_to_tag(i), 0, MallocLimitMode::trigger_fatal);\n-  }\n-}\n-\n-void MallocLimitSet::print_on(outputStream* st) const {\n-  static const char* flagnames[] = { MODE_FATAL, MODE_OOM };\n-  if (_glob.sz > 0) {\n-    st->print_cr(\"MallocLimit: total limit: \" PROPERFMT \" (%s)\", PROPERFMTARGS(_glob.sz),\n-                 mode_to_name(_glob.mode));\n-  } else {\n-    for (int i = 0; i < mt_number_of_tags; i++) {\n-      if (_cat[i].sz > 0) {\n-        st->print_cr(\"MallocLimit: category \\\"%s\\\" limit: \" PROPERFMT \" (%s)\",\n-                     NMTUtil::tag_to_enum_name(NMTUtil::index_to_tag(i)),\n-                     PROPERFMTARGS(_cat[i].sz), mode_to_name(_cat[i].mode));\n-      }\n-    }\n-  }\n-}\n-\n-bool MallocLimitSet::parse_malloclimit_option(const char* v, const char** err) {\n-\n-#define BAIL_UNLESS(condition, errormessage) if (!(condition)) { *err = errormessage; return false; }\n-\n-  \/\/ Global form:\n-  \/\/ MallocLimit=<size>[:flag]\n-\n-  \/\/ Category-specific form:\n-  \/\/ MallocLimit=<category>:<size>[:flag][,<category>:<size>[:flag]...]\n-\n-  reset();\n-\n-  ParserHelper sst(v);\n-\n-  BAIL_UNLESS(!sst.eof(), \"Empty string\");\n-\n-  \/\/ Global form?\n-  if (sst.match_size(&_glob.sz)) {\n-    \/\/ Match optional mode flag (e.g. 1g:oom)\n-    if (!sst.eof()) {\n-      BAIL_UNLESS(sst.match_char(':'), \"Expected colon\");\n-      BAIL_UNLESS(sst.match_mode_flag(&_glob.mode), \"Expected flag\");\n-    }\n-  }\n-  \/\/ Category-specific form?\n-  else {\n-    while (!sst.eof()) {\n-      MemTag mem_tag;\n-\n-      \/\/ Match category, followed by :\n-      BAIL_UNLESS(sst.match_category(&mem_tag), \"Expected category name\");\n-      BAIL_UNLESS(sst.match_char(':'), \"Expected colon following category\");\n-\n-      malloclimit* const modified_limit = &_cat[NMTUtil::tag_to_index(mem_tag)];\n-\n-      \/\/ Match size\n-      BAIL_UNLESS(sst.match_size(&modified_limit->sz), \"Expected size\");\n-\n-      \/\/ Match optional flag\n-      if (!sst.eof() && sst.match_char(':')) {\n-        BAIL_UNLESS(sst.match_mode_flag(&modified_limit->mode), \"Expected flag\");\n-      }\n-\n-      \/\/ More to come?\n-      if (!sst.eof()) {\n-        BAIL_UNLESS(sst.match_char(','), \"Expected comma\");\n-      }\n-    }\n-  }\n-  return true;\n-}\n-\n-void MallocLimitHandler::initialize(const char* options) {\n-  _have_limit = false;\n-  if (options != nullptr && options[0] != '\\0') {\n-    const char* err = nullptr;\n-    if (!_limits.parse_malloclimit_option(options, &err)) {\n-      vm_exit_during_initialization(\"Failed to parse MallocLimit\", err);\n-    }\n-    _have_limit = true;\n-  }\n-}\n-\n-void MallocLimitHandler::print_on(outputStream* st) {\n-  if (have_limit()) {\n-    _limits.print_on(st);\n-  } else {\n-    st->print_cr(\"MallocLimit: unset\");\n-  }\n-}\n","filename":"src\/hotspot\/share\/nmt\/mallocLimit.cpp","additions":0,"deletions":231,"binary":false,"changes":231,"status":"deleted"},{"patch":"@@ -1,81 +0,0 @@\n-\/*\n- * Copyright (c) 2023 SAP SE. All rights reserved.\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_SERVICES_MALLOCLIMIT_HPP\n-#define SHARE_SERVICES_MALLOCLIMIT_HPP\n-\n-#include \"memory\/allStatic.hpp\"\n-#include \"nmt\/memTag.hpp\"\n-#include \"utilities\/debug.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-enum class MallocLimitMode {\n-  trigger_fatal = 0,\n-  trigger_oom   = 1\n-};\n-\n-struct malloclimit {\n-  size_t sz;            \/\/ Limit size\n-  MallocLimitMode mode; \/\/ Behavior flags\n-};\n-\n-\/\/ forward declaration\n-class outputStream;\n-\n-class MallocLimitSet {\n-  malloclimit _glob;                    \/\/ global limit\n-  malloclimit _cat[mt_number_of_tags]; \/\/ per-category limit\n-public:\n-  MallocLimitSet();\n-\n-  void reset();\n-  bool parse_malloclimit_option(const char* optionstring, const char** err);\n-\n-  void set_global_limit(size_t s, MallocLimitMode type);\n-  void set_category_limit(MemTag mem_tag, size_t s, MallocLimitMode mode);\n-\n-  const malloclimit* global_limit() const             { return &_glob; }\n-  const malloclimit* category_limit(MemTag mem_tag) const { return &_cat[(int)mem_tag]; }\n-\n-  void print_on(outputStream* st) const;\n-};\n-\n-class MallocLimitHandler : public AllStatic {\n-  static MallocLimitSet _limits;\n-  static bool _have_limit; \/\/ shortcut\n-\n-public:\n-\n-  static const malloclimit* global_limit()             { return _limits.global_limit(); }\n-  static const malloclimit* category_limit(MemTag mem_tag) { return _limits.category_limit(mem_tag); }\n-\n-  static void initialize(const char* options);\n-  static void print_on(outputStream* st);\n-\n-  \/\/ True if there is any limit established\n-  static bool have_limit() { return _have_limit; }\n-};\n-\n-#endif \/\/ SHARE_SERVICES_MALLOCLIMIT_HPP\n","filename":"src\/hotspot\/share\/nmt\/mallocLimit.hpp","additions":0,"deletions":81,"binary":false,"changes":81,"status":"deleted"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"nmt\/mallocLimit.hpp\"\n@@ -100,55 +99,1 @@\n-  MallocLimitHandler::initialize(MallocLimit);\n-}\n-\n-bool MallocMemorySummary::total_limit_reached(size_t s, size_t so_far, const malloclimit* limit) {\n-\n-#define FORMATTED \\\n-  \"MallocLimit: reached global limit (triggering allocation size: \" PROPERFMT \", allocated so far: \" PROPERFMT \", limit: \" PROPERFMT \") \", \\\n-  PROPERFMTARGS(s), PROPERFMTARGS(so_far), PROPERFMTARGS(limit->sz)\n-\n-  \/\/ If we hit the limit during error reporting, we print a short warning but otherwise ignore it.\n-  \/\/ We don't want to risk recursive assertion or torn hs-err logs.\n-  if (VMError::is_error_reported()) {\n-    \/\/ Print warning, but only the first n times to avoid flooding output.\n-    static int stopafter = 10;\n-    if (stopafter-- > 0) {\n-      log_warning(nmt)(FORMATTED);\n-    }\n-    return false;\n-  }\n-\n-  if (limit->mode == MallocLimitMode::trigger_fatal) {\n-    fatal(FORMATTED);\n-  } else {\n-    log_warning(nmt)(FORMATTED);\n-  }\n-#undef FORMATTED\n-\n-  return true;\n-}\n-\n-bool MallocMemorySummary::category_limit_reached(MemTag mem_tag, size_t s, size_t so_far, const malloclimit* limit) {\n-\n-#define FORMATTED \\\n-  \"MallocLimit: reached category \\\"%s\\\" limit (triggering allocation size: \" PROPERFMT \", allocated so far: \" PROPERFMT \", limit: \" PROPERFMT \") \", \\\n-  NMTUtil::tag_to_enum_name(mem_tag), PROPERFMTARGS(s), PROPERFMTARGS(so_far), PROPERFMTARGS(limit->sz)\n-\n-  \/\/ If we hit the limit during error reporting, we print a short warning but otherwise ignore it.\n-  \/\/ We don't want to risk recursive assertion or torn hs-err logs.\n-  if (VMError::is_error_reported()) {\n-    \/\/ Print warning, but only the first n times to avoid flooding output.\n-    static int stopafter = 10;\n-    if (stopafter-- > 0) {\n-      log_warning(nmt)(FORMATTED);\n-    }\n-    return false;\n-  }\n-\n-  if (limit->mode == MallocLimitMode::trigger_fatal) {\n-    fatal(FORMATTED);\n-  } else {\n-    log_warning(nmt)(FORMATTED);\n-  }\n-#undef FORMATTED\n-\n-  return true;\n+  NMemLimitHandler::initialize(MallocLimit, NMemType::Malloc);\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.cpp","additions":1,"deletions":56,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"nmt\/nMemLimit.hpp\"\n@@ -37,1 +38,1 @@\n-struct malloclimit;\n+struct nMemlimit;\n@@ -211,8 +212,0 @@\n-  \/\/ Called when a total limit break was detected.\n-  \/\/ Will return true if the limit was handled, false if it was ignored.\n-  static bool total_limit_reached(size_t s, size_t so_far, const malloclimit* limit);\n-\n-  \/\/ Called when a total limit break was detected.\n-  \/\/ Will return true if the limit was handled, false if it was ignored.\n-  static bool category_limit_reached(MemTag mem_tag, size_t s, size_t so_far, const malloclimit* limit);\n-\n@@ -261,1 +254,0 @@\n-\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.hpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 2023 SAP SE. All rights reserved.\n- * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_NMT_MALLOCTRACKER_INLINE_HPP\n-#define SHARE_NMT_MALLOCTRACKER_INLINE_HPP\n-\n-#include \"nmt\/mallocLimit.hpp\"\n-#include \"nmt\/mallocTracker.hpp\"\n-#include \"utilities\/debug.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-\/\/ Returns true if allocating s bytes on f would trigger either global or the category limit\n-inline bool MallocMemorySummary::check_exceeds_limit(size_t s, MemTag mem_tag) {\n-\n-  \/\/ Note: checks are ordered to have as little impact as possible on the standard code path,\n-  \/\/ when MallocLimit is unset, resp. it is set but we have reached no limit yet.\n-  \/\/ Somewhat expensive are:\n-  \/\/ - as_snapshot()->total(), total malloc load (requires iteration over arena types)\n-  \/\/ - VMError::is_error_reported() is a load from a volatile.\n-  if (MallocLimitHandler::have_limit()) {\n-\n-    \/\/ Global Limit ?\n-    const malloclimit* l = MallocLimitHandler::global_limit();\n-    if (l->sz > 0) {\n-      size_t so_far = as_snapshot()->total();\n-      if ((so_far + s) > l->sz) { \/\/ hit the limit\n-        return total_limit_reached(s, so_far, l);\n-      }\n-    } else {\n-      \/\/ Category Limit?\n-      l = MallocLimitHandler::category_limit(mem_tag);\n-      if (l->sz > 0) {\n-        const MallocMemory* mm = as_snapshot()->by_tag(mem_tag);\n-        size_t so_far = mm->malloc_size() + mm->arena_size();\n-        if ((so_far + s) > l->sz) {\n-          return category_limit_reached(mem_tag, s, so_far, l);\n-        }\n-      }\n-    }\n-  }\n-\n-  return false;\n-}\n-\n-inline bool MallocTracker::check_exceeds_limit(size_t s, MemTag mem_tag) {\n-  return MallocMemorySummary::check_exceeds_limit(s, mem_tag);\n-}\n-\n-\n-#endif \/\/ SHARE_NMT_MALLOCTRACKER_INLINE_HPP\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.inline.hpp","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"nmt\/mallocLimit.hpp\"\n@@ -82,0 +81,3 @@\n+    if (MmapLimit != nullptr) {\n+      warning(\"MmapLimit will be ignored since NMT is disabled.\");\n+    }\n@@ -95,1 +97,1 @@\n-    MallocLimitHandler::print_on(&ls);\n+    NMemLimitHandler::print_on(&ls);\n@@ -105,1 +107,1 @@\n-    MallocLimitHandler::print_on(output);\n+    NMemLimitHandler::print_on(output);\n@@ -163,1 +165,1 @@\n-  MallocLimitHandler::print_on(out);\n+  NMemLimitHandler::print_on(out);\n","filename":"src\/hotspot\/share\/nmt\/memTracker.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"nmt\/nMemLimit.hpp\"\n@@ -271,1 +272,1 @@\n-  static inline bool check_exceeds_limit(size_t s, MemTag mem_tag);\n+  static inline bool check_exceeds_limit(size_t s, MemTag mem_tag, NMemType type);\n","filename":"src\/hotspot\/share\/nmt\/memTracker.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright (c) 2025 Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -23,1 +24,0 @@\n- *\n@@ -30,0 +30,16 @@\n+#include \"nmt\/nMemLimit.hpp\"\n+#include \"nmt\/mallocTracker.hpp\"\n+#include \"nmt\/virtualMemoryTracker.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"nmt\/nMemoryLimitPrinter.hpp\"\n+#include \"utilities\/vmError.hpp\"\n+#include \"logging\/log.hpp\"\n+\n+\/\/ Returns true if allocating s bytes on f would trigger either global or the category limit\n+inline bool MallocMemorySummary::check_exceeds_limit(size_t s, MemTag mem_tag) {\n+  \/\/ Note: checks are ordered to have as little impact as possible on the standard code path,\n+  \/\/ when MallocLimit is unset, resp. it is set but we have reached no limit yet.\n+  \/\/ Somewhat expensive are:\n+  \/\/ - as_snapshot()->total(), total malloc load (requires iteration over arena types)\n+  \/\/ - category_limit_reached: uses VMError::is_error_reported(), which is a load from a volatile.\n+  if (NMemLimitHandler::have_limit(NMemType::Malloc)) {\n@@ -31,1 +47,52 @@\n-#include \"nmt\/mallocTracker.inline.hpp\"\n+    \/\/ Global Limit ?\n+    const nMemlimit* l = NMemLimitHandler::global_limit(NMemType::Malloc);\n+    if (l->sz > 0) {\n+      size_t so_far = MallocMemorySummary::as_snapshot()->total();\n+      if ((so_far + s) > l->sz) { \/\/ hit the limit\n+        return NMemoryLimitPrinter::total_limit_reached(s, so_far, l, NMemType::Malloc);\n+      }\n+    } else {\n+      \/\/ Category Limit?\n+      l = NMemLimitHandler::category_limit(mem_tag, NMemType::Malloc);\n+      if (l->sz > 0) {\n+        const MallocMemory* mm = MallocMemorySummary::as_snapshot()->by_tag(mem_tag);\n+        size_t so_far = mm->malloc_size() + mm->arena_size();\n+        if ((so_far + s) > l->sz) {\n+          return NMemoryLimitPrinter::category_limit_reached(mem_tag, s, so_far, l, NMemType::Malloc);\n+        }\n+      }\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+\/\/ Returns true if allocating s bytes on f would trigger either global or the category limit\n+inline bool VirtualMemorySummary::check_exceeds_limit(size_t s, MemTag mem_tag) {\n+  \/\/ Note: checks are ordered to have as little impact as possible on the standard code path,\n+  \/\/ when MmapLimit is unset, resp. it is set but we have reached no limit yet.\n+  \/\/ Somewhat expensive are:\n+  \/\/ - as_snapshot()->total_committed()\n+  \/\/ - category_limit_reached: uses VMError::is_error_reported(), which is a load from a volatile.\n+\n+  if (NMemLimitHandler::have_limit(NMemType::Mmap)) {\n+\n+    \/\/ Global Limit ?\n+    const nMemlimit* l = NMemLimitHandler::global_limit(NMemType::Mmap);\n+    if (l->sz > 0) {\n+      size_t so_far = VirtualMemorySummary::as_snapshot()->total_committed();\n+      if ((so_far + s) > l->sz) { \/\/ hit the limit\n+        return NMemoryLimitPrinter::total_limit_reached(s, so_far, l, NMemType::Mmap);\n+      }\n+    } else {\n+      \/\/ Category Limit?\n+      l = NMemLimitHandler::category_limit(mem_tag, NMemType::Mmap);\n+      if (l->sz > 0) {\n+        const VirtualMemory* mm = VirtualMemorySummary::as_snapshot()->by_tag(mem_tag);\n+        size_t so_far = mm->committed();\n+        if ((so_far + s) > l->sz) {\n+          return NMemoryLimitPrinter::category_limit_reached(mem_tag, s, so_far, l, NMemType::Mmap);\n+        }\n+      }\n+    }\n+  }\n@@ -33,1 +100,12 @@\n-inline bool MemTracker::check_exceeds_limit(size_t s, MemTag mem_tag) {\n+  return false;\n+}\n+\n+inline bool MallocTracker::check_exceeds_limit(size_t s, MemTag mem_tag) {\n+  return MallocMemorySummary::check_exceeds_limit(s, mem_tag);\n+}\n+\n+inline bool VirtualMemoryTracker::check_exceeds_limit(size_t s, MemTag mem_tag) {\n+  return VirtualMemorySummary::check_exceeds_limit(s, mem_tag);\n+}\n+\n+inline bool MemTracker::check_exceeds_limit(size_t s, MemTag mem_tag, NMemType type) {\n@@ -37,1 +115,8 @@\n-  return MallocTracker::check_exceeds_limit(s, mem_tag);\n+\n+  if (NMemType::Malloc == type) {\n+    return MallocTracker::check_exceeds_limit(s, mem_tag);\n+  } else if (NMemType::Mmap == type) {\n+    return VirtualMemoryTracker::check_exceeds_limit(s, mem_tag);\n+  } else {\n+    ShouldNotReachHere();\n+  }\n","filename":"src\/hotspot\/share\/nmt\/memTracker.inline.hpp","additions":89,"deletions":4,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -0,0 +1,265 @@\n+\/*\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Amazon.com Inc and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"nmt\/nMemLimit.hpp\"\n+#include \"nmt\/memTag.hpp\"\n+#include \"nmt\/nmtCommon.hpp\"\n+#include \"runtime\/java.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/parseInteger.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"logging\/log.hpp\"\n+\n+NMemLimitSet NMemLimitHandler::_malloc_limits;\n+NMemLimitSet NMemLimitHandler::_mmap_limits;\n+bool NMemLimitHandler::_have_limit_map[2] = {false, false};\n+\n+static const char* const MODE_OOM = \"oom\";\n+static const char* const MODE_FATAL = \"fatal\";\n+\n+static const char* mode_to_name(NMemLimitMode m) {\n+  switch (m) {\n+  case NMemLimitMode::trigger_fatal: return MODE_FATAL;\n+  case NMemLimitMode::trigger_oom: return MODE_OOM;\n+  default: ShouldNotReachHere();\n+  };\n+  return nullptr;\n+}\n+\n+class ParserHelper {\n+  \/\/ Start, end of parsed string.\n+  const char* const _s;\n+  const char* const _end;\n+  \/\/ Current parse position.\n+  const char* _p;\n+\n+public:\n+  ParserHelper(const char* s) : _s(s), _end(s + strlen(s)), _p(s) {}\n+\n+  bool eof() const { return _p >= _end; }\n+\n+  \/\/ Check if string at position matches a malloclimit_mode_t.\n+  \/\/ Advance position on match.\n+  bool match_mode_flag(NMemLimitMode* out) {\n+    if (eof()) {\n+      return false;\n+    }\n+    if (strncasecmp(_p, MODE_OOM, strlen(MODE_OOM)) == 0) {\n+      *out = NMemLimitMode::trigger_oom;\n+      _p += 3;\n+      return true;\n+    } else if (strncasecmp(_p, MODE_FATAL, strlen(MODE_FATAL)) == 0) {\n+      *out = NMemLimitMode::trigger_fatal;\n+      _p += 5;\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  \/\/ Check if string at position matches a category name.\n+  \/\/ Advances position on match.\n+  bool match_category(MemTag* out) {\n+    if (eof()) {\n+      return false;\n+    }\n+    const char* end = strchr(_p, ':');\n+    if (end == nullptr) {\n+      end = _end;\n+    }\n+    stringStream ss;\n+    ss.print(\"%.*s\", (int)(end - _p), _p);\n+    MemTag mem_tag = NMTUtil::string_to_mem_tag(ss.base());\n+    if (mem_tag != mtNone) {\n+      *out = mem_tag;\n+      _p = end;\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  \/\/ Check if string at position matches a memory size (e.g. \"100\", \"100g\" etc).\n+  \/\/ Advances position on match.\n+  bool match_size(size_t* out) {\n+    if (!eof()) {\n+      char* remainder = nullptr;\n+      if (parse_integer<size_t>(_p, &remainder, out)) {\n+        assert(remainder > _p && remainder <= _end, \"sanity\");\n+        _p = remainder;\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  \/\/ Check if char at pos matches c; return true and advance pos if so.\n+  bool match_char(char c) {\n+    if (!eof() && (*_p) == c) {\n+      _p ++;\n+      return true;\n+    }\n+    return false;\n+  }\n+};\n+\n+NMemLimitSet::NMemLimitSet() {\n+  reset();\n+}\n+\n+void NMemLimitSet::set_global_limit(size_t s, NMemLimitMode flag) {\n+  _glob.sz = s; _glob.mode = flag;\n+}\n+\n+void NMemLimitSet::set_category_limit(MemTag mem_tag, size_t s, NMemLimitMode flag) {\n+  const int i = NMTUtil::tag_to_index(mem_tag);\n+  _cat[i].sz = s; _cat[i].mode = flag;\n+}\n+\n+void NMemLimitSet::reset() {\n+  set_global_limit(0, NMemLimitMode::trigger_fatal);\n+  _glob.sz = 0; _glob.mode = NMemLimitMode::trigger_fatal;\n+  for (int i = 0; i < mt_number_of_tags; i++) {\n+    set_category_limit(NMTUtil::index_to_tag(i), 0, NMemLimitMode::trigger_fatal);\n+  }\n+}\n+\n+void NMemLimitSet::print_on(outputStream* st, const char* type_str) const {\n+  static const char* flagnames[] = { MODE_FATAL, MODE_OOM };\n+  if (_glob.sz > 0) {\n+    st->print_cr(\"%sLimit: total limit: \" PROPERFMT \" (%s)\", type_str, PROPERFMTARGS(_glob.sz),\n+                 mode_to_name(_glob.mode));\n+  } else {\n+    for (int i = 0; i < mt_number_of_tags; i++) {\n+      if (_cat[i].sz > 0) {\n+        st->print_cr(\"%sLimit: category \\\"%s\\\" limit: \" PROPERFMT \" (%s)\",\n+                     type_str, NMTUtil::tag_to_enum_name(NMTUtil::index_to_tag(i)),\n+                     PROPERFMTARGS(_cat[i].sz), mode_to_name(_cat[i].mode));\n+      }\n+    }\n+  }\n+}\n+\n+bool NMemLimitSet::parse_n_mem_limit_option(const char* v, const char** err) {\n+\n+#define BAIL_UNLESS(condition, errormessage) if (!(condition)) { *err = errormessage; return false; }\n+\n+  \/\/ Global form:\n+  \/\/ MallocLimit=<size>[:flag] or MmapLimit=<size>[:flag]\n+\n+  \/\/ Category-specific form:\n+  \/\/ MallocLimit=<category>:<size>[:flag][,<category>:<size>[:flag]...]\n+  \/\/ or, MmapLimit=<category>:<size>[:flag][,<category>:<size>[:flag]...]\n+\n+  reset();\n+\n+  ParserHelper sst(v);\n+\n+  BAIL_UNLESS(!sst.eof(), \"Empty string\");\n+\n+  \/\/ Global form?\n+  if (sst.match_size(&_glob.sz)) {\n+    \/\/ Match optional mode flag (e.g. 1g:oom)\n+    if (!sst.eof()) {\n+      BAIL_UNLESS(sst.match_char(':'), \"Expected colon\");\n+      BAIL_UNLESS(sst.match_mode_flag(&_glob.mode), \"Expected flag\");\n+    }\n+  }\n+  \/\/ Category-specific form?\n+  else {\n+    while (!sst.eof()) {\n+      MemTag mem_tag;\n+\n+      \/\/ Match category, followed by :\n+      BAIL_UNLESS(sst.match_category(&mem_tag), \"Expected category name\");\n+      BAIL_UNLESS(sst.match_char(':'), \"Expected colon following category\");\n+\n+      nMemlimit* const modified_limit = &_cat[NMTUtil::tag_to_index(mem_tag)];\n+\n+      \/\/ Match size\n+      BAIL_UNLESS(sst.match_size(&modified_limit->sz), \"Expected size\");\n+\n+      \/\/ Match optional flag\n+      if (!sst.eof() && sst.match_char(':')) {\n+        BAIL_UNLESS(sst.match_mode_flag(&modified_limit->mode), \"Expected flag\");\n+      }\n+\n+      \/\/ More to come?\n+      if (!sst.eof()) {\n+        BAIL_UNLESS(sst.match_char(','), \"Expected comma\");\n+      }\n+    }\n+  }\n+  return true;\n+}\n+\n+void NMemLimitHandler::initialize(const char* options, NMemType type) {\n+  log_info(nmt)(\"in NMemLimitHandler initialize. type: %s\", NMemLimitHandler::nmem_type_to_str(type));\n+  _have_limit_map[nmemtype_to_int(type)] = false;\n+  NMemLimitSet* limits = get_mem_limit_set(type);\n+\n+  if (options != nullptr && options[0] != '\\0') {\n+    const char* err = nullptr;\n+    if (!limits->parse_n_mem_limit_option(options, &err)) {\n+      vm_exit_during_initialization(\"Failed to parse MallocLimit\", err);\n+    }\n+    _have_limit_map[nmemtype_to_int(type)] = true;\n+  }\n+}\n+\n+void NMemLimitHandler::print_on(outputStream* st) {\n+  NMemLimitHandler::print_on_by_type(st, NMemType::Malloc);\n+  NMemLimitHandler::print_on_by_type(st, NMemType::Mmap);\n+}\n+\n+void NMemLimitHandler::print_on_by_type(outputStream* st, NMemType type) {\n+  NMemLimitSet* limits = get_mem_limit_set(type);\n+\n+  if (have_limit(type)) {\n+    limits->print_on(st, NMemLimitHandler::nmem_type_to_str(type));\n+  } else {\n+    st->print_cr(\"%sLimit: unset\", NMemLimitHandler::nmem_type_to_str(type));\n+  }\n+}\n+\n+int NMemLimitHandler::nmemtype_to_int(NMemType type) {\n+  if (NMemType::Malloc == type) {\n+    return 0;\n+  } else if (NMemType::Mmap == type) {\n+    return 1;\n+  } else {\n+    ShouldNotReachHere();\n+  }\n+}\n+\n+const char* NMemLimitHandler::nmem_type_to_str(NMemType type) { \/\/ TODO: use snake name\n+  switch (type) {\n+    case NMemType::Malloc: return \"Malloc\";\n+    case NMemType::Mmap: return \"Mmap\";\n+    default: ShouldNotReachHere();\n+  }\n+  ShouldNotReachHere();\n+}\n+\n","filename":"src\/hotspot\/share\/nmt\/nMemLimit.cpp","additions":265,"deletions":0,"binary":false,"changes":265,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025 Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_NMT_NMEMLIMIT_HPP\n+#define SHARE_NMT_NMEMLIMIT_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"nmt\/memTag.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+enum class NMemType : int {\n+  Malloc,\n+  Mmap\n+};\n+\n+enum class NMemLimitMode {\n+  trigger_fatal = 0,\n+  trigger_oom   = 1\n+};\n+\n+struct nMemlimit {\n+  size_t sz;            \/\/ Limit size\n+  NMemLimitMode mode; \/\/ Behavior flags\n+};\n+\n+\/\/ forward declaration\n+class outputStream;\n+\n+class NMemLimitSet {\n+  nMemlimit _glob;                    \/\/ global limit\n+  nMemlimit _cat[mt_number_of_tags]; \/\/ per-category limit\n+public:\n+  NMemLimitSet();\n+\n+  void reset();\n+  bool parse_n_mem_limit_option(const char* optionstring, const char** err);\n+\n+  void set_global_limit(size_t s, NMemLimitMode type);\n+  void set_category_limit(MemTag mem_tag, size_t s, NMemLimitMode mode);\n+\n+  const nMemlimit* global_limit() const             { return &_glob; }\n+  const nMemlimit* category_limit(MemTag mem_tag) const { return &_cat[(int)mem_tag]; }\n+\n+  void print_on(outputStream* st, const char* type_str) const;\n+};\n+\n+class NMemLimitHandler : public AllStatic {\n+private:\n+  static NMemLimitSet* get_mem_limit_set(NMemType type) {\n+    if (NMemType::Malloc == type) {\n+      return &_malloc_limits;\n+    } else if (NMemType::Mmap == type) {\n+      return &_mmap_limits;\n+    } else {\n+      ShouldNotReachHere();\n+    }\n+  }\n+protected:\n+  static NMemLimitSet _malloc_limits;\n+  static NMemLimitSet _mmap_limits;\n+  static bool _have_limit_map[2]; \/\/ A map mapping from NMemType to whether it has limit set\n+\n+public:\n+  static const nMemlimit* global_limit(NMemType type)             { return get_mem_limit_set(type)->global_limit(); }\n+  static const nMemlimit* category_limit(MemTag mem_tag, NMemType type) { return get_mem_limit_set(type)->category_limit(mem_tag); }\n+\n+  static void initialize(const char* options, NMemType type);\n+  static void print_on_by_type(outputStream* st, NMemType type);\n+  static void print_on(outputStream* st);\n+  static const char* nmem_type_to_str(NMemType type);\n+  static int nmemtype_to_int(NMemType type);\n+\n+  \/\/ True if there is any limit established\n+  static bool have_limit(NMemType type) {\n+    return _have_limit_map[nmemtype_to_int(type)];\n+  }\n+};\n+\n+#endif\n","filename":"src\/hotspot\/share\/nmt\/nMemLimit.hpp","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2025 Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"nmt\/nMemoryLimitPrinter.hpp\"\n+#include \"utilities\/vmError.hpp\"\n+\n+bool NMemoryLimitPrinter::total_limit_reached(size_t s, size_t so_far, const nMemlimit* limit, const NMemType type) {\n+\n+  const char* typeStr = NMemLimitHandler::nmem_type_to_str(type);\n+\n+  #define FORMATTED \\\n+  \"%sLimit: reached global limit (triggering allocation size: \" PROPERFMT \", allocated so far: \" PROPERFMT \", limit: \" PROPERFMT \") \", \\\n+  typeStr, PROPERFMTARGS(s), PROPERFMTARGS(so_far), PROPERFMTARGS(limit->sz)\n+\n+  \/\/ If we hit the limit during error reporting, we print a short warning but otherwise ignore it.\n+  \/\/ We don't want to risk recursive assertion or torn hs-err logs.\n+  if (VMError::is_error_reported()) {\n+    \/\/ Print warning, but only the first n times to avoid flooding output.\n+    static int stopafter = 10;\n+    if (stopafter-- > 0) {\n+      log_warning(nmt)(FORMATTED);\n+    }\n+    return false;\n+  }\n+\n+  if (limit->mode == NMemLimitMode::trigger_fatal) {\n+    fatal(FORMATTED);\n+  } else {\n+    log_warning(nmt)(FORMATTED);\n+  }\n+#undef FORMATTED\n+\n+  return true;\n+}\n+\n+bool NMemoryLimitPrinter::category_limit_reached(MemTag mem_tag, size_t s, size_t so_far, const nMemlimit* limit, const NMemType type) {\n+\n+  const char* typeStr = NMemLimitHandler::nmem_type_to_str(type);\n+\n+  #define FORMATTED \\\n+    \"%sLimit: reached category \\\"%s\\\" limit (triggering allocation size: \" PROPERFMT \", allocated so far: \" PROPERFMT \", limit: \" PROPERFMT \") \", \\\n+    typeStr, NMTUtil::tag_to_enum_name(mem_tag), PROPERFMTARGS(s), PROPERFMTARGS(so_far), PROPERFMTARGS(limit->sz)\n+\n+    \/\/ If we hit the limit during error reporting, we print a short warning but otherwise ignore it.\n+    \/\/ We don't want to risk recursive assertion or torn hs-err logs.\n+    if (VMError::is_error_reported()) {\n+      \/\/ Print warning, but only the first n times to avoid flooding output.\n+      static int stopafter = 10;\n+      if (stopafter-- > 0) {\n+        log_warning(nmt)(FORMATTED);\n+      }\n+      return false;\n+    }\n+\n+    if (limit->mode == NMemLimitMode::trigger_fatal) {\n+      fatal(FORMATTED);\n+    } else {\n+      log_warning(nmt)(FORMATTED);\n+    }\n+  #undef FORMATTED\n+\n+    return true;\n+}\n+\n","filename":"src\/hotspot\/share\/nmt\/nMemoryLimitPrinter.cpp","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2025 Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_NMT_NMEMORYLIMITPRINTER_HPP\n+#define SHARE_NMT_NMEMORYLIMITPRINTER_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"nmt\/nMemLimit.hpp\"\n+\n+class NMemoryLimitPrinter : public AllStatic {\n+\n+public:\n+  \/\/ Called when a total limit break was detected.\n+  \/\/ Will return true if the limit was handled, false if it was ignored.\n+  static bool total_limit_reached(size_t s, size_t so_far, const nMemlimit* limit, const NMemType type);\n+\n+  \/\/ Called when a category limit break was detected.\n+  \/\/ Will return true if the limit was handled, false if it was ignored.\n+  static bool category_limit_reached(MemTag mem_tag, size_t s, size_t so_far, const nMemlimit* limit, const NMemType type);\n+};\n+\n+#endif\n","filename":"src\/hotspot\/share\/nmt\/nMemoryLimitPrinter.hpp","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"nmt\/memTracker.inline.hpp\"\n+#include \"nmt\/nMemLimit.hpp\"\n@@ -33,0 +35,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -145,0 +148,4 @@\n+  if (MemTracker::check_exceeds_limit(size, mem_tag(), NMemType::Mmap)) {\n+    vm_exit_out_of_memory(size, OOM_MMAP_ERROR, \"ReservedMemoryRegion::add_committed_region\");\n+  }\n+\n@@ -299,1 +306,6 @@\n-    VirtualMemorySummary::move_committed_memory(mem_tag(), new_mem_tag, committed_size());\n+\n+    size_t committed_size = ReservedMemoryRegion::committed_size();\n+    VirtualMemorySummary::move_committed_memory(mem_tag(), new_mem_tag, committed_size);\n+    if (MemTracker::check_exceeds_limit(committed_size, new_mem_tag, NMemType::Mmap)) {\n+      vm_exit_out_of_memory(committed_size, OOM_MMAP_ERROR, \"ReservedMemoryRegion::set_mem_tag\");\n+    }\n@@ -329,1 +341,2 @@\n-    return (_reserved_regions != nullptr);\n+      NMemLimitHandler::initialize(MmapLimit, NMemType::Mmap);\n+      return (_reserved_regions != nullptr);\n@@ -588,1 +601,0 @@\n-\n","filename":"src\/hotspot\/share\/nmt\/virtualMemoryTracker.cpp","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"nmt\/nMemLimit.hpp\"\n@@ -173,0 +174,5 @@\n+  \/\/ MmapLimt: Given an allocation size s, check if mmaping this much\n+  \/\/ for MemTag would hit either the global limit or the limit for MemTag.\n+  static inline bool check_exceeds_limit(size_t s, MemTag mem_tag);\n+\n+\n@@ -406,0 +412,2 @@\n+  static bool check_exceeds_limit(size_t s, MemTag mem_tag);\n+\n","filename":"src\/hotspot\/share\/nmt\/virtualMemoryTracker.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1339,0 +1339,17 @@\n+  product(ccstr, MmapLimit, nullptr, DIAGNOSTIC,                            \\\n+          \"Limit mmap allocation size from VM. Reaching a limit will \"      \\\n+          \"trigger an action (see flag). This feature requires \"            \\\n+          \"NativeMemoryTracking=summary or NativeMemoryTracking=detail.\"    \\\n+          \"Usage:\"                                                          \\\n+          \"\\\"-XX:MmapLimit=<size>[:<flag>]\\\" sets a total limit.\"           \\\n+          \"\\\"-XX:MmapLimit=<category>:<size>[:<flag>][,<category>:<size>[:<flag>] ...]\\\"\" \\\n+          \"sets one or more category-specific limits.\"                      \\\n+          \"<flag> defines the action upon reaching the limit:\"              \\\n+          \"\\\"fatal\\\": end VM with a fatal error at the allocation site\"     \\\n+          \"\\\"oom\\\"  : will mimic a native OOM\"                              \\\n+          \"If <flag> is omitted, \\\"fatal\\\" is the default.\"                 \\\n+        \"Examples:\\n\"                                                       \\\n+          \"-XX:MmapLimit=2g\"                                                \\\n+          \"-XX:MmapLimit=2g:oom\"                                            \\\n+          \"-XX:MmapLimit=gc:200m:oom,code:100m\")                            \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -646,1 +646,1 @@\n-  if (MemTracker::check_exceeds_limit(size, mem_tag)) {\n+  if (MemTracker::check_exceeds_limit(size, mem_tag, NMemType::Malloc)) {\n@@ -710,1 +710,1 @@\n-    if ((size > old_size) && MemTracker::check_exceeds_limit(size - old_size, mem_tag)) {\n+    if ((size > old_size) && MemTracker::check_exceeds_limit(size - old_size, mem_tag, NMemType::Malloc)) {\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"nmt\/mallocLimit.hpp\"\n@@ -28,0 +27,1 @@\n+#include \"nmt\/nMemLimit.hpp\"\n@@ -38,1 +38,1 @@\n-static bool compare_limits(const malloclimit* a, const malloclimit* b) {\n+static bool compare_limits(const nMemlimit* a, const nMemlimit* b) {\n@@ -42,1 +42,1 @@\n-static bool compare_sets(const MallocLimitSet* a, const MallocLimitSet* b) {\n+static bool compare_sets(const NMemLimitSet* a, const NMemLimitSet* b) {\n@@ -54,2 +54,2 @@\n-static void test(const char* s, const MallocLimitSet& expected) {\n-  MallocLimitSet set;\n+static void test(const char* s, const NMemLimitSet& expected) {\n+  NMemLimitSet set;\n@@ -57,1 +57,1 @@\n-  EXPECT_TRUE(set.parse_malloclimit_option(s, &err)) << err;\n+  EXPECT_TRUE(set.parse_n_mem_limit_option(s, &err)) << err;\n@@ -62,1 +62,1 @@\n-  MallocLimitSet expected;\n+  NMemLimitSet expected;\n@@ -64,1 +64,1 @@\n-  expected.set_global_limit(1 * G, MallocLimitMode::trigger_fatal);\n+  expected.set_global_limit(1 * G, NMemLimitMode::trigger_fatal);\n@@ -73,1 +73,1 @@\n-  expected.set_global_limit(2 * M, MallocLimitMode::trigger_oom);\n+  expected.set_global_limit(2 * M, NMemLimitMode::trigger_oom);\n@@ -80,1 +80,1 @@\n-  MallocLimitSet expected;\n+  NMemLimitSet expected;\n@@ -82,1 +82,1 @@\n-  expected.set_category_limit(mtMetaspace, 1 * M, MallocLimitMode::trigger_fatal);\n+  expected.set_category_limit(mtMetaspace, 1 * M, NMemLimitMode::trigger_fatal);\n@@ -87,5 +87,5 @@\n-  expected.set_category_limit(mtCompiler, 2 * M, MallocLimitMode::trigger_oom);\n-  expected.set_category_limit(mtThread, 3 * M, MallocLimitMode::trigger_oom);\n-  expected.set_category_limit(mtThreadStack, 4 * M, MallocLimitMode::trigger_oom);\n-  expected.set_category_limit(mtClass, 5 * M, MallocLimitMode::trigger_fatal);\n-  expected.set_category_limit(mtClassShared, 6 * M, MallocLimitMode::trigger_fatal);\n+  expected.set_category_limit(mtCompiler, 2 * M, NMemLimitMode::trigger_oom);\n+  expected.set_category_limit(mtThread, 3 * M, NMemLimitMode::trigger_oom);\n+  expected.set_category_limit(mtThreadStack, 4 * M, NMemLimitMode::trigger_oom);\n+  expected.set_category_limit(mtClass, 5 * M, NMemLimitMode::trigger_fatal);\n+  expected.set_category_limit(mtClassShared, 6 * M, NMemLimitMode::trigger_fatal);\n@@ -96,1 +96,1 @@\n-  MallocLimitSet expected;\n+  NMemLimitSet expected;\n@@ -101,1 +101,1 @@\n-      expected.set_category_limit(mem_tag, (i + 1) * M, MallocLimitMode::trigger_fatal);\n+      expected.set_category_limit(mem_tag, (i + 1) * M, NMemLimitMode::trigger_fatal);\n@@ -109,1 +109,1 @@\n-  MallocLimitSet expected;\n+  NMemLimitSet expected;\n@@ -114,1 +114,1 @@\n-      expected.set_category_limit(mem_tag, (i + 1) * M, MallocLimitMode::trigger_fatal);\n+      expected.set_category_limit(mem_tag, (i + 1) * M, NMemLimitMode::trigger_fatal);\n@@ -122,1 +122,1 @@\n-  MallocLimitSet set;\n+  NMemLimitSet set;\n@@ -124,1 +124,1 @@\n-  ASSERT_FALSE(set.parse_malloclimit_option(s, &err));\n+  ASSERT_FALSE(set.parse_n_mem_limit_option(s, &err));\n@@ -142,1 +142,1 @@\n-  MallocLimitHandler::initialize(\"test:100m:fatal\");\n+  NMemLimitHandler::initialize(\"test:100m:fatal\", NMemType::Malloc);\n@@ -153,1 +153,1 @@\n-  MallocLimitHandler::initialize(\"test:10m:fatal\");\n+  NMemLimitHandler::initialize(\"test:10m:fatal\", NMemType::Malloc);\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_malloclimit.cpp","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -1,176 +0,0 @@\n-\/*\n- * Copyright (c) 2022 SAP SE. All rights reserved.\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/*\n- * @test id=global-limit-fatal\n- * @summary Verify -XX:MallocLimit with a global limit\n- * @requires vm.flagless\n- * @modules java.base\/jdk.internal.misc\n- * @library \/test\/lib\n- * @run driver MallocLimitTest global-limit-fatal\n- *\/\n-\n-\/*\n- * @test id=global-limit-oom\n- * @summary Verify -XX:MallocLimit with a global limit\n- * @requires vm.flagless\n- * @modules java.base\/jdk.internal.misc\n- * @library \/test\/lib\n- * @run driver MallocLimitTest global-limit-oom\n- *\/\n-\n-\/*\n- * @test id=compiler-limit-fatal\n- * @summary Verify -XX:MallocLimit with a compiler-specific limit (for \"mtCompiler\" category)\n- * @requires vm.flagless\n- * @modules java.base\/jdk.internal.misc\n- * @library \/test\/lib\n- * @run driver MallocLimitTest compiler-limit-fatal\n- *\/\n-\n-\/*\n- * @test id=compiler-limit-oom\n- * @summary Verify -XX:MallocLimit with a compiler-specific limit (for \"mtCompiler\" category)\n- * @requires vm.flagless\n- * @modules java.base\/jdk.internal.misc\n- * @library \/test\/lib\n- * @run driver MallocLimitTest compiler-limit-oom\n- *\/\n-\n-\/*\n- * @test id=multi-limit\n- * @summary Verify -XX:MallocLimit with multiple limits\n- * @requires vm.flagless\n- * @modules java.base\/jdk.internal.misc\n- * @library \/test\/lib\n- * @run driver MallocLimitTest multi-limit\n- *\/\n-\n-\/*\n- * @test id=limit-without-nmt\n- * @summary Verify that the VM warns if -XX:MallocLimit is given but NMT is disabled\n- * @requires vm.flagless\n- * @modules java.base\/jdk.internal.misc\n- * @library \/test\/lib\n- * @run driver MallocLimitTest limit-without-nmt\n- *\/\n-\n-\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-\n-public class MallocLimitTest {\n-\n-    private static ProcessBuilder processBuilderWithSetting(String... extraSettings) {\n-        List<String> args = new ArrayList<>();\n-        args.add(\"-XX:+UnlockDiagnosticVMOptions\"); \/\/ MallocLimit is diagnostic\n-        args.add(\"-Xmx64m\");\n-        args.add(\"-XX:-CreateCoredumpOnCrash\");\n-        args.add(\"-Xlog:nmt\");\n-        args.add(\"-XX:NativeMemoryTracking=summary\");\n-        args.addAll(Arrays.asList(extraSettings));\n-        args.add(\"-version\");\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(args);\n-        return pb;\n-    }\n-\n-    private static void testGlobalLimitFatal() throws IOException {\n-        ProcessBuilder pb = processBuilderWithSetting(\"-XX:MallocLimit=1m\");\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-        output.shouldNotHaveExitValue(0);\n-        output.shouldContain(\"[nmt] MallocLimit: total limit: 1024K (fatal)\");\n-        output.shouldMatch(\"#  fatal error: MallocLimit: reached global limit \\\\(triggering allocation size: \\\\d+[BKM], allocated so far: \\\\d+[BKM], limit: 1024K\\\\)\");\n-    }\n-\n-    private static void testGlobalLimitOOM() throws IOException {\n-        ProcessBuilder pb = processBuilderWithSetting(\"-XX:MallocLimit=1m:oom\");\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-        output.shouldNotHaveExitValue(0);\n-        output.shouldContain(\"[nmt] MallocLimit: total limit: 1024K (oom)\");\n-        output.shouldMatch(\".*\\\\[warning\\\\]\\\\[nmt\\\\] MallocLimit: reached global limit \\\\(triggering allocation size: \\\\d+[BKM], allocated so far: \\\\d+[BKM], limit: 1024K\\\\)\");\n-        \/\/ The rest is fuzzy. We may get SIGSEGV or a native OOM message, depending on how the failing allocation was handled.\n-    }\n-\n-    private static void testCompilerLimitFatal() throws IOException {\n-        ProcessBuilder pb = processBuilderWithSetting(\"-XX:MallocLimit=compiler:1234k\", \"-Xcomp\");\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-        output.shouldNotHaveExitValue(0);\n-        output.shouldContain(\"[nmt] MallocLimit: category \\\"mtCompiler\\\" limit: 1234K (fatal)\");\n-        output.shouldMatch(\"#  fatal error: MallocLimit: reached category \\\"mtCompiler\\\" limit \\\\(triggering allocation size: \\\\d+[BKM], allocated so far: \\\\d+[BKM], limit: 1234K\\\\)\");\n-    }\n-\n-    private static void testCompilerLimitOOM() throws IOException {\n-        ProcessBuilder pb = processBuilderWithSetting(\"-XX:MallocLimit=compiler:1234k:oom\", \"-Xcomp\");\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-        output.shouldNotHaveExitValue(0);\n-        output.shouldContain(\"[nmt] MallocLimit: category \\\"mtCompiler\\\" limit: 1234K (oom)\");\n-        output.shouldMatch(\".*\\\\[warning\\\\]\\\\[nmt\\\\] MallocLimit: reached category \\\"mtCompiler\\\" limit \\\\(triggering allocation size: \\\\d+[BKM], allocated so far: \\\\d+[BKM], limit: 1234K\\\\)\");\n-        \/\/ The rest is fuzzy. We may get SIGSEGV or a native OOM message, depending on how the failing allocation was handled.\n-    }\n-\n-    private static void testMultiLimit() throws IOException {\n-        ProcessBuilder pb = processBuilderWithSetting(\"-XX:MallocLimit=other:2g,compiler:1g:oom,internal:1k\");\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-        output.shouldNotHaveExitValue(0);\n-        output.shouldContain(\"[nmt] MallocLimit: category \\\"mtCompiler\\\" limit: 1024M (oom)\");\n-        output.shouldContain(\"[nmt] MallocLimit: category \\\"mtInternal\\\" limit: 1024B (fatal)\");\n-        output.shouldContain(\"[nmt] MallocLimit: category \\\"mtOther\\\" limit: 2048M (fatal)\");\n-        output.shouldMatch(\"#  fatal error: MallocLimit: reached category \\\"mtInternal\\\" limit \\\\(triggering allocation size: \\\\d+[BKM], allocated so far: \\\\d+[BKM], limit: 1024B\\\\)\");\n-    }\n-\n-    private static void testLimitWithoutNmt() throws IOException {\n-        ProcessBuilder pb = processBuilderWithSetting(\"-XX:NativeMemoryTracking=off\", \/\/ overrides \"summary\" from processBuilderWithSetting()\n-                \"-XX:MallocLimit=3g\");\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-        output.reportDiagnosticSummary();\n-        output.shouldHaveExitValue(0); \/\/ Not a fatal error, just a warning\n-        output.shouldContain(\"MallocLimit will be ignored since NMT is disabled\");\n-    }\n-\n-    public static void main(String args[]) throws Exception {\n-\n-        if (args[0].equals(\"global-limit-fatal\")) {\n-            testGlobalLimitFatal();\n-        } else if (args[0].equals(\"global-limit-oom\")) {\n-            testGlobalLimitOOM();\n-        } else if (args[0].equals(\"compiler-limit-fatal\")) {\n-            testCompilerLimitFatal();\n-        } else if (args[0].equals(\"compiler-limit-oom\")) {\n-            testCompilerLimitOOM();\n-        } else if (args[0].equals(\"multi-limit\")) {\n-            testMultiLimit();\n-        } else if (args[0].equals(\"limit-without-nmt\")) {\n-            testLimitWithoutNmt();\n-        } else {\n-            throw new RuntimeException(\"invalid test: \" + args[0]);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/MallocLimitTest.java","additions":0,"deletions":176,"binary":false,"changes":176,"status":"deleted"},{"patch":"@@ -0,0 +1,285 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test id=global-limit-fatal\n+ * @summary Verify -XX:MallocLimit \/ -XX:MmapLimit with a global limit\n+ * @requires vm.flagless\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver NMemLimitTest global-limit-fatal\n+ *\/\n+\n+\/*\n+ * @test id=global-limit-oom\n+ * @summary Verify -XX:MallocLimit \/ -XX:MmapLimit with a global limit\n+ * @requires vm.flagless\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver NMemLimitTest global-limit-oom\n+ *\/\n+\n+\/*\n+ * @test id=compiler-limit-fatal\n+ * @summary Verify -XX:MallocLimit with a compiler-specific limit (for \"mtCompiler\" category)\n+ * @requires vm.flagless\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver NMemLimitTest compiler-limit-fatal\n+ *\/\n+\n+\/*\n+ * @test id=compiler-limit-oom\n+ * @summary Verify -XX:MallocLimit \/ -XX:MmapLimit with a compiler-specific limit (for \"mtCompiler\" category)\n+ * @requires vm.flagless\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver NMemLimitTest compiler-limit-oom\n+ *\/\n+\n+\/*\n+ * @test id=gc-limit-fatal\n+ * @summary Verify -XX:MallocLimit \/ -XX:MmapLimit with a gc-specific limit (for \"mtGC\" category)\n+ * @requires vm.flagless\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver NMemLimitTest gc-limit-fatal\n+ *\/\n+\n+\/*\n+ * @test id=gc-limit-oom\n+ * @summary Verify -XX:MallocLimit \/ -XX:MmapLimit with a gc-specific limit (for \"mtGC\" category)\n+ * @requires vm.flagless\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver NMemLimitTest gc-limit-oom\n+ *\/\n+\n+\/*\n+ * @test id=malloc-mmap-limit-mix-malloc-fatal\n+ * @summary Verify -XX:MallocLimit & -XX:MmapLimit with a gc-specific limit (for \"mtGC\" category)\n+ * @requires vm.flagless\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver NMemLimitTest malloc-mmap-limit-mix-malloc-fatal\n+ *\/\n+\n+\/*\n+ * @test id=malloc-mmap-limit-mix-mmap-fatal\n+ * @summary Verify -XX:MallocLimit & -XX:MmapLimit with a gc-specific limit (for \"mtGC\" category)\n+ * @requires vm.flagless\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver NMemLimitTest malloc-mmap-limit-mix-mmap-fatal\n+ *\/\n+\n+\/*\n+ * @test id=malloc-mmap-limit-mix-neither-failed\n+ * @summary Verify -XX:MallocLimit & -XX:MmapLimit with a gc-specific limit (for \"mtGC\" category)\n+ * @requires vm.flagless\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver NMemLimitTest malloc-mmap-limit-mix-neither-failed\n+ *\/\n+\n+\/*\n+ * @test id=multi-limit\n+ * @summary Verify -XX:MallocLimit \/ -XX:MmapLimit with multiple limits\n+ * @requires vm.flagless\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver NMemLimitTest multi-limit\n+ *\/\n+\n+\/*\n+ * @test id=limit-without-nmt\n+ * @summary Verify that the VM warns if -XX:MallocLimit \/ -XX:MmapLimit is given but NMT is disabled\n+ * @requires vm.flagless\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver NMemLimitTest limit-without-nmt\n+ *\/\n+\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class NMemLimitTest {\n+\n+    private static ProcessBuilder processBuilderWithSetting(String... extraSettings) {\n+        List<String> args = new ArrayList<>();\n+        args.add(\"-XX:+UnlockDiagnosticVMOptions\"); \/\/ MallocLimit is diagnostic\n+        args.add(\"-Xmx64m\");\n+        args.add(\"-XX:-CreateCoredumpOnCrash\");\n+        args.add(\"-Xlog:nmt\");\n+        args.add(\"-XX:NativeMemoryTracking=summary\");\n+        args.addAll(Arrays.asList(extraSettings));\n+        args.add(\"-version\");\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(args);\n+        return pb;\n+    }\n+\n+    private enum LimitType {\n+        Malloc,\n+        Mmap\n+    }\n+\n+    private static void testGlobalLimitFatal(LimitType type) throws IOException {\n+        ProcessBuilder pb = processBuilderWithSetting(String.format(\"-XX:%sLimit=1m\", type.toString()));\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldNotHaveExitValue(0);\n+        output.shouldContain(String.format(\"[nmt] %sLimit: total limit: 1024K (fatal)\", type.toString()));\n+        output.shouldMatch(String.format(\"#  fatal error: %sLimit: reached global limit \\\\(triggering allocation size: \\\\d+[BKM], allocated so far: \\\\d+[BKM], limit: 1024K\\\\)\", type.toString()));\n+    }\n+\n+    private static void testGlobalLimitOOM(LimitType type) throws IOException {\n+        ProcessBuilder pb = processBuilderWithSetting(String.format(\"-XX:%sLimit=1m:oom\", type.toString()));\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldNotHaveExitValue(0);\n+        output.shouldContain(String.format(\"[nmt] %sLimit: total limit: 1024K (oom)\", type.toString()));\n+        output.shouldMatch(String.format(\".*\\\\[warning\\\\]\\\\[nmt\\\\] %sLimit: reached global limit \\\\(triggering allocation size: \\\\d+[BKM], allocated so far: \\\\d+[BKM], limit: 1024K\\\\)\", type.toString()));\n+        \/\/ The rest is fuzzy. We may get SIGSEGV or a native OOM message, depending on how the failing allocation was handled.\n+    }\n+\n+    private static void testCompilerLimitFatal(LimitType type) throws IOException {\n+        ProcessBuilder pb = processBuilderWithSetting(String.format(\"-XX:%sLimit=compiler:1234k\", type.toString()), \"-Xcomp\");\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldNotHaveExitValue(0);\n+        output.shouldContain(String.format(\"[nmt] %sLimit: category \\\"mtCompiler\\\" limit: 1234K (fatal)\", type.toString()));\n+        output.shouldMatch(String.format(\"#  fatal error: %sLimit: reached category \\\"mtCompiler\\\" limit \\\\(triggering allocation size: \\\\d+[BKM], allocated so far: \\\\d+[BKM], limit: 1234K\\\\)\", type.toString()));\n+    }\n+\n+    private static void testCompilerLimitOOM(LimitType type) throws IOException {\n+        ProcessBuilder pb = processBuilderWithSetting(String.format(\"-XX:%sLimit=compiler:1234k:oom\", type.toString()), \"-Xcomp\");\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldNotHaveExitValue(0);\n+        output.shouldContain(String.format(\"[nmt] %sLimit: category \\\"mtCompiler\\\" limit: 1234K (oom)\", type.toString()));\n+        output.shouldMatch(String.format(\".*\\\\[warning\\\\]\\\\[nmt\\\\] %sLimit: reached category \\\"mtCompiler\\\" limit \\\\(triggering allocation size: \\\\d+[BKM], allocated so far: \\\\d+[BKM], limit: 1234K\\\\)\", type.toString()));\n+        \/\/ The rest is fuzzy. We may get SIGSEGV or a native OOM message, depending on how the failing allocation was handled.\n+    }\n+\n+    private static void testGCLimitFatal(LimitType type) throws IOException {\n+        ProcessBuilder pb = processBuilderWithSetting(String.format(\"-XX:%sLimit=gc:1234K\", type.toString()));\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldNotHaveExitValue(0);\n+        output.shouldContain(String.format(\"[nmt] %sLimit: category \\\"mtGC\\\" limit: 1234K (fatal)\", type.toString()));\n+        output.shouldMatch(String.format(\"#  fatal error: %sLimit: reached category \\\"mtGC\\\" limit \\\\(triggering allocation size: \\\\d+[BKM], allocated so far: \\\\d+[BKM], limit: 1234K\\\\)\", type.toString()));\n+    }\n+\n+    private static void testGCLimitOOM(LimitType type) throws IOException {\n+        ProcessBuilder pb = processBuilderWithSetting(String.format(\"-XX:%sLimit=gc:1234K:oom\", type.toString()));\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldNotHaveExitValue(0);\n+        output.shouldContain(String.format(\"[nmt] %sLimit: category \\\"mtGC\\\" limit: 1234K (oom)\", type.toString()));\n+        output.shouldMatch(String.format(\".*\\\\[warning\\\\]\\\\[nmt\\\\] %sLimit: reached category \\\"mtGC\\\" limit \\\\(triggering allocation size: \\\\d+[BKM], allocated so far: \\\\d+[BKM], limit: 1234K\\\\)\", type.toString()));\n+        \/\/ The rest is fuzzy. We may get SIGSEGV or a native OOM message, depending on how the failing allocation was handled.\n+    }\n+\n+    private static void testMultiLimit(LimitType type) throws IOException {\n+        ProcessBuilder pb = processBuilderWithSetting(String.format(\"-XX:%sLimit=other:2g,compiler:1g:oom,internal:1k\", type.toString()));\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldNotHaveExitValue(0);\n+        output.shouldContain(String.format(\"[nmt] %sLimit: category \\\"mtCompiler\\\" limit: 1024M (oom)\", type.toString()));\n+        output.shouldContain(String.format(\"[nmt] %sLimit: category \\\"mtInternal\\\" limit: 1024B (fatal)\", type.toString()));\n+        output.shouldContain(String.format(\"[nmt] %sLimit: category \\\"mtOther\\\" limit: 2048M (fatal)\", type.toString()));\n+        output.shouldMatch(String.format(\"#  fatal error: %sLimit: reached category \\\"mtInternal\\\" limit \\\\(triggering allocation size: \\\\d+[BKM], allocated so far: \\\\d+[BKM], limit: 1024B\\\\)\", type.toString()));\n+    }\n+\n+    private static void testMallocMMapLimitMixMMallocFatal() throws IOException {\n+        ProcessBuilder pb = processBuilderWithSetting(\"-XX:MallocLimit=gc:1234K\", \"-XX:MmapLimit=gc:500M\");\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldNotHaveExitValue(0);\n+        output.shouldContain(String.format(\"[nmt] MallocLimit: category \\\"mtGC\\\" limit: 1234K (fatal)\"));\n+        output.shouldContain(String.format(\"[nmt] MmapLimit: category \\\"mtGC\\\" limit: 500M (fatal)\"));\n+        output.shouldMatch(String.format(\"#  fatal error: MallocLimit: reached category \\\"mtGC\\\" limit \\\\(triggering allocation size: \\\\d+[BKM], allocated so far: \\\\d+[BKM], limit: 1234K\\\\)\"));\n+    }\n+\n+    private static void testMallocMMapLimitMixMMapFatal() throws IOException {\n+        ProcessBuilder pb = processBuilderWithSetting(\"-XX:MallocLimit=gc:500M\", \"-XX:MmapLimit=gc:1234k\");\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldNotHaveExitValue(0);\n+        output.shouldContain(String.format(\"[nmt] MallocLimit: category \\\"mtGC\\\" limit: 500M (fatal)\"));\n+        output.shouldContain(String.format(\"[nmt] MmapLimit: category \\\"mtGC\\\" limit: 1234K (fatal)\"));\n+        output.shouldMatch(String.format(\"#  fatal error: MmapLimit: reached category \\\"mtGC\\\" limit \\\\(triggering allocation size: \\\\d+[BKM], allocated so far: \\\\d+[BKM], limit: 1234K\\\\)\"));\n+    }\n+\n+    private static void testMallocMMapLimitMixNeitherFailed() throws IOException {\n+        ProcessBuilder pb = processBuilderWithSetting(\"-XX:MallocLimit=gc:500M\", \"-XX:MmapLimit=gc:500M\");\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        output.shouldContain(String.format(\"[nmt] MallocLimit: category \\\"mtGC\\\" limit: 500M (fatal)\"));\n+        output.shouldContain(String.format(\"[nmt] MmapLimit: category \\\"mtGC\\\" limit: 500M (fatal)\"));\n+    }\n+\n+    private static void testLimitWithoutNmt(LimitType type) throws IOException {\n+        ProcessBuilder pb = processBuilderWithSetting(\"-XX:NativeMemoryTracking=off\", \/\/ overrides \"summary\" from processBuilderWithSetting()\n+                String.format(\"-XX:%sLimit=3g\", type.toString()));\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.reportDiagnosticSummary();\n+        output.shouldHaveExitValue(0); \/\/ Not a fatal error, just a warning\n+        output.shouldContain(String.format(\"%sLimit will be ignored since NMT is disabled\", type.toString()));\n+    }\n+\n+    public static void main(String args[]) throws Exception {\n+\n+        if (args[0].equals(\"global-limit-fatal\")) {\n+            testGlobalLimitFatal(LimitType.Malloc);\n+            testGlobalLimitFatal(LimitType.Mmap);\n+        } else if (args[0].equals(\"global-limit-oom\")) {\n+            testGlobalLimitOOM(LimitType.Malloc);\n+            testGlobalLimitOOM(LimitType.Mmap);\n+        } else if (args[0].equals(\"compiler-limit-fatal\")) {\n+            testCompilerLimitFatal(LimitType.Malloc); \/\/ compiler only has malloc, but not mmap\n+        } else if (args[0].equals(\"compiler-limit-oom\")) {\n+            testCompilerLimitOOM(LimitType.Malloc); \/\/ compiler only has malloc, but not mmap\n+        } else if (args[0].equals(\"gc-limit-fatal\")) {\n+            testGCLimitOOM(LimitType.Malloc);\n+            testGCLimitOOM(LimitType.Mmap);\n+        } else if (args[0].equals(\"gc-limit-oom\")) {\n+            testMultiLimit(LimitType.Malloc);\n+            testMultiLimit(LimitType.Mmap);\n+        } else if (args[0].equals(\"multi-limit\")) {\n+            testMultiLimit(LimitType.Malloc);\n+            testMultiLimit(LimitType.Mmap);\n+        } else if (args[0].equals(\"malloc-mmap-limit-mix-malloc-fatal\")){\n+            testMallocMMapLimitMixMMallocFatal();\n+        }  else if (args[0].equals(\"malloc-mmap-limit-mix-mmap-fatal\")){\n+            testMallocMMapLimitMixMMapFatal();\n+        }  else if (args[0].equals(\"malloc-mmap-limit-mix-neither-failed\")){\n+            testMallocMMapLimitMixNeitherFailed();\n+        } else if (args[0].equals(\"limit-without-nmt\")) {\n+            testLimitWithoutNmt(LimitType.Malloc);\n+            testLimitWithoutNmt(LimitType.Mmap);\n+        } else {\n+            throw new RuntimeException(\"invalid test: \" + args[0]);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/NMemLimitTest.java","additions":285,"deletions":0,"binary":false,"changes":285,"status":"added"}]}