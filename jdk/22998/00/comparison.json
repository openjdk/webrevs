{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,2 @@\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/globals.hpp\"\n@@ -37,0 +39,1 @@\n+#include \"runtime\/os.hpp\"\n@@ -39,0 +42,175 @@\n+bool volatile MonitorDeflationThread::_is_async_deflation_requested = false;\n+jlong MonitorDeflationThread::_last_async_deflation_time_ns = 0;\n+\n+\/\/ monitors_used_above_threshold() policy is as follows:\n+\/\/\n+\/\/ The ratio of the current in_use_list() count to the ceiling is used\n+\/\/ to determine if we are above MonitorUsedDeflationThreshold and need\n+\/\/ to do an async monitor deflation cycle. The ceiling is increased by\n+\/\/ AvgMonitorsPerThreadEstimate when a thread is added to the system\n+\/\/ and is decreased by AvgMonitorsPerThreadEstimate when a thread is\n+\/\/ removed from the system.\n+\/\/\n+\/\/ Note: If the in_use_list() max exceeds the ceiling, then\n+\/\/ monitors_used_above_threshold() will use the in_use_list max instead\n+\/\/ of the thread count derived ceiling because we have used more\n+\/\/ ObjectMonitors than the estimated average.\n+\/\/\n+\/\/ Note: If deflate_idle_monitors() has NoAsyncDeflationProgressMax\n+\/\/ no-progress async monitor deflation cycles in a row, then the ceiling\n+\/\/ is adjusted upwards by monitors_used_above_threshold().\n+\/\/\n+\/\/ Start the ceiling with the estimate for one thread in initialize()\n+\/\/ which is called after cmd line options are processed.\n+static size_t _in_use_list_ceiling = 0;\n+static uintx _no_progress_cnt = 0;\n+static bool _no_progress_skip_increment = false;\n+\n+size_t MonitorDeflationThread::in_use_list_ceiling() {\n+  return _in_use_list_ceiling;\n+}\n+\n+void MonitorDeflationThread::dec_in_use_list_ceiling() {\n+  Atomic::sub(&_in_use_list_ceiling, AvgMonitorsPerThreadEstimate);\n+}\n+\n+void MonitorDeflationThread::inc_in_use_list_ceiling() {\n+  Atomic::add(&_in_use_list_ceiling, AvgMonitorsPerThreadEstimate);\n+}\n+\n+void MonitorDeflationThread::update_heuristics(size_t deflated_count) {\n+  if (deflated_count != 0) {\n+    _no_progress_cnt = 0;\n+  } else if (_no_progress_skip_increment) {\n+    _no_progress_skip_increment = false;\n+  } else {\n+    _no_progress_cnt++;\n+  }\n+}\n+\n+bool MonitorDeflationThread::monitors_used_above_threshold() {\n+  if (MonitorUsedDeflationThreshold == 0) {  \/\/ disabled case is easy\n+    return false;\n+  }\n+\n+  MonitorList* list = ObjectSynchronizer::in_use_list();\n+\n+  \/\/ Start with ceiling based on a per-thread estimate:\n+  size_t ceiling = _in_use_list_ceiling;\n+  size_t old_ceiling = ceiling;\n+  if (ceiling < list->max()) {\n+    \/\/ The max used by the system has exceeded the ceiling so use that:\n+    ceiling = list->max();\n+  }\n+  size_t monitors_used = list->count();\n+  if (monitors_used == 0) {  \/\/ empty list is easy\n+    return false;\n+  }\n+  if (NoAsyncDeflationProgressMax != 0 &&\n+      _no_progress_cnt >= NoAsyncDeflationProgressMax) {\n+    double remainder = (100.0 - MonitorUsedDeflationThreshold) \/ 100.0;\n+    size_t new_ceiling = ceiling + (size_t)((double)ceiling * remainder) + 1;\n+    _in_use_list_ceiling = new_ceiling;\n+    log_info(monitorinflation)(\"Too many deflations without progress; \"\n+                               \"bumping in_use_list_ceiling from \" SIZE_FORMAT\n+                               \" to \" SIZE_FORMAT, old_ceiling, new_ceiling);\n+    _no_progress_cnt = 0;\n+    ceiling = new_ceiling;\n+  }\n+\n+  \/\/ Check if our monitor usage is above the threshold:\n+  size_t monitor_usage = (monitors_used * 100LL) \/ ceiling;\n+  if (int(monitor_usage) > MonitorUsedDeflationThreshold) {\n+    log_info(monitorinflation)(\"monitors_used=\" SIZE_FORMAT \", ceiling=\" SIZE_FORMAT\n+                               \", monitor_usage=\" SIZE_FORMAT \", threshold=%d\",\n+                               monitors_used, ceiling, monitor_usage, MonitorUsedDeflationThreshold);\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+\n+bool MonitorDeflationThread::is_async_deflation_needed() {\n+  if (_is_async_deflation_requested) {\n+    \/\/ Async deflation request.\n+    log_info(monitorinflation)(\"Async deflation needed: explicit request\");\n+    return true;\n+  }\n+\n+  jlong ms_since_last = (os::javaTimeNanos() - _last_async_deflation_time_ns) \/ (NANOUNITS \/ MILLIUNITS);\n+\n+  if (AsyncDeflationInterval > 0 &&\n+      ms_since_last > AsyncDeflationInterval &&\n+      monitors_used_above_threshold()) {\n+    \/\/ It's been longer than our specified deflate interval and there\n+    \/\/ are too many monitors in use. We don't deflate more frequently\n+    \/\/ than AsyncDeflationInterval (unless is_async_deflation_requested)\n+    \/\/ in order to not swamp the MonitorDeflationThread.\n+    log_info(monitorinflation)(\"Async deflation needed: monitors used are above the threshold\");\n+    return true;\n+  }\n+\n+  if (GuaranteedAsyncDeflationInterval > 0 &&\n+      ms_since_last > GuaranteedAsyncDeflationInterval) {\n+    \/\/ It's been longer than our specified guaranteed deflate interval.\n+    \/\/ We need to clean up the used monitors even if the threshold is\n+    \/\/ not reached, to keep the memory utilization at bay when many threads\n+    \/\/ touched many monitors.\n+    log_info(monitorinflation)(\"Async deflation needed: guaranteed interval (\" INTX_FORMAT \" ms) \"\n+                               \"is greater than time since last deflation (\" JLONG_FORMAT \" ms)\",\n+                               GuaranteedAsyncDeflationInterval, ms_since_last);\n+\n+    \/\/ If this deflation has no progress, then it should not affect the no-progress\n+    \/\/ tracking, otherwise threshold heuristics would think it was triggered, experienced\n+    \/\/ no progress, and needs to backoff more aggressively. In this \"no progress\" case,\n+    \/\/ the generic code would bump the no-progress counter, and we compensate for that\n+    \/\/ by telling it to skip the update.\n+    \/\/\n+    \/\/ If this deflation has progress, then it should let non-progress tracking\n+    \/\/ know about this, otherwise the threshold heuristics would kick in, potentially\n+    \/\/ experience no-progress due to aggressive cleanup by this deflation, and think\n+    \/\/ it is still in no-progress stride. In this \"progress\" case, the generic code would\n+    \/\/ zero the counter, and we allow it to happen.\n+    _no_progress_skip_increment = true;\n+\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+void MonitorDeflationThread::request_deflate_idle_monitors() {\n+  MonitorLocker ml(MonitorDeflation_lock, Mutex::_no_safepoint_check_flag);\n+  _is_async_deflation_requested = true;\n+  ml.notify_all();\n+}\n+\n+bool MonitorDeflationThread::request_deflate_idle_monitors_from_wb() {\n+  JavaThread* current = JavaThread::current();\n+  bool ret_code = false;\n+\n+  jlong last_time = _last_async_deflation_time_ns;\n+\n+  request_deflate_idle_monitors();\n+\n+  const int N_CHECKS = 5;\n+  for (int i = 0; i < N_CHECKS; i++) {  \/\/ sleep for at most 5 seconds\n+    if (_last_async_deflation_time_ns > last_time) {\n+      log_info(monitorinflation)(\"Async Deflation happened after %d check(s).\", i);\n+      ret_code = true;\n+      break;\n+    }\n+    {\n+      \/\/ JavaThread has to honor the blocking protocol.\n+      ThreadBlockInVM tbivm(current);\n+      os::naked_short_sleep(999);  \/\/ sleep for almost 1 second\n+    }\n+  }\n+  if (!ret_code) {\n+    log_info(monitorinflation)(\"Async Deflation DID NOT happen after %d checks.\", N_CHECKS);\n+  }\n+\n+  return ret_code;\n+}\n+\n@@ -48,0 +226,6 @@\n+  \/\/ Start the timer for deflations, so it does not trigger immediately.\n+  _last_async_deflation_time_ns = os::javaTimeNanos();\n+\n+  \/\/ Start the ceiling with the estimate for one thread.\n+  _in_use_list_ceiling = AvgMonitorsPerThreadEstimate;\n+\n@@ -86,1 +270,1 @@\n-      while (!ObjectSynchronizer::is_async_deflation_needed()) {\n+      while (!is_async_deflation_needed()) {\n","filename":"src\/hotspot\/share\/runtime\/monitorDeflationThread.cpp","additions":186,"deletions":2,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,4 @@\n-\/\/ A hidden from external view JavaThread for deflating idle monitors.\n+\/\/ A hidden from external view JavaThread for asynchronously deflating idle monitors.\n+\/\/ The API for requesting\/querying async deflation is mostly maintained here,\n+\/\/ but some functions are also exposed through ObjectSynchronizer to provide\n+\/\/ an external, public API.\n@@ -34,0 +37,3 @@\n+  friend class ObjectSynchronizer;\n+  friend class ObjectMonitorDeflationLogging;\n+\n@@ -39,0 +45,16 @@\n+  static volatile bool _is_async_deflation_requested;\n+  static jlong         _last_async_deflation_time_ns;\n+\n+  static bool is_async_deflation_needed();\n+  static void set_is_async_deflation_requested(bool new_value) { _is_async_deflation_requested = new_value; }\n+  static void set_last_async_deflation_time_ns(jlong ns) { _last_async_deflation_time_ns = ns; }\n+\n+  static void request_deflate_idle_monitors();\n+  static bool request_deflate_idle_monitors_from_wb();  \/\/ for whitebox test support\n+\n+  static size_t in_use_list_ceiling();\n+  static void dec_in_use_list_ceiling();\n+  static void inc_in_use_list_ceiling();\n+  static void update_heuristics(size_t deflated_count);\n+  static bool monitors_used_above_threshold();\n+\n@@ -44,2 +66,0 @@\n-\n-  bool is_monitor_deflation_thread() const { return true; }\n","filename":"src\/hotspot\/share\/runtime\/monitorDeflationThread.hpp","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+#include \"runtime\/monitorDeflationThread.hpp\"\n@@ -276,5 +277,0 @@\n-  \/\/ Start the ceiling with the estimate for one thread.\n-  set_in_use_list_ceiling(AvgMonitorsPerThreadEstimate);\n-\n-  \/\/ Start the timer for deflations, so it does not trigger immediately.\n-  _last_async_deflation_time_ns = os::javaTimeNanos();\n@@ -288,22 +284,0 @@\n-\/\/ monitors_used_above_threshold() policy is as follows:\n-\/\/\n-\/\/ The ratio of the current _in_use_list count to the ceiling is used\n-\/\/ to determine if we are above MonitorUsedDeflationThreshold and need\n-\/\/ to do an async monitor deflation cycle. The ceiling is increased by\n-\/\/ AvgMonitorsPerThreadEstimate when a thread is added to the system\n-\/\/ and is decreased by AvgMonitorsPerThreadEstimate when a thread is\n-\/\/ removed from the system.\n-\/\/\n-\/\/ Note: If the _in_use_list max exceeds the ceiling, then\n-\/\/ monitors_used_above_threshold() will use the in_use_list max instead\n-\/\/ of the thread count derived ceiling because we have used more\n-\/\/ ObjectMonitors than the estimated average.\n-\/\/\n-\/\/ Note: If deflate_idle_monitors() has NoAsyncDeflationProgressMax\n-\/\/ no-progress async monitor deflation cycles in a row, then the ceiling\n-\/\/ is adjusted upwards by monitors_used_above_threshold().\n-\/\/\n-\/\/ Start the ceiling with the estimate for one thread in initialize()\n-\/\/ which is called after cmd line options are processed.\n-static size_t _in_use_list_ceiling = 0;\n-bool volatile ObjectSynchronizer::_is_async_deflation_requested = false;\n@@ -311,3 +285,0 @@\n-jlong ObjectSynchronizer::_last_async_deflation_time_ns = 0;\n-static uintx _no_progress_cnt = 0;\n-static bool _no_progress_skip_increment = false;\n@@ -1263,42 +1234,1 @@\n-static bool monitors_used_above_threshold(MonitorList* list) {\n-  if (MonitorUsedDeflationThreshold == 0) {  \/\/ disabled case is easy\n-    return false;\n-  }\n-  \/\/ Start with ceiling based on a per-thread estimate:\n-  size_t ceiling = ObjectSynchronizer::in_use_list_ceiling();\n-  size_t old_ceiling = ceiling;\n-  if (ceiling < list->max()) {\n-    \/\/ The max used by the system has exceeded the ceiling so use that:\n-    ceiling = list->max();\n-  }\n-  size_t monitors_used = list->count();\n-  if (monitors_used == 0) {  \/\/ empty list is easy\n-    return false;\n-  }\n-  if (NoAsyncDeflationProgressMax != 0 &&\n-      _no_progress_cnt >= NoAsyncDeflationProgressMax) {\n-    double remainder = (100.0 - MonitorUsedDeflationThreshold) \/ 100.0;\n-    size_t new_ceiling = ceiling + (size_t)((double)ceiling * remainder) + 1;\n-    ObjectSynchronizer::set_in_use_list_ceiling(new_ceiling);\n-    log_info(monitorinflation)(\"Too many deflations without progress; \"\n-                               \"bumping in_use_list_ceiling from \" SIZE_FORMAT\n-                               \" to \" SIZE_FORMAT, old_ceiling, new_ceiling);\n-    _no_progress_cnt = 0;\n-    ceiling = new_ceiling;\n-  }\n-\n-  \/\/ Check if our monitor usage is above the threshold:\n-  size_t monitor_usage = (monitors_used * 100LL) \/ ceiling;\n-  if (int(monitor_usage) > MonitorUsedDeflationThreshold) {\n-    log_info(monitorinflation)(\"monitors_used=\" SIZE_FORMAT \", ceiling=\" SIZE_FORMAT\n-                               \", monitor_usage=\" SIZE_FORMAT \", threshold=%d\",\n-                               monitors_used, ceiling, monitor_usage, MonitorUsedDeflationThreshold);\n-    return true;\n-  }\n-\n-  return false;\n-}\n-\n-size_t ObjectSynchronizer::in_use_list_ceiling() {\n-  return _in_use_list_ceiling;\n-}\n+\/\/ Async monitor deflation APIs\n@@ -1307,1 +1237,1 @@\n-  Atomic::sub(&_in_use_list_ceiling, AvgMonitorsPerThreadEstimate);\n+  MonitorDeflationThread::dec_in_use_list_ceiling();\n@@ -1311,54 +1241,1 @@\n-  Atomic::add(&_in_use_list_ceiling, AvgMonitorsPerThreadEstimate);\n-}\n-\n-void ObjectSynchronizer::set_in_use_list_ceiling(size_t new_value) {\n-  _in_use_list_ceiling = new_value;\n-}\n-\n-bool ObjectSynchronizer::is_async_deflation_needed() {\n-  if (is_async_deflation_requested()) {\n-    \/\/ Async deflation request.\n-    log_info(monitorinflation)(\"Async deflation needed: explicit request\");\n-    return true;\n-  }\n-\n-  jlong time_since_last = time_since_last_async_deflation_ms();\n-\n-  if (AsyncDeflationInterval > 0 &&\n-      time_since_last > AsyncDeflationInterval &&\n-      monitors_used_above_threshold(&_in_use_list)) {\n-    \/\/ It's been longer than our specified deflate interval and there\n-    \/\/ are too many monitors in use. We don't deflate more frequently\n-    \/\/ than AsyncDeflationInterval (unless is_async_deflation_requested)\n-    \/\/ in order to not swamp the MonitorDeflationThread.\n-    log_info(monitorinflation)(\"Async deflation needed: monitors used are above the threshold\");\n-    return true;\n-  }\n-\n-  if (GuaranteedAsyncDeflationInterval > 0 &&\n-      time_since_last > GuaranteedAsyncDeflationInterval) {\n-    \/\/ It's been longer than our specified guaranteed deflate interval.\n-    \/\/ We need to clean up the used monitors even if the threshold is\n-    \/\/ not reached, to keep the memory utilization at bay when many threads\n-    \/\/ touched many monitors.\n-    log_info(monitorinflation)(\"Async deflation needed: guaranteed interval (\" INTX_FORMAT \" ms) \"\n-                               \"is greater than time since last deflation (\" JLONG_FORMAT \" ms)\",\n-                               GuaranteedAsyncDeflationInterval, time_since_last);\n-\n-    \/\/ If this deflation has no progress, then it should not affect the no-progress\n-    \/\/ tracking, otherwise threshold heuristics would think it was triggered, experienced\n-    \/\/ no progress, and needs to backoff more aggressively. In this \"no progress\" case,\n-    \/\/ the generic code would bump the no-progress counter, and we compensate for that\n-    \/\/ by telling it to skip the update.\n-    \/\/\n-    \/\/ If this deflation has progress, then it should let non-progress tracking\n-    \/\/ know about this, otherwise the threshold heuristics would kick in, potentially\n-    \/\/ experience no-progress due to aggressive cleanup by this deflation, and think\n-    \/\/ it is still in no-progress stride. In this \"progress\" case, the generic code would\n-    \/\/ zero the counter, and we allow it to happen.\n-    _no_progress_skip_increment = true;\n-\n-    return true;\n-  }\n-\n-  return false;\n+  MonitorDeflationThread::inc_in_use_list_ceiling();\n@@ -1368,3 +1245,1 @@\n-  MonitorLocker ml(MonitorDeflation_lock, Mutex::_no_safepoint_check_flag);\n-  set_is_async_deflation_requested(true);\n-  ml.notify_all();\n+  MonitorDeflationThread::request_deflate_idle_monitors();\n@@ -1374,29 +1249,1 @@\n-  JavaThread* current = JavaThread::current();\n-  bool ret_code = false;\n-\n-  jlong last_time = last_async_deflation_time_ns();\n-\n-  request_deflate_idle_monitors();\n-\n-  const int N_CHECKS = 5;\n-  for (int i = 0; i < N_CHECKS; i++) {  \/\/ sleep for at most 5 seconds\n-    if (last_async_deflation_time_ns() > last_time) {\n-      log_info(monitorinflation)(\"Async Deflation happened after %d check(s).\", i);\n-      ret_code = true;\n-      break;\n-    }\n-    {\n-      \/\/ JavaThread has to honor the blocking protocol.\n-      ThreadBlockInVM tbivm(current);\n-      os::naked_short_sleep(999);  \/\/ sleep for almost 1 second\n-    }\n-  }\n-  if (!ret_code) {\n-    log_info(monitorinflation)(\"Async Deflation DID NOT happen after %d checks.\", N_CHECKS);\n-  }\n-\n-  return ret_code;\n-}\n-\n-jlong ObjectSynchronizer::time_since_last_async_deflation_ms() {\n-  return (os::javaTimeNanos() - last_async_deflation_time_ns()) \/ (NANOUNITS \/ MILLIUNITS);\n+  return  MonitorDeflationThread::request_deflate_idle_monitors_from_wb();\n@@ -1699,1 +1546,1 @@\n-  size_t ceiling() const { return ObjectSynchronizer::in_use_list_ceiling(); }\n+  size_t ceiling() const { return MonitorDeflationThread::in_use_list_ceiling(); }\n@@ -1791,1 +1638,0 @@\n-  assert(current->is_monitor_deflation_thread(), \"The only monitor deflater\");\n@@ -1794,2 +1640,2 @@\n-  _last_async_deflation_time_ns = os::javaTimeNanos();\n-  set_is_async_deflation_requested(false);\n+  MonitorDeflationThread::set_last_async_deflation_time_ns(os::javaTimeNanos());\n+  MonitorDeflationThread::set_is_async_deflation_requested(false);\n@@ -1850,7 +1696,1 @@\n-  if (deflated_count != 0) {\n-    _no_progress_cnt = 0;\n-  } else if (_no_progress_skip_increment) {\n-    _no_progress_skip_increment = false;\n-  } else {\n-    _no_progress_cnt++;\n-  }\n+  MonitorDeflationThread::update_heuristics(deflated_count);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":11,"deletions":171,"binary":false,"changes":182,"status":"modified"},{"patch":"@@ -184,0 +184,4 @@\n+  \/\/ Deflate idle monitors:\n+ private:\n+  friend class MonitorDeflationThread;\n+\n@@ -187,2 +191,1 @@\n-\n-  \/\/ Deflate idle monitors:\n+  static MonitorList* in_use_list() { return &_in_use_list; }\n@@ -190,6 +193,0 @@\n-  static size_t in_use_list_ceiling();\n-  static void dec_in_use_list_ceiling();\n-  static void inc_in_use_list_ceiling();\n-  static void set_in_use_list_ceiling(size_t new_value);\n-  static bool is_async_deflation_needed();\n-  static bool is_async_deflation_requested() { return _is_async_deflation_requested; }\n@@ -198,1 +195,6 @@\n-  static jlong last_async_deflation_time_ns() { return _last_async_deflation_time_ns; }\n+\n+ public:\n+  static void dec_in_use_list_ceiling();\n+  static void inc_in_use_list_ceiling();\n+\n+  \/\/ Public API to request deflation. Delegates to MonitorDeflationThread.\n@@ -201,2 +203,0 @@\n-  static void set_is_async_deflation_requested(bool new_value) { _is_async_deflation_requested = new_value; }\n-  static jlong time_since_last_async_deflation_ms();\n@@ -217,1 +217,0 @@\n-  static volatile bool _is_async_deflation_requested;\n@@ -219,1 +218,0 @@\n-  static jlong         _last_async_deflation_time_ns;\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -315,1 +315,0 @@\n-  virtual bool is_monitor_deflation_thread() const   { return false; }\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}