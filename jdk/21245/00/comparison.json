{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+\n+import jdk.internal.util.OperatingSystem;\n@@ -151,0 +153,5 @@\n+        \/\/ for systems other than Windows we don't\n+        \/\/ do any special conversion\n+        if (!OperatingSystem.isWindows()) {\n+            return url;\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/jar\/JarFileFactory.java","additions":8,"deletions":1,"binary":false,"changes":9,"previous_filename":"src\/java.base\/windows\/classes\/sun\/net\/www\/protocol\/jar\/JarFileFactory.java","status":"renamed"},{"patch":"@@ -1,239 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.net.www.protocol.jar;\n-\n-import java.io.IOException;\n-import java.io.FileNotFoundException;\n-import java.net.URL;\n-import java.net.URLConnection;\n-import java.util.HashMap;\n-import java.util.jar.JarFile;\n-import java.security.Permission;\n-import sun.net.util.URLUtil;\n-\n-\/* A factory for cached JAR file. This class is used to both retrieve\n- * and cache Jar files.\n- *\n- * @author Benjamin Renaud\n- * @since 1.2\n- *\/\n-class JarFileFactory implements URLJarFile.URLJarFileCloseController {\n-\n-    \/* the url to file cache *\/\n-    private static final HashMap<String, JarFile> fileCache = new HashMap<>();\n-\n-    \/* the file to url cache *\/\n-    private static final HashMap<JarFile, URL> urlCache = new HashMap<>();\n-\n-    private static final JarFileFactory instance = new JarFileFactory();\n-\n-    private JarFileFactory() { }\n-\n-    public static JarFileFactory getInstance() {\n-        return instance;\n-    }\n-\n-    URLConnection getConnection(JarFile jarFile) throws IOException {\n-        URL u;\n-        synchronized (instance) {\n-            u = urlCache.get(jarFile);\n-        }\n-        if (u != null)\n-            return u.openConnection();\n-\n-        return null;\n-    }\n-\n-    public JarFile get(URL url) throws IOException {\n-        return get(url, true);\n-    }\n-\n-    \/**\n-     * Get or create a {@code JarFile} for the given {@code url}.\n-     * If {@code useCaches} is true, this method attempts to find\n-     * a jar file in the cache, and if so, returns it.\n-     * If no jar file is found in the cache, or {@code useCaches}\n-     * is false, the method creates a new jar file.\n-     * If the URL points to a local file, the returned jar file\n-     * will not be put in the cache yet.\n-     * The caller should then call {@link #cacheIfAbsent(URL, JarFile)}\n-     * with the returned jar file, if updating the cache is desired.\n-     * @param url the jar file url\n-     * @param useCaches whether the cache should be used\n-     * @return a new or cached jar file.\n-     * @throws IOException if the jar file couldn't be created\n-     *\/\n-    JarFile getOrCreate(URL url, boolean useCaches) throws IOException {\n-        if (useCaches == false) {\n-            return get(url, false);\n-        }\n-\n-        if (!URLJarFile.isFileURL(url)) {\n-            \/\/ A temporary file will be created, we can prepopulate\n-            \/\/ the cache in this case.\n-            return get(url, useCaches);\n-        }\n-\n-        \/\/ We have a local file. Do not prepopulate the cache.\n-        JarFile result;\n-        synchronized (instance) {\n-            result = getCachedJarFile(url);\n-        }\n-        if (result == null) {\n-            result = URLJarFile.getJarFile(url, this);\n-        }\n-        if (result == null)\n-            throw new FileNotFoundException(url.toString());\n-        return result;\n-    }\n-\n-    \/**\n-     * Close the given jar file if it isn't present in the cache.\n-     * Otherwise, does nothing.\n-     * @param url the jar file URL\n-     * @param jarFile the jar file to close\n-     * @return true if the jar file has been closed, false otherwise.\n-     * @throws IOException if an error occurs while closing the jar file.\n-     *\/\n-    boolean closeIfNotCached(URL url, JarFile jarFile) throws IOException {\n-        JarFile result;\n-        synchronized (instance) {\n-            result = getCachedJarFile(url);\n-        }\n-        if (result != jarFile) jarFile.close();\n-        return result != jarFile;\n-    }\n-\n-    boolean cacheIfAbsent(URL url, JarFile jarFile) {\n-        JarFile cached;\n-        synchronized (instance) {\n-            String key = urlKey(url);\n-            cached = fileCache.get(key);\n-            if (cached == null) {\n-                fileCache.put(key, jarFile);\n-                urlCache.put(jarFile, url);\n-            }\n-        }\n-        return cached == null || cached == jarFile;\n-    }\n-\n-    JarFile get(URL url, boolean useCaches) throws IOException {\n-\n-        JarFile result;\n-        JarFile local_result;\n-\n-        if (useCaches) {\n-            synchronized (instance) {\n-                result = getCachedJarFile(url);\n-            }\n-            if (result == null) {\n-                local_result = URLJarFile.getJarFile(url, this);\n-                synchronized (instance) {\n-                    result = getCachedJarFile(url);\n-                    if (result == null) {\n-                        fileCache.put(urlKey(url), local_result);\n-                        urlCache.put(local_result, url);\n-                        result = local_result;\n-                    } else {\n-                        if (local_result != null) {\n-                            local_result.close();\n-                        }\n-                    }\n-                }\n-            }\n-        } else {\n-            result = URLJarFile.getJarFile(url, this);\n-        }\n-        if (result == null)\n-            throw new FileNotFoundException(url.toString());\n-\n-        return result;\n-    }\n-\n-    \/**\n-     * Callback method of the URLJarFileCloseController to\n-     * indicate that the JarFile is closed. This way we can\n-     * remove the JarFile from the cache\n-     *\/\n-    public void close(JarFile jarFile) {\n-        synchronized (instance) {\n-            URL urlRemoved = urlCache.remove(jarFile);\n-            if (urlRemoved != null)\n-                fileCache.remove(urlKey(urlRemoved));\n-        }\n-    }\n-\n-    private JarFile getCachedJarFile(URL url) {\n-        assert Thread.holdsLock(instance);\n-        JarFile result = fileCache.get(urlKey(url));\n-\n-        \/* if the JAR file is cached, the permission will always be there *\/\n-        if (result != null) {\n-            @SuppressWarnings(\"removal\")\n-            SecurityManager sm = System.getSecurityManager();\n-            if (sm != null) {\n-                Permission perm = getPermission(result);\n-                if (perm != null) {\n-                    try {\n-                        sm.checkPermission(perm);\n-                    } catch (SecurityException se) {\n-                        \/\/ fallback to checkRead\/checkConnect for pre 1.2\n-                        \/\/ security managers\n-                        if ((perm instanceof java.io.FilePermission) &&\n-                            perm.getActions().contains(\"read\")) {\n-                            sm.checkRead(perm.getName());\n-                        } else if ((perm instanceof\n-                            java.net.SocketPermission) &&\n-                            perm.getActions().contains(\"connect\")) {\n-                            sm.checkConnect(url.getHost(), url.getPort());\n-                        } else {\n-                            throw se;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        return result;\n-    }\n-\n-    private String urlKey(URL url) {\n-        String urlstr =  URLUtil.urlNoFragString(url);\n-        if (\"runtime\".equals(url.getRef())) urlstr += \"#runtime\";\n-        return urlstr;\n-    }\n-\n-    private Permission getPermission(JarFile jarFile) {\n-        try {\n-            URLConnection uc = getConnection(jarFile);\n-            if (uc != null)\n-                return uc.getPermission();\n-        } catch (IOException ioe) {\n-            \/\/ gulp\n-        }\n-\n-        return null;\n-    }\n-}\n","filename":"src\/java.base\/unix\/classes\/sun\/net\/www\/protocol\/jar\/JarFileFactory.java","additions":0,"deletions":239,"binary":false,"changes":239,"status":"deleted"}]}