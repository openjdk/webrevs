{"files":[{"patch":"@@ -80,1 +80,1 @@\n-    assert(!region->is_active_alloc_region(), \"There should be no active alloc regions when choosing collection set\");\n+    assert(!region->is_atomic_alloc_region(), \"There should be no active alloc regions when choosing collection set\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahGenerationalHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-    assert(!region->is_active_alloc_region(), \"There should be no active alloc regions when rebuilding free set\");\n+    assert(!region->is_atomic_alloc_region(), \"There should be no active alloc regions when rebuilding free set\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -279,1 +279,1 @@\n-        region->concurrent_set_update_watermark(region->top());\n+        region->concurrent_set_update_watermark(region->top<true>());\n@@ -281,1 +281,1 @@\n-        region->set_update_watermark(region->top());\n+        region->set_update_watermark(region->top<false>());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAllocator.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-  assert(!r->is_active_alloc_region(), \"Active alloc region can't be added to collection set\");\n+  assert(!r->is_atomic_alloc_region(), \"Atomic alloc region can't be added to collection set\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -910,1 +910,1 @@\n-        assert(!validate_totals || r->is_active_alloc_region() || (capacity != _region_size_bytes), \"Should not be retired if empty\");\n+        assert(!validate_totals || r->is_atomic_alloc_region() || (capacity != _region_size_bytes), \"Should not be retired if empty\");\n@@ -926,1 +926,1 @@\n-          assert(r->is_cset() || r->is_active_alloc_region() || (capacity < PLAB::min_size() * HeapWordSize),\n+          assert(r->is_cset() || r->is_atomic_alloc_region() || (capacity < PLAB::min_size() * HeapWordSize),\n@@ -1636,1 +1636,1 @@\n-      assert(!_heap->get_region(end)->is_active_alloc_region(), \"Must not\");\n+      assert(!_heap->get_region(end)->is_atomic_alloc_region(), \"Must not be atomic alloc region\");\n@@ -1962,1 +1962,1 @@\n-    assert(!region->is_active_alloc_region(), \"There should be no active alloc regions when choosing collection set\");\n+    assert(!region->is_atomic_alloc_region(), \"There should be no atomic alloc regions when choosing collection set\");\n@@ -3104,0 +3104,1 @@\n+    assert(r->get_top_before_promote() == nullptr, \"Must not be PIP region\");\n@@ -3237,0 +3238,1 @@\n+    assert(r->get_top_before_promote() == nullptr, \"Must not be PIP region\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -579,1 +579,1 @@\n-        if (!heap->is_concurrent_old_mark_in_progress() && tams == original_top && !r->is_active_alloc_region()) {\n+        if (!heap->is_concurrent_old_mark_in_progress() && tams == original_top && !r->is_atomic_alloc_region()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-  if (r->is_young() && r->is_active() && _heap->is_tenurable(r) && !r->is_active_alloc_region()) {\n+  if (r->is_young() && r->is_active() && _heap->is_tenurable(r) && !r->is_atomic_alloc_region()) {\n@@ -189,0 +189,1 @@\n+    assert(!region->is_atomic_alloc_region(), \"Must not be atomic alloc region\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalEvacuationTask.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -93,1 +93,0 @@\n-  _active_alloc_region.unset();\n@@ -576,1 +575,1 @@\n-  assert(!is_active_alloc_region(), \"Must not be active alloc region\");\n+  assert(!is_atomic_alloc_region(), \"Must not be atomic alloc region\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -273,2 +273,0 @@\n-  ShenandoahSharedFlag _active_alloc_region; \/\/ Flag indicates that whether the region is an active alloc region.\n-\n@@ -462,1 +460,1 @@\n-    return AtomicAccess::load(&_atomic_top);\n+    return AtomicAccess::load_acquire(&_atomic_top);\n@@ -465,0 +463,2 @@\n+  \/\/ The field _top can be stale when the region is an atomic alloc region, therefore,\n+  \/\/ it always checks the atomic top first if CHECK_ATOMIC_TOP is not overridden.\n@@ -468,2 +468,2 @@\n-      HeapWord* v_top = atomic_top();\n-      return v_top == nullptr ? AtomicAccess::load(&_top) : v_top;\n+      HeapWord* at = atomic_top();\n+      return at == nullptr ? AtomicAccess::load(&_top) : at;\n@@ -471,0 +471,1 @@\n+    assert(!is_atomic_alloc_region(), \"Must not be an atomic alloc region\");\n@@ -475,0 +476,1 @@\n+    assert(!is_atomic_alloc_region(), \"Must not be an atomic alloc region\");\n@@ -563,2 +565,1 @@\n-    assert(_active_alloc_region.is_unset(), \"Must be\");\n-    \/\/ Sync _top to _atomic_top before setting _active_alloc_region flag to prepare for CAS allocation\n+    shenandoah_assert_heaplocked();\n@@ -566,2 +567,2 @@\n-    AtomicAccess::store(&_atomic_top, top<false>());\n-    _active_alloc_region.set();\n+    \/\/ Sync _top to _atomic_top to set the region as an active atomic alloc region\n+    AtomicAccess::release_store(&_atomic_top, top<false>());\n@@ -575,1 +576,1 @@\n-    assert(is_active_alloc_region(), \"Must be\");\n+    assert(is_atomic_alloc_region(), \"Must be\");\n@@ -580,1 +581,2 @@\n-    HeapWord* previous_atomic_top = nullptr;\n+    HeapWord* prior_atomic_top = nullptr;\n+    HeapWord* current_atomic_top = atomic_top();\n@@ -582,4 +584,2 @@\n-      previous_atomic_top = atomic_top();\n-      assert(previous_atomic_top != nullptr, \"Must not\");\n-      set_top(previous_atomic_top); \/\/ Sync current _atomic_top back to _top\n-      \/\/ previous_atomic_top MUST be stored to _top before swapping _atomic_top with nullptr\n+      assert(current_atomic_top != nullptr, \"Must not\");\n+      AtomicAccess::store(&_top, current_atomic_top); \/\/ Sync current _atomic_top back to _top\n@@ -587,2 +587,3 @@\n-      if (AtomicAccess::cmpxchg(&_atomic_top, previous_atomic_top, (HeapWord*) nullptr) == previous_atomic_top) {\n-        \/\/ break when successfully exchange _atomic_top to nullptr\n+      prior_atomic_top = AtomicAccess::cmpxchg(&_atomic_top, current_atomic_top, (HeapWord*) nullptr, memory_order_release);\n+      if (prior_atomic_top == current_atomic_top) {\n+        \/\/ break out the loop when successfully exchange _atomic_top to nullptr\n@@ -591,0 +592,1 @@\n+      current_atomic_top = prior_atomic_top;\n@@ -592,2 +594,1 @@\n-    assert(top<false>() == previous_atomic_top, \"Must be\");\n-    _active_alloc_region.unset();\n+    assert(top<false>() == current_atomic_top, \"Value of _atomic_top must have synced to _top\");\n@@ -596,2 +597,3 @@\n-  inline bool is_active_alloc_region() const {\n-    return _active_alloc_region.is_set();\n+  inline bool is_atomic_alloc_region() const {\n+    \/\/ region is an active atomic alloc region if the atomic top is set\n+    return atomic_top() != nullptr;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":23,"deletions":21,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-  assert(!is_active_alloc_region(), \"Must not\");\n+  assert(!is_atomic_alloc_region(), \"Must not\");\n@@ -242,1 +242,1 @@\n-  if ((prior_atomic_top = AtomicAccess::cmpxchg(&_atomic_top, obj, new_top)) == obj) {\n+  if ((prior_atomic_top = AtomicAccess::cmpxchg(&_atomic_top, obj, new_top, memory_order_release)) == obj) {\n@@ -361,1 +361,3 @@\n-  _top_before_promoted = top();\n+  assert(!is_atomic_alloc_region(), \"Must not\");\n+  assert(atomic_top() == nullptr, \"Must be\");\n+  _top_before_promoted = top<false>();\n@@ -365,0 +367,2 @@\n+  assert(!is_atomic_alloc_region(), \"Must not\");\n+  assert(atomic_top() == nullptr, \"Must be\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.inline.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -380,1 +380,1 @@\n-    if (r->is_cset() || r->is_trash() || r->is_active_alloc_region()) {\n+    if (r->is_cset() || r->is_trash() || r->is_atomic_alloc_region()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}