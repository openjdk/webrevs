{"files":[{"patch":"@@ -80,1 +80,1 @@\n-    assert(!region->is_active_alloc_region(), \"Not expecting any active alloc region at the time\");\n+    assert(!region->is_active_alloc_region(), \"There should be no active alloc regions when choosing collection set\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahGenerationalHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-    assert(!region->is_active_alloc_region(), \"Not expecting any active alloc region at the time\");\n+    assert(!region->is_active_alloc_region(), \"There should be no active alloc regions when rebuilding free set\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-    obj = atomic_allocate_in(r, false, req, in_new_region, ready_for_retire);\n+    obj = allocate_in<false>(r, false, req, in_new_region, ready_for_retire);\n@@ -186,3 +186,3 @@\n-                                                                   bool &in_new_region,\n-                                                                   uint const alloc_start_index,\n-                                                                   uint &regions_ready_for_refresh) {\n+                                                                                    bool &in_new_region,\n+                                                                                    uint const alloc_start_index,\n+                                                                                    uint &regions_ready_for_refresh) {\n@@ -194,1 +194,1 @@\n-      HeapWord* obj = atomic_allocate_in(r, true, req, in_new_region, ready_for_retire);\n+      HeapWord* obj = allocate_in<true>(r, true, req, in_new_region, ready_for_retire);\n@@ -214,1 +214,2 @@\n-HeapWord* ShenandoahAllocator<ALLOC_PARTITION>::atomic_allocate_in(ShenandoahHeapRegion* region, bool const is_alloc_region, ShenandoahAllocRequest &req, bool &in_new_region, bool &ready_for_retire) {\n+template <bool ATOMIC>\n+HeapWord* ShenandoahAllocator<ALLOC_PARTITION>::allocate_in(ShenandoahHeapRegion* region, bool const is_alloc_region, ShenandoahAllocRequest &req, bool &in_new_region, bool &ready_for_retire) {\n@@ -216,0 +217,3 @@\n+  if (ATOMIC) {\n+    shenandoah_assert_heaplocked();\n+  }\n@@ -219,1 +223,1 @@\n-    obj = region->allocate_lab_atomic(req, actual_size, ready_for_retire);\n+    obj = ATOMIC ? region->allocate_lab_atomic(req, actual_size, ready_for_retire) : region->allocate_lab(req, actual_size);\n@@ -221,1 +225,1 @@\n-    obj = region->allocate_atomic(actual_size, req, ready_for_retire);\n+    obj = ATOMIC ? region->allocate_atomic(actual_size, req, ready_for_retire) : region->allocate(req.size(), req);\n@@ -235,0 +239,4 @@\n+\n+    if (!ATOMIC && region->free_words() < PLAB::min_size()) {\n+      ready_for_retire = true;\n+    }\n@@ -293,1 +301,1 @@\n-          *obj = atomic_allocate_in(reserved[i], true, *req, *in_new_region, ready_for_retire);\n+          *obj = allocate_in<false>(reserved[i], true, *req, *in_new_region, ready_for_retire);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAllocator.cpp","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -56,3 +56,5 @@\n-  \/\/ Attempt to allocate\n-  \/\/ It will try to allocate in alloc regions first, if fails it will try to get new alloc regions from free-set\n-  \/\/ and allocate with in the region got from free-set.\n+  \/\/ Attempt to allocate memory to satisfy alloc request.\n+  \/\/ If _alloc_region_count is not 0, it will try to allocate in shared alloc regions first with atomic operations w\/o\n+  \/\/ the need of global heap lock(fast path); when fast path fails, it will call attempt_allocation_slow which takes\n+  \/\/ global heap lock and try to refresh shared alloc regions if they are not refreshed by other mutator thread.\n+  \/\/ If _alloc_region_count is 0, no shared alloc region will be reserved, allocation is always done with global heap lock held.\n@@ -61,1 +63,2 @@\n-  \/\/ Slow path of allocation attempt, it will handle the allocation with heap lock held.\n+  \/\/ Slow path of allocation attempt. When fast path trying to allocate in shared alloc regions fails attempt_allocation_slow will\n+  \/\/ be called to refresh shared alloc regions and allocate memory for the alloc request.\n@@ -64,1 +67,1 @@\n-  \/\/ Attempt to allocate from a region in free set, rather than from any of alloc regions.\n+  \/\/ Attempt to allocate from a region in free set, rather than from any of shared alloc regions.\n@@ -73,2 +76,4 @@\n-  \/\/ Allocate in a region with atomic.\n-  HeapWord* atomic_allocate_in(ShenandoahHeapRegion* region, bool is_alloc_region, ShenandoahAllocRequest &req, bool &in_new_region, bool &ready_for_retire);\n+  \/\/ Allocate in a region, use atomic operations if template parameter ATOMIC is true.\n+  \/\/ When template parameter ATOMIC is false, heap lock is required.\n+  template <bool ATOMIC>\n+  HeapWord* allocate_in(ShenandoahHeapRegion* region, bool is_alloc_region, ShenandoahAllocRequest &req, bool &in_new_region, bool &ready_for_retire);\n@@ -76,1 +81,1 @@\n-  \/\/ Refresh new alloc regions, allocate the object in the new alloc region.\n+  \/\/ Refresh new alloc regions, allocate the object in the new alloc region before making the new alloc region visible to other mutators.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAllocator.hpp","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1954,1 +1954,1 @@\n-    assert(!region->is_active_alloc_region(), \"Not expecting any active alloc region at the time\");\n+    assert(!region->is_active_alloc_region(), \"There should be no active alloc regions when choosing collection set\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}