{"files":[{"patch":"@@ -95,2 +95,2 @@\n-        if (region->reserved_for_direct_allocation()) {\n-          heap->free_set()->release_directly_allocatable_region(region);\n+        if (region->is_active_alloc_region()) {\n+          heap->free_set()->release_alloc_region(region);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahGenerationalHeuristics.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -116,2 +116,2 @@\n-        if (region->reserved_for_direct_allocation()) {\n-          heap->free_set()->release_directly_allocatable_region(region);\n+        if (region->is_active_alloc_region()) {\n+          heap->free_set()->release_alloc_region(region);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -106,2 +106,2 @@\n-    if (r->reserved_for_direct_allocation()) {\n-      _heap->free_set()->release_directly_allocatable_region(r);\n+    if (r->is_active_alloc_region()) {\n+      _heap->free_set()->release_alloc_region(r);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -755,2 +755,2 @@\n-  if (orig_partition == ShenandoahFreeSetPartitionId::Mutator && r->reserved_for_direct_allocation()) {\n-    ShenandoahHeap::heap()->free_set()->release_directly_allocatable_region(r);\n+  if (orig_partition == ShenandoahFreeSetPartitionId::Mutator && r->is_active_alloc_region()) {\n+    ShenandoahHeap::heap()->free_set()->release_alloc_region(r);\n@@ -944,1 +944,1 @@\n-        assert(!validate_totals || r->reserved_for_direct_allocation() || (capacity != _region_size_bytes), \"Should not be retired if empty\");\n+        assert(!validate_totals || r->is_active_alloc_region() || (capacity != _region_size_bytes), \"Should not be retired if empty\");\n@@ -960,1 +960,1 @@\n-          assert(r->is_cset() || r->reserved_for_direct_allocation() || (capacity < PLAB::min_size() * HeapWordSize),\n+          assert(r->is_cset() || r->is_active_alloc_region() || (capacity < PLAB::min_size() * HeapWordSize),\n@@ -1193,1 +1193,1 @@\n-THREAD_LOCAL uint ShenandoahFreeSet::_alloc_region_index = UINT_MAX;\n+THREAD_LOCAL uint ShenandoahFreeSet::_mutator_alloc_region_index = UINT_MAX;\n@@ -1213,3 +1213,3 @@\n-  _direct_allocation_regions = PaddedArray<ShenandoahDirectAllocationRegion, mtGC>::create_unfreeable(ShenandoahDirectlyAllocatableRegionCount);\n-  for (uint i = 0; i < ShenandoahDirectlyAllocatableRegionCount; i++) {\n-    _direct_allocation_regions[i]._address = nullptr;\n+  _mutator_alloc_regions = PaddedArray<ShenandoahAllocRegion, mtGC>::create_unfreeable(ShenandoahMutatorAllocRegionCount);\n+  for (uint i = 0; i < ShenandoahMutatorAllocRegionCount; i++) {\n+    _mutator_alloc_regions[i]._address = nullptr;\n@@ -1391,1 +1391,1 @@\n-    if (!r->reserved_for_direct_allocation() && alloc_capacity(r) >= min_size * HeapWordSize) {\n+    if (!r->is_active_alloc_region() && alloc_capacity(r) >= min_size * HeapWordSize) {\n@@ -1742,1 +1742,1 @@\n-      assert(!_heap->get_region(end)->reserved_for_direct_allocation(), \"Must not\");\n+      assert(!_heap->get_region(end)->is_active_alloc_region(), \"Must not\");\n@@ -2189,1 +2189,1 @@\n-        if (!region->reserved_for_direct_allocation()) {\n+        if (!region->is_active_alloc_region()) {\n@@ -2229,1 +2229,1 @@\n-          \/\/ region->reserved_for_direct_allocation(), a reserved region should count in mutator regions,\n+          \/\/ region->is_active_alloc_region(), a reserved region should count in mutator regions,\n@@ -2930,1 +2930,1 @@\n-    } else if (!r->reserved_for_direct_allocation()) {\n+    } else if (!r->is_active_alloc_region()) {\n@@ -3327,1 +3327,1 @@\n-  while (i < ShenandoahDirectlyAllocatableRegionCount) {\n+  while (i < ShenandoahMutatorAllocRegionCount) {\n@@ -3332,2 +3332,2 @@\n-    uint idx = (start_index + i) % ShenandoahDirectlyAllocatableRegionCount;\n-    ShenandoahDirectAllocationRegion& shared_region = _direct_allocation_regions[idx];\n+    uint idx = (start_index + i) % ShenandoahMutatorAllocRegionCount;\n+    ShenandoahAllocRegion& shared_region = _mutator_alloc_regions[idx];\n@@ -3336,1 +3336,1 @@\n-    if ((r = shared_region._address) != nullptr && r->reserved_for_direct_allocation()) {\n+    if ((r = shared_region._address) != nullptr && r->is_active_alloc_region()) {\n@@ -3365,1 +3365,1 @@\n-    uint next_start_index = ShenandoahDirectlyAllocatableRegionCount;\n+    uint next_start_index = ShenandoahMutatorAllocRegionCount;\n@@ -3373,1 +3373,1 @@\n-      if (next_start_index != ShenandoahDirectlyAllocatableRegionCount) {\n+      if (next_start_index != ShenandoahMutatorAllocRegionCount) {\n@@ -3410,1 +3410,1 @@\n-  PaddedEnd<ShenandoahDirectAllocationRegion>* _direct_allocation_regions;\n+  PaddedEnd<ShenandoahAllocRegion>* _direct_allocation_regions;\n@@ -3425,1 +3425,1 @@\n-  DirectAllocatableRegionRefillClosure(PaddedEnd<ShenandoahDirectAllocationRegion>* direct_allocation_regions, uint start_index, ShenandoahAllocRequest &req, HeapWord* &obj, bool &in_new_region)\n+  DirectAllocatableRegionRefillClosure(PaddedEnd<ShenandoahAllocRegion>* direct_allocation_regions, uint start_index, ShenandoahAllocRequest &req, HeapWord* &obj, bool &in_new_region)\n@@ -3432,1 +3432,1 @@\n-      _next_region_with_sufficient_mem(ShenandoahDirectlyAllocatableRegionCount),\n+      _next_region_with_sufficient_mem(ShenandoahMutatorAllocRegionCount),\n@@ -3438,2 +3438,2 @@\n-    while (_scanned_region < (int) ShenandoahDirectlyAllocatableRegionCount) {\n-      const uint idx = (_start_index + (size_t) _scanned_region) % ShenandoahDirectlyAllocatableRegionCount;\n+    while (_scanned_region < (int) ShenandoahMutatorAllocRegionCount) {\n+      const uint idx = (_start_index + (size_t) _scanned_region) % ShenandoahMutatorAllocRegionCount;\n@@ -3441,1 +3441,1 @@\n-      ShenandoahDirectAllocationRegion& shared_region = _direct_allocation_regions[idx];\n+      ShenandoahAllocRegion& shared_region = _direct_allocation_regions[idx];\n@@ -3448,1 +3448,1 @@\n-        assert(r->reserved_for_direct_allocation(), \"Must be direct allocation reserved region.\");\n+        assert(r->is_active_alloc_region(), \"Must be direct allocation reserved region.\");\n@@ -3454,1 +3454,1 @@\n-        r->release_from_direct_allocation();\n+        r->unset_active_alloc_region();\n@@ -3458,1 +3458,1 @@\n-      if (_obj == nullptr && _next_region_with_sufficient_mem == ShenandoahDirectlyAllocatableRegionCount && r->free() >= _min_req_byte_size) {\n+      if (_obj == nullptr && _next_region_with_sufficient_mem == ShenandoahMutatorAllocRegionCount && r->free() >= _min_req_byte_size) {\n@@ -3469,1 +3469,1 @@\n-    if (r->reserved_for_direct_allocation()) return false;\n+    if (r->is_active_alloc_region()) return false;\n@@ -3498,1 +3498,1 @@\n-      ShenandoahDirectAllocationRegion& shared_region = _direct_allocation_regions[_next_retire_eligible_region];\n+      ShenandoahAllocRegion& shared_region = _direct_allocation_regions[_next_retire_eligible_region];\n@@ -3500,1 +3500,1 @@\n-      r->reserve_for_direct_allocation();\n+      r->set_active_alloc_region();\n@@ -3525,1 +3525,1 @@\n-  assert(start_index < ShenandoahDirectlyAllocatableRegionCount, \"Must be\");\n+  assert(start_index < ShenandoahMutatorAllocRegionCount, \"Must be\");\n@@ -3529,1 +3529,1 @@\n-  DirectAllocatableRegionRefillClosure cl(_direct_allocation_regions, start_index, req, obj, in_new_region);\n+  DirectAllocatableRegionRefillClosure cl(_mutator_alloc_regions, start_index, req, obj, in_new_region);\n@@ -3531,1 +3531,1 @@\n-  if (cl._next_region_with_sufficient_mem != ShenandoahDirectlyAllocatableRegionCount && obj == nullptr) {\n+  if (cl._next_region_with_sufficient_mem != ShenandoahMutatorAllocRegionCount && obj == nullptr) {\n@@ -3547,1 +3547,1 @@\n-void ShenandoahFreeSet::release_all_directly_allocatable_regions() {\n+void ShenandoahFreeSet::release_all_alloc_regions() {\n@@ -3550,2 +3550,2 @@\n-  for (uint i = 0; i < ShenandoahDirectlyAllocatableRegionCount; i++) {\n-    ShenandoahDirectAllocationRegion& shared_region = _direct_allocation_regions[i];\n+  for (uint i = 0; i < ShenandoahMutatorAllocRegionCount; i++) {\n+    ShenandoahAllocRegion& shared_region = _mutator_alloc_regions[i];\n@@ -3554,1 +3554,1 @@\n-      assert(r->reserved_for_direct_allocation(), \"Must be\");\n+      assert(r->is_active_alloc_region(), \"Must be\");\n@@ -3556,1 +3556,1 @@\n-      r->release_from_direct_allocation();\n+      r->unset_active_alloc_region();\n@@ -3570,1 +3570,1 @@\n-void ShenandoahFreeSet::release_directly_allocatable_region(ShenandoahHeapRegion* region) {\n+void ShenandoahFreeSet::release_alloc_region(ShenandoahHeapRegion* region) {\n@@ -3574,2 +3574,2 @@\n-  for (uint i = 0u; i < ShenandoahDirectlyAllocatableRegionCount; i++) {\n-    ShenandoahDirectAllocationRegion& shared_region = _direct_allocation_regions[i];\n+  for (uint i = 0u; i < ShenandoahMutatorAllocRegionCount; i++) {\n+    ShenandoahAllocRegion& shared_region = _mutator_alloc_regions[i];\n@@ -3581,1 +3581,1 @@\n-  region->release_from_direct_allocation();\n+  region->unset_active_alloc_region();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":43,"deletions":43,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -443,1 +443,1 @@\n-struct ShenandoahDirectAllocationRegion {\n+struct ShenandoahAllocRegion {\n@@ -460,2 +460,2 @@\n-  PaddedEnd<ShenandoahDirectAllocationRegion>* _direct_allocation_regions;\n-  static THREAD_LOCAL uint _alloc_region_index;\n+  PaddedEnd<ShenandoahAllocRegion>* _mutator_alloc_regions;\n+  static THREAD_LOCAL uint _mutator_alloc_region_index;\n@@ -685,2 +685,2 @@\n-    if (_alloc_region_index == UINT_MAX) {\n-      _alloc_region_index = abs(os::random()) % ShenandoahDirectlyAllocatableRegionCount;\n+    if (_mutator_alloc_region_index == UINT_MAX) {\n+      _mutator_alloc_region_index = abs(os::random()) % ShenandoahMutatorAllocRegionCount;\n@@ -688,1 +688,1 @@\n-    return _alloc_region_index;\n+    return _mutator_alloc_region_index;\n@@ -852,1 +852,1 @@\n-  void release_all_directly_allocatable_regions();\n+  void release_all_alloc_regions();\n@@ -854,1 +854,1 @@\n-  void release_directly_allocatable_region(ShenandoahHeapRegion *region);\n+  void release_alloc_region(ShenandoahHeapRegion *region);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -222,1 +222,1 @@\n-    heap->free_set()->release_all_directly_allocatable_regions();\n+    heap->free_set()->release_all_alloc_regions();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -577,1 +577,1 @@\n-        if (!heap->is_concurrent_old_mark_in_progress() && tams == original_top && !r->reserved_for_direct_allocation()) {\n+        if (!heap->is_concurrent_old_mark_in_progress() && tams == original_top && !r->is_active_alloc_region()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-  _direct_alloc_reserved.unset();\n+  _active_alloc_region.unset();\n@@ -862,1 +862,1 @@\n-  assert(new_affiliation != OLD_GENERATION || !reserved_for_direct_allocation(), \"Reserved region can't move to old\");\n+  assert(new_affiliation != OLD_GENERATION || !is_active_alloc_region(), \"Reserved region can't move to old\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -271,1 +271,1 @@\n-  ShenandoahSharedFlag _direct_alloc_reserved; \/\/ Flag to indicate that whether the region is reserved for lock-free direct allocation\n+  ShenandoahSharedFlag _active_alloc_region; \/\/ Flag indicates that whether the region is an active alloc region.\n@@ -532,3 +532,3 @@\n-  inline void reserve_for_direct_allocation() {\n-    assert(_direct_alloc_reserved.is_unset(), \"Must be\");\n-    _direct_alloc_reserved.set();\n+  inline void set_active_alloc_region() {\n+    assert(_active_alloc_region.is_unset(), \"Must be\");\n+    _active_alloc_region.set();\n@@ -537,3 +537,3 @@\n-  inline void release_from_direct_allocation() {\n-    assert(_direct_alloc_reserved.is_set(), \"Must be\");\n-    _direct_alloc_reserved.unset();\n+  inline void unset_active_alloc_region() {\n+    assert(_active_alloc_region.is_set(), \"Must be\");\n+    _active_alloc_region.unset();\n@@ -542,2 +542,2 @@\n-  inline bool reserved_for_direct_allocation() const {\n-    return _direct_alloc_reserved.is_set();\n+  inline bool is_active_alloc_region() const {\n+    return _active_alloc_region.is_set();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-    if (!reserved_for_direct_allocation()) {\n+    if (!is_active_alloc_region()) {\n@@ -178,1 +178,1 @@\n-    if (!reserved_for_direct_allocation()) {\n+    if (!is_active_alloc_region()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -380,1 +380,1 @@\n-    if (r->is_cset() || r->is_trash() || r->reserved_for_direct_allocation()) {\n+    if (r->is_cset() || r->is_trash() || r->is_active_alloc_region()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -553,1 +553,1 @@\n-  product(uintx, ShenandoahDirectlyAllocatableRegionCount, 13, EXPERIMENTAL,\\\n+  product(uintx, ShenandoahMutatorAllocRegionCount, 13, EXPERIMENTAL,\\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}