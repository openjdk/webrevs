{"files":[{"patch":"@@ -277,1 +277,1 @@\n-      region->concurrent_set_update_watermark(region->top());\n+      region->concurrent_set_update_watermark(IS_SHARED_ALLOC_REGION ? region->volatile_top() : region->top());\n@@ -304,1 +304,1 @@\n-    const size_t free_bytes = region == nullptr ? 0 : region->free();\n+    const size_t free_bytes = region == nullptr ? 0 : region->free_bytes_for_atomic_alloc();\n@@ -337,6 +337,0 @@\n-          if (ready_for_retire) {\n-            log_debug(gc, alloc)(\"%sAllocator: heap region %li has no space left after satisfying alloc req.\",\n-              _alloc_partition_name, reserved[i]->index());\n-            reserved[i]->unset_active_alloc_region();\n-            continue;\n-          }\n@@ -344,0 +338,1 @@\n+        reserved[i]->set_active_alloc_region();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAllocator.cpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3178,1 +3178,0 @@\n-    r->set_active_alloc_region();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+  _volatile_top(start + RegionSizeWords),\n@@ -575,0 +576,2 @@\n+  assert(!is_active_alloc_region(), \"Must not be active alloc region\");\n+  assert(volatile_top() == end(), \"Must be\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -253,1 +253,2 @@\n-  HeapWord* volatile _top;\n+  HeapWord* volatile _volatile_top;\n+  HeapWord*          _top;\n@@ -458,0 +459,4 @@\n+  HeapWord* volatile_top() const {\n+    return AtomicAccess::load(&_volatile_top);\n+  }\n+\n@@ -459,1 +464,1 @@\n-    return AtomicAccess::load(&_top);\n+    return is_active_alloc_region() ? volatile_top() : _top;\n@@ -462,1 +467,1 @@\n-    AtomicAccess::store(&_top, v);\n+    _top = v;\n@@ -476,1 +481,4 @@\n-\n+  size_t free_bytes_for_atomic_alloc() const {\n+    assert(is_active_alloc_region(), \"Must be\");\n+    return byte_size(volatile_top(),    end());\n+  }\n@@ -548,0 +556,2 @@\n+    \/\/ Sync _top to _volatile_top before setting _active_alloc_region flag to prepare for CAS allocation\n+    AtomicAccess::store(&_volatile_top, _top);\n@@ -551,0 +561,3 @@\n+  \/\/ Unset a heap region as active alloc region,\n+  \/\/ This method should be only called from ShenandoahAllocator::refresh_alloc_regions or ShenandoahAllocator::release_alloc_regions\n+  \/\/ when the region is removed from the alloc region array in ShenandoahAllocator.\n@@ -552,0 +565,13 @@\n+    shenandoah_assert_heaplocked();\n+\n+    \/\/ Before unset _active_alloc_region flag, _volatile_top needs to be set to the end of region,\n+    \/\/ this avoid race condition when the alloc region removed from the alloc regions array used by lock-free allocation in allocator.\n+    HeapWord* current_volatile_top = volatile_top();\n+    while (current_volatile_top != end() &&\n+           AtomicAccess::cmpxchg(&_volatile_top, current_volatile_top, end()) != current_volatile_top) {\n+      \/\/ Failed to exchange _volatile_top with end, get new _volatile_top and retry\n+      current_volatile_top = volatile_top();\n+    }\n+    set_top(current_volatile_top); \/\/ Sync current _volatile_top back to _top\n+\n+    assert(is_active_alloc_region(), \"Must be\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":30,"deletions":4,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -174,1 +174,1 @@\n-    HeapWord* obj = top();\n+    HeapWord* obj = volatile_top();\n@@ -198,1 +198,1 @@\n-    HeapWord* obj = top();\n+    HeapWord* obj = volatile_top();\n@@ -223,1 +223,1 @@\n-  if (AtomicAccess::cmpxchg(&_top, obj, new_top) == obj) {\n+  if (AtomicAccess::cmpxchg(&_volatile_top, obj, new_top) == obj) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,14 +33,19 @@\n-#define VM_STRUCTS_SHENANDOAH(nonstatic_field, volatile_nonstatic_field, static_field)                \\\n-  nonstatic_field(ShenandoahHeap, _num_regions,                    size_t)                            \\\n-  nonstatic_field(ShenandoahHeap, _regions,                        ShenandoahHeapRegion**)            \\\n-  nonstatic_field(ShenandoahHeap, _log_min_obj_alignment_in_bytes, int)                               \\\n-  nonstatic_field(ShenandoahHeap, _free_set,                       ShenandoahFreeSet*)                \\\n-  volatile_nonstatic_field(ShenandoahHeap, _committed,             size_t)                            \\\n-  static_field(ShenandoahHeapRegion, RegionSizeBytes,              size_t)                            \\\n-  static_field(ShenandoahHeapRegion, RegionSizeBytesShift,         size_t)                            \\\n-  volatile_nonstatic_field(ShenandoahHeapRegion, _state,           ShenandoahHeapRegion::RegionState) \\\n-  nonstatic_field(ShenandoahHeapRegion, _index,                    size_t const)                      \\\n-  nonstatic_field(ShenandoahHeapRegion, _bottom,                   HeapWord* const)                   \\\n-  volatile_nonstatic_field(ShenandoahHeapRegion, _top,             HeapWord*)                         \\\n-  nonstatic_field(ShenandoahHeapRegion, _end,                      HeapWord* const)                   \\\n-  nonstatic_field(ShenandoahFreeSet, _total_global_used,           size_t)                            \\\n+#define VM_STRUCTS_SHENANDOAH(nonstatic_field, volatile_nonstatic_field, static_field)                    \\\n+  nonstatic_field(ShenandoahHeap, _num_regions,                        size_t)                            \\\n+  nonstatic_field(ShenandoahHeap, _regions,                            ShenandoahHeapRegion**)            \\\n+  nonstatic_field(ShenandoahHeap, _log_min_obj_alignment_in_bytes,     int)                               \\\n+  nonstatic_field(ShenandoahHeap, _free_set,                           ShenandoahFreeSet*)                \\\n+  volatile_nonstatic_field(ShenandoahHeap, _committed,                 size_t)                            \\\n+  static_field(ShenandoahHeapRegion, RegionSizeBytes,                  size_t)                            \\\n+  static_field(ShenandoahHeapRegion, RegionSizeBytesShift,             size_t)                            \\\n+  volatile_nonstatic_field(ShenandoahHeapRegion, _state,               ShenandoahHeapRegion::RegionState) \\\n+  nonstatic_field(ShenandoahHeapRegion, _index,                        size_t const)                      \\\n+  nonstatic_field(ShenandoahHeapRegion, _bottom,                       HeapWord* const)                   \\\n+  volatile_nonstatic_field(ShenandoahHeapRegion, _volatile_top,        HeapWord*)                         \\\n+  volatile_nonstatic_field(ShenandoahHeapRegion, _tlab_allocs,         size_t)                            \\\n+  volatile_nonstatic_field(ShenandoahHeapRegion, _gclab_allocs,        size_t)                            \\\n+  volatile_nonstatic_field(ShenandoahHeapRegion, _plab_allocs,         size_t)                            \\\n+  volatile_nonstatic_field(ShenandoahHeapRegion, _age,                 uint)                              \\\n+  CENSUS_NOISE(volatile_nonstatic_field(ShenandoahHeapRegion, _youth,  uint))                             \\\n+  nonstatic_field(ShenandoahHeapRegion, _end,                          HeapWord* const)                   \\\n+  nonstatic_field(ShenandoahFreeSet, _total_global_used,               size_t)                            \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/vmStructs_shenandoah.hpp","additions":19,"deletions":14,"binary":false,"changes":33,"status":"modified"}]}