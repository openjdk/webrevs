{"files":[{"patch":"@@ -126,1 +126,1 @@\n-  HeapWord* obj = attempt_allocation_in_alloc_regions(req, in_new_region, alloc_start_index(), regions_ready_for_refresh);\n+  HeapWord* obj = attempt_allocation_in_alloc_regions<true \/*holding heap lock*\/>(req, in_new_region, alloc_start_index(), regions_ready_for_refresh);\n@@ -185,0 +185,1 @@\n+template<bool HOLDING_HEAP_LOCK>\n@@ -192,1 +193,1 @@\n-    if (ShenandoahHeapRegion* r = nullptr; (r = AtomicAccess::load(&_alloc_regions[i].address)) != nullptr) {\n+    if (ShenandoahHeapRegion* r = nullptr; (r = HOLDING_HEAP_LOCK ? _alloc_regions[i].address : AtomicAccess::load(&_alloc_regions[i].address)) != nullptr) {\n@@ -402,15 +403,0 @@\n-#ifdef ASSERT\n-void ShenandoahMutatorAllocator::verify(ShenandoahAllocRequest& req) {\n-  assert(req.is_mutator_alloc(), \"Must be mutator alloc request.\");\n-}\n-\n-void ShenandoahCollectorAllocator::verify(ShenandoahAllocRequest& req) {\n-  assert(req.is_gc_alloc() && req.affiliation() == YOUNG_GENERATION, \"Must be gc alloc request in young gen.\");\n-}\n-\n-void ShenandoahOldCollectorAllocator::verify(ShenandoahAllocRequest& req) {\n-  assert(req.is_gc_alloc() && req.affiliation() == OLD_GENERATION, \"Must be gc alloc request in young gen.\");\n-}\n-#endif \/\/ ASSERT\n-\n-\n@@ -443,1 +429,1 @@\n-  if (req.is_old() && !old_gen->can_allocate(req)) {\n+  if (!old_gen->can_allocate(req)) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAllocator.cpp","additions":4,"deletions":18,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+  template<bool HOLDING_HEAP_LOCK = false>\n@@ -83,0 +84,1 @@\n+\n@@ -84,1 +86,16 @@\n-  virtual void verify(ShenandoahAllocRequest& req) { }\n+  void verify(ShenandoahAllocRequest& req) {\n+    switch (ALLOC_PARTITION) {\n+      case ShenandoahFreeSetPartitionId::Mutator:\n+        assert(req.is_mutator_alloc(), \"Must be mutator alloc request\");\n+        assert(Thread::current()->is_Java_thread(), \"Must be Java thread\");\n+        break;\n+      case ShenandoahFreeSetPartitionId::Collector:\n+        assert(req.is_gc_alloc() && req.affiliation() == YOUNG_GENERATION, \"Must be gc alloc request in young gen\");\n+        break;\n+      case ShenandoahFreeSetPartitionId::OldCollector:\n+        assert(req.is_gc_alloc() && req.affiliation() == OLD_GENERATION, \"Must be gc alloc request in old gen\");\n+        break;\n+      default:\n+        assert(false, \"Should not be here\");\n+    }\n+  }\n@@ -93,1 +110,1 @@\n-  \/\/ Handle the allocation request.\n+  \/\/ Handle the allocation request - entry point of memory allocation, including humongous allocation.\n@@ -105,4 +122,0 @@\n-#ifdef ASSERT\n-  void verify(ShenandoahAllocRequest& req) override;\n-#endif \/\/ ASSERT\n-\n@@ -115,3 +128,0 @@\n-#ifdef ASSERT\n-  void verify(ShenandoahAllocRequest& req) override;\n-#endif \/\/ ASSERT\n@@ -123,1 +133,1 @@\n-\/\/ because of the complexity in plab allocation where we have specialised logic to handle card table size alignment.\n+\/\/ because of the complexity in plab allocation where we have specialized logic to handle card table size alignment.\n@@ -127,3 +137,0 @@\n-#ifdef ASSERT\n-  void verify(ShenandoahAllocRequest& req) override;\n-#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAllocator.hpp","additions":20,"deletions":13,"binary":false,"changes":33,"status":"modified"}]}