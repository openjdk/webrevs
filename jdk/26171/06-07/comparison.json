{"files":[{"patch":"@@ -3391,2 +3391,1 @@\n-HeapWord* ShenandoahFreeSet::cas_allocate_single_for_mutator(\n-  uint probe_start, uint probe_count, ShenandoahAllocRequest &req, bool &in_new_region) {\n+HeapWord* ShenandoahFreeSet::cas_allocate_single_for_mutator(uint start_index, ShenandoahAllocRequest &req, bool &in_new_region) {\n@@ -3395,1 +3394,1 @@\n-  while (i < probe_count) {\n+  while (i < ShenandoahDirectlyAllocatableRegionCount) {\n@@ -3400,1 +3399,1 @@\n-    uint idx = (probe_start + i) % ShenandoahDirectlyAllocatableRegionCount;\n+    uint idx = (start_index + i) % ShenandoahDirectlyAllocatableRegionCount;\n@@ -3414,0 +3413,1 @@\n+\n@@ -3425,1 +3425,0 @@\n-  const uint max_probes = ShenandoahDirectAllocationMaxProbes;\n@@ -3428,1 +3427,1 @@\n-    obj = cas_allocate_single_for_mutator<IS_TLAB>(start_idx, max_probes, req, in_new_region);\n+    obj = cas_allocate_single_for_mutator<IS_TLAB>(start_idx, req, in_new_region);\n@@ -3434,1 +3433,1 @@\n-    if (!try_allocate_directly_allocatable_regions(start_idx, false, req, obj, in_new_region, next_start_index)) {\n+    if (!try_allocate_directly_allocatable_regions(start_idx, req, obj, in_new_region, next_start_index)) {\n@@ -3440,0 +3439,1 @@\n+      \/\/ This only happens when other thread wins the race to refresh the regions.\n@@ -3443,12 +3443,0 @@\n-        \/\/ try to steal from other directly allocatable regions\n-        uint steal_alloc_start_idx = (start_idx + max_probes) % ShenandoahDirectlyAllocatableRegionCount;\n-        uint steal_alloc_probes = ShenandoahDirectlyAllocatableRegionCount - max_probes;\n-        obj = cas_allocate_single_for_mutator<IS_TLAB>(steal_alloc_start_idx,\n-                                                       steal_alloc_probes,\n-                                                       req,\n-                                                       in_new_region);\n-        if (obj != nullptr) {\n-          return obj;\n-        }\n-\n-        \/\/ No new directly allocatable region, no existing region directly allocatable region has sufficient memory.\n@@ -3492,3 +3480,0 @@\n-  \/\/ exclusive\n-  const uint _probe_end_index;\n-  const bool _replace_all_eligible_regions;\n@@ -3507,1 +3492,1 @@\n-  DirectAllocatableRegionRefillClosure(PaddedEnd<ShenandoahDirectAllocationRegion>* direct_allocation_regions, uint start_index, bool replace_all_eligible_regions, ShenandoahAllocRequest &req, HeapWord* &obj, bool &in_new_region)\n+  DirectAllocatableRegionRefillClosure(PaddedEnd<ShenandoahDirectAllocationRegion>* direct_allocation_regions, uint start_index, ShenandoahAllocRequest &req, HeapWord* &obj, bool &in_new_region)\n@@ -3510,2 +3495,0 @@\n-      _probe_end_index((start_index + 3) % ShenandoahDirectlyAllocatableRegionCount),\n-      _replace_all_eligible_regions(replace_all_eligible_regions),\n@@ -3521,4 +3504,0 @@\n-  bool is_probing_region(const uint index) const {\n-    return !(index >= _probe_end_index && index < _start_index);\n-  }\n-\n@@ -3526,3 +3505,1 @@\n-    int const max_regions_to_scan = static_cast<int>(_replace_all_eligible_regions ? ShenandoahDirectlyAllocatableRegionCount\n-                                                                                   : ShenandoahDirectAllocationMaxProbes);\n-    while (_scanned_region < max_regions_to_scan) {\n+    while (_scanned_region < (int) ShenandoahDirectlyAllocatableRegionCount) {\n@@ -3540,1 +3517,0 @@\n-        OrderAccess::fence();\n@@ -3595,1 +3571,0 @@\n-      OrderAccess::fence();\n@@ -3612,1 +3587,0 @@\n-                                                                  bool replace_all_eligible_regions,\n@@ -3622,1 +3596,1 @@\n-  DirectAllocatableRegionRefillClosure cl(_direct_allocation_regions, start_index, replace_all_eligible_regions, req, obj, in_new_region);\n+  DirectAllocatableRegionRefillClosure cl(_direct_allocation_regions, start_index, req, obj, in_new_region);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":10,"deletions":36,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -685,1 +685,1 @@\n-    uint probe_start, uint probe_count, ShenandoahAllocRequest &req, bool &in_new_region);\n+    uint start_index, ShenandoahAllocRequest &req, bool &in_new_region);\n@@ -690,0 +690,10 @@\n+  \/\/ Try to allocate and refresh directly allocatable regions with heap lock held.\n+  \/\/ It may allocate the object in the region before checking the free bytes of the region, so it may end up\n+  \/\/ allocating the object in region which has sufficient space for the alloc reqeust, but won't reserve the region for\n+  \/\/ CAS alloc because there is not more enough space left.\n+  \/\/ return true if any region is reserved for CAS alloc, which also implies the obj should have been allocated.\n+  \/\/ return false if no new region is reserved for CAS alloc, in this case there some specific scenarios we need to consider:\n+  \/\/  1. the obj may have been allocated in a region with only sufficient space for the alloc req.\n+  \/\/  2. there is no regions can be reserved for CAS alloc, but there is existing directly allocatable region with enough space, this happens\n+  \/\/     when there is other mutator thread contending the lock to refresh the regions.\n+  \/\/     In this scenario, the new_start_index will be set the index of the directly allocatable region.\n@@ -691,1 +701,0 @@\n-                                                 bool replace_all_eligible_regions,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -557,5 +557,0 @@\n-         range(1, 128)                                                      \\\n-                                                                            \\\n-  product(uintx, ShenandoahDirectAllocationMaxProbes, 3, EXPERIMENTAL,      \\\n-         \"Max number of region to probe for direct allocation without \"     \\\n-         \"stealing space from other directly allocatable regions.    \")     \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"}]}