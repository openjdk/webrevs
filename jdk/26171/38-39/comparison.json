{"files":[{"patch":"@@ -197,1 +197,0 @@\n-  HeapWord* obj;\n@@ -203,1 +202,1 @@\n-    obj = allocate_in<false>(r, false, req, in_new_region, ready_for_retire);\n+    HeapWord *obj = allocate_in<false>(r, false, req, in_new_region, ready_for_retire);\n@@ -433,1 +432,1 @@\n-  ShenandoahAllocator((uint) ShenandoahMutatorAllocRegions, free_set) {\n+  ShenandoahAllocator(static_cast<uint>(ShenandoahMutatorAllocRegions), free_set) {\n@@ -438,1 +437,1 @@\n-  ShenandoahAllocator((uint) ShenandoahCollectorAllocRegions, free_set) {\n+  ShenandoahAllocator(static_cast<uint>(ShenandoahCollectorAllocRegions), free_set) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAllocator.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-  \/\/ Call must not hold heap lock.\n+  \/\/ Caller must not hold heap lock.\n@@ -89,1 +89,1 @@\n-  \/\/ Caller has to hold heap lock.\n+  \/\/ Caller must hold the heap lock.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAllocator.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -516,2 +516,12 @@\n-    if (current != 0) {\n-      AtomicAccess::store(&_age, uint(0));\n+    \/\/ return immediately in fast path when current age is 0\n+    if (current == 0u) return;\n+    \/\/ reset_age can be called from multiple mutator\/worker threads concurrently w\/o heap lock,\n+    \/\/ if no need to update census noise, there is no need to use cmpxchg here.\n+    \/\/ The while loop with cmpxchg is to make sure we don't duplicately count the age in census noise.\n+    uint old = current;\n+    while ((current = AtomicAccess::cmpxchg(&_age, old, 0u)) != old &&\n+           current != 0u) {\n+      old = current;\n+    }\n+    if (current != 0u) {\n+      \/\/ Only the thread successfully resets age should update census noise\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"}]}