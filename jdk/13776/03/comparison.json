{"files":[{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright (c) 2023 Red Hat, Inc. All rights reserved.\n@@ -76,1 +77,1 @@\n-template <size_t smallest_word_size, int num_lists>\n+template <int num_lists>\n@@ -81,5 +82,1 @@\n-    const size_t _word_size;\n-    Block(Block* next, size_t word_size) :\n-      _next(next),\n-      _word_size(word_size)\n-    {}\n+    Block(Block* next) : _next(next) {}\n@@ -88,2 +85,2 @@\n-#define BLOCK_FORMAT          \"Block @\" PTR_FORMAT \": size: \" SIZE_FORMAT \", next: \" PTR_FORMAT\n-#define BLOCK_FORMAT_ARGS(b)  p2i(b), (b)->_word_size, p2i((b)->_next)\n+#define BLOCK_FORMAT              \"Block @\" PTR_FORMAT \": size: \" SIZE_FORMAT \", next: \" PTR_FORMAT\n+#define BLOCK_FORMAT_ARGS(b, sz)  p2i(b), (sz), p2i((b)->_next)\n@@ -91,2 +88,2 @@\n-  \/\/ Smallest block size must be large enough to hold a Block structure.\n-  STATIC_ASSERT(smallest_word_size * sizeof(MetaWord) >= sizeof(Block));\n+  \/\/ Block size must be exactly one word size.\n+  STATIC_ASSERT(sizeof(Block) == BytesPerWord);\n@@ -98,1 +95,1 @@\n-  const static size_t MinWordSize = smallest_word_size;\n+  const static size_t MinWordSize = 1;\n@@ -101,1 +98,1 @@\n-  const static size_t MaxWordSize = MinWordSize + num_lists - 1;\n+  const static size_t MaxWordSize = num_lists;\n@@ -117,1 +114,1 @@\n-    return MinWordSize + index;\n+    return index + MinWordSize;\n@@ -130,0 +127,13 @@\n+#ifdef ASSERT\n+  static const uintptr_t canary = 0xFFEEFFEE;\n+  static void write_canary(MetaWord* p, size_t word_size) {\n+    if (word_size > 1) { \/\/ 1-word-sized blocks have no space for a canary\n+      ((uintptr_t*)p)[word_size - 1] = canary;\n+    }\n+  }\n+  static bool check_canary(const Block* b, size_t word_size) {\n+    return word_size == 1 || \/\/ 1-word-sized blocks have no space for a canary\n+           ((const uintptr_t*)b)[word_size - 1] == canary;\n+  }\n+#endif\n+\n@@ -141,0 +151,1 @@\n+    DEBUG_ONLY(write_canary(p, word_size);)\n@@ -143,1 +154,1 @@\n-    Block* new_head = new(p)Block(old_head, word_size);\n+    Block* new_head = new(p)Block(old_head);\n@@ -159,3 +170,2 @@\n-      assert(b->_word_size >= word_size &&\n-             b->_word_size == real_word_size,\n-             \"bad block size in list[%d] (\" BLOCK_FORMAT \")\", index, BLOCK_FORMAT_ARGS(b));\n+      assert(check_canary(b, real_word_size),\n+             \"bad block in list[%d] (\" BLOCK_FORMAT \")\", index, BLOCK_FORMAT_ARGS(b, real_word_size));\n@@ -184,1 +194,1 @@\n-      const size_t s = MinWordSize + i;\n+      const size_t s = word_size_for_index(i);\n@@ -187,3 +197,1 @@\n-        assert(b->_word_size == s,\n-               \"bad block size in list[%d] at pos %d (\" BLOCK_FORMAT \")\",\n-               i, pos, BLOCK_FORMAT_ARGS(b));\n+        assert(check_canary(b, s), \"\");\n@@ -199,1 +207,1 @@\n-typedef BinListImpl<2, 32> BinList32;\n+typedef BinListImpl<32> BinList32;\n","filename":"src\/hotspot\/share\/memory\/metaspace\/binList.hpp","additions":30,"deletions":22,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-  assert(word_size >= MinWordSize, \"sanity (\" SIZE_FORMAT \")\", word_size);\n@@ -43,2 +42,0 @@\n-  assert(requested_word_size >= MinWordSize,\n-      \"requested_word_size too small (\" SIZE_FORMAT \")\", requested_word_size);\n@@ -56,1 +53,1 @@\n-    if (waste > MinWordSize) {\n+    if (waste >= MinWordSize) {\n","filename":"src\/hotspot\/share\/memory\/metaspace\/freeBlocks.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-  if (remaining_words > FreeBlocks::MinWordSize) {\n+  if (remaining_words >= FreeBlocks::MinWordSize) {\n@@ -104,0 +104,4 @@\n+  assert(p != nullptr, \"p is null\");\n+  assert_is_aligned_metaspace_pointer(p);\n+  assert(word_size > 0, \"zero sized\");\n+\n@@ -234,2 +238,3 @@\n-      UL2(trace, \"taken from fbl (now: %d, \" SIZE_FORMAT \").\",\n-          _fbl->count(), _fbl->total_size());\n+      UL2(trace, \"returning \" PTR_FORMAT \" - taken from fbl (now: %d, \" SIZE_FORMAT \").\",\n+          p2i(p), _fbl->count(), _fbl->total_size());\n+      assert_is_aligned_metaspace_pointer(p);\n@@ -244,1 +249,1 @@\n-  p = allocate_inner(requested_word_size);\n+  p = allocate_inner(raw_word_size);\n@@ -352,0 +357,3 @@\n+\n+  assert_is_aligned_metaspace_pointer(p);\n+\n@@ -368,0 +376,5 @@\n+  \/\/ Only blocks that had been allocated via MetaspaceArena::allocate(size) must be handed in\n+  \/\/ to MetaspaceArena::deallocate(), and only with the same size that had been original used for allocation.\n+  \/\/ Therefore the pointer must be aligned correctly, and size can be alignment-adjusted (the latter\n+  \/\/ only matters on 32-bit):\n+  assert_is_aligned_metaspace_pointer(p);\n@@ -369,0 +382,1 @@\n+\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceArena.cpp","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -171,18 +171,0 @@\n-\/\/ Given a net allocation word size, return the raw word size we actually allocate.\n-\/\/ Note: externally visible for gtests.\n-\/\/static\n-size_t get_raw_word_size_for_requested_word_size(size_t word_size) {\n-  size_t byte_size = word_size * BytesPerWord;\n-\n-  \/\/ Deallocated metablocks are kept in a binlist which limits their minimal\n-  \/\/  size to at least the size of a binlist item (2 words).\n-  byte_size = MAX2(byte_size, FreeBlocks::MinWordSize * BytesPerWord);\n-\n-  \/\/ Metaspace allocations are aligned to word size.\n-  byte_size = align_up(byte_size, AllocationAlignmentByteSize);\n-\n-  size_t raw_word_size = byte_size \/ BytesPerWord;\n-  assert(raw_word_size * BytesPerWord == byte_size, \"Sanity\");\n-  return raw_word_size;\n-}\n-\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceCommon.cpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -41,2 +41,3 @@\n-\/\/ 1) Metaspace allocations have to be aligned such that 64bit values are aligned\n-\/\/  correctly.\n+\/\/ Metaspace allocations have to be aligned such that 64-bit values are aligned\n+\/\/  correctly. We currently don't hold members with a larger alignment requirement\n+\/\/  than 64-bit inside MetaData, so 8-byte alignment is enough.\n@@ -44,1 +45,2 @@\n-\/\/ 2) Klass* structures allocated from Metaspace have to be aligned to KlassAlignmentInBytes.\n+\/\/ Klass* structures need to be aligned to KlassAlignmentInBytes, but since that is\n+\/\/ 64-bit, we don't need special handling for allocating Klass*.\n@@ -46,5 +48,1 @@\n-\/\/ At the moment LogKlassAlignmentInBytes is 3, so KlassAlignmentInBytes == 8,\n-\/\/  so (1) and (2) can both be fulfilled with an alignment of 8. Should we increase\n-\/\/  KlassAlignmentInBytes at any time this will increase the necessary alignment as well. In\n-\/\/  that case we may think about introducing a separate alignment just for the class space\n-\/\/  since that alignment would only be needed for Klass structures.\n+\/\/ On 64-bit platforms, we align to word size; on 32-bit, we align to two words.\n@@ -57,2 +55,7 @@\n-\/\/ Returns the raw word size allocated for a given net allocation\n-size_t get_raw_word_size_for_requested_word_size(size_t word_size);\n+\/\/ Returns the raw word size allocated for a given net allocation. This only matters on 32-bit, where\n+\/\/ allocations have to be 64-bit aligned too and therefore must be 2-word-aligned.\n+inline size_t get_raw_word_size_for_requested_word_size(size_t word_size) {\n+  LP64_ONLY(STATIC_ASSERT(AllocationAlignmentWordSize == 1)); \/\/ rewrite if this does not hold true anymore\n+  return LP64_ONLY(word_size) \/\/ no-op on 64-bit\n+         NOT_LP64(align_up(word_size, AllocationAlignmentWordSize));\n+}\n@@ -84,0 +87,2 @@\n+#define assert_is_aligned_metaspace_pointer(p) \\\n+  assert_is_aligned((p), metaspace::AllocationAlignmentByteSize);\n@@ -86,0 +91,1 @@\n+#define assert_is_aligned_metaspace_pointer(pointer)\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceCommon.hpp","additions":16,"deletions":10,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -49,2 +49,1 @@\n-  static const size_t minws;\n-  static const size_t maxws;\n+    static const size_t maxws;\n@@ -60,1 +59,1 @@\n-    size_t innocous_size = minws + ((maxws - minws) \/ 2);\n+    size_t innocous_size = MAX2((size_t)1, maxws \/ 2);\n@@ -91,2 +90,2 @@\n-    for (size_t s1 = minws; s1 <= maxws; s1++) {\n-      for (size_t s2 = minws; s2 <= maxws; s2++) {\n+    for (size_t s1 = 1; s1 <= maxws; s1++) {\n+      for (size_t s2 = 1; s2 <= maxws; s2++) {\n@@ -111,1 +110,1 @@\n-          p = bl.remove_block(minws, &real_size);\n+          p = bl.remove_block(1, &real_size);\n@@ -132,1 +131,1 @@\n-    RandSizeGenerator rgen(minws, maxws + 1);\n+    RandSizeGenerator rgen(1, maxws + 1);\n@@ -187,1 +186,1 @@\n-        MetaWord* p = bl[which].remove_block(minws, &real_size);\n+        MetaWord* p = bl[which].remove_block(1, &real_size);\n@@ -190,1 +189,1 @@\n-        ASSERT_GE(real_size, minws);\n+        ASSERT_GE(real_size, (size_t)1);\n@@ -208,1 +207,0 @@\n-template <typename BINLISTTYPE> const size_t BinListBasicTest<BINLISTTYPE>::minws = BINLISTTYPE::MinWordSize;\n@@ -211,2 +209,2 @@\n-TEST_VM(metaspace, BinList_basic_8)     { BinListBasicTest< BinListImpl<2, 8> >::basic_test(); }\n-TEST_VM(metaspace, BinList_basic_16)    { BinListBasicTest< BinListImpl<2, 16> >::basic_test(); }\n+TEST_VM(metaspace, BinList_basic_1)     { BinListBasicTest< BinListImpl<1> >::basic_test(); }\n+TEST_VM(metaspace, BinList_basic_8)     { BinListBasicTest< BinListImpl<8> >::basic_test(); }\n@@ -214,2 +212,0 @@\n-TEST_VM(metaspace, BinList_basic_1331)  { BinListBasicTest< BinListImpl<13, 31> >::basic_test(); }\n-TEST_VM(metaspace, BinList_basic_131)   { BinListBasicTest< BinListImpl<13, 1> >::basic_test(); }\n@@ -217,11 +213,3 @@\n-TEST_VM(metaspace, BinList_basic2_8)     { BinListBasicTest< BinListImpl<2, 8> >::basic_test_2(); }\n-TEST_VM(metaspace, BinList_basic2_16)    { BinListBasicTest< BinListImpl<2, 16> >::basic_test_2(); }\n-TEST_VM(metaspace, BinList_basic2_32)    { BinListBasicTest<BinList32 >::basic_test_2(); }\n-TEST_VM(metaspace, BinList_basic2_1331)  { BinListBasicTest< BinListImpl<13, 31> >::basic_test_2(); }\n-TEST_VM(metaspace, BinList_basic2_131)   { BinListBasicTest< BinListImpl<13, 1> >::basic_test_2(); }\n-\n-TEST_VM(metaspace, BinList_random_test_8)     { BinListBasicTest< BinListImpl<2, 8> >::random_test(); }\n-TEST_VM(metaspace, BinList_random_test_16)    { BinListBasicTest< BinListImpl<2, 16> >::random_test(); }\n-TEST_VM(metaspace, BinList_random_test_32)    { BinListBasicTest<BinList32>::random_test(); }\n-TEST_VM(metaspace, BinList_random_test_1331)  { BinListBasicTest< BinListImpl<13, 31> >::random_test(); }\n-TEST_VM(metaspace, BinList_random_test_131)   { BinListBasicTest< BinListImpl<13, 1> >::random_test(); }\n+TEST_VM(metaspace, BinList_basic_2_1)     { BinListBasicTest< BinListImpl<1> >::basic_test_2(); }\n+TEST_VM(metaspace, BinList_basic_2_8)     { BinListBasicTest< BinListImpl<8> >::basic_test_2(); }\n+TEST_VM(metaspace, BinList_basic_2_32)    { BinListBasicTest<BinList32>::basic_test_2(); }\n@@ -229,0 +217,3 @@\n+TEST_VM(metaspace, BinList_basic_rand_1)     { BinListBasicTest< BinListImpl<1> >::random_test(); }\n+TEST_VM(metaspace, BinList_basic_rand_8)     { BinListBasicTest< BinListImpl<8> >::random_test(); }\n+TEST_VM(metaspace, BinList_basic_rand_32)    { BinListBasicTest<BinList32>::random_test(); }\n","filename":"test\/hotspot\/gtest\/metaspace\/test_binlist.cpp","additions":16,"deletions":25,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-    size_t word_size = MAX2(_rgen_allocations.get(), _freeblocks.MinWordSize);\n+    size_t word_size = MAX2(_rgen_allocations.get(), size_t(1));\n","filename":"test\/hotspot\/gtest\/metaspace\/test_freeblocks.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+using metaspace::AllocationAlignmentByteSize;\n@@ -53,5 +54,0 @@\n-\/\/ See metaspaceArena.cpp : needed for predicting commit sizes.\n-namespace metaspace {\n-  extern size_t get_raw_word_size_for_requested_word_size(size_t net_word_size);\n-}\n-\n@@ -182,1 +178,1 @@\n-      ASSERT_TRUE(is_aligned(p, sizeof(MetaWord)));\n+      ASSERT_TRUE(is_aligned(p, AllocationAlignmentByteSize));\n","filename":"test\/hotspot\/gtest\/metaspace\/test_metaspacearena.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+using metaspace::AllocationAlignmentByteSize;\n@@ -55,5 +56,0 @@\n-\/\/ See metaspaceArena.cpp : needed for predicting commit sizes.\n-namespace metaspace {\n-  extern size_t get_raw_word_size_for_requested_word_size(size_t net_word_size);\n-}\n-\n@@ -182,1 +178,2 @@\n-      EXPECT_TRUE(is_aligned(p, sizeof(MetaWord)));\n+      EXPECT_TRUE(is_aligned(p, AllocationAlignmentByteSize));\n+\n","filename":"test\/hotspot\/gtest\/metaspace\/test_metaspacearena_stress.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -387,2 +387,0 @@\n- -runtime\/Metaspace\/elastic\/TestMetaspaceAllocationMT1.java \\\n- -runtime\/Metaspace\/elastic\/TestMetaspaceAllocationMT2.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}