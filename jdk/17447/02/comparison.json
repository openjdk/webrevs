{"files":[{"patch":"@@ -75,6 +75,5 @@\n-class VerifyCleanCardClosure: public BasicOopIterateClosure {\n-private:\n-  HeapWord* _boundary;\n-  HeapWord* _begin;\n-  HeapWord* _end;\n-protected:\n+class CheckForUnmarkedOops : public BasicOopIterateClosure {\n+  DefNewGeneration* _young_gen;\n+  CardTableRS* _card_table;\n+  HeapWord*    _unmarked_addr;\n+\n@@ -82,5 +81,0 @@\n-    HeapWord* jp = (HeapWord*)p;\n-    assert(jp >= _begin && jp < _end,\n-           \"Error: jp \" PTR_FORMAT \" should be within \"\n-           \"[_begin, _end) = [\" PTR_FORMAT \",\" PTR_FORMAT \")\",\n-           p2i(jp), p2i(_begin), p2i(_end));\n@@ -88,15 +82,7 @@\n-    guarantee(obj == nullptr || cast_from_oop<HeapWord*>(obj) >= _boundary,\n-              \"pointer \" PTR_FORMAT \" at \" PTR_FORMAT \" on \"\n-              \"clean card crosses boundary\" PTR_FORMAT,\n-              p2i(obj), p2i(jp), p2i(_boundary));\n-  }\n-\n-public:\n-  VerifyCleanCardClosure(HeapWord* b, HeapWord* begin, HeapWord* end) :\n-    _boundary(b), _begin(begin), _end(end) {\n-    assert(b <= begin,\n-           \"Error: boundary \" PTR_FORMAT \" should be at or below begin \" PTR_FORMAT,\n-           p2i(b), p2i(begin));\n-    assert(begin <= end,\n-           \"Error: begin \" PTR_FORMAT \" should be strictly below end \" PTR_FORMAT,\n-           p2i(begin), p2i(end));\n+    if (_young_gen->is_in_reserved(obj) &&\n+        !_card_table->is_dirty_for_addr(p)) {\n+      \/\/ Don't overwrite the first missing card mark\n+      if (_unmarked_addr == nullptr) {\n+        _unmarked_addr = (HeapWord*)p;\n+      }\n+    }\n@@ -105,3 +91,5 @@\n-  virtual void do_oop(oop* p)       { VerifyCleanCardClosure::do_oop_work(p); }\n-  virtual void do_oop(narrowOop* p) { VerifyCleanCardClosure::do_oop_work(p); }\n-};\n+ public:\n+  CheckForUnmarkedOops(DefNewGeneration* young_gen, CardTableRS* card_table) :\n+    _young_gen(young_gen),\n+    _card_table(card_table),\n+    _unmarked_addr(nullptr) {}\n@@ -109,9 +97,2 @@\n-class VerifyCTSpaceClosure: public SpaceClosure {\n-private:\n-  CardTableRS* _ct;\n-  HeapWord* _boundary;\n-public:\n-  VerifyCTSpaceClosure(CardTableRS* ct, HeapWord* boundary) :\n-    _ct(ct), _boundary(boundary) {}\n-  virtual void do_space(Space* s) { _ct->verify_space(s, _boundary); }\n-};\n+  void do_oop(oop* p)       override { do_oop_work(p); }\n+  void do_oop(narrowOop* p) override { do_oop_work(p); }\n@@ -119,12 +100,2 @@\n-class VerifyCTGenClosure: public SerialHeap::GenClosure {\n-  CardTableRS* _ct;\n-public:\n-  VerifyCTGenClosure(CardTableRS* ct) : _ct(ct) {}\n-  void do_generation(Generation* gen) {\n-    \/\/ Skip the youngest generation.\n-    if (SerialHeap::heap()->is_young_gen(gen)) {\n-      return;\n-    }\n-    \/\/ Normally, we're interested in pointers to younger generations.\n-    VerifyCTSpaceClosure blk(_ct, gen->reserved().start());\n-    gen->space_iterate(&blk, true);\n+  bool has_unmarked_oop() {\n+    return _unmarked_addr != nullptr;\n@@ -134,4 +105,11 @@\n-void CardTableRS::verify_space(Space* s, HeapWord* gen_boundary) {\n-  \/\/ We don't need to do young-gen spaces.\n-  if (s->end() <= gen_boundary) return;\n-  MemRegion used = s->used_region();\n+void CardTableRS::verify() {\n+  class CheckForUnmarkedObjects : public ObjectClosure {\n+    DefNewGeneration* _young_gen;\n+    CardTableRS* _card_table;\n+\n+   public:\n+    CheckForUnmarkedObjects() {\n+      SerialHeap* heap = SerialHeap::heap();\n+      _young_gen = heap->young_gen();\n+      _card_table = heap->rem_set();\n+    }\n@@ -139,39 +117,6 @@\n-  CardValue* cur_entry = byte_for(used.start());\n-  CardValue* limit = byte_after(used.last());\n-  while (cur_entry < limit) {\n-    if (*cur_entry == clean_card_val()) {\n-      CardValue* first_dirty = cur_entry+1;\n-      while (first_dirty < limit &&\n-             *first_dirty == clean_card_val()) {\n-        first_dirty++;\n-      }\n-      \/\/ If the first object is a regular object, and it has a\n-      \/\/ young-to-old field, that would mark the previous card.\n-      HeapWord* boundary = addr_for(cur_entry);\n-      HeapWord* end = (first_dirty >= limit) ? used.end() : addr_for(first_dirty);\n-      HeapWord* boundary_block = s->block_start(boundary);\n-      HeapWord* begin = boundary;             \/\/ Until proven otherwise.\n-      HeapWord* start_block = boundary_block; \/\/ Until proven otherwise.\n-      if (boundary_block < boundary) {\n-        if (s->block_is_obj(boundary_block) && s->obj_is_alive(boundary_block)) {\n-          oop boundary_obj = cast_to_oop(boundary_block);\n-          if (!boundary_obj->is_objArray() &&\n-              !boundary_obj->is_typeArray()) {\n-            guarantee(cur_entry > byte_for(used.start()),\n-                      \"else boundary would be boundary_block\");\n-            if (*byte_for(boundary_block) != clean_card_val()) {\n-              begin = boundary_block + s->block_size(boundary_block);\n-              start_block = begin;\n-            }\n-          }\n-        }\n-      }\n-      \/\/ Now traverse objects until end.\n-      if (begin < end) {\n-        MemRegion mr(begin, end);\n-        VerifyCleanCardClosure verify_blk(gen_boundary, begin, end);\n-        for (HeapWord* cur = start_block; cur < end; cur += s->block_size(cur)) {\n-          if (s->block_is_obj(cur) && s->obj_is_alive(cur)) {\n-            cast_to_oop(cur)->oop_iterate(&verify_blk, mr);\n-          }\n-        }\n+    void do_object(oop obj) override {\n+      CheckForUnmarkedOops object_check(_young_gen, _card_table);\n+      obj->oop_iterate(&object_check);\n+      \/\/ If this obj is imprecisely-marked, the card for obj-start must be dirty.\n+      if (object_check.has_unmarked_oop()) {\n+        guarantee(_card_table->is_dirty_for_addr(obj), \"Found unmarked old-to-young pointer\");\n@@ -179,155 +124,0 @@\n-      cur_entry = first_dirty;\n-    } else {\n-      \/\/ We'd normally expect that cur_youngergen_and_prev_nonclean_card\n-      \/\/ is a transient value, that cannot be in the card table\n-      \/\/ except during GC, and thus assert that:\n-      \/\/ guarantee(*cur_entry != cur_youngergen_and_prev_nonclean_card,\n-      \/\/        \"Illegal CT value\");\n-      \/\/ That however, need not hold, as will become clear in the\n-      \/\/ following...\n-\n-      \/\/ We'd normally expect that if we are in the parallel case,\n-      \/\/ we can't have left a prev value (which would be different\n-      \/\/ from the current value) in the card table, and so we'd like to\n-      \/\/ assert that:\n-      \/\/ guarantee(cur_youngergen_card_val() == youngergen_card\n-      \/\/           || !is_prev_youngergen_card_val(*cur_entry),\n-      \/\/           \"Illegal CT value\");\n-      \/\/ That, however, may not hold occasionally, because of\n-      \/\/ CMS or MSC in the old gen. To wit, consider the\n-      \/\/ following two simple illustrative scenarios:\n-      \/\/ (a) CMS: Consider the case where a large object L\n-      \/\/     spanning several cards is allocated in the old\n-      \/\/     gen, and has a young gen reference stored in it, dirtying\n-      \/\/     some interior cards. A young collection scans the card,\n-      \/\/     finds a young ref and installs a youngergenP_n value.\n-      \/\/     L then goes dead. Now a CMS collection starts,\n-      \/\/     finds L dead and sweeps it up. Assume that L is\n-      \/\/     abutting _unallocated_blk, so _unallocated_blk is\n-      \/\/     adjusted down to (below) L. Assume further that\n-      \/\/     no young collection intervenes during this CMS cycle.\n-      \/\/     The next young gen cycle will not get to look at this\n-      \/\/     youngergenP_n card since it lies in the unoccupied\n-      \/\/     part of the space.\n-      \/\/     Some young collections later the blocks on this\n-      \/\/     card can be re-allocated either due to direct allocation\n-      \/\/     or due to absorbing promotions. At this time, the\n-      \/\/     before-gc verification will fail the above assert.\n-      \/\/ (b) MSC: In this case, an object L with a young reference\n-      \/\/     is on a card that (therefore) holds a youngergen_n value.\n-      \/\/     Suppose also that L lies towards the end of the used\n-      \/\/     the used space before GC. An MSC collection\n-      \/\/     occurs that compacts to such an extent that this\n-      \/\/     card is no longer in the occupied part of the space.\n-      \/\/     Since current code in MSC does not always clear cards\n-      \/\/     in the unused part of old gen, this stale youngergen_n\n-      \/\/     value is left behind and can later be covered by\n-      \/\/     an object when promotion or direct allocation\n-      \/\/     re-allocates that part of the heap.\n-      \/\/\n-      \/\/ Fortunately, the presence of such stale card values is\n-      \/\/ \"only\" a minor annoyance in that subsequent young collections\n-      \/\/ might needlessly scan such cards, but would still never corrupt\n-      \/\/ the heap as a result. However, it's likely not to be a significant\n-      \/\/ performance inhibitor in practice. For instance,\n-      \/\/ some recent measurements with unoccupied cards eagerly cleared\n-      \/\/ out to maintain this invariant, showed next to no\n-      \/\/ change in young collection times; of course one can construct\n-      \/\/ degenerate examples where the cost can be significant.)\n-      \/\/ Note, in particular, that if the \"stale\" card is modified\n-      \/\/ after re-allocation, it would be dirty, not \"stale\". Thus,\n-      \/\/ we can never have a younger ref in such a card and it is\n-      \/\/ safe not to scan that card in any collection. [As we see\n-      \/\/ below, we do some unnecessary scanning\n-      \/\/ in some cases in the current parallel scanning algorithm.]\n-      \/\/\n-      \/\/ The main point below is that the parallel card scanning code\n-      \/\/ deals correctly with these stale card values. There are two main\n-      \/\/ cases to consider where we have a stale \"young gen\" value and a\n-      \/\/ \"derivative\" case to consider, where we have a stale\n-      \/\/ \"cur_younger_gen_and_prev_non_clean\" value, as will become\n-      \/\/ apparent in the case analysis below.\n-      \/\/ o Case 1. If the stale value corresponds to a younger_gen_n\n-      \/\/   value other than the cur_younger_gen value then the code\n-      \/\/   treats this as being tantamount to a prev_younger_gen\n-      \/\/   card. This means that the card may be unnecessarily scanned.\n-      \/\/   There are two sub-cases to consider:\n-      \/\/   o Case 1a. Let us say that the card is in the occupied part\n-      \/\/     of the generation at the time the collection begins. In\n-      \/\/     that case the card will be either cleared when it is scanned\n-      \/\/     for young pointers, or will be set to cur_younger_gen as a\n-      \/\/     result of promotion. (We have elided the normal case where\n-      \/\/     the scanning thread and the promoting thread interleave\n-      \/\/     possibly resulting in a transient\n-      \/\/     cur_younger_gen_and_prev_non_clean value before settling\n-      \/\/     to cur_younger_gen. [End Case 1a.]\n-      \/\/   o Case 1b. Consider now the case when the card is in the unoccupied\n-      \/\/     part of the space which becomes occupied because of promotions\n-      \/\/     into it during the current young GC. In this case the card\n-      \/\/     will never be scanned for young references. The current\n-      \/\/     code will set the card value to either\n-      \/\/     cur_younger_gen_and_prev_non_clean or leave\n-      \/\/     it with its stale value -- because the promotions didn't\n-      \/\/     result in any younger refs on that card. Of these two\n-      \/\/     cases, the latter will be covered in Case 1a during\n-      \/\/     a subsequent scan. To deal with the former case, we need\n-      \/\/     to further consider how we deal with a stale value of\n-      \/\/     cur_younger_gen_and_prev_non_clean in our case analysis\n-      \/\/     below. This we do in Case 3 below. [End Case 1b]\n-      \/\/   [End Case 1]\n-      \/\/ o Case 2. If the stale value corresponds to cur_younger_gen being\n-      \/\/   a value not necessarily written by a current promotion, the\n-      \/\/   card will not be scanned by the younger refs scanning code.\n-      \/\/   (This is OK since as we argued above such cards cannot contain\n-      \/\/   any younger refs.) The result is that this value will be\n-      \/\/   treated as a prev_younger_gen value in a subsequent collection,\n-      \/\/   which is addressed in Case 1 above. [End Case 2]\n-      \/\/ o Case 3. We here consider the \"derivative\" case from Case 1b. above\n-      \/\/   because of which we may find a stale\n-      \/\/   cur_younger_gen_and_prev_non_clean card value in the table.\n-      \/\/   Once again, as in Case 1, we consider two subcases, depending\n-      \/\/   on whether the card lies in the occupied or unoccupied part\n-      \/\/   of the space at the start of the young collection.\n-      \/\/   o Case 3a. Let us say the card is in the occupied part of\n-      \/\/     the old gen at the start of the young collection. In that\n-      \/\/     case, the card will be scanned by the younger refs scanning\n-      \/\/     code which will set it to cur_younger_gen. In a subsequent\n-      \/\/     scan, the card will be considered again and get its final\n-      \/\/     correct value. [End Case 3a]\n-      \/\/   o Case 3b. Now consider the case where the card is in the\n-      \/\/     unoccupied part of the old gen, and is occupied as a result\n-      \/\/     of promotions during thus young gc. In that case,\n-      \/\/     the card will not be scanned for younger refs. The presence\n-      \/\/     of newly promoted objects on the card will then result in\n-      \/\/     its keeping the value cur_younger_gen_and_prev_non_clean\n-      \/\/     value, which we have dealt with in Case 3 here. [End Case 3b]\n-      \/\/   [End Case 3]\n-      \/\/\n-      \/\/ (Please refer to the code in the helper class\n-      \/\/ ClearNonCleanCardWrapper and in CardTable for details.)\n-      \/\/\n-      \/\/ The informal arguments above can be tightened into a formal\n-      \/\/ correctness proof and it behooves us to write up such a proof,\n-      \/\/ or to use model checking to prove that there are no lingering\n-      \/\/ concerns.\n-      \/\/\n-      \/\/ Clearly because of Case 3b one cannot bound the time for\n-      \/\/ which a card will retain what we have called a \"stale\" value.\n-      \/\/ However, one can obtain a Loose upper bound on the redundant\n-      \/\/ work as a result of such stale values. Note first that any\n-      \/\/ time a stale card lies in the occupied part of the space at\n-      \/\/ the start of the collection, it is scanned by younger refs\n-      \/\/ code and we can define a rank function on card values that\n-      \/\/ declines when this is so. Note also that when a card does not\n-      \/\/ lie in the occupied part of the space at the beginning of a\n-      \/\/ young collection, its rank can either decline or stay unchanged.\n-      \/\/ In this case, no extra work is done in terms of redundant\n-      \/\/ younger refs scanning of that card.\n-      \/\/ Then, the case analysis above reveals that, in the worst case,\n-      \/\/ any such stale card will be scanned unnecessarily at most twice.\n-      \/\/\n-      \/\/ It is nonetheless advisable to try and get rid of some of this\n-      \/\/ redundant work in a subsequent (low priority) re-design of\n-      \/\/ the card-scanning code, if only to simplify the underlying\n-      \/\/ state machine analysis\/proof. ysr 1\/28\/2002. XXX\n-      cur_entry++;\n@@ -335,2 +125,1 @@\n-  }\n-}\n+  } check;\n@@ -338,5 +127,1 @@\n-void CardTableRS::verify() {\n-  \/\/ At present, we only know how to verify the card table RS for\n-  \/\/ generational heaps.\n-  VerifyCTGenClosure blk(this);\n-  SerialHeap::heap()->generation_iterate(&blk, false);\n+  SerialHeap::heap()->old_gen()->object_iterate(&check);\n","filename":"src\/hotspot\/share\/gc\/serial\/cardTableRS.cpp","additions":40,"deletions":255,"binary":false,"changes":295,"status":"modified"},{"patch":"@@ -41,4 +41,0 @@\n-  \/\/ Below are private classes used in impl.\n-  friend class VerifyCTSpaceClosure;\n-\n-  void verify_space(Space* s, HeapWord* gen_start);\n@@ -77,0 +73,5 @@\n+  bool is_dirty_for_addr(const void* p) const {\n+    CardValue* card = byte_for(p);\n+    return is_dirty(card);\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/cardTableRS.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"}]}