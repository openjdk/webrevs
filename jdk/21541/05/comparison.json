{"files":[{"patch":"@@ -24,88 +24,0 @@\n-\/*\n- * Summary:\n- *   Test SuperWord vectorization with different access offsets\n- *   and various MaxVectorSize values, and +- AlignVector.\n- *\n- * Note: this test is auto-generated. Please modify \/ generate with script:\n- *       https:\/\/bugs.openjdk.org\/browse\/JDK-8333729\n- *\n- * Types: int, long, short, char, byte, float, double\n- * Offsets: 0, -1, 1, -2, 2, -3, 3, -4, 4, -7, 7, -8, 8, -14, 14, -16, 16, -18, 18, -20, 20, -31, 31, -32, 32, -63, 63, -64, 64, -65, 65, -128, 128, -129, 129, -192, 192\n- *\n- * Checking if we should vectorize is a bit complicated. It depends on\n- * Matcher::vector_width_in_bytes, of the respective platforms (eg. x86.ad)\n- * This vector_width can be further constrained by MaxVectorSize.\n- *\n- * With '-XX:-AlignVector', we vectorize if:\n- *  - Vectors have at least 4 bytes:    vector_width >= 4\n- *  - Vectors hold at least 2 elements: vector_width >= 2 * sizeofop(velt_type)\n- *    -> min_vector_width = max(4, 2 * sizeofop(velt_type))\n- *    -> simplifies to: vector_width >= min_vector_width\n- *  - No cyclic dependency:\n- *    - Access: data[i + offset] = data[i] * fac;\n- *    - byte_offset = offset * sizeofop(type)\n- *    - Cyclic dependency if: 0 < byte_offset < vector_width\n- *\n- * Note: sizeofop(type) = sizeof(type), except sizeofop(char) = 2\n- *\n- * Different types can lead to different vector_width. This depends on\n- * the CPU-features.\n- *\n- * Definition:\n- *     MaxVectorSize: limit through flag\n- *     vector_width: limit given by specific CPU feature for a specific velt_type\n- *     actual_vector_width: what is actually vectorized with\n- *     min_vector_width: what is minimally required for vectorization\n- *\n- *     min_vector_width = max(4, 2 * sizeofop(velt_type))\n- *     MaxVectorSize >= vector_width >= actual_vector_width >= min_vector_width\n- *\n- * In general, we cannot easily specify negative IR rules, that require no\n- * vectorization to happen. We may improve the SuperWord algorithm later,\n- * or some additional optimization collapses some Loads, and suddenly cyclic\n- * dependency disappears, and we can vectorize.\n- *\n- * With '-XX:+AlignVector' we do the following:\n- *\n- * Must vectorize cleanly if:\n- *   1) guaranteed no misalignment AND\n- *   2) guaratneed no cyclic dependency\n- *\n- * Must not vectorize at all if:\n- *   1) guaranteed misalignment AND\n- *   2) guaranteed no cyclic dependency\n- *\n- * We could imagine a case with cyclic dependency, where C2 detects\n- * that only the first load is needed, and so no vectorization is\n- * required for it, and hence the store vector can be aligned.\n- *\n- * The alignment criteria is\n- *     byte_offset % aw == 0\n- * where align width (aw) is\n- *     aw = min(actual_vector_width, ObjectAlignmentInBytes)\n- * For simplicity, we assume that ObjectAlignmentInBytes == 8,\n- * which currently can only be changed manually and then no IR\n- * rule is run.\n- * This allows us to do the computation statically.\n- * Further, we define:\n- *     aw_min = min(min_vector_width, ObjectAlignmentInBytes)\n- *     aw_max = min(vector_width, ObjectAlignmentInBytes)\n- *     aw_min <= aw <= aw_max\n- *\n- * Again, we have no cyclic dependency, except when:\n- *     byte_offset > 0 and p.vector_width > byte_offset\n- * Here we must ensure that:\n- *     byte_offset >= MaxVectorSize\n- *\n- * Guaranteed no misalignment:\n- *     byte_offset % aw_max == 0\n- *       implies\n- *         byte_offset % aw == 0\n- *\n- * Guaranteed misalignment:\n- *     byte_offset % aw_min != 0\n- *       implies\n- *         byte_offset % aw != 0\n- *\n- *\/\n-\n@@ -117,0 +29,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -125,0 +38,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -136,0 +50,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -147,0 +62,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -158,0 +74,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -169,0 +86,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -180,0 +98,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -191,0 +110,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -194,22 +114,0 @@\n-\/*\n- * @test id=sse4-v002-A\n- * @bug 8298935 8308606 8310308 8312570 8310190\n- * @summary Test SuperWord: vector size, offsets, dependencies, alignment.\n- * @requires vm.compiler2.enabled\n- * @requires (os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\")\n- * @requires vm.cpu.features ~= \".*sse4.*\"\n- * @library \/test\/lib \/\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets sse4-v002-A\n- *\/\n-\n-\/*\n- * @test id=sse4-v002-U\n- * @bug 8298935 8308606 8310308 8312570 8310190\n- * @summary Test SuperWord: vector size, offsets, dependencies, alignment.\n- * @requires vm.compiler2.enabled\n- * @requires (os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\")\n- * @requires vm.cpu.features ~= \".*sse4.*\"\n- * @library \/test\/lib \/\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets sse4-v002-U\n- *\/\n-\n@@ -224,0 +122,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -235,0 +134,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -246,0 +146,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -257,0 +158,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -268,0 +170,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -279,0 +182,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -290,0 +194,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -301,0 +206,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -312,0 +218,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -323,0 +230,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -334,0 +242,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -345,0 +254,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -356,0 +266,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -367,0 +278,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -378,0 +290,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -389,0 +302,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -399,0 +313,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -409,0 +324,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -419,0 +335,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -429,0 +346,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -439,0 +357,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -449,0 +368,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -459,0 +379,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -469,0 +390,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -479,0 +401,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -489,0 +412,1 @@\n+ * @compile ..\/..\/lib\/ir_framework\/TestFramework.java\n@@ -493,1 +417,0 @@\n-import compiler.lib.ir_framework.*;\n@@ -495,784 +418,2 @@\n-public class TestDependencyOffsets {\n-    static final int RANGE = 512;\n-\n-    static int[] goldIntP0 = new int[RANGE];\n-    static int[] goldIntM1 = new int[RANGE];\n-    static int[] goldIntP1 = new int[RANGE];\n-    static int[] goldIntM2 = new int[RANGE];\n-    static int[] goldIntP2 = new int[RANGE];\n-    static int[] goldIntM3 = new int[RANGE];\n-    static int[] goldIntP3 = new int[RANGE];\n-    static int[] goldIntM4 = new int[RANGE];\n-    static int[] goldIntP4 = new int[RANGE];\n-    static int[] goldIntM7 = new int[RANGE];\n-    static int[] goldIntP7 = new int[RANGE];\n-    static int[] goldIntM8 = new int[RANGE];\n-    static int[] goldIntP8 = new int[RANGE];\n-    static int[] goldIntM14 = new int[RANGE];\n-    static int[] goldIntP14 = new int[RANGE];\n-    static int[] goldIntM16 = new int[RANGE];\n-    static int[] goldIntP16 = new int[RANGE];\n-    static int[] goldIntM18 = new int[RANGE];\n-    static int[] goldIntP18 = new int[RANGE];\n-    static int[] goldIntM20 = new int[RANGE];\n-    static int[] goldIntP20 = new int[RANGE];\n-    static int[] goldIntM31 = new int[RANGE];\n-    static int[] goldIntP31 = new int[RANGE];\n-    static int[] goldIntM32 = new int[RANGE];\n-    static int[] goldIntP32 = new int[RANGE];\n-    static int[] goldIntM63 = new int[RANGE];\n-    static int[] goldIntP63 = new int[RANGE];\n-    static int[] goldIntM64 = new int[RANGE];\n-    static int[] goldIntP64 = new int[RANGE];\n-    static int[] goldIntM65 = new int[RANGE];\n-    static int[] goldIntP65 = new int[RANGE];\n-    static int[] goldIntM128 = new int[RANGE];\n-    static int[] goldIntP128 = new int[RANGE];\n-    static int[] goldIntM129 = new int[RANGE];\n-    static int[] goldIntP129 = new int[RANGE];\n-    static int[] goldIntM192 = new int[RANGE];\n-    static int[] goldIntP192 = new int[RANGE];\n-    static long[] goldLongP0 = new long[RANGE];\n-    static long[] goldLongM1 = new long[RANGE];\n-    static long[] goldLongP1 = new long[RANGE];\n-    static long[] goldLongM2 = new long[RANGE];\n-    static long[] goldLongP2 = new long[RANGE];\n-    static long[] goldLongM3 = new long[RANGE];\n-    static long[] goldLongP3 = new long[RANGE];\n-    static long[] goldLongM4 = new long[RANGE];\n-    static long[] goldLongP4 = new long[RANGE];\n-    static long[] goldLongM7 = new long[RANGE];\n-    static long[] goldLongP7 = new long[RANGE];\n-    static long[] goldLongM8 = new long[RANGE];\n-    static long[] goldLongP8 = new long[RANGE];\n-    static long[] goldLongM14 = new long[RANGE];\n-    static long[] goldLongP14 = new long[RANGE];\n-    static long[] goldLongM16 = new long[RANGE];\n-    static long[] goldLongP16 = new long[RANGE];\n-    static long[] goldLongM18 = new long[RANGE];\n-    static long[] goldLongP18 = new long[RANGE];\n-    static long[] goldLongM20 = new long[RANGE];\n-    static long[] goldLongP20 = new long[RANGE];\n-    static long[] goldLongM31 = new long[RANGE];\n-    static long[] goldLongP31 = new long[RANGE];\n-    static long[] goldLongM32 = new long[RANGE];\n-    static long[] goldLongP32 = new long[RANGE];\n-    static long[] goldLongM63 = new long[RANGE];\n-    static long[] goldLongP63 = new long[RANGE];\n-    static long[] goldLongM64 = new long[RANGE];\n-    static long[] goldLongP64 = new long[RANGE];\n-    static long[] goldLongM65 = new long[RANGE];\n-    static long[] goldLongP65 = new long[RANGE];\n-    static long[] goldLongM128 = new long[RANGE];\n-    static long[] goldLongP128 = new long[RANGE];\n-    static long[] goldLongM129 = new long[RANGE];\n-    static long[] goldLongP129 = new long[RANGE];\n-    static long[] goldLongM192 = new long[RANGE];\n-    static long[] goldLongP192 = new long[RANGE];\n-    static short[] goldShortP0 = new short[RANGE];\n-    static short[] goldShortM1 = new short[RANGE];\n-    static short[] goldShortP1 = new short[RANGE];\n-    static short[] goldShortM2 = new short[RANGE];\n-    static short[] goldShortP2 = new short[RANGE];\n-    static short[] goldShortM3 = new short[RANGE];\n-    static short[] goldShortP3 = new short[RANGE];\n-    static short[] goldShortM4 = new short[RANGE];\n-    static short[] goldShortP4 = new short[RANGE];\n-    static short[] goldShortM7 = new short[RANGE];\n-    static short[] goldShortP7 = new short[RANGE];\n-    static short[] goldShortM8 = new short[RANGE];\n-    static short[] goldShortP8 = new short[RANGE];\n-    static short[] goldShortM14 = new short[RANGE];\n-    static short[] goldShortP14 = new short[RANGE];\n-    static short[] goldShortM16 = new short[RANGE];\n-    static short[] goldShortP16 = new short[RANGE];\n-    static short[] goldShortM18 = new short[RANGE];\n-    static short[] goldShortP18 = new short[RANGE];\n-    static short[] goldShortM20 = new short[RANGE];\n-    static short[] goldShortP20 = new short[RANGE];\n-    static short[] goldShortM31 = new short[RANGE];\n-    static short[] goldShortP31 = new short[RANGE];\n-    static short[] goldShortM32 = new short[RANGE];\n-    static short[] goldShortP32 = new short[RANGE];\n-    static short[] goldShortM63 = new short[RANGE];\n-    static short[] goldShortP63 = new short[RANGE];\n-    static short[] goldShortM64 = new short[RANGE];\n-    static short[] goldShortP64 = new short[RANGE];\n-    static short[] goldShortM65 = new short[RANGE];\n-    static short[] goldShortP65 = new short[RANGE];\n-    static short[] goldShortM128 = new short[RANGE];\n-    static short[] goldShortP128 = new short[RANGE];\n-    static short[] goldShortM129 = new short[RANGE];\n-    static short[] goldShortP129 = new short[RANGE];\n-    static short[] goldShortM192 = new short[RANGE];\n-    static short[] goldShortP192 = new short[RANGE];\n-    static char[] goldCharP0 = new char[RANGE];\n-    static char[] goldCharM1 = new char[RANGE];\n-    static char[] goldCharP1 = new char[RANGE];\n-    static char[] goldCharM2 = new char[RANGE];\n-    static char[] goldCharP2 = new char[RANGE];\n-    static char[] goldCharM3 = new char[RANGE];\n-    static char[] goldCharP3 = new char[RANGE];\n-    static char[] goldCharM4 = new char[RANGE];\n-    static char[] goldCharP4 = new char[RANGE];\n-    static char[] goldCharM7 = new char[RANGE];\n-    static char[] goldCharP7 = new char[RANGE];\n-    static char[] goldCharM8 = new char[RANGE];\n-    static char[] goldCharP8 = new char[RANGE];\n-    static char[] goldCharM14 = new char[RANGE];\n-    static char[] goldCharP14 = new char[RANGE];\n-    static char[] goldCharM16 = new char[RANGE];\n-    static char[] goldCharP16 = new char[RANGE];\n-    static char[] goldCharM18 = new char[RANGE];\n-    static char[] goldCharP18 = new char[RANGE];\n-    static char[] goldCharM20 = new char[RANGE];\n-    static char[] goldCharP20 = new char[RANGE];\n-    static char[] goldCharM31 = new char[RANGE];\n-    static char[] goldCharP31 = new char[RANGE];\n-    static char[] goldCharM32 = new char[RANGE];\n-    static char[] goldCharP32 = new char[RANGE];\n-    static char[] goldCharM63 = new char[RANGE];\n-    static char[] goldCharP63 = new char[RANGE];\n-    static char[] goldCharM64 = new char[RANGE];\n-    static char[] goldCharP64 = new char[RANGE];\n-    static char[] goldCharM65 = new char[RANGE];\n-    static char[] goldCharP65 = new char[RANGE];\n-    static char[] goldCharM128 = new char[RANGE];\n-    static char[] goldCharP128 = new char[RANGE];\n-    static char[] goldCharM129 = new char[RANGE];\n-    static char[] goldCharP129 = new char[RANGE];\n-    static char[] goldCharM192 = new char[RANGE];\n-    static char[] goldCharP192 = new char[RANGE];\n-    static byte[] goldByteP0 = new byte[RANGE];\n-    static byte[] goldByteM1 = new byte[RANGE];\n-    static byte[] goldByteP1 = new byte[RANGE];\n-    static byte[] goldByteM2 = new byte[RANGE];\n-    static byte[] goldByteP2 = new byte[RANGE];\n-    static byte[] goldByteM3 = new byte[RANGE];\n-    static byte[] goldByteP3 = new byte[RANGE];\n-    static byte[] goldByteM4 = new byte[RANGE];\n-    static byte[] goldByteP4 = new byte[RANGE];\n-    static byte[] goldByteM7 = new byte[RANGE];\n-    static byte[] goldByteP7 = new byte[RANGE];\n-    static byte[] goldByteM8 = new byte[RANGE];\n-    static byte[] goldByteP8 = new byte[RANGE];\n-    static byte[] goldByteM14 = new byte[RANGE];\n-    static byte[] goldByteP14 = new byte[RANGE];\n-    static byte[] goldByteM16 = new byte[RANGE];\n-    static byte[] goldByteP16 = new byte[RANGE];\n-    static byte[] goldByteM18 = new byte[RANGE];\n-    static byte[] goldByteP18 = new byte[RANGE];\n-    static byte[] goldByteM20 = new byte[RANGE];\n-    static byte[] goldByteP20 = new byte[RANGE];\n-    static byte[] goldByteM31 = new byte[RANGE];\n-    static byte[] goldByteP31 = new byte[RANGE];\n-    static byte[] goldByteM32 = new byte[RANGE];\n-    static byte[] goldByteP32 = new byte[RANGE];\n-    static byte[] goldByteM63 = new byte[RANGE];\n-    static byte[] goldByteP63 = new byte[RANGE];\n-    static byte[] goldByteM64 = new byte[RANGE];\n-    static byte[] goldByteP64 = new byte[RANGE];\n-    static byte[] goldByteM65 = new byte[RANGE];\n-    static byte[] goldByteP65 = new byte[RANGE];\n-    static byte[] goldByteM128 = new byte[RANGE];\n-    static byte[] goldByteP128 = new byte[RANGE];\n-    static byte[] goldByteM129 = new byte[RANGE];\n-    static byte[] goldByteP129 = new byte[RANGE];\n-    static byte[] goldByteM192 = new byte[RANGE];\n-    static byte[] goldByteP192 = new byte[RANGE];\n-    static float[] goldFloatP0 = new float[RANGE];\n-    static float[] goldFloatM1 = new float[RANGE];\n-    static float[] goldFloatP1 = new float[RANGE];\n-    static float[] goldFloatM2 = new float[RANGE];\n-    static float[] goldFloatP2 = new float[RANGE];\n-    static float[] goldFloatM3 = new float[RANGE];\n-    static float[] goldFloatP3 = new float[RANGE];\n-    static float[] goldFloatM4 = new float[RANGE];\n-    static float[] goldFloatP4 = new float[RANGE];\n-    static float[] goldFloatM7 = new float[RANGE];\n-    static float[] goldFloatP7 = new float[RANGE];\n-    static float[] goldFloatM8 = new float[RANGE];\n-    static float[] goldFloatP8 = new float[RANGE];\n-    static float[] goldFloatM14 = new float[RANGE];\n-    static float[] goldFloatP14 = new float[RANGE];\n-    static float[] goldFloatM16 = new float[RANGE];\n-    static float[] goldFloatP16 = new float[RANGE];\n-    static float[] goldFloatM18 = new float[RANGE];\n-    static float[] goldFloatP18 = new float[RANGE];\n-    static float[] goldFloatM20 = new float[RANGE];\n-    static float[] goldFloatP20 = new float[RANGE];\n-    static float[] goldFloatM31 = new float[RANGE];\n-    static float[] goldFloatP31 = new float[RANGE];\n-    static float[] goldFloatM32 = new float[RANGE];\n-    static float[] goldFloatP32 = new float[RANGE];\n-    static float[] goldFloatM63 = new float[RANGE];\n-    static float[] goldFloatP63 = new float[RANGE];\n-    static float[] goldFloatM64 = new float[RANGE];\n-    static float[] goldFloatP64 = new float[RANGE];\n-    static float[] goldFloatM65 = new float[RANGE];\n-    static float[] goldFloatP65 = new float[RANGE];\n-    static float[] goldFloatM128 = new float[RANGE];\n-    static float[] goldFloatP128 = new float[RANGE];\n-    static float[] goldFloatM129 = new float[RANGE];\n-    static float[] goldFloatP129 = new float[RANGE];\n-    static float[] goldFloatM192 = new float[RANGE];\n-    static float[] goldFloatP192 = new float[RANGE];\n-    static double[] goldDoubleP0 = new double[RANGE];\n-    static double[] goldDoubleM1 = new double[RANGE];\n-    static double[] goldDoubleP1 = new double[RANGE];\n-    static double[] goldDoubleM2 = new double[RANGE];\n-    static double[] goldDoubleP2 = new double[RANGE];\n-    static double[] goldDoubleM3 = new double[RANGE];\n-    static double[] goldDoubleP3 = new double[RANGE];\n-    static double[] goldDoubleM4 = new double[RANGE];\n-    static double[] goldDoubleP4 = new double[RANGE];\n-    static double[] goldDoubleM7 = new double[RANGE];\n-    static double[] goldDoubleP7 = new double[RANGE];\n-    static double[] goldDoubleM8 = new double[RANGE];\n-    static double[] goldDoubleP8 = new double[RANGE];\n-    static double[] goldDoubleM14 = new double[RANGE];\n-    static double[] goldDoubleP14 = new double[RANGE];\n-    static double[] goldDoubleM16 = new double[RANGE];\n-    static double[] goldDoubleP16 = new double[RANGE];\n-    static double[] goldDoubleM18 = new double[RANGE];\n-    static double[] goldDoubleP18 = new double[RANGE];\n-    static double[] goldDoubleM20 = new double[RANGE];\n-    static double[] goldDoubleP20 = new double[RANGE];\n-    static double[] goldDoubleM31 = new double[RANGE];\n-    static double[] goldDoubleP31 = new double[RANGE];\n-    static double[] goldDoubleM32 = new double[RANGE];\n-    static double[] goldDoubleP32 = new double[RANGE];\n-    static double[] goldDoubleM63 = new double[RANGE];\n-    static double[] goldDoubleP63 = new double[RANGE];\n-    static double[] goldDoubleM64 = new double[RANGE];\n-    static double[] goldDoubleP64 = new double[RANGE];\n-    static double[] goldDoubleM65 = new double[RANGE];\n-    static double[] goldDoubleP65 = new double[RANGE];\n-    static double[] goldDoubleM128 = new double[RANGE];\n-    static double[] goldDoubleP128 = new double[RANGE];\n-    static double[] goldDoubleM129 = new double[RANGE];\n-    static double[] goldDoubleP129 = new double[RANGE];\n-    static double[] goldDoubleM192 = new double[RANGE];\n-    static double[] goldDoubleP192 = new double[RANGE];\n-\n-    static {\n-        \/\/ compute the gold standard in interpreter mode\n-        init(goldIntP0);\n-        testIntP0(goldIntP0);\n-        init(goldIntM1);\n-        testIntM1(goldIntM1);\n-        init(goldIntP1);\n-        testIntP1(goldIntP1);\n-        init(goldIntM2);\n-        testIntM2(goldIntM2);\n-        init(goldIntP2);\n-        testIntP2(goldIntP2);\n-        init(goldIntM3);\n-        testIntM3(goldIntM3);\n-        init(goldIntP3);\n-        testIntP3(goldIntP3);\n-        init(goldIntM4);\n-        testIntM4(goldIntM4);\n-        init(goldIntP4);\n-        testIntP4(goldIntP4);\n-        init(goldIntM7);\n-        testIntM7(goldIntM7);\n-        init(goldIntP7);\n-        testIntP7(goldIntP7);\n-        init(goldIntM8);\n-        testIntM8(goldIntM8);\n-        init(goldIntP8);\n-        testIntP8(goldIntP8);\n-        init(goldIntM14);\n-        testIntM14(goldIntM14);\n-        init(goldIntP14);\n-        testIntP14(goldIntP14);\n-        init(goldIntM16);\n-        testIntM16(goldIntM16);\n-        init(goldIntP16);\n-        testIntP16(goldIntP16);\n-        init(goldIntM18);\n-        testIntM18(goldIntM18);\n-        init(goldIntP18);\n-        testIntP18(goldIntP18);\n-        init(goldIntM20);\n-        testIntM20(goldIntM20);\n-        init(goldIntP20);\n-        testIntP20(goldIntP20);\n-        init(goldIntM31);\n-        testIntM31(goldIntM31);\n-        init(goldIntP31);\n-        testIntP31(goldIntP31);\n-        init(goldIntM32);\n-        testIntM32(goldIntM32);\n-        init(goldIntP32);\n-        testIntP32(goldIntP32);\n-        init(goldIntM63);\n-        testIntM63(goldIntM63);\n-        init(goldIntP63);\n-        testIntP63(goldIntP63);\n-        init(goldIntM64);\n-        testIntM64(goldIntM64);\n-        init(goldIntP64);\n-        testIntP64(goldIntP64);\n-        init(goldIntM65);\n-        testIntM65(goldIntM65);\n-        init(goldIntP65);\n-        testIntP65(goldIntP65);\n-        init(goldIntM128);\n-        testIntM128(goldIntM128);\n-        init(goldIntP128);\n-        testIntP128(goldIntP128);\n-        init(goldIntM129);\n-        testIntM129(goldIntM129);\n-        init(goldIntP129);\n-        testIntP129(goldIntP129);\n-        init(goldIntM192);\n-        testIntM192(goldIntM192);\n-        init(goldIntP192);\n-        testIntP192(goldIntP192);\n-        init(goldLongP0);\n-        testLongP0(goldLongP0);\n-        init(goldLongM1);\n-        testLongM1(goldLongM1);\n-        init(goldLongP1);\n-        testLongP1(goldLongP1);\n-        init(goldLongM2);\n-        testLongM2(goldLongM2);\n-        init(goldLongP2);\n-        testLongP2(goldLongP2);\n-        init(goldLongM3);\n-        testLongM3(goldLongM3);\n-        init(goldLongP3);\n-        testLongP3(goldLongP3);\n-        init(goldLongM4);\n-        testLongM4(goldLongM4);\n-        init(goldLongP4);\n-        testLongP4(goldLongP4);\n-        init(goldLongM7);\n-        testLongM7(goldLongM7);\n-        init(goldLongP7);\n-        testLongP7(goldLongP7);\n-        init(goldLongM8);\n-        testLongM8(goldLongM8);\n-        init(goldLongP8);\n-        testLongP8(goldLongP8);\n-        init(goldLongM14);\n-        testLongM14(goldLongM14);\n-        init(goldLongP14);\n-        testLongP14(goldLongP14);\n-        init(goldLongM16);\n-        testLongM16(goldLongM16);\n-        init(goldLongP16);\n-        testLongP16(goldLongP16);\n-        init(goldLongM18);\n-        testLongM18(goldLongM18);\n-        init(goldLongP18);\n-        testLongP18(goldLongP18);\n-        init(goldLongM20);\n-        testLongM20(goldLongM20);\n-        init(goldLongP20);\n-        testLongP20(goldLongP20);\n-        init(goldLongM31);\n-        testLongM31(goldLongM31);\n-        init(goldLongP31);\n-        testLongP31(goldLongP31);\n-        init(goldLongM32);\n-        testLongM32(goldLongM32);\n-        init(goldLongP32);\n-        testLongP32(goldLongP32);\n-        init(goldLongM63);\n-        testLongM63(goldLongM63);\n-        init(goldLongP63);\n-        testLongP63(goldLongP63);\n-        init(goldLongM64);\n-        testLongM64(goldLongM64);\n-        init(goldLongP64);\n-        testLongP64(goldLongP64);\n-        init(goldLongM65);\n-        testLongM65(goldLongM65);\n-        init(goldLongP65);\n-        testLongP65(goldLongP65);\n-        init(goldLongM128);\n-        testLongM128(goldLongM128);\n-        init(goldLongP128);\n-        testLongP128(goldLongP128);\n-        init(goldLongM129);\n-        testLongM129(goldLongM129);\n-        init(goldLongP129);\n-        testLongP129(goldLongP129);\n-        init(goldLongM192);\n-        testLongM192(goldLongM192);\n-        init(goldLongP192);\n-        testLongP192(goldLongP192);\n-        init(goldShortP0);\n-        testShortP0(goldShortP0);\n-        init(goldShortM1);\n-        testShortM1(goldShortM1);\n-        init(goldShortP1);\n-        testShortP1(goldShortP1);\n-        init(goldShortM2);\n-        testShortM2(goldShortM2);\n-        init(goldShortP2);\n-        testShortP2(goldShortP2);\n-        init(goldShortM3);\n-        testShortM3(goldShortM3);\n-        init(goldShortP3);\n-        testShortP3(goldShortP3);\n-        init(goldShortM4);\n-        testShortM4(goldShortM4);\n-        init(goldShortP4);\n-        testShortP4(goldShortP4);\n-        init(goldShortM7);\n-        testShortM7(goldShortM7);\n-        init(goldShortP7);\n-        testShortP7(goldShortP7);\n-        init(goldShortM8);\n-        testShortM8(goldShortM8);\n-        init(goldShortP8);\n-        testShortP8(goldShortP8);\n-        init(goldShortM14);\n-        testShortM14(goldShortM14);\n-        init(goldShortP14);\n-        testShortP14(goldShortP14);\n-        init(goldShortM16);\n-        testShortM16(goldShortM16);\n-        init(goldShortP16);\n-        testShortP16(goldShortP16);\n-        init(goldShortM18);\n-        testShortM18(goldShortM18);\n-        init(goldShortP18);\n-        testShortP18(goldShortP18);\n-        init(goldShortM20);\n-        testShortM20(goldShortM20);\n-        init(goldShortP20);\n-        testShortP20(goldShortP20);\n-        init(goldShortM31);\n-        testShortM31(goldShortM31);\n-        init(goldShortP31);\n-        testShortP31(goldShortP31);\n-        init(goldShortM32);\n-        testShortM32(goldShortM32);\n-        init(goldShortP32);\n-        testShortP32(goldShortP32);\n-        init(goldShortM63);\n-        testShortM63(goldShortM63);\n-        init(goldShortP63);\n-        testShortP63(goldShortP63);\n-        init(goldShortM64);\n-        testShortM64(goldShortM64);\n-        init(goldShortP64);\n-        testShortP64(goldShortP64);\n-        init(goldShortM65);\n-        testShortM65(goldShortM65);\n-        init(goldShortP65);\n-        testShortP65(goldShortP65);\n-        init(goldShortM128);\n-        testShortM128(goldShortM128);\n-        init(goldShortP128);\n-        testShortP128(goldShortP128);\n-        init(goldShortM129);\n-        testShortM129(goldShortM129);\n-        init(goldShortP129);\n-        testShortP129(goldShortP129);\n-        init(goldShortM192);\n-        testShortM192(goldShortM192);\n-        init(goldShortP192);\n-        testShortP192(goldShortP192);\n-        init(goldCharP0);\n-        testCharP0(goldCharP0);\n-        init(goldCharM1);\n-        testCharM1(goldCharM1);\n-        init(goldCharP1);\n-        testCharP1(goldCharP1);\n-        init(goldCharM2);\n-        testCharM2(goldCharM2);\n-        init(goldCharP2);\n-        testCharP2(goldCharP2);\n-        init(goldCharM3);\n-        testCharM3(goldCharM3);\n-        init(goldCharP3);\n-        testCharP3(goldCharP3);\n-        init(goldCharM4);\n-        testCharM4(goldCharM4);\n-        init(goldCharP4);\n-        testCharP4(goldCharP4);\n-        init(goldCharM7);\n-        testCharM7(goldCharM7);\n-        init(goldCharP7);\n-        testCharP7(goldCharP7);\n-        init(goldCharM8);\n-        testCharM8(goldCharM8);\n-        init(goldCharP8);\n-        testCharP8(goldCharP8);\n-        init(goldCharM14);\n-        testCharM14(goldCharM14);\n-        init(goldCharP14);\n-        testCharP14(goldCharP14);\n-        init(goldCharM16);\n-        testCharM16(goldCharM16);\n-        init(goldCharP16);\n-        testCharP16(goldCharP16);\n-        init(goldCharM18);\n-        testCharM18(goldCharM18);\n-        init(goldCharP18);\n-        testCharP18(goldCharP18);\n-        init(goldCharM20);\n-        testCharM20(goldCharM20);\n-        init(goldCharP20);\n-        testCharP20(goldCharP20);\n-        init(goldCharM31);\n-        testCharM31(goldCharM31);\n-        init(goldCharP31);\n-        testCharP31(goldCharP31);\n-        init(goldCharM32);\n-        testCharM32(goldCharM32);\n-        init(goldCharP32);\n-        testCharP32(goldCharP32);\n-        init(goldCharM63);\n-        testCharM63(goldCharM63);\n-        init(goldCharP63);\n-        testCharP63(goldCharP63);\n-        init(goldCharM64);\n-        testCharM64(goldCharM64);\n-        init(goldCharP64);\n-        testCharP64(goldCharP64);\n-        init(goldCharM65);\n-        testCharM65(goldCharM65);\n-        init(goldCharP65);\n-        testCharP65(goldCharP65);\n-        init(goldCharM128);\n-        testCharM128(goldCharM128);\n-        init(goldCharP128);\n-        testCharP128(goldCharP128);\n-        init(goldCharM129);\n-        testCharM129(goldCharM129);\n-        init(goldCharP129);\n-        testCharP129(goldCharP129);\n-        init(goldCharM192);\n-        testCharM192(goldCharM192);\n-        init(goldCharP192);\n-        testCharP192(goldCharP192);\n-        init(goldByteP0);\n-        testByteP0(goldByteP0);\n-        init(goldByteM1);\n-        testByteM1(goldByteM1);\n-        init(goldByteP1);\n-        testByteP1(goldByteP1);\n-        init(goldByteM2);\n-        testByteM2(goldByteM2);\n-        init(goldByteP2);\n-        testByteP2(goldByteP2);\n-        init(goldByteM3);\n-        testByteM3(goldByteM3);\n-        init(goldByteP3);\n-        testByteP3(goldByteP3);\n-        init(goldByteM4);\n-        testByteM4(goldByteM4);\n-        init(goldByteP4);\n-        testByteP4(goldByteP4);\n-        init(goldByteM7);\n-        testByteM7(goldByteM7);\n-        init(goldByteP7);\n-        testByteP7(goldByteP7);\n-        init(goldByteM8);\n-        testByteM8(goldByteM8);\n-        init(goldByteP8);\n-        testByteP8(goldByteP8);\n-        init(goldByteM14);\n-        testByteM14(goldByteM14);\n-        init(goldByteP14);\n-        testByteP14(goldByteP14);\n-        init(goldByteM16);\n-        testByteM16(goldByteM16);\n-        init(goldByteP16);\n-        testByteP16(goldByteP16);\n-        init(goldByteM18);\n-        testByteM18(goldByteM18);\n-        init(goldByteP18);\n-        testByteP18(goldByteP18);\n-        init(goldByteM20);\n-        testByteM20(goldByteM20);\n-        init(goldByteP20);\n-        testByteP20(goldByteP20);\n-        init(goldByteM31);\n-        testByteM31(goldByteM31);\n-        init(goldByteP31);\n-        testByteP31(goldByteP31);\n-        init(goldByteM32);\n-        testByteM32(goldByteM32);\n-        init(goldByteP32);\n-        testByteP32(goldByteP32);\n-        init(goldByteM63);\n-        testByteM63(goldByteM63);\n-        init(goldByteP63);\n-        testByteP63(goldByteP63);\n-        init(goldByteM64);\n-        testByteM64(goldByteM64);\n-        init(goldByteP64);\n-        testByteP64(goldByteP64);\n-        init(goldByteM65);\n-        testByteM65(goldByteM65);\n-        init(goldByteP65);\n-        testByteP65(goldByteP65);\n-        init(goldByteM128);\n-        testByteM128(goldByteM128);\n-        init(goldByteP128);\n-        testByteP128(goldByteP128);\n-        init(goldByteM129);\n-        testByteM129(goldByteM129);\n-        init(goldByteP129);\n-        testByteP129(goldByteP129);\n-        init(goldByteM192);\n-        testByteM192(goldByteM192);\n-        init(goldByteP192);\n-        testByteP192(goldByteP192);\n-        init(goldFloatP0);\n-        testFloatP0(goldFloatP0);\n-        init(goldFloatM1);\n-        testFloatM1(goldFloatM1);\n-        init(goldFloatP1);\n-        testFloatP1(goldFloatP1);\n-        init(goldFloatM2);\n-        testFloatM2(goldFloatM2);\n-        init(goldFloatP2);\n-        testFloatP2(goldFloatP2);\n-        init(goldFloatM3);\n-        testFloatM3(goldFloatM3);\n-        init(goldFloatP3);\n-        testFloatP3(goldFloatP3);\n-        init(goldFloatM4);\n-        testFloatM4(goldFloatM4);\n-        init(goldFloatP4);\n-        testFloatP4(goldFloatP4);\n-        init(goldFloatM7);\n-        testFloatM7(goldFloatM7);\n-        init(goldFloatP7);\n-        testFloatP7(goldFloatP7);\n-        init(goldFloatM8);\n-        testFloatM8(goldFloatM8);\n-        init(goldFloatP8);\n-        testFloatP8(goldFloatP8);\n-        init(goldFloatM14);\n-        testFloatM14(goldFloatM14);\n-        init(goldFloatP14);\n-        testFloatP14(goldFloatP14);\n-        init(goldFloatM16);\n-        testFloatM16(goldFloatM16);\n-        init(goldFloatP16);\n-        testFloatP16(goldFloatP16);\n-        init(goldFloatM18);\n-        testFloatM18(goldFloatM18);\n-        init(goldFloatP18);\n-        testFloatP18(goldFloatP18);\n-        init(goldFloatM20);\n-        testFloatM20(goldFloatM20);\n-        init(goldFloatP20);\n-        testFloatP20(goldFloatP20);\n-        init(goldFloatM31);\n-        testFloatM31(goldFloatM31);\n-        init(goldFloatP31);\n-        testFloatP31(goldFloatP31);\n-        init(goldFloatM32);\n-        testFloatM32(goldFloatM32);\n-        init(goldFloatP32);\n-        testFloatP32(goldFloatP32);\n-        init(goldFloatM63);\n-        testFloatM63(goldFloatM63);\n-        init(goldFloatP63);\n-        testFloatP63(goldFloatP63);\n-        init(goldFloatM64);\n-        testFloatM64(goldFloatM64);\n-        init(goldFloatP64);\n-        testFloatP64(goldFloatP64);\n-        init(goldFloatM65);\n-        testFloatM65(goldFloatM65);\n-        init(goldFloatP65);\n-        testFloatP65(goldFloatP65);\n-        init(goldFloatM128);\n-        testFloatM128(goldFloatM128);\n-        init(goldFloatP128);\n-        testFloatP128(goldFloatP128);\n-        init(goldFloatM129);\n-        testFloatM129(goldFloatM129);\n-        init(goldFloatP129);\n-        testFloatP129(goldFloatP129);\n-        init(goldFloatM192);\n-        testFloatM192(goldFloatM192);\n-        init(goldFloatP192);\n-        testFloatP192(goldFloatP192);\n-        init(goldDoubleP0);\n-        testDoubleP0(goldDoubleP0);\n-        init(goldDoubleM1);\n-        testDoubleM1(goldDoubleM1);\n-        init(goldDoubleP1);\n-        testDoubleP1(goldDoubleP1);\n-        init(goldDoubleM2);\n-        testDoubleM2(goldDoubleM2);\n-        init(goldDoubleP2);\n-        testDoubleP2(goldDoubleP2);\n-        init(goldDoubleM3);\n-        testDoubleM3(goldDoubleM3);\n-        init(goldDoubleP3);\n-        testDoubleP3(goldDoubleP3);\n-        init(goldDoubleM4);\n-        testDoubleM4(goldDoubleM4);\n-        init(goldDoubleP4);\n-        testDoubleP4(goldDoubleP4);\n-        init(goldDoubleM7);\n-        testDoubleM7(goldDoubleM7);\n-        init(goldDoubleP7);\n-        testDoubleP7(goldDoubleP7);\n-        init(goldDoubleM8);\n-        testDoubleM8(goldDoubleM8);\n-        init(goldDoubleP8);\n-        testDoubleP8(goldDoubleP8);\n-        init(goldDoubleM14);\n-        testDoubleM14(goldDoubleM14);\n-        init(goldDoubleP14);\n-        testDoubleP14(goldDoubleP14);\n-        init(goldDoubleM16);\n-        testDoubleM16(goldDoubleM16);\n-        init(goldDoubleP16);\n-        testDoubleP16(goldDoubleP16);\n-        init(goldDoubleM18);\n-        testDoubleM18(goldDoubleM18);\n-        init(goldDoubleP18);\n-        testDoubleP18(goldDoubleP18);\n-        init(goldDoubleM20);\n-        testDoubleM20(goldDoubleM20);\n-        init(goldDoubleP20);\n-        testDoubleP20(goldDoubleP20);\n-        init(goldDoubleM31);\n-        testDoubleM31(goldDoubleM31);\n-        init(goldDoubleP31);\n-        testDoubleP31(goldDoubleP31);\n-        init(goldDoubleM32);\n-        testDoubleM32(goldDoubleM32);\n-        init(goldDoubleP32);\n-        testDoubleP32(goldDoubleP32);\n-        init(goldDoubleM63);\n-        testDoubleM63(goldDoubleM63);\n-        init(goldDoubleP63);\n-        testDoubleP63(goldDoubleP63);\n-        init(goldDoubleM64);\n-        testDoubleM64(goldDoubleM64);\n-        init(goldDoubleP64);\n-        testDoubleP64(goldDoubleP64);\n-        init(goldDoubleM65);\n-        testDoubleM65(goldDoubleM65);\n-        init(goldDoubleP65);\n-        testDoubleP65(goldDoubleP65);\n-        init(goldDoubleM128);\n-        testDoubleM128(goldDoubleM128);\n-        init(goldDoubleP128);\n-        testDoubleP128(goldDoubleP128);\n-        init(goldDoubleM129);\n-        testDoubleM129(goldDoubleM129);\n-        init(goldDoubleP129);\n-        testDoubleP129(goldDoubleP129);\n-        init(goldDoubleM192);\n-        testDoubleM192(goldDoubleM192);\n-        init(goldDoubleP192);\n-        testDoubleP192(goldDoubleP192);\n-    }\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.compile_framework.*;\n@@ -1280,7 +421,9 @@\n-    public static void main(String args[]) {\n-        TestFramework framework = new TestFramework(TestDependencyOffsets.class);\n-        framework.addFlags(\"-XX:-TieredCompilation\",\n-                           \"-XX:CompileCommand=compileonly,compiler.loopopts.superword.TestDependencyOffsets::init\",\n-                           \"-XX:CompileCommand=compileonly,compiler.loopopts.superword.TestDependencyOffsets::test*\",\n-                           \"-XX:CompileCommand=compileonly,compiler.loopopts.superword.TestDependencyOffsets::verify\",\n-                           \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:LoopUnrollLimit=250\");\n+import jdk.test.lib.Utils;\n+import java.util.Arrays;\n+import java.util.stream.Collectors;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.HashMap;\n+import java.util.Random;\n@@ -1288,0 +431,50 @@\n+\/*\n+ * We want to test SuperWord \/ AutoVectorization with different constant offsets (positive and negative):\n+ *   for (int i = ...) { a[i + offset] = b[i] * 11; }\n+ *\n+ * To test aliasing, we have 3 modes: single-array, aliasing and non-aliasing.\n+ * We test for various primitive types (int, long, short, char, byte, float, double).\n+ * We run all test under various settings of MaxVectorSize and +-AlignVector.\n+ * Finally, we verify the results and check that vectors of the expected length were created (IR rules).\n+ *\/\n+public class TestDependencyOffsets {\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+    private static final int SIZE = 5_000 + RANDOM.nextInt(1000);\n+\n+    \/*\n+     * Template for the inner test class.\n+     *\/\n+    private static String generate(CompileFramework comp, String[] flags) {\n+        return String.format(\"\"\"\n+               import compiler.lib.ir_framework.*;\n+\n+               public class InnerTest {\n+                   private static int SIZE = %s;\n+\n+                   public static void main(String args[]) {\n+                       TestFramework framework = new TestFramework(InnerTest.class);\n+                       framework.addFlags(\"-classpath\", \"%s\");\n+                       framework.addFlags(%s);\n+                       framework.setDefaultWarmup(0);\n+                       framework.start();\n+                   }\n+\n+                   \/\/ ------------------------- Init ---------------------------\n+               %s\n+\n+                   \/\/ ------------------------- Verify -------------------------\n+               %s\n+\n+                   \/\/ ------------------------- Tests --------------------------\n+               %s\n+               }\n+               \"\"\",\n+               SIZE,\n+               comp.getEscapedClassPathOfCompiledClasses(),\n+               Arrays.stream(flags).map(s -> \"\\\"\" + s + \"\\\"\").collect(Collectors.joining(\", \")),\n+               Arrays.stream(TYPES).map(Type::generateInit).collect(Collectors.joining(\"\\n\")),\n+               Arrays.stream(TYPES).map(Type::generateVerify).collect(Collectors.joining(\"\\n\")),\n+               getTests().stream().map(TestDefinition::generate).collect(Collectors.joining(\"\\n\")));\n+    }\n+\n+    public static void main(String[] args) {\n@@ -1292,2097 +485,193 @@\n-        switch (args[0]) {\n-        case \"vanilla-A\":\n-            framework.addFlags(\"-XX:+AlignVector\");\n-            break;\n-        case \"vanilla-U\":\n-            framework.addFlags(\"-XX:-AlignVector\");\n-            break;\n-        case \"sse4-v016-A\":\n-            framework.addFlags(\"-XX:UseSSE=4\", \"-XX:MaxVectorSize=16\", \"-XX:+AlignVector\");\n-            break;\n-        case \"sse4-v016-U\":\n-            framework.addFlags(\"-XX:UseSSE=4\", \"-XX:MaxVectorSize=16\", \"-XX:-AlignVector\");\n-            break;\n-        case \"sse4-v008-A\":\n-            framework.addFlags(\"-XX:UseSSE=4\", \"-XX:MaxVectorSize=8\", \"-XX:+AlignVector\");\n-            break;\n-        case \"sse4-v008-U\":\n-            framework.addFlags(\"-XX:UseSSE=4\", \"-XX:MaxVectorSize=8\", \"-XX:-AlignVector\");\n-            break;\n-        case \"sse4-v004-A\":\n-            framework.addFlags(\"-XX:UseSSE=4\", \"-XX:MaxVectorSize=4\", \"-XX:+AlignVector\");\n-            break;\n-        case \"sse4-v004-U\":\n-            framework.addFlags(\"-XX:UseSSE=4\", \"-XX:MaxVectorSize=4\", \"-XX:-AlignVector\");\n-            break;\n-        case \"sse4-v002-A\":\n-            framework.addFlags(\"-XX:UseSSE=4\", \"-XX:MaxVectorSize=4\", \"-XX:+AlignVector\");\n-            break;\n-        case \"sse4-v002-U\":\n-            framework.addFlags(\"-XX:UseSSE=4\", \"-XX:MaxVectorSize=4\", \"-XX:-AlignVector\");\n-            break;\n-        case \"avx1-v032-A\":\n-            framework.addFlags(\"-XX:UseAVX=1\", \"-XX:MaxVectorSize=32\", \"-XX:+AlignVector\");\n-            break;\n-        case \"avx1-v032-U\":\n-            framework.addFlags(\"-XX:UseAVX=1\", \"-XX:MaxVectorSize=32\", \"-XX:-AlignVector\");\n-            break;\n-        case \"avx1-v016-A\":\n-            framework.addFlags(\"-XX:UseAVX=1\", \"-XX:MaxVectorSize=16\", \"-XX:+AlignVector\");\n-            break;\n-        case \"avx1-v016-U\":\n-            framework.addFlags(\"-XX:UseAVX=1\", \"-XX:MaxVectorSize=16\", \"-XX:-AlignVector\");\n-            break;\n-        case \"avx2-v032-A\":\n-            framework.addFlags(\"-XX:UseAVX=2\", \"-XX:MaxVectorSize=32\", \"-XX:+AlignVector\");\n-            break;\n-        case \"avx2-v032-U\":\n-            framework.addFlags(\"-XX:UseAVX=2\", \"-XX:MaxVectorSize=32\", \"-XX:-AlignVector\");\n-            break;\n-        case \"avx2-v016-A\":\n-            framework.addFlags(\"-XX:UseAVX=2\", \"-XX:MaxVectorSize=16\", \"-XX:+AlignVector\");\n-            break;\n-        case \"avx2-v016-U\":\n-            framework.addFlags(\"-XX:UseAVX=2\", \"-XX:MaxVectorSize=16\", \"-XX:-AlignVector\");\n-            break;\n-        case \"avx512-v064-A\":\n-            framework.addFlags(\"-XX:UseAVX=3\", \"-XX:+UseKNLSetting\", \"-XX:MaxVectorSize=64\", \"-XX:+AlignVector\");\n-            break;\n-        case \"avx512-v064-U\":\n-            framework.addFlags(\"-XX:UseAVX=3\", \"-XX:+UseKNLSetting\", \"-XX:MaxVectorSize=64\", \"-XX:-AlignVector\");\n-            break;\n-        case \"avx512-v032-A\":\n-            framework.addFlags(\"-XX:UseAVX=3\", \"-XX:+UseKNLSetting\", \"-XX:MaxVectorSize=32\", \"-XX:+AlignVector\");\n-            break;\n-        case \"avx512-v032-U\":\n-            framework.addFlags(\"-XX:UseAVX=3\", \"-XX:+UseKNLSetting\", \"-XX:MaxVectorSize=32\", \"-XX:-AlignVector\");\n-            break;\n-        case \"avx512bw-v064-A\":\n-            framework.addFlags(\"-XX:UseAVX=3\", \"-XX:MaxVectorSize=64\", \"-XX:+AlignVector\");\n-            break;\n-        case \"avx512bw-v064-U\":\n-            framework.addFlags(\"-XX:UseAVX=3\", \"-XX:MaxVectorSize=64\", \"-XX:-AlignVector\");\n-            break;\n-        case \"avx512bw-v032-A\":\n-            framework.addFlags(\"-XX:UseAVX=3\", \"-XX:MaxVectorSize=32\", \"-XX:+AlignVector\");\n-            break;\n-        case \"avx512bw-v032-U\":\n-            framework.addFlags(\"-XX:UseAVX=3\", \"-XX:MaxVectorSize=32\", \"-XX:-AlignVector\");\n-            break;\n-        case \"vec-v064-A\":\n-            framework.addFlags(\"-XX:MaxVectorSize=64\", \"-XX:+AlignVector\");\n-            break;\n-        case \"vec-v064-U\":\n-            framework.addFlags(\"-XX:MaxVectorSize=64\", \"-XX:-AlignVector\");\n-            break;\n-        case \"vec-v032-A\":\n-            framework.addFlags(\"-XX:MaxVectorSize=32\", \"-XX:+AlignVector\");\n-            break;\n-        case \"vec-v032-U\":\n-            framework.addFlags(\"-XX:MaxVectorSize=32\", \"-XX:-AlignVector\");\n-            break;\n-        case \"vec-v016-A\":\n-            framework.addFlags(\"-XX:MaxVectorSize=16\", \"-XX:+AlignVector\");\n-            break;\n-        case \"vec-v016-U\":\n-            framework.addFlags(\"-XX:MaxVectorSize=16\", \"-XX:-AlignVector\");\n-            break;\n-        case \"vec-v008-A\":\n-            framework.addFlags(\"-XX:MaxVectorSize=8\", \"-XX:+AlignVector\");\n-            break;\n-        case \"vec-v008-U\":\n-            framework.addFlags(\"-XX:MaxVectorSize=8\", \"-XX:-AlignVector\");\n-            break;\n-        case \"vec-v004-A\":\n-            framework.addFlags(\"-XX:MaxVectorSize=4\", \"-XX:+AlignVector\");\n-            break;\n-        case \"vec-v004-U\":\n-            framework.addFlags(\"-XX:MaxVectorSize=4\", \"-XX:-AlignVector\");\n-            break;\n-        default:\n-            throw new RuntimeException(\"Test argument not recognized: \" + args[0]);\n-        }\n-        framework.start();\n-    }\n-\n-    \/\/ ------------------- Tests -------------------\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntP0(int[] data) {\n-        for (int j = 0; j < RANGE; j++) {\n-            data[j + 0] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntP0\")\n-    @Warmup(0)\n-    public static void runIntP0() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntP0(data);\n-        verify(\"testIntP0\", data, goldIntP0);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntM1(int[] data) {\n-        for (int j = 1; j < RANGE; j++) {\n-            data[j + -1] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntM1\")\n-    @Warmup(0)\n-    public static void runIntM1() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntM1(data);\n-        verify(\"testIntM1\", data, goldIntM1);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntP1(int[] data) {\n-        for (int j = 0; j < RANGE - 1; j++) {\n-            data[j + 1] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntP1\")\n-    @Warmup(0)\n-    public static void runIntP1() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntP1(data);\n-        verify(\"testIntP1\", data, goldIntP1);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntM2(int[] data) {\n-        for (int j = 2; j < RANGE; j++) {\n-            data[j + -2] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntM2\")\n-    @Warmup(0)\n-    public static void runIntM2() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntM2(data);\n-        verify(\"testIntM2\", data, goldIntM2);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntP2(int[] data) {\n-        for (int j = 0; j < RANGE - 2; j++) {\n-            data[j + 2] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntP2\")\n-    @Warmup(0)\n-    public static void runIntP2() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntP2(data);\n-        verify(\"testIntP2\", data, goldIntP2);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntM3(int[] data) {\n-        for (int j = 3; j < RANGE; j++) {\n-            data[j + -3] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntM3\")\n-    @Warmup(0)\n-    public static void runIntM3() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntM3(data);\n-        verify(\"testIntM3\", data, goldIntM3);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    \/\/   positive byte_offset 12 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 12\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    \/\/   positive byte_offset 12 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 12\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    \/\/   positive byte_offset 12 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 12\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    \/\/   positive byte_offset 12 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 12\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 12 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 12\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntP3(int[] data) {\n-        for (int j = 0; j < RANGE - 3; j++) {\n-            data[j + 3] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntP3\")\n-    @Warmup(0)\n-    public static void runIntP3() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntP3(data);\n-        verify(\"testIntP3\", data, goldIntP3);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntM4(int[] data) {\n-        for (int j = 4; j < RANGE; j++) {\n-            data[j + -4] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntM4\")\n-    @Warmup(0)\n-    public static void runIntM4() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntM4(data);\n-        verify(\"testIntM4\", data, goldIntM4);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntP4(int[] data) {\n-        for (int j = 0; j < RANGE - 4; j++) {\n-            data[j + 4] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntP4\")\n-    @Warmup(0)\n-    public static void runIntP4() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntP4(data);\n-        verify(\"testIntP4\", data, goldIntP4);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntM7(int[] data) {\n-        for (int j = 7; j < RANGE; j++) {\n-            data[j + -7] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntM7\")\n-    @Warmup(0)\n-    public static void runIntM7() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntM7(data);\n-        verify(\"testIntM7\", data, goldIntM7);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    \/\/   positive byte_offset 28 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 28\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 28\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    \/\/   positive byte_offset 28 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 28\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 28\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 28 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 28\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 28\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntP7(int[] data) {\n-        for (int j = 0; j < RANGE - 7; j++) {\n-            data[j + 7] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntP7\")\n-    @Warmup(0)\n-    public static void runIntP7() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntP7(data);\n-        verify(\"testIntP7\", data, goldIntP7);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntM8(int[] data) {\n-        for (int j = 8; j < RANGE; j++) {\n-            data[j + -8] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntM8\")\n-    @Warmup(0)\n-    public static void runIntM8() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntM8(data);\n-        verify(\"testIntM8\", data, goldIntM8);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    \/\/   positive byte_offset 32 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 32 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntP8(int[] data) {\n-        for (int j = 0; j < RANGE - 8; j++) {\n-            data[j + 8] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntP8\")\n-    @Warmup(0)\n-    public static void runIntP8() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntP8(data);\n-        verify(\"testIntP8\", data, goldIntP8);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntM14(int[] data) {\n-        for (int j = 14; j < RANGE; j++) {\n-            data[j + -14] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntM14\")\n-    @Warmup(0)\n-    public static void runIntM14() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntM14(data);\n-        verify(\"testIntM14\", data, goldIntM14);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    \/\/   positive byte_offset 56 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 56\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 56\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 56 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 56\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 56\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntP14(int[] data) {\n-        for (int j = 0; j < RANGE - 14; j++) {\n-            data[j + 14] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntP14\")\n-    @Warmup(0)\n-    public static void runIntP14() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntP14(data);\n-        verify(\"testIntP14\", data, goldIntP14);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntM16(int[] data) {\n-        for (int j = 16; j < RANGE; j++) {\n-            data[j + -16] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntM16\")\n-    @Warmup(0)\n-    public static void runIntM16() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntM16(data);\n-        verify(\"testIntM16\", data, goldIntM16);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 64 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 64\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 64\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntP16(int[] data) {\n-        for (int j = 0; j < RANGE - 16; j++) {\n-            data[j + 16] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntP16\")\n-    @Warmup(0)\n-    public static void runIntP16() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntP16(data);\n-        verify(\"testIntP16\", data, goldIntP16);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntM18(int[] data) {\n-        for (int j = 18; j < RANGE; j++) {\n-            data[j + -18] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntM18\")\n-    @Warmup(0)\n-    public static void runIntM18() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntM18(data);\n-        verify(\"testIntM18\", data, goldIntM18);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 72 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 72\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 72\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntP18(int[] data) {\n-        for (int j = 0; j < RANGE - 18; j++) {\n-            data[j + 18] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntP18\")\n-    @Warmup(0)\n-    public static void runIntP18() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntP18(data);\n-        verify(\"testIntP18\", data, goldIntP18);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntM20(int[] data) {\n-        for (int j = 20; j < RANGE; j++) {\n-            data[j + -20] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntM20\")\n-    @Warmup(0)\n-    public static void runIntM20() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntM20(data);\n-        verify(\"testIntM20\", data, goldIntM20);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 80 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 80\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 80\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntP20(int[] data) {\n-        for (int j = 0; j < RANGE - 20; j++) {\n-            data[j + 20] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntP20\")\n-    @Warmup(0)\n-    public static void runIntP20() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntP20(data);\n-        verify(\"testIntP20\", data, goldIntP20);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntM31(int[] data) {\n-        for (int j = 31; j < RANGE; j++) {\n-            data[j + -31] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntM31\")\n-    @Warmup(0)\n-    public static void runIntM31() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntM31(data);\n-        verify(\"testIntM31\", data, goldIntM31);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 124 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 124\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 124\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntP31(int[] data) {\n-        for (int j = 0; j < RANGE - 31; j++) {\n-            data[j + 31] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntP31\")\n-    @Warmup(0)\n-    public static void runIntP31() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntP31(data);\n-        verify(\"testIntP31\", data, goldIntP31);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntM32(int[] data) {\n-        for (int j = 32; j < RANGE; j++) {\n-            data[j + -32] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntM32\")\n-    @Warmup(0)\n-    public static void runIntM32() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntM32(data);\n-        verify(\"testIntM32\", data, goldIntM32);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 128 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 128\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 128\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntP32(int[] data) {\n-        for (int j = 0; j < RANGE - 32; j++) {\n-            data[j + 32] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntP32\")\n-    @Warmup(0)\n-    public static void runIntP32() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntP32(data);\n-        verify(\"testIntP32\", data, goldIntP32);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntM63(int[] data) {\n-        for (int j = 63; j < RANGE; j++) {\n-            data[j + -63] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntM63\")\n-    @Warmup(0)\n-    public static void runIntM63() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntM63(data);\n-        verify(\"testIntM63\", data, goldIntM63);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 252 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 252\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 252\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntP63(int[] data) {\n-        for (int j = 0; j < RANGE - 63; j++) {\n-            data[j + 63] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntP63\")\n-    @Warmup(0)\n-    public static void runIntP63() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntP63(data);\n-        verify(\"testIntP63\", data, goldIntP63);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntM64(int[] data) {\n-        for (int j = 64; j < RANGE; j++) {\n-            data[j + -64] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntM64\")\n-    @Warmup(0)\n-    public static void runIntM64() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntM64(data);\n-        verify(\"testIntM64\", data, goldIntM64);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntP64(int[] data) {\n-        for (int j = 0; j < RANGE - 64; j++) {\n-            data[j + 64] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntP64\")\n-    @Warmup(0)\n-    public static void runIntP64() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntP64(data);\n-        verify(\"testIntP64\", data, goldIntP64);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntM65(int[] data) {\n-        for (int j = 65; j < RANGE; j++) {\n-            data[j + -65] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntM65\")\n-    @Warmup(0)\n-    public static void runIntM65() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntM65(data);\n-        verify(\"testIntM65\", data, goldIntM65);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntP65(int[] data) {\n-        for (int j = 0; j < RANGE - 65; j++) {\n-            data[j + 65] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntP65\")\n-    @Warmup(0)\n-    public static void runIntP65() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntP65(data);\n-        verify(\"testIntP65\", data, goldIntP65);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntM128(int[] data) {\n-        for (int j = 128; j < RANGE; j++) {\n-            data[j + -128] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntM128\")\n-    @Warmup(0)\n-    public static void runIntM128() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntM128(data);\n-        verify(\"testIntM128\", data, goldIntM128);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntP128(int[] data) {\n-        for (int j = 0; j < RANGE - 128; j++) {\n-            data[j + 128] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntP128\")\n-    @Warmup(0)\n-    public static void runIntP128() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntP128(data);\n-        verify(\"testIntP128\", data, goldIntP128);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntM129(int[] data) {\n-        for (int j = 129; j < RANGE; j++) {\n-            data[j + -129] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntM129\")\n-    @Warmup(0)\n-    public static void runIntM129() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntM129(data);\n-        verify(\"testIntM129\", data, goldIntM129);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_I, IRNode.MUL_VI, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntP129(int[] data) {\n-        for (int j = 0; j < RANGE - 129; j++) {\n-            data[j + 129] = (int)(data[j] * (int)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testIntP129\")\n-    @Warmup(0)\n-    public static void runIntP129() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntP129(data);\n-        verify(\"testIntP129\", data, goldIntP129);\n-    }\n+        String[] flags = switch (args[0]) {\n+            case \"vanilla-A\" -> new String[] {\"-XX:+AlignVector\"};\n+            case \"vanilla-U\" -> new String[] {\"-XX:-AlignVector\"};\n+            case \"sse4-v016-A\" -> new String[] {\"-XX:UseSSE=4\", \"-XX:MaxVectorSize=16\", \"-XX:+AlignVector\"};\n+            case \"sse4-v016-U\" -> new String[] {\"-XX:UseSSE=4\", \"-XX:MaxVectorSize=16\", \"-XX:-AlignVector\"};\n+            case \"sse4-v008-A\" -> new String[] {\"-XX:UseSSE=4\", \"-XX:MaxVectorSize=8\", \"-XX:+AlignVector\"};\n+            case \"sse4-v008-U\" -> new String[] {\"-XX:UseSSE=4\", \"-XX:MaxVectorSize=8\", \"-XX:-AlignVector\"};\n+            case \"sse4-v004-A\" -> new String[] {\"-XX:UseSSE=4\", \"-XX:MaxVectorSize=4\", \"-XX:+AlignVector\"};\n+            case \"sse4-v004-U\" -> new String[] {\"-XX:UseSSE=4\", \"-XX:MaxVectorSize=4\", \"-XX:-AlignVector\"};\n+            case \"avx1-v032-A\" -> new String[] {\"-XX:UseAVX=1\", \"-XX:MaxVectorSize=32\", \"-XX:+AlignVector\"};\n+            case \"avx1-v032-U\" -> new String[] {\"-XX:UseAVX=1\", \"-XX:MaxVectorSize=32\", \"-XX:-AlignVector\"};\n+            case \"avx1-v016-A\" -> new String[] {\"-XX:UseAVX=1\", \"-XX:MaxVectorSize=16\", \"-XX:+AlignVector\"};\n+            case \"avx1-v016-U\" -> new String[] {\"-XX:UseAVX=1\", \"-XX:MaxVectorSize=16\", \"-XX:-AlignVector\"};\n+            case \"avx2-v032-A\" -> new String[] {\"-XX:UseAVX=2\", \"-XX:MaxVectorSize=32\", \"-XX:+AlignVector\"};\n+            case \"avx2-v032-U\" -> new String[] {\"-XX:UseAVX=2\", \"-XX:MaxVectorSize=32\", \"-XX:-AlignVector\"};\n+            case \"avx2-v016-A\" -> new String[] {\"-XX:UseAVX=2\", \"-XX:MaxVectorSize=16\", \"-XX:+AlignVector\"};\n+            case \"avx2-v016-U\" -> new String[] {\"-XX:UseAVX=2\", \"-XX:MaxVectorSize=16\", \"-XX:-AlignVector\"};\n+            case \"avx512-v064-A\" -> new String[] {\"-XX:UseAVX=3\", \"-XX:+UseKNLSetting\", \"-XX:MaxVectorSize=64\", \"-XX:+AlignVector\"};\n+            case \"avx512-v064-U\" -> new String[] {\"-XX:UseAVX=3\", \"-XX:+UseKNLSetting\", \"-XX:MaxVectorSize=64\", \"-XX:-AlignVector\"};\n+            case \"avx512-v032-A\" -> new String[] {\"-XX:UseAVX=3\", \"-XX:+UseKNLSetting\", \"-XX:MaxVectorSize=32\", \"-XX:+AlignVector\"};\n+            case \"avx512-v032-U\" -> new String[] {\"-XX:UseAVX=3\", \"-XX:+UseKNLSetting\", \"-XX:MaxVectorSize=32\", \"-XX:-AlignVector\"};\n+            case \"avx512bw-v064-A\" -> new String[] {\"-XX:UseAVX=3\", \"-XX:MaxVectorSize=64\", \"-XX:+AlignVector\"};\n+            case \"avx512bw-v064-U\" -> new String[] {\"-XX:UseAVX=3\", \"-XX:MaxVectorSize=64\", \"-XX:-AlignVector\"};\n+            case \"avx512bw-v032-A\" -> new String[] {\"-XX:UseAVX=3\", \"-XX:MaxVectorSize=32\", \"-XX:+AlignVector\"};\n+            case \"avx512bw-v032-U\" -> new String[] {\"-XX:UseAVX=3\", \"-XX:MaxVectorSize=32\", \"-XX:-AlignVector\"};\n+            case \"vec-v064-A\" -> new String[] {\"-XX:MaxVectorSize=64\", \"-XX:+AlignVector\"};\n+            case \"vec-v064-U\" -> new String[] {\"-XX:MaxVectorSize=64\", \"-XX:-AlignVector\"};\n+            case \"vec-v032-A\" -> new String[] {\"-XX:MaxVectorSize=32\", \"-XX:+AlignVector\"};\n+            case \"vec-v032-U\" -> new String[] {\"-XX:MaxVectorSize=32\", \"-XX:-AlignVector\"};\n+            case \"vec-v016-A\" -> new String[] {\"-XX:MaxVectorSize=16\", \"-XX:+AlignVector\"};\n+            case \"vec-v016-U\" -> new String[] {\"-XX:MaxVectorSize=16\", \"-XX:-AlignVector\"};\n+            case \"vec-v008-A\" -> new String[] {\"-XX:MaxVectorSize=8\", \"-XX:+AlignVector\"};\n+            case \"vec-v008-U\" -> new String[] {\"-XX:MaxVectorSize=8\", \"-XX:-AlignVector\"};\n+            case \"vec-v004-A\" -> new String[] {\"-XX:MaxVectorSize=4\", \"-XX:+AlignVector\"};\n+            case \"vec-v004-U\" -> new String[] {\"-XX:MaxVectorSize=4\", \"-XX:-AlignVector\"};\n+            default -> { throw new RuntimeException(\"Test argument not recognized: \" + args[0]); }\n+        };\n+\n+        CompileFramework comp = new CompileFramework();\n+        long time0 = System.currentTimeMillis();\n+        comp.addJavaSourceCode(\"InnerTest\", generate(comp, flags));\n+        long time1 = System.currentTimeMillis();\n+        comp.compile();\n+        long time2 = System.currentTimeMillis();\n+        comp.invoke(\"InnerTest\", \"main\", new Object[] {null});\n+        long time3 = System.currentTimeMillis();\n+        System.out.println(\"Generate: \" + (time1 - time0));\n+        System.out.println(\"Compile:  \" + (time2 - time1));\n+        System.out.println(\"Run:      \" + (time3 - time2));\n+    }\n+\n+    static record Type (String name, int size, String value, String operator, String irNode) {\n+        String letter() {\n+            return name.substring(0, 1).toUpperCase();\n+        }\n+\n+        \/*\n+         * Template for init method generation.\n+         *\/\n+        String generateInit() {\n+            return String.format(\"\"\"\n+                       static void init(%s[] a, %s[] b) {\n+                           for (int i = 0; i < SIZE; i++) {\n+                               a[i] = (%s)(2 * i);\n+                               b[i] = (%s)(3 * i);\n+                           }\n+                       }\n+                   \"\"\",\n+                   name, name, name, name);\n+        }\n+\n+        \/*\n+         * Template for verify method generation.\n+         *\/\n+        String generateVerify() {\n+            return String.format(\"\"\"\n+                       static void verify(String context, %s[] aTest, %s[] bTest, %s[] aGold, %s[] bGold) {\n+                           for (int i = 0; i < SIZE; i++) {\n+                               if (aTest[i] != aGold[i] || bTest[i] != bGold[i]) {\n+                                   throw new RuntimeException(\"Wrong result in \" + context + \" at i=\" + i + \": \" +\n+                                                              \"aTest=\" + aTest[i] + \", aGold=\" + aGold[i] +\n+                                                              \"bTest=\" + bTest[i] + \", bGold=\" + bGold[i]);\n+                               }\n+                           }\n+                       }\n+                   \"\"\",\n+                   name, name, name, name);\n+        }\n+    }\n+\n+    static final Type[] TYPES = new Type[] {\n+        new Type(\"int\",    4, \"-11\",    \"*\", \"MUL_VI\"),\n+        new Type(\"long\",   8, \"-11\",    \"+\", \"ADD_VL\"), \/\/ aarch64 NEON does not support MulVL\n+        new Type(\"short\",  2, \"-11\",    \"*\", \"MUL_VS\"),\n+        new Type(\"char\",   2, \"-11\",    \"*\", \"MUL_VS\"), \/\/ char behaves like short\n+        new Type(\"byte\",   1, \"11\",     \"*\", \"MUL_VB\"),\n+        new Type(\"float\",  4, \"1.001f\", \"*\", \"MUL_VF\"),\n+        new Type(\"double\", 8, \"1.001\",  \"*\", \"MUL_VD\"),\n+    };\n+\n+    \/*\n+     * Every CPU can define its own Matcher::min_vector_size. This happens to be different for\n+     * our targeted platforms: x86 \/ sse4.1 and aarch64 \/ asimd.\n+     *\/\n+    static record CPUMinVectorWidth (String applyIfCPUFeature, int minVectorWidth) {}\n+\n+    static final String SSE4_ASIMD = \"        applyIfCPUFeatureOr = {\\\"sse4.1\\\", \\\"true\\\", \\\"asimd\\\", \\\"true\\\"})\\n\";\n+    static final String SSE4       = \"        applyIfCPUFeature = {\\\"sse4.1\\\", \\\"true\\\"})\\n\";\n+    static final String ASIMD      = \"        applyIfCPUFeature = {\\\"asimd\\\", \\\"true\\\"})\\n\";\n+\n+    static CPUMinVectorWidth[] getCPUMinVectorWidth(String typeName) {\n+        return switch (typeName) {\n+            case \"byte\"   -> new CPUMinVectorWidth[]{new CPUMinVectorWidth(SSE4_ASIMD, 4 )};\n+            case \"char\"   -> new CPUMinVectorWidth[]{new CPUMinVectorWidth(SSE4,       4 ),\n+                                                     new CPUMinVectorWidth(ASIMD,      8 )};\n+            case \"short\"  -> new CPUMinVectorWidth[]{new CPUMinVectorWidth(SSE4,       4 ),\n+                                                     new CPUMinVectorWidth(ASIMD,      8 )};\n+            case \"int\"    -> new CPUMinVectorWidth[]{new CPUMinVectorWidth(SSE4_ASIMD, 8 )};\n+            case \"long\"   -> new CPUMinVectorWidth[]{new CPUMinVectorWidth(SSE4_ASIMD, 16)};\n+            case \"float\"  -> new CPUMinVectorWidth[]{new CPUMinVectorWidth(SSE4_ASIMD, 8 )};\n+            case \"double\" -> new CPUMinVectorWidth[]{new CPUMinVectorWidth(SSE4_ASIMD, 16)};\n+            default -> { throw new RuntimeException(\"type not supported: \" + typeName); }\n+        };\n+    }\n+\n+    static List<Integer> getOffsets() {\n+        \/\/ Some carefully hand-picked values\n+        int[] always = new int[] {\n+            0,\n+            -1, 1,\n+            -2, 2,     \/\/ 2^1\n+            -3, 3,\n+            -4, 4,     \/\/ 2^2\n+            -7, 7,\n+            -8, 8,     \/\/ 2^3\n+            -14, 14,\n+            -16, 16,   \/\/ 2^4\n+            -18, 18,\n+            -20, 20,\n+            -31, 31,\n+            -32, 32,   \/\/ 2^5\n+            -63, 63,\n+            -64, 64,   \/\/ 2^6\n+            -65, 65,\n+            -128, 128, \/\/ 2^7\n+            -129, 129,\n+            -192, 192, \/\/ 3 * 64\n+        };\n+        Set<Integer> set = Arrays.stream(always).boxed().collect(Collectors.toSet());\n+\n+        \/\/ Sample some random values on an exponential scale\n+        for (int i = 0; i < 10; i++) {\n+            int base = 4 << i;\n+            int offset = base + RANDOM.nextInt(base);\n+            set.add(offset);\n+            set.add(-offset);\n+        }\n+\n+        return new ArrayList<Integer>(set);\n+    }\n+\n+    static record TestDefinition (int id, Type type, int offset) {\n+\n+        \/*\n+         * Template for test generation, together with its static variables, static initialization,\n+         * @IR rules and @Run method (initialization, execution and verification).\n+         *\/\n+        String generate() {\n+            int start = offset >= 0 ? 0 : -offset;\n+            String end = offset >= 0 ? \"SIZE - \" + offset : \"SIZE\";\n+\n+            String aliasingComment;\n+            String secondArgument;\n+            String loadFrom;\n+            switch (RANDOM.nextInt(3)) {\n+            case 0: \/\/ a[i + offset] = a[i]\n+                aliasingComment = \"single-array\";\n+                secondArgument = \"a\";\n+                loadFrom = \"a\";\n+                break;\n+            case 1: \/\/ a[i + offset] = b[i], but a and b alias, i.e. at runtime a == b.\n+                aliasingComment = \"aliasing\";\n+                secondArgument = \"a\";\n+                loadFrom = \"b\";\n+                break;\n+            case 2: \/\/ a[i + offset] = b[i], and a and b do not alias, i.e. at runtime a != b.\n+                aliasingComment = \"non-aliasing\";\n+                secondArgument = \"b\";\n+                loadFrom = \"b\";\n+                break;\n+            default:\n+                throw new RuntimeException(\"impossible\");\n+            }\n@@ -3390,44 +679,130 @@\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntM192(int[] data) {\n-        for (int j = 192; j < RANGE; j++) {\n-            data[j + -192] = (int)(data[j] * (int)-11);\n+            return String.format(\"\"\"\n+                       \/\/ test%d: type=%s, offset=%d, mode=%s\n+                       static %s[] aGold%d = new %s[SIZE];\n+                       static %s[] bGold%d = new %s[SIZE];\n+                       static %s[] aTest%d = new %s[SIZE];\n+                       static %s[] bTest%d = new %s[SIZE];\n+\n+                       static {\n+                           init(aGold%d, bGold%d);\n+                           test%d(aGold%d, %sGold%d);\n+                       }\n+\n+                       @Test\n+                   %s\n+                       public static void test%d(%s[] a, %s[] b) {\n+                           for (int i = %d; i < %s; i++) {\n+                               a[i + %d] = (%s)(%s[i] %s %s);\n+                           }\n+                       }\n+\n+                       @Run(test = \"test%s\")\n+                       public static void run%s() {\n+                           init(aTest%d, bTest%d);\n+                           test%d(aTest%d, %sTest%d);\n+                           verify(\"test%d\", aTest%d, bTest%d, aGold%d, bGold%d);\n+                       }\n+                   \"\"\",\n+                   \/\/ title\n+                   id, type.name, offset, aliasingComment,\n+                   \/\/ static\n+                   type.name, id, type.name,\n+                   type.name, id, type.name,\n+                   type.name, id, type.name,\n+                   type.name, id, type.name,\n+                   id, id, id, id, secondArgument, id,\n+                   \/\/ IR rules\n+                   generateIRRules(),\n+                   \/\/ test\n+                   id, type.name, type.name,\n+                   start, end,\n+                   offset, type.name, loadFrom, type.operator, type.value,\n+                   \/\/ run\n+                   id, id, id, id, id, id, secondArgument, id, id, id, id, id, id);\n+        }\n+\n+        \/*\n+         * We generate a number of IR rules for every TestDefinition. If an what kind of vectorization we\n+         * expect depends on AlignVector and MaxVectorSize, as well as the byteOffset between the load and\n+         * store.\n+         *\/\n+        String generateIRRules() {\n+            StringBuilder builder = new StringBuilder();\n+\n+            for (CPUMinVectorWidth cm : getCPUMinVectorWidth(type.name)) {\n+                String applyIfCPUFeature = cm.applyIfCPUFeature;\n+                int minVectorWidth = cm.minVectorWidth;\n+                builder.append(\"    \/\/ minVectorWidth = \" + minVectorWidth + \"\\n\");\n+\n+                int byteOffset = offset * type.size;\n+                builder.append(\"    \/\/ byteOffset = \" + byteOffset + \" = offset * type.size\\n\");\n+\n+                \/\/ In a store-forward case, later iterations load from stores of previous iterations.\n+                \/\/ If the offset is too small, that leads to cyclic dependencies in the vectors. Hence,\n+                \/\/ we use shorter vectors to avoid cycles and still vectorize. Vector lengths have to\n+                \/\/ be powers-of-2, and smaller or equal to the byteOffset. So we round down to the next\n+                \/\/ power of two.\n+                int infinity = 256; \/\/ No vector size is ever larger than this.\n+                int maxVectorWidth = infinity; \/\/ no constraint by default\n+                if (0 < byteOffset && byteOffset < maxVectorWidth) {\n+                    int log2 = 31 - Integer.numberOfLeadingZeros(offset);\n+                    int floorPow2 = 1 << log2;\n+                    maxVectorWidth = Math.min(maxVectorWidth, floorPow2 * type.size);\n+                    builder.append(\"    \/\/ Vectors must have at most \" + floorPow2 +\n+                                   \" elements: maxVectorWidth = \" + maxVectorWidth +\n+                                   \" to avoid cyclic dependency.\\n\");\n+                }\n+\n+                \/\/ Rule 1: No strict alignment: -XX:-AlignVector\n+                IRRule r1 = new IRRule(type, type.irNode, applyIfCPUFeature);\n+                r1.addApplyIf(\"\\\"AlignVector\\\", \\\"false\\\"\");\n+                r1.addApplyIf(\"\\\"MaxVectorSize\\\", \\\">=\" + minVectorWidth + \"\\\"\");\n+\n+                if (maxVectorWidth < minVectorWidth) {\n+                    builder.append(\"    \/\/ maxVectorWidth < minVectorWidth -> expect no vectorization.\\n\");\n+                    r1.setNegative();\n+                } else if (maxVectorWidth < infinity) {\n+                    r1.setSize(\"min(\" + (maxVectorWidth \/ type.size) + \",max_\" + type.name + \")\");\n+                }\n+                r1.generate(builder);\n+\n+                \/\/ Rule 2: strict alignment: -XX:+AlignVector\n+                IRRule r2 = new IRRule(type, type.irNode, applyIfCPUFeature);\n+                r2.addApplyIf(\"\\\"AlignVector\\\", \\\"true\\\"\");\n+                r2.addApplyIf(\"\\\"MaxVectorSize\\\", \\\">=\" + minVectorWidth + \"\\\"\");\n+\n+                \/\/ All vectors must be aligned by some alignment width aw:\n+                \/\/   aw = min(actualVectorWidth, ObjectAlignmentInBytes)\n+                \/\/ The runtime aw must thus lay between these two values:\n+                \/\/   awMin <= aw <= awMax\n+                int awMin = Math.min(minVectorWidth, 8);\n+                int awMax = 8;\n+\n+                \/\/ We must align both the load and the store, thus we must also be able to align\n+                \/\/ for the difference of the two, i.e. byteOffset must be a multiple of aw:\n+                \/\/   byteOffset % aw == 0\n+                \/\/ We don't know the aw, only awMin and awMax. But:\n+                \/\/   byteOffset % awMax == 0      ->      byteOffset % aw == 0\n+                \/\/   byteOffset % awMin != 0      ->      byteOffset % aw != 0\n+                builder.append(\"    \/\/ awMin = \" + awMin + \" = min(minVectorWidth, 8)\\n\");\n+                builder.append(\"    \/\/ awMax = \" + awMax + \"\\n\");\n+\n+                if (byteOffset % awMax == 0) {\n+                    builder.append(\"    \/\/ byteOffset % awMax == 0   -> always trivially aligned\\n\");\n+                } else if (byteOffset % awMin != 0) {\n+                    builder.append(\"    \/\/ byteOffset % awMin != 0   -> can never align -> expect no vectorization.\\n\");\n+                    r2.setNegative();\n+                } else {\n+                    builder.append(\"    \/\/ Alignment unknown -> disable IR rule.\\n\");\n+                    r2.disable();\n+                }\n+\n+                if (maxVectorWidth < minVectorWidth) {\n+                    builder.append(\"    \/\/ Not at least 2 elements or 4 bytes -> expect no vectorization.\\n\");\n+                    r2.setNegative();\n+                } else if (maxVectorWidth < infinity) {\n+                    r2.setSize(\"min(\" + (maxVectorWidth \/ type.size) + \",max_\" + type.name + \")\");\n+                }\n+                r2.generate(builder);\n+            }\n+            return builder.toString();\n@@ -3437,8 +812,2 @@\n-    @Run(test = \"testIntM192\")\n-    @Warmup(0)\n-    public static void runIntM192() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntM192(data);\n-        verify(\"testIntM192\", data, goldIntM192);\n-    }\n+    static List<TestDefinition> getTests() {\n+        List<TestDefinition> tests = new ArrayList<>();\n@@ -3446,44 +815,6 @@\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testIntP192(int[] data) {\n-        for (int j = 0; j < RANGE - 192; j++) {\n-            data[j + 192] = (int)(data[j] * (int)-11);\n+        \/\/ Cross product of all types and offsets.\n+        int id = 0;\n+        for (Type type : TYPES) {\n+            for (int offset : getOffsets()) {\n+                tests.add(new TestDefinition(id++, type, offset));\n+            }\n@@ -3491,1 +822,0 @@\n-    }\n@@ -3493,7 +823,1 @@\n-    @Run(test = \"testIntP192\")\n-    @Warmup(0)\n-    public static void runIntP192() {\n-        int[] data = new int[RANGE];\n-        init(data);\n-        testIntP192(data);\n-        verify(\"testIntP192\", data, goldIntP192);\n+        return tests;\n@@ -3502,55 +826,8 @@\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongP0(long[] data) {\n-        for (int j = 0; j < RANGE; j++) {\n-            data[j + 0] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongP0\")\n-    @Warmup(0)\n-    public static void runLongP0() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongP0(data);\n-        verify(\"testLongP0\", data, goldLongP0);\n-    }\n+    static class IRRule {\n+        Type type;\n+        String irNode;\n+        String applyIfCPUFeature;\n+        String size;\n+        boolean isEnabled;\n+        boolean isPositiveRule;\n+        ArrayList<String> applyIf;\n@@ -3558,44 +835,8 @@\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongM1(long[] data) {\n-        for (int j = 1; j < RANGE; j++) {\n-            data[j + -1] = (long)(data[j] + (long)-11);\n+        IRRule(Type type, String irNode, String applyIfCPUFeature) {\n+            this.type = type;\n+            this.irNode = irNode;\n+            this.applyIfCPUFeature = applyIfCPUFeature;\n+            this.size = null;\n+            this.isPositiveRule = true;\n+            this.isEnabled = true;\n+            this.applyIf = new ArrayList<String>();\n@@ -3603,10 +844,0 @@\n-    }\n-\n-    @Run(test = \"testLongM1\")\n-    @Warmup(0)\n-    public static void runLongM1() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongM1(data);\n-        verify(\"testLongM1\", data, goldLongM1);\n-    }\n@@ -3614,29 +845,2 @@\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect alignment.\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect alignment.\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect alignment.\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect alignment.\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect alignment.\n-    \/\/   No positive IR rule: conditions impossible.\n-    public static void testLongP1(long[] data) {\n-        for (int j = 0; j < RANGE - 1; j++) {\n-            data[j + 1] = (long)(data[j] + (long)-11);\n+        void setSize(String size) {\n+            this.size = size;\n@@ -3644,1 +848,0 @@\n-    }\n@@ -3646,53 +849,2 @@\n-    @Run(test = \"testLongP1\")\n-    @Warmup(0)\n-    public static void runLongP1() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongP1(data);\n-        verify(\"testLongP1\", data, goldLongP1);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongM2(long[] data) {\n-        for (int j = 2; j < RANGE; j++) {\n-            data[j + -2] = (long)(data[j] + (long)-11);\n+        void setNegative() {\n+            this.isPositiveRule = false;\n@@ -3700,10 +852,0 @@\n-    }\n-\n-    @Run(test = \"testLongM2\")\n-    @Warmup(0)\n-    public static void runLongM2() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongM2(data);\n-        verify(\"testLongM2\", data, goldLongM2);\n-    }\n@@ -3711,47 +853,2 @@\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongP2(long[] data) {\n-        for (int j = 0; j < RANGE - 2; j++) {\n-            data[j + 2] = (long)(data[j] + (long)-11);\n+        void disable() {\n+            this.isEnabled = false;\n@@ -3759,10 +856,0 @@\n-    }\n-\n-    @Run(test = \"testLongP2\")\n-    @Warmup(0)\n-    public static void runLongP2() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongP2(data);\n-        verify(\"testLongP2\", data, goldLongP2);\n-    }\n@@ -3770,44 +857,2 @@\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongM3(long[] data) {\n-        for (int j = 3; j < RANGE; j++) {\n-            data[j + -3] = (long)(data[j] + (long)-11);\n+        void addApplyIf(String constraint) {\n+            this.applyIf.add(constraint);\n@@ -3815,10 +860,0 @@\n-    }\n-\n-    @Run(test = \"testLongM3\")\n-    @Warmup(0)\n-    public static void runLongM3() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongM3(data);\n-        verify(\"testLongM3\", data, goldLongM3);\n-    }\n@@ -3826,49 +861,5 @@\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    \/\/   positive byte_offset 24 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    \/\/   positive byte_offset 24 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 24 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongP3(long[] data) {\n-        for (int j = 0; j < RANGE - 3; j++) {\n-            data[j + 3] = (long)(data[j] + (long)-11);\n-        }\n-    }\n+        void generate(StringBuilder builder) {\n+            if (!isEnabled) {\n+                builder.append(\"    \/\/ No IR rule: disabled.\\n\");\n+            } else {\n+                builder.append(counts());\n@@ -3876,8 +867,8 @@\n-    @Run(test = \"testLongP3\")\n-    @Warmup(0)\n-    public static void runLongP3() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongP3(data);\n-        verify(\"testLongP3\", data, goldLongP3);\n-    }\n+                \/\/ applyIf\n+                if (!applyIf.isEmpty()) {\n+                    builder.append(\"        applyIf\");\n+                    builder.append(applyIf.size() > 1 ? \"And\" : \"\");\n+                    builder.append(\" = {\");\n+                    builder.append(String.join(\", \", applyIf));\n+                    builder.append(\"},\\n\");\n+                }\n@@ -3885,44 +876,3 @@\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongM4(long[] data) {\n-        for (int j = 4; j < RANGE; j++) {\n-            data[j + -4] = (long)(data[j] + (long)-11);\n+                \/\/ CPU features\n+                builder.append(applyIfCPUFeature);\n+            }\n@@ -3930,1 +880,0 @@\n-    }\n@@ -3932,11969 +881,25 @@\n-    @Run(test = \"testLongM4\")\n-    @Warmup(0)\n-    public static void runLongM4() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongM4(data);\n-        verify(\"testLongM4\", data, goldLongM4);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    \/\/   positive byte_offset 32 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 32 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongP4(long[] data) {\n-        for (int j = 0; j < RANGE - 4; j++) {\n-            data[j + 4] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongP4\")\n-    @Warmup(0)\n-    public static void runLongP4() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongP4(data);\n-        verify(\"testLongP4\", data, goldLongP4);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongM7(long[] data) {\n-        for (int j = 7; j < RANGE; j++) {\n-            data[j + -7] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongM7\")\n-    @Warmup(0)\n-    public static void runLongM7() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongM7(data);\n-        verify(\"testLongM7\", data, goldLongM7);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    \/\/   positive byte_offset 56 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 56\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 56\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 56 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 56\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 56\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongP7(long[] data) {\n-        for (int j = 0; j < RANGE - 7; j++) {\n-            data[j + 7] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongP7\")\n-    @Warmup(0)\n-    public static void runLongP7() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongP7(data);\n-        verify(\"testLongP7\", data, goldLongP7);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongM8(long[] data) {\n-        for (int j = 8; j < RANGE; j++) {\n-            data[j + -8] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongM8\")\n-    @Warmup(0)\n-    public static void runLongM8() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongM8(data);\n-        verify(\"testLongM8\", data, goldLongM8);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 64 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 64\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 64\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongP8(long[] data) {\n-        for (int j = 0; j < RANGE - 8; j++) {\n-            data[j + 8] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongP8\")\n-    @Warmup(0)\n-    public static void runLongP8() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongP8(data);\n-        verify(\"testLongP8\", data, goldLongP8);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongM14(long[] data) {\n-        for (int j = 14; j < RANGE; j++) {\n-            data[j + -14] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongM14\")\n-    @Warmup(0)\n-    public static void runLongM14() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongM14(data);\n-        verify(\"testLongM14\", data, goldLongM14);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 112 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 112\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 112\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongP14(long[] data) {\n-        for (int j = 0; j < RANGE - 14; j++) {\n-            data[j + 14] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongP14\")\n-    @Warmup(0)\n-    public static void runLongP14() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongP14(data);\n-        verify(\"testLongP14\", data, goldLongP14);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongM16(long[] data) {\n-        for (int j = 16; j < RANGE; j++) {\n-            data[j + -16] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongM16\")\n-    @Warmup(0)\n-    public static void runLongM16() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongM16(data);\n-        verify(\"testLongM16\", data, goldLongM16);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 128 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 128\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 128\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongP16(long[] data) {\n-        for (int j = 0; j < RANGE - 16; j++) {\n-            data[j + 16] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongP16\")\n-    @Warmup(0)\n-    public static void runLongP16() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongP16(data);\n-        verify(\"testLongP16\", data, goldLongP16);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongM18(long[] data) {\n-        for (int j = 18; j < RANGE; j++) {\n-            data[j + -18] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongM18\")\n-    @Warmup(0)\n-    public static void runLongM18() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongM18(data);\n-        verify(\"testLongM18\", data, goldLongM18);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 144 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 144\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 144\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongP18(long[] data) {\n-        for (int j = 0; j < RANGE - 18; j++) {\n-            data[j + 18] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongP18\")\n-    @Warmup(0)\n-    public static void runLongP18() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongP18(data);\n-        verify(\"testLongP18\", data, goldLongP18);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongM20(long[] data) {\n-        for (int j = 20; j < RANGE; j++) {\n-            data[j + -20] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongM20\")\n-    @Warmup(0)\n-    public static void runLongM20() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongM20(data);\n-        verify(\"testLongM20\", data, goldLongM20);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 160 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 160\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 160\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongP20(long[] data) {\n-        for (int j = 0; j < RANGE - 20; j++) {\n-            data[j + 20] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongP20\")\n-    @Warmup(0)\n-    public static void runLongP20() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongP20(data);\n-        verify(\"testLongP20\", data, goldLongP20);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongM31(long[] data) {\n-        for (int j = 31; j < RANGE; j++) {\n-            data[j + -31] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongM31\")\n-    @Warmup(0)\n-    public static void runLongM31() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongM31(data);\n-        verify(\"testLongM31\", data, goldLongM31);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 248 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 248\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 248\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongP31(long[] data) {\n-        for (int j = 0; j < RANGE - 31; j++) {\n-            data[j + 31] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongP31\")\n-    @Warmup(0)\n-    public static void runLongP31() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongP31(data);\n-        verify(\"testLongP31\", data, goldLongP31);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongM32(long[] data) {\n-        for (int j = 32; j < RANGE; j++) {\n-            data[j + -32] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongM32\")\n-    @Warmup(0)\n-    public static void runLongM32() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongM32(data);\n-        verify(\"testLongM32\", data, goldLongM32);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongP32(long[] data) {\n-        for (int j = 0; j < RANGE - 32; j++) {\n-            data[j + 32] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongP32\")\n-    @Warmup(0)\n-    public static void runLongP32() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongP32(data);\n-        verify(\"testLongP32\", data, goldLongP32);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongM63(long[] data) {\n-        for (int j = 63; j < RANGE; j++) {\n-            data[j + -63] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongM63\")\n-    @Warmup(0)\n-    public static void runLongM63() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongM63(data);\n-        verify(\"testLongM63\", data, goldLongM63);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongP63(long[] data) {\n-        for (int j = 0; j < RANGE - 63; j++) {\n-            data[j + 63] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongP63\")\n-    @Warmup(0)\n-    public static void runLongP63() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongP63(data);\n-        verify(\"testLongP63\", data, goldLongP63);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongM64(long[] data) {\n-        for (int j = 64; j < RANGE; j++) {\n-            data[j + -64] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongM64\")\n-    @Warmup(0)\n-    public static void runLongM64() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongM64(data);\n-        verify(\"testLongM64\", data, goldLongM64);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongP64(long[] data) {\n-        for (int j = 0; j < RANGE - 64; j++) {\n-            data[j + 64] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongP64\")\n-    @Warmup(0)\n-    public static void runLongP64() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongP64(data);\n-        verify(\"testLongP64\", data, goldLongP64);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongM65(long[] data) {\n-        for (int j = 65; j < RANGE; j++) {\n-            data[j + -65] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongM65\")\n-    @Warmup(0)\n-    public static void runLongM65() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongM65(data);\n-        verify(\"testLongM65\", data, goldLongM65);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongP65(long[] data) {\n-        for (int j = 0; j < RANGE - 65; j++) {\n-            data[j + 65] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongP65\")\n-    @Warmup(0)\n-    public static void runLongP65() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongP65(data);\n-        verify(\"testLongP65\", data, goldLongP65);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongM128(long[] data) {\n-        for (int j = 128; j < RANGE; j++) {\n-            data[j + -128] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongM128\")\n-    @Warmup(0)\n-    public static void runLongM128() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongM128(data);\n-        verify(\"testLongM128\", data, goldLongM128);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongP128(long[] data) {\n-        for (int j = 0; j < RANGE - 128; j++) {\n-            data[j + 128] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongP128\")\n-    @Warmup(0)\n-    public static void runLongP128() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongP128(data);\n-        verify(\"testLongP128\", data, goldLongP128);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongM129(long[] data) {\n-        for (int j = 129; j < RANGE; j++) {\n-            data[j + -129] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongM129\")\n-    @Warmup(0)\n-    public static void runLongM129() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongM129(data);\n-        verify(\"testLongM129\", data, goldLongM129);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongP129(long[] data) {\n-        for (int j = 0; j < RANGE - 129; j++) {\n-            data[j + 129] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongP129\")\n-    @Warmup(0)\n-    public static void runLongP129() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongP129(data);\n-        verify(\"testLongP129\", data, goldLongP129);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongM192(long[] data) {\n-        for (int j = 192; j < RANGE; j++) {\n-            data[j + -192] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongM192\")\n-    @Warmup(0)\n-    public static void runLongM192() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongM192(data);\n-        verify(\"testLongM192\", data, goldLongM192);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\", IRNode.ADD_VL, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testLongP192(long[] data) {\n-        for (int j = 0; j < RANGE - 192; j++) {\n-            data[j + 192] = (long)(data[j] + (long)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testLongP192\")\n-    @Warmup(0)\n-    public static void runLongP192() {\n-        long[] data = new long[RANGE];\n-        init(data);\n-        testLongP192(data);\n-        verify(\"testLongP192\", data, goldLongP192);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortP0(short[] data) {\n-        for (int j = 0; j < RANGE; j++) {\n-            data[j + 0] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortP0\")\n-    @Warmup(0)\n-    public static void runShortP0() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortP0(data);\n-        verify(\"testShortP0\", data, goldShortP0);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortM1(short[] data) {\n-        for (int j = 1; j < RANGE; j++) {\n-            data[j + -1] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortM1\")\n-    @Warmup(0)\n-    public static void runShortM1() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortM1(data);\n-        verify(\"testShortM1\", data, goldShortM1);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    \/\/   positive byte_offset 2 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    \/\/   positive byte_offset 2 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 2 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    \/\/   positive byte_offset 2 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 2 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortP1(short[] data) {\n-        for (int j = 0; j < RANGE - 1; j++) {\n-            data[j + 1] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortP1\")\n-    @Warmup(0)\n-    public static void runShortP1() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortP1(data);\n-        verify(\"testShortP1\", data, goldShortP1);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    public static void testShortM2(short[] data) {\n-        for (int j = 2; j < RANGE; j++) {\n-            data[j + -2] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortM2\")\n-    @Warmup(0)\n-    public static void runShortM2() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortM2(data);\n-        verify(\"testShortM2\", data, goldShortM2);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    public static void testShortP2(short[] data) {\n-        for (int j = 0; j < RANGE - 2; j++) {\n-            data[j + 2] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortP2\")\n-    @Warmup(0)\n-    public static void runShortP2() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortP2(data);\n-        verify(\"testShortP2\", data, goldShortP2);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortM3(short[] data) {\n-        for (int j = 3; j < RANGE; j++) {\n-            data[j + -3] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortM3\")\n-    @Warmup(0)\n-    public static void runShortM3() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortM3(data);\n-        verify(\"testShortM3\", data, goldShortM3);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    \/\/   positive byte_offset 6 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 6\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    \/\/   positive byte_offset 6 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 6\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 6 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 6\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    \/\/   positive byte_offset 6 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 6\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 6 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 6\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortP3(short[] data) {\n-        for (int j = 0; j < RANGE - 3; j++) {\n-            data[j + 3] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortP3\")\n-    @Warmup(0)\n-    public static void runShortP3() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortP3(data);\n-        verify(\"testShortP3\", data, goldShortP3);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortM4(short[] data) {\n-        for (int j = 4; j < RANGE; j++) {\n-            data[j + -4] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortM4\")\n-    @Warmup(0)\n-    public static void runShortM4() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortM4(data);\n-        verify(\"testShortM4\", data, goldShortM4);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortP4(short[] data) {\n-        for (int j = 0; j < RANGE - 4; j++) {\n-            data[j + 4] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortP4\")\n-    @Warmup(0)\n-    public static void runShortP4() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortP4(data);\n-        verify(\"testShortP4\", data, goldShortP4);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortM7(short[] data) {\n-        for (int j = 7; j < RANGE; j++) {\n-            data[j + -7] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortM7\")\n-    @Warmup(0)\n-    public static void runShortM7() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortM7(data);\n-        verify(\"testShortM7\", data, goldShortM7);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    \/\/   positive byte_offset 14 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    \/\/   positive byte_offset 14 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 14 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    \/\/   positive byte_offset 14 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 14 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortP7(short[] data) {\n-        for (int j = 0; j < RANGE - 7; j++) {\n-            data[j + 7] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortP7\")\n-    @Warmup(0)\n-    public static void runShortP7() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortP7(data);\n-        verify(\"testShortP7\", data, goldShortP7);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortM8(short[] data) {\n-        for (int j = 8; j < RANGE; j++) {\n-            data[j + -8] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortM8\")\n-    @Warmup(0)\n-    public static void runShortM8() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortM8(data);\n-        verify(\"testShortM8\", data, goldShortM8);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortP8(short[] data) {\n-        for (int j = 0; j < RANGE - 8; j++) {\n-            data[j + 8] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortP8\")\n-    @Warmup(0)\n-    public static void runShortP8() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortP8(data);\n-        verify(\"testShortP8\", data, goldShortP8);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    public static void testShortM14(short[] data) {\n-        for (int j = 14; j < RANGE; j++) {\n-            data[j + -14] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortM14\")\n-    @Warmup(0)\n-    public static void runShortM14() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortM14(data);\n-        verify(\"testShortM14\", data, goldShortM14);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    \/\/   positive byte_offset 28 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 28\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 28 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 28\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 28 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 28\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    public static void testShortP14(short[] data) {\n-        for (int j = 0; j < RANGE - 14; j++) {\n-            data[j + 14] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortP14\")\n-    @Warmup(0)\n-    public static void runShortP14() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortP14(data);\n-        verify(\"testShortP14\", data, goldShortP14);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortM16(short[] data) {\n-        for (int j = 16; j < RANGE; j++) {\n-            data[j + -16] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortM16\")\n-    @Warmup(0)\n-    public static void runShortM16() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortM16(data);\n-        verify(\"testShortM16\", data, goldShortM16);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 32 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 32 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortP16(short[] data) {\n-        for (int j = 0; j < RANGE - 16; j++) {\n-            data[j + 16] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortP16\")\n-    @Warmup(0)\n-    public static void runShortP16() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortP16(data);\n-        verify(\"testShortP16\", data, goldShortP16);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    public static void testShortM18(short[] data) {\n-        for (int j = 18; j < RANGE; j++) {\n-            data[j + -18] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortM18\")\n-    @Warmup(0)\n-    public static void runShortM18() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortM18(data);\n-        verify(\"testShortM18\", data, goldShortM18);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 36 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 36\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 36 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 36\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    public static void testShortP18(short[] data) {\n-        for (int j = 0; j < RANGE - 18; j++) {\n-            data[j + 18] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortP18\")\n-    @Warmup(0)\n-    public static void runShortP18() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortP18(data);\n-        verify(\"testShortP18\", data, goldShortP18);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortM20(short[] data) {\n-        for (int j = 20; j < RANGE; j++) {\n-            data[j + -20] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortM20\")\n-    @Warmup(0)\n-    public static void runShortM20() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortM20(data);\n-        verify(\"testShortM20\", data, goldShortM20);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 40 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 40\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 40\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 40 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 40\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 40\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortP20(short[] data) {\n-        for (int j = 0; j < RANGE - 20; j++) {\n-            data[j + 20] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortP20\")\n-    @Warmup(0)\n-    public static void runShortP20() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortP20(data);\n-        verify(\"testShortP20\", data, goldShortP20);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortM31(short[] data) {\n-        for (int j = 31; j < RANGE; j++) {\n-            data[j + -31] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortM31\")\n-    @Warmup(0)\n-    public static void runShortM31() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortM31(data);\n-        verify(\"testShortM31\", data, goldShortM31);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 62 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 62\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 62\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 62 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 62\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 62\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortP31(short[] data) {\n-        for (int j = 0; j < RANGE - 31; j++) {\n-            data[j + 31] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortP31\")\n-    @Warmup(0)\n-    public static void runShortP31() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortP31(data);\n-        verify(\"testShortP31\", data, goldShortP31);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortM32(short[] data) {\n-        for (int j = 32; j < RANGE; j++) {\n-            data[j + -32] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortM32\")\n-    @Warmup(0)\n-    public static void runShortM32() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortM32(data);\n-        verify(\"testShortM32\", data, goldShortM32);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 64 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 64\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 64\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortP32(short[] data) {\n-        for (int j = 0; j < RANGE - 32; j++) {\n-            data[j + 32] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortP32\")\n-    @Warmup(0)\n-    public static void runShortP32() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortP32(data);\n-        verify(\"testShortP32\", data, goldShortP32);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortM63(short[] data) {\n-        for (int j = 63; j < RANGE; j++) {\n-            data[j + -63] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortM63\")\n-    @Warmup(0)\n-    public static void runShortM63() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortM63(data);\n-        verify(\"testShortM63\", data, goldShortM63);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 126 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 126\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 126\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortP63(short[] data) {\n-        for (int j = 0; j < RANGE - 63; j++) {\n-            data[j + 63] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortP63\")\n-    @Warmup(0)\n-    public static void runShortP63() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortP63(data);\n-        verify(\"testShortP63\", data, goldShortP63);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortM64(short[] data) {\n-        for (int j = 64; j < RANGE; j++) {\n-            data[j + -64] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortM64\")\n-    @Warmup(0)\n-    public static void runShortM64() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortM64(data);\n-        verify(\"testShortM64\", data, goldShortM64);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 128 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 128\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 128\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortP64(short[] data) {\n-        for (int j = 0; j < RANGE - 64; j++) {\n-            data[j + 64] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortP64\")\n-    @Warmup(0)\n-    public static void runShortP64() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortP64(data);\n-        verify(\"testShortP64\", data, goldShortP64);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortM65(short[] data) {\n-        for (int j = 65; j < RANGE; j++) {\n-            data[j + -65] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortM65\")\n-    @Warmup(0)\n-    public static void runShortM65() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortM65(data);\n-        verify(\"testShortM65\", data, goldShortM65);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 130 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 130\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 130\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortP65(short[] data) {\n-        for (int j = 0; j < RANGE - 65; j++) {\n-            data[j + 65] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortP65\")\n-    @Warmup(0)\n-    public static void runShortP65() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortP65(data);\n-        verify(\"testShortP65\", data, goldShortP65);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortM128(short[] data) {\n-        for (int j = 128; j < RANGE; j++) {\n-            data[j + -128] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortM128\")\n-    @Warmup(0)\n-    public static void runShortM128() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortM128(data);\n-        verify(\"testShortM128\", data, goldShortM128);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortP128(short[] data) {\n-        for (int j = 0; j < RANGE - 128; j++) {\n-            data[j + 128] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortP128\")\n-    @Warmup(0)\n-    public static void runShortP128() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortP128(data);\n-        verify(\"testShortP128\", data, goldShortP128);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortM129(short[] data) {\n-        for (int j = 129; j < RANGE; j++) {\n-            data[j + -129] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortM129\")\n-    @Warmup(0)\n-    public static void runShortM129() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortM129(data);\n-        verify(\"testShortM129\", data, goldShortM129);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_S, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortP129(short[] data) {\n-        for (int j = 0; j < RANGE - 129; j++) {\n-            data[j + 129] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortP129\")\n-    @Warmup(0)\n-    public static void runShortP129() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortP129(data);\n-        verify(\"testShortP129\", data, goldShortP129);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortM192(short[] data) {\n-        for (int j = 192; j < RANGE; j++) {\n-            data[j + -192] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortM192\")\n-    @Warmup(0)\n-    public static void runShortM192() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortM192(data);\n-        verify(\"testShortM192\", data, goldShortM192);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testShortP192(short[] data) {\n-        for (int j = 0; j < RANGE - 192; j++) {\n-            data[j + 192] = (short)(data[j] * (short)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testShortP192\")\n-    @Warmup(0)\n-    public static void runShortP192() {\n-        short[] data = new short[RANGE];\n-        init(data);\n-        testShortP192(data);\n-        verify(\"testShortP192\", data, goldShortP192);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharP0(char[] data) {\n-        for (int j = 0; j < RANGE; j++) {\n-            data[j + 0] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharP0\")\n-    @Warmup(0)\n-    public static void runCharP0() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharP0(data);\n-        verify(\"testCharP0\", data, goldCharP0);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharM1(char[] data) {\n-        for (int j = 1; j < RANGE; j++) {\n-            data[j + -1] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharM1\")\n-    @Warmup(0)\n-    public static void runCharM1() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharM1(data);\n-        verify(\"testCharM1\", data, goldCharM1);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    \/\/   positive byte_offset 2 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    \/\/   positive byte_offset 2 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 2 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    \/\/   positive byte_offset 2 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 2 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharP1(char[] data) {\n-        for (int j = 0; j < RANGE - 1; j++) {\n-            data[j + 1] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharP1\")\n-    @Warmup(0)\n-    public static void runCharP1() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharP1(data);\n-        verify(\"testCharP1\", data, goldCharP1);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    public static void testCharM2(char[] data) {\n-        for (int j = 2; j < RANGE; j++) {\n-            data[j + -2] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharM2\")\n-    @Warmup(0)\n-    public static void runCharM2() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharM2(data);\n-        verify(\"testCharM2\", data, goldCharM2);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    public static void testCharP2(char[] data) {\n-        for (int j = 0; j < RANGE - 2; j++) {\n-            data[j + 2] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharP2\")\n-    @Warmup(0)\n-    public static void runCharP2() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharP2(data);\n-        verify(\"testCharP2\", data, goldCharP2);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharM3(char[] data) {\n-        for (int j = 3; j < RANGE; j++) {\n-            data[j + -3] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharM3\")\n-    @Warmup(0)\n-    public static void runCharM3() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharM3(data);\n-        verify(\"testCharM3\", data, goldCharM3);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    \/\/   positive byte_offset 6 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 6\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    \/\/   positive byte_offset 6 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 6\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 6 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 6\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    \/\/   positive byte_offset 6 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 6\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 6 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 6\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 6\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharP3(char[] data) {\n-        for (int j = 0; j < RANGE - 3; j++) {\n-            data[j + 3] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharP3\")\n-    @Warmup(0)\n-    public static void runCharP3() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharP3(data);\n-        verify(\"testCharP3\", data, goldCharP3);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharM4(char[] data) {\n-        for (int j = 4; j < RANGE; j++) {\n-            data[j + -4] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharM4\")\n-    @Warmup(0)\n-    public static void runCharM4() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharM4(data);\n-        verify(\"testCharM4\", data, goldCharM4);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharP4(char[] data) {\n-        for (int j = 0; j < RANGE - 4; j++) {\n-            data[j + 4] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharP4\")\n-    @Warmup(0)\n-    public static void runCharP4() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharP4(data);\n-        verify(\"testCharP4\", data, goldCharP4);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharM7(char[] data) {\n-        for (int j = 7; j < RANGE; j++) {\n-            data[j + -7] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharM7\")\n-    @Warmup(0)\n-    public static void runCharM7() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharM7(data);\n-        verify(\"testCharM7\", data, goldCharM7);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    \/\/   positive byte_offset 14 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    \/\/   positive byte_offset 14 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 14 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    \/\/   positive byte_offset 14 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 14 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharP7(char[] data) {\n-        for (int j = 0; j < RANGE - 7; j++) {\n-            data[j + 7] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharP7\")\n-    @Warmup(0)\n-    public static void runCharP7() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharP7(data);\n-        verify(\"testCharP7\", data, goldCharP7);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharM8(char[] data) {\n-        for (int j = 8; j < RANGE; j++) {\n-            data[j + -8] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharM8\")\n-    @Warmup(0)\n-    public static void runCharM8() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharM8(data);\n-        verify(\"testCharM8\", data, goldCharM8);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharP8(char[] data) {\n-        for (int j = 0; j < RANGE - 8; j++) {\n-            data[j + 8] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharP8\")\n-    @Warmup(0)\n-    public static void runCharP8() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharP8(data);\n-        verify(\"testCharP8\", data, goldCharP8);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    public static void testCharM14(char[] data) {\n-        for (int j = 14; j < RANGE; j++) {\n-            data[j + -14] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharM14\")\n-    @Warmup(0)\n-    public static void runCharM14() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharM14(data);\n-        verify(\"testCharM14\", data, goldCharM14);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    \/\/   positive byte_offset 28 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 28\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 28 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 28\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 28 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 28\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    public static void testCharP14(char[] data) {\n-        for (int j = 0; j < RANGE - 14; j++) {\n-            data[j + 14] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharP14\")\n-    @Warmup(0)\n-    public static void runCharP14() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharP14(data);\n-        verify(\"testCharP14\", data, goldCharP14);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharM16(char[] data) {\n-        for (int j = 16; j < RANGE; j++) {\n-            data[j + -16] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharM16\")\n-    @Warmup(0)\n-    public static void runCharM16() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharM16(data);\n-        verify(\"testCharM16\", data, goldCharM16);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 32 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 32 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharP16(char[] data) {\n-        for (int j = 0; j < RANGE - 16; j++) {\n-            data[j + 16] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharP16\")\n-    @Warmup(0)\n-    public static void runCharP16() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharP16(data);\n-        verify(\"testCharP16\", data, goldCharP16);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    public static void testCharM18(char[] data) {\n-        for (int j = 18; j < RANGE; j++) {\n-            data[j + -18] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharM18\")\n-    @Warmup(0)\n-    public static void runCharM18() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharM18(data);\n-        verify(\"testCharM18\", data, goldCharM18);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 36 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 36\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 36 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 36\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    public static void testCharP18(char[] data) {\n-        for (int j = 0; j < RANGE - 18; j++) {\n-            data[j + 18] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharP18\")\n-    @Warmup(0)\n-    public static void runCharP18() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharP18(data);\n-        verify(\"testCharP18\", data, goldCharP18);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharM20(char[] data) {\n-        for (int j = 20; j < RANGE; j++) {\n-            data[j + -20] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharM20\")\n-    @Warmup(0)\n-    public static void runCharM20() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharM20(data);\n-        verify(\"testCharM20\", data, goldCharM20);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 40 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 40\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 40\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 40 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 40\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 40\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharP20(char[] data) {\n-        for (int j = 0; j < RANGE - 20; j++) {\n-            data[j + 20] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharP20\")\n-    @Warmup(0)\n-    public static void runCharP20() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharP20(data);\n-        verify(\"testCharP20\", data, goldCharP20);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharM31(char[] data) {\n-        for (int j = 31; j < RANGE; j++) {\n-            data[j + -31] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharM31\")\n-    @Warmup(0)\n-    public static void runCharM31() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharM31(data);\n-        verify(\"testCharM31\", data, goldCharM31);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    \/\/   positive byte_offset 62 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 62\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 62\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 62 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 62\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 62\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharP31(char[] data) {\n-        for (int j = 0; j < RANGE - 31; j++) {\n-            data[j + 31] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharP31\")\n-    @Warmup(0)\n-    public static void runCharP31() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharP31(data);\n-        verify(\"testCharP31\", data, goldCharP31);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharM32(char[] data) {\n-        for (int j = 32; j < RANGE; j++) {\n-            data[j + -32] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharM32\")\n-    @Warmup(0)\n-    public static void runCharM32() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharM32(data);\n-        verify(\"testCharM32\", data, goldCharM32);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 64 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 64\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 64\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharP32(char[] data) {\n-        for (int j = 0; j < RANGE - 32; j++) {\n-            data[j + 32] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharP32\")\n-    @Warmup(0)\n-    public static void runCharP32() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharP32(data);\n-        verify(\"testCharP32\", data, goldCharP32);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharM63(char[] data) {\n-        for (int j = 63; j < RANGE; j++) {\n-            data[j + -63] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharM63\")\n-    @Warmup(0)\n-    public static void runCharM63() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharM63(data);\n-        verify(\"testCharM63\", data, goldCharM63);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 126 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 126\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 126\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharP63(char[] data) {\n-        for (int j = 0; j < RANGE - 63; j++) {\n-            data[j + 63] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharP63\")\n-    @Warmup(0)\n-    public static void runCharP63() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharP63(data);\n-        verify(\"testCharP63\", data, goldCharP63);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharM64(char[] data) {\n-        for (int j = 64; j < RANGE; j++) {\n-            data[j + -64] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharM64\")\n-    @Warmup(0)\n-    public static void runCharM64() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharM64(data);\n-        verify(\"testCharM64\", data, goldCharM64);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 128 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 128\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 128\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharP64(char[] data) {\n-        for (int j = 0; j < RANGE - 64; j++) {\n-            data[j + 64] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharP64\")\n-    @Warmup(0)\n-    public static void runCharP64() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharP64(data);\n-        verify(\"testCharP64\", data, goldCharP64);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharM65(char[] data) {\n-        for (int j = 65; j < RANGE; j++) {\n-            data[j + -65] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharM65\")\n-    @Warmup(0)\n-    public static void runCharM65() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharM65(data);\n-        verify(\"testCharM65\", data, goldCharM65);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    \/\/   positive byte_offset 130 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 130\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 130\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharP65(char[] data) {\n-        for (int j = 0; j < RANGE - 65; j++) {\n-            data[j + 65] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharP65\")\n-    @Warmup(0)\n-    public static void runCharP65() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharP65(data);\n-        verify(\"testCharP65\", data, goldCharP65);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharM128(char[] data) {\n-        for (int j = 128; j < RANGE; j++) {\n-            data[j + -128] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharM128\")\n-    @Warmup(0)\n-    public static void runCharM128() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharM128(data);\n-        verify(\"testCharM128\", data, goldCharM128);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharP128(char[] data) {\n-        for (int j = 0; j < RANGE - 128; j++) {\n-            data[j + 128] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharP128\")\n-    @Warmup(0)\n-    public static void runCharP128() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharP128(data);\n-        verify(\"testCharP128\", data, goldCharP128);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharM129(char[] data) {\n-        for (int j = 129; j < RANGE; j++) {\n-            data[j + -129] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharM129\")\n-    @Warmup(0)\n-    public static void runCharM129() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharM129(data);\n-        verify(\"testCharM129\", data, goldCharM129);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_C, IRNode.MUL_VS, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharP129(char[] data) {\n-        for (int j = 0; j < RANGE - 129; j++) {\n-            data[j + 129] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharP129\")\n-    @Warmup(0)\n-    public static void runCharP129() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharP129(data);\n-        verify(\"testCharP129\", data, goldCharP129);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharM192(char[] data) {\n-        for (int j = 192; j < RANGE; j++) {\n-            data[j + -192] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharM192\")\n-    @Warmup(0)\n-    public static void runCharM192() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharM192(data);\n-        verify(\"testCharM192\", data, goldCharM192);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 128\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_C, \"> 0\", IRNode.MUL_VS, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testCharP192(char[] data) {\n-        for (int j = 0; j < RANGE - 192; j++) {\n-            data[j + 192] = (char)(data[j] * (char)-11);\n-        }\n-    }\n-\n-    @Run(test = \"testCharP192\")\n-    @Warmup(0)\n-    public static void runCharP192() {\n-        char[] data = new char[RANGE];\n-        init(data);\n-        testCharP192(data);\n-        verify(\"testCharP192\", data, goldCharP192);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteP0(byte[] data) {\n-        for (int j = 0; j < RANGE; j++) {\n-            data[j + 0] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteP0\")\n-    @Warmup(0)\n-    public static void runByteP0() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteP0(data);\n-        verify(\"testByteP0\", data, goldByteP0);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteM1(byte[] data) {\n-        for (int j = 1; j < RANGE; j++) {\n-            data[j + -1] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteM1\")\n-    @Warmup(0)\n-    public static void runByteM1() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteM1(data);\n-        verify(\"testByteM1\", data, goldByteM1);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    \/\/   positive byte_offset 1 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 1\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    \/\/   positive byte_offset 1 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 1\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    \/\/   positive byte_offset 1 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 1\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    \/\/   positive byte_offset 1 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 1\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    \/\/   positive byte_offset 1 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 1\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteP1(byte[] data) {\n-        for (int j = 0; j < RANGE - 1; j++) {\n-            data[j + 1] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteP1\")\n-    @Warmup(0)\n-    public static void runByteP1() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteP1(data);\n-        verify(\"testByteP1\", data, goldByteP1);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteM2(byte[] data) {\n-        for (int j = 2; j < RANGE; j++) {\n-            data[j + -2] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteM2\")\n-    @Warmup(0)\n-    public static void runByteM2() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteM2(data);\n-        verify(\"testByteM2\", data, goldByteM2);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    \/\/   positive byte_offset 2 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    \/\/   positive byte_offset 2 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    \/\/   positive byte_offset 2 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    \/\/   positive byte_offset 2 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    \/\/   positive byte_offset 2 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 2\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteP2(byte[] data) {\n-        for (int j = 0; j < RANGE - 2; j++) {\n-            data[j + 2] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteP2\")\n-    @Warmup(0)\n-    public static void runByteP2() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteP2(data);\n-        verify(\"testByteP2\", data, goldByteP2);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteM3(byte[] data) {\n-        for (int j = 3; j < RANGE; j++) {\n-            data[j + -3] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteM3\")\n-    @Warmup(0)\n-    public static void runByteM3() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteM3(data);\n-        verify(\"testByteM3\", data, goldByteM3);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    \/\/   positive byte_offset 3 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 3\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    \/\/   positive byte_offset 3 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 3\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    \/\/   positive byte_offset 3 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 3\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    \/\/   positive byte_offset 3 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 3\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    \/\/   positive byte_offset 3 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 3\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteP3(byte[] data) {\n-        for (int j = 0; j < RANGE - 3; j++) {\n-            data[j + 3] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteP3\")\n-    @Warmup(0)\n-    public static void runByteP3() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteP3(data);\n-        verify(\"testByteP3\", data, goldByteP3);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    public static void testByteM4(byte[] data) {\n-        for (int j = 4; j < RANGE; j++) {\n-            data[j + -4] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteM4\")\n-    @Warmup(0)\n-    public static void runByteM4() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteM4(data);\n-        verify(\"testByteM4\", data, goldByteM4);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    public static void testByteP4(byte[] data) {\n-        for (int j = 0; j < RANGE - 4; j++) {\n-            data[j + 4] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteP4\")\n-    @Warmup(0)\n-    public static void runByteP4() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteP4(data);\n-        verify(\"testByteP4\", data, goldByteP4);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteM7(byte[] data) {\n-        for (int j = 7; j < RANGE; j++) {\n-            data[j + -7] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteM7\")\n-    @Warmup(0)\n-    public static void runByteM7() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteM7(data);\n-        verify(\"testByteM7\", data, goldByteM7);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    \/\/   positive byte_offset 7 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 7\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 7\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    \/\/   positive byte_offset 7 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 7\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 7\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    \/\/   positive byte_offset 7 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 7\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 7\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    \/\/   positive byte_offset 7 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 7\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 7\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    \/\/   positive byte_offset 7 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 7\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 7\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteP7(byte[] data) {\n-        for (int j = 0; j < RANGE - 7; j++) {\n-            data[j + 7] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteP7\")\n-    @Warmup(0)\n-    public static void runByteP7() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteP7(data);\n-        verify(\"testByteP7\", data, goldByteP7);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteM8(byte[] data) {\n-        for (int j = 8; j < RANGE; j++) {\n-            data[j + -8] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteM8\")\n-    @Warmup(0)\n-    public static void runByteM8() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteM8(data);\n-        verify(\"testByteM8\", data, goldByteM8);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteP8(byte[] data) {\n-        for (int j = 0; j < RANGE - 8; j++) {\n-            data[j + 8] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteP8\")\n-    @Warmup(0)\n-    public static void runByteP8() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteP8(data);\n-        verify(\"testByteP8\", data, goldByteP8);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteM14(byte[] data) {\n-        for (int j = 14; j < RANGE; j++) {\n-            data[j + -14] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteM14\")\n-    @Warmup(0)\n-    public static void runByteM14() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteM14(data);\n-        verify(\"testByteM14\", data, goldByteM14);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    \/\/   positive byte_offset 14 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    \/\/   positive byte_offset 14 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    \/\/   positive byte_offset 14 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    \/\/   positive byte_offset 14 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    \/\/   positive byte_offset 14 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 14\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteP14(byte[] data) {\n-        for (int j = 0; j < RANGE - 14; j++) {\n-            data[j + 14] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteP14\")\n-    @Warmup(0)\n-    public static void runByteP14() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteP14(data);\n-        verify(\"testByteP14\", data, goldByteP14);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteM16(byte[] data) {\n-        for (int j = 16; j < RANGE; j++) {\n-            data[j + -16] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteM16\")\n-    @Warmup(0)\n-    public static void runByteM16() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteM16(data);\n-        verify(\"testByteM16\", data, goldByteM16);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteP16(byte[] data) {\n-        for (int j = 0; j < RANGE - 16; j++) {\n-            data[j + 16] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteP16\")\n-    @Warmup(0)\n-    public static void runByteP16() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteP16(data);\n-        verify(\"testByteP16\", data, goldByteP16);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteM18(byte[] data) {\n-        for (int j = 18; j < RANGE; j++) {\n-            data[j + -18] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteM18\")\n-    @Warmup(0)\n-    public static void runByteM18() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteM18(data);\n-        verify(\"testByteM18\", data, goldByteM18);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    \/\/   positive byte_offset 18 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 18\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 18\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    \/\/   positive byte_offset 18 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 18\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 18\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    \/\/   positive byte_offset 18 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 18\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 18\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteP18(byte[] data) {\n-        for (int j = 0; j < RANGE - 18; j++) {\n-            data[j + 18] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteP18\")\n-    @Warmup(0)\n-    public static void runByteP18() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteP18(data);\n-        verify(\"testByteP18\", data, goldByteP18);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    public static void testByteM20(byte[] data) {\n-        for (int j = 20; j < RANGE; j++) {\n-            data[j + -20] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteM20\")\n-    @Warmup(0)\n-    public static void runByteM20() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteM20(data);\n-        verify(\"testByteM20\", data, goldByteM20);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    \/\/   positive byte_offset 20 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 20\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    \/\/   positive byte_offset 20 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 20\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    \/\/   positive byte_offset 20 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 20\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Alignment unclear -> no IR rule for -XX:+AlignVector.\n-    public static void testByteP20(byte[] data) {\n-        for (int j = 0; j < RANGE - 20; j++) {\n-            data[j + 20] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteP20\")\n-    @Warmup(0)\n-    public static void runByteP20() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteP20(data);\n-        verify(\"testByteP20\", data, goldByteP20);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteM31(byte[] data) {\n-        for (int j = 31; j < RANGE; j++) {\n-            data[j + -31] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteM31\")\n-    @Warmup(0)\n-    public static void runByteM31() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteM31(data);\n-        verify(\"testByteM31\", data, goldByteM31);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    \/\/   positive byte_offset 31 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 31\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 31\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    \/\/   positive byte_offset 31 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 31\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 31\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    \/\/   positive byte_offset 31 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 31\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 31\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteP31(byte[] data) {\n-        for (int j = 0; j < RANGE - 31; j++) {\n-            data[j + 31] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteP31\")\n-    @Warmup(0)\n-    public static void runByteP31() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteP31(data);\n-        verify(\"testByteP31\", data, goldByteP31);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteM32(byte[] data) {\n-        for (int j = 32; j < RANGE; j++) {\n-            data[j + -32] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteM32\")\n-    @Warmup(0)\n-    public static void runByteM32() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteM32(data);\n-        verify(\"testByteM32\", data, goldByteM32);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    \/\/   positive byte_offset 32 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    \/\/   positive byte_offset 32 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteP32(byte[] data) {\n-        for (int j = 0; j < RANGE - 32; j++) {\n-            data[j + 32] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteP32\")\n-    @Warmup(0)\n-    public static void runByteP32() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteP32(data);\n-        verify(\"testByteP32\", data, goldByteP32);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteM63(byte[] data) {\n-        for (int j = 63; j < RANGE; j++) {\n-            data[j + -63] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteM63\")\n-    @Warmup(0)\n-    public static void runByteM63() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteM63(data);\n-        verify(\"testByteM63\", data, goldByteM63);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    \/\/   positive byte_offset 63 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 63\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 63\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    \/\/   positive byte_offset 63 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 63\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 63\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteP63(byte[] data) {\n-        for (int j = 0; j < RANGE - 63; j++) {\n-            data[j + 63] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteP63\")\n-    @Warmup(0)\n-    public static void runByteP63() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteP63(data);\n-        verify(\"testByteP63\", data, goldByteP63);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteM64(byte[] data) {\n-        for (int j = 64; j < RANGE; j++) {\n-            data[j + -64] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteM64\")\n-    @Warmup(0)\n-    public static void runByteM64() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteM64(data);\n-        verify(\"testByteM64\", data, goldByteM64);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    \/\/   positive byte_offset 64 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 64\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 64\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteP64(byte[] data) {\n-        for (int j = 0; j < RANGE - 64; j++) {\n-            data[j + 64] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteP64\")\n-    @Warmup(0)\n-    public static void runByteP64() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteP64(data);\n-        verify(\"testByteP64\", data, goldByteP64);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteM65(byte[] data) {\n-        for (int j = 65; j < RANGE; j++) {\n-            data[j + -65] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteM65\")\n-    @Warmup(0)\n-    public static void runByteM65() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteM65(data);\n-        verify(\"testByteM65\", data, goldByteM65);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    \/\/   positive byte_offset 65 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 65\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 65\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteP65(byte[] data) {\n-        for (int j = 0; j < RANGE - 65; j++) {\n-            data[j + 65] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteP65\")\n-    @Warmup(0)\n-    public static void runByteP65() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteP65(data);\n-        verify(\"testByteP65\", data, goldByteP65);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteM128(byte[] data) {\n-        for (int j = 128; j < RANGE; j++) {\n-            data[j + -128] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteM128\")\n-    @Warmup(0)\n-    public static void runByteM128() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteM128(data);\n-        verify(\"testByteM128\", data, goldByteM128);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    \/\/   positive byte_offset 128 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 128\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 128\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteP128(byte[] data) {\n-        for (int j = 0; j < RANGE - 128; j++) {\n-            data[j + 128] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteP128\")\n-    @Warmup(0)\n-    public static void runByteP128() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteP128(data);\n-        verify(\"testByteP128\", data, goldByteP128);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteM129(byte[] data) {\n-        for (int j = 129; j < RANGE; j++) {\n-            data[j + -129] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteM129\")\n-    @Warmup(0)\n-    public static void runByteM129() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteM129(data);\n-        verify(\"testByteM129\", data, goldByteM129);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    \/\/   positive byte_offset 129 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 129\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_B, IRNode.MUL_VB, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 129\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteP129(byte[] data) {\n-        for (int j = 0; j < RANGE - 129; j++) {\n-            data[j + 129] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteP129\")\n-    @Warmup(0)\n-    public static void runByteP129() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteP129(data);\n-        verify(\"testByteP129\", data, goldByteP129);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteM192(byte[] data) {\n-        for (int j = 192; j < RANGE; j++) {\n-            data[j + -192] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteM192\")\n-    @Warmup(0)\n-    public static void runByteM192() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteM192(data);\n-        verify(\"testByteM192\", data, goldByteM192);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n-    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n-    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 256\n-    \/\/   positive byte_offset 192 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 192\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\", IRNode.MUL_VB, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 192\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testByteP192(byte[] data) {\n-        for (int j = 0; j < RANGE - 192; j++) {\n-            data[j + 192] = (byte)(data[j] * (byte)11);\n-        }\n-    }\n-\n-    @Run(test = \"testByteP192\")\n-    @Warmup(0)\n-    public static void runByteP192() {\n-        byte[] data = new byte[RANGE];\n-        init(data);\n-        testByteP192(data);\n-        verify(\"testByteP192\", data, goldByteP192);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatP0(float[] data) {\n-        for (int j = 0; j < RANGE; j++) {\n-            data[j + 0] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatP0\")\n-    @Warmup(0)\n-    public static void runFloatP0() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatP0(data);\n-        verify(\"testFloatP0\", data, goldFloatP0);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatM1(float[] data) {\n-        for (int j = 1; j < RANGE; j++) {\n-            data[j + -1] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatM1\")\n-    @Warmup(0)\n-    public static void runFloatM1() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatM1(data);\n-        verify(\"testFloatM1\", data, goldFloatM1);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 4 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 4\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatP1(float[] data) {\n-        for (int j = 0; j < RANGE - 1; j++) {\n-            data[j + 1] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatP1\")\n-    @Warmup(0)\n-    public static void runFloatP1() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatP1(data);\n-        verify(\"testFloatP1\", data, goldFloatP1);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatM2(float[] data) {\n-        for (int j = 2; j < RANGE; j++) {\n-            data[j + -2] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatM2\")\n-    @Warmup(0)\n-    public static void runFloatM2() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatM2(data);\n-        verify(\"testFloatM2\", data, goldFloatM2);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatP2(float[] data) {\n-        for (int j = 0; j < RANGE - 2; j++) {\n-            data[j + 2] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatP2\")\n-    @Warmup(0)\n-    public static void runFloatP2() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatP2(data);\n-        verify(\"testFloatP2\", data, goldFloatP2);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatM3(float[] data) {\n-        for (int j = 3; j < RANGE; j++) {\n-            data[j + -3] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatM3\")\n-    @Warmup(0)\n-    public static void runFloatM3() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatM3(data);\n-        verify(\"testFloatM3\", data, goldFloatM3);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    \/\/   positive byte_offset 12 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 12\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    \/\/   positive byte_offset 12 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 12\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    \/\/   positive byte_offset 12 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 12\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    \/\/   positive byte_offset 12 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 12\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 12 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 12\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 12\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatP3(float[] data) {\n-        for (int j = 0; j < RANGE - 3; j++) {\n-            data[j + 3] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatP3\")\n-    @Warmup(0)\n-    public static void runFloatP3() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatP3(data);\n-        verify(\"testFloatP3\", data, goldFloatP3);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatM4(float[] data) {\n-        for (int j = 4; j < RANGE; j++) {\n-            data[j + -4] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatM4\")\n-    @Warmup(0)\n-    public static void runFloatM4() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatM4(data);\n-        verify(\"testFloatM4\", data, goldFloatM4);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatP4(float[] data) {\n-        for (int j = 0; j < RANGE - 4; j++) {\n-            data[j + 4] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatP4\")\n-    @Warmup(0)\n-    public static void runFloatP4() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatP4(data);\n-        verify(\"testFloatP4\", data, goldFloatP4);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatM7(float[] data) {\n-        for (int j = 7; j < RANGE; j++) {\n-            data[j + -7] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatM7\")\n-    @Warmup(0)\n-    public static void runFloatM7() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatM7(data);\n-        verify(\"testFloatM7\", data, goldFloatM7);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    \/\/   positive byte_offset 28 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 28\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 28\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    \/\/   positive byte_offset 28 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 28\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 28\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 28 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 28\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 28\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatP7(float[] data) {\n-        for (int j = 0; j < RANGE - 7; j++) {\n-            data[j + 7] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatP7\")\n-    @Warmup(0)\n-    public static void runFloatP7() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatP7(data);\n-        verify(\"testFloatP7\", data, goldFloatP7);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatM8(float[] data) {\n-        for (int j = 8; j < RANGE; j++) {\n-            data[j + -8] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatM8\")\n-    @Warmup(0)\n-    public static void runFloatM8() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatM8(data);\n-        verify(\"testFloatM8\", data, goldFloatM8);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    \/\/   positive byte_offset 32 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 32 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatP8(float[] data) {\n-        for (int j = 0; j < RANGE - 8; j++) {\n-            data[j + 8] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatP8\")\n-    @Warmup(0)\n-    public static void runFloatP8() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatP8(data);\n-        verify(\"testFloatP8\", data, goldFloatP8);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatM14(float[] data) {\n-        for (int j = 14; j < RANGE; j++) {\n-            data[j + -14] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatM14\")\n-    @Warmup(0)\n-    public static void runFloatM14() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatM14(data);\n-        verify(\"testFloatM14\", data, goldFloatM14);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    \/\/   positive byte_offset 56 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 56\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 56\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 56 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 56\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 56\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatP14(float[] data) {\n-        for (int j = 0; j < RANGE - 14; j++) {\n-            data[j + 14] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatP14\")\n-    @Warmup(0)\n-    public static void runFloatP14() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatP14(data);\n-        verify(\"testFloatP14\", data, goldFloatP14);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatM16(float[] data) {\n-        for (int j = 16; j < RANGE; j++) {\n-            data[j + -16] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatM16\")\n-    @Warmup(0)\n-    public static void runFloatM16() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatM16(data);\n-        verify(\"testFloatM16\", data, goldFloatM16);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 64 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 64\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 64\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatP16(float[] data) {\n-        for (int j = 0; j < RANGE - 16; j++) {\n-            data[j + 16] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatP16\")\n-    @Warmup(0)\n-    public static void runFloatP16() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatP16(data);\n-        verify(\"testFloatP16\", data, goldFloatP16);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatM18(float[] data) {\n-        for (int j = 18; j < RANGE; j++) {\n-            data[j + -18] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatM18\")\n-    @Warmup(0)\n-    public static void runFloatM18() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatM18(data);\n-        verify(\"testFloatM18\", data, goldFloatM18);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 72 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 72\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 72\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatP18(float[] data) {\n-        for (int j = 0; j < RANGE - 18; j++) {\n-            data[j + 18] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatP18\")\n-    @Warmup(0)\n-    public static void runFloatP18() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatP18(data);\n-        verify(\"testFloatP18\", data, goldFloatP18);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatM20(float[] data) {\n-        for (int j = 20; j < RANGE; j++) {\n-            data[j + -20] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatM20\")\n-    @Warmup(0)\n-    public static void runFloatM20() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatM20(data);\n-        verify(\"testFloatM20\", data, goldFloatM20);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 80 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 80\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 80\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatP20(float[] data) {\n-        for (int j = 0; j < RANGE - 20; j++) {\n-            data[j + 20] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatP20\")\n-    @Warmup(0)\n-    public static void runFloatP20() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatP20(data);\n-        verify(\"testFloatP20\", data, goldFloatP20);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatM31(float[] data) {\n-        for (int j = 31; j < RANGE; j++) {\n-            data[j + -31] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatM31\")\n-    @Warmup(0)\n-    public static void runFloatM31() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatM31(data);\n-        verify(\"testFloatM31\", data, goldFloatM31);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 124 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 124\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 124\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatP31(float[] data) {\n-        for (int j = 0; j < RANGE - 31; j++) {\n-            data[j + 31] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatP31\")\n-    @Warmup(0)\n-    public static void runFloatP31() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatP31(data);\n-        verify(\"testFloatP31\", data, goldFloatP31);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatM32(float[] data) {\n-        for (int j = 32; j < RANGE; j++) {\n-            data[j + -32] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatM32\")\n-    @Warmup(0)\n-    public static void runFloatM32() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatM32(data);\n-        verify(\"testFloatM32\", data, goldFloatM32);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 128 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 128\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 128\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatP32(float[] data) {\n-        for (int j = 0; j < RANGE - 32; j++) {\n-            data[j + 32] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatP32\")\n-    @Warmup(0)\n-    public static void runFloatP32() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatP32(data);\n-        verify(\"testFloatP32\", data, goldFloatP32);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatM63(float[] data) {\n-        for (int j = 63; j < RANGE; j++) {\n-            data[j + -63] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatM63\")\n-    @Warmup(0)\n-    public static void runFloatM63() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatM63(data);\n-        verify(\"testFloatM63\", data, goldFloatM63);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    \/\/   positive byte_offset 252 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 252\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"<= 252\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatP63(float[] data) {\n-        for (int j = 0; j < RANGE - 63; j++) {\n-            data[j + 63] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatP63\")\n-    @Warmup(0)\n-    public static void runFloatP63() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatP63(data);\n-        verify(\"testFloatP63\", data, goldFloatP63);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatM64(float[] data) {\n-        for (int j = 64; j < RANGE; j++) {\n-            data[j + -64] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatM64\")\n-    @Warmup(0)\n-    public static void runFloatM64() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatM64(data);\n-        verify(\"testFloatM64\", data, goldFloatM64);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatP64(float[] data) {\n-        for (int j = 0; j < RANGE - 64; j++) {\n-            data[j + 64] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatP64\")\n-    @Warmup(0)\n-    public static void runFloatP64() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatP64(data);\n-        verify(\"testFloatP64\", data, goldFloatP64);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatM65(float[] data) {\n-        for (int j = 65; j < RANGE; j++) {\n-            data[j + -65] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatM65\")\n-    @Warmup(0)\n-    public static void runFloatM65() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatM65(data);\n-        verify(\"testFloatM65\", data, goldFloatM65);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatP65(float[] data) {\n-        for (int j = 0; j < RANGE - 65; j++) {\n-            data[j + 65] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatP65\")\n-    @Warmup(0)\n-    public static void runFloatP65() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatP65(data);\n-        verify(\"testFloatP65\", data, goldFloatP65);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatM128(float[] data) {\n-        for (int j = 128; j < RANGE; j++) {\n-            data[j + -128] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatM128\")\n-    @Warmup(0)\n-    public static void runFloatM128() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatM128(data);\n-        verify(\"testFloatM128\", data, goldFloatM128);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatP128(float[] data) {\n-        for (int j = 0; j < RANGE - 128; j++) {\n-            data[j + 128] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatP128\")\n-    @Warmup(0)\n-    public static void runFloatP128() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatP128(data);\n-        verify(\"testFloatP128\", data, goldFloatP128);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatM129(float[] data) {\n-        for (int j = 129; j < RANGE; j++) {\n-            data[j + -129] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatM129\")\n-    @Warmup(0)\n-    public static void runFloatM129() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatM129(data);\n-        verify(\"testFloatM129\", data, goldFloatM129);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect misalignment.\n-    @IR(failOn = {IRNode.LOAD_VECTOR_F, IRNode.MUL_VF, IRNode.STORE_VECTOR},\n-        applyIf = {\"AlignVector\", \"true\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatP129(float[] data) {\n-        for (int j = 0; j < RANGE - 129; j++) {\n-            data[j + 129] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatP129\")\n-    @Warmup(0)\n-    public static void runFloatP129() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatP129(data);\n-        verify(\"testFloatP129\", data, goldFloatP129);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatM192(float[] data) {\n-        for (int j = 192; j < RANGE; j++) {\n-            data[j + -192] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatM192\")\n-    @Warmup(0)\n-    public static void runFloatM192() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatM192(data);\n-        verify(\"testFloatM192\", data, goldFloatM192);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 64\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testFloatP192(float[] data) {\n-        for (int j = 0; j < RANGE - 192; j++) {\n-            data[j + 192] = (float)(data[j] * (float)1.001f);\n-        }\n-    }\n-\n-    @Run(test = \"testFloatP192\")\n-    @Warmup(0)\n-    public static void runFloatP192() {\n-        float[] data = new float[RANGE];\n-        init(data);\n-        testFloatP192(data);\n-        verify(\"testFloatP192\", data, goldFloatP192);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleP0(double[] data) {\n-        for (int j = 0; j < RANGE; j++) {\n-            data[j + 0] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleP0\")\n-    @Warmup(0)\n-    public static void runDoubleP0() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleP0(data);\n-        verify(\"testDoubleP0\", data, goldDoubleP0);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleM1(double[] data) {\n-        for (int j = 1; j < RANGE; j++) {\n-            data[j + -1] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleM1\")\n-    @Warmup(0)\n-    public static void runDoubleM1() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleM1(data);\n-        verify(\"testDoubleM1\", data, goldDoubleM1);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect alignment.\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect alignment.\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect alignment.\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect alignment.\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 8 can lead to cyclic dependency\n-    \/\/   No positive IR rule: conditions impossible.\n-    \/\/   Expect alignment.\n-    \/\/   No positive IR rule: conditions impossible.\n-    public static void testDoubleP1(double[] data) {\n-        for (int j = 0; j < RANGE - 1; j++) {\n-            data[j + 1] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleP1\")\n-    @Warmup(0)\n-    public static void runDoubleP1() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleP1(data);\n-        verify(\"testDoubleP1\", data, goldDoubleP1);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleM2(double[] data) {\n-        for (int j = 2; j < RANGE; j++) {\n-            data[j + -2] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleM2\")\n-    @Warmup(0)\n-    public static void runDoubleM2() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleM2(data);\n-        verify(\"testDoubleM2\", data, goldDoubleM2);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 16 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \"16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \"16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleP2(double[] data) {\n-        for (int j = 0; j < RANGE - 2; j++) {\n-            data[j + 2] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleP2\")\n-    @Warmup(0)\n-    public static void runDoubleP2() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleP2(data);\n-        verify(\"testDoubleP2\", data, goldDoubleP2);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleM3(double[] data) {\n-        for (int j = 3; j < RANGE; j++) {\n-            data[j + -3] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleM3\")\n-    @Warmup(0)\n-    public static void runDoubleM3() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleM3(data);\n-        verify(\"testDoubleM3\", data, goldDoubleM3);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    \/\/   positive byte_offset 24 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    \/\/   positive byte_offset 24 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 24 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleP3(double[] data) {\n-        for (int j = 0; j < RANGE - 3; j++) {\n-            data[j + 3] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleP3\")\n-    @Warmup(0)\n-    public static void runDoubleP3() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleP3(data);\n-        verify(\"testDoubleP3\", data, goldDoubleP3);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleM4(double[] data) {\n-        for (int j = 4; j < RANGE; j++) {\n-            data[j + -4] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleM4\")\n-    @Warmup(0)\n-    public static void runDoubleM4() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleM4(data);\n-        verify(\"testDoubleM4\", data, goldDoubleM4);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    \/\/   positive byte_offset 32 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 32 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 32\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleP4(double[] data) {\n-        for (int j = 0; j < RANGE - 4; j++) {\n-            data[j + 4] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleP4\")\n-    @Warmup(0)\n-    public static void runDoubleP4() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleP4(data);\n-        verify(\"testDoubleP4\", data, goldDoubleP4);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleM7(double[] data) {\n-        for (int j = 7; j < RANGE; j++) {\n-            data[j + -7] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleM7\")\n-    @Warmup(0)\n-    public static void runDoubleM7() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleM7(data);\n-        verify(\"testDoubleM7\", data, goldDoubleM7);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    \/\/   positive byte_offset 56 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 56\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 56\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 56 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 56\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 56\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleP7(double[] data) {\n-        for (int j = 0; j < RANGE - 7; j++) {\n-            data[j + 7] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleP7\")\n-    @Warmup(0)\n-    public static void runDoubleP7() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleP7(data);\n-        verify(\"testDoubleP7\", data, goldDoubleP7);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleM8(double[] data) {\n-        for (int j = 8; j < RANGE; j++) {\n-            data[j + -8] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleM8\")\n-    @Warmup(0)\n-    public static void runDoubleM8() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleM8(data);\n-        verify(\"testDoubleM8\", data, goldDoubleM8);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 64 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 64\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 64\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleP8(double[] data) {\n-        for (int j = 0; j < RANGE - 8; j++) {\n-            data[j + 8] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleP8\")\n-    @Warmup(0)\n-    public static void runDoubleP8() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleP8(data);\n-        verify(\"testDoubleP8\", data, goldDoubleP8);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleM14(double[] data) {\n-        for (int j = 14; j < RANGE; j++) {\n-            data[j + -14] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleM14\")\n-    @Warmup(0)\n-    public static void runDoubleM14() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleM14(data);\n-        verify(\"testDoubleM14\", data, goldDoubleM14);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 112 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 112\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 112\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleP14(double[] data) {\n-        for (int j = 0; j < RANGE - 14; j++) {\n-            data[j + 14] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleP14\")\n-    @Warmup(0)\n-    public static void runDoubleP14() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleP14(data);\n-        verify(\"testDoubleP14\", data, goldDoubleP14);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleM16(double[] data) {\n-        for (int j = 16; j < RANGE; j++) {\n-            data[j + -16] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleM16\")\n-    @Warmup(0)\n-    public static void runDoubleM16() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleM16(data);\n-        verify(\"testDoubleM16\", data, goldDoubleM16);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 128 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 128\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 128\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleP16(double[] data) {\n-        for (int j = 0; j < RANGE - 16; j++) {\n-            data[j + 16] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleP16\")\n-    @Warmup(0)\n-    public static void runDoubleP16() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleP16(data);\n-        verify(\"testDoubleP16\", data, goldDoubleP16);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleM18(double[] data) {\n-        for (int j = 18; j < RANGE; j++) {\n-            data[j + -18] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleM18\")\n-    @Warmup(0)\n-    public static void runDoubleM18() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleM18(data);\n-        verify(\"testDoubleM18\", data, goldDoubleM18);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 144 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 144\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 144\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleP18(double[] data) {\n-        for (int j = 0; j < RANGE - 18; j++) {\n-            data[j + 18] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleP18\")\n-    @Warmup(0)\n-    public static void runDoubleP18() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleP18(data);\n-        verify(\"testDoubleP18\", data, goldDoubleP18);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleM20(double[] data) {\n-        for (int j = 20; j < RANGE; j++) {\n-            data[j + -20] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleM20\")\n-    @Warmup(0)\n-    public static void runDoubleM20() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleM20(data);\n-        verify(\"testDoubleM20\", data, goldDoubleM20);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 160 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 160\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 160\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleP20(double[] data) {\n-        for (int j = 0; j < RANGE - 20; j++) {\n-            data[j + 20] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleP20\")\n-    @Warmup(0)\n-    public static void runDoubleP20() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleP20(data);\n-        verify(\"testDoubleP20\", data, goldDoubleP20);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleM31(double[] data) {\n-        for (int j = 31; j < RANGE; j++) {\n-            data[j + -31] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleM31\")\n-    @Warmup(0)\n-    public static void runDoubleM31() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleM31(data);\n-        verify(\"testDoubleM31\", data, goldDoubleM31);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    \/\/   positive byte_offset 248 can lead to cyclic dependency\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 248\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 248\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleP31(double[] data) {\n-        for (int j = 0; j < RANGE - 31; j++) {\n-            data[j + 31] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleP31\")\n-    @Warmup(0)\n-    public static void runDoubleP31() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleP31(data);\n-        verify(\"testDoubleP31\", data, goldDoubleP31);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleM32(double[] data) {\n-        for (int j = 32; j < RANGE; j++) {\n-            data[j + -32] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleM32\")\n-    @Warmup(0)\n-    public static void runDoubleM32() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleM32(data);\n-        verify(\"testDoubleM32\", data, goldDoubleM32);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleP32(double[] data) {\n-        for (int j = 0; j < RANGE - 32; j++) {\n-            data[j + 32] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleP32\")\n-    @Warmup(0)\n-    public static void runDoubleP32() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleP32(data);\n-        verify(\"testDoubleP32\", data, goldDoubleP32);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleM63(double[] data) {\n-        for (int j = 63; j < RANGE; j++) {\n-            data[j + -63] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleM63\")\n-    @Warmup(0)\n-    public static void runDoubleM63() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleM63(data);\n-        verify(\"testDoubleM63\", data, goldDoubleM63);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleP63(double[] data) {\n-        for (int j = 0; j < RANGE - 63; j++) {\n-            data[j + 63] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleP63\")\n-    @Warmup(0)\n-    public static void runDoubleP63() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleP63(data);\n-        verify(\"testDoubleP63\", data, goldDoubleP63);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleM64(double[] data) {\n-        for (int j = 64; j < RANGE; j++) {\n-            data[j + -64] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleM64\")\n-    @Warmup(0)\n-    public static void runDoubleM64() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleM64(data);\n-        verify(\"testDoubleM64\", data, goldDoubleM64);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleP64(double[] data) {\n-        for (int j = 0; j < RANGE - 64; j++) {\n-            data[j + 64] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleP64\")\n-    @Warmup(0)\n-    public static void runDoubleP64() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleP64(data);\n-        verify(\"testDoubleP64\", data, goldDoubleP64);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleM65(double[] data) {\n-        for (int j = 65; j < RANGE; j++) {\n-            data[j + -65] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleM65\")\n-    @Warmup(0)\n-    public static void runDoubleM65() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleM65(data);\n-        verify(\"testDoubleM65\", data, goldDoubleM65);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleP65(double[] data) {\n-        for (int j = 0; j < RANGE - 65; j++) {\n-            data[j + 65] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleP65\")\n-    @Warmup(0)\n-    public static void runDoubleP65() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleP65(data);\n-        verify(\"testDoubleP65\", data, goldDoubleP65);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleM128(double[] data) {\n-        for (int j = 128; j < RANGE; j++) {\n-            data[j + -128] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleM128\")\n-    @Warmup(0)\n-    public static void runDoubleM128() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleM128(data);\n-        verify(\"testDoubleM128\", data, goldDoubleM128);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleP128(double[] data) {\n-        for (int j = 0; j < RANGE - 128; j++) {\n-            data[j + 128] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleP128\")\n-    @Warmup(0)\n-    public static void runDoubleP128() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleP128(data);\n-        verify(\"testDoubleP128\", data, goldDoubleP128);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleM129(double[] data) {\n-        for (int j = 129; j < RANGE; j++) {\n-            data[j + -129] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleM129\")\n-    @Warmup(0)\n-    public static void runDoubleM129() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleM129(data);\n-        verify(\"testDoubleM129\", data, goldDoubleM129);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleP129(double[] data) {\n-        for (int j = 0; j < RANGE - 129; j++) {\n-            data[j + 129] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleP129\")\n-    @Warmup(0)\n-    public static void runDoubleP129() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleP129(data);\n-        verify(\"testDoubleP129\", data, goldDoubleP129);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleM192(double[] data) {\n-        for (int j = 192; j < RANGE; j++) {\n-            data[j + -192] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleM192\")\n-    @Warmup(0)\n-    public static void runDoubleM192() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleM192(data);\n-        verify(\"testDoubleM192\", data, goldDoubleM192);\n-    }\n-\n-    @Test\n-    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n-    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n-    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"avx512\", \"true\"})\n-    \/\/ CPU: asimd -> vector_width: 16 -> elements in vector: 2\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    \/\/ CPU: sve -> max vector_width: 256 -> max elements in vector: 32\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    \/\/   Expect alignment.\n-    @IR(counts = {IRNode.LOAD_VECTOR_D, \"> 0\", IRNode.MUL_VD, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n-        applyIfCPUFeature = {\"sve\", \"true\"})\n-    public static void testDoubleP192(double[] data) {\n-        for (int j = 0; j < RANGE - 192; j++) {\n-            data[j + 192] = (double)(data[j] * (double)1.001);\n-        }\n-    }\n-\n-    @Run(test = \"testDoubleP192\")\n-    @Warmup(0)\n-    public static void runDoubleP192() {\n-        double[] data = new double[RANGE];\n-        init(data);\n-        testDoubleP192(data);\n-        verify(\"testDoubleP192\", data, goldDoubleP192);\n-    }\n-\n-    \/\/ ------------------- Initialization -------------------\n-\n-    static void init(int[] data) {\n-        for (int j = 0; j < RANGE; j++) {\n-            data[j] = (int)j;\n-        }\n-    }\n-\n-    static void init(long[] data) {\n-        for (int j = 0; j < RANGE; j++) {\n-            data[j] = (long)j;\n-        }\n-    }\n-\n-    static void init(short[] data) {\n-        for (int j = 0; j < RANGE; j++) {\n-            data[j] = (short)j;\n-        }\n-    }\n-\n-    static void init(char[] data) {\n-        for (int j = 0; j < RANGE; j++) {\n-            data[j] = (char)j;\n-        }\n-    }\n-\n-    static void init(byte[] data) {\n-        for (int j = 0; j < RANGE; j++) {\n-            data[j] = (byte)j;\n-        }\n-    }\n-\n-    static void init(float[] data) {\n-        for (int j = 0; j < RANGE; j++) {\n-            data[j] = (float)j;\n-        }\n-    }\n-\n-    static void init(double[] data) {\n-        for (int j = 0; j < RANGE; j++) {\n-            data[j] = (double)j;\n-        }\n-    }\n-\n-    \/\/ ------------------- Verification -------------------\n-\n-    static void verify(String context, int[] data, int[] gold) {\n-        for (int i = 0; i < RANGE; i++) {\n-            if (data[i] != gold[i]) {\n-                throw new RuntimeException(\" Invalid \" + context + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n-            }\n-        }\n-    }\n-    static void verify(String context, long[] data, long[] gold) {\n-        for (int i = 0; i < RANGE; i++) {\n-            if (data[i] != gold[i]) {\n-                throw new RuntimeException(\" Invalid \" + context + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n-            }\n-        }\n-    }\n-    static void verify(String context, short[] data, short[] gold) {\n-        for (int i = 0; i < RANGE; i++) {\n-            if (data[i] != gold[i]) {\n-                throw new RuntimeException(\" Invalid \" + context + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n-            }\n-        }\n-    }\n-    static void verify(String context, char[] data, char[] gold) {\n-        for (int i = 0; i < RANGE; i++) {\n-            if (data[i] != gold[i]) {\n-                throw new RuntimeException(\" Invalid \" + context + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n-            }\n-        }\n-    }\n-    static void verify(String context, byte[] data, byte[] gold) {\n-        for (int i = 0; i < RANGE; i++) {\n-            if (data[i] != gold[i]) {\n-                throw new RuntimeException(\" Invalid \" + context + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n-            }\n-        }\n-    }\n-    static void verify(String context, float[] data, float[] gold) {\n-        for (int i = 0; i < RANGE; i++) {\n-            if (data[i] != gold[i]) {\n-                throw new RuntimeException(\" Invalid \" + context + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n-            }\n-        }\n-    }\n-    static void verify(String context, double[] data, double[] gold) {\n-        for (int i = 0; i < RANGE; i++) {\n-            if (data[i] != gold[i]) {\n-                throw new RuntimeException(\" Invalid \" + context + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+        String counts() {\n+            if (!isPositiveRule) {\n+               return String.format(\"\"\"\n+                       @IR(failOn = {IRNode.LOAD_VECTOR_%s,\n+                                     IRNode.%s,\n+                                     IRNode.STORE_VECTOR},\n+                   \"\"\",\n+                   type.letter(),\n+                   irNode);\n+            } else if (size == null) {\n+               return String.format(\"\"\"\n+                       @IR(counts = {IRNode.LOAD_VECTOR_%s, \">0\",\n+                                     IRNode.%s, \">0\",\n+                                     IRNode.STORE_VECTOR, \">0\"},\n+                   \"\"\",\n+                   type.letter(),\n+                   irNode);\n+            } else {\n+               return String.format(\"\"\"\n+                       @IR(counts = {IRNode.LOAD_VECTOR_%s, IRNode.VECTOR_SIZE + \"%s\", \">0\",\n+                                     IRNode.%s, IRNode.VECTOR_SIZE + \"%s\", \">0\",\n+                                     IRNode.STORE_VECTOR, \">0\"},\n+                   \"\"\",\n+                   type.letter(), size,\n+                   irNode, size);\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestDependencyOffsets.java","additions":492,"deletions":15487,"binary":false,"changes":15979,"status":"modified"}]}