{"files":[{"patch":"@@ -585,0 +585,25 @@\n+    \/*\n+     * Every CPU can define its own Matcher::min_vector_size. This happens to be different for\n+     * our targetted platforms: x86 \/ sse4.1 and aarch64 \/ asimd.\n+     *\/\n+    static record CPUMinVectorWidth (String applyIfCPUFeature, int minVectorWidth) {}\n+\n+    static final String SSE4_ASIMD = \"        applyIfCPUFeatureOr = {\\\"sse4.1\\\", \\\"true\\\", \\\"asimd\\\", \\\"true\\\"})\\n\";\n+    static final String SSE4       = \"        applyIfCPUFeature = {\\\"sse4.1\\\", \\\"true\\\"})\\n\";\n+    static final String ASIMD      = \"        applyIfCPUFeature = {\\\"asimd\\\", \\\"true\\\"})\\n\";\n+\n+    static CPUMinVectorWidth[] getCPUMinVectorWidth(String typeName) {\n+        return switch (typeName) {\n+            case \"byte\"   -> new CPUMinVectorWidth[]{new CPUMinVectorWidth(SSE4_ASIMD, 4 )};\n+            case \"char\"   -> new CPUMinVectorWidth[]{new CPUMinVectorWidth(SSE4,       4 ),\n+                                                     new CPUMinVectorWidth(ASIMD,      8 )};\n+            case \"short\"  -> new CPUMinVectorWidth[]{new CPUMinVectorWidth(SSE4,       4 ),\n+                                                     new CPUMinVectorWidth(ASIMD,      8 )};\n+            case \"int\"    -> new CPUMinVectorWidth[]{new CPUMinVectorWidth(SSE4_ASIMD, 8 )};\n+            case \"long\"   -> new CPUMinVectorWidth[]{new CPUMinVectorWidth(SSE4_ASIMD, 16)};\n+            case \"float\"  -> new CPUMinVectorWidth[]{new CPUMinVectorWidth(SSE4_ASIMD, 8 )};\n+            case \"double\" -> new CPUMinVectorWidth[]{new CPUMinVectorWidth(SSE4_ASIMD, 16)};\n+            default -> { throw new RuntimeException(\"type not supported: \" + typeName); }\n+        };\n+    }\n+\n@@ -707,24 +732,23 @@\n-            \/\/ General condition for vectorization:\n-            \/\/   at least 4 bytes:    width >= 4\n-            \/\/   at least 2 elements: width >= 2 * type.size\n-            int minVectorWidth = Math.max(4, 2 * type.size);\n-            builder.append(\"    \/\/ minVectorWidth = \" + minVectorWidth + \" = max(4, 2 * type.size)\\n\");\n-\n-            int byteOffset = offset * type.size;\n-            builder.append(\"    \/\/ byteOffset = \" + byteOffset + \" = offset * type.size\\n\");\n-\n-            \/\/ In a store-forward case, later iterations load from stores of previous iterations.\n-            \/\/ If the offset is too small, that leads to cyclic dependencies in the vectors. Hence,\n-            \/\/ we use shorter vectors to avoid cycles and still vectorize. Vector lengths have to\n-            \/\/ be powers-of-2, and smaller or equal to the byteOffset. So we round down to the next\n-            \/\/ power of two.\n-            int infinity = 256; \/\/ No vector size is ever larger than this.\n-            int maxVectorWidth = infinity; \/\/ no constraint by default\n-            if (0 < byteOffset && byteOffset < maxVectorWidth) {\n-                int log2 = 31 - Integer.numberOfLeadingZeros(offset);\n-                int floorPow2 = 1 << log2;\n-                maxVectorWidth = Math.min(maxVectorWidth, floorPow2 * type.size);\n-                builder.append(\"    \/\/ Vectors must have at most \" + floorPow2 +\n-                               \" elements: maxVectorWidth = \" + maxVectorWidth +\n-                               \" to avoid cyclic dependency.\\n\");\n-            }\n+            for (CPUMinVectorWidth cm : getCPUMinVectorWidth(type.name)) {\n+                String applyIfCPUFeature = cm.applyIfCPUFeature;\n+                int minVectorWidth = cm.minVectorWidth;\n+                builder.append(\"    \/\/ minVectorWidth = \" + minVectorWidth + \"\\n\");\n+\n+                int byteOffset = offset * type.size;\n+                builder.append(\"    \/\/ byteOffset = \" + byteOffset + \" = offset * type.size\\n\");\n+\n+                \/\/ In a store-forward case, later iterations load from stores of previous iterations.\n+                \/\/ If the offset is too small, that leads to cyclic dependencies in the vectors. Hence,\n+                \/\/ we use shorter vectors to avoid cycles and still vectorize. Vector lengths have to\n+                \/\/ be powers-of-2, and smaller or equal to the byteOffset. So we round down to the next\n+                \/\/ power of two.\n+                int infinity = 256; \/\/ No vector size is ever larger than this.\n+                int maxVectorWidth = infinity; \/\/ no constraint by default\n+                if (0 < byteOffset && byteOffset < maxVectorWidth) {\n+                    int log2 = 31 - Integer.numberOfLeadingZeros(offset);\n+                    int floorPow2 = 1 << log2;\n+                    maxVectorWidth = Math.min(maxVectorWidth, floorPow2 * type.size);\n+                    builder.append(\"    \/\/ Vectors must have at most \" + floorPow2 +\n+                                   \" elements: maxVectorWidth = \" + maxVectorWidth +\n+                                   \" to avoid cyclic dependency.\\n\");\n+                }\n@@ -732,4 +756,4 @@\n-            \/\/ Rule 1: No strict alignment: -XX:-AlignVector\n-            IRRule r1 = new IRRule(type, type.irNode);\n-            r1.addApplyIf(\"\\\"AlignVector\\\", \\\"false\\\"\");\n-            r1.addApplyIf(\"\\\"MaxVectorSize\\\", \\\">=\" + minVectorWidth + \"\\\"\");\n+                \/\/ Rule 1: No strict alignment: -XX:-AlignVector\n+                IRRule r1 = new IRRule(type, type.irNode, applyIfCPUFeature);\n+                r1.addApplyIf(\"\\\"AlignVector\\\", \\\"false\\\"\");\n+                r1.addApplyIf(\"\\\"MaxVectorSize\\\", \\\">=\" + minVectorWidth + \"\\\"\");\n@@ -737,38 +761,38 @@\n-            if (maxVectorWidth < minVectorWidth) {\n-                builder.append(\"    \/\/ maxVectorWidth < minVectorWidth -> expect no vectorization.\\n\");\n-                r1.setNegative();\n-            } else if (maxVectorWidth < infinity) {\n-                r1.setSize(\"min(\" + (maxVectorWidth \/ type.size) + \",max_\" + type.name + \")\");\n-            }\n-            r1.generate(builder);\n-\n-            \/\/ Rule 2: strict alignment: -XX:+AlignVector\n-            IRRule r2 = new IRRule(type, type.irNode);\n-            r2.addApplyIf(\"\\\"AlignVector\\\", \\\"true\\\"\");\n-            r2.addApplyIf(\"\\\"MaxVectorSize\\\", \\\">=\" + minVectorWidth + \"\\\"\");\n-\n-            \/\/ All vectors must be aligned by some alignment width aw:\n-            \/\/   aw = min(actualVectorWidth, ObjectAlignmentInBytes)\n-            \/\/ The runtime aw must thus lay between these two values:\n-            \/\/   awMin <= aw <= awMax\n-            int awMin = Math.min(minVectorWidth, 8);\n-            int awMax = 8;\n-\n-            \/\/ We must align both the load and the store, thus we must also be able to align\n-            \/\/ for the difference of the two, i.e. byteOffset must be a multiple of aw:\n-            \/\/   byteOffset % aw == 0\n-            \/\/ We don't know the aw, only awMin and awMax. But:\n-            \/\/   byteOffset % awMax == 0      ->      byteOffset % aw == 0\n-            \/\/   byteOffset % awMin != 0      ->      byteOffset % aw != 0\n-            builder.append(\"    \/\/ awMin = \" + awMin + \" = min(minVectorWidth, 8)\\n\");\n-            builder.append(\"    \/\/ awMax = \" + awMax + \"\\n\");\n-\n-            if (byteOffset % awMax == 0) {\n-                builder.append(\"    \/\/ byteOffset % awMax == 0   -> always trivially aligned\\n\");\n-            } else if (byteOffset % awMin != 0) {\n-                builder.append(\"    \/\/ byteOffset % awMin != 0   -> can never align -> expect no vectorization.\\n\");\n-                r2.setNegative();\n-            } else {\n-                builder.append(\"    \/\/ Alignment unknown -> disable IR rule.\\n\");\n-                r2.disable();\n-            }\n+                if (maxVectorWidth < minVectorWidth) {\n+                    builder.append(\"    \/\/ maxVectorWidth < minVectorWidth -> expect no vectorization.\\n\");\n+                    r1.setNegative();\n+                } else if (maxVectorWidth < infinity) {\n+                    r1.setSize(\"min(\" + (maxVectorWidth \/ type.size) + \",max_\" + type.name + \")\");\n+                }\n+                r1.generate(builder);\n+\n+                \/\/ Rule 2: strict alignment: -XX:+AlignVector\n+                IRRule r2 = new IRRule(type, type.irNode, applyIfCPUFeature);\n+                r2.addApplyIf(\"\\\"AlignVector\\\", \\\"true\\\"\");\n+                r2.addApplyIf(\"\\\"MaxVectorSize\\\", \\\">=\" + minVectorWidth + \"\\\"\");\n+\n+                \/\/ All vectors must be aligned by some alignment width aw:\n+                \/\/   aw = min(actualVectorWidth, ObjectAlignmentInBytes)\n+                \/\/ The runtime aw must thus lay between these two values:\n+                \/\/   awMin <= aw <= awMax\n+                int awMin = Math.min(minVectorWidth, 8);\n+                int awMax = 8;\n+\n+                \/\/ We must align both the load and the store, thus we must also be able to align\n+                \/\/ for the difference of the two, i.e. byteOffset must be a multiple of aw:\n+                \/\/   byteOffset % aw == 0\n+                \/\/ We don't know the aw, only awMin and awMax. But:\n+                \/\/   byteOffset % awMax == 0      ->      byteOffset % aw == 0\n+                \/\/   byteOffset % awMin != 0      ->      byteOffset % aw != 0\n+                builder.append(\"    \/\/ awMin = \" + awMin + \" = min(minVectorWidth, 8)\\n\");\n+                builder.append(\"    \/\/ awMax = \" + awMax + \"\\n\");\n+\n+                if (byteOffset % awMax == 0) {\n+                    builder.append(\"    \/\/ byteOffset % awMax == 0   -> always trivially aligned\\n\");\n+                } else if (byteOffset % awMin != 0) {\n+                    builder.append(\"    \/\/ byteOffset % awMin != 0   -> can never align -> expect no vectorization.\\n\");\n+                    r2.setNegative();\n+                } else {\n+                    builder.append(\"    \/\/ Alignment unknown -> disable IR rule.\\n\");\n+                    r2.disable();\n+                }\n@@ -776,5 +800,7 @@\n-            if (maxVectorWidth < minVectorWidth) {\n-                builder.append(\"    \/\/ Not at least 2 elements or 4 bytes -> expect no vectorization.\\n\");\n-                r2.setNegative();\n-            } else if (maxVectorWidth < infinity) {\n-                r2.setSize(\"min(\" + (maxVectorWidth \/ type.size) + \",max_\" + type.name + \")\");\n+                if (maxVectorWidth < minVectorWidth) {\n+                    builder.append(\"    \/\/ Not at least 2 elements or 4 bytes -> expect no vectorization.\\n\");\n+                    r2.setNegative();\n+                } else if (maxVectorWidth < infinity) {\n+                    r2.setSize(\"min(\" + (maxVectorWidth \/ type.size) + \",max_\" + type.name + \")\");\n+                }\n+                r2.generate(builder);\n@@ -782,2 +808,0 @@\n-            r2.generate(builder);\n-\n@@ -805,0 +829,1 @@\n+        String applyIfCPUFeature;\n@@ -810,1 +835,1 @@\n-        IRRule(Type type, String irNode) {\n+        IRRule(Type type, String irNode, String applyIfCPUFeature) {\n@@ -813,0 +838,1 @@\n+            this.applyIfCPUFeature = applyIfCPUFeature;\n@@ -851,1 +877,1 @@\n-                builder.append(\"        applyIfCPUFeatureOr = {\\\"sse4.1\\\", \\\"true\\\", \\\"asimd\\\", \\\"true\\\"})\\n\");\n+                builder.append(applyIfCPUFeature);\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestDependencyOffsets.java","additions":101,"deletions":75,"binary":false,"changes":176,"status":"modified"}]}