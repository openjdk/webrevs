{"files":[{"patch":"@@ -1875,1 +1875,1 @@\n-  return java_thread->obj_field(_park_blocker_offset);\n+  return java_thread->obj_field_access<MO_RELAXED>(_park_blocker_offset);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -745,0 +745,6 @@\n+  template(jdk_internal_vm_ThreadSnapshot,         \"jdk\/internal\/vm\/ThreadSnapshot\")                              \\\n+  template(jdk_internal_vm_ThreadLock,             \"jdk\/internal\/vm\/ThreadSnapshot$ThreadLock\")                   \\\n+  template(jdk_internal_vm_ThreadLock_signature,   \"Ljdk\/internal\/vm\/ThreadSnapshot$ThreadLock;\")                 \\\n+  template(jdk_internal_vm_ThreadLock_array,       \"[Ljdk\/internal\/vm\/ThreadSnapshot$ThreadLock;\")                \\\n+  template(java_lang_StackTraceElement_of_name,    \"of\")                                                          \\\n+  template(java_lang_StackTraceElement_of_signature, \"([Ljava\/lang\/StackTraceElement;)[Ljava\/lang\/StackTraceElement;\") \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -304,0 +304,3 @@\n+JNIEXPORT jobject JNICALL\n+JVM_CreateThreadSnapshot(JNIEnv* env, jobject thread);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2964,0 +2964,9 @@\n+JVM_ENTRY(jobject, JVM_CreateThreadSnapshot(JNIEnv* env, jobject jthread))\n+#if INCLUDE_JVMTI\n+  oop snapshot = VMThreadSnapshot::get_thread_snapshot(jthread, THREAD);\n+  return JNIHandles::make_local(THREAD, snapshot);\n+#else\n+  return nullptr;\n+#endif\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-class JvmtiVTMSTransitionDisabler {\n+class JvmtiVTMSTransitionDisabler : public AnyObj {\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -130,0 +130,1 @@\n+#if INCLUDE_JVMTI\n@@ -131,0 +132,1 @@\n+#endif \/\/ INCLUDE_JVMTI\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"oops\/method.inline.hpp\"\n@@ -42,0 +43,1 @@\n+#include \"prims\/jvmtiThreadState.hpp\"\n@@ -45,0 +47,1 @@\n+#include \"runtime\/javaCalls.hpp\"\n@@ -46,0 +49,1 @@\n+#include \"runtime\/jniHandles.inline.hpp\"\n@@ -47,1 +51,1 @@\n-#include \"runtime\/synchronizer.hpp\"\n+#include \"runtime\/synchronizer.inline.hpp\"\n@@ -51,1 +55,1 @@\n-#include \"runtime\/vframe.hpp\"\n+#include \"runtime\/vframe.inline.hpp\"\n@@ -1118,0 +1122,427 @@\n+\n+\n+\/\/ jdk.internal.vm.ThreadSnapshot support\n+#if INCLUDE_JVMTI\n+\n+class GetThreadSnapshotClosure: public HandshakeClosure {\n+private:\n+  static OopStorage* oop_storage() {\n+    assert(_thread_service_storage != nullptr, \"sanity\");\n+    return _thread_service_storage;\n+  }\n+\n+public:\n+  struct OwnedLock {\n+    \/\/ should be synced with ordinals of jdk.internal.vm.ThreadSnapshot.OwnedLockType enum\n+    enum Type {\n+      NOTHING = -1,\n+      LOCKED = 0,\n+      ELIMINATED = 1,\n+    };\n+\n+    int _depth;\n+    Type _type;\n+    \/\/ synchronization object (when type == LOCKED) ot its klass (type == ELIMINATED)\n+    OopHandle _obj;\n+\n+    OwnedLock(int depth, Type type, OopHandle obj): _depth(depth), _type(type), _obj(obj) {}\n+    OwnedLock(): _depth(0), _type(NOTHING), _obj(nullptr) {}\n+  };\n+\n+  struct Blocker {\n+    \/\/ should be synced with ordinals of jdk.internal.vm.ThreadSnapshot.BlockerLockType enum\n+    enum Type {\n+      NOTHING = -1,\n+      PARK_BLOCKER = 0,\n+      WAITING_TO_LOCK = 1,\n+      WAITING_ON = 2,\n+    };\n+\n+    Type _type;\n+    OopHandle _obj;\n+\n+    Blocker(Type type, OopHandle obj): _type(type), _obj(obj) {}\n+    Blocker(): _type(NOTHING), _obj(nullptr) {}\n+\n+    bool is_empty() const {\n+      return _type == NOTHING;\n+    }\n+  };\n+\n+  Handle _thread_h;\n+  JavaThread* _java_thread;\n+  int _stack_depth; \/\/ length of _methods and _bcis arrays\n+  GrowableArray<Method*>* _methods;\n+  GrowableArray<int>* _bcis;\n+  JavaThreadStatus _thread_status;\n+  OopHandle _name;\n+  GrowableArray<OwnedLock>* _locks;\n+  Blocker _blocker;\n+\n+  GetThreadSnapshotClosure(Handle thread_h, JavaThread* java_thread):\n+    HandshakeClosure(\"GetThreadSnapshotClosure\"),\n+    _thread_h(thread_h), _java_thread(java_thread),\n+    _stack_depth(0), _methods(nullptr), _bcis(nullptr),\n+    _thread_status(), _name(nullptr),\n+    _locks(nullptr), _blocker() {\n+  }\n+  virtual ~GetThreadSnapshotClosure() {\n+    delete _methods;\n+    delete _bcis;\n+    _name.release(oop_storage());\n+    if (_locks != nullptr) {\n+      for (int i = 0; i < _locks->length(); i++) {\n+        _locks->at(i)._obj.release(oop_storage());\n+      }\n+      delete _locks;\n+    }\n+    _blocker._obj.release(oop_storage());\n+  }\n+\n+private:\n+  void detect_locks(javaVFrame* jvf, int depth) {\n+    Thread* current = Thread::current();\n+\n+    if (depth == 0 && _blocker.is_empty()) {\n+      \/\/ If this is the first frame and it is java.lang.Object.wait(...)\n+      \/\/ then print out the receiver.\n+      if (jvf->method()->name() == vmSymbols::wait_name() &&\n+        jvf->method()->method_holder()->name() == vmSymbols::java_lang_Object()) {\n+        OopHandle lock_object;\n+        StackValueCollection* locs = jvf->locals();\n+        if (!locs->is_empty()) {\n+          StackValue* sv = locs->at(0);\n+          if (sv->type() == T_OBJECT) {\n+            Handle o = locs->at(0)->get_obj();\n+            lock_object = OopHandle(oop_storage(), o());\n+          }\n+        }\n+        _blocker = Blocker(Blocker::WAITING_ON, lock_object);\n+      }\n+    }\n+\n+    GrowableArray<MonitorInfo*>* mons = jvf->monitors();\n+    if (!mons->is_empty()) {\n+      for (int index = (mons->length() - 1); index >= 0; index--) {\n+        MonitorInfo* monitor = mons->at(index);\n+        if (monitor->eliminated() && jvf->is_compiled_frame()) { \/\/ Eliminated in compiled code\n+          if (monitor->owner_is_scalar_replaced()) {\n+            Klass* k = java_lang_Class::as_Klass(monitor->owner_klass());\n+            _locks->push(OwnedLock(depth, OwnedLock::ELIMINATED, OopHandle(oop_storage(), k->klass_holder())));\n+          } else {\n+            Handle owner(current, monitor->owner());\n+            if (owner.not_null()) {\n+              Klass* k = owner->klass();\n+              _locks->push(OwnedLock(depth, OwnedLock::ELIMINATED, OopHandle(oop_storage(), k->klass_holder())));\n+            }\n+          }\n+          continue;\n+        }\n+        if (monitor->owner() != nullptr) {\n+          \/\/ the monitor is associated with an object, i.e., it is locked\n+\n+          if (depth == 0 && _blocker.is_empty()) {\n+            ObjectMonitor* pending_moninor = java_lang_VirtualThread::is_instance(_thread_h())\n+              ? java_lang_VirtualThread::current_pending_monitor(_thread_h())\n+              : jvf->thread()->current_pending_monitor();\n+\n+            markWord mark = monitor->owner()->mark();\n+            \/\/ The first stage of async deflation does not affect any field\n+            \/\/ used by this comparison so the ObjectMonitor* is usable here.\n+            if (mark.has_monitor()) {\n+              ObjectMonitor* mon = ObjectSynchronizer::read_monitor(current, monitor->owner(), mark);\n+              if (\/\/ if the monitor is null we must be in the process of locking\n+                  mon == nullptr ||\n+                  \/\/ we have marked ourself as pending on this monitor\n+                  mon == pending_moninor ||\n+                  \/\/ we are not the owner of this monitor\n+                  (_java_thread != nullptr && !mon->is_entered(_java_thread))) {\n+                _blocker = Blocker(Blocker::WAITING_TO_LOCK, OopHandle(oop_storage(), monitor->owner()));\n+                continue; \/\/ go to next monitor\n+              }\n+            }\n+          }\n+          _locks->push(OwnedLock(depth, OwnedLock::LOCKED, OopHandle(oop_storage(), monitor->owner())));\n+        }\n+      }\n+    }\n+  }\n+\n+public:\n+  void do_thread(Thread* th) override {\n+    Thread* current = Thread::current();\n+\n+    bool is_virtual = java_lang_VirtualThread::is_instance(_thread_h());\n+    if (_java_thread != nullptr) {\n+      if (is_virtual) {\n+        \/\/ mounted vthread, use carrier thread state\n+        oop carrier_thread = java_lang_VirtualThread::carrier_thread(_thread_h());\n+        _thread_status = java_lang_Thread::get_thread_status(carrier_thread);\n+      } else {\n+        _thread_status = java_lang_Thread::get_thread_status(_thread_h());\n+      }\n+    } else {\n+      \/\/ unmounted vthread\n+      int vt_state = java_lang_VirtualThread::state(_thread_h());\n+      _thread_status = java_lang_VirtualThread::map_state_to_thread_status(vt_state);\n+    }\n+    _name = OopHandle(oop_storage(), java_lang_Thread::name(_thread_h()));\n+\n+    if (_java_thread != nullptr && !_java_thread->has_last_Java_frame()) {\n+      \/\/ stack trace is empty\n+      return;\n+    }\n+\n+    bool walk_cont = (_java_thread != nullptr) && (_java_thread->vthread_continuation() != nullptr);\n+\n+    oop park_blocker = java_lang_Thread::park_blocker(_thread_h());\n+    if (park_blocker != nullptr) {\n+      _blocker = Blocker(Blocker::PARK_BLOCKER, OopHandle(oop_storage(), park_blocker));\n+    }\n+\n+    ResourceMark rm(current);\n+    HandleMark hm(current);\n+\n+    const int max_depth = MaxJavaStackTraceDepth;\n+    const bool skip_hidden = !ShowHiddenFrames;\n+\n+    \/\/ Pick minimum length that will cover most cases\n+    int init_length = 64;\n+    _methods = new (mtInternal) GrowableArray<Method*>(init_length, mtInternal);\n+    _bcis = new (mtInternal) GrowableArray<int>(init_length, mtInternal);\n+    _locks = new (mtInternal) GrowableArray<OwnedLock>(init_length, mtInternal);\n+    int total_count = 0;\n+\n+    vframeStream vfst(_java_thread != nullptr\n+      ? vframeStream(_java_thread, false, true, walk_cont)\n+      : vframeStream(java_lang_VirtualThread::continuation(_thread_h())));\n+\n+    for (;\n+      !vfst.at_end() && (max_depth == 0 || max_depth != total_count);\n+      vfst.next()) {\n+\n+      detect_locks(vfst.asJavaVFrame(), total_count);\n+\n+      if (skip_hidden && (vfst.method()->is_hidden() ||\n+        vfst.method()->is_continuation_enter_intrinsic())) {\n+        continue;\n+      }\n+      _methods->push(vfst.method());\n+      _bcis->push(vfst.bci());\n+      total_count++;\n+    }\n+\n+    _stack_depth = total_count;\n+  }\n+};\n+\n+class jdk_internal_vm_ThreadLock: AllStatic {\n+  static bool _inited;\n+  static int _depth_offset;\n+  static int _typeOrdinal_offset;\n+  static int _obj_offset;\n+\n+  static void compute_offsets(InstanceKlass* klass, TRAPS) {\n+    JavaClasses::compute_offset(_depth_offset, klass, \"depth\", vmSymbols::int_signature(), false);\n+    JavaClasses::compute_offset(_typeOrdinal_offset, klass, \"typeOrdinal\", vmSymbols::int_signature(), false);\n+    JavaClasses::compute_offset(_obj_offset, klass, \"obj\", vmSymbols::object_signature(), false);\n+  }\n+public:\n+  static void init(InstanceKlass* klass, TRAPS) {\n+    if (!_inited) {\n+      compute_offsets(klass, CHECK);\n+      _inited = true;\n+    }\n+  }\n+\n+  static Handle create(InstanceKlass* klass, int depth, int type_ordinal, OopHandle obj, TRAPS) {\n+    init(klass, CHECK_NH);\n+    Handle result = klass->allocate_instance_handle(CHECK_NH);\n+    result->int_field_put(_depth_offset, depth);\n+    result->int_field_put(_typeOrdinal_offset, type_ordinal);\n+    result->obj_field_put(_obj_offset, obj.resolve());\n+    return result;\n+  }\n+};\n+\n+bool jdk_internal_vm_ThreadLock::_inited = false;\n+int jdk_internal_vm_ThreadLock::_depth_offset;\n+int jdk_internal_vm_ThreadLock::_typeOrdinal_offset;\n+int jdk_internal_vm_ThreadLock::_obj_offset;\n+\n+class jdk_internal_vm_ThreadSnapshot: AllStatic {\n+  static bool _inited;\n+  static int _name_offset;\n+  static int _threadStatus_offset;\n+  static int _carrierThread_offset;\n+  static int _stackTrace_offset;\n+  static int _locks_offset;\n+  static int _blockerTypeOrdinal_offset;\n+  static int _blockerObject_offset;\n+\n+  static void compute_offsets(InstanceKlass* klass, TRAPS) {\n+    JavaClasses::compute_offset(_name_offset, klass, \"name\", vmSymbols::string_signature(), false);\n+    JavaClasses::compute_offset(_threadStatus_offset, klass, \"threadStatus\", vmSymbols::int_signature(), false);\n+    JavaClasses::compute_offset(_carrierThread_offset, klass, \"carrierThread\", vmSymbols::thread_signature(), false);\n+    JavaClasses::compute_offset(_stackTrace_offset, klass, \"stackTrace\", vmSymbols::java_lang_StackTraceElement_array(), false);\n+    JavaClasses::compute_offset(_locks_offset, klass, \"locks\", vmSymbols::jdk_internal_vm_ThreadLock_array(), false);\n+    JavaClasses::compute_offset(_blockerTypeOrdinal_offset, klass, \"blockerTypeOrdinal\", vmSymbols::int_signature(), false);\n+    JavaClasses::compute_offset(_blockerObject_offset, klass, \"blockerObject\", vmSymbols::object_signature(), false);\n+  }\n+public:\n+  static void init(InstanceKlass* klass, TRAPS) {\n+    if (!_inited) {\n+      compute_offsets(klass, CHECK);\n+      _inited = true;\n+    }\n+  }\n+\n+  static Handle allocate(InstanceKlass* klass, TRAPS) {\n+    init(klass, CHECK_NH);\n+    Handle h_k = klass->allocate_instance_handle(CHECK_NH);\n+    return h_k;\n+  }\n+\n+  static void set_name(oop snapshot, oop name) {\n+    snapshot->obj_field_put(_name_offset, name);\n+  }\n+  static void set_thread_status(oop snapshot, int status) {\n+    snapshot->int_field_put(_threadStatus_offset, status);\n+  }\n+  static void set_carrier_thread(oop snapshot, oop carrier_thread) {\n+    snapshot->obj_field_put(_carrierThread_offset, carrier_thread);\n+  }\n+  static void set_stack_trace(oop snapshot, oop trace) {\n+    snapshot->obj_field_put(_stackTrace_offset, trace);\n+  }\n+  static void set_locks(oop snapshot, oop locks) {\n+    snapshot->obj_field_put(_locks_offset, locks);\n+  }\n+  static void set_blocker(oop snapshot, int type_ordinal, oop lock) {\n+    snapshot->int_field_put(_blockerTypeOrdinal_offset, type_ordinal);\n+    snapshot->obj_field_put(_blockerObject_offset, lock);\n+  }\n+};\n+\n+bool jdk_internal_vm_ThreadSnapshot::_inited = false;\n+int jdk_internal_vm_ThreadSnapshot::_name_offset;\n+int jdk_internal_vm_ThreadSnapshot::_threadStatus_offset;\n+int jdk_internal_vm_ThreadSnapshot::_carrierThread_offset;\n+int jdk_internal_vm_ThreadSnapshot::_stackTrace_offset;\n+int jdk_internal_vm_ThreadSnapshot::_locks_offset;\n+int jdk_internal_vm_ThreadSnapshot::_blockerTypeOrdinal_offset;\n+int jdk_internal_vm_ThreadSnapshot::_blockerObject_offset;\n+\n+oop VMThreadSnapshot::get_thread_snapshot(jobject jthread, TRAPS) {\n+  ThreadsListHandle tlh(THREAD);\n+\n+  ResourceMark rm(THREAD);\n+  HandleMark   hm(THREAD);\n+  Handle thread_h(THREAD, JNIHandles::resolve(jthread));\n+\n+  \/\/ wrapper to auto delete JvmtiVTMSTransitionDisabler\n+  class TransitionDisabler {\n+    JvmtiVTMSTransitionDisabler* _transition_disabler;\n+  public:\n+    TransitionDisabler(): _transition_disabler(nullptr) {}\n+    ~TransitionDisabler() {\n+      reset();\n+    }\n+    void init(jobject jthread) {\n+      _transition_disabler = new (mtInternal) JvmtiVTMSTransitionDisabler(jthread);\n+    }\n+    void reset() {\n+      if (_transition_disabler != nullptr) {\n+        delete _transition_disabler;\n+        _transition_disabler = nullptr;\n+      }\n+    }\n+  } transition_disabler;\n+\n+  JavaThread* java_thread = nullptr;\n+  bool is_virtual = java_lang_VirtualThread::is_instance(thread_h());\n+  Handle carrier_thread;\n+  if (is_virtual) {\n+    \/\/ 1st need to disable mount\/unmount transitions\n+    transition_disabler.init(jthread);\n+\n+    carrier_thread = Handle(THREAD, java_lang_VirtualThread::carrier_thread(thread_h()));\n+    if (carrier_thread != nullptr) {\n+      java_thread = java_lang_Thread::thread(carrier_thread());\n+    }\n+  } else {\n+    java_thread = java_lang_Thread::thread(thread_h());\n+  }\n+\n+  \/\/ Handshake with target\n+  GetThreadSnapshotClosure cl(thread_h, java_thread);\n+  if (java_thread == nullptr) {\n+    \/\/ unmounted vthread, execute on the current thread\n+    cl.do_thread(nullptr);\n+  } else {\n+    Handshake::execute(&cl, &tlh, java_thread);\n+  }\n+\n+  \/\/ all info is collected, can enable transitions.\n+  transition_disabler.reset();\n+\n+  \/\/ StackTrace\n+  InstanceKlass* ste_klass = vmClasses::StackTraceElement_klass();\n+  assert(ste_klass != nullptr, \"must be loaded\");\n+\n+  objArrayHandle trace = oopFactory::new_objArray_handle(ste_klass, cl._stack_depth, CHECK_NULL);\n+\n+  for (int i = 0; i < cl._stack_depth; i++) {\n+    methodHandle method(THREAD, cl._methods->at(i));\n+    oop element = java_lang_StackTraceElement::create(method, cl._bcis->at(i), CHECK_NULL);\n+    trace->obj_at_put(i, element);\n+  }\n+\n+  \/\/ Locks\n+  Symbol* lock_sym = vmSymbols::jdk_internal_vm_ThreadLock();\n+  Klass* lock_k = SystemDictionary::resolve_or_fail(lock_sym, true, CHECK_NULL);\n+  InstanceKlass* lock_klass = InstanceKlass::cast(lock_k);\n+\n+  objArrayHandle locks;\n+  if (cl._locks != nullptr && cl._locks->length() > 0) {\n+    locks = oopFactory::new_objArray_handle(lock_klass, cl._locks->length(), CHECK_NULL);\n+    for (int n = 0; n < cl._locks->length(); n++) {\n+      GetThreadSnapshotClosure::OwnedLock* lock_info = cl._locks->adr_at(n);\n+\n+      Handle lock = jdk_internal_vm_ThreadLock::create(lock_klass,\n+        lock_info->_depth, lock_info->_type, lock_info->_obj, CHECK_NULL);\n+      locks->obj_at_put(n, lock());\n+    }\n+  }\n+\n+  \/\/ call static StackTraceElement[] StackTraceElement.of(StackTraceElement[] stackTrace)\n+  \/\/ to properly initialize STEs.\n+  JavaValue result(T_OBJECT);\n+  JavaCalls::call_static(&result,\n+    ste_klass,\n+    vmSymbols::java_lang_StackTraceElement_of_name(),\n+    vmSymbols::java_lang_StackTraceElement_of_signature(),\n+    trace,\n+    CHECK_NULL);\n+  \/\/ the method return the same trace array\n+\n+  Symbol* snapshot_klass_name = vmSymbols::jdk_internal_vm_ThreadSnapshot();\n+  Klass* snapshot_klass = SystemDictionary::resolve_or_fail(snapshot_klass_name, true, CHECK_NULL);\n+  if (snapshot_klass->should_be_initialized()) {\n+    snapshot_klass->initialize(CHECK_NULL);\n+  }\n+\n+  Handle snapshot = jdk_internal_vm_ThreadSnapshot::allocate(InstanceKlass::cast(snapshot_klass), CHECK_NULL);\n+  jdk_internal_vm_ThreadSnapshot::set_name(snapshot(), cl._name.resolve());\n+  jdk_internal_vm_ThreadSnapshot::set_thread_status(snapshot(), (int)cl._thread_status);\n+  jdk_internal_vm_ThreadSnapshot::set_carrier_thread(snapshot(), carrier_thread());\n+  jdk_internal_vm_ThreadSnapshot::set_stack_trace(snapshot(), trace());\n+  jdk_internal_vm_ThreadSnapshot::set_locks(snapshot(), locks());\n+  if (!cl._blocker.is_empty()) {\n+    jdk_internal_vm_ThreadSnapshot::set_blocker(snapshot(), cl._blocker._type, cl._blocker._obj.resolve());\n+  }\n+  return snapshot();\n+}\n+\n+#endif \/\/ INCLUDE_JVMTI\n+\n","filename":"src\/hotspot\/share\/services\/threadService.cpp","additions":433,"deletions":2,"binary":false,"changes":435,"status":"modified"},{"patch":"@@ -634,0 +634,7 @@\n+\n+\/\/ jdk.internal.vm.ThreadSnapshot support\n+class VMThreadSnapshot: AllStatic {\n+public:\n+  JVMTI_ONLY(static oop get_thread_snapshot(jobject jthread, TRAPS);)\n+};\n+\n","filename":"src\/hotspot\/share\/services\/threadService.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,217 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.vm;\n+\n+import java.util.Arrays;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Represents a snapshot of information about a Thread.\n+ *\/\n+class ThreadSnapshot {\n+    private static final StackTraceElement[] EMPTY_STACK = new StackTraceElement[0];\n+    private static final ThreadLock[] EMPTY_LOCKS = new ThreadLock[0];\n+\n+    \/\/ filled by VM\n+    private String name;\n+    private int threadStatus;\n+    private Thread carrierThread;\n+    private StackTraceElement[] stackTrace;\n+    \/\/ owned monitors\n+    private ThreadLock[] locks;\n+    \/\/ an object the thread is blocked\/waiting on, converted to ThreadBlocker by ThreadSnapshot.of()\n+    private int blockerTypeOrdinal;\n+    private Object blockerObject;\n+\n+    \/\/ set by ThreadSnapshot.of()\n+    private ThreadBlocker blocker;\n+\n+    private ThreadSnapshot() {}\n+\n+    \/**\n+     * Take a snapshot of a Thread to get all information about the thread.\n+     *\/\n+    static ThreadSnapshot of(Thread thread) {\n+        ThreadSnapshot snapshot = create(thread);\n+        if (snapshot.stackTrace == null) {\n+            snapshot.stackTrace = EMPTY_STACK;\n+        }\n+        if (snapshot.locks != null) {\n+            Arrays.stream(snapshot.locks).forEach(ThreadLock::finishInit);\n+        } else {\n+            snapshot.locks = EMPTY_LOCKS;\n+        }\n+        if (snapshot.blockerObject != null) {\n+            snapshot.blocker = new ThreadBlocker(snapshot.blockerTypeOrdinal, snapshot.blockerObject);\n+            snapshot.blockerObject = null; \/\/ release\n+        }\n+        return snapshot;\n+    }\n+\n+    \/**\n+     * Returns the thread name.\n+     *\/\n+    String threadName() {\n+        return name;\n+    }\n+\n+    \/**\n+     * Returns the thread state.\n+     *\/\n+    Thread.State threadState() {\n+        return jdk.internal.misc.VM.toThreadState(threadStatus);\n+    }\n+\n+    \/**\n+     * Returns the thread stack trace.\n+     *\/\n+    StackTraceElement[] stackTrace() {\n+        return stackTrace;\n+    }\n+\n+    \/**\n+     * Returns the thread's parkBlocker.\n+     *\/\n+    Object parkBlocker() {\n+        return getBlocker(BlockerLockType.PARK_BLOCKER);\n+    }\n+\n+    \/**\n+     * Returns the object that the thread is blocked on.\n+     * @throws IllegalStateException if not in the blocked state\n+     *\/\n+    Object blockedOn() {\n+        if (threadState() != Thread.State.BLOCKED) {\n+            throw new IllegalStateException();\n+        }\n+        return getBlocker(BlockerLockType.WAITING_TO_LOCK);\n+    }\n+\n+    \/**\n+     * Returns the object that the thread is waiting on.\n+     * @throws IllegalStateException if not in the waiting state\n+     *\/\n+    Object waitingOn() {\n+        if (threadState() != Thread.State.WAITING\n+                && threadState() != Thread.State.TIMED_WAITING) {\n+            throw new IllegalStateException();\n+        }\n+        return getBlocker(BlockerLockType.WAITING_ON);\n+    }\n+\n+    private Object getBlocker(BlockerLockType type) {\n+        return (blocker != null && blocker.type == type) ? blocker.obj : null;\n+    }\n+\n+    \/**\n+     * Returns true if the thread owns any object monitors.\n+     *\/\n+    boolean ownsMonitors() {\n+        return locks.length > 0;\n+    }\n+\n+    \/**\n+     * Returns the objects that the thread locked at the given depth. The stream\n+     * will contain a null element for a monitor that has been eliminated.\n+     *\/\n+    Stream<Object> ownedMonitorsAt(int depth) {\n+        return Arrays.stream(locks)\n+                .filter(lock -> lock.depth() == depth)\n+                .map(lock -> (lock.type == OwnedLockType.LOCKED)\n+                        ? lock.lockObject()\n+                        : \/*eliminated*\/ null);\n+    }\n+\n+    \/**\n+     * If the thread is a mounted virtual thread then return its carrier.\n+     *\/\n+    Thread carrierThread() {\n+        return carrierThread;\n+    }\n+\n+    \/**\n+     * Represents information about a locking operation.\n+     *\/\n+    private enum OwnedLockType {\n+        LOCKED,\n+        \/\/ Lock object is a class of the eliminated monitor\n+        ELIMINATED,\n+    }\n+\n+    private enum BlockerLockType {\n+        \/\/ Park blocker\n+        PARK_BLOCKER,\n+        WAITING_TO_LOCK,\n+        \/\/ Object.wait()\n+        WAITING_ON,\n+    }\n+\n+    \/**\n+     * Represents a locking operation of a thread at a specific stack depth.\n+     *\/\n+    private class ThreadLock {\n+        private static final OwnedLockType[] lockTypeValues = OwnedLockType.values(); \/\/ cache\n+\n+        \/\/ set by the VM\n+        private int depth;\n+        private int typeOrdinal;\n+        private Object obj;\n+\n+        \/\/ set by ThreadLock.of()\n+        private OwnedLockType type;\n+\n+        private ThreadLock() {}\n+\n+        void finishInit() {\n+            type = lockTypeValues[typeOrdinal];\n+        }\n+\n+        int depth() {\n+            return depth;\n+        }\n+\n+        OwnedLockType type() {\n+            return type;\n+        }\n+\n+        Object lockObject() {\n+            if (type == OwnedLockType.ELIMINATED) {\n+                \/\/ we have no lock object, lock contains lock class\n+                return null;\n+            }\n+            return obj;\n+        }\n+    }\n+\n+    private record ThreadBlocker(BlockerLockType type, Object obj) {\n+        private static final BlockerLockType[] lockTypeValues = BlockerLockType.values(); \/\/ cache\n+\n+        ThreadBlocker(int typeOrdinal, Object obj) {\n+            this(lockTypeValues[typeOrdinal], obj);\n+        }\n+    }\n+\n+    private static native ThreadSnapshot create(Thread thread);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ThreadSnapshot.java","additions":217,"deletions":0,"binary":false,"changes":217,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include \"jvm.h\"\n+\n+#include \"jdk_internal_vm_ThreadSnapshot.h\"\n+\n+\n+JNIEXPORT jobject JNICALL\n+Java_jdk_internal_vm_ThreadSnapshot_create(JNIEnv *env, jclass cls, jobject thread)\n+{\n+  return JVM_CreateThreadSnapshot(env, thread);\n+}\n","filename":"src\/java.base\/share\/native\/libjava\/ThreadSnapshot.c","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"}]}