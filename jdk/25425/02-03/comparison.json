{"files":[{"patch":"@@ -1875,1 +1875,1 @@\n-  return java_thread->obj_field_acquire(_park_blocker_offset);\n+  return java_thread->obj_field_access<MO_RELAXED>(_park_blocker_offset);\n@@ -5059,1 +5059,1 @@\n-  return obj->obj_field_acquire(_owner_offset);\n+  return obj->obj_field(_owner_offset);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2968,1 +2968,1 @@\n-#elif\n+#else\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"oops\/method.inline.hpp\"\n@@ -1144,0 +1145,1 @@\n+    \/\/ synchronization object (when type == LOCKED) ot its klass (type == ELIMINATED)\n@@ -1170,4 +1172,3 @@\n-  Handle _java_thread;\n-  JavaThread* _thread;\n-  int _depth;\n-  bool _retry_handshake;\n+  Handle _thread_h;\n+  JavaThread* _java_thread;\n+  int _stack_depth; \/\/ length of _methods and _bcis arrays\n@@ -1180,1 +1181,0 @@\n-  OopHandle _blocker_owner;\n@@ -1182,1 +1182,1 @@\n-  GetThreadSnapshotClosure(JavaThread* calling_thread, Handle java_thread, JavaThread* thread):\n+  GetThreadSnapshotClosure(Handle thread_h, JavaThread* java_thread):\n@@ -1184,3 +1184,2 @@\n-    _java_thread(java_thread), _thread(thread),\n-    _depth(0), _retry_handshake(false),\n-    _methods(nullptr), _bcis(nullptr),\n+    _thread_h(thread_h), _java_thread(java_thread),\n+    _stack_depth(0), _methods(nullptr), _bcis(nullptr),\n@@ -1188,1 +1187,2 @@\n-    _locks(nullptr), _blocker(), _blocker_owner(nullptr) { }\n+    _locks(nullptr), _blocker() {\n+  }\n@@ -1200,9 +1200,0 @@\n-    _blocker_owner.release(oop_storage());\n-  }\n-\n-  bool read_reset_retry() {\n-    bool ret = _retry_handshake;\n-    \/\/ If we re-execute the handshake this method need to return false\n-    \/\/ when the handshake cannot be performed. (E.g. thread terminating)\n-    _retry_handshake = false;\n-    return ret;\n@@ -1229,1 +1220,0 @@\n-\n@@ -1255,2 +1245,2 @@\n-            ObjectMonitor* pending_moninor = java_lang_VirtualThread::is_instance(_java_thread())\n-              ? java_lang_VirtualThread::current_pending_monitor(_java_thread())\n+            ObjectMonitor* pending_moninor = java_lang_VirtualThread::is_instance(_thread_h())\n+              ? java_lang_VirtualThread::current_pending_monitor(_thread_h())\n@@ -1265,5 +1255,5 @@\n-                mon == nullptr ||\n-                \/\/ we have marked ourself as pending on this monitor\n-                mon == pending_moninor ||\n-                \/\/ we are not the owner of this monitor\n-                (_thread != nullptr && !mon->is_entered(_thread))) {\n+                  mon == nullptr ||\n+                  \/\/ we have marked ourself as pending on this monitor\n+                  mon == pending_moninor ||\n+                  \/\/ we are not the owner of this monitor\n+                  (_java_thread != nullptr && !mon->is_entered(_java_thread))) {\n@@ -1284,4 +1274,0 @@\n-    if (!current->is_Java_thread()) {\n-      _retry_handshake = true;\n-      return;\n-    }\n@@ -1289,2 +1275,2 @@\n-    bool is_virtual = java_lang_VirtualThread::is_instance(_java_thread());\n-    if (_thread != nullptr) {\n+    bool is_virtual = java_lang_VirtualThread::is_instance(_thread_h());\n+    if (_java_thread != nullptr) {\n@@ -1293,1 +1279,1 @@\n-        oop carrier_thread = java_lang_VirtualThread::carrier_thread(_java_thread());\n+        oop carrier_thread = java_lang_VirtualThread::carrier_thread(_thread_h());\n@@ -1296,1 +1282,1 @@\n-        _thread_status = java_lang_Thread::get_thread_status(_java_thread());\n+        _thread_status = java_lang_Thread::get_thread_status(_thread_h());\n@@ -1300,1 +1286,1 @@\n-      int vt_state = java_lang_VirtualThread::state(_java_thread());\n+      int vt_state = java_lang_VirtualThread::state(_thread_h());\n@@ -1303,1 +1289,1 @@\n-    _name = OopHandle(oop_storage(), java_lang_Thread::name(_java_thread()));\n+    _name = OopHandle(oop_storage(), java_lang_Thread::name(_thread_h()));\n@@ -1305,1 +1291,1 @@\n-    if (_thread != nullptr && !_thread->has_last_Java_frame()) {\n+    if (_java_thread != nullptr && !_java_thread->has_last_Java_frame()) {\n@@ -1310,1 +1296,1 @@\n-    bool walk_cont = false;\n+    bool walk_cont = (_java_thread != nullptr) && (_java_thread->vthread_continuation() != nullptr);\n@@ -1312,13 +1298,1 @@\n-    if (is_virtual) {\n-      if (_thread != nullptr) {\n-        \/\/ if (thread->vthread() != _java_thread()) \/\/ We might be inside a System.executeOnCarrierThread\n-        const ContinuationEntry* ce = _thread->vthread_continuation();\n-        if (ce == nullptr || ce->cont_oop(_thread) != java_lang_VirtualThread::continuation(_java_thread())) {\n-          \/\/ TODO: handle\n-        }\n-      }\n-    } else {\n-      walk_cont = (_thread->vthread_continuation() != nullptr);\n-    }\n-\n-    oop park_blocker = java_lang_Thread::park_blocker(_java_thread());\n+    oop park_blocker = java_lang_Thread::park_blocker(_thread_h());\n@@ -1327,4 +1301,0 @@\n-      if (park_blocker->is_a(vmClasses::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass())) {\n-        oop blocker_owner = java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(park_blocker);\n-        _blocker_owner = OopHandle(oop_storage(), blocker_owner);\n-      }\n@@ -1346,3 +1316,3 @@\n-    vframeStream vfst(_thread != nullptr\n-      ? vframeStream(_thread, false, true, walk_cont)\n-      : vframeStream(java_lang_VirtualThread::continuation(_java_thread())));\n+    vframeStream vfst(_java_thread != nullptr\n+      ? vframeStream(_java_thread, false, true, walk_cont)\n+      : vframeStream(java_lang_VirtualThread::continuation(_thread_h())));\n@@ -1365,1 +1335,1 @@\n-    _depth = total_count;\n+    _stack_depth = total_count;\n@@ -1412,1 +1382,0 @@\n-  static int _blockerOwner_offset;\n@@ -1422,1 +1391,0 @@\n-    JavaClasses::compute_offset(_blockerOwner_offset, klass, \"blockerOwner\", vmSymbols::object_signature(), false);\n@@ -1434,1 +1402,2 @@\n-    return klass->allocate_instance_handle(CHECK_NH);\n+    Handle h_k = klass->allocate_instance_handle(CHECK_NH);\n+    return h_k;\n@@ -1456,3 +1425,0 @@\n-  static void set_blocker_owner(oop snapshot, oop owner) {\n-    snapshot->obj_field_put(_blockerOwner_offset, owner);\n-  }\n@@ -1469,1 +1435,0 @@\n-int jdk_internal_vm_ThreadSnapshot::_blockerOwner_offset;\n@@ -1476,1 +1441,1 @@\n-  Handle java_thread(THREAD, JNIHandles::resolve(jthread));\n+  Handle thread_h(THREAD, JNIHandles::resolve(jthread));\n@@ -1497,2 +1462,2 @@\n-  JavaThread* thread = nullptr;\n-  bool is_virtual = java_lang_VirtualThread::is_instance(java_thread());\n+  JavaThread* java_thread = nullptr;\n+  bool is_virtual = java_lang_VirtualThread::is_instance(thread_h());\n@@ -1504,1 +1469,1 @@\n-    carrier_thread = Handle(THREAD, java_lang_VirtualThread::carrier_thread(java_thread()));\n+    carrier_thread = Handle(THREAD, java_lang_VirtualThread::carrier_thread(thread_h()));\n@@ -1506,1 +1471,1 @@\n-      thread = java_lang_Thread::thread(carrier_thread());\n+      java_thread = java_lang_Thread::thread(carrier_thread());\n@@ -1509,1 +1474,1 @@\n-    thread = java_lang_Thread::thread(java_thread());\n+    java_thread = java_lang_Thread::thread(thread_h());\n@@ -1513,2 +1478,2 @@\n-  GetThreadSnapshotClosure cl(THREAD, java_thread, thread);\n-  if (thread == nullptr) {\n+  GetThreadSnapshotClosure cl(thread_h, java_thread);\n+  if (java_thread == nullptr) {\n@@ -1518,3 +1483,1 @@\n-    do {\n-      Handshake::execute(&cl, &tlh, thread);\n-    } while (cl.read_reset_retry());\n+    Handshake::execute(&cl, &tlh, java_thread);\n@@ -1528,4 +1491,1 @@\n-  assert(ste_klass != nullptr, \"must be loaded in 1.4+\");\n-  if (ste_klass->should_be_initialized()) {\n-    ste_klass->initialize(CHECK_NULL);\n-  }\n+  assert(ste_klass != nullptr, \"must be loaded\");\n@@ -1533,1 +1493,1 @@\n-  objArrayHandle trace = oopFactory::new_objArray_handle(ste_klass, cl._depth, CHECK_NULL);\n+  objArrayHandle trace = oopFactory::new_objArray_handle(ste_klass, cl._stack_depth, CHECK_NULL);\n@@ -1535,1 +1495,1 @@\n-  for (int i = 0; i < cl._depth; i++) {\n+  for (int i = 0; i < cl._stack_depth; i++) {\n@@ -1559,11 +1519,9 @@\n-  \/\/ to properly initialize STE.\n-  {\n-    JavaValue result(T_OBJECT);\n-    JavaCalls::call_static(&result,\n-      ste_klass,\n-      vmSymbols::java_lang_StackTraceElement_of_name(),\n-      vmSymbols::java_lang_StackTraceElement_of_signature(),\n-      trace,\n-      CHECK_NULL);\n-    \/\/ the method return the same trace object\n-  }\n+  \/\/ to properly initialize STEs.\n+  JavaValue result(T_OBJECT);\n+  JavaCalls::call_static(&result,\n+    ste_klass,\n+    vmSymbols::java_lang_StackTraceElement_of_name(),\n+    vmSymbols::java_lang_StackTraceElement_of_signature(),\n+    trace,\n+    CHECK_NULL);\n+  \/\/ the method return the same trace array\n@@ -1585,1 +1543,0 @@\n-    jdk_internal_vm_ThreadSnapshot::set_blocker_owner(snapshot(), cl._blocker_owner.resolve());\n","filename":"src\/hotspot\/share\/services\/threadService.cpp","additions":53,"deletions":96,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -47,2 +47,0 @@\n-    \/\/ blocker owner (if known)\n-    private Object blockerOwner;\n@@ -103,7 +101,0 @@\n-    \/**\n-     * Returns the owner of exclusive mode synchronizer when the parkBlocker is an AQS.\n-     *\/\n-    Object exclusiveOwnerThread() {\n-        return parkBlocker() != null ? blockerOwner : null;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ThreadSnapshot.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"}]}