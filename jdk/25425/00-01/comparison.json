{"files":[{"patch":"@@ -69,1 +69,0 @@\n-#include \"prims\/jvmtiThreadState.hpp\" \/\/ for JvmtiVTMSTransitionDisabler\n@@ -87,1 +86,0 @@\n-#include \"runtime\/synchronizer.inline.hpp\"\n@@ -1880,237 +1878,0 @@\n-class GetThreadSnapshotClosure : public HandshakeClosure {\n-public:\n-  struct OwnedLock {\n-    \/\/ should be synced with ordinals of jdk.internal.vm.ThreadSnapshot.OwnedLockType enum\n-    enum Type {\n-      NOTHING = -1,\n-      LOCKED = 0,\n-      ELIMINATED = 1,\n-    };\n-\n-    int _depth;\n-    Type _type;\n-    OopHandle _obj;\n-\n-    OwnedLock(int depth, Type type, OopHandle obj): _depth(depth), _type(type), _obj(obj) {}\n-    OwnedLock(): _depth(0), _type(NOTHING), _obj(nullptr) {}\n-  };\n-\n-  struct Blocker {\n-    \/\/ should be synced with ordinals of jdk.internal.vm.ThreadSnapshot.BlockerLockType enum\n-    enum Type {\n-      NOTHING = -1,\n-      PARK_BLOCKER = 0,\n-      WAITING_TO_LOCK = 1,\n-      WAITING_ON = 2,\n-    };\n-\n-    Type _type;\n-    OopHandle _obj;\n-\n-    Blocker(Type type, OopHandle obj): _type(type), _obj(obj) {}\n-    Blocker(): _type(NOTHING), _obj(nullptr) {}\n-\n-    bool is_empty() const {\n-      return _type == NOTHING;\n-    }\n-  };\n-\n-  Handle _java_thread;\n-  JavaThread* _thread;\n-  int _depth;\n-  bool _retry_handshake;\n-  GrowableArray<Method*>* _methods;\n-  GrowableArray<int>* _bcis;\n-  JavaThreadStatus _thread_status;\n-  OopHandle _name;\n-  GrowableArray<OwnedLock>* _locks;\n-  Blocker _blocker;\n-  OopHandle _blocker_owner;\n-\n-  GetThreadSnapshotClosure(JavaThread* calling_thread, Handle java_thread, JavaThread* thread) :\n-      HandshakeClosure(\"GetThreadSnapshotClosure\"),\n-      _java_thread(java_thread), _thread(thread),\n-      _depth(0), _retry_handshake(false),\n-      _methods(nullptr), _bcis(nullptr),\n-      _thread_status(), _name(nullptr),\n-      _locks(nullptr), _blocker(), _blocker_owner(nullptr) { }\n-  virtual ~GetThreadSnapshotClosure() {\n-    delete _methods;\n-    delete _bcis;\n-    _name.release(Universe::vm_global());\n-    if (_locks != nullptr) {\n-      for (int i = 0; i < _locks->length(); i++) {\n-        _locks->at(i)._obj.release(Universe::vm_global());\n-      }\n-      delete _locks;\n-    }\n-    _blocker._obj.release(Universe::vm_global());\n-    _blocker_owner.release(Universe::vm_global());\n-  }\n-\n-  bool read_reset_retry() {\n-    bool ret = _retry_handshake;\n-    \/\/ If we re-execute the handshake this method need to return false\n-    \/\/ when the handshake cannot be performed. (E.g. thread terminating)\n-    _retry_handshake = false;\n-    return ret;\n-  }\n-\n-private:\n-  void detect_locks(javaVFrame* jvf, int depth) {\n-    Thread* current = Thread::current();\n-\n-    if (depth == 0 && _blocker.is_empty()) {\n-      \/\/ If this is the first frame and it is java.lang.Object.wait(...)\n-      \/\/ then print out the receiver.\n-      if (jvf->method()->name() == vmSymbols::wait_name() &&\n-          jvf->method()->method_holder()->name() == vmSymbols::java_lang_Object()) {\n-        OopHandle lock_object;\n-        StackValueCollection* locs = jvf->locals();\n-        if (!locs->is_empty()) {\n-          StackValue* sv = locs->at(0);\n-          if (sv->type() == T_OBJECT) {\n-            Handle o = locs->at(0)->get_obj();\n-            lock_object = OopHandle(Universe::vm_global(), o());\n-          }\n-        }\n-\n-        _blocker = Blocker(Blocker::WAITING_ON, lock_object);\n-      }\n-    }\n-\n-    GrowableArray<MonitorInfo*>* mons = jvf->monitors();\n-    if (!mons->is_empty()) {\n-      for (int index = (mons->length() - 1); index >= 0; index--) {\n-        MonitorInfo* monitor = mons->at(index);\n-        if (monitor->eliminated() && jvf->is_compiled_frame()) { \/\/ Eliminated in compiled code\n-          if (monitor->owner_is_scalar_replaced()) {\n-            Klass* k = java_lang_Class::as_Klass(monitor->owner_klass());\n-            _locks->push(OwnedLock(depth, OwnedLock::ELIMINATED, OopHandle(Universe::vm_global(), k->klass_holder())));\n-          } else {\n-            Handle owner(current, monitor->owner());\n-            if (owner.not_null()) {\n-              Klass* k = owner->klass();\n-              _locks->push(OwnedLock(depth, OwnedLock::ELIMINATED, OopHandle(Universe::vm_global(), k->klass_holder())));\n-            }\n-          }\n-          continue;\n-        }\n-        if (monitor->owner() != nullptr) {\n-          \/\/ the monitor is associated with an object, i.e., it is locked\n-\n-          if (depth == 0 && _blocker.is_empty()) {\n-            ObjectMonitor* pending_moninor = java_lang_VirtualThread::is_instance(_java_thread())\n-                           ? java_lang_VirtualThread::current_pending_monitor(_java_thread())\n-                           : jvf->thread()->current_pending_monitor();\n-\n-            markWord mark = monitor->owner()->mark();\n-            \/\/ The first stage of async deflation does not affect any field\n-            \/\/ used by this comparison so the ObjectMonitor* is usable here.\n-            if (mark.has_monitor()) {\n-              ObjectMonitor* mon = ObjectSynchronizer::read_monitor(current, monitor->owner(), mark);\n-              if (\/\/ if the monitor is null we must be in the process of locking\n-                  mon == nullptr ||\n-                  \/\/ we have marked ourself as pending on this monitor\n-                  mon == pending_moninor ||\n-                  \/\/ we are not the owner of this monitor\n-                  (_thread != nullptr && !mon->is_entered(_thread))) {\n-                _blocker = Blocker(Blocker::WAITING_TO_LOCK, OopHandle(Universe::vm_global(), monitor->owner()));\n-                continue; \/\/ go to next monitor\n-              }\n-            }\n-          }\n-          _locks->push(OwnedLock(depth, OwnedLock::LOCKED, OopHandle(Universe::vm_global(), monitor->owner())));\n-        }\n-      }\n-    }\n-  }\n-\n-public:\n-  void do_thread(Thread* th) override {\n-    Thread* current = Thread::current();\n-    if (!current->is_Java_thread()) {\n-      _retry_handshake = true;\n-      return;\n-    }\n-\n-    bool is_virtual = java_lang_VirtualThread::is_instance(_java_thread());\n-    if (_thread != nullptr) {\n-      if (is_virtual) {\n-        \/\/ mounted vthread, use carrier thread state\n-        oop carrier_thread = java_lang_VirtualThread::carrier_thread(_java_thread());\n-        _thread_status = java_lang_Thread::get_thread_status(carrier_thread);\n-      } else {\n-        _thread_status = java_lang_Thread::get_thread_status(_java_thread());\n-      }\n-    } else {\n-      \/\/ unmounted vthread\n-      int vt_state = java_lang_VirtualThread::state(_java_thread());\n-      _thread_status = java_lang_VirtualThread::map_state_to_thread_status(vt_state);\n-    }\n-    _name = OopHandle(Universe::vm_global(), java_lang_Thread::name(_java_thread()));\n-\n-    if (_thread != nullptr && !_thread->has_last_Java_frame()) {\n-      \/\/ stack trace is empty\n-      return;\n-    }\n-\n-    bool walk_cont = false;\n-\n-    if (is_virtual) {\n-      if (_thread != nullptr) {\n-        \/\/ if (thread->vthread() != _java_thread()) \/\/ We might be inside a System.executeOnCarrierThread\n-        const ContinuationEntry* ce = _thread->vthread_continuation();\n-        if (ce == nullptr || ce->cont_oop(_thread) != java_lang_VirtualThread::continuation(_java_thread())) {\n-          \/\/ TODO: handle\n-        }\n-      }\n-    } else {\n-      walk_cont = (_thread->vthread_continuation() != nullptr);\n-    }\n-\n-    oop park_blocker = java_lang_Thread::park_blocker(_java_thread());\n-    if (park_blocker != nullptr) {\n-      _blocker = Blocker(Blocker::PARK_BLOCKER, OopHandle(Universe::vm_global(), park_blocker));\n-      if (park_blocker->is_a(vmClasses::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass())) {\n-        oop blocker_owner = java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(park_blocker);\n-        _blocker_owner = OopHandle(Universe::vm_global(), blocker_owner);\n-      }\n-    }\n-\n-    ResourceMark rm(current);\n-    HandleMark hm(current);\n-\n-    const int max_depth = MaxJavaStackTraceDepth;\n-    const bool skip_hidden = !ShowHiddenFrames;\n-\n-    \/\/ Pick minimum length that will cover most cases\n-    int init_length = 64;\n-    _methods = new (mtInternal) GrowableArray<Method*>(init_length, mtInternal);\n-    _bcis = new (mtInternal) GrowableArray<int>(init_length, mtInternal);\n-    _locks = new (mtInternal) GrowableArray<OwnedLock>(init_length, mtInternal);\n-    int total_count = 0;\n-\n-    vframeStream vfst(_thread != nullptr\n-        ? vframeStream(_thread, false, true, walk_cont)\n-        : vframeStream(java_lang_VirtualThread::continuation(_java_thread())));\n-\n-    for (;\n-        !vfst.at_end() && (max_depth == 0 || max_depth != total_count);\n-        vfst.next()) {\n-\n-      detect_locks(vfst.asJavaVFrame(), total_count);\n-\n-      if (skip_hidden && (vfst.method()->is_hidden() ||\n-        vfst.method()->is_continuation_enter_intrinsic())) {\n-        continue;\n-      }\n-      _methods->push(vfst.method());\n-      _bcis->push(vfst.bci());\n-      total_count++;\n-    }\n-\n-    _depth = total_count;\n-  }\n-};\n-\n@@ -2241,221 +2002,0 @@\n-class jdk_internal_vm_ThreadLock: AllStatic {\n-  static bool _inited;\n-  static int _depth_offset;\n-  static int _typeOrdinal_offset;\n-  static int _obj_offset;\n-\n-  static void compute_offsets(InstanceKlass * klass, TRAPS) {\n-    JavaClasses::compute_offset(_depth_offset, klass, \"depth\", vmSymbols::int_signature(), false);\n-    JavaClasses::compute_offset(_typeOrdinal_offset, klass, \"typeOrdinal\", vmSymbols::int_signature(), false);\n-    JavaClasses::compute_offset(_obj_offset, klass, \"obj\", vmSymbols::object_signature(), false);\n-  }\n-public:\n-  static void init(InstanceKlass* klass, TRAPS) {\n-    if (!_inited) {\n-      compute_offsets(klass, CHECK);\n-      _inited = true;\n-    }\n-  }\n-\n-  static Handle create(InstanceKlass* klass, int depth, int type_ordinal, OopHandle obj, TRAPS) {\n-    init(klass, CHECK_NH);\n-    Handle result = klass->allocate_instance_handle(CHECK_NH);\n-    result->int_field_put(_depth_offset, depth);\n-    result->int_field_put(_typeOrdinal_offset, type_ordinal);\n-    result->obj_field_put(_obj_offset, obj.resolve());\n-    return result;\n-  }\n-};\n-\n-bool jdk_internal_vm_ThreadLock::_inited = false;\n-int jdk_internal_vm_ThreadLock::_depth_offset;\n-int jdk_internal_vm_ThreadLock::_typeOrdinal_offset;\n-int jdk_internal_vm_ThreadLock::_obj_offset;\n-\n-class jdk_internal_vm_ThreadSnapshot: AllStatic {\n-  static bool _inited;\n-  static int _name_offset;\n-  static int _threadStatus_offset;\n-  static int _carrierThread_offset;\n-  static int _stackTrace_offset;\n-  static int _locks_offset;\n-  static int _blockerTypeOrdinal_offset;\n-  static int _blockerObject_offset;\n-  static int _blockerOwner_offset;\n-\n-  static void compute_offsets(InstanceKlass* klass, TRAPS) {\n-    JavaClasses::compute_offset(_name_offset, klass, \"name\", vmSymbols::string_signature(), false);\n-    JavaClasses::compute_offset(_threadStatus_offset, klass, \"threadStatus\", vmSymbols::int_signature(), false);\n-    JavaClasses::compute_offset(_carrierThread_offset, klass, \"carrierThread\", vmSymbols::thread_signature(), false);\n-    JavaClasses::compute_offset(_stackTrace_offset, klass, \"stackTrace\", vmSymbols::java_lang_StackTraceElement_array(), false);\n-    JavaClasses::compute_offset(_locks_offset, klass, \"locks\", vmSymbols::jdk_internal_vm_ThreadLock_array(), false);\n-    JavaClasses::compute_offset(_blockerTypeOrdinal_offset, klass, \"blockerTypeOrdinal\", vmSymbols::int_signature(), false);\n-    JavaClasses::compute_offset(_blockerObject_offset, klass, \"blockerObject\", vmSymbols::object_signature(), false);\n-    JavaClasses::compute_offset(_blockerOwner_offset, klass, \"blockerOwner\", vmSymbols::object_signature(), false);\n-  }\n-public:\n-  static void init(InstanceKlass* klass, TRAPS) {\n-    if (!_inited) {\n-      compute_offsets(klass, CHECK);\n-      _inited = true;\n-    }\n-  }\n-\n-  static Handle allocate(InstanceKlass* klass, TRAPS) {\n-    init(klass, CHECK_NH);\n-    return klass->allocate_instance_handle(CHECK_NH);\n-  }\n-\n-  static void set_name(oop snapshot, oop name) {\n-    snapshot->obj_field_put(_name_offset, name);\n-  }\n-  static void set_thread_status(oop snapshot, int status) {\n-    snapshot->int_field_put(_threadStatus_offset, status);\n-  }\n-  static void set_carrier_thread(oop snapshot, oop carrier_thread) {\n-    snapshot->obj_field_put(_carrierThread_offset, carrier_thread);\n-  }\n-  static void set_stack_trace(oop snapshot, oop trace) {\n-    snapshot->obj_field_put(_stackTrace_offset, trace);\n-  }\n-  static void set_locks(oop snapshot, oop locks) {\n-    snapshot->obj_field_put(_locks_offset, locks);\n-  }\n-  static void set_blocker(oop snapshot, int type_ordinal, oop lock) {\n-    snapshot->int_field_put(_blockerTypeOrdinal_offset, type_ordinal);\n-    snapshot->obj_field_put(_blockerObject_offset, lock);\n-  }\n-  static void set_blocker_owner(oop snapshot, oop owner) {\n-    snapshot->obj_field_put(_blockerOwner_offset, owner);\n-  }\n-};\n-\n-bool jdk_internal_vm_ThreadSnapshot::_inited = false;\n-int jdk_internal_vm_ThreadSnapshot::_name_offset;\n-int jdk_internal_vm_ThreadSnapshot::_threadStatus_offset;\n-int jdk_internal_vm_ThreadSnapshot::_carrierThread_offset;\n-int jdk_internal_vm_ThreadSnapshot::_stackTrace_offset;\n-int jdk_internal_vm_ThreadSnapshot::_locks_offset;\n-int jdk_internal_vm_ThreadSnapshot::_blockerTypeOrdinal_offset;\n-int jdk_internal_vm_ThreadSnapshot::_blockerObject_offset;\n-int jdk_internal_vm_ThreadSnapshot::_blockerOwner_offset;\n-\n-oop java_lang_Thread::get_thread_snapshot(jobject jthread, TRAPS) {\n-  ThreadsListHandle tlh(THREAD);\n-\n-  ResourceMark rm(THREAD);\n-  HandleMark   hm(THREAD);\n-  Handle java_thread(THREAD, JNIHandles::resolve(jthread));\n-\n-  \/\/ wrapper to auto delete JvmtiVTMSTransitionDisabler\n-  class TransitionDisabler {\n-    JvmtiVTMSTransitionDisabler* _transition_disabler;\n-  public:\n-    TransitionDisabler() : _transition_disabler(nullptr) {}\n-    ~TransitionDisabler() {\n-      reset();\n-    }\n-    void init(jobject jthread) {\n-      _transition_disabler = new (mtInternal) JvmtiVTMSTransitionDisabler(jthread);\n-    }\n-    void reset() {\n-      if (_transition_disabler != nullptr) {\n-        delete _transition_disabler;\n-        _transition_disabler = nullptr;\n-      }\n-    }\n-  } transition_disabler;\n-\n-  JavaThread* thread = nullptr;\n-  bool is_virtual = java_lang_VirtualThread::is_instance(java_thread());\n-  Handle carrier_thread;\n-  if (is_virtual) {\n-    \/\/ 1st need to disable mount\/unmount transitions\n-    transition_disabler.init(jthread);\n-\n-    carrier_thread = Handle(THREAD, java_lang_VirtualThread::carrier_thread(java_thread()));\n-    if (carrier_thread != nullptr) {\n-      thread = java_lang_Thread::thread(carrier_thread());\n-    }\n-  } else {\n-    thread = java_lang_Thread::thread(java_thread());\n-  }\n-\n-  \/\/ Handshake with target\n-  GetThreadSnapshotClosure cl(THREAD, java_thread, thread);\n-  if (thread == nullptr) {\n-    \/\/ unmounted vthread, execute on the current thread\n-    cl.do_thread(nullptr);\n-  } else {\n-    do {\n-      Handshake::execute(&cl, &tlh, thread);\n-    } while (cl.read_reset_retry());\n-  }\n-\n-  \/\/ all info is collected, can enable transitions.\n-  transition_disabler.reset();\n-\n-  \/\/ StackTrace\n-  InstanceKlass* ste_klass = vmClasses::StackTraceElement_klass();\n-  assert(ste_klass != nullptr, \"must be loaded in 1.4+\");\n-  if (ste_klass->should_be_initialized()) {\n-    ste_klass->initialize(CHECK_NULL);\n-  }\n-\n-  objArrayHandle trace = oopFactory::new_objArray_handle(ste_klass, cl._depth, CHECK_NULL);\n-\n-  for (int i = 0; i < cl._depth; i++) {\n-    methodHandle method(THREAD, cl._methods->at(i));\n-    oop element = java_lang_StackTraceElement::create(method, cl._bcis->at(i), CHECK_NULL);\n-    trace->obj_at_put(i, element);\n-  }\n-\n-  \/\/ Locks\n-  Symbol* lock_sym = vmSymbols::jdk_internal_vm_ThreadLock();\n-  Klass* lock_k = SystemDictionary::resolve_or_fail(lock_sym, true, CHECK_NULL);\n-  InstanceKlass* lock_klass = InstanceKlass::cast(lock_k);\n-\n-  objArrayHandle locks;\n-  if (cl._locks != nullptr && cl._locks->length() > 0) {\n-    locks = oopFactory::new_objArray_handle(lock_klass, cl._locks->length(), CHECK_NULL);\n-    for (int n = 0; n < cl._locks->length(); n++) {\n-      GetThreadSnapshotClosure::OwnedLock* lock_info = cl._locks->adr_at(n);\n-\n-      Handle lock = jdk_internal_vm_ThreadLock::create(lock_klass,\n-        lock_info->_depth, lock_info->_type, lock_info->_obj, CHECK_NULL);\n-      locks->obj_at_put(n, lock());\n-    }\n-  }\n-\n-  \/\/ call static StackTraceElement[] StackTraceElement.of(StackTraceElement[] stackTrace)\n-  \/\/ to properly initialize STE.\n-  {\n-    JavaValue result(T_OBJECT);\n-    JavaCalls::call_static(&result,\n-                           ste_klass,\n-                           vmSymbols::java_lang_StackTraceElement_of_name(),\n-                           vmSymbols::java_lang_StackTraceElement_of_signature(),\n-                           trace,\n-                           CHECK_NULL);\n-    \/\/ the method return the same trace object\n-  }\n-\n-  Symbol* snapshot_klass_name = vmSymbols::jdk_internal_vm_ThreadSnapshot();\n-  Klass* snapshot_klass = SystemDictionary::resolve_or_fail(snapshot_klass_name, true, CHECK_NULL);\n-  if (snapshot_klass->should_be_initialized()) {\n-    snapshot_klass->initialize(CHECK_NULL);\n-  }\n-\n-  Handle snapshot = jdk_internal_vm_ThreadSnapshot::allocate(InstanceKlass::cast(snapshot_klass), CHECK_NULL);\n-  jdk_internal_vm_ThreadSnapshot::set_name(snapshot(), cl._name.resolve());\n-  jdk_internal_vm_ThreadSnapshot::set_thread_status(snapshot(), (int)cl._thread_status);\n-  jdk_internal_vm_ThreadSnapshot::set_carrier_thread(snapshot(), carrier_thread());\n-  jdk_internal_vm_ThreadSnapshot::set_stack_trace(snapshot(), trace());\n-  jdk_internal_vm_ThreadSnapshot::set_locks(snapshot(), locks());\n-  if (!cl._blocker.is_empty()) {\n-    jdk_internal_vm_ThreadSnapshot::set_blocker(snapshot(), cl._blocker._type, cl._blocker._obj.resolve());\n-    jdk_internal_vm_ThreadSnapshot::set_blocker_owner(snapshot(), cl._blocker_owner.resolve());\n-  }\n-  return snapshot();\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":0,"deletions":460,"binary":false,"changes":460,"status":"modified"},{"patch":"@@ -463,1 +463,0 @@\n-  static oop get_thread_snapshot(jobject jthread, TRAPS);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2965,1 +2965,2 @@\n-  oop snapshot = java_lang_Thread::get_thread_snapshot(jthread, THREAD);\n+#if INCLUDE_JVMTI\n+  oop snapshot = VMThreadSnapshot::get_thread_snapshot(jthread, THREAD);\n@@ -2967,0 +2968,3 @@\n+#elif\n+  return nullptr;\n+#endif\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -130,0 +130,1 @@\n+#if INCLUDE_JVMTI\n@@ -131,0 +132,1 @@\n+#endif \/\/ INCLUDE_JVMTI\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"prims\/jvmtiThreadState.hpp\"\n@@ -45,0 +46,1 @@\n+#include \"runtime\/javaCalls.hpp\"\n@@ -46,0 +48,1 @@\n+#include \"runtime\/jniHandles.inline.hpp\"\n@@ -47,1 +50,1 @@\n-#include \"runtime\/synchronizer.hpp\"\n+#include \"runtime\/synchronizer.inline.hpp\"\n@@ -51,1 +54,1 @@\n-#include \"runtime\/vframe.hpp\"\n+#include \"runtime\/vframe.inline.hpp\"\n@@ -1118,0 +1121,471 @@\n+\n+\n+\/\/ jdk.internal.vm.ThreadSnapshot support\n+#if INCLUDE_JVMTI\n+\n+class GetThreadSnapshotClosure: public HandshakeClosure {\n+private:\n+  static OopStorage* oop_storage() {\n+    assert(_thread_service_storage != nullptr, \"sanity\");\n+    return _thread_service_storage;\n+  }\n+\n+public:\n+  struct OwnedLock {\n+    \/\/ should be synced with ordinals of jdk.internal.vm.ThreadSnapshot.OwnedLockType enum\n+    enum Type {\n+      NOTHING = -1,\n+      LOCKED = 0,\n+      ELIMINATED = 1,\n+    };\n+\n+    int _depth;\n+    Type _type;\n+    OopHandle _obj;\n+\n+    OwnedLock(int depth, Type type, OopHandle obj): _depth(depth), _type(type), _obj(obj) {}\n+    OwnedLock(): _depth(0), _type(NOTHING), _obj(nullptr) {}\n+  };\n+\n+  struct Blocker {\n+    \/\/ should be synced with ordinals of jdk.internal.vm.ThreadSnapshot.BlockerLockType enum\n+    enum Type {\n+      NOTHING = -1,\n+      PARK_BLOCKER = 0,\n+      WAITING_TO_LOCK = 1,\n+      WAITING_ON = 2,\n+    };\n+\n+    Type _type;\n+    OopHandle _obj;\n+\n+    Blocker(Type type, OopHandle obj): _type(type), _obj(obj) {}\n+    Blocker(): _type(NOTHING), _obj(nullptr) {}\n+\n+    bool is_empty() const {\n+      return _type == NOTHING;\n+    }\n+  };\n+\n+  Handle _java_thread;\n+  JavaThread* _thread;\n+  int _depth;\n+  bool _retry_handshake;\n+  GrowableArray<Method*>* _methods;\n+  GrowableArray<int>* _bcis;\n+  JavaThreadStatus _thread_status;\n+  OopHandle _name;\n+  GrowableArray<OwnedLock>* _locks;\n+  Blocker _blocker;\n+  OopHandle _blocker_owner;\n+\n+  GetThreadSnapshotClosure(JavaThread* calling_thread, Handle java_thread, JavaThread* thread):\n+    HandshakeClosure(\"GetThreadSnapshotClosure\"),\n+    _java_thread(java_thread), _thread(thread),\n+    _depth(0), _retry_handshake(false),\n+    _methods(nullptr), _bcis(nullptr),\n+    _thread_status(), _name(nullptr),\n+    _locks(nullptr), _blocker(), _blocker_owner(nullptr) { }\n+  virtual ~GetThreadSnapshotClosure() {\n+    delete _methods;\n+    delete _bcis;\n+    _name.release(oop_storage());\n+    if (_locks != nullptr) {\n+      for (int i = 0; i < _locks->length(); i++) {\n+        _locks->at(i)._obj.release(oop_storage());\n+      }\n+      delete _locks;\n+    }\n+    _blocker._obj.release(oop_storage());\n+    _blocker_owner.release(oop_storage());\n+  }\n+\n+  bool read_reset_retry() {\n+    bool ret = _retry_handshake;\n+    \/\/ If we re-execute the handshake this method need to return false\n+    \/\/ when the handshake cannot be performed. (E.g. thread terminating)\n+    _retry_handshake = false;\n+    return ret;\n+  }\n+\n+private:\n+  void detect_locks(javaVFrame* jvf, int depth) {\n+    Thread* current = Thread::current();\n+\n+    if (depth == 0 && _blocker.is_empty()) {\n+      \/\/ If this is the first frame and it is java.lang.Object.wait(...)\n+      \/\/ then print out the receiver.\n+      if (jvf->method()->name() == vmSymbols::wait_name() &&\n+        jvf->method()->method_holder()->name() == vmSymbols::java_lang_Object()) {\n+        OopHandle lock_object;\n+        StackValueCollection* locs = jvf->locals();\n+        if (!locs->is_empty()) {\n+          StackValue* sv = locs->at(0);\n+          if (sv->type() == T_OBJECT) {\n+            Handle o = locs->at(0)->get_obj();\n+            lock_object = OopHandle(oop_storage(), o());\n+          }\n+        }\n+\n+        _blocker = Blocker(Blocker::WAITING_ON, lock_object);\n+      }\n+    }\n+\n+    GrowableArray<MonitorInfo*>* mons = jvf->monitors();\n+    if (!mons->is_empty()) {\n+      for (int index = (mons->length() - 1); index >= 0; index--) {\n+        MonitorInfo* monitor = mons->at(index);\n+        if (monitor->eliminated() && jvf->is_compiled_frame()) { \/\/ Eliminated in compiled code\n+          if (monitor->owner_is_scalar_replaced()) {\n+            Klass* k = java_lang_Class::as_Klass(monitor->owner_klass());\n+            _locks->push(OwnedLock(depth, OwnedLock::ELIMINATED, OopHandle(oop_storage(), k->klass_holder())));\n+          } else {\n+            Handle owner(current, monitor->owner());\n+            if (owner.not_null()) {\n+              Klass* k = owner->klass();\n+              _locks->push(OwnedLock(depth, OwnedLock::ELIMINATED, OopHandle(oop_storage(), k->klass_holder())));\n+            }\n+          }\n+          continue;\n+        }\n+        if (monitor->owner() != nullptr) {\n+          \/\/ the monitor is associated with an object, i.e., it is locked\n+\n+          if (depth == 0 && _blocker.is_empty()) {\n+            ObjectMonitor* pending_moninor = java_lang_VirtualThread::is_instance(_java_thread())\n+              ? java_lang_VirtualThread::current_pending_monitor(_java_thread())\n+              : jvf->thread()->current_pending_monitor();\n+\n+            markWord mark = monitor->owner()->mark();\n+            \/\/ The first stage of async deflation does not affect any field\n+            \/\/ used by this comparison so the ObjectMonitor* is usable here.\n+            if (mark.has_monitor()) {\n+              ObjectMonitor* mon = ObjectSynchronizer::read_monitor(current, monitor->owner(), mark);\n+              if (\/\/ if the monitor is null we must be in the process of locking\n+                mon == nullptr ||\n+                \/\/ we have marked ourself as pending on this monitor\n+                mon == pending_moninor ||\n+                \/\/ we are not the owner of this monitor\n+                (_thread != nullptr && !mon->is_entered(_thread))) {\n+                _blocker = Blocker(Blocker::WAITING_TO_LOCK, OopHandle(oop_storage(), monitor->owner()));\n+                continue; \/\/ go to next monitor\n+              }\n+            }\n+          }\n+          _locks->push(OwnedLock(depth, OwnedLock::LOCKED, OopHandle(oop_storage(), monitor->owner())));\n+        }\n+      }\n+    }\n+  }\n+\n+public:\n+  void do_thread(Thread* th) override {\n+    Thread* current = Thread::current();\n+    if (!current->is_Java_thread()) {\n+      _retry_handshake = true;\n+      return;\n+    }\n+\n+    bool is_virtual = java_lang_VirtualThread::is_instance(_java_thread());\n+    if (_thread != nullptr) {\n+      if (is_virtual) {\n+        \/\/ mounted vthread, use carrier thread state\n+        oop carrier_thread = java_lang_VirtualThread::carrier_thread(_java_thread());\n+        _thread_status = java_lang_Thread::get_thread_status(carrier_thread);\n+      } else {\n+        _thread_status = java_lang_Thread::get_thread_status(_java_thread());\n+      }\n+    } else {\n+      \/\/ unmounted vthread\n+      int vt_state = java_lang_VirtualThread::state(_java_thread());\n+      _thread_status = java_lang_VirtualThread::map_state_to_thread_status(vt_state);\n+    }\n+    _name = OopHandle(oop_storage(), java_lang_Thread::name(_java_thread()));\n+\n+    if (_thread != nullptr && !_thread->has_last_Java_frame()) {\n+      \/\/ stack trace is empty\n+      return;\n+    }\n+\n+    bool walk_cont = false;\n+\n+    if (is_virtual) {\n+      if (_thread != nullptr) {\n+        \/\/ if (thread->vthread() != _java_thread()) \/\/ We might be inside a System.executeOnCarrierThread\n+        const ContinuationEntry* ce = _thread->vthread_continuation();\n+        if (ce == nullptr || ce->cont_oop(_thread) != java_lang_VirtualThread::continuation(_java_thread())) {\n+          \/\/ TODO: handle\n+        }\n+      }\n+    } else {\n+      walk_cont = (_thread->vthread_continuation() != nullptr);\n+    }\n+\n+    oop park_blocker = java_lang_Thread::park_blocker(_java_thread());\n+    if (park_blocker != nullptr) {\n+      _blocker = Blocker(Blocker::PARK_BLOCKER, OopHandle(oop_storage(), park_blocker));\n+      if (park_blocker->is_a(vmClasses::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass())) {\n+        oop blocker_owner = java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(park_blocker);\n+        _blocker_owner = OopHandle(oop_storage(), blocker_owner);\n+      }\n+    }\n+\n+    ResourceMark rm(current);\n+    HandleMark hm(current);\n+\n+    const int max_depth = MaxJavaStackTraceDepth;\n+    const bool skip_hidden = !ShowHiddenFrames;\n+\n+    \/\/ Pick minimum length that will cover most cases\n+    int init_length = 64;\n+    _methods = new (mtInternal) GrowableArray<Method*>(init_length, mtInternal);\n+    _bcis = new (mtInternal) GrowableArray<int>(init_length, mtInternal);\n+    _locks = new (mtInternal) GrowableArray<OwnedLock>(init_length, mtInternal);\n+    int total_count = 0;\n+\n+    vframeStream vfst(_thread != nullptr\n+      ? vframeStream(_thread, false, true, walk_cont)\n+      : vframeStream(java_lang_VirtualThread::continuation(_java_thread())));\n+\n+    for (;\n+      !vfst.at_end() && (max_depth == 0 || max_depth != total_count);\n+      vfst.next()) {\n+\n+      detect_locks(vfst.asJavaVFrame(), total_count);\n+\n+      if (skip_hidden && (vfst.method()->is_hidden() ||\n+        vfst.method()->is_continuation_enter_intrinsic())) {\n+        continue;\n+      }\n+      _methods->push(vfst.method());\n+      _bcis->push(vfst.bci());\n+      total_count++;\n+    }\n+\n+    _depth = total_count;\n+  }\n+};\n+\n+class jdk_internal_vm_ThreadLock: AllStatic {\n+  static bool _inited;\n+  static int _depth_offset;\n+  static int _typeOrdinal_offset;\n+  static int _obj_offset;\n+\n+  static void compute_offsets(InstanceKlass* klass, TRAPS) {\n+    JavaClasses::compute_offset(_depth_offset, klass, \"depth\", vmSymbols::int_signature(), false);\n+    JavaClasses::compute_offset(_typeOrdinal_offset, klass, \"typeOrdinal\", vmSymbols::int_signature(), false);\n+    JavaClasses::compute_offset(_obj_offset, klass, \"obj\", vmSymbols::object_signature(), false);\n+  }\n+public:\n+  static void init(InstanceKlass* klass, TRAPS) {\n+    if (!_inited) {\n+      compute_offsets(klass, CHECK);\n+      _inited = true;\n+    }\n+  }\n+\n+  static Handle create(InstanceKlass* klass, int depth, int type_ordinal, OopHandle obj, TRAPS) {\n+    init(klass, CHECK_NH);\n+    Handle result = klass->allocate_instance_handle(CHECK_NH);\n+    result->int_field_put(_depth_offset, depth);\n+    result->int_field_put(_typeOrdinal_offset, type_ordinal);\n+    result->obj_field_put(_obj_offset, obj.resolve());\n+    return result;\n+  }\n+};\n+\n+bool jdk_internal_vm_ThreadLock::_inited = false;\n+int jdk_internal_vm_ThreadLock::_depth_offset;\n+int jdk_internal_vm_ThreadLock::_typeOrdinal_offset;\n+int jdk_internal_vm_ThreadLock::_obj_offset;\n+\n+class jdk_internal_vm_ThreadSnapshot: AllStatic {\n+  static bool _inited;\n+  static int _name_offset;\n+  static int _threadStatus_offset;\n+  static int _carrierThread_offset;\n+  static int _stackTrace_offset;\n+  static int _locks_offset;\n+  static int _blockerTypeOrdinal_offset;\n+  static int _blockerObject_offset;\n+  static int _blockerOwner_offset;\n+\n+  static void compute_offsets(InstanceKlass* klass, TRAPS) {\n+    JavaClasses::compute_offset(_name_offset, klass, \"name\", vmSymbols::string_signature(), false);\n+    JavaClasses::compute_offset(_threadStatus_offset, klass, \"threadStatus\", vmSymbols::int_signature(), false);\n+    JavaClasses::compute_offset(_carrierThread_offset, klass, \"carrierThread\", vmSymbols::thread_signature(), false);\n+    JavaClasses::compute_offset(_stackTrace_offset, klass, \"stackTrace\", vmSymbols::java_lang_StackTraceElement_array(), false);\n+    JavaClasses::compute_offset(_locks_offset, klass, \"locks\", vmSymbols::jdk_internal_vm_ThreadLock_array(), false);\n+    JavaClasses::compute_offset(_blockerTypeOrdinal_offset, klass, \"blockerTypeOrdinal\", vmSymbols::int_signature(), false);\n+    JavaClasses::compute_offset(_blockerObject_offset, klass, \"blockerObject\", vmSymbols::object_signature(), false);\n+    JavaClasses::compute_offset(_blockerOwner_offset, klass, \"blockerOwner\", vmSymbols::object_signature(), false);\n+  }\n+public:\n+  static void init(InstanceKlass* klass, TRAPS) {\n+    if (!_inited) {\n+      compute_offsets(klass, CHECK);\n+      _inited = true;\n+    }\n+  }\n+\n+  static Handle allocate(InstanceKlass* klass, TRAPS) {\n+    init(klass, CHECK_NH);\n+    return klass->allocate_instance_handle(CHECK_NH);\n+  }\n+\n+  static void set_name(oop snapshot, oop name) {\n+    snapshot->obj_field_put(_name_offset, name);\n+  }\n+  static void set_thread_status(oop snapshot, int status) {\n+    snapshot->int_field_put(_threadStatus_offset, status);\n+  }\n+  static void set_carrier_thread(oop snapshot, oop carrier_thread) {\n+    snapshot->obj_field_put(_carrierThread_offset, carrier_thread);\n+  }\n+  static void set_stack_trace(oop snapshot, oop trace) {\n+    snapshot->obj_field_put(_stackTrace_offset, trace);\n+  }\n+  static void set_locks(oop snapshot, oop locks) {\n+    snapshot->obj_field_put(_locks_offset, locks);\n+  }\n+  static void set_blocker(oop snapshot, int type_ordinal, oop lock) {\n+    snapshot->int_field_put(_blockerTypeOrdinal_offset, type_ordinal);\n+    snapshot->obj_field_put(_blockerObject_offset, lock);\n+  }\n+  static void set_blocker_owner(oop snapshot, oop owner) {\n+    snapshot->obj_field_put(_blockerOwner_offset, owner);\n+  }\n+};\n+\n+bool jdk_internal_vm_ThreadSnapshot::_inited = false;\n+int jdk_internal_vm_ThreadSnapshot::_name_offset;\n+int jdk_internal_vm_ThreadSnapshot::_threadStatus_offset;\n+int jdk_internal_vm_ThreadSnapshot::_carrierThread_offset;\n+int jdk_internal_vm_ThreadSnapshot::_stackTrace_offset;\n+int jdk_internal_vm_ThreadSnapshot::_locks_offset;\n+int jdk_internal_vm_ThreadSnapshot::_blockerTypeOrdinal_offset;\n+int jdk_internal_vm_ThreadSnapshot::_blockerObject_offset;\n+int jdk_internal_vm_ThreadSnapshot::_blockerOwner_offset;\n+\n+oop VMThreadSnapshot::get_thread_snapshot(jobject jthread, TRAPS) {\n+  ThreadsListHandle tlh(THREAD);\n+\n+  ResourceMark rm(THREAD);\n+  HandleMark   hm(THREAD);\n+  Handle java_thread(THREAD, JNIHandles::resolve(jthread));\n+\n+  \/\/ wrapper to auto delete JvmtiVTMSTransitionDisabler\n+  class TransitionDisabler {\n+    JvmtiVTMSTransitionDisabler* _transition_disabler;\n+  public:\n+    TransitionDisabler(): _transition_disabler(nullptr) {}\n+    ~TransitionDisabler() {\n+      reset();\n+    }\n+    void init(jobject jthread) {\n+      _transition_disabler = new (mtInternal) JvmtiVTMSTransitionDisabler(jthread);\n+    }\n+    void reset() {\n+      if (_transition_disabler != nullptr) {\n+        delete _transition_disabler;\n+        _transition_disabler = nullptr;\n+      }\n+    }\n+  } transition_disabler;\n+\n+  JavaThread* thread = nullptr;\n+  bool is_virtual = java_lang_VirtualThread::is_instance(java_thread());\n+  Handle carrier_thread;\n+  if (is_virtual) {\n+    \/\/ 1st need to disable mount\/unmount transitions\n+    transition_disabler.init(jthread);\n+\n+    carrier_thread = Handle(THREAD, java_lang_VirtualThread::carrier_thread(java_thread()));\n+    if (carrier_thread != nullptr) {\n+      thread = java_lang_Thread::thread(carrier_thread());\n+    }\n+  } else {\n+    thread = java_lang_Thread::thread(java_thread());\n+  }\n+\n+  \/\/ Handshake with target\n+  GetThreadSnapshotClosure cl(THREAD, java_thread, thread);\n+  if (thread == nullptr) {\n+    \/\/ unmounted vthread, execute on the current thread\n+    cl.do_thread(nullptr);\n+  } else {\n+    do {\n+      Handshake::execute(&cl, &tlh, thread);\n+    } while (cl.read_reset_retry());\n+  }\n+\n+  \/\/ all info is collected, can enable transitions.\n+  transition_disabler.reset();\n+\n+  \/\/ StackTrace\n+  InstanceKlass* ste_klass = vmClasses::StackTraceElement_klass();\n+  assert(ste_klass != nullptr, \"must be loaded in 1.4+\");\n+  if (ste_klass->should_be_initialized()) {\n+    ste_klass->initialize(CHECK_NULL);\n+  }\n+\n+  objArrayHandle trace = oopFactory::new_objArray_handle(ste_klass, cl._depth, CHECK_NULL);\n+\n+  for (int i = 0; i < cl._depth; i++) {\n+    methodHandle method(THREAD, cl._methods->at(i));\n+    oop element = java_lang_StackTraceElement::create(method, cl._bcis->at(i), CHECK_NULL);\n+    trace->obj_at_put(i, element);\n+  }\n+\n+  \/\/ Locks\n+  Symbol* lock_sym = vmSymbols::jdk_internal_vm_ThreadLock();\n+  Klass* lock_k = SystemDictionary::resolve_or_fail(lock_sym, true, CHECK_NULL);\n+  InstanceKlass* lock_klass = InstanceKlass::cast(lock_k);\n+\n+  objArrayHandle locks;\n+  if (cl._locks != nullptr && cl._locks->length() > 0) {\n+    locks = oopFactory::new_objArray_handle(lock_klass, cl._locks->length(), CHECK_NULL);\n+    for (int n = 0; n < cl._locks->length(); n++) {\n+      GetThreadSnapshotClosure::OwnedLock* lock_info = cl._locks->adr_at(n);\n+\n+      Handle lock = jdk_internal_vm_ThreadLock::create(lock_klass,\n+        lock_info->_depth, lock_info->_type, lock_info->_obj, CHECK_NULL);\n+      locks->obj_at_put(n, lock());\n+    }\n+  }\n+\n+  \/\/ call static StackTraceElement[] StackTraceElement.of(StackTraceElement[] stackTrace)\n+  \/\/ to properly initialize STE.\n+  {\n+    JavaValue result(T_OBJECT);\n+    JavaCalls::call_static(&result,\n+      ste_klass,\n+      vmSymbols::java_lang_StackTraceElement_of_name(),\n+      vmSymbols::java_lang_StackTraceElement_of_signature(),\n+      trace,\n+      CHECK_NULL);\n+    \/\/ the method return the same trace object\n+  }\n+\n+  Symbol* snapshot_klass_name = vmSymbols::jdk_internal_vm_ThreadSnapshot();\n+  Klass* snapshot_klass = SystemDictionary::resolve_or_fail(snapshot_klass_name, true, CHECK_NULL);\n+  if (snapshot_klass->should_be_initialized()) {\n+    snapshot_klass->initialize(CHECK_NULL);\n+  }\n+\n+  Handle snapshot = jdk_internal_vm_ThreadSnapshot::allocate(InstanceKlass::cast(snapshot_klass), CHECK_NULL);\n+  jdk_internal_vm_ThreadSnapshot::set_name(snapshot(), cl._name.resolve());\n+  jdk_internal_vm_ThreadSnapshot::set_thread_status(snapshot(), (int)cl._thread_status);\n+  jdk_internal_vm_ThreadSnapshot::set_carrier_thread(snapshot(), carrier_thread());\n+  jdk_internal_vm_ThreadSnapshot::set_stack_trace(snapshot(), trace());\n+  jdk_internal_vm_ThreadSnapshot::set_locks(snapshot(), locks());\n+  if (!cl._blocker.is_empty()) {\n+    jdk_internal_vm_ThreadSnapshot::set_blocker(snapshot(), cl._blocker._type, cl._blocker._obj.resolve());\n+    jdk_internal_vm_ThreadSnapshot::set_blocker_owner(snapshot(), cl._blocker_owner.resolve());\n+  }\n+  return snapshot();\n+}\n+\n+#endif \/\/ INCLUDE_JVMTI\n+\n","filename":"src\/hotspot\/share\/services\/threadService.cpp","additions":476,"deletions":2,"binary":false,"changes":478,"status":"modified"},{"patch":"@@ -634,0 +634,7 @@\n+\n+\/\/ jdk.internal.vm.ThreadSnapshot support\n+class VMThreadSnapshot: AllStatic {\n+public:\n+  JVMTI_ONLY(static oop get_thread_snapshot(jobject jthread, TRAPS);)\n+};\n+\n","filename":"src\/hotspot\/share\/services\/threadService.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,0 +53,2 @@\n+    private ThreadSnapshot() {}\n+\n@@ -192,0 +194,2 @@\n+        private ThreadLock() {}\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ThreadSnapshot.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}