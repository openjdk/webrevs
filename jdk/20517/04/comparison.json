{"files":[{"patch":"@@ -0,0 +1,345 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"cds\/aotConstantPoolResolver.hpp\"\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/cdsConfig.hpp\"\n+#include \"cds\/regeneratedClasses.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n+#include \"interpreter\/bytecodeStream.hpp\"\n+#include \"interpreter\/interpreterRuntime.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/constantPool.inline.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/klass.inline.hpp\"\n+#include \"runtime\/handles.inline.hpp\"\n+\n+AOTConstantPoolResolver::ClassesTable* AOTConstantPoolResolver::_processed_classes = nullptr;\n+AOTConstantPoolResolver::ClassesTable* AOTConstantPoolResolver::_vm_classes = nullptr;\n+\n+bool AOTConstantPoolResolver::is_vm_class(InstanceKlass* ik) {\n+  return (_vm_classes->get(ik) != nullptr);\n+}\n+\n+void AOTConstantPoolResolver::add_one_vm_class(InstanceKlass* ik) {\n+  bool created;\n+  _vm_classes->put_if_absent(ik, &created);\n+  if (created) {\n+    InstanceKlass* super = ik->java_super();\n+    if (super != nullptr) {\n+      add_one_vm_class(super);\n+    }\n+    Array<InstanceKlass*>* ifs = ik->local_interfaces();\n+    for (int i = 0; i < ifs->length(); i++) {\n+      add_one_vm_class(ifs->at(i));\n+    }\n+  }\n+}\n+\n+void AOTConstantPoolResolver::initialize() {\n+  assert(_vm_classes == nullptr, \"must be\");\n+  _vm_classes = new (mtClass)ClassesTable();\n+  _processed_classes = new (mtClass)ClassesTable();\n+  for (auto id : EnumRange<vmClassID>{}) {\n+    add_one_vm_class(vmClasses::klass_at(id));\n+  }\n+}\n+\n+void AOTConstantPoolResolver::dispose() {\n+  assert(_vm_classes != nullptr, \"must be\");\n+  delete _vm_classes;\n+  delete _processed_classes;\n+  _vm_classes = nullptr;\n+  _processed_classes = nullptr;\n+}\n+\n+\/\/ Returns true if we CAN PROVE that cp_index will always resolve to\n+\/\/ the same information at both dump time and run time. This is a\n+\/\/ necessary (but not sufficient) condition for pre-resolving cp_index\n+\/\/ during CDS archive assembly.\n+bool AOTConstantPoolResolver::is_resolution_deterministic(ConstantPool* cp, int cp_index) {\n+  assert(!is_in_archivebuilder_buffer(cp), \"sanity\");\n+\n+  if (cp->tag_at(cp_index).is_klass()) {\n+    \/\/ We require cp_index to be already resolved. This is fine for now, are we\n+    \/\/ currently archive only CP entries that are already resolved.\n+    Klass* resolved_klass = cp->resolved_klass_at(cp_index);\n+    return resolved_klass != nullptr && is_class_resolution_deterministic(cp->pool_holder(), resolved_klass);\n+  } else if (cp->tag_at(cp_index).is_field() ||\n+             cp->tag_at(cp_index).is_method() ||\n+             cp->tag_at(cp_index).is_interface_method()) {\n+    int klass_cp_index = cp->uncached_klass_ref_index_at(cp_index);\n+    if (!cp->tag_at(klass_cp_index).is_klass()) {\n+      \/\/ Not yet resolved\n+      return false;\n+    }\n+    Klass* k = cp->resolved_klass_at(klass_cp_index);\n+    if (!is_class_resolution_deterministic(cp->pool_holder(), k)) {\n+      return false;\n+    }\n+\n+    if (!k->is_instance_klass()) {\n+      \/\/ TODO: support non instance klasses as well.\n+      return false;\n+    }\n+\n+    \/\/ Here, We don't check if this entry can actually be resolved to a valid Field\/Method.\n+    \/\/ This method should be called by the ConstantPool to check Fields\/Methods that\n+    \/\/ have already been successfully resolved.\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+bool AOTConstantPoolResolver::is_class_resolution_deterministic(InstanceKlass* cp_holder, Klass* resolved_class) {\n+  assert(!is_in_archivebuilder_buffer(cp_holder), \"sanity\");\n+  assert(!is_in_archivebuilder_buffer(resolved_class), \"sanity\");\n+\n+  if (resolved_class->is_instance_klass()) {\n+    InstanceKlass* ik = InstanceKlass::cast(resolved_class);\n+\n+    if (!ik->is_shared() && SystemDictionaryShared::is_excluded_class(ik)) {\n+      return false;\n+    }\n+\n+    if (cp_holder->is_subtype_of(ik)) {\n+      \/\/ All super types of ik will be resolved in ik->class_loader() before\n+      \/\/ ik is defined in this loader, so it's safe to archive the resolved klass reference.\n+      return true;\n+    }\n+\n+    if (is_vm_class(ik)) {\n+      if (ik->class_loader() != cp_holder->class_loader()) {\n+        \/\/ At runtime, cp_holder() may not be able to resolve to the same\n+        \/\/ ik. For example, a different version of ik may be defined in\n+        \/\/ cp->pool_holder()'s loader using MethodHandles.Lookup.defineClass().\n+        return false;\n+      } else {\n+        return true;\n+      }\n+    }\n+  } else if (resolved_class->is_objArray_klass()) {\n+    Klass* elem = ObjArrayKlass::cast(resolved_class)->bottom_klass();\n+    if (elem->is_instance_klass()) {\n+      return is_class_resolution_deterministic(cp_holder, InstanceKlass::cast(elem));\n+    } else if (elem->is_typeArray_klass()) {\n+      return true;\n+    }\n+  } else if (resolved_class->is_typeArray_klass()) {\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+void AOTConstantPoolResolver::dumptime_resolve_constants(InstanceKlass* ik, TRAPS) {\n+  if (!ik->is_linked()) {\n+    return;\n+  }\n+  bool first_time;\n+  _processed_classes->put_if_absent(ik, &first_time);\n+  if (!first_time) {\n+    \/\/ We have already resolved the constants in class, so no need to do it again.\n+    return;\n+  }\n+\n+  constantPoolHandle cp(THREAD, ik->constants());\n+  for (int cp_index = 1; cp_index < cp->length(); cp_index++) { \/\/ Index 0 is unused\n+    switch (cp->tag_at(cp_index).value()) {\n+    case JVM_CONSTANT_String:\n+      resolve_string(cp, cp_index, CHECK); \/\/ may throw OOM when interning strings.\n+      break;\n+    }\n+  }\n+}\n+\n+\/\/ This works only for the boot\/platform\/app loaders\n+Klass* AOTConstantPoolResolver::find_loaded_class(Thread* current, oop class_loader, Symbol* name) {\n+  HandleMark hm(current);\n+  Handle h_loader(current, class_loader);\n+  Klass* k = SystemDictionary::find_instance_or_array_klass(current, name,\n+                                                            h_loader,\n+                                                            Handle());\n+  if (k != nullptr) {\n+    return k;\n+  }\n+  if (h_loader() == SystemDictionary::java_system_loader()) {\n+    return find_loaded_class(current, SystemDictionary::java_platform_loader(), name);\n+  } else if (h_loader() == SystemDictionary::java_platform_loader()) {\n+    return find_loaded_class(current, nullptr, name);\n+  } else {\n+    assert(h_loader() == nullptr, \"This function only works for boot\/platform\/app loaders %p %p %p\",\n+           cast_from_oop<address>(h_loader()),\n+           cast_from_oop<address>(SystemDictionary::java_system_loader()),\n+           cast_from_oop<address>(SystemDictionary::java_platform_loader()));\n+  }\n+\n+  return nullptr;\n+}\n+\n+Klass* AOTConstantPoolResolver::find_loaded_class(Thread* current, ConstantPool* cp, int class_cp_index) {\n+  Symbol* name = cp->klass_name_at(class_cp_index);\n+  return find_loaded_class(current, cp->pool_holder()->class_loader(), name);\n+}\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+void AOTConstantPoolResolver::resolve_string(constantPoolHandle cp, int cp_index, TRAPS) {\n+  if (CDSConfig::is_dumping_heap()) {\n+    int cache_index = cp->cp_to_object_index(cp_index);\n+    ConstantPool::string_at_impl(cp, cp_index, cache_index, CHECK);\n+  }\n+}\n+#endif\n+\n+void AOTConstantPoolResolver::preresolve_class_cp_entries(JavaThread* current, InstanceKlass* ik, GrowableArray<bool>* preresolve_list) {\n+  if (!SystemDictionaryShared::is_builtin_loader(ik->class_loader_data())) {\n+    return;\n+  }\n+\n+  JavaThread* THREAD = current;\n+  constantPoolHandle cp(THREAD, ik->constants());\n+  for (int cp_index = 1; cp_index < cp->length(); cp_index++) {\n+    if (cp->tag_at(cp_index).value() == JVM_CONSTANT_UnresolvedClass) {\n+      if (preresolve_list != nullptr && preresolve_list->at(cp_index) == false) {\n+        \/\/ This class was not resolved during trial run. Don't attempt to resolve it. Otherwise\n+        \/\/ the compiler may generate less efficient code.\n+        continue;\n+      }\n+      if (find_loaded_class(current, cp(), cp_index) == nullptr) {\n+        \/\/ Do not resolve any class that has not been loaded yet\n+        continue;\n+      }\n+      Klass* resolved_klass = cp->klass_at(cp_index, THREAD);\n+      if (HAS_PENDING_EXCEPTION) {\n+        CLEAR_PENDING_EXCEPTION; \/\/ just ignore\n+      } else {\n+        log_trace(cds, resolve)(\"Resolved class  [%3d] %s -> %s\", cp_index, ik->external_name(),\n+                                resolved_klass->external_name());\n+      }\n+    }\n+  }\n+}\n+\n+void AOTConstantPoolResolver::preresolve_field_and_method_cp_entries(JavaThread* current, InstanceKlass* ik, GrowableArray<bool>* preresolve_list) {\n+  JavaThread* THREAD = current;\n+  constantPoolHandle cp(THREAD, ik->constants());\n+  if (cp->cache() == nullptr) {\n+    return;\n+  }\n+  for (int i = 0; i < ik->methods()->length(); i++) {\n+    Method* m = ik->methods()->at(i);\n+    BytecodeStream bcs(methodHandle(THREAD, m));\n+    while (!bcs.is_last_bytecode()) {\n+      bcs.next();\n+      Bytecodes::Code raw_bc = bcs.raw_code();\n+      switch (raw_bc) {\n+      case Bytecodes::_getfield:\n+      case Bytecodes::_putfield:\n+        maybe_resolve_fmi_ref(ik, m, raw_bc, bcs.get_index_u2(), preresolve_list, THREAD);\n+        if (HAS_PENDING_EXCEPTION) {\n+          CLEAR_PENDING_EXCEPTION; \/\/ just ignore\n+        }\n+        break;\n+      case Bytecodes::_invokespecial:\n+      case Bytecodes::_invokevirtual:\n+      case Bytecodes::_invokeinterface:\n+        maybe_resolve_fmi_ref(ik, m, raw_bc, bcs.get_index_u2(), preresolve_list, THREAD);\n+        if (HAS_PENDING_EXCEPTION) {\n+          CLEAR_PENDING_EXCEPTION; \/\/ just ignore\n+        }\n+        break;\n+      default:\n+        break;\n+      }\n+    }\n+  }\n+}\n+\n+void AOTConstantPoolResolver::maybe_resolve_fmi_ref(InstanceKlass* ik, Method* m, Bytecodes::Code bc, int raw_index,\n+                                           GrowableArray<bool>* preresolve_list, TRAPS) {\n+  methodHandle mh(THREAD, m);\n+  constantPoolHandle cp(THREAD, ik->constants());\n+  HandleMark hm(THREAD);\n+  int cp_index = cp->to_cp_index(raw_index, bc);\n+\n+  if (cp->is_resolved(raw_index, bc)) {\n+    return;\n+  }\n+\n+  if (preresolve_list != nullptr && preresolve_list->at(cp_index) == false) {\n+    \/\/ This field wasn't resolved during the trial run. Don't attempt to resolve it. Otherwise\n+    \/\/ the compiler may generate less efficient code.\n+    return;\n+  }\n+\n+  int klass_cp_index = cp->uncached_klass_ref_index_at(cp_index);\n+  if (find_loaded_class(THREAD, cp(), klass_cp_index) == nullptr) {\n+    \/\/ Do not resolve any field\/methods from a class that has not been loaded yet.\n+    return;\n+  }\n+\n+  Klass* resolved_klass = cp->klass_ref_at(raw_index, bc, CHECK);\n+\n+  switch (bc) {\n+  case Bytecodes::_getfield:\n+  case Bytecodes::_putfield:\n+    InterpreterRuntime::resolve_get_put(bc, raw_index, mh, cp, false \/*initialize_holder*\/, CHECK);\n+    break;\n+\n+  case Bytecodes::_invokevirtual:\n+  case Bytecodes::_invokespecial:\n+  case Bytecodes::_invokeinterface:\n+    InterpreterRuntime::cds_resolve_invoke(bc, raw_index, cp, CHECK);\n+    break;\n+\n+  default:\n+    ShouldNotReachHere();\n+  }\n+\n+  if (log_is_enabled(Trace, cds, resolve)) {\n+    ResourceMark rm(THREAD);\n+    bool resolved = cp->is_resolved(raw_index, bc);\n+    Symbol* name = cp->name_ref_at(raw_index, bc);\n+    Symbol* signature = cp->signature_ref_at(raw_index, bc);\n+    log_trace(cds, resolve)(\"%s %s [%3d] %s -> %s.%s:%s\",\n+                            (resolved ? \"Resolved\" : \"Failed to resolve\"),\n+                            Bytecodes::name(bc), cp_index, ik->external_name(),\n+                            resolved_klass->external_name(),\n+                            name->as_C_string(), signature->as_C_string());\n+  }\n+}\n+\n+#ifdef ASSERT\n+bool AOTConstantPoolResolver::is_in_archivebuilder_buffer(address p) {\n+  if (!Thread::current()->is_VM_thread() || ArchiveBuilder::current() == nullptr) {\n+    return false;\n+  } else {\n+    return ArchiveBuilder::current()->is_in_buffer_space(p);\n+  }\n+}\n+#endif\n","filename":"src\/hotspot\/share\/cds\/aotConstantPoolResolver.cpp","additions":345,"deletions":0,"binary":false,"changes":345,"status":"added"},{"patch":"@@ -25,2 +25,2 @@\n-#ifndef SHARE_CDS_CLASSPRELINKER_HPP\n-#define SHARE_CDS_CLASSPRELINKER_HPP\n+#ifndef SHARE_CDS_AOTCONSTANTPOOLRESOLVER_HPP\n+#define SHARE_CDS_AOTCONSTANTPOOLRESOLVER_HPP\n@@ -42,1 +42,3 @@\n-\/\/ ClassPrelinker is used to perform ahead-of-time linking of ConstantPool entries\n+template <typename T> class GrowableArray;\n+\n+\/\/ AOTConstantPoolResolver is used to perform ahead-of-time linking of ConstantPool entries\n@@ -52,1 +54,1 @@\n-class ClassPrelinker :  AllStatic {\n+class AOTConstantPoolResolver :  AllStatic {\n@@ -96,1 +98,1 @@\n-#endif \/\/ SHARE_CDS_CLASSPRELINKER_HPP\n+#endif \/\/ SHARE_CDS_AOTCONSTANTPOOLRESOLVER_HPP\n","filename":"src\/hotspot\/share\/cds\/aotConstantPoolResolver.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"previous_filename":"src\/hotspot\/share\/cds\/classPrelinker.hpp","status":"renamed"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotConstantPoolResolver.hpp\"\n@@ -28,1 +29,0 @@\n-#include \"cds\/classPrelinker.hpp\"\n@@ -853,1 +853,1 @@\n-    ClassPrelinker::preresolve_class_cp_entries(THREAD, ik, &preresolve_list);\n+    AOTConstantPoolResolver::preresolve_class_cp_entries(THREAD, ik, &preresolve_list);\n@@ -856,1 +856,1 @@\n-    ClassPrelinker::preresolve_field_and_method_cp_entries(THREAD, ik, &preresolve_list);\n+    AOTConstantPoolResolver::preresolve_field_and_method_cp_entries(THREAD, ik, &preresolve_list);\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,345 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"cds\/archiveBuilder.hpp\"\n-#include \"cds\/cdsConfig.hpp\"\n-#include \"cds\/classPrelinker.hpp\"\n-#include \"cds\/regeneratedClasses.hpp\"\n-#include \"classfile\/systemDictionary.hpp\"\n-#include \"classfile\/systemDictionaryShared.hpp\"\n-#include \"classfile\/vmClasses.hpp\"\n-#include \"interpreter\/bytecodeStream.hpp\"\n-#include \"interpreter\/interpreterRuntime.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"oops\/constantPool.inline.hpp\"\n-#include \"oops\/instanceKlass.hpp\"\n-#include \"oops\/klass.inline.hpp\"\n-#include \"runtime\/handles.inline.hpp\"\n-\n-ClassPrelinker::ClassesTable* ClassPrelinker::_processed_classes = nullptr;\n-ClassPrelinker::ClassesTable* ClassPrelinker::_vm_classes = nullptr;\n-\n-bool ClassPrelinker::is_vm_class(InstanceKlass* ik) {\n-  return (_vm_classes->get(ik) != nullptr);\n-}\n-\n-void ClassPrelinker::add_one_vm_class(InstanceKlass* ik) {\n-  bool created;\n-  _vm_classes->put_if_absent(ik, &created);\n-  if (created) {\n-    InstanceKlass* super = ik->java_super();\n-    if (super != nullptr) {\n-      add_one_vm_class(super);\n-    }\n-    Array<InstanceKlass*>* ifs = ik->local_interfaces();\n-    for (int i = 0; i < ifs->length(); i++) {\n-      add_one_vm_class(ifs->at(i));\n-    }\n-  }\n-}\n-\n-void ClassPrelinker::initialize() {\n-  assert(_vm_classes == nullptr, \"must be\");\n-  _vm_classes = new (mtClass)ClassesTable();\n-  _processed_classes = new (mtClass)ClassesTable();\n-  for (auto id : EnumRange<vmClassID>{}) {\n-    add_one_vm_class(vmClasses::klass_at(id));\n-  }\n-}\n-\n-void ClassPrelinker::dispose() {\n-  assert(_vm_classes != nullptr, \"must be\");\n-  delete _vm_classes;\n-  delete _processed_classes;\n-  _vm_classes = nullptr;\n-  _processed_classes = nullptr;\n-}\n-\n-\/\/ Returns true if we CAN PROVE that cp_index will always resolve to\n-\/\/ the same information at both dump time and run time. This is a\n-\/\/ necessary (but not sufficient) condition for pre-resolving cp_index\n-\/\/ during CDS archive assembly.\n-bool ClassPrelinker::is_resolution_deterministic(ConstantPool* cp, int cp_index) {\n-  assert(!is_in_archivebuilder_buffer(cp), \"sanity\");\n-\n-  if (cp->tag_at(cp_index).is_klass()) {\n-    \/\/ We require cp_index to be already resolved. This is fine for now, are we\n-    \/\/ currently archive only CP entries that are already resolved.\n-    Klass* resolved_klass = cp->resolved_klass_at(cp_index);\n-    return resolved_klass != nullptr && is_class_resolution_deterministic(cp->pool_holder(), resolved_klass);\n-  } else if (cp->tag_at(cp_index).is_field() ||\n-             cp->tag_at(cp_index).is_method() ||\n-             cp->tag_at(cp_index).is_interface_method()) {\n-    int klass_cp_index = cp->uncached_klass_ref_index_at(cp_index);\n-    if (!cp->tag_at(klass_cp_index).is_klass()) {\n-      \/\/ Not yet resolved\n-      return false;\n-    }\n-    Klass* k = cp->resolved_klass_at(klass_cp_index);\n-    if (!is_class_resolution_deterministic(cp->pool_holder(), k)) {\n-      return false;\n-    }\n-\n-    if (!k->is_instance_klass()) {\n-      \/\/ TODO: support non instance klasses as well.\n-      return false;\n-    }\n-\n-    \/\/ Here, We don't check if this entry can actually be resolved to a valid Field\/Method.\n-    \/\/ This method should be called by the ConstantPool to check Fields\/Methods that\n-    \/\/ have already been successfully resolved.\n-    return true;\n-  } else {\n-    return false;\n-  }\n-}\n-\n-bool ClassPrelinker::is_class_resolution_deterministic(InstanceKlass* cp_holder, Klass* resolved_class) {\n-  assert(!is_in_archivebuilder_buffer(cp_holder), \"sanity\");\n-  assert(!is_in_archivebuilder_buffer(resolved_class), \"sanity\");\n-\n-  if (resolved_class->is_instance_klass()) {\n-    InstanceKlass* ik = InstanceKlass::cast(resolved_class);\n-\n-    if (!ik->is_shared() && SystemDictionaryShared::is_excluded_class(ik)) {\n-      return false;\n-    }\n-\n-    if (cp_holder->is_subtype_of(ik)) {\n-      \/\/ All super types of ik will be resolved in ik->class_loader() before\n-      \/\/ ik is defined in this loader, so it's safe to archive the resolved klass reference.\n-      return true;\n-    }\n-\n-    if (is_vm_class(ik)) {\n-      if (ik->class_loader() != cp_holder->class_loader()) {\n-        \/\/ At runtime, cp_holder() may not be able to resolve to the same\n-        \/\/ ik. For example, a different version of ik may be defined in\n-        \/\/ cp->pool_holder()'s loader using MethodHandles.Lookup.defineClass().\n-        return false;\n-      } else {\n-        return true;\n-      }\n-    }\n-  } else if (resolved_class->is_objArray_klass()) {\n-    Klass* elem = ObjArrayKlass::cast(resolved_class)->bottom_klass();\n-    if (elem->is_instance_klass()) {\n-      return is_class_resolution_deterministic(cp_holder, InstanceKlass::cast(elem));\n-    } else if (elem->is_typeArray_klass()) {\n-      return true;\n-    }\n-  } else if (resolved_class->is_typeArray_klass()) {\n-    return true;\n-  }\n-\n-  return false;\n-}\n-\n-void ClassPrelinker::dumptime_resolve_constants(InstanceKlass* ik, TRAPS) {\n-  if (!ik->is_linked()) {\n-    return;\n-  }\n-  bool first_time;\n-  _processed_classes->put_if_absent(ik, &first_time);\n-  if (!first_time) {\n-    \/\/ We have already resolved the constants in class, so no need to do it again.\n-    return;\n-  }\n-\n-  constantPoolHandle cp(THREAD, ik->constants());\n-  for (int cp_index = 1; cp_index < cp->length(); cp_index++) { \/\/ Index 0 is unused\n-    switch (cp->tag_at(cp_index).value()) {\n-    case JVM_CONSTANT_String:\n-      resolve_string(cp, cp_index, CHECK); \/\/ may throw OOM when interning strings.\n-      break;\n-    }\n-  }\n-}\n-\n-\/\/ This works only for the boot\/platform\/app loaders\n-Klass* ClassPrelinker::find_loaded_class(Thread* current, oop class_loader, Symbol* name) {\n-  HandleMark hm(current);\n-  Handle h_loader(current, class_loader);\n-  Klass* k = SystemDictionary::find_instance_or_array_klass(current, name,\n-                                                            h_loader,\n-                                                            Handle());\n-  if (k != nullptr) {\n-    return k;\n-  }\n-  if (h_loader() == SystemDictionary::java_system_loader()) {\n-    return find_loaded_class(current, SystemDictionary::java_platform_loader(), name);\n-  } else if (h_loader() == SystemDictionary::java_platform_loader()) {\n-    return find_loaded_class(current, nullptr, name);\n-  } else {\n-    assert(h_loader() == nullptr, \"This function only works for boot\/platform\/app loaders %p %p %p\",\n-           cast_from_oop<address>(h_loader()),\n-           cast_from_oop<address>(SystemDictionary::java_system_loader()),\n-           cast_from_oop<address>(SystemDictionary::java_platform_loader()));\n-  }\n-\n-  return nullptr;\n-}\n-\n-Klass* ClassPrelinker::find_loaded_class(Thread* current, ConstantPool* cp, int class_cp_index) {\n-  Symbol* name = cp->klass_name_at(class_cp_index);\n-  return find_loaded_class(current, cp->pool_holder()->class_loader(), name);\n-}\n-\n-#if INCLUDE_CDS_JAVA_HEAP\n-void ClassPrelinker::resolve_string(constantPoolHandle cp, int cp_index, TRAPS) {\n-  if (CDSConfig::is_dumping_heap()) {\n-    int cache_index = cp->cp_to_object_index(cp_index);\n-    ConstantPool::string_at_impl(cp, cp_index, cache_index, CHECK);\n-  }\n-}\n-#endif\n-\n-void ClassPrelinker::preresolve_class_cp_entries(JavaThread* current, InstanceKlass* ik, GrowableArray<bool>* preresolve_list) {\n-  if (!SystemDictionaryShared::is_builtin_loader(ik->class_loader_data())) {\n-    return;\n-  }\n-\n-  JavaThread* THREAD = current;\n-  constantPoolHandle cp(THREAD, ik->constants());\n-  for (int cp_index = 1; cp_index < cp->length(); cp_index++) {\n-    if (cp->tag_at(cp_index).value() == JVM_CONSTANT_UnresolvedClass) {\n-      if (preresolve_list != nullptr && preresolve_list->at(cp_index) == false) {\n-        \/\/ This class was not resolved during trial run. Don't attempt to resolve it. Otherwise\n-        \/\/ the compiler may generate less efficient code.\n-        continue;\n-      }\n-      if (find_loaded_class(current, cp(), cp_index) == nullptr) {\n-        \/\/ Do not resolve any class that has not been loaded yet\n-        continue;\n-      }\n-      Klass* resolved_klass = cp->klass_at(cp_index, THREAD);\n-      if (HAS_PENDING_EXCEPTION) {\n-        CLEAR_PENDING_EXCEPTION; \/\/ just ignore\n-      } else {\n-        log_trace(cds, resolve)(\"Resolved class  [%3d] %s -> %s\", cp_index, ik->external_name(),\n-                                resolved_klass->external_name());\n-      }\n-    }\n-  }\n-}\n-\n-void ClassPrelinker::preresolve_field_and_method_cp_entries(JavaThread* current, InstanceKlass* ik, GrowableArray<bool>* preresolve_list) {\n-  JavaThread* THREAD = current;\n-  constantPoolHandle cp(THREAD, ik->constants());\n-  if (cp->cache() == nullptr) {\n-    return;\n-  }\n-  for (int i = 0; i < ik->methods()->length(); i++) {\n-    Method* m = ik->methods()->at(i);\n-    BytecodeStream bcs(methodHandle(THREAD, m));\n-    while (!bcs.is_last_bytecode()) {\n-      bcs.next();\n-      Bytecodes::Code raw_bc = bcs.raw_code();\n-      switch (raw_bc) {\n-      case Bytecodes::_getfield:\n-      case Bytecodes::_putfield:\n-        maybe_resolve_fmi_ref(ik, m, raw_bc, bcs.get_index_u2(), preresolve_list, THREAD);\n-        if (HAS_PENDING_EXCEPTION) {\n-          CLEAR_PENDING_EXCEPTION; \/\/ just ignore\n-        }\n-        break;\n-      case Bytecodes::_invokespecial:\n-      case Bytecodes::_invokevirtual:\n-      case Bytecodes::_invokeinterface:\n-        maybe_resolve_fmi_ref(ik, m, raw_bc, bcs.get_index_u2(), preresolve_list, THREAD);\n-        if (HAS_PENDING_EXCEPTION) {\n-          CLEAR_PENDING_EXCEPTION; \/\/ just ignore\n-        }\n-        break;\n-      default:\n-        break;\n-      }\n-    }\n-  }\n-}\n-\n-void ClassPrelinker::maybe_resolve_fmi_ref(InstanceKlass* ik, Method* m, Bytecodes::Code bc, int raw_index,\n-                                           GrowableArray<bool>* preresolve_list, TRAPS) {\n-  methodHandle mh(THREAD, m);\n-  constantPoolHandle cp(THREAD, ik->constants());\n-  HandleMark hm(THREAD);\n-  int cp_index = cp->to_cp_index(raw_index, bc);\n-\n-  if (cp->is_resolved(raw_index, bc)) {\n-    return;\n-  }\n-\n-  if (preresolve_list != nullptr && preresolve_list->at(cp_index) == false) {\n-    \/\/ This field wasn't resolved during the trial run. Don't attempt to resolve it. Otherwise\n-    \/\/ the compiler may generate less efficient code.\n-    return;\n-  }\n-\n-  int klass_cp_index = cp->uncached_klass_ref_index_at(cp_index);\n-  if (find_loaded_class(THREAD, cp(), klass_cp_index) == nullptr) {\n-    \/\/ Do not resolve any field\/methods from a class that has not been loaded yet.\n-    return;\n-  }\n-\n-  Klass* resolved_klass = cp->klass_ref_at(raw_index, bc, CHECK);\n-\n-  switch (bc) {\n-  case Bytecodes::_getfield:\n-  case Bytecodes::_putfield:\n-    InterpreterRuntime::resolve_get_put(bc, raw_index, mh, cp, false \/*initialize_holder*\/, CHECK);\n-    break;\n-\n-  case Bytecodes::_invokevirtual:\n-  case Bytecodes::_invokespecial:\n-  case Bytecodes::_invokeinterface:\n-    InterpreterRuntime::cds_resolve_invoke(bc, raw_index, cp, CHECK);\n-    break;\n-\n-  default:\n-    ShouldNotReachHere();\n-  }\n-\n-  if (log_is_enabled(Trace, cds, resolve)) {\n-    ResourceMark rm(THREAD);\n-    bool resolved = cp->is_resolved(raw_index, bc);\n-    Symbol* name = cp->name_ref_at(raw_index, bc);\n-    Symbol* signature = cp->signature_ref_at(raw_index, bc);\n-    log_trace(cds, resolve)(\"%s %s [%3d] %s -> %s.%s:%s\",\n-                            (resolved ? \"Resolved\" : \"Failed to resolve\"),\n-                            Bytecodes::name(bc), cp_index, ik->external_name(),\n-                            resolved_klass->external_name(),\n-                            name->as_C_string(), signature->as_C_string());\n-  }\n-}\n-\n-#ifdef ASSERT\n-bool ClassPrelinker::is_in_archivebuilder_buffer(address p) {\n-  if (!Thread::current()->is_VM_thread() || ArchiveBuilder::current() == nullptr) {\n-    return false;\n-  } else {\n-    return ArchiveBuilder::current()->is_in_buffer_space(p);\n-  }\n-}\n-#endif\n","filename":"src\/hotspot\/share\/cds\/classPrelinker.cpp","additions":0,"deletions":345,"binary":false,"changes":345,"status":"deleted"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotConstantPoolResolver.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"cds\/classPrelinker.hpp\"\n@@ -237,1 +237,1 @@\n-  ClassPrelinker::dispose();\n+  AOTConstantPoolResolver::dispose();\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotConstantPoolResolver.hpp\"\n@@ -35,1 +36,0 @@\n-#include \"cds\/classPrelinker.hpp\"\n@@ -607,1 +607,1 @@\n-  ClassPrelinker::dumptime_resolve_constants(ik, CHECK_(false));\n+  AOTConstantPoolResolver::dumptime_resolve_constants(ik, CHECK_(false));\n@@ -612,1 +612,1 @@\n-  ClassPrelinker::initialize();\n+  AOTConstantPoolResolver::initialize();\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-  \/\/ Used by ClassPrelinker\n+  \/\/ Used by AOTConstantPoolResolver\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotConstantPoolResolver.hpp\"\n@@ -30,1 +31,0 @@\n-#include \"cds\/classPrelinker.hpp\"\n@@ -485,1 +485,1 @@\n-    can_archive = ClassPrelinker::is_resolution_deterministic(src_cp, cp_index);\n+    can_archive = AOTConstantPoolResolver::is_resolution_deterministic(src_cp, cp_index);\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-  friend class ClassPrelinker;       \/\/ CDS\n+  friend class AOTConstantPoolResolver;\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotConstantPoolResolver.hpp\"\n@@ -28,1 +29,0 @@\n-#include \"cds\/classPrelinker.hpp\"\n@@ -425,1 +425,1 @@\n-    if (resolved && ClassPrelinker::is_resolution_deterministic(src_cp, cp_index)) {\n+    if (resolved && AOTConstantPoolResolver::is_resolution_deterministic(src_cp, cp_index)) {\n@@ -526,1 +526,1 @@\n-  if (!ClassPrelinker::is_resolution_deterministic(src_cp, cp_index)) {\n+  if (!AOTConstantPoolResolver::is_resolution_deterministic(src_cp, cp_index)) {\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}