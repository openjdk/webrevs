{"files":[{"patch":"@@ -239,1 +239,1 @@\n-          \/\/ The waiting thread timed out and thus did not free the task.\n+          \/\/ The waiting thread timed out and thus did not delete the task.\n@@ -252,2 +252,2 @@\n-      \/\/ The task can only be freed once the task lock is released.\n-      CompileTask::free(task);\n+      \/\/ The task can only be deleted once the task lock is released.\n+      delete task;\n@@ -258,3 +258,3 @@\n-    \/\/ By convention, the compiling thread is responsible for\n-    \/\/ recycling a non-blocking CompileTask.\n-    CompileTask::free(task);\n+    \/\/ By convention, the compiling thread is responsible for deleting\n+    \/\/ a non-blocking CompileTask.\n+    delete task;\n@@ -363,3 +363,3 @@\n- * Empties compilation queue by putting all compilation tasks onto\n- * a freelist. Furthermore, the method wakes up all threads that are\n- * waiting on a compilation task to finish. This can happen if background\n+ * Empties compilation queue by deleting all compilation tasks.\n+ * Furthermore, the method wakes up all threads that are waiting\n+ * on a compilation task to finish. This can happen if background\n@@ -368,1 +368,1 @@\n-void CompileQueue::free_all() {\n+void CompileQueue::delete_all() {\n@@ -388,5 +388,4 @@\n-      \/\/ If no one was waiting for this task, we need to free it ourselves. In this case, the task\n-      \/\/ is also certainly unlocked, because, again, there is no waiter.\n-      \/\/ Otherwise, by convention, it's the waiters responsibility to free the task.\n-      \/\/ Put the task back on the freelist.\n-      CompileTask::free(current);\n+      \/\/ If no one was waiting for this task, we need to delete it ourselves.\n+      \/\/ In this case, the task is also certainly unlocked, because, again, there is no waiter.\n+      \/\/ Otherwise, by convention, it's the waiters responsibility to delete the task.\n+      delete current;\n@@ -1630,4 +1629,2 @@\n-  CompileTask* new_task = CompileTask::allocate();\n-  new_task->initialize(compile_id, method, osr_bci, comp_level,\n-                       hot_count, compile_reason,\n-                       blocking);\n+  CompileTask* new_task = new CompileTask(compile_id, method, osr_bci, comp_level,\n+                                          hot_count, compile_reason, blocking);\n@@ -1654,1 +1651,1 @@\n- * @return true if this thread needs to free\/recycle the task\n+ * @return true if this thread needs to delete the task\n@@ -1737,1 +1734,1 @@\n-      CompileTask::free(task);\n+      delete task;\n@@ -1742,1 +1739,1 @@\n-    \/\/ completion is a stable property (until the task object is recycled).\n+    \/\/ completion is a stable property (until the task object is deleted).\n@@ -1745,1 +1742,1 @@\n-    \/\/ By convention, the waiter is responsible for recycling a\n+    \/\/ By convention, the waiter is responsible for deleting a\n@@ -1748,2 +1745,2 @@\n-    \/\/ be using this CompileTask; we can free it.\n-    CompileTask::free(task);\n+    \/\/ be using this CompileTask; we can delete it.\n+    delete task;\n@@ -1830,1 +1827,1 @@\n-      _c1_compile_queue->free_all();\n+      _c1_compile_queue->delete_all();\n@@ -1834,1 +1831,1 @@\n-      _c2_compile_queue->free_all();\n+      _c2_compile_queue->delete_all();\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":24,"deletions":27,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-  void free_all();\n+  void delete_all();\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-CompileTask*  CompileTask::_task_free_list = nullptr;\n@@ -42,63 +41,7 @@\n-\/**\n- * Allocate a CompileTask, from the free list if possible.\n- *\/\n-CompileTask* CompileTask::allocate() {\n-  MonitorLocker locker(CompileTaskAlloc_lock);\n-  CompileTask* task = nullptr;\n-\n-  if (_task_free_list != nullptr) {\n-    task = _task_free_list;\n-    _task_free_list = task->next();\n-    task->set_next(nullptr);\n-  } else {\n-    task = new CompileTask();\n-    task->set_next(nullptr);\n-    task->set_is_free(true);\n-  }\n-  assert(task->is_free(), \"Task must be free.\");\n-  task->set_is_free(false);\n-  _active_tasks++;\n-  return task;\n-}\n-\n-\/**\n-* Add a task to the free list.\n-*\/\n-void CompileTask::free(CompileTask* task) {\n-  MonitorLocker locker(CompileTaskAlloc_lock);\n-  if (!task->is_free()) {\n-    if ((task->_method_holder != nullptr && JNIHandles::is_weak_global_handle(task->_method_holder))) {\n-      JNIHandles::destroy_weak_global(task->_method_holder);\n-    } else {\n-      JNIHandles::destroy_global(task->_method_holder);\n-    }\n-    if (task->_failure_reason_on_C_heap && task->_failure_reason != nullptr) {\n-      os::free((void*) task->_failure_reason);\n-    }\n-    task->_failure_reason = nullptr;\n-    task->_failure_reason_on_C_heap = false;\n-\n-    task->set_is_free(true);\n-    task->set_next(_task_free_list);\n-    _task_free_list = task;\n-    _active_tasks--;\n-    if (_active_tasks == 0) {\n-      locker.notify_all();\n-    }\n-  }\n-}\n-\n-void CompileTask::wait_for_no_active_tasks() {\n-  MonitorLocker locker(CompileTaskAlloc_lock);\n-  while (_active_tasks > 0) {\n-    locker.wait();\n-  }\n-}\n-\n-void CompileTask::initialize(int compile_id,\n-                             const methodHandle& method,\n-                             int osr_bci,\n-                             int comp_level,\n-                             int hot_count,\n-                             CompileTask::CompileReason compile_reason,\n-                             bool is_blocking) {\n+CompileTask::CompileTask(int compile_id,\n+                         const methodHandle& method,\n+                         int osr_bci,\n+                         int comp_level,\n+                         int hot_count,\n+                         CompileReason compile_reason,\n+                         bool is_blocking) {\n@@ -136,0 +79,27 @@\n+\n+  Atomic::add(&_active_tasks, 1, memory_order_relaxed);\n+}\n+\n+CompileTask::~CompileTask() {\n+  if (_method_holder != nullptr && JNIHandles::is_weak_global_handle(_method_holder)) {\n+    JNIHandles::destroy_weak_global(_method_holder);\n+  } else {\n+    JNIHandles::destroy_global(_method_holder);\n+  }\n+  if (_failure_reason_on_C_heap && _failure_reason != nullptr) {\n+    os::free((void*) _failure_reason);\n+    _failure_reason = nullptr;\n+    _failure_reason_on_C_heap = false;\n+  }\n+\n+  if (Atomic::sub(&_active_tasks, 1, memory_order_relaxed) == 0) {\n+    MonitorLocker wait_ml(CompileTaskWait_lock);\n+    wait_ml.notify_all();\n+  }\n+}\n+\n+void CompileTask::wait_for_no_active_tasks() {\n+  MonitorLocker locker(CompileTaskWait_lock);\n+  while (Atomic::load(&_active_tasks) > 0) {\n+    locker.wait();\n+  }\n","filename":"src\/hotspot\/share\/compiler\/compileTask.cpp","additions":34,"deletions":64,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -85,1 +85,0 @@\n-  static CompileTask*  _task_free_list;\n@@ -107,1 +106,0 @@\n-  bool                 _is_free;\n@@ -120,8 +118,4 @@\n-  CompileTask() : _failure_reason(nullptr), _failure_reason_on_C_heap(false) {}\n-  void initialize(int compile_id, const methodHandle& method, int osr_bci, int comp_level,\n-                  int hot_count,\n-                  CompileTask::CompileReason compile_reason, bool is_blocking);\n-\n-  static CompileTask* allocate();\n-  static void         free(CompileTask* task);\n-  static void         wait_for_no_active_tasks();\n+  CompileTask(int compile_id, const methodHandle& method, int osr_bci, int comp_level,\n+              int hot_count, CompileReason compile_reason, bool is_blocking);\n+  ~CompileTask();\n+  static void wait_for_no_active_tasks();\n@@ -209,2 +203,0 @@\n-  bool         is_free() const                   { return _is_free; }\n-  void         set_is_free(bool val)             { _is_free = val; }\n","filename":"src\/hotspot\/share\/compiler\/compileTask.hpp","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -87,1 +87,0 @@\n-Monitor* CompileTaskAlloc_lock        = nullptr;\n@@ -349,1 +348,0 @@\n-  MUTEX_DEFL(CompileTaskAlloc_lock          , PaddedMonitor, MethodCompileQueue_lock);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -89,1 +89,0 @@\n-extern Monitor* CompileTaskAlloc_lock;           \/\/ a lock held when CompileTasks are allocated\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}