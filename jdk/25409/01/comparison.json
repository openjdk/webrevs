{"files":[{"patch":"@@ -238,1 +238,1 @@\n-          \/\/ The waiting thread timed out and thus did not free the task.\n+          \/\/ The waiting thread timed out and thus did not delete the task.\n@@ -251,2 +251,2 @@\n-      \/\/ The task can only be freed once the task lock is released.\n-      CompileTask::free(task);\n+      \/\/ The task can only be deleted once the task lock is released.\n+      delete task;\n@@ -257,3 +257,3 @@\n-    \/\/ By convention, the compiling thread is responsible for\n-    \/\/ recycling a non-blocking CompileTask.\n-    CompileTask::free(task);\n+    \/\/ By convention, the compiling thread is responsible for deleting\n+    \/\/ a non-blocking CompileTask.\n+    delete task;\n@@ -355,3 +355,3 @@\n- * Empties compilation queue by putting all compilation tasks onto\n- * a freelist. Furthermore, the method wakes up all threads that are\n- * waiting on a compilation task to finish. This can happen if background\n+ * Empties compilation queue by deleting all compilation tasks.\n+ * Furthermore, the method wakes up all threads that are waiting\n+ * on a compilation task to finish. This can happen if background\n@@ -360,1 +360,1 @@\n-void CompileQueue::free_all() {\n+void CompileQueue::delete_all() {\n@@ -374,1 +374,1 @@\n-        \/\/ so they will stop waiting and free the task.\n+        \/\/ so they will stop waiting and delete the task.\n@@ -380,5 +380,4 @@\n-      \/\/ If no one was waiting for this task, we need to free it ourselves. In this case, the task\n-      \/\/ is also certainly unlocked, because, again, there is no waiter.\n-      \/\/ Otherwise, by convention, it's the waiters responsibility to free the task.\n-      \/\/ Put the task back on the freelist.\n-      CompileTask::free(current);\n+      \/\/ If no one was waiting for this task, we need to delete it ourselves.\n+      \/\/ In this case, the task is also certainly unlocked, because, again, there is no waiter.\n+      \/\/ Otherwise, by convention, it's the waiters responsibility to delete the task.\n+      delete current;\n@@ -1605,4 +1604,2 @@\n-  CompileTask* new_task = CompileTask::allocate();\n-  new_task->initialize(compile_id, method, osr_bci, comp_level,\n-                       hot_count, compile_reason,\n-                       blocking);\n+  CompileTask* new_task = new CompileTask(compile_id, method, osr_bci, comp_level,\n+                                          hot_count, compile_reason, blocking);\n@@ -1629,1 +1626,1 @@\n- * @return true if this thread needs to free\/recycle the task\n+ * @return true if this thread needs to delete the task\n@@ -1712,1 +1709,1 @@\n-      CompileTask::free(task);\n+      delete task;\n@@ -1717,1 +1714,1 @@\n-    \/\/ completion is a stable property (until the task object is recycled).\n+    \/\/ completion is a stable property (until the task object is deleted).\n@@ -1720,1 +1717,1 @@\n-    \/\/ By convention, the waiter is responsible for recycling a\n+    \/\/ By convention, the waiter is responsible for deleting a\n@@ -1723,2 +1720,2 @@\n-    \/\/ be using this CompileTask; we can free it.\n-    CompileTask::free(task);\n+    \/\/ be using this CompileTask; we can delete it.\n+    delete task;\n@@ -1801,1 +1798,1 @@\n-      _c1_compile_queue->free_all();\n+      _c1_compile_queue->delete_all();\n@@ -1805,1 +1802,1 @@\n-      _c2_compile_queue->free_all();\n+      _c2_compile_queue->delete_all();\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":25,"deletions":28,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-  void free_all();\n+  void delete_all();\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,55 +39,8 @@\n-CompileTask*  CompileTask::_task_free_list = nullptr;\n-\n-\/**\n- * Allocate a CompileTask, from the free list if possible.\n- *\/\n-CompileTask* CompileTask::allocate() {\n-  MutexLocker locker(CompileTaskAlloc_lock);\n-  CompileTask* task = nullptr;\n-\n-  if (_task_free_list != nullptr) {\n-    task = _task_free_list;\n-    _task_free_list = task->next();\n-    task->set_next(nullptr);\n-  } else {\n-    task = new CompileTask();\n-    task->set_next(nullptr);\n-    task->set_is_free(true);\n-  }\n-  assert(task->is_free(), \"Task must be free.\");\n-  task->set_is_free(false);\n-  return task;\n-}\n-\n-\/**\n-* Add a task to the free list.\n-*\/\n-void CompileTask::free(CompileTask* task) {\n-  MutexLocker locker(CompileTaskAlloc_lock);\n-  if (!task->is_free()) {\n-    assert(!task->lock()->is_locked(), \"Should not be locked when freed\");\n-    if ((task->_method_holder != nullptr && JNIHandles::is_weak_global_handle(task->_method_holder))) {\n-      JNIHandles::destroy_weak_global(task->_method_holder);\n-    } else {\n-      JNIHandles::destroy_global(task->_method_holder);\n-    }\n-    if (task->_failure_reason_on_C_heap && task->_failure_reason != nullptr) {\n-      os::free((void*) task->_failure_reason);\n-    }\n-    task->_failure_reason = nullptr;\n-    task->_failure_reason_on_C_heap = false;\n-\n-    task->set_is_free(true);\n-    task->set_next(_task_free_list);\n-    _task_free_list = task;\n-  }\n-}\n-\n-void CompileTask::initialize(int compile_id,\n-                             const methodHandle& method,\n-                             int osr_bci,\n-                             int comp_level,\n-                             int hot_count,\n-                             CompileTask::CompileReason compile_reason,\n-                             bool is_blocking) {\n-  assert(!_lock->is_locked(), \"bad locking\");\n+CompileTask::CompileTask(int compile_id,\n+                         const methodHandle& method,\n+                         int osr_bci,\n+                         int comp_level,\n+                         int hot_count,\n+                         CompileReason compile_reason,\n+                         bool is_blocking) {\n+  _lock = new Monitor(Mutex::safepoint-1, \"CompileTask_lock\");\n@@ -127,0 +80,16 @@\n+CompileTask::~CompileTask() {\n+  assert(!_lock->is_locked(), \"Should not be locked when freed\");\n+  delete _lock;\n+\n+  if ((_method_holder != nullptr && JNIHandles::is_weak_global_handle(_method_holder))) {\n+    JNIHandles::destroy_weak_global(_method_holder);\n+  } else {\n+    JNIHandles::destroy_global(_method_holder);\n+  }\n+  if (_failure_reason_on_C_heap && _failure_reason != nullptr) {\n+    os::free((void*) _failure_reason);\n+    _failure_reason = nullptr;\n+    _failure_reason_on_C_heap = false;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/compiler\/compileTask.cpp","additions":24,"deletions":55,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -83,1 +83,0 @@\n-  static CompileTask*  _task_free_list;\n@@ -105,1 +104,0 @@\n-  bool                 _is_free;\n@@ -117,11 +115,3 @@\n-  CompileTask() : _failure_reason(nullptr), _failure_reason_on_C_heap(false) {\n-    \/\/ May hold MethodCompileQueue_lock\n-    _lock = new Monitor(Mutex::safepoint-1, \"CompileTask_lock\");\n-  }\n-\n-  void initialize(int compile_id, const methodHandle& method, int osr_bci, int comp_level,\n-                  int hot_count,\n-                  CompileTask::CompileReason compile_reason, bool is_blocking);\n-\n-  static CompileTask* allocate();\n-  static void         free(CompileTask* task);\n+  CompileTask(int compile_id, const methodHandle& method, int osr_bci, int comp_level,\n+              int hot_count, CompileReason compile_reason, bool is_blocking);\n+  ~CompileTask();\n@@ -211,2 +201,0 @@\n-  bool         is_free() const                   { return _is_free; }\n-  void         set_is_free(bool val)             { _is_free = val; }\n","filename":"src\/hotspot\/share\/compiler\/compileTask.hpp","additions":3,"deletions":15,"binary":false,"changes":18,"status":"modified"}]}