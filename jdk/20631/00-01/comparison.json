{"files":[{"patch":"@@ -70,0 +70,2 @@\n+    \/\/ the starting 3 or 5 bits of the domain separator and 10*1 padding\n+    \/\/ (11111... for the SHAKE functions and 011... for the SHA3-nnn ones)\n@@ -71,0 +73,2 @@\n+\n+    \/\/ the stae matrix flattened into an array\n@@ -72,1 +76,9 @@\n-    private int squeezeOffset = -1;\n+\n+    \/\/ The byte offset in the state where the next sqeeze() will start.\n+    \/\/ -1 indicates that either we are in the absorbing phase (only\n+    \/\/ update() calls were made so far)\n+    \/\/ The first squeeze() call (after a possibly empty sequence of update()\n+    \/\/ calls) will set it to 0 at its start.\n+    \/\/ When a squeeze() call uses up all available bytes from this state\n+    \/\/ and so a new keccak() call is made, squeezeOffset is reset to 0.\n+    protected int squeezeOffset = -1;\n@@ -123,0 +135,2 @@\n+        \/\/ Moving this allocation to the block where t is used causes a little\n+        \/\/ performance drop, that is why it is here.\n@@ -142,1 +156,1 @@\n-        int numLongs = (numBytes + 7) \/ 8;\n+        int numLongs = numBytes \/ 8;\n@@ -144,1 +158,1 @@\n-        for (int i = 0; i < numLongs - 1; i++) {\n+        for (int i = 0; i < numLongs; i++) {\n@@ -148,6 +162,3 @@\n-        if (numBytes == numLongs * 8) {\n-            asLittleEndian.set(out, ofs, state[numLongs - 1]);\n-        } else {\n-            asLittleEndian.set(byteState, 0, state[numLongs - 1]);\n-            System.arraycopy(byteState, 0,\n-                    out, ofs, numBytes - (numLongs - 1) * 8);\n+        if (numBytes % 8 != 0) {\n+            asLittleEndian.set(byteState, 0, state[numLongs]);\n+            System.arraycopy(byteState, 0, out, ofs, numBytes % 8);\n@@ -158,0 +169,2 @@\n+        \/\/ Moving this allocation to the block where t is used causes a little\n+        \/\/ performance drop, that is why it is here.\n@@ -171,6 +184,0 @@\n-        if (availableBytes == 0) {\n-            keccak();\n-            squeezeOffset = 0;\n-            availableBytes = blockSize;\n-        }\n-\n@@ -210,0 +217,2 @@\n+\n+            if (numBytes == 0) return;\n@@ -431,18 +440,3 @@\n-\n-    \/*\n-     * The SHAKE128 extendable output function.\n-     *\/\n-    public static final class SHAKE128 extends SHA3 {\n-        \/\/ d is the required number of output bytes.\n-        \/\/ If this constructor is used with d > 0, the squeezing methods\n-        \/\/ will throw a ProviderException.\n-        public SHAKE128(int d) {\n-            super(\"SHAKE128\", d, (byte) 0x1F, 32);\n-        }\n-\n-        \/\/ If this constructor is used to get an instance of the class, then,\n-        \/\/ after the last update, one can get the generated bytes using the\n-        \/\/ squeezing methods.\n-        \/\/ Calling digest method will throw a ProviderException.\n-        public SHAKE128() {\n-            super(\"SHAKE128\", 0, (byte) 0x1F, 32);\n+    public static abstract class SHA3XOF extends SHA3 {\n+        public SHA3XOF(String name, int digestLength, byte offset, int c) {\n+            super(name, digestLength, offset, c);\n@@ -450,1 +444,0 @@\n-\n@@ -452,0 +445,3 @@\n+            if (squeezeOffset  != -1) {\n+                throw new ProviderException(\"update() after squeeze() is not allowed.\");\n+            }\n@@ -455,0 +451,3 @@\n+            if (squeezeOffset  != -1) {\n+                throw new ProviderException(\"update() after squeeze() is not allowed.\");\n+            }\n@@ -459,0 +458,3 @@\n+            if (squeezeOffset  != -1) {\n+                throw new ProviderException(\"update() after squeeze() is not allowed.\");\n+            }\n@@ -477,0 +479,21 @@\n+\n+    \/*\n+     * The SHAKE128 extendable output function.\n+     *\/\n+    public static final class SHAKE128 extends SHA3XOF {\n+        \/\/ d is the required number of output bytes.\n+        \/\/ If this constructor is used with d > 0, the squeezing methods\n+        \/\/ will throw a ProviderException.\n+        public SHAKE128(int d) {\n+            super(\"SHAKE128\", d, (byte) 0x1F, 32);\n+        }\n+\n+        \/\/ If this constructor is used to get an instance of the class, then,\n+        \/\/ after the last update, one can get the generated bytes using the\n+        \/\/ squeezing methods.\n+        \/\/ Calling digest method will throw a ProviderException.\n+        public SHAKE128() {\n+            super(\"SHAKE128\", 0, (byte) 0x1F, 32);\n+        }\n+    }\n+\n@@ -480,1 +503,1 @@\n-    public static final class SHAKE256 extends SHA3 {\n+    public static final class SHAKE256 extends SHA3XOF {\n@@ -495,26 +518,0 @@\n-\n-        public void update(byte in) {\n-            engineUpdate(in);\n-        }\n-        public void update(byte[] in, int off, int len) {\n-            engineUpdate(in, off, len);\n-        }\n-\n-        public void update(byte[] in) {\n-            engineUpdate(in, 0, in.length);\n-        }\n-\n-        public byte[] digest() {\n-            return engineDigest();\n-        }\n-\n-        public void squeeze(byte[] output, int offset, int numBytes) {\n-            implSqueeze(output, offset, numBytes);\n-        }\n-        public byte[] squeeze(int numBytes) {\n-            return implSqueeze(numBytes);\n-        }\n-\n-        public void reset() {\n-            engineReset();\n-        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SHA3.java","additions":58,"deletions":61,"binary":false,"changes":119,"status":"modified"}]}