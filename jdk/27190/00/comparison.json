{"files":[{"patch":"@@ -471,0 +471,4 @@\n+\n+    if (is_shutting_down()) {\n+      stall_for_vm_shutdown();\n+    }\n@@ -1507,4 +1511,0 @@\n-bool G1CollectedHeap::concurrent_mark_is_terminating() const {\n-  return _cm_thread->should_terminate();\n-}\n-\n@@ -1814,1 +1814,1 @@\n-    if (op.terminating()) {\n+    if (is_shutting_down()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -903,3 +903,0 @@\n-  \/\/ Returns whether concurrent mark threads (and the VM) are about to terminate.\n-  bool concurrent_mark_is_terminating() const;\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2044,1 +2044,1 @@\n-  if (!cm_thread()->in_progress() && !_g1h->concurrent_mark_is_terminating()) {\n+  if (!cm_thread()->in_progress() && !_g1h->is_shutting_down()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -665,0 +665,1 @@\n+  assert(!_g1h->is_shutting_down(), \"Invariant!\");\n@@ -1249,1 +1250,1 @@\n-  if (_g1h->concurrent_mark_is_terminating()) {\n+  if (_g1h->is_shutting_down()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1108,1 +1108,1 @@\n-              _g1h->concurrent_mark_is_terminating()) &&\n+              _g1h->is_shutting_down()) &&\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,1 +67,0 @@\n-  _terminating(false),\n@@ -86,3 +85,0 @@\n-  \/\/ Record for handling by caller.\n-  _terminating = g1h->concurrent_mark_is_terminating();\n-\n@@ -92,7 +88,1 @@\n-  if (_terminating && GCCause::is_user_requested_gc(_gc_cause)) {\n-    \/\/ When terminating, the request to initiate a concurrent cycle will be\n-    \/\/ ignored by do_collection_pause_at_safepoint; instead it will just do\n-    \/\/ a young-only or mixed GC (depending on phase).  For a user request\n-    \/\/ there's no point in even doing that much, so done.  For some non-user\n-    \/\/ requests the alternative GC might still be needed.\n-  } else if (!g1h->policy()->force_concurrent_start_if_outside_cycle(_gc_cause)) {\n+  if (!g1h->policy()->force_concurrent_start_if_outside_cycle(_gc_cause)) {\n@@ -122,1 +112,0 @@\n-\n@@ -159,0 +148,8 @@\n+  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+  if (g1h->is_shutting_down()) {\n+    Heap_lock->unlock();\n+    \/\/ JVM shutdown has started. This ensures that any further operations will be properly aborted\n+    \/\/ and will not interfere with the shutdown process.\n+    g1h->concurrent_mark()->abort_marking_threads();\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.cpp","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-  bool _terminating;\n@@ -66,1 +65,0 @@\n-  bool terminating() const { return _terminating; }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -321,0 +321,4 @@\n+\n+      if (is_shutting_down()) {\n+        stall_for_vm_shutdown();\n+      }\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -326,0 +326,4 @@\n+    if (is_shutting_down()) {\n+      stall_for_vm_shutdown();\n+    }\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -280,0 +280,1 @@\n+  _is_shutting_down(false),\n@@ -607,0 +608,56 @@\n+bool CollectedHeap::is_shutting_down() const {\n+  return Atomic::load_acquire(&_is_shutting_down);\n+}\n+\n+void CollectedHeap::stall_for_vm_shutdown() {\n+  assert(is_shutting_down(), \"Precondition\");\n+  \/\/ If the VM is shutting down, we may have skipped VM_CollectForAllocation.\n+  \/\/ To avoid returning nullptr (which could cause premature OOME), we stall\n+  \/\/ allocation requests here until the VM shutdown is complete.\n+  MonitorLocker ml(VMExit_lock);\n+  while (true) {\n+    ml.wait();\n+  }\n+}\n+\n+static void log_cpu_time() {\n+  LogTarget(Info, cpu) cpuLog;\n+  if (!cpuLog.is_enabled()) {\n+    return;\n+  }\n+\n+  const double process_cpu_time = os::elapsed_process_cpu_time();\n+  if (process_cpu_time == 0 || process_cpu_time == -1) {\n+    \/\/ 0 can happen e.g. for short running processes with\n+    \/\/ low CPU utilization\n+    return;\n+  }\n+\n+  const double gc_threads_cpu_time = (double) CPUTimeUsage::GC::gc_threads() \/ NANOSECS_PER_SEC;\n+  const double gc_vm_thread_cpu_time = (double) CPUTimeUsage::GC::vm_thread() \/ NANOSECS_PER_SEC;\n+  const double gc_string_dedup_cpu_time = (double) CPUTimeUsage::GC::stringdedup() \/ NANOSECS_PER_SEC;\n+  const double gc_cpu_time = (double) gc_threads_cpu_time + gc_vm_thread_cpu_time + gc_string_dedup_cpu_time;\n+\n+  const double elasped_time = os::elapsedTime();\n+  const bool has_error = CPUTimeUsage::Error::has_error();\n+\n+  if (gc_cpu_time < process_cpu_time) {\n+    cpuLog.print(\"=== CPU time Statistics =============================================================\");\n+    if (has_error) {\n+      cpuLog.print(\"WARNING: CPU time sampling reported errors, numbers may be unreliable\");\n+    }\n+    cpuLog.print(\"                                                                            CPUs\");\n+    cpuLog.print(\"                                                               s       %%  utilized\");\n+    cpuLog.print(\"   Process\");\n+    cpuLog.print(\"     Total                        %30.4f  %6.2f  %8.1f\", process_cpu_time, 100.0, process_cpu_time \/ elasped_time);\n+    cpuLog.print(\"     Garbage Collection           %30.4f  %6.2f  %8.1f\", gc_cpu_time, percent_of(gc_cpu_time, process_cpu_time), gc_cpu_time \/ elasped_time);\n+    cpuLog.print(\"       GC Threads                 %30.4f  %6.2f  %8.1f\", gc_threads_cpu_time, percent_of(gc_threads_cpu_time, process_cpu_time), gc_threads_cpu_time \/ elasped_time);\n+    cpuLog.print(\"       VM Thread                  %30.4f  %6.2f  %8.1f\", gc_vm_thread_cpu_time, percent_of(gc_vm_thread_cpu_time, process_cpu_time), gc_vm_thread_cpu_time \/ elasped_time);\n+\n+    if (UseStringDeduplication) {\n+      cpuLog.print(\"       String Deduplication       %30.4f  %6.2f  %8.1f\", gc_string_dedup_cpu_time, percent_of(gc_string_dedup_cpu_time, process_cpu_time), gc_string_dedup_cpu_time \/ elasped_time);\n+    }\n+    cpuLog.print(\"=====================================================================================\");\n+  }\n+}\n+\n@@ -608,1 +665,0 @@\n-  print_tracing_info();\n@@ -610,0 +666,7 @@\n+  {\n+    \/\/ Acquire the Heap_lock to ensure mutual exclusion with VM_GC_Operations.\n+    MutexLocker ml(Heap_lock);\n+    log_cpu_time();\n+    print_tracing_info();\n+    Atomic::release_store(&_is_shutting_down, true);\n+  }\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":64,"deletions":1,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -113,0 +113,3 @@\n+  \/\/ Flag to indicate that VM is shutting down.\n+  volatile bool _is_shutting_down;\n+\n@@ -252,0 +255,5 @@\n+  bool is_shutting_down() const;\n+\n+  \/\/ Stall allocation requests until the VM shutdown is complete.\n+  void stall_for_vm_shutdown();\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-  if (skip_operation()) {\n+  if (skip_operation() || Universe::heap()->is_shutting_down()) {\n","filename":"src\/hotspot\/share\/gc\/shared\/gcVMOperations.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1305,40 +1305,0 @@\n-static void log_cpu_time() {\n-  LogTarget(Info, cpu) cpuLog;\n-  if (!cpuLog.is_enabled()) {\n-    return;\n-  }\n-\n-  const double process_cpu_time = os::elapsed_process_cpu_time();\n-  if (process_cpu_time == 0 || process_cpu_time == -1) {\n-    \/\/ 0 can happen e.g. for short running processes with\n-    \/\/ low CPU utilization\n-    return;\n-  }\n-\n-  const double gc_threads_cpu_time = (double) CPUTimeUsage::GC::gc_threads() \/ NANOSECS_PER_SEC;\n-  const double gc_vm_thread_cpu_time = (double) CPUTimeUsage::GC::vm_thread() \/ NANOSECS_PER_SEC;\n-  const double gc_string_dedup_cpu_time = (double) CPUTimeUsage::GC::stringdedup() \/ NANOSECS_PER_SEC;\n-  const double gc_cpu_time = (double) gc_threads_cpu_time + gc_vm_thread_cpu_time + gc_string_dedup_cpu_time;\n-\n-  const double elasped_time = os::elapsedTime();\n-  const bool has_error = CPUTimeUsage::Error::has_error();\n-\n-  if (gc_cpu_time < process_cpu_time) {\n-    cpuLog.print(\"=== CPU time Statistics =============================================================\");\n-    if (has_error) {\n-      cpuLog.print(\"WARNING: CPU time sampling reported errors, numbers may be unreliable\");\n-    }\n-    cpuLog.print(\"                                                                            CPUs\");\n-    cpuLog.print(\"                                                               s       %%  utilized\");\n-    cpuLog.print(\"   Process\");\n-    cpuLog.print(\"     Total                        %30.4f  %6.2f  %8.1f\", process_cpu_time, 100.0, process_cpu_time \/ elasped_time);\n-    cpuLog.print(\"     Garbage Collection           %30.4f  %6.2f  %8.1f\", gc_cpu_time, percent_of(gc_cpu_time, process_cpu_time), gc_cpu_time \/ elasped_time);\n-    cpuLog.print(\"       GC Threads                 %30.4f  %6.2f  %8.1f\", gc_threads_cpu_time, percent_of(gc_threads_cpu_time, process_cpu_time), gc_threads_cpu_time \/ elasped_time);\n-    cpuLog.print(\"       VM Thread                  %30.4f  %6.2f  %8.1f\", gc_vm_thread_cpu_time, percent_of(gc_vm_thread_cpu_time, process_cpu_time), gc_vm_thread_cpu_time \/ elasped_time);\n-\n-    if (UseStringDeduplication) {\n-      cpuLog.print(\"       String Deduplication       %30.4f  %6.2f  %8.1f\", gc_string_dedup_cpu_time, percent_of(gc_string_dedup_cpu_time, process_cpu_time), gc_string_dedup_cpu_time \/ elasped_time);\n-    }\n-    cpuLog.print(\"=====================================================================================\");\n-  }\n-}\n@@ -1347,1 +1307,0 @@\n-  log_cpu_time();\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":0,"deletions":41,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -85,0 +85,1 @@\n+Monitor* VMExit_lock                  = nullptr;\n@@ -250,0 +251,1 @@\n+  MUTEX_DEFN(VMExit_lock                     , PaddedMonitor, safepoint);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,0 +87,1 @@\n+extern Monitor* VMExit_lock;                     \/\/ a lock used to stall threads until VM shuts down\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}