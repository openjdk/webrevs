{"files":[{"patch":"@@ -471,0 +471,5 @@\n+\n+    if (is_shutting_down()) {\n+      stall_for_vm_shutdown();\n+      return nullptr;\n+    }\n@@ -706,0 +711,5 @@\n+\n+    if (is_shutting_down()) {\n+      stall_for_vm_shutdown();\n+      return nullptr;\n+    }\n@@ -1507,4 +1517,0 @@\n-bool G1CollectedHeap::concurrent_mark_is_terminating() const {\n-  return _cm_thread->should_terminate();\n-}\n-\n@@ -1814,1 +1820,1 @@\n-    if (op.terminating()) {\n+    if (is_shutting_down()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -902,3 +902,0 @@\n-  \/\/ Returns whether concurrent mark threads (and the VM) are about to terminate.\n-  bool concurrent_mark_is_terminating() const;\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1886,1 +1886,1 @@\n-  if (!cm_thread()->in_progress() && !_g1h->concurrent_mark_is_terminating()) {\n+  if (!cm_thread()->in_progress() && !_g1h->is_shutting_down()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -665,0 +665,1 @@\n+  assert(!_g1h->is_shutting_down(), \"Invariant!\");\n@@ -1249,1 +1250,1 @@\n-  if (_g1h->concurrent_mark_is_terminating()) {\n+  if (_g1h->is_shutting_down()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1108,1 +1108,1 @@\n-              _g1h->concurrent_mark_is_terminating()) &&\n+              _g1h->is_shutting_down()) &&\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,1 +67,0 @@\n-  _terminating(false),\n@@ -86,3 +85,0 @@\n-  \/\/ Record for handling by caller.\n-  _terminating = g1h->concurrent_mark_is_terminating();\n-\n@@ -92,7 +88,1 @@\n-  if (_terminating && GCCause::is_user_requested_gc(_gc_cause)) {\n-    \/\/ When terminating, the request to initiate a concurrent cycle will be\n-    \/\/ ignored by do_collection_pause_at_safepoint; instead it will just do\n-    \/\/ a young-only or mixed GC (depending on phase).  For a user request\n-    \/\/ there's no point in even doing that much, so done.  For some non-user\n-    \/\/ requests the alternative GC might still be needed.\n-  } else if (!g1h->policy()->force_concurrent_start_if_outside_cycle(_gc_cause)) {\n+  if (!g1h->policy()->force_concurrent_start_if_outside_cycle(_gc_cause)) {\n@@ -122,1 +112,0 @@\n-\n@@ -159,0 +148,8 @@\n+  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+  if (g1h->is_shutting_down()) {\n+    Heap_lock->unlock();\n+    \/\/ JVM shutdown has started. This ensures that any further operations will be properly aborted\n+    \/\/ and will not interfere with the shutdown process.\n+    g1h->concurrent_mark()->abort_marking_threads();\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.cpp","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-  bool _terminating;\n@@ -66,1 +65,0 @@\n-  bool terminating() const { return _terminating; }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -329,0 +329,5 @@\n+\n+      if (is_shutting_down()) {\n+        stall_for_vm_shutdown();\n+        return nullptr;\n+      }\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -343,0 +343,5 @@\n+    if (is_shutting_down()) {\n+      stall_for_vm_shutdown();\n+      return nullptr;\n+    }\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -388,0 +388,6 @@\n+\n+    if (is_shutting_down()) {\n+      stall_for_vm_shutdown();\n+      return nullptr;\n+    }\n+\n@@ -606,0 +612,17 @@\n+bool CollectedHeap::is_shutting_down() const {\n+  return Universe::is_shutting_down();\n+}\n+\n+void CollectedHeap::stall_for_vm_shutdown() {\n+  assert(is_shutting_down(), \"Precondition\");\n+  \/\/ Stall the thread (2 seconds) instead of an indefinite wait to avoid deadlock\n+  \/\/ if the VM shutdown triggers a GC.\n+  \/\/ The 2-seconds sleep is:\n+  \/\/   - long enough to keep daemon threads stalled, while the shutdown\n+  \/\/     sequence completes in the common case.\n+  \/\/   - short enough to avoid excessive stall time if the shutdown itself\n+  \/\/     triggers a GC.\n+  JavaThread::current()->sleep(2 * MILLIUNITS);\n+  log_warning(gc, alloc)(\"%s: Stall for VM-Shutdown timed out; allocation may fail with OOME\", Thread::current()->name());\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -249,0 +249,7 @@\n+  bool is_shutting_down() const;\n+\n+  \/\/ If the VM is shutting down, we may have skipped VM_CollectForAllocation.\n+  \/\/ In this case, stall the allocation request briefly in the hope that\n+  \/\/ the VM shutdown completes before the allocation request returns.\n+  void stall_for_vm_shutdown();\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-  if (skip_operation()) {\n+  if (skip_operation() || Universe::is_shutting_down()) {\n","filename":"src\/hotspot\/share\/gc\/shared\/gcVMOperations.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -186,0 +186,1 @@\n+volatile bool   Universe::_is_shutting_down = false;\n@@ -1347,1 +1348,8 @@\n-  log_cpu_time();\n+  {\n+    \/\/ Acquire the Heap_lock to synchronize with VM_Heap_Sync_Operations,\n+    \/\/ which may depend on the value of _is_shutting_down flag.\n+    MutexLocker hl(Heap_lock);\n+    log_cpu_time();\n+    AtomicAccess::release_store(&_is_shutting_down, true);\n+  }\n+\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -131,0 +131,3 @@\n+  \/\/ Shutdown\n+  static volatile bool _is_shutting_down;\n+\n@@ -327,0 +330,2 @@\n+  static bool is_shutting_down()                  { return  AtomicAccess::load_acquire(&_is_shutting_down); }\n+\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/osThread.hpp\"\n","filename":"src\/hotspot\/share\/services\/cpuTimeUsage.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}