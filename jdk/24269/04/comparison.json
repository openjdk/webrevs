{"files":[{"patch":"@@ -1077,12 +1077,4 @@\n-  JvmtiVTMSTransitionDisabler disabler(true);\n-  JavaThread* current = JavaThread::current();\n-  ThreadsListHandle tlh(current);\n-\n-  JavaThread* java_thread = nullptr;\n-  oop thread_oop = nullptr;\n-  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, current, &java_thread, &thread_oop);\n-  if (err != JVMTI_ERROR_NONE) {\n-    return err;\n-  }\n-  err = resume_thread(thread_oop, java_thread, \/* single_resume *\/ true);\n-  return err;\n+  \/\/ resume thread with handshake\n+  ResumeThreadClosure op(\/* single_resume *\/ true);\n+  JvmtiHandshake::execute(&op, thread);\n+  return op.result();\n@@ -1097,5 +1089,0 @@\n-  oop thread_oop = nullptr;\n-  JavaThread* java_thread = nullptr;\n-  JvmtiVTMSTransitionDisabler disabler(true);\n-  ThreadsListHandle tlh;\n-\n@@ -1104,1 +1091,1 @@\n-    jvmtiError err = JvmtiExport::cv_external_thread_to_JavaThread(tlh.list(), thread, &java_thread, &thread_oop);\n+    oop thread_oop = JNIHandles::resolve_external_guard(thread);\n@@ -1106,12 +1093,3 @@\n-    if (thread_oop != nullptr &&\n-        java_lang_VirtualThread::is_instance(thread_oop) &&\n-        !JvmtiEnvBase::is_vthread_alive(thread_oop)) {\n-      err = JVMTI_ERROR_THREAD_NOT_ALIVE;\n-    }\n-    if (err != JVMTI_ERROR_NONE) {\n-      if (thread_oop == nullptr || err != JVMTI_ERROR_INVALID_THREAD) {\n-        results[i] = err;\n-        continue;\n-      }\n-    }\n-    results[i] = resume_thread(thread_oop, java_thread, \/* single_resume *\/ true);\n+    ResumeThreadClosure op(\/* single_resume *\/ true);\n+    JvmtiHandshake::execute(&op, thread);\n+    results[i] = op.result();\n@@ -1133,0 +1111,2 @@\n+  JavaThread* current = JavaThread::current();\n+  HandleMark hm(current);\n@@ -1135,0 +1115,1 @@\n+  ThreadsListHandle tlh(current);\n@@ -1159,1 +1140,2 @@\n-      resume_thread(vt_oop, java_thread, \/* single_resume *\/ false);\n+      ResumeThreadClosure op(\/* single_resume *\/ false);\n+      JvmtiHandshake::execute(&op, &tlh, java_thread, Handle(current, vt_oop));\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":13,"deletions":31,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -1752,0 +1752,13 @@\n+\n+\/*\n+ * The JVMTI Suspend\/Resume support includes suspend_thread and resume_thread internal functions.\n+ * A synchronization is needed between suspend_thread and resume_thread as they have to update\n+ * same context atomically which includes virtual thread suspension registration and a couple of\n+ * JavaThread flags, e.g. is_suspended and is_carrier_thread_suspended.\n+ * In most common case this synchronization is provided by JvmtiVTMSTransitionDisabler.\n+ * But a JvmtiVTMSTransitionDisabler can not be held in a case of self suspension.\n+ * To support such a case the resume_thread function is executed in a context of ResumeThreadClosure.\n+ * In contrast, the suspend_thread function is executed normally. To be thread safe these functions\n+ * should not trigger safepoints while the suspension state is inconsistent.\n+ *\/\n+\n@@ -1759,0 +1772,1 @@\n+  bool is_thread_carrying = is_thread_carrying_vthread(java_thread, thread_h());\n@@ -1785,1 +1799,0 @@\n-  bool is_thread_carrying = is_thread_carrying_vthread(java_thread, thread_h());\n@@ -1823,0 +1836,3 @@\n+\/\/ Synchronization is needed between suspend_thread and resume_thread\n+\/\/ This function is executed in context of ResumeThreadClosure. In contrast, the suspend_thread\n+\/\/ is executed normally without any HandshakeClosure.\n@@ -1825,1 +1841,2 @@\n-  JavaThread* current = JavaThread::current();\n+  \/\/ current thread can be VMThread which is a NonJavaThread\n+  Thread* current = Thread::current();\n@@ -1828,0 +1845,1 @@\n+  ThreadsListHandle tlh(current);\n@@ -1829,0 +1847,1 @@\n+  NoSafepointVerifier nsv;\n@@ -2059,0 +2078,1 @@\n+  hs_cl->set_target_h(target_h);\n@@ -2615,0 +2635,10 @@\n+void\n+ResumeThreadClosure::do_thread(Thread *target) {\n+  set_result(JvmtiEnvBase::resume_thread(_target_h(), _target_jt, _single_resume));\n+}\n+\n+void\n+ResumeThreadClosure::do_vthread(Handle thread_h) {\n+  set_result(JvmtiEnvBase::resume_thread(_target_h(), _target_jt, _single_resume));\n+}\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":32,"deletions":2,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -485,0 +485,1 @@\n+  Handle _target_h;\n@@ -497,0 +498,1 @@\n+  void set_target_h(Handle target_h) { _target_h = target_h; }\n@@ -661,0 +663,16 @@\n+\n+\/\/ HandshakeClosure to resume thread.\n+class ResumeThreadClosure : public JvmtiUnitedHandshakeClosure {\n+ private:\n+  bool _single_resume;\n+\n+ public:\n+  ResumeThreadClosure(bool single_resume)\n+      : JvmtiUnitedHandshakeClosure(\"ResumeThread\"),\n+        _single_resume(single_resume) {}\n+\n+  void do_thread(Thread *target);\n+  void do_vthread(Handle thread_h);\n+};\n+\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -257,1 +257,4 @@\n-  : _is_SR(false), _thread(thread)\n+  : _is_SR(false),\n+    _is_virtual(false),\n+    _is_self(false),\n+    _thread(thread)\n@@ -265,0 +268,10 @@\n+  JavaThread* current = JavaThread::current();\n+  oop thread_oop = JNIHandles::resolve_external_guard(thread);\n+  _is_virtual = java_lang_VirtualThread::is_instance(thread_oop);\n+\n+  if (thread == nullptr ||\n+      (!_is_virtual && thread_oop == current->threadObj()) ||\n+      (_is_virtual && thread_oop == current->vthread())) {\n+    _is_self = true;\n+    return; \/\/ no need for current thread to disable and enable transitions for itself\n+  }\n@@ -268,1 +281,0 @@\n-  oop thread_oop = JNIHandles::resolve_external_guard(thread);\n@@ -275,5 +287,1 @@\n-  if (!java_lang_VirtualThread::is_instance(thread_oop)) {\n-    _thread = nullptr; \/\/ target is a platform thread, switch to disabling VTMS transitions for all threads\n-  }\n-\n-  if (_thread != nullptr) {\n+  if (_is_virtual) {\n@@ -288,1 +296,4 @@\n-  : _is_SR(is_SR), _thread(nullptr)\n+  : _is_SR(is_SR),\n+    _is_virtual(false),\n+    _is_self(false),\n+    _thread(nullptr)\n@@ -312,1 +323,4 @@\n-  if (_thread != nullptr) {\n+  if (_is_self) {\n+    return; \/\/ no need for current thread to disable and enable transitions for itself\n+  }\n+  if (_is_virtual) {\n@@ -687,1 +701,1 @@\n-  MonitorLocker ml(JvmtiVTMSTransition_lock);\n+  MutexLocker ml(JvmtiVThreadSuspend_lock, Mutex::_no_safepoint_check_flag);\n@@ -696,1 +710,1 @@\n-  MonitorLocker ml(JvmtiVTMSTransition_lock);\n+  MutexLocker ml(JvmtiVThreadSuspend_lock, Mutex::_no_safepoint_check_flag);\n@@ -706,1 +720,1 @@\n-  MonitorLocker ml(JvmtiVTMSTransition_lock);\n+  MutexLocker ml(JvmtiVThreadSuspend_lock, Mutex::_no_safepoint_check_flag);\n@@ -723,1 +737,1 @@\n-  MonitorLocker ml(JvmtiVTMSTransition_lock);\n+  MutexLocker ml(JvmtiVThreadSuspend_lock, Mutex::_no_safepoint_check_flag);\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.cpp","additions":27,"deletions":13,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,0 +89,2 @@\n+  bool _is_virtual;                                      \/\/ target thread is virtual\n+  bool _is_self;                                         \/\/ JvmtiVTMSTransitionDisabler is a no-op for current platform, carrier or virtual thread\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -794,4 +794,0 @@\n-  if (!is_suspended()) {\n-    return false;\n-  }\n-  MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+Mutex*   JvmtiVThreadSuspend_lock     = nullptr;\n@@ -263,0 +264,1 @@\n+  MUTEX_DEFN(JvmtiVThreadSuspend_lock        , PaddedMutex,   nosafepoint-1);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+extern Mutex*   JvmtiVThreadSuspend_lock;        \/\/ a lock for virtual threads suspension\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -111,1 +111,0 @@\n-runtime\/handshake\/HandshakeSuspendExitTest.java 8294313 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}