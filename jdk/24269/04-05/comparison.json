{"files":[{"patch":"@@ -991,0 +991,4 @@\n+      if (java_lang_VirtualThread::is_instance(thread_oop)) {\n+        oop carrier_thread = java_lang_VirtualThread::carrier_thread(thread_oop);\n+        java_thread = carrier_thread == nullptr ? nullptr : java_lang_Thread::thread(carrier_thread);\n+      }\n@@ -1077,4 +1081,12 @@\n-  \/\/ resume thread with handshake\n-  ResumeThreadClosure op(\/* single_resume *\/ true);\n-  JvmtiHandshake::execute(&op, thread);\n-  return op.result();\n+  JvmtiVTMSTransitionDisabler disabler(true);\n+  JavaThread* current = JavaThread::current();\n+  ThreadsListHandle tlh(current);\n+\n+  JavaThread* java_thread = nullptr;\n+  oop thread_oop = nullptr;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, current, &java_thread, &thread_oop);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+  err = resume_thread(thread_oop, java_thread, \/* single_resume *\/ true);\n+  return err;\n@@ -1089,0 +1101,5 @@\n+  oop thread_oop = nullptr;\n+  JavaThread* java_thread = nullptr;\n+  JvmtiVTMSTransitionDisabler disabler(true);\n+  ThreadsListHandle tlh;\n+\n@@ -1091,1 +1108,1 @@\n-    oop thread_oop = JNIHandles::resolve_external_guard(thread);\n+    jvmtiError err = JvmtiExport::cv_external_thread_to_JavaThread(tlh.list(), thread, &java_thread, &thread_oop);\n@@ -1093,3 +1110,16 @@\n-    ResumeThreadClosure op(\/* single_resume *\/ true);\n-    JvmtiHandshake::execute(&op, thread);\n-    results[i] = op.result();\n+    if (thread_oop != nullptr &&\n+        java_lang_VirtualThread::is_instance(thread_oop) &&\n+        !JvmtiEnvBase::is_vthread_alive(thread_oop)) {\n+      err = JVMTI_ERROR_THREAD_NOT_ALIVE;\n+    }\n+    if (err != JVMTI_ERROR_NONE) {\n+      if (thread_oop == nullptr || err != JVMTI_ERROR_INVALID_THREAD) {\n+        results[i] = err;\n+        continue;\n+      }\n+    }\n+    if (java_lang_VirtualThread::is_instance(thread_oop)) {\n+      oop carrier_thread = java_lang_VirtualThread::carrier_thread(thread_oop);\n+      java_thread = carrier_thread == nullptr ? nullptr : java_lang_Thread::thread(carrier_thread);\n+    }      \n+    results[i] = resume_thread(thread_oop, java_thread, \/* single_resume *\/ true);\n@@ -1111,2 +1141,0 @@\n-  JavaThread* current = JavaThread::current();\n-  HandleMark hm(current);\n@@ -1115,1 +1143,0 @@\n-  ThreadsListHandle tlh(current);\n@@ -1140,2 +1167,1 @@\n-      ResumeThreadClosure op(\/* single_resume *\/ false);\n-      JvmtiHandshake::execute(&op, &tlh, java_thread, Handle(current, vt_oop));\n+      resume_thread(vt_oop, java_thread, \/* single_resume *\/ false);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":39,"deletions":13,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -1401,2 +1401,1 @@\n-  }\n-  if (vt_oop->is_a(vmClasses::BoundVirtualThread_klass())) {\n+  } else if (vt_oop->is_a(vmClasses::BoundVirtualThread_klass())) {\n@@ -1752,13 +1751,0 @@\n-\n-\/*\n- * The JVMTI Suspend\/Resume support includes suspend_thread and resume_thread internal functions.\n- * A synchronization is needed between suspend_thread and resume_thread as they have to update\n- * same context atomically which includes virtual thread suspension registration and a couple of\n- * JavaThread flags, e.g. is_suspended and is_carrier_thread_suspended.\n- * In most common case this synchronization is provided by JvmtiVTMSTransitionDisabler.\n- * But a JvmtiVTMSTransitionDisabler can not be held in a case of self suspension.\n- * To support such a case the resume_thread function is executed in a context of ResumeThreadClosure.\n- * In contrast, the suspend_thread function is executed normally. To be thread safe these functions\n- * should not trigger safepoints while the suspension state is inconsistent.\n- *\/\n-\n@@ -1772,1 +1758,0 @@\n-  bool is_thread_carrying = is_thread_carrying_vthread(java_thread, thread_h());\n@@ -1774,25 +1759,1 @@\n-  if (is_virtual) {\n-    if (single_suspend) {\n-      if (JvmtiVTSuspender::is_vthread_suspended(thread_h())) {\n-        return JVMTI_ERROR_THREAD_SUSPENDED;\n-      }\n-      JvmtiVTSuspender::register_vthread_suspend(thread_h());\n-      \/\/ Check if virtual thread is mounted and there is a java_thread.\n-      \/\/ A non-null java_thread is always passed in the !single_suspend case.\n-      oop carrier_thread = java_lang_VirtualThread::carrier_thread(thread_h());\n-      java_thread = carrier_thread == nullptr ? nullptr : java_lang_Thread::thread(carrier_thread);\n-    }\n-    \/\/ The java_thread can be still blocked in VTMS transition after a previous JVMTI resume call.\n-    \/\/ There is no need to suspend the java_thread in this case. After vthread unblocking,\n-    \/\/ it will check for ext_suspend request and suspend itself if necessary.\n-    if (java_thread == nullptr || java_thread->is_suspended()) {\n-      \/\/ We are done if the virtual thread is unmounted or\n-      \/\/ the java_thread is externally suspended.\n-      return JVMTI_ERROR_NONE;\n-    }\n-    \/\/ The virtual thread is mounted: suspend the java_thread.\n-  }\n-  \/\/ Don't allow hidden thread suspend request.\n-  if (java_thread->is_hidden_from_external_view()) {\n-    return JVMTI_ERROR_NONE;\n-  }\n+  \/\/ Unmounted vthread case.\n@@ -1800,5 +1761,3 @@\n-  \/\/ A case of non-virtual thread.\n-  if (!is_virtual) {\n-    \/\/ Thread.suspend() is used in some tests. It sets jt->is_suspended() only.\n-    if (java_thread->is_carrier_thread_suspended() ||\n-        (!is_thread_carrying && java_thread->is_suspended())) {\n+  if (is_virtual && java_thread == nullptr) {\n+    assert(single_suspend, \"sanity check\");\n+    if (JvmtiVTSuspender::is_vthread_suspended(thread_h())) {\n@@ -1807,1 +1766,2 @@\n-    java_thread->set_carrier_thread_suspended();\n+    JvmtiVTSuspender::register_vthread_suspend(thread_h());\n+    return JVMTI_ERROR_NONE;\n@@ -1809,0 +1769,4 @@\n+\n+  \/\/ Platform thread or mounted vthread cases.\n+\n+  assert(java_thread != nullptr, \"sanity check\");\n@@ -1811,3 +1775,4 @@\n-  assert(!single_suspend || (!is_virtual && java_thread->is_carrier_thread_suspended()) ||\n-          (is_virtual && JvmtiVTSuspender::is_vthread_suspended(thread_h())),\n-         \"sanity check\");\n+  \/\/ Don't allow hidden thread suspend request.\n+  if (java_thread->is_hidden_from_external_view()) {\n+    return JVMTI_ERROR_NONE;\n+  }\n@@ -1817,2 +1782,6 @@\n-  \/\/ and it will be actually suspended at virtual thread unmount transition.\n-  if (!is_thread_carrying) {\n+  \/\/ and it will be actually suspended at virtual thread unmount transition. \n+  bool is_thread_carrying = is_thread_carrying_vthread(java_thread, thread_h());\n+  if (is_thread_carrying) {\n+    return java_thread->set_carrier_thread_suspended() ? JVMTI_ERROR_NONE : JVMTI_ERROR_THREAD_SUSPENDED;\n+  } else {\n+    \/\/ Platform thread (not carrying vthread) or mounted vthread cases.\n@@ -1822,2 +1791,8 @@\n-    \/\/ Case of mounted virtual or attached carrier thread.\n-    if (!java_thread->java_suspend()) {\n+\n+    \/\/ Ideally we would just need to check java_thread->is_suspended(), but we have to\n+    \/\/ consider the case of trying to suspend a thread that was previously suspended while\n+    \/\/ carrying a vthread but has already unmounted it.\n+    if (java_thread->is_suspended() || (!is_virtual && java_thread->is_carrier_thread_suspended())) {\n+      return JVMTI_ERROR_THREAD_SUSPENDED;\n+    }\n+    if (!java_thread->java_suspend(single_suspend)) {\n@@ -1831,0 +1806,1 @@\n+    return JVMTI_ERROR_NONE;\n@@ -1832,1 +1808,0 @@\n-  return JVMTI_ERROR_NONE;\n@@ -1836,3 +1811,0 @@\n-\/\/ Synchronization is needed between suspend_thread and resume_thread\n-\/\/ This function is executed in context of ResumeThreadClosure. In contrast, the suspend_thread\n-\/\/ is executed normally without any HandshakeClosure.\n@@ -1841,2 +1813,1 @@\n-  \/\/ current thread can be VMThread which is a NonJavaThread\n-  Thread* current = Thread::current();\n+  JavaThread* current = JavaThread::current();\n@@ -1845,1 +1816,0 @@\n-  ThreadsListHandle tlh(current);\n@@ -1847,1 +1817,0 @@\n-  NoSafepointVerifier nsv;\n@@ -1849,20 +1818,9 @@\n-  if (is_virtual) {\n-    if (single_resume) {\n-      if (!JvmtiVTSuspender::is_vthread_suspended(thread_h())) {\n-        return JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n-      }\n-      JvmtiVTSuspender::register_vthread_resume(thread_h());\n-      \/\/ Check if virtual thread is mounted and there is a java_thread.\n-      \/\/ A non-null java_thread is always passed in the !single_resume case.\n-      oop carrier_thread = java_lang_VirtualThread::carrier_thread(thread_h());\n-      java_thread = carrier_thread == nullptr ? nullptr : java_lang_Thread::thread(carrier_thread);\n-    }\n-    \/\/ The java_thread can be still blocked in VTMS transition after a previous JVMTI suspend call.\n-    \/\/ There is no need to resume the java_thread in this case. After vthread unblocking,\n-    \/\/ it will check for is_vthread_suspended request and remain resumed if necessary.\n-    if (java_thread == nullptr || !java_thread->is_suspended()) {\n-      \/\/ We are done if the virtual thread is unmounted or\n-      \/\/ the java_thread is not externally suspended.\n-      return JVMTI_ERROR_NONE;\n-    }\n-    \/\/ The virtual thread is mounted and java_thread is supended: resume the java_thread.\n+  \/\/ Unmounted vthread case.\n+\n+  if (is_virtual && java_thread == nullptr) {\n+    assert(single_resume, \"sanity check\");\n+    if (!JvmtiVTSuspender::is_vthread_suspended(thread_h())) {\n+      return JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n+    } \n+    JvmtiVTSuspender::register_vthread_resume(thread_h());\n+    return JVMTI_ERROR_NONE;\n@@ -1870,0 +1828,6 @@\n+\n+  \/\/ Platform thread or mounted vthread cases.\n+\n+  assert(java_thread != nullptr, \"sanity check\");\n+  assert(!java_thread->is_in_VTMS_transition(), \"sanity check\");\n+ \n@@ -1874,11 +1838,0 @@\n-  bool is_thread_carrying = is_thread_carrying_vthread(java_thread, thread_h());\n-\n-  \/\/ A case of a non-virtual thread.\n-  if (!is_virtual) {\n-    if (!java_thread->is_carrier_thread_suspended() &&\n-        (is_thread_carrying || !java_thread->is_suspended())) {\n-      return JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n-    }\n-    java_thread->clear_carrier_thread_suspended();\n-  }\n-  assert(!java_thread->is_in_VTMS_transition(), \"sanity check\");\n@@ -1886,1 +1839,6 @@\n-  if (!is_thread_carrying) {\n+  bool is_thread_carrying = is_thread_carrying_vthread(java_thread, thread_h());\n+  if (is_thread_carrying) {\n+    return java_thread->clear_carrier_thread_suspended() ? JVMTI_ERROR_NONE : JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n+  } else {\n+    \/\/ Platform thread (not carrying vthread) or mounted vthread cases.\n+ \n@@ -1890,4 +1848,12 @@\n-    if (java_thread->is_suspended()) {\n-      if (!java_thread->java_resume()) {\n-        return JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n-      }\n+\n+    \/\/ Ideally we would not have to check this but we have to consider the case\n+    \/\/ of trying to resume a thread that was previously suspended while carrying\n+    \/\/ a vthread but has already unmounted it.\n+    if (!is_virtual && java_thread->is_carrier_thread_suspended()) {\n+      bool res = java_thread->clear_carrier_thread_suspended();\n+      assert(res, \"resume operations running concurrently?\");\n+      return JVMTI_ERROR_NONE;\n+    }\n+\n+    if (!java_thread->java_resume(single_resume)) {\n+      return JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n@@ -1895,0 +1861,1 @@\n+    return JVMTI_ERROR_NONE;\n@@ -1896,1 +1863,0 @@\n-  return JVMTI_ERROR_NONE;\n@@ -2078,1 +2044,0 @@\n-  hs_cl->set_target_h(target_h);\n@@ -2635,10 +2600,0 @@\n-void\n-ResumeThreadClosure::do_thread(Thread *target) {\n-  set_result(JvmtiEnvBase::resume_thread(_target_h(), _target_jt, _single_resume));\n-}\n-\n-void\n-ResumeThreadClosure::do_vthread(Handle thread_h) {\n-  set_result(JvmtiEnvBase::resume_thread(_target_h(), _target_jt, _single_resume));\n-}\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":65,"deletions":110,"binary":false,"changes":175,"status":"modified"},{"patch":"@@ -485,1 +485,0 @@\n-  Handle _target_h;\n@@ -498,1 +497,0 @@\n-  void set_target_h(Handle target_h) { _target_h = target_h; }\n@@ -663,16 +661,0 @@\n-\n-\/\/ HandshakeClosure to resume thread.\n-class ResumeThreadClosure : public JvmtiUnitedHandshakeClosure {\n- private:\n-  bool _single_resume;\n-\n- public:\n-  ResumeThreadClosure(bool single_resume)\n-      : JvmtiUnitedHandshakeClosure(\"ResumeThread\"),\n-        _single_resume(single_resume) {}\n-\n-  void do_thread(Thread *target);\n-  void do_vthread(Handle thread_h);\n-};\n-\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.hpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -661,1 +661,1 @@\n-  if (!(_self || _thread->is_carrier_thread_suspended())) {\n+  if (!_self && !_thread->is_suspended() && !_thread->is_carrier_thread_suspended()) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"prims\/jvmtiThreadState.hpp\"\n@@ -732,1 +733,1 @@\n-bool HandshakeState::suspend_with_handshake() {\n+bool HandshakeState::suspend_with_handshake(bool update_vthread_list) {\n@@ -747,1 +748,1 @@\n-      set_suspended(true);\n+      set_suspended(true, update_vthread_list);\n@@ -755,1 +756,1 @@\n-  set_suspended(true);\n+  set_suspended(true, update_vthread_list);\n@@ -765,0 +766,1 @@\n+  bool _update_vthread_list;\n@@ -767,1 +769,2 @@\n-  SuspendThreadHandshake() : HandshakeClosure(\"SuspendThread\"), _did_suspend(false) {}\n+  SuspendThreadHandshake(bool update_vthread_list) : HandshakeClosure(\"SuspendThread\"),\n+    _update_vthread_list(update_vthread_list), _did_suspend(false) {}\n@@ -770,1 +773,1 @@\n-    _did_suspend = target->handshake_state()->suspend_with_handshake();\n+    _did_suspend = target->handshake_state()->suspend_with_handshake(_update_vthread_list);\n@@ -775,1 +778,1 @@\n-bool HandshakeState::suspend() {\n+bool HandshakeState::suspend(bool update_vthread_list) {\n@@ -783,1 +786,1 @@\n-    set_suspended(true);\n+    set_suspended(true, update_vthread_list);\n@@ -787,1 +790,1 @@\n-    SuspendThreadHandshake st;\n+    SuspendThreadHandshake st(update_vthread_list);\n@@ -793,1 +796,2 @@\n-bool HandshakeState::resume() {\n+bool HandshakeState::resume(bool update_vthread_list) {\n+  MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n@@ -799,1 +803,1 @@\n-  set_suspended(false);\n+  set_suspended(false, update_vthread_list);\n@@ -804,0 +808,13 @@\n+void HandshakeState::set_suspended(bool is_suspend, bool update_vthread_list) {\n+#if INCLUDE_JVMTI\n+  if (update_vthread_list && _handshakee->is_vthread_mounted()) {\n+    if (is_suspend) {\n+      JvmtiVTSuspender::register_vthread_suspend(_handshakee->vthread());\n+    } else {\n+      JvmtiVTSuspender::register_vthread_resume(_handshakee->vthread());\n+    }\n+  }\n+#endif\n+  Atomic::store(&_suspended, is_suspend);\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":27,"deletions":10,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -176,1 +176,1 @@\n-  bool suspend_with_handshake();\n+  bool suspend_with_handshake(bool update_vthread_list);\n@@ -182,1 +182,1 @@\n-  void set_suspended(bool to)               { return Atomic::store(&_suspended, to); }\n+  void set_suspended(bool to, bool update_vthread_list);\n@@ -186,2 +186,2 @@\n-  bool suspend();\n-  bool resume();\n+  bool suspend(bool update_vthread_list);\n+  bool resume(bool update_vthread_list);\n","filename":"src\/hotspot\/share\/runtime\/handshake.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1196,1 +1196,1 @@\n-bool JavaThread::java_suspend() {\n+bool JavaThread::java_suspend(bool update_vthread_list) {\n@@ -1205,1 +1205,1 @@\n-  return this->handshake_state()->suspend();\n+  return this->handshake_state()->suspend(update_vthread_list);\n@@ -1208,1 +1208,1 @@\n-bool JavaThread::java_resume() {\n+bool JavaThread::java_resume(bool update_vthread_list) {\n@@ -1211,1 +1211,1 @@\n-  return this->handshake_state()->resume();\n+  return this->handshake_state()->resume(update_vthread_list);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -701,2 +701,2 @@\n-  bool java_suspend();\n-  bool java_resume();\n+  bool java_suspend(bool update_vthread_list);\n+  bool java_resume(bool update_vthread_list);\n@@ -713,2 +713,2 @@\n-  inline void set_carrier_thread_suspended();\n-  inline void clear_carrier_thread_suspended();\n+  inline bool set_carrier_thread_suspended();\n+  inline bool clear_carrier_thread_suspended();\n@@ -717,1 +717,1 @@\n-    return _carrier_thread_suspended;\n+    return Atomic::load(&_carrier_thread_suspended);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -74,2 +74,2 @@\n-inline void JavaThread::set_carrier_thread_suspended() {\n-  _carrier_thread_suspended = true;\n+inline bool JavaThread::set_carrier_thread_suspended() {\n+  return Atomic::cmpxchg(&_carrier_thread_suspended, false, true) == false;\n@@ -77,2 +77,2 @@\n-inline void JavaThread::clear_carrier_thread_suspended() {\n-  _carrier_thread_suspended = false;\n+inline bool JavaThread::clear_carrier_thread_suspended() {\n+  return Atomic::cmpxchg(&_carrier_thread_suspended, true, false) == true;\n","filename":"src\/hotspot\/share\/runtime\/javaThread.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}