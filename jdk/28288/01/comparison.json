{"files":[{"patch":"@@ -1135,1 +1135,1 @@\n-bool PhaseIterGVN::verify_Value_for(Node* n) {\n+bool PhaseIterGVN::verify_Value_for(Node* n, bool strict) {\n@@ -1155,1 +1155,1 @@\n-  if (n->is_Load() && !told->singleton()) {\n+  if (!strict && n->is_Load() && !told->singleton()) {\n@@ -1163,1 +1163,1 @@\n-  if (n->Opcode() == Op_CmpP && type(n->in(1))->isa_oopptr() && type(n->in(2))->isa_oopptr()) {\n+  if (!strict && n->Opcode() == Op_CmpP && type(n->in(1))->isa_oopptr() && type(n->in(2))->isa_oopptr()) {\n@@ -2788,0 +2788,1 @@\n+  Unique_Node_List worklist_revisit(&local_arena);\n@@ -2796,2 +2797,3 @@\n-  \/\/ Pull from worklist; compute new value; push changes out.\n-  \/\/ This loop is the meat of CCP.\n+  \/\/ This is the meat of CCP: pull from worklist; compute new value; push changes out.\n+\n+  \/\/ Do the first round.\n@@ -2801,0 +2803,3 @@\n+    if (needs_revisit(n)) {\n+      worklist_revisit.push(n);\n+    }\n@@ -2806,6 +2811,10 @@\n-    const Type* new_type = n->Value(this);\n-    if (new_type != type(n)) {\n-      DEBUG_ONLY(verify_type(n, new_type, type(n));)\n-      dump_type_and_node(n, new_type);\n-      set_type(n, new_type);\n-      push_child_nodes_to_worklist(worklist, n);\n+    analyze_step(worklist, n);\n+  }\n+\n+  \/\/ More rounds to catch updates in revisited nodes.\n+  \/\/ Revisit nodes that might be able to refine their types at the end of the round.\n+  \/\/ If so, process these nodes. If there is remaining work, start another round.\n+  do {\n+    while (worklist.size() != 0) {\n+      Node* n = fetch_next_node(worklist);\n+      analyze_step(worklist, n);\n@@ -2813,4 +2822,3 @@\n-    if (KillPathsReachableByDeadTypeNode && n->is_Type() && new_type == Type::TOP) {\n-      \/\/ Keep track of Type nodes to kill CFG paths that use Type\n-      \/\/ nodes that become dead.\n-      _maybe_top_type_nodes.push(n);\n+    for (uint t = 0; t < worklist_revisit.size(); t++) {\n+      Node* n = worklist_revisit.at(t);\n+      analyze_step(worklist, n);\n@@ -2818,1 +2826,2 @@\n-  }\n+  } while (worklist.size() != 0);\n+\n@@ -2822,0 +2831,31 @@\n+void PhaseCCP::analyze_step(Unique_Node_List& worklist, Node* n) {\n+  const Type* new_type = n->Value(this);\n+  if (new_type != type(n)) {\n+    DEBUG_ONLY(verify_type(n, new_type, type(n));)\n+    dump_type_and_node(n, new_type);\n+    set_type(n, new_type);\n+    push_child_nodes_to_worklist(worklist, n);\n+  }\n+  if (KillPathsReachableByDeadTypeNode && n->is_Type() && new_type == Type::TOP) {\n+    \/\/ Keep track of Type nodes to kill CFG paths that use Type\n+    \/\/ nodes that become dead.\n+    _maybe_top_type_nodes.push(n);\n+  }\n+}\n+\n+\/\/ Some nodes can refine their types due to type change somewhere deep\n+\/\/ in the graph. We will need to revisit them before claiming convergence.\n+\/\/ Add nodes here if particular *Node::Value is doing deep graph traversals\n+\/\/ not handled by PhaseCCP::push_more_uses().\n+bool PhaseCCP::needs_revisit(Node* n) const {\n+  \/\/ LoadNode performs deep traversals. Load is not notified for changes far away.\n+  if (n->is_Load()) {\n+    return true;\n+  }\n+  \/\/ CmpPNode performs deep traversals if it compares oopptr. CmpP is not notified for changes far away.\n+  if (n->Opcode() == Op_CmpP && type(n->in(1))->isa_oopptr() && type(n->in(2))->isa_oopptr()) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n@@ -2824,1 +2864,2 @@\n-\/\/ We have a list of exceptions, see comments in verify_Value_for.\n+\/\/ Note for CCP the non-convergence can lead to unsound analysis and mis-compilation.\n+\/\/ Therefore, we are verifying Value convergence strictly.\n@@ -2829,1 +2870,1 @@\n-    failure |= verify_Value_for(n);\n+    failure |= verify_Value_for(n, \/* strict = *\/ true);\n@@ -2833,2 +2874,3 @@\n-  \/\/ in PhaseCCP::push_child_nodes_to_worklist() to update their type or add an exception\n-  \/\/ in the verification code above if that is not possible for some reason (like Load nodes).\n+  \/\/ in PhaseCCP::push_child_nodes_to_worklist() to update their type in the same round,\n+  \/\/ or that they are added in PhaseCCP::needs_revisit() so that analysis revisits\n+  \/\/ them at the end of the round.\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":62,"deletions":20,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -493,1 +493,1 @@\n-  bool verify_Value_for(Node* n);\n+  bool verify_Value_for(Node* n, bool strict = false);\n@@ -646,0 +646,2 @@\n+  void analyze_step(Unique_Node_List& worklist, Node* n);\n+  bool needs_revisit(Node* n) const;\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}