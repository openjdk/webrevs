{"files":[{"patch":"@@ -1135,1 +1135,1 @@\n-bool PhaseIterGVN::verify_Value_for(Node* n) {\n+bool PhaseIterGVN::verify_Value_for(Node* n, bool strict) {\n@@ -1155,1 +1155,1 @@\n-  if (n->is_Load() && !told->singleton()) {\n+  if (!strict && n->is_Load() && !told->singleton()) {\n@@ -1163,1 +1163,1 @@\n-  if (n->Opcode() == Op_CmpP && type(n->in(1))->isa_oopptr() && type(n->in(2))->isa_oopptr()) {\n+  if (!strict && n->Opcode() == Op_CmpP && type(n->in(1))->isa_oopptr() && type(n->in(2))->isa_oopptr()) {\n@@ -2788,0 +2788,1 @@\n+  Unique_Node_List worklist_revisit(&local_arena);\n@@ -2798,19 +2799,28 @@\n-  while (worklist.size() != 0) {\n-    Node* n = fetch_next_node(worklist);\n-    DEBUG_ONLY(worklist_verify.push(n);)\n-    if (n->is_SafePoint()) {\n-      \/\/ Make sure safepoints are processed by PhaseCCP::transform even if they are\n-      \/\/ not reachable from the bottom. Otherwise, infinite loops would be removed.\n-      _root_and_safepoints.push(n);\n-    }\n-    const Type* new_type = n->Value(this);\n-    if (new_type != type(n)) {\n-      DEBUG_ONLY(verify_type(n, new_type, type(n));)\n-      dump_type_and_node(n, new_type);\n-      set_type(n, new_type);\n-      push_child_nodes_to_worklist(worklist, n);\n-    }\n-    if (KillPathsReachableByDeadTypeNode && n->is_Type() && new_type == Type::TOP) {\n-      \/\/ Keep track of Type nodes to kill CFG paths that use Type\n-      \/\/ nodes that become dead.\n-      _maybe_top_type_nodes.push(n);\n+  bool first_round = true;\n+  do {\n+    \/\/ Start the CCP round.\n+    while (worklist.size() != 0) {\n+      Node* n = fetch_next_node(worklist);\n+      if (first_round) {\n+        DEBUG_ONLY(worklist_verify.push(n);)\n+        if (needs_revisit(n)) {\n+          worklist_revisit.push(n);\n+        }\n+        if (n->is_SafePoint()) {\n+          \/\/ Make sure safepoints are processed by PhaseCCP::transform even if they are\n+          \/\/ not reachable from the bottom. Otherwise, infinite loops would be removed.\n+          _root_and_safepoints.push(n);\n+        }\n+      }\n+      const Type* new_type = n->Value(this);\n+      if (new_type != type(n)) {\n+        DEBUG_ONLY(verify_type(n, new_type, type(n));)\n+        dump_type_and_node(n, new_type);\n+        set_type(n, new_type);\n+        push_child_nodes_to_worklist(worklist, n);\n+      }\n+      if (KillPathsReachableByDeadTypeNode && n->is_Type() && new_type == Type::TOP) {\n+        \/\/ Keep track of Type nodes to kill CFG paths that use Type\n+        \/\/ nodes that become dead.\n+        _maybe_top_type_nodes.push(n);\n+      }\n@@ -2818,1 +2828,15 @@\n-  }\n+\n+    \/\/ Check if any nodes slated for revisit are able to refine their types at the end of the round.\n+    \/\/ If so, push them to worklist to start another round and process them.\n+    for (uint t = 0; t < worklist_revisit.size(); t++) {\n+      Node* n = worklist_revisit.at(t);\n+      const Type* new_type = n->Value(this);\n+      if (new_type != type(n)) {\n+        worklist.push(n);\n+      }\n+    }\n+\n+    \/\/ First round is done.\n+    first_round = false;\n+  } while (worklist.size() != 0);\n+\n@@ -2822,0 +2846,16 @@\n+\/\/ Some nodes can refine their types due to type change somewhere deep\n+\/\/ in the graph. We will need to revisit them before claiming convergence.\n+\/\/ Add nodes here if particular *Node::Value is doing deep graph traversals\n+\/\/ not handled by push_more_uses.\n+bool PhaseCCP::needs_revisit(Node *n) const {\n+  \/\/ LoadNode performs deep traversals. Load is not notified for changes far away.\n+  if (n->is_Load()) {\n+    return true;\n+  }\n+  \/\/ CmpPNode performs deep traversals if it compares oopptr. CmpP is not notified for changes far away.\n+  if (n->Opcode() == Op_CmpP) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n@@ -2824,1 +2864,2 @@\n-\/\/ We have a list of exceptions, see comments in verify_Value_for.\n+\/\/ Note for CCP the non-convergence can lead to unsound analysis and mis-compilation.\n+\/\/ Therefore, we are verifying Value convergence strictly.\n@@ -2829,1 +2870,1 @@\n-    failure |= verify_Value_for(n);\n+    failure |= verify_Value_for(n, \/* strict = *\/ true);\n@@ -2833,2 +2874,3 @@\n-  \/\/ in PhaseCCP::push_child_nodes_to_worklist() to update their type or add an exception\n-  \/\/ in the verification code above if that is not possible for some reason (like Load nodes).\n+  \/\/ in PhaseCCP::push_child_nodes_to_worklist() to update their type in the same round,\n+  \/\/ or that they are added in PhaseCCP::maybe_needs_revisit() so that analysis revisits\n+  \/\/ them at the end of the round.\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":69,"deletions":27,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -493,1 +493,1 @@\n-  bool verify_Value_for(Node* n);\n+  bool verify_Value_for(Node* n, bool strict = false);\n@@ -646,0 +646,1 @@\n+  bool needs_revisit(Node* n) const;\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}