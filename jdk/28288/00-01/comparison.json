{"files":[{"patch":"@@ -2797,3 +2797,20 @@\n-  \/\/ Pull from worklist; compute new value; push changes out.\n-  \/\/ This loop is the meat of CCP.\n-  bool first_round = true;\n+  \/\/ This is the meat of CCP: pull from worklist; compute new value; push changes out.\n+\n+  \/\/ Do the first round.\n+  while (worklist.size() != 0) {\n+    Node* n = fetch_next_node(worklist);\n+    DEBUG_ONLY(worklist_verify.push(n);)\n+    if (needs_revisit(n)) {\n+      worklist_revisit.push(n);\n+    }\n+    if (n->is_SafePoint()) {\n+      \/\/ Make sure safepoints are processed by PhaseCCP::transform even if they are\n+      \/\/ not reachable from the bottom. Otherwise, infinite loops would be removed.\n+      _root_and_safepoints.push(n);\n+    }\n+    analyze_step(worklist, n);\n+  }\n+\n+  \/\/ More rounds to catch updates in revisited nodes.\n+  \/\/ Revisit nodes that might be able to refine their types at the end of the round.\n+  \/\/ If so, process these nodes. If there is remaining work, start another round.\n@@ -2801,1 +2818,0 @@\n-    \/\/ Start the CCP round.\n@@ -2804,23 +2820,1 @@\n-      if (first_round) {\n-        DEBUG_ONLY(worklist_verify.push(n);)\n-        if (needs_revisit(n)) {\n-          worklist_revisit.push(n);\n-        }\n-        if (n->is_SafePoint()) {\n-          \/\/ Make sure safepoints are processed by PhaseCCP::transform even if they are\n-          \/\/ not reachable from the bottom. Otherwise, infinite loops would be removed.\n-          _root_and_safepoints.push(n);\n-        }\n-      }\n-      const Type* new_type = n->Value(this);\n-      if (new_type != type(n)) {\n-        DEBUG_ONLY(verify_type(n, new_type, type(n));)\n-        dump_type_and_node(n, new_type);\n-        set_type(n, new_type);\n-        push_child_nodes_to_worklist(worklist, n);\n-      }\n-      if (KillPathsReachableByDeadTypeNode && n->is_Type() && new_type == Type::TOP) {\n-        \/\/ Keep track of Type nodes to kill CFG paths that use Type\n-        \/\/ nodes that become dead.\n-        _maybe_top_type_nodes.push(n);\n-      }\n+      analyze_step(worklist, n);\n@@ -2828,3 +2822,0 @@\n-\n-    \/\/ Check if any nodes slated for revisit are able to refine their types at the end of the round.\n-    \/\/ If so, push them to worklist to start another round and process them.\n@@ -2833,4 +2824,1 @@\n-      const Type* new_type = n->Value(this);\n-      if (new_type != type(n)) {\n-        worklist.push(n);\n-      }\n+      analyze_step(worklist, n);\n@@ -2838,3 +2826,0 @@\n-\n-    \/\/ First round is done.\n-    first_round = false;\n@@ -2846,0 +2831,15 @@\n+void PhaseCCP::analyze_step(Unique_Node_List& worklist, Node* n) {\n+  const Type* new_type = n->Value(this);\n+  if (new_type != type(n)) {\n+    DEBUG_ONLY(verify_type(n, new_type, type(n));)\n+    dump_type_and_node(n, new_type);\n+    set_type(n, new_type);\n+    push_child_nodes_to_worklist(worklist, n);\n+  }\n+  if (KillPathsReachableByDeadTypeNode && n->is_Type() && new_type == Type::TOP) {\n+    \/\/ Keep track of Type nodes to kill CFG paths that use Type\n+    \/\/ nodes that become dead.\n+    _maybe_top_type_nodes.push(n);\n+  }\n+}\n+\n@@ -2849,2 +2849,2 @@\n-\/\/ not handled by push_more_uses.\n-bool PhaseCCP::needs_revisit(Node *n) const {\n+\/\/ not handled by PhaseCCP::push_more_uses().\n+bool PhaseCCP::needs_revisit(Node* n) const {\n@@ -2856,1 +2856,1 @@\n-  if (n->Opcode() == Op_CmpP) {\n+  if (n->Opcode() == Op_CmpP && type(n->in(1))->isa_oopptr() && type(n->in(2))->isa_oopptr()) {\n@@ -2875,1 +2875,1 @@\n-  \/\/ or that they are added in PhaseCCP::maybe_needs_revisit() so that analysis revisits\n+  \/\/ or that they are added in PhaseCCP::needs_revisit() so that analysis revisits\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":41,"deletions":41,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -646,0 +646,1 @@\n+  void analyze_step(Unique_Node_List& worklist, Node* n);\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}