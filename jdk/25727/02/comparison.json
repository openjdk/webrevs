{"files":[{"patch":"@@ -40,0 +40,1 @@\n+import java.util.List;\n@@ -43,0 +44,1 @@\n+import java.util.Objects;\n@@ -47,0 +49,1 @@\n+import java.util.function.Supplier;\n@@ -384,11 +387,1 @@\n-    private static class ThreadTrackHolder {\n-        static final ThreadTracker TRACKER = new ThreadTracker();\n-    }\n-\n-    private static Object tryBeginLookup() {\n-        return ThreadTrackHolder.TRACKER.tryBegin();\n-    }\n-\n-    private static void endLookup(Object key) {\n-        ThreadTrackHolder.TRACKER.end(key);\n-    }\n+    private static final ScopedValue<Boolean> IN_LOOKUP = ScopedValue.newInstance();\n@@ -409,2 +402,1 @@\n-        Object key = tryBeginLookup();\n-        if (key == null) {\n+        if (IN_LOOKUP.isBound()) {\n@@ -415,9 +407,17 @@\n-            for (Iterator<CharsetProvider> i = providers(); i.hasNext();) {\n-                CharsetProvider cp = i.next();\n-                Charset cs = cp.charsetForName(charsetName);\n-                if (cs != null)\n-                    return cs;\n-            }\n-            return null;\n-        } finally {\n-            endLookup(key);\n+            return ScopedValue.where(IN_LOOKUP, true).call(\n+                    new ScopedValue.CallableOp<Charset, Exception>() {\n+                        @Override\n+                        public Charset call() {\n+                            for (Iterator<CharsetProvider> i = providers(); i.hasNext(); ) {\n+                                CharsetProvider cp = i.next();\n+                                Charset cs = cp.charsetForName(charsetName);\n+                                if (cs != null)\n+                                    return cs;\n+                            }\n+                            return null;\n+                        }\n+                    }\n+            );\n+        } catch (Exception t) {\n+            \/\/ Should not happen\n+            throw new RuntimeException(t);\n@@ -425,0 +425,1 @@\n+\n@@ -428,7 +429,7 @@\n-    private static class ExtendedProviderHolder {\n-        static final CharsetProvider[] extendedProviders = extendedProviders();\n-        \/\/ returns ExtendedProvider, if installed\n-        private static CharsetProvider[] extendedProviders() {\n-            CharsetProvider[] cps = new CharsetProvider[1];\n-            int n = 0;\n-            ServiceLoader<CharsetProvider> sl =\n+    private static final Supplier<List<CharsetProvider>> EXTENDED_PROVIDERS = StableValue.supplier(\n+            new Supplier<>() { public List<CharsetProvider> get() { return extendedProviders0(); }});\n+\n+    private static List<CharsetProvider> extendedProviders0() {\n+        CharsetProvider[] cps = new CharsetProvider[1];\n+        int n = 0;\n+        final ServiceLoader<CharsetProvider> sl =\n@@ -436,5 +437,3 @@\n-            for (CharsetProvider cp : sl) {\n-                if (n + 1 > cps.length) {\n-                    cps = Arrays.copyOf(cps, cps.length << 1);\n-                }\n-                cps[n++] = cp;\n+        for (CharsetProvider cp : sl) {\n+            if (n + 1 > cps.length) {\n+                cps = Arrays.copyOf(cps, cps.length << 1);\n@@ -442,1 +441,1 @@\n-            return n == cps.length ? cps : Arrays.copyOf(cps, n);\n+            cps[n++] = cp;\n@@ -444,0 +443,1 @@\n+        return List.of(n == cps.length ? cps : Arrays.copyOf(cps, n));\n@@ -449,2 +449,1 @@\n-        CharsetProvider[] ecps = ExtendedProviderHolder.extendedProviders;\n-        for (CharsetProvider cp : ecps) {\n+        for (CharsetProvider cp : EXTENDED_PROVIDERS.get()) {\n@@ -611,2 +610,1 @@\n-        CharsetProvider[] ecps = ExtendedProviderHolder.extendedProviders;\n-        for (CharsetProvider ecp :ecps) {\n+        for (CharsetProvider ecp : EXTENDED_PROVIDERS.get()) {\n@@ -622,1 +620,10 @@\n-    private @Stable static Charset defaultCharset;\n+    private static final Supplier<Charset> defaultCharset = StableValue.supplier(\n+            new Supplier<>() { public Charset get() { return defaultCharset0(); }});\n+\n+    private static Charset defaultCharset0() {\n+        \/\/ do not look for providers other than the standard one\n+        final Charset cs = standardProvider.charsetForName(StaticProperty.fileEncoding());\n+        return (cs == null)\n+                ? sun.nio.cs.UTF_8.INSTANCE\n+                : cs;\n+    }\n@@ -643,11 +650,1 @@\n-        if (defaultCharset == null) {\n-            synchronized (Charset.class) {\n-                \/\/ do not look for providers other than the standard one\n-                Charset cs = standardProvider.charsetForName(StaticProperty.fileEncoding());\n-                if (cs != null)\n-                    defaultCharset = cs;\n-                else\n-                    defaultCharset = sun.nio.cs.UTF_8.INSTANCE;\n-            }\n-        }\n-        return defaultCharset;\n+        return defaultCharset.get();\n@@ -659,3 +656,7 @@\n-    private final String name;          \/\/ tickles a bug in oldjavac\n-    private final String[] aliases;     \/\/ tickles a bug in oldjavac\n-    private Set<String> aliasSet;\n+    @Stable\n+    private final String name;\n+    @Stable\n+    private final String[] aliases;\n+    @Stable\n+    private final Supplier<Set<String>> aliasSet = StableValue.supplier(\n+            new Supplier<>() { public Set<String> get() { return Set.of(aliases); }});\n@@ -713,6 +714,1 @@\n-        Set<String> set = this.aliasSet;\n-        if (set == null) {\n-            set = Set.of(aliases);\n-            this.aliasSet = set;\n-        }\n-        return set;\n+        return aliasSet.get();\n","filename":"src\/java.base\/share\/classes\/java\/nio\/charset\/Charset.java","additions":56,"deletions":60,"binary":false,"changes":116,"status":"modified"}]}