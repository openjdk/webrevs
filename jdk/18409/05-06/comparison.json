{"files":[{"patch":"@@ -2598,0 +2598,1 @@\n+     *          A cipher implementation may accept a {@code null} value.\n@@ -2599,0 +2600,1 @@\n+     *          (must be greater than 0)\n@@ -2608,0 +2610,1 @@\n+     * @throws NullPointerException if {@code algorithm} is {@code null}\n@@ -2612,0 +2615,5 @@\n+        Objects.requireNonNull(algorithm);\n+        if (length <= 0) {\n+            throw new IllegalArgumentException(\"length cannot be negative\");\n+        }\n+        checkCipherState();\n@@ -2634,0 +2642,1 @@\n+     *          A cipher implementation may accept a {@code null} value.\n@@ -2635,0 +2644,1 @@\n+     *          (must be greater than 0)\n@@ -2649,0 +2659,4 @@\n+        if (length <= 0) {\n+            throw new IllegalArgumentException(\"length cannot be negative\");\n+        }\n+        checkCipherState();\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/Cipher.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -976,0 +976,1 @@\n+     *          A cipher implementation may accept a {@code null} value.\n@@ -1015,0 +1016,1 @@\n+     *          A cipher implementation may accept a {@code null} value.\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/CipherSpi.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-\/**\n+\/*\n@@ -27,2 +27,3 @@\n- * @library \/test\/lib\n- * @modules java.base\/javax.crypto:+open\n+ * @library \/test\/lib \/test\/jdk\/security\/unsignedjce\n+ * @build java.base\/javax.crypto.ProviderVerifier\n+ * @run main\/othervm Export\n@@ -36,0 +37,1 @@\n+import javax.crypto.KeyGenerator;\n@@ -41,0 +43,1 @@\n+import java.security.Provider;\n@@ -45,0 +48,6 @@\n+\n+    public static Provider PROVIDER = new Provider(\"X\", \"X\", \"X\") {{\n+        put(\"Cipher.X\", CipherImpl.class.getName());\n+        put(\"Cipher.NX\", CipherImplNoEx.class.getName());\n+    }};\n+\n@@ -47,1 +56,36 @@\n-        SecretKey sk = new SecretKeySpec(s2b(\"key\"), \"X\");\n+        \/\/ Not supported by AES cipher.\n+        Cipher c0 = Cipher.getInstance(\"AES\");\n+        c0.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(new byte[16], \"AES\"));\n+        Asserts.assertThrows(UnsupportedOperationException.class,\n+                () -> c0.exportKey(\"X\", s2b(\"one\"), 32));\n+        Asserts.assertThrows(UnsupportedOperationException.class,\n+                () -> c0.exportData(s2b(\"one\"), 32));\n+\n+        SecretKey key = new SecretKeySpec(s2b(\"key\"), \"X\");\n+\n+        \/\/ X cipher defined in this class supports exporting.\n+        Cipher c1 = Cipher.getInstance(\"X\", PROVIDER);\n+\n+        \/\/ Cipher not initialized\n+        Asserts.assertThrows(IllegalStateException.class,\n+                () -> c1.exportKey(\"X\", s2b(\"one\"), 32));\n+\n+        c1.init(Cipher.ENCRYPT_MODE, key);\n+\n+        \/\/ Several error cases\n+        Asserts.assertThrows(NullPointerException.class,\n+                () -> c1.exportKey(null, s2b(\"one\"), 32));\n+        Asserts.assertThrows(IllegalArgumentException.class,\n+                () -> c1.exportKey(\"X\", null, 32));\n+        Asserts.assertThrows(IllegalArgumentException.class,\n+                () -> c1.exportData(null, 32));\n+        Asserts.assertThrows(IllegalArgumentException.class,\n+                () -> c1.exportKey(\"X\", s2b(\"one\"), 0));\n+        Asserts.assertThrows(IllegalArgumentException.class,\n+                () -> c1.exportData(s2b(\"one\"), 0));\n+\n+        \/\/ Normal usages\n+        SecretKey sk1 = c1.exportKey(\"X\", s2b(\"one\"), 32);\n+        SecretKey sk1p = c1.exportKey(\"X\", s2b(\"two\"), 32);\n+        byte[] d1 = c1.exportData(s2b(\"one\"), 32);\n+        byte[] d1p = c1.exportData(s2b(\"two\"), 32);\n@@ -49,6 +93,3 @@\n-        Cipher c1 = newCipher();\n-        c1.init(Cipher.ENCRYPT_MODE, sk);\n-        SecretKey sk11 = c1.exportKey(\"X\", s2b(\"hi\"), 32);\n-        SecretKey sk12 = c1.exportKey(\"X\", s2b(\"ho\"), 32);\n-        byte[] b11 = c1.exportData(s2b(\"hi\"), 32);\n-        byte[] b12 = c1.exportData(s2b(\"ho\"), 32);\n+        \/\/ Different context strings return different exported data\n+        Asserts.assertNotEqualsByteArray(sk1.getEncoded(), sk1p.getEncoded());\n+        Asserts.assertNotEqualsByteArray(d1, d1p);\n@@ -56,4 +97,4 @@\n-        Cipher c2 = newCipher();\n-        c2.init(Cipher.ENCRYPT_MODE, sk);\n-        SecretKey sk21 = c2.exportKey(\"X\", s2b(\"hi\"), 32);\n-        byte[] b21 = c2.exportData(s2b(\"hi\"), 32);\n+        Cipher c2 = Cipher.getInstance(\"X\", PROVIDER);\n+        c2.init(Cipher.DECRYPT_MODE, key);\n+        SecretKey sk2 = c2.exportKey(\"X\", s2b(\"one\"), 32);\n+        byte[] d2 = c2.exportData(s2b(\"one\"), 32);\n@@ -61,4 +102,18 @@\n-        Asserts.assertEqualsByteArray(sk11.getEncoded(), sk21.getEncoded());\n-        Asserts.assertNotEqualsByteArray(sk11.getEncoded(), sk12.getEncoded());\n-        Asserts.assertEqualsByteArray(b11, b21);\n-        Asserts.assertNotEqualsByteArray(b11, b12);\n+        \/\/ Encryptor and decryptor export the same data\n+        Asserts.assertEqualsByteArray(sk1.getEncoded(), sk2.getEncoded());\n+        Asserts.assertEqualsByteArray(d1, d2);\n+\n+        \/\/ Initialized with a different key\n+        Cipher c3 = Cipher.getInstance(\"X\", PROVIDER);\n+        c3.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(s2b(\"another\"), \"X\"));\n+        byte[] d3 = c3.exportData(s2b(\"one\"), 32);\n+        Asserts.assertNotEqualsByteArray(d1, d3);\n+\n+        \/\/ NX cipher\n+        Cipher c4 = Cipher.getInstance(\"NX\", PROVIDER);\n+        c4.init(Cipher.ENCRYPT_MODE, key);\n+        c4.exportKey(\"X\", s2b(\"one\"), 32);\n+\n+        \/\/ NX does not support exportData\n+        Asserts.assertThrows(UnsupportedOperationException.class,\n+                () -> c4.exportData(s2b(\"one\"), 32));\n@@ -67,1 +122,1 @@\n-    static class CipherImpl extends CipherSpi {\n+    public static class CipherImpl extends CipherSpi {\n@@ -75,6 +130,6 @@\n-        protected void engineInit(int opmode, Key key, AlgorithmParameterSpec params, SecureRandom random) { }\n-        protected void engineInit(int opmode, Key key, AlgorithmParameters params, SecureRandom random) { }\n-        protected byte[] engineUpdate(byte[] input, int inputOffset, int inputLen) { return new byte[0]; }\n-        protected int engineUpdate(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset) { return 0; }\n-        protected byte[] engineDoFinal(byte[] input, int inputOffset, int inputLen) { return new byte[0]; }\n-        protected int engineDoFinal(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset) { return 0; }\n+        protected void engineInit(int o, Key k, AlgorithmParameterSpec p, SecureRandom r) { }\n+        protected void engineInit(int o, Key k, AlgorithmParameters p, SecureRandom r) { }\n+        protected byte[] engineUpdate(byte[] i, int o, int l) { return new byte[0]; }\n+        protected int engineUpdate(byte[] i, int o, int l, byte[] op, int opo) { return 0; }\n+        protected byte[] engineDoFinal(byte[] i, int o, int l) { return new byte[0]; }\n+        protected int engineDoFinal(byte[] i, int o, int l, byte[] op, int opo) { return 0; }\n@@ -89,1 +144,1 @@\n-            return new SecretKeySpec(engineExportData(context, length), algorithm);\n+            return new SecretKeySpec(exportInternal(context, length), algorithm);\n@@ -94,0 +149,7 @@\n+            return exportInternal(context, length);\n+        }\n+\n+        private byte[] exportInternal(byte[] context, int length) {\n+            if (context == null) {\n+                throw new IllegalArgumentException();\n+            }\n@@ -96,1 +158,1 @@\n-                output[i] = (byte)(context[i % context.length] ^ keyBytes[i % keyBytes.length]);\n+                output[i] = (byte) (context[i % context.length] ^ keyBytes[i % keyBytes.length]);\n@@ -102,4 +164,5 @@\n-    static Cipher newCipher() throws Exception {\n-        var ctor = Cipher.class.getDeclaredConstructor(CipherSpi.class, String.class);\n-        ctor.setAccessible(true);\n-        return ctor.newInstance(new CipherImpl(), \"X\");\n+    public static class CipherImplNoEx extends CipherImpl {\n+        @Override\n+        protected byte[] engineExportData(byte[] context, int length) {\n+            throw new UnsupportedOperationException(\"Not supported\");\n+        }\n","filename":"test\/jdk\/javax\/crypto\/Cipher\/Export.java","additions":94,"deletions":31,"binary":false,"changes":125,"status":"modified"}]}