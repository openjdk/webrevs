{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+exports sun.nio.fs to jdk.attach;\n","filename":"src\/java.base\/unix\/classes\/module-info.java.extra","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.io.File;\n@@ -34,0 +33,7 @@\n+import java.net.SocketAddress;\n+import java.net.StandardProtocolFamily;\n+import java.net.UnixDomainSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.Channels;\n+import java.nio.channels.SocketChannel;\n+import java.nio.file.FileAlreadyExistsException;\n@@ -36,2 +42,6 @@\n-import java.nio.file.Paths;\n-\n+import java.nio.file.attribute.GroupPrincipal;\n+import java.nio.file.attribute.PosixFileAttributes;\n+import java.nio.file.attribute.PosixFilePermission;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.nio.file.attribute.UserPrincipal;\n+import java.util.EnumSet;\n@@ -39,1 +49,1 @@\n-\n+import java.util.Set;\n@@ -42,1 +52,7 @@\n-import static java.nio.charset.StandardCharsets.UTF_8;\n+import jdk.internal.misc.VM;\n+import sun.nio.fs.UnixUserPrincipals;\n+\n+import static java.nio.file.attribute.PosixFilePermission.GROUP_READ;\n+import static java.nio.file.attribute.PosixFilePermission.GROUP_WRITE;\n+import static java.nio.file.attribute.PosixFilePermission.OTHERS_READ;\n+import static java.nio.file.attribute.PosixFilePermission.OTHERS_WRITE;\n@@ -60,1 +76,4 @@\n-    String socket_path;\n+    private static final Set<PosixFilePermission> NOT_EXPECTED_PERMISSIONS = EnumSet.of(GROUP_READ, GROUP_WRITE, OTHERS_READ, OTHERS_WRITE);\n+\n+    Path socket_path;\n+    private SocketAddress socket_address;\n@@ -63,0 +82,1 @@\n+\n@@ -82,3 +102,3 @@\n-        final File socket_file = findSocketFile(pid, ns_pid);\n-        socket_path = socket_file.getPath();\n-        if (!socket_file.exists()) {\n+        final Path socket_file = findSocketFile(pid, ns_pid);\n+        socket_path = socket_file;\n+        if (!Files.exists(socket_file)) {\n@@ -86,1 +106,1 @@\n-            File f = createAttachFile(pid, ns_pid).getCanonicalFile();\n+            Path f = createAttachFile(pid, ns_pid).toRealPath();\n@@ -107,1 +127,1 @@\n-                    if (time_spent > timeout\/2 && !socket_file.exists()) {\n+                    if (time_spent > timeout\/2 && !Files.exists(socket_file)) {\n@@ -111,1 +131,1 @@\n-                } while (!timedout && !socket_file.exists());\n+                } while (!timedout && !Files.exists(socket_file));\n@@ -113,1 +133,1 @@\n-                if (!socket_file.exists()) {\n+                if (!Files.exists(socket_file)) {\n@@ -120,1 +140,1 @@\n-                f.delete();\n+                Files.delete(f);\n@@ -128,0 +148,2 @@\n+        socket_address = UnixDomainSocketAddress.of(socket_path);\n+\n@@ -134,5 +156,2 @@\n-            int s = socket();\n-            try {\n-                connect(s, socket_path);\n-            } finally {\n-                close(s);\n+            try (SocketChannel s = SocketChannel.open(StandardProtocolFamily.UNIX)) {\n+                s.connect(socket_address);\n@@ -168,2 +187,1 @@\n-        int s = socket();\n-\n+        SocketChannel s = SocketChannel.open(StandardProtocolFamily.UNIX);\n@@ -172,1 +190,1 @@\n-            connect(s, socket_path);\n+            s.connect(socket_address);\n@@ -174,1 +192,1 @@\n-            close(s);\n+            s.close();\n@@ -190,1 +208,1 @@\n-        SocketInputStreamImpl sis = new SocketInputStreamImpl(s);\n+        InputStream sis = Channels.newInputStream(s);\n@@ -200,3 +218,3 @@\n-        private int fd;\n-        public SocketOutputStream(int fd) {\n-            this.fd = fd;\n+        private final SocketChannel channel;\n+        public SocketOutputStream(SocketChannel channel) {\n+            this.channel = channel;\n@@ -206,20 +224,2 @@\n-            VirtualMachineImpl.write(fd, buffer, offset, length);\n-        }\n-    }\n-\n-    \/*\n-     * InputStream for the socket connection to get target VM\n-     *\/\n-    private static class SocketInputStreamImpl extends SocketInputStream {\n-        public SocketInputStreamImpl(long fd) {\n-            super(fd);\n-        }\n-\n-        @Override\n-        protected int read(long fd, byte[] bs, int off, int len) throws IOException {\n-            return VirtualMachineImpl.read((int)fd, bs, off, len);\n-        }\n-\n-        @Override\n-        protected void close(long fd) throws IOException {\n-            VirtualMachineImpl.close((int)fd);\n+            ByteBuffer bb = ByteBuffer.wrap(buffer, offset, length);\n+            channel.write(bb);\n@@ -230,2 +230,2 @@\n-    private File findSocketFile(long pid, long ns_pid) throws AttachNotSupportedException, IOException {\n-        return new File(findTargetProcessTmpDirectory(pid, ns_pid), \".java_pid\" + ns_pid);\n+    private static Path findSocketFile(long pid, long ns_pid) throws AttachNotSupportedException, IOException {\n+        return findTargetProcessTmpDirectory(pid, ns_pid).resolve(\".java_pid\" + ns_pid);\n@@ -238,1 +238,1 @@\n-    private File createAttachFile(long pid, long ns_pid) throws AttachNotSupportedException, IOException {\n+    private static Path createAttachFile(long pid, long ns_pid) throws AttachNotSupportedException, IOException {\n@@ -241,1 +241,0 @@\n-        File f    = new File(path.toString());\n@@ -244,4 +243,4 @@\n-            f.createNewFile();\n-        } catch (IOException _) {\n-            f = new File(findTargetProcessTmpDirectory(pid, ns_pid), fn.toString());\n-            f.createNewFile();\n+            Files.createFile(path);\n+        } catch (FileAlreadyExistsException _) {\n+            path = findTargetProcessTmpDirectory(pid, ns_pid).resolve(fn);\n+            Files.createFile(path);\n@@ -249,1 +248,1 @@\n-        return f;\n+        return path;\n@@ -252,1 +251,1 @@\n-    private String findTargetProcessTmpDirectory(long pid, long ns_pid) throws AttachNotSupportedException, IOException {\n+    private static Path findTargetProcessTmpDirectory(long pid, long ns_pid) throws AttachNotSupportedException, IOException {\n@@ -278,1 +277,1 @@\n-        return (Files.isWritable(procPidRoot) ? procPidRoot : TMPDIR).toString();\n+        return Files.isWritable(procPidRoot) ? procPidRoot : TMPDIR;\n@@ -283,1 +282,1 @@\n-    private long getNamespacePid(long pid) throws AttachNotSupportedException, IOException {\n+    private static long getNamespacePid(long pid) throws AttachNotSupportedException, IOException {\n@@ -286,3 +285,2 @@\n-        final var statusFile = PROC.resolve(Long.toString(pid)).resolve(STATUS).toString();\n-        File f = new File(statusFile);\n-        if (!f.exists()) {\n+        final var statusPath = PROC.resolve(Long.toString(pid)).resolve(STATUS);\n+        if (!Files.exists(statusPath)) {\n@@ -292,2 +290,0 @@\n-        Path statusPath = Paths.get(statusFile);\n-\n@@ -382,5 +378,24 @@\n-    \/\/-- native methods\n-\n-    static native void sendQuitTo(int pid) throws IOException;\n-\n-    static native void checkPermissions(String path) throws IOException;\n+    private static void checkPermissions(Path path) throws IOException {\n+        UserPrincipal processUser = UnixUserPrincipals.fromUid((int) VM.geteuid());\n+        GroupPrincipal processGroup = UnixUserPrincipals.fromGid((int) VM.getegid());\n+\n+        PosixFileAttributes attributes = Files.readAttributes(path, PosixFileAttributes.class);\n+        UserPrincipal root = path.getFileSystem().getUserPrincipalLookupService().lookupPrincipalByName(\"root\");\n+        boolean isRoot = root.equals(processUser);\n+\n+        Set<PosixFilePermission> permissions = attributes.permissions();\n+        UserPrincipal fileOwner = attributes.owner();\n+        GroupPrincipal fileGroup = attributes.group();\n+\n+        if (!fileOwner.equals(processUser) && !isRoot) {\n+            throwFileNotSecure(path,\n+                \"file should be owned by the current user (which is \" + processUser + \") but is owned by \" + fileOwner);\n+        } else if (!fileGroup.equals(processGroup) && !isRoot) {\n+            throwFileNotSecure(path,\n+                \"file's group should be the current group (which is \" + fileGroup + \") but the group is \" + processGroup);\n+        } else if (!permissions.isEmpty()) {\n+            Set<PosixFilePermission> intersection = EnumSet.copyOf(permissions);\n+            intersection.retainAll(NOT_EXPECTED_PERMISSIONS);\n+            if (!intersection.isEmpty()) {\n+                throwFileNotSecure(path, \"file should only be readable and writable by the owner but has \"\n+                    + PosixFilePermissions.toString(permissions) + \" access\");\n@@ -388,3 +403,3 @@\n-    static native int socket() throws IOException;\n-\n-    static native void connect(int fd, String path) throws IOException;\n+            }\n+        }\n+    }\n@@ -392,1 +407,3 @@\n-    static native void close(int fd) throws IOException;\n+    private static void throwFileNotSecure(Path pathSpec, String message) throws IOException {\n+        throw new IOException(\"well-known file \" + pathSpec + \" is not secure: \" + message);\n+    }\n@@ -394,1 +411,1 @@\n-    static native int read(int fd, byte buf[], int off, int bufLen) throws IOException;\n+    \/\/-- native methods\n@@ -396,1 +413,1 @@\n-    static native void write(int fd, byte buf[], int off, int bufLen) throws IOException;\n+    static native void sendQuitTo(int pid) throws IOException;\n","filename":"src\/jdk.attach\/linux\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":92,"deletions":75,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,5 +28,0 @@\n-#include <sys\/socket.h>\n-#include <sys\/stat.h>\n-#include <sys\/types.h>\n-#include <sys\/un.h>\n-#include <errno.h>\n@@ -34,4 +29,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-#include <unistd.h>\n@@ -41,68 +32,0 @@\n-#define ROOT_UID 0\n-\n-\/*\n- * Declare library specific JNI_Onload entry if static build\n- *\/\n-DEF_STATIC_JNI_OnLoad\n-\n-\/*\n- * Class:     sun_tools_attach_VirtualMachineImpl\n- * Method:    socket\n- * Signature: ()I\n- *\/\n-JNIEXPORT jint JNICALL Java_sun_tools_attach_VirtualMachineImpl_socket\n-  (JNIEnv *env, jclass cls)\n-{\n-    int fd = socket(PF_UNIX, SOCK_STREAM, 0);\n-    if (fd == -1) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"socket\");\n-    }\n-    return (jint)fd;\n-}\n-\n-\/*\n- * Class:     sun_tools_attach_VirtualMachineImpl\n- * Method:    connect\n- * Signature: (ILjava\/lang\/String;)I\n- *\/\n-JNIEXPORT void JNICALL Java_sun_tools_attach_VirtualMachineImpl_connect\n-  (JNIEnv *env, jclass cls, jint fd, jstring path)\n-{\n-    jboolean isCopy;\n-    const char* p = GetStringPlatformChars(env, path, &isCopy);\n-    if (p != NULL) {\n-        struct sockaddr_un addr;\n-        int err = 0;\n-\n-        memset(&addr, 0, sizeof(addr));\n-        addr.sun_family = AF_UNIX;\n-        \/* strncpy is safe because addr.sun_path was zero-initialized before. *\/\n-        strncpy(addr.sun_path, p, sizeof(addr.sun_path) - 1);\n-\n-        if (connect(fd, (struct sockaddr*)&addr, sizeof(addr)) == -1) {\n-            err = errno;\n-        }\n-\n-        if (isCopy) {\n-            JNU_ReleaseStringPlatformChars(env, path, p);\n-        }\n-\n-        \/*\n-         * If the connect failed then we throw the appropriate exception\n-         * here (can't throw it before releasing the string as can't call\n-         * JNI with pending exception)\n-         *\/\n-        if (err != 0) {\n-            if (err == ENOENT) {\n-                JNU_ThrowByName(env, \"java\/io\/FileNotFoundException\", NULL);\n-            } else {\n-                char* msg = strdup(strerror(err));\n-                JNU_ThrowIOException(env, msg);\n-                if (msg != NULL) {\n-                    free(msg);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n@@ -121,138 +44,0 @@\n-\n-\/*\n- * Class:     sun_tools_attach_VirtualMachineImpl\n- * Method:    checkPermissions\n- * Signature: (Ljava\/lang\/String;)V\n- *\/\n-JNIEXPORT void JNICALL Java_sun_tools_attach_VirtualMachineImpl_checkPermissions\n-  (JNIEnv *env, jclass cls, jstring path)\n-{\n-    jboolean isCopy;\n-    const char* p = GetStringPlatformChars(env, path, &isCopy);\n-    if (p != NULL) {\n-        struct stat sb;\n-        uid_t uid, gid;\n-        int res;\n-\n-        memset(&sb, 0, sizeof(struct stat));\n-\n-        \/*\n-         * Check that the path is owned by the effective uid\/gid of this\n-         * process. Also check that group\/other access is not allowed.\n-         *\/\n-        uid = geteuid();\n-        gid = getegid();\n-\n-        res = stat(p, &sb);\n-        if (res != 0) {\n-            \/* save errno *\/\n-            res = errno;\n-        }\n-\n-        if (res == 0) {\n-            char msg[100];\n-            jboolean isError = JNI_FALSE;\n-            if (sb.st_uid != uid && uid != ROOT_UID) {\n-                snprintf(msg, sizeof(msg),\n-                    \"file should be owned by the current user (which is %d) but is owned by %d\", uid, sb.st_uid);\n-                isError = JNI_TRUE;\n-            } else if (sb.st_gid != gid && uid != ROOT_UID) {\n-                snprintf(msg, sizeof(msg),\n-                    \"file's group should be the current group (which is %d) but the group is %d\", gid, sb.st_gid);\n-                isError = JNI_TRUE;\n-            } else if ((sb.st_mode & (S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH)) != 0) {\n-                snprintf(msg, sizeof(msg),\n-                    \"file should only be readable and writable by the owner but has 0%03o access\", sb.st_mode & 0777);\n-                isError = JNI_TRUE;\n-            }\n-            if (isError) {\n-                char buf[256];\n-                snprintf(buf, sizeof(buf), \"well-known file %s is not secure: %s\", p, msg);\n-                JNU_ThrowIOException(env, buf);\n-            }\n-        } else {\n-            char* msg = strdup(strerror(res));\n-            JNU_ThrowIOException(env, msg);\n-            if (msg != NULL) {\n-                free(msg);\n-            }\n-        }\n-\n-        if (isCopy) {\n-            JNU_ReleaseStringPlatformChars(env, path, p);\n-        }\n-    }\n-}\n-\n-\/*\n- * Class:     sun_tools_attach_VirtualMachineImpl\n- * Method:    close\n- * Signature: (I)V\n- *\/\n-JNIEXPORT void JNICALL Java_sun_tools_attach_VirtualMachineImpl_close\n-  (JNIEnv *env, jclass cls, jint fd)\n-{\n-    shutdown(fd, SHUT_RDWR);\n-    close(fd);\n-}\n-\n-\/*\n- * Class:     sun_tools_attach_VirtualMachineImpl\n- * Method:    read\n- * Signature: (I[BI)I\n- *\/\n-JNIEXPORT jint JNICALL Java_sun_tools_attach_VirtualMachineImpl_read\n-  (JNIEnv *env, jclass cls, jint fd, jbyteArray ba, jint off, jint baLen)\n-{\n-    unsigned char buf[128];\n-    size_t len = sizeof(buf);\n-    ssize_t n;\n-\n-    size_t remaining = (size_t)(baLen - off);\n-    if (len > remaining) {\n-        len = remaining;\n-    }\n-\n-    RESTARTABLE(read(fd, buf, len), n);\n-    if (n == -1) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"read\");\n-    } else {\n-        if (n == 0) {\n-            n = -1;     \/\/ EOF\n-        } else {\n-            (*env)->SetByteArrayRegion(env, ba, off, (jint)n, (jbyte *)(buf));\n-        }\n-    }\n-    return n;\n-}\n-\n-\/*\n- * Class:     sun_tools_attach_VirtualMachineImpl\n- * Method:    write\n- * Signature: (I[B)V\n- *\/\n-JNIEXPORT void JNICALL Java_sun_tools_attach_VirtualMachineImpl_write\n-  (JNIEnv *env, jclass cls, jint fd, jbyteArray ba, jint off, jint bufLen)\n-{\n-    size_t remaining = bufLen;\n-    do {\n-        unsigned char buf[128];\n-        size_t len = sizeof(buf);\n-        int n;\n-\n-        if (len > remaining) {\n-            len = remaining;\n-        }\n-        (*env)->GetByteArrayRegion(env, ba, off, len, (jbyte *)buf);\n-\n-        RESTARTABLE(write(fd, buf, len), n);\n-        if (n > 0) {\n-            off += n;\n-            remaining -= n;\n-        } else {\n-            JNU_ThrowIOExceptionWithLastError(env, \"write\");\n-            return;\n-        }\n-\n-    } while (remaining > 0);\n-}\n","filename":"src\/jdk.attach\/linux\/native\/libattach\/VirtualMachineImpl.c","additions":1,"deletions":216,"binary":false,"changes":217,"status":"modified"}]}