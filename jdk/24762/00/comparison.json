{"files":[{"patch":"@@ -77,1 +77,1 @@\n-                        MacCertificate certificate = new MacCertificate(result);\n+                        MacCertificate certificate = new MacCertificate(result, keychain);\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacAppBundler.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+import java.util.HexFormat;\n@@ -44,1 +45,2 @@\n-import java.util.HexFormat;\n+import java.util.Objects;\n+import java.util.Optional;\n@@ -50,0 +52,1 @@\n+    private final Optional<String> keychainName;\n@@ -51,2 +54,3 @@\n-    public MacCertificate(String certificate) {\n-        this.certificate = certificate;\n+    public MacCertificate(String certificate, String keychainName) {\n+        this.certificate = Objects.requireNonNull(certificate);\n+        this.keychainName = Optional.ofNullable(keychainName);\n@@ -56,1 +60,1 @@\n-        return verifyCertificate(this.certificate);\n+        return verifyCertificate();\n@@ -298,1 +302,1 @@\n-    private boolean verifyCertificate(String certificate) {\n+    private boolean verifyCertificate() {\n@@ -306,1 +310,1 @@\n-                file = getFindCertificateOutputPEM(certificate, null);\n+                file = getFindCertificateOutputPEM(certificate, keychainName.orElse(null));\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacCertificate.java","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -133,1 +133,1 @@\n-                        MacCertificate certificate = new MacCertificate(result);\n+                        MacCertificate certificate = new MacCertificate(result, keychain);\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPkgBundler.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n@@ -35,0 +34,1 @@\n+import java.io.BufferedInputStream;\n@@ -45,0 +45,1 @@\n+import java.security.cert.CertificateExpiredException;\n@@ -46,0 +47,1 @@\n+import java.security.cert.CertificateNotYetValidException;\n@@ -66,0 +68,1 @@\n+import jdk.jpackage.internal.util.function.ThrowingSupplier;\n@@ -396,3 +399,17 @@\n-            final var in = new ByteArrayInputStream(\n-                    security(\"find-certificate\", \"-ap\", name).saveOutput().execute().getOutput().stream().collect(joining(\"\\n\")).getBytes(StandardCharsets.UTF_8));\n-            return toFunction(CERT_FACTORY::generateCertificates).apply(in).stream().map(X509Certificate.class::cast).toList();\n+            final List<X509Certificate> certs = new ArrayList<>();\n+            try (final var in = new BufferedInputStream(new ByteArrayInputStream(\n+                    security(\"find-certificate\", \"-ap\", name).executeAndGetOutput().stream().collect(joining(\"\\n\")).getBytes(StandardCharsets.UTF_8)))) {\n+                while (in.available() > 0) {\n+                    final X509Certificate cert;\n+                    try {\n+                        cert = (X509Certificate)CERT_FACTORY.generateCertificate(in);\n+                    } catch (Exception ex) {\n+                        TKit.trace(\"Failed to parse certificate data: \" + ex);\n+                        continue;\n+                    }\n+                    certs.add(cert);\n+                }\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+            return certs;\n@@ -403,2 +420,25 @@\n-            .addArguments(keychains.stream().map(Keychain::name).toList())\n-            .execute();\n+                    .addArguments(keychains.stream().map(Keychain::name).toList())\n+                    .execute();\n+        }\n+\n+        public static void withAddedKeychains(Collection<Keychain> keychains, Runnable runnable) {\n+            final var curKeychains = activeKeychainFiles();\n+            addToSearchList(keychains);\n+            try {\n+                runnable.run();\n+            } finally {\n+                security(\"list-keychains\", \"-d\", \"user\", \"-s\")\n+                        .addArguments(curKeychains.stream().map(Path::toString).toList())\n+                        .execute();\n+            }\n+        }\n+\n+        private static List<Path> activeKeychainFiles() {\n+            \/\/ $ security list-keychains\n+            \/\/     \"\/Users\/alexeysemenyuk\/Library\/Keychains\/login.keychain-db\"\n+            \/\/     \"\/Library\/Keychains\/System.keychain\"\n+            return security(\"list-keychains\", \"-d\", \"user\").executeAndGetOutput().stream().map(line -> {\n+                return line.stripLeading();\n+            }).filter(line -> {\n+                return line.charAt(0) == '\"' && line.charAt(line.length() - 1) == '\"';\n+            }).map(line -> line.substring(1, line.length() - 1)).map(Path::of).toList();\n@@ -412,1 +452,10 @@\n-    record ResolvedCertificateRequest(CertificateRequest request, X509Certificate cert, VerifyStatus verifyStatus) {\n+    private enum VerifyStatus {\n+        VERIFY_OK,\n+        VERIFY_EXPIRED,\n+        VERIFY_ERROR,\n+        VERIFY_UNTRUSTED,\n+        VERIFY_EXPIRED_UNTRUSTED,\n+        UNVERIFIED\n+    }\n+\n+    private record ResolvedCertificateRequest(InstalledCertificate installed, X509Certificate cert, VerifyStatus verifyStatus) {\n@@ -414,1 +463,1 @@\n-            Objects.requireNonNull(request);\n+            Objects.requireNonNull(installed);\n@@ -419,4 +468,6 @@\n-        enum VerifyStatus {\n-            VERIFY_OK,\n-            VERIFY_ERROR,\n-            UNVERIFIED\n+        CertificateRequest request() {\n+            if (!verified()) {\n+                throw new IllegalStateException();\n+            }\n+            return new CertificateRequest(installed.name(), installed.type(), installed.days(), installed.expired(),\n+                    Set.of(VerifyStatus.VERIFY_OK, VerifyStatus.VERIFY_EXPIRED).contains(verifyStatus));\n@@ -426,1 +477,1 @@\n-            this(new CertificateRequest(cert), cert, VerifyStatus.UNVERIFIED);\n+            this(new InstalledCertificate(cert), cert, VerifyStatus.UNVERIFIED);\n@@ -429,3 +480,9 @@\n-        ResolvedCertificateRequest copyVerified(boolean verifySuccess) {\n-            return new ResolvedCertificateRequest(request, cert,\n-                    verifySuccess ? VerifyStatus.VERIFY_OK : VerifyStatus.VERIFY_ERROR);\n+        ResolvedCertificateRequest copyVerified(VerifyStatus verifyStatus) {\n+            if (verifyStatus == VerifyStatus.UNVERIFIED) {\n+                throw new IllegalArgumentException();\n+            }\n+            return new ResolvedCertificateRequest(installed, cert, verifyStatus);\n+        }\n+\n+        private boolean verified() {\n+            return verifyStatus != VerifyStatus.UNVERIFIED;\n@@ -435,2 +492,2 @@\n-    record CertificateStats(List<ResolvedCertificateRequest> allResolvedCertificateRequests,\n-            List<X509Certificate> allCertificates, List<CertificateRequest> knownCertificateRequests,\n+    private record CertificateStats(List<ResolvedCertificateRequest> allResolvedCertificateRequests,\n+            List<CertificateRequest> knownCertificateRequests,\n@@ -439,1 +496,1 @@\n-        private static CertificateStats get(KeychainWithCertsSpec spec) {\n+        static CertificateStats get(KeychainWithCertsSpec spec) {\n@@ -445,1 +502,1 @@\n-                return allResolvedCertificateRequests.stream().filter(v -> {\n+                return allVerifiedResolvedCertificateRequest().filter(v -> {\n@@ -453,2 +510,2 @@\n-                return allResolvedCertificateRequests.stream().anyMatch(v -> {\n-                    return v.request().equals(certificateRequest) && v.verifyStatus() == ResolvedCertificateRequest.VerifyStatus.VERIFY_ERROR;\n+                return allVerifiedResolvedCertificateRequest().anyMatch(v -> {\n+                    return v.request().equals(certificateRequest) && v.verifyStatus() != certificateRequest.expectedVerifyStatus();\n@@ -461,1 +518,5 @@\n-                    allResolvedCertificateRequests.stream().map(ResolvedCertificateRequest::request).collect(toSet())).unique1();\n+                    allVerifiedResolvedCertificateRequest().map(ResolvedCertificateRequest::request).collect(toSet())).unique1();\n+        }\n+\n+        private Stream<ResolvedCertificateRequest> allVerifiedResolvedCertificateRequest() {\n+            return allResolvedCertificateRequests.stream().filter(ResolvedCertificateRequest::verified);\n@@ -485,1 +546,1 @@\n-                    if (spec.certificateRequests().contains(resolvedCertificateRequest.request)) {\n+                    if (spec.certificateRequests().stream().anyMatch(resolvedCertificateRequest.installed()::match)) {\n@@ -487,2 +548,2 @@\n-                        final var verifySuccess = verifyCertificate(resolvedCertificateRequest, spec.keychain(), certFile);\n-                        resolvedCertificateRequest = resolvedCertificateRequest.copyVerified(verifySuccess);\n+                        final var verifyStatus = verifyCertificate(resolvedCertificateRequest, spec.keychain(), certFile);\n+                        resolvedCertificateRequest = resolvedCertificateRequest.copyVerified(verifyStatus);\n@@ -495,1 +556,1 @@\n-            return new CertificateStats(allResolvedCertificateRequests, List.copyOf(allCertificates),\n+            return new CertificateStats(allResolvedCertificateRequests,\n@@ -502,1 +563,1 @@\n-    record PemData(String label, byte[] data) {\n+    private record PemData(String label, byte[] data) {\n@@ -535,1 +596,14 @@\n-        private final static Base64.Encoder ENCODER = Base64.getMimeEncoder(64, \"\\n\".getBytes());\n+        private static final Base64.Encoder ENCODER = Base64.getMimeEncoder(64, \"\\n\".getBytes());\n+    }\n+\n+    public enum DigestAlgorithm {\n+        SHA1(20, () -> MessageDigest.getInstance(\"SHA-1\")),\n+        SHA256(32, () -> MessageDigest.getInstance(\"SHA-256\"));\n+\n+        DigestAlgorithm(int hashLength, ThrowingSupplier<MessageDigest> createDigest) {\n+            this.hashLength = hashLength;\n+            this.createDigest = createDigest;\n+        }\n+\n+        final int hashLength;\n+        final ThrowingSupplier<MessageDigest> createDigest;\n@@ -538,1 +612,1 @@\n-    public record CertificateHash(byte[] value) {\n+    public record CertificateHash(byte[] value, DigestAlgorithm alg) {\n@@ -541,2 +615,3 @@\n-            if (value.length != 20) {\n-                throw new IllegalArgumentException(\"Invalid SHA-1 hash\");\n+            Objects.requireNonNull(alg);\n+            if (value.length != alg.hashLength) {\n+                throw new IllegalArgumentException(String.format(\"Invalid %s hash\", alg));\n@@ -547,0 +622,4 @@\n+            return of(cert, DigestAlgorithm.SHA1);\n+        }\n+\n+        public static CertificateHash of(X509Certificate cert, DigestAlgorithm alg) {\n@@ -548,1 +627,1 @@\n-                final MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n+                final MessageDigest md = alg.createDigest.get();\n@@ -551,1 +630,1 @@\n-            }).get());\n+            }).get(), alg);\n@@ -604,1 +683,23 @@\n-    public record CertificateRequest(String name, CertificateType type, int days) implements Comparable<CertificateRequest>{\n+    public enum StandardCertificateNamePrefix {\n+        CODE_SIGND(\"Developer ID Application: \"),\n+        INSTALLER(\"Developer ID Installer: \");\n+\n+        StandardCertificateNamePrefix(String value) {\n+            this.value = Objects.requireNonNull(value);\n+        }\n+\n+        public String value( ) {\n+            return value;\n+        }\n+\n+        private final String value;\n+    }\n+\n+    public record NameWithPrefix(String prefix, String name) {\n+        public NameWithPrefix {\n+            Objects.requireNonNull(prefix);\n+            Objects.requireNonNull(name);\n+        }\n+    }\n+\n+    public record CertificateRequest(String name, CertificateType type, int days, boolean expired, boolean trusted) implements Comparable<CertificateRequest>{\n@@ -608,0 +709,3 @@\n+            if (days <= 0) {\n+                throw new IllegalArgumentException();\n+            }\n@@ -610,2 +714,22 @@\n-        CertificateRequest(X509Certificate cert) {\n-            this(getSubjectCN(cert), getType(cert), getDurationInDays(cert));\n+        public String shortName() {\n+            return nameWithPrefix().map(NameWithPrefix::name).orElseThrow();\n+        }\n+\n+        public Optional<NameWithPrefix> nameWithPrefix() {\n+            return Stream.of(StandardCertificateNamePrefix.values()).map(StandardCertificateNamePrefix::value).filter(prefix -> {\n+                return name.startsWith(prefix);\n+            }).map(prefix -> {\n+                return new NameWithPrefix(prefix, name.substring(prefix.length()));\n+            }).findAny();\n+        }\n+\n+        VerifyStatus expectedVerifyStatus() {\n+            if (expired && !trusted) {\n+                return VerifyStatus.VERIFY_EXPIRED_UNTRUSTED;\n+            } else if (!trusted) {\n+                return VerifyStatus.VERIFY_UNTRUSTED;\n+            } else if (expired) {\n+                return VerifyStatus.VERIFY_EXPIRED;\n+            }else {\n+                return VerifyStatus.VERIFY_OK;\n+            }\n@@ -626,2 +750,2 @@\n-            public Builder commonName(String v) {\n-                commonName = v;\n+            public Builder subjectCommonName(String v) {\n+                subjectCommonName = v;\n@@ -641,0 +765,18 @@\n+            public Builder expired(boolean v) {\n+                expired = v;\n+                return this;\n+            }\n+\n+            public Builder expired() {\n+                return expired(true);\n+            }\n+\n+            public Builder trusted(boolean v) {\n+                trusted = v;\n+                return this;\n+            }\n+\n+            public Builder untrusted() {\n+                return trusted(false);\n+            }\n+\n@@ -642,1 +784,1 @@\n-                return new CertificateRequest(validatedCN(), type, days);\n+                return new CertificateRequest(validatedCN(), type, days, expired, trusted);\n@@ -650,1 +792,1 @@\n-                return Optional.ofNullable(commonName).orElseGet(() -> {\n+                return Optional.ofNullable(subjectCommonName).orElseGet(() -> {\n@@ -653,1 +795,1 @@\n-                            return \"Developer ID Application: \" + validatedUserName();\n+                            return StandardCertificateNamePrefix.CODE_SIGND.value() + validatedUserName();\n@@ -656,1 +798,1 @@\n-                            return \"Developer ID Installer: \" + validatedUserName();\n+                            return StandardCertificateNamePrefix.INSTALLER.value() + validatedUserName();\n@@ -666,1 +808,1 @@\n-            private String commonName; \/\/ CN\n+            private String subjectCommonName; \/\/ CN\n@@ -669,0 +811,32 @@\n+            private boolean expired;\n+            private boolean trusted = true;\n+        }\n+\n+        private static final Comparator<CertificateRequest> COMPARATOR =\n+                Comparator.comparing(CertificateRequest::name)\n+                .thenComparing(Comparator.comparing(CertificateRequest::type))\n+                .thenComparing(Comparator.comparingInt(CertificateRequest::days))\n+                .thenComparing(Comparator.comparing(CertificateRequest::expired, Boolean::compare))\n+                .thenComparing(Comparator.comparing(CertificateRequest::trusted, Boolean::compare));\n+    }\n+\n+    private record InstalledCertificate(String name, CertificateType type, int days, boolean expired) implements Comparable<InstalledCertificate>{\n+        InstalledCertificate {\n+            Objects.requireNonNull(name);\n+            Objects.requireNonNull(type);\n+            if (days <= 0) {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        InstalledCertificate(X509Certificate cert) {\n+            this(getSubjectCN(cert), getType(cert), getDurationInDays(cert), getExpired(cert));\n+        }\n+\n+        boolean match(CertificateRequest request) {\n+            return name.equals(request.name()) && type.equals(request.type()) && days == request.days() && expired == request.expired();\n+        }\n+\n+        @Override\n+        public int compareTo(InstalledCertificate o) {\n+            return COMPARATOR.compare(this, o);\n@@ -703,4 +877,14 @@\n-        private static final Comparator<CertificateRequest> COMPARATOR =\n-                Comparator.comparing(CertificateRequest::name)\n-                .thenComparing(Comparator.comparing(CertificateRequest::type))\n-                .thenComparing(Comparator.comparingInt(CertificateRequest::days));\n+        private static boolean getExpired(X509Certificate cert) {\n+            try {\n+                cert.checkValidity();\n+                return false;\n+            } catch (CertificateExpiredException | CertificateNotYetValidException ex) {\n+                return true;\n+            }\n+        }\n+\n+        private static final Comparator<InstalledCertificate> COMPARATOR =\n+                Comparator.comparing(InstalledCertificate::name)\n+                .thenComparing(Comparator.comparing(InstalledCertificate::type))\n+                .thenComparing(Comparator.comparingInt(InstalledCertificate::days))\n+                .thenComparing(Comparator.comparing(InstalledCertificate::expired, Boolean::compare));\n@@ -720,0 +904,2 @@\n+     * <p>\n+     * Created keychains will NOT be added to the keychain search list.\n@@ -770,1 +956,3 @@\n-                trustConfig.put(certPemFile.getValue(), keychains.getFirst());\n+                if (certPemFile.getKey().trusted()) {\n+                    trustConfig.put(certPemFile.getValue(), keychains.getFirst());\n+                }\n@@ -776,2 +964,0 @@\n-\n-        Keychain.addToSearchList(specs.stream().map(KeychainWithCertsSpec::keychain).toList());\n@@ -823,1 +1009,1 @@\n-                    .sorted(Comparator.comparing(ResolvedCertificateRequest::request)).toList();\n+                    .sorted(Comparator.comparing(ResolvedCertificateRequest::installed)).toList();\n@@ -827,1 +1013,1 @@\n-                        resolvedCertificateRequest.request(),\n+                        resolvedCertificateRequest.installed(),\n@@ -852,1 +1038,25 @@\n-    public static Map<CertificateRequest, X509Certificate> mapCertificateRequests(KeychainWithCertsSpec spec) {\n+    public final static class ResolvedKeychain {\n+        public ResolvedKeychain(KeychainWithCertsSpec spec) {\n+            this.spec = Objects.requireNonNull(spec);\n+        }\n+\n+        public KeychainWithCertsSpec spec() {\n+            return spec;\n+        }\n+\n+        public Map<CertificateRequest, X509Certificate> mapCertificateRequests() {\n+            if (certMap == null) {\n+                synchronized(this) {\n+                    if (certMap == null) {\n+                        certMap = MacSign.mapCertificateRequests(spec);\n+                    }\n+                }\n+            }\n+            return certMap;\n+        }\n+\n+        private final KeychainWithCertsSpec spec;\n+        private volatile Map<CertificateRequest, X509Certificate> certMap;\n+    }\n+\n+    private static Map<CertificateRequest, X509Certificate> mapCertificateRequests(KeychainWithCertsSpec spec) {\n@@ -879,1 +1089,1 @@\n-    private static boolean verifyCertificate(ResolvedCertificateRequest resolvedCertificateRequest, Keychain keychain, Path certFile) {\n+    private static VerifyStatus verifyCertificate(ResolvedCertificateRequest resolvedCertificateRequest, Keychain keychain, Path certFile) {\n@@ -881,2 +1091,4 @@\n-        for (final var mode : List.of(\"-q\", \"-v\")) {\n-            final var ok = security(\"verify-cert\", \"-L\", \"-n\", mode,\n+        Executor.Result result = null;\n+        for (final var quite : List.of(true, false)) {\n+            result = security(\"verify-cert\", \"-L\", \"-n\",\n+                    quite ? \"-q\" : \"-v\",\n@@ -885,3 +1097,3 @@\n-                    \"-p\", resolvedCertificateRequest.request().type().verifyPolicy()).executeWithoutExitCodeCheck().getExitCode() == 0;\n-            if (ok) {\n-                return true;\n+                    \"-p\", resolvedCertificateRequest.installed().type().verifyPolicy()).saveOutput(!quite).executeWithoutExitCodeCheck();\n+            if (result.exitCode() == 0) {\n+                return VerifyStatus.VERIFY_OK;\n@@ -890,1 +1102,20 @@\n-        return false;\n+\n+        final var expired = result.getOutput().stream().anyMatch(line -> {\n+            \/\/ Look up for \"Certificate has expired, or is not yet valid (check date) [TemporalValidity]\" string\n+            return line.contains(\"    Certificate has expired, or is not yet valid (check date) [TemporalValidity]\");\n+        });\n+\n+        final var untrusted = result.getOutput().stream().anyMatch(line -> {\n+            \/\/ Look up for \"The root of the certificate chain is not trusted [AnchorTrusted]\" string\n+            return line.contains(\"    The root of the certificate chain is not trusted [AnchorTrusted]\");\n+        });\n+\n+        if (expired && untrusted) {\n+            return VerifyStatus.VERIFY_EXPIRED_UNTRUSTED;\n+        } else if (untrusted) {\n+            return VerifyStatus.VERIFY_UNTRUSTED;\n+        } else if (expired) {\n+            return VerifyStatus.VERIFY_EXPIRED;\n+        } else {\n+            return VerifyStatus.VERIFY_ERROR;\n+        }\n@@ -971,1 +1202,9 @@\n-                        final var openssl = Executor.of(OPENSSL.toString(), \"req\",\n+                        final Executor openssl;\n+                        if (certificateRequest.expired()) {\n+                            final var format = String.format(\"-%dd\", certificateRequest.days + 1);\n+                            openssl = Executor.of(FAKETIME.toString(), \"-f\", format, OPENSSL.toString());\n+                        } else {\n+                            openssl = Executor.of(OPENSSL.toString());\n+                        }\n+\n+                        openssl.addArguments(\"req\",\n@@ -1043,0 +1282,4 @@\n+\n+    \/\/ faketime is not a standard macOS command.\n+    \/\/ One way to get it is with Homebrew.\n+    private static final Path FAKETIME = Path.of(Optional.ofNullable(TKit.getConfigProperty(\"faketime\")).orElse(\"faketime\"));\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacSign.java","additions":305,"deletions":62,"binary":false,"changes":367,"status":"modified"},{"patch":"@@ -0,0 +1,229 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n+import static jdk.jpackage.test.MacSign.DigestAlgorithm.SHA256;\n+\n+import java.nio.file.Path;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.HexFormat;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import jdk.jpackage.internal.util.PListReader;\n+import jdk.jpackage.test.MacSign.CertificateHash;\n+import jdk.jpackage.test.MacSign.CertificateRequest;\n+\n+\/**\n+ * Utilities to verify sign signatures.\n+ *\/\n+public final class MacSignVerify {\n+\n+    public static void assertSigned(Path path, CertificateRequest certRequest) {\n+        assertSigned(path);\n+        TKit.assertEquals(certRequest.name(), findCodesignSignOrigin(path).orElse(null),\n+                String.format(\"Check [%s] signed with certificate\", path));\n+    }\n+\n+    public static void assertAdhocSigned(Path path) {\n+        assertSigned(path);\n+        TKit.assertEquals(ADHOC_SIGN_ORIGIN, findCodesignSignOrigin(path).orElse(null),\n+                String.format(\"Check [%s] signed with adhoc signature\", path));\n+    }\n+\n+    public static void assertUnsigned(Path path) {\n+        TKit.assertTrue(findSpctlSignOrigin(SpctlType.EXEC, path).isEmpty(),\n+                String.format(\"Check [%s] unsigned\", path));\n+    }\n+\n+    public static void assertPkgSigned(Path path, CertificateRequest certRequest, X509Certificate cert) {\n+        final var expectedCertChain = List.of(new SignIdentity(certRequest.name(), CertificateHash.of(cert, SHA256)));\n+        final var actualCertChain = getPkgCertificateChain(path);\n+        TKit.assertStringListEquals(\n+                expectedCertChain.stream().map(SignIdentity::toString).toList(),\n+                actualCertChain.stream().map(SignIdentity::toString).toList(),\n+                String.format(\"Check certificate chain of [%s] is as expected\", path));\n+        TKit.assertEquals(certRequest.name(), findSpctlSignOrigin(SpctlType.INSTALL, path).orElse(null),\n+                String.format(\"Check [%s] signed for installation\", path));\n+    }\n+\n+    public enum SpctlType {\n+        EXEC(\"exec\"), INSTALL(\"install\");\n+\n+        SpctlType(String value) {\n+            this.value = Objects.requireNonNull(value);\n+        }\n+\n+        public String value() {\n+            return value;\n+        }\n+\n+        final private String value;\n+    }\n+\n+    public static final String ADHOC_SIGN_ORIGIN = \"-\";\n+\n+    public static Optional<String> findSpctlSignOrigin(SpctlType type, Path path) {\n+        final var exec = Executor.of(\"\/usr\/sbin\/spctl\", \"-vv\", \"--raw\", \"--assess\", \"--type\", type.value(), path.toString()).saveOutput().discardStderr();\n+        final var result = exec.executeWithoutExitCodeCheck();\n+        TKit.assertTrue(Set.of(0, 3).contains(result.exitCode()),\n+                String.format(\"Check exit code of command %s is either 0 or 3\", exec.getPrintableCommandLine()));\n+        return toSupplier(() -> {\n+            try {\n+                return Optional.of(new PListReader(String.join(\"\", result.getOutput()).getBytes()).queryValue(\"assessment:originator\"));\n+            } catch (NoSuchElementException ex) {\n+                return Optional.<String>empty();\n+            }\n+        }).get();\n+    }\n+\n+    public static Optional<String> findCodesignSignOrigin(Path path) {\n+        final var exec = Executor.of(\"\/usr\/bin\/codesign\", \"--display\", \"--verbose=4\", path.toString()).saveOutput();\n+        final var result = exec.executeWithoutExitCodeCheck();\n+        if (result.getExitCode() == 0) {\n+            return Optional.of(result.getOutput().stream().map(line -> {\n+                if (line.equals(\"Signature=adhoc\")) {\n+                    return ADHOC_SIGN_ORIGIN;\n+                } else if (line.startsWith(\"Authority=\")) {\n+                    return line.substring(\"Authority=\".length());\n+                } else {\n+                    return null;\n+                }\n+            }).filter(Objects::nonNull).reduce((x, y) -> {\n+                throw new UnsupportedOperationException(String.format(\n+                        \"Both adhoc [%s] and certificate [%s] signatures found in codesign output\", x, y));\n+            }).orElseThrow(() -> {\n+                final var msg = \"Neither adhoc nor certificate signatures found in codesign output\";\n+                TKit.trace(msg + \":\");\n+                result.getOutput().forEach(TKit::trace);\n+                TKit.trace(\"Done\");\n+                return new UnsupportedOperationException(msg);\n+            }));\n+        } else if (result.getExitCode() == 1 && result.getFirstLineOfOutput().endsWith(\"code object is not signed at all\")) {\n+            return Optional.empty();\n+        } else {\n+            reportUnexpectedCommandOutcome(exec.getPrintableCommandLine(), result);\n+            return null; \/\/ Unreachable\n+        }\n+    }\n+\n+    public static void assertSigned(Path path) {\n+        final var verifier = TKit.TextStreamVerifier.group()\n+                .add(TKit.assertTextStream(\": valid on disk\").predicate(String::endsWith))\n+                .add(TKit.assertTextStream(\": satisfies its Designated Requirement\").predicate(String::endsWith))\n+                .create();\n+        verifier.accept(Executor.of(\"\/usr\/bin\/codesign\", \"--verify\", \"--deep\",\n+                \"--strict\", \"--verbose=2\", path.toString()).executeAndGetOutput().iterator());\n+    }\n+\n+    public static List<SignIdentity> getPkgCertificateChain(Path path) {\n+        \/\/\n+        \/\/ Typical output of `\/usr\/sbin\/pkgutil --check-signature`:\n+        \/\/ Package \"foo.pkg\":\n+        \/\/    Status: signed by a developer certificate issued by Apple for distribution\n+        \/\/    Notarization: trusted by the Apple notary service\n+        \/\/    Signed with a trusted timestamp on: 2022-05-10 19:54:56 +0000\n+        \/\/    Certificate Chain:\n+        \/\/      1. Developer ID Installer: Foo\n+        \/\/         SHA256 Fingerprint:\n+        \/\/             4A A9 4A 85 20 2A DE 02 B2 9B 36 DA 45 00 B4 40 CF 31 43 4E 96 02\n+        \/\/             60 6A 6D BC 02 F4 5D 3A 86 4A\n+        \/\/         ------------------------------------------------------------------------\n+        \/\/      2. Developer ID Certification Authority\n+        \/\/         Expires: 2027-02-01 22:12:15 +0000\n+        \/\/         SHA256 Fingerprint:\n+        \/\/             7A FC 9D 01 A6 2F 03 A2 DE 96 37 93 6D 4A FE 68 09 0D 2D E1 8D 03\n+        \/\/             F2 9C 88 CF B0 B1 BA 63 58 7F\n+        \/\/         ------------------------------------------------------------------------\n+        \/\/      3. Apple Root CA\n+        \/\/         Expires: 2035-02-09 21:40:36 +0000\n+        \/\/         SHA256 Fingerprint:\n+        \/\/             B0 B1 73 0E CB C7 FF 45 05 14 2C 49 F1 29 5E 6E DA 6B CA ED 7E 2C\n+        \/\/             68 C5 BE 91 B5 A1 10 01 F0 24\n+        final var exec = Executor.of(\"\/usr\/sbin\/pkgutil\", \"--check-signature\", path.toString()).saveOutput();\n+        final var result = exec.executeWithoutExitCodeCheck();\n+        if (result.getExitCode() == 0) {\n+            try {\n+                final List<SignIdentity> signIdentities = new ArrayList<>();\n+                final var lineIt = result.getOutput().iterator();\n+                while (!lineIt.next().endsWith(\"Certificate Chain:\")) {\n+\n+                }\n+                do {\n+                    final var m = SIGN_IDENTITY_NAME_REGEXP.matcher(lineIt.next());\n+                    m.find();\n+                    final var name = m.group(1);\n+                    while (!lineIt.next().endsWith(\"SHA256 Fingerprint:\")) {\n+\n+                    }\n+                    final var digest = new StringBuilder();\n+                    do {\n+                        final var line = lineIt.next().strip();\n+                        if (line.endsWith(\"----\") || line.isEmpty()) {\n+                            break;\n+                        }\n+                        digest.append(\" \" + line.strip());\n+                    } while (lineIt.hasNext());\n+                    final var fingerprint = new CertificateHash(\n+                            FINGERPRINT_FORMAT.parseHex(digest.substring(1)), SHA256);\n+                    signIdentities.add(new SignIdentity(name, fingerprint));\n+                } while (lineIt.hasNext());\n+                return signIdentities;\n+            } catch (Throwable t) {\n+                t.printStackTrace();\n+                reportUnexpectedCommandOutcome(exec.getPrintableCommandLine(), result);\n+                return null; \/\/ Unreachable\n+            }\n+        } else if (result.getExitCode() == 1 && result.getOutput().getLast().endsWith(\"Status: no signature\")) {\n+            return List.of();\n+        } else {\n+            reportUnexpectedCommandOutcome(exec.getPrintableCommandLine(), result);\n+            return null; \/\/ Unreachable\n+        }\n+    }\n+\n+    public record SignIdentity(String name, CertificateHash fingerprint) {\n+        public SignIdentity {\n+            Objects.requireNonNull(name);\n+            Objects.requireNonNull(fingerprint);\n+        }\n+    }\n+\n+    private static void reportUnexpectedCommandOutcome(String printableCommandLine, Executor.Result result) {\n+        Objects.requireNonNull(printableCommandLine);\n+        Objects.requireNonNull(result);\n+        TKit.trace(String.format(\"Command %s exited with exit code %d and the following output:\",\n+                printableCommandLine, result.getExitCode()));\n+        result.getOutput().forEach(TKit::trace);\n+        TKit.trace(\"Done\");\n+        TKit.assertUnexpected(String.format(\"Outcome of command %s\", printableCommandLine));\n+    }\n+\n+    private static final Pattern SIGN_IDENTITY_NAME_REGEXP = Pattern.compile(\"^\\\\s+\\\\d+\\\\.\\\\s+(.*)$\");\n+    private static final HexFormat FINGERPRINT_FORMAT = HexFormat.ofDelimiter(\" \").withUpperCase();\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacSignVerify.java","additions":229,"deletions":0,"binary":false,"changes":229,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+import java.util.Collection;\n@@ -28,0 +29,6 @@\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.Annotations.ParameterSupplier;\n@@ -33,0 +40,4 @@\n+import jdk.jpackage.test.MacSign;\n+import jdk.jpackage.test.MacSign.CertificateRequest;\n+import jdk.jpackage.test.MacSignVerify;\n+import jdk.jpackage.test.PackageType;\n@@ -67,15 +78,162 @@\n-        \/\/ --app-content and --type app-image\n-        \/\/ Expect `message.codesign.failed.reason.app.content` message in the log.\n-        \/\/ This is not a fatal error, just a warning.\n-        \/\/ To make jpackage fail, specify bad additional content.\n-        final var cmd = JPackageCommand.helloAppImage()\n-                .ignoreDefaultVerbose(true)\n-                .validateOutput(expectedStrings.toArray(CannedFormattedString[]::new))\n-                .addArguments(\"--app-content\", appContent)\n-                .addArguments(\"--mac-sign\")\n-                .addArguments(\"--mac-signing-keychain\", SigningBase.StandardKeychain.MAIN.spec().keychain().name())\n-                .addArguments(\"--mac-app-image-sign-identity\", SigningBase.StandardCertificateRequest.APP_IMAGE.spec().name());\n-\n-        if (MacHelper.isXcodeDevToolsInstalled()) {\n-            \/\/ Check there is no warning about missing xcode command line developer tools.\n-            cmd.validateOutput(TKit.assertTextStream(xcodeWarning.getValue()).negate());\n+        final var keychain = SigningBase.StandardKeychain.EXPIRED.spec().keychain();\n+\n+        MacSign.Keychain.withAddedKeychains(List.of(keychain), () -> {\n+            \/\/ --app-content and --type app-image\n+            \/\/ Expect `message.codesign.failed.reason.app.content` message in the log.\n+            \/\/ This is not a fatal error, just a warning.\n+            \/\/ To make jpackage fail, specify bad additional content.\n+            final var cmd = JPackageCommand.helloAppImage()\n+                    .ignoreDefaultVerbose(true)\n+                    .validateOutput(expectedStrings.toArray(CannedFormattedString[]::new))\n+                    .addArguments(\"--app-content\", appContent)\n+                    .addArguments(\"--mac-sign\")\n+                    .addArguments(\"--mac-signing-keychain\", keychain.name())\n+                    .addArguments(\"--mac-app-image-sign-identity\", SigningBase.StandardCertificateRequest.CODESIGN.spec().name());\n+\n+            if (MacHelper.isXcodeDevToolsInstalled()) {\n+                \/\/ Check there is no warning about missing xcode command line developer tools.\n+                cmd.validateOutput(TKit.assertTextStream(xcodeWarning.getValue()).negate());\n+            }\n+\n+            cmd.execute(1);\n+        });\n+    }\n+\n+    @Test\n+    @Parameter({\"IMAGE\", \"EXPIRED_SIGNING_KEY_USER_NAME\"})\n+    @Parameter({\"MAC_DMG\", \"EXPIRED_SIGNING_KEY_USER_NAME\"})\n+    @Parameter({\"MAC_PKG\", \"EXPIRED_SIGNING_KEY_USER_NAME\", \"EXPIRED_SIGNING_KEY_USER_NAME_PKG\"})\n+\n+    @Parameter({\"IMAGE\", \"EXPIRED_SIGN_IDENTITY\"})\n+    @Parameter({\"MAC_DMG\", \"EXPIRED_SIGN_IDENTITY\"})\n+    @Parameter({\"MAC_PKG\", \"EXPIRED_SIGN_IDENTITY\"})\n+\n+    @Parameter({\"IMAGE\", \"EXPIRED_CODESIGN_SIGN_IDENTITY\"})\n+    @Parameter({\"MAC_DMG\", \"EXPIRED_CODESIGN_SIGN_IDENTITY\"})\n+    @Parameter({\"MAC_PKG\", \"EXPIRED_CODESIGN_SIGN_IDENTITY\"})\n+\n+    @Parameter({\"MAC_PKG\", \"GOOD_CODESIGN_SIGN_IDENTITY\", \"EXPIRED_PKG_SIGN_IDENTITY\"})\n+    @Parameter({\"MAC_PKG\", \"EXPIRED_CODESIGN_SIGN_IDENTITY\", \"GOOD_PKG_SIGN_IDENTITY\"})\n+    public static void testExpiredCertificate(PackageType type, SignOption... options) {\n+\n+        final var keychain = SigningBase.StandardKeychain.EXPIRED.spec().keychain();\n+\n+        MacSign.Keychain.withAddedKeychains(List.of(keychain), () -> {\n+            final var cmd = JPackageCommand.helloAppImage()\n+                    .ignoreDefaultVerbose(true)\n+                    .addArguments(\"--mac-sign\")\n+                    .addArguments(\"--mac-signing-keychain\", keychain.name())\n+                    .addArguments(Stream.of(options).map(SignOption::args).flatMap(List::stream).toList())\n+                    .setPackageType(type);\n+\n+            SignOption.configureOutputValidation(cmd, Stream.of(options).filter(SignOption::expired).toList(), opt -> {\n+                return JPackageStringBundle.MAIN.cannedFormattedString(\"error.certificate.expired\", opt.identityName());\n+            }).execute(1);\n+        });\n+    }\n+\n+    @Test\n+    @Parameter({\"IMAGE\", \"GOOD_SIGNING_KEY_USER_NAME\"})\n+    @Parameter({\"MAC_DMG\", \"GOOD_SIGNING_KEY_USER_NAME\"})\n+    @Parameter({\"MAC_PKG\", \"GOOD_SIGNING_KEY_USER_NAME_PKG\", \"GOOD_SIGNING_KEY_USER_NAME\"})\n+\n+    @Parameter({\"IMAGE\", \"GOOD_CODESIGN_SIGN_IDENTITY\"})\n+    @Parameter({\"MAC_PKG\", \"GOOD_CODESIGN_SIGN_IDENTITY\", \"GOOD_PKG_SIGN_IDENTITY\"})\n+    @Parameter({\"MAC_PKG\", \"GOOD_PKG_SIGN_IDENTITY\"})\n+    public static void testMultipleCertificates(PackageType type, SignOption... options) {\n+\n+        final var keychain = SigningBase.StandardKeychain.DUPLICATE.spec().keychain();\n+\n+        MacSign.Keychain.withAddedKeychains(List.of(keychain), () -> {\n+            final var cmd = JPackageCommand.helloAppImage()\n+                    .ignoreDefaultVerbose(true)\n+                    .addArguments(\"--mac-sign\")\n+                    .addArguments(\"--mac-signing-keychain\", keychain.name())\n+                    .addArguments(Stream.of(options).map(SignOption::args).flatMap(List::stream).toList())\n+                    .setPackageType(type);\n+\n+            SignOption.configureOutputValidation(cmd, List.of(options), opt -> {\n+                return JPackageStringBundle.MAIN.cannedFormattedString(\"error.multiple.certs.found\", opt.identityName(), keychain.name());\n+            }).execute(1);\n+        });\n+    }\n+\n+    @Test\n+    @ParameterSupplier\n+    public static void testSelectSigningIdentity(String signingKeyUserName, CertificateRequest certRequest) {\n+\n+        final var keychain = SigningBase.StandardKeychain.MAIN.spec().keychain();\n+\n+        MacSign.Keychain.withAddedKeychains(List.of(keychain), () -> {\n+            final var cmd = JPackageCommand.helloAppImage()\n+                    .setFakeRuntime()\n+                    .addArguments(\"--mac-sign\")\n+                    .addArguments(\"--mac-signing-keychain\", keychain.name())\n+                    .addArguments(\"--mac-signing-key-user-name\", signingKeyUserName);\n+\n+            cmd.executeAndAssertHelloAppImageCreated();\n+\n+            MacSignVerify.assertSigned(cmd.outputBundle(), certRequest);\n+        });\n+    }\n+\n+    public static Collection<Object[]> testSelectSigningIdentity() {\n+        return Stream.of(\n+                SigningBase.StandardCertificateRequest.CODESIGN,\n+                SigningBase.StandardCertificateRequest.CODESIGN_UNICODE\n+        ).map(SigningBase.StandardCertificateRequest::spec).<Object[]>mapMulti((certRequest, acc) -> {\n+            acc.accept(new Object[] {certRequest.shortName(), certRequest});\n+            acc.accept(new Object[] {certRequest.name(), certRequest});\n+        }).toList();\n+    }\n+\n+    enum SignOption {\n+        EXPIRED_SIGNING_KEY_USER_NAME(\"--mac-signing-key-user-name\", SigningBase.StandardCertificateRequest.CODESIGN_EXPIRED.spec(), true, false),\n+        EXPIRED_SIGNING_KEY_USER_NAME_PKG(\"--mac-signing-key-user-name\", SigningBase.StandardCertificateRequest.PKG_EXPIRED.spec(), true, false),\n+        EXPIRED_SIGN_IDENTITY(\"--mac-signing-key-user-name\", SigningBase.StandardCertificateRequest.CODESIGN_EXPIRED.spec(), false, false),\n+        EXPIRED_CODESIGN_SIGN_IDENTITY(\"--mac-app-image-sign-identity\", SigningBase.StandardCertificateRequest.CODESIGN_EXPIRED.spec(), false, true),\n+        EXPIRED_PKG_SIGN_IDENTITY(\"--mac-installer-sign-identity\", SigningBase.StandardCertificateRequest.PKG_EXPIRED.spec(), false, true),\n+        GOOD_SIGNING_KEY_USER_NAME(\"--mac-signing-key-user-name\", SigningBase.StandardCertificateRequest.CODESIGN.spec(), true, false),\n+        GOOD_SIGNING_KEY_USER_NAME_PKG(\"--mac-signing-key-user-name\", SigningBase.StandardCertificateRequest.PKG.spec(), true, false),\n+        GOOD_CODESIGN_SIGN_IDENTITY(\"--mac-app-image-sign-identity\", SigningBase.StandardCertificateRequest.CODESIGN.spec(), false, true),\n+        GOOD_PKG_SIGN_IDENTITY(\"--mac-app-image-sign-identity\", SigningBase.StandardCertificateRequest.PKG.spec(), false, true);\n+\n+        SignOption(String option, MacSign.CertificateRequest cert, boolean shortName, boolean passThrough) {\n+            this.option = Objects.requireNonNull(option);\n+            this.cert = Objects.requireNonNull(cert);\n+            this.shortName = shortName;\n+            this.passThrough = passThrough;\n+        }\n+\n+        boolean passThrough() {\n+            return passThrough;\n+        }\n+\n+        boolean expired() {\n+            return cert.expired();\n+        }\n+\n+        String identityName() {\n+            return cert.name();\n+        }\n+\n+        List<String> args() {\n+            return List.of(option, shortName ? cert.shortName() : cert.name());\n+        }\n+\n+        static JPackageCommand configureOutputValidation(JPackageCommand cmd, List<SignOption> options,\n+                Function<SignOption, CannedFormattedString> conv) {\n+            options.stream().filter(SignOption::passThrough)\n+                    .map(conv)\n+                    .map(CannedFormattedString::getValue)\n+                    .map(TKit::assertTextStream)\n+                    .map(TKit.TextStreamVerifier::negate)\n+                    .forEach(cmd::validateOutput);\n+\n+            options.stream().filter(Predicate.not(SignOption::passThrough))\n+                    .map(conv)\n+                    .map(CannedFormattedString::getValue)\n+                    .map(TKit::assertTextStream)\n+                    .forEach(cmd::validateOutput);\n+\n+            return cmd;\n@@ -84,1 +242,4 @@\n-        cmd.execute(1);\n+        private final String option;\n+        private final MacSign.CertificateRequest cert;\n+        private final boolean shortName;\n+        private final boolean passThrough;\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/MacSignTest.java","additions":177,"deletions":16,"binary":false,"changes":193,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.security.cert.X509Certificate;\n@@ -27,0 +28,1 @@\n+import java.util.Objects;\n@@ -28,2 +30,0 @@\n-import jdk.jpackage.test.Executor;\n-import jdk.jpackage.test.Executor.Result;\n@@ -32,1 +32,0 @@\n-import jdk.jpackage.test.MacSign.CertificateType;\n@@ -34,0 +33,1 @@\n+import jdk.jpackage.test.MacSign.CertificateType;\n@@ -35,0 +35,2 @@\n+import jdk.jpackage.test.MacSign.ResolvedKeychain;\n+import jdk.jpackage.test.MacSignVerify;\n@@ -67,4 +69,8 @@\n-        APP_IMAGE(cert().userName(DEV_NAMES[CertIndex.ASCII_INDEX.value()])),\n-        INSTALLER(cert().type(CertificateType.INSTALLER).userName(DEV_NAMES[CertIndex.ASCII_INDEX.value()])),\n-        APP_IMAGE_UNICODE(cert().userName(DEV_NAMES[CertIndex.UNICODE_INDEX.value()])),\n-        INSTALLER_UNICODE(cert().type(CertificateType.INSTALLER).userName(DEV_NAMES[CertIndex.UNICODE_INDEX.value()]));\n+        CODESIGN(cert().userName(DEV_NAMES[CertIndex.ASCII_INDEX.value()])),\n+        CODESIGN_COPY(cert().days(100).userName(DEV_NAMES[CertIndex.ASCII_INDEX.value()])),\n+        PKG(cert().type(CertificateType.INSTALLER).userName(DEV_NAMES[CertIndex.ASCII_INDEX.value()])),\n+        PKG_COPY(cert().type(CertificateType.INSTALLER).days(100).userName(DEV_NAMES[CertIndex.ASCII_INDEX.value()])),\n+        CODESIGN_UNICODE(cert().userName(DEV_NAMES[CertIndex.UNICODE_INDEX.value()])),\n+        PKG_UNICODE(cert().type(CertificateType.INSTALLER).userName(DEV_NAMES[CertIndex.UNICODE_INDEX.value()])),\n+        CODESIGN_EXPIRED(cert().expired().userName(\"expired jpackage test\")),\n+        PKG_EXPIRED(cert().expired().type(CertificateType.INSTALLER).userName(\"expired jpackage test\"));\n@@ -88,1 +94,15 @@\n-        MAIN(DEFAULT_KEYCHAIN, StandardCertificateRequest.values());\n+        MAIN(DEFAULT_KEYCHAIN,\n+                StandardCertificateRequest.CODESIGN,\n+                StandardCertificateRequest.PKG,\n+                StandardCertificateRequest.CODESIGN_UNICODE,\n+                StandardCertificateRequest.PKG_UNICODE),\n+        EXPIRED(\"jpackagerTest-expired.keychain\",\n+                StandardCertificateRequest.CODESIGN,\n+                StandardCertificateRequest.PKG,\n+                StandardCertificateRequest.CODESIGN_EXPIRED,\n+                StandardCertificateRequest.PKG_EXPIRED),\n+        DUPLICATE(\"jpackagerTest-duplicate.keychain\",\n+                StandardCertificateRequest.CODESIGN,\n+                StandardCertificateRequest.PKG,\n+                StandardCertificateRequest.CODESIGN_COPY,\n+                StandardCertificateRequest.PKG_COPY);\n@@ -97,1 +117,1 @@\n-            this.spec = builder.create();\n+            this.spec = new ResolvedKeychain(builder.create());\n@@ -101,1 +121,5 @@\n-            return spec;\n+            return spec.spec();\n+        }\n+\n+        public X509Certificate mapCertificateRequest(CertificateRequest certRequest) {\n+            return Objects.requireNonNull(spec.mapCertificateRequests().get(certRequest));\n@@ -116,1 +140,1 @@\n-        private final KeychainWithCertsSpec spec;\n+        private final ResolvedKeychain spec;\n@@ -134,1 +158,1 @@\n-        private final static boolean SIGN_ENV_READY = MacSign.isDeployed(StandardKeychain.signingEnv());\n+        private static final boolean SIGN_ENV_READY = MacSign.isDeployed(StandardKeychain.signingEnv());\n@@ -202,117 +226,1 @@\n-    \/\/ Note: It is not clear if we can combine \"--verify\" and \"--display\", so\n-    \/\/ we testing them separately. Since JDK-8298488 unsigned app images are\n-    \/\/ actually signed with adhoc signature and it will pass \"--verify\", so in\n-    \/\/ addition we will check certificate name which was used to sign.\n-    private static enum CodesignCheckType {\n-        VERIFY, \/\/ Runs codesign with \"--verify\" to check signature and 0 exit code\n-        VERIFY_UNSIGNED, \/\/ Runs codesign with \"--verify\" to check signature and 1 exit code\n-        DISPLAY \/\/ Runs codesign with \"--display --verbose=4\" to get info about signature\n-    };\n-\n-    private static void checkString(List<String> result, String lookupString) {\n-        TKit.assertTextStream(lookupString).predicate(\n-                (line, what) -> line.trim().contains(what)).apply(result.stream());\n-    }\n-\n-    @SuppressWarnings(\"fallthrough\")\n-    private static List<String> codesignResult(Path target, CodesignCheckType type) {\n-        int exitCode = 0;\n-        Executor executor = new Executor().setExecutable(\"\/usr\/bin\/codesign\");\n-        switch (type) {\n-            case VERIFY_UNSIGNED:\n-                exitCode = 1;\n-            case VERIFY:\n-                executor.addArguments(\"--verify\", \"--deep\", \"--strict\",\n-                                      \"--verbose=2\", target.toString());\n-                break;\n-            case DISPLAY:\n-                executor.addArguments(\"--display\", \"--verbose=4\", target.toString());\n-                break;\n-            default:\n-                TKit.error(\"Unknown CodesignCheckType: \" + type);\n-                break;\n-        }\n-        return executor.saveOutput().execute(exitCode).getOutput();\n-    }\n-\n-    private static void verifyCodesignResult(List<String> result, Path target,\n-            boolean signed, CodesignCheckType type, int certIndex) {\n-        result.stream().forEachOrdered(TKit::trace);\n-        String lookupString;\n-        switch (type) {\n-            case VERIFY:\n-                lookupString = target.toString() + \": valid on disk\";\n-                checkString(result, lookupString);\n-                lookupString = target.toString() + \": satisfies its Designated Requirement\";\n-                checkString(result, lookupString);\n-                break;\n-            case VERIFY_UNSIGNED:\n-                lookupString = target.toString() + \": code object is not signed at all\";\n-                checkString(result, lookupString);\n-                break;\n-            case DISPLAY:\n-                if (signed) {\n-                    lookupString = \"Authority=\" + getAppCert(certIndex);\n-                } else {\n-                    lookupString = \"Signature=adhoc\";\n-                }\n-                checkString(result, lookupString);\n-                break;\n-            default:\n-                TKit.error(\"Unknown CodesignCheckType: \" + type);\n-                break;\n-        }\n-    }\n-\n-    private static Result spctlResult(Path target, String type) {\n-        Result result = new Executor()\n-                .setExecutable(\"\/usr\/sbin\/spctl\")\n-                .addArguments(\"-vvv\", \"--assess\", \"--type\", type,\n-                        target.toString())\n-                .saveOutput()\n-                .executeWithoutExitCodeCheck();\n-\n-        \/\/ allow exit code 3 for not being notarized\n-        if (result.getExitCode() != 3) {\n-            result.assertExitCodeIsZero();\n-        }\n-        return result;\n-    }\n-\n-    private static void verifySpctlResult(List<String> output, Path target,\n-            String type, int exitCode, int certIndex) {\n-        output.stream().forEachOrdered(TKit::trace);\n-        String lookupString;\n-\n-        if (exitCode == 0) {\n-            lookupString = target.toString() + \": accepted\";\n-            checkString(output, lookupString);\n-        } else if (exitCode == 3) {\n-            \/\/ allow failure purely for not being notarized\n-            lookupString = target.toString() + \": rejected\";\n-            checkString(output, lookupString);\n-        }\n-\n-        if (type.equals(\"install\")) {\n-            lookupString = \"origin=\" + getInstallerCert(certIndex);\n-        } else {\n-            lookupString = \"origin=\" + getAppCert(certIndex);\n-        }\n-        checkString(output, lookupString);\n-    }\n-\n-    private static List<String> pkgutilResult(Path target, boolean signed) {\n-        List<String> result = new Executor()\n-                .setExecutable(\"\/usr\/sbin\/pkgutil\")\n-                .addArguments(\"--check-signature\",\n-                        target.toString())\n-                .saveOutput()\n-                .execute(signed ? 0 : 1)\n-                .getOutput();\n-\n-        return result;\n-    }\n-\n-    private static void verifyPkgutilResult(List<String> result, boolean signed,\n-                                            int certIndex) {\n-        result.stream().forEachOrdered(TKit::trace);\n+    public static void verifyCodesign(Path target, boolean signed, int certIndex) {\n@@ -320,4 +228,2 @@\n-            String lookupString = \"Status: signed by\";\n-            checkString(result, lookupString);\n-            lookupString = \"1. \" + getInstallerCert(certIndex);\n-            checkString(result, lookupString);\n+            final var certRequest = getCertRequest(certIndex);\n+            MacSignVerify.assertSigned(target, certRequest);\n@@ -325,2 +231,1 @@\n-            String lookupString = \"Status: no signature\";\n-            checkString(result, lookupString);\n+            MacSignVerify.assertAdhocSigned(target);\n@@ -330,8 +235,0 @@\n-    public static void verifyCodesign(Path target, boolean signed, int certIndex) {\n-        List<String> result = codesignResult(target, CodesignCheckType.VERIFY);\n-        verifyCodesignResult(result, target, signed, CodesignCheckType.VERIFY, certIndex);\n-\n-        result = codesignResult(target, CodesignCheckType.DISPLAY);\n-        verifyCodesignResult(result, target, signed, CodesignCheckType.DISPLAY, certIndex);\n-    }\n-\n@@ -344,1 +241,1 @@\n-            TKit.error(\"Unexpected target: \" + target);\n+            throw new IllegalArgumentException(\"Unexpected target: \" + target);\n@@ -347,2 +244,1 @@\n-        List<String> result = codesignResult(target, CodesignCheckType.VERIFY_UNSIGNED);\n-        verifyCodesignResult(result, target, false, CodesignCheckType.VERIFY_UNSIGNED, -1);\n+        MacSignVerify.assertUnsigned(target);\n@@ -352,2 +248,20 @@\n-        Result result = spctlResult(target, type);\n-        List<String> output = result.getOutput();\n+        final var standardCertIndex = Stream.of(CertIndex.values()).filter(v -> {\n+            return v.value() == certIndex;\n+        }).findFirst().orElseThrow();\n+\n+        final var standardType = Stream.of(MacSignVerify.SpctlType.values()).filter(v -> {\n+            return v.value().equals(type);\n+        }).findFirst().orElseThrow();\n+\n+        final String expectedSignOrigin;\n+        if (standardCertIndex == CertIndex.INVALID_INDEX) {\n+            expectedSignOrigin = null;\n+        } else if (standardType == MacSignVerify.SpctlType.EXEC) {\n+            expectedSignOrigin = getCertRequest(certIndex).name();\n+        } else if (standardType == MacSignVerify.SpctlType.INSTALL) {\n+            expectedSignOrigin = getPkgCertRequest(certIndex).name();\n+        } else {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        final var signOrigin = MacSignVerify.findSpctlSignOrigin(standardType, target).orElse(null);\n@@ -355,1 +269,2 @@\n-        verifySpctlResult(output, target, type, result.getExitCode(), certIndex);\n+        TKit.assertEquals(signOrigin, expectedSignOrigin,\n+                String.format(\"Check [%s] has sign origin as expected\", target));\n@@ -359,2 +274,6 @@\n-        List<String> result = pkgutilResult(target, signed);\n-        verifyPkgutilResult(result, signed, certIndex);\n+        if (signed) {\n+            final var certRequest = getPkgCertRequest(certIndex);\n+            MacSignVerify.assertPkgSigned(target, certRequest, StandardKeychain.MAIN.mapCertificateRequest(certRequest));\n+        } else {\n+            MacSignVerify.assertUnsigned(target);\n+        }\n@@ -381,0 +300,27 @@\n+    private static CertificateRequest getCertRequest(int certIndex) {\n+        switch (CertIndex.values()[certIndex]) {\n+            case ASCII_INDEX -> {\n+                return StandardCertificateRequest.CODESIGN.spec();\n+            }\n+            case UNICODE_INDEX -> {\n+                return StandardCertificateRequest.CODESIGN_UNICODE.spec();\n+            }\n+            default -> {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+    }\n+\n+    private static CertificateRequest getPkgCertRequest(int certIndex) {\n+        switch (CertIndex.values()[certIndex]) {\n+            case ASCII_INDEX -> {\n+                return StandardCertificateRequest.PKG.spec();\n+            }\n+            case UNICODE_INDEX -> {\n+                return StandardCertificateRequest.PKG_UNICODE.spec();\n+            }\n+            default -> {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+    }\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/base\/SigningBase.java","additions":97,"deletions":151,"binary":false,"changes":248,"status":"modified"}]}