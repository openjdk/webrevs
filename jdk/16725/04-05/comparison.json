{"files":[{"patch":"@@ -559,1 +559,1 @@\n-     * *  Because we don't know about usage patterns (or most commonly,\n+     * * Because we don't know about usage patterns (or most commonly,\n@@ -566,1 +566,3 @@\n-     *    aren't needed. But there is no efficient way to detect this.\n+     *    aren't needed. We filter out some of these cases by exiting\n+     *    retry loops in signalWork if the task responsible for the\n+     *    signal has already been taken.\n@@ -582,3 +584,1 @@\n-     *   signalling when all were from the same source. Also, retries\n-     *   are suppressed on CAS failures by newly activated workers,\n-     *   which serves as a form of admission control.  These\n+     *   signalling when all were from the same source. These\n@@ -612,17 +612,8 @@\n-     * found by a worker, it tries to deactivate (in runWorker).  Note\n-     * that not finding tasks doesn't mean that there won't soon be\n-     * some. Further, a scan may give up under contention, returning\n-     * even without knowing whether any tasks are still present, which\n-     * is OK given, a secondary check (in deactivate) needed to cover\n-     * deactivation\/signal races. Blocking and unblocking via\n-     * park\/unpark can cause serious slowdowns when tasks are rapidly\n-     * but irregularly generated (which is often due to garbage\n-     * collectors and other activities). One way to ameliorate is for\n-     * workers to rescan multiple times, even when there are unlikely\n-     * to be tasks. But this causes enough memory traffic and CAS\n-     * contention to prefer using quieter short spinwaits in awaitWork\n-     * and elsewhere; set to small values that only cover near-miss\n-     * scenarios for deactivate\/reactivate races.  Because idle workers\n-     * are often not yet blocked (parked), we use the WorkQueue parker\n-     * field to advertise that a waiter actually needs unparking upon\n-     * signal.\n+     * found by a worker, it tries to deactivate (in awaitWork),\n+     * giving up (and rescanning) on ctl contention. To avoid missed\n+     * signals during deactivation, the method rescans and reactivates\n+     * if there may have been a missed signal during deactivation,\n+     * filtering out most cases in which this is unnecessary. Because\n+     * idle workers are often not yet blocked (parked), we use the\n+     * WorkQueue parking field to advertise that a waiter actually\n+     * needs unparking upon signal.\n@@ -1219,1 +1210,0 @@\n-        volatile Thread parker;    \/\/ set when parking in awaitWork\n@@ -1235,0 +1225,2 @@\n+        @jdk.internal.vm.annotation.Contended(\"w\")\n+        volatile int parking;      \/\/ nonzero if parked in awaitWork\n@@ -1304,1 +1296,1 @@\n-            int s = top, b = base, cap, m, room, newCap; ForkJoinTask<?>[] a;\n+            int s = top, b = base, cap, m, p, room, newCap; ForkJoinTask<?>[] a;\n@@ -1312,1 +1304,1 @@\n-            long pos = slotOffset(m & s);\n+            long pos = slotOffset(p = m & s);\n@@ -1334,0 +1326,1 @@\n+                a = null;\n@@ -1337,2 +1330,2 @@\n-            if ((room == 0 || a[m & (s - 1)] == null) && pool != null)\n-                pool.signalWork();\n+            if ((a == null || a[m & (s - 1)] == null) && pool != null)\n+                pool.signalWork(a, p);\n@@ -1445,1 +1438,1 @@\n-                            pool.signalWork();    \/\/ propagate\n+                            pool.signalWork(a, nk); \/\/ propagate\n@@ -1462,8 +1455,17 @@\n-            ForkJoinTask<?> t; ForkJoinTask<?>[] a; int b, cap, k;\n-            if ((a = array) != null && (cap = a.length) > 0 &&\n-                (t = a[k = (b = base) & (cap - 1)]) != null) {\n-                U.loadFence();\n-                if (base == b &&\n-                    U.compareAndSetReference(a, slotOffset(k), t, null)) {\n-                    updateBase(b + 1);\n-                    return t;\n+            ForkJoinTask<?>[] a; int cap;\n+            if ((a = array) != null && (cap = a.length) > 0) {\n+                for (int b = base, k;;) {  \/\/ loop only if inconsistent\n+                    ForkJoinTask<?> t = a[k = b & (cap - 1)];\n+                    U.loadFence();\n+                    if (b == (b = base)) {\n+                        Object o;\n+                        if (t == null)\n+                            o = a[k];\n+                        else if (t == (o = U.compareAndExchangeReference(\n+                                           a, slotOffset(k), t, null))) {\n+                            updateBase(b + 1);\n+                            return t;\n+                        }\n+                        if (o == null)\n+                            break;\n+                    }\n@@ -1906,1 +1908,1 @@\n-            signalWork(); \/\/ may replace unless trimmed or uninitialized\n+            signalWork(null, 0); \/\/ may replace unless trimmed or uninitialized\n@@ -1912,1 +1914,5 @@\n-     * Releases an idle worker, or creates one if not enough exist.\n+     * Releases an idle worker, or creates one if not enough exist,\n+     * returning on contention if a signal task is already taken.\n+     *\n+     * @param a if nonnull, a task array holding task signalled\n+     * @param k index of task in array\n@@ -1914,1 +1920,1 @@\n-    final void signalWork() {\n+    final void signalWork(ForkJoinTask<?>[] a, int k) {\n@@ -1936,1 +1942,0 @@\n-                    Thread t;\n@@ -1938,2 +1943,2 @@\n-                    if ((t = v.parker) != null)\n-                        U.unpark(t);\n+                    if (v.parking != 0)\n+                        U.unpark(v.owner);\n@@ -1943,0 +1948,2 @@\n+            if (a != null && k >= 0 && k < a.length && a[k] == null)\n+                break;\n@@ -1961,1 +1968,1 @@\n-                Thread t;\n+                Thread t = v.owner;\n@@ -1963,1 +1970,1 @@\n-                if ((t = v.parker) != null) {\n+                if (v.parking != 0&& t != null) {\n@@ -2001,1 +2008,1 @@\n-                                    signalWork();         \/\/ ensure live\n+                                    signalWork(null, 0);  \/\/ ensure live\n@@ -2031,1 +2038,1 @@\n-                r ^= r << 13; r ^= r >>> 17; r ^= r << 5;   \/\/ xorshift\n+                r ^= r << 13; r ^= r >>> 17; r ^= r << 5; \/\/ xorshift\n@@ -2033,2 +2040,1 @@\n-                     ((window != (window = scan(w, window, r)) || window < 0L ||\n-                       ((phase = deactivate(w, phase)) & IDLE) == 0 ||\n+                     (((window = scan(w, window, r)) < 0L ||\n@@ -2057,3 +2063,3 @@\n-                for (;;) {\n-                    int b, k; Object o;\n-                    ForkJoinTask<?> t = a[k = (b = q.base) & (cap - 1)];\n+                for (int b = q.base;;) {\n+                    int nb = b + 1, nk = nb & (cap - 1), k;\n+                    ForkJoinTask<?> t = a[k = b & (cap - 1)];\n@@ -2061,9 +2067,4 @@\n-                    if (q.base == b) {            \/\/ else inconsistent; retry\n-                        int nb = b + 1, nk = nb & (cap - 1);\n-                        if (t == null) {\n-                            if (a[k] == null) {   \/\/ revisit if another task\n-                                if (next >= 0L && a[nk] != null)\n-                                    next |= RESCAN;\n-                                break;\n-                            }\n-                        }\n+                    if (b == (b = q.base)) {      \/\/ else inconsistent; retry\n+                        Object o;\n+                        if (t == null)\n+                            o = a[k];\n@@ -2074,3 +2075,2 @@\n-                            if (((short)(next >>> 32) != j || next != window) &&\n-                                a[nk] != null)\n-                                signalWork();     \/\/ limit propagation\n+                            if (window != next && a[nk] != null)\n+                                signalWork(a, nk); \/\/ limit propagation\n@@ -2081,2 +2081,5 @@\n-                        else if (o == null)       \/\/ contended\n-                            break;                \/\/ retried unless newly active\n+                        if (o == null) {\n+                            if (next >= 0L && a[nk] != null)\n+                                next |= RESCAN;\n+                            break;\n+                        }\n@@ -2091,2 +2094,1 @@\n-     * Deactivates w, reactivating on contention, already signalled,\n-     * or possible missed signal.\n+     * Tries to inactivate, and if successful, awaits signal or termination.\n@@ -2096,1 +2098,1 @@\n-     * @return phase on exit\n+     * @return current phase, with IDLE set if worker should exit\n@@ -2098,11 +2100,28 @@\n-    private int deactivate(WorkQueue w, int phase) {\n-        int idle = phase | IDLE, p = idle, active = idle + IDLE;\n-        if (phase != idle && w != null) {\n-            long pc = ctl, qc = (active & LMASK) | ((pc - RC_UNIT) & UMASK);\n-            w.stackPred = (int)pc;                  \/\/ set ctl stack link\n-            w.phase = idle;                         \/\/ try to deactivate\n-            if (!compareAndSetCtl(pc, qc))          \/\/ contended enque\n-                p = w.phase = phase;                \/\/ back out\n-            else if ((runState & SHUTDOWN) == 0 || (qc & RC_MASK) > 0L ||\n-                     !quiescent() || (runState & STOP) == 0) {\n-                WorkQueue[] qs = queues;            \/\/ recheck queues\n+    private int awaitWork(WorkQueue w, int phase) {\n+        boolean quiet;                           \/\/ true if possibly quiescent\n+        int active = phase + (IDLE << 1), p = phase | IDLE, e;\n+        if (w != null) {\n+            w.phase = p;                         \/\/ deactivate\n+            long np = active & LMASK, pc = ctl;  \/\/ try to enqueue\n+            long qc = np | ((pc - RC_UNIT) & UMASK);\n+            w.stackPred = (int)pc;               \/\/ set ctl stack link\n+            if (pc != (pc = compareAndExchangeCtl(pc, qc))) {\n+                qc = np | ((pc - RC_UNIT) & UMASK);\n+                w.stackPred = (int)pc;           \/\/ retry once\n+                if (pc != (pc = compareAndExchangeCtl(pc, qc)))\n+                    p = w.phase = phase;         \/\/ back out\n+            }\n+            if (p != phase && ((e = runState) & STOP) == 0 &&\n+                (!(quiet = (qc & RC_MASK) <= 0L) || (e & SHUTDOWN) == 0 ||\n+                 !(quiet = quiescent()) || (runState & STOP) == 0)) {\n+                long deadline = 0L;              \/\/ not terminating\n+                if (quiet) {                     \/\/ use timeout if trimmable\n+                    int nt = (short)(qc >>> TC_SHIFT);\n+                    long delay = keepAlive;      \/\/ scale if not at target\n+                    if (nt != (nt = Math.max(nt, parallelism)) && nt > 0)\n+                        delay = Math.max(TIMEOUT_SLOP, delay \/ nt);\n+                    if ((deadline = delay + System.currentTimeMillis()) == 0L)\n+                        deadline = 1L;           \/\/ avoid zero\n+                }\n+                boolean release = quiet;\n+                WorkQueue[] qs = queues;         \/\/ recheck queues\n@@ -2110,1 +2129,1 @@\n-                for (int i = -n; i < n; ++i) {\n+                for (int l = -n, j = active; l < n; ++l, ++j) {\n@@ -2112,6 +2131,1 @@\n-                    if ((p = w.phase) == active)    \/\/ precede, then interleave\n-                        break;                      \/\/  with signal checks\n-                    if (i >= 0 && (q = qs[i]) != null && (a = q.array) != null &&\n-                        (cap = a.length) > 0 && a[q.base & (cap - 1)] != null &&\n-                        qc == ctl && qc == compareAndExchangeCtl(qc, pc)) {\n-                        p = w.phase = active;       \/\/ may have missed signal\n+                    if ((p = w.phase) == active) \/\/ interleave signal checks\n@@ -2119,0 +2133,8 @@\n+                    if ((q = qs[j & (n - 1)]) != null &&\n+                        (a = q.array) != null && (cap = a.length) > 0 &&\n+                        a[q.base & (cap - 1)] != null) {\n+                        if (release && qc == ctl && compareAndSetCtl(qc, pc)) {\n+                            p = w.phase = active;\n+                            break;               \/\/ possible missed signal\n+                        }\n+                        release = true;          \/\/ track multiple or reencounter\n@@ -2120,1 +2142,1 @@\n-                    Thread.onSpinWait();            \/\/ reduce memory traffic\n+                    Thread.onSpinWait();         \/\/ reduce memory traffic\n@@ -2122,41 +2144,22 @@\n-            }\n-        }\n-        return p;\n-    }\n-\n-    \/**\n-     * Awaits signal or termination.\n-     *\n-     * @param w the worker (may be null if already terminated)\n-     * @param p current phase with IDLE known to be set\n-     * @return current phase, with IDLE set if worker should exit\n-     *\/\n-    private int awaitWork(WorkQueue w, int p) {\n-        int active = p + IDLE;\n-        long deadline = 0L, c = ctl;                \/\/ use timeout if trimmable\n-        if ((c & RC_MASK) <= 0L && ((int)c & SMASK) == (active & SMASK)) {\n-            int nt = (short)(c >>> TC_SHIFT);       \/\/ all idle and w is ctl top\n-            long delay = keepAlive;                 \/\/ scale if not at target\n-            if (nt != (nt = Math.max(nt, parallelism)) && nt > 0)\n-                delay = Math.max(TIMEOUT_SLOP, delay \/ nt);\n-            if ((deadline = delay + System.currentTimeMillis()) == 0L)\n-                deadline = 1L;                      \/\/ avoid zero\n-        }\n-        if ((runState & STOP) == 0 && w != null && (p = w.phase) != active) {\n-            LockSupport.setCurrentBlocker(this);    \/\/ emulate LockSupport.park\n-            w.parker = Thread.currentThread();\n-            for (;;) {\n-                if ((runState & STOP) != 0 || (p = w.phase) == active)\n-                    break;\n-                U.park(deadline != 0L, deadline);\n-                if ((p = w.phase) == active || (runState & STOP) != 0)\n-                    break;\n-                Thread.interrupted();               \/\/ clear for next park\n-                if (deadline != 0L &&               \/\/ try to trim on timeout\n-                    deadline - System.currentTimeMillis() < TIMEOUT_SLOP) {\n-                    long sp = w.stackPred & LMASK, qc = ctl;\n-                    if (((int)qc & SMASK) == (active & SMASK) &&\n-                        compareAndSetCtl(qc, sp | (UMASK & (qc - TC_UNIT)))) {\n-                        w.source = DEREGISTERED;\n-                        w.phase = active;\n-                        break;\n+                if (p != active) {               \/\/ emulate LockSupport.park\n+                    LockSupport.setCurrentBlocker(this);\n+                    w.parking = 1;\n+                    for (;;) {\n+                        if ((runState & STOP) != 0 || (p = w.phase) == active)\n+                            break;\n+                        U.park(deadline != 0L, deadline);\n+                        if ((p = w.phase) == active || (runState & STOP) != 0)\n+                            break;\n+                        Thread.interrupted();    \/\/ clear for next park\n+                        if (deadline != 0L && TIMEOUT_SLOP >\n+                            deadline - System.currentTimeMillis()) {\n+                            long sp = w.stackPred & LMASK, c = ctl;\n+                            long nc = sp | (UMASK & (c - TC_UNIT));\n+                            if (((int)c & SMASK) == (active & SMASK) &&\n+                                compareAndSetCtl(c, nc)) {\n+                                w.source = DEREGISTERED;\n+                                w.phase = active;\n+                                break;           \/\/ trimmed on timeout\n+                            }\n+                            deadline = 0L;       \/\/ no longer trimmable\n+                        }\n@@ -2164,1 +2167,2 @@\n-                    deadline = 0L;                  \/\/ no longer trimmable\n+                    w.parking = 0;\n+                    LockSupport.setCurrentBlocker(null);\n@@ -2167,2 +2171,0 @@\n-            w.parker = null;\n-            LockSupport.setCurrentBlocker(null);\n@@ -2220,1 +2222,1 @@\n-            WorkQueue[] qs; WorkQueue v; int i; Thread t;\n+            WorkQueue[] qs; WorkQueue v; int i;\n@@ -2225,2 +2227,2 @@\n-                if ((t = v.parker) != null)\n-                    U.unpark(t);\n+                if (v.parking != 0)\n+                    U.unpark(v.owner);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":136,"deletions":134,"binary":false,"changes":270,"status":"modified"},{"patch":"@@ -629,0 +629,16 @@\n+    \/**\n+     * invoke throws a RuntimeException if task throws unchecked exception\n+     *\/\n+    public void testInvokeUncheckedException() throws Throwable {\n+        ForkJoinPool p = new ForkJoinPool(1);\n+        try (PoolCleaner cleaner = cleaner(p)) {\n+            try {\n+                p.invoke(ForkJoinTask.adapt(new Callable<Object>() {\n+                        public Object call() { throw new ArithmeticException(); }}));\n+                shouldThrow();\n+            } catch (RuntimeException success) {\n+                assertTrue(success.getCause() instanceof ArithmeticException);\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/ForkJoinPoolTest.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"}]}