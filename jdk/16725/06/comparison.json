{"files":[{"patch":"@@ -559,1 +559,1 @@\n-     * *  Because we don't know about usage patterns (or most commonly,\n+     * * Because we don't know about usage patterns (or most commonly,\n@@ -566,1 +566,3 @@\n-     *    aren't needed. But there is no efficient way to detect this.\n+     *    aren't needed. We filter out some of these cases by exiting\n+     *    retry loops in signalWork if the task responsible for the\n+     *    signal has already been taken.\n@@ -582,3 +584,1 @@\n-     *   signalling when all were from the same source. Also, retries\n-     *   are suppressed on CAS failures by newly activated workers,\n-     *   which serves as a form of admission control.  These\n+     *   signalling when all were from the same source. These\n@@ -612,16 +612,7 @@\n-     * found by a worker, it tries to deactivate (in runWorker).  Note\n-     * that not finding tasks doesn't mean that there won't soon be\n-     * some. Further, a scan may give up under contention, returning\n-     * even without knowing whether any tasks are still present, which\n-     * is OK given, a secondary check (in awaitWork) needed to cover\n-     * deactivation\/signal races. Blocking and unblocking via\n-     * park\/unpark can cause serious slowdowns when tasks are rapidly\n-     * but irregularly generated (which is often due to garbage\n-     * collectors and other activities). One way to ameliorate is for\n-     * workers to rescan multiple times, even when there are unlikely\n-     * to be tasks. But this causes enough memory traffic and CAS\n-     * contention to prefer using quieter short spinwaits in awaitWork\n-     * and elsewhere.  Those in awaitWork are set to small values that\n-     * only cover near-miss scenarios for inactivate\/activate races.\n-     * Because idle workers are often not yet blocked (parked), we use\n-     * the WorkQueue parker field to advertise that a waiter actually\n+     * found by a worker, it tries to deactivate (in awaitWork),\n+     * giving up (and rescanning) on ctl contention. To avoid missed\n+     * signals during deactivation, the method rescans and reactivates\n+     * if there may have been a missed signal during deactivation,\n+     * filtering out most cases in which this is unnecessary. Because\n+     * idle workers are often not yet blocked (parked), we use the\n+     * WorkQueue parking field to advertise that a waiter actually\n@@ -679,1 +670,4 @@\n-     * period given by field keepAlive.\n+     * period given by field keepAlive (default 60sec), which applies\n+     * to the first timeout of a fully populated pool. Subsequent (or\n+     * other) cases use delays such that, if still quiescent, all will\n+     * be released before one additional keepAlive unit elapses.\n@@ -889,16 +883,18 @@\n-     * For class ForkJoinPool, it is usually more effective to order\n-     * fields such that the most commonly accessed fields are unlikely\n-     * to share cache lines with adjacent objects under JVM layout\n-     * rules. For class WorkQueue, an embedded @Contended region\n-     * segregates fields most heavily updated by owners from those\n-     * most commonly read by stealers or other management.  Initial\n-     * sizing and resizing of WorkQueue arrays is an even more\n-     * delicate tradeoff because the best strategy systematically\n-     * varies across garbage collectors. Small arrays are better for\n-     * locality and reduce GC scan time, but large arrays reduce both\n-     * direct false-sharing and indirect cases due to GC bookkeeping\n-     * (cardmarks etc), and reduce the number of resizes, which are\n-     * not especially fast because they require atomic transfers.\n-     * Currently, arrays are initialized to be fairly small but early\n-     * resizes rapidly increase size by more than a factor of two\n-     * until very large.  (Maintenance note: any changes in fields,\n+     * We isolate the ForkJoinPool.ctl field that otherwise causes the\n+     * most false-sharing misses with respect to other fields. Also,\n+     * ForkJoinPool fields are ordered such that fields less prone to\n+     * contention effects are first, offsetting those that otherwise\n+     * would be, while also reducing total footprint vs using\n+     * multiple @Contended regions, which tends to slow down\n+     * less-contended applications. For class WorkQueue, an\n+     * embedded @Contended region segregates fields most heavily\n+     * updated by owners from those most commonly read by stealers or\n+     * other management.  Initial sizing and resizing of WorkQueue\n+     * arrays is an even more delicate tradeoff because the best\n+     * strategy systematically varies across garbage collectors. Small\n+     * arrays are better for locality and reduce GC scan time, but\n+     * large arrays reduce both direct false-sharing and indirect\n+     * cases due to GC bookkeeping (cardmarks etc), and reduce the\n+     * number of resizes, which are not especially fast because they\n+     * require atomic transfers.  Currently, arrays are initialized to\n+     * be fairly small.  (Maintenance note: any changes in fields,\n@@ -1038,1 +1034,2 @@\n-    static final long WMASK           = ~(((long)SMASK) << 48); \/\/ id bits only\n+    static final long HMASK           = ((((long)SMASK) << 32) |\n+                                         (((long)SMASK) << 16)); \/\/ history bits\n@@ -1213,1 +1210,0 @@\n-        volatile Thread parker;    \/\/ set when parking in awaitWork\n@@ -1229,0 +1225,2 @@\n+        @jdk.internal.vm.annotation.Contended(\"w\")\n+        volatile int parking;      \/\/ nonzero if parked in awaitWork\n@@ -1298,1 +1296,1 @@\n-            int s = top, b = base, cap, m, room; ForkJoinTask<?>[] a;\n+            int s = top, b = base, cap, m, p, room, newCap; ForkJoinTask<?>[] a;\n@@ -1306,1 +1304,1 @@\n-            long pos = slotOffset(m & s);\n+            long pos = slotOffset(p = m & s);\n@@ -1311,17 +1309,14 @@\n-            if (room == 0) {                          \/\/ resize for next time\n-                int newCap;                           \/\/ rapidly grow until large\n-                if ((newCap = (cap < 1 << 24) ? cap << 2 : cap << 1) > 0) {\n-                    ForkJoinTask<?>[] newArray = null;\n-                    try {\n-                        newArray = new ForkJoinTask<?>[newCap];\n-                    } catch (OutOfMemoryError ex) {\n-                    }\n-                    if (newArray != null) {           \/\/ else throw on next push\n-                        int newMask = newCap - 1;     \/\/ poll old, push to new\n-                        for (int k = s, j = cap; j > 0; --j, --k) {\n-                            if ((newArray[k & newMask] =\n-                                 (ForkJoinTask<?>)U.getAndSetReference(\n-                                     a, slotOffset(k & m), null)) == null)\n-                                break;                \/\/ lost to pollers\n-                        }\n-                        updateArray(newArray);        \/\/ fully fenced\n+            if (room == 0 && (newCap = cap << 1) > 0) {\n+                ForkJoinTask<?>[] newArray = null;\n+                try {                                 \/\/ resize for next time\n+                    newArray = new ForkJoinTask<?>[newCap];\n+                } catch (OutOfMemoryError ex) {\n+                }\n+                if (newArray != null) {               \/\/ else throw on next push\n+                    int newMask = newCap - 1;         \/\/ poll old, push to new\n+                    for (int k = s, j = cap; j > 0; --j, --k) {\n+                        ForkJoinTask<?> u;\n+                        if ((u = (ForkJoinTask<?>)U.getAndSetReference(\n+                                 a, slotOffset(k & m), null)) == null)\n+                            break;                    \/\/ lost to pollers\n+                        newArray[k & newMask] = u;\n@@ -1329,0 +1324,1 @@\n+                    updateArray(newArray);            \/\/ fully fenced\n@@ -1330,0 +1326,1 @@\n+                a = null;\n@@ -1333,3 +1330,2 @@\n-            if ((room == 0 || room >= m || a[m & (s - 1)] == null) &&\n-                pool != null)\n-                pool.signalWork();\n+            if ((a == null || a[m & (s - 1)] == null) && pool != null)\n+                pool.signalWork(a, p);\n@@ -1442,1 +1438,1 @@\n-                            pool.signalWork();    \/\/ propagate\n+                            pool.signalWork(a, nk); \/\/ propagate\n@@ -1459,8 +1455,17 @@\n-            ForkJoinTask<?> t; ForkJoinTask<?>[] a; int b, cap, k;\n-            if ((a = array) != null && (cap = a.length) > 0 &&\n-                (t = a[k = (b = base) & (cap - 1)]) != null) {\n-                U.loadFence();\n-                if (base == b &&\n-                    U.compareAndSetReference(a, slotOffset(k), t, null)) {\n-                    updateBase(b + 1);\n-                    return t;\n+            ForkJoinTask<?>[] a; int cap;\n+            if ((a = array) != null && (cap = a.length) > 0) {\n+                for (int b = base, k;;) {  \/\/ loop only if inconsistent\n+                    ForkJoinTask<?> t = a[k = b & (cap - 1)];\n+                    U.loadFence();\n+                    if (b == (b = base)) {\n+                        Object o;\n+                        if (t == null)\n+                            o = a[k];\n+                        else if (t == (o = U.compareAndExchangeReference(\n+                                           a, slotOffset(k), t, null))) {\n+                            updateBase(b + 1);\n+                            return t;\n+                        }\n+                        if (o == null)\n+                            break;\n+                    }\n@@ -1679,0 +1684,2 @@\n+    volatile int runState;               \/\/ versioned, lockable\n+    @jdk.internal.vm.annotation.Contended(\"fjpctl\") \/\/ segregate\n@@ -1680,0 +1687,1 @@\n+    @jdk.internal.vm.annotation.Contended(\"fjpctl\") \/\/ colocate\n@@ -1681,1 +1689,0 @@\n-    volatile int runState;               \/\/ versioned, lockable\n@@ -1879,2 +1886,2 @@\n-        else if ((int)c == 0)             \/\/ was dropped on timeout\n-            replaceable = false;\n+        else if ((int)c != 0)\n+            replaceable = true;           \/\/ signal below to cascade timeouts\n@@ -1901,1 +1908,1 @@\n-            signalWork(); \/\/ may replace unless trimmed or uninitialized\n+            signalWork(null, 0); \/\/ may replace unless trimmed or uninitialized\n@@ -1907,1 +1914,5 @@\n-     * Releases an idle worker, or creates one if not enough exist.\n+     * Releases an idle worker, or creates one if not enough exist,\n+     * returning on contention if a signal task is already taken.\n+     *\n+     * @param a if nonnull, a task array holding task signalled\n+     * @param k index of task in array\n@@ -1909,1 +1920,1 @@\n-    final void signalWork() {\n+    final void signalWork(ForkJoinTask<?>[] a, int k) {\n@@ -1931,1 +1942,0 @@\n-                    Thread t;\n@@ -1933,2 +1943,2 @@\n-                    if ((t = v.parker) != null)\n-                        U.unpark(t);\n+                    if (v.parking != 0)\n+                        U.unpark(v.owner);\n@@ -1938,0 +1948,2 @@\n+            if (a != null && k >= 0 && k < a.length && a[k] == null)\n+                break;\n@@ -1956,1 +1968,1 @@\n-                Thread t;\n+                Thread t = v.owner;\n@@ -1958,1 +1970,1 @@\n-                if ((t = v.parker) != null) {\n+                if (v.parking != 0&& t != null) {\n@@ -1996,1 +2008,1 @@\n-                                    signalWork();         \/\/ ensure live\n+                                    signalWork(null, 0);  \/\/ ensure live\n@@ -2003,4 +2015,1 @@\n-                else if (compareAndSetCtl(c, c) &&        \/\/ confirm\n-                         casRunState(e, (e & SHUTDOWN) != 0 ? e | STOP : e)) {\n-                    if ((e & SHUTDOWN) != 0)              \/\/ enable termination\n-                        interruptAll();\n+                else if ((e & SHUTDOWN) == 0)\n@@ -2008,0 +2017,3 @@\n+                else if (compareAndSetCtl(c, c) && casRunState(e, e | STOP)) {\n+                    interruptAll();                       \/\/ confirmed\n+                    return true;                          \/\/ enable termination\n@@ -2024,11 +2036,6 @@\n-            for (long window = NO_HISTORY | (r >>> 16);;) {\n-                r ^= r << 13; r ^= r >>> 17; r ^= r << 5;   \/\/ xorshift\n-                if ((runState & STOP) != 0)                 \/\/ terminating\n-                    break;\n-                if (window == (window = scan(w, window & WMASK, r)) &&\n-                    window >= 0L && phase != (phase = awaitWork(w, phase))) {\n-                    if ((phase & IDLE) != 0)\n-                        break;                              \/\/ worker exit\n-                    window = NO_HISTORY | (window & SMASK); \/\/ clear history\n-                }\n-             }\n+            long window = (long)((r >>> 16) & SMASK) | NO_HISTORY;\n+            do {\n+                r ^= r << 13; r ^= r >>> 17; r ^= r << 5; \/\/ xorshift\n+            } while ((runState & STOP) == 0 &&\n+                     (((window = scan(w, window, r)) < 0L ||\n+                       ((phase = awaitWork(w, phase)) & IDLE) == 0)));\n@@ -2051,0 +2058,1 @@\n+        long next = window & ~RESCAN;\n@@ -2055,3 +2063,3 @@\n-                for (;;) {\n-                    int b, k; Object o;\n-                    ForkJoinTask<?> t = a[k = (b = q.base) & (cap - 1)];\n+                for (int b = q.base;;) {\n+                    int nb = b + 1, nk = nb & (cap - 1), k;\n+                    ForkJoinTask<?> t = a[k = b & (cap - 1)];\n@@ -2059,9 +2067,4 @@\n-                    if (q.base == b) {            \/\/ else inconsistent; retry\n-                        int nb = b + 1, nk = nb & (cap - 1);\n-                        if (t == null) {\n-                            if (a[k] == null) {   \/\/ revisit if another task\n-                                if (window >= 0L && a[nk] != null)\n-                                    window |= RESCAN;\n-                                break;\n-                            }\n-                        }\n+                    if (b == (b = q.base)) {      \/\/ else inconsistent; retry\n+                        Object o;\n+                        if (t == null)\n+                            o = a[k];\n@@ -2069,1 +2072,1 @@\n-                                            a, slotOffset(k), t, null))) {\n+                                           a, slotOffset(k), t, null))) {\n@@ -2071,5 +2074,3 @@\n-                            long pw = window, nw = ((pw << 16) | j) & WMASK;\n-                            window = nw | RESCAN;\n-                            if ((nw != pw || (short)(nw >>> 32) != j) &&\n-                                a[nk] != null)\n-                                signalWork();     \/\/ limit propagation\n+                            next = RESCAN | ((window << 16) & HMASK) | j;\n+                            if (window != next && a[nk] != null)\n+                                signalWork(a, nk); \/\/ limit propagation\n@@ -2080,2 +2081,5 @@\n-                        else if (o == null)       \/\/ contended\n-                            break;                \/\/ retried unless newly active\n+                        if (o == null) {\n+                            if (next >= 0L && a[nk] != null)\n+                                next |= RESCAN;\n+                            break;\n+                        }\n@@ -2086,1 +2090,1 @@\n-        return window;\n+        return next;\n@@ -2093,1 +2097,1 @@\n-     * @param p current phase\n+     * @param phase current phase\n@@ -2096,1 +2100,3 @@\n-    private int awaitWork(WorkQueue w, int p) {\n+    private int awaitWork(WorkQueue w, int phase) {\n+        boolean quiet;                           \/\/ true if possibly quiescent\n+        int active = phase + (IDLE << 1), p = phase | IDLE, e;\n@@ -2098,17 +2104,24 @@\n-            int idlePhase = p + IDLE, nextPhase = p + (IDLE << 1);\n-            long pc = ctl, qc = (nextPhase & LMASK) | ((pc - RC_UNIT) & UMASK);\n-            w.stackPred = (int)pc;                   \/\/ set ctl stack link\n-            w.phase = idlePhase;                     \/\/ try to inactivate\n-            if (!compareAndSetCtl(pc, qc))           \/\/ contended enque\n-                return w.phase = p;                  \/\/ back out\n-            int ac = (short)(qc >>> RC_SHIFT);\n-            boolean quiescent = (ac <= 0 && quiescent());\n-            if ((runState & STOP) != 0)\n-                return idlePhase;\n-            int spins = ac + ((((int)(qc >>> TC_SHIFT)) & SMASK) << 1);\n-            while ((p = w.phase) == idlePhase && --spins > 0)\n-                Thread.onSpinWait();  \/\/ spin for approx #accesses to signal\n-            if (p == idlePhase) {\n-                long deadline = (!quiescent ? 0L :   \/\/ timeout for trim\n-                                 System.currentTimeMillis() + keepAlive);\n-                WorkQueue[] qs = queues;\n+            w.phase = p;                         \/\/ deactivate\n+            long np = active & LMASK, pc = ctl;  \/\/ try to enqueue\n+            long qc = np | ((pc - RC_UNIT) & UMASK);\n+            w.stackPred = (int)pc;               \/\/ set ctl stack link\n+            if (pc != (pc = compareAndExchangeCtl(pc, qc))) {\n+                qc = np | ((pc - RC_UNIT) & UMASK);\n+                w.stackPred = (int)pc;           \/\/ retry once\n+                if (pc != (pc = compareAndExchangeCtl(pc, qc)))\n+                    p = w.phase = phase;         \/\/ back out\n+            }\n+            if (p != phase && ((e = runState) & STOP) == 0 &&\n+                (!(quiet = (qc & RC_MASK) <= 0L) || (e & SHUTDOWN) == 0 ||\n+                 !(quiet = quiescent()) || (runState & STOP) == 0)) {\n+                long deadline = 0L;              \/\/ not terminating\n+                if (quiet) {                     \/\/ use timeout if trimmable\n+                    int nt = (short)(qc >>> TC_SHIFT);\n+                    long delay = keepAlive;      \/\/ scale if not at target\n+                    if (nt != (nt = Math.max(nt, parallelism)) && nt > 0)\n+                        delay = Math.max(TIMEOUT_SLOP, delay \/ nt);\n+                    if ((deadline = delay + System.currentTimeMillis()) == 0L)\n+                        deadline = 1L;           \/\/ avoid zero\n+                }\n+                boolean release = quiet;\n+                WorkQueue[] qs = queues;         \/\/ recheck queues\n@@ -2116,1 +2129,1 @@\n-                for (int i = 0; i < n; ++i) {        \/\/ recheck queues\n+                for (int l = -n, j = active; l < n; ++l, ++j) {\n@@ -2118,5 +2131,1 @@\n-                    if ((q = qs[i]) != null &&\n-                        (a = q.array) != null && (cap = a.length) > 0 &&\n-                        a[q.base & (cap - 1)] != null &&\n-                        ctl == qc && compareAndSetCtl(qc, pc)) {\n-                        w.phase = (int)qc;           \/\/ release\n+                    if ((p = w.phase) == active) \/\/ interleave signal checks\n@@ -2124,0 +2133,8 @@\n+                    if ((q = qs[j & (n - 1)]) != null &&\n+                        (a = q.array) != null && (cap = a.length) > 0 &&\n+                        a[q.base & (cap - 1)] != null) {\n+                        if (release && qc == ctl && compareAndSetCtl(qc, pc)) {\n+                            p = w.phase = active;\n+                            break;               \/\/ possible missed signal\n+                        }\n+                        release = true;          \/\/ track multiple or reencounter\n@@ -2125,0 +2142,1 @@\n+                    Thread.onSpinWait();         \/\/ reduce memory traffic\n@@ -2126,1 +2144,1 @@\n-                if ((p = w.phase) == idlePhase) {    \/\/ emulate LockSupport.park\n+                if (p != active) {               \/\/ emulate LockSupport.park\n@@ -2128,1 +2146,1 @@\n-                    w.parker = Thread.currentThread();\n+                    w.parking = 1;\n@@ -2130,1 +2148,1 @@\n-                        if ((runState & STOP) != 0 || (p = w.phase) != idlePhase)\n+                        if ((runState & STOP) != 0 || (p = w.phase) == active)\n@@ -2132,2 +2150,2 @@\n-                        U.park(quiescent, deadline);\n-                        if ((p = w.phase) != idlePhase || (runState & STOP) != 0)\n+                        U.park(deadline != 0L, deadline);\n+                        if ((p = w.phase) == active || (runState & STOP) != 0)\n@@ -2135,2 +2153,2 @@\n-                        Thread.interrupted();        \/\/ clear for next park\n-                        if (quiescent && TIMEOUT_SLOP >\n+                        Thread.interrupted();    \/\/ clear for next park\n+                        if (deadline != 0L && TIMEOUT_SLOP >\n@@ -2138,3 +2156,3 @@\n-                            long sp = w.stackPred & LMASK;\n-                            long c = ctl, nc = sp | (UMASK & (c - TC_UNIT));\n-                            if (((int)c & SMASK) == (idlePhase & SMASK) &&\n+                            long sp = w.stackPred & LMASK, c = ctl;\n+                            long nc = sp | (UMASK & (c - TC_UNIT));\n+                            if (((int)c & SMASK) == (active & SMASK) &&\n@@ -2143,2 +2161,2 @@\n-                                w.phase = (int)c;\n-                                break;\n+                                w.phase = active;\n+                                break;           \/\/ trimmed on timeout\n@@ -2146,1 +2164,1 @@\n-                            deadline += keepAlive;   \/\/ not head; reset timer\n+                            deadline = 0L;       \/\/ no longer trimmable\n@@ -2149,1 +2167,1 @@\n-                    w.parker = null;\n+                    w.parking = 0;\n@@ -2204,1 +2222,1 @@\n-            WorkQueue[] qs; WorkQueue v; int i; Thread t;\n+            WorkQueue[] qs; WorkQueue v; int i;\n@@ -2209,2 +2227,2 @@\n-                if ((t = v.parker) != null)\n-                    U.unpark(t);\n+                if (v.parking != 0)\n+                    U.unpark(v.owner);\n@@ -3102,1 +3120,7 @@\n-        return task.join();\n+        try {\n+            return task.join();\n+        } catch (RuntimeException | Error unchecked) {\n+            throw unchecked;\n+        } catch (Exception checked) {\n+            throw new RuntimeException(checked);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":186,"deletions":162,"binary":false,"changes":348,"status":"modified"},{"patch":"@@ -629,0 +629,16 @@\n+    \/**\n+     * invoke throws a RuntimeException if task throws unchecked exception\n+     *\/\n+    public void testInvokeUncheckedException() throws Throwable {\n+        ForkJoinPool p = new ForkJoinPool(1);\n+        try (PoolCleaner cleaner = cleaner(p)) {\n+            try {\n+                p.invoke(ForkJoinTask.adapt(new Callable<Object>() {\n+                        public Object call() { throw new ArithmeticException(); }}));\n+                shouldThrow();\n+            } catch (RuntimeException success) {\n+                assertTrue(success.getCause() instanceof ArithmeticException);\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/ForkJoinPoolTest.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"}]}