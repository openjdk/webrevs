{"files":[{"patch":"@@ -679,1 +679,4 @@\n-     * period given by field keepAlive.\n+     * period given by field keepAlive (default 60sec), which applies\n+     * to the first timeout of a fully populated pool. Subsequent (or\n+     * other) cases use delays such that, if still quiescent, all will\n+     * be released before one additional keepAlive unit elapses.\n@@ -1879,2 +1882,2 @@\n-        else if ((int)c == 0)             \/\/ was dropped on timeout\n-            replaceable = false;\n+        else if ((int)c != 0)\n+            replaceable = true;           \/\/ signal below to cascade timeouts\n@@ -2097,54 +2100,47 @@\n-        if (w != null) {\n-            int idlePhase = p + IDLE, nextPhase = p + (IDLE << 1);\n-            long pc = ctl, qc = (nextPhase & LMASK) | ((pc - RC_UNIT) & UMASK);\n-            w.stackPred = (int)pc;                   \/\/ set ctl stack link\n-            w.phase = idlePhase;                     \/\/ try to inactivate\n-            if (!compareAndSetCtl(pc, qc))           \/\/ contended enque\n-                return w.phase = p;                  \/\/ back out\n-            int ac = (short)(qc >>> RC_SHIFT);\n-            boolean quiescent = (ac <= 0 && quiescent());\n-            if ((runState & STOP) != 0)\n-                return idlePhase;\n-            int spins = ac + ((((int)(qc >>> TC_SHIFT)) & SMASK) << 1);\n-            while ((p = w.phase) == idlePhase && --spins > 0)\n-                Thread.onSpinWait();  \/\/ spin for approx #accesses to signal\n-            if (p == idlePhase) {\n-                long deadline = (!quiescent ? 0L :   \/\/ timeout for trim\n-                                 System.currentTimeMillis() + keepAlive);\n-                WorkQueue[] qs = queues;\n-                int n = (qs == null) ? 0 : qs.length;\n-                for (int i = 0; i < n; ++i) {        \/\/ recheck queues\n-                    WorkQueue q; ForkJoinTask<?>[] a; int cap;\n-                    if ((q = qs[i]) != null &&\n-                        (a = q.array) != null && (cap = a.length) > 0 &&\n-                        a[q.base & (cap - 1)] != null &&\n-                        ctl == qc && compareAndSetCtl(qc, pc)) {\n-                        w.phase = (int)qc;           \/\/ release\n-                        break;\n-                    }\n-                }\n-                if ((p = w.phase) == idlePhase) {    \/\/ emulate LockSupport.park\n-                    LockSupport.setCurrentBlocker(this);\n-                    w.parker = Thread.currentThread();\n-                    for (;;) {\n-                        if ((runState & STOP) != 0 || (p = w.phase) != idlePhase)\n-                            break;\n-                        U.park(quiescent, deadline);\n-                        if ((p = w.phase) != idlePhase || (runState & STOP) != 0)\n-                            break;\n-                        Thread.interrupted();        \/\/ clear for next park\n-                        if (quiescent && TIMEOUT_SLOP >\n-                            deadline - System.currentTimeMillis()) {\n-                            long sp = w.stackPred & LMASK;\n-                            long c = ctl, nc = sp | (UMASK & (c - TC_UNIT));\n-                            if (((int)c & SMASK) == (idlePhase & SMASK) &&\n-                                compareAndSetCtl(c, nc)) {\n-                                w.source = DEREGISTERED;\n-                                w.phase = (int)c;\n-                                break;\n-                            }\n-                            deadline += keepAlive;   \/\/ not head; reset timer\n-                        }\n-                    }\n-                    w.parker = null;\n-                    LockSupport.setCurrentBlocker(null);\n+        if ((p & IDLE) != 0 || w == null)       \/\/ already terminating\n+            return p;\n+        int nextPhase = p + (IDLE << 1);\n+        long pc = ctl, qc = (nextPhase & LMASK) | ((pc - RC_UNIT) & UMASK);\n+        w.stackPred = (int)pc;                  \/\/ set ctl stack link\n+        w.phase = p | IDLE;                     \/\/ try to inactivate\n+        if (!compareAndSetCtl(pc, qc))          \/\/ contended enque\n+            return w.phase = p;                 \/\/ back out\n+        WorkQueue[] qs = queues;                \/\/ recheck queues\n+        int n = (qs == null) ? 0 : qs.length;\n+        for (int l = n, r = nextPhase; l > 0; --l, ++r) {\n+            WorkQueue q; ForkJoinTask<?>[] a; int cap;\n+            if ((q = qs[r & SMASK & (n - 1)]) != null && (a = q.array) != null &&\n+                (cap = a.length) > 0 && a[q.base & (cap - 1)] != null &&\n+                qc == ctl && qc == compareAndExchangeCtl(qc, pc))\n+                return p = w.phase = nextPhase; \/\/ self-signal\n+            if ((p = w.phase) == nextPhase)\n+                return p;                       \/\/ interleave signal checks\n+            Thread.onSpinWait();                \/\/ reduce memory traffic\n+        }\n+        long deadline = 0L;                     \/\/ timeout if trimmable\n+        if ((qc & RC_MASK) <= 0L && quiescent() && \/\/ all idle and w is ctl top\n+            (nextPhase & SMASK) == ((int)(qc = ctl) & SMASK)) {\n+            int nt = (short)(qc >>> TC_SHIFT), np = parallelism;\n+            long delay = keepAlive;\n+            if (np != nt)                       \/\/ scale if not at target\n+                delay = Math.max(TIMEOUT_SLOP, delay \/ Math.max(2, np));\n+            if ((deadline = delay + System.currentTimeMillis()) == 0L)\n+                deadline = 1L;                  \/\/ avoid zero\n+        }\n+        LockSupport.setCurrentBlocker(this);    \/\/ emulate LockSupport.park\n+        w.parker = Thread.currentThread();\n+        for (p = IDLE;;) {\n+            if ((runState & STOP) != 0 || (p = w.phase) == nextPhase)\n+                break;\n+            U.park(deadline != 0L, deadline);\n+            if ((p = w.phase) == nextPhase || (runState & STOP) != 0)\n+                break;\n+            Thread.interrupted();               \/\/ clear for next park\n+            if (deadline != 0L &&               \/\/ try to trim on timeout\n+                deadline - System.currentTimeMillis() < TIMEOUT_SLOP) {\n+                long sp = w.stackPred & LMASK, c;\n+                if ((nextPhase & SMASK) == ((int)(c = ctl) & SMASK)  &&\n+                    compareAndSetCtl(c, sp | (UMASK & (c - TC_UNIT)))) {\n+                    w.source = DEREGISTERED;\n+                    w.phase = nextPhase;\n+                    break;\n@@ -2152,0 +2148,1 @@\n+                deadline = 0L;                  \/\/ no longer trimmable\n@@ -2154,0 +2151,2 @@\n+        w.parker = null;\n+        LockSupport.setCurrentBlocker(null);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":56,"deletions":57,"binary":false,"changes":113,"status":"modified"}]}