{"files":[{"patch":"@@ -679,1 +679,4 @@\n-     * period given by field keepAlive.\n+     * period given by field keepAlive (default 60sec), which applies\n+     * to the first timeout of a fully populated pool. Subsequent (or\n+     * other) cases use delays such that, if still quiescent, all will\n+     * be released before one additional keepAlive unit elapses.\n@@ -889,19 +892,22 @@\n-     * For class ForkJoinPool, it is usually more effective to order\n-     * fields such that the most commonly accessed fields are unlikely\n-     * to share cache lines with adjacent objects under JVM layout\n-     * rules. For class WorkQueue, an embedded @Contended region\n-     * segregates fields most heavily updated by owners from those\n-     * most commonly read by stealers or other management.  Initial\n-     * sizing and resizing of WorkQueue arrays is an even more\n-     * delicate tradeoff because the best strategy systematically\n-     * varies across garbage collectors. Small arrays are better for\n-     * locality and reduce GC scan time, but large arrays reduce both\n-     * direct false-sharing and indirect cases due to GC bookkeeping\n-     * (cardmarks etc), and reduce the number of resizes, which are\n-     * not especially fast because they require atomic transfers.\n-     * Currently, arrays are initialized to be fairly small but early\n-     * resizes rapidly increase size by more than a factor of two\n-     * until very large.  (Maintenance note: any changes in fields,\n-     * queues, or their uses, or JVM layout policies, must be\n-     * accompanied by re-evaluation of these placement and sizing\n-     * decisions.)\n+     * We isolate the ForkJoinPool.ctl field that otherwise causes the\n+     * most false-sharing misses with respect to other fields. Also,\n+     * ForkJoinPool fields are ordered such that fields less prone to\n+     * contention effects are first, offsetting those that otherwise\n+     * would be, while also reducing total footprint vs using\n+     * multiple @Contended regions, which tends to slow down\n+     * less-contended applications. For class WorkQueue, an\n+     * embedded @Contended region segregates fields most heavily\n+     * updated by owners from those most commonly read by stealers or\n+     * other management.  Initial sizing and resizing of WorkQueue\n+     * arrays is an even more delicate tradeoff because the best\n+     * strategy systematically varies across garbage collectors. Small\n+     * arrays are better for locality and reduce GC scan time, but\n+     * large arrays reduce both direct false-sharing and indirect\n+     * cases due to GC bookkeeping (cardmarks etc), and reduce the\n+     * number of resizes, which are not especially fast because they\n+     * require atomic transfers.  Currently, arrays are initialized to\n+     * be fairly small but early resizes rapidly increase size by more\n+     * than a factor of two until very large.  (Maintenance note: any\n+     * changes in fields, queues, or their uses, or JVM layout\n+     * policies, must be accompanied by re-evaluation of these\n+     * placement and sizing decisions.)\n@@ -1679,0 +1685,2 @@\n+    volatile int runState;               \/\/ versioned, lockable\n+    @jdk.internal.vm.annotation.Contended(\"fjpctl\") \/\/ segregate\n@@ -1680,0 +1688,1 @@\n+    @jdk.internal.vm.annotation.Contended(\"fjpctl\") \/\/ colocate\n@@ -1681,1 +1690,0 @@\n-    volatile int runState;               \/\/ versioned, lockable\n@@ -1879,2 +1887,2 @@\n-        else if ((int)c == 0)             \/\/ was dropped on timeout\n-            replaceable = false;\n+        else if ((int)c != 0)\n+            replaceable = true;           \/\/ signal below to cascade timeouts\n@@ -2003,4 +2011,1 @@\n-                else if (compareAndSetCtl(c, c) &&        \/\/ confirm\n-                         casRunState(e, (e & SHUTDOWN) != 0 ? e | STOP : e)) {\n-                    if ((e & SHUTDOWN) != 0)              \/\/ enable termination\n-                        interruptAll();\n+                else if ((e & SHUTDOWN) == 0)\n@@ -2008,0 +2013,3 @@\n+                else if (compareAndSetCtl(c, c) && casRunState(e, e | STOP)) {\n+                    interruptAll();                       \/\/ confirmed\n+                    return true;                          \/\/ enable termination\n@@ -2097,54 +2105,49 @@\n-        if (w != null) {\n-            int idlePhase = p + IDLE, nextPhase = p + (IDLE << 1);\n-            long pc = ctl, qc = (nextPhase & LMASK) | ((pc - RC_UNIT) & UMASK);\n-            w.stackPred = (int)pc;                   \/\/ set ctl stack link\n-            w.phase = idlePhase;                     \/\/ try to inactivate\n-            if (!compareAndSetCtl(pc, qc))           \/\/ contended enque\n-                return w.phase = p;                  \/\/ back out\n-            int ac = (short)(qc >>> RC_SHIFT);\n-            boolean quiescent = (ac <= 0 && quiescent());\n-            if ((runState & STOP) != 0)\n-                return idlePhase;\n-            int spins = ac + ((((int)(qc >>> TC_SHIFT)) & SMASK) << 1);\n-            while ((p = w.phase) == idlePhase && --spins > 0)\n-                Thread.onSpinWait();  \/\/ spin for approx #accesses to signal\n-            if (p == idlePhase) {\n-                long deadline = (!quiescent ? 0L :   \/\/ timeout for trim\n-                                 System.currentTimeMillis() + keepAlive);\n-                WorkQueue[] qs = queues;\n-                int n = (qs == null) ? 0 : qs.length;\n-                for (int i = 0; i < n; ++i) {        \/\/ recheck queues\n-                    WorkQueue q; ForkJoinTask<?>[] a; int cap;\n-                    if ((q = qs[i]) != null &&\n-                        (a = q.array) != null && (cap = a.length) > 0 &&\n-                        a[q.base & (cap - 1)] != null &&\n-                        ctl == qc && compareAndSetCtl(qc, pc)) {\n-                        w.phase = (int)qc;           \/\/ release\n-                        break;\n-                    }\n-                }\n-                if ((p = w.phase) == idlePhase) {    \/\/ emulate LockSupport.park\n-                    LockSupport.setCurrentBlocker(this);\n-                    w.parker = Thread.currentThread();\n-                    for (;;) {\n-                        if ((runState & STOP) != 0 || (p = w.phase) != idlePhase)\n-                            break;\n-                        U.park(quiescent, deadline);\n-                        if ((p = w.phase) != idlePhase || (runState & STOP) != 0)\n-                            break;\n-                        Thread.interrupted();        \/\/ clear for next park\n-                        if (quiescent && TIMEOUT_SLOP >\n-                            deadline - System.currentTimeMillis()) {\n-                            long sp = w.stackPred & LMASK;\n-                            long c = ctl, nc = sp | (UMASK & (c - TC_UNIT));\n-                            if (((int)c & SMASK) == (idlePhase & SMASK) &&\n-                                compareAndSetCtl(c, nc)) {\n-                                w.source = DEREGISTERED;\n-                                w.phase = (int)c;\n-                                break;\n-                            }\n-                            deadline += keepAlive;   \/\/ not head; reset timer\n-                        }\n-                    }\n-                    w.parker = null;\n-                    LockSupport.setCurrentBlocker(null);\n+        int idlePhase, nextPhase;\n+        if ((idlePhase = p | IDLE) == p || w == null)\n+            return p;                           \/\/ already terminating\n+        long pc = ctl, qc = (((nextPhase = p + (IDLE << 1)) & LMASK) |\n+                             ((pc - RC_UNIT) & UMASK));\n+        w.stackPred = (int)pc;                  \/\/ set ctl stack link\n+        w.phase = idlePhase;                    \/\/ try to inactivate\n+        if (!compareAndSetCtl(pc, qc))          \/\/ contended enque\n+            return w.phase = p;                 \/\/ back out\n+        WorkQueue[] qs = queues;                \/\/ recheck queues\n+        int n = (qs == null) ? 0 : qs.length;\n+        for (int l = -n, r = nextPhase; l < n; ++l, ++r) {\n+            WorkQueue q; ForkJoinTask<?>[] a; int cap;\n+            U.loadFence();\n+            if ((q = qs[r & SMASK & (n - 1)]) != null && (a = q.array) != null &&\n+                (cap = a.length) > 0 && a[q.base & (cap - 1)] != null &&\n+                qc == ctl && qc == compareAndExchangeCtl(qc, pc))\n+                return p = w.phase = nextPhase; \/\/ self-signal\n+            Thread.onSpinWait();                \/\/ reduce memory traffic\n+            if ((p = w.phase) == nextPhase)\n+                return p;                       \/\/ interleave signal checks\n+        }\n+        long deadline = 0L;                     \/\/ timeout if trimmable\n+        if ((qc & RC_MASK) <= 0L && quiescent() && \/\/ all idle and w is ctl top\n+            (nextPhase & SMASK) == ((int)(qc = ctl) & SMASK)) {\n+            int nt = (short)(qc >>> TC_SHIFT);\n+            long delay = keepAlive;             \/\/ scale if not at target\n+            if (nt != (nt = Math.max(nt, parallelism)) && nt > 0)\n+                delay = Math.max(TIMEOUT_SLOP, delay \/ nt);\n+            if ((deadline = delay + System.currentTimeMillis()) == 0L)\n+                deadline = 1L;                  \/\/ avoid zero\n+        }\n+        LockSupport.setCurrentBlocker(this);    \/\/ emulate LockSupport.park\n+        w.parker = Thread.currentThread();\n+        for (p = IDLE;;) {\n+            if ((runState & STOP) != 0 || (p = w.phase) == nextPhase)\n+                break;\n+            U.park(deadline != 0L, deadline);\n+            if ((p = w.phase) == nextPhase || (runState & STOP) != 0)\n+                break;\n+            Thread.interrupted();               \/\/ clear for next park\n+            if (deadline != 0L &&               \/\/ try to trim on timeout\n+                deadline - System.currentTimeMillis() < TIMEOUT_SLOP) {\n+                long sp = w.stackPred & LMASK, c;\n+                if ((nextPhase & SMASK) == ((int)(c = ctl) & SMASK)  &&\n+                    compareAndSetCtl(c, sp | (UMASK & (c - TC_UNIT)))) {\n+                    w.source = DEREGISTERED;\n+                    w.phase = nextPhase;\n+                    break;\n@@ -2152,0 +2155,1 @@\n+                deadline = 0L;                  \/\/ no longer trimmable\n@@ -2154,0 +2158,2 @@\n+        w.parker = null;\n+        LockSupport.setCurrentBlocker(null);\n@@ -3102,1 +3108,9 @@\n-        return task.join();\n+        try {\n+            return task.join();\n+        } catch (RuntimeException rex) {\n+            throw rex;\n+        } catch (Error eex) {\n+            throw eex;\n+        } catch (Exception ex) {\n+            throw new RuntimeException(ex);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":96,"deletions":82,"binary":false,"changes":178,"status":"modified"}]}