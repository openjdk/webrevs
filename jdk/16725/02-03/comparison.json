{"files":[{"patch":"@@ -616,1 +616,1 @@\n-     * is OK given, a secondary check (in awaitWork) needed to cover\n+     * is OK given, a secondary check (in deactivate) needed to cover\n@@ -624,5 +624,5 @@\n-     * and elsewhere.  Those in awaitWork are set to small values that\n-     * only cover near-miss scenarios for inactivate\/activate races.\n-     * Because idle workers are often not yet blocked (parked), we use\n-     * the WorkQueue parker field to advertise that a waiter actually\n-     * needs unparking upon signal.\n+     * and elsewhere; set to small values that only cover near-miss\n+     * scenarios for deactivate\/reactivate races.  Because idle workers\n+     * are often not yet blocked (parked), we use the WorkQueue parker\n+     * field to advertise that a waiter actually needs unparking upon\n+     * signal.\n@@ -909,5 +909,4 @@\n-     * be fairly small but early resizes rapidly increase size by more\n-     * than a factor of two until very large.  (Maintenance note: any\n-     * changes in fields, queues, or their uses, or JVM layout\n-     * policies, must be accompanied by re-evaluation of these\n-     * placement and sizing decisions.)\n+     * be fairly small.  (Maintenance note: any changes in fields,\n+     * queues, or their uses, or JVM layout policies, must be\n+     * accompanied by re-evaluation of these placement and sizing\n+     * decisions.)\n@@ -1044,1 +1043,2 @@\n-    static final long WMASK           = ~(((long)SMASK) << 48); \/\/ id bits only\n+    static final long HMASK           = ((((long)SMASK) << 32) |\n+                                         (((long)SMASK) << 16)); \/\/ history bits\n@@ -1304,1 +1304,1 @@\n-            int s = top, b = base, cap, m, room; ForkJoinTask<?>[] a;\n+            int s = top, b = base, cap, m, room, newCap; ForkJoinTask<?>[] a;\n@@ -1317,17 +1317,14 @@\n-            if (room == 0) {                          \/\/ resize for next time\n-                int newCap;                           \/\/ rapidly grow until large\n-                if ((newCap = (cap < 1 << 24) ? cap << 2 : cap << 1) > 0) {\n-                    ForkJoinTask<?>[] newArray = null;\n-                    try {\n-                        newArray = new ForkJoinTask<?>[newCap];\n-                    } catch (OutOfMemoryError ex) {\n-                    }\n-                    if (newArray != null) {           \/\/ else throw on next push\n-                        int newMask = newCap - 1;     \/\/ poll old, push to new\n-                        for (int k = s, j = cap; j > 0; --j, --k) {\n-                            if ((newArray[k & newMask] =\n-                                 (ForkJoinTask<?>)U.getAndSetReference(\n-                                     a, slotOffset(k & m), null)) == null)\n-                                break;                \/\/ lost to pollers\n-                        }\n-                        updateArray(newArray);        \/\/ fully fenced\n+            if (room == 0 && (newCap = cap << 1) > 0) {\n+                ForkJoinTask<?>[] newArray = null;\n+                try {                                 \/\/ resize for next time\n+                    newArray = new ForkJoinTask<?>[newCap];\n+                } catch (OutOfMemoryError ex) {\n+                }\n+                if (newArray != null) {               \/\/ else throw on next push\n+                    int newMask = newCap - 1;         \/\/ poll old, push to new\n+                    for (int k = s, j = cap; j > 0; --j, --k) {\n+                        ForkJoinTask<?> u;\n+                        if ((u = (ForkJoinTask<?>)U.getAndSetReference(\n+                                 a, slotOffset(k & m), null)) == null)\n+                            break;                    \/\/ lost to pollers\n+                        newArray[k & newMask] = u;\n@@ -1335,0 +1332,1 @@\n+                    updateArray(newArray);            \/\/ fully fenced\n@@ -1339,2 +1337,1 @@\n-            if ((room == 0 || room >= m || a[m & (s - 1)] == null) &&\n-                pool != null)\n+            if ((room == 0 || a[m & (s - 1)] == null) && pool != null)\n@@ -2032,1 +2029,2 @@\n-            for (long window = NO_HISTORY | (r >>> 16);;) {\n+            long window = (long)((r >>> 16) & SMASK) | NO_HISTORY;\n+            do {\n@@ -2034,9 +2032,4 @@\n-                if ((runState & STOP) != 0)                 \/\/ terminating\n-                    break;\n-                if (window == (window = scan(w, window & WMASK, r)) &&\n-                    window >= 0L && phase != (phase = awaitWork(w, phase))) {\n-                    if ((phase & IDLE) != 0)\n-                        break;                              \/\/ worker exit\n-                    window = NO_HISTORY | (window & SMASK); \/\/ clear history\n-                }\n-             }\n+            } while ((runState & STOP) == 0 &&\n+                     ((window != (window = scan(w, window, r)) || window < 0L ||\n+                       ((phase = deactivate(w, phase)) & IDLE) == 0 ||\n+                       ((phase = awaitWork(w, phase)) & IDLE) == 0)));\n@@ -2059,0 +2052,1 @@\n+        long next = window & ~RESCAN;\n@@ -2070,5 +2064,3 @@\n-                            if (a[k] == null) {   \/\/ revisit if another task\n-                                if (window >= 0L && a[nk] != null)\n-                                    window |= RESCAN;\n-                                break;\n-                            }\n+                            if (next >= 0L && (a[k] != null || a[nk] != null))\n+                                next |= RESCAN;\n+                            break;                \/\/ revisit if another task\n@@ -2077,1 +2069,1 @@\n-                                            a, slotOffset(k), t, null))) {\n+                                           a, slotOffset(k), t, null))) {\n@@ -2079,3 +2071,2 @@\n-                            long pw = window, nw = ((pw << 16) | j) & WMASK;\n-                            window = nw | RESCAN;\n-                            if ((nw != pw || (short)(nw >>> 32) != j) &&\n+                            next = RESCAN | ((window << 16) & HMASK) | j;\n+                            if (((short)(next >>> 32) != j || next != window) &&\n@@ -2094,1 +2085,38 @@\n-        return window;\n+        return next;\n+    }\n+\n+    \/**\n+     * Deactivates w, reactivating on contention, already signalled,\n+     * or possible missed signal.\n+     *\n+     * @param w the worker (may be null if already terminated)\n+     * @param phase current phase\n+     * @return phase on exit\n+     *\/\n+    private int deactivate(WorkQueue w, int phase) {\n+        int idle = phase | IDLE, p = idle, active = idle + IDLE;\n+        if (phase != idle && w != null) {\n+            long pc = ctl, qc = (active & LMASK) | ((pc - RC_UNIT) & UMASK);\n+            w.stackPred = (int)pc;                  \/\/ set ctl stack link\n+            w.phase = idle;                         \/\/ try to deactivate\n+            if (!compareAndSetCtl(pc, qc))          \/\/ contended enque\n+                p = w.phase = phase;                \/\/ back out\n+            else if ((runState & SHUTDOWN) == 0 || (qc & RC_MASK) > 0L ||\n+                     !quiescent() || (runState & STOP) == 0) {\n+                WorkQueue[] qs = queues;            \/\/ recheck queues\n+                int n = (qs == null) ? 0 : qs.length;\n+                for (int i = -n; i < n; ++i) {\n+                    WorkQueue q; ForkJoinTask<?>[] a; int cap;\n+                    if ((p = w.phase) == active)    \/\/ precede, then interleave\n+                        break;                      \/\/  with signal checks\n+                    if (i >= 0 && (q = qs[i]) != null && (a = q.array) != null &&\n+                        (cap = a.length) > 0 && a[q.base & (cap - 1)] != null &&\n+                        qc == ctl && qc == compareAndExchangeCtl(qc, pc)) {\n+                        p = w.phase = active;       \/\/ may have missed signal\n+                        break;\n+                    }\n+                    Thread.onSpinWait();            \/\/ reduce memory traffic\n+                }\n+            }\n+        }\n+        return p;\n@@ -2098,1 +2126,1 @@\n-     * Tries to inactivate, and if successful, awaits signal or termination.\n+     * Awaits signal or termination.\n@@ -2101,1 +2129,1 @@\n-     * @param p current phase\n+     * @param p current phase with IDLE known to be set\n@@ -2105,27 +2133,5 @@\n-        int idlePhase, nextPhase;\n-        if ((idlePhase = p | IDLE) == p || w == null)\n-            return p;                           \/\/ already terminating\n-        long pc = ctl, qc = (((nextPhase = p + (IDLE << 1)) & LMASK) |\n-                             ((pc - RC_UNIT) & UMASK));\n-        w.stackPred = (int)pc;                  \/\/ set ctl stack link\n-        w.phase = idlePhase;                    \/\/ try to inactivate\n-        if (!compareAndSetCtl(pc, qc))          \/\/ contended enque\n-            return w.phase = p;                 \/\/ back out\n-        WorkQueue[] qs = queues;                \/\/ recheck queues\n-        int n = (qs == null) ? 0 : qs.length;\n-        for (int l = -n, r = nextPhase; l < n; ++l, ++r) {\n-            WorkQueue q; ForkJoinTask<?>[] a; int cap;\n-            U.loadFence();\n-            if ((q = qs[r & SMASK & (n - 1)]) != null && (a = q.array) != null &&\n-                (cap = a.length) > 0 && a[q.base & (cap - 1)] != null &&\n-                qc == ctl && qc == compareAndExchangeCtl(qc, pc))\n-                return p = w.phase = nextPhase; \/\/ self-signal\n-            Thread.onSpinWait();                \/\/ reduce memory traffic\n-            if ((p = w.phase) == nextPhase)\n-                return p;                       \/\/ interleave signal checks\n-        }\n-        long deadline = 0L;                     \/\/ timeout if trimmable\n-        if ((qc & RC_MASK) <= 0L && quiescent() && \/\/ all idle and w is ctl top\n-            (nextPhase & SMASK) == ((int)(qc = ctl) & SMASK)) {\n-            int nt = (short)(qc >>> TC_SHIFT);\n-            long delay = keepAlive;             \/\/ scale if not at target\n+        int active = p + IDLE;\n+        long deadline = 0L, c = ctl;                \/\/ use timeout if trimmable\n+        if ((c & RC_MASK) <= 0L && ((int)c & SMASK) == (active & SMASK)) {\n+            int nt = (short)(c >>> TC_SHIFT);       \/\/ all idle and w is ctl top\n+            long delay = keepAlive;                 \/\/ scale if not at target\n@@ -2135,1 +2141,1 @@\n-                deadline = 1L;                  \/\/ avoid zero\n+                deadline = 1L;                      \/\/ avoid zero\n@@ -2137,16 +2143,5 @@\n-        LockSupport.setCurrentBlocker(this);    \/\/ emulate LockSupport.park\n-        w.parker = Thread.currentThread();\n-        for (p = IDLE;;) {\n-            if ((runState & STOP) != 0 || (p = w.phase) == nextPhase)\n-                break;\n-            U.park(deadline != 0L, deadline);\n-            if ((p = w.phase) == nextPhase || (runState & STOP) != 0)\n-                break;\n-            Thread.interrupted();               \/\/ clear for next park\n-            if (deadline != 0L &&               \/\/ try to trim on timeout\n-                deadline - System.currentTimeMillis() < TIMEOUT_SLOP) {\n-                long sp = w.stackPred & LMASK, c;\n-                if ((nextPhase & SMASK) == ((int)(c = ctl) & SMASK)  &&\n-                    compareAndSetCtl(c, sp | (UMASK & (c - TC_UNIT)))) {\n-                    w.source = DEREGISTERED;\n-                    w.phase = nextPhase;\n+        if ((runState & STOP) == 0 && w != null && (p = w.phase) != active) {\n+            LockSupport.setCurrentBlocker(this);    \/\/ emulate LockSupport.park\n+            w.parker = Thread.currentThread();\n+            for (;;) {\n+                if ((runState & STOP) != 0 || (p = w.phase) == active)\n@@ -2154,0 +2149,14 @@\n+                U.park(deadline != 0L, deadline);\n+                if ((p = w.phase) == active || (runState & STOP) != 0)\n+                    break;\n+                Thread.interrupted();               \/\/ clear for next park\n+                if (deadline != 0L &&               \/\/ try to trim on timeout\n+                    deadline - System.currentTimeMillis() < TIMEOUT_SLOP) {\n+                    long sp = w.stackPred & LMASK, qc = ctl;\n+                    if (((int)qc & SMASK) == (active & SMASK) &&\n+                        compareAndSetCtl(qc, sp | (UMASK & (qc - TC_UNIT)))) {\n+                        w.source = DEREGISTERED;\n+                        w.phase = active;\n+                        break;\n+                    }\n+                    deadline = 0L;                  \/\/ no longer trimmable\n@@ -2155,1 +2164,0 @@\n-                deadline = 0L;                  \/\/ no longer trimmable\n@@ -2157,0 +2165,2 @@\n+            w.parker = null;\n+            LockSupport.setCurrentBlocker(null);\n@@ -2158,2 +2168,0 @@\n-        w.parker = null;\n-        LockSupport.setCurrentBlocker(null);\n@@ -3110,6 +3118,4 @@\n-        } catch (RuntimeException rex) {\n-            throw rex;\n-        } catch (Error eex) {\n-            throw eex;\n-        } catch (Exception ex) {\n-            throw new RuntimeException(ex);\n+        } catch (RuntimeException | Error unchecked) {\n+            throw unchecked;\n+        } catch (Exception checked) {\n+            throw new RuntimeException(checked);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":113,"deletions":107,"binary":false,"changes":220,"status":"modified"}]}