{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -353,1 +353,4 @@\n-        output.shouldBeEmptyIgnoreVMWarnings();\n+        List<String> stdout = output.asLinesWithoutVMWarnings();\n+        output.reportDiagnosticSummary();\n+        assertEquals(stdout.size(), 1, \"Output should contain one line\");\n+        assertTrue(stdout.get(0).startsWith(\"jstatd started\"), \"List should start with 'jstatd started'\");\n","filename":"test\/jdk\/sun\/tools\/jstatd\/JstatdTest.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 2019, 2023 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Unit test for ProcessTools.startProcess()\n+ * @library \/test\/lib\n+ * @compile ProcessToolsStartProcessTest.java\n+ * @run main ProcessToolsStartProcessTest\n+ *\/\n+\n+import java.util.function.Consumer;\n+import java.io.File;\n+\n+import jdk.test.lib.JDKToolLauncher;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class ProcessToolsStartProcessTest {\n+    static final int NUM_LINES = 50;\n+    static String output = \"\";\n+\n+    private static Consumer<String> outputConsumer = s -> {\n+        output += s + \"\\n\";\n+    };\n+\n+    static boolean testStartProcess(boolean withConsumer) throws Exception {\n+        boolean success = true;\n+        Process p;\n+        JDKToolLauncher launcher = JDKToolLauncher.createUsingTestJDK(\"java\");\n+        launcher.addToolArg(\"-cp\");\n+        launcher.addToolArg(Utils.TEST_CLASSES);\n+        launcher.addToolArg(\"ProcessToolsStartProcessTest\");\n+        launcher.addToolArg(\"test\"); \/\/ This one argument triggers producing the output\n+        ProcessBuilder pb = new ProcessBuilder();\n+        pb.command(launcher.getCommand());\n+\n+        System.out.println(\"DEBUG: Test with withConsumer=\" + withConsumer);\n+        System.out.println(\"DEBUG: about to start process.\");\n+        if (withConsumer) {\n+            p = ProcessTools.startProcess(\"java\", pb, outputConsumer);\n+        } else {\n+            p = ProcessTools.startProcess(\"java\", pb);\n+        }\n+        OutputAnalyzer out = new OutputAnalyzer(p);\n+\n+        System.out.println(\"DEBUG: process started.\");\n+        p.waitFor();\n+        if (p.exitValue() != 0) {\n+            throw new RuntimeException(\"Bad exit value: \" + p.exitValue());\n+        }\n+\n+        if (withConsumer) {\n+            int numLines = output.split(\"\\n\").length;\n+            if (numLines != NUM_LINES ) {\n+                System.out.print(\"FAILED: wrong number of lines in Consumer output\\n\");\n+                success = false;\n+            }\n+            System.out.println(\"DEBUG: Consumer output: got \" + numLines + \" lines , expected \"\n+                               + NUM_LINES  + \". Output follow:\");\n+            System.out.print(output);\n+            System.out.println(\"DEBUG: done with Consumer output.\");\n+        }\n+\n+        int numLinesOut = out.getStdout().split(\"\\n\").length;\n+        if (numLinesOut != NUM_LINES) {\n+            System.out.print(\"FAILED: wrong number of lines in OutputAnalyzer output\\n\");\n+            success = false;\n+        }\n+        System.out.println(\"DEBUG: OutputAnalyzer output: got \" + numLinesOut + \" lines, expected \"\n+                           + NUM_LINES  + \". Output follows:\");\n+        System.out.print(out.getStdout());\n+        System.out.println(\"DEBUG: done with OutputAnalyzer stdout.\");\n+\n+        return success;\n+    }\n+\n+    public static void main(String[] args) {\n+        if (args.length > 0) {\n+            for (int i = 0; i < NUM_LINES; i++) {\n+                System.out.println(\"A line on stdout \" + i);\n+            }\n+        } else {\n+            try {\n+                boolean test1Result = testStartProcess(false);\n+                boolean test2Result = testStartProcess(true);\n+                if (!test1Result || !test2Result) {\n+                    throw new RuntimeException(\"One or more tests failed. See output for details.\");\n+                }\n+            } catch (RuntimeException re) {\n+                re.printStackTrace();\n+                System.out.println(\"Test ERROR\");\n+                throw re;\n+            } catch (Exception ex) {\n+                ex.printStackTrace();\n+                System.out.println(\"Test ERROR\");\n+                throw new RuntimeException(ex);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/lib-test\/jdk\/test\/lib\/process\/ProcessToolsStartProcessTest.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"patch":"@@ -30,0 +30,2 @@\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n@@ -35,1 +37,0 @@\n-import java.lang.Thread.State;\n@@ -80,2 +81,7 @@\n-     * <span>The default redirects of STDOUT and STDERR are started<\/span>\n-     *\n+     * <span>The process output is saved in ByteArrayOutputStream and available for\n+     * analysis after process is finished. <\/span>\n+     * <p>\n+     * Same as\n+     * {@linkplain #startProcess(String, ProcessBuilder, Consumer, Predicate, long, TimeUnit) startProcess}\n+     * {@code (name, processBuilder, null, null, -1, TimeUnit.NANOSECONDS)}\n+     * <\/p>\n@@ -95,2 +101,8 @@\n-     * <span>The default redirects of STDOUT and STDERR are started<\/span>\n-     * <p>It is possible to monitor the in-streams via the provided {@code consumer}\n+     * <span>Allows to read process output with provided {@linkplain Consumer}.\n+     * The process output is saved in ByteArrayOutputStream and available for\n+     * analysis after process is finished. <\/span>\n+     * <p>\n+     * Same as\n+     * {@linkplain #startProcess(String, ProcessBuilder, Consumer, Predicate, long, TimeUnit) startProcess}\n+     * {@code (name, processBuilder, consumer, null, -1, TimeUnit.NANOSECONDS)}\n+     * <\/p>\n@@ -99,1 +111,0 @@\n-     * @param consumer       {@linkplain Consumer} instance to process the in-streams\n@@ -101,0 +112,1 @@\n+     * @param consumer       {@linkplain Consumer} instance to process the in-streams\n@@ -119,1 +131,4 @@\n-     * <span>The default redirects of STDOUT and STDERR are started<\/span>\n+     * <span>Allows to wait for process warm-up using {@linkplain Predicate}\n+     * The process output is saved in ByteArrayOutputStream and available for\n+     * analysis after process is finished.\n+     * <\/span>\n@@ -121,2 +136,3 @@\n-     * It is possible to wait for the process to get to a warmed-up state\n-     * via {@linkplain Predicate} condition on the STDOUT\/STDERR\n+     * Same as\n+     * {@linkplain #startProcess(String, ProcessBuilder, Consumer, Predicate, long, TimeUnit) startProcess}\n+     * {@code (name, processBuilder, null, linePredicate, timeout, unit)}\n@@ -149,1 +165,2 @@\n-     * <span>The default redirects of STDOUT and STDERR are started<\/span>\n+     * <span>The process output is saved in ByteArrayOutputStream and available for\n+     * analysis after process is finished. <\/span>\n@@ -153,1 +170,1 @@\n-     * in-streams via the provided {@linkplain Consumer}\n+     * in-streams via the provided {@linkplain Consumer}*\n@@ -184,0 +201,6 @@\n+        ByteArrayOutputStream outBaos = new ByteArrayOutputStream();\n+        ByteArrayOutputStream errBaos = new ByteArrayOutputStream();\n+\n+        stdout.addOutputStream(outBaos);\n+        stderr.addOutputStream(errBaos);\n+\n@@ -253,1 +276,1 @@\n-        return new ProcessImpl(p, stdoutTask, stderrTask);\n+        return new ProcessImpl(p, stdoutTask, stderrTask, outBaos, errBaos);\n@@ -704,0 +727,2 @@\n+        private final ByteArrayOutputStream outBaos;\n+        private final ByteArrayOutputStream errBaos;\n@@ -708,1 +733,2 @@\n-        public ProcessImpl(Process p, Future<Void> stdoutTask, Future<Void> stderrTask) {\n+        public ProcessImpl(Process p, Future<Void> stdoutTask, Future<Void> stderrTask,\n+                           ByteArrayOutputStream outBaos, ByteArrayOutputStream errBaos) {\n@@ -712,0 +738,2 @@\n+            this.outBaos = outBaos;\n+            this.errBaos = errBaos;\n@@ -721,1 +749,5 @@\n-            return p.getInputStream();\n+            try {\n+                waitFor();\n+            } catch (InterruptedException ie) {\n+            }\n+            return new ByteArrayInputStream(outBaos.toByteArray());\n@@ -726,1 +758,5 @@\n-            return p.getErrorStream();\n+            try {\n+                waitFor();\n+            } catch (InterruptedException ie) {\n+            }\n+            return new ByteArrayInputStream(errBaos.toByteArray());\n","filename":"test\/lib\/jdk\/test\/lib\/process\/ProcessTools.java","additions":51,"deletions":15,"binary":false,"changes":66,"status":"modified"}]}