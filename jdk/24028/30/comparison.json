{"files":[{"patch":"@@ -217,0 +217,1 @@\n+  LOG_TAG(vmatree) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-        _stack_storage.get(prev->val().out.stack()).print_on(stream);\n+        _stack_storage.get(prev->val().out.reserved_stack()).print_on(stream);\n","filename":"src\/hotspot\/share\/nmt\/memoryFileTracker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,2 +46,0 @@\n-\n-private:\n@@ -50,1 +48,0 @@\n-public:\n","filename":"src\/hotspot\/share\/nmt\/nmtNativeCallStackStorage.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,1 +31,53 @@\n-const VMATree::RegionData VMATree::empty_regiondata{NativeCallStackStorage::StackIndex{}, mtNone};\n+\n+\/\/ Semantics\n+\/\/ This tree is used to store and track the state of virtual memory regions.\n+\/\/ The nodes in the tree are key-value pairs where the key is the memory address and the value is the State of the memory regions.\n+\/\/ The State of a region describes whether the region is released, reserved or committed, which MemTag it has and where in\n+\/\/ Hotspot (using call-stacks) it is reserved or committed.\n+\/\/ Each node holds the State of the regions to its left and right. Each memory region is described by two\n+\/\/ memory addresses for its start and end.\n+\/\/ For example, to describe the region that starts at memory address 0xA000 with size 0x1000, there will be two nodes\n+\/\/ with the keys 0xA000 (node A) and 0xB000 (node B) in the tree. The value of the key-value pairs of node A and\n+\/\/ node B describe the region's State, using right of A and left of B (<--left--A--right-->.....<--left--B--right-->...).\n+\/\/\n+\/\/ Virtual memory can be reserved, committed, uncommitted and released. For each operation a request\n+\/\/ (<from-address, to-address, operation, tag, call-stack, which-tag-to-use >) is sent to the tree to handle.\n+\/\/\n+\/\/ The expected changes are described here for each operation:\n+\/\/\n+\/\/ ### Reserve a region\n+\/\/ When a region is reserved, all the overlapping regions in the tree should:\n+\/\/   - be marked as Reserved\n+\/\/   - take MemTag of the operation\n+\/\/   - store call-stack of the request to the reserve call-stack\n+\/\/   - clear commit call-stack\n+\/\/\n+\/\/ ### Commit a region\n+\/\/ When a region is committed, all the overlapping regions in the tree should:\n+\/\/   - be marked as Committed\n+\/\/   - take MemTag of the operation or MemTag of the existing region, depends on which-tag-to-use in the request\n+\/\/   - if the region is in Released state\n+\/\/     - mark the region as both Reserved and Committed\n+\/\/     - store the call-stack of the request to the reserve call-stack\n+\/\/   - store the call-stack of the request to the commit call-stack\n+\/\/\n+\/\/ ### Uncommit a region\n+\/\/ When a region is uncommitted, all the overlapping regions in the tree should:\n+\/\/   - be ignored if the region is in Released state\n+\/\/   - be marked as Reserved\n+\/\/   - not change the MemTag\n+\/\/   - not change the reserve call-stack\n+\/\/   - clear commit call-stack\n+\/\/\n+\/\/ ### Release a region\n+\/\/ When a region is released, all the overlapping regions in the tree should:\n+\/\/   - be marked as Released\n+\/\/   - set the MemTag to mtNone\n+\/\/   - clear both reserve and commit call-stack\n+\/\/\n+\/\/ ---  Accounting\n+\/\/ After each operation, the tree should be able to report how much memory is reserved or committed per MemTag.\n+\/\/ So for each region that changes to a new State, the report should contain (separately for each tag) the amount\n+\/\/ of reserve and commit that are changed (increased or decreased) due to the operation.\n+\n+const VMATree::RegionData VMATree::empty_regiondata{NativeCallStackStorage::invalid, mtNone};\n@@ -34,1 +86,1 @@\n-  \"reserved\", \"committed\", \"released\",\n+  \"released\", \"reserved\", \"committed\"\n@@ -37,1 +89,156 @@\n-VMATree::SummaryDiff VMATree::register_mapping(position A, position B, StateType state,\n+VMATree::SIndex VMATree::get_new_reserve_callstack(const SIndex es, const StateType ex, const RequestInfo& req) const {\n+  const SIndex ES = NativeCallStackStorage::invalid; \/\/ Empty Stack\n+  const SIndex rq = req.callstack;\n+  const int op = req.op_to_index();\n+  const Operation oper = req.op();\n+  assert(oper != Operation::Invalid && op >= 0 && op < 4, \"should be\");\n+  assert(op >= 0 && op < 4, \"should be\");\n+                            \/\/ existing state\n+  SIndex result[4][3] = {\/\/ Rl  Rs   C\n+                           {ES, ES, ES},   \/\/ op == Release\n+                           {rq, rq, rq},   \/\/ op == Reserve\n+                           {es, es, es},   \/\/ op == Commit\n+                           {es, es, es}    \/\/ op == Uncommit\n+                           };\n+  \/\/ When committing a Released region, the reserve-call-stack of the region should also be as what is in the request\n+  if (oper == Operation::Commit && ex == StateType::Released) {\n+    return rq;\n+  } else {\n+    return result[op][state_to_index(ex)];\n+  }\n+}\n+\n+VMATree::SIndex VMATree::get_new_commit_callstack(const SIndex es, const StateType ex, const RequestInfo& req) const {\n+  const SIndex ES = NativeCallStackStorage::invalid; \/\/ Empty Stack\n+  const SIndex rq = req.callstack;\n+  const int op_index = req.op_to_index();\n+  const Operation op = req.op();\n+  assert(op != Operation::Invalid && op_index >= 0 && op_index < 4, \"should be\");\n+                         \/\/ existing state\n+  SIndex result[4][3] = {\/\/ Rl  Rs   C\n+                           {ES, ES, ES},   \/\/ op == Release\n+                           {ES, ES, ES},   \/\/ op == Reserve\n+                           {rq, rq, rq},   \/\/ op == Commit\n+                           {ES, ES, ES}    \/\/ op == Uncommit\n+                        };\n+  return result[op_index][state_to_index(ex)];\n+}\n+\n+VMATree::StateType VMATree::get_new_state(const StateType ex, const RequestInfo& req) const {\n+  const StateType Rl = StateType::Released;\n+  const StateType Rs = StateType::Reserved;\n+  const StateType C = StateType::Committed;\n+  const int op = req.op_to_index();\n+  assert(op >= 0 && op < 4, \"should be\");\n+                            \/\/ existing state\n+  StateType result[4][3] = {\/\/ Rl  Rs   C\n+                              {Rl, Rl, Rl},   \/\/ op == Release\n+                              {Rs, Rs, Rs},   \/\/ op == Reserve\n+                              { C,  C,  C},   \/\/ op == Commit\n+                              {Rl, Rs, Rs}    \/\/ op == Uncommit\n+                           };\n+  return result[op][state_to_index(ex)];\n+}\n+\n+MemTag VMATree::get_new_tag(const MemTag ex, const RequestInfo& req) const {\n+  switch(req.op()) {\n+    case Operation::Release:\n+      return mtNone;\n+    case Operation::Reserve:\n+      return req.tag;\n+    case Operation::Commit:\n+      return req.use_tag_inplace ? ex : req.tag;\n+    case Operation::Uncommit:\n+      return ex;\n+    default:\n+      break;\n+  }\n+  return mtNone;\n+}\n+\n+void VMATree::compute_summary_diff(const SingleDiff::delta region_size,\n+                                   const MemTag current_tag,\n+                                   const StateType& ex,\n+                                   const RequestInfo& req,\n+                                   const MemTag operation_tag,\n+                                   SummaryDiff& diff) const {\n+  const StateType Rl = StateType::Released;\n+  const StateType Rs = StateType::Reserved;\n+  const StateType C = StateType::Committed;\n+  const int op = req.op_to_index();\n+  const Operation oper =  req.op();\n+  assert(oper != Operation::Invalid && op >= 0 && op < 4, \"should be\");\n+\n+  SingleDiff::delta a = region_size;\n+  \/\/ A region with size `a` has a state as <column> and an operation is requested as in <row>\n+  \/\/ The region has tag `current_tag` and the operation has tag `operation_tag`.\n+  \/\/ For each state, we decide how much to be added\/subtracted from current_tag to operation_tag. Two tables for reserve and commit.\n+  \/\/ Each pair of <x,y> in the table means add `x` to current_tag and add `y` to operation_tag. There are 3 pairs in each row for 3 states.\n+  \/\/ For example, `reserve[1][4,5]` says `-a,a` means:\n+  \/\/    - we are reserving with operation_tag a region which is already commited with current_tag\n+  \/\/    - since we are reserving, then `a` will be added to operation_tag. (`y` is `a`)\n+  \/\/    - since we uncommitting (by reserving) then `a` is to be subtracted from current_tag. (`x` is `-a`).\n+  \/\/    - amount of uncommitted size is in table `commit[1][4,5]` which is `-a,0` that means subtract `a` from current_tag.\n+                                       \/\/ existing state\n+  SingleDiff::delta reserve[4][3*2] = {\/\/ Rl    Rs     C\n+                                         {0,0, -a,0, -a,0 },   \/\/ op == Release\n+                                         {0,a, -a,a, -a,a },   \/\/ op == Reserve\n+                                         {0,a, -a,a, -a,a },   \/\/ op == Commit\n+                                         {0,0,  0,0,  0,0 }    \/\/ op == Uncommit\n+                                      };\n+  SingleDiff::delta commit[4][3*2] = {\/\/ Rl    Rs     C\n+                                        {0,0,  0,0, -a,0 },    \/\/ op == Release\n+                                        {0,0,  0,0, -a,0 },    \/\/ op == Reserve\n+                                        {0,a,  0,a, -a,a },    \/\/ op == Commit\n+                                        {0,0,  0,0, -a,0 }     \/\/ op == Uncommit\n+                                     };\n+  SingleDiff& from_rescom = diff.tag[NMTUtil::tag_to_index(current_tag)];\n+  SingleDiff&   to_rescom = diff.tag[NMTUtil::tag_to_index(operation_tag)];\n+  int st = state_to_index(ex);\n+  from_rescom.reserve += reserve[op][st * 2    ];\n+    to_rescom.reserve += reserve[op][st * 2 + 1];\n+  from_rescom.commit  +=  commit[op][st * 2    ];\n+    to_rescom.commit  +=  commit[op][st * 2 + 1];\n+\n+}\n+\/\/ update the region state between n1 and n2. Since n1 and n2 are pointers, any update of them will be visible from tree.\n+\/\/ If n1 is noop, it can be removed because its left region (n1->val().in) is already decided and its right state (n1->val().out) is decided here.\n+\/\/ The state of right of n2 (n2->val().out) cannot be decided here yet.\n+void VMATree::update_region(TreapNode* n1, TreapNode* n2, const RequestInfo& req, SummaryDiff& diff) {\n+  assert(n1 != nullptr,\"sanity\");\n+  assert(n2 != nullptr,\"sanity\");\n+  \/\/.........n1......n2......\n+  \/\/          ^------^\n+  \/\/             |\n+  IntervalState exSt = n1->val().out; \/\/ existing state info\n+\n+\n+  StateType existing_state              = exSt.type();\n+  MemTag    existing_tag                = exSt.mem_tag();\n+  SIndex    existing_reserve_callstack  = exSt.reserved_stack();\n+  SIndex    existing_commit_callstack   = exSt.committed_stack();\n+\n+  StateType new_state                   = get_new_state(existing_state, req);\n+  MemTag    new_tag                     = get_new_tag(n1->val().out.mem_tag(), req);\n+  SIndex    new_reserve_callstack       = get_new_reserve_callstack(existing_reserve_callstack, existing_state, req);\n+  SIndex    new_commit_callstack        = get_new_commit_callstack(existing_commit_callstack, existing_state, req);\n+\n+  \/\/  n1........n2\n+  \/\/ out-->\n+  n1->val().out.set_tag(new_tag);\n+  n1->val().out.set_type(new_state);\n+  n1->val().out.set_reserve_stack(new_reserve_callstack);\n+  n1->val().out.set_commit_stack(new_commit_callstack);\n+\n+  \/\/  n1........n2\n+  \/\/         <--in\n+  n2->val().in.set_tag(new_tag);\n+  n2->val().in.set_type(new_state);\n+  n2->val().in.set_reserve_stack(new_reserve_callstack);\n+  n2->val().in.set_commit_stack(new_commit_callstack);\n+\n+  SingleDiff::delta region_size = n2->key() - n1->key();\n+  compute_summary_diff(region_size, existing_tag, existing_state, req, new_tag, diff);\n+}\n+\n+VMATree::SummaryDiff VMATree::register_mapping(position _A, position _B, StateType state,\n@@ -39,4 +246,2 @@\n-  assert(!use_tag_inplace || metadata.mem_tag == mtNone,\n-         \"If using use_tag_inplace, then the supplied tag should be mtNone, was instead: %s\", NMTUtil::tag_to_name(metadata.mem_tag));\n-  if (A == B) {\n-    \/\/ A 0-sized mapping isn't worth recording.\n+\n+  if (_A == _B) {\n@@ -45,1 +250,3 @@\n-\n+  assert(_A < _B, \"should be\");\n+  SummaryDiff diff;\n+  RequestInfo req{_A, _B, state, metadata.mem_tag, metadata.stack_idx, use_tag_inplace};\n@@ -54,0 +261,4 @@\n+  stA.out.set_commit_stack(NativeCallStackStorage::invalid);\n+  stB.in.set_commit_stack(NativeCallStackStorage::invalid);\n+  VMATreap::Range rA = _tree.find_enclosing_range(_A);\n+  VMATreap::Range rB = _tree.find_enclosing_range(_B);\n@@ -55,13 +266,67 @@\n-  \/\/ First handle A.\n-  \/\/ Find closest node that is LEQ A\n-  bool LEQ_A_found = false;\n-  AddressState LEQ_A;\n-  TreapNode* leqA_n = _tree.closest_leq(A);\n-  if (leqA_n == nullptr) {\n-    assert(!use_tag_inplace, \"Cannot use the tag inplace if no pre-existing tag exists. From: \" PTR_FORMAT \" To: \" PTR_FORMAT, A, B);\n-    if (use_tag_inplace) {\n-      log_debug(nmt)(\"Cannot use the tag inplace if no pre-existing tag exists. From: \" PTR_FORMAT \" To: \" PTR_FORMAT, A, B);\n-    }\n-    \/\/ No match. We add the A node directly, unless it would have no effect.\n-    if (!stA.is_noop()) {\n-      _tree.upsert(A, stA);\n+  \/\/ nodes:          .....X.......Y...Z......W........U\n+  \/\/ request:                 A------------------B\n+  \/\/ X,Y = enclosing_nodes(A)\n+  \/\/ W,U = enclosing_nodes(B)\n+  \/\/ The cases are whether or not X and Y exists and X == A. (A == Y doesn't happen since it is searched by 'lt' predicate)\n+  \/\/ The cases are whether or not W and U exists and W == B. (B == U doesn't happen since it is searched by 'lt' predicate)\n+\n+  \/\/ We update regions in 3 sections: 1) X..A..Y, 2) Y....W, 3) W..B..U\n+  \/\/ Y: is the closest node greater than A, but less than B\n+  \/\/ W: is the closest node less than B, but greater than A\n+  \/\/ The regions in [Y,W) are updated in a loop. We update X..A..Y before the loop and W..B..U after the loop.\n+  \/\/ The table below summarizes the overlap cases. The overlapping case depends on whether X, Y, W and U exist or not,\n+  \/\/ and if they exist whether they are the same or not.\n+  \/\/ In the notations here, when there is not dot ('.') between two nodes it meaans that they are the same. For example,\n+  \/\/ ...XA....Y.... means X == A.\n+\n+\n+  \/\/ row  0:  .........A..................B.....\n+  \/\/ row  1:  .........A...YW.............B.....  \/\/ it is impossible, since it means only one node exists in the tree.\n+  \/\/ row  2:  .........A...Y..........W...B.....\n+  \/\/ row  3:  .........A...Y.............WB.....\n+\n+  \/\/ row  4:  .....X...A..................B.....\n+  \/\/ row  5:  .....X...A...YW.............B.....\n+  \/\/ row  6:  .....X...A...Y..........W...B.....\n+  \/\/ row  7:  .....X...A...Y.............WB.....\n+\n+  \/\/ row  8:  ........XA..................B.....\n+  \/\/ row  9:  ........XA...YW.............B.....\n+  \/\/ row 10:  ........XA...Y..........W...B.....\n+  \/\/ row 11:  ........XA...Y.............WB.....\n+\n+  \/\/ row 12:  .........A..................B....U\n+  \/\/ row 13:  .........A...YW.............B....U\n+  \/\/ row 14:  .........A...Y..........W...B....U\n+  \/\/ row 15:  .........A...Y.............WB....U\n+\n+  \/\/ row 16:  .....X...A..................B....U\n+  \/\/ row 17:  .....X...A...YW.............B....U\n+  \/\/ row 18:  .....X...A...Y..........W...B....U\n+  \/\/ row 19:  .....X...A...Y.............WB....U\n+\n+  \/\/ row 20:  ........XA..................B....U\n+  \/\/ row 21:  ........XA...YW.............B....U\n+  \/\/ row 22:  ........XA...Y..........W...B....U\n+  \/\/ row 23:  ........XA...Y.............WB....U\n+\n+\n+  \/\/ We intentionally did not summarize\/compress the cases to keep them as separate.\n+  \/\/ This expanded way of describing the cases helps us to understand\/analyze\/verify\/debug\/maintain\n+  \/\/ the corresponding code more easily.\n+  \/\/ Mapping of table to row, row to switch-case should be consistent. If one changes, the others have\n+  \/\/ to be updated accordingly. The sequence of dependecies is: table -> row no -> switch(row)-case -> code.\n+  \/\/ Meaning that whenever any of one item in this sequence is changed, the rest of the consequent items to\n+  \/\/ be checked\/changed.\n+\n+  TreapNode* X = rA.start;\n+  TreapNode* Y = rA.end;\n+  TreapNode* W = rB.start;\n+  TreapNode* U = rB.end;\n+  TreapNode nA{_A, stA, 0}; \/\/ the node that represents A\n+  TreapNode nB{_B, stB, 0}; \/\/ the node that represents B\n+  TreapNode* A = &nA;\n+  TreapNode* B = &nB;\n+  auto upsert_if= [&](TreapNode* node) {\n+    if (!node->val().is_noop()) {\n+      _tree.upsert(node->key(), node->val());\n@@ -69,12 +334,9 @@\n-  } else {\n-    LEQ_A_found = true;\n-    LEQ_A = AddressState{leqA_n->key(), leqA_n->val()};\n-    StateType leqA_state = leqA_n->val().out.type();\n-    StateType new_state = stA.out.type();\n-    \/\/ If we specify use_tag_inplace then the new region takes over the current tag instead of the tag in metadata.\n-    \/\/ This is important because the VirtualMemoryTracker API doesn't require supplying the tag for some operations.\n-    if (use_tag_inplace) {\n-      assert(leqA_n->val().out.type() != StateType::Released, \"Should not use inplace the tag of a released region\");\n-      MemTag tag = leqA_n->val().out.mem_tag();\n-      stA.out.set_tag(tag);\n-      stB.in.set_tag(tag);\n+  };\n+  \/\/ update region between n1 and n2\n+  auto update = [&](TreapNode* n1, TreapNode* n2) {\n+    update_region(n1, n2, req, diff);\n+  };\n+  auto remove_if = [&](TreapNode* node) -> bool{\n+    if (node->val().is_noop()) {\n+      _tree.remove(node->key());\n+      return true;\n@@ -82,40 +344,14 @@\n-\n-    \/\/ Unless we know better, let B's outgoing state be the outgoing state of the node at or preceding A.\n-    \/\/ Consider the case where the found node is the start of a region enclosing [A,B)\n-    stB.out = out_state(leqA_n);\n-\n-    \/\/ Direct address match.\n-    if (leqA_n->key() == A) {\n-      \/\/ Take over in state from old address.\n-      stA.in = in_state(leqA_n);\n-\n-      \/\/ We may now be able to merge two regions:\n-      \/\/ If the node's old state matches the new, it becomes a noop. That happens, for example,\n-      \/\/ when expanding a committed area: commit [x1, A); ... commit [A, x3)\n-      \/\/ and the result should be a larger area, [x1, x3). In that case, the middle node (A and le_n)\n-      \/\/ is not needed anymore. So we just remove the old node.\n-      stB.in = stA.out;\n-      if (stA.is_noop()) {\n-        \/\/ invalidates leqA_n\n-        _tree.remove(leqA_n->key());\n-      } else {\n-        \/\/ If the state is not matching then we have different operations, such as:\n-        \/\/ reserve [x1, A); ... commit [A, x2); or\n-        \/\/ reserve [x1, A), mem_tag1; ... reserve [A, x2), mem_tag2; or\n-        \/\/ reserve [A, x1), mem_tag1; ... reserve [A, x2), mem_tag2;\n-        \/\/ then we re-use the existing out node, overwriting its old metadata.\n-        leqA_n->val() = stA;\n-      }\n-    } else {\n-      \/\/ The address must be smaller.\n-      assert(A > leqA_n->key(), \"must be\");\n-\n-      \/\/ We add a new node, but only if there would be a state change. If there would not be a\n-      \/\/ state change, we just omit the node.\n-      \/\/ That happens, for example, when reserving within an already reserved region with identical metadata.\n-      stA.in = out_state(leqA_n); \/\/ .. and the region's prior state is the incoming state\n-      if (stA.is_noop()) {\n-        \/\/ Nothing to do.\n-      } else {\n-        \/\/ Add new node.\n-        _tree.upsert(A, stA);\n+    return false;\n+  };\n+  GrowableArrayCHeap<position, mtNMT> to_be_removed;\n+  \/\/ update regions in [Y,W)\n+  auto update_loop = [&]() {\n+    TreapNode* prev = nullptr;\n+    _tree.visit_range_in_order(_A + 1, _B + 1, [&](TreapNode* curr) {\n+      if (prev != nullptr) {\n+        update_region(prev, curr, req, diff);\n+        \/\/ during visit, structure of the tree should not be changed\n+        \/\/ keep the keys to be removed, and remove them later\n+        if (prev->val().is_noop()) {\n+          to_be_removed.push(prev->key());\n+        }\n@@ -123,2 +359,34 @@\n-    }\n-  }\n+      prev = curr;\n+    });\n+  };\n+  \/\/ update region of [A,T)\n+  auto update_A = [&](TreapNode* T) {\n+    A->val().out = A->val().in;\n+    update(A, T);\n+  };\n+  bool X_exists = X != nullptr;\n+  bool Y_exists = Y != nullptr && Y->key() <= _B;\n+  bool W_exists = W != nullptr && W->key() > _A;\n+  bool U_exists = U != nullptr;\n+  bool X_eq_A = X_exists && X->key() == _A;\n+  bool W_eq_B = W_exists && W->key() == _B;\n+  bool Y_eq_W = Y_exists && W_exists && W->key() == Y->key();\n+  int row = -1;\n+#ifdef ASSERT\n+  auto print_case = [&]() {\n+    log_trace(vmatree)(\" req: %4d---%4d\", (int)_A, (int)_B);\n+    log_trace(vmatree)(\" row: %2d\", row);\n+    log_trace(vmatree)(\" X: %4ld\", X_exists ? (long)X->key() : -1);\n+    log_trace(vmatree)(\" Y: %4ld\", Y_exists ? (long)Y->key() : -1);\n+    log_trace(vmatree)(\" W: %4ld\", W_exists ? (long)W->key() : -1);\n+    log_trace(vmatree)(\" U: %4ld\", U_exists ? (long)U->key() : -1);\n+  };\n+#endif\n+  \/\/ Order of the nodes if they exist are as: X <= A < Y <= W <= B < U\n+  \/\/             A---------------------------B\n+  \/\/       X           Y          YW         WB          U\n+  \/\/       XA          Y          YW         WB          U\n+  if (!X_exists && !Y_exists                       && !U_exists) { row =  0; }\n+  if (!X_exists &&  Y_exists &&  Y_eq_W && !W_eq_B && !U_exists) { row =  1; }\n+  if (!X_exists &&  Y_exists && !Y_eq_W && !W_eq_B && !U_exists) { row =  2; }\n+  if (!X_exists &&  Y_exists &&             W_eq_B && !U_exists) { row =  3; }\n@@ -126,26 +394,4 @@\n-  \/\/ Now we handle B.\n-  \/\/ We first search all nodes that are (A, B]. All of these nodes\n-  \/\/ need to be deleted and summary accounted for. The last node before B determines B's outgoing state.\n-  \/\/ If there is no node between A and B, its A's incoming state.\n-  GrowableArrayCHeap<AddressState, mtNMT> to_be_deleted_inbetween_a_b;\n-  bool B_needs_insert = true;\n-\n-  \/\/ Find all nodes between (A, B] and record their addresses and values. Also update B's\n-  \/\/ outgoing state.\n-  _tree.visit_range_in_order(A + 1, B + 1, [&](TreapNode* head) {\n-    int cmp_B = PositionComparator::cmp(head->key(), B);\n-    stB.out = out_state(head);\n-    if (cmp_B < 0) {\n-      \/\/ Record all nodes preceding B.\n-      to_be_deleted_inbetween_a_b.push({head->key(), head->val()});\n-    } else if (cmp_B == 0) {\n-      \/\/ Re-purpose B node, unless it would result in a noop node, in\n-      \/\/ which case record old node at B for deletion and summary accounting.\n-      if (stB.is_noop()) {\n-        to_be_deleted_inbetween_a_b.push(AddressState{B, head->val()});\n-      } else {\n-        head->val() = stB;\n-      }\n-      B_needs_insert = false;\n-    }\n-  });\n+  if ( X_exists && !Y_exists                       && !U_exists) { row =  4; }\n+  if ( X_exists &&  Y_exists &&  Y_eq_W && !W_eq_B && !U_exists) { row =  5; }\n+  if ( X_exists &&  Y_exists && !Y_eq_W && !W_eq_B && !U_exists) { row =  6; }\n+  if ( X_exists &&  Y_exists &&             W_eq_B && !U_exists) { row =  7; }\n@@ -153,6 +399,4 @@\n-  \/\/ Insert B node if needed\n-  if (B_needs_insert && \/\/ Was not already inserted\n-      !stB.is_noop())   \/\/ The operation is differing\n-    {\n-    _tree.upsert(B, stB);\n-  }\n+  if ( X_eq_A   && !Y_exists                       && !U_exists) { row =  8; }\n+  if ( X_eq_A   &&  Y_exists &&  Y_eq_W && !W_eq_B && !U_exists) { row =  9; }\n+  if ( X_eq_A   &&  Y_exists && !Y_eq_W && !W_eq_B && !U_exists) { row = 10; }\n+  if ( X_eq_A   &&  Y_exists &&             W_eq_B && !U_exists) { row = 11; }\n@@ -160,4 +404,4 @@\n-  \/\/ We now need to:\n-  \/\/ a) Delete all nodes between (A, B]. Including B in the case of a noop.\n-  \/\/ b) Perform summary accounting\n-  SummaryDiff diff;\n+  if (!X_exists && !Y_exists                       &&  U_exists) { row = 12; }\n+  if (!X_exists &&  Y_exists &&  Y_eq_W && !W_eq_B &&  U_exists) { row = 13; }\n+  if (!X_exists &&  Y_exists && !Y_eq_W && !W_eq_B &&  U_exists) { row = 14; }\n+  if (!X_exists &&  Y_exists &&             W_eq_B &&  U_exists) { row = 15; }\n@@ -165,11 +409,4 @@\n-  if (to_be_deleted_inbetween_a_b.length() == 0 && LEQ_A_found) {\n-    \/\/ We must have smashed a hole in an existing region (or replaced it entirely).\n-    \/\/ LEQ_A < A < B <= C\n-    SingleDiff& rescom = diff.tag[NMTUtil::tag_to_index(LEQ_A.out().mem_tag())];\n-    if (LEQ_A.out().type() == StateType::Reserved) {\n-      rescom.reserve -= B - A;\n-    } else if (LEQ_A.out().type() == StateType::Committed) {\n-      rescom.commit -= B - A;\n-      rescom.reserve -= B - A;\n-    }\n-  }\n+  if ( X_exists && !Y_exists                       &&  U_exists) { row = 16; }\n+  if ( X_exists &&  Y_exists &&  Y_eq_W && !W_eq_B &&  U_exists) { row = 17; }\n+  if ( X_exists &&  Y_exists && !Y_eq_W && !W_eq_B &&  U_exists) { row = 18; }\n+  if ( X_exists &&  Y_exists &&             W_eq_B &&  U_exists) { row = 19; }\n@@ -177,16 +414,4 @@\n-  \/\/ Track the previous node.\n-  AddressState prev{A, stA};\n-  for (int i = 0; i < to_be_deleted_inbetween_a_b.length(); i++) {\n-    const AddressState delete_me = to_be_deleted_inbetween_a_b.at(i);\n-    _tree.remove(delete_me.address);\n-\n-    \/\/ Perform summary accounting\n-    SingleDiff& rescom = diff.tag[NMTUtil::tag_to_index(delete_me.in().mem_tag())];\n-    if (delete_me.in().type() == StateType::Reserved) {\n-      rescom.reserve -= delete_me.address - prev.address;\n-    } else if (delete_me.in().type() == StateType::Committed) {\n-      rescom.commit -= delete_me.address - prev.address;\n-      rescom.reserve -= delete_me.address - prev.address;\n-    }\n-    prev = delete_me;\n-  }\n+  if ( X_eq_A   && !Y_exists                       &&  U_exists) { row = 20; }\n+  if ( X_eq_A   &&  Y_exists &&  Y_eq_W && !W_eq_B &&  U_exists) { row = 21; }\n+  if ( X_eq_A   &&  Y_exists && !Y_eq_W && !W_eq_B &&  U_exists) { row = 22; }\n+  if ( X_eq_A   &&  Y_exists &&             W_eq_B &&  U_exists) { row = 23; }\n@@ -194,11 +419,32 @@\n-  if (prev.address != A && prev.out().type() != StateType::Released) {\n-    \/\/ The last node wasn't released, so it must be connected to a node outside of (A, B)\n-    \/\/ A - prev - B - (some node >= B)\n-    \/\/ It might be that prev.address == B == (some node >= B), this is fine.\n-    if (prev.out().type() == StateType::Reserved) {\n-      SingleDiff& rescom = diff.tag[NMTUtil::tag_to_index(prev.out().mem_tag())];\n-      rescom.reserve -= B - prev.address;\n-    } else if (prev.out().type() == StateType::Committed) {\n-      SingleDiff& rescom = diff.tag[NMTUtil::tag_to_index(prev.out().mem_tag())];\n-      rescom.commit -= B - prev.address;\n-      rescom.reserve -= B - prev.address;\n+  DEBUG_ONLY(print_case();)\n+  switch(row) {\n+    \/\/ row  0:  .........A..................B.....\n+    case 0: {\n+      update_A(B);\n+      upsert_if(A);\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row  1:  .........A...YW.............B.....\n+    case 1: {\n+      ShouldNotReachHere();\n+      break;\n+    }\n+    \/\/ row  2:  .........A...Y..........W...B.....\n+    case 2: {\n+      update_A(Y);\n+      upsert_if(A);\n+      update_loop();\n+      remove_if(Y);\n+      update(W, B);\n+      remove_if(W);\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row  3:  .........A...Y.............WB.....\n+    case 3: {\n+      update_A(Y);\n+      upsert_if(A);\n+      update_loop();\n+      remove_if(W);\n+      break;\n@@ -206,0 +452,188 @@\n+    \/\/ row  4:  .....X...A..................B.....\n+    case 4: {\n+      A->val().in = X->val().out;\n+      update_A(B);\n+      upsert_if(A);\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row  5:  .....X...A...YW.............B.....\n+    case 5: {\n+      A->val().in = X->val().out;\n+      update_A(Y);\n+      upsert_if(A);\n+      update(Y, B);\n+      remove_if(Y);\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row  6:  .....X...A...Y..........W...B.....\n+    case 6: {\n+      A->val().in = X->val().out;\n+      update_A(Y);\n+      upsert_if(A);\n+      update_loop();\n+      update(W, B);\n+      remove_if(W);\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row  7:  .....X...A...Y.............WB.....\n+    case 7: {\n+      A->val().in = X->val().out;\n+      update_A(Y);\n+      upsert_if(A);\n+      update_loop();\n+      remove_if(W);\n+      break;\n+    }\n+    \/\/ row  8:  ........XA..................B.....\n+    case 8: {\n+      update(X, B);\n+      remove_if(X);\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row  9:  ........XA...YW.............B.....\n+    case 9: {\n+      update(X, Y);\n+      remove_if(X);\n+      update(W, B);\n+      remove_if(W);\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row 10:  ........XA...Y..........W...B.....\n+    case 10: {\n+      update(X, Y);\n+      remove_if(X);\n+      update_loop();\n+      update(W, B);\n+      remove_if(W);\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row 11:  ........XA...Y.............WB.....\n+    case 11: {\n+      update(X, Y);\n+      remove_if(X);\n+      update_loop();\n+      remove_if(W);\n+      break;\n+    }\n+    \/\/ row 12:  .........A..................B....U\n+    case 12: {\n+      update_A(B);\n+      upsert_if(A);\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row 13:  .........A...YW.............B....U\n+    case 13: {\n+      update_A(Y);\n+      upsert_if(A);\n+      update(W, B);\n+      remove_if(W);\n+      B->val().out = U->val().in;\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row 14:  .........A...Y..........W...B....U\n+    case 14: {\n+      update_A(Y);\n+      upsert_if(A);\n+      update_loop();\n+      update(W, B);\n+      remove_if(W);\n+      B->val().out = U->val().in;\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row 15:  .........A...Y.............WB....U\n+    case 15: {\n+      update_A(Y);\n+      upsert_if(A);\n+      update_loop();\n+      remove_if(W);\n+      break;\n+    }\n+    \/\/ row 16:  .....X...A..................B....U\n+    case 16: {\n+      A->val().in = X->val().out;\n+      update_A(B);\n+      upsert_if(A);\n+      B->val().out = U->val().in;\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row 17:  .....X...A...YW.............B....U\n+    case 17: {\n+      A->val().in = X->val().out;\n+      update_A(Y);\n+      upsert_if(A);\n+      update(W, B);\n+      remove_if(W);\n+      B->val().out = U->val().in;\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row 18:  .....X...A...Y..........W...B....U\n+    case 18: {\n+      A->val().in = X->val().out;\n+      update_A(Y);\n+      upsert_if(A);\n+      update_loop();\n+      update(W, B);\n+      remove_if(W);\n+      B->val().out = U->val().in;\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row 19:  .....X...A...Y.............WB....U\n+    case 19: {\n+      A->val().in = X->val().out;\n+      update_A(Y);\n+      upsert_if(A);\n+      update_loop();\n+      remove_if(W);\n+      break;\n+    }\n+    \/\/ row 20:  ........XA..................B....U\n+    case 20: {\n+      update(X, B);\n+      remove_if(X);\n+      B->val().out = U->val().in;\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row 21:  ........XA...YW.............B....U\n+    case 21: {\n+      update(X, Y);\n+      remove_if(X);\n+      update(W, B);\n+      remove_if(W);\n+      B->val().out = U->val().in;\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row 22:  ........XA...Y..........W...B....U\n+    case 22: {\n+      update(X, Y);\n+      remove_if(X);\n+      update_loop();\n+      update(W, B);\n+      remove_if(W);\n+      B->val().out = U->val().in;\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row 23:  ........XA...Y.............WB....U\n+    case 23: {\n+      update(X, Y);\n+      remove_if(X);\n+      update_loop();\n+      remove_if(W);\n+      break;\n+    }\n+    default:\n+      ShouldNotReachHere();\n@@ -208,7 +642,3 @@\n-  \/\/ Finally, we can register the new region [A, B)'s summary data.\n-  SingleDiff& rescom = diff.tag[NMTUtil::tag_to_index(stA.out.mem_tag())];\n-  if (state == StateType::Reserved) {\n-    rescom.reserve += B - A;\n-  } else if (state == StateType::Committed) {\n-    rescom.commit += B - A;\n-    rescom.reserve += B - A;\n+  \/\/ Remove the 'noop' nodes that found inside the loop\n+  while(to_be_removed.length() != 0) {\n+    _tree.remove(to_be_removed.pop());\n@@ -216,0 +646,1 @@\n+\n@@ -222,2 +653,2 @@\n-    out->print(\"%zu (%s) - %s - \", current->key(), NMTUtil::tag_to_name(out_state(current).mem_tag()),\n-               statetype_to_string(out_state(current).type()));\n+    out->print(\"%zu (%s) - %s [%d, %d]-> \", current->key(), NMTUtil::tag_to_name(out_state(current).mem_tag()),\n+              statetype_to_string(out_state(current).type()), current->val().out.reserved_stack(), current->val().out.committed_stack());\n@@ -271,1 +702,1 @@\n-    RegionData new_data = RegionData(out.stack(), tag);\n+    RegionData new_data = RegionData(out.reserved_stack(), tag);\n@@ -292,1 +723,1 @@\n-      RegionData new_data = RegionData(out.stack(), tag);\n+      RegionData new_data = RegionData(out.reserved_stack(), tag);\n","filename":"src\/hotspot\/share\/nmt\/vmatree.cpp","additions":591,"deletions":160,"binary":false,"changes":751,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+  using SIndex = NativeCallStackStorage::StackIndex;\n@@ -58,1 +59,1 @@\n-  enum class StateType : uint8_t { Reserved, Committed, Released, LAST };\n+  enum class StateType : uint8_t { Released, Reserved, Committed, LAST };\n@@ -73,1 +74,1 @@\n-    const NativeCallStackStorage::StackIndex stack_idx;\n+    const SIndex stack_idx;\n@@ -78,1 +79,1 @@\n-    RegionData(NativeCallStackStorage::StackIndex stack_idx, MemTag mem_tag)\n+    RegionData(SIndex stack_idx, MemTag mem_tag)\n@@ -94,1 +95,2 @@\n-    NativeCallStackStorage::StackIndex sidx;\n+    NativeCallStackStorage::StackIndex _reserved_stack;\n+    NativeCallStackStorage::StackIndex _committed_stack;\n@@ -97,1 +99,11 @@\n-    IntervalState() : type_tag{0,0}, sidx() {}\n+    IntervalState() : type_tag{0,0}, _reserved_stack(NativeCallStackStorage::invalid), _committed_stack(NativeCallStackStorage::invalid) {}\n+    IntervalState(const StateType type,\n+                  const MemTag mt,\n+                  const NativeCallStackStorage::StackIndex res_stack,\n+                  const NativeCallStackStorage::StackIndex com_stack) {\n+      assert(!(type == StateType::Released) || mt == mtNone, \"Released state-type must have memory tag mtNone\");\n+      type_tag[0] = static_cast<uint8_t>(type);\n+      type_tag[1] = static_cast<uint8_t>(mt);\n+      _reserved_stack = res_stack;\n+      _committed_stack = com_stack;\n+    }\n@@ -102,1 +114,2 @@\n-      sidx = data.stack_idx;\n+      _reserved_stack = data.stack_idx;\n+      _committed_stack = NativeCallStackStorage::invalid;\n@@ -113,2 +126,5 @@\n-    RegionData regiondata() const {\n-      return RegionData{sidx, mem_tag()};\n+    RegionData reserved_regiondata() const {\n+      return RegionData{_reserved_stack, mem_tag()};\n+    }\n+    RegionData committed_regiondata() const {\n+      return RegionData{_committed_stack, mem_tag()};\n@@ -121,2 +137,33 @@\n-    NativeCallStackStorage::StackIndex stack() const {\n-     return sidx;\n+    NativeCallStackStorage::StackIndex reserved_stack() const {\n+      return _reserved_stack;\n+    }\n+\n+    NativeCallStackStorage::StackIndex committed_stack() const {\n+      return _committed_stack;\n+    }\n+\n+    void set_reserve_stack(NativeCallStackStorage::StackIndex idx) {\n+      _reserved_stack = idx;\n+    }\n+\n+    void set_commit_stack(NativeCallStackStorage::StackIndex idx) {\n+      _committed_stack = idx;\n+    }\n+\n+    bool has_reserved_stack() {\n+      return _reserved_stack != NativeCallStackStorage::invalid;\n+    }\n+\n+    bool has_committed_stack() {\n+      return _committed_stack != NativeCallStackStorage::invalid;\n+    }\n+\n+    void set_type(StateType t) {\n+      type_tag[0] = static_cast<uint8_t>(t);\n+    }\n+\n+    bool equals(const IntervalState& other) const {\n+      return mem_tag()          == other.mem_tag()          &&\n+             type()             == other.type()             &&\n+             reserved_stack()   == other.reserved_stack()   &&\n+             committed_stack()  == other.committed_stack();\n@@ -133,0 +180,5 @@\n+      if (in.type() == StateType::Released &&\n+          in.type() == out.type() &&\n+          in.mem_tag() == out.mem_tag()) {\n+        return true;\n+      }\n@@ -134,1 +186,2 @@\n-             RegionData::equals(in.regiondata(), out.regiondata());\n+             RegionData::equals(in.reserved_regiondata(), out.reserved_regiondata()) &&\n+             RegionData::equals(in.committed_regiondata(), out.committed_regiondata());\n@@ -196,0 +249,26 @@\n+  enum Operation {Release, Reserve, Commit, Uncommit, Invalid};\n+  struct RequestInfo {\n+    position A, B;\n+    StateType _op;\n+    MemTag tag;\n+    SIndex callstack;\n+    bool use_tag_inplace;\n+    Operation op() const {\n+      return\n+            _op == StateType::Released                      ? Operation::Release  :\n+            _op == StateType::Reserved && !use_tag_inplace  ? Operation::Reserve  :\n+            _op == StateType::Committed                     ? Operation::Commit   :\n+            _op == StateType::Reserved &&  use_tag_inplace  ? Operation::Uncommit :\n+             Operation::Invalid; \/\/ should not reach here\n+    }\n+\n+    int op_to_index() const {\n+      return\n+            _op == StateType::Released                      ? 0 :\n+            _op == StateType::Reserved && !use_tag_inplace  ? 1 :\n+            _op == StateType::Committed                     ? 2 :\n+            _op == StateType::Reserved &&  use_tag_inplace  ? 3 :\n+             -1;\n+    }\n+  };\n+\n@@ -198,0 +277,12 @@\n+  StateType get_new_state(const StateType existinting_state, const RequestInfo& req) const;\n+  MemTag get_new_tag(const MemTag existinting_tag, const RequestInfo& req) const;\n+  SIndex get_new_reserve_callstack(const SIndex existinting_stack, const StateType ex, const RequestInfo& req) const;\n+  SIndex get_new_commit_callstack(const SIndex existinting_stack, const StateType ex, const RequestInfo& req) const;\n+  void compute_summary_diff(const SingleDiff::delta region_size, const MemTag t1, const StateType& ex, const RequestInfo& req, const MemTag new_tag, SummaryDiff& diff) const;\n+  void update_region(TreapNode* n1, TreapNode* n2, const RequestInfo& req, SummaryDiff& diff);\n+  int state_to_index(const StateType st) const {\n+    return\n+      st == StateType::Released ? 0 :\n+      st == StateType::Reserved ? 1 :\n+      st == StateType::Committed ? 2 : -1;\n+  }\n","filename":"src\/hotspot\/share\/nmt\/vmatree.hpp","additions":102,"deletions":11,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-  constexpr static const int si_len = 2;\n+  constexpr static const int si_len = 4;\n@@ -46,0 +46,2 @@\n+    stacks[2] = make_stack(0xC);\n+    stacks[3] = make_stack(0xD);\n@@ -47,1 +49,3 @@\n-    si[1] = ncs.push(stacks[0]);\n+    si[1] = ncs.push(stacks[1]);\n+    si[2] = ncs.push(stacks[2]);\n+    si[3] = ncs.push(stacks[3]);\n@@ -102,0 +106,5 @@\n+    \/\/                      900---1000\n+    \/\/                 800--900\n+    \/\/            700--800\n+    \/\/        ...\n+    \/\/ 0--100\n@@ -170,0 +179,148 @@\n+  template<int NodeCount> struct ExpectedTree {\n+    int nodes[NodeCount];\n+    MemTag tags[NodeCount + 1];\n+    VMATree::StateType states[NodeCount + 1];\n+    NativeCallStackStorage::StackIndex res_si[NodeCount + 1];\n+    NativeCallStackStorage::StackIndex com_si[NodeCount + 1];\n+  };\n+\n+  using State = VMATree::StateType;\n+  using SIndex = VMATree::SIndex;\n+  enum OpType { Rel, Res, Com, ComF, Uncom };\n+\n+  struct UpdateCallInfo {\n+    VMATree::IntervalState ex_st;\n+    VMATree::RequestInfo req;\n+    VMATree::IntervalState new_st;\n+    int reserve[2], commit[2];\n+  };\n+\n+  void call_update_region(const UpdateCallInfo upd) {\n+    VMATree::TreapNode n1{upd.req.A, {}, 0}, n2{upd.req.B, {}, 0};\n+    n1.val().out= upd.ex_st;\n+    n2.val().in = n1.val().out;\n+    Tree tree;\n+    VMATree::SummaryDiff diff;\n+    tree.update_region(&n1, &n2, upd.req, diff);\n+    int from = NMTUtil::tag_to_index(upd.ex_st.mem_tag());\n+    int   to = NMTUtil::tag_to_index(upd.new_st.mem_tag());\n+    stringStream ss;\n+    ss.print(\"Ex. State: %d, op: %d, use-tag:%d, from==to: %d\",\n+             (int)upd.ex_st.type(), (int)upd.req.op_to_index(), upd.req.use_tag_inplace, from == to);\n+    const char* failed_case = ss.base();\n+    EXPECT_EQ(n1.val().out.type(), upd.new_st.type()) << failed_case;\n+    EXPECT_EQ(n1.val().out.mem_tag(), upd.new_st.mem_tag()) << failed_case;\n+    EXPECT_EQ(n1.val().out.reserved_stack(), upd.new_st.reserved_stack()) << failed_case;\n+    EXPECT_EQ(n1.val().out.committed_stack(), upd.new_st.committed_stack()) << failed_case;\n+\n+    if (from == to) {\n+      EXPECT_EQ(diff.tag[from].reserve, upd.reserve[0] + upd.reserve[1]) << failed_case;\n+      EXPECT_EQ(diff.tag[from].commit, upd.commit[0] + upd.commit[1]) << failed_case;\n+    } else {\n+      EXPECT_EQ(diff.tag[from].reserve, upd.reserve[0]) << failed_case;\n+      EXPECT_EQ(diff.tag[from].commit, upd.commit[0]) << failed_case;\n+      EXPECT_EQ(diff.tag[to].reserve, upd.reserve[1]) << failed_case;\n+      EXPECT_EQ(diff.tag[to].commit, upd.commit[1]) << failed_case;\n+    }\n+  }\n+\n+  template<int N>\n+  void create_tree(Tree& tree, ExpectedTree<N>& et) {\n+    using SIndex = NativeCallStackStorage::StackIndex;\n+    const SIndex ES = NativeCallStackStorage::invalid; \/\/ Empty Stack\n+    VMATree::IntervalChange st;\n+    for (int i = 0; i < N; i++) {\n+      st.in.set_type(et.states[i]);\n+      st.in.set_tag(et.tags[i]);\n+      if (et.res_si[i] >= 0) {\n+        st.in.set_reserve_stack(et.res_si[i]);\n+      } else {\n+        st.in.set_reserve_stack(ES);\n+      }\n+      if (et.com_si[i] >= 0) {\n+        st.in.set_commit_stack(et.com_si[i]);\n+      } else {\n+        st.in.set_commit_stack(ES);\n+      }\n+\n+      st.out.set_type(et.states[i+1]);\n+      st.out.set_tag(et.tags[i+1]);\n+      if (et.res_si[i+1] >= 0) {\n+        st.out.set_reserve_stack(et.res_si[i+1]);\n+      } else {\n+        st.out.set_reserve_stack(ES);\n+      }\n+      if (et.com_si[i+1] >= 0) {\n+        st.out.set_commit_stack(et.com_si[i+1]);\n+      } else {\n+        st.out.set_commit_stack(ES);\n+      }\n+      tree.tree().upsert((VMATree::position)et.nodes[i], st);\n+    }\n+}\n+\n+  template <int N>\n+  void check_tree(Tree& tree, const ExpectedTree<N>& et, int line_no) {\n+    using Node = VMATree::TreapNode;\n+    auto left_released = [&](Node n) -> bool {\n+      return n.val().in.type() == VMATree::StateType::Released and\n+            n.val().in.mem_tag() == mtNone;\n+    };\n+    auto right_released = [&](Node n) -> bool {\n+      return n.val().out.type() == VMATree::StateType::Released and\n+            n.val().out.mem_tag() == mtNone;\n+    };\n+    for (int i = 0; i < N; i++) {\n+      VMATree::VMATreap::Range r = tree.tree().find_enclosing_range(et.nodes[i]);\n+      ASSERT_TRUE(r.start != nullptr);\n+      Node node = *r.start;\n+      ASSERT_EQ(node.key(), (VMATree::position)et.nodes[i]) << \"at line \" << line_no;\n+      if (i == (N -1)) { \/\/ last node\n+        EXPECT_TRUE(right_released(node)) << \"right-of last node is not Released\";\n+        break;\n+      }\n+      if (i == 0) { \/\/ first node\n+        EXPECT_TRUE(left_released(node)) << \"left-of first node is not Released\";\n+      }\n+      stringStream ss(50);\n+      ss.print(\"test at line: %d, for node: %d\", line_no, et.nodes[i]);\n+      const char* for_this_node = ss.base();\n+      EXPECT_EQ(node.val().out.type(), et.states[i+1]) << for_this_node;\n+      EXPECT_EQ(node.val().out.mem_tag(), et.tags[i+1]) << for_this_node;\n+      if (et.res_si[i+1] >= 0) {\n+        EXPECT_EQ(node.val().out.reserved_stack(), et.res_si[i+1]) << for_this_node;\n+        EXPECT_EQ(r.end->val().in.reserved_stack(), et.res_si[i+1]) << for_this_node;\n+      } else {\n+        EXPECT_FALSE(node.val().out.has_reserved_stack()) << for_this_node;\n+        EXPECT_FALSE(r.end->val().in.has_reserved_stack()) << for_this_node;\n+      }\n+      if (et.com_si[i+1] >= 0) {\n+        EXPECT_EQ(node.val().out.committed_stack(), et.com_si[i+1]) << for_this_node;\n+        EXPECT_EQ(r.end->val().in.committed_stack(), et.com_si[i+1]) << for_this_node;\n+      } else {\n+        EXPECT_FALSE(node.val().out.has_committed_stack()) << for_this_node;\n+        EXPECT_FALSE(r.end->val().in.has_committed_stack()) << for_this_node;\n+      }\n+    }\n+  }\n+\n+  template<int N>\n+  void print_tree(const ExpectedTree<N>& et, int line_no) {\n+    const State Rs = State::Reserved;\n+    const State Rl = State::Released;\n+    const State C = State::Committed;\n+    stringStream ss;\n+    ss.print_cr(\"Tree nodes for line %d\", line_no);\n+    ss.print_cr(\"\/\/            1         2         3         4         5         6         7\");\n+    ss.print_cr(\"\/\/  01234567890123456789012345678901234567890123456789012345678901234567890\");\n+    ss.print   (\"    \");\n+    for (int i = 0; i < N; i++) {\n+      char state_char = et.states[i+1] == Rl ? '.' :\n+                        et.states[i+1] == Rs ? 'r' :\n+                        et.states[i+1] ==  C ? 'C' : ' ';\n+      for (int j = et.nodes[i]; i < (N - 1) && j < et.nodes[i + 1]; j++) {\n+        ss.put(state_char);\n+      }\n+    }\n+    tty->print_cr(\"%s\", ss.base());\n+  }\n@@ -182,1 +339,1 @@\n-TEST_VM_F(NMTVMATreeTest, UseFlagInplace) {\n+TEST_VM_F(NMTVMATreeTest, UseTagInplace) {\n@@ -187,0 +344,4 @@\n+  \/\/ reserve:   0---------------------100\n+  \/\/ commit:        20**********70\n+  \/\/ uncommit:          30--40\n+  \/\/ post-cond: 0---20**30--40**70----100\n@@ -232,1 +393,1 @@\n-        EXPECT_EQ(x->val().out.regiondata().mem_tag, mtTest);\n+        EXPECT_EQ(x->val().out.reserved_regiondata().mem_tag, mtTest);\n@@ -268,1 +429,1 @@\n-        EXPECT_EQ(mtTest, x->val().out.regiondata().mem_tag);\n+        EXPECT_EQ(mtTest, x->val().out.reserved_regiondata().mem_tag);\n@@ -271,1 +432,1 @@\n-        EXPECT_EQ(mtTest, x->val().in.regiondata().mem_tag);\n+        EXPECT_EQ(mtTest, x->val().in.reserved_regiondata().mem_tag);\n@@ -292,1 +453,1 @@\n-    NCS::StackIndex stack;\n+    NCS::StackIndex reserve_stack;\n@@ -297,1 +458,1 @@\n-  auto expect_equivalent_form = [&](auto& expected, VMATree& tree) {\n+  auto expect_equivalent_form = [&](auto& expected, VMATree& tree, int line_no) {\n@@ -314,2 +475,2 @@\n-      EXPECT_EQ(expect.tag, found.start->val().out.mem_tag());\n-      EXPECT_EQ(expect.tag, found.end->val().in.mem_tag());\n+      EXPECT_EQ(expect.tag, found.start->val().out.mem_tag()) << \" and at test-line: \" << line_no;\n+      EXPECT_EQ(expect.tag, found.end->val().in.mem_tag()) << \" and at test-line: \" << line_no;\n@@ -317,2 +478,2 @@\n-      EXPECT_EQ(expect.stack, found.start->val().out.stack());\n-      EXPECT_EQ(expect.stack, found.end->val().in.stack());\n+      EXPECT_EQ(expect.reserve_stack, found.start->val().out.reserved_stack()) << \"Unexpected stack at region: \" << i << \" and at test-line: \" << line_no;\n+      EXPECT_EQ(expect.reserve_stack, found.end->val().in.reserved_stack()) << \"Unexpected stack at region: \" << i << \" and at test-line: \" << line_no;\n@@ -327,0 +488,2 @@\n+  NCS::StackIndex es = NCS::invalid; \/\/ empty or no stack is stored\n+\n@@ -340,1 +503,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -356,0 +519,7 @@\n+    \/\/ 0---------------------------------------------------600\n+    \/\/        100****225\n+    \/\/                           550***560\n+    \/\/                                       565***575\n+    \/\/ 0------100****225---------550***560---565***575-----600\n+    \/\/ 0------100****225---500---550***560---565***575-----600\n+    \/\/ <-------mtGC---------><-----------mtClassShared------->\n@@ -364,1 +534,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -377,1 +547,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -393,1 +563,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -406,1 +576,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -421,1 +591,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -427,1 +597,1 @@\n-        {50,  75,        mtNone, si, State::Released},\n+        {50,  75,        mtNone, es, State::Released},\n@@ -436,1 +606,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -447,1 +617,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -453,1 +623,1 @@\n-        { 1,  50, mtNone, si, State::Released},\n+        { 1,  50, mtNone, es, State::Released},\n@@ -455,1 +625,1 @@\n-        {75,  99, mtNone, si, State::Released},\n+        {75,  99, mtNone, es, State::Released},\n@@ -464,1 +634,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -475,0 +645,6 @@\n+\/\/            1         2         3         4         5         6         7         8         9         10         11\n+\/\/  01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\n+\/\/  AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA..........\n+\/\/  Legend:\n+\/\/  A - Test (reserved)\n+\/\/  . - free\n@@ -478,0 +654,8 @@\n+\/\/              1         2         3         4         5         6         7         8         9         10         11\n+\/\/    01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\n+\/\/    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCC..........\n+\/\/    Legend:\n+\/\/     A - Test (reserved)\n+\/\/     B - Native Memory Tracking (reserved)\n+\/\/     C - Test (reserved)\n+\/\/     . - free\n@@ -487,0 +671,6 @@\n+\/\/            1         2         3         4         5         6         7         8         9         10         11\n+\/\/  01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\n+\/\/  AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA..........\n+\/\/  Legend:\n+\/\/  A - Test (reserved)\n+\/\/  . - free\n@@ -490,0 +680,4 @@\n+\/\/            1         2         3         4         5         6         7         8         9         10        11\n+\/\/  01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\n+\/\/  ..............................................................................................................\n+\/\/  Legend:\n@@ -497,0 +691,6 @@\n+\/\/            1         2         3         4         5         6         7         8         9         10         11\n+\/\/  01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\n+\/\/  AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA..........\n+\/\/  Legend:\n+\/\/  A - Test (reserved)\n+\/\/  . - free\n@@ -500,0 +700,6 @@\n+\/\/            1         2         3         4         5         6         7         8         9         10         11\n+\/\/  01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\n+\/\/  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa..........\n+\/\/  Legend:\n+\/\/  a - Test (committed)\n+\/\/  . - free\n@@ -507,1 +713,7 @@\n-    VMATree::SummaryDiff all_diff = tree.reserve_mapping(0, 100, rd);\n+    VMATree::SummaryDiff all_diff = tree.reserve_mapping(0, 10, rd);\n+\/\/            1         2\n+\/\/  01234567890123456789\n+\/\/  AAAAAAAAAA..........\n+\/\/  Legend:\n+\/\/  A - Test (reserved)\n+\/\/  . - free\n@@ -509,2 +721,8 @@\n-    EXPECT_EQ(diff.reserve, 100);\n-    all_diff = tree.reserve_mapping(100, 100, rd);\n+    EXPECT_EQ(diff.reserve, 10);\n+    all_diff = tree.reserve_mapping(10, 10, rd);\n+\/\/            1         2         3\n+\/\/  012345678901234567890123456789\n+\/\/  AAAAAAAAAAAAAAAAAAAA..........\n+\/\/  Legend:\n+\/\/  A - Test (reserved)\n+\/\/  . - free\n@@ -512,1 +730,1 @@\n-    EXPECT_EQ(100, diff.reserve);\n+    EXPECT_EQ(10, diff.reserve);\n@@ -518,1 +736,7 @@\n-    VMATree::SummaryDiff all_diff = tree.reserve_mapping(0, 100, rd);\n+    VMATree::SummaryDiff all_diff = tree.reserve_mapping(0, 10, rd);\n+\/\/            1         2\n+\/\/  01234567890123456789\n+\/\/  AAAAAAAAAA..........\n+\/\/  Legend:\n+\/\/  A - Test (reserved)\n+\/\/  . - free\n@@ -520,2 +744,9 @@\n-    EXPECT_EQ(diff.reserve, 100);\n-    all_diff = tree.reserve_mapping(100, 100, rd2);\n+    EXPECT_EQ(diff.reserve, 10);\n+    all_diff = tree.reserve_mapping(10, 10, rd2);\n+\/\/            1         2         3\n+\/\/  012345678901234567890123456789\n+\/\/  AAAAAAAAAABBBBBBBBBB..........\n+\/\/  Legend:\n+\/\/  A - Test (reserved)\n+\/\/  B - Native Memory Tracking (reserved)\n+\/\/  . - free\n@@ -525,1 +756,1 @@\n-    EXPECT_EQ(100, diff.reserve);\n+    EXPECT_EQ(10, diff.reserve);\n@@ -532,5 +763,23 @@\n-    tree.commit_mapping(128, 128, rd);\n-    tree.commit_mapping(512, 128, rd);\n-    VMATree::SummaryDiff diff = tree.commit_mapping(0, 1024, rd);\n-    EXPECT_EQ(768, diff.tag[NMTUtil::tag_to_index(mtTest)].commit);\n-    EXPECT_EQ(768, diff.tag[NMTUtil::tag_to_index(mtTest)].reserve);\n+    tree.commit_mapping(16, 16, rd);\n+\/\/            1         2         3         4\n+\/\/  0123456789012345678901234567890123456789\n+\/\/  ................aaaaaaaaaaaaaaaa..........\n+\/\/  Legend:\n+\/\/  a - Test (committed)\n+\/\/  . - free\n+    tree.commit_mapping(32, 32, rd);\n+\/\/            1         2         3         4         5         6         7\n+\/\/  0123456789012345678901234567890123456789012345678901234567890123456789\n+\/\/  ................aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa..........\n+\/\/  Legend:\n+\/\/  a - Test (committed)\n+\/\/  . - free\n+    VMATree::SummaryDiff diff = tree.commit_mapping(0, 64, rd);\n+\/\/            1         2         3         4         5         6         7\n+\/\/  0123456789012345678901234567890123456789012345678901234567890123456789\n+\/\/  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa..........\n+\/\/  Legend:\n+\/\/  a - Test (committed)\n+\/\/  . - free\n+    EXPECT_EQ(16, diff.tag[NMTUtil::tag_to_index(mtTest)].commit);\n+    EXPECT_EQ(16, diff.tag[NMTUtil::tag_to_index(mtTest)].reserve);\n@@ -716,4 +965,15 @@\n-        const NativeCallStack& start_stack = ncss.get(startn->val().out.stack());\n-        const NativeCallStack& end_stack = ncss.get(endn->val().in.stack());\n-        ASSERT_TRUE(starti.stack.equals(start_stack));\n-        ASSERT_TRUE(endi.stack.equals(end_stack));\n+        const NativeCallStack& start_stack = ncss.get(startn->val().out.reserved_stack());\n+        const NativeCallStack& end_stack = ncss.get(endn->val().in.reserved_stack());\n+        \/\/ If start-node of a reserved region is committed, the stack is stored in the second_stack of the node.\n+        if (startn->val().out.has_committed_stack()) {\n+          const NativeCallStack& start_second_stack = ncss.get(startn->val().out.committed_stack());\n+          ASSERT_TRUE(starti.stack.equals(start_stack) || starti.stack.equals(start_second_stack));\n+        } else {\n+          ASSERT_TRUE(starti.stack.equals(start_stack));\n+        }\n+        if (endn->val().in.has_committed_stack()) {\n+          const NativeCallStack& end_second_stack = ncss.get(endn->val().in.committed_stack());\n+          ASSERT_TRUE(endi.stack.equals(end_stack) || endi.stack.equals(end_second_stack));\n+        } else {\n+          ASSERT_TRUE(endi.stack.equals(end_stack));\n+        }\n@@ -728,1 +988,1 @@\n-TEST_VM_F(NMTVMATreeTest, SummaryAccountingWhenUseFlagInplace) {\n+TEST_VM_F(NMTVMATreeTest, SummaryAccountingWhenUseTagInplace) {\n@@ -732,2 +992,19 @@\n-  tree.reserve_mapping(0, 100, rd1);\n-  VMATree::SummaryDiff diff = tree.commit_mapping(0, 50, rd2, true);\n+\/\/            1         2         3         4         5\n+\/\/  012345678901234567890123456789012345678901234567890\n+\/\/  ..................................................\n+\/\/ Legend:\n+\/\/ . - free(released)\n+  tree.reserve_mapping(0, 50, rd1);\n+\/\/            1         2         3         4         5\n+\/\/  012345678901234567890123456789012345678901234567890\n+\/\/  rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr\n+\/\/ Legend:\n+\/\/ r - reserve\n+\n+VMATree::SummaryDiff diff = tree.commit_mapping(0, 25, rd2, true);\n+\/\/            1         2         3         4         5\n+\/\/  012345678901234567890123456789012345678901234567890\n+\/\/  CCCCCCCCCCCCCCCCCCCCCCCCCrrrrrrrrrrrrrrrrrrrrrrrrr\n+\/\/ Legend:\n+\/\/ r - Test, reserve\n+\/\/ C - Test, commit\n@@ -735,2 +1012,9 @@\n-  EXPECT_EQ(50, diff.tag[NMTUtil::tag_to_index(mtTest)].commit);\n-  diff = tree.commit_mapping(60, 10, rd2, true);\n+  EXPECT_EQ(25, diff.tag[NMTUtil::tag_to_index(mtTest)].commit);\n+\n+  diff = tree.commit_mapping(30, 5, rd2, true);\n+\/\/            1         2         3         4         5\n+\/\/  012345678901234567890123456789012345678901234567890\n+\/\/  CCCCCCCCCCCCCCCCCCCCCCCCCrrrrrCCCCCrrrrrrrrrrrrrrr\n+\/\/ Legend:\n+\/\/ r - Test, reserve\n+\/\/ C - Test, commit\n@@ -738,2 +1022,9 @@\n-  EXPECT_EQ(10, diff.tag[NMTUtil::tag_to_index(mtTest)].commit);\n-  diff = tree.uncommit_mapping(0, 50, rd2);\n+  EXPECT_EQ(5, diff.tag[NMTUtil::tag_to_index(mtTest)].commit);\n+\n+  diff = tree.uncommit_mapping(0, 25, rd2);\n+\/\/            1         2         3         4         5\n+\/\/  012345678901234567890123456789012345678901234567890\n+\/\/  rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrCCCCCrrrrrrrrrrrrrrr\n+\/\/ Legend:\n+\/\/ r - Test, reserve\n+\/\/ C - Test, commit\n@@ -741,1 +1032,1941 @@\n-  EXPECT_EQ(-50, diff.tag[NMTUtil::tag_to_index(mtTest)].commit);\n+  EXPECT_EQ(-25, diff.tag[NMTUtil::tag_to_index(mtTest)].commit);\n+}\n+\n+TEST_VM_F(NMTVMATreeTest, SeparateStacksForCommitAndReserve) {\n+  using SIndex = NativeCallStackStorage::StackIndex;\n+  using State = VMATree::StateType;\n+  SIndex si_1 = si[0];\n+  SIndex si_2 = si[1];\n+\n+  const State Rs = State::Reserved;\n+  const State Rl = State::Released;\n+  const State C = State::Committed;\n+  VMATree::RegionData call_stack_1(si_1, mtTest);\n+  VMATree::RegionData call_stack_2(si_2, mtNone);\n+\n+  \/\/ Visualization guide\n+  \/\/ Nodes in the tree are shown in ascending order as:\n+  \/\/ A....B-----C*****D---E... means:\n+  \/\/   [A,B) is released\n+  \/\/   [B,C) is reserved, same as [D,E)\n+  \/\/   [C,D) is committed\n+  \/\/ Each node A in the tree has this metada (MemTag, State, Reserve Call-Stack, Commit Call-Stack);\n+  \/\/  one for the region to its left (called 'in'), and one for the region to its right (called 'out').\n+  \/\/ For every adjacent nodes of [A,B), always A.out == B.in (required).\n+  \/\/ In visualizations, we can avoid repeating metadata of A.out for B.in and write them once.\n+  \/\/ So for example, we write:\n+  \/\/                     A....B-----C*****D-----E...\n+  \/\/ MemTag:               mt1   mt2   mt3  mt4\n+  \/\/ State:                Rl    Rs    C    Rs\n+  \/\/ Reserve Call-Stack:   -     CS2   CS3  CS4\n+  \/\/ Commit Call-Stack:    -     CS2   CS5  CS4\n+  \/\/\n+  \/\/ where Rl = Released, Rs = Reserved and C = Committed.\n+  \/\/ '-' for call-stack means 'empty'\n+\n+\n+  \/\/ How the memory regions are visualized:\n+  \/\/            1         2         3         4         5         6         7       |\n+  \/\/  0123456789012345678901234567890123456789012345678901234567890123456789        |_> memory address\n+  \/\/  aaaaaaBBBBBBBcccccccDDDDDDDeeeeeeeFFFFFFFF...........................         |->some letters showing the state of the memory\n+  \/\/ Legend:\n+  \/\/ . - None (free\/released)\n+  \/\/ r - MemTag (reserved)\n+  \/\/ C - MemTag (committed)\n+  \/\/ MemTag is Test if omitted.\n+\n+  {\/\/ Check committing into a reserved region inherits the call stacks\n+    Tree tree;\n+    tree.reserve_mapping(0, 50, call_stack_1); \/\/ reserve in an empty tree\n+    \/\/ Pre: empty tree.\n+    \/\/ Post:\n+    \/\/            1         2         3         4         5         6         7\n+    \/\/  0123456789012345678901234567890123456789012345678901234567890123456789\n+    \/\/  rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr....................\n+\n+    \/\/ Post: .........0---------50.........\n+    \/\/        mtNone    mtTest       mtNone\n+    \/\/        Rl        Rs           Rl\n+    \/\/        -         si_1         -\n+    \/\/        -         -            -\n+    ExpectedTree<2> et1 = {{     0,     50        },\n+                           {mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    },\n+                           {-1    , -1    , -1    }};\n+    check_tree(tree, et1, __LINE__);\n+\n+    tree.commit_mapping(25, 10, call_stack_2, true); \/\/ commit at the middle of the region\n+    \/\/ Post:\n+    \/\/            1         2         3         4         5         6         7\n+    \/\/  0123456789012345678901234567890123456789012345678901234567890123456789\n+    \/\/  rrrrrrrrrrrrrrrrrrrrrrrrrCCCCCCCCCCrrrrrrrrrrrrrrr....................\n+\n+    \/\/ Pre : .........0------------------------------50.........\n+    \/\/ Post: .........0---------25*********35--------50.........\n+    \/\/        mtNone    mtTest       mtTest   mtTest     mtNone\n+    \/\/        Rl        Rs           C        Rs         Rl\n+    \/\/        -         si_1         si_1     si_1       -\n+    \/\/        -         -            si_2     -          -\n+    ExpectedTree<4> et2 = {{     0,     25,     35,     50        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , C     , Rs    , Rl    },\n+                           {-1    , si_1  , si_1  , si_1  , -1    },\n+                           {-1    , -1    , si_2  , -1    , -1    }};\n+    check_tree(tree, et2, __LINE__);\n+\n+    tree.commit_mapping(0, 20, call_stack_2, true); \/\/ commit at the beginning of the region\n+    \/\/ Post:\n+    \/\/            1         2         3         4         5         6         7\n+    \/\/  0123456789012345678901234567890123456789012345678901234567890123456789\n+    \/\/  CCCCCCCCCCCCCCCCCCCCrrrrrCCCCCCCCCCrrrrrrrrrrrrrrr....................\n+\n+    \/\/ Pre:  .........0-------------------25********35--------50.........\n+    \/\/ Post: .........0********20---------25********35--------50.........\n+    \/\/        mtNone    mtTest    mtTest      mtTest   mtTest     mtNone\n+    \/\/        Rl        C         Rs          C        Rs         Rl\n+    \/\/        -         si_1      si_1        si_1     si_1       -\n+    \/\/        -         si_2      -           si_2     -          -\n+    ExpectedTree<5> et3 = {{     0,     20,     25,     35,    50         },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , C     , Rs    , C     , Rs    , Rl    },\n+                           {-1    , si_1  , si_1  , si_1  , si_1  , -1    },\n+                           {-1    , si_2  , -1    , si_2  , -1    , -1    }};\n+    check_tree(tree, et3, __LINE__);\n+\n+    tree.commit_mapping(40, 10, call_stack_2, true); \/\/ commit at the end of the region\n+    \/\/ Post:\n+    \/\/            1         2         3         4         5         6         7\n+    \/\/  0123456789012345678901234567890123456789012345678901234567890123456789\n+    \/\/  CCCCCCCCCCCCCCCCCCCCrrrrrCCCCCCCCCCrrrrrCCCCCCCCCC....................\n+\n+    \/\/ Pre:  .........0********20---------25********35------------------50.........\n+    \/\/ Post: .........0********20---------25********35--------40********50.........\n+    \/\/        mtNone    mtTest    mtTest      mtTest   mtTest     mtTest    mtNone\n+    \/\/        Rl        C         Rs          C        Rs         C         Rl\n+    \/\/        -         si_1      si_1        si_1     si_1       si_1      -\n+    \/\/        -         si_2      -           si_2     -          si_2      -\n+    ExpectedTree<6> et4 = {{     0,     20,     25,     35,     40,     50        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , C     , Rs    , C     , Rs    , C     , Rl    },\n+                           {-1    , si_1  , si_1  , si_1  , si_1  , si_1  , -1    },\n+                           {-1    , si_2  , -1    , si_2  , -1    , si_2  , -1    }};\n+    check_tree(tree, et4, __LINE__);\n+  }\n+  {\/\/ committing overlapped regions does not destroy the old call-stacks\n+    Tree tree;\n+    tree.reserve_mapping(0, 50, call_stack_1); \/\/ reserving in an empty tree\n+    \/\/ Pre: empty tree.\n+    \/\/            1         2         3         4         5         6         7\n+    \/\/  0123456789012345678901234567890123456789012345678901234567890123456789\n+    \/\/  rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr....................\n+\n+    \/\/ Post: .........0---------50..........\n+    \/\/        mtNone    mtTest       mtNone\n+    \/\/        Rl        Rs           Rl\n+    \/\/        -         si_1         -\n+    \/\/        -         -            -\n+    ExpectedTree<2> et1 = {{      0  , 50         },\n+                           {mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    },\n+                           {-1    , -1    , -1    }};\n+    check_tree(tree, et1, __LINE__);\n+\n+    tree.commit_mapping(10, 10, call_stack_2, true);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  aaaaaaaaaaCCCCCCCCCCaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.\n+    \/\/  Legend:\n+    \/\/  a - Test (reserved)\n+    \/\/  C - Test (committed)\n+    \/\/  . - free\n+    \/\/ Pre:  .........0----------------------------50.........\n+    \/\/ Post: .........0---------10********20-------50.........\n+    \/\/        mtNone    mtTest     mtTest    mtTest    mtNone\n+    \/\/        Rl        Rs           C       Rs        Rl\n+    \/\/        -         si_1         si_1    si_1      -\n+    \/\/        -         -            si_2     -        -\n+    ExpectedTree<4> et2 = {{     0,     10,     20,    50         },\n+                           {mtNone, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , C     , Rs    , Rl    },\n+                           {-1    , si_1  , si_1  , si_1  , -1    },\n+                           {-1    , -1    , si_2  , -1    , -1    }};\n+    check_tree(tree, et2, __LINE__);\n+\n+    SIndex si_3 = si[2];\n+    VMATree::RegionData call_stack_3(si_3, mtTest);\n+    \/\/ commit with overlap at the region's start\n+    tree.commit_mapping(5, 10, call_stack_3);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  aaaaaaaaaaCCCCCCCCCCaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.\n+    \/\/  Legend:\n+    \/\/  a - Test (reserved)\n+    \/\/  C - Test (committed)\n+    \/\/  . - free\n+    \/\/ Pre:  .........0-------------10**************20-------50.........\n+    \/\/ Post: .........0----------5********15********20-------50.........\n+    \/\/        mtNone    mtTest     mtTest    mtTest    mtTest    mtNone\n+    \/\/        Rl        Rs           C       C         Rs        Rl\n+    \/\/        -         si_1         si_1    si_1      si_1      -\n+    \/\/        -         -            si_3    si_2        -       -\n+    ExpectedTree<5> et3 = {{     0,      5,     15,     20,     50        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , C     , C     , Rs    , Rl    },\n+                           {-1    , si_1  , si_1  , si_1  , si_1  , -1    },\n+                           {-1    , -1    , si_3  , si_2  , -1    , -1    }};\n+    check_tree(tree, et3, __LINE__);\n+\n+    SIndex si_4 = si[3];\n+    VMATree::RegionData call_stack_4(si_4, mtTest);\n+    \/\/ commit with overlap at the region's end\n+    tree.commit_mapping(15, 10, call_stack_4);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  aaaaaaaaaaCCCCCCCCCCaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.\n+    \/\/  Legend:\n+    \/\/  a - Test (reserved)\n+    \/\/  C - Test (committed)\n+    \/\/  . - free\n+    \/\/ Pre:  .........0----------5********15**20-------------50.........\n+    \/\/ Post: .........0----------5********15********25-------50.........\n+    \/\/        mtNone    mtTest     mtTest    mtTest    mtTest    mtNone\n+    \/\/        Rl        Rs           C       C         Rs        Rl\n+    \/\/        -         si_1         si_1    si_1      si_1      -\n+    \/\/        -         -            si_3    si_4        -       -\n+    ExpectedTree<5> et4 = {{     0,      5,     15,     25,     50        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , C     , C     , Rs    , Rl    },\n+                           {-1    , si_1  , si_1  , si_1  , si_1  , -1    },\n+                           {-1    , -1    , si_3  , si_4  , -1    , -1    }};\n+    check_tree(tree, et4, __LINE__);\n+  }\n+  {\/\/ uncommit should not store any call-stack\n+    Tree tree;\n+    tree.reserve_mapping(0, 50, call_stack_1);\n+\n+    tree.commit_mapping(10, 10, call_stack_2, true);\n+\n+    tree.commit_mapping(0, 5, call_stack_2, true);\n+\n+    tree.uncommit_mapping(0, 3, call_stack_2);\n+    \/\/ Pre:  .........0*****************5--------10********20-------50.........\n+    \/\/        mtNone         mtTest        mtTest    mtTest    mtTest    mtNone\n+    \/\/        Rl             C             Rs        C         Rs        Rl\n+    \/\/        -              si_1          si_1      si_1      si_1      -\n+    \/\/        -              si_2          -         si_2      -         -\n+    \/\/ Post: .........0--------3********5--------10********20-------50.........\n+    \/\/        mtNone    mtTest   mtTest    mtTest    mtTest    mtTest    mtNone\n+    \/\/        Rl        Rs       C         Rs        C         Rs        Rl\n+    \/\/        -         si_1     si_1      si_1      si_1      si_1      -\n+    \/\/        -         -        si_2      -         si_2      -         -\n+    ExpectedTree<6> et1 = {{     0,     3,       5,     10,     20,     50        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , C     , Rs    , C     , Rs    , Rl    },\n+                           {-1    , si_1  , si_1  , si_1  , si_1  , si_1  , -1    },\n+                           {-1    , -1    , si_2  , -1    , si_2  , -1    , -1    }};\n+    check_tree(tree, et1, __LINE__);\n+\n+    tree.uncommit_mapping(5, 10, call_stack_2);\n+    \/\/ Pre:  .........0--------3********5----10*************20-------50..........\n+    \/\/ Post: .........0--------3********5---------15********20-------50..........\n+    \/\/        mtNone    mtTest   mtTest    mtTest    mtTest    mtTest    mtNone\n+    \/\/        Rl        Rs       C         Rs        C         Rs        Rl\n+    \/\/        -         si_1     si_1      si_1      si_1      si_1      -\n+    \/\/        -         -        si_2      -         si_2      -         -\n+    ExpectedTree<6> et2 = {{     0,      3,      5,     15,     20,     50        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , C     , Rs    , C     , Rs    , Rl    },\n+                           {-1    , si_1  , si_1  , si_1  , si_1  , si_1  , -1    },\n+                           {-1    , -1    , si_2  , -1    , si_2  , -1    , -1    }};\n+    check_tree(tree, et2, __LINE__);\n+  }\n+  {\/\/ reserve after reserve, but only different call-stacks\n+    SIndex si_4 = si[3];\n+    VMATree::RegionData call_stack_4(si_4, mtTest);\n+\n+    Tree tree;\n+    tree.reserve_mapping(0, 50, call_stack_1);\n+    tree.reserve_mapping(10, 10, call_stack_4);\n+    \/\/ Pre:  .........0----------------------------50.........\n+    \/\/ Post: .........0--------10--------20--------50.........\n+    \/\/        mtNone   mtTest    mtTest    mtTest    mtNone\n+    \/\/        Rl       Rs        Rs         Rs       Rl\n+    \/\/        -        si_1      si_4      si_1      -\n+    \/\/        -        -         -         -         -\n+    ExpectedTree<4> et1 = {{     0,     10,     20,     50       },\n+                           {mtNone, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , Rs    , Rs    , Rl    },\n+                           {-1    , si_1  , si_4  , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    }};\n+    check_tree(tree, et1, __LINE__);\n+  }\n+  {\/\/ commit without reserve\n+    Tree tree;\n+    tree.commit_mapping(0, 50, call_stack_1);\n+    ExpectedTree<2> et = {{     0,      50       },\n+                          {mtNone, mtTest, mtNone},\n+                          {Rl    , C     , Rl    },\n+                          {-1    , si_1  , -1    },\n+                          {-1    , si_1  , -1    }};\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\/\/ reserve after commit\n+    Tree tree;\n+    tree.commit_mapping(0, 50, call_stack_2);\n+    tree.reserve_mapping(0, 50, call_stack_1);\n+    ExpectedTree<2> et = {{     0,      50       },\n+                          {mtNone, mtTest, mtNone},\n+                          {Rl    , Rs    , Rl    },\n+                          {-1    , si_1  , -1    },\n+                          {-1    , -1    , -1    }};\n+    check_tree(tree, et, __LINE__);\n+  }\n+}\n+\n+\/\/ Nodes in the tree :   R.....X......W......U....Z\n+\/\/ New request (A!=X):           A-------B\n+\/\/ New request (A==X):         A-------B\n+\/\/ Operations: {Reserve, Commit, Uncommit, Release}\n+\/\/ State of [X, W) region: {released, reserved, committed}\n+\/\/ total number of cases:\n+\/\/  no.of(Operations) x no.of(States) x no.of{A == X | A != X} =\n+\/\/        4           x     3         x        2               = 24\n+\/\/ AllCases_A_eq_X contains 12 cases for A == X\n+\/\/ AllCases_A_neq_X contains 12 cases for A != X\n+TEST_VM_F(NMTVMATreeTest, AllCases_A_eq_X) {\n+  using SIndex = NativeCallStackStorage::StackIndex;\n+  using State = VMATree::StateType;\n+  SIndex si_1 = si[0];\n+  SIndex si_2 = si[1];\n+  SIndex si_3 = si[2];\n+\n+  const State Rs = State::Reserved;\n+  const State Rl = State::Released;\n+  const State C = State::Committed;\n+  VMATree::RegionData call_stack_1(si_1, mtTest);\n+  VMATree::RegionData call_stack_1_mtNone(si_1, mtNone);\n+  VMATree::RegionData call_stack_2(si_2, mtTest);\n+  VMATree::RegionData call_stack_2_mtNone(si_2, mtNone);\n+  VMATree::RegionData call_stack_3(si_3, mtTest);\n+\n+  { \/\/ Do 'Reserve' for a released region\n+    Tree tree;\n+    \/\/ Prepare pre-cond\n+    tree.reserve_mapping(0, 40, call_stack_1);\n+    tree.commit_mapping(10, 10, call_stack_1_mtNone, true);\n+    tree.commit_mapping(30, 10, call_stack_1_mtNone, true);\n+    tree.release_mapping(10, 10);\n+    \/\/ New request\n+    tree.reserve_mapping(10, 15, call_stack_2);\n+    \/\/ Pre:  ........0--------10................20------------------------30********40........\n+    \/\/ Request:               10--------------------------------25\n+    \/\/ Post: ........0--------10--------------------------------25--------30********40........\n+    \/\/        mtNone   mtTest                 mtTest                 mtTest     mtTest     mtNone\n+    \/\/        Rl       Rs                     Rs                     Rs         C          Rl\n+    \/\/        -        si_1                   si_2                   si_1       si_1       -\n+    \/\/        -        -                      -                      -          si_1       -\n+    ExpectedTree<5> et = {{     0,     10,     25,     30,     40         },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtNone },\n+                          {Rl    , Rs    , Rs    , Rs    , C     , Rl     },\n+                          {-1    , si_1  , si_2  , si_1  , si_1  , -1     },\n+                          {-1    , -1    , -1    , -1    , si_1  , -1     }};\n+    check_tree(tree, et, __LINE__);\n+  }\n+  { \/\/ Do 'Commit' for a released region\n+    Tree tree;\n+    \/\/ Prepare pre-cond\n+    tree.reserve_mapping(0, 40, call_stack_1);\n+    tree.commit_mapping(10, 10, call_stack_1_mtNone, true);\n+    tree.commit_mapping(30, 10, call_stack_1_mtNone, true);\n+    tree.release_mapping(10, 10);\n+    \/\/ New request\n+    tree.commit_mapping(10, 15, call_stack_2);\n+    \/\/ Pre:  ........0--------10................20------------------------30********40........\n+    \/\/ Request:               10********************************25\n+    \/\/ Post: ........0--------10********************************25--------30********40........\n+    \/\/        mtNone   mtTest                 mtTest                 mtTest     mtTest     mtNone\n+    \/\/        Rl       Rs                     C                      Rs         C          Rl\n+    \/\/        -        si_1                   si_2                   si_1       si_1       -\n+    \/\/        -        -                      si_2                   -          si_1       -\n+    ExpectedTree<5> et = {{     0,     10,     25,     30,     40         },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtNone },\n+                          {Rl    , Rs    , C     , Rs    , C     , Rl     },\n+                          {-1    , si_1  , si_2  , si_1  , si_1  , -1     },\n+                          {-1    , -1    , si_2  , -1    , si_1  , -1     }};\n+    check_tree(tree, et, __LINE__);\n+  }\n+  { \/\/ Do 'Uncommit' for a released region\n+    Tree tree;\n+    \/\/ Prepare pre-cond\n+    tree.reserve_mapping(0, 40, call_stack_1);\n+    tree.commit_mapping(10, 10, call_stack_1_mtNone, true);\n+    tree.commit_mapping(30, 10, call_stack_1_mtNone, true);\n+    tree.release_mapping(10, 10);\n+    \/\/ New request\n+    tree.uncommit_mapping(10, 15, call_stack_2);\n+    \/\/\n+    \/\/ Pre:  ........0--------10................20------------------------30********40........\n+    \/\/ Request:               10--------------------------------25\n+    \/\/ Post: ........0--------10................20------------------------30********40........\n+    \/\/        mtNone   mtTest         mtNone               mtTest               mtTest     mtNone\n+    \/\/        Rl       Rs             Rl                   Rs                   C          Rl\n+    \/\/        -        si_1           -                    si_1                 si_1       -\n+    \/\/        -        -              -                    -                    si_1       -\n+    ExpectedTree<5> et = {{     0,     10,     20,     30,     40         },\n+                          {mtNone, mtTest, mtNone, mtTest, mtTest, mtNone },\n+                          {Rl    , Rs    , Rl    , Rs    , C     , Rl     },\n+                          {-1    , si_1  , -1    , si_1  , si_1  , -1     },\n+                          {-1    , -1    , -1    , -1    , si_1  , -1     }};\n+    check_tree(tree, et, __LINE__);\n+  }\n+  { \/\/ Do 'Release' for a released region\n+    Tree tree;\n+    \/\/ Prepare pre-cond\n+    tree.reserve_mapping(0, 40, call_stack_1);\n+    tree.commit_mapping(10, 10, call_stack_1_mtNone, true);\n+    tree.commit_mapping(30, 10, call_stack_1_mtNone, true);\n+    tree.release_mapping(10, 10);\n+    \/\/ New request\n+    tree.release_mapping(10, 15);\n+    \/\/ Pre:  ........0--------10................20------------------------30********40........\n+    \/\/ Request:               10................................25\n+    \/\/ Post: ........0--------10................................25--------30********40........\n+    \/\/        mtNone   mtTest                 mtNone                 mtTest     mtTest     mtNone\n+    \/\/        Rl       Rs                     Rl                     Rs         C          Rl\n+    \/\/        -        si_1                   -                      si_1       si_1       -\n+    \/\/        -        -                      -                      -          si_1       -\n+    ExpectedTree<5> et = {{     0,     10,     25,     30,     40         },\n+                          {mtNone, mtTest, mtNone, mtTest, mtTest, mtNone },\n+                          {Rl    , Rs    , Rl    , Rs    , C     , Rl     },\n+                          {-1    , si_1  , -1    , si_1  , si_1  , -1     },\n+                          {-1    , -1    , -1    , -1    , si_1  , -1     }};\n+    check_tree(tree, et, __LINE__);\n+  }\n+  { \/\/ Do 'Reserve' for a reserved region\n+    Tree tree;\n+    \/\/ Prepare pre-cond\n+    tree.reserve_mapping(0, 40, call_stack_1);\n+    tree.commit_mapping(10, 10, call_stack_1_mtNone, true);\n+    tree.commit_mapping(30, 10, call_stack_1_mtNone, true);\n+    tree.reserve_mapping(10, 10, call_stack_1);\n+    \/\/ New request\n+    tree.reserve_mapping(10, 15, call_stack_2);\n+    \/\/ Pre:  ........0--------10----------------20------------------------30********40........\n+    \/\/ Request:               10--------------------------------25\n+    \/\/ Post: ........0--------10--------------------------------25--------30********40........\n+    \/\/        mtNone   mtTest                 mtTest                 mtTest     mtTest     mtNone\n+    \/\/        Rl       Rs                     Rs                     Rs         C          Rl\n+    \/\/        -        si_1                   si_2                   si_1       si_1       -\n+    \/\/        -        -                      -                      -          si_1       -\n+    ExpectedTree<5> et = {{     0,     10,     25,     30,     40         },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtNone },\n+                          {Rl    , Rs    , Rs    , Rs    , C     , Rl     },\n+                          {-1    , si_1  , si_2  , si_1  , si_1  , -1     },\n+                          {-1    , -1    , -1    , -1    , si_1  , -1     }};\n+    check_tree(tree, et, __LINE__);\n+  }\n+  { \/\/ Do 'Commit' for a reserved region\n+    Tree tree;\n+    \/\/ Prepare pre-cond\n+    tree.reserve_mapping(0, 40, call_stack_1);\n+    tree.commit_mapping(10, 10, call_stack_1_mtNone, true);\n+    tree.commit_mapping(30, 10, call_stack_1_mtNone, true);\n+    tree.reserve_mapping(10, 10, call_stack_1);\n+    \/\/ New request\n+    tree.commit_mapping(10, 15, call_stack_2);\n+    \/\/ Pre:  ........0--------10----------------20------------------------30********40........\n+    \/\/ Request:               10********************************25\n+    \/\/ Post: ........0--------10********************************25--------30********40........\n+    \/\/        mtNone   mtTest                 mtTest                 mtTest     mtTest     mtNone\n+    \/\/        Rl       Rs                     C                      Rs         C          Rl\n+    \/\/        -        si_1                   si_2                   si_1       si_1       -\n+    \/\/        -        -                      si_2                   -          si_1       -\n+    ExpectedTree<5> et = {{     0,     10,     25,     30,     40         },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtNone },\n+                          {Rl    , Rs    , C     , Rs    , C     , Rl     },\n+                          {-1    , si_1  , si_1  , si_1  , si_1  , -1     },\n+                          {-1    , -1    , si_2  , -1    , si_1  , -1     }};\n+    check_tree(tree, et, __LINE__);\n+  }\n+  { \/\/ Do 'Uncommit' over two different reserved regions\n+    Tree tree;\n+    \/\/ Prepare pre-cond\n+    tree.reserve_mapping(0, 40, call_stack_1);\n+    tree.commit_mapping(10, 10, call_stack_1_mtNone, true);\n+    tree.commit_mapping(30, 10, call_stack_1_mtNone, true);\n+    tree.reserve_mapping(10, 10, call_stack_2);\n+    \/\/ New request\n+    tree.uncommit_mapping(10, 15, call_stack_1_mtNone);\n+    \/\/ Pre:  ........0--------10----------------20------------------------30********40........\n+    \/\/ Request:               10--------------------------------25\n+    \/\/ Post: ........0--------10----------------20------------------------30********40........\n+    \/\/        mtNone   mtTest        mtTest             mtTest                  mtTest     mtNone\n+    \/\/        Rl       Rs            Rs                 Rs                      C          Rl\n+    \/\/        -        si_1          si_2               si_1                    si_1       -\n+    \/\/        -        -             -                  -                       si_1       -\n+    ExpectedTree<5> et = {{     0,     10,     20,     30,     40         },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtNone },\n+                          {Rl    , Rs    , Rs    , Rs    , C     , Rl     },\n+                          {-1    , si_1  , si_2  , si_1  , si_1  , -1     },\n+                          {-1    , -1    , -1    , -1    , si_1  , -1     }};\n+    check_tree(tree, et, __LINE__);\n+  }\n+  { \/\/ Do 'Release' for a reserved region\n+    Tree tree;\n+    \/\/ Prepare pre-cond\n+    tree.reserve_mapping(0, 40, call_stack_1);\n+    tree.commit_mapping(10, 10, call_stack_1_mtNone, true);\n+    tree.commit_mapping(30, 10, call_stack_1_mtNone, true);\n+    tree.reserve_mapping(10, 10, call_stack_1);\n+    \/\/ New request\n+    tree.release_mapping(10, 15);\n+    \/\/ Pre:  ........0--------10----------------20------------------------30********40........\n+    \/\/ Request:               10................................25\n+    \/\/ Post: ........0--------10................................25--------30********40........\n+    \/\/        mtNone   mtTest                 mtNone                 mtTest     mtTest     mtNone\n+    \/\/        Rl       Rs                     Rl                     Rs         C          Rl\n+    \/\/        -        si_1                   -                      si_1       si_1       -\n+    \/\/        -        -                      -                      -          si_1       -\n+    ExpectedTree<5> et = {{     0,     10,     25,     30,     40         },\n+                          {mtNone, mtTest, mtNone, mtTest, mtTest, mtNone },\n+                          {Rl    , Rs    , Rl    , Rs    , C     , Rl     },\n+                          {-1    , si_1  , -1    , si_1  , si_1  , -1     },\n+                          {-1    , -1    , -1    , -1    , si_1  , -1     }};\n+    check_tree(tree, et, __LINE__);\n+  }\n+  { \/\/ Do 'Reserve' for a committed region\n+    Tree tree;\n+    \/\/ Prepare pre-cond\n+    tree.reserve_mapping(0, 40, call_stack_1);\n+    tree.commit_mapping(10, 10, call_stack_1_mtNone, true);\n+    tree.commit_mapping(30, 10, call_stack_1_mtNone, true);\n+    \/\/ New request\n+    tree.reserve_mapping(10, 15, call_stack_2);\n+    \/\/ Pre:  ........0--------10****************20------------------------30********40........\n+    \/\/ Request:               10--------------------------------25\n+    \/\/ Post: ........0--------10--------------------------------25--------30********40........\n+    \/\/        mtNone   mtTest                 mtTest                 mtTest     mtTest     mtNone\n+    \/\/        Rl       Rs                     Rs                     Rs         C          Rl\n+    \/\/        -        si_1                   si_2                   si_1       si_1       -\n+    \/\/        -        -                      -                      -          si_1       -\n+    ExpectedTree<5> et = {{     0,     10,     25,     30,     40         },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtNone },\n+                          {Rl    , Rs    , Rs    , Rs    , C     , Rl     },\n+                          {-1    , si_1  , si_2  , si_1  , si_1  , -1     },\n+                          {-1    , -1    , -1    , -1    , si_1  , -1     }};\n+    check_tree(tree, et, __LINE__);\n+  }\n+  { \/\/ Do 'Commit' for a committed region\n+    Tree tree;\n+    \/\/ Prepare pre-cond\n+    tree.reserve_mapping(0, 40, call_stack_1);\n+    tree.commit_mapping(10, 10, call_stack_1_mtNone, true);\n+    tree.commit_mapping(30, 10, call_stack_1_mtNone, true);\n+    \/\/ New request\n+    tree.commit_mapping(10, 15, call_stack_2);\n+    \/\/ Pre:  ........0--------10****************20------------------------30********40........\n+    \/\/ Request:               10********************************25\n+    \/\/ Post: ........0--------10********************************25--------30********40........\n+    \/\/        mtNone   mtTest                 mtTest                 mtTest     mtTest     mtNone\n+    \/\/        Rl       Rs                     C                      Rs         C          Rl\n+    \/\/        -        si_1                   si_1                   si_1       si_1       -\n+    \/\/        -        -                      si_2                   -          si_1       -\n+    ExpectedTree<5> et = {{     0,     10,     25,     30,     40         },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtNone },\n+                          {Rl    , Rs    , C     , Rs    , C     , Rl     },\n+                          {-1    , si_1  , si_1  , si_1  , si_1  , -1     },\n+                          {-1    , -1    , si_2  , -1    , si_1  , -1     }};\n+    check_tree(tree, et, __LINE__);\n+  }\n+  { \/\/ Do 'Uncommit' for a committed region\n+    Tree tree;\n+    \/\/ Prepare pre-cond\n+    tree.reserve_mapping(0, 40, call_stack_1);\n+    tree.commit_mapping(10, 10, call_stack_1_mtNone, true);\n+    tree.commit_mapping(30, 10, call_stack_1_mtNone, true);\n+    \/\/ New request\n+    tree.uncommit_mapping(10, 15, call_stack_1_mtNone);\n+    \/\/ Pre:  ........0--------10****************20------------------30********40........\n+    \/\/ Request:               10--------------------------25\n+    \/\/ Post: ........0----------------------------------------------30********40........\n+    \/\/        mtNone                    mtTest                         mtTest     mtNone\n+    \/\/        Rl                        Rs                             C          Rl\n+    \/\/        -                         si_1                           si_1       -\n+    \/\/        -                         -                              si_1       -\n+    ExpectedTree<3> et = {{     0,     30,     40         },\n+                          {mtNone, mtTest, mtTest, mtNone },\n+                          {Rl    , Rs    , C     , Rl     },\n+                          {-1    , si_1  , si_1  , -1     },\n+                          {-1    , -1    , si_1  , -1     }};\n+    check_tree(tree, et, __LINE__);\n+  }\n+  { \/\/ Do 'Release' for a committed region\n+    Tree tree;\n+    \/\/ Prepare pre-cond\n+    tree.reserve_mapping(0, 40, call_stack_1);\n+    tree.commit_mapping(10, 10, call_stack_1_mtNone, true);\n+    tree.commit_mapping(30, 10, call_stack_1_mtNone, true);\n+    \/\/ New request\n+    tree.release_mapping(10, 15);\n+    \/\/ Pre:  ........0--------10****************20------------------------30********40........\n+    \/\/ Request:               10................................25\n+    \/\/ Post: ........0--------10................................25--------30********40........\n+    \/\/        mtNone   mtTest               mtNone                 mtTest    mtTest     mtNone\n+    \/\/        Rl       Rs                   Rl                     Rs        C          Rl\n+    \/\/        -        si_1                 -                      si_1      si_1       -\n+    \/\/        -        -                    -                      -         si_1       -\n+    ExpectedTree<5> et = {{     0,     10,     25,     30,     40          },\n+                          {mtNone, mtTest, mtNone, mtTest, mtTest, mtNone  },\n+                          {Rl    , Rs    , Rl    , Rs    , C     , Rl      },\n+                          {-1    , si_1  , -1    , si_1  , si_1  , -1      },\n+                          {-1    , -1    , -1    , -1    , si_1  , -1      }};\n+    check_tree(tree, et, __LINE__);\n+  }\n+}\n+\n+TEST_VM_F(NMTVMATreeTest, AllCases_A_neq_X) {\n+  using SIndex = NativeCallStackStorage::StackIndex;\n+  using State = VMATree::StateType;\n+  SIndex si_1 = si[0];\n+  SIndex si_2 = si[1];\n+  SIndex si_3 = si[2];\n+\n+  const State Rs = State::Reserved;\n+  const State Rl = State::Released;\n+  const State C = State::Committed;\n+  VMATree::RegionData call_stack_1(si_1, mtTest);\n+  VMATree::RegionData call_stack_1_mtNone(si_1, mtNone);\n+  VMATree::RegionData call_stack_2(si_2, mtTest);\n+  VMATree::RegionData call_stack_3(si_3, mtTest);\n+\n+  { \/\/ Do 'Reserve' for a released region\n+    Tree tree;\n+    \/\/ Prepare pre-cond\n+    tree.reserve_mapping(0, 40, call_stack_1);\n+    tree.commit_mapping(10, 10, call_stack_1_mtNone, true);\n+    tree.commit_mapping(30, 10, call_stack_1_mtNone, true);\n+    tree.release_mapping(10, 10);\n+    \/\/ New request\n+    tree.reserve_mapping(15, 10, call_stack_2);\n+    \/\/ Pre:  ........0--------10................20----------------------30*********40........\n+    \/\/ Request:                         15----------------25\n+    \/\/ Post: ........0--------10........15----------------25------------30*********40........\n+    \/\/        mtNone   mtTest    mtNone        mtTest          mtTest      mtTest     mtNone\n+    \/\/        Rl       Rs        Rl            Rs              Rs          C          Rl\n+    \/\/        -        si_1      -             si_2            si_1        si_1       -\n+    \/\/        -        -         -              -               -          si_1       -\n+    ExpectedTree<6> et = {{     0,     10,     15,     25,     30,    40          },\n+                          {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtNone },\n+                          {Rl    , Rs    , Rl    , Rs    , Rs    , C     , Rl     },\n+                          {-1    , si_1  , -1    , si_2  , si_1  , si_1  , -1     },\n+                          {-1    , -1    , -1    , -1    , -1    , si_1  , -1     }};\n+    check_tree(tree, et, __LINE__);\n+  }\n+  { \/\/ Do 'Commit' for a released region\n+    Tree tree;\n+    \/\/ Prepare pre-cond\n+    tree.reserve_mapping(0, 40, call_stack_1);\n+    tree.commit_mapping(10, 10, call_stack_1_mtNone, true);\n+    tree.commit_mapping(30, 10, call_stack_1_mtNone, true);\n+    tree.release_mapping(10, 10);\n+    \/\/ New request\n+    tree.commit_mapping(15, 10, call_stack_2);\n+    \/\/ Pre:  ........0--------10................20----------------------30********40........\n+    \/\/ Request:                         15****************25\n+    \/\/ Post: ........0--------10........15****************25------------30********40........\n+    \/\/        mtNone   mtTest    mtNone        mtTest         mtTest       mtTest     mtNone\n+    \/\/        Rl       Rs        Rl            C              Rs           C          Rl\n+    \/\/        -        si_1      -1            si_2           si_1         si_1       -\n+    \/\/        -        -         -1            si_2           -            si_1       -\n+    ExpectedTree<6> et = {{     0,     10,     15,     25,     30,    40          },\n+                          {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtNone },\n+                          {Rl    , Rs    , Rl    , C     , Rs    , C     , Rl     },\n+                          {-1    , si_1  , -1    , si_2  , si_1  , si_1  , -1     },\n+                          {-1    , -1    , -1    , si_2  , -1    , si_1  , -1     }};\n+    check_tree(tree, et, __LINE__);\n+  }\n+  { \/\/ Do 'Uncommit' for a released region\n+    Tree tree;\n+    \/\/ Prepare pre-cond\n+    tree.reserve_mapping(0, 40, call_stack_1);\n+    tree.commit_mapping(10, 10, call_stack_1_mtNone, true);\n+    tree.commit_mapping(30, 10, call_stack_1_mtNone, true);\n+    tree.release_mapping(10, 10);\n+    \/\/ New request\n+    \/\/ 8354115\n+    tree.uncommit_mapping(15, 10, call_stack_2);\n+    \/\/ Pre:  ........0--------10................20-----------------------30********40........\n+    \/\/ Request:                         15----------------25\n+    \/\/ Post: ........0--------10................20-----------------------30********40........\n+    \/\/        mtNone   mtTest     mtNone                 mtTest             mtTest     mtNone\n+    \/\/        Rl       Rs         Rl                     Rs                 C          Rl\n+    \/\/        -        si_1       -                      si_1               si_1       -\n+    \/\/        -        -          -                      -                  si_1       -\n+    ExpectedTree<5> et = {{     0,     10,     20,     30,    40          },\n+                          {mtNone, mtTest, mtNone, mtTest, mtTest, mtNone },\n+                          {Rl    , Rs    , Rl    , Rs    , C     , Rl     },\n+                          {-1    , si_1  , -1    , si_1  , si_1  , -1     },\n+                          {-1    , -1    , -1    , -1    , si_1  , -1     }};\n+    check_tree(tree, et, __LINE__);\n+  }\n+  { \/\/ Do 'Release' for a released region\n+    Tree tree;\n+    \/\/ Prepare pre-cond\n+    tree.reserve_mapping(0, 40, call_stack_1);\n+    tree.commit_mapping(10, 10, call_stack_1_mtNone, true);\n+    tree.commit_mapping(30, 10, call_stack_1_mtNone, true);\n+    tree.release_mapping(10, 10);\n+    \/\/ New request\n+    tree.release_mapping(15, 10);\n+    \/\/ Pre:  ........0--------10................20--------------------30********40........\n+    \/\/ Request:                           15............25\n+    \/\/ Post: ........0--------10........................25------------30********40........\n+    \/\/        mtNone   mtTest          mtNone               mtTest       mtTest     mtNone\n+    \/\/        Rl       Rs              Rl                   Rs           C          Rl\n+    \/\/        -        si_1            -                    si_1         si_1       -\n+    \/\/        -        -               -                    -            si_1       -\n+    ExpectedTree<5> et = {{     0,     10,     25,     30,    40          },\n+                          {mtNone, mtTest,  mtNone, mtTest, mtTest, mtNone},\n+                          {Rl    , Rs    ,  Rl   , Rs    , C     , Rl     },\n+                          {-1    , si_1  ,  -1   , si_1  , si_1  , -1     },\n+                          {-1    , -1    ,  -1   , -1    , si_1  , -1     }};\n+    check_tree(tree, et, __LINE__);\n+  }\n+  { \/\/ Do 'Reserve' for a reserved region\n+    Tree tree;\n+    \/\/ Prepare pre-cond\n+    tree.reserve_mapping(0, 40, call_stack_1);\n+    tree.commit_mapping(10, 10, call_stack_1_mtNone, true);\n+    tree.commit_mapping(30, 10, call_stack_1_mtNone, true);\n+    tree.reserve_mapping(10, 10, call_stack_3);\n+    \/\/ New request\n+    tree.reserve_mapping(15, 10, call_stack_2);\n+    \/\/ Pre:  ........0--------10----------------20----------------------30********40........\n+    \/\/ Request:                         15----------------25\n+    \/\/ Post: ........0--------10--------15----------------25------------30********40........\n+    \/\/        mtNone   mtTest    mtTest     mtTest           mtTest       mtTest     mtNone\n+    \/\/        Rl       Rs        Rs         Rs               Rs           C          Rl\n+    \/\/        -        si_1      si_3       si_2             si_1         si_1       -\n+    \/\/        -        -         -          -                -            si_1       -\n+    ExpectedTree<6> et = {{     0,     10,     15,     25,     30,    40          },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone },\n+                          {Rl    , Rs    , Rs    , Rs    , Rs    , C     , Rl     },\n+                          {-1    , si_1  , si_3  , si_2  , si_1  , si_1  , -1     },\n+                          {-1    , -1    , -1    , -1    , -1    , si_1  , -1     }};\n+    check_tree(tree, et, __LINE__);\n+  }\n+  { \/\/ Do 'Commit' over two different reserved regions\n+    Tree tree;\n+    \/\/ Prepare pre-cond\n+    tree.reserve_mapping(0, 40, call_stack_1);\n+    tree.commit_mapping(10, 10, call_stack_1_mtNone, true);\n+    tree.commit_mapping(30, 10, call_stack_1_mtNone, true);\n+    tree.reserve_mapping(10, 10, call_stack_3);\n+    \/\/ New request\n+    tree.commit_mapping(15, 10, call_stack_2);\n+    \/\/ Pre:  ........0--------10-------------------20------------------30********40........\n+    \/\/                   si_1         si_3                  si_1                si_1\n+    \/\/\n+    \/\/ Request:                         15******************25\n+    \/\/ Post: ........0--------10--------15********20********25---------30********40........\n+    \/\/        mtNone   mtTest     mtTest   mtTest    mtTest     mtTest     mtTest     mtNone\n+    \/\/        Rl       Rs         Rs       C         C          Rs         C          Rl\n+    \/\/        -        si_1       si_3     si_3      si_1       si_1       si_1       -\n+    \/\/        -        -          -        si_2      si_2       -          si_1       -\n+    ExpectedTree<7> et = {{     0,     10,     15,     20,     25,     30,    40          },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone },\n+                          {Rl    , Rs    , Rs    , C     , C     , Rs    , C     , Rl     },\n+                          {-1    , si_1  , si_3  , si_3  , si_1  , si_1  , si_1  , -1     },\n+                          {-1    , -1    , -1    , si_2  , si_2  , -1    , si_1  , -1     }};\n+    check_tree(tree, et, __LINE__);\n+  }\n+  { \/\/ Do 'Uncommit' over two different reserved regions\n+    Tree tree;\n+    \/\/ Prepare pre-cond\n+    tree.reserve_mapping(0, 40, call_stack_1);\n+    tree.commit_mapping(10, 10, call_stack_1_mtNone, true);\n+    tree.commit_mapping(30, 10, call_stack_1_mtNone, true);\n+    tree.reserve_mapping(10, 10, call_stack_2);\n+    \/\/ New request\n+    tree.uncommit_mapping(15, 10, call_stack_1_mtNone);\n+    \/\/ Pre:  ........0--------10----------------20-----------------------30********40........\n+    \/\/                  si_1          si_2                 si_1                  si_1\n+    \/\/\n+    \/\/ Reqquest:                      15-------------------25\n+    \/\/ Pre:  ........0--------10----------------20-----------------------30********40........\n+    \/\/        mtNone   mtTest        mtTest             mtTest              mtTest     mtNone\n+    \/\/        Rl       Rs            Rs                 Rs                  C          Rl\n+    \/\/        -        si_1          si_2               si_1                si_1       -\n+    \/\/        -        -             -                  -                   si_1       -\n+    ExpectedTree<5> et = {{     0,     10,     20,     30,    40          },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtNone },\n+                          {Rl    , Rs    , Rs    , Rs    , C     , Rl     },\n+                          {-1    , si_1  , si_2  , si_1  , si_1  , -1     },\n+                          {-1    , -1    , -1    , -1    , si_1  , -1     }};\n+    check_tree(tree, et, __LINE__);\n+  }\n+  { \/\/ Do 'Release' for a reserved region\n+    Tree tree;\n+    \/\/ Prepare pre-cond\n+    tree.reserve_mapping(0, 40, call_stack_1);\n+    tree.commit_mapping(10, 10, call_stack_1_mtNone, true);\n+    tree.commit_mapping(30, 10, call_stack_1_mtNone, true);\n+    tree.reserve_mapping(10, 10, call_stack_2);\n+    \/\/ New request\n+    tree.release_mapping(15, 10);\n+    \/\/ Pre:  ........0--------10----------------20----------------------30********40........\n+    \/\/ Request:                         15................25\n+    \/\/ Post: ........0--------10--------15................25------------30********40........\n+    \/\/        mtNone   mtTest     mtTest       mtNone          mtTest      mtTest     mtNone\n+    \/\/        Rl       Rs         Rs           Rl              Rs          C          Rl\n+    \/\/        -        si_1       si_2         -               si_1        si_1       -\n+    \/\/        -        -          -            -               -           si_1       -\n+    ExpectedTree<6> et = {{     0,     10,     15,     25,     30,    40          },\n+                          {mtNone, mtTest, mtTest, mtNone, mtTest, mtTest, mtNone },\n+                          {Rl    , Rs    , Rs    , Rl    , Rs    , C     , Rl     },\n+                          {-1    , si_1  , si_2  , -1    , si_1  , si_1  , -1     },\n+                          {-1    , -1    , -1    , -1    , -1    , si_1  , -1     }};\n+    check_tree(tree, et, __LINE__);\n+  }\n+  { \/\/ Do 'Reserve' for a committed region\n+    Tree tree;\n+    \/\/ Prepare pre-cond\n+    tree.reserve_mapping(0, 40, call_stack_1);\n+    tree.commit_mapping(10, 10, call_stack_1_mtNone, true);\n+    tree.commit_mapping(30, 10, call_stack_1_mtNone, true);\n+    \/\/ New request\n+    tree.reserve_mapping(15, 10, call_stack_2);\n+    \/\/ Pre:  ........0--------10****************20----------------------30********40........\n+    \/\/ Request:                         15----------------25\n+    \/\/ Post: ........0--------10********15----------------25------------30********40........\n+    \/\/        mtNone   mtTest    mtTest      mtTest           mtTest       mtTest     mtNone\n+    \/\/        Rl       Rs        C           Rs               Rs           C          Rl\n+    \/\/        -        si_1      si_1        si_2             si_1         si_1       -\n+    \/\/        -        -         si_1        -                -            si_1       -\n+    ExpectedTree<6> et = {{     0,     10,     15,     25,     30,    40          },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone },\n+                          {Rl    , Rs    , C     , Rs    , Rs    , C     , Rl     },\n+                          {-1    , si_1  , si_1  , si_2  , si_1  , si_1  , -1     },\n+                          {-1    , -1    , si_1  , -1    , -1    , si_1  , -1     }};\n+    check_tree(tree, et, __LINE__);\n+  }\n+  { \/\/ Do 'Commit' for a committed region\n+    Tree tree;\n+    \/\/ Prepare pre-cond\n+    tree.reserve_mapping(0, 40, call_stack_1);\n+    tree.commit_mapping(10, 10, call_stack_1_mtNone, true);\n+    tree.commit_mapping(30, 10, call_stack_1_mtNone, true);\n+    \/\/ New request\n+    tree.commit_mapping(15, 10, call_stack_2);\n+    \/\/ Pre:  ........0--------10****************20----------------------30********40........\n+    \/\/ Request:                         15****************25\n+    \/\/ Post: ........0--------10********15****************25------------30********40........\n+    \/\/        mtNone   mtTest     mtTest     mtTest           mtTest       mtTest     mtNone\n+    \/\/        Rl       Rs         C          C                Rs           C          Rl\n+    \/\/        -        si_1       si_1       si_1             si_1         si_1       -\n+    \/\/        -        -          si_1       si_2             -            si_1       -\n+    ExpectedTree<6> et = {{     0,     10,     15,     25,     30,    40          },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone },\n+                          {Rl    , Rs    , C     , C     , Rs    , C     , Rl     },\n+                          {-1    , si_1  , si_1  , si_1  , si_1  , si_1  , -1     },\n+                          {-1    , -1    , si_1  , si_2  , -1    , si_1  , -1     }};\n+    check_tree(tree, et, __LINE__);\n+  }\n+  { \/\/ Do 'Uncommit' for a committed region\n+    Tree tree;\n+    \/\/ Prepare pre-cond\n+    tree.reserve_mapping(0, 40, call_stack_1);\n+    tree.commit_mapping(10, 10, call_stack_1_mtNone, true);\n+    tree.commit_mapping(30, 10, call_stack_1_mtNone, true);\n+    \/\/ New request\n+    tree.uncommit_mapping(15, 10, call_stack_1_mtNone);\n+    \/\/ Pre:  ........0--------10*******************20--------------------30********40........\n+    \/\/ Request:                         15--------------------25\n+    \/\/ Post: ........0--------10********15-------------------------------30********40........\n+    \/\/        mtNone   mtTest    mtTest              mtTest                 mtTest     mtNone\n+    \/\/        Rl       Rs        C                   Rs                     C          Rl\n+    \/\/        -        si_1      si_1                si_1                   si_1       -\n+    \/\/        -        -         si_1                -                      si_1       -\n+    ExpectedTree<5> et = {{     0,     10,     15,     30,    40          },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtNone },\n+                          {Rl    , Rs    , C     , Rs    , C     , Rl     },\n+                          {-1    , si_1  , si_1  , si_1  , si_1  , -1     },\n+                          {-1    , -1    , si_1  , -1    , si_1  , -1     }};\n+    check_tree(tree, et, __LINE__);\n+  }\n+  { \/\/ Do 'Release' for a committed region\n+    Tree tree;\n+    \/\/ Prepare pre-cond\n+    tree.reserve_mapping(0, 40, call_stack_1);\n+    tree.commit_mapping(10, 10, call_stack_1_mtNone, true);\n+    tree.commit_mapping(30, 10, call_stack_1_mtNone, true);\n+    \/\/ New request\n+    tree.release_mapping(15, 10);\n+    \/\/ Pre:  ........0--------10****************20----------------------30********40........\n+    \/\/ Request:                         15................25\n+    \/\/ Post: ........0--------10********15................25------------30********40........\n+    \/\/        mtNone   mtTest     mtTest     mtNone           mtTest       mtTest     mtNone\n+    \/\/        Rl       Rs         C          Rl               Rs           C          Rl\n+    \/\/        -        si_1       si_1       -                si_1         si_1       -\n+    \/\/        -        -          si_1       -                -            si_1       -\n+    ExpectedTree<6> et = {{     0,     10,     15,     25,     30,    40          },\n+                          {mtNone, mtTest, mtTest, mtNone, mtTest, mtTest, mtNone },\n+                          {Rl    , Rs    , C     , Rl    , Rs    , C     , Rl     },\n+                          {-1    , si_1  , si_1  , -1    , si_1  , si_1  , -1     },\n+                          {-1    , -1    , si_1  , -1    , -1    , si_1  , -1     }};\n+    check_tree(tree, et, __LINE__);\n+  }\n+}\n+\n+TEST_VM_F(NMTVMATreeTest, MultipleRegionsAllWithSameTag) {\n+  using SIndex = NativeCallStackStorage::StackIndex;\n+  using State = VMATree::StateType;\n+  SIndex si_1 = si[0];\n+  SIndex si_2 = si[1];\n+  SIndex si_3 = si[2];\n+\n+  const State Rs = State::Reserved;\n+  const State Rl = State::Released;\n+  const State C = State::Committed;\n+  VMATree::RegionData call_stack_1(si_1, mtTest);\n+  VMATree::RegionData call_stack_1_mtNone(si_1, mtNone);\n+  VMATree::RegionData call_stack_2(si_2, mtTest);\n+  VMATree::RegionData call_stack_2_mtNone(si_2, mtNone);\n+  VMATree::RegionData call_stack_3_mtNone(si_3, mtNone);\n+\n+  { \/\/ Do 'Reserve' over multiple committed\/reserved regions\n+    Tree tree;\n+    \/\/ Prepare pre-cond\n+    tree.reserve_mapping(0, 50, call_stack_1);\n+    tree.commit_mapping(10, 5, call_stack_1_mtNone, true);\n+    tree.commit_mapping(20, 5, call_stack_1_mtNone, true);\n+    tree.commit_mapping(30, 5, call_stack_1_mtNone, true);\n+    \/\/ New request\n+    tree.reserve_mapping(5, 40, call_stack_2);\n+    \/\/ Pre:     ........0----------------10*********15--------20********25--------30********35-------------------50........\n+    \/\/ Request: (reserve)        5-----------------------------------------------------------------------45\n+    \/\/ Post:    ........0--------5-----------------------------------------------------------------------45-------50........\n+    \/\/           mtNone   mtTest                                 mtTest                                     mtTest      mtNone\n+    \/\/           Rl       Rs                                     Rs                                         Rs          Rl\n+    \/\/           -        si_1                                   si_2                                       si_1        -\n+    \/\/           -        -                                      -                                          -           -\n+    ExpectedTree<4> et = {{     0,      5,     45,     50         },\n+                          {mtNone, mtTest, mtTest, mtTest, mtNone },\n+                          {Rl    , Rs    , Rs    , Rs    , Rl     },\n+                          {-1    , si_1  , si_2  , si_1  , -1     },\n+                          {-1    , -1    , -1    , -1    , -1     }};\n+    check_tree(tree, et, __LINE__);\n+  }\n+  { \/\/ Do 'Reserve' [A, B) over multiple committed\/reserved regions where B already exists in nodes\n+    Tree tree;\n+    \/\/ Prepare pre-cond\n+    tree.reserve_mapping(0, 50, call_stack_1);\n+    tree.commit_mapping(10, 5, call_stack_1_mtNone, true);\n+    tree.commit_mapping(20, 5, call_stack_1_mtNone, true);\n+    tree.commit_mapping(30, 5, call_stack_1_mtNone, true);\n+    \/\/ New request\n+    tree.reserve_mapping(5, 30, call_stack_2);\n+    \/\/ Pre:     ........0----------------10*********15--------20********25--------30********35-------------------50........\n+    \/\/ Request: (reserve)        5----------------------------------------------------------35\n+    \/\/ Post:    ........0--------5----------------------------------------------------------35-------------------50........\n+    \/\/           mtNone                                          mtTest                            mtTest            mtNone\n+    \/\/           Rl                                              Rs                                Rs                Rl\n+    \/\/           -                                               si_2                              si_1              -\n+    \/\/           -                                               -                                 -                 -\n+    ExpectedTree<4> et = {{     0,      5,     35,     50         },\n+                          {mtNone, mtTest, mtTest, mtTest, mtNone },\n+                          {Rl    , Rs    , Rs    , Rs    , Rl     },\n+                          {-1    , si_1  , si_2  , si_1  , -1     },\n+                          {-1    , -1    , -1    , -1    , -1     }};\n+    check_tree(tree, et, __LINE__);\n+  }\n+  { \/\/ Do 'Reserve' [A, B) over multiple committed\/reserved regions where A already exists in nodes\n+    Tree tree;\n+    \/\/ Prepare pre-cond\n+    tree.reserve_mapping(0, 50, call_stack_1);\n+    tree.commit_mapping(10, 5, call_stack_1_mtNone, true);\n+    tree.commit_mapping(20, 5, call_stack_1_mtNone, true);\n+    tree.commit_mapping(30, 5, call_stack_1_mtNone, true);\n+    \/\/ New request\n+    tree.reserve_mapping(0, 45, call_stack_2);\n+    \/\/ Pre:     ..........0----------------10*********15--------20********25--------30********35------------50........\n+    \/\/ Request: (reserve) 0-------------------------------------------------------------------------45\n+    \/\/ Post:    ..........0-------------------------------------------------------------------------45------50........\n+    \/\/           mtNone                                 mtTest                                         mtTest  mtNone\n+    \/\/           Rl                                     Rs                                             Rs      Rl\n+    \/\/           -                                      si_2                                           si_1    -\n+    \/\/           -                                      -                                              -       -\n+    ExpectedTree<3> et = {{     0,     45,     50        },\n+                          {mtNone, mtTest, mtTest, mtNone },\n+                          {Rl    , Rs    , Rs    , Rl     },\n+                          {-1    , si_2  , si_1  , -1     },\n+                          {-1    , -1    , -1    , -1     }};\n+    check_tree(tree, et, __LINE__);\n+  }\n+  { \/\/ Do 'Uncommit' over multiple committed\/reserved regions\n+    Tree tree;\n+    \/\/ Prepare pre-cond\n+    tree.reserve_mapping(0, 50, call_stack_1);\n+    tree.commit_mapping(10, 5, call_stack_1_mtNone, true);\n+    tree.commit_mapping(20, 5, call_stack_1_mtNone, true);\n+    tree.commit_mapping(30, 5, call_stack_1_mtNone, true);\n+    \/\/ New request\n+    tree.uncommit_mapping(5, 40, call_stack_1_mtNone);\n+    \/\/ Pre:     ..........0----------------10*********15--------20********25--------30********35------------50........\n+    \/\/ Request: (uncommit)         5----------------------------------------------------------------45\n+    \/\/ Post:    ..........0---------------------------------------------------------------------------------50........\n+    \/\/           mtNone                                           mtTest                                       mtNone\n+    \/\/           Rl                                               Rs                                           Rl\n+    \/\/           -                                                si_1                                         -\n+    \/\/           -                                                -                                            -\n+    ExpectedTree<2> et = {{     0,     50         },\n+                          {mtNone, mtTest, mtNone },\n+                          {Rl    , Rs    , Rl     },\n+                          {-1    , si_1  , -1     },\n+                          {-1    , -1    , -1     }};\n+    check_tree(tree, et, __LINE__);\n+    VMATree::VMATreap::Range r = tree.tree().find_enclosing_range(5);\n+    EXPECT_EQ((int)r.start->key(), 0);\n+    EXPECT_EQ((int)r.end->key(), 50);\n+  }\n+  { \/\/ Do 'Uncommit' over multiple committed\/reserved regions with different call-stacks\n+    Tree tree;\n+    \/\/ Prepare pre-cond\n+    tree.reserve_mapping(0, 50, call_stack_1);\n+    tree.reserve_mapping(10, 5, call_stack_2);\n+    tree.reserve_mapping(20, 5, call_stack_2);\n+    tree.reserve_mapping(30, 5, call_stack_2);\n+    \/\/ New request\n+    tree.uncommit_mapping(5, 35, call_stack_3_mtNone); \/\/ The call-stack should not be taken into account\n+\n+    \/\/ Pre:     ........0----------------10---------15--------20--------25--------30--------35-------------------50........\n+    \/\/                         si_1          si_2       si_1      si_2       si_1       si_2          si_1           -\n+    \/\/\n+    \/\/ Request: (uncommit)       5---------------------------------------------------------------------40\n+    \/\/                                                       si_3\n+    \/\/\n+    \/\/ Post:    ........0----------------10----------15--------20--------25--------30--------35-------------------50........\n+    \/\/           mtNone       mtTest         mtTest      mtTest     mtTest     mtTest     mtTest        mtTest       mtNone                                      mtNone\n+    \/\/           Rl           Rs             Rs          Rs         Rs         Rs         Rs            Rs           Rl\n+    \/\/           -            si_1           si_2        si_1       si_2       si_1       si_2          si_1         -\n+    \/\/           -            -              -           -          -          -          -             -            -\n+    ExpectedTree<8> et = {{     0,     10,     15,     20,     25,     30,     35,     50         },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone },\n+                          {Rl    , Rs    , Rs    , Rs    , Rs    , Rs    , Rs    , Rs    , Rl     },\n+                          {-1    , si_1  , si_2  , si_1  , si_2  , si_1  , si_2  , si_1  , -1     },\n+                          {-1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    , -1     }};\n+    check_tree(tree, et, __LINE__);\n+  }\n+  { \/\/ Do 'Uncommit' [A,B) over multiple committed\/reserved regions where B already exists in the nodes\n+    Tree tree;\n+    \/\/ Prepare pre-cond\n+    tree.reserve_mapping(0, 50, call_stack_1);\n+    tree.commit_mapping(10, 5, call_stack_1_mtNone, true);\n+    tree.commit_mapping(20, 5, call_stack_1_mtNone, true);\n+    tree.commit_mapping(30, 5, call_stack_1_mtNone, true);\n+    \/\/ New request\n+    tree.uncommit_mapping(5, 30, call_stack_1_mtNone);\n+    \/\/ Pre:     ........0----------------100*********200--------300********400--------500********600-------------------1000........\n+    \/\/ Request: (uncommit)       50--------------------------------------------------------------600\n+    \/\/ Post:    ........0----------------------------------------------------------------------------------------------1000........\n+    \/\/           mtNone                                           mtTest                                                    mtNone\n+    \/\/           Rl                                               Rs                                                        Rl\n+    \/\/           -                                                si_1                                                      -\n+    \/\/           -                                                -                                                         -\n+    ExpectedTree<2> et = {{     0,     50         },\n+                          {mtNone, mtTest, mtNone },\n+                          {Rl    , Rs    , Rl     },\n+                          {-1    , si_1  , -1     },\n+                          {-1    , -1    , -1     }};\n+    check_tree(tree, et, __LINE__);\n+    VMATree::VMATreap::Range r = tree.tree().find_enclosing_range(5);\n+    EXPECT_EQ((int)r.start->key(), 0);  \/\/ make sure 600 is removed\n+    EXPECT_EQ((int)r.end->key(), 50);\n+  }\n+  { \/\/ Do 'Uncommit' [A,B) over multiple committed\/reserved regions where A already exists in the nodes\n+    Tree tree;\n+    \/\/ Prepare pre-cond\n+    tree.reserve_mapping(0, 50, call_stack_1);\n+    tree.commit_mapping(10, 5, call_stack_1_mtNone, true);\n+    tree.commit_mapping(20, 5, call_stack_1_mtNone, true);\n+    tree.commit_mapping(30, 5, call_stack_1_mtNone, true);\n+    \/\/ New request\n+    tree.uncommit_mapping(10, 40, call_stack_1_mtNone);\n+    \/\/ Pre:     ........0----------------100*********200--------300********400--------500********600-------------------1000........\n+    \/\/ Request: (uncommit)               100--------------------------------------------------------------950\n+    \/\/ Post:    ........0----------------------------------------------------------------------------------------------1000........\n+    \/\/           mtNone                                           mtTest                                                    mtNone\n+    \/\/           Rl                                               Rs                                                        Rl\n+    \/\/           -                                                si_1                                                      -\n+    \/\/           -                                                -                                                         -\n+    ExpectedTree<2> et = {{     0,     50         },\n+                          {mtNone, mtTest, mtNone },\n+                          {Rl    , Rs    , Rl     },\n+                          {-1    , si_1  , -1     },\n+                          {-1    , -1    , -1     }};\n+    check_tree(tree, et, __LINE__);\n+    VMATree::VMATreap::Range r = tree.tree().find_enclosing_range(5);\n+    EXPECT_EQ((int)r.start->key(), 0);\n+    EXPECT_EQ((int)r.end->key(), 50);\n+  }\n+  { \/\/ Do 'Release' over multiple committed\/reserved regions\n+    Tree tree;\n+    \/\/ Prepare pre-cond\n+    tree.reserve_mapping(0, 50, call_stack_1);\n+    tree.commit_mapping(10, 5, call_stack_1_mtNone, true);\n+    tree.commit_mapping(20, 5, call_stack_1_mtNone, true);\n+    tree.commit_mapping(30, 5, call_stack_1_mtNone, true);\n+    \/\/ New request\n+    tree.release_mapping(5, 40);\n+    \/\/ Pre:     ........0----------------100*********200--------300********400--------500********600-------------------1000........\n+    \/\/ Request:                  50-------------------------------------------------------------------------950\n+    \/\/ Post:    ........0--------50.........................................................................950--------1000........\n+    \/\/           mtNone   mtTest                                 mtNone                                         mtTest      mtNone\n+    \/\/           Rl       Rs                                     Rl                                             Rs          Rl\n+    \/\/           -        si_1                                   -                                              si_1        -\n+    \/\/           -        -                                      -                                              -           -\n+    ExpectedTree<4> et = {{     0,      5,     45,     50         },\n+                          {mtNone, mtTest, mtNone, mtTest, mtNone },\n+                          {Rl    , Rs    , Rl    , Rs    , Rl     },\n+                          {-1    , si_1  , -1    , si_1  , -1     },\n+                          {-1    , -1    , -1    , -1    , -1     }};\n+    check_tree(tree, et, __LINE__);\n+  }\n+  { \/\/ Do 'Release' [A,B) over multiple committed\/reserved regions where B already exists in the nodes\n+    Tree tree;\n+    \/\/ Prepare pre-cond\n+    tree.reserve_mapping(0, 50, call_stack_1);\n+    tree.commit_mapping(10, 5, call_stack_1_mtNone, true);\n+    tree.commit_mapping(20, 5, call_stack_1_mtNone, true);\n+    tree.commit_mapping(30, 5, call_stack_1_mtNone, true);\n+    \/\/ New request\n+    tree.release_mapping(5, 30);\n+    \/\/ Pre:     ........0----------------100*********200--------300********400--------500********600-------------------1000........\n+    \/\/ Request:                  50..............................................................600\n+    \/\/ Post:    ........0--------50..............................................................600-------------------1000........\n+    \/\/           mtNone   mtTest                                 mtNone                                    mtTest           mtNone\n+    \/\/           Rl       Rs                                     Rl                                        Rs               Rl\n+    \/\/           -        si_1                                   -                                         si_1             -\n+    \/\/           -        -                                      -                                         -               -\n+    ExpectedTree<4> et = {{     0,      5,     35,     50         },\n+                          {mtNone, mtTest, mtNone, mtTest, mtNone },\n+                          {Rl    , Rs    , Rl    , Rs    , Rl     },\n+                          {-1    , si_1  , -1    , si_1  , -1     },\n+                          {-1    , -1    , -1    , -1    , -1     }};\n+    check_tree(tree, et, __LINE__);\n+  }\n+  { \/\/ Do 'Release' [A,B) over multiple committed\/reserved regions where B is start of a released region\n+    Tree tree;\n+    \/\/ Prepare pre-cond\n+    tree.reserve_mapping(0, 50, call_stack_1);\n+    tree.commit_mapping(10, 5, call_stack_1_mtNone, true);\n+    tree.commit_mapping(20, 5, call_stack_1_mtNone, true);\n+    tree.commit_mapping(30, 5, call_stack_1_mtNone, true);\n+    \/\/ New request\n+    tree.release_mapping(5, 40);\n+    \/\/ Pre:     ........0----------------100*********200--------300********400--------500********600-------------------1000........\n+    \/\/ Request:                  50....................................................................................1000\n+    \/\/ Post:    ........0--------50.........\n+    \/\/           mtNone   mtTest    mtNone\n+    \/\/           Rl       Rs        Rl\n+    \/\/           -        si_1      -\n+    \/\/           -        -         -\n+    ExpectedTree<2> et = {{     0,      5,        },\n+                          {mtNone, mtTest, mtNone },\n+                          {Rl    , Rs    , Rl     },\n+                          {-1    , si_1  , -1     },\n+                          {-1    , -1    , -1     }};\n+    check_tree(tree, et, __LINE__);\n+  }\n+  { \/\/ Do 'Release' [A,B) over multiple committed\/reserved regions where A already exists in the nodes\n+    Tree tree;\n+    \/\/ Prepare pre-cond\n+    tree.reserve_mapping(0, 50, call_stack_1);\n+    tree.commit_mapping(10, 5, call_stack_1_mtNone, true);\n+    tree.commit_mapping(20, 5, call_stack_1_mtNone, true);\n+    tree.commit_mapping(30, 5, call_stack_1_mtNone, true);\n+    \/\/ New request\n+    tree.release_mapping(0, 40);\n+    \/\/ Pre:     ........0----------------100*********200--------300********400--------500********600-------------------1000........\n+    \/\/ Request:         0..................................................................................700\n+    \/\/ Post:    ...........................................................................................700---------1000........\n+    \/\/                                                   mtNone                                                 mtTest      mtNone\n+    \/\/                                                   Rl                                                     Rs          Rl\n+    \/\/                                                   -                                                      si_1        -\n+    \/\/                                                   -                                                      -           -\n+    ExpectedTree<2> et = {{    40,     50,        },\n+                          {mtNone, mtTest, mtNone },\n+                          {Rl    , Rs    , Rl     },\n+                          {-1    , si_1  , -1     },\n+                          {-1    , -1    , -1     }};\n+    check_tree(tree, et, __LINE__);\n+    VMATree::VMATreap::Range r = tree.tree().find_enclosing_range(0);\n+    EXPECT_EQ(r.start, nullptr);  \/\/ make sure 0 is removed\n+    EXPECT_EQ((int)r.end->key(), 40);\n+ }\n+}\n+\n+TEST_VM_F(NMTVMATreeTest, OverlapTableRows0To3) {\n+  using SIndex = NativeCallStackStorage::StackIndex;\n+  using State = VMATree::StateType;\n+  SIndex si_1 = si[0];\n+  SIndex si_2 = si[1];\n+  SIndex si_3 = si[2];\n+\n+  const State Rs = State::Reserved;\n+  const State Rl = State::Released;\n+  const State C = State::Committed;\n+  VMATree::RegionData call_stack_1(si_1, mtTest);\n+  VMATree::RegionData call_stack_1_mtNone(si_1, mtNone);\n+  VMATree::RegionData call_stack_2(si_2, mtTest);\n+  VMATree::RegionData call_stack_2_mtNone(si_2, mtNone);\n+  VMATree::RegionData call_stack_3_mtNone(si_3, mtNone);\n+\n+  \/\/ row  0:  .........A..................B.....\n+  \/\/ case of empty tree is already covered in other tests.\n+  \/\/ row 1 is impossible. See the implementation.\n+  {\n+    \/\/ row  2:  .........A...Y.......................W.....B..........\n+    \/\/          .............100---120---140---160---200......\n+    \/\/                          si1   si2   si1   si2\n+    \/\/ request:          50********************************250\n+    \/\/ post:             50**100***120***140***160***200***250\n+    \/\/                    si2   si1   si2   si1   si2   si2\n+    \/\/                    si2   si2   si2   si2   si2   si2\n+    \/\/ post:             50**100***120***140***160*********250   200 has the same state at its left and right, thus to be removed.\n+    \/\/                    si2   si1   si2   si1     si2\n+    \/\/                    si2   si2   si2   si2     si2\n+    Tree tree;\n+    ExpectedTree<5> pre = {{    10,     12,     14,     16,     20        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , Rs    , Rs    , Rs    , Rl    },\n+                           {-1    , si_1  , si_2  , si_1  , si_2  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(5, 20, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 20);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 10);\n+    ExpectedTree<6> et = {{     5,     10,     12,     14,     16,     25        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                          {Rl    , C     , C     , C     , C     , C     , Rl    },\n+                          {-1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    },\n+                          {-1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row  3:  .........A...Y.......................WB.....\n+    \/\/          .............100---120---140---160---200......\n+    \/\/                          si1   si2   si1   si2\n+    \/\/ request:          50**************************200\n+    \/\/ post:             50**100***120***140***160***200\n+    \/\/                    si2   si1   si2   si1   si2\n+    \/\/                    si2   si2   si2   si2   si2\n+\n+    Tree tree;\n+    ExpectedTree<5> pre = {{    10,     12,     14,     16,     20        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , Rs    , Rs    , Rs    , Rl    },\n+                           {-1    , si_1  , si_2  , si_1  , si_2  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(5, 15, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 15);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 5);\n+    ExpectedTree<6> et = {{   5,      10,     12,     14,     16,      20        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                          {Rl    , C     , C     , C     , C     , C     , Rl    },\n+                          {-1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    },\n+                          {-1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+\n+}\n+\n+TEST_VM_F(NMTVMATreeTest, OverlapTableRows4to7) {\n+  using SIndex = NativeCallStackStorage::StackIndex;\n+  using State = VMATree::StateType;\n+  SIndex si_1 = si[0];\n+  SIndex si_2 = si[1];\n+  SIndex si_3 = si[2];\n+\n+  const State Rs = State::Reserved;\n+  const State Rl = State::Released;\n+  const State C = State::Committed;\n+  VMATree::RegionData call_stack_1(si_1, mtTest);\n+  VMATree::RegionData call_stack_1_mtNone(si_1, mtNone);\n+  VMATree::RegionData call_stack_2(si_2, mtTest);\n+  VMATree::RegionData call_stack_2_mtNone(si_2, mtNone);\n+  VMATree::RegionData call_stack_3_mtNone(si_3, mtNone);\n+\n+  {\n+    \/\/ row  4:  .....X...A..................B.....\n+    \/\/ nodes:   0---10...........................\n+    \/\/ request:          50*****************250\n+    \/\/ post:    0---10...50*****************250\n+    \/\/            si1        si2\n+    \/\/            -          si2\n+    Tree tree;\n+    ExpectedTree<2> pre = {{     0,     10,       },\n+                           {mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    },\n+                           {-1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(20, 20, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 20);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 20);\n+    ExpectedTree<4> et = {{     0,     10,     20,     40        },\n+                          {mtNone, mtTest, mtNone, mtTest, mtNone},\n+                          {Rl    , Rs    , Rl    , C     , Rl    },\n+                          {-1    , si_1  , -1    , si_2  , -1    },\n+                          {-1    , -1    , -1    , si_2  , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row  5:  .....X...A...YW.............B.....\n+    \/\/ nodes:   .....10------70................\n+    \/\/ request:          50*****************250\n+    \/\/ post:    .....10--50**70*************250\n+    \/\/                si1  si1    si2\n+    \/\/                -    si2    si2\n+    Tree tree;\n+    ExpectedTree<2> pre = {{    0,     10,       },\n+                           {mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    },\n+                           {-1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(5, 20, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 20);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 25 - 10);\n+    ExpectedTree<4> et = {{     0,      5,     10,     25        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtNone},\n+                          {Rl    , Rs    , C     , C     , Rl    },\n+                          {-1    , si_1  , si_1  , si_2  , -1    },\n+                          {-1    , -1    , si_2  , si_2  , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row  6:  .....X...A.....Y.......................W.....B...\n+    \/\/ nodes:   0---10.........100---120---140---160---200........\n+    \/\/           si1              si1   si2   si1   si2\n+    \/\/ request:          50**********************************250\n+    \/\/ post:    0---10...50****100***120***140***160***200***250\n+    \/\/            si1       si2   si1   si2   si1   si2   si2\n+    \/\/            -         si2   si2   si2   si2   si2   si2\n+    \/\/ post:    0---10...50****100***120***140***160*********250      ; 200 is noop\n+    \/\/            si1       si2   si1   si2   si1     si2\n+    \/\/            -         si2   si2   si2   si2     si2\n+    Tree tree;\n+    ExpectedTree<7> pre = {{     0,      5,     10,     12,     14,     16,     20        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , Rs    , Rs    , Rs    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_1  , si_2  , si_1  , si_2  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(7, 20, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 20);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 10);\n+    ExpectedTree<8> et = {{     0,      5,      7,    10,      12,     14,     16,     27        },\n+                          {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                          {Rl    , Rs    , Rl    , C     , C     , C     , C     , C     , Rl    },\n+                          {-1    , si_1  , -1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    },\n+                          {-1    , -1    , -1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row  7:  .....X...A...Y.......................WB.....\n+    \/\/ nodes:   0---10.......100---120---140---160---200....\n+    \/\/           si1            si1   si2   si1   si2\n+    \/\/ request:          50**************************200\n+    \/\/ post:    0---10...50****100***120***140***160*200\n+    \/\/            si1       si2   si1   si2   si1   si2\n+    \/\/            -         si2   si2   si2   si2   si2\n+    Tree tree;\n+    ExpectedTree<7> pre = {{     0,      5,     10,     12,     14,     16,     20        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , Rs    , Rs    , Rs    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_1  , si_2  , si_1  , si_2  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(7, 13, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 13);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 3);\n+    ExpectedTree<8> et = {{     0,      5,      7,     10,     12,     14,     16,     20        },\n+                          {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                          {Rl    , Rs    , Rl    , C     , C     , C     , C     , C     , Rl    },\n+                          {-1    , si_1  , -1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    },\n+                          {-1    , -1    , -1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+\n+}\n+\n+TEST_VM_F(NMTVMATreeTest, OverlapTableRows8to11) {\n+  using SIndex = NativeCallStackStorage::StackIndex;\n+  using State = VMATree::StateType;\n+  SIndex si_1 = si[0];\n+  SIndex si_2 = si[1];\n+  SIndex si_3 = si[2];\n+\n+  const State Rs = State::Reserved;\n+  const State Rl = State::Released;\n+  const State C = State::Committed;\n+  VMATree::RegionData call_stack_1(si_1, mtTest);\n+  VMATree::RegionData call_stack_1_mtNone(si_1, mtNone);\n+  VMATree::RegionData call_stack_2(si_2, mtTest);\n+  VMATree::RegionData call_stack_2_mtNone(si_2, mtNone);\n+  VMATree::RegionData call_stack_3_mtNone(si_3, mtNone);\n+  {\n+    \/\/ row  8:  ........XA..................B.....\n+    \/\/ nodes:   0--------50...........................\n+    \/\/            si1\n+    \/\/            -\n+    \/\/ request:          50*****************250\n+    \/\/ post:    0--------50*****************250\n+    \/\/            si1        si2\n+    \/\/            -          si2\n+    Tree tree;\n+    ExpectedTree<2> pre = {{     0,     50,       },\n+                           {mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    },\n+                           {-1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(50, 200, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 200);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 200);\n+    ExpectedTree<3> et = {{     0,     50,    250        },\n+                          {mtNone, mtTest, mtTest, mtNone},\n+                          {Rl    , Rs    , C     , Rl    },\n+                          {-1    , si_1  , si_2  , -1    },\n+                          {-1    , -1    , si_2  , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row  9:  ........XA....YW.............B.....\n+    \/\/ nodes:   ........10----70................\n+    \/\/ request:         10*******************250\n+    \/\/ post:    ........10****70*************250\n+    \/\/                    si1        si2\n+    \/\/                    si2        si2\n+    Tree tree;\n+    ExpectedTree<2> pre = {{    10,     70,       },\n+                           {mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    },\n+                           {-1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(10, 240, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 240);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 250 - 70);\n+    ExpectedTree<3> et = {{    10,     70,    250        },\n+                          {mtNone, mtTest, mtTest, mtNone},\n+                          {Rl    , C     , C     , Rl    },\n+                          {-1    , si_1  , si_2  , -1    },\n+                          {-1    , si_2  , si_2  , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 10:  ........XA...Y.......................W.....B...\n+    \/\/ nodes:   ........50---100---120---140---160---200.......\n+    \/\/                    si2   si1   si2   si1   si2\n+    \/\/ request:         50*********************************250\n+    \/\/ post:    ........50***100***120***140***160***200***250\n+    \/\/                    si2   si1   si2   si1   si2   si2\n+    \/\/                    si2   si2   si2   si2   si2   si2\n+    \/\/ post:    ........50***100***120***140***160***200***250        ; 200 is noop\n+    \/\/                    si2   si1   si2   si1   si2   si2\n+    \/\/                    si2   si2   si2   si2   si2   si2\n+    Tree tree;\n+    ExpectedTree<6> pre = {{    50,    100,    120,    140,    160,    200        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , Rs    , Rs    , Rs    , Rs    , Rl    },\n+                           {-1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(50, 200, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 200);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 250 - 200);\n+    ExpectedTree<6> et = {{    50,    100,    120,    140,    160,    250        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                          {Rl    , C     , C     , C     , C     , C     , Rl    },\n+                          {-1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    },\n+                          {-1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 11:  ........XA...Y.......................WB.....\n+    \/\/ nodes:   ........50---100---120---140---160---200....\n+    \/\/                    si2   si1   si2   si1   si2\n+    \/\/ request:         50***************************200\n+    \/\/ post:    ........50***100***120***140***160***200....\n+    \/\/                    si2   si1   si2   si1   si2\n+    \/\/                    si2   si2   si2   si2   si2\n+    Tree tree;\n+    ExpectedTree<6> pre = {{    50,    100,    120,    140,    160,    200        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , Rs    , Rs    , Rs    , Rs    , Rl    },\n+                           {-1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(50, 150, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 150);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 0);\n+    ExpectedTree<6> et = {{    50,    100,    120,    140,    160,    200        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                          {Rl    , C     , C     , C     , C     , C     , Rl    },\n+                          {-1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    },\n+                          {-1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+\n+}\n+\n+TEST_VM_F(NMTVMATreeTest, OverlapTableRows12to15) {\n+  using SIndex = NativeCallStackStorage::StackIndex;\n+  using State = VMATree::StateType;\n+  SIndex si_1 = si[0];\n+  SIndex si_2 = si[1];\n+  SIndex si_3 = si[2];\n+\n+  const State Rs = State::Reserved;\n+  const State Rl = State::Released;\n+  const State C = State::Committed;\n+  VMATree::RegionData call_stack_1(si_1, mtTest);\n+  VMATree::RegionData call_stack_1_mtNone(si_1, mtNone);\n+  VMATree::RegionData call_stack_2(si_2, mtTest);\n+  VMATree::RegionData call_stack_2_mtNone(si_2, mtNone);\n+  VMATree::RegionData call_stack_3_mtNone(si_3, mtNone);\n+\n+  {\n+    \/\/ row 12:  .........A..................B.....U\n+    \/\/ nodes:   ..................................300---400\n+    \/\/ request:          50*****************250\n+    \/\/ post:             50*****************250...300---400\n+    \/\/                          si2\n+    \/\/                          si2\n+    Tree tree;\n+    ExpectedTree<2> pre = {{   300,    400        },\n+                           {mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    },\n+                           {-1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(50, 200, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 200);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 200);\n+    ExpectedTree<4> et = {{    50,    250,    300,    400        },\n+                          {mtNone, mtTest, mtNone, mtTest, mtNone},\n+                          {Rl    , C     , Rl    , Rs    , Rl    },\n+                          {-1    , si_2  , -1    , si_1  , -1    },\n+                          {-1    , si_2  , -1    , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 13:  .........A...YW.............B....U\n+    \/\/ nodes:   .............70------------------300\n+    \/\/ request:          50*****************250\n+    \/\/ post:    .........50**70*************250--300\n+    \/\/                    si2     si1          si1\n+    \/\/                    si2     si2          -\n+    Tree tree;\n+    ExpectedTree<2> pre = {{    70,    300        },\n+                           {mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    },\n+                           {-1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(50, 200, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 200);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 70 - 50);\n+    ExpectedTree<4> et = {{    50,     70,    250,    300        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtNone},\n+                          {Rl    , C     , C     , Rs    , Rl    },\n+                          {-1    , si_2  , si_1  , si_1  , -1    },\n+                          {-1    , si_2  , si_2  , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 14:  .........A...Y.......................W....B....U\n+    \/\/ nodes:   .............100---120---140---160---200.......300---400\n+    \/\/ request:          50*******************************250\n+    \/\/ post:             50***100**120***140***160***200**250..300---400\n+    \/\/                     si2   si1  si2   si1   si2   si2\n+    \/\/                     si2   si2  si2   si2   si2   si2\n+    \/\/ post:             50***100**120***140***160********250..300---400        ; node 200 is noop\n+    \/\/                     si2   si1  si2   si1     si2\n+    \/\/                     si2   si2  si2   si2     si2\n+    Tree tree;\n+    ExpectedTree<7> pre = {{   100,    120,    140,    160,    200,    300,    400        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rs    , Rs    , Rs    , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , si_2  , si_1  , si_2  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(50, 200, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 200);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 100);\n+    ExpectedTree<8> et = {{    50,    100,    120,    140,    160,    250,    300,    400        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                          {Rl    , C     , C     , C     , C     , C     , Rl    , Rs    , Rl    },\n+                          {-1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    , si_1  , -1    },\n+                          {-1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 15:  .........A...Y.......................WB....U\n+    \/\/ nodes:   .............100---120---140---160---200...300---400\n+    \/\/ request:          50**************************200\n+    \/\/ post:             50***100**120***140***160***200...300---400\n+    \/\/                     si2   si1  si2   si1   si2\n+    \/\/                     si2   si2  si2   si2   si2\n+    \/\/ post:             50***100**120***140***160***200...300---400\n+    \/\/                     si2   si1  si2   si1    si2\n+    \/\/                     si2   si2  si2   si2    si2\n+    Tree tree;\n+    ExpectedTree<7> pre = {{   100,    120,    140,    160,    200,    300,    400        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rs    , Rs    , Rs    , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , si_2  , si_1  , si_2  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(50, 150, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 150);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 50);\n+    ExpectedTree<8> et = {{    50,    100,    120,    140,    160,    200,    300,    400        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                          {Rl    , C     , C     , C     , C     , C     , Rl    , Rs    , Rl    },\n+                          {-1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    , si_1  , -1    },\n+                          {-1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+\n+}\n+\n+TEST_VM_F(NMTVMATreeTest, OverlapTableRows16to19) {\n+  using SIndex = NativeCallStackStorage::StackIndex;\n+  using State = VMATree::StateType;\n+  SIndex si_1 = si[0];\n+  SIndex si_2 = si[1];\n+  SIndex si_3 = si[2];\n+\n+  const State Rs = State::Reserved;\n+  const State Rl = State::Released;\n+  const State C = State::Committed;\n+  VMATree::RegionData call_stack_1(si_1, mtTest);\n+  VMATree::RegionData call_stack_1_mtNone(si_1, mtNone);\n+  VMATree::RegionData call_stack_2(si_2, mtTest);\n+  VMATree::RegionData call_stack_2_mtNone(si_2, mtNone);\n+  VMATree::RegionData call_stack_3_mtNone(si_3, mtNone);\n+\n+  {\n+    \/\/ row 16:  .....X...A..................B....U\n+    \/\/ nodes:   0---10...........................300---400\n+    \/\/ request:          50*****************250\n+    \/\/ post:    0---10...50*****************250..300---400\n+    \/\/                          si2\n+    \/\/                          si2\n+    Tree tree;\n+    ExpectedTree<4> pre = {{     0,    10,     300,    400        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(50, 200, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 200);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 200);\n+    ExpectedTree<6> et = {{     0,     10,     50,    250,    300,    400        },\n+                          {mtNone, mtTest, mtNone, mtTest, mtNone, mtTest, mtNone},\n+                          {Rl    , Rs    , Rl    , C     , Rl    , Rs    , Rl    },\n+                          {-1    , si_1  , -1    , si_2  , -1    , si_1  , -1    },\n+                          {-1    , -1    , -1    , si_2  , -1    , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 17:  .....X...A...YW.............B....U\n+    \/\/ nodes:   0----10......70------------------300\n+    \/\/ request:          50*****************250\n+    \/\/ post:    0----10..50**70*************250--300\n+    \/\/                    si2     si1          si1\n+    \/\/                    si2     si2          -\n+    Tree tree;\n+    ExpectedTree<4> pre = {{     0,     10,     70,    300        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(50, 200, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 200);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 70 - 50);\n+    ExpectedTree<6> et = {{     0,     10,     50,     70,    250,    300        },\n+                          {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtNone},\n+                          {Rl    , Rs    , Rl    , C     , C     , Rs    , Rl    },\n+                          {-1    , si_1  , -1    , si_2  , si_1  , si_1  , -1    },\n+                          {-1    , -1    , -1    , si_2  , si_2  , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 18:  ....X....A...Y.......................W....B....U\n+    \/\/ nodes:   0---10.......100---120---140---160---200.......300---400\n+    \/\/                          si2   si1   si2   si1\n+    \/\/ request:          50*******************************250\n+    \/\/ post:    0---10...50***100**120***140***160***200**250..300---400\n+    \/\/                     si2   si2  si1   si2   si1   si2\n+    \/\/                     si2   si2  si2   si2   si2   si2\n+    \/\/ post:    0---10...50********120***140***160***200**250..300---400\n+    \/\/                        si2     si1   si2    si1  si2\n+    \/\/                        si2     si2   si2    si2  si2\n+    Tree tree;\n+    ExpectedTree<9> pre = {{     0,     10,    100,    120,    140,    160,    200,    300,    400        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , Rs    , Rs    , Rs    , Rs    , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_2  , si_1  , si_2  , si_1  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(50, 200, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 200);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 100);\n+    ExpectedTree<10> et = {{     0,     10,     50,    120,    140,    160,    200,   250,    300,    400        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , C     , C     , C     , C     , C     , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 19:  .....X...A...Y.......................WB....U\n+    \/\/ nodes:   0----10......100---120---140---160---200...300---400\n+    \/\/ request:          50**************************200\n+    \/\/ post:    0----10..50***100**120***140***160***200...300---400\n+    \/\/                     si2   si1  si2   si1   si2\n+    \/\/                     si2   si2  si2   si2   si2\n+    Tree tree;\n+    ExpectedTree<9> pre = {{     0,     10,    100,    120,    140,    160,    200,    300,    400        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , Rs    , Rs    , Rs    , Rs    , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_1  , si_2  , si_1  , si_2  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(50, 150, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 150);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 50);\n+    ExpectedTree<10> et = {{     0,     10,     50,    100,    120,    140,    160,    200,    300,    400        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , C     , C     , C     , C     , C     , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+\n+}\n+\n+TEST_VM_F(NMTVMATreeTest, OverlapTableRows20to23) {\n+  using SIndex = NativeCallStackStorage::StackIndex;\n+  using State = VMATree::StateType;\n+  SIndex si_1 = si[0];\n+  SIndex si_2 = si[1];\n+  SIndex si_3 = si[2];\n+\n+  const State Rs = State::Reserved;\n+  const State Rl = State::Released;\n+  const State C = State::Committed;\n+  VMATree::RegionData call_stack_1(si_1, mtTest);\n+  VMATree::RegionData call_stack_1_mtNone(si_1, mtNone);\n+  VMATree::RegionData call_stack_2(si_2, mtTest);\n+  VMATree::RegionData call_stack_2_mtNone(si_2, mtNone);\n+  VMATree::RegionData call_stack_3_mtNone(si_3, mtNone);\n+\n+  {\n+    \/\/ row 20:  ........XA..................B....U\n+    \/\/ nodes:   0-------50.......................300---400\n+    \/\/ request:         50******************250\n+    \/\/ post:    0-------50******************250..300---400\n+    \/\/                          si2\n+    \/\/                          si2\n+    Tree tree;\n+    ExpectedTree<4> pre = {{     0,    50,     300,    400        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(50, 200, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 200);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 200);\n+    ExpectedTree<5> et = {{     0,     50,    250,    300,    400        },\n+                          {mtNone, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                          {Rl    , Rs    , C     , Rl    , Rs    , Rl    },\n+                          {-1    , si_1  , si_2  , -1    , si_1  , -1    },\n+                          {-1    , -1    , si_2  , -1    , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 21:  ........XA...YW.............B....U\n+    \/\/ nodes:   0-------50...70------------------300\n+    \/\/ request:         50******************250\n+    \/\/ post:    0-------50**70**************250--300\n+    \/\/                    si2     si1          si1\n+    \/\/                    si2     si2          -\n+    Tree tree;\n+    ExpectedTree<4> pre = {{     0,     50,     70,    300        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(50, 200, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 200);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 70 - 50);\n+    ExpectedTree<5> et = {{     0,     50,     70,    250,    300        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                          {Rl    , Rs    , C     , C     , Rs    , Rl    },\n+                          {-1    , si_1  , si_2  , si_1  , si_1  , -1    },\n+                          {-1    , -1    , si_2  , si_2  , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 22:  ........XA...Y.......................W....B....U\n+    \/\/ nodes:   0-------50...100---120---140---160---200.......300---400\n+    \/\/                          si2   si1   si2   si1\n+    \/\/ request:         50********************************250\n+    \/\/ post:    0-------50***100***120***140***160***200**250..300---400\n+    \/\/                     si2   si2  si1   si2   si1   si2\n+    \/\/                     si2   si2  si2   si2   si2   si2\n+    \/\/ post:    0-------50*********120***140***160***200**250..300---400\n+    \/\/                        si2     si1   si2    si1  si2\n+    \/\/                        si2     si2   si2    si2  si2\n+    Tree tree;\n+    ExpectedTree<9> pre = {{     0,     50,    100,    120,    140,    160,    200,    300,    400        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , Rs    , Rs    , Rs    , Rs    , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_2  , si_1  , si_2  , si_1  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(50, 200, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 200);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 100);\n+    ExpectedTree<9> et = {{     0,     50,    120,    140,    160,    200,   250,    300,    400        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                          {Rl    , Rs    , C     , C     , C     , C     , C     , Rl    , Rs    , Rl    },\n+                          {-1    , si_1  , si_2  , si_1  , si_2  , si_1  , si_2  , -1    , si_1  , -1    },\n+                          {-1    , -1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 23:  ........XA...Y.......................WB....U\n+    \/\/ nodes:   0-------50...100---120---140---160---200...300---400\n+    \/\/ request:         50***************************200\n+    \/\/ post:    0-------50***100***120***140***160***200...300---400\n+    \/\/                     si2  si1   si2   si1   si2\n+    \/\/                     si2  si2   si2   si2   si2\n+    Tree tree;\n+    ExpectedTree<9> pre = {{     0,     50,    100,    120,    140,    160,    200,    300,    400        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , Rs    , Rs    , Rs    , Rs    , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_1  , si_2  , si_1  , si_2  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(50, 150, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 150);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 50);\n+    ExpectedTree<9> et = {{     0,     50,    100,    120,    140,    160,    200,    300,    400        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                          {Rl    , Rs    , C     , C     , C     , C     , C     , Rl    , Rs    , Rl    },\n+                          {-1    , si_1  , si_2  , si_1  , si_2  , si_1  , si_2  , -1    , si_1  , -1    },\n+                          {-1    , -1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+\n+}\n+\n+TEST_VM_F(NMTVMATreeTest, UpdateRegionTest) {\n+  using State = VMATree::StateType;\n+  using SIndex = VMATree::SIndex;\n+  SIndex ES = NativeCallStackStorage::invalid;\n+  SIndex s0 = si[0];\n+  SIndex s1 = si[1];\n+  SIndex s2 = si[2];\n+\n+  const State Rs = State::Reserved;\n+  const State Rl = State::Released;\n+  const State C = State::Committed;\n+  const int a = 100;\n+  const MemTag ReqTag = mtTest;\n+  const VMATree::RequestInfo       ReleaseRequest{0, a, Rl, mtNone, ES, false};\n+  const VMATree::RequestInfo       ReserveRequest{0, a, Rs, ReqTag, s2, false};\n+  const VMATree::RequestInfo        CommitRequest{0, a,  C, ReqTag, s2, false};\n+  const VMATree::RequestInfo      UncommitRequest{0, a, Rs, mtNone, ES, true};\n+  const VMATree::RequestInfo CopyTagCommitRequest{0, a,  C, ReqTag, s2, true};\n+                              \/\/  existing state           request              expected state     expected diff\n+                              \/\/ st   tag    stacks                           st   tag    stacks   reserve  commit\n+                              \/\/ --  ------  ------  ----------------------   --  ------  ------   -------  -------\n+  UpdateCallInfo  call_info[]={{{Rl, mtNone, ES, ES},        ReleaseRequest, {Rl, mtNone, ES, ES}, {0,  0}, {0,  0}},\n+                               {{Rl, mtNone, ES, ES},        ReserveRequest, {Rs, ReqTag, s2, ES}, {0,  a}, {0,  0}},\n+                               {{Rl, mtNone, ES, ES},         CommitRequest, { C, ReqTag, s2, s2}, {0,  a}, {0,  a}},\n+                               {{Rl, mtNone, ES, ES},  CopyTagCommitRequest, { C, mtNone, s2, s2}, {0,  a}, {0,  a}},\n+                               {{Rl, mtNone, ES, ES},       UncommitRequest, {Rl, mtNone, ES, ES}, {0,  0}, {0,  0}},\n+                               {{Rs,   mtGC, s0, ES},        ReleaseRequest, {Rl, mtNone, ES, ES}, {-a, 0}, {0,  0}},\n+                               {{Rs,   mtGC, s0, ES},        ReserveRequest, {Rs, ReqTag, s2, ES}, {-a, a}, {0,  0}}, \/\/ diff tag\n+                               {{Rs, mtTest, s0, ES},        ReserveRequest, {Rs, ReqTag, s2, ES}, {0,  0}, {0,  0}}, \/\/ same tag\n+                               {{Rs,   mtGC, s0, ES},         CommitRequest, { C, ReqTag, s0, s2}, {-a, a}, {0,  a}},\n+                               {{Rs,   mtGC, s0, ES},  CopyTagCommitRequest, { C,   mtGC, s0, s2}, {0,  0}, {0,  a}},\n+                               {{Rs,   mtGC, s0, ES},       UncommitRequest, {Rs,   mtGC, s0, ES}, {0,  0}, {0,  0}},\n+                               {{ C,   mtGC, s0, s1},        ReleaseRequest, {Rl, mtNone, ES, ES}, {-a, 0}, {-a, 0}},\n+                               {{ C,   mtGC, s0, s1},        ReserveRequest, {Rs, ReqTag, s2, ES}, {-a, a}, {-a, 0}}, \/\/ diff tag\n+                               {{ C, mtTest, s0, s1},        ReserveRequest, {Rs, ReqTag, s2, ES}, {0,  0}, {-a, 0}}, \/\/ same tag\n+                               {{ C,   mtGC, s0, s1},         CommitRequest, { C, ReqTag, s0, s2}, {-a, a}, {-a, a}},\n+                               {{ C,   mtGC, s0, s1},  CopyTagCommitRequest, { C,   mtGC, s0, s2}, {0,  0}, {-a, a}},\n+                               {{ C,   mtGC, s0, s1},       UncommitRequest, {Rs,   mtGC, s0, ES}, {0,  0}, {-a, 0}}\n+                              };\n+  for (auto ci : call_info) {\n+    call_update_region(ci);\n+  }\n","filename":"test\/hotspot\/gtest\/nmt\/test_vmatree.cpp","additions":2280,"deletions":49,"binary":false,"changes":2329,"status":"modified"}]}