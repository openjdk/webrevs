{"files":[{"patch":"@@ -56,1 +56,5 @@\n-  return result[op][st_to_index(ex)];\n+  if (op == 2 && ex == StateType::Released) {\n+    return rq;\n+  } else {\n+    return result[op][st_to_index(ex)];\n+  }\n@@ -142,1 +146,0 @@\n-  tty->print_cr(\"%d %d %d %d %ld %ld\", (int)t1, (int)t2, op, st, from_rescom.reserve, to_rescom.reserve);\n@@ -152,1 +155,1 @@\n-  IntervalState exSt; \/\/ existing state info\n+  IntervalState exSt = n1->val().out; \/\/ existing state info\n@@ -155,5 +158,1 @@\n-  if (n1->key() == req.A) {\n-    exSt = n1->val().in;\n-  } else {\n-    exSt = n1->val().out;\n-  }\n+\n@@ -167,1 +166,1 @@\n-  MemTag    new_tag                     = req.use_tag_inplace ? existing_tag : req.tag;\n+  MemTag    new_tag                     = req.use_tag_inplace ? n1->val().out.mem_tag() : req.tag;\n@@ -169,1 +168,1 @@\n-  SIndex    new_committ_callstack       = get_new_reserve_callstack(existing_reserve_callstack, existing_state, req);\n+  SIndex    new_committ_callstack       = get_new_commit_callstack(existing_commit_callstack, existing_state, req);\n@@ -173,1 +172,0 @@\n-  n1->val().out.set_commit_stack(new_committ_callstack);\n@@ -175,0 +173,1 @@\n+  n1->val().out.set_commit_stack(new_committ_callstack);\n@@ -178,1 +177,0 @@\n-  n2->val().in.set_commit_stack(new_committ_callstack);\n@@ -180,0 +178,1 @@\n+  n2->val().in.set_commit_stack(new_committ_callstack);\n@@ -186,1 +185,1 @@\n-VMATree::SummaryDiff VMATree::register_mapping(position A, position B, StateType state,\n+VMATree::SummaryDiff VMATree::register_mapping(position _A, position _B, StateType state,\n@@ -189,1 +188,1 @@\n-  if (A == B) {\n+  if (_A == _B) {\n@@ -192,1 +191,1 @@\n-  assert(A < B, \"should be\");\n+  assert(_A < _B, \"should be\");\n@@ -194,1 +193,1 @@\n-  RequestInfo req{A, B, state, metadata.mem_tag, metadata.stack_idx, use_tag_inplace};\n+  RequestInfo req{_A, _B, state, metadata.mem_tag, metadata.stack_idx, use_tag_inplace};\n@@ -203,2 +202,43 @@\n-  VMATreap::Range rA = _tree.find_enclosing_range(A);\n-  VMATreap::Range rB = _tree.find_enclosing_range(B);\n+  auto upsert_if= [&](TreapNode* node) {\n+    if (!node->val().is_noop()) {\n+      _tree.upsert(node->key(), node->val());\n+    }\n+  };\n+  auto update = [&](TreapNode* n1, TreapNode* n2) {\n+    update_region(n1, n2, req, diff);\n+  };\n+  auto remove_if = [&](TreapNode* node) -> bool{\n+    if (node->val().is_noop()) {\n+      _tree.remove(node->key());\n+      return true;\n+    }\n+    return false;\n+  };\n+  GrowableArrayCHeap<position, mtNMT> to_be_removed;\n+  \/\/ update regions in [Y,W)\n+  auto update_loop = [&]() {\n+    \/*(S,F)\n+    n1 = S\n+    while(n2 != F) {\n+      n2=gt(n1);\n+      update(n1,n2);\n+      n1=n2;\n+    }\n+    *\/\n+    TreapNode* prev = nullptr;\n+    _tree.visit_range_in_order(_A + 1, _B + 1, [&](TreapNode* curr) {\n+      if (prev != nullptr) {\n+        update_region(prev, curr, req, diff);\n+        \/\/ during visit, structure of the tree should not be changed\n+        \/\/ keep the keys to be removed, and remove them later\n+        if (prev->val().is_noop()) {\n+          to_be_removed.push(prev->key());\n+        }\n+      }\n+      prev = curr;\n+    });\n+  };\n+  stA.out.set_commit_stack(NativeCallStackStorage::invalid);\n+  stB.in.set_commit_stack(NativeCallStackStorage::invalid);\n+  VMATreap::Range rA = _tree.find_enclosing_range(_A);\n+  VMATreap::Range rB = _tree.find_enclosing_range(_B);\n@@ -214,25 +254,37 @@\n-  \/\/ The table below summarizes the cases and what to do.\n-  \/\/ 'update'  for a region [a,b) means call 'update_region(node a, node b, req, diff)' to update the region based on existing State and the request.\n-\n-\n-  \/\/                                                                                              Regions before loop                                         Regions in\n-  \/\/                                                             X exists     Y exists    X == A   [X,A)         [A,Y)    remove X if        upsert A if       the loop                                    to do after loop\n-  \/\/                                                             --------     --------    ------   ------        -----    ---------------    --------------   -------------  ----------------------------------------------------------------\n-  \/\/ row  0: nodes:          .........A..................B.....  no             no        --       --            --        --                 !A_is_noop()        --\n-  \/\/ row  1: nodes:          .....X...A..................B.....  yes            no        no       A.in = X.out  --        --                 !A_is_noop()        --\n-  \/\/ row  2: nodes:          .....XA.....................B.....  yes            no        yes      A.in = X.in   --        X.in == A.out      !remove_X           --\n-  \/\/ row  3: nodes:          .........A...Y...Z......W...B....U  no             yes       --       --            update    --                 !A_is_noop()       [Y,W)\n-  \/\/ row  4: nodes:          .....X...A...Y...Z......W...B....U  yes            yes       no       A.in = X.out  update    --                 !A_is_noop()       [Y,W)\n-  \/\/ row  5: nodes:          .....XA......Y...Z......W...B....U  yes            yes       yes      A.in = X.in   update    X.in == A.out      !remove_X          [Y,W)\n-  \/\/       :\n-  \/\/       :                                                     W exists     U exists    W == B                                                                             [W,B)         [B,U)            remove W if       upsert B if\n-  \/\/       :                                                     --------     --------    ------   ------------------------------------------------------------------------  -----         ------          ----------------  ---------------\n-  \/\/ row  6: nodes:          .........A..................B.....   no            no          --                                                                                --            --              --                !B.is_noop()\n-  \/\/ row  7: nodes:          .........A..................B....U   no            yes         --                                                                                --           B.out = U.in     --                !B.is_noop()\n-  \/\/ row  8: nodes:          .....X...A...Y...Z......W...B.....   yes           no          no                                                                                update        --              W.is_noop()       !B.is_noop()\n-  \/\/ row  9: nodes:          .....X...A...Y...Z......WB........   yes           no          yes                                                                               --            --              W.in == B.out     !remove_W\n-  \/\/ row 10: nodes:          .....X...A...Y...Z......W...B....U   yes           yes         no                                                                                update       B.out = U.in     W.is_noop()       !B.is_noop()\n-  \/\/ row 11: nodes:          .....X...A...Y...Z......WB.......U   yes           yes         yes                                                                               --            --              W.in == B.out     !remove_W\n-\n-  \/\/ We intentionally did not summarize\/compress the cases to have them as separate. This expanded way of describing the cases helps us to understand\/analyze\/verify\/debug\/maintain the corresponding code more easily.\n-  \/\/ Mapping of table to row, row to switch-case, 'what to do' to code should be consistent. If one changes, the others have to be updated accordingly.\n+  \/\/ The table below summarizes the overlap cases.\n+\n+\n+  \/\/ row  0:  .........A..................B.....\n+  \/\/ row  1:  .........A...YW.............B.....\n+  \/\/ row  2:  .........A...Y..........W...B.....\n+  \/\/ row  3:  .........A...Y.............WB.....\n+\n+  \/\/ row  4:  .....X...A..................B.....\n+  \/\/ row  5:  .....X...A...YW.............B.....\n+  \/\/ row  6:  .....X...A...Y..........W...B.....\n+  \/\/ row  7:  .....X...A...Y.............WB.....\n+\n+  \/\/ row  8:  ........XA..................B.....\n+  \/\/ row  9:  ........XA...YW.............B.....\n+  \/\/ row 10:  ........XA...Y..........W...B.....\n+  \/\/ row 11:  ........XA...Y.............WB.....\n+\n+  \/\/ row 12:  .........A..................B....U\n+  \/\/ row 13:  .........A...YW.............B....U\n+  \/\/ row 14:  .........A...Y..........W...B....U\n+  \/\/ row 15:  .........A...Y.............WB....U\n+\n+  \/\/ row 16:  .....X...A..................B....U\n+  \/\/ row 17:  .....X...A...YW.............B....U\n+  \/\/ row 18:  .....X...A...Y..........W...B....U\n+  \/\/ row 19:  .....X...A...Y.............WB....U\n+\n+  \/\/ row 20:  ........XA..................B....U\n+  \/\/ row 21:  ........XA...YW.............B....U\n+  \/\/ row 22:  ........XA...Y..........W...B....U\n+  \/\/ row 23:  ........XA...Y.............WB....U\n+\n+\n+  \/\/ We intentionally did not summarize\/compress the cases to keep them as separate.\n+  \/\/ This expanded way of describing the cases helps us to understand\/analyze\/verify\/debug\/maintain the corresponding code more easily.\n+  \/\/ Mapping of table to row, row to switch-case should be consistent. If one changes, the others have to be updated accordingly.\n@@ -243,1 +295,11 @@\n-  TreapNode nA{A, stA, 0}; \/\/ the node that represents A\n+  TreapNode* W = rB.start;\n+  TreapNode* U = rB.end;\n+  TreapNode nA{_A, stA, 0}; \/\/ the node that represents A\n+  TreapNode nB{_B, stB, 0}; \/\/ the node that represents B\n+  TreapNode* A = &nA;\n+  TreapNode* B = &nB;\n+  \/\/ update region of [A,T)\n+  auto update_A = [&](TreapNode* T) {\n+    A->val().out = A->val().in;\n+    update(A, T);\n+  };\n@@ -245,2 +307,6 @@\n-  bool Y_exists = Y != nullptr;\n-  bool X_eq_A = X_exists && rA.start->key() == A;\n+  bool Y_exists = Y != nullptr && Y->key() <= _B;\n+  bool W_exists = W != nullptr && W->key() > _A;\n+  bool U_exists = U != nullptr;\n+  bool X_eq_A = X_exists && X->key() == _A;\n+  bool W_eq_B = W_exists && W->key() == _B;\n+  bool Y_eq_W = Y_exists && W_exists && W->key() == Y->key();\n@@ -248,8 +314,48 @@\n-  if (!X_exists && !Y_exists           ) { row = 0; }\n-  if ( X_exists && !Y_exists && !X_eq_A) { row = 1; }\n-  if ( X_exists && !Y_exists &&  X_eq_A) { row = 2; }\n-  if (!X_exists &&  Y_exists           ) { row = 3; }\n-  if (!X_exists &&  Y_exists && !X_eq_A) { row = 4; }\n-  if ( X_exists &&  Y_exists &&  X_eq_A) { row = 5; }\n-\n-  \/\/ ************************************************************************************ Before loop\n+#ifdef ASSERT\n+  auto print_case = [&](int a = 1) {\n+    tty->print(\" req: %4d---%4d\", (int)_A, (int)_B);\n+    tty->print(\" row: %2d\", row);\n+    if (a) {\n+      tty->print(\" X: %4ld\", X_exists ? X->key() : -1);\n+      tty->print(\" Y: %4ld\", Y_exists ? Y->key() : -1);\n+      tty->print(\" W: %4ld\", W_exists ? W->key() : -1);\n+      tty->print(\" U: %4ld\", U_exists ? U->key() : -1);\n+    }\n+    tty->print_cr(\"\");\n+  };\n+#endif\n+  \/\/ Order of the nodes if they exist are as: X <= A < Y <= W <= B < U\n+  \/\/             A---------------------------B\n+  \/\/       X           Y          YW         WB          U\n+  \/\/       XA          Y          YW         WB          U\n+  if (!X_exists && !Y_exists                       && !U_exists) { row =  0; }\n+  if (!X_exists &&  Y_exists &&  Y_eq_W && !W_eq_B && !U_exists) { row =  1; }\n+  if (!X_exists &&  Y_exists && !Y_eq_W && !W_eq_B && !U_exists) { row =  2; }\n+  if (!X_exists &&  Y_exists &&             W_eq_B && !U_exists) { row =  3; }\n+\n+  if ( X_exists && !Y_exists                       && !U_exists) { row =  4; }\n+  if ( X_exists &&  Y_exists &&  Y_eq_W && !W_eq_B && !U_exists) { row =  5; }\n+  if ( X_exists &&  Y_exists && !Y_eq_W && !W_eq_B && !U_exists) { row =  6; }\n+  if ( X_exists &&  Y_exists &&             W_eq_B && !U_exists) { row =  7; }\n+\n+  if ( X_eq_A   && !Y_exists                       && !U_exists) { row =  8; }\n+  if ( X_eq_A   &&  Y_exists &&  Y_eq_W && !W_eq_B && !U_exists) { row =  9; }\n+  if ( X_eq_A   &&  Y_exists && !Y_eq_W && !W_eq_B && !U_exists) { row = 10; }\n+  if ( X_eq_A   &&  Y_exists &&             W_eq_B && !U_exists) { row = 11; }\n+\n+  if (!X_exists && !Y_exists                       &&  U_exists) { row = 12; }\n+  if (!X_exists &&  Y_exists &&  Y_eq_W && !W_eq_B &&  U_exists) { row = 13; }\n+  if (!X_exists &&  Y_exists && !Y_eq_W && !W_eq_B &&  U_exists) { row = 14; }\n+  if (!X_exists &&  Y_exists &&             W_eq_B &&  U_exists) { row = 15; }\n+\n+  if ( X_exists && !Y_exists                       &&  U_exists) { row = 16; }\n+  if ( X_exists &&  Y_exists &&  Y_eq_W && !W_eq_B &&  U_exists) { row = 17; }\n+  if ( X_exists &&  Y_exists && !Y_eq_W && !W_eq_B &&  U_exists) { row = 18; }\n+  if ( X_exists &&  Y_exists &&             W_eq_B &&  U_exists) { row = 19; }\n+\n+  if ( X_eq_A   && !Y_exists                       &&  U_exists) { row = 20; }\n+  if ( X_eq_A   &&  Y_exists &&  Y_eq_W && !W_eq_B &&  U_exists) { row = 21; }\n+  if ( X_eq_A   &&  Y_exists && !Y_eq_W && !W_eq_B &&  U_exists) { row = 22; }\n+  if ( X_eq_A   &&  Y_exists &&             W_eq_B &&  U_exists) { row = 23; }\n+\n+  DEBUG_ONLY(print_case();)\n@@ -257,2 +363,5 @@\n-    case 0:\n-      if (!stA.is_noop()) { _tree.upsert(A, stA); }\n+    \/\/ row  0:  .........A..................B.....\n+    case 0: {\n+      update_A(B);\n+      upsert_if(A);\n+      upsert_if(B);\n@@ -260,3 +369,8 @@\n-    case 1:\n-      stA.in = X->val().out;\n-      if (!stA.is_noop()) { _tree.upsert(A, stA); }\n+    }\n+    \/\/ row  1:  .........A...YW.............B.....\n+    case 1: {\n+      update_A(Y);\n+      upsert_if(A);\n+      update(W, B);\n+      remove_if(W);\n+      upsert_if(B);\n@@ -264,7 +378,10 @@\n-    case 2:\n-      stA.in = X->val().in;\n-      if (X->val().in.equals(stA.out)) {\n-        _tree.remove(X->key());\n-      } else {\n-        _tree.upsert(A, stA);\n-      }\n+    }\n+    \/\/ row  2:  .........A...Y..........W...B.....\n+    case 2: {\n+      update_A(Y);\n+      upsert_if(A);\n+      update_loop();\n+      remove_if(Y);\n+      update(W, B);\n+      remove_if(W);\n+      upsert_if(B);\n@@ -272,3 +389,8 @@\n-    case 3:\n-      update_region(&nA, Y, req, diff);\n-      if (!nA.val().is_noop()) { _tree.upsert(A, nA.val()); }\n+    }\n+    \/\/ row  3:  .........A...Y.............WB.....\n+    case 3: {\n+      update_A(Y);\n+      upsert_if(A);\n+      update(Y, W);\n+      remove_if(Y);\n+      remove_if(W);\n@@ -276,4 +398,7 @@\n-    case 4:\n-      stA.in = X->val().out;\n-      update_region(&nA, Y, req, diff);\n-      if (!nA.val().is_noop()) { _tree.upsert(A, nA.val()); }\n+    }\n+    \/\/ row  4:  .....X...A..................B.....\n+    case 4: {\n+      A->val().in = X->val().out;\n+      upsert_if(A);\n+      update(A, B);\n+      upsert_if(B);\n@@ -281,8 +406,9 @@\n-    case 5:\n-      stA.in = X->val().in;\n-      update_region(&nA, Y, req, diff);\n-      if (X->val().in.equals(stA.out)) {\n-        _tree.remove(X->key());\n-      } else {\n-        _tree.upsert(A, nA.val());\n-      }\n+    }\n+    \/\/ row  5:  .....X...A...YW.............B.....\n+    case 5: {\n+      A->val().in = X->val().out;\n+      update_A(Y);\n+      upsert_if(A);\n+      update(Y, B);\n+      remove_if(Y);\n+      upsert_if(B);\n@@ -290,1 +416,10 @@\n-    default:\n+    }\n+    \/\/ row  6:  .....X...A...Y..........W...B.....\n+    case 6: {\n+      A->val().in = X->val().out;\n+      update_A(Y);\n+      upsert_if(A);\n+      update_loop();\n+      update(W, B);\n+      remove_if(W);\n+      upsert_if(B);\n@@ -292,13 +427,0 @@\n-  }\n-\n-  \/\/ ************************************************************************************ Loop\n-  GrowableArrayCHeap<position, mtNMT> to_be_removed;\n-  TreapNode* prev = nullptr;\n-  _tree.visit_range_in_order(Y->key(), B + 1, [&](TreapNode* curr){\n-    if (prev != nullptr) {\n-      update_region(prev, curr, req, diff);\n-      \/\/ during visit, structure of the tree should not be changed\n-      \/\/ keep the keys to be removed, and remove them later\n-      if (prev->val().is_noop()) {\n-        to_be_removed.push(prev->key());\n-      }\n@@ -306,19 +428,7 @@\n-    prev = curr;\n-  });\n-\n-  \/\/ ************************************************************************************ After loop\n-  TreapNode* W = rB.start;\n-  TreapNode* U = rB.end;\n-  TreapNode nB{B, stB, 0}; \/\/ the node that represents B\n-  bool W_exists = W != nullptr;\n-  bool U_exists = U != nullptr;\n-  bool W_eq_B = W_exists && W->key() == B;\n-  if (!W_exists && !U_exists           ) { row = 6; }\n-  if (!W_exists &&  U_exists           ) { row = 7; }\n-  if ( W_exists && !U_exists && !W_eq_B) { row = 8; }\n-  if ( W_exists && !U_exists &&  W_eq_B) { row = 9; }\n-  if ( W_exists &&  U_exists && !W_eq_B) { row = 10; }\n-  if ( W_exists &&  U_exists &&  W_eq_B) { row = 11; }\n-  switch(row) {\n-    case 6:\n-      if (!stB.is_noop()) { _tree.upsert(B, stB); }\n+    \/\/ row  7:  .....X...A...Y.............WB.....\n+    case 7: {\n+      A->val().in = X->val().out;\n+      update_A(Y);\n+      upsert_if(A);\n+      update_loop();\n+      remove_if(W);\n@@ -326,3 +436,6 @@\n-    case 7:\n-      stB.out = U->val().in;\n-      if (!stB.is_noop()) { _tree.upsert(B, stB); }\n+    }\n+    \/\/ row  8:  ........XA..................B.....\n+    case 8: {\n+      update(X, B);\n+      remove_if(X);\n+      upsert_if(B);\n@@ -330,4 +443,8 @@\n-    case 8:\n-      update_region(W, &nB, req, diff);\n-      if (W->val().is_noop()) { _tree.remove(W->key()); }\n-      if (!nB.val().is_noop()) { _tree.upsert(B, nB.val()); }\n+    }\n+    \/\/ row  9:  ........XA...YW.............B.....\n+    case 9: {\n+      update(X, Y);\n+      remove_if(X);\n+      update(W, B);\n+      remove_if(W);\n+      upsert_if(B);\n@@ -335,6 +452,9 @@\n-    case 9:\n-      if (W->val().in.equals(stB.out)) {\n-        _tree.remove(W->key());\n-      } else {\n-        _tree.upsert(B, stB);\n-      }\n+    }\n+    \/\/ row 10:  ........XA...Y..........W...B.....\n+    case 10: {\n+      update(X, Y);\n+      remove_if(X);\n+      update_loop();\n+      update(W, B);\n+      remove_if(W);\n+      upsert_if(B);\n@@ -342,8 +462,7 @@\n-    case 10:\n-      stB.out = U->val().in;\n-      update_region(W, &nB, req, diff);\n-      if (W->val().in.equals(stB.out)) {\n-        _tree.remove(W->key());\n-      } else {\n-        _tree.upsert(B, stB);\n-      }\n+    }\n+    \/\/ row 11:  ........XA...Y.............WB.....\n+    case 11: {\n+      update(X, Y);\n+      remove_if(X);\n+      update_loop();\n+      remove_if(W);\n@@ -351,6 +470,6 @@\n-    case 11:\n-      if (W->val().in.equals(stB.out)) {\n-        _tree.remove(W->key());\n-      } else {\n-        _tree.upsert(B, stB);\n-      }\n+    }\n+    \/\/ row 12:  .........A..................B....U\n+    case 12: {\n+      update_A(B);\n+      upsert_if(A);\n+      upsert_if(B);\n@@ -358,1 +477,9 @@\n-    default:\n+    }\n+    \/\/ row 13:  .........A...YW.............B....U\n+    case 13: {\n+      update_A(Y);\n+      upsert_if(A);\n+      update(W, B);\n+      remove_if(W);\n+      B->val().out = U->val().in;\n+      upsert_if(B);\n@@ -360,52 +487,0 @@\n-  }\n-\n-\n-  \/\/ ************************************************************************************ Delete noop nodes found in the loop\n-  while(to_be_removed.length() != 0) {\n-    _tree.remove(to_be_removed.pop());\n-  }\n-\n-  return diff;\n-}\n-VMATree::SummaryDiff VMATree::register_mapping_new(position A, position B, StateType state,\n-                                                   const RegionData& metadata, bool use_tag_inplace) {\n-  assert(!use_tag_inplace || metadata.mem_tag == mtNone,\n-         \"If using use_tag_inplace, then the supplied tag should be mtNone, was instead: %s\", NMTUtil::tag_to_name(metadata.mem_tag));\n-  if (A == B) {\n-    \/\/ A 0-sized mapping isn't worth recording.\n-    return SummaryDiff();\n-  }\n-\n-  IntervalChange stA{\n-      IntervalState{StateType::Released, empty_regiondata},\n-      IntervalState{              state,   metadata}\n-  };\n-  IntervalChange stB{\n-      IntervalState{              state,   metadata},\n-      IntervalState{StateType::Released, empty_regiondata}\n-  };\n-\n-  bool is_reserve_operation = state == StateType::Reserved && !use_tag_inplace;\n-  bool is_uncommit_operation = state == StateType::Reserved && use_tag_inplace;\n-  bool is_commit_operation = state == StateType::Committed;\n-  stA.out.set_reserve_stack(NativeCallStackStorage::invalid);\n-  stB.in.set_reserve_stack(NativeCallStackStorage::invalid);\n-  stA.out.set_commit_stack(NativeCallStackStorage::invalid);\n-  stA.in.set_commit_stack(NativeCallStackStorage::invalid);\n-  if (is_reserve_operation) {\n-    stA.out.set_reserve_stack(metadata.stack_idx);\n-    stB.in.set_reserve_stack(metadata.stack_idx);\n-  }\n-  if (is_commit_operation) {\n-    stA.out.set_commit_stack(metadata.stack_idx);\n-    stB.in.set_commit_stack(metadata.stack_idx);\n-  }\n-  \/\/ First handle A.\n-  \/\/ Find closest node that is LEQ A\n-  bool LEQ_A_found = false;\n-  AddressState LEQ_A;\n-  TreapNode* leqA_n = _tree.closest_leq(A);\n-  if (leqA_n == nullptr) {\n-    assert(!use_tag_inplace, \"Cannot use the tag inplace if no pre-existing tag exists. From: \" PTR_FORMAT \" To: \" PTR_FORMAT, A, B);\n-    if (use_tag_inplace) {\n-      log_debug(nmt)(\"Cannot use the tag inplace if no pre-existing tag exists. From: \" PTR_FORMAT \" To: \" PTR_FORMAT, A, B);\n@@ -413,6 +488,10 @@\n-    stA.out.set_reserve_stack(metadata.stack_idx);\n-    stB.in.set_reserve_stack(metadata.stack_idx);\n-\n-    \/\/ No match. We add the A node directly, unless it would have no effect.\n-    if (!stA.is_noop()) {\n-      _tree.upsert(A, stA);\n+    \/\/ row 14:  .........A...Y..........W...B....U\n+    case 14: {\n+      update_A(Y);\n+      upsert_if(A);\n+      update_loop();\n+      update(W, B);\n+      remove_if(W);\n+      B->val().out = U->val().in;\n+      upsert_if(B);\n+      break;\n@@ -420,12 +499,7 @@\n-  } else {\n-    LEQ_A_found = true;\n-    LEQ_A = AddressState{leqA_n->key(), leqA_n->val()};\n-    StateType leqA_state = leqA_n->val().out.type();\n-    StateType new_state = stA.out.type();\n-    \/\/ If we specify use_tag_inplace then the new region takes over the current tag instead of the tag in metadata.\n-    \/\/ This is important because the VirtualMemoryTracker API doesn't require supplying the tag for some operations.\n-    if (use_tag_inplace) {\n-      assert(leqA_n->val().out.type() != StateType::Released, \"Should not use inplace the tag of a released region\");\n-      MemTag tag = leqA_n->val().out.mem_tag();\n-      stA.out.set_tag(tag);\n-      stB.in.set_tag(tag);\n+    \/\/ row 15:  .........A...Y.............WB....U\n+    case 15: {\n+      update_A(Y);\n+      upsert_if(A);\n+      update_loop();\n+      remove_if(W);\n+      break;\n@@ -433,65 +507,8 @@\n-\n-    \/\/ Unless we know better, let B's outgoing state be the outgoing state of the node at or preceding A.\n-    \/\/ Consider the case where the found node is the start of a region enclosing [A,B)\n-    stB.out = out_state(leqA_n);\n-\n-    \/\/ Direct address match.\n-    if (leqA_n->key() == A) {\n-      if (is_commit_operation) {\n-        if (leqA_n->val().out.has_reserved_stack()) {\n-          stA.out.set_reserve_stack(leqA_n->val().out.reserved_stack());\n-        } else {\n-          stA.out.set_reserve_stack(metadata.stack_idx);\n-        }\n-      }\n-      if (is_uncommit_operation) {\n-        stA.out.set_reserve_stack(leqA_n->val().out.reserved_stack());\n-        stA.out.set_commit_stack(NativeCallStackStorage::invalid);\n-      }\n-      \/\/ Take over in state from old address.\n-      stA.in = in_state(leqA_n);\n-\n-      \/\/ We may now be able to merge two regions:\n-      \/\/ If the node's old state matches the new, it becomes a noop. That happens, for example,\n-      \/\/ when expanding a committed area: commit [x1, A); ... commit [A, x3)\n-      \/\/ and the result should be a larger area, [x1, x3). In that case, the middle node (A and le_n)\n-      \/\/ is not needed anymore. So we just remove the old node.\n-      stB.in = stA.out;\n-      if (stA.is_noop()) {\n-        \/\/ invalidates leqA_n\n-        _tree.remove(leqA_n->key());\n-      } else {\n-        \/\/ If the state is not matching then we have different operations, such as:\n-        \/\/ reserve [x1, A); ... commit [A, x2); or\n-        \/\/ reserve [x1, A), mem_tag1; ... reserve [A, x2), mem_tag2; or\n-        \/\/ reserve [A, x1), mem_tag1; ... reserve [A, x2), mem_tag2;\n-        \/\/ then we re-use the existing out node, overwriting its old metadata.\n-        leqA_n->val() = stA;\n-      }\n-    } else {\n-      \/\/ The address must be smaller.\n-      assert(A > leqA_n->key(), \"must be\");\n-      if (is_commit_operation) {\n-        if (leqA_n->val().out.has_reserved_stack()) {\n-          stA.out.set_reserve_stack(leqA_n->val().out.reserved_stack());\n-          stB.in.set_reserve_stack(leqA_n->val().out.reserved_stack());\n-        } else {\n-          stA.out.set_reserve_stack(metadata.stack_idx);\n-          stB.in.set_reserve_stack(metadata.stack_idx);\n-        }\n-      }\n-      if (is_uncommit_operation) {\n-        stA.out.set_reserve_stack(leqA_n->val().out.reserved_stack());\n-        stB.in.set_reserve_stack(leqA_n->val().out.reserved_stack());\n-      }\n-\n-      \/\/ We add a new node, but only if there would be a state change. If there would not be a\n-      \/\/ state change, we just omit the node.\n-      \/\/ That happens, for example, when reserving within an already reserved region with identical metadata.\n-      stA.in = out_state(leqA_n); \/\/ .. and the region's prior state is the incoming state\n-      if (stA.is_noop()) {\n-        \/\/ Nothing to do.\n-      } else {\n-        \/\/ Add new node.\n-        _tree.upsert(A, stA);\n-      }\n+    \/\/ row 16:  .....X...A..................B....U\n+    case 16: {\n+      A->val().in = X->val().out;\n+      update_A(B);\n+      upsert_if(A);\n+      B->val().out = U->val().in;\n+      upsert_if(B);\n+      break;\n@@ -499,26 +516,10 @@\n-  }\n-\n-  \/\/ Now we handle B.\n-  \/\/ We first search all nodes that are (A, B]. All of these nodes\n-  \/\/ need to be deleted and summary accounted for. The last node before B determines B's outgoing state.\n-  \/\/ If there is no node between A and B, its A's incoming state.\n-  GrowableArrayCHeap<AddressState, mtNMT> to_be_deleted_inbetween_a_b;\n-  bool B_needs_insert = true;\n-\n-  \/\/ Find all nodes between (A, B] and record their addresses and values. Also update B's\n-  \/\/ outgoing state.\n-  _tree.visit_range_in_order(A + 1, B + 1, [&](TreapNode* head) {\n-    int cmp_B = PositionComparator::cmp(head->key(), B);\n-    stB.out = out_state(head);\n-    if (cmp_B < 0) {\n-      \/\/ Record all nodes preceding B.\n-      to_be_deleted_inbetween_a_b.push({head->key(), head->val()});\n-    } else if (cmp_B == 0) {\n-      \/\/ Re-purpose B node, unless it would result in a noop node, in\n-      \/\/ which case record old node at B for deletion and summary accounting.\n-      if (stB.is_noop()) {\n-        to_be_deleted_inbetween_a_b.push(AddressState{B, head->val()});\n-      } else {\n-        head->val() = stB;\n-      }\n-      B_needs_insert = false;\n+    \/\/ row 17:  .....X...A...YW.............B....U\n+    case 17: {\n+      A->val().in = X->val().out;\n+      update_A(Y);\n+      upsert_if(A);\n+      update(W, B);\n+      remove_if(W);\n+      B->val().out = U->val().in;\n+      upsert_if(B);\n+      break;\n@@ -526,23 +527,11 @@\n-  });\n-\n-  \/\/ Insert B node if needed\n-  if (B_needs_insert && \/\/ Was not already inserted\n-      !stB.is_noop())   \/\/ The operation is differing\n-    {\n-    _tree.upsert(B, stB);\n-  }\n-\n-  \/\/ We now need to:\n-  \/\/ a) Delete all nodes between (A, B]. Including B in the case of a noop.\n-  \/\/ b) Perform summary accounting\n-  SummaryDiff diff;\n-\n-  if (to_be_deleted_inbetween_a_b.length() == 0 && LEQ_A_found) {\n-    \/\/ We must have smashed a hole in an existing region (or replaced it entirely).\n-    \/\/ LEQ_A < A < B <= C\n-    SingleDiff& rescom = diff.tag[NMTUtil::tag_to_index(LEQ_A.out().mem_tag())];\n-    if (LEQ_A.out().type() == StateType::Reserved) {\n-      rescom.reserve -= B - A;\n-    } else if (LEQ_A.out().type() == StateType::Committed) {\n-      rescom.commit -= B - A;\n-      rescom.reserve -= B - A;\n+    \/\/ row 18:  .....X...A...Y..........W...B....U\n+    case 18: {\n+      A->val().in = X->val().out;\n+      update_A(Y);\n+      upsert_if(A);\n+      update_loop();\n+      update(W, B);\n+      remove_if(W);\n+      B->val().out = U->val().in;\n+      upsert_if(B);\n+      break;\n@@ -550,15 +539,8 @@\n-  }\n-\n-  \/\/ Track the previous node.\n-  AddressState prev{A, stA};\n-  for (int i = 0; i < to_be_deleted_inbetween_a_b.length(); i++) {\n-    const AddressState delete_me = to_be_deleted_inbetween_a_b.at(i);\n-    _tree.remove(delete_me.address);\n-\n-    \/\/ Perform summary accounting\n-    SingleDiff& rescom = diff.tag[NMTUtil::tag_to_index(delete_me.in().mem_tag())];\n-    if (delete_me.in().type() == StateType::Reserved) {\n-      rescom.reserve -= delete_me.address - prev.address;\n-    } else if (delete_me.in().type() == StateType::Committed) {\n-      rescom.commit -= delete_me.address - prev.address;\n-      rescom.reserve -= delete_me.address - prev.address;\n+    \/\/ row 19:  .....X...A...Y.............WB....U\n+    case 19: {\n+      A->val().in = X->val().out;\n+      update_A(Y);\n+      upsert_if(A);\n+      update_loop();\n+      remove_if(W);\n+      break;\n@@ -566,14 +548,7 @@\n-    prev = delete_me;\n-  }\n-\n-  if (prev.address != A && prev.out().type() != StateType::Released) {\n-    \/\/ The last node wasn't released, so it must be connected to a node outside of (A, B)\n-    \/\/ A - prev - B - (some node >= B)\n-    \/\/ It might be that prev.address == B == (some node >= B), this is fine.\n-    if (prev.out().type() == StateType::Reserved) {\n-      SingleDiff& rescom = diff.tag[NMTUtil::tag_to_index(prev.out().mem_tag())];\n-      rescom.reserve -= B - prev.address;\n-    } else if (prev.out().type() == StateType::Committed) {\n-      SingleDiff& rescom = diff.tag[NMTUtil::tag_to_index(prev.out().mem_tag())];\n-      rescom.commit -= B - prev.address;\n-      rescom.reserve -= B - prev.address;\n+    \/\/ row 20:  ........XA..................B....U\n+    case 20: {\n+      update(X, B);\n+      remove_if(X);\n+      B->val().out = U->val().in;\n+      upsert_if(B);\n+      break;\n@@ -581,0 +556,31 @@\n+    \/\/ row 21:  ........XA...YW.............B....U\n+    case 21: {\n+      update(X, Y);\n+      remove_if(X);\n+      update(W, B);\n+      remove_if(W);\n+      B->val().out = U->val().in;\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row 22:  ........XA...Y..........W...B....U\n+    case 22: {\n+      update(X, Y);\n+      remove_if(X);\n+      update_loop();\n+      update(W, B);\n+      remove_if(W);\n+      B->val().out = U->val().in;\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row 23:  ........XA...Y.............WB....U\n+    case 23: {\n+      update(X, Y);\n+      remove_if(X);\n+      update_loop();\n+      remove_if(W);\n+      break;\n+    }\n+    default:\n+      ShouldNotReachHere();\n@@ -583,7 +589,3 @@\n-  \/\/ Finally, we can register the new region [A, B)'s summary data.\n-  SingleDiff& rescom = diff.tag[NMTUtil::tag_to_index(stA.out.mem_tag())];\n-  if (state == StateType::Reserved) {\n-    rescom.reserve += B - A;\n-  } else if (state == StateType::Committed) {\n-    rescom.commit += B - A;\n-    rescom.reserve += B - A;\n+  \/\/ ************************************************************************************ Remove the 'noop' nodes that found inside the loop\n+  while(to_be_removed.length() != 0) {\n+    _tree.remove(to_be_removed.pop());\n@@ -591,0 +593,1 @@\n+\n@@ -597,2 +600,8 @@\n-    out->print(\"%zu (%s) - %s [%d, %d]- \", current->key(), NMTUtil::tag_to_name(out_state(current).mem_tag()),\n-               statetype_to_string(out_state(current).type()), current->val().out.reserved_stack(), current->val().out.committed_stack());\n+    if (current->val().out.has_committed_stack()) {\n+      out->print(\"%zu (%s) - %s [%d, %d]-> \", current->key(), NMTUtil::tag_to_name(out_state(current).mem_tag()),\n+                statetype_to_string(out_state(current).type()), current->val().out.reserved_stack(), current->val().out.committed_stack());\n+    } else {\n+      out->print(\"%zu (%s) - %s [%d, --]-> \", current->key(), NMTUtil::tag_to_name(out_state(current).mem_tag()),\n+                statetype_to_string(out_state(current).type()), current->val().out.reserved_stack());\n+\n+    }\n","filename":"src\/hotspot\/share\/nmt\/vmatree.cpp","additions":373,"deletions":364,"binary":false,"changes":737,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-  enum class StateType : uint8_t { Reserved, Committed, Released, LAST };\n+  enum class StateType : uint8_t { Released, Reserved, Committed, LAST };\n@@ -254,1 +254,0 @@\n-  SummaryDiff register_mapping_new(position A, position B, StateType state, const RegionData& metadata, bool use_tag_inplace = false);\n","filename":"src\/hotspot\/share\/nmt\/vmatree.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -106,0 +106,5 @@\n+    \/\/                      900---1000\n+    \/\/                 800--900\n+    \/\/            700--800\n+    \/\/        ...\n+    \/\/ 0--100\n@@ -179,1 +184,0 @@\n-  return;\n@@ -187,1 +191,1 @@\n-TEST_VM_F(NMTVMATreeTest, UseFlagInplace) {\n+TEST_VM_F(NMTVMATreeTest, UseTagInplace) {\n@@ -192,0 +196,4 @@\n+  \/\/ reserve:   0---------------------100\n+  \/\/ commit:        20**********70\n+  \/\/ uncommit:          30--40\n+  \/\/ post-cond: 0---20**30--40**70----100\n@@ -319,2 +327,2 @@\n-      EXPECT_EQ(expect.tag, found.start->val().out.mem_tag());\n-      EXPECT_EQ(expect.tag, found.end->val().in.mem_tag());\n+      EXPECT_EQ(expect.tag, found.start->val().out.mem_tag()) << \" and at test-line: \" << line_no;\n+      EXPECT_EQ(expect.tag, found.end->val().in.mem_tag()) << \" and at test-line: \" << line_no;\n@@ -363,0 +371,7 @@\n+    \/\/ 0---------------------------------------------------600\n+    \/\/        100****225\n+    \/\/                           550***560\n+    \/\/                                       565***575\n+    \/\/ 0------100****225---------550***560---565***575-----600\n+    \/\/ 0------100****225---500---550***560---565***575-----600\n+    \/\/ <-------mtGC---------><-----------mtClassShared------->\n@@ -629,0 +644,2 @@\n+  tty->print_cr(\"Skipped\");\n+  return;\n@@ -748,1 +765,1 @@\n-TEST_VM_F(NMTVMATreeTest, SummaryAccountingWhenUseFlagInplace) {\n+TEST_VM_F(NMTVMATreeTest, SummaryAccountingWhenUseTagInplace) {\n@@ -1072,1 +1089,0 @@\n-  const bool ok_to_run = false;\n@@ -1136,2 +1152,1 @@\n-    \/\/ 8354115\n-    if (ok_to_run) tree.uncommit_mapping(100, 150, call_stack_2);\n+    tree.uncommit_mapping(100, 150, call_stack_2);\n@@ -1142,9 +1157,9 @@\n-    \/\/ Post: ........0--------100????????????????200?????????????250--------300********400........\n-    \/\/        mtNone   mtTest                 mtTest                 mtTest     mtTest     mtNone\n-    \/\/        Rl       Rs                     Rs                     Rs         C          Rl\n-    \/\/        -        si_1                   si_2                   si_1       si_1       -\n-    \/\/        -        -                      -                      -          si_1       -\n-    ExpectedTree<5> et = {{     0,    100,    250,    300,    400         },\n-                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtNone },\n-                          {Rl    , Rs    , Rs    , Rs    , C     , Rl     },\n-                          {-1    , si_1  , si_2  , si_1  , si_1  , -1     },\n+    \/\/ Post: ........0--------100................200------------------------300********400........\n+    \/\/        mtNone   mtTest         mtNone               mtTest               mtTest     mtNone\n+    \/\/        Rl       Rs             Rl                   Rs                   C          Rl\n+    \/\/        -        si_1           -                    si_1                 si_1       -\n+    \/\/        -        -              -                    -                    si_1       -\n+    ExpectedTree<5> et = {{     0,    100,    200,    300,    400         },\n+                          {mtNone, mtTest, mtNone, mtTest, mtTest, mtNone },\n+                          {Rl    , Rs    , Rl    , Rs    , C     , Rl     },\n+                          {-1    , si_1  , -1    , si_1  , si_1  , -1     },\n@@ -1152,1 +1167,1 @@\n-    if (ok_to_run) check_tree(tree, et, __LINE__);\n+    check_tree(tree, et, __LINE__);\n@@ -1234,11 +1249,11 @@\n-    \/\/ Post: ........0--------100----------------200-------------250--------300********400........\n-    \/\/        mtNone   mtTest        mtTest             mtTest       mtTest     mtTest     mtNone\n-    \/\/        Rl       Rs            Rs                 Rs           Rs         C          Rl\n-    \/\/        -        si_1          si_2               si_1         si_1       si_1       -\n-    \/\/        -        -             -                  -            -          si_1       -\n-    ExpectedTree<6> et = {{     0,    100,    200,    250,    300,    400         },\n-                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone },\n-                          {Rl    , Rs    , Rs    , Rs    , Rs    , C     , Rl     },\n-                          {-1    , si_1  , si_2  , si_1  , si_1  , si_1  , -1     },\n-                          {-1    , -1    , -1    , -1    , -1    , si_1  , -1     }};\n-    if (ok_to_run) check_tree(tree, et, __LINE__);\n+    \/\/ Post: ........0--------100----------------200------------------------300********400........\n+    \/\/        mtNone   mtTest        mtTest             mtTest                  mtTest     mtNone\n+    \/\/        Rl       Rs            Rs                 Rs                      C          Rl\n+    \/\/        -        si_1          si_2               si_1                    si_1       -\n+    \/\/        -        -             -                  -                       si_1       -\n+    ExpectedTree<5> et = {{     0,    100,    200,    300,    400         },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtNone },\n+                          {Rl    , Rs    , Rs    , Rs    , C     , Rl     },\n+                          {-1    , si_1  , si_2  , si_1  , si_1  , -1     },\n+                          {-1    , -1    , -1    , -1    , si_1  , -1     }};\n+    check_tree(tree, et, __LINE__);\n@@ -1366,1 +1381,0 @@\n-  const bool ok_to_run = false;\n@@ -1430,2 +1444,1 @@\n-    if (ok_to_run) tree.uncommit_mapping(150, 100, call_stack_2);\n-    \/\/ To be re-written after 8354115\n+    tree.uncommit_mapping(150, 100, call_stack_2);\n@@ -1434,11 +1447,11 @@\n-    \/\/ Post: ........0--------100........150----------------250------------300********400........\n-    \/\/        mtNone   mtTest     mtNone         mtTest           mtTest       mtTest     mtNone\n-    \/\/        Rl       Rs         Rl             Rs               Rs           C          Rl\n-    \/\/        -        si_1       -              si_2             si_1         si_1       -\n-    \/\/        -        -          -              -                -            si_1       -\n-    ExpectedTree<6> et = {{     0,    100,    150,    250,    300,   400          },\n-                          {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtNone },\n-                          {Rl    , Rs    , Rl    , Rs    , Rs    , C     , Rl     },\n-                          {-1    , si_1  , -1    , si_2  , si_1  , si_1  , -1     },\n-                          {-1    , -1    , -1    , -1    , -1    , si_1  , -1     }};\n-    if (ok_to_run) check_tree(tree, et, __LINE__);\n+    \/\/ Post: ........0--------100................200-----------------------300********400........\n+    \/\/        mtNone   mtTest       mtNone                 mtTest              mtTest     mtNone\n+    \/\/        Rl       Rs           Rl                     Rs                  C          Rl\n+    \/\/        -        si_1         -                      si_1                si_1       -\n+    \/\/        -        -            -                      -                   si_1       -\n+    ExpectedTree<5> et = {{     0,    100,    200,    300,   400          },\n+                          {mtNone, mtTest, mtNone, mtTest, mtTest, mtNone },\n+                          {Rl    , Rs    , Rl    , Rs    , C     , Rl     },\n+                          {-1    , si_1  , -1    , si_1  , si_1  , -1     },\n+                          {-1    , -1    , -1    , -1    , si_1  , -1     }};\n+    check_tree(tree, et, __LINE__);\n@@ -1515,1 +1528,1 @@\n-    if (ok_to_run) check_tree(tree, et, __LINE__);\n+    check_tree(tree, et, __LINE__);\n@@ -1540,1 +1553,1 @@\n-    if (ok_to_run) check_tree(tree, et, __LINE__);\n+    check_tree(tree, et, __LINE__);\n@@ -1662,1 +1675,0 @@\n-  const bool ok_to_run = false;\n@@ -1793,1 +1805,1 @@\n-    if (ok_to_run) check_tree(tree, et, __LINE__);\n+    check_tree(tree, et, __LINE__);\n","filename":"test\/hotspot\/gtest\/nmt\/test_vmatree.cpp","additions":59,"deletions":47,"binary":false,"changes":106,"status":"modified"}]}