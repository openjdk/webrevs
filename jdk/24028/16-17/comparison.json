{"files":[{"patch":"@@ -34,1 +34,1 @@\n-  \"reserved\", \"committed\", \"released\",\n+  \"released\", \"reserved\", \"committed\"\n@@ -37,2 +37,1 @@\n-NativeCallStackStorage::StackIndex VMATree::get_new_reserve_callstack(NativeCallStackStorage::StackIndex es, StateType ex, const RequestInfo& req){\n-  using SIndex = NativeCallStackStorage::StackIndex;\n+VMATree::SIndex VMATree::get_new_reserve_callstack(const SIndex es, const StateType ex, const RequestInfo& req) const {\n@@ -41,6 +40,0 @@\n-  auto st_to_index = [&](StateType st) -> int {\n-    return\n-      st == StateType::Released ? 0 :\n-      st == StateType::Reserved ? 1 :\n-      st == StateType::Committed ? 2 : -1;\n-  };\n@@ -59,1 +52,1 @@\n-    return result[op][st_to_index(ex)];\n+    return result[op][state_to_index(ex)];\n@@ -63,2 +56,1 @@\n-NativeCallStackStorage::StackIndex VMATree::get_new_commit_callstack(NativeCallStackStorage::StackIndex es, StateType ex, const RequestInfo& req){\n-  using SIndex = NativeCallStackStorage::StackIndex;\n+VMATree::SIndex VMATree::get_new_commit_callstack(const SIndex es, const StateType ex, const RequestInfo& req) const {\n@@ -67,6 +59,0 @@\n-  auto st_to_index = [&](StateType st) -> int {\n-    return\n-      st == StateType::Released ? 0 :\n-      st == StateType::Reserved ? 1 :\n-      st == StateType::Committed ? 2 : -1;\n-  };\n@@ -75,1 +61,1 @@\n-                            \/\/ existing state\n+                         \/\/ existing state\n@@ -81,2 +67,2 @@\n-                           };\n-  return result[op][st_to_index(ex)];\n+                        };\n+  return result[op][state_to_index(ex)];\n@@ -85,1 +71,1 @@\n-VMATree::StateType VMATree::get_new_state(StateType ex, const RequestInfo& req) {\n+VMATree::StateType VMATree::get_new_state(const StateType ex, const RequestInfo& req) const {\n@@ -89,6 +75,0 @@\n-  auto st_to_index = [&](StateType st) -> int {\n-    return\n-      st == StateType::Released ? 0 :\n-      st == StateType::Reserved ? 1 :\n-      st == StateType::Committed ? 2 : -1;\n-  };\n@@ -104,1 +84,1 @@\n-  return result[op][st_to_index(ex)];\n+  return result[op][state_to_index(ex)];\n@@ -107,1 +87,6 @@\n-void VMATree::compute_summary_diff(SingleDiff::delta region_size, MemTag t1, const StateType& ex, const RequestInfo& req, MemTag t2, SummaryDiff& diff) {\n+void VMATree::compute_summary_diff(const SingleDiff::delta region_size,\n+                                   const MemTag t1,\n+                                   const StateType& ex,\n+                                   const RequestInfo& req,\n+                                   const MemTag t2,\n+                                   SummaryDiff& diff) const {\n@@ -111,6 +96,0 @@\n-  auto st_to_index = [&](StateType st) -> int {\n-    return\n-      st == StateType::Released ? 0 :\n-      st == StateType::Reserved ? 1 :\n-      st == StateType::Committed ? 2 : -1;\n-  };\n@@ -138,4 +117,4 @@\n-                                        {0,0,  0,0, -a,0 },   \/\/ op == Release\n-                                        {0,a,  0,a, -a,0 },   \/\/ op == Reserve\n-                                        {0,a,  0,a, -a,a },   \/\/ op == Commit\n-                                        {0,0,  0,0, -a,0 }    \/\/ op == Uncommit\n+                                        {0,0,  0,0, -a,0 },    \/\/ op == Release\n+                                        {0,a,  0,a, -a,0 },    \/\/ op == Reserve\n+                                        {0,a,  0,a, -a,a },    \/\/ op == Commit\n+                                        {0,0,  0,0, -a,0 }     \/\/ op == Uncommit\n@@ -145,1 +124,1 @@\n-  int st = st_to_index(ex);\n+  int st = state_to_index(ex);\n@@ -152,1 +131,3 @@\n-\n+\/\/ update the region state between n1 and n2. Since n1 and n2 are pointers, any update of them will be visible from tree.\n+\/\/ If n1 is noop, it can be removed because its left region (n1->val().in) is already decided and its right state (n1->val().out) is decided here.\n+\/\/ The state of right of n2 (n2->val().out) cannot be decided here yet.\n@@ -154,1 +135,3 @@\n-  using SIndex = NativeCallStackStorage::StackIndex;\n+  \/\/.........n1......n2......\n+  \/\/          ^------^\n+  \/\/             |\n@@ -168,1 +151,1 @@\n-  SIndex    new_committ_callstack       = get_new_commit_callstack(existing_commit_callstack, existing_state, req);\n+  SIndex    new_commit_callstack        = get_new_commit_callstack(existing_commit_callstack, existing_state, req);\n@@ -170,0 +153,2 @@\n+  \/\/  n1........n2\n+  \/\/ out-->\n@@ -173,1 +158,1 @@\n-  n1->val().out.set_commit_stack(new_committ_callstack);\n+  n1->val().out.set_commit_stack(new_commit_callstack);\n@@ -175,0 +160,2 @@\n+  \/\/  n1........n2\n+  \/\/         <--in\n@@ -178,1 +165,1 @@\n-  n2->val().in.set_commit_stack(new_committ_callstack);\n+  n2->val().in.set_commit_stack(new_commit_callstack);\n@@ -184,1 +171,0 @@\n-\n@@ -202,39 +188,0 @@\n-  auto upsert_if= [&](TreapNode* node) {\n-    if (!node->val().is_noop()) {\n-      _tree.upsert(node->key(), node->val());\n-    }\n-  };\n-  auto update = [&](TreapNode* n1, TreapNode* n2) {\n-    update_region(n1, n2, req, diff);\n-  };\n-  auto remove_if = [&](TreapNode* node) -> bool{\n-    if (node->val().is_noop()) {\n-      _tree.remove(node->key());\n-      return true;\n-    }\n-    return false;\n-  };\n-  GrowableArrayCHeap<position, mtNMT> to_be_removed;\n-  \/\/ update regions in [Y,W)\n-  auto update_loop = [&]() {\n-    \/*(S,F)\n-    n1 = S\n-    while(n2 != F) {\n-      n2=gt(n1);\n-      update(n1,n2);\n-      n1=n2;\n-    }\n-    *\/\n-    TreapNode* prev = nullptr;\n-    _tree.visit_range_in_order(_A + 1, _B + 1, [&](TreapNode* curr) {\n-      if (prev != nullptr) {\n-        update_region(prev, curr, req, diff);\n-        \/\/ during visit, structure of the tree should not be changed\n-        \/\/ keep the keys to be removed, and remove them later\n-        if (prev->val().is_noop()) {\n-          to_be_removed.push(prev->key());\n-        }\n-      }\n-      prev = curr;\n-    });\n-  };\n@@ -245,0 +192,1 @@\n+\n@@ -253,2 +201,7 @@\n-  \/\/ The regons in [Y,W) are updated in a loop. We update X..A..Y before the loop and W..B..U after the loop.\n-  \/\/ The table below summarizes the overlap cases.\n+  \/\/ Y: is the closest node greater than A, but less than B\n+  \/\/ W: is the closest node less than B, but greater than A\n+  \/\/ The regions in [Y,W) are updated in a loop. We update X..A..Y before the loop and W..B..U after the loop.\n+  \/\/ The table below summarizes the overlap cases. The overlapping case depends on whether X, Y, W and U exist or not,\n+  \/\/ and if they exist whether they are the same or not.\n+  \/\/ In the notations here, when there is not dot ('.') between two nodes it meaans that they are the same. For example,\n+  \/\/ ...XA....Y.... means X == A.\n@@ -258,1 +211,1 @@\n-  \/\/ row  1:  .........A...YW.............B.....\n+  \/\/ row  1:  .........A...YW.............B.....  \/\/ it is impossible, since it means only one node exists in the tree.\n@@ -289,3 +242,6 @@\n-  \/\/ This expanded way of describing the cases helps us to understand\/analyze\/verify\/debug\/maintain the corresponding code more easily.\n-  \/\/ Mapping of table to row, row to switch-case should be consistent. If one changes, the others have to be updated accordingly.\n-  \/\/ The sequence of dependecies is: table -> row no -> switch(row)-case -> code. Meaning that whenever any of one item in this sequence is changed, the rest of the consequent items to be checked\/changed.\n+  \/\/ This expanded way of describing the cases helps us to understand\/analyze\/verify\/debug\/maintain\n+  \/\/ the corresponding code more easily.\n+  \/\/ Mapping of table to row, row to switch-case should be consistent. If one changes, the others have\n+  \/\/ to be updated accordingly. The sequence of dependecies is: table -> row no -> switch(row)-case -> code.\n+  \/\/ Meaning that whenever any of one item in this sequence is changed, the rest of the consequent items to\n+  \/\/ be checked\/changed.\n@@ -301,0 +257,32 @@\n+  auto upsert_if= [&](TreapNode* node) {\n+    if (!node->val().is_noop()) {\n+      _tree.upsert(node->key(), node->val());\n+    }\n+  };\n+  \/\/ update region between n1 and n2\n+  auto update = [&](TreapNode* n1, TreapNode* n2) {\n+    update_region(n1, n2, req, diff);\n+  };\n+  auto remove_if = [&](TreapNode* node) -> bool{\n+    if (node->val().is_noop()) {\n+      _tree.remove(node->key());\n+      return true;\n+    }\n+    return false;\n+  };\n+  GrowableArrayCHeap<position, mtNMT> to_be_removed;\n+  \/\/ update regions in [Y,W)\n+  auto update_loop = [&]() {\n+    TreapNode* prev = nullptr;\n+    _tree.visit_range_in_order(_A + 1, _B + 1, [&](TreapNode* curr) {\n+      if (prev != nullptr) {\n+        update_region(prev, curr, req, diff);\n+        \/\/ during visit, structure of the tree should not be changed\n+        \/\/ keep the keys to be removed, and remove them later\n+        if (prev->val().is_noop()) {\n+          to_be_removed.push(prev->key());\n+        }\n+      }\n+      prev = curr;\n+    });\n+  };\n@@ -372,5 +360,1 @@\n-      update_A(Y);\n-      upsert_if(A);\n-      update(W, B);\n-      remove_if(W);\n-      upsert_if(B);\n+      ShouldNotReachHere();\n@@ -394,2 +378,1 @@\n-      update(Y, W);\n-      remove_if(Y);\n+      update_loop();\n@@ -402,0 +385,1 @@\n+      update_A(B);\n@@ -403,1 +387,0 @@\n-      update(A, B);\n","filename":"src\/hotspot\/share\/nmt\/vmatree.cpp","additions":83,"deletions":100,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+  using SIndex = NativeCallStackStorage::StackIndex;\n@@ -73,1 +74,1 @@\n-    const NativeCallStackStorage::StackIndex stack_idx;\n+    const SIndex stack_idx;\n@@ -78,1 +79,1 @@\n-    RegionData(NativeCallStackStorage::StackIndex stack_idx, MemTag mem_tag)\n+    RegionData(SIndex stack_idx, MemTag mem_tag)\n@@ -212,1 +213,1 @@\n-    NativeCallStackStorage::StackIndex callstack;\n+    SIndex callstack;\n@@ -254,4 +255,4 @@\n-  StateType get_new_state(StateType existinting_state, const RequestInfo& req);\n-  NativeCallStackStorage::StackIndex get_new_reserve_callstack(NativeCallStackStorage::StackIndex existinting_stack, StateType ex, const RequestInfo& req);\n-  NativeCallStackStorage::StackIndex get_new_commit_callstack(NativeCallStackStorage::StackIndex existinting_stack, StateType ex, const RequestInfo& req);\n-  void compute_summary_diff(SingleDiff::delta region_size, MemTag t1, const StateType& ex, const RequestInfo& req, MemTag new_tag, SummaryDiff& diff);\n+  StateType get_new_state(const StateType existinting_state, const RequestInfo& req) const;\n+  SIndex get_new_reserve_callstack(const SIndex existinting_stack, const StateType ex, const RequestInfo& req) const;\n+  SIndex get_new_commit_callstack(const SIndex existinting_stack, const StateType ex, const RequestInfo& req) const;\n+  void compute_summary_diff(const SingleDiff::delta region_size, const MemTag t1, const StateType& ex, const RequestInfo& req, const MemTag new_tag, SummaryDiff& diff) const;\n@@ -259,0 +260,6 @@\n+  int state_to_index(const StateType st) const {\n+    return\n+      st == StateType::Released ? 0 :\n+      st == StateType::Reserved ? 1 :\n+      st == StateType::Committed ? 2 : -1;\n+  }\n","filename":"src\/hotspot\/share\/nmt\/vmatree.hpp","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -179,0 +179,84 @@\n+  template<int NodeCount> struct ExpectedTree {\n+    int nodes[NodeCount];\n+    MemTag tags[NodeCount + 1];\n+    VMATree::StateType states[NodeCount + 1];\n+    NativeCallStackStorage::StackIndex res_si[NodeCount + 1];\n+    NativeCallStackStorage::StackIndex com_si[NodeCount + 1];\n+  };\n+\n+  template<int N>\n+  void create_tree(Tree& tree, ExpectedTree<N>& et) {\n+    using SIndex = NativeCallStackStorage::StackIndex;\n+    const SIndex ES = NativeCallStackStorage::invalid; \/\/ Empty Stack\n+    VMATree::IntervalChange st;\n+    for (int i = 0; i < N; i++) {\n+      st.in.set_type(et.states[i]);\n+      st.in.set_tag(et.tags[i]);\n+      if (et.res_si[i] >= 0)\n+        st.in.set_reserve_stack(et.res_si[i]);\n+      else\n+        st.in.set_reserve_stack(ES);\n+      if (et.com_si[i] >= 0)\n+        st.in.set_commit_stack(et.com_si[i]);\n+      else\n+        st.in.set_commit_stack(ES);\n+\n+      st.out.set_type(et.states[i+1]);\n+      st.out.set_tag(et.tags[i+1]);\n+      if (et.res_si[i+1] >= 0)\n+        st.out.set_reserve_stack(et.res_si[i+1]);\n+      else\n+        st.out.set_reserve_stack(ES);\n+      if (et.com_si[i+1] >= 0)\n+        st.out.set_commit_stack(et.com_si[i+1]);\n+      else\n+        st.out.set_commit_stack(ES);\n+      tree.tree().upsert((VMATree::position)et.nodes[i], st);\n+    }\n+}\n+\n+  template <int N>\n+  void check_tree(Tree& tree,const ExpectedTree<N>& et, int line_no) {\n+    using Node = VMATree::TreapNode;\n+    auto left_released = [&](Node n) -> bool {\n+      return n.val().in.type() == VMATree::StateType::Released and\n+            n.val().in.mem_tag() == mtNone;\n+    };\n+    auto right_released = [&](Node n) -> bool {\n+      return n.val().out.type() == VMATree::StateType::Released and\n+            n.val().out.mem_tag() == mtNone;\n+    };\n+    for (int i = 0; i < N; i++) {\n+      VMATree::VMATreap::Range r = tree.tree().find_enclosing_range(et.nodes[i]);\n+      ASSERT_TRUE(r.start != nullptr);\n+      Node node = *r.start;\n+      ASSERT_EQ(node.key(), (VMATree::position)et.nodes[i]) << \"at line \" << line_no;\n+      if (i == (N -1)) { \/\/ last node\n+        EXPECT_TRUE(right_released(node)) << \"right-of last node is not Released\";\n+        break;\n+      }\n+      if (i == 0) { \/\/ first node\n+        EXPECT_TRUE(left_released(node)) << \"left-of first node is not Released\";\n+      }\n+      stringStream ss(50);\n+      ss.print(\"test at line: %d, for node: %d\", line_no, et.nodes[i]);\n+      const char* for_this_node = ss.base();\n+      EXPECT_EQ(node.val().out.type(), et.states[i+1]) << for_this_node;\n+      EXPECT_EQ(node.val().out.mem_tag(), et.tags[i+1]) << for_this_node;\n+      if (et.res_si[i+1] >= 0) {\n+        EXPECT_EQ(node.val().out.reserved_stack(), et.res_si[i+1]) << for_this_node;\n+        EXPECT_EQ(r.end->val().in.reserved_stack(), et.res_si[i+1]) << for_this_node;\n+      } else {\n+        EXPECT_FALSE(node.val().out.has_reserved_stack()) << for_this_node;\n+        EXPECT_FALSE(r.end->val().in.has_reserved_stack()) << for_this_node;\n+      }\n+      if (et.com_si[i+1] >= 0) {\n+        EXPECT_EQ(node.val().out.committed_stack(), et.com_si[i+1]) << for_this_node;\n+        EXPECT_EQ(r.end->val().in.committed_stack(), et.com_si[i+1]) << for_this_node;\n+      } else {\n+        EXPECT_FALSE(node.val().out.has_committed_stack()) << for_this_node;\n+        EXPECT_FALSE(r.end->val().in.has_committed_stack()) << for_this_node;\n+      }\n+    }\n+  }\n+\n@@ -781,52 +865,0 @@\n-template<int NodeCount> struct ExpectedTree {\n-  int nodes[NodeCount];\n-  MemTag tags[NodeCount + 1];\n-  VMATree::StateType states[NodeCount + 1];\n-  NativeCallStackStorage::StackIndex res_si[NodeCount + 1];\n-  NativeCallStackStorage::StackIndex com_si[NodeCount + 1];\n-};\n-template <int N>\n-void check_tree(Tree& tree,const ExpectedTree<N>& et, int line_no) {\n-  using Node = VMATree::TreapNode;\n-  auto left_released = [&](Node n) -> bool {\n-    return n.val().in.type() == VMATree::StateType::Released and\n-           n.val().in.mem_tag() == mtNone;\n-  };\n-  auto right_released = [&](Node n) -> bool {\n-    return n.val().out.type() == VMATree::StateType::Released and\n-           n.val().out.mem_tag() == mtNone;\n-  };\n-  for (int i = 0; i < N; i++) {\n-    VMATree::VMATreap::Range r = tree.tree().find_enclosing_range(et.nodes[i]);\n-    ASSERT_TRUE(r.start != nullptr);\n-    Node node = *r.start;\n-    ASSERT_EQ(node.key(), (VMATree::position)et.nodes[i]) << \"at line \" << line_no;\n-    if (i == (N -1)) { \/\/ last node\n-      EXPECT_TRUE(right_released(node)) << \"right-of last node is not Released\";\n-      break;\n-    }\n-    if (i == 0) { \/\/ first node\n-      EXPECT_TRUE(left_released(node)) << \"left-of first node is not Released\";\n-    }\n-    stringStream ss(50);\n-    ss.print(\"test at line: %d, for node: %d\", line_no, et.nodes[i]);\n-    const char* for_this_node = ss.base();\n-    EXPECT_EQ(node.val().out.type(), et.states[i+1]) << for_this_node;\n-    EXPECT_EQ(node.val().out.mem_tag(), et.tags[i+1]) << for_this_node;\n-    if (et.res_si[i+1] >= 0) {\n-      EXPECT_EQ(node.val().out.reserved_stack(), et.res_si[i+1]) << for_this_node;\n-      EXPECT_EQ(r.end->val().in.reserved_stack(), et.res_si[i+1]) << for_this_node;\n-    } else {\n-      EXPECT_FALSE(node.val().out.has_reserved_stack()) << for_this_node;\n-      EXPECT_FALSE(r.end->val().in.has_reserved_stack()) << for_this_node;\n-    }\n-    if (et.com_si[i+1] >= 0) {\n-      EXPECT_EQ(node.val().out.committed_stack(), et.com_si[i+1]) << for_this_node;\n-      EXPECT_EQ(r.end->val().in.committed_stack(), et.com_si[i+1]) << for_this_node;\n-    } else {\n-      EXPECT_FALSE(node.val().out.has_committed_stack()) << for_this_node;\n-      EXPECT_FALSE(r.end->val().in.has_committed_stack()) << for_this_node;\n-    }\n-  }\n-}\n-\n@@ -1954,1 +1986,721 @@\n-}\n\\ No newline at end of file\n+}\n+\n+TEST_VM_F(NMTVMATreeTest, OverlapTableRows0To3) {\n+  using SIndex = NativeCallStackStorage::StackIndex;\n+  using State = VMATree::StateType;\n+  SIndex si_1 = si[0];\n+  SIndex si_2 = si[1];\n+  SIndex si_3 = si[2];\n+\n+  const State Rs = State::Reserved;\n+  const State Rl = State::Released;\n+  const State C = State::Committed;\n+  VMATree::RegionData call_stack_1(si_1, mtTest);\n+  VMATree::RegionData call_stack_1_mtNone(si_1, mtNone);\n+  VMATree::RegionData call_stack_2(si_2, mtTest);\n+  VMATree::RegionData call_stack_2_mtNone(si_2, mtNone);\n+  VMATree::RegionData call_stack_3_mtNone(si_3, mtNone);\n+\n+  \/\/ row  0:  .........A..................B.....\n+  \/\/ case of empty tree is already covered in other tests.\n+  \/\/ row 1 is impossible. See the implementation.\n+  {\n+    \/\/ row  2:  .........A...Y.......................W.....B..........\n+    \/\/          .............100---120---140---160---200......\n+    \/\/                          si1   si2   si1   si2\n+    \/\/ request:          50********************************250\n+    \/\/ post:             50**100***120***140***160***200***250\n+    \/\/                    si2   si1   si2   si1   si2   si2\n+    \/\/                    si2   si2   si2   si2   si2   si2\n+    \/\/ post:             50**100***120***140***160*********250   200 has the same state at its left and right, thus to be removed.\n+    \/\/                    si2   si1   si2   si1     si2\n+    \/\/                    si2   si2   si2   si2     si2\n+    Tree tree;\n+    ExpectedTree<5> pre = {{   100,    120,    140,    160,    200        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , Rs    , Rs    , Rs    , Rl    },\n+                           {-1    , si_1  , si_2  , si_1  , si_2  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(50, 200, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 200);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 100);\n+    ExpectedTree<6> et = {{   50,     100,    120,    140,    160,    250        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                          {Rl    , C     , C     , C     , C     , C     , Rl    },\n+                          {-1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    },\n+                          {-1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row  3:  .........A...Y.......................WB.....\n+    \/\/          .............100---120---140---160---200......\n+    \/\/                          si1   si2   si1   si2\n+    \/\/ request:          50**************************200\n+    \/\/ post:             50**100***120***140***160***200\n+    \/\/                    si2   si1   si2   si1   si2\n+    \/\/                    si2   si2   si2   si2   si2\n+\n+    Tree tree;\n+    ExpectedTree<5> pre = {{   100,    120,    140,    160,    200        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , Rs    , Rs    , Rs    , Rl    },\n+                           {-1    , si_1  , si_2  , si_1  , si_2  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(50, 150, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 150);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 50);\n+    ExpectedTree<6> et = {{   50,     100,    120,    140,    160,    200        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                          {Rl    , C     , C     , C     , C     , C     , Rl    },\n+                          {-1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    },\n+                          {-1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+\n+}\n+\n+TEST_VM_F(NMTVMATreeTest, OverlapTableRows4to7) {\n+  using SIndex = NativeCallStackStorage::StackIndex;\n+  using State = VMATree::StateType;\n+  SIndex si_1 = si[0];\n+  SIndex si_2 = si[1];\n+  SIndex si_3 = si[2];\n+\n+  const State Rs = State::Reserved;\n+  const State Rl = State::Released;\n+  const State C = State::Committed;\n+  VMATree::RegionData call_stack_1(si_1, mtTest);\n+  VMATree::RegionData call_stack_1_mtNone(si_1, mtNone);\n+  VMATree::RegionData call_stack_2(si_2, mtTest);\n+  VMATree::RegionData call_stack_2_mtNone(si_2, mtNone);\n+  VMATree::RegionData call_stack_3_mtNone(si_3, mtNone);\n+\n+  {\n+    \/\/ row  4:  .....X...A..................B.....\n+    \/\/ nodes:   0---10...........................\n+    \/\/ request:          50*****************250\n+    \/\/ post:    0---10...50*****************250\n+    \/\/            si1        si2\n+    \/\/            -          si2\n+    Tree tree;\n+    ExpectedTree<2> pre = {{     0,     10,       },\n+                           {mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    },\n+                           {-1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(50, 200, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 200);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 200);\n+    ExpectedTree<4> et = {{     0,     10,     50,    250        },\n+                          {mtNone, mtTest, mtNone, mtTest, mtNone},\n+                          {Rl    , Rs    , Rl    , C     , Rl    },\n+                          {-1    , si_1  , -1    , si_2  , -1    },\n+                          {-1    , -1    , -1    , si_2  , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row  5:  .....X...A...YW.............B.....\n+    \/\/ nodes:   .....10------70................\n+    \/\/ request:          50*****************250\n+    \/\/ post:    .....10--50**70*************250\n+    \/\/                si1  si1    si2\n+    \/\/                -    si2    si2\n+    Tree tree;\n+    ExpectedTree<2> pre = {{    10,     70,       },\n+                           {mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    },\n+                           {-1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(50, 200, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 200);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 250 - 70);\n+    ExpectedTree<4> et = {{    10,     50,     70,    250        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtNone},\n+                          {Rl    , Rs    , C     , C     , Rl    },\n+                          {-1    , si_1  , si_1  , si_2  , -1    },\n+                          {-1    , -1    , si_2  , si_2  , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row  6:  .....X...A.....Y.......................W.....B...\n+    \/\/ nodes:   0---10.........100---120---140---160---200........\n+    \/\/           si1              si1   si2   si1   si2\n+    \/\/ request:          50**********************************250\n+    \/\/ post:    0---10...50****100***120***140***160***200***250\n+    \/\/            si1       si2   si1   si2   si1   si2   si2\n+    \/\/            -         si2   si2   si2   si2   si2   si2\n+    \/\/ post:    0---10...50****100***120***140***160*********250      ; 200 is noop\n+    \/\/            si1       si2   si1   si2   si1     si2\n+    \/\/            -         si2   si2   si2   si2     si2\n+    Tree tree;\n+    ExpectedTree<7> pre = {{     0,     10,    100,    120,    140,    160,    200        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , Rs    , Rs    , Rs    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_1  , si_2  , si_1  , si_2  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(50, 200, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 200);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 100);\n+    ExpectedTree<8> et = {{     0,     10,     50,    100,    120,    140,    160,    250        },\n+                          {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                          {Rl    , Rs    , Rl    , C     , C     , C     , C     , C     , Rl    },\n+                          {-1    , si_1  , -1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    },\n+                          {-1    , -1    , -1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row  7:  .....X...A...Y.......................WB.....\n+    \/\/ nodes:   0---10.......100---120---140---160---200....\n+    \/\/           si1            si1   si2   si1   si2\n+    \/\/ request:          50**************************200\n+    \/\/ post:    0---10...50****100***120***140***160*200\n+    \/\/            si1       si2   si1   si2   si1   si2\n+    \/\/            -         si2   si2   si2   si2   si2\n+    Tree tree;\n+    ExpectedTree<7> pre = {{     0,     10,    100,    120,    140,    160,    200        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , Rs    , Rs    , Rs    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_1  , si_2  , si_1  , si_2  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(50, 150, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 150);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 50);\n+    ExpectedTree<8> et = {{     0,     10,     50,    100,    120,    140,    160,    200        },\n+                          {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                          {Rl    , Rs    , Rl    , C     , C     , C     , C     , C     , Rl    },\n+                          {-1    , si_1  , -1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    },\n+                          {-1    , -1    , -1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+\n+}\n+\n+TEST_VM_F(NMTVMATreeTest, OverlapTableRows8to11) {\n+  using SIndex = NativeCallStackStorage::StackIndex;\n+  using State = VMATree::StateType;\n+  SIndex si_1 = si[0];\n+  SIndex si_2 = si[1];\n+  SIndex si_3 = si[2];\n+\n+  const State Rs = State::Reserved;\n+  const State Rl = State::Released;\n+  const State C = State::Committed;\n+  VMATree::RegionData call_stack_1(si_1, mtTest);\n+  VMATree::RegionData call_stack_1_mtNone(si_1, mtNone);\n+  VMATree::RegionData call_stack_2(si_2, mtTest);\n+  VMATree::RegionData call_stack_2_mtNone(si_2, mtNone);\n+  VMATree::RegionData call_stack_3_mtNone(si_3, mtNone);\n+  {\n+    \/\/ row  8:  ........XA..................B.....\n+    \/\/ nodes:   0--------50...........................\n+    \/\/            si1\n+    \/\/            -\n+    \/\/ request:          50*****************250\n+    \/\/ post:    0--------50*****************250\n+    \/\/            si1        si2\n+    \/\/            -          si2\n+    Tree tree;\n+    ExpectedTree<2> pre = {{     0,     50,       },\n+                           {mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    },\n+                           {-1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(50, 200, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 200);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 200);\n+    ExpectedTree<3> et = {{     0,     50,    250        },\n+                          {mtNone, mtTest, mtTest, mtNone},\n+                          {Rl    , Rs    , C     , Rl    },\n+                          {-1    , si_1  , si_2  , -1    },\n+                          {-1    , -1    , si_2  , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row  9:  ........XA....YW.............B.....\n+    \/\/ nodes:   ........10----70................\n+    \/\/ request:             50*****************250\n+    \/\/ post:    ........10--50**70*************250\n+    \/\/                    si1  si1    si2\n+    \/\/                    -    si2    si2\n+    Tree tree;\n+    ExpectedTree<2> pre = {{    10,     70,       },\n+                           {mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    },\n+                           {-1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(50, 200, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 200);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 250 - 70);\n+    ExpectedTree<4> et = {{    10,     50,     70,    250        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtNone},\n+                          {Rl    , Rs    , C     , C     , Rl    },\n+                          {-1    , si_1  , si_1  , si_2  , -1    },\n+                          {-1    , -1    , si_2  , si_2  , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 10:  ........XA...Y.......................W.....B...\n+    \/\/ nodes:   ........50---100---120---140---160---200.......\n+    \/\/                    si2   si1   si2   si1   si2\n+    \/\/ request:         50*********************************250\n+    \/\/ post:    ........50***100***120***140***160***200***250\n+    \/\/                    si2   si1   si2   si1   si2   si2\n+    \/\/                    si2   si2   si2   si2   si2   si2\n+    \/\/ post:    ........50***100***120***140***160***200***250        ; 200 is noop\n+    \/\/                    si2   si1   si2   si1   si2   si2\n+    \/\/                    si2   si2   si2   si2   si2   si2\n+    Tree tree;\n+    ExpectedTree<6> pre = {{    50,    100,    120,    140,    160,    200        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , Rs    , Rs    , Rs    , Rs    , Rl    },\n+                           {-1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(50, 200, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 200);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 250 - 200);\n+    ExpectedTree<6> et = {{    50,    100,    120,    140,    160,    250        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                          {Rl    , C     , C     , C     , C     , C     , Rl    },\n+                          {-1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    },\n+                          {-1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 11:  ........XA...Y.......................WB.....\n+    \/\/ nodes:   ........50---100---120---140---160---200....\n+    \/\/                    si2   si1   si2   si1   si2\n+    \/\/ request:         50***************************200\n+    \/\/ post:    ........50***100***120***140***160***200....\n+    \/\/                    si2   si1   si2   si1   si2\n+    \/\/                    si2   si2   si2   si2   si2\n+    Tree tree;\n+    ExpectedTree<6> pre = {{    50,    100,    120,    140,    160,    200        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , Rs    , Rs    , Rs    , Rs    , Rl    },\n+                           {-1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(50, 150, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 150);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 0);\n+    ExpectedTree<6> et = {{    50,    100,    120,    140,    160,    200        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                          {Rl    , C     , C     , C     , C     , C     , Rl    },\n+                          {-1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    },\n+                          {-1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+\n+}\n+\n+TEST_VM_F(NMTVMATreeTest, OverlapTableRows12to15) {\n+  using SIndex = NativeCallStackStorage::StackIndex;\n+  using State = VMATree::StateType;\n+  SIndex si_1 = si[0];\n+  SIndex si_2 = si[1];\n+  SIndex si_3 = si[2];\n+\n+  const State Rs = State::Reserved;\n+  const State Rl = State::Released;\n+  const State C = State::Committed;\n+  VMATree::RegionData call_stack_1(si_1, mtTest);\n+  VMATree::RegionData call_stack_1_mtNone(si_1, mtNone);\n+  VMATree::RegionData call_stack_2(si_2, mtTest);\n+  VMATree::RegionData call_stack_2_mtNone(si_2, mtNone);\n+  VMATree::RegionData call_stack_3_mtNone(si_3, mtNone);\n+\n+  {\n+    \/\/ row 12:  .........A..................B.....U\n+    \/\/ nodes:   ..................................300---400\n+    \/\/ request:          50*****************250\n+    \/\/ post:             50*****************250...300---400\n+    \/\/                          si2\n+    \/\/                          si2\n+    Tree tree;\n+    ExpectedTree<2> pre = {{   300,    400        },\n+                           {mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    },\n+                           {-1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(50, 200, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 200);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 200);\n+    ExpectedTree<4> et = {{    50,    250,    300,    400        },\n+                          {mtNone, mtTest, mtNone, mtTest, mtNone},\n+                          {Rl    , C     , Rl    , Rs    , Rl    },\n+                          {-1    , si_2  , -1    , si_1  , -1    },\n+                          {-1    , si_2  , -1    , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 13:  .........A...YW.............B....U\n+    \/\/ nodes:   .............70------------------300\n+    \/\/ request:          50*****************250\n+    \/\/ post:    .........50**70*************250--300\n+    \/\/                    si2     si1          si1\n+    \/\/                    si2     si2          -\n+    Tree tree;\n+    ExpectedTree<2> pre = {{    70,    300        },\n+                           {mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    },\n+                           {-1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(50, 200, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 200);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 70 - 50);\n+    ExpectedTree<4> et = {{    50,     70,    250,    300        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtNone},\n+                          {Rl    , C     , C     , Rs    , Rl    },\n+                          {-1    , si_2  , si_1  , si_1  , -1    },\n+                          {-1    , si_2  , si_2  , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 14:  .........A...Y.......................W....B....U\n+    \/\/ nodes:   .............100---120---140---160---200.......300---400\n+    \/\/ request:          50*******************************250\n+    \/\/ post:             50***100**120***140***160***200**250..300---400\n+    \/\/                     si2   si1  si2   si1   si2   si2\n+    \/\/                     si2   si2  si2   si2   si2   si2\n+    \/\/ post:             50***100**120***140***160********250..300---400        ; node 200 is noop\n+    \/\/                     si2   si1  si2   si1     si2\n+    \/\/                     si2   si2  si2   si2     si2\n+    Tree tree;\n+    ExpectedTree<7> pre = {{   100,    120,    140,    160,    200,    300,    400        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rs    , Rs    , Rs    , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , si_2  , si_1  , si_2  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(50, 200, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 200);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 100);\n+    ExpectedTree<8> et = {{    50,    100,    120,    140,    160,    250,    300,    400        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                          {Rl    , C     , C     , C     , C     , C     , Rl    , Rs    , Rl    },\n+                          {-1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    , si_1  , -1    },\n+                          {-1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 15:  .........A...Y.......................WB....U\n+    \/\/ nodes:   .............100---120---140---160---200...300---400\n+    \/\/ request:          50**************************200\n+    \/\/ post:             50***100**120***140***160***200...300---400\n+    \/\/                     si2   si1  si2   si1   si2\n+    \/\/                     si2   si2  si2   si2   si2\n+    \/\/ post:             50***100**120***140***160***200...300---400\n+    \/\/                     si2   si1  si2   si1    si2\n+    \/\/                     si2   si2  si2   si2    si2\n+    Tree tree;\n+    ExpectedTree<7> pre = {{   100,    120,    140,    160,    200,    300,    400        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rs    , Rs    , Rs    , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , si_2  , si_1  , si_2  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(50, 150, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 150);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 50);\n+    ExpectedTree<8> et = {{    50,    100,    120,    140,    160,    200,    300,    400        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                          {Rl    , C     , C     , C     , C     , C     , Rl    , Rs    , Rl    },\n+                          {-1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    , si_1  , -1    },\n+                          {-1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+\n+}\n+\n+TEST_VM_F(NMTVMATreeTest, OverlapTableRows16to19) {\n+  using SIndex = NativeCallStackStorage::StackIndex;\n+  using State = VMATree::StateType;\n+  SIndex si_1 = si[0];\n+  SIndex si_2 = si[1];\n+  SIndex si_3 = si[2];\n+\n+  const State Rs = State::Reserved;\n+  const State Rl = State::Released;\n+  const State C = State::Committed;\n+  VMATree::RegionData call_stack_1(si_1, mtTest);\n+  VMATree::RegionData call_stack_1_mtNone(si_1, mtNone);\n+  VMATree::RegionData call_stack_2(si_2, mtTest);\n+  VMATree::RegionData call_stack_2_mtNone(si_2, mtNone);\n+  VMATree::RegionData call_stack_3_mtNone(si_3, mtNone);\n+\n+  {\n+    \/\/ row 16:  .....X...A..................B....U\n+    \/\/ nodes:   0---10...........................300---400\n+    \/\/ request:          50*****************250\n+    \/\/ post:    0---10...50*****************250..300---400\n+    \/\/                          si2\n+    \/\/                          si2\n+    Tree tree;\n+    ExpectedTree<4> pre = {{     0,    10,     300,    400        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(50, 200, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 200);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 200);\n+    ExpectedTree<6> et = {{     0,     10,     50,    250,    300,    400        },\n+                          {mtNone, mtTest, mtNone, mtTest, mtNone, mtTest, mtNone},\n+                          {Rl    , Rs    , Rl    , C     , Rl    , Rs    , Rl    },\n+                          {-1    , si_1  , -1    , si_2  , -1    , si_1  , -1    },\n+                          {-1    , -1    , -1    , si_2  , -1    , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 17:  .....X...A...YW.............B....U\n+    \/\/ nodes:   0----10......70------------------300\n+    \/\/ request:          50*****************250\n+    \/\/ post:    0----10..50**70*************250--300\n+    \/\/                    si2     si1          si1\n+    \/\/                    si2     si2          -\n+    Tree tree;\n+    ExpectedTree<4> pre = {{     0,     10,     70,    300        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(50, 200, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 200);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 70 - 50);\n+    ExpectedTree<6> et = {{     0,     10,     50,     70,    250,    300        },\n+                          {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtNone},\n+                          {Rl    , Rs    , Rl    , C     , C     , Rs    , Rl    },\n+                          {-1    , si_1  , -1    , si_2  , si_1  , si_1  , -1    },\n+                          {-1    , -1    , -1    , si_2  , si_2  , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 18:  ....X....A...Y.......................W....B....U\n+    \/\/ nodes:   0---10.......100---120---140---160---200.......300---400\n+    \/\/                          si2   si1   si2   si1\n+    \/\/ request:          50*******************************250\n+    \/\/ post:    0---10...50***100**120***140***160***200**250..300---400\n+    \/\/                     si2   si2  si1   si2   si1   si2\n+    \/\/                     si2   si2  si2   si2   si2   si2\n+    \/\/ post:    0---10...50********120***140***160***200**250..300---400\n+    \/\/                        si2     si1   si2    si1  si2\n+    \/\/                        si2     si2   si2    si2  si2\n+    Tree tree;\n+    ExpectedTree<9> pre = {{     0,     10,    100,    120,    140,    160,    200,    300,    400        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , Rs    , Rs    , Rs    , Rs    , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_2  , si_1  , si_2  , si_1  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(50, 200, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 200);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 100);\n+    ExpectedTree<10> et = {{     0,     10,     50,    120,    140,    160,    200,   250,    300,    400        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , C     , C     , C     , C     , C     , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 19:  .....X...A...Y.......................WB....U\n+    \/\/ nodes:   0----10......100---120---140---160---200...300---400\n+    \/\/ request:          50**************************200\n+    \/\/ post:    0----10..50***100**120***140***160***200...300---400\n+    \/\/                     si2   si1  si2   si1   si2\n+    \/\/                     si2   si2  si2   si2   si2\n+    Tree tree;\n+    ExpectedTree<9> pre = {{     0,     10,    100,    120,    140,    160,    200,    300,    400        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , Rs    , Rs    , Rs    , Rs    , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_1  , si_2  , si_1  , si_2  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(50, 150, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 150);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 50);\n+    ExpectedTree<10> et = {{     0,     10,     50,    100,    120,    140,    160,    200,    300,    400        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , C     , C     , C     , C     , C     , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+\n+}\n+\n+TEST_VM_F(NMTVMATreeTest, OverlapTableRows19to23) {\n+  using SIndex = NativeCallStackStorage::StackIndex;\n+  using State = VMATree::StateType;\n+  SIndex si_1 = si[0];\n+  SIndex si_2 = si[1];\n+  SIndex si_3 = si[2];\n+\n+  const State Rs = State::Reserved;\n+  const State Rl = State::Released;\n+  const State C = State::Committed;\n+  VMATree::RegionData call_stack_1(si_1, mtTest);\n+  VMATree::RegionData call_stack_1_mtNone(si_1, mtNone);\n+  VMATree::RegionData call_stack_2(si_2, mtTest);\n+  VMATree::RegionData call_stack_2_mtNone(si_2, mtNone);\n+  VMATree::RegionData call_stack_3_mtNone(si_3, mtNone);\n+\n+  {\n+    \/\/ row 20:  ........XA..................B....U\n+    \/\/ nodes:   0-------50.......................300---400\n+    \/\/ request:         50******************250\n+    \/\/ post:    0-------50******************250..300---400\n+    \/\/                          si2\n+    \/\/                          si2\n+    Tree tree;\n+    ExpectedTree<4> pre = {{     0,    50,     300,    400        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(50, 200, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 200);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 200);\n+    ExpectedTree<5> et = {{     0,     50,    250,    300,    400        },\n+                          {mtNone, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                          {Rl    , Rs    , C     , Rl    , Rs    , Rl    },\n+                          {-1    , si_1  , si_2  , -1    , si_1  , -1    },\n+                          {-1    , -1    , si_2  , -1    , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 21:  ........XA...YW.............B....U\n+    \/\/ nodes:   0-------50...70------------------300\n+    \/\/ request:         50******************250\n+    \/\/ post:    0-------50**70**************250--300\n+    \/\/                    si2     si1          si1\n+    \/\/                    si2     si2          -\n+    Tree tree;\n+    ExpectedTree<4> pre = {{     0,     50,     70,    300        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(50, 200, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 200);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 70 - 50);\n+    ExpectedTree<5> et = {{     0,     50,     70,    250,    300        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                          {Rl    , Rs    , C     , C     , Rs    , Rl    },\n+                          {-1    , si_1  , si_2  , si_1  , si_1  , -1    },\n+                          {-1    , -1    , si_2  , si_2  , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 22:  ........XA...Y.......................W....B....U\n+    \/\/ nodes:   0-------50...100---120---140---160---200.......300---400\n+    \/\/                          si2   si1   si2   si1\n+    \/\/ request:         50********************************250\n+    \/\/ post:    0-------50***100***120***140***160***200**250..300---400\n+    \/\/                     si2   si2  si1   si2   si1   si2\n+    \/\/                     si2   si2  si2   si2   si2   si2\n+    \/\/ post:    0-------50*********120***140***160***200**250..300---400\n+    \/\/                        si2     si1   si2    si1  si2\n+    \/\/                        si2     si2   si2    si2  si2\n+    Tree tree;\n+    ExpectedTree<9> pre = {{     0,     50,    100,    120,    140,    160,    200,    300,    400        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , Rs    , Rs    , Rs    , Rs    , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_2  , si_1  , si_2  , si_1  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(50, 200, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 200);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 100);\n+    ExpectedTree<9> et = {{     0,     50,    120,    140,    160,    200,   250,    300,    400        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                          {Rl    , Rs    , C     , C     , C     , C     , C     , Rl    , Rs    , Rl    },\n+                          {-1    , si_1  , si_2  , si_1  , si_2  , si_1  , si_2  , -1    , si_1  , -1    },\n+                          {-1    , -1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 23:  ........XA...Y.......................WB....U\n+    \/\/ nodes:   0-------50...100---120---140---160---200...300---400\n+    \/\/ request:         50***************************200\n+    \/\/ post:    0-------50***100***120***140***160***200...300---400\n+    \/\/                     si2  si1   si2   si1   si2\n+    \/\/                     si2  si2   si2   si2   si2\n+    Tree tree;\n+    ExpectedTree<9> pre = {{     0,     50,    100,    120,    140,    160,    200,    300,    400        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , Rs    , Rs    , Rs    , Rs    , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_1  , si_2  , si_1  , si_2  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(50, 150, call_stack_2, false);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 150);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 50);\n+    ExpectedTree<9> et = {{     0,     50,    100,    120,    140,    160,    200,    300,    400        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                          {Rl    , Rs    , C     , C     , C     , C     , C     , Rl    , Rs    , Rl    },\n+                          {-1    , si_1  , si_2  , si_1  , si_2  , si_1  , si_2  , -1    , si_1  , -1    },\n+                          {-1    , -1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+\n+}\n","filename":"test\/hotspot\/gtest\/nmt\/test_vmatree.cpp","additions":805,"deletions":53,"binary":false,"changes":858,"status":"modified"}]}