{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,2 +46,0 @@\n-\n-private:\n@@ -50,1 +48,0 @@\n-public:\n@@ -56,1 +53,1 @@\n-    return a == invalid;\n+    return a == invalid || a < 0;\n","filename":"src\/hotspot\/share\/nmt\/nmtNativeCallStackStorage.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -89,0 +89,13 @@\n+      \/\/ For NMT reports in detail mode, separate stacks are required for Reserve and Commit operations.\n+      \/\/ So, do not touch the stack of the node since it is for Reserve operation. Instead store the new\n+      \/\/ call-stack in the second_stack of the node.\n+      if ((leqA_n->val().out.mem_tag() != leqA_n->val().in.mem_tag()\n+           || leqA_n->val().out.type() != leqA_n->val().in.type())          \/\/ leqA_n is the start of a reserved region\n+          && !(state == StateType::Reserved && !use_tag_inplace)            \/\/ we are not reserving a new region\n+          && !NativeCallStackStorage::is_invalid(leqA_n->val().out.stack()) \/\/ the primary stack is already filled\n+         ) {\n+        stA.out.set_stack(leqA_n->val().out.stack());\n+        stB.in.set_stack(leqA_n->val().out.stack());\n+        stA.out.set_second_stack(metadata.stack_idx);\n+        stB.in.set_second_stack(metadata.stack_idx);\n+      }\n","filename":"src\/hotspot\/share\/nmt\/vmatree.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -94,1 +94,2 @@\n-    NativeCallStackStorage::StackIndex sidx;\n+    NativeCallStackStorage::StackIndex sidx;       \/\/ call-stack of all operations\n+    NativeCallStackStorage::StackIndex second_idx; \/\/ call-stack when committing\/uncommitting the start-node of a reserved region\n@@ -97,1 +98,1 @@\n-    IntervalState() : type_tag{0,0}, sidx() {}\n+    IntervalState() : type_tag{0,0}, sidx(), second_idx(NativeCallStackStorage::invalid) {}\n@@ -122,1 +123,13 @@\n-     return sidx;\n+      return sidx;\n+    }\n+\n+    NativeCallStackStorage::StackIndex second_stack() const {\n+      return second_idx;\n+    }\n+\n+    void set_stack(NativeCallStackStorage::StackIndex idx) {\n+      sidx = idx;\n+    }\n+\n+    void set_second_stack(NativeCallStackStorage::StackIndex idx) {\n+      second_idx = idx;\n","filename":"src\/hotspot\/share\/nmt\/vmatree.hpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-    si[1] = ncs.push(stacks[0]);\n+    si[1] = ncs.push(stacks[1]);\n@@ -297,1 +297,1 @@\n-  auto expect_equivalent_form = [&](auto& expected, VMATree& tree) {\n+  auto expect_equivalent_form = [&](auto& expected, VMATree& tree, int line_no) {\n@@ -317,2 +317,2 @@\n-      EXPECT_EQ(expect.stack, found.start->val().out.stack());\n-      EXPECT_EQ(expect.stack, found.end->val().in.stack());\n+      EXPECT_EQ(expect.stack, found.start->val().out.stack()) << \"Unexpected stack at test-line: \" << line_no;\n+      EXPECT_EQ(expect.stack, found.end->val().in.stack()) << \"Unexpected stack at test-line: \" << line_no;\n@@ -340,1 +340,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -364,1 +364,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -377,1 +377,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -393,1 +393,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -406,1 +406,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -421,1 +421,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -436,1 +436,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -447,1 +447,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -464,1 +464,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -718,2 +718,13 @@\n-        ASSERT_TRUE(starti.stack.equals(start_stack));\n-        ASSERT_TRUE(endi.stack.equals(end_stack));\n+        \/\/ If start-node of a reserved region is committed, the stack is stored in the second_stack of the node.\n+        if (!NativeCallStackStorage::is_invalid(startn->val().out.second_stack())) {\n+          const NativeCallStack& start_second_stack = ncss.get(startn->val().out.second_stack());\n+          ASSERT_TRUE(starti.stack.equals(start_stack) || starti.stack.equals(start_second_stack));\n+        } else {\n+          ASSERT_TRUE(starti.stack.equals(start_stack));\n+        }\n+        if (!NativeCallStackStorage::is_invalid(endn->val().in.second_stack())) {\n+          const NativeCallStack& end_second_stack = ncss.get(endn->val().in.second_stack());\n+          ASSERT_TRUE(endi.stack.equals(end_stack) || endi.stack.equals(end_second_stack));\n+        } else {\n+          ASSERT_TRUE(endi.stack.equals(end_stack));\n+        }\n@@ -742,0 +753,21 @@\n+}\n+\n+TEST_VM_F(NMTVMATreeTest, SeparateStacksForCommitAndReserve) {\n+  Tree tree;\n+  VMATree::RegionData call_stack_1(si[0], mtTest);\n+  VMATree::RegionData call_stack_2(si[1], mtNone);\n+  tree.reserve_mapping(0, 100, call_stack_1);\n+\n+  tree.commit_mapping(0, 50, call_stack_2, true);\n+  VMATree::VMATreap::Range r = tree.tree().find_enclosing_range(0);\n+  EXPECT_EQ(r.start->val().out.stack(), si[0]);\n+  EXPECT_EQ(r.end->val().in.stack(), si[0]);\n+  EXPECT_EQ(r.start->val().out.second_stack(), si[1]);\n+  EXPECT_EQ(r.end->val().in.second_stack(), si[1]);\n+\n+  tree.uncommit_mapping(0, 30, call_stack_2);\n+  r = tree.tree().find_enclosing_range(0);\n+  EXPECT_EQ(r.start->val().out.stack(), si[0]);\n+  EXPECT_EQ(r.end->val().in.stack(), si[0]);\n+  EXPECT_EQ(r.start->val().out.second_stack(), si[1]);\n+  EXPECT_EQ(r.end->val().in.second_stack(), si[1]);\n","filename":"test\/hotspot\/gtest\/nmt\/test_vmatree.cpp","additions":47,"deletions":15,"binary":false,"changes":62,"status":"modified"}]}