{"files":[{"patch":"@@ -37,0 +37,136 @@\n+NativeCallStackStorage::StackIndex VMATree::new_reserve_callstack(NativeCallStackStorage::StackIndex es, StateType ex, const RequestInfo& req){\n+  using SIndex = NativeCallStackStorage::StackIndex;\n+  const SIndex ES = NativeCallStackStorage::invalid; \/\/ Empty Stack\n+  const SIndex rq = req.callstack;\n+  auto st_to_index = [&](StateType st) -> int {\n+    return\n+      st == StateType::Released ? 0 :\n+      st == StateType::Reserved ? 1 :\n+      st == StateType::Committed ? 2 : -1;\n+  };\n+  const int op = req.op_to_index();\n+  assert(op >= 0 && op < 4, \"should be\");\n+                            \/\/ existing state\n+  SIndex result[4][3] = {\/\/ Rl  Rs   C\n+                           {ES, ES, ES},   \/\/ op == Release\n+                           {rq, rq, rq},   \/\/ op == Reserve\n+                           {es, es, es},   \/\/ op == Commit\n+                           {es, es, es}    \/\/ op == Uncommit\n+                           };\n+  return result[op][st_to_index(ex)];\n+}\n+\n+NativeCallStackStorage::StackIndex VMATree::new_commit_callstack(NativeCallStackStorage::StackIndex es, StateType ex, const RequestInfo& req){\n+  using SIndex = NativeCallStackStorage::StackIndex;\n+  const SIndex ES = NativeCallStackStorage::invalid; \/\/ Empty Stack\n+  const SIndex rq = req.callstack;\n+  auto st_to_index = [&](StateType st) -> int {\n+    return\n+      st == StateType::Released ? 0 :\n+      st == StateType::Reserved ? 1 :\n+      st == StateType::Committed ? 2 : -1;\n+  };\n+  const int op = req.op_to_index();\n+  assert(op >= 0 && op < 4, \"should be\");\n+                            \/\/ existing state\n+  SIndex result[4][3] = {\/\/ Rl  Rs   C\n+                           {ES, ES, ES},   \/\/ op == Release\n+                           {ES, ES, ES},   \/\/ op == Reserve\n+                           {rq, rq, rq},   \/\/ op == Commit\n+                           {ES, ES, ES}    \/\/ op == Uncommit\n+                           };\n+  return result[op][st_to_index(ex)];\n+}\n+\n+VMATree::StateType VMATree::new_state(StateType ex, const RequestInfo& req) {\n+  const StateType Rl = StateType::Released;\n+  const StateType Rs = StateType::Reserved;\n+  const StateType C = StateType::Committed;\n+  auto st_to_index = [&](StateType st) -> int {\n+    return\n+      st == StateType::Released ? 0 :\n+      st == StateType::Reserved ? 1 :\n+      st == StateType::Committed ? 2 : -1;\n+  };\n+  const int op = req.op_to_index();\n+  assert(op >= 0 && op < 4, \"should be\");\n+                            \/\/ existing state\n+  StateType result[4][3] = {\/\/ Rl  Rs   C\n+                              {Rl, Rl, Rl},   \/\/ op == Release\n+                              {Rs, Rs, Rs},   \/\/ op == Reserve\n+                              { C,  C,  C},   \/\/ op == Commit\n+                              {Rl, Rs, Rs}    \/\/ op == Uncommit\n+                           };\n+  return result[op][st_to_index(ex)];\n+}\n+\n+VMATree::SummaryDiff VMATree::register_mapping_new(position A, position B, StateType state,\n+                                               const RegionData& metadata, bool use_tag_inplace) {\n+\n+  assert(A < B, \"should be\");\n+  RequestInfo req{A, B, state, metadata.mem_tag, metadata.stack_idx, use_tag_inplace};\n+  SummaryDiff diff;\n+  VMATreap::Range rA = _tree.find_enclosing_range(A);\n+  VMATreap::Range rB = _tree.find_enclosing_range(B);\n+  bool no_node_before_A = rA.start == nullptr;\n+  bool no_node_before_B = rB.start == nullptr;\n+  bool no_overlap_before = no_node_before_A && no_node_before_B;\n+  bool no_node_after_A = rA.end == nullptr;\n+  bool no_node_after_B = rB.end == nullptr;\n+  bool no_overlap_after = no_node_after_A && no_node_after_B;\n+  bool no_overlap = no_overlap_before || no_overlap_after;\n+  \/\/ ...............X....Y.....Z.............\n+  \/\/   ^--^        ^--------------^  ^----^\n+  \/\/   no-overlap     with-overlap    no-overlap\n+  if (no_overlap) {\n+    \/\/ just insert A and B\n+    return diff;\n+  }\n+  \/\/ finding the X....Y region that overlaps with A---B\n+  \/\/ a--A--b---c---B---d\n+  const position impossible = -1;\n+  position X =   rA.start != nullptr ? rA.start->key()\n+               : rA.end   != nullptr ? rA.end->key()\n+               : rB.start != nullptr ? rB.start->key()\n+               : rB.end   != nullptr ? rB.end->key() : impossible;\n+  assert(X != impossible, \"should not\");\n+  TreapNode* nY = _tree.closest_gt(X);\n+  assert(nY != nullptr, \"should not\");\n+  position Y = nY->key();\n+\n+  enum overlap_case {         \/\/                      ........X..............Y......................\n+                     A_B_X_Y, \/\/ A < B < X < Y           A--B\n+                     A_BX__Y, \/\/ A < B = X < Y           A----B\n+                     A_X_B_Y, \/\/ A < X < B < Y           A--------B\n+                     A_X__BY, \/\/ A < X < Y = B           A-------------------B\n+                     A_X_Y_B, \/\/ A < X < Y < B           A-----------------------B\n+                     AX_B__Y, \/\/ A = X < B < Y                A----B\n+                     AX___BY, \/\/ A = X < B = Y                A--------------B\n+                     AX_Y__B, \/\/ A = X < Y < B                A--------------------B\n+                     X_A_B_Y, \/\/ X < A < B < Y                    A---B\n+                     X_A__BY, \/\/ X < A < B = Y                    A---------B\n+                     X_A_Y_B  \/\/ X < A < Y < B                    A-------------------B\n+  };\n+  overlap_case oc;\n+  if (B < X) oc = A_B_X_Y;\n+  if (B == X) oc = A_BX__Y;\n+  switch(oc) {    \/\/                      ........X..............Y......................\n+    case A_B_X_Y: \/\/ A < B < X < Y           A--B\n+    case A_BX__Y: \/\/ A < B = X < Y           A----B\n+    case A_X_B_Y: \/\/ A < X < B < Y           A--------B\n+    case A_X__BY: \/\/ A < X < Y = B           A-------------------B\n+    case A_X_Y_B: \/\/ A < X < Y < B           A-----------------------B\n+      \/\/ decompose into A--Y and Y--B\n+      \/\/ handle A--Y here and\n+      \/\/ recursive call of the register_mapping(Y, B, ...)\n+      break;\n+    case AX_B__Y: \/\/ A = X < B < Y                A----B\n+    case AX___BY: \/\/ A = X < B = Y                A--------------B\n+    case AX_Y__B: \/\/ A = X < Y < B                A--------------------B\n+    case X_A_B_Y: \/\/ X < A < B < Y                    A---B\n+    case X_A__BY: \/\/ X < A < B = Y                    A---------B\n+    case X_A_Y_B: \/\/ X < A < Y < B                    A-------------------B\n+      break;\n+  }\n+  return diff;\n+}\n","filename":"src\/hotspot\/share\/nmt\/vmatree.cpp","additions":136,"deletions":0,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -197,0 +197,14 @@\n+  struct RequestInfo {\n+    position A,B;\n+    StateType op;\n+    MemTag tag;\n+    NativeCallStackStorage::StackIndex callstack;\n+    bool use_tag_inplace;\n+    int op_to_index() const {\n+      return\n+            op == StateType::Released ? 0 :\n+            op == StateType::Reserved && !use_tag_inplace ? 1 :\n+            op == StateType::Committed ? 2 :\n+            op == StateType::Reserved && use_tag_inplace ? 3 : -1;\n+    }\n+  };\n@@ -229,0 +243,4 @@\n+  SummaryDiff register_mapping_new(position A, position B, StateType state, const RegionData& metadata, bool use_tag_inplace = false);\n+  StateType new_state(StateType existinting_state, const RequestInfo& req);\n+  NativeCallStackStorage::StackIndex new_reserve_callstack(NativeCallStackStorage::StackIndex existinting_stack, StateType ex, const RequestInfo& req);\n+  NativeCallStackStorage::StackIndex new_commit_callstack(NativeCallStackStorage::StackIndex existinting_stack, StateType ex, const RequestInfo& req);\n","filename":"src\/hotspot\/share\/nmt\/vmatree.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1921,1 +1921,1 @@\n-    tree.release_mapping(50, 650);\n+    tree.release_mapping(0, 700);\n@@ -1934,7 +1934,4 @@\n-    \/\/ Skipped until JDK-8354115 is integrated\n-    if (ok_to_run) {\n-      check_tree(tree, et, __LINE__);\n-      VMATree::VMATreap::Range r = tree.tree().find_enclosing_range(0);\n-      EXPECT_EQ(r.start, nullptr);  \/\/ make sure 0 is removed\n-      EXPECT_EQ((int)r.end->key(), 700);\n-    }\n+    check_tree(tree, et, __LINE__);\n+    VMATree::VMATreap::Range r = tree.tree().find_enclosing_range(0);\n+    EXPECT_EQ(r.start, nullptr);  \/\/ make sure 0 is removed\n+    EXPECT_EQ((int)r.end->key(), 700);\n","filename":"test\/hotspot\/gtest\/nmt\/test_vmatree.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"}]}